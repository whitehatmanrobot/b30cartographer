  
                    FreeWorkGroup(workGroup);
                }
            }
            else {
                result = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI EjectNtmsMedia(HANDLE hSession,
                            LPNTMS_GUID lpMediaId,
                            LPNTMS_GUID lpEjectOperation,
                            DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        PHYSICAL_MEDIA *physMedia;

        physMedia = FindPhysicalMedia(lpMediaId);
        if (physMedia){
            MEDIA_POOL *mediaPool;
            LIBRARY *lib;

            /*
             *  Get the library for this media.
             */
            LockPhysicalMediaWithLibrary(physMedia);
            mediaPool = physMedia->owningMediaPool;
            lib = mediaPool ? mediaPool->owningLibrary : NULL;
            if (lib){
                RefObject(lib);
            }
            UnlockPhysicalMediaWithLibrary(physMedia);

            if (lib){
                WORKITEM *workItem;
                
                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem for the eject.
                     */
                    BuildEjectWorkItem(workItem, physMedia, lpEjectOperation, dwAction);
                    
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     *  Then wait for the workItem to complete.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     *  Also get result parameters (eject guid is returned
                     *  when dwAction = NTMS_EJECT_START).
                     */
                    result = workItem->currentOp.resultStatus;    
                    *lpEjectOperation = workItem->currentOp.guidArg;

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }

                DerefObject(lib);
            }
            else {
                result = ERROR_DATABASE_FAILURE;
            }

            DerefObject(physMedia);
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}



DWORD WINAPI InjectNtmsMedia(   HANDLE hSession,
                                LPNTMS_GUID lpLibraryId,
                                LPNTMS_GUID lpInjectOperation,
                                DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            if (lib->state == LIBSTATE_ONLINE){
                WORKITEM *workItem;
                    
                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem for the inject.
                     */
                    BuildInjectWorkItem(workItem, lpInjectOperation, dwAction);
                   
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     *  Then wait for the workItem to complete.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     */
                    result = workItem->currentOp.resultStatus;    
                    *lpInjectOperation = workItem->currentOp.guidArg;

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                result = ERROR_LIBRARY_OFFLINE;
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

     
DWORD WINAPI AccessNtmsLibraryDoor( HANDLE hSession,
                                    LPNTMS_GUID lpLibraryId,
                                    DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            if (lib->state == LIBSTATE_ONLINE){
                WORKITEM *workItem;
                    
                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem for the door unlock.
                     */
                    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                    workItem->currentOp.opcode = NTMS_LM_DOORACCESS;
                    workItem->currentOp.options = dwAction;
                    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                   
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    /*
                     *  Wait for the request to be processed by the library thread.
                     *  Note:  If the library is busy, the workItem will be completed 
                     *        immediately and the door will be unlocked later.
                     */
                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     */
                    result = workItem->currentOp.resultStatus;    

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                result = ERROR_LIBRARY_OFFLINE;
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI CleanNtmsDrive(HANDLE hSession, LPNTMS_GUID lpDriveId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        DRIVE *drive;

        drive = FindDrive(lpDriveId);
        if (drive){
            WORKITEM *workItem;

            ASSERT(drive->lib);
                    
            workItem = DequeueFreeWorkItem(drive->lib, TRUE);
            if (workItem){
                /*
                 *  Build the workItem to clean the drive.
                 *  Reference every object pointed to by the workItem.
                 */
                RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                workItem->currentOp.opcode = NTMS_LM_CLEANDRIVE;
                workItem->currentOp.drive = drive;
                workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                RefObject(drive);
                
                /*
                 *  Give this workItem to the library and wake up the library thread.
                 */
                EnqueuePendingWorkItem(workItem->owningLib, workItem);

                /*
                 *  Wait for the request to be processed by the library thread.
                 */
                WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                /*
                 *  Get result from the completed workItem.
                 */
                result = workItem->currentOp.resultStatus;    

                EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
            }
            else {
                result = ERROR_NOT_ENOUGH_MEMORY;
            }

            DerefObject(drive);
        }
        else {
            result = ERROR_INVALID_DRIVE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DismountNtmsDrive(HANDLE hSession, LPNTMS_GUID lpDriveId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        DRIVE *drive;

        drive = FindDrive(lpDriveId);
        if (drive){
            WORKITEM *workItem;
               
            workItem = DequeueFreeWorkItem(drive->lib, TRUE);
            if (workItem){
                /*
                 *  Build the workItem to dismount.
                 *  Reference every object pointed to by the workItem.
                 */
                RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                workItem->currentOp.opcode = NTMS_LM_DISMOUNT;
                workItem->currentOp.drive = drive;
                workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                RefObject(drive);
                
                /*
                 *  Give this workItem to the library and wake up the library thread.
                 */
                EnqueuePendingWorkItem(workItem->owningLib, workItem);

                /*
                 *  Wait for the request to be processed by the library thread.
                 */
                WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                /*
                 *  Get result from the completed workItem.
                 */
                result = workItem->currentOp.resultStatus;    

                EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
            }
            else {
                result = ERROR_NOT_ENOUGH_MEMORY;
            }

            DerefObject(drive);
        }
        else {
            result = ERROR_INVALID_DRIVE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI InventoryNtmsLibrary(  HANDLE hSession,
                                    LPNTMS_GUID lpLibraryId,
                                    DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            if (lib->state == LIBSTATE_ONLINE){
                WORKITEM *workItem;
                    
                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem for the inventory.
                     */
                    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                    workItem->currentOp.opcode = NTMS_LM_INVENTORY;
                    workItem->currentOp.options = dwAction;
                    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                   
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    /*
                     *  Wait for the request to be processed by the library thread.
                     *  Note:  If the library is busy, the workItem will be completed 
                     *        immediately and the inventory will happen later.
                     */
                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     */
                    result = workItem->currentOp.resultStatus;    

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                result = ERROR_LIBRARY_OFFLINE;
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
        

DWORD WINAPI UpdateNtmsOmidInfo(    HANDLE hSession,
                                    LPNTMS_GUID lpLogicalMediaId,
                                    DWORD labelType,
                                    DWORD numberOfBytes,
                                    LPVOID lpBuffer)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_PARTITION *mediaPart;

        mediaPart = FindMediaPartition(lpLogicalMediaId);
        if (mediaPart){
            MEDIA_POOL *mediaPool;
            LIBRARY *lib;
            
            ASSERT(mediaPart->owningPhysicalMedia);

            /*
             *  Get the library for this media.
             */
            LockPhysicalMediaWithLibrary(mediaPart->owningPhysicalMedia);
            mediaPool = mediaPart->owningPhysicalMedia->owningMediaPool;
            lib = mediaPool ? mediaPool->owningLibrary : NULL;
            if (lib){
                RefObject(lib);
            }
            UnlockPhysicalMediaWithLibrary(mediaPart->owningPhysicalMedia);

            if (lib){
                WORKITEM *workItem;
                    
                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem.
                     */
                    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                    workItem->currentOp.opcode = NTMS_LM_UPDATEOMID;
                    workItem->currentOp.options = labelType;
                    workItem->currentOp.buf = lpBuffer;
                    workItem->currentOp.bufLen = numberOfBytes;
                    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                   
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    /*
                     *  Wait for the request to be processed by the library thread.
                     */
                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     */
                    result = workItem->currentOp.resultStatus;    

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }

                DerefObject(lib);
            }
            else {
                result = ERROR_DATABASE_FAILURE;             
            }

            DerefObject(mediaPart);
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
     
   
DWORD WINAPI CancelNtmsLibraryRequest(HANDLE hSession, LPNTMS_GUID lpRequestId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        WORKITEM *workItem = NULL;
        LIST_ENTRY *listEntry;
        
        /*
         *  Go through every library and find the workItem to cancel.
         *  This is HUGELY INEFFICIENT but this is a rare call.
         *  This is better than putting every request into the database.
         *
         *  BUGBUG - this only cancels workItems that are still pending.
         *            what about workItems currently being processed ?
         */
        EnterCriticalSection(&g_globalServiceLock);
        listEntry = &g_allLibrariesList;
        while ((listEntry = listEntry->Flink) != &g_allLibrariesList){
            LIBRARY *lib = CONTAINING_RECORD(listEntry, LIBRARY, allLibrariesListEntry);
            workItem = DequeuePendingWorkItemByGuid(lib, lpRequestId);
            if (workItem){
                break;
            }
        }
        LeaveCriticalSection(&g_globalServiceLock);

        if (workItem){
            /*
             *  Found the workItem to cancel.
             *  Dereference any objects pointed to by the workItem
             *  and put it back in the free list.
             */
            FlushWorkItem(workItem);
            EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
            result = ERROR_SUCCESS;            
        }
        else {
            result = ERROR_OBJECT_NOT_FOUND;
        }       
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI ReserveNtmsCleanerSlot(    HANDLE hSession,
                                        LPNTMS_GUID lpLibraryId,
                                        LPNTMS_GUID lpSlotId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            SLOT *slot;

            slot = FindLibrarySlot(lib, lpSlotId);
            if (slot){
                /*
                 *  To be reserved as the cleaner slot, the slot must
                 *  be empty and the library must have no cleaner slot reserved.
                 *  Redundant calls to reserve the same cleaner slot fail.
                 */
                EnterCriticalSection(&lib->lock); 
                if (lib->cleanerSlotIndex == NO_SLOT_INDEX){
                    ASSERT(!slot->isCleanerSlot);
                    if (slot->insertedMedia){
                        result = ERROR_RESOURCE_NOT_AVAILABLE; // BUGBUG ERROR_SLOT_FULL; not defined
                    }
                    else {
                        lib->cleanerSlotIndex = slot->slotIndex;
                        slot->isCleanerSlot = TRUE;
                        result = ERROR_SUCCESS;
                    }
                }
                else {
                    result = ERROR_CLEANER_SLOT_SET;
                }
                LeaveCriticalSection(&lib->lock); 

                DerefObject(slot);
            }
            else {
                result = ERROR_INVALID_HANDLE; // BUGBUG ERROR_INVALID_SLOT not defined
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
        

DWORD WINAPI ReleaseNtmsCleanerSlot(HANDLE hSession, LPNTMS_GUID lpLibraryId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            if (lib->cleanerSlotIndex == NO_SLOT_INDEX){
                /*
                 *  There is no cleaner slot configured.
                 */
                result = ERROR_CLEANER_SLOT_NOT_SET;   
            }
            else {
                SLOT *slot;

                ASSERT(lib->cleanerSlotIndex < lib->numSlots);
                slot = &lib->slots[lib->cleanerSlotIndex];
                ASSERT(slot->isCleanerSlot);
                
                if (slot->insertedMedia){
                    result = ERROR_RESOURCE_NOT_AVAILABLE; // BUGBUG ERROR_SLOT_FULL; not defined
                }
                else {
                    slot->isCleanerSlot = FALSE;
                    lib->cleanerSlotIndex = NO_SLOT_INDEX;
                    result = ERROR_SUCCESS;
                }     
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI InjectNtmsCleaner( HANDLE hSession,
                                LPNTMS_GUID lpLibraryId,
                                LPNTMS_GUID lpInjectOperation,
                                DWORD dwNumberOfCleansLeft,
                                DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){
            
            EnterCriticalSection(&lib->lock);

            /*
             *  The library must have a designated cleaner slot index reserved
             *  in order to receive the cleaner.
             *
             *  BUGBUG - move all these checks to the lib thread.
             */           
            if (lib->cleanerSlotIndex == NO_SLOT_INDEX){
                result = ERROR_CLEANER_SLOT_NOT_SET;
            }
            else {
                SLOT *slot = &lib->slots[lib->cleanerSlotIndex];
                ASSERT(lib->cleanerSlotIndex < lib->numSlots);
                ASSERT(slot->isCleanerSlot);
                if (slot->insertedMedia){
                    result = ERROR_RESOURCE_NOT_AVAILABLE; // BUGBUG ERROR_SLOT_FULL; not defined
                }
                else {

                    if (dwAction == NTMS_INJECT_START){
                        WORKITEM *workItem;

                        workItem = DequeueFreeWorkItem(lib, TRUE);
                        if (workItem){
                            /*
                             *  Build the workItem.
                             */
                            RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                            workItem->currentOp.opcode = NTMS_LM_INJECTCLEANER;
                            workItem->currentOp.lParam = dwNumberOfCleansLeft;
                            workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                           
                            /*
                             *  Give this workItem to the library and wake up the library thread.
                             */
                            EnqueuePendingWorkItem(workItem->owningLib, workItem);

                            /*
                             *  When we enqueued the workItem in the pending queue,
                             *  it got assigned a requestGuid.  Since we're holding the
                             *  library lock, that workItem hasn't gone anywhere yet.
                             *  So its ok to read out the requestGuid from the workItem.
                             */
                            *lpInjectOperation = workItem->currentOp.requestGuid; 

                            /*
                             *  Wait for the request to be processed by the library thread.
                             *  Note:  The workItem will complete as soon as the library thread
                             *         starts the injection.  The app may cancel the cleaner
                             *         injection using NTMS_INJECT_STOP and the returned GUID.
                             *  BUGBUG ?
                             */
                            WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                            /*
                             *  Get result from the completed workItem.
                             */
                            result = workItem->currentOp.resultStatus;    

                            EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                        }
                        else {
                            result = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                    else if (dwAction == NTMS_INJECT_STOP){
                        result = StopCleanerInjection(lib, lpInjectOperation);
                    }
                    else {
                        result = ERROR_INVALID_PARAMETER;
                    }
                }
            }
                
            LeaveCriticalSection(&lib->lock);
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI EjectNtmsCleaner(  HANDLE hSession,
                                LPNTMS_GUID lpLibraryId,
                                LPNTMS_GUID lpEjectOperation,
                                DWORD dwAction)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){

            EnterCriticalSection(&lib->lock);
            
            if (dwAction == NTMS_EJECT_START){
                WORKITEM *workItem;

                workItem = DequeueFreeWorkItem(lib, TRUE);
                if (workItem){
                    /*
                     *  Build the workItem.
                     */
                    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
                    workItem->currentOp.opcode = NTMS_LM_EJECTCLEANER;
                    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
                           
                    /*
                     *  Give this workItem to the library and wake up the library thread.
                     */
                    EnqueuePendingWorkItem(workItem->owningLib, workItem);

                    /*
                     *  When we enqueued the workItem in the pending queue,
                     *  it got assigned a requestGuid.  Since we're holding the
                     *  library lock, that workItem hasn't gone anywhere yet.
                     *  So its ok to read out the requestGuid from the workItem.
                     */
                    *lpEjectOperation = workItem->currentOp.requestGuid; 

                    /*
                     *  Wait for the request to be processed by the library thread.
                     *  Note:  The workItem will complete as soon as the library thread
                     *         starts the ejection.  The app may cancel the cleaner
                     *         ejection using NTMS_EJECT_STOP and the returned GUID.
                     *  BUGBUG ?
                     */
                    WaitForSingleObject(workItem->workItemCompleteEvent, INFINITE);

                    /*
                     *  Get result from the completed workItem.
                     */
                    result = workItem->currentOp.resultStatus;    

                    EnqueueFreeWorkItem(workItem->owningLib, workItem);                     
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else if (dwAction == NTMS_EJECT_STOP){
                result = StopCleanerEjection(lib, lpEjectOperation);
            }
            else {
                result = ERROR_INVALID_PARAMETER;
            }

            LeaveCriticalSection(&lib->lock);

            DerefObject(lib);                          
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}        


DWORD WINAPI DeleteNtmsLibrary(HANDLE hSession, LPNTMS_GUID lpLibraryId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibraryId);
        if (lib){

            result = DeleteLibrary(lib);
            
            /*
             *  Dereference the library due to the reference that happened
             *  when we called FindLibrary.  The library will get deleted
             *  once all references go away.
             */
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DeleteNtmsDrive(HANDLE hSession, LPNTMS_GUID lpDriveId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        DRIVE *drive;

        drive = FindDrive(lpDriveId);
        if (drive){
            
            result = DeleteDrive(drive);

            /*
             *  Dereference the drive due to the reference that happened
             *  when we called FindDrive.  The drive will get deleted
             *  once all references go away.
             */
            DerefObject(drive);
        }
        else {
            result = ERROR_INVALID_DRIVE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI GetNtmsRequestOrder(   HANDLE hSession,
                                    LPNTMS_GUID lpRequestId,
                                    LPDWORD lpdwOrderNumber)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        if (lpRequestId){
            LIST_ENTRY *listEntry;
            
            result = ERROR_INVALID_HANDLE;
            *lpdwOrderNumber = 0;

            EnterCriticalSection(&g_globalServiceLock);
            
            /*
             *  Go through every library and find the pending workItem.
             *  This is HUGELY INEFFICIENT but this is a rare call.
             *  This is better than putting every request into the database.
             */            
            listEntry = &g_allLibrariesList;
            while ((listEntry = listEntry->Flink) != &g_allLibrariesList){
                LIBRARY *lib = CONTAINING_RECORD(listEntry, LIBRARY, allLibrariesListEntry);
                LIST_ENTRY *listEntry2;
                ULONG requestOrder = 1;

                EnterCriticalSection(&lib->lock);
                
                listEntry2 = &lib->pendingWorkItemsList;
                while ((listEntry2 = listEntry2->Flink) != &lib->pendingWorkItemsList){
                    WORKITEM *workItem = CONTAINING_RECORD(listEntry2, WORKITEM, libListEntry);
                    if (RtlEqualMemory(&workItem->currentOp.requestGuid, lpRequestId, sizeof(NTMS_GUID))){
                        *lpdwOrderNumber = requestOrder;
                        result = ERROR_SUCCESS;
                        break;
                    }
                    else {
                        requestOrder++;
                    }
                }

                LeaveCriticalSection(&lib->lock);
                
                if (result == ERROR_SUCCESS){
                    break;
                }
            }
            
            LeaveCriticalSection(&g_globalServiceLock);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsRequestOrder(   HANDLE hSession,
                                    LPNTMS_GUID lpRequestId,
                                    DWORD dwOrderNumber)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI DeleteNtmsRequests(HANDLE hSession,
                                LPNTMS_GUID lpRequestId,
                                DWORD dwType,
                                DWORD dwCount)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI BeginNtmsDeviceChangeDetection(HANDLE hSession, LPHANDLE lpDetectHandle)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
 
       
DWORD WINAPI SetNtmsDeviceChangeDetection(  HANDLE hSession,
                                            HANDLE DetectHandle,
                                            LPNTMS_GUID lpRequestId,
                                            DWORD dwType,
                                            DWORD dwCount)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI EndNtmsDeviceChangeDetection(HANDLE hSession, HANDLE DetectHandle)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}






/******** BUGBUG: INtmsObjectManagement1 APIs *********************/

DWORD WINAPI GetNtmsObjectSecurity(     HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        DWORD dwType,
                                        SECURITY_INFORMATION RequestedInformation,
                                        PSECURITY_DESCRIPTOR lpSecurityDescriptor,
                                        DWORD nLength,
                                        LPDWORD lpnLengthNeeded)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsObjectSecurity(     HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        DWORD dwType,
                                        SECURITY_INFORMATION SecurityInformation,
                                        PSECURITY_DESCRIPTOR lpSecurityDescriptor)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}
        

DWORD WINAPI GetNtmsObjectAttributeW(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCWSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            LPDWORD lpAttributeSize)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetNtmsObjectAttributeA(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            LPDWORD lpAttributeSize)
{
    HRESULT result;
    WCHAR wAttributeName[NTMS_OBJECTNAME_LENGTH];

    AsciiToWChar(wAttributeName, lpAttributeName, NTMS_OBJECTNAME_LENGTH);
    result = GetNtmsObjectAttributeW(   hSession,
                                        lpObjectId,
                                        dwType,
                                        wAttributeName,
                                        lpAttributeData,
                                        lpAttributeSize);
    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsObjectAttributeA(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            DWORD dwAttributeSize)
{
    HRESULT result;
    WCHAR wAttributeName[NTMS_OBJECTNAME_LENGTH];

    AsciiToWChar(wAttributeName, lpAttributeName, NTMS_OBJECTNAME_LENGTH);
    result = SetNtmsObjectAttributeW(   hSession,
                                        lpObjectId,
                                        dwType,
                                        wAttributeName,
                                        lpAttributeData,
                                        dwAttributeSize);
    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsObjectAttributeW(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCWSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            DWORD AttributeSize)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI EnumerateNtmsObject(   HANDLE hSession,
                                    const LPNTMS_GUID lpContainerId,
                                    LPNTMS_GUID lpList,
                                    LPDWORD lpdwListSize,
                                    DWORD dwType,
                                    DWORD dwOptions)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI EnableNtmsObject(HANDLE hSession, DWORD dwType, LPNTMS_GUID lpObjectId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI DisableNtmsObject(HANDLE hSession, DWORD dwType, LPNTMS_GUID lpObjectId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}




/******* BUGBUG: INtmsObjectInfo1 APIs  ****************************/

                    // BUGBUG - these 4 functions have another form with type,size as last args


HRESULT WINAPI GetNtmsServerObjectInformationW( HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONW lpInfo,
                                                int revision)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


HRESULT WINAPI GetNtmsServerObjectInformationA( HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONA lpInfo,
                                                int revision)
{
    HRESULT result;

    if (lpInfo){
        NTMS_OBJECTINFORMATIONW wObjInfo;

        ConvertObjectInfoAToWChar(&wObjInfo, lpInfo);
        result = GetNtmsServerObjectInformationW(hSession, lpObjectId, &wObjInfo, revision);
    }
    else {
        result = ERROR_INVALID_PARAMETER;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


HRESULT WINAPI SetNtmsServerObjectInformationW( HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONW lpInfo,
                                                int revision)\
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


HRESULT WINAPI SetNtmsServerObjectInformationA( HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONA lpInfo,
                                                int revision)
{
    HRESULT result;

    if (lpObjectId && lpInfo){
        NTMS_OBJECTINFORMATIONW wObjInfo;

        ConvertObjectInfoAToWChar(&wObjInfo, lpInfo);
        result = SetNtmsServerObjectInformationW(hSession, lpObjectId, &wObjInfo, revision);
    }
    else {
        result = ERROR_INVALID_PARAMETER;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI CreateNtmsMediaA(      HANDLE hSession,
                                    LPNTMS_OBJECTINFORMATIONA lpMedia,
                                    LPNTMS_OBJECTINFORMATIONA lpList,
                                    DWORD dwOptions)
{
    HRESULT result;

    if (lpMedia && lpList){
        NTMS_OBJECTINFORMATIONW wObjInfoMedia, wObjInfoList;

        ConvertObjectInfoAToWChar(&wObjInfoMedia, lpMedia);
        ConvertObjectInfoAToWChar(&wObjInfoList, lpList);
        result = CreateNtmsMediaW(hSession, &wObjInfoMedia, &wObjInfoList, dwOptions);
    }
    else {
        result = ERROR_INVALID_PARAMETER;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI CreateNtmsMediaW(      HANDLE hSession,
                                    LPNTMS_OBJECTINFORMATIONW lpMedia,
                                    LPNTMS_OBJECTINFORMATIONW lpList,
                                    DWORD dwOptions)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}



DWORD WINAPI GetNtmsObjectInformationA( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONA lpInfo)
{
    HRESULT result;

    if (lpInfo){
        NTMS_OBJECTINFORMATIONW wObjInfo;

        ConvertObjectInfoAToWChar(&wObjInfo, lpInfo);
        result = GetNtmsObjectInformationW(hSession, lpObjectId, &wObjInfo);
    }
    else {
        result = ERROR_INVALID_PARAMETER;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetNtmsObjectInformationW( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONW lpInfo)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        if (lpObjectId && lpInfo){

            // BUGBUG FINISH

            result = ERROR_SUCCESS;
        }
        else {
            result = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsObjectInformationA( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONA lpInfo)
{
    HRESULT result;

    if (lpInfo){
        NTMS_OBJECTINFORMATIONW wObjInfo;

        ConvertObjectInfoAToWChar(&wObjInfo, lpInfo);
        result = SetNtmsObjectInformationW(hSession, lpObjectId, &wObjInfo);
    }
    else {
        result = ERROR_INVALID_PARAMETER;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsObjectInformationW( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONW lpInfo)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        if (lpObjectId && lpInfo){

            // BUGBUG FINISH
            result = ERROR_SUCCESS;
        }
        else {
            result = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


HANDLE WINAPI OpenNtmsNotification(HANDLE hSession, DWORD dwType)
{
    HANDLE hNotify;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH
        hNotify = NULL;
    }
    else {
        SetLastError(ERROR_INVALID_HANDLE);
        hNotify = NULL;
    }

    return hNotify;
}


DWORD WINAPI WaitForNtmsNotification(   HANDLE hNotification,
                                        LPNTMS_NOTIFICATIONINFORMATION lpNotificationInformation,
                                        DWORD dwTimeout)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI CloseNtmsNotification(HANDLE hNotification)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}



DWORD WINAPI EjectDiskFromSADriveA( LPCSTR lpComputerName,
                                    LPCSTR lpAppName,
                                    LPCSTR lpDeviceName,
                                    HWND hWnd,
                                    LPCSTR lpTitle,
                                    LPCSTR lpMessage,
                                    DWORD dwOptions)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI EjectDiskFromSADriveW( LPCWSTR lpComputerName,
                                    LPCWSTR lpAppName,
                                    LPCWSTR lpDeviceName,
                                    HWND hWnd,
                                    LPCWSTR lpTitle,
                                    LPCWSTR lpMessage,
                                    DWORD dwOptions)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetVolumesFromDriveA(  LPSTR pszDriveName,
                                    LPSTR* VolumeNameBufferPtr,
                                    LPSTR* DriveLetterBufferPtr)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetVolumesFromDriveW(  LPWSTR pszDriveName,
                                    LPWSTR *VolumeNameBufferPtr,
                                    LPWSTR *DriveLetterBufferPtr)
{
    HRESULT result;

    // BUGBUG FINISH
    result = ERROR_SUCCESS;

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI IdentifyNtmsSlot(HANDLE hSession, LPNTMS_GUID lpSlotId, DWORD dwOption)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetNtmsUIOptionsA( HANDLE hSession,
                                const LPNTMS_GUID lpObjectId,
                                DWORD dwType,
                                LPSTR lpszDestination,
                                LPDWORD lpAttributeSize)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetNtmsUIOptionsW( HANDLE hSession,
                                const LPNTMS_GUID lpObjectId,
                                DWORD dwType,
                                LPWSTR lpszDestination,
                                LPDWORD lpdwSize)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsUIOptionsA( HANDLE hSession,
                                const LPNTMS_GUID lpObjectId,
                                DWORD dwType,
                                DWORD dwOperation,
                                LPCSTR lpszDestination)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI SetNtmsUIOptionsW( HANDLE hSession,
                                const LPNTMS_GUID lpObjectId,
                                DWORD dwType,
                                DWORD dwOperation,
                                LPCWSTR lpszDestination)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\session.c ===
/*
 *  SESSION.C
 *
 *      RSM Service :  Sessions
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


SESSION *NewSession(LPCWSTR lpServer, 
                    LPCWSTR lpApplication,
                    LPCWSTR lpClientName,
                    LPCWSTR lpUserName)
{
    SESSION *newSession;

    newSession = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SESSION));
    if (newSession){

        newSession->sig = SESSION_SIG;

        InitializeCriticalSection(&newSession->lock);
        InitializeListHead(&newSession->operatorRequestList);
        InitializeListHead(&newSession->allSessionsListEntry);

        WStrNCpy(newSession->serverName, lpServer, NTMS_COMPUTERNAME_LENGTH);
        WStrNCpy(newSession->applicationName, lpApplication, NTMS_APPLICATIONNAME_LENGTH);
        WStrNCpy(newSession->clientName, lpClientName, NTMS_COMPUTERNAME_LENGTH);
        WStrNCpy(newSession->userName, lpUserName, NTMS_USERNAME_LENGTH);

        EnterCriticalSection(&g_globalServiceLock);
        InsertTailList(&g_allSessionsList, &newSession->allSessionsListEntry);
        LeaveCriticalSection(&g_globalServiceLock);
    }
    else {
        ASSERT(newSession);
    }

    return newSession;
}


VOID FreeSession(SESSION *thisSession)
{
    // BUGBUG FINISH - clean up mounts, etc.

    ASSERT(IsEmptyList(&s->operatorRequestList));

    /*
     *  Dequeue the session
     */
    EnterCriticalSection(&g_globalServiceLock);
    ASSERT(!IsEmptyList(&thisSession->allSessionsListEntry));
    ASSERT(!IsEmptyList(&g_allSessionsList));
    RemoveEntryList(&thisSession->allSessionsListEntry);
    InitializeListHead(&thisSession->allSessionsListEntry);
    LeaveCriticalSection(&g_globalServiceLock);

    DeleteCriticalSection(&thisSession->lock);
    
    GlobalFree(thisSession);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\util.c ===
/*
 *  UTIL.C
 *
 *      RSM Service :  Utilities
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"




/*
 *  WStrNCpy
 *
 *      Like wcsncpy, but terminates the string if truncated.
 *      Also, tolerates NULL src string.
 */
ULONG WStrNCpy(WCHAR *dest, const WCHAR *src, ULONG maxWChars)
{
    ULONG wCharsWritten = 0;

    ASSERT(dest);

    if (src){
        while ((maxWChars-- > 1) && (*dest++ = *src++)){
            wCharsWritten++;
        }
        if (maxWChars == 1){
            *dest = (WCHAR)NULL;
            wCharsWritten++;
        }
    }
    else {
        *dest = (WCHAR)NULL;
        wCharsWritten++;
    }

    return wCharsWritten;
}


/*
 *  AsciiToWChar
 *
 *      Like mbstowcs, but terminates the string if truncated.
 *      Also, tolerates NULL ascii string.
 */
ULONG AsciiToWChar(WCHAR *dest, const char *src, ULONG maxChars)
{
    ULONG charsWritten = 0;

    if (src){
        while ((maxChars-- > 1) && (*dest++ = (WCHAR)*src++)){
            charsWritten++;
        }
        if (maxChars == 1){
            *dest = (WCHAR)NULL;
            charsWritten++;
        }
    }
    else {
        *dest = (WCHAR)NULL;
        charsWritten++;
    }

    return charsWritten;
}


/*
 *  WCharToAscii
 *
 *      Reverse of AsciiToWChar.
 *      Terminates the string if truncated.
 *      Also, tolerates NULL wchar string.
 */
ULONG WCharToAscii(char *dest, WCHAR *src, ULONG maxChars)
{
    ULONG charsWritten = 0;

    if (src){
        while ((maxChars-- > 1) && (*dest++ = (char)(unsigned char)*src++)){
            charsWritten++;
        }
        if (maxChars == 1){
            *dest = (char)NULL;
            charsWritten++;
        }
    }
    else {
        *dest = (char)NULL;
        charsWritten++;
    }

    return charsWritten;
}


/*
 *  WStringsEqual
 *
 *      Like RtlEqualString (but ntrtl.h doesn't compile with our other headers).
 */
BOOL WStringsEqualN(PWCHAR s, PWCHAR p, BOOL caseSensitive, ULONG maxLen)
{
    BOOL result = TRUE;

    while (maxLen > 0){
        if (!*s && !*p){
            break;
        }
        else if (!*s || !*p){
            result = FALSE;
            break;
        }
        else if (caseSensitive){
            if (*s != *p){
                result = FALSE;
                break;
            }
        }
        else {
            if ((*s | 0x20) != (*p | 0x20)){
                result = FALSE;
                break;
            }
        }
        s++, p++;
        maxLen--;
    }

    return result;
}

/*
 *  ConvertObjectInfoAToWChar
 *
 *      Just converts the NTMS_OBJECTINFORMATION structure and all its parts
 *      from ascii to wide-char.
 */
VOID ConvertObjectInfoAToWChar(LPNTMS_OBJECTINFORMATIONW wObjInfo, LPNTMS_OBJECTINFORMATIONA aObjInfo)
{
    wObjInfo->dwSize = aObjInfo->dwSize;
    wObjInfo->dwType = aObjInfo->dwType;
    wObjInfo->Created = aObjInfo->Created;
    wObjInfo->Modified = aObjInfo->Modified;
    wObjInfo->ObjectGuid = aObjInfo->ObjectGuid;
    wObjInfo->Enabled = aObjInfo->Enabled;
    wObjInfo->dwOperationalState = aObjInfo->dwOperationalState;
    AsciiToWChar(wObjInfo->szName, aObjInfo->szName, NTMS_OBJECTNAME_LENGTH);
    AsciiToWChar(wObjInfo->szDescription, aObjInfo->szDescription, NTMS_OBJECTNAME_LENGTH);

    /*
     *  Convert the Union portion of the structure, based on its 'union' type.
     */
    switch (aObjInfo->dwType){
        case NTMS_DRIVE:
            {
                NTMS_DRIVEINFORMATIONA *driveInfoA = &aObjInfo->Info.Drive;
                NTMS_DRIVEINFORMATIONW *driveInfoW = &wObjInfo->Info.Drive;
                driveInfoW->Number = driveInfoA->Number;
                driveInfoW->State = driveInfoA->State;
                driveInfoW->DriveType = driveInfoA->DriveType;
                AsciiToWChar(driveInfoW->szDeviceName, driveInfoA->szDeviceName, sizeof(driveInfoA->szDeviceName));
                AsciiToWChar(driveInfoW->szSerialNumber, driveInfoA->szSerialNumber, sizeof(driveInfoA->szSerialNumber));
                AsciiToWChar(driveInfoW->szRevision, driveInfoA->szRevision, sizeof(driveInfoA->szRevision));
                driveInfoW->ScsiPort = driveInfoA->ScsiPort;
                driveInfoW->ScsiBus = driveInfoA->ScsiBus;
                driveInfoW->ScsiTarget = driveInfoA->ScsiTarget;
                driveInfoW->ScsiLun = driveInfoA->ScsiLun;
                driveInfoW->dwMountCount = driveInfoA->dwMountCount;
                driveInfoW->LastCleanedTs = driveInfoA->LastCleanedTs;
                driveInfoW->SavedPartitionId = driveInfoA->SavedPartitionId;
                driveInfoW->Library = driveInfoA->Library;
                driveInfoW->Reserved = driveInfoA->Reserved;
                driveInfoW->dwDeferDismountDelay = driveInfoA->dwDeferDismountDelay;
            }
            break;
        case NTMS_DRIVE_TYPE:
            {
                NTMS_DRIVETYPEINFORMATIONA *driveTypeInfoA = &aObjInfo->Info.DriveType;
                NTMS_DRIVETYPEINFORMATIONW *driveTypeInfoW = &wObjInfo->Info.DriveType;
                AsciiToWChar(driveTypeInfoW->szVendor, driveTypeInfoA->szVendor, sizeof(driveTypeInfoA->szVendor));
                AsciiToWChar(driveTypeInfoW->szProduct, driveTypeInfoA->szProduct, sizeof(driveTypeInfoA->szVendor));
                driveTypeInfoW->NumberOfHeads = driveTypeInfoA->NumberOfHeads;
                driveTypeInfoW->DeviceType = driveTypeInfoA->DeviceType;
            }
            break;
        case NTMS_LIBRARY:
            {
                NTMS_LIBRARYINFORMATION *libInfoA = &aObjInfo->Info.Library;
                NTMS_LIBRARYINFORMATION *libInfoW = &wObjInfo->Info.Library;
                *libInfoW = *libInfoA;
            }
            break;
        case NTMS_CHANGER:
            {
                NTMS_CHANGERINFORMATIONA *changerInfoA = &aObjInfo->Info.Changer;
                NTMS_CHANGERINFORMATIONW *changerInfoW = &wObjInfo->Info.Changer;
                changerInfoW->Number = changerInfoA->Number;
                changerInfoW->ChangerType = changerInfoA->ChangerType;
                AsciiToWChar(changerInfoW->szSerialNumber, changerInfoA->szSerialNumber, sizeof(changerInfoA->szSerialNumber));
                AsciiToWChar(changerInfoW->szRevision, changerInfoA->szRevision, sizeof(changerInfoA->szRevision));
                AsciiToWChar(changerInfoW->szDeviceName, changerInfoA->szDeviceName, sizeof(changerInfoA->szDeviceName));
                changerInfoW->ScsiPort = changerInfoA->ScsiPort;
                changerInfoW->ScsiBus = changerInfoA->ScsiBus;
                changerInfoW->ScsiTarget = changerInfoA->ScsiTarget;
                changerInfoW->ScsiLun = changerInfoA->ScsiLun;
                changerInfoW->Library = changerInfoA->Library;
            }
            break;
        case NTMS_CHANGER_TYPE:
            {
                NTMS_CHANGERTYPEINFORMATIONA *changerTypeInfoA = &aObjInfo->Info.ChangerType;
                NTMS_CHANGERTYPEINFORMATIONW *changerTypeInfoW = &wObjInfo->Info.ChangerType;
                AsciiToWChar(changerTypeInfoW->szVendor, changerTypeInfoA->szVendor, sizeof(changerTypeInfoA->szVendor));
                AsciiToWChar(changerTypeInfoW->szProduct, changerTypeInfoA->szProduct, sizeof(changerTypeInfoA->szProduct));
                changerTypeInfoW->DeviceType = changerTypeInfoA->DeviceType;
            }
            break;
        case NTMS_STORAGESLOT:
            {
                NTMS_STORAGESLOTINFORMATION *slotInfoA = &aObjInfo->Info.StorageSlot;
                NTMS_STORAGESLOTINFORMATION *slotInfoW = &wObjInfo->Info.StorageSlot;
                *slotInfoW = *slotInfoA;
            }
            break;
         case NTMS_IEDOOR:
            {
                NTMS_IEDOORINFORMATION *ieDoorA = &aObjInfo->Info.IEDoor;
                NTMS_IEDOORINFORMATION *ieDoorW = &wObjInfo->Info.IEDoor;
                *ieDoorW = *ieDoorA;
            }
            break;
        case NTMS_IEPORT:
            {
                NTMS_IEPORTINFORMATION *iePortA = &aObjInfo->Info.IEPort;
                NTMS_IEPORTINFORMATION *iePortW = &wObjInfo->Info.IEPort;
                *iePortW = *iePortA;
            }
            break;
        case NTMS_PHYSICAL_MEDIA:
            {
                NTMS_PMIDINFORMATIONA *physMediaA = &aObjInfo->Info.PhysicalMedia;
                NTMS_PMIDINFORMATIONW *physMediaW = &wObjInfo->Info.PhysicalMedia;
                physMediaW->CurrentLibrary = physMediaA->CurrentLibrary;
                physMediaW->MediaPool = physMediaA->MediaPool;
                physMediaW->Location = physMediaA->Location;
                physMediaW->LocationType = physMediaA->LocationType;
                physMediaW->MediaType = physMediaA->MediaType;
                physMediaW->HomeSlot = physMediaA->HomeSlot;
                AsciiToWChar(physMediaW->szBarCode, physMediaA->szBarCode, sizeof(physMediaA->szBarCode));
                physMediaW->BarCodeState = physMediaA->BarCodeState;
                AsciiToWChar(physMediaW->szSequenceNumber, physMediaA->szSequenceNumber, sizeof(physMediaA->szSequenceNumber));
                physMediaW->MediaState = physMediaA->MediaState;
                physMediaW->dwNumberOfPartitions = physMediaA->dwNumberOfPartitions;
                physMediaW->dwMediaTypeCode = physMediaA->dwMediaTypeCode;
                physMediaW->dwDensityCode = physMediaA->dwDensityCode;
                physMediaW->MountedPartition = physMediaA->MountedPartition;
            }
            break;
        case NTMS_LOGICAL_MEDIA:
            {
                NTMS_LMIDINFORMATION *logMediaA = &aObjInfo->Info.LogicalMedia;
                NTMS_LMIDINFORMATION *logMediaW = &wObjInfo->Info.LogicalMedia;
                *logMediaW = *logMediaA;
            }
            break;
        case NTMS_PARTITION:
            {
                NTMS_PARTITIONINFORMATIONA *partitionInfoA = &aObjInfo->Info.Partition;
                NTMS_PARTITIONINFORMATIONW *partitionInfoW = &wObjInfo->Info.Partition;
                memcpy(&partitionInfoW->PhysicalMedia, &partitionInfoA->PhysicalMedia, sizeof(partitionInfoA->PhysicalMedia));
                memcpy(&partitionInfoW->LogicalMedia, &partitionInfoA->LogicalMedia, sizeof(partitionInfoA->LogicalMedia));
                partitionInfoW->State = partitionInfoA->State;
                partitionInfoW->Side = partitionInfoA->Side;
                partitionInfoW->dwOmidLabelIdLength = partitionInfoA->dwOmidLabelIdLength;
                memcpy(partitionInfoW->OmidLabelId, partitionInfoA->OmidLabelId, sizeof(partitionInfoA->OmidLabelId));
                AsciiToWChar(partitionInfoW->szOmidLabelType, partitionInfoA->szOmidLabelType, sizeof(partitionInfoA->szOmidLabelType));
                AsciiToWChar(partitionInfoW->szOmidLabelInfo, partitionInfoA->szOmidLabelInfo, sizeof(partitionInfoA->szOmidLabelInfo));
                partitionInfoW->dwMountCount = partitionInfoA->dwMountCount;
                partitionInfoW->dwAllocateCount = partitionInfoA->dwAllocateCount;
                partitionInfoW->Capacity = partitionInfoA->Capacity;
            }
            break;
        case NTMS_MEDIA_POOL:
            {
                NTMS_MEDIAPOOLINFORMATION *mediaPoolInfoA = &aObjInfo->Info.MediaPool;
                NTMS_MEDIAPOOLINFORMATION *mediaPoolInfoW = &wObjInfo->Info.MediaPool;
                *mediaPoolInfoW = *mediaPoolInfoA;
            }
            break;
        case NTMS_MEDIA_TYPE:
            {
                NTMS_MEDIATYPEINFORMATION *mediaTypeInfoA = &aObjInfo->Info.MediaType;
                NTMS_MEDIATYPEINFORMATION *mediaTypeInfoW = &wObjInfo->Info.MediaType;
                *mediaTypeInfoW = *mediaTypeInfoA;
            }
            break;
        case NTMS_LIBREQUEST:
            {
                NTMS_LIBREQUESTINFORMATIONA *libReqInfoA = &aObjInfo->Info.LibRequest;
                NTMS_LIBREQUESTINFORMATIONW *libReqInfoW = &wObjInfo->Info.LibRequest;
                libReqInfoW->OperationCode = libReqInfoA->OperationCode;
                libReqInfoW->OperationOption = libReqInfoA->OperationOption;
                libReqInfoW->State = libReqInfoA->State;
                memcpy(&libReqInfoW->PartitionId, &libReqInfoA->PartitionId, sizeof(NTMS_GUID));
                memcpy(&libReqInfoW->DriveId, &libReqInfoA->DriveId, sizeof(NTMS_GUID));
                memcpy(&libReqInfoW->PhysMediaId, &libReqInfoA->PhysMediaId, sizeof(NTMS_GUID));
                memcpy(&libReqInfoW->Library, &libReqInfoA->Library, sizeof(NTMS_GUID));
                memcpy(&libReqInfoW->SlotId, &libReqInfoA->SlotId, sizeof(NTMS_GUID));
                libReqInfoW->TimeQueued = libReqInfoA->TimeQueued;
                libReqInfoW->TimeCompleted = libReqInfoA->TimeCompleted;
                AsciiToWChar(libReqInfoW->szApplication, libReqInfoA->szApplication, sizeof(libReqInfoA->szApplication));
                AsciiToWChar(libReqInfoW->szUser, libReqInfoA->szUser, sizeof(libReqInfoA->szUser));
                AsciiToWChar(libReqInfoW->szComputer, libReqInfoA->szComputer, sizeof(libReqInfoA->szComputer));
                libReqInfoW->dwErrorCode = libReqInfoA->dwErrorCode;
                libReqInfoW->WorkItemId = libReqInfoA->WorkItemId;
                libReqInfoW->dwPriority = libReqInfoA->dwPriority;
            }
            break;
        case NTMS_OPREQUEST:
            {
                NTMS_OPREQUESTINFORMATIONA *opReqInfoA = &aObjInfo->Info.OpRequest;
                NTMS_OPREQUESTINFORMATIONW *opReqInfoW = &wObjInfo->Info.OpRequest;
                opReqInfoW->Request = opReqInfoA->Request;
                opReqInfoW->Submitted = opReqInfoA->Submitted;
                opReqInfoW->State = opReqInfoA->State;
                AsciiToWChar(opReqInfoW->szMessage, opReqInfoA->szMessage, sizeof(opReqInfoA->szMessage));
                opReqInfoW->Arg1Type = opReqInfoA->Arg1Type;
                memcpy(&opReqInfoW->Arg1, &opReqInfoA->Arg1, sizeof(NTMS_GUID));
                opReqInfoW->Arg2Type = opReqInfoA->Arg2Type;
                memcpy(&opReqInfoW->Arg2, &opReqInfoA->Arg2, sizeof(NTMS_GUID));
                AsciiToWChar(opReqInfoW->szApplication, opReqInfoA->szApplication, sizeof(opReqInfoA->szApplication));
                AsciiToWChar(opReqInfoW->szUser, opReqInfoA->szUser, sizeof(opReqInfoA->szUser));
                AsciiToWChar(opReqInfoW->szComputer, opReqInfoA->szComputer, sizeof(opReqInfoA->szComputer));
            }
            break;
        case NTMS_COMPUTER:
            {
                NTMS_COMPUTERINFORMATION *compInfoA = &aObjInfo->Info.Computer;
                NTMS_COMPUTERINFORMATION *compInfoW = &wObjInfo->Info.Computer;
                *compInfoW = *compInfoA;
            }
            break;
        default:
            DBGERR(("ConvertObjectInfoToWChar: unrecognized dwType"));
            break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\work.c ===
/*
 *  WORK.C
 *
 *      RSM Service :  Code to service a work item
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"



/*
 *  ServiceOneWorkItem
 *
 *      Service a single work item.
 *
 *      Return TRUE iff the workItem is complete.
 */
BOOL ServiceOneWorkItem(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL workItemCompleted = FALSE;

    switch (workItem->currentOp.opcode){

        case NTMS_LM_REMOVE:
            workItemCompleted = ServiceRemove(lib, workItem);
            break;
                    
        // case NTMS_LM_DISABLECHANGER: has same value as NTMS_LM_DISABLELIBRARY
        case NTMS_LM_DISABLELIBRARY:
            DBGERR(("NTMS_LM_DISABLELIBRARY not yet implemented"));
            #if 0
                if (xxx){
                    workItemCompleted = ServiceDisableLibrary(lib, workItem);
                }
                else {
                    workItemCompleted = ServiceDisableChanger(lib, workItem);
                }
            #endif
            break;
            
        // case NTMS_LM_ENABLECHANGER: has same value as NTMS_LM_ENABLELIBRARY
        case NTMS_LM_ENABLELIBRARY:
            DBGERR(("NTMS_LM_ENABLELIBRARY not yet implemented"));
            #if 0
                if (xxx){
                    workItemCompleted = ServiceEnableLibrary(lib, workItem);
                }
                else {
                    workItemCompleted = ServiceEnableChanger(lib, workItem);
                }
            #endif
            break;
            
        case NTMS_LM_DISABLEDRIVE:
            workItemCompleted = ServiceDisableDrive(lib, workItem);
            break;
            
        case NTMS_LM_ENABLEDRIVE:
            workItemCompleted = ServiceEnableDrive(lib, workItem);
            break;
            
        case NTMS_LM_DISABLEMEDIA:
            workItemCompleted = ServiceDisableMedia(lib, workItem);
            break;
            
        case NTMS_LM_ENABLEMEDIA:
            workItemCompleted = ServiceEnableMedia(lib, workItem);
            break;
            
        case NTMS_LM_UPDATEOMID:
            workItemCompleted = ServiceUpdateOmid(lib, workItem);
            break;
            
        case NTMS_LM_INVENTORY:
            workItemCompleted = ServiceInventory(lib, workItem);
            break;
            
        case NTMS_LM_DOORACCESS:
            workItemCompleted = ServiceDoorAccess(lib, workItem);
            break;
            
        case NTMS_LM_EJECT:
            workItemCompleted = ServiceEject(lib, workItem);
            break;
            
        case NTMS_LM_EJECTCLEANER:
            workItemCompleted = ServiceEjectCleaner(lib, workItem);
            break;
            
        case NTMS_LM_INJECT:
            workItemCompleted = ServiceInject(lib, workItem);
            break;
            
        case NTMS_LM_INJECTCLEANER:
            workItemCompleted = ServiceInjectCleaner(lib, workItem);
            break;
            
        case NTMS_LM_PROCESSOMID:
            workItemCompleted = ServiceProcessOmid(lib, workItem);
            break;
            
        case NTMS_LM_CLEANDRIVE:
            workItemCompleted = ServiceCleanDrive(lib, workItem);
            break;
            
        case NTMS_LM_DISMOUNT:
            workItemCompleted = ServiceDismount(lib, workItem);
            break;
            
        case NTMS_LM_MOUNT:
            workItemCompleted = ServiceMount(lib, workItem);
            break;
            
        case NTMS_LM_WRITESCRATCH:
            workItemCompleted = ServiceWriteScratch(lib, workItem);
            break;
            
        case NTMS_LM_CLASSIFY:
            workItemCompleted = ServiceClassify(lib, workItem);
            break;
            
        case NTMS_LM_RESERVECLEANER:
            workItemCompleted = ServiceReserveCleaner(lib, workItem);
            break;
            
        default:
            DBGERR(("ServiceOneWorkItem: illegal opcode %xh.", workItem->currentOp.opcode));
            break;
            
    }
        
    return workItemCompleted;
}



BOOL ServiceRemove(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}


BOOL ServiceDisableChanger(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}


BOOL ServiceDisableLibrary(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceEnableChanger(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceEnableLibrary(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceDisableDrive(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceEnableDrive(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceDisableMedia(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceEnableMedia(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceUpdateOmid(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceInventory(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceDoorAccess(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceEject(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceEjectCleaner(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceInject(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceInjectCleaner(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceProcessOmid(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceCleanDrive(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceDismount(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceMount(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceWriteScratch(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceClassify(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceReserveCleaner(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}

BOOL ServiceReleaseCleaner(LIBRARY *lib, WORKITEM *workItem)
{
    BOOL complete = FALSE;

    // BUGBUG FINISH
    return complete;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\svcapi.c ===
/*
 *  SVCAPI.C
 *
 *      Interfaces for RSM Service
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"



STDAPI DllRegisterServer(void)
{
    HRESULT hres;

    // BUGBUG FINISH
    hres = S_OK;

    return hres;
}


STDAPI DllUnregisterServer(void)
{
    HRESULT hres;

    // BUGBUG FINISH
    hres = S_OK;

    return hres;
}


VOID WINAPI ServiceMain(DWORD dwNumServiceArgs, LPWSTR *lpServiceArgVectors)
{
    SERVICE_STATUS_HANDLE hService;

    ASSERT(g_hInstance);

    hService = RegisterServiceCtrlHandlerEx("NtmsSvc", RSMServiceHandler, 0);
    if (hService){
        BOOL ok;

        ok = InitializeRSMService();
        if (ok){

            /*
             *  WAIT HERE UNTIL SERVICE TERMINATES
             */
            WaitForSingleObject(g_terminateServiceEvent, INFINITE);
        }

        ShutdownRSMService();
    }

}


// BUGBUG - how does old ntmssvc's DllMain get called 
//          without being declared in the .def file ?
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason){
        case DLL_PROCESS_ATTACH:
            /*
             *  This service DLL has its own process space,
             *  so it should only get once instance handle ever.
             *  BUGBUG -- is this right ?
             */
            ASSERT(!g_hInstance || (hInstance == g_hInstance));
            g_hInstance = hInstance;
            break;  

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\workitem.c ===
/*
 *  WORKITEM.C
 *
 *      RSM Service :  Library work items
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include <objbase.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


WORKITEM *NewWorkItem(LIBRARY *lib)
{
    WORKITEM *newWorkItem;

    newWorkItem = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(WORKITEM));
    if (newWorkItem){

        newWorkItem->state = WORKITEMSTATE_NONE;
        InitializeListHead(&newWorkItem->libListEntry);
        InitializeListHead(&newWorkItem->workGroupListEntry);

        newWorkItem->workItemCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (newWorkItem->workItemCompleteEvent){
            
            EnterCriticalSection(&lib->lock);
            lib->numTotalWorkItems++;
            newWorkItem->owningLib = lib;
            LeaveCriticalSection(&lib->lock);
        }
        else {
            GlobalFree(newWorkItem);
            newWorkItem = NULL;
        }
    }

    ASSERT(newWorkItem);
    return newWorkItem;
}


VOID FreeWorkItem(WORKITEM *workItem)
{

    EnterCriticalSection(&workItem->owningLib->lock);
    ASSERT(IsEmptyList(&workItem->libListEntry));
    ASSERT(IsEmptyList(&workItem->workGroupListEntry));
    ASSERT(lib->numTotalWorkItems > 0);
    workItem->owningLib->numTotalWorkItems--;
    LeaveCriticalSection(&workItem->owningLib->lock);
    
    CloseHandle(workItem->workItemCompleteEvent);
    GlobalFree(workItem);
}


VOID EnqueueFreeWorkItem(LIBRARY *lib, WORKITEM *workItem)
{
    ASSERT(workItem->owningLib == lib);
    workItem->state = WORKITEMSTATE_FREE;

    EnterCriticalSection(&lib->lock);
    InsertTailList(&lib->freeWorkItemsList, &workItem->libListEntry);
    LeaveCriticalSection(&lib->lock);
}


WORKITEM *DequeueFreeWorkItem(LIBRARY *lib, BOOL allocOrYieldIfNeeded)
{
    WORKITEM *workItem;

    EnterCriticalSection(&lib->lock);

    if (IsListEmpty(&lib->freeWorkItemsList)){

        if (allocOrYieldIfNeeded){
            /*
             *  No free workItems immediately available.
             *  If possible, try allocating a new one.
             *  Otherwise, go do some work and maybe that'll free some up.
             */
            if (lib->numTotalWorkItems < MAX_LIBRARY_WORKITEMS){
                workItem = NewWorkItem(lib);
            }
            else {

                /*
                 *  Give the library thread a chance to free up some workItems.
                 */
                LeaveCriticalSection(&lib->lock);
                Sleep(10);
                EnterCriticalSection(&lib->lock);

                if (IsListEmpty(&lib->freeWorkItemsList)){
                    workItem = NULL;
                }
                else {
                    LIST_ENTRY *listEntry = RemoveHeadList(&lib->freeWorkItemsList);
                    workItem = CONTAINING_RECORD(listEntry, WORKITEM, libListEntry);
                    InitializeListHead(&workItem->libListEntry);
                }
            }
        }
        else {
            workItem = NULL;
        }
    }
    else {
        LIST_ENTRY *listEntry = RemoveHeadList(&lib->freeWorkItemsList);
        workItem = CONTAINING_RECORD(listEntry, WORKITEM, libListEntry);
        InitializeListHead(&workItem->libListEntry);
    }

    if (workItem){
        workItem->state = WORKITEMSTATE_STAGING;
    }
    
    LeaveCriticalSection(&lib->lock);

    return workItem;
}


VOID EnqueuePendingWorkItem(LIBRARY *lib, WORKITEM *workItem)
{
    workItem->state = WORKITEMSTATE_PENDING;

    /*
     *  Make sure workItemCompleteEvent is reset to non-signalled.
     */
    ResetEvent(workItem->workItemCompleteEvent);

    /*
     *  Create a unique identifier for this workItem,
     *  which can be used to enumerate and cancel it.
     */
    CoCreateGuid(&workItem->currentOp.requestGuid);
    
    EnterCriticalSection(&lib->lock);
    InsertTailList(&lib->pendingWorkItemsList, &workItem->libListEntry);
    LeaveCriticalSection(&lib->lock);

    /*
     *  Wake up the library thread so it can process this workItem.
     */
    PulseEvent(lib->somethingToDoEvent);
}


WORKITEM *DequeuePendingWorkItem(LIBRARY *lib, WORKITEM *specificWorkItem)
{
    WORKITEM *workItem;
    
    EnterCriticalSection(&lib->lock);

    if (specificWorkItem){
        ASSERT(!IsListEmpty(&lib->pendingWorkItemsList));
        ASSERT(!IsListEmpty(&specificWorkItem->libListEntry));
        RemoveEntryList(&specificWorkItem->libListEntry);
        InitializeListHead(&specificWorkItem->libListEntry);
        workItem = specificWorkItem;
    }
    else {
        if (IsListEmpty(&lib->pendingWorkItemsList)){
            workItem = NULL;
        }
        else {
            LIST_ENTRY *listEntry = RemoveHeadList(&lib->pendingWorkItemsList);
            workItem = CONTAINING_RECORD(listEntry, WORKITEM, libListEntry);
            InitializeListHead(&workItem->libListEntry);
        }
    }
    
    LeaveCriticalSection(&lib->lock);

    return workItem;
}


WORKITEM *DequeuePendingWorkItemByGuid(LIBRARY *lib, LPNTMS_GUID lpRequestId)
{
    WORKITEM *workItem = NULL;
    LIST_ENTRY *listEntry;
    
    EnterCriticalSection(&lib->lock);

    listEntry = &lib->pendingWorkItemsList;
    while ((listEntry = listEntry->Flink) != &lib->pendingWorkItemsList){
        WORKITEM *thisWorkItem = CONTAINING_RECORD(listEntry, WORKITEM, libListEntry);
        if (RtlEqualMemory(&workItem->currentOp.requestGuid, lpRequestId, sizeof(NTMS_GUID))){
            workItem = thisWorkItem;
            RemoveEntryList(&workItem->libListEntry);
            InitializeListHead(&workItem->libListEntry);
            break;
        }
    }
    
    LeaveCriticalSection(&lib->lock);

    return workItem;
}

VOID EnqueueCompleteWorkItem(LIBRARY *lib, WORKITEM *workItem)
{
    
    EnterCriticalSection(&lib->lock);
    
    /*
     *  Put the workItem in the complete queue and signal its complete event
     *  to wake up the thread that originally queued this event.
     */
    workItem->state = WORKITEMSTATE_COMPLETE;
    InsertTailList(&lib->completeWorkItemsList, &workItem->libListEntry);
    PulseEvent(workItem->workItemCompleteEvent);

    /*
     *  If the workItem is a member of a workGroup, decrement
     *  the count in the workGroup.  If the entire workGroup is complete,
     *  signal the workGroup's complete event.
     */
    if (workItem->workGroup){
        EnterCriticalSection(&workItem->workGroup->lock);
        ASSERT(workItem->workGroup->numPendingWorkItems > 0);
        ASSERT(workItem->workGroup->numPendingWorkItems <= workItem->workGroup->numTotalWorkItems);
        workItem->workGroup->numPendingWorkItems--;
        if (workItem->workGroup->numPendingWorkItems == 0){
            PulseEvent(workItem->workGroup->allWorkItemsCompleteEvent);
        }
        LeaveCriticalSection(&workItem->workGroup->lock);
    }
    
    LeaveCriticalSection(&lib->lock);

}


WORKITEM *DequeueCompleteWorkItem(LIBRARY *lib, WORKITEM *specificWorkItem)
{
    WORKITEM *workItem;
    
    EnterCriticalSection(&lib->lock);

    if (specificWorkItem){
        ASSERT(!IsListEmpty(&lib->completeWorkItemsList));
        ASSERT(!IsListEmpty(&specificWorkItem->libListEntry));
        RemoveEntryList(&specificWorkItem->libListEntry);
        InitializeListHead(&specificWorkItem->libListEntry);
        workItem = specificWorkItem;
    }
    else {
        if (IsListEmpty(&lib->completeWorkItemsList)){
            workItem = NULL;
        }
        else {
            LIST_ENTRY *listEntry = RemoveHeadList(&lib->completeWorkItemsList);
            workItem = CONTAINING_RECORD(listEntry, WORKITEM, libListEntry);
            InitializeListHead(&workItem->libListEntry);
        }
    }
    
    LeaveCriticalSection(&lib->lock);

    return workItem;
}


/*
 *  FlushWorkItem
 *
 *      Dereference any objects pointed to by the workItem 
 *      and zero out the current op.
 */
VOID FlushWorkItem(WORKITEM *workItem)
{
    if (workItem->currentOp.drive) DerefObject(workItem->currentOp.drive); 
    if (workItem->currentOp.physMedia) DerefObject(workItem->currentOp.physMedia);
    if (workItem->currentOp.mediaPartition) DerefObject(workItem->currentOp.mediaPartition);
        
    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
}


VOID BuildSingleMountWorkItem(  WORKITEM *workItem, 
                                    DRIVE *drive OPTIONAL, 
                                    OBJECT_HEADER *mediaOrPartObj,
                                    ULONG dwOptions,
                                    int dwPriority)
{

    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
    workItem->currentOp.opcode = NTMS_LM_MOUNT;
    workItem->currentOp.options = dwOptions;
    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
    workItem->currentOp.drive = drive;
    
    switch (mediaOrPartObj->objType){
        case OBJECTTYPE_PHYSICALMEDIA:
            workItem->currentOp.physMedia = (PHYSICAL_MEDIA *)mediaOrPartObj;
            break;
        case OBJECTTYPE_MEDIAPARTITION:
            workItem->currentOp.mediaPartition = (MEDIA_PARTITION *)mediaOrPartObj;
            break;
        default:
            ASSERT(0);
            break;
    }

    /*
     *  Reference every object that we're pointing this workItem to.
     */
    if (drive) RefObject(drive);
    RefObject(mediaOrPartObj);
    
}


VOID BuildSingleDismountWorkItem(   WORKITEM *workItem,
                                            OBJECT_HEADER *mediaOrPartObj,
                                            DWORD dwOptions)
{

    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
    workItem->currentOp.opcode = NTMS_LM_DISMOUNT;
    workItem->currentOp.options = dwOptions;
    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
    
    switch (mediaOrPartObj->objType){
        case OBJECTTYPE_PHYSICALMEDIA:
            workItem->currentOp.physMedia = (PHYSICAL_MEDIA *)mediaOrPartObj;
            break;
        case OBJECTTYPE_MEDIAPARTITION:
            workItem->currentOp.mediaPartition = (MEDIA_PARTITION *)mediaOrPartObj;
            break;
        default:
            ASSERT(0);
            break;
    }

    /*
     *  Reference every object that we're pointing this workItem to.
     */
    RefObject(mediaOrPartObj);
    
}


VOID BuildInjectWorkItem(   WORKITEM *workItem, 
                                LPNTMS_GUID lpInjectOperation, 
                                ULONG dwAction)
{

    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
    workItem->currentOp.opcode = NTMS_LM_INJECT;
    workItem->currentOp.options = dwAction;
    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
    workItem->currentOp.guidArg = *lpInjectOperation;
}


VOID BuildEjectWorkItem(   WORKITEM *workItem, 
                                PHYSICAL_MEDIA *physMedia,
                                LPNTMS_GUID lpEjectOperation, 
                                ULONG dwAction)
{

    RtlZeroMemory(&workItem->currentOp, sizeof(workItem->currentOp));
    workItem->currentOp.opcode = NTMS_LM_EJECT;
    workItem->currentOp.options = dwAction;
    workItem->currentOp.physMedia = physMedia;
    workItem->currentOp.resultStatus = ERROR_IO_PENDING;
    workItem->currentOp.guidArg = *lpEjectOperation;

    /*
     *  Reference every object that we point the workItem to.
     */
    RefObject(physMedia);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\service.c ===
/*
 *  SERVICE.C
 *
 *      Entrypoint for RSM Service 
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"




DWORD RSMServiceHandler(	IN DWORD dwOpcode,
							IN DWORD dwEventType,
							IN PVOID pEventData,
							IN PVOID pData)
{
    DWORD status = NO_ERROR;

    switch (dwOpcode){

        case SERVICE_CONTROL_STOP:
            break;

        case SERVICE_CONTROL_PAUSE:
            break;

        case SERVICE_CONTROL_CONTINUE:
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_SHUTDOWN:
            break;

        case SERVICE_CONTROL_PARAMCHANGE:
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
            break;

        case SERVICE_CONTROL_NETBINDREMOVE:
            break;

        default:
            break;

    }

    return status;
}


BOOL InitializeRSMService()
{
    BOOL result = FALSE;
    DWORD dwStatus;

    InitGuidHash();

    StartLibraryManager();


    // BUGBUG FINISH
    // create global events
    // Initialize Device Notifications (InitializeDeviceNotClass)
    // WMI initialization (WmiOpenBlock, etc)

    /*
     *  Populate the RSM database with default objects.
     */
    #if 0       // BUGBUG FINISH
        dwStatus = NtmsDbInstall();
        if ((dwStatus == ERROR_SUCCESS) || (dwStatus == ERROR_ALREADY_EXISTS)){

            // BUGBUG FINISH
            result = TRUE;
        }
        else {
        }
    #endif

    return result;
}


VOID ShutdownRSMService()
{


}


VOID RSMServiceLoop()
{
    MSG msg;

    /*
     *  Loop in message pump
     *  Unlike an app window's message pump, 
     *  a NULL-window message pump dispatches messages posted to
     *  the current thread via PostThreadMessage().
     */
    while (GetMessage(&msg, NULL, 0, 0)){
        DispatchMessage(&msg);
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\workgrp.c ===
/*
 *  WORKGRP.C
 *
 *      RSM Service :  Work Groups (collections of work items)
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


WORKGROUP *NewWorkGroup()
{
    WORKGROUP *workGroup;

    workGroup = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(WORKGROUP));
    if (workGroup){
        
        workGroup->allWorkItemsCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (workGroup->allWorkItemsCompleteEvent){
            InitializeListHead(&workGroup->workItemsList);
            InitializeCriticalSection(&workGroup->lock);
        }
        else {
            GlobalFree(workGroup);
            workGroup = NULL;
        }
    }

    ASSERT(workGroup);
    return workGroup;
}


VOID FreeWorkGroup(WORKGROUP *workGroup)
{
    FlushWorkGroup(workGroup);
    
    CloseHandle(workGroup->allWorkItemsCompleteEvent);
    DeleteCriticalSection(&workGroup->lock);
    GlobalFree(workGroup);
}


/*
 *  FlushWorkGroup
 *
 *      Release all the workItems in the workGroup.
 */
VOID FlushWorkGroup(WORKGROUP *workGroup)
{

    EnterCriticalSection(&workGroup->lock);
    
    while (!IsListEmpty(&workGroup->workItemsList)){
        LIST_ENTRY *listEntry;
        WORKITEM *workItem;

        listEntry = RemoveHeadList(&workGroup->workItemsList);
        workItem = CONTAINING_RECORD(listEntry, WORKITEM, workGroupListEntry);
            
        InitializeListHead(&workItem->workGroupListEntry);
        workItem->workGroup = NULL;

        /*
         *  Dereference the objects in the workItem.
         */
        FlushWorkItem(workItem);
             
        /*
         *  Get the workItem back in the library's free queue.
         */
        switch (workItem->state){
            case WORKITEMSTATE_FREE:
                break;
            case WORKITEMSTATE_PENDING:
                // BUGBUG FINISH - have to abort whatever the library thread
                //                  is doing with this workItem.
                DequeuePendingWorkItem(workItem->owningLib, workItem);
                EnqueueFreeWorkItem(workItem->owningLib, workItem);     
                break;
            case WORKITEMSTATE_COMPLETE:
                DequeueCompleteWorkItem(workItem->owningLib, workItem);
                EnqueueFreeWorkItem(workItem->owningLib, workItem);     
                break;
            case WORKITEMSTATE_STAGING:
                EnqueueFreeWorkItem(workItem->owningLib, workItem);     
                break;
            default:
                DBGERR(("bad workItem state in FlushWorkGroup"));
                break;
        }
    }

    LeaveCriticalSection(&workGroup->lock);

}


/*
 *  BuildMountWorkGroup
 *
 *      Build a work group (collection of work items) for a mount
 *      request, which may include multiple mounts, possibly spanning
 *      more than one library.
 */
HRESULT BuildMountWorkGroup(WORKGROUP *workGroup,
                                    LPNTMS_GUID lpMediaOrPartitionIds,
                                    LPNTMS_GUID lpDriveIds,
                                    DWORD dwCount,
                                    DWORD dwOptions,
                                    DWORD dwPriority)
{
    HRESULT result;
    ULONG i;
    
    ASSERT(IsListEmpty(&workGroup->workItemsList));

    /*
     *  1.  Create a workItem for each mount request.
     *      We will only proceed if all the mount requests are valid.
     */
    result = ERROR_SUCCESS; 
    for (i = 0; i < dwCount; i++){
        DRIVE *drive;

        /*
         *  If NTMS_MOUNT_SPECIFIC_DRIVE is set,
         *  we must mount a specific drive. 
         *  Otherwise, we select the drives and return them in lpDriveIds.
         */
        if (dwOptions & NTMS_MOUNT_SPECIFIC_DRIVE){
            drive = FindDrive(&lpDriveIds[i]);
        }
        else {
            drive = NULL;
        }

        if (drive || !(dwOptions & NTMS_MOUNT_SPECIFIC_DRIVE)){
            PHYSICAL_MEDIA *physMedia = NULL;
            MEDIA_PARTITION *mediaPart = NULL;
            
            /*
             *  We may be given either a physical media or a 
             *  media partition to mount.  Figure out which one
             *  by trying to resolve the GUID as either.
             */
            physMedia = FindPhysicalMedia(&lpMediaOrPartitionIds[i]);
            if (!physMedia){
                mediaPart = FindMediaPartition(&lpMediaOrPartitionIds[i]);
                if (mediaPart){
                    physMedia = mediaPart->owningPhysicalMedia;
                }
            }
            if (physMedia){               
                LIBRARY *lib;
                BOOLEAN ok;
                
                /*
                 *  Figure out what library we're dealing with.
                 *  Since we may not be given a specific drive, 
                 *  we have to figure it out from the media.
                 *  For sanity, check that the media is in a pool.
                 *
                 *  BUGBUG - how do we keep the media from moving
                 *            before the work item fires ?
                 */

                ok = LockPhysicalMediaWithLibrary(physMedia);
                if (ok){
                    LIBRARY *lib;

                    lib = physMedia->owningMediaPool ? 
                            physMedia->owningMediaPool->owningLibrary : 
                            NULL;
                    if (lib){
                        /*
                         *  If we're targetting a specific drive, then
                         *  it should be in the same library.
                         */
                        if (!drive || (drive->lib == lib)){
                            OBJECT_HEADER *mediaOrPartObj = 
                                            mediaPart ? 
                                            (OBJECT_HEADER *)mediaPart : 
                                            (OBJECT_HEADER *)physMedia;
                            WORKITEM *workItem;

                            workItem = DequeueFreeWorkItem(lib, TRUE);
                            if (workItem){
                                BuildSingleMountWorkItem( workItem,
                                                        drive,
                                                        mediaOrPartObj,
                                                        dwOptions,
                                                        dwPriority);
                                /*
                                 *  We've built one of the mount requests.
                                 *  Put it in the work group.
                                 */
                                InsertTailList( &workGroup->workItemsList, 
                                            &workItem->workGroupListEntry);
                                workItem->workGroup = workGroup;
                            }
                            else {
                                result = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        else {
                            result = ERROR_DRIVE_MEDIA_MISMATCH;
                        }
                    }
                    else {
                        result = ERROR_INVALID_LIBRARY;
                    }
                    
                    UnlockPhysicalMediaWithLibrary(physMedia);
                }
                else {
                    result = ERROR_DATABASE_FAILURE;
                }
            }
            else {
                result = ERROR_INVALID_MEDIA;
            }
        }
        else {
            result = ERROR_INVALID_DRIVE;
        }

        if (result != ERROR_SUCCESS){
            break;
        }
    }


    if (result == ERROR_SUCCESS){
        workGroup->numTotalWorkItems = workGroup->numPendingWorkItems = dwCount;
    }
    else {
        /*
         *  If we failed, release any work items that we did create.
         */
        FlushWorkGroup(workGroup);
    }
    
    return result;
}


/*
 *  BuildDismountWorkGroup
 *
 *      Build a work group (collection of work items) for a dismount
 *      request, which may include multiple dismounts, possibly spanning
 *      more than one library.
 */
HRESULT BuildDismountWorkGroup( WORKGROUP *workGroup,
                                       LPNTMS_GUID lpMediaOrPartitionIds,
                                       DWORD dwCount,
                                       DWORD dwOptions)
{
    HRESULT result;
    ULONG i;
    
    ASSERT(IsListEmpty(&workGroup->workItemsList));

    /*
     *  1.  Create a workItem for each dismount request.
     *      We will only proceed if all the dismount requests are valid.
     */
    result = ERROR_SUCCESS; 
    for (i = 0; i < dwCount; i++){
        PHYSICAL_MEDIA *physMedia = NULL;
        MEDIA_PARTITION *mediaPart = NULL;
            
        /*
         *  We may be given either a physical media or a 
         *  media partition to mount.  Figure out which one
         *  by trying to resolve the GUID as either.
         */
        physMedia = FindPhysicalMedia(&lpMediaOrPartitionIds[i]);
        if (!physMedia){
            mediaPart = FindMediaPartition(&lpMediaOrPartitionIds[i]);
            if (mediaPart){
                physMedia = mediaPart->owningPhysicalMedia;
            }
        }
        if (physMedia){               
            LIBRARY *lib;
            BOOLEAN ok;
                
            /*
             *  Figure out what library we're dealing with.
             */
            ok = LockPhysicalMediaWithLibrary(physMedia);
            if (ok){
                LIBRARY *lib;

                lib = physMedia->owningMediaPool ? 
                        physMedia->owningMediaPool->owningLibrary : 
                        NULL;
                if (lib){
                    OBJECT_HEADER *mediaOrPartObj = 
                                            mediaPart ? 
                                            (OBJECT_HEADER *)mediaPart : 
                                            (OBJECT_HEADER *)physMedia;
                    WORKITEM *workItem;

                    workItem = DequeueFreeWorkItem(lib, TRUE);
                    if (workItem){
                        BuildSingleDismountWorkItem( workItem,
                                                    mediaOrPartObj,
                                                    dwOptions);
                        /*
                         *  We've built one of the mount requests.
                         *  Put it in the work group.
                         */
                        InsertTailList( &workGroup->workItemsList, 
                                    &workItem->workGroupListEntry);
                        workItem->workGroup = workGroup;
                    }
                    else {
                        result = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else {
                    result = ERROR_DRIVE_MEDIA_MISMATCH;
                }
                    
                UnlockPhysicalMediaWithLibrary(physMedia);
            }
            else {
                result = ERROR_DATABASE_FAILURE;
            }
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }


    if (result == ERROR_SUCCESS){
        workGroup->numTotalWorkItems = workGroup->numPendingWorkItems = dwCount;
    }
    else {
        /*
         *  If we failed, release any work items that we did create and clean up.
         */
        FlushWorkGroup(workGroup);
    }
        
    return result;
}

/*
 *  ScheduleWorkGroup
 *
 *      Submit all the work items in the work group.
 */
HRESULT ScheduleWorkGroup(WORKGROUP *workGroup)
{
    LIST_ENTRY *listEntry;
    HRESULT result;
    
    EnterCriticalSection(&workGroup->lock);

    /*
     *  Set the workGroup's status to success.
     *  If any workItems fail, they'll set this to an error code.
     */
    workGroup->resultStatus = ERROR_SUCCESS;

    listEntry = &workGroup->workItemsList;
    while ((listEntry = listEntry->Flink) != &workGroup->workItemsList){
        WORKITEM *workItem = CONTAINING_RECORD(listEntry, WORKITEM, workGroupListEntry);
        ASSERT(workItem->state == WORKITEMSTATE_STAGING);

        /*
         *  Give this workItem to the library and wake up the library thread.
         */
        EnqueuePendingWorkItem(workItem->owningLib, workItem);
    }

    LeaveCriticalSection(&workGroup->lock);

    result = ERROR_SUCCESS;
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\validate.c ===
/*
 *  VALIDATE.C
 *
 *      RSM Service :  Handle validation code
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"



#pragma optimize("agpswy", off)
BOOL ValidateSessionHandle(HANDLE hSession)
{
    BOOL ok;

    /*
     *  The server runs in its own context.
     *  So just need to validate:
     *      (1) its our context (we can write to it), and
     *      (2) its a session context (not another one of our contexts)
     */
    __try {
        SESSION *s = (SESSION *)hSession;
        ok = (s->sig == SESSION_SIG);
    }
    __except (EXCEPTION_EXECUTE_HANDLER){
        DWORD exceptionCode = GetExceptionCode();
        ok = FALSE;
        DBGERR(("invalid session handle (%xh) (code=%xh)", hSession, exceptionCode));
    }

    return ok;
}
#pragma optimize("agpswy", on)  // BUGBUG - how to set back to 'default' ?


#pragma optimize("agpswy", off)
BOOL ValidateWStr(LPCWSTR ws)
{
    BOOL ok;

    __try {
        while (*ws++);
        ok = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER){
        DWORD exceptionCode = GetExceptionCode();
        ok = FALSE;
        DBGERR(("invalid string arg (code=%xh)", exceptionCode));
    }

    return ok;
}
#pragma optimize("agpswy", on)  // BUGBUG - how to set back to 'default' ?


#pragma optimize("agpswy", off)
BOOL ValidateAStr(LPCSTR s)
{
    BOOL ok;

    __try {
        while (*s++);
        ok = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER){
        DWORD exceptionCode = GetExceptionCode();
        ok = FALSE;
        DBGERR(("invalid string arg (code=%xh)", exceptionCode));
    }

    return ok;
}
#pragma optimize("agpswy", on)  // BUGBUG - how to set back to 'default' ?

#pragma optimize("agpswy", off)
BOOL ValidateBuffer(PVOID buf, ULONG len)
{
    PUCHAR bufPtr = (PUCHAR) buf;
    BOOL ok;

    __try {
        while (len > 0){
            *bufPtr = *bufPtr;
        }
        ok = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER){
        DWORD exceptionCode = GetExceptionCode();
        ok = FALSE;
        DBGERR(("invalid buffer (code=%xh)", exceptionCode));
    }

    return ok;
}
#pragma optimize("agpswy", on)  // BUGBUG - how to set back to 'default' ?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\workutil.c ===
/*
 *  WORKUTIL.C
 *
 *      RSM Service :  Utilities for servicing work items
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "..\..\..\rsm\tools\reskit\rsm_config\winioctl.h"
#include "internal.h"
#include "resource.h"
#include "debug.h"


BOOL SendIoctlSync( HANDLE hDevice, 
                        DWORD dwIoControlCode, 
                        LPVOID lpInBuffer, 
                        DWORD nInBufferSize, 
                        LPVOID lpOutBuffer, 
                        DWORD nOutBufferSize, 
                        LPDWORD lpBytesReturned, 
                        DWORD timeoutMillisec)
{
    DWORD status;
    DWORD startTime;

    startTime = GetTickCount();
    
    do
    {
        BOOL ok;
        
        ok = DeviceIoControl(hDevice, 
                         dwIoControlCode,
                         lpInBuffer, 
                         nInBufferSize,
                         lpOutBuffer, 
                         nOutBufferSize,
                         lpBytesReturned, 
                         NULL);
        if (ok){
            status = NO_ERROR;
            break;
        }
        else {
            BOOL done;
            
            // BUGBUG - check for shutdown
            
            status = GetLastError();

            switch (status){
                case ERROR_NOT_READY:
                case ERROR_DRIVE_LOCKED:
                case ERROR_BUSY_DRIVE:
                case ERROR_BUSY:
                    Sleep(3000);
                    done = FALSE;
                    break;
                default:
                    done = TRUE;
                    break;
            }

            if (!done){
                break;
            }
        }
    }
    while (GetTickCount() - startTime < timeoutMillisec);

    return status;
}


DWORD ChangerMoveMedium(HANDLE      libHandle,
                      DWORD         TrnsElementOffset,
                      ELEMENT_TYPE  SrcElementType,
                      DWORD         SrcElementOffset,
                      ELEMENT_TYPE  DstElementType,
                      DWORD         DstElementOffset,
                      BOOLEAN       Flip,
                      ULONG         Timeout, // NOT USED
                      DWORD         timeoutval)
{
    DWORD status;
    DWORD byteCount = 0;
    CHANGER_MOVE_MEDIUM LibMoveMedium;

    LibMoveMedium.Transport.ElementType = ChangerTransport;
    LibMoveMedium.Transport.ElementAddress = 0;
    LibMoveMedium.Source.ElementType = SrcElementType;
    LibMoveMedium.Source.ElementAddress = SrcElementOffset;
    LibMoveMedium.Destination.ElementType = DstElementType;
    LibMoveMedium.Destination.ElementAddress = DstElementOffset;
    LibMoveMedium.Flip = Flip;

    status = SendIoctlSync(libHandle,
                         IOCTL_CHANGER_MOVE_MEDIUM, 
                         &LibMoveMedium, 
                         sizeof(CHANGER_MOVE_MEDIUM),
                         NULL, 
                         0,
                         &byteCount, 
                         timeoutval);
    return status;
}


DWORD ChangerSetAccess(HANDLE libHandle,
                       ELEMENT_TYPE ElementType,
                       ULONG ElementOffset,
                       ULONG  Control,
                       DWORD timeoutval)
{
    DWORD status;
    DWORD byteCount = 0;
    CHANGER_SET_ACCESS libSetSecurity;

    libSetSecurity.Element.ElementType = ElementType;
    libSetSecurity.Element.ElementAddress = ElementOffset;
    libSetSecurity.Control = Control;

    status = SendIoctlSync(libHandle,
                         IOCTL_CHANGER_SET_ACCESS, 
                         &libSetSecurity, 
                         sizeof(CHANGER_SET_ACCESS),
                         NULL, 
                         0, 
                         &byteCount, 
                         timeoutval);
    return status;
}


DWORD ChangerSetPosition(HANDLE         libHandle,              
                         DWORD         TrnsElementOffset,
                         ELEMENT_TYPE   DstElementType,
                         DWORD         DstElementOffset,
                         BOOLEAN        Flip,
                         ULONG          Timeout, // NOT USED
                         DWORD timeoutval)
{
    DWORD status;
    DWORD byteCount = 0;
    CHANGER_SET_POSITION LibSetPosition;

    LibSetPosition.Transport.ElementType = ChangerTransport;
    LibSetPosition.Transport.ElementAddress = 0;
    LibSetPosition.Destination.ElementType = DstElementType;
    LibSetPosition.Destination.ElementAddress = DstElementOffset;
    LibSetPosition.Flip = Flip;
    
    status = SendIoctlSync(libHandle,
                         IOCTL_CHANGER_SET_POSITION, 
                         &LibSetPosition, sizeof(CHANGER_SET_POSITION),
                         NULL, 
                         0,
                         &byteCount, 
                         timeoutval);
    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\inc\rsmsvc.h ===
/*
 *  SVCAPI.H
 *
 *      RSM Service :  Service API header (NEW)
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

    // BUGBUG - contains many redundancies and errors


HANDLE WINAPI OpenNtmsServerSessionW(   LPCWSTR lpServer,
                                        LPCWSTR lpApplication,
                                        LPCWSTR lpClientName,
                                        LPCWSTR lpUserName,
                                        DWORD   dwOptions,
                                        LPVOID  lpConnectionContext);
HANDLE WINAPI OpenNtmsSessionA( LPCSTR lpServer,
                                LPCSTR lpApplication,
                                LPCSTR lpClientName,
                                LPCSTR lpUserName,
                                DWORD  dwOptions,
                                LPVOID  lpConnectionContext);
HRESULT WINAPI CloseNtmsSession(HANDLE hSession);
HRESULT WINAPI SubmitNtmsOperatorRequestW(  HANDLE hSession,
                                            DWORD dwRequest,
                                            LPCWSTR lpMessage,
                                            LPNTMS_GUID lpArg1Id,
                                            LPNTMS_GUID lpArg2Id,
                                            LPNTMS_GUID lpRequestId);
HRESULT WINAPI SubmitNtmsOperatorRequestA(  HANDLE hSession,
                                            DWORD dwRequest,
                                            LPCSTR lpMessage,
                                            LPNTMS_GUID lpArg1Id,
                                            LPNTMS_GUID lpArg2Id,
                                            LPNTMS_GUID lpRequestId);
HRESULT WINAPI WaitForNtmsOperatorRequest(  HANDLE hSession, 
                                            LPNTMS_GUID lpRequestId,
                                            DWORD dwTimeout);
HRESULT WINAPI CancelNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId);
HRESULT WINAPI SatisfyNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId);
HRESULT WINAPI ImportNtmsDatabase(HANDLE hSession);
HRESULT WINAPI ExportNtmsDatabase(HANDLE hSession);
HRESULT WINAPI GetNtmsMountDrives(  HANDLE hSession,
                                    LPNTMS_MOUNT_INFORMATION lpMountInformation,
                                    LPNTMS_GUID lpDriveId,
                                    DWORD dwCount);       
HRESULT WINAPI AllocateNtmsMedia(   HANDLE hSession,
                                    LPNTMS_GUID lpMediaPool,
                                    LPNTMS_GUID lpPartition,    // optional
                                    LPNTMS_GUID lpMediaId,      // OUTPUT, media id o
                                    DWORD dwOptions,
                                    DWORD dwTimeout,
                                    LPNTMS_ALLOCATION_INFORMATION lpAllocateInformation);
HRESULT WINAPI DeallocateNtmsMedia( HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    DWORD dwOptions);
HRESULT WINAPI SwapNtmsMedia(   HANDLE hSession,
                                LPNTMS_GUID lpMediaId1,
                                LPNTMS_GUID lpMediaId2);
HRESULT WINAPI DecommissionNtmsMedia(   HANDLE hSession,
                                        LPNTMS_GUID lpMediaId);
HRESULT WINAPI SetNtmsMediaComplete(    HANDLE hSession,
                                        LPNTMS_GUID lpMediaId);
HRESULT WINAPI DeleteNtmsMedia( HANDLE hSession,
                                LPNTMS_GUID lpMediaId);
HRESULT WINAPI CreateNtmsMediaPoolA(    HANDLE hSession,
                                        LPCSTR lpPoolName,
                                        LPNTMS_GUID lpMediaType,
                                        DWORD dwAction,
                                        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                        OUT LPNTMS_GUID lpPoolId);
HRESULT WINAPI CreateNtmsMediaPoolW(    HANDLE hSession,
                                        LPCWSTR lpPoolName,
                                        LPNTMS_GUID lpMediaType,
                                        DWORD dwAction,
                                        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                        OUT LPNTMS_GUID lpPoolId);
HRESULT WINAPI GetNtmsMediaPoolNameA(   HANDLE hSession,
                                        LPNTMS_GUID lpPoolId,
                                        LPSTR lpBufName,
                                        LPDWORD lpdwNameSize);
HRESULT WINAPI GetNtmsMediaPoolNameW(   HANDLE hSession,
                                        LPNTMS_GUID lpPoolId,
                                        LPWSTR lpBufName,
                                        LPDWORD lpdwNameSize);
HRESULT WINAPI MoveToNtmsMediaPool( HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    LPNTMS_GUID lpPoolId);
HRESULT WINAPI DeleteNtmsMediaPool(HANDLE hSession, LPNTMS_GUID lpPoolId);
HRESULT WINAPI AddNtmsMediaType(    HANDLE hSession,
                                    LPNTMS_GUID lpMediaTypeId,
                                    LPNTMS_GUID lpLibId);
HRESULT WINAPI DeleteNtmsMediaType( HANDLE hSession,
                                    LPNTMS_GUID lpMediaTypeId,
                                    LPNTMS_GUID lpLibId);
HRESULT WINAPI ChangeNtmsMediaType( HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    LPNTMS_GUID lpPoolId);
HRESULT WINAPI MountNtmsMedia(  HANDLE hSession,
                                LPNTMS_GUID lpMediaId,
                                LPNTMS_GUID lpDriveId,
                                DWORD dwCount,
                                DWORD dwOptions,
                                int dwPriority,
                                DWORD dwTimeout,
                                LPNTMS_MOUNT_INFORMATION lpMountInformation);
HRESULT WINAPI DismountNtmsMedia(   HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    DWORD dwCount,
                                    DWORD dwOptions);
DWORD WINAPI EjectNtmsMedia(    HANDLE hSession,
                                LPNTMS_GUID lpMediaId,
                                LPNTMS_GUID lpEjectOperation,
                                DWORD dwAction);
DWORD WINAPI InjectNtmsMedia(   HANDLE hSession,
                                LPNTMS_GUID lpLibraryId,
                                LPNTMS_GUID lpInjectOperation,
                                DWORD dwAction);
DWORD WINAPI AccessNtmsLibraryDoor( HANDLE hSession,
                                    LPNTMS_GUID lpLibraryId,
                                    DWORD dwAction);
DWORD WINAPI CleanNtmsDrive(            HANDLE hSession,
                                        LPNTMS_GUID lpDriveId);
DWORD WINAPI DismountNtmsDrive(         HANDLE hSession,
                                        LPNTMS_GUID lpDriveId);
DWORD WINAPI InventoryNtmsLibrary(
        HANDLE hSession,
        LPNTMS_GUID lpLibraryId,
        DWORD dwAction
        )
DWORD WINAPI UpdateNtmsOmidInfo(    HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    DWORD labelType,
                                    DWORD numberOfBytes,
                                    LPVOID lpBuffer);
DWORD WINAPI CancelNtmsLibraryRequest(  HANDLE hSession,
                                        LPNTMS_GUID lpRequestId);
DWORD WINAPI ReserveNtmsCleanerSlot(    HANDLE hSession,
                                        LPNTMS_GUID lpLibrary,
                                        LPNTMS_GUID lpSlot);
DWORD WINAPI ReleaseNtmsCleanerSlot(    HANDLE hSession,
                                        LPNTMS_GUID lpLibrary);
DWORD WINAPI InjectNtmsCleaner(     HANDLE hSession,
                                    LPNTMS_GUID lpLibrary,
                                    LPNTMS_GUID lpInjectOperation,
                                    DWORD dwNumberOfCleansLeft,
                                    DWORD dwAction);
DWORD WINAPI EjectNtmsCleaner(      HANDLE hSession,
                                    LPNTMS_GUID lpLibrary,
                                    LPNTMS_GUID lpEjectOperation,
                                    DWORD dwAction);
DWORD WINAPI DeleteNtmsLibrary(HANDLE hSession, LPNTMS_GUID lpLibraryId);
DWORD WINAPI DeleteNtmsDrive(HANDLE hSession, LPNTMS_GUID lpDriveId);
DWORD WINAPI GetNtmsRequestOrder(   HANDLE hSession,
                                    LPNTMS_GUID lpRequestId,
                                    LPDWORD lpdwOrderNumber);
DWORD WINAPI SetNtmsRequestOrder(   HANDLE hSession,
                                    LPNTMS_GUID lpRequestId,
                                    DWORD dwOrderNumber);
DWORD WINAPI DeleteNtmsRequests(    HANDLE hSession,
                                    LPNTMS_GUID lpRequestId,
                                    DWORD dwType,
                                    DWORD dwCount);
DWORD WINAPI BeginNtmsDeviceChangeDetection(HANDLE hSession, LPHANDLE lpDetectHandle);
DWORD WINAPI SetNtmsDeviceChangeDetection(  HANDLE hSession,
                                            HANDLE DetectHandle,
                                            LPNTMS_GUID lpRequestId,
                                            DWORD dwType,
                                            DWORD dwCount);
DWORD WINAPI EndNtmsDeviceChangeDetection(HANDLE hSession, HANDLE DetectHandle);

/******** BUGBUG: INtmsObjectManagement1 APIs *********************/

DWORD WINAPI GetNtmsObjectSecurity(     HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        DWORD dwType,
                                        SECURITY_INFORMATION RequestedInformation,
                                        PSECURITY_DESCRIPTOR lpSecurityDescriptor,
                                        DWORD nLength,
                                        LPDWORD lpnLengthNeeded);
DWORD WINAPI SetNtmsObjectSecurity(     HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        DWORD dwType,
                                        SECURITY_INFORMATION SecurityInformation,
                                        PSECURITY_DESCRIPTOR lpSecurityDescriptor);
DWORD WINAPI GetNtmsObjectAttributeA(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            LPDWORD lpAttributeSize);
DWORD WINAPI GetNtmsObjectAttributeW(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCWSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            LPDWORD lpAttributeSize);
DWORD WINAPI SetNtmsObjectAttributeA(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            DWORD dwAttributeSize);
DWORD WINAPI SetNtmsObjectAttributeW(       HANDLE hSession,
                                            LPNTMS_GUID lpObjectId,
                                            DWORD dwType,
                                            LPCWSTR lpAttributeName,
                                            LPVOID lpAttributeData,
                                            DWORD AttributeSize);
DWORD WINAPI EnumerateNtmsObject(   HANDLE hSession,
                                    const LPNTMS_GUID lpContainerId,
                                    LPNTMS_GUID lpList,
                                    LPDWORD lpdwListSize,
                                    DWORD dwType,
                                    DWORD dwOptions);
DWORD WINAPI EnableNtmsObject(          HANDLE hSession,
                                        DWORD dwType,
                                        LPNTMS_GUID lpObjectId);
DWORD WINAPI DisableNtmsObject(         HANDLE hSession,
                                        DWORD dwType,
                                        LPNTMS_GUID lpObjectId);

/******* BUGBUG: INtmsObjectInfo1 APIs  ****************************/

                    // BUGBUG - these 4 functions have another form with type,size as last args
DWORD WINAPI GetNtmsServerObjectInformationA(   HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONA lpInfo,
                                                int revision);
DWORD WINAPI GetNtmsServerObjectInformationW(   HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONW lpInfo,
                                                int revision);
DWORD WINAPI SetNtmsServerObjectInformationA(   HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONA lpInfo,
                                                int revision);
DWORD WINAPI SetNtmsServerObjectInformationW(   HANDLE hSession,
                                                LPNTMS_GUID lpObjectId,
                                                LPNTMS_OBJECTINFORMATIONW lpInfo,
                                                int revision);
DWORD WINAPI CreateNtmsMediaA(      HANDLE hSession,
                                    LPNTMS_OBJECTINFORMATIONA lpMedia,
                                    LPNTMS_OBJECTINFORMATIONA lpList,
                                    DWORD dwOptions);
DWORD WINAPI CreateNtmsMediaW(      HANDLE hSession,
                                    LPNTMS_OBJECTINFORMATIONW lpMedia,
                                    LPNTMS_OBJECTINFORMATIONW lpList,
                                    DWORD dwOptions);
DWORD WINAPI GetNtmsObjectInformationA( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONA lpInfo);
DWORD WINAPI GetNtmsObjectInformationW( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONW lpInfo);
DWORD WINAPI SetNtmsObjectInformationA( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONA lpInfo);
DWORD WINAPI SetNtmsObjectInformationW( HANDLE hSession,
                                        LPNTMS_GUID lpObjectId,
                                        LPNTMS_OBJECTINFORMATIONW lpInfo);
DWORD WINAPI SubmitNtmsOperatorRequestA(        HANDLE hSession,
                                                DWORD dwRequest,
                                                LPCSTR lpMessage,
                                                LPNTMS_GUID lpArg1Id,
                                                LPNTMS_GUID lpArg2Id,
                                                LPNTMS_GUID lpRequestId);
DWORD WINAPI SubmitNtmsOperatorRequestW(        HANDLE hSession,
                                                DWORD dwRequest,
                                                LPCWSTR lpMessage,
                                                LPNTMS_GUID lpArg1Id,
                                                LPNTMS_GUID lpArg2Id,
                                                LPNTMS_GUID lpRequestId);
DWORD WINAPI WaitForNtmsOperatorRequest(    HANDLE hSession,
                                            LPNTMS_GUID lpRequestId,
                                            DWORD dwTimeout);
DWORD WINAPI CancelNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId);
DWORD WINAPI SatisfyNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId);
HANDLE WINAPI OpenNtmsNotification(HANDLE hSession, DWORD dwType);
DWORD WINAPI WaitForNtmsNotification(   HANDLE hNotification,
                                        LPNTMS_NOTIFICATIONINFORMATION lpNotificationInformation,
                                        DWORD dwTimeout);
DWORD WINAPI CloseNtmsNotification(HANDLE hNotification);
DWORD WINAPI ImportNtmsDatabase(HANDLE hSession);
DWORD WINAPI ExportNtmsDatabase(HANDLE hSession);
DWORD WINAPI EjectDiskFromSADriveA(     LPCSTR lpComputerName,
                                        LPCSTR lpAppName,
                                        LPCSTR lpDeviceName,
                                        HWND hWnd,
                                        LPCSTR lpTitle,
                                        LPCSTR lpMessage,
                                        DWORD dwOptions);
DWORD WINAPI EjectDiskFromSADriveW(     LPCWSTR lpComputerName,
                                        LPCWSTR lpAppName,
                                        LPCWSTR lpDeviceName,
                                        HWND hWnd,
                                        LPCWSTR lpTitle,
                                        LPCWSTR lpMessage,
                                        DWORD dwOptions);
DWORD WINAPI GetVolumesFromDriveA(      LPSTR pszDriveName,
                                        LPSTR* VolumeNameBufferPtr,
                                        LPSTR* DriveLetterBufferPtr);
DWORD WINAPI GetVolumesFromDriveW(      LPWSTR pszDriveName,
                                        LPWSTR *VolumeNameBufferPtr,
                                        LPWSTR *DriveLetterBufferPtr);
DWORD WINAPI IdentifyNtmsSlot(          HANDLE hSession,
                                        LPNTMS_GUID lpSlotId,
                                        DWORD dwOption);
DWORD WINAPI GetNtmsUIOptionsA(     HANDLE hSession,
                                    const LPNTMS_GUID lpObjectId,
                                    DWORD dwType,
                                    LPSTR lpszDestination,
                                    LPDWORD lpAttributeSize);
DWORD WINAPI GetNtmsUIOptionsW(     HANDLE hSession,
                                    const LPNTMS_GUID lpObjectId,
                                    DWORD dwType,
                                    LPWSTR lpszDestination,
                                    LPDWORD lpdwSize);
DWORD WINAPI SetNtmsUIOptionsA(     HANDLE hSession,
                                    const LPNTMS_GUID lpObjectId,
                                    DWORD dwType,
                                    DWORD dwOperation,
                                    LPCSTR lpszDestination);

DWORD WINAPI SetNtmsUIOptionsW(     HANDLE hSession,
                                    const LPNTMS_GUID lpObjectId,
                                    DWORD dwType,
                                    DWORD dwOperation,
                                    LPCWSTR lpszDestination);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sbp2port\ntm_api.h ===
/*
    private api for ntmap to path an SG list 
    to sbp2port or usbstor

     irpStack->Parameters.Others.Argument1
         set to NTMAP_SCATTER_GATHER_SIG
             
     irpStack->Parameters.Others.Argument2 
        set to PNTMAP_SG_REQUEST
     
*/

typedef struct _NTMAP_SG_REQUEST
{
    PSCSI_REQUEST_BLOCK Srb;
    SCATTER_GATHER_LIST SgList;

} NTMAP_SG_REQUEST, *PNTMAP_SG_REQUEST;


#define NTMAP_SCATTER_GATHER_SIG   'pmTN'


/*

from ntddk.h

typedef struct _SCATTER_GATHER_ELEMENT
{
    PHYSICAL_ADDRESS    Address;
    ULONG               Length;
    ULONG_PTR           Reserved;

} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

typedef struct _SCATTER_GATHER_LIST
{
    ULONG                   NumberOfElements;
    ULONG_PTR               Reserved;
    SCATTER_GATHER_ELEMENT  Elements[];

} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sbp2port\sbp2.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sbp2.h

Abstract:

    Definitions for SBP2 protocol

Author:

    georgioc 22-Jan-97

Environment:

    Kernel mode only

Revision History:


--*/
#ifndef _SBP2_
#define _SBP2_

#ifndef SBP2KDX
#include "wdm.h"
#endif

#include "1394.h"
#include "rbc.h"

#include "scsi.h"
#include "ntddstor.h"

typedef union _QUADLET {

    ULONG QuadPart;
    struct {
        USHORT LowPart;
        USHORT HighPart;
    } u;

} QUADLET, *PQUADLET;


typedef struct _B1394_ADDRESS {
    USHORT Off_High;        // little endian ordering within an octlet
    NODE_ADDRESS NodeId;
    ULONG  Off_Low;
} B1394_ADDRESS, *PB1394_ADDRESS;



typedef union _OCTLET {
    LONGLONG OctletPart;
    B1394_ADDRESS BusAddress;
    struct {
        QUADLET HighQuad;
        QUADLET LowQuad;
    } u;
    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
        UCHAR Byte4;
        UCHAR Byte5;
        UCHAR Byte6;
        UCHAR Byte7;
    } ByteArray;

} OCTLET, *POCTLET;



//
// Various ORB and block definitions
//

typedef struct _ORB_NORMAL_CMD {
    OCTLET  NextOrbAddress;
    OCTLET  DataDescriptor;
    QUADLET OrbInfo;
    UCHAR  Cdb[12];
} ORB_NORMAL_CMD, *PORB_NORMAL_CMD;

#define CMD_ORB_HEADER_SIZE 0x14


typedef struct _ORB_LOGIN {
    OCTLET  Password;
    OCTLET  LoginResponseAddress;
    QUADLET OrbInfo;
    QUADLET LengthInfo;
    OCTLET  StatusBlockAddress;
} ORB_LOGIN, *PORB_LOGIN;

typedef struct _ORB_QUERY_LOGIN {
    OCTLET  Reserved;
    OCTLET  QueryResponseAddress;
    QUADLET OrbInfo;
    QUADLET LengthInfo;
    OCTLET  StatusBlockAddress;
} ORB_QUERY_LOGIN, *PORB_QUERY_LOGIN;

typedef struct _ORB_SET_PASSWORD {
    OCTLET  Password;
    OCTLET  Reserved;
    QUADLET OrbInfo;
    QUADLET LengthInfo;
    OCTLET  StatusBlockAddress;
} ORB_SET_PASSWORD, *PORB_SET_PASSWORD;

typedef struct _ORB_MNG {
    OCTLET  Reserved[2];
    QUADLET OrbInfo;
    QUADLET Reserved1;
    OCTLET  StatusBlockAddress;
} ORB_MNG, *PORB_MNG;

typedef struct _ORB_TASK_MNG {
    OCTLET  OrbAddress;
    OCTLET  Reserved;
    QUADLET OrbInfo;
    QUADLET Reserved1;
    OCTLET  StatusBlockAddress;
} ORB_TASK_MNG, *PORB_TASK_MNG;



typedef struct _ORB_DUMMY {
    OCTLET  NextOrbAddress;
    OCTLET  NotUsed;
    QUADLET OrbInfo;
    OCTLET  Unused[3];
} ORB_DUMMY, *PORB_DUMMY;

typedef struct _LOGIN_RESPONSE {
    QUADLET LengthAndLoginId;
    QUADLET Csr_Off_High;
    QUADLET Csr_Off_Low;
    QUADLET Reserved;
} LOGIN_RESPONSE, *PLOGIN_RESPONSE;

typedef struct _QUERY_RESPONSE_ELEMENT {
    QUADLET NodeAndLoginId;
    OCTLET  EUI64;
} QUERY_RESPONSE_ELEMENT, *PQUERY_RESPONSE_ELEMENT;

typedef struct _QUERY_LOGIN_RESPONSE {
    QUADLET LengthAndNumLogins;
    QUERY_RESPONSE_ELEMENT Elements[4];
} QUERY_LOGIN_RESPONSE, *PQUERY_LOGIN_RESPONSE;

typedef struct _STATUS_FIFO_BLOCK {
    OCTLET AddressAndStatus;
    OCTLET Contents[3];
} STATUS_FIFO_BLOCK, *PSTATUS_FIFO_BLOCK;

#define SBP2_MIN_ORB_SIZE 32
#define SBP2_ORB_CDB_SIZE 12

#define SBP2_MAX_DIRECT_BUFFER_SIZE     (ULONG) (65536) // (64K - 1) max size for direct addressing buffer
#define SBP2_MAX_PAGE_SIZE              SBP2_MAX_DIRECT_BUFFER_SIZE

//
// MANAGEMENT Transactions
//

#define TRANSACTION_LOGIN 0x00
#define TRANSACTION_QUERY_LOGINS 0x01
#define TRANSACTION_ISOCHRONOUS_LOGIN 0x02
#define TRANSACTION_RECONNECT 0x03
#define TRANSACTION_SET_PASSWORD        0x04
#define TRANSACTION_LOGOUT 0x07
#define TRANSACTION_TERMINATE_TASK 0x0b
#define TRANSACTION_ABORT_TASK 0x0b
#define TRANSACTION_ABORT_TASK_SET 0x0c
#define TRANSACTION_CLEAR_TASK_SET 0x0D
#define TRANSACTION_LOGICAL_UNIT_RESET 0x0E
#define TRANSACTION_TARGET_RESET 0x0F


#define MANAGEMENT_AGENT_REG_ADDRESS_LOW 0xF0010000
#define CSR_REG_ADDRESS_LOW 0xF0010000

//
// Register Names
//
#define MANAGEMENT_AGENT_REG    0x0000
#define AGENT_STATE_REG         0x0001
#define AGENT_RESET_REG         0x0002
#define ORB_POINTER_REG         0x0004
#define DOORBELL_REG            0x0008
#define UNSOLICITED_STATUS_REG  0x0010
#define CORE_RESET_REG          0x0020
#define CORE_BUSY_TIMEOUT_REG   0x0040
#define TEST_REG                0x0080

//
// register access type
//
#define REG_WRITE_SYNC          0x0100
#define REG_READ_SYNC           0x0200
#define REG_WRITE_ASYNC         0x0400

#define REG_TYPE_MASK           0x00FF



//
// Relative offsets from base of Target's CSR
//

#define AGENT_STATE_REG_OFFSET      0x00
#define AGENT_RESET_REG_OFFSET      0x04
#define ORB_POINTER_REG_OFFSET      0x08
#define DOORBELL_REG_OFFSET         0x10
#define UNSOLICITED_STATUS_REG_OFFSET   0x14
#define TEST_REG_OFFSET             0x10020

//
// config rom stuff
//

#define CR_BASE_ADDRESS_LOW 0xF0000400
#define CR_MODULE_ID_OFFSET (0x06 * sizeof(QUADLET))
#define CSR_OFFSET_KEY_SIGNATURE 0x54
#define LUN_CHARACTERISTICS_KEY_SIGNATURE 0x3A
#define FIRMWARE_REVISION_KEY_SIGNATURE 0x3C
#define LUN_KEY_SIGNATURE 0x14
#define LU_DIRECTORY_KEY_SIGNATURE 0xD4
#define SW_VERSION_KEY_SIGNATURE 0x13
#define CMD_SET_ID_KEY_SIGNATURE 0x39
#define CMD_SET_SPEC_ID_KEY_SIGNATURE 0x38

#define SBP2_LUN_DEVICE_TYPE_MASK 0x00FF0000

#define SBP2_PHY_RESET_SETTLING_TIME (-10000000 * 1) // 1 sec in units of 100 nsecs


#define SCSI_COMMAND_SET_ID 0x0104D8

//
// vendor hacks
//

#define LSI_VENDOR_ID   0x0000A0B8


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sbp2port\debug.h ===
/*++

Copyright (C) 1999-2002  Microsoft Corporation

Module Name:

    debug.h

Abstract

    SBP2 Protocol Driver

Author:

    Peter Binder

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
11/11/1999 pbinder   created
04/10/2000 pbinder   cleanup for whistler
01/13/2002 pbinder   taken for sbp2port
--*/

#if DBG

#define _DRIVERNAME_        "SBP2PORT"

#define TL_MASK             0xF0000000
#define TL_INFO             0x10000000
#define TL_TRACE            0x20000000
#define TL_WARNING          0x40000000
#define TL_ERROR            0x80000000

#define TL_PNP_MASK         0x0000000F
#define TL_PNP_INFO         0x00000001
#define TL_PNP_TRACE        0x00000002
#define TL_PNP_WARNING      0x00000004
#define TL_PNP_ERROR        0x00000008

#define TL_1394_MASK        0x000000F0
#define TL_1394_INFO        0x00000010
#define TL_1394_TRACE       0x00000020
#define TL_1394_WARNING     0x00000040
#define TL_1394_ERROR       0x00000080

#define TL_SCSI_MASK        0x00000F00
#define TL_SCSI_INFO        0x00000100
#define TL_SCSI_TRACE       0x00000200
#define TL_SCSI_WARNING     0x00000400
#define TL_SCSI_ERROR       0x00000800

#define DEFAULT_DEBUG_LEVEL 0x00000000

extern ULONG NewSbp2DebugLevel;
extern ULONG Sbp2TrapLevel;

#define TRACE( l, x )                       \
    if( (l) & NewSbp2DebugLevel ) {         \
        KdPrint( (_DRIVERNAME_ ": ") );     \
        KdPrint( x );                       \
        KdPrint( ("\n") );                  \
    }

#define TRAP                                            \
    if (Sbp2TrapLevel) {                                \
        TRACE( TL_ERROR,                                \
            ("Code coverage trap: file %s, line %d",    \
            __FILE__, __LINE__ ));                      \
        DbgBreakPoint();                                \
    }

#define BAD_POINTER     ((PVOID)0xFFFFFFFE)

#define ENTER(n)        TRACE(TL_TRACE, ("%s Enter", n))

#define EXIT(n,x)                                       \
    if (NT_SUCCESS(x)) {                                \
        TRACE(TL_TRACE, ("%s Exit = %x", n, x));        \
    } else {                                            \
        TRACE(TL_ERROR, ("%s Exit = %x", n, x));        \
    }

#else  // DBG

#define TRACE( l, x )
#define TRAP

#define ENTER(n)
#define EXIT(n,x)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sbp2port\prop.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2001

Module Name:

    prop.c

Abstract:

    This is the NT SBP2 port/filter driver.  This module contains code relating to
    property queries

Authors:

    georgioc

Environment:

    kernel mode only

Notes:

Revision History:

    georgioc    - grabbed this module from scsiport, since i needed to duplicate this functionality
                  in order to present sbp2port as a storage port

--*/

#include "sbp2port.h"
#include "stdio.h"

NTSTATUS
Sbp2BuildDeviceDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

NTSTATUS
Sbp2BuildAdapterDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );


NTSTATUS
Sbp2QueryProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    )

/*++

Routine Description:

    This routine will handle a property query request.  It will build the
    descriptor on it's own if possible, or it may forward the request down
    to lower level drivers.

    Since this routine may forward the request downwards the caller should
    not complete the irp

    This routine is asynchronous.
    This routine must be called at <= IRQL_DISPATCH

Arguments:

    DeviceObject - a pointer to the device object being queried

    QueryIrp - a pointer to the irp for the query

Return Value:

    STATUS_PENDING if the request cannot be completed yet
    STATUS_SUCCESS if the query was successful

    STATUS_INVALID_PARAMETER_1 if the property id does not exist
    STATUS_INVALID_PARAMETER_2 if the query type is invalid
    STATUS_INVALID_PARAMETER_3 if an invalid optional parameter was passed

    STATUS_INVALID_DEVICE_REQUEST if this request cannot be handled by this
    device

    other error values as applicable

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(QueryIrp);

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PSTORAGE_PROPERTY_QUERY query = QueryIrp->AssociatedIrp.SystemBuffer;
    ULONG queryLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    NTSTATUS status;

    //
    // We don't handle mask queries yet
    //

    if (query->QueryType >= PropertyMaskQuery) {

        status = STATUS_INVALID_PARAMETER_1;
        QueryIrp->IoStatus.Status = status;
        QueryIrp->IoStatus.Information = 0;
        IoCompleteRequest(QueryIrp, IO_NO_INCREMENT);
        return status;
    }

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);

    if (!NT_SUCCESS (status)) {

        QueryIrp->IoStatus.Status = status;
        QueryIrp->IoStatus.Information = 0;
        IoCompleteRequest(QueryIrp, IO_NO_INCREMENT);
        return status;
    }

    switch (query->PropertyId) {

        case StorageDeviceProperty:

            if (query->QueryType == PropertyExistsQuery) {

                status = STATUS_SUCCESS;

            } else {

                status = Sbp2BuildDeviceDescriptor(
                            DeviceObject,
                            QueryIrp->AssociatedIrp.SystemBuffer,
                            &queryLength);

                QueryIrp->IoStatus.Information = queryLength;
            }

            break;

        case StorageAdapterProperty:

            //
            // Although we are a filter, we are essentially presenting the
            // 1394 bus driver as a Port driver, so this is handled here
            //

            if (query->QueryType == PropertyExistsQuery) {

                status = STATUS_SUCCESS;

            } else {

                status = Sbp2BuildAdapterDescriptor(
                            DeviceObject,
                            QueryIrp->AssociatedIrp.SystemBuffer,
                            &queryLength);

                QueryIrp->IoStatus.Information = queryLength;
            }

            break;

        default:

            //
            // Nope, this property really doesn't exist
            //

            status = STATUS_INVALID_PARAMETER_1;
            QueryIrp->IoStatus.Information = 0;
            break;
    }

    QueryIrp->IoStatus.Status = status;
    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
    IoCompleteRequest (QueryIrp, IO_DISK_INCREMENT);

    return status;
}

NTSTATUS
Sbp2BuildDeviceDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )

/*++

Routine Description:

    This routine will create a device descriptor based on the information in
    it's device extension.  It will copy as much data as possible into
    the Descriptor and will update the DescriptorLength to indicate the
    number of bytes copied

Arguments:

    DeviceObject - a pointer to the PDO we are building a descriptor for

    Descriptor - a buffer to store the descriptor in

    DescriptorLength - the length of the buffer and the number of bytes
                       returned

    QueryIrp - unused

Return Value:

    status

--*/

{
    LONG    maxLength = *DescriptorLength;
    LONG    bytesRemaining = maxLength;
    ULONG   realLength = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    ULONG   infoLength;
    PUCHAR  currentOffset = (PUCHAR) Descriptor;

    PINQUIRYDATA                inquiryData;
    PDEVICE_EXTENSION           deviceExtension =DeviceObject->DeviceExtension;
    STORAGE_DEVICE_DESCRIPTOR   tmp;

    inquiryData = &deviceExtension->InquiryData;

    //
    // The info includes VendorId, ProductId, ProductRevsisionLevel,
    // and (sprintf'd) EUI64 strings, plus ascii NULL terminators for each
    //

    infoLength =
        sizeof (inquiryData->VendorId) + 1 +
        sizeof (inquiryData->ProductId) + 1 +
        sizeof (inquiryData->ProductRevisionLevel) + 1 +
        16 + 1;

    realLength += infoLength;

    RtlZeroMemory (Descriptor, maxLength);

    //
    // Build the device descriptor structure on the stack then copy as much as
    // can be copied over
    //

    RtlZeroMemory (&tmp, sizeof (STORAGE_DEVICE_DESCRIPTOR));

    tmp.Version = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    tmp.Size = realLength;

    tmp.DeviceType = deviceExtension->InquiryData.DeviceType;

    tmp.DeviceTypeModifier = 0;

    if (deviceExtension->InquiryData.RemovableMedia ||
        (tmp.DeviceType == READ_ONLY_DIRECT_ACCESS_DEVICE)) {

        tmp.RemovableMedia = TRUE;
        DeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;

    } else {

        //
        // default case, if INQUIRY failed..
        //

        tmp.RemovableMedia = FALSE;
    }

    tmp.BusType = BusType1394;

    //
    // always true for sbp2 targets
    //

    tmp.CommandQueueing = TRUE;

    RtlCopyMemory(
        currentOffset,
        &tmp,
        min (sizeof (STORAGE_DEVICE_DESCRIPTOR), bytesRemaining)
        );

    bytesRemaining -= sizeof (STORAGE_DEVICE_DESCRIPTOR);

    if (bytesRemaining <= 0) {

        return STATUS_SUCCESS;
    }

    currentOffset += sizeof (STORAGE_DEVICE_DESCRIPTOR);

    //
    // If our inquiry buffer is empty, make up some strings...
    //

    if (deviceExtension->InquiryData.VendorId[0] == 0) {

        sprintf (inquiryData->VendorId, "Vendor");
        sprintf (inquiryData->ProductId, "Sbp2");
        sprintf (inquiryData->ProductRevisionLevel, "1.0");
    }

    //
    // First the vendor id + NULL
    //

    if (bytesRemaining <= sizeof (inquiryData->VendorId)) {

        return STATUS_SUCCESS;
    }

    RtlCopyMemory(
        currentOffset,
        inquiryData->VendorId,
        sizeof (inquiryData->VendorId)
        );

    Descriptor->VendorIdOffset = (ULONG)
        ((ULONG_PTR) currentOffset - (ULONG_PTR) Descriptor);

    bytesRemaining -= sizeof (inquiryData->VendorId) + sizeof (UCHAR);

    currentOffset += sizeof (inquiryData->VendorId) + sizeof (UCHAR);

    //
    // Now the product id + NULL
    //

    if (bytesRemaining <= sizeof (inquiryData->ProductId)) {

        return STATUS_SUCCESS;
    }

    RtlCopyMemory(
        currentOffset,
        inquiryData->ProductId,
        sizeof (inquiryData->ProductId)
        );

    Descriptor->ProductIdOffset = (ULONG)
        ((ULONG_PTR) currentOffset - (ULONG_PTR) Descriptor);

    bytesRemaining -= sizeof (inquiryData->ProductId) + sizeof (UCHAR);

    currentOffset += sizeof (inquiryData->ProductId) + sizeof (UCHAR);

    //
    // Now the product revision + NULL
    //

    if (bytesRemaining <= sizeof (inquiryData->ProductRevisionLevel)) {

        return STATUS_SUCCESS;
    }

    RtlCopyMemory(
        currentOffset,
        inquiryData->ProductRevisionLevel,
        sizeof (inquiryData->ProductRevisionLevel)
        );

    Descriptor->ProductRevisionOffset = (ULONG)
        ((ULONG_PTR) currentOffset - (ULONG_PTR) Descriptor);

    bytesRemaining -=
        sizeof (inquiryData->ProductRevisionLevel) + sizeof (UCHAR);

    currentOffset +=
        sizeof (inquiryData->ProductRevisionLevel) + sizeof (UCHAR);

    //
    // And finally the device serial number (use the UniqueId
    // converted from binary to string format) + NULL
    //

    if (bytesRemaining <= 16) {

        return STATUS_SUCCESS;
    }

    sprintf(
        currentOffset,
        "%08x%08x",
        deviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[0],
        deviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[1]
        );

    Descriptor->SerialNumberOffset = (ULONG)
        ((ULONG_PTR) currentOffset - (ULONG_PTR) Descriptor);

    *DescriptorLength = realLength;

    return STATUS_SUCCESS;
}


NTSTATUS
Sbp2BuildAdapterDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    STORAGE_ADAPTER_DESCRIPTOR tmp;
    ULONG realLength;

    realLength = sizeof(STORAGE_ADAPTER_DESCRIPTOR);

    tmp.Version = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
    tmp.Size = sizeof(STORAGE_ADAPTER_DESCRIPTOR);

    if (*DescriptorLength < realLength ) {

        RtlCopyMemory (Descriptor,&tmp,*DescriptorLength);
        return STATUS_SUCCESS;
    }

    tmp.MaximumTransferLength = deviceExtension->DeviceInfo->MaxClassTransferSize;
    tmp.MaximumPhysicalPages = tmp.MaximumTransferLength/PAGE_SIZE ;

    tmp.AlignmentMask = SBP2_ALIGNMENT_MASK;

    tmp.AdapterUsesPio = FALSE;
    tmp.AdapterScansDown = FALSE;
    tmp.CommandQueueing = TRUE;
    tmp.AcceleratedTransfer = TRUE;

    tmp.BusType = BusType1394;
    tmp.BusMajorVersion = 1;
    tmp.BusMinorVersion = 0;

    RtlCopyMemory(Descriptor,
                  &tmp,
                  sizeof(STORAGE_ADAPTER_DESCRIPTOR));

    *DescriptorLength =  sizeof(STORAGE_ADAPTER_DESCRIPTOR);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sbp2port\sbp2port.c ===
/*++


Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    sbp2port.c

Abstract:

    Main module for the SBP-2 port driver

    Author:

    George Chrysanthakopoulos January-1997

Environment:

    Kernel mode

Revision History :

--*/

#include "sbp2port.h"
#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"


#if DBG
ULONG Sbp2DebugLevel = 0;

ULONG NewSbp2DebugLevel = DEFAULT_DEBUG_LEVEL;
ULONG Sbp2TrapLevel = FALSE;
#endif

BOOLEAN SystemIsNT;


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
Sbp2AddDevice(
    PDRIVER_OBJECT  DriverObject,
    PDEVICE_OBJECT  Pdo
    );

NTSTATUS
Sbp2StartDevice(
    IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS
Sbp2CreateDeviceRelations(
    IN PFDO_DEVICE_EXTENSION FdoExtension,
    IN PDEVICE_RELATIONS DeviceRelations
    );

NTSTATUS
Sbp2CreateDevObject(
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           Pdo
    );

NTSTATUS
Sbp2DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Sbp2CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Sbp2PnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
Sbp2FDOPnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
Sbp2CreatePdo(
    IN PFDO_DEVICE_EXTENSION FdoExtension,
    IN PDEVICE_INFORMATION DeviceInfo,
    ULONG instanceNum
    );

NTSTATUS
Sbp2PowerControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
Sbp2SystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
Sbp2FdoRequestCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );


VOID
Sbp2Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
Sbp2_BuildDeviceId(
    IN PDEVICE_INFORMATION  DeviceInfo,
    IN OUT PUNICODE_STRING  uniDeviceId
    );

NTSTATUS
Sbp2_BuildHardwareIds(
    IN PDEVICE_INFORMATION  DeviceInfo,
    IN OUT PUNICODE_STRING  uniHardwareIds
    );

NTSTATUS
Sbp2_BuildCompatIds(
    IN PDEVICE_INFORMATION  DeviceInfo,
    IN OUT PUNICODE_STRING  uniCompatIds
    );

NTSTATUS
Sbp2_BuildInstanceId(
    IN PDEVICE_INFORMATION  DeviceInfo,
    IN OUT PUNICODE_STRING  uniInstanceId
    );

NTSTATUS
Sbp2_BuildDeviceText(
    IN DEVICE_TEXT_TYPE     TextType,
    IN PDEVICE_INFORMATION  DeviceInfo,
    IN OUT PUNICODE_STRING  uniDeviceText
    );

NTSTATUS
Sbp2ForwardIrpSynchronous(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
Sbp2PortForwardIrpSynchronousCompletionRoutine(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, Sbp2AddDevice)
#pragma alloc_text(PAGE, Sbp2StartDevice)
#pragma alloc_text(PAGE, Sbp2CreateDeviceRelations)
#pragma alloc_text(PAGE, Sbp2CreatePdo)
#pragma alloc_text(PAGE, Sbp2CreateDevObject)
#pragma alloc_text(PAGE, Sbp2DeviceControl)
#pragma alloc_text(PAGE, Sbp2SystemControl)
#pragma alloc_text(PAGE, Sbp2CreateClose)
#pragma alloc_text(PAGE, Sbp2ForwardIrpSynchronous)

#endif


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called at system initialization time so we can fill in the basic dispatch points

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS

--*/

{
    //
    // Initialize the Driver Object with driver's entry points
    //

    DEBUGPRINT2(("Sbp2Port: DriverEntry: %s %s\n", __DATE__, __TIME__));

    DriverObject->MajorFunction[IRP_MJ_CREATE] = Sbp2CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = Sbp2CreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = Sbp2DeviceControl;

    DriverObject->MajorFunction[IRP_MJ_SCSI] = Sbp2ScsiRequests;

    DriverObject->DriverExtension->AddDevice = Sbp2AddDevice;
    DriverObject->MajorFunction[IRP_MJ_PNP] = Sbp2PnpDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP_POWER] = Sbp2PnpDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_POWER] = Sbp2PowerControl;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = Sbp2SystemControl;

    DriverObject->DriverStartIo = Sbp2StartIo;
    DriverObject->DriverUnload = Sbp2Unload;

    SystemIsNT = IoIsWdmVersionAvailable ((UCHAR)0x01, (UCHAR)0x10);

    return STATUS_SUCCESS;
}


NTSTATUS
Sbp2AddDevice(
    PDRIVER_OBJECT  DriverObject,
    PDEVICE_OBJECT  Pdo
    )

/*++

Routine Description:

    This is our PNP AddDevice called with the PDO ejected from the bus driver

Arguments:

    Argument1          - Driver Object.
    Argument2          - PDO.


Return Value:

    A valid return code for a DriverEntry routine.

--*/

{
    return (Sbp2CreateDevObject (DriverObject,Pdo));
}


NTSTATUS
Sbp2CreateDevObject(
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           Pdo
    )
/*++

Routine Description:

    This routine creates an object for the physical device specified and
    sets up the deviceExtension.

Arguments:

    DriverObject - Pointer to driver object created by system.

    PhysicalDeviceObject = PDO we should attach to.


Return Value:

    NTSTATUS

--*/
{
    PFDO_DEVICE_EXTENSION deviceExtension;
    NTSTATUS       status;
    PDEVICE_OBJECT deviceObject = NULL;

    UNICODE_STRING uniDeviceName;

    WCHAR buffer[64];
    UNICODE_STRING unicodeDirectoryName;
    HANDLE handle;
    OBJECT_ATTRIBUTES objectAttributes;

    ULONG NextId = 0;

    //
    // This is the sbp2 filter device object and name
    //

    do {

        swprintf (buffer, L"\\Device\\Sbp2Port%x", NextId);

        RtlInitUnicodeString (&uniDeviceName, buffer);

        status = IoCreateDevice(DriverObject,
                                sizeof(FDO_DEVICE_EXTENSION),
                                &uniDeviceName,
                                FILE_DEVICE_BUS_EXTENDER,
                                FILE_DEVICE_SECURE_OPEN,
                                FALSE,
                                &deviceObject);

        NextId++;

    } while (status == STATUS_OBJECT_NAME_COLLISION);

    if (!NT_SUCCESS(status)) {

        return status;
    }


    deviceExtension = deviceObject->DeviceExtension;
    RtlZeroMemory(deviceExtension,sizeof(FDO_DEVICE_EXTENSION));

    if (Pdo != NULL) {

        if ((deviceExtension->LowerDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject,Pdo))==NULL){

            IoDeleteDevice(deviceObject);
            return status;
        }
    }

    deviceExtension->Type = SBP2_FDO;
    deviceExtension->DeviceFlags = 0;
    deviceExtension->DeviceObject = deviceObject;
    deviceExtension->Pdo = Pdo;
    KeInitializeSpinLock(&deviceExtension->DeviceListLock);
    KeInitializeMutex (&deviceExtension->EnableBusResetNotificationMutex, 0);

    //
    // create a directory object for Sbp2 children devices
    //

    swprintf(buffer, L"\\Device\\Sbp2");

    RtlInitUnicodeString(&unicodeDirectoryName, buffer);

    InitializeObjectAttributes(&objectAttributes,
                               &unicodeDirectoryName,
                               OBJ_CASE_INSENSITIVE | OBJ_PERMANENT | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    status = ZwCreateDirectoryObject(&handle,
                                     DIRECTORY_ALL_ACCESS,
                                     &objectAttributes);


    if (NT_SUCCESS(status)) {

        deviceExtension->Sbp2ObjectDirectory = handle;

    } else {

        //
        // the directory is already created by another instance of this driver..
        //

        status = STATUS_SUCCESS;
    }

    ExInitializeFastMutex(&deviceExtension->ResetMutex);

    IoInitializeRemoveLock( &deviceExtension->RemoveLock,
                            '2pbS',
                            REMLOCK_TIMEOUT,
                            REMLOCK_HIGH_WATERMARK
                            );

#if DBG
    deviceExtension->ulWorkItemCount = 0;
    deviceExtension->ulBusResetMutexCount = 0;
#endif

    deviceObject->Flags |= DO_DIRECT_IO;
    deviceObject->Flags &=~DO_DEVICE_INITIALIZING;

    return status;
}


NTSTATUS
Sbp2CreatePdo(
    IN PFDO_DEVICE_EXTENSION FdoExtension,
    IN PDEVICE_INFORMATION DeviceInfo,
    ULONG InstanceNumber
    )
{
    PDEVICE_EXTENSION pdoExtension;
    DEVICE_TYPE devType;
    WCHAR *buffer;
    UNICODE_STRING uniDeviceName;
    NTSTATUS status;
    ULONG byteSwappedData;

    PAGED_CODE();

    switch (DeviceInfo->CmdSetId.QuadPart) {

    case 0x10483:
    case SCSI_COMMAND_SET_ID:

       switch ((DeviceInfo->Lun.u.HighPart & 0x001F)) {

       case PRINTER_DEVICE:

           devType = FILE_DEVICE_PRINTER;
           break;

       case SCANNER_DEVICE:

           devType = FILE_DEVICE_SCANNER;
           break;

       case READ_ONLY_DIRECT_ACCESS_DEVICE:
       case RBC_DEVICE:
       case DIRECT_ACCESS_DEVICE:
       default:

           devType = FILE_DEVICE_MASS_STORAGE;
           break;
       }

       break;

    default:

        devType = FILE_DEVICE_UNKNOWN;
        break;
    }

    buffer = ExAllocatePool(PagedPool,
                            5 * SBP2_MAX_TEXT_LEAF_LENGTH * sizeof (WCHAR)
                            );

    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (DeviceInfo->uniVendorId.Buffer && DeviceInfo->uniModelId.Buffer) {

        swprintf( buffer,
                  L"\\Device\\Sbp2\\%ws&%ws&%x&%08x_%08x_Instance%02d",
                  DeviceInfo->uniVendorId.Buffer,
                  DeviceInfo->uniModelId.Buffer,
                  DeviceInfo->Lun.u.LowPart,
                  bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[0]),
                  bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[1]),
                  InstanceNumber
                  );
    }
    else {

        swprintf( buffer,
                  L"\\Device\\Sbp2\\UNKNOWN_VENDOR&UNKNOWN_MODEL&%x&%08x_%08x_Instance%02d",
                  DeviceInfo->Lun.u.LowPart,
                  bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[0]),
                  bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[1]),
                  InstanceNumber
                  );
    }

    RtlInitUnicodeString (&uniDeviceName, buffer);

    //
    // Need to create a device object for this device
    //

    status = IoCreateDevice(
                FdoExtension->DeviceObject->DriverObject,
                sizeof(DEVICE_EXTENSION),
                &uniDeviceName,
                devType,
                0,
                FALSE,
                &DeviceInfo->DeviceObject
                );

    if (!NT_SUCCESS(status)) {

        ExFreePool (buffer);
        return status;
    }

    // only set alignment if it's less than we require
    if (DeviceInfo->DeviceObject->AlignmentRequirement < SBP2_ALIGNMENT_MASK)
        DeviceInfo->DeviceObject->AlignmentRequirement = SBP2_ALIGNMENT_MASK;

    pdoExtension = (PDEVICE_EXTENSION)DeviceInfo->DeviceObject->DeviceExtension;

    RtlZeroMemory(pdoExtension,sizeof(DEVICE_EXTENSION));

    pdoExtension->LowerDeviceObject = FdoExtension->LowerDeviceObject;
    pdoExtension->DeviceObject = DeviceInfo->DeviceObject;
    pdoExtension->Type = SBP2_PDO;
    pdoExtension->DeviceInfo = DeviceInfo;
    pdoExtension->DeviceInfo->MaxClassTransferSize = FdoExtension->MaxClassTransferSize;
    pdoExtension->BusFdo = FdoExtension->DeviceObject;

#if DBG
    pdoExtension->ulPendingEvents = 0;
    pdoExtension->ulInternalEventCount = 0;
#endif

    KeInitializeSpinLock (&pdoExtension->ExtensionDataSpinLock);

    IoInitializeRemoveLock(
        &pdoExtension->RemoveLock,
        '2pbS',
        REMLOCK_TIMEOUT,
        REMLOCK_HIGH_WATERMARK
        );

    switch (DeviceInfo->CmdSetId.QuadPart) {

    case 0x10483:
    case SCSI_COMMAND_SET_ID:

        //
        // intepret device type only for scsi-variant command sets
        //
        // NOTE: sbp2port.h #define's MAX_GENERIC_NAME_LENGTH as 16
        //

        DeviceInfo->uniGenericName.Length = 0;
        DeviceInfo->uniGenericName.MaximumLength = MAX_GENERIC_NAME_LENGTH;
        DeviceInfo->uniGenericName.Buffer = ExAllocatePool(PagedPool, DeviceInfo->uniGenericName.MaximumLength);

        if (!DeviceInfo->uniGenericName.Buffer) {

            TRACE(TL_PNP_ERROR, ("Failed to allocate uniGenericName.Buffer!"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        RtlZeroMemory(DeviceInfo->uniGenericName.Buffer, DeviceInfo->uniGenericName.MaximumLength);

        switch ((DeviceInfo->Lun.u.HighPart & 0x001F)) {

        case RBC_DEVICE:
        case DIRECT_ACCESS_DEVICE:

            RtlAppendUnicodeToString(&DeviceInfo->uniGenericName, L"GenDisk");
            break;

        case SEQUENTIAL_ACCESS_DEVICE:

            RtlAppendUnicodeToString(&DeviceInfo->uniGenericName, L"GenSequential");
            break;

        case PRINTER_DEVICE:

            RtlAppendUnicodeToString(&DeviceInfo->uniGenericName, L"GenPrinter");
            break;

        case WRITE_ONCE_READ_MULTIPLE_DEVICE:

            RtlAppendUnicodeToString(&DeviceInfo->uniGenericName, L"GenWorm");
            break;

        case READ_ONLY_DIRECT_ACCESS_DEVICE:

            RtlAppendUnicodeToString(&DeviceInfo->uniGenericName, L"GenCdRom");
            break;

        case SCANNER_DEVICE:

            RtlAppendUnicodeToString(&DeviceInfo->uniGenericName, L"GenScanner");
            break;

        case OPTICAL_DEVICE:

            RtlAppendUnicodeToString(&DeviceInfo->uniGenericName, L"GenOptical");
            break;

        case MEDIUM_CHANGER:

            RtlAppendUnicodeToString(&DeviceInfo->uniGenericName, L"GenChanger");
            break;

        default:

            RtlAppendUnicodeToString(&DeviceInfo->uniGenericName, L"GenSbp2Device");
            break;
        }

        break;

    default:

        RtlAppendUnicodeToString(&DeviceInfo->uniGenericName, L"GenSbp2Device");
        break;
    }

    TRACE(TL_PNP_INFO, ("GenericName = %ws", DeviceInfo->uniGenericName.Buffer));

    DeviceInfo->DeviceObject->Flags |= DO_DIRECT_IO;

    status = Sbp2PreAllocateLists (pdoExtension);

    if (!NT_SUCCESS(status)) {

        IoDeleteDevice (pdoExtension->DeviceObject);
        DeviceInfo->DeviceObject = NULL;

    } else {

        PWCHAR symlinkBuffer;

        symlinkBuffer = ExAllocatePool(PagedPool,
                                3 * SBP2_MAX_TEXT_LEAF_LENGTH * sizeof (WCHAR)
                                );

        if (symlinkBuffer) {

            swprintf(
                symlinkBuffer,
                L"\\DosDevices\\Sbp2&LUN%x&%08x%08x&Instance%02d",
                DeviceInfo->Lun.u.LowPart,
                bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[0]),
                bswap(FdoExtension->ConfigRom.CR_Node_UniqueID[1]),
                InstanceNumber
                );

            RtlInitUnicodeString (&pdoExtension->UniSymLinkName,symlinkBuffer);

            status = IoCreateUnprotectedSymbolicLink(
                &pdoExtension->UniSymLinkName,
                &uniDeviceName
                );

            if (NT_SUCCESS (status)) {

                DEBUGPRINT2((
                    "Sbp2Port: CreatePdo: symLink=%ws\n",
                    symlinkBuffer
                    ));

            } else {

                DEBUGPRINT1((
                    "\nSbp2Port: CreatePdo: createSymLink err=x%x\n",
                    status
                    ));
            }

        } else {

            DEBUGPRINT1(("\n Sbp2CreatePdo: failed to alloc sym link buf\n"));
        }

        //
        // if sym link fails its not critical
        //

        status = STATUS_SUCCESS;
    }

    ExFreePool (buffer);

    DeviceInfo->DeviceObject->Flags &=~DO_DEVICE_INITIALIZING;
    return status;
}


NTSTATUS
Sbp2StartDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This is our START_DEVICE, called when we get an IPR_MN_START_DEVICE. Initializes the driver and
    retrieves physical device information and 1394 bus information required for accessing the device.

Arguments:

    DeviceObject = Sbp2 driver's device object

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION   deviceExtension=DeviceObject->DeviceExtension;
    PFDO_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG temp;
    BOOLEAN enabledBusResetNotification = FALSE;

    if (deviceExtension->Type == SBP2_PDO) {

#if PASSWORD_SUPPORT

        Sbp2GetExclusiveValue(DeviceObject, &deviceExtension->Exclusive);

#endif

        if (!TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZED)){

            //
            // initialize our device state flags
            //

            deviceExtension->DevicePowerState = PowerDeviceD0;
            deviceExtension->SystemPowerState = PowerSystemWorking;

            deviceExtension->MaxOrbListDepth = MAX_ORB_LIST_DEPTH;
        }

        deviceExtension->DeviceFlags = DEVICE_FLAG_PNP_STOPPED |
            DEVICE_FLAG_STOPPED | DEVICE_FLAG_INITIALIZING;

        //
        // Initiliaze the Timer and timeout DPC used for resets, reconnects and TASK functions
        //

        KeInitializeDpc(
            &deviceExtension->DeviceManagementTimeoutDpc,
            Sbp2DeviceManagementTimeoutDpc,
            deviceExtension
            );

        KeInitializeTimer(&deviceExtension->DeviceManagementTimer);

        KeInitializeSpinLock(&deviceExtension->OrbListSpinLock);
        KeInitializeSpinLock(&deviceExtension->ExtensionDataSpinLock);

        KeInitializeSpinLock(&deviceExtension->StatusFifoLock);
        KeInitializeSpinLock(&deviceExtension->FreeContextLock);
        KeInitializeSpinLock(&deviceExtension->BusRequestLock);

        ASSERT(!deviceExtension->ulPendingEvents);
        ASSERT(!deviceExtension->ulInternalEventCount);

#if DBG
        deviceExtension->ulPendingEvents = 0;
        deviceExtension->ulInternalEventCount = 0;
#endif

        //
        // Initialize our device Extension ORB's, status blocks, Irp and Irb's
        // Also allocate 1394 addresses for extension-held sbp2 ORB's
        //

        status = Sbp2InitializeDeviceExtension(deviceExtension);

        if (!NT_SUCCESS(status)) {

            goto exitStartDevice;
        }

        DEBUGPRINT2(("\nSbp2Port: StartDev: cmd set id=x%x\n", deviceExtension->DeviceInfo->CmdSetId.QuadPart));

        switch (deviceExtension->DeviceInfo->CmdSetId.QuadPart) {

        case 0x0:
        case 0x10483:
        case SCSI_COMMAND_SET_ID:

            SET_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_SPC_CMD_SET);

            DEBUGPRINT2(("Sbp2Port: StartDev: enabling SPC cmd set\n"));

            break;
        }

        //
        // login
        //

        status = Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGIN);

        if (!NT_SUCCESS(status)) {

            DEBUGPRINT1(("\nSbp2StartDev: Login failed with %x, retrying\n",status));

            if (status == STATUS_ACCESS_DENIED) {

                //
                // retry the login. By now we should have access since our bus reset forced a logout
                //

                Sbp2ManagementTransaction(deviceExtension,TRANSACTION_QUERY_LOGINS);
            }

            temp = 0;

            do {

                //
                // Give things time (one second) to settle...
                //

                LARGE_INTEGER waitValue;

                ASSERT(InterlockedIncrement(&deviceExtension->ulPendingEvents) == 1);

                KeInitializeEvent(&deviceExtension->ManagementEvent, NotificationEvent, FALSE);

                waitValue.QuadPart = -1 * 1000 * 1000 * 10;

                KeWaitForSingleObject(&deviceExtension->ManagementEvent,Executive,KernelMode,FALSE,&waitValue);

                ASSERT(InterlockedDecrement(&deviceExtension->ulPendingEvents) == 0);

                //
                // all the resident 1394 memory addresses's that we have, are
                // now invalidated... So we need to free them and re-allocate
                // them

                Sbp2CleanDeviceExtension (deviceExtension->DeviceObject,FALSE);

                Sbp2InitializeDeviceExtension(deviceExtension);

                status = Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGIN);

                temp ++;

                //
                // Note: We get STATUS_REQUEST_ABORTED rather than
                //       STATUS_INVALID_GENERATION at passive level,
                //       so check for that instead
                //

            } while ((status == STATUS_REQUEST_ABORTED) &&
                     (temp <= 3));

            if (!NT_SUCCESS(status)) {

                goto exitStartDevice;
            }
        }

#if PASSWORD_SUPPORT

        if (deviceExtension->Exclusive & EXCLUSIVE_FLAG_ENABLE) {

            status = Sbp2SetPasswordTransaction(
                deviceExtension,
                SBP2REQ_SET_PASSWORD_EXCLUSIVE
                );

            if (NT_SUCCESS(status)) {

                deviceExtension->Exclusive = EXCLUSIVE_FLAG_SET;

            } else {

                deviceExtension->Exclusive = EXCLUSIVE_FLAG_CLEAR;
            }

            Sbp2SetExclusiveValue(
                deviceExtension->DeviceObject,
                &deviceExtension->Exclusive
                );
        }

#endif

        //
        // We are ready to receive and pass down requests, init the target's
        // fetch agent. The value we write to it is not important
        //

        Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,AGENT_RESET_REG | REG_WRITE_SYNC);

        //
        // enable unsolicited status reg
        //

        Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,UNSOLICITED_STATUS_REG | REG_WRITE_SYNC);

        CLEAR_FLAG(
            deviceExtension->DeviceFlags,
            (DEVICE_FLAG_PNP_STOPPED | DEVICE_FLAG_STOPPED)
            );

        //
        // register for idle detection
        //

        deviceExtension->IdleCounter = PoRegisterDeviceForIdleDetection(DeviceObject,
                                                                        -1,
                                                                        -1,
                                                                        PowerDeviceD3);

        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZING );
        SET_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZED);

        //
        // OK to register for bus reset notifications now
        //

        if (!Sbp2EnableBusResetNotification (deviceExtension, TRUE)) {

            SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED);
            CleanupOrbList (deviceExtension, STATUS_REQUEST_ABORTED);
            Sbp2ManagementTransaction (deviceExtension, TRANSACTION_LOGOUT);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitStartDevice;
        }

        enabledBusResetNotification = TRUE;


        if (TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_SPC_CMD_SET)) {

            //
            // issue an Inquiry to the target...
            //

            status = Sbp2IssueInternalCommand (deviceExtension,SCSIOP_INQUIRY);

            if (NT_SUCCESS(status)) {

                DEBUGPRINT2((
                    "Sbp2Port: StartDev: cfgRom devType=x%x, inq devType=x%x\n",
                    (deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F),
                    deviceExtension->InquiryData.DeviceType
                    ));

            } else if ((status == STATUS_DEVICE_DOES_NOT_EXIST) ||
                       (status == STATUS_DEVICE_BUSY)) {

                //
                // In win2k if the inquiry failed we'd just turn off the
                // SPC_CMD_SET flag and trundle on like nothing happened.
                //
                // However, we found some devices would allow logins but
                // nothing else, like a powered-down mactell hd which would
                // allow us to login but fail all other requests.  This
                // really caused problems in win9x because Ntmap would
                // get loaded, but not init'd correctly, and on subsequent
                // re-plugs of any device we'd see trap 14's and the like.
                // So, it really makes alot more sense to just nip this
                // in the bud and fail the start if we get an error back
                // from the inquiry that tells us (per Sbp2ScsiRequests())
                // that the device has been removed or it timed out the 1st
                // inquiry .  DanKn, 7 Apr 2000
                //

                DEBUGPRINT1((
                    "\nSbp2Port: StartDev: ext=x%p, fatal INQUIRY err=x%x, " \
                        "log out\n",
                    deviceExtension,
                    status
                    ));

                Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGOUT);
                status = STATUS_IO_DEVICE_ERROR;
                goto exitStartDevice;

            } else {

                CLEAR_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_SPC_CMD_SET
                    );

                DEBUGPRINT1((
                    "\nSbp2Port: StartDev: ext=x%p, non-fatal INQUIRY err=x%x\n",
                    deviceExtension,
                    status
                    ));

                status = STATUS_SUCCESS;
            }
        }

        if (deviceExtension->InquiryData.DeviceType != (deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F)){

            deviceExtension->InquiryData.DeviceType = (deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F);
            DEBUGPRINT1(("\nSbp2StartDev: DeviceType mismatch, using one in ConfigRom %x\n",
                           (deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F)));
        }

        //
        // if this is a scanner or a printer we dont need to remain logged on..
        //

        if ((deviceExtension->InquiryData.DeviceType == PRINTER_DEVICE) ||
            (deviceExtension->InquiryData.DeviceType == SCANNER_DEVICE)){

            if (NT_SUCCESS(status)) {

                SET_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED);
                CleanupOrbList(deviceExtension,STATUS_REQUEST_ABORTED);

                Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGOUT);
            }

        } else if (deviceExtension->InquiryData.DeviceType == RBC_DEVICE) {

            if (NT_SUCCESS(status)) {

                //
                // retrieve the RBC device mode page
                //

                status = Sbp2IssueInternalCommand(deviceExtension,SCSIOP_MODE_SENSE);

                if (!NT_SUCCESS(status)) {

                    DEBUGPRINT1(("\nSbp2StartDev: Failed to retrieve RBC mode page\n"));
                    goto exitStartDevice;

                }
            }
        }

exitStartDevice:

        if (!NT_SUCCESS(status)) {

            PIO_ERROR_LOG_PACKET errorLogEntry;
            ULONG errorId = __LINE__ ;


            errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceObject,sizeof(IO_ERROR_LOG_PACKET));

            if(errorLogEntry != NULL) {

                errorLogEntry->ErrorCode = IO_ERR_DRIVER_ERROR;
                errorLogEntry->UniqueErrorValue = errorId;
                errorLogEntry->FinalStatus = status;
                errorLogEntry->DumpDataSize = 0;
                IoWriteErrorLogEntry(errorLogEntry);
            }

            DEBUGPRINT1((
                "Sbp2Port: StartDev: FAILED, status=x%x\n",
                status
                ));

            SET_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_PNP_STOPPED | DEVICE_FLAG_DEVICE_FAILED)
                );

            if (enabledBusResetNotification) {

                Sbp2EnableBusResetNotification (deviceExtension, FALSE);
            }

        } else {

            if (!SystemIsNT) {

                DeviceObject->Flags |= DO_POWER_PAGABLE;

            } else {

                DeviceObject->Flags &= ~DO_POWER_PAGABLE;
            }
        }

    } else if (deviceExtension->Type == SBP2_FDO){

        //
        // Bus driver FDO start device
        // retrieve parameters from the registry, if present
        //

        fdoExtension->MaxClassTransferSize = SBP2_MAX_TRANSFER_SIZE;
        DEBUGPRINT2(("Sbp2Port: StartDev: maxXferSize=x%x\n", fdoExtension->MaxClassTransferSize ));

        fdoExtension->DevicePowerState = PowerDeviceD0;
        fdoExtension->SystemPowerState = PowerSystemWorking;

        deviceExtension->DeviceFlags=DEVICE_FLAG_INITIALIZED;
        status = STATUS_SUCCESS;

    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

    return status;
}


NTSTATUS
Sbp2PreAllocateLists(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Initializes all the single linked workhorse lists plus lookasides. Only called from AddDevice or after
    a REMOVE -> START

Arguments:

    DeviceExtension = Sbp2 driver's extension

Return Value:

    NTSTATUS

--*/
{
    ULONG                   cnt ;
    PIRBIRP                 packet;
    NTSTATUS                status;
    PADDRESS_FIFO           statusFifoElement ;
    PSTATUS_FIFO_BLOCK      statusFifo;
    PASYNC_REQUEST_CONTEXT  context;


    //
    // initialize all interlocked lists
    //

    SET_FLAG(
        DeviceExtension->DeviceFlags,
        (DEVICE_FLAG_INITIALIZING | DEVICE_FLAG_STOPPED |
            DEVICE_FLAG_PNP_STOPPED)
        );

    InitializeListHead(&DeviceExtension->PendingOrbList);

    // BUGBUG: Some of these should be changed to lookaside lists
    ExInitializeSListHead(&DeviceExtension->FreeContextListHead);
    ExInitializeSListHead(&DeviceExtension->BusRequestIrpIrbListHead);
    ExInitializeSListHead(&DeviceExtension->StatusFifoListHead);

    // init bus request context pool
    ExInitializeNPagedLookasideList( &DeviceExtension->BusRequestContextPool,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(REQUEST_CONTEXT),
                                     '2pbs',
                                     0
                                     );

    KeInitializeSpinLock(&DeviceExtension->OrbListSpinLock);
    KeInitializeSpinLock(&DeviceExtension->ExtensionDataSpinLock);

    KeInitializeSpinLock(&DeviceExtension->StatusFifoLock);
    KeInitializeSpinLock(&DeviceExtension->FreeContextLock);
    KeInitializeSpinLock(&DeviceExtension->BusRequestLock);


    //
    // alloc the irb/irp and context slists
    //

    for (cnt = 0; cnt < MAX_ORB_LIST_DEPTH; cnt++) {

        packet = ExAllocatePoolWithTag (NonPagedPool,sizeof(IRBIRP),'2pbs');

        if (!packet) {

            goto Sbp2PreAllocateLists_error;
        }

        packet->Irb = ExAllocatePoolWithTag (NonPagedPool,sizeof(IRB),'2pbs');

        if (!packet->Irb) {

            ExFreePool(packet);

            goto Sbp2PreAllocateLists_error;
        }

        packet->Irp = IoAllocateIrp (DeviceExtension->LowerDeviceObject->StackSize,FALSE);

        if (!packet->Irp) {

            ExFreePool(packet->Irb);
            ExFreePool(packet);

            goto Sbp2PreAllocateLists_error;
        }

        ExInterlockedPushEntrySList (&DeviceExtension->BusRequestIrpIrbListHead,
                                     &packet->ListPointer,
                                     &DeviceExtension->BusRequestLock);
    }

    //
    // status FIFO list
    //

    cnt = (sizeof(ADDRESS_FIFO)+sizeof(STATUS_FIFO_BLOCK))*NUM_PREALLOCATED_STATUS_FIFO_ELEMENTS;

    DeviceExtension->StatusFifoBase = \
        (PASYNC_REQUEST_CONTEXT) ExAllocatePoolWithTag(NonPagedPool,cnt,'2pbs');

    if (DeviceExtension->StatusFifoBase == NULL) {

        goto Sbp2PreAllocateLists_error;
    }

    for (cnt = 0; cnt < (NUM_PREALLOCATED_STATUS_FIFO_ELEMENTS - 1); cnt++) {

        statusFifoElement = (PADDRESS_FIFO) ((PUCHAR)DeviceExtension->StatusFifoBase + \
            cnt * (sizeof(ADDRESS_FIFO)+sizeof(STATUS_FIFO_BLOCK)));

        statusFifo = (PSTATUS_FIFO_BLOCK) ((PUCHAR)statusFifoElement + sizeof(ADDRESS_FIFO));

        //
        // make Mdl for this status fifo Element
        //

        statusFifoElement->FifoMdl = IoAllocateMdl(statusFifo,sizeof(STATUS_FIFO_BLOCK),FALSE,FALSE,NULL);

        if (statusFifoElement->FifoMdl == NULL) {

            goto Sbp2PreAllocateLists_error;
        }

        MmBuildMdlForNonPagedPool (statusFifoElement->FifoMdl);

        ExInterlockedPushEntrySList(&DeviceExtension->StatusFifoListHead,
                                    &statusFifoElement->FifoList,
                                    &DeviceExtension->StatusFifoLock);
    }


    //
    // Initialize the async request contexts (including page tables)
    //

    cnt = sizeof (ASYNC_REQUEST_CONTEXT) * MAX_ORB_LIST_DEPTH;

    DeviceExtension->AsyncContextBase = (PASYNC_REQUEST_CONTEXT)
        ExAllocatePoolWithTag (NonPagedPool, cnt, '2pbs');

    if (DeviceExtension->AsyncContextBase == NULL) {

        goto Sbp2PreAllocateLists_error;
    }

    RtlZeroMemory (DeviceExtension->AsyncContextBase, cnt);

    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        goto Sbp2PreAllocateLists_error;
    }

    for (cnt = 0; cnt < MAX_ORB_LIST_DEPTH; cnt++) {

        context = DeviceExtension->AsyncContextBase + cnt;

        context->Tag = SBP2_ASYNC_CONTEXT_TAG;

        //
        // Initialize the timeout DPC and timer
        //

        KeInitializeDpc(
            &context->TimerDpc,
            Sbp2RequestTimeoutDpc,
            DeviceExtension
            );

        KeInitializeTimer (&context->Timer);


        //
        // Alloc and/or map a page table
        //

        packet->Irb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;

        packet->Irb->u.AllocateAddressRange.nLength = PAGE_SIZE;
        packet->Irb->u.AllocateAddressRange.fulNotificationOptions =
            NOTIFY_FLAGS_NEVER;
        packet->Irb->u.AllocateAddressRange.fulAccessType =
            ACCESS_FLAGS_TYPE_READ;

        packet->Irb->u.AllocateAddressRange.fulFlags =
            ALLOCATE_ADDRESS_FLAGS_USE_COMMON_BUFFER;

        packet->Irb->u.AllocateAddressRange.Callback = NULL;
        packet->Irb->u.AllocateAddressRange.Context = NULL;

        packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_High = 0;
        packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_Low = 0;

        packet->Irb->u.AllocateAddressRange.FifoSListHead = NULL;
        packet->Irb->u.AllocateAddressRange.FifoSpinLock = NULL;

        packet->Irb->u.AllocateAddressRange.AddressesReturned = 0;
        packet->Irb->u.AllocateAddressRange.DeviceExtension = DeviceExtension;

        packet->Irb->u.AllocateAddressRange.Mdl =
            context->PageTableContext.AddressContext.RequestMdl;

        packet->Irb->u.AllocateAddressRange.MaxSegmentSize =
            (SBP2_MAX_DIRECT_BUFFER_SIZE) / 2;

        packet->Irb->u.AllocateAddressRange.p1394AddressRange =(PADDRESS_RANGE)
            &context->PageTableContext.AddressContext.Address;

        status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

        if (!NT_SUCCESS (status)) {

            DeAllocateIrpAndIrb (DeviceExtension, packet);
            goto Sbp2PreAllocateLists_error;
        }


        //
        // Common buffer allocations get an mdl *back* from the
        // bus/port driver, need to retrieve a corresponding VA
        //

        context->PageTableContext.AddressContext.RequestMdl =
            packet->Irb->u.AllocateAddressRange.Mdl;

        context->PageTableContext.PageTable = MmGetMdlVirtualAddress(
            packet->Irb->u.AllocateAddressRange.Mdl
            );

        context->PageTableContext.AddressContext.AddressHandle =
            packet->Irb->u.AllocateAddressRange.hAddressRange;
        context->PageTableContext.AddressContext.Address.BusAddress.NodeId =
            DeviceExtension->InitiatorAddressId;

        context->PageTableContext.MaxPages = SBP2_NUM_PAGE_TABLE_ENTRIES;


        //
        // add this context to the linked list
        //

        ExInterlockedPushEntrySList(
            &DeviceExtension->FreeContextListHead,
            &context->LookasideList,
            &DeviceExtension->FreeContextLock
            );
    }

    DeAllocateIrpAndIrb (DeviceExtension, packet);


    //
    // initialize the mdl used for quadlet requests to the port driver..
    //

    DeviceExtension->ReservedMdl = IoAllocateMdl(
        &DeviceExtension->Reserved,
        sizeof(QUADLET),
        FALSE,
        FALSE,
        NULL
        );

    if (!DeviceExtension->ReservedMdl) {

        goto Sbp2PreAllocateLists_error;
    }

    MmBuildMdlForNonPagedPool (DeviceExtension->ReservedMdl);

    return STATUS_SUCCESS;


Sbp2PreAllocateLists_error:

    Sbp2CleanDeviceExtension (DeviceExtension->DeviceObject, TRUE);

    return STATUS_INSUFFICIENT_RESOURCES;
}


NTSTATUS
Sbp2InitializeDeviceExtension(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Initializes all the data structures in our device extension, allocates appropriate 1394 addresses and workhorse
    Irps. It also creates a FreeList with pre-allocated contexts and command ORBs.

Arguments:

    DeviceExtension = Sbp2 driver's extension

Return Value:

    NTSTATUS

--*/

{
    ULONG                   i;
    KIRQL                   cIrql;
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject = DeviceExtension->DeviceObject;
    PASYNC_REQUEST_CONTEXT  context, oldContext;



    if (DeviceExtension->DeviceFlags & DEVICE_FLAG_REMOVED) {

        return STATUS_SUCCESS;
    }

    InitializeListHead(&DeviceExtension->PendingOrbList);

    DeviceExtension->NextContextToFree = NULL;

    DeviceExtension->OrbListDepth = 0;
    DeviceExtension->CurrentKey = 0;

    //
    // Get information volatile between bus resets
    //

    status = Sbp2UpdateNodeInformation (DeviceExtension);

    if (!NT_SUCCESS(status)) {

        goto exitInit;
    }


    //
    // get 1394 data transfer information
    //

    status = Sbp2GetControllerInfo (DeviceExtension);

    if (!NT_SUCCESS(status)) {

        goto exitInit;
    }


    //
    //
    // allocate a status block for the task ORB and a Management ORB
    //

    if (DeviceExtension->TaskOrbStatusContext.AddressHandle == NULL) {

        status = AllocateAddressForStatus(deviceObject,
                                          &DeviceExtension->TaskOrbStatusContext,
                                          TASK_STATUS_BLOCK);

        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }
    }

    if (DeviceExtension->ManagementOrbStatusContext.AddressHandle == NULL) {

        status = AllocateAddressForStatus(deviceObject,
                                      &DeviceExtension->ManagementOrbStatusContext,
                                      MANAGEMENT_STATUS_BLOCK);

        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }
    }

    if (DeviceExtension->GlobalStatusContext.AddressHandle == NULL) {

        //
        // setup the status FIFO list with the bus driver
        //

        status = AllocateAddressForStatus(deviceObject,
                                          &DeviceExtension->GlobalStatusContext,
                                          CMD_ORB_STATUS_BLOCK);
        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }
    }

#if PASSWORD_SUPPORT

    if (DeviceExtension->PasswordOrbStatusContext.AddressHandle == NULL) {

        status = AllocateAddressForStatus( deviceObject,
                                           &DeviceExtension->PasswordOrbStatusContext,
                                           PASSWORD_STATUS_BLOCK
                                           );

        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }
    }

    DeviceExtension->PasswordOrbContext.DeviceObject = deviceObject;

#endif

    //
    // Allocate a dummy,task, management ORBs and a login response ,which are going to be reused through out the drivers life...
    //

    DeviceExtension->TaskOrbContext.DeviceObject = deviceObject;
    DeviceExtension->ManagementOrbContext.DeviceObject = deviceObject;
    DeviceExtension->LoginRespContext.DeviceObject = deviceObject;
    DeviceExtension->QueryLoginRespContext.DeviceObject = deviceObject;

    KeInitializeEvent(&DeviceExtension->ManagementEvent,SynchronizationEvent, FALSE);

#if PASSWORD_SUPPORT

    // kevent for password orb context
    KeInitializeEvent(
        &DeviceExtension->PasswordEvent,
        SynchronizationEvent,
        FALSE
        );

#endif

    if (DeviceExtension->CommonBufferContext.AddressHandle == NULL) {

        status = AllocateSingle1394Address(
            deviceObject,
            NULL,
            sizeof (*DeviceExtension->CommonBuffer),
            ACCESS_FLAGS_TYPE_READ | ACCESS_FLAGS_TYPE_WRITE,
            &DeviceExtension->CommonBufferContext
            );

        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }

        (PVOID) DeviceExtension->CommonBuffer =
            DeviceExtension->CommonBufferContext.Reserved;


        DeviceExtension->TaskOrb = &DeviceExtension->CommonBuffer->TaskOrb;

        DeviceExtension->TaskOrbContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;


        DeviceExtension->ManagementOrb =
            &DeviceExtension->CommonBuffer->ManagementOrb;

        DeviceExtension->ManagementOrbContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;

        DeviceExtension->ManagementOrbContext.Address.BusAddress.Off_Low +=
            (ULONG) ((PUCHAR) DeviceExtension->ManagementOrb -
                (PUCHAR) DeviceExtension->CommonBuffer);


        DeviceExtension->LoginResponse =
            &DeviceExtension->CommonBuffer->LoginResponse;

        DeviceExtension->LoginRespContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;

        DeviceExtension->LoginRespContext.Address.BusAddress.Off_Low +=
            (ULONG) ((PUCHAR) DeviceExtension->LoginResponse -
                (PUCHAR) DeviceExtension->CommonBuffer);


        DeviceExtension->QueryLoginResponse =
            &DeviceExtension->CommonBuffer->QueryLoginResponse;

        DeviceExtension->QueryLoginRespContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;

        DeviceExtension->QueryLoginRespContext.Address.BusAddress.Off_Low +=
            (ULONG) ((PUCHAR) DeviceExtension->QueryLoginResponse -
                (PUCHAR) DeviceExtension->CommonBuffer);


#if PASSWORD_SUPPORT

        DeviceExtension->PasswordOrb =
            &DeviceExtension->CommonBuffer->PasswordOrb;

        DeviceExtension->PasswordOrbContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;

        DeviceExtension->PasswordOrbContext.Address.BusAddress.Off_Low +=
            (ULONG) ((PUCHAR) DeviceExtension->PasswordOrb -
                (PUCHAR) DeviceExtension->CommonBuffer);

#endif

        DeviceExtension->OrbPoolContext.Reserved =
            DeviceExtension->CommonBuffer->CmdOrbs;

        DeviceExtension->OrbPoolContext.Address.BusAddress =
            DeviceExtension->CommonBufferContext.Address.BusAddress;

        DeviceExtension->OrbPoolContext.Address.BusAddress.Off_Low +=
            (ULONG) ((PUCHAR) DeviceExtension->OrbPoolContext.Reserved -
                (PUCHAR) DeviceExtension->CommonBuffer);


        KeAcquireSpinLock (&DeviceExtension->OrbListSpinLock, &cIrql);

        //
        // Initialize our pool of contexts
        //

        for (i = 0, context = NULL; i < MAX_ORB_LIST_DEPTH; i++) {

            //
            // Mark this unused context as completed so if we had to
            // free our freelist now (because we got a remove) we wouldn't
            // try to complete its request
            //

            oldContext = context;

            context = (PVOID) ExInterlockedPopEntrySList (&DeviceExtension->FreeContextListHead,
                                                          &DeviceExtension->FreeContextLock);

            context = RETRIEVE_CONTEXT (context,LookasideList);

            context->Flags |= ASYNC_CONTEXT_FLAG_COMPLETED;

            //
            // Create a linked list so we push all the entries later
            //

            context->OrbList.Blink = (PLIST_ENTRY) oldContext;

            //
            // Each command ORB gets a small piece of our continuous pool
            // mapped into the 1394 memory space.  The sizeof(PVOID) bytes
            // before the cmdorb buffer are the pointer to its context.
            //

            context->CmdOrb = &DeviceExtension->CommonBuffer->CmdOrbs[i].Orb;

            DeviceExtension->CommonBuffer->CmdOrbs[i].AsyncReqCtx = context;

            context->CmdOrbAddress.BusAddress.Off_Low = \
                DeviceExtension->OrbPoolContext.Address.BusAddress.Off_Low +
                (i * sizeof (ARCP_ORB)) + FIELD_OFFSET (ARCP_ORB, Orb);

            context->CmdOrbAddress.BusAddress.Off_High = \
                DeviceExtension->OrbPoolContext.Address.BusAddress.Off_High;

            context->CmdOrbAddress.BusAddress.NodeId = \
                DeviceExtension->InitiatorAddressId;
        }

        //
        // re-create the free list
        //

        while (context) {

            oldContext = context;

            ExInterlockedPushEntrySList(&DeviceExtension->FreeContextListHead,
                                        &context->LookasideList,
                                        &DeviceExtension->FreeContextLock);

            context = (PASYNC_REQUEST_CONTEXT) oldContext->OrbList.Blink;

            oldContext->OrbList.Blink = NULL;
        }


        KeReleaseSpinLock (&DeviceExtension->OrbListSpinLock,cIrql);
    }

    //
    // Update the NodeId portion of the page table addr for each
    // ASYNC_REQUEST_CONTEXT and for the login/queryLogin responses
    //

    for (i = 0; i < MAX_ORB_LIST_DEPTH; i++) {

        context = DeviceExtension->AsyncContextBase + i;

        context->PageTableContext.AddressContext.Address.BusAddress.NodeId =
            DeviceExtension->InitiatorAddressId;
    }

    DeviceExtension->LoginRespContext.Address.BusAddress.NodeId =
        DeviceExtension->InitiatorAddressId;

    DeviceExtension->QueryLoginRespContext.Address.BusAddress.NodeId =
        DeviceExtension->InitiatorAddressId;


    //
    // Finally, allocate a dummy addr that we can easily free & realloc
    // to re-enable phyical addr filters after bus resets
    //

    if (DeviceExtension->DummyContext.AddressHandle == NULL) {

            status = AllocateSingle1394Address(
                deviceObject,
                &DeviceExtension->Dummy,
                sizeof(DeviceExtension->Dummy),
                ACCESS_FLAGS_TYPE_READ | ACCESS_FLAGS_TYPE_WRITE,
                &DeviceExtension->DummyContext
                );

        if (!NT_SUCCESS(status)) {

            goto exitInit;
        }
    }

    //
    // Done
    //

    DEBUGPRINT2(("Sbp2Port: InitDevExt: ext=x%p\n", DeviceExtension));

exitInit:

    return status;
}


BOOLEAN
Sbp2CleanDeviceExtension(
    IN PDEVICE_OBJECT DeviceObject,
    BOOLEAN FreeLists
    )
/*++

Routine Description:

    Called when we get a remove, so it will free all used pool and all the resident Irps.
    It wil also free our FreeList of contexts and any complete any pending IO requests

Arguments:

    DeviceExtension = Sbp2 driver's extension
    FreeLists - TRUE means we cleanup EVERYTHING including our lookaside lists

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PFDO_DEVICE_EXTENSION fdoExtension = (PFDO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL cIrql;
    PADDRESS_FIFO statusFifoElement;
    ULONG i;
    BOOLEAN valid = FALSE;
    PIRBIRP packet;

    //
    // there are two types of cleanups. One for the PDO and one for the FDO(alot simpler)
    //

    if (deviceExtension->Type == SBP2_PDO) {

        //
        // make sure that this PDO is something in our list and that we have NOT deleted
        // it already....
        //

        fdoExtension = (PFDO_DEVICE_EXTENSION) deviceExtension->BusFdo->DeviceExtension;

        for (i = 0; i < fdoExtension->DeviceListSize; i++) {

            if (fdoExtension->DeviceList[i].DeviceObject == DeviceObject) {

                valid = TRUE;
            }
        }

        if (!valid) {

            return FALSE;
        }

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZED) ){

            //
            // stop the timer for any pending management requests
            //

            KeCancelTimer (&deviceExtension->DeviceManagementTimer);

            //
            // We have a list of requests pending, clean it up
            // The reset/logout has automatically made the target to discard any requests
            //

            CleanupOrbList (deviceExtension, STATUS_REQUEST_ABORTED);
        }

        //
        // after a bus reset we must reallocate at least one physical address to allow
        // the ohci driver to re-enable the physical address filters
        //

        if (deviceExtension->DummyContext.AddressHandle != NULL) {

            FreeAddressRange (deviceExtension,&deviceExtension->DummyContext);
        }

        if (FreeLists){

            if (TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_INITIALIZED) ||
                TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_INITIALIZING)){

                FreeAddressRange(deviceExtension,&deviceExtension->TaskOrbStatusContext);
                FreeAddressRange(deviceExtension,&deviceExtension->GlobalStatusContext);
#if PASSWORD_SUPPORT
                FreeAddressRange(deviceExtension,&deviceExtension->PasswordOrbStatusContext);
#endif
                FreeAddressRange(deviceExtension,&deviceExtension->ManagementOrbStatusContext);

                if (deviceExtension->PowerDeferredIrp) {

                    deviceExtension->PowerDeferredIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
                    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                    IoCompleteRequest (deviceExtension->PowerDeferredIrp, IO_NO_INCREMENT);
                    deviceExtension->PowerDeferredIrp = NULL;
                }

                if (deviceExtension->DeferredPowerRequest) {

                    deviceExtension->DeferredPowerRequest->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
                    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                    IoCompleteRequest(deviceExtension->DeferredPowerRequest, IO_NO_INCREMENT);
                    deviceExtension->DeferredPowerRequest = NULL;
                }

                if (deviceExtension->UniSymLinkName.Buffer) {

                    IoDeleteSymbolicLink(&deviceExtension->UniSymLinkName);
                    RtlFreeUnicodeString(&deviceExtension->UniSymLinkName);
                    deviceExtension->UniSymLinkName.Buffer = NULL;
                }

                //
                // before we go any further, check if the device is physically removed
                //

                if (!TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED)) {

                    DEBUGPRINT2(("Sbp2Port: Cleanup: ext=x%p, not freeing ALL wkg sets, dev present\n", deviceExtension));
                    return TRUE;

                } else {

                    DEBUGPRINT2(("Sbp2Port: Cleanup: ext=x%p, freeing ALL wkg sets\n", deviceExtension));
                }

                CLEAR_FLAG(deviceExtension->DeviceFlags, (DEVICE_FLAG_INITIALIZED | DEVICE_FLAG_INITIALIZING));

                //
                // OK to free common buffer if device is going away
                //

                FreeAddressRange(deviceExtension,&deviceExtension->CommonBufferContext);

                deviceExtension->OrbPoolContext.Reserved = NULL;

                //
                // Free all the page tables & async context buffer
                //

                if (deviceExtension->AsyncContextBase != NULL) {

                    for (i = 0; i < MAX_ORB_LIST_DEPTH; i++) {

                        PASYNC_REQUEST_CONTEXT context;


                        context = deviceExtension->AsyncContextBase + i;

                        if (context->PageTableContext.PageTable != NULL) {

                            //
                            // Common buffer, we didn't alloc the mdl,
                            // so zero the field to prevent our free'ing it
                            //

                            context->PageTableContext.AddressContext.
                                RequestMdl = NULL;

                            FreeAddressRange(
                                deviceExtension,
                                &context->PageTableContext.AddressContext
                                );
                        }
                    }

                    ExFreePool (deviceExtension->AsyncContextBase);
                    deviceExtension->AsyncContextBase = NULL;
                }

                //
                // free pool for status fifo list
                //

                if (deviceExtension->StatusFifoBase !=NULL ) {

                    statusFifoElement = (PVOID) ExInterlockedPopEntrySList (&deviceExtension->StatusFifoListHead,
                                                                  &deviceExtension->StatusFifoLock);
                    while (statusFifoElement){

                        DEBUGPRINT3(("Sbp2Port: Cleanup: freeing statusFifo=x%p, fifoBase=x%p\n",
                                    statusFifoElement,deviceExtension->StatusFifoBase));

                        IoFreeMdl (statusFifoElement->FifoMdl);
                        statusFifoElement = (PVOID) ExInterlockedPopEntrySList (&deviceExtension->StatusFifoListHead,
                                                                  &deviceExtension->StatusFifoLock);
                    };

                    ExFreePool (deviceExtension->StatusFifoBase);
                    deviceExtension->StatusFifoBase = NULL;
                }

                //
                // free the irb/irp and context slists
                //

                packet = (PIRBIRP) ExInterlockedPopEntrySList (&deviceExtension->BusRequestIrpIrbListHead,
                                                               &deviceExtension->BusRequestLock);
                while (packet) {

                    ExFreePool(packet->Irb);

                    if (packet->Irp->Type == IO_TYPE_IRP) {

                        IoFreeIrp(packet->Irp);
                    }

                    ExFreePool(packet);

                    packet = (PIRBIRP) ExInterlockedPopEntrySList (&deviceExtension->BusRequestIrpIrbListHead,
                                                                   &deviceExtension->BusRequestLock);
                };


                // delete our bus request context lookaside list
                ExDeleteNPagedLookasideList(&deviceExtension->BusRequestContextPool);

                if (deviceExtension->ReservedMdl) {

                    IoFreeMdl (deviceExtension->ReservedMdl);
                    deviceExtension->ReservedMdl = NULL;
                }

                // free the vendor id
                if (deviceExtension->DeviceInfo->uniVendorId.Buffer) {

                    ExFreePool(deviceExtension->DeviceInfo->uniVendorId.Buffer);
                    deviceExtension->DeviceInfo->uniVendorId.Length = 0;
                    deviceExtension->DeviceInfo->uniVendorId.Buffer = NULL;
                }

                // free the model id
                if (deviceExtension->DeviceInfo->uniModelId.Buffer) {

                    ExFreePool(deviceExtension->DeviceInfo->uniModelId.Buffer);
                    deviceExtension->DeviceInfo->uniModelId.Length = 0;
                    deviceExtension->DeviceInfo->uniModelId.Buffer = NULL;
                }

                // free the generic name
                if (deviceExtension->DeviceInfo->uniGenericName.Buffer) {

                    ExFreePool(deviceExtension->DeviceInfo->uniGenericName.Buffer);
                    deviceExtension->DeviceInfo->uniGenericName.Length = 0;
                    deviceExtension->DeviceInfo->uniGenericName.Buffer = NULL;
                }
            }
        }

    } else {

        fdoExtension = (PFDO_DEVICE_EXTENSION) deviceExtension;

        if (fdoExtension->Sbp2ObjectDirectory != NULL) {

            ZwMakeTemporaryObject (fdoExtension->Sbp2ObjectDirectory);
            ZwClose (fdoExtension->Sbp2ObjectDirectory);
            fdoExtension->Sbp2ObjectDirectory = NULL;
        }

        if (TEST_FLAG(fdoExtension->DeviceFlags,DEVICE_FLAG_REMOVED)) {

            return FALSE;

        } else {

            SET_FLAG (fdoExtension->DeviceFlags, DEVICE_FLAG_REMOVED);
        }

        if (fdoExtension->DeviceListSize != 0) {

            //
            // Disable bus reset notifications
            //

            AllocateIrpAndIrb ((PDEVICE_EXTENSION) fdoExtension, &packet);

            if (packet) {

                packet->Irb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
                packet->Irb->Flags = 0;
                packet->Irb->u.BusResetNotification.fulFlags =
                    DEREGISTER_NOTIFICATION_ROUTINE;

                Sbp2SendRequest(
                    (PDEVICE_EXTENSION) fdoExtension,
                    packet,
                    SYNC_1394_REQUEST
                    );

                DeAllocateIrpAndIrb ((PDEVICE_EXTENSION) fdoExtension, packet);
            }
        }

        //
        // Clean up any remaining PDO's
        //

        KeAcquireSpinLock (&fdoExtension->DeviceListLock,&cIrql);

        for (; fdoExtension->DeviceListSize > 0; fdoExtension->DeviceListSize--) {

            i = fdoExtension->DeviceListSize - 1;

            if (fdoExtension->DeviceList[i].DeviceObject) {

                deviceExtension =
                    fdoExtension->DeviceList[i].DeviceObject->DeviceExtension;

                SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED);

                DeviceObject = fdoExtension->DeviceList[i].DeviceObject;

                KeReleaseSpinLock (&fdoExtension->DeviceListLock, cIrql);

                if (Sbp2CleanDeviceExtension (DeviceObject, TRUE)) {

                    //
                    // Acquire the pdo's remove lock, start the queue
                    // cleanup, and and wait for io to complete.  Then
                    // delete the device & continue.
                    //

                    IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);

                    KeRaiseIrql (DISPATCH_LEVEL, &cIrql);

                    Sbp2StartNextPacketByKey (DeviceObject, 0);

                    KeLowerIrql (cIrql);

                    DEBUGPRINT2((
                        "Sbp2Port: CleanDevExt: walking fdo, wait for " \
                            "io compl pdo=x%p...\n",
                        DeviceObject
                        ));

                    IoReleaseRemoveLockAndWait(
                        &deviceExtension->RemoveLock,
                        NULL
                        );

                    deviceExtension->Type = SBP2_PDO_DELETED;

                    KeCancelTimer(&deviceExtension->DeviceManagementTimer);

                    IoDeleteDevice (DeviceObject);

                    DEBUGPRINT2((
                        "Sbp2Port: CleanDevExt: ............ io compl," \
                            " deleted pdo=x%p\n",
                        DeviceObject
                        ));

                    KeAcquireSpinLock (&fdoExtension->DeviceListLock, &cIrql);

                    fdoExtension->DeviceList[i].DeviceObject = NULL;

                } else {

                    KeAcquireSpinLock (&fdoExtension->DeviceListLock, &cIrql);
                }
            }

            if (fdoExtension->DeviceList[i].uniVendorId.Buffer) {

                ExFreePool(fdoExtension->DeviceList[i].uniVendorId.Buffer);
                fdoExtension->DeviceList[i].uniVendorId.Length = 0;
                fdoExtension->DeviceList[i].uniVendorId.Buffer = NULL;
            }

            if (fdoExtension->DeviceList[i].uniModelId.Buffer) {

                ExFreePool(fdoExtension->DeviceList[i].uniModelId.Buffer);
                fdoExtension->DeviceList[i].uniModelId.Length = 0;
                fdoExtension->DeviceList[i].uniModelId.Buffer = NULL;
            }

            if (fdoExtension->DeviceList[i].uniGenericName.Buffer) {

                ExFreePool(fdoExtension->DeviceList[i].uniGenericName.Buffer);
                fdoExtension->DeviceList[i].uniGenericName.Length = 0;
                fdoExtension->DeviceList[i].uniGenericName.Buffer = NULL;
            }

        }

        KeReleaseSpinLock (&fdoExtension->DeviceListLock, cIrql);
    }

    return TRUE;
}


VOID
Sbp2Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Does nothing really...

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/
{
    DEBUGPRINT1(("Sbp2Port: unloading\n\n"));

    return;
}


VOID
Sbp2DeviceManagementTimeoutDpc(
    IN PKDPC Dpc,
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    ULONG                   i;
    PDEVICE_EXTENSION       pdoExtension;
    PFDO_DEVICE_EXTENSION   fdoExtension;


    if (Dpc != &DeviceExtension->DeviceManagementTimeoutDpc) {

        return;
    }

    if (TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED)) {

        return;
    }

    if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_RECONNECT)) {

        //
        // The flag indicates that a bus reset occured, and a reconnect never happened...
        // OR that the device is realy hose so we reset it and we need to re-login
        //

        DEBUGPRINT1((
            "Sbp2Port: RECONNECT timeout, Ext=x%p, Flags=x%x, doing re-login\n",
            DeviceExtension,
            DeviceExtension->DeviceFlags
            ));

        //
        // all the resident 1394 memory addresses's that we have, are
        // now invalidated... So we need to free them and re-allocate
        // them

        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->ExtensionDataSpinLock);
        CLEAR_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_RECONNECT);
        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

        //
        // If device is marked STOPPED then a target reset was
        // done and that affected all LUNs (spec sect 10.4.4).
        // So if this is a multilun device try logins on each
        // pdo as appropriate.
        //

        fdoExtension = (PFDO_DEVICE_EXTENSION)
            DeviceExtension->BusFdo->DeviceExtension;

        if ((fdoExtension->DeviceListSize > 1)  &&

            TEST_FLAG (DeviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED)) {

            for (i = 0; i < fdoExtension->DeviceListSize; i++) {

                pdoExtension = (PDEVICE_EXTENSION)
                    fdoExtension->DeviceList[i].DeviceObject->DeviceExtension;

                if (pdoExtension->DeviceObject ==
                        DeviceExtension->DeviceObject) {

                    // No need to update node info since no bus reset done

                    Sbp2ManagementTransaction(
                        pdoExtension,
                        TRANSACTION_LOGIN
                        );

                    continue;
                }

                KeAcquireSpinLockAtDpcLevel(
                    &pdoExtension->ExtensionDataSpinLock
                    );

                if (TEST_FLAG(
                        pdoExtension->DeviceFlags,
                        DEVICE_FLAG_INITIALIZED
                        )  &&

                    !TEST_FLAG(
                        pdoExtension->DeviceFlags,
                        DEVICE_FLAG_STOPPED | DEVICE_FLAG_RESET_IN_PROGRESS |
                        DEVICE_FLAG_REMOVED | DEVICE_FLAG_LOGIN_IN_PROGRESS |
                        DEVICE_FLAG_RECONNECT | DEVICE_FLAG_DEVICE_FAILED |
                        DEVICE_FLAG_SURPRISE_REMOVED
                        )) {

                    SET_FLAG(
                        pdoExtension->DeviceFlags,
                        (DEVICE_FLAG_STOPPED | DEVICE_FLAG_RESET_IN_PROGRESS)
                        );

                    KeReleaseSpinLockFromDpcLevel(
                        &pdoExtension->ExtensionDataSpinLock
                        );

                    CleanupOrbList (pdoExtension, STATUS_REQUEST_ABORTED);

                    // No need to update node info since no bus reset done

                    Sbp2ManagementTransaction(
                        pdoExtension,
                        TRANSACTION_LOGIN
                        );

                } else {

                    KeReleaseSpinLockFromDpcLevel(
                        &pdoExtension->ExtensionDataSpinLock
                        );
                }
            }

        } else {

            Sbp2UpdateNodeInformation (DeviceExtension);
            Sbp2ManagementTransaction (DeviceExtension, TRANSACTION_LOGIN);
        }

        return ;
    }


    if (TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_LOGIN_IN_PROGRESS)) {

        ULONG flags;


        //
        // the asynchronous login attempt timed out. This is bad news and means the
        // device is not responding
        //

        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

        flags = DeviceExtension->DeviceFlags;

        CLEAR_FLAG(DeviceExtension->DeviceFlags,(DEVICE_FLAG_LOGIN_IN_PROGRESS | DEVICE_FLAG_RESET_IN_PROGRESS));
        SET_FLAG(DeviceExtension->DeviceFlags, (DEVICE_FLAG_STOPPED | DEVICE_FLAG_DEVICE_FAILED));

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

        //
        // check if we had a power irp deferred.. If we did call startio to abort it..
        //

        if (DeviceExtension->DeferredPowerRequest) {

            Sbp2StartIo(DeviceExtension->DeviceObject,DeviceExtension->DeferredPowerRequest);
            DeviceExtension->DeferredPowerRequest = NULL;
        }

        DEBUGPRINT1((
            "Sbp2Port: LOGIN timeout, Ext=x%p, Flags=x%x, device stopped\n",
            DeviceExtension,
            flags
            ));

        Sbp2StartNextPacketByKey (DeviceExtension->DeviceObject, 0);

        IoInvalidateDeviceState(DeviceExtension->DeviceObject);
        return;
    }


    if (TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_RESET_IN_PROGRESS)) {

        //
        // the reset attempt has timed out
        //

        DEBUGPRINT1((
            "Sbp2Port: RESET timeout, Ext=x%p, Flags=x%x, ",
            DeviceExtension,
            DeviceExtension->DeviceFlags
            ));

        if (!TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED)) {

            //
            // Second level of recovery, do a TARGET_RESET task function
            //

            DEBUGPRINT1(("doing target reset\n"));

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

            SET_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED);
            DeviceExtension->MaxOrbListDepth = max(MIN_ORB_LIST_DEPTH,DeviceExtension->MaxOrbListDepth/2);

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

            CleanupOrbList(DeviceExtension,STATUS_REQUEST_ABORTED);

            //
            // we are close to timing out a reset, try a hard reset
            //

            Sbp2Reset (DeviceExtension->DeviceObject, TRUE);
            return;

        } else {

            //
            // Third level of recovery. Do a hardware node reset
            //

            DEBUGPRINT1(("doing CMD_RESET and relogin.\n"));

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->ExtensionDataSpinLock);

            DeviceExtension->Reserved = 0;
            SET_FLAG(DeviceExtension->DeviceFlags, (DEVICE_FLAG_RESET_IN_PROGRESS | DEVICE_FLAG_RECONNECT | DEVICE_FLAG_STOPPED));

            DeviceExtension->DueTime.HighPart = -1;
            DeviceExtension->DueTime.LowPart = SBP2_RELOGIN_DELAY;
            KeSetTimer(&DeviceExtension->DeviceManagementTimer,DeviceExtension->DueTime, &DeviceExtension->DeviceManagementTimeoutDpc);

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->ExtensionDataSpinLock);
            Sbp2AccessRegister(DeviceExtension,&DeviceExtension->Reserved,CORE_RESET_REG | REG_WRITE_ASYNC);

            return;
        }
    }
}


VOID
Sbp2RequestTimeoutDpc(
    IN PKDPC Dpc,
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Our Device object
    Context - DeviceExtension

Return Value:
    NTSTATUS

--*/
{
    PIRP requestIrp = NULL;
    PASYNC_REQUEST_CONTEXT current = NULL;
    PASYNC_REQUEST_CONTEXT next = NULL;
    LARGE_INTEGER Time;

#if DBG

    ULONG xferLen;
    UCHAR cdb[6];

#endif

    //
    // return if device is stopped, but since reset can occur while device is stopped
    // thats why this check is ater the reset timing code
    //

    if (IsListEmpty (&DeviceExtension->PendingOrbList)) {

        return ;
    }

    //
    // search the linked list of contexts, to see which guy timed out
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->OrbListSpinLock);

    next = RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Flink,OrbList);

    // see if the last status has the suspended state bit set...
    if ((DeviceExtension->LastStatusBlock.AddressAndStatus.u.HighQuad.u.HighPart & STATUS_BLOCK_ENDOFLIST_BIT_MASK) &&
        (next->Flags & ASYNC_CONTEXT_FLAG_TIMER_STARTED) &&
        !(next->Flags & ASYNC_CONTEXT_FLAG_RANG_DOORBELL)) {

        TRACE(TL_1394_INFO, ("GC: Pending Orb - Ring Doorbell."));

        // set the flag...
        SET_FLAG(next->Flags, ASYNC_CONTEXT_FLAG_RANG_DOORBELL);

        Time.QuadPart = (-5*10*1000*1000); // 5 seconds
        KeSetTimer(&next->Timer, Time, &next->TimerDpc);

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->OrbListSpinLock);

        // reset the timer to track this request...
        // we still have a pending orb, but the device thinks its done.
        // ring the doorbell...
        Sbp2AccessRegister( DeviceExtension,
                            &DeviceExtension->Reserved,
                            DOORBELL_REG | REG_WRITE_ASYNC
                            );

        return;
    }

    if (next->Flags & ASYNC_CONTEXT_FLAG_RANG_DOORBELL) {

        CLEAR_FLAG(next->Flags, ASYNC_CONTEXT_FLAG_RANG_DOORBELL);
        TRACE(TL_1394_INFO, ("Rang Doorbell - didn't work."));
    }

    do {

        current = next;
        if ((&current->TimerDpc == Dpc) && (current->Flags & ASYNC_CONTEXT_FLAG_TIMER_STARTED)) {

            if (TEST_FLAG(current->Flags,ASYNC_CONTEXT_FLAG_COMPLETED)) {

                DEBUGPRINT1(("Sbp2Port: ReqTimeoutDpc: timeout, but req already compl!!\n" ));
                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->OrbListSpinLock);
                return;
            }

            //
            // this is the timed out request
            // do an abort Task Set
            //

            CLEAR_FLAG(current->Flags,ASYNC_CONTEXT_FLAG_TIMER_STARTED);

            KeCancelTimer(&current->Timer);

#if DBG
            xferLen = current->Srb->DataTransferLength;
            cdb[0] = current->Srb->Cdb[0];
            cdb[1] = current->Srb->Cdb[1];
            cdb[2] = current->Srb->Cdb[2];
            cdb[3] = current->Srb->Cdb[3];
            cdb[4] = current->Srb->Cdb[4];
            cdb[5] = current->Srb->Cdb[5];
#endif

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->OrbListSpinLock);

            Sbp2CreateRequestErrorLog(DeviceExtension->DeviceObject,current,STATUS_TIMEOUT);

            if (!TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_RESET_IN_PROGRESS)){

                DEBUGPRINT1((
                    "Sbp2Port: ReqTimeoutDpc: cdb=x%02x %02x %02x %02x %02x " \
                        "%02x, len=x%x\n",
                    cdb[0],
                    cdb[1],
                    cdb[2],
                    cdb[3],
                    cdb[4],
                    cdb[5],
                    xferLen
                    ));

                Sbp2Reset (DeviceExtension->DeviceObject, FALSE);
            }

            return;
        }

        next = (PASYNC_REQUEST_CONTEXT) current->OrbList.Flink;

    } while ( current != RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Blink,OrbList));

    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->OrbListSpinLock);

    return;
}


VOID
Sbp2Reset(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN HardReset
    )
/*++

Routine Description:

    Used to implement SBP2 high level recovery mechanisms. It will issue an ABORT_TASK_SET if HardReset == FALSE
    otherswise it will issue a RESET_TARGET. Its all done asynchronously and out timer DPC will track the requests
    to check if they timed out...

Arguments:

    DeviceObject= Sbp2 driver's device object
    HardReset = Type of recovery to perform, TRUE is a target reset, FALSE is an abort task set

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    KIRQL oldIrql;
    NTSTATUS status;
#if DBG
    ULONG generation;
#endif


    if ((deviceExtension->DeviceFlags & DEVICE_FLAG_REMOVED) ||
        (deviceExtension->DeviceFlags & DEVICE_FLAG_RECONNECT)) {

        return;
    }

    if (HardReset == TRUE) {

        DEBUGPRINT2(("Sbp2Port: Reset: ext=x%p, do target reset\n", deviceExtension ));

        //
        // Do a target reset
        //

        KeAcquireSpinLock (&deviceExtension->ExtensionDataSpinLock,&oldIrql);

        deviceExtension->TaskOrbContext.TransactionType = TRANSACTION_TARGET_RESET;
        deviceExtension->TaskOrb->OrbInfo.QuadPart = 0;
        deviceExtension->TaskOrb->OrbInfo.u.HighPart |= ORB_NOTIFY_BIT_MASK;
        deviceExtension->TaskOrb->OrbInfo.u.HighPart |= 0x00FF & TRANSACTION_TARGET_RESET;

        deviceExtension->TaskOrb->OrbInfo.u.LowPart =
            deviceExtension->LoginResponse->LengthAndLoginId.u.LowPart; // LOGIN ID

        deviceExtension->TaskOrb->StatusBlockAddress.BusAddress =
            deviceExtension->TaskOrbStatusContext.Address.BusAddress;

        //
        // endian conversion
        //

        octbswap (deviceExtension->TaskOrb->StatusBlockAddress);

        deviceExtension->TaskOrb->OrbInfo.QuadPart =
            bswap(deviceExtension->TaskOrb->OrbInfo.QuadPart);

        //
        // send the task ORB , mark start of reset/abort
        //

        deviceExtension->DeviceFlags |= DEVICE_FLAG_RESET_IN_PROGRESS;

        //
        // now set the timer to track this request
        //

        deviceExtension->DueTime.HighPart = -1;
        deviceExtension->DueTime.LowPart = SBP2_HARD_RESET_TIMEOUT;
        KeSetTimer(&deviceExtension->DeviceManagementTimer,deviceExtension->DueTime,&deviceExtension->DeviceManagementTimeoutDpc);

        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,oldIrql);

        status = Sbp2AccessRegister(deviceExtension, &deviceExtension->TaskOrbContext.Address, MANAGEMENT_AGENT_REG | REG_WRITE_ASYNC);

        if (status == STATUS_INVALID_GENERATION) {

            KeCancelTimer(&deviceExtension->DeviceManagementTimer);
#if DBG
            //
            // Check to see if perhaps we didn't get the reset
            // notification we were expecting
            //

            generation = deviceExtension->CurrentGeneration;

            status = Sbp2UpdateNodeInformation (deviceExtension);

            DEBUGPRINT1((
                "Sbp2Port: Reset:  target reset error, sts=x%x, extGen=x%x, " \
                    "curGen=x%x\n",
                status,
                generation,
                deviceExtension->CurrentGeneration
                ));
#endif
            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&oldIrql);

            SET_FLAG(deviceExtension->DeviceFlags, (DEVICE_FLAG_STOPPED | DEVICE_FLAG_DEVICE_FAILED));

            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,oldIrql);

            //
            // check if we had a power irp deferred.. If we did call startio to abort it..
            //

            if (deviceExtension->DeferredPowerRequest) {

                Sbp2StartIo(deviceExtension->DeviceObject,deviceExtension->DeferredPowerRequest);
                deviceExtension->DeferredPowerRequest = NULL;
            }

            Sbp2StartNextPacketByKey (deviceExtension->DeviceObject, 0);

            return;
        }

    } else {

        DEBUGPRINT2(("Sbp2Port: Reset: ext=x%p, do abort task set\n", deviceExtension ));

        //
        // Do an abort task set
        //

        KeAcquireSpinLock (&deviceExtension->ExtensionDataSpinLock,&oldIrql);

        deviceExtension->TaskOrbContext.TransactionType = TRANSACTION_ABORT_TASK_SET;
        deviceExtension->TaskOrb->OrbInfo.QuadPart = 0;
        deviceExtension->TaskOrb->OrbInfo.u.HighPart |= ORB_NOTIFY_BIT_MASK;
        deviceExtension->TaskOrb->OrbInfo.u.HighPart |= 0x00FF & TRANSACTION_ABORT_TASK_SET;

        deviceExtension->TaskOrb->OrbInfo.u.LowPart =
            deviceExtension->LoginResponse->LengthAndLoginId.u.LowPart; // LOGIN ID

        deviceExtension->TaskOrb->StatusBlockAddress.BusAddress =
            deviceExtension->TaskOrbStatusContext.Address.BusAddress;

        //
        // endian conversion
        //

        octbswap (deviceExtension->TaskOrb->StatusBlockAddress);

        deviceExtension->TaskOrb->OrbInfo.QuadPart =
            bswap (deviceExtension->TaskOrb->OrbInfo.QuadPart);

        //
        // send the task ORB , mark start of reset/abort
        //

        deviceExtension->DeviceFlags |= DEVICE_FLAG_RESET_IN_PROGRESS;

        //
        // now set the timer to track this request
        //

        deviceExtension->DueTime.HighPart = -1;
        deviceExtension->DueTime.LowPart = SBP2_RESET_TIMEOUT;
        KeSetTimer(&deviceExtension->DeviceManagementTimer,deviceExtension->DueTime,&deviceExtension->DeviceManagementTimeoutDpc);

        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,oldIrql);

        Sbp2AccessRegister(deviceExtension, &deviceExtension->TaskOrbContext.Address, MANAGEMENT_AGENT_REG | REG_WRITE_ASYNC);
    }
}


NTSTATUS
Sbp2DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the device control dispatcher.

Arguments:

    DeviceObject
    Irp

Return Value:


    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG requiredSize;

    if (deviceExtension->Type == SBP2_PDO) {

        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_STORAGE_QUERY_PROPERTY: {
            //
            // Validate the query
            //

            PSTORAGE_PROPERTY_QUERY query = Irp->AssociatedIrp.SystemBuffer;

            if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
               sizeof(STORAGE_PROPERTY_QUERY)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            status = Sbp2QueryProperty(DeviceObject, Irp);


            break;
        }

        case IOCTL_SCSI_PASS_THROUGH:

            status = Sbp2_ScsiPassThrough(DeviceObject, Irp, FALSE);
            break;

        case IOCTL_SCSI_PASS_THROUGH_DIRECT:

            status = Sbp2_ScsiPassThrough(DeviceObject, Irp, TRUE);
            break;

        case IOCTL_SBP2_REQUEST:

            status = Sbp2HandleApiRequest(deviceExtension, Irp);

            break;

        default:

            DEBUGPRINT3(("Sbp2Port: Sbp2DeviceControl: Irp Not Handled.\n" ));
            status = STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Status =status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);

            break;
        }

    } else {

        status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status =status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
Sbp2HandleApiRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSBP2_REQUEST sbp2Req;
    NTSTATUS status;


    status = IoAcquireRemoveLock (&DeviceExtension->RemoveLock, NULL);

    if (!NT_SUCCESS (status)) {

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        return status;
    }

    if (Irp->RequestorMode == KernelMode) {

        sbp2Req = irpStack->Parameters.Others.Argument1;

    } else { // UserMode

        sbp2Req = Irp->AssociatedIrp.SystemBuffer;
    }

    if (sbp2Req == NULL) {

        DEBUGPRINT1(("Sbp2Port: HandleApiReq: Invalid sbp2Req!"));
        status = STATUS_INVALID_PARAMETER;
        goto Exit_Sbp2HandleApiRequest;
    }

    status = STATUS_NOT_IMPLEMENTED;

    switch (sbp2Req->RequestNumber) {

    case SBP2_REQUEST_RETRIEVE_TEXT_LEAFS:

        //
        // Only allow kernel-mode requests of this type, since the
        // RetrieveTextLeaf definition currently has us passing
        // back a buf alloc'd via ExAllocPool - not something we
        // want to hand back to user-mode.
        //

        if (Irp->RequestorMode == KernelMode) {

            status = Sbp2Get1394ConfigInfo(
                (PFDO_DEVICE_EXTENSION)
                    DeviceExtension->BusFdo->DeviceExtension,
                sbp2Req
                );
        }

        break;

#if PASSWORD_SUPPORT

    case SBP2_REQUEST_SET_PASSWORD:

        if (sbp2Req->u.SetPassword.fulFlags == SBP2REQ_SET_PASSWORD_CLEAR) {

            DEBUGPRINT1(("Sbp2Port: Setting Password to Clear\n"));

            status = Sbp2SetPasswordTransaction(
                DeviceExtension,
                SBP2REQ_SET_PASSWORD_CLEAR
                );

            if (NT_SUCCESS(status)) {

                DeviceExtension->Exclusive = EXCLUSIVE_FLAG_CLEAR;
            }

        } else if (sbp2Req->u.SetPassword.fulFlags ==
                        SBP2REQ_SET_PASSWORD_EXCLUSIVE) {

            DEBUGPRINT1 (("Sbp2Port: HandleApiReq: set passwd to excl\n"));

            status = Sbp2SetPasswordTransaction(
                DeviceExtension,
                SBP2REQ_SET_PASSWORD_EXCLUSIVE
                );

            if (NT_SUCCESS(status)) {

                DeviceExtension->Exclusive = EXCLUSIVE_FLAG_SET;
            }

        } else {

            DEBUGPRINT1((
                "Sbp2Port: HandleApiReq: set passwd, inval fl=x%x\n",
                sbp2Req->u.SetPassword.fulFlags
                ));

            status = STATUS_INVALID_PARAMETER;
            goto Exit_Sbp2HandleApiRequest;
        }

        Sbp2SetExclusiveValue(
             DeviceExtension->DeviceObject,
             &DeviceExtension->Exclusive
             );

        DEBUGPRINT1((
            "Sbp2Port: HandleApiReq: set passwd sts=x%x\n",
            status
            ));

        break;

#endif

    default:

        status = STATUS_INVALID_PARAMETER;
        break;
    }

Exit_Sbp2HandleApiRequest:

    Irp->IoStatus.Status = status;
    IoReleaseRemoveLock (&DeviceExtension->RemoveLock, NULL);
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return status;
}


NTSTATUS
Sbp2CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    create and close routine.  This is called by the I/O system
    when the device is opened or closed. The sbp2 driver will do login and logout on
    create/close respectively

Arguments:

    DeviceObject - Pointer to device object for this miniport

    Irp - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;


    if (deviceExtension->Type == SBP2_PDO) {

        if ((deviceExtension->InquiryData.DeviceType == PRINTER_DEVICE) ||
            (deviceExtension->InquiryData.DeviceType == SCANNER_DEVICE)){

            if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_INITIALIZING)) {

                status = IoAcquireRemoveLock(
                    &deviceExtension->RemoveLock,
                    NULL
                    );

                if (!NT_SUCCESS (status)) {

                    goto Sbp2CreateClose_CompleteReq;
                }

                switch (irpStack->MajorFunction) {

                case IRP_MJ_CREATE:

                    DEBUGPRINT2(("Sbp2Port: Sbp2CreateClose: OPEN_REQUEST, handle cound %d.\n", deviceExtension->HandleCount));

                    if (deviceExtension->DeviceFlags & DEVICE_FLAG_STOPPED) {

                        //
                        // do a login.
                        //

                        DEBUGPRINT2(("Sbp2Port: Sbp2CreateClose: LOGIN.\n" ));
                        status = Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGIN);

                        if (status == STATUS_SUCCESS) {

                            //
                            // make retry limit high for busy transactions
                            //

                            deviceExtension->Reserved = BUSY_TIMEOUT_SETTING;
                            Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,CORE_BUSY_TIMEOUT_REG | REG_WRITE_SYNC);

                            //
                            // We are ready to receive and pass down requests, init the target's
                            // fetch agent.
                            //

                            Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,AGENT_RESET_REG | REG_WRITE_ASYNC);

                            deviceExtension->DeviceFlags &= ~DEVICE_FLAG_STOPPED;

                            InterlockedIncrement(&deviceExtension->HandleCount);
                        }

                    } else {

                        InterlockedIncrement(&deviceExtension->HandleCount);
                    }

                    break;

                case IRP_MJ_CLOSE:

                    if (deviceExtension->HandleCount) {

                        InterlockedDecrement(&deviceExtension->HandleCount);
                    }

                    DEBUGPRINT2(("Sbp2Port: Sbp2CreateClose: CLOSE_REQUEST, handle cound %d.\n", deviceExtension->HandleCount));

                    if (!(deviceExtension->DeviceFlags & (DEVICE_FLAG_REMOVED | DEVICE_FLAG_STOPPED)) &&
                        !deviceExtension->HandleCount) {

                        //
                        // Logout
                        //

                        DEBUGPRINT2(("Sbp2Port: Sbp2CreateClose: LOGIN OUT.\n" ));

                        deviceExtension->DeviceFlags |= DEVICE_FLAG_STOPPED;

                        Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGOUT);

                        CleanupOrbList(deviceExtension,STATUS_REQUEST_ABORTED);
                    }

                    break;
                }

                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
            }
        } // device type check

    } else if (deviceExtension->Type != SBP2_FDO) {

        status = STATUS_NO_SUCH_DEVICE;
    }

Sbp2CreateClose_CompleteReq:

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, 0);
    return status;
}


NTSTATUS
Sbp2PnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This routine handles the PNP requests (primarily for PDO's)

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

   NTSTATUS

--*/
{
    KIRQL                   cIrql;
    PULONG                  count;
    NTSTATUS                status;
    UNICODE_STRING          unicodeIdString;
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    PDEVICE_RELATIONS       deviceRelations;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_CAPABILITIES    deviceCapabilities;
    PFDO_DEVICE_EXTENSION   fdoExtension;

#if DBG

    const char * minorFuncs[] =
    {
        "START_DEV,           ",
        "QUERY_REMOVE_DEV,    ",
        "REMOVE_DEV,          ",
        "CANCEL_REMOVE_DEV,   ",
        "STOP_DEV,            ",
        "QUERY_STOP_DEV,      ",
        "CANCEL_STOP_DEV,     ",
        "QUERY_DEV_RELATIONS, ",
        "QUERY_INTERFACE,     ",
        "QUERY_CAPABILITIES,  ",
        "QUERY_RESOURCES,     ",
        "QUERY_RESOURCE_REQS, ",
        "QUERY_DEV_TEXT,      ",
        "FILTER_RESOURCE_REQS,",
        "??,                  ",    // 0xd (14)
        "READ_CFG,            ",
        "WRITE_CFG,           ",
        "EJECT,               ",
        "SET_LOCK,            ",
        "QUERY_ID,            ",
        "QUERY_PNP_DEV_STATE, ",
        "QUERY_BUS_INFO,      ",
        "DEV_USAGE_NOTIF,     ",
        "SURPRISE_REMOVAL,    ",
        "QUERY_LEG_BUS_INFO,  "     // 0x18
    };

    DEBUGPRINT2((
        "Sbp2Port: Pnp: [x%02x] %s %sdoX=x%p, fl=x%x\n",
        irpStack->MinorFunction,
        (irpStack->MinorFunction <= 0x18 ?
            minorFuncs[irpStack->MinorFunction] : minorFuncs[14]),
        (deviceExtension->Type == SBP2_PDO ? "p" :
            (deviceExtension->Type == SBP2_FDO ? "f" : "???")),
        deviceExtension,
        deviceExtension->DeviceFlags
        ));

#endif

    //
    // We may receive an IRP_MN_BUS_RESET before our AddDevice
    // has completed. Check to make sure our DeviceObject is
    // initialized before we allow processing of PNP Irps.
    //
    if (DeviceObject->Flags & DO_DEVICE_INITIALIZING) {

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_NO_SUCH_DEVICE);
    }

    switch (deviceExtension->Type) {

    case SBP2_PDO:

        break;

    case SBP2_FDO:

        return Sbp2FDOPnpDeviceControl (DeviceObject, Irp);

    default:

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);

    if (!NT_SUCCESS (status)) {

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        return status;
    }

    switch (irpStack->MinorFunction) {

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        DEBUGPRINT3((
            "Sbp2Port: Pnp: ... Type = %x\n",
            irpStack->Parameters.QueryDeviceRelations.Type
            ));

        //
        // Fill in the DeviceRelations array with this PDO,
        // reference it, and return.
        //

        if (irpStack->Parameters.QueryDeviceRelations.Type !=
                TargetDeviceRelation) {

            status = Irp->IoStatus.Status;

            break;
        }

        if (Irp->IoStatus.Information) {

            deviceRelations = (PDEVICE_RELATIONS)Irp->IoStatus.Information;

        } else {

            deviceRelations = ExAllocatePool(
                PagedPool,
                sizeof (*deviceRelations)
                );

            if (!deviceRelations) {

                Irp->IoStatus.Status = status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;

                break;
            }

            deviceRelations->Count = 0;
        }

        deviceRelations->Objects[deviceRelations->Count] = DeviceObject;
        deviceRelations->Count++;

        ObReferenceObject (DeviceObject);

        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

        break;

    case IRP_MN_QUERY_DEVICE_TEXT:
        {
            PDEVICE_INFORMATION DeviceInfo = deviceExtension->DeviceInfo;
            UNICODE_STRING      uniRetString;

            // assume success
            status = STATUS_SUCCESS;

            if ((irpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) ||
                (irpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation)) {

                status = Sbp2_BuildDeviceText( irpStack->Parameters.QueryDeviceText.DeviceTextType,
                                               DeviceInfo,
                                               &uniRetString
                                               );

                Irp->IoStatus.Information = (ULONG_PTR)uniRetString.Buffer;
                TRACE(TL_PNP_INFO, ("DeviceText = %ws", uniRetString.Buffer));
            }
            else {

                status = STATUS_NOT_SUPPORTED;
            }

            Irp->IoStatus.Status = status;
        }
        break;

        case IRP_MN_QUERY_ID:
            {
                PDEVICE_INFORMATION DeviceInfo = deviceExtension->DeviceInfo;
                UNICODE_STRING      uniRetString;

                TRACE(TL_PNP_TRACE, ("PDO: IRP_MN_QUERY_ID"));

                // assume success
                status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG_PTR)NULL;

                switch (irpStack->Parameters.QueryId.IdType) {

                    case BusQueryDeviceID:
                        TRACE(TL_PNP_TRACE, ("BusQueryDeviceID"));

                        // build our DeviceId
                        status = Sbp2_BuildDeviceId(DeviceInfo, &uniRetString);

                        if (!NT_SUCCESS(status)) {

                            TRACE(TL_PNP_ERROR, ("Failed to build DeviceId! = 0x%x", status));
                        }
                        else {

                            Irp->IoStatus.Information = (ULONG_PTR)uniRetString.Buffer;
                            TRACE(TL_PNP_TRACE, ("DeviceID = %ws", uniRetString.Buffer));
                        }
                        break; // BusQueryDeviceID

                    case BusQueryHardwareIDs:
                        TRACE(TL_PNP_TRACE, ("BusQueryHardwareIDs"));

                        // build our HardwareIds
                        status = Sbp2_BuildHardwareIds(DeviceInfo, &uniRetString);

                        if (!NT_SUCCESS(status)) {

                            TRACE(TL_PNP_ERROR, ("Failed to build HardwareIds! = 0x%x", status));
                        }
                        else {

                            Irp->IoStatus.Information = (ULONG_PTR)uniRetString.Buffer;
                            TRACE(TL_PNP_TRACE, ("HardwareIds = %ws", uniRetString.Buffer));
                        }
                        break; // BusQueryHardwareIDs

                    case BusQueryCompatibleIDs:
                        TRACE(TL_PNP_TRACE, ("BusQueryCompatibleIDs"));

                        // build our CompatIds
                        status = Sbp2_BuildCompatIds(DeviceInfo, &uniRetString);

                        if (!NT_SUCCESS(status)) {

                            TRACE(TL_1394_ERROR, ("Failed to build CompatIds! = 0x%x", status));
                        }
                        else {

                            Irp->IoStatus.Information = (ULONG_PTR)uniRetString.Buffer;
                            TRACE(TL_PNP_TRACE, ("CompatIds = %ws", uniRetString.Buffer));
                        }
                        break; // BusQueryCompatibleIDs

                    case BusQueryInstanceID:

//                        if (BusExtension->Tag == BUS_DEVICE_TAG) {

                            TRACE(TL_PNP_TRACE, ("BusQueryInstanceID"));

                            // build our InstanceId
                            status = Sbp2_BuildInstanceId(DeviceInfo, &uniRetString);

                            if (!NT_SUCCESS(status)) {

                                TRACE(TL_1394_ERROR, ("Failed to build InstanceId! = 0x%x", status));
                            }
                            else {

                                Irp->IoStatus.Information = (ULONG_PTR)uniRetString.Buffer;
                                TRACE(TL_PNP_TRACE, ("InstanceID = %ws", uniRetString.Buffer));
                            }
//                        }
//                        else {
//
//                            // let 1394bus deal with it...
//                            IoSkipCurrentIrpStackLocation(Irp);
//                            status = IoCallDriver(BusExtension->ParentDeviceObject, Irp);
//                            return(status); // default
//                        }
                        break; // BusQueryCompatibleIDs

                    default:
                        TRACE(TL_PNP_WARNING, ("Unsupported IRP_MN_QUERY_ID"));

                        // set status to avoid changing the current IoStatus
                        status = Irp->IoStatus.Status;
                        break; // default
                } // switch
            }

            Irp->IoStatus.Status = status;
            break; // IRP_MN_QUERY_ID

    case IRP_MN_QUERY_CAPABILITIES:

        deviceCapabilities =
            irpStack->Parameters.DeviceCapabilities.Capabilities;

        //
        // Settings consistent across all 1394 devices
        //

        deviceCapabilities->Removable = TRUE;
        deviceCapabilities->UniqueID = TRUE;
        deviceCapabilities->SilentInstall = TRUE;

        //
        // Settings for different types of devices.  We are very
        // familar with SCSI-variant devices and can make some
        // good choices here, but for other devices we'll leave
        // these choices up to the higher-level driver(s).
        //

        switch (deviceExtension->DeviceInfo->CmdSetId.QuadPart) {

        case 0x10483:
        case SCSI_COMMAND_SET_ID:

            switch ((deviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F)) {

            case PRINTER_DEVICE:
            case SCANNER_DEVICE:

                deviceCapabilities->RawDeviceOK = FALSE;
                deviceCapabilities->SurpriseRemovalOK = TRUE;
                break;

            default:

                deviceCapabilities->RawDeviceOK = TRUE;
                break;
            }

            break;

        default:

            break;
        }

        deviceCapabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
        deviceCapabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
        deviceCapabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
        deviceCapabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
        deviceCapabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
        deviceCapabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

        deviceCapabilities->SystemWake = PowerSystemUnspecified;
        deviceCapabilities->DeviceWake = PowerDeviceUnspecified;
        deviceCapabilities->D1Latency  = 1 * (1000 * 10);     // 1 sec
        deviceCapabilities->D2Latency  = 1 * (1000 * 10);     // 1
        deviceCapabilities->D3Latency  = 1 * (1000 * 10);     // 1

        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        break;

    case IRP_MN_START_DEVICE:

        status = Sbp2StartDevice (DeviceObject);

        Irp->IoStatus.Status = status;

        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:

        status = Irp->IoStatus.Status = STATUS_SUCCESS;

        break;

    case IRP_MN_STOP_DEVICE:

        //
        // Disable bus reset notifications
        //

        Sbp2EnableBusResetNotification (deviceExtension, FALSE);


        //
        // disable idle detection
        //

        PoRegisterDeviceForIdleDetection (DeviceObject, 0L, 0L, PowerDeviceD3);

        //
        // Cleanup
        //

        KeAcquireSpinLock (&deviceExtension->ExtensionDataSpinLock, &cIrql);

        if (!TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED)) {

            SET_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_PNP_STOPPED | DEVICE_FLAG_STOPPED)
                );

            KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);

            fdoExtension = (PFDO_DEVICE_EXTENSION)
                deviceExtension->BusFdo->DeviceExtension;

            ASSERT(!fdoExtension->ulWorkItemCount);

            ExAcquireFastMutex(&fdoExtension->ResetMutex);
            Sbp2ManagementTransaction (deviceExtension,TRANSACTION_LOGOUT);
            ExReleaseFastMutex(&fdoExtension->ResetMutex);

            Sbp2CleanDeviceExtension (DeviceObject,FALSE);

        } else {

            SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_PNP_STOPPED);

            KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);
        }

        Irp->IoStatus.Status = status = STATUS_SUCCESS;

        ASSERT(!deviceExtension->ulPendingEvents);
        ASSERT(!deviceExtension->ulInternalEventCount);
        break;

    case IRP_MN_BUS_RESET:

        //
        // Start of a PHY reset. We will re-connect asynchronously to the
        // target when our callback is called, so this is ignored..
        //
        // After a bus reset is complete, the bus driver should call our
        // BusResetNotification callback. When it does, we will attempt
        // to reconnect. If the reconnect completion status callback,
        // never fires, it means the following things:
        //
        // 1) The device never completed the RECONNECT, or
        // 2) The device completed the reconnect but because our
        //    controlller was BUSY or hosed we didnt get it
        //
        // If 1 or 2 happens, the timeout DPC queued in our bus reset
        // notification, should fire and attempt a relogin...
        //

        Irp->IoStatus.Status = status = STATUS_SUCCESS;

        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_REMOVED | DEVICE_FLAG_DEVICE_FAILED)
                ) &&

            !TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_RESET_IN_PROGRESS
                )){

            //
            // Set DEVICE_FLAG_REPORTED_FAILED so the SURPRISE_REMOVE
            // handler knows it didn't get called because of physical
            // hardware removal
            //

            KeAcquireSpinLock (&deviceExtension->ExtensionDataSpinLock,&cIrql);

            SET_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_REPORTED_FAILED
                );

            KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);

            //
            // indicate our device is disabled due to a failure..
            //

            Irp->IoStatus.Information |= PNP_DEVICE_FAILED;

            DEBUGPRINT2((
                "Sbp2Port: Pnp: QUERY_DEVICE_STATE, device FAILED!!!\n"
                ));
        }

        status = Irp->IoStatus.Status = STATUS_SUCCESS;

        break;

    case IRP_MN_DEVICE_USAGE_NOTIFICATION:

        switch (irpStack->Parameters.UsageNotification.Type) {

        case DeviceUsageTypePaging:

            count = &deviceExtension->PagingPathCount;
            break;

        case DeviceUsageTypeHibernation:

            count = &deviceExtension->HibernateCount;
            break;

        default:

            count = NULL;
            break;
        }

        if (count) {

            //
            // Send the irp down to see what everyone else thinks
            //

            status = Sbp2ForwardIrpSynchronous(deviceExtension->LowerDeviceObject, Irp);

            if (NT_SUCCESS(status)) {

                IoAdjustPagingPathCount(count, irpStack->Parameters.UsageNotification.InPath);

            }

        } else {

            status = STATUS_NOT_SUPPORTED;

        }

        Irp->IoStatus.Status = status;

        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        if (deviceExtension->PagingPathCount ||
            deviceExtension->HibernateCount  ||
            deviceExtension->CrashDumpCount) {

            status = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

        } else {

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            SET_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_REMOVE_PENDING);
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);
            status = Irp->IoStatus.Status = STATUS_SUCCESS;
        }

        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_REMOVE_PENDING);
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        status = Irp->IoStatus.Status = STATUS_SUCCESS;

        break;

    case IRP_MN_REMOVE_DEVICE:

        status = STATUS_SUCCESS;

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);

        SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_PNP_STOPPED);

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_SURPRISE_REMOVED
                )) {

            //
            // We already cleaned up in SURPRISE_REMOVAL handler.
            // Empty out the queue, wait for io to complete, then
            // delete the device, complete the request, & return.
            //

            KeReleaseSpinLock(
                &deviceExtension->ExtensionDataSpinLock,
                cIrql
                );

            KeRaiseIrql (DISPATCH_LEVEL, &cIrql);

            Sbp2StartNextPacketByKey (DeviceObject, 0);

            KeLowerIrql (cIrql);

            DEBUGPRINT2((
                "Sbp2Port: Pnp: wait for io compl pdo=x%p...\n",
                DeviceObject
                ));

            IoReleaseRemoveLockAndWait (&deviceExtension->RemoveLock, NULL);

            deviceExtension->Type = SBP2_PDO_DELETED;

            KeCancelTimer(&deviceExtension->DeviceManagementTimer);

            IoDeleteDevice (DeviceObject);

            DEBUGPRINT2((
                "Sbp2Port: Pnp: ......... deleted pdo=x%p\n", DeviceObject
                ));

            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);

            return status;
        }

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_REMOVE_PENDING
                )) {

            KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);

            //
            // If device is initialized & MgmtOrbCtx event is still around
            // then do a log out
            //

            if (TEST_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_INITIALIZED
                    )) {

                DEBUGPRINT1((
                    "Sbp2Port: Pnp: LOG OUT, since QUERY preceded RMV\n"
                    ));

                fdoExtension = (PFDO_DEVICE_EXTENSION)
                    deviceExtension->BusFdo->DeviceExtension;

                ExAcquireFastMutex(&fdoExtension->ResetMutex);
                Sbp2ManagementTransaction(deviceExtension,TRANSACTION_LOGOUT);
                ExReleaseFastMutex(&fdoExtension->ResetMutex);
            }

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);

            CLEAR_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_REMOVE_PENDING
                );

            SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED);

        } else if (!TEST_FLAG(
                        deviceExtension->DeviceFlags,
                        (DEVICE_FLAG_REMOVED | DEVICE_FLAG_DEVICE_FAILED)
                        )){

            //
            // If no query has preceded and NO SUPRISE_REMOVAL has preceded
            // this means we are running under win98, where physical device
            // removals are only indicated by only MN_REMOVES being sent,
            // with no QUERY_REMOVE prior to the remove.
            //

            if (deviceExtension->DeviceFlags ==
                    (DEVICE_FLAG_INITIALIZING | DEVICE_FLAG_STOPPED)  &&
                !SystemIsNT) {

                DEBUGPRINT1((
                    "Sbp2Port: Pnp: 9x REMOVE, don't delete dev\n"
                    ));

                deviceExtension->DeviceFlags =
                    DEVICE_FLAG_UNSTARTED_AND_REMOVED;

            } else {

                SET_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED);

                CLEAR_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_RESET_IN_PROGRESS | DEVICE_FLAG_RECONNECT |
                        DEVICE_FLAG_LOGIN_IN_PROGRESS
                    );

                DEBUGPRINT1((
                    "Sbp2Port: Pnp: Suprise removal, since QUERY " \
                        "did not precede REMOVE.\n"
                    ));
            }
        }

        CLEAR_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_CLAIMED);

        KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);

        if (!Sbp2CleanDeviceExtension (DeviceObject, TRUE)) {

            DEBUGPRINT1(("Sbp2Port: Pnp: Double remove\n"));
        }

        //
        // In all cases other than surprise removals, pdo's will get
        // deleted by the fdo remove handler
        //

        Irp->IoStatus.Status = status;

        break;

    case IRP_MN_SURPRISE_REMOVAL: {

        //
        // If device was reported failed (due to async login failure &
        // IoInvalidateDeviceState) then just set REMOVED & PNP_STOPPED
        // flags and clean up the device extension - we don't want to
        // delete the pdo at this point.
        //
        // Otherwise, assume physical device removal occured, in which
        // case we need to do our own cleanup & teardown right here
        // because the dev stack will start disintegrating.
        //
        // ISSUE: Per AdriaO, another case where we can get a
        //        SURPRISE_REMOVAL is if a START fails *after* a STOP
        //        - at any point in this pdo's stack!  Not sure how to
        //        tell whether or not this is the case if it's not
        //        SBP2PORT that failed the START, so leaving that case
        //        as is for now.  DanKn, 04-Jun-2001
        //

        BOOLEAN reportedMissing;

        KeAcquireSpinLock (&deviceExtension->ExtensionDataSpinLock, &cIrql);

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_REPORTED_FAILED
                )) {

            SET_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_REMOVED | DEVICE_FLAG_PNP_STOPPED)
                );

            reportedMissing = FALSE;

        } else {

            SET_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_REMOVED | DEVICE_FLAG_SURPRISE_REMOVED |
                    DEVICE_FLAG_PNP_STOPPED)
                );

            reportedMissing = TRUE;
        }

        CLEAR_FLAG(
            deviceExtension->DeviceFlags,
            (DEVICE_FLAG_RESET_IN_PROGRESS | DEVICE_FLAG_RECONNECT |
                DEVICE_FLAG_LOGIN_IN_PROGRESS | DEVICE_FLAG_REPORTED_FAILED)
            );

        KeReleaseSpinLock (&deviceExtension->ExtensionDataSpinLock, cIrql);

        Sbp2CleanDeviceExtension (DeviceObject, TRUE);

        if (reportedMissing) {

            Sbp2HandleRemove (DeviceObject);
        }

        Irp->IoStatus.Status = STATUS_SUCCESS;

        break;
    }
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

        //
        // PnP walks up the device tree looking for the FILE_CHAR flags,
        // and stops when it finds a node marked Removable. Since our pdo's
        // are marked Removable, PnP won't make it to a BUS1394 PDO, so we
        // need to propagate the FILE_CHAR flags here.
        //

        fdoExtension = (PFDO_DEVICE_EXTENSION)
            deviceExtension->BusFdo->DeviceExtension;

        DeviceObject->Characteristics |=
            (FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK &
            fdoExtension->Pdo->Characteristics);

        status = Irp->IoStatus.Status;

        break;

    default:

        status = Irp->IoStatus.Status;

        break;
    }

    //
    // This is the bottom of the stack, complete the request
    //

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
Sbp2FDOPnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This routine handles the PNP requests for FDO's

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

   NTSTATUS

--*/
{
    KEVENT                  event;
    NTSTATUS                status;
    PDEVICE_RELATIONS       deviceRelations;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_CAPABILITIES    deviceCapabilities;
    PFDO_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock(&fdoExtension->RemoveLock, NULL);

    if (!NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        return status;
    }

    switch (irpStack->MinorFunction) {

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        DEBUGPRINT3((
            "Sbp2Port: Pnp: ... Type = %x\n",
            irpStack->Parameters.QueryDeviceRelations.Type
            ));

        if (irpStack->Parameters.QueryDeviceRelations.Type != BusRelations) {

            break;
        }

        deviceRelations = ExAllocatePool(
            PagedPool,
            sizeof (*deviceRelations) +
                (SBP2_MAX_LUNS_PER_NODE * sizeof (PDEVICE_OBJECT))
            );

        if (!deviceRelations) {

            DEBUGPRINT1 (("Sbp2Port: Pnp: devRels alloc failed!!\n"));

            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        status = Sbp2CreateDeviceRelations (fdoExtension, deviceRelations);
        Irp->IoStatus.Status = status;

        if (NT_SUCCESS(status)) {

            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

        } else {

            Irp->IoStatus.Information = 0;

            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            return status;
        }

        break;

    case IRP_MN_QUERY_CAPABILITIES:

        deviceCapabilities =
            irpStack->Parameters.DeviceCapabilities.Capabilities;

        deviceCapabilities->SurpriseRemovalOK = TRUE;

        break;

    case IRP_MN_START_DEVICE:

        KeInitializeEvent (&event, SynchronizationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine(
            Irp,
            Sbp2FdoRequestCompletionRoutine,
            (PVOID) &event,
            TRUE,
            TRUE,
            TRUE
            );

        status = IoCallDriver (fdoExtension->LowerDeviceObject, Irp);

        if(!NT_SUCCESS(Irp->IoStatus.Status) && (status != STATUS_PENDING)) {

            status = Irp->IoStatus.Status;

        } else {

            KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

            status = Sbp2StartDevice (DeviceObject);
        }

        IoReleaseRemoveLock(&fdoExtension->RemoveLock, NULL);

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        return status;

    case IRP_MN_REMOVE_DEVICE:

        KeInitializeEvent (&event, SynchronizationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
            Irp,
            Sbp2FdoRequestCompletionRoutine,
            (PVOID) &event,
            TRUE,
            TRUE,
            TRUE
            );

        status = IoCallDriver (fdoExtension->LowerDeviceObject, Irp);

        if (!NT_SUCCESS (Irp->IoStatus.Status) && status != STATUS_PENDING) {

            status = Irp->IoStatus.Status;

        } else {

            KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);

            //
            // do FDO cleanup..
            //

            IoReleaseRemoveLockAndWait(&fdoExtension->RemoveLock, NULL);

            if (Sbp2CleanDeviceExtension (DeviceObject, TRUE)) {

                ASSERT(!fdoExtension->ulBusResetMutexCount);
                ASSERT(!fdoExtension->ulWorkItemCount);

                IoDetachDevice (fdoExtension->LowerDeviceObject);
                IoDeleteDevice (DeviceObject);
            }

            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);

        return status;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:

        Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;

        break;

    default:

        break;
    }

    IoReleaseRemoveLock(&fdoExtension->RemoveLock, NULL);

    //
    // Pass the irp down the stack
    //

    IoCopyCurrentIrpStackLocationToNext (Irp);

    status = IoCallDriver (fdoExtension->LowerDeviceObject, Irp);

    return status;
}


VOID
Sbp2HandleRemove(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PFDO_DEVICE_EXTENSION fdoExtension;
    KIRQL cIrql;
    ULONG i,j;
    PIRBIRP packet;

    fdoExtension = (PFDO_DEVICE_EXTENSION) deviceExtension->BusFdo->DeviceExtension;

    if (!TEST_FLAG (deviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED)) {

        return;
    }

    //
    // now we need to remove ourselves from the DeviceList, the sbp2 FDO keeps of its
    // children...
    // then we re-condense the list..
    //

    KeAcquireSpinLock (&fdoExtension->DeviceListLock,&cIrql);

    if (fdoExtension->DeviceListSize > 1) {

        DEBUGPRINT1(("\'Sbp2Cleanup, condensing PDO list\n"));

        for (i = 0; i < fdoExtension->DeviceListSize; i++) {

            if (fdoExtension->DeviceList[i].DeviceObject == DeviceObject) {

                //
                // free the model descriptor only if its not the same as the FDOs
                // this only happens in the multi-lu case
                //

                if (fdoExtension->DeviceList[i].uniVendorId.Buffer) {

                    ExFreePool(fdoExtension->DeviceList[i].uniVendorId.Buffer);
                    fdoExtension->DeviceList[i].uniVendorId.Length = 0;
                    fdoExtension->DeviceList[i].uniVendorId.Buffer = NULL;
                }

                if (fdoExtension->DeviceList[i].uniModelId.Buffer) {

                    ExFreePool(fdoExtension->DeviceList[i].uniModelId.Buffer);
                    fdoExtension->DeviceList[i].uniModelId.Length = 0;
                    fdoExtension->DeviceList[i].uniModelId.Buffer = NULL;
                }

                if (fdoExtension->DeviceList[i].uniGenericName.Buffer) {

                    ExFreePool(fdoExtension->DeviceList[i].uniGenericName.Buffer);
                    fdoExtension->DeviceList[i].uniGenericName.Length = 0;
                    fdoExtension->DeviceList[i].uniGenericName.Buffer = NULL;
                }

                //
                // we found our place in the list. Remove us and re-condense the list
                //

                for (j = i; j < fdoExtension->DeviceListSize; j++) {

                    if ((j + 1) < fdoExtension->DeviceListSize) {

                        fdoExtension->DeviceList[j] = fdoExtension->DeviceList[j+1];

                        //
                        // Change the (pdo)DevExt->DeviceInfo to point at
                        // the next postion in the device list
                        //

                        deviceExtension = fdoExtension->DeviceList[j].
                            DeviceObject->DeviceExtension;

                        deviceExtension->DeviceInfo =
                            &fdoExtension->DeviceList[j];
                    }
                }

                fdoExtension->DeviceListSize--;
            }
        }

    } else {

        if (fdoExtension->DeviceList[0].DeviceObject == DeviceObject) {

            if (fdoExtension->DeviceList[0].uniVendorId.Buffer) {

                ExFreePool(fdoExtension->DeviceList[0].uniVendorId.Buffer);
                fdoExtension->DeviceList[0].uniVendorId.Length = 0;
                fdoExtension->DeviceList[0].uniVendorId.Buffer = NULL;
            }

            if (fdoExtension->DeviceList[0].uniModelId.Buffer) {

                ExFreePool(fdoExtension->DeviceList[0].uniModelId.Buffer);
                fdoExtension->DeviceList[0].uniModelId.Length = 0;
                fdoExtension->DeviceList[0].uniModelId.Buffer = NULL;
            }

            if (fdoExtension->DeviceList[0].uniGenericName.Buffer) {

                ExFreePool(fdoExtension->DeviceList[0].uniGenericName.Buffer);
                fdoExtension->DeviceList[0].uniGenericName.Length = 0;
                fdoExtension->DeviceList[0].uniGenericName.Buffer = NULL;
            }
        }

        fdoExtension->DeviceList[0].DeviceObject = NULL;
        fdoExtension->DeviceListSize = 0;

        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZED);
    }

    if (fdoExtension->DeviceListSize == 0) {

        //
        // all our children have been deleted, set our FDO to be inactive
        // so it can not re create  PDOs qhen it receives a QDR.
        // The reaosn is that if our PDOS are all removed, we dont support
        // dynamic changes ot the crom, which would then warrant us being
        //  able to eject PDOs again.
        //

        SET_FLAG(fdoExtension->DeviceFlags, DEVICE_FLAG_STOPPED);

        KeReleaseSpinLock (&fdoExtension->DeviceListLock, cIrql);

        //
        // Disable bus reset notifications
        //

        AllocateIrpAndIrb ((PDEVICE_EXTENSION) fdoExtension, &packet);

        if (packet) {

            packet->Irb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
            packet->Irb->Flags = 0;
            packet->Irb->u.BusResetNotification.fulFlags = DEREGISTER_NOTIFICATION_ROUTINE;

            Sbp2SendRequest(
                (PDEVICE_EXTENSION) fdoExtension,
                packet,
                SYNC_1394_REQUEST
                );

            DeAllocateIrpAndIrb((PDEVICE_EXTENSION)fdoExtension,packet);
        }

        fdoExtension->NumPDOsStarted = 0;

    } else {

        KeReleaseSpinLock (&fdoExtension->DeviceListLock, cIrql);
    }

}


NTSTATUS
Sbp2FdoRequestCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
Sbp2CreateDeviceRelations(
    IN PFDO_DEVICE_EXTENSION FdoExtension,
    IN PDEVICE_RELATIONS DeviceRelations
    )
{
    ULONG i;
    NTSTATUS status;
    ULONG instanceNum;

    PAGED_CODE();

    //
    // LUNS are static in the Config Rom. so if our DeviceListSize >0, that objetc
    // has been seen before
    //

    DeviceRelations->Count = 0;

    status = Sbp2Get1394ConfigInfo (FdoExtension, NULL);

    if (!NT_SUCCESS(status)) {

        ExFreePool (DeviceRelations);
        return status;
    }

    if (TEST_FLAG (FdoExtension->DeviceFlags,DEVICE_FLAG_STOPPED)) {

        ExFreePool(DeviceRelations);
        return STATUS_UNSUCCESSFUL;
    }

    for (i = 0; i < FdoExtension->DeviceListSize; i++) {

        if (!FdoExtension->DeviceList[i].DeviceObject) {

            instanceNum = 0;

            do {

                status = Sbp2CreatePdo (FdoExtension,&FdoExtension->DeviceList[i],instanceNum++);

            } while (status == STATUS_OBJECT_NAME_COLLISION);

            if (!NT_SUCCESS(status)) {

                DEBUGPRINT1(("\'Sbp2CreateDeviceRelations, Failed to create PDO \n"));

                ExFreePool (DeviceRelations);
                return status;
            }

            DeviceRelations->Objects[DeviceRelations->Count] = FdoExtension->DeviceList[i].DeviceObject;
            DeviceRelations->Count++;
            ObReferenceObject (FdoExtension->DeviceList[i].DeviceObject);

        } else {

            //
            // On NT we always add existing pdo's to the dev relations list.
            //
            // On 9x, we only add pdo's to the list whose DevFlags field
            // is non-zero. If we see a pdo with a zero DevFlags field
            // then that means it was never started (likely for lack of
            // a driver), and we don't want to re-indicate it to the caller.
            // The pdo will eventually get deleted when cleaning up the fdo.
            //

            if (!SystemIsNT) {

                PDEVICE_EXTENSION   pdoExtension;


                pdoExtension = (PDEVICE_EXTENSION)
                    FdoExtension->DeviceList[i].DeviceObject->DeviceExtension;

                if (pdoExtension->DeviceFlags &
                        DEVICE_FLAG_UNSTARTED_AND_REMOVED) {

                    ASSERT(pdoExtension->DeviceFlags == DEVICE_FLAG_UNSTARTED_AND_REMOVED);

                    DEBUGPRINT2((
                        "Sbp2Port: CreateDevRelations: excluding ext=x%x\n",
                        pdoExtension
                        ));

                    continue;
                }
            }

            DeviceRelations->Objects[DeviceRelations->Count] =
                FdoExtension->DeviceList[i].DeviceObject;
            DeviceRelations->Count++;
            ObReferenceObject (FdoExtension->DeviceList[i].DeviceObject);
        }
    }

    return STATUS_SUCCESS;
}

//
// code below ported from scsiport
//

NTSTATUS
Sbp2SystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This routine handles only the WMI related requests. It mostly passes everything down

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

   NTSTATUS

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;


    if (deviceExtension->Type == SBP2_FDO) {

        DEBUGPRINT2(("Sbp2Port: WmiCtl: irp=x%p not handled, passing it down\n", Irp));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        return (IoCallDriver(deviceExtension->LowerDeviceObject, Irp));

    } else {

        status = Irp->IoStatus.Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }
}

/* ******************************* POWER MANAGEMENT ********************************/


NTSTATUS
Sbp2PowerControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine receives the various Power messages

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PFDO_DEVICE_EXTENSION   fdoExtension;
    PIO_STACK_LOCATION irpStack;
    PIO_COMPLETION_ROUTINE complRoutine;
    KIRQL cIrql;
    NTSTATUS status;
    POWER_STATE State;
    UCHAR minorFunction;


    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);

    DEBUGPRINT2((
        "Sbp2Port: Power: %sExt=x%p, irp=x%p, minor=x%x\n",
        (deviceExtension->Type == SBP2_FDO ? "fdo" : "pdo"),
        deviceExtension,
        Irp,
        irpStack->MinorFunction
        ));

    switch (deviceExtension->Type) {

    case SBP2_PDO:

        status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);

        if (!NT_SUCCESS (status)) {

            DEBUGPRINT2((
                "Sbp2Port: Power:   pdoExt=x%p REMOVED!\n",
                deviceExtension
                ));

            Irp->IoStatus.Status = status;
            PoStartNextPowerIrp (Irp);
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            return status;
        }

        switch ((minorFunction = irpStack->MinorFunction)) {

        case IRP_MN_SET_POWER:

            DEBUGPRINT2(("Sbp2Port: Power:   Type = %d, State = %d\n",
                irpStack->Parameters.Power.Type,irpStack->Parameters.Power.State.DeviceState));

            State = irpStack->Parameters.Power.State;

            if (irpStack->Parameters.Power.Type == SystemPowerState) {

                BOOLEAN sendDIrp = FALSE;


                //
                // make up a device state to correspond to a system state
                //

                DEBUGPRINT2(("Sbp2Port: Power:   sys power chg from %x to %x\n",deviceExtension->SystemPowerState,State));

                status = STATUS_SUCCESS;

                KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);

                if (State.SystemState >= PowerSystemShutdown) {

                    //
                    // dont do anything for shutdown
                    //

                    DEBUGPRINT2(("Sbp2Port: Power:   sys shutdown, ignoring\n"));
                    deviceExtension->SystemPowerState = State.SystemState;

                } else if ((deviceExtension->SystemPowerState == PowerSystemWorking) &&
                    (State.SystemState != PowerSystemWorking)){

                    deviceExtension->SystemPowerState = State.SystemState;

                    if (deviceExtension->DevicePowerState != PowerDeviceD3) {

                        //
                        // Powering down
                        //

                        State.DeviceState = PowerDeviceD3;
                        sendDIrp = TRUE;
                    }

                } else if (State.SystemState == PowerSystemWorking) {

                    deviceExtension->SystemPowerState = State.SystemState;

                    if (deviceExtension->DevicePowerState != PowerDeviceD0) {

                        //
                        // Powering up - check for an absent fdo
                        //

                        fdoExtension =
                            deviceExtension->BusFdo->DeviceExtension;

                        if (TEST_FLAG(
                                fdoExtension->DeviceFlags,
                                DEVICE_FLAG_ABSENT_ON_POWER_UP
                                )) {

                            SET_FLAG(
                                deviceExtension->DeviceFlags,
                                DEVICE_FLAG_ABSENT_ON_POWER_UP
                                );

                            DEBUGPRINT1((
                                "Sbp2Port: Power:   dev absent, failing\n"
                                ));

                            status = STATUS_NO_SUCH_DEVICE;

                        } else {

                            State.DeviceState = PowerDeviceD0;
                            sendDIrp = TRUE;
                        }
                    }
                }

                KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

                if (sendDIrp) {

                    DEBUGPRINT2((
                        "Sbp2Port: Power:   ext=x%p send D irp for state %d\n",
                        deviceExtension,
                        State
                        ));

                    IoMarkIrpPending (Irp);

                    status = PoRequestPowerIrp(
                            DeviceObject,
                            IRP_MN_SET_POWER,
                            State,
                            Sbp2PdoDIrpCompletion,
                            Irp,
                            NULL);

                    if (NT_SUCCESS (status)) {

                        return STATUS_PENDING;
                    }

                    irpStack->Control &= ~SL_PENDING_RETURNED;

                    DEBUGPRINT1((
                        "Sbp2Port: Power: ext=x%p PoReqPowerIrp err=x%x\n",
                        deviceExtension,
                        status
                        ));
                }

                Irp->IoStatus.Status = status;
                PoStartNextPowerIrp (Irp);
                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                IoCompleteRequest(Irp,IO_NO_INCREMENT);
                return status;

            } else {

                DEBUGPRINT2(("Sbp2Port: Power:   dev power chg from %x to %x\n",deviceExtension->DevicePowerState,State));
                KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
                deviceExtension->DevicePowerState = State.DeviceState;
                KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);
            }

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        case IRP_MN_QUERY_POWER:

            status = STATUS_SUCCESS;
            break;

        default:

            status = Irp->IoStatus.Status;
            break;
        }

        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        if ((minorFunction == IRP_MN_SET_POWER) &&
            (State.DeviceState == PowerDeviceD0)) {

            //
            // restart our queue if we had to queue something while powering up
            //
            // ISSUE: This may be bad - there is already some logic in
            //        SBP2SCSI.C to restart the queue on power up, i.e.
            //        the UNLOCK_QUEUE handler. For now i am at least
            //        limiting this to SET_POWER irps when state is D0
            //        DanKn 02-Jun-2001
            //

            KeRaiseIrql (DISPATCH_LEVEL, &cIrql);

            Sbp2StartNextPacketByKey(
                DeviceObject,
                deviceExtension->CurrentKey
                );

            KeLowerIrql (cIrql);
        }

        IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);

        return (status);

    case SBP2_FDO:

        fdoExtension = (PFDO_DEVICE_EXTENSION) deviceExtension;

        complRoutine = NULL;

        if (irpStack->MinorFunction == IRP_MN_SET_POWER) {

            DEBUGPRINT2((
                "Sbp2Port: Power:   Type = %d, State = %d\n",
                irpStack->Parameters.Power.Type,
                irpStack->Parameters.Power.State.DeviceState
                ));

            if (irpStack->Parameters.Power.Type == SystemPowerState) {

                State = irpStack->Parameters.Power.State;

                DEBUGPRINT2((
                    "Sbp2Port: Power:   sys power chg from %x to %x\n",
                    fdoExtension->SystemPowerState,
                    State
                    ));

                if (State.SystemState >= PowerSystemShutdown) {

                    //
                    // Shutdown  (setting state here, the assumption being
                    // that we're shutting down regardless of the
                    // completion status of this request)
                    //

                    fdoExtension->SystemPowerState = State.SystemState;

                } else if ((fdoExtension->SystemPowerState ==
                                PowerSystemWorking) &&

                           (State.SystemState != PowerSystemWorking)) {

                    //
                    // Power down.  If DevPowerState != D3 then send
                    // a D irp first (when that completes successfully
                    // we'll continue with the S irp), else just
                    // set the completion routine so we can update
                    // the system state field in our extension on
                    // successful completion of this S irp.
                    //

                    if (fdoExtension->DevicePowerState != PowerDeviceD3) {

                        //
                        // Power down, send a D irp first
                        //

                        IoMarkIrpPending (Irp);

                        fdoExtension->SystemPowerIrp = Irp;

                        State.DeviceState = PowerDeviceD3;

                        DEBUGPRINT2((
                            "Sbp2Port: Power:   ext=x%p sending D irp for state %x\n",
                            deviceExtension,
                            State
                            ));

                        status = PoRequestPowerIrp(
                            fdoExtension->Pdo,
                            IRP_MN_SET_POWER,
                            State,
                            Sbp2FdoDIrpCompletion,
                            fdoExtension,
                            NULL
                            );

                        if (!NT_SUCCESS (status)) {

                            DEBUGPRINT1((
                                "Sbp2Port: Power: ext=x%p PoReqPowerIrp err=x%x\n",
                                fdoExtension,
                                status
                                ));

                            irpStack->Control &= ~SL_PENDING_RETURNED;
                            Irp->IoStatus.Status = status;
                            PoStartNextPowerIrp (Irp);
                            IoCompleteRequest (Irp,IO_NO_INCREMENT);
                        }

                        return status;

                    } else {

                        complRoutine = Sbp2FdoSIrpCompletion;
                    }

                } else if (State.SystemState == PowerSystemWorking) {

                    //
                    // Power up.  Set the completion routine so we
                    // follow up with a D irp or update the system
                    // state field in our extension on successful
                    // completion of this S irp.
                    //

                    complRoutine = Sbp2FdoSIrpCompletion;
                }
            }
        }

        PoStartNextPowerIrp (Irp);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        if (complRoutine) {

            IoSetCompletionRoutine(
                Irp,
                Sbp2FdoSIrpCompletion,
                NULL,
                TRUE,
                TRUE,
                TRUE
                );
        }

        return (PoCallDriver (deviceExtension->LowerDeviceObject, Irp));

    default:

        break;
    }

    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    PoStartNextPowerIrp (Irp);
    IoCompleteRequest (Irp,IO_NO_INCREMENT);
    return STATUS_NO_SUCH_DEVICE;
}


VOID
Sbp2PdoDIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    ASSERT(deviceExtension->Type == SBP2_PDO);

    if (SIrp) {

        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation (SIrp);
        SYSTEM_POWER_STATE state = irpStack->Parameters.Power.State.SystemState;

        DEBUGPRINT1((
            "Sbp2Port: PdoDIrpCompl: ext=x%p, sIrp=x%p, state=%d, status=x%x\n",
            deviceExtension,
            SIrp,
            PowerState.DeviceState,
            IoStatus->Status
            ));

        SIrp->IoStatus.Status = STATUS_SUCCESS;

        PoStartNextPowerIrp (SIrp);
        IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
        IoCompleteRequest (SIrp, IO_NO_INCREMENT);
    }
}


NTSTATUS
Sbp2FdoSIrpCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Unused
    )
{
    KIRQL                   cIrql;
    NTSTATUS                status = Irp->IoStatus.Status;
    POWER_STATE             state;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation (Irp);
    PFDO_DEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;


    state = irpStack->Parameters.Power.State;

    DEBUGPRINT1((
        "Sbp2Port: FdoSIrpCompl: fdoExt=x%p, status=x%x, state=%d\n",
        fdoExtension,
        status,
        state
        ));

    if (!NT_SUCCESS (status)) {

        if ((status == STATUS_NO_SUCH_DEVICE)  &&
            (state.SystemState == PowerSystemWorking)) {

            //
            // Controller (i.e. pc card) was ejected while powered down
            //

            SET_FLAG(
                fdoExtension->DeviceFlags,
                DEVICE_FLAG_ABSENT_ON_POWER_UP
                );
        }

        PoStartNextPowerIrp (Irp);
        return STATUS_SUCCESS;
    }

    //
    // If we're completing a power up S irp then see if we have
    // to follow up with a power up D irp
    //

    if ((state.SystemState == PowerSystemWorking)  &&
        (fdoExtension->DevicePowerState != PowerDeviceD0)) {

        fdoExtension->SystemPowerIrp = Irp;

        state.DeviceState = PowerDeviceD0;

        DEBUGPRINT1(("Sbp2Port: FdoSIrpCompl: sending D irp...\n"));

        status = PoRequestPowerIrp(
            fdoExtension->Pdo,
            IRP_MN_SET_POWER,
            state,
            Sbp2FdoDIrpCompletion,
            fdoExtension,
            NULL
            );

        if (!NT_SUCCESS (status)) {

            DEBUGPRINT1((
                "Sbp2Port: FdoSIrpCompl: ERROR! fdoExt=x%p, D irp sts=x%x\n",
                fdoExtension,
                status
                ));

            Irp->IoStatus.Status = status;
            PoStartNextPowerIrp (Irp);
            return status;
        }

        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    //
    // Update appropriate XxxPowerState extension fields
    //

    if ((fdoExtension->SystemPowerState == PowerSystemWorking)  &&
        (state.SystemState != PowerSystemWorking)) {

        //
        // Power down (might not have sent a D irp but it doesn't
        // hurt to overwrite the DevicePowerState field anyway)
        //

        fdoExtension->SystemPowerState = state.SystemState;
        fdoExtension->DevicePowerState = PowerDeviceD3;

    } else if (state.SystemState == PowerSystemWorking) {

        //
        // Power up
        //

        fdoExtension->SystemPowerState = PowerSystemWorking;
    }

    PoStartNextPowerIrp (Irp);

    return STATUS_SUCCESS;
}


VOID
Sbp2FdoDIrpCompletion(
    IN PDEVICE_OBJECT           TargetDeviceObject,
    IN UCHAR                    MinorFunction,
    IN POWER_STATE              PowerState,
    IN PFDO_DEVICE_EXTENSION    FdoExtension,
    IN PIO_STATUS_BLOCK         IoStatus
    )
{
    PIRP    sIrp = FdoExtension->SystemPowerIrp;


    DEBUGPRINT1((
        "Sbp2Port: FdoDIrpCompl: ext=x%p, status=x%x\n",
        FdoExtension,
        IoStatus->Status
        ));

    FdoExtension->SystemPowerIrp = NULL;

    if (NT_SUCCESS (IoStatus->Status)) {

        if (PowerState.DeviceState == PowerDeviceD0) {

            //
            // Power up, update the XxxPowerState extension fields &
            // complete the s irp
            //

            FdoExtension->SystemPowerState = PowerSystemWorking;
            FdoExtension->DevicePowerState = PowerDeviceD0;

        } else {

            //
            // Power down, forward the s irp
            //

            PoStartNextPowerIrp (sIrp);
            IoCopyCurrentIrpStackLocationToNext (sIrp);
            PoCallDriver (FdoExtension->LowerDeviceObject, sIrp);

            return;
        }

    } else {

        //
        // Propagate the error to the S irp & complete it
        //

        DEBUGPRINT1((
            "Sbp2Port: FdoDIrpCompl: ERROR! fdoExt=x%p, D irp status=x%x\n",
            FdoExtension,
            IoStatus->Status
            ));

        sIrp->IoStatus.Status = IoStatus->Status;
    }

    PoStartNextPowerIrp (sIrp);
    IoCompleteRequest (sIrp, IO_NO_INCREMENT);
}


BOOLEAN
Sbp2EnableBusResetNotification(
    PDEVICE_EXTENSION   DeviceExtension,
    BOOLEAN             Enable
    )
/*++

Routine Description:

    This routine serializes the enabling/disabling of the bus reset
    notification routine for a set of related PDOs (1 or more).
    Enables bus reset notifications for the first device to start, and
    disables bus reset notifications when the last started device stops.

Arguments:

    DeviceObject - Supplies a pointer to the device extension for this request.

    StartDevice - Whether we are processing a START_DEVICE or (implicitly)
                  a STOP_DEVICE request.

Return Value:

   BOOLEAN - yay or nay

--*/
{
    BOOLEAN                 result = TRUE;
    PIRBIRP                 packet;
    LARGE_INTEGER           waitValue;
    PFDO_DEVICE_EXTENSION   fdoExtension;


    fdoExtension = DeviceExtension->BusFdo->DeviceExtension;

    ASSERT(InterlockedIncrement(&fdoExtension->ulBusResetMutexCount) == 1);

    waitValue.QuadPart = -3 * 1000 * 1000 * 10; // 3 seconds

    KeWaitForSingleObject(
        &fdoExtension->EnableBusResetNotificationMutex,
        Executive,
        KernelMode,
        FALSE,
        &waitValue
        );

    ASSERT(InterlockedDecrement(&fdoExtension->ulBusResetMutexCount) == 0);

    if (Enable) {

        fdoExtension->NumPDOsStarted++;

        if (fdoExtension->NumPDOsStarted > 1) {

            goto releaseMutex;
        }

    } else {

        fdoExtension->NumPDOsStarted--;

        if (fdoExtension->NumPDOsStarted > 0) {

            goto releaseMutex;
        }
    }

    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (packet) {

        packet->Irb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
        packet->Irb->Flags = 0;

        if (Enable) {

            packet->Irb->u.BusResetNotification.fulFlags =
                REGISTER_NOTIFICATION_ROUTINE;
            packet->Irb->u.BusResetNotification.ResetRoutine =
                (PBUS_BUS_RESET_NOTIFICATION) Sbp2BusResetNotification;
            packet->Irb->u.BusResetNotification.ResetContext =
                fdoExtension;

        } else {

            packet->Irb->u.BusResetNotification.fulFlags =
                DEREGISTER_NOTIFICATION_ROUTINE;
        }

        Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

        DeAllocateIrpAndIrb (DeviceExtension,packet);

    } else {

        if (Enable) {

            fdoExtension->NumPDOsStarted--;
        }

        result = FALSE;
    }

releaseMutex:

    KeReleaseMutex (&fdoExtension->EnableBusResetNotificationMutex, FALSE);

    return result;
}

NTSTATUS
Sbp2_BuildDeviceId(
    IN PDEVICE_INFORMATION  DeviceInfo,
    IN OUT PUNICODE_STRING  uniDeviceId
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Create the DeviceId
    //
    uniDeviceId->Length = 0;
    uniDeviceId->MaximumLength = DEVICE_NAME_MAX_CHARS*3;
    uniDeviceId->Buffer = ExAllocatePool(PagedPool, uniDeviceId->MaximumLength);

    if (!uniDeviceId->Buffer) {

        TRACE(TL_PNP_ERROR, ("Failed to allocate uniDeviceId->Buffer"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2_BuildDeviceId;
    }
    RtlZeroMemory(uniDeviceId->Buffer, uniDeviceId->MaximumLength);

    // Format: SBP2\\<VendorName>&<ModelName>&LUN<#>
    if ((DeviceInfo->uniVendorId.Buffer) && (DeviceInfo->uniModelId.Buffer)) {

        swprintf( uniDeviceId->Buffer,
                  L"SBP2\\%ws&%ws&LUN%x",
                  DeviceInfo->uniVendorId.Buffer,
                  DeviceInfo->uniModelId.Buffer,
                  DeviceInfo->Lun.u.LowPart
                  );
    }
    else {

        swprintf( uniDeviceId->Buffer,
                  L"SBP2\\UNKNOWN VENDOR&UNKNOWN MODEL&LUN%x",
                  DeviceInfo->Lun.u.LowPart
                  );
    }

Exit_Sbp2_BuildDeviceId:

    return(ntStatus);
} // Sbp2_BuildDeviceId

NTSTATUS
Sbp2_BuildHardwareIds(
    IN PDEVICE_INFORMATION  DeviceInfo,
    IN OUT PUNICODE_STRING  uniHardwareIds
    )
{
    NTSTATUS        ntStatus = STATUS_SUCCESS;

    UNICODE_STRING  uniLunNumber;
    UNICODE_STRING  uniCmdSetId;

    PAGED_CODE();

    // init our unicodes in case of error...
    uniLunNumber.Buffer  = NULL;
    uniCmdSetId.Buffer   = NULL;

    //
    // Create uniLunNumber
    //
    uniLunNumber.Length = 0;
    uniLunNumber.MaximumLength = DEVICE_NAME_MAX_CHARS;
    uniLunNumber.Buffer = ExAllocatePool(PagedPool, uniLunNumber.MaximumLength);

    if (!uniLunNumber.Buffer) {

        TRACE(TL_PNP_ERROR, ("Failed to allocate uniLunNumber.Buffer"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2_BuildHardwareIds;
    }
    RtlZeroMemory(uniLunNumber.Buffer, uniLunNumber.MaximumLength);

    RtlIntegerToUnicodeString(DeviceInfo->Lun.u.LowPart, 16, &uniLunNumber);

    //
    // Create uniCmdSetId
    //
    uniCmdSetId.Length = 0;
    uniCmdSetId.MaximumLength = DEVICE_NAME_MAX_CHARS;
    uniCmdSetId.Buffer = ExAllocatePool(PagedPool, uniCmdSetId.MaximumLength);

    if (!uniCmdSetId.Buffer) {

        TRACE(TL_PNP_ERROR, ("Failed to allocate uniCmdSetId.Buffer"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2_BuildHardwareIds;
    }
    RtlZeroMemory(uniCmdSetId.Buffer, uniCmdSetId.MaximumLength);

    RtlIntegerToUnicodeString(DeviceInfo->CmdSetId.QuadPart, 16, &uniCmdSetId);

    //
    // Create the HardwareIds
    //
    uniHardwareIds->Length = 0;
    uniHardwareIds->MaximumLength = DEVICE_NAME_MAX_CHARS*5;
    uniHardwareIds->Buffer = ExAllocatePool(PagedPool, uniHardwareIds->MaximumLength);

    if (!uniHardwareIds->Buffer) {

        TRACE(TL_PNP_ERROR, ("Failed to allocate uniHardwareIds->Buffer"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2_BuildHardwareIds;
    }
    RtlZeroMemory(uniHardwareIds->Buffer, uniHardwareIds->MaximumLength);

    // 1. SBP2\<Vendor>&<Model>&CmdSetId<number,base16>&Gen<dev type, ie. Disk>

    // BASE: SBP2
    RtlAppendUnicodeToString(uniHardwareIds, BASE_SBP2_DEVICE_NAME);

    // VendorName and ModelName
    if ((DeviceInfo->uniVendorId.Buffer) && (DeviceInfo->uniModelId.Buffer)) {

        RtlAppendUnicodeStringToString(uniHardwareIds, &DeviceInfo->uniVendorId);
        RtlAppendUnicodeToString(uniHardwareIds, L"&");
        RtlAppendUnicodeStringToString(uniHardwareIds, &DeviceInfo->uniModelId);
    }
    else {

        RtlAppendUnicodeToString(uniHardwareIds, L"UNKNOWN VENDOR&UNKNOWN MODEL");
    }
    RtlAppendUnicodeToString(uniHardwareIds, L"&");

    // CmdSetId
    RtlAppendUnicodeToString(uniHardwareIds, L"CmdSetId");
    RtlAppendUnicodeStringToString(uniHardwareIds, &uniCmdSetId);
    RtlAppendUnicodeToString(uniHardwareIds, L"&");

    // GenericName
    RtlAppendUnicodeStringToString(uniHardwareIds, &DeviceInfo->uniGenericName);

    uniHardwareIds->Length += sizeof(WCHAR);

    // 2. SBP2\<Vendor>&<Model>&CmdSetId<number,base16>

    // BASE: SBP2
    RtlAppendUnicodeToString(uniHardwareIds, BASE_SBP2_DEVICE_NAME);

    // VendorName and ModelName
    if ((DeviceInfo->uniVendorId.Buffer) && (DeviceInfo->uniModelId.Buffer)) {

        RtlAppendUnicodeStringToString(uniHardwareIds, &DeviceInfo->uniVendorId);
        RtlAppendUnicodeToString(uniHardwareIds, L"&");
        RtlAppendUnicodeStringToString(uniHardwareIds, &DeviceInfo->uniModelId);
    }
    else {

        RtlAppendUnicodeToString(uniHardwareIds, L"UNKNOWN VENDOR&UNKNOWN MODEL");
    }
    RtlAppendUnicodeToString(uniHardwareIds, L"&");

    // CmdSetId
    RtlAppendUnicodeToString(uniHardwareIds, L"CmdSetId");
    RtlAppendUnicodeStringToString(uniHardwareIds, &uniCmdSetId);

    uniHardwareIds->Length += sizeof(WCHAR);

    // 3. SBP2\<Vendor>&<Model>&LUN<number,base16>

    // BASE: SBP2
    RtlAppendUnicodeToString(uniHardwareIds, BASE_SBP2_DEVICE_NAME);

    // VendorName and ModelName
    if ((DeviceInfo->uniVendorId.Buffer) && (DeviceInfo->uniModelId.Buffer)) {

        RtlAppendUnicodeStringToString(uniHardwareIds, &DeviceInfo->uniVendorId);
        RtlAppendUnicodeToString(uniHardwareIds, L"&");
        RtlAppendUnicodeStringToString(uniHardwareIds, &DeviceInfo->uniModelId);
    }
    else {

        RtlAppendUnicodeToString(uniHardwareIds, L"UNKNOWN VENDOR&UNKNOWN MODEL");
    }
    RtlAppendUnicodeToString(uniHardwareIds, L"&");

    // LunNumber
    RtlAppendUnicodeToString(uniHardwareIds, L"LUN");
    RtlAppendUnicodeStringToString(uniHardwareIds, &uniLunNumber);

    uniHardwareIds->Length += sizeof(WCHAR);

    // 4. SBP2\Gen<dev type, i.e. Disk>

    // BASE: SBP2
    RtlAppendUnicodeToString(uniHardwareIds, BASE_SBP2_DEVICE_NAME);

    // GenericName
    RtlAppendUnicodeStringToString(uniHardwareIds, &DeviceInfo->uniGenericName);

    uniHardwareIds->Length += sizeof(WCHAR);

    // 5. Gen<dev type, i.e Disk>

    // GenericName
    RtlAppendUnicodeStringToString(uniHardwareIds, &DeviceInfo->uniGenericName);

Exit_Sbp2_BuildHardwareIds:

    if (uniLunNumber.Buffer)
        ExFreePool(uniLunNumber.Buffer);

    if (uniCmdSetId.Buffer)
        ExFreePool(uniCmdSetId.Buffer);

    return(ntStatus);
} // Sbp2_BuildHardwareIds

NTSTATUS
Sbp2_BuildCompatIds(
    IN PDEVICE_INFORMATION  DeviceInfo,
    IN OUT PUNICODE_STRING  uniCompatIds
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Create the CompatIds
    //
    uniCompatIds->Length = 0;
    uniCompatIds->MaximumLength = DEVICE_NAME_MAX_CHARS;
    uniCompatIds->Buffer = ExAllocatePool(PagedPool, uniCompatIds->MaximumLength);

    if (!uniCompatIds->Buffer) {

        TRACE(TL_PNP_ERROR, ("Failed to allocate uniCompatIds->Buffer"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2_BuildCompatIds;
    }
    RtlZeroMemory(uniCompatIds->Buffer, uniCompatIds->MaximumLength);

    // Format: SBP2\\<CmdSetSpecId,base10>&<CmdSetId,base10>&<Lun,base10>

    swprintf( uniCompatIds->Buffer,
              L"SBP2\\%d&%d&%d",
              DeviceInfo->CmdSetSpecId.QuadPart,
              DeviceInfo->CmdSetId.QuadPart,
              (ULONG)(DeviceInfo->Lun.u.HighPart & 0x001F) // huh?
              );

Exit_Sbp2_BuildCompatIds:

    return(ntStatus);
} // Sbp2_BuildCompatIds

NTSTATUS
Sbp2_BuildInstanceId(
    IN PDEVICE_INFORMATION  DeviceInfo,
    IN OUT PUNICODE_STRING  uniInstanceId
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Create the InstanceId
    //
    uniInstanceId->Length = 0;
    uniInstanceId->MaximumLength = UNIQUE_ID_MAX_CHARS;
    uniInstanceId->Buffer = ExAllocatePool(PagedPool, uniInstanceId->MaximumLength);

    if (!uniInstanceId->Buffer) {

        TRACE(TL_PNP_ERROR, ("Failed to allocate uniInstanceId->Buffer"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2_BuildInstanceId;
    }
    RtlZeroMemory(uniInstanceId->Buffer, uniInstanceId->MaximumLength);

    swprintf( uniInstanceId->Buffer,
              L"%08x%08x",
              bswap(DeviceInfo->ConfigRom->CR_Node_UniqueID[0]),
              bswap(DeviceInfo->ConfigRom->CR_Node_UniqueID[1])
              );

Exit_Sbp2_BuildInstanceId:

    return(ntStatus);
} // Sbp2_BuildInstanceId

NTSTATUS
Sbp2_BuildDeviceText(
    IN DEVICE_TEXT_TYPE     TextType,
    IN PDEVICE_INFORMATION  DeviceInfo,
    IN OUT PUNICODE_STRING  uniDeviceText
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Create the DeviceText
    //
    uniDeviceText->Length = 0;
    uniDeviceText->MaximumLength = DEVICE_NAME_MAX_CHARS*3;
    uniDeviceText->Buffer = ExAllocatePool(PagedPool, uniDeviceText->MaximumLength);

    if (!uniDeviceText->Buffer) {

        TRACE(TL_PNP_ERROR, ("Failed to allocate uniDeviceText->Buffer"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2_BuildDeviceText;
    }
    RtlZeroMemory(uniDeviceText->Buffer, uniDeviceText->MaximumLength);

    if (TextType == DeviceTextDescription) {

        if ((DeviceInfo->uniVendorId.Buffer) && (DeviceInfo->uniModelId.Buffer)) {

            swprintf( uniDeviceText->Buffer,
                      L"%ws %ws IEEE 1394 SBP2 Device",
                      DeviceInfo->uniVendorId.Buffer,
                      DeviceInfo->uniModelId.Buffer
                      );
        }
        else {

            swprintf( uniDeviceText->Buffer,
                      L"UNKNOWN VENDOR AND MODEL IEEE 1394 SBP2 Device"
                      );
        }
    }
    else if (TextType == DeviceTextLocationInformation) {

        swprintf( uniDeviceText->Buffer,
                  L"LUN %d",
                  DeviceInfo->Lun.u.LowPart
                  );
    }

Exit_Sbp2_BuildDeviceText:

    return(ntStatus);
} // Sbp2_BuildDeviceText


NTSTATUS
Sbp2ForwardIrpSynchronous(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIRP  newIrp;

    PAGED_CODE();

    ASSERT(DeviceObject);

    newIrp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (newIrp)
    {
        PIO_STACK_LOCATION currentIrpSp = IoGetCurrentIrpStackLocation(Irp);
        PIO_STACK_LOCATION newIrpSp = IoGetNextIrpStackLocation(newIrp);

        KEVENT event;

        RtlMoveMemory (newIrpSp, currentIrpSp, sizeof(IO_STACK_LOCATION));
        newIrp->IoStatus = Irp->IoStatus;

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoSetCompletionRoutine(newIrp, Sbp2PortForwardIrpSynchronousCompletionRoutine, &event, TRUE, TRUE, TRUE);

        ntStatus = IoCallDriver (DeviceObject, newIrp);

        if (ntStatus == STATUS_PENDING)
        {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        }

        ntStatus = newIrp->IoStatus.Status;

        IoFreeIrp(newIrp);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
Sbp2PortForwardIrpSynchronousCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT event = Context;

    KeSetEvent(event, EVENT_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sbp2port\sbp21394.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    sbp21394.c

Abstract:

    1394 bus driver to SBP2 interface routines

    Author:

    George Chrysanthakopoulos January-1997

Environment:

    Kernel mode

Revision History :

--*/

#include "sbp2port.h"

NTSTATUS
Sbp2_ProcessTextualDescriptor(
    IN PTEXTUAL_LEAF            TextLeaf,
    IN OUT PUNICODE_STRING      uniString
    );

NTSTATUS
Sbp2Issue1394BusReset (
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    PIRBIRP     packet = NULL;
    NTSTATUS    status;


    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Issue a 1394 bus reset
    //

    packet->Irb->FunctionNumber = REQUEST_BUS_RESET;
    packet->Irb->Flags = BUS_RESET_FLAGS_PERFORM_RESET;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1((
            "Sbp2Port: IssueBusReset: err=x%x issuing bus reset\n",
            status
            ));
    }

    DeAllocateIrpAndIrb(DeviceExtension,packet);

    return status;
}

void
Sbp2BusResetNotification(
    PFDO_DEVICE_EXTENSION   FdoExtension
    )
{
    NTSTATUS        ntStatus;
    PIO_WORKITEM    WorkItem;

    ntStatus = IoAcquireRemoveLock(&FdoExtension->RemoveLock, NULL);

    if (NT_SUCCESS(ntStatus)) {

        WorkItem = IoAllocateWorkItem(FdoExtension->DeviceObject);

        IoQueueWorkItem( WorkItem,
                         Sbp2BusResetNotificationWorker,
                         CriticalWorkQueue,
                         WorkItem
                         );
    }

    return;
}

void
Sbp2BusResetNotificationWorker(
    PDEVICE_OBJECT      DeviceObject,
    PIO_WORKITEM        WorkItem
    )
{
    PFDO_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PDEVICE_EXTENSION deviceExtension;
    PSCSI_REQUEST_BLOCK pendingPowerSrb = NULL;
    ULONG i=0;
    BOOLEAN doReconnect;
    KIRQL DeviceListIrql, DataIrql;
    NTSTATUS ntStatus;

    ExAcquireFastMutex(&fdoExtension->ResetMutex);

#if DBG
    InterlockedIncrement(&fdoExtension->ulWorkItemCount);
#endif

    //
    // dont check if alloc failed here, its not critical
    //

    //
    // go through each children, and do whats necessry (reconnect/cleanup)
    //

    KeAcquireSpinLock(&fdoExtension->DeviceListLock, &DeviceListIrql);

    if (fdoExtension->DeviceListSize == 0) {

        DEBUGPRINT1(("Sbp2Port:Sbp2BusResetNotification, NO PDOs, exiting..\n"));
        goto Exit_Sbp2BusResetNotificationWorker;
    }

    for (i = 0;i < fdoExtension->DeviceListSize; i++) {

        if (!fdoExtension->DeviceList[i].DeviceObject) {

            break;
        }

        deviceExtension = fdoExtension->DeviceList[i].DeviceObject->DeviceExtension;

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED) ||
            !TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_INITIALIZED)){

            continue;
        }

        KeCancelTimer(&deviceExtension->DeviceManagementTimer);

        ntStatus = IoAcquireRemoveLock(&deviceExtension->RemoveLock, NULL);

        if (!NT_SUCCESS(ntStatus))
            continue;

        //
        // if this a login-per-use device, we might be logged at the moment
        // so we do need to re-init but not reconnect
        //

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_STOPPED)) {

            doReconnect = FALSE;

        } else {

            //
            // Turn on the RESET & RECONNECT flags, and turn off the LOGIN
            // flag just in case the reset interrupted a previous (re-)LOGIN.
            // All address mappings are invalidated after a reset
            //

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock, &DataIrql);
            CLEAR_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_LOGIN_IN_PROGRESS);
            SET_FLAG(deviceExtension->DeviceFlags, (DEVICE_FLAG_RESET_IN_PROGRESS | DEVICE_FLAG_RECONNECT));
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock, DataIrql);
            doReconnect = TRUE;
        }

        KeReleaseSpinLock(&fdoExtension->DeviceListLock, DeviceListIrql);

        DEBUGPRINT1((
            "\nSbp2Port: BusResetNotification: ext=x%x, lun=x%x\n",
            deviceExtension,
            deviceExtension->DeviceInfo->Lun.u.LowPart
            ));

        Sbp2DeferPendingRequest(deviceExtension, NULL);

        Sbp2CleanDeviceExtension(deviceExtension->DeviceObject,FALSE);

        //
        // all the resident 1394 memory addresses's that we have, are
        // now invalidated... So we need to free them and re-allocate
        // them

        Sbp2InitializeDeviceExtension(deviceExtension);

        if (doReconnect) {

            deviceExtension->DueTime.HighPart = -1;
            deviceExtension->DueTime.LowPart = -((deviceExtension->DeviceInfo->UnitCharacteristics.u.LowPart >> 8) & 0x000000FF) * 1000 * 1000 * 5;
            KeSetTimer(&deviceExtension->DeviceManagementTimer,deviceExtension->DueTime,&deviceExtension->DeviceManagementTimeoutDpc);

            Sbp2ManagementTransaction(deviceExtension, TRANSACTION_RECONNECT);

        } else {

            DEBUGPRINT1(("Sbp2Port:Sbp2BusResetNotification, NO need for reconnect, device stopped\n"));
            SET_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_STOPPED);
        }

        KeAcquireSpinLock(&fdoExtension->DeviceListLock, &DeviceListIrql);

        IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
    }

Exit_Sbp2BusResetNotificationWorker:

    KeReleaseSpinLock(&fdoExtension->DeviceListLock, DeviceListIrql);

#if DBG
    InterlockedDecrement(&fdoExtension->ulWorkItemCount);
#endif

    ExReleaseFastMutex(&fdoExtension->ResetMutex);
    IoFreeWorkItem(WorkItem);

    IoReleaseRemoveLock(&fdoExtension->RemoveLock, NULL);
    return;
}


VOID
Sbp2DeferPendingRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
{
    KIRQL   oldIrql;

    //
    // If the queue is locked, it means that we might be trying to process
    // a power request.   We cannot abort it, since that would prevent the
    // device from powering up/down.  So save the SRB and irp, free the
    // context, and then after we are done-reinitializing, call StartIo
    // directly with the power request
    //

    if (TEST_FLAG (DeviceExtension->DeviceFlags, DEVICE_FLAG_QUEUE_LOCKED)) {

        KeAcquireSpinLock (&DeviceExtension->OrbListSpinLock, &oldIrql);

        if (!IsListEmpty (&DeviceExtension->PendingOrbList)) {

            PASYNC_REQUEST_CONTEXT tail = \
                RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Flink,OrbList);

            ASSERT (Irp == NULL);

            if (TEST_FLAG(tail->Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {

                DEBUGPRINT1((
                    "Sbp2Port: DeferPendingReq: ext=x%p, defer irp=x%p cdb=x%x\n",
                    DeviceExtension,
                    tail->Srb->OriginalRequest,
                    tail->Srb->Cdb[0]
                    ));

                ASSERT (DeviceExtension->DeferredPowerRequest == NULL);

                DeviceExtension->DeferredPowerRequest =
                    tail->Srb->OriginalRequest;

                //
                // Since a bus reset has occured it's safe to remove the
                // pending ORB from the list... this only works if there
                // is only one pending ORB (the power one)
                //

                ASSERT (tail->OrbList.Flink == tail->OrbList.Blink);

                tail->Srb = NULL;

                CLEAR_FLAG (tail->Flags, ASYNC_CONTEXT_FLAG_TIMER_STARTED);
                KeCancelTimer (&tail->Timer);

                FreeAsyncRequestContext (DeviceExtension, tail);
                InitializeListHead (&DeviceExtension->PendingOrbList);

            } else {

                DeviceExtension->DeferredPowerRequest = NULL;
            }

        } else if (Irp) {

            DEBUGPRINT1((
                "Sbp2Port: DeferPendingReq: ext=x%p, defer irp=x%p\n",
                DeviceExtension,
                Irp
                ));

            ASSERT (DeviceExtension->DeferredPowerRequest == NULL);

            DeviceExtension->DeferredPowerRequest = Irp;
        }

        KeReleaseSpinLock (&DeviceExtension->OrbListSpinLock, oldIrql);
    }
}


NTSTATUS
Sbp2Get1394ConfigInfo(
    IN PFDO_DEVICE_EXTENSION DeviceExtension,
    IN OUT PSBP2_REQUEST Sbp2Req
    )
/*++

Routine Description:

    Reads the configuration ROM from the SBP2 device. Retrieve any SBP2 required info
    for accessing the device and updates our device extension.

Arguments:

    DeviceExtension - Pointer to device extension.
    Sbp2Req - Sbp2 request packet to read/parse a text leaf for a give key. When this parameter is defined
        this routine does NOT re-enumerate the crom, looking for pdos and sbp2 keys

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_INFORMATION devInfo, firstDevInfo;
    NTSTATUS status;
    ULONG directoryLength, vendorLeafLength, modelLeafLength,
          depDirLength, devListSize = DeviceExtension->DeviceListSize;

    ULONG i,j,dirInfoQuad;
    ULONG currentGeneration;

    ULONG unitDirEntries = 0;
    BOOLEAN sbp2Device = FALSE;
    BOOLEAN firstOne = FALSE;

    PVOID unitDirectory = NULL;
    PVOID unitDependentDirectory = NULL;
    PVOID modelLeaf = NULL;
    PVOID vendorLeaf = NULL;
    IO_ADDRESS cromOffset, cromOffset1;
    ULONG offset;

    PIRBIRP packet = NULL;


    AllocateIrpAndIrb ((PDEVICE_EXTENSION) DeviceExtension, &packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // find out how much configuration space we need by setting lengths to zero.
    //

    packet->Irb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize = 0;
    packet->Irb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize = 0;
    packet->Irb->u.GetConfigurationInformation.VendorLeafBufferSize = 0;
    packet->Irb->u.GetConfigurationInformation.ModelLeafBufferSize = 0;

    status = Sbp2SendRequest(
        (PDEVICE_EXTENSION) DeviceExtension,
        packet,
        SYNC_1394_REQUEST
        );

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: err=x%x getting cfg info (1)\n", status));
        goto exit1394Config;
    }

    //
    // Now go thru and allocate what we need to so we can get our info.
    //

    if (packet->Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize) {
        unitDirectory = ExAllocatePool(NonPagedPool, packet->Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize);

        if (!unitDirectory) {

            DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: alloc UnitDir me failed\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit1394Config;
        }

    } else {

        DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: no unit dir, bad dev\n"));
        status = STATUS_BAD_DEVICE_TYPE;
        goto exit1394Config;
    }


    if (packet->Irb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize) {

        unitDependentDirectory = ExAllocatePool(NonPagedPool, packet->Irb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize);

        if (!unitDependentDirectory) {

            DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: alloc UnitDepDir mem failed\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit1394Config;
        }
    }

    if (packet->Irb->u.GetConfigurationInformation.VendorLeafBufferSize) {

        vendorLeaf = ExAllocatePool(NonPagedPool, packet->Irb->u.GetConfigurationInformation.VendorLeafBufferSize);

        if (!vendorLeaf) {

            DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: alloc VendorLeaf mem failed\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit1394Config;
        }

        vendorLeafLength = packet->Irb->u.GetConfigurationInformation.VendorLeafBufferSize;
    }

    if (packet->Irb->u.GetConfigurationInformation.ModelLeafBufferSize) {

        modelLeaf = ExAllocatePool(NonPagedPool, packet->Irb->u.GetConfigurationInformation.ModelLeafBufferSize);

        if (!modelLeaf) {

            DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: alloc ModelLeaf mem failed\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit1394Config;
        }

        modelLeafLength = packet->Irb->u.GetConfigurationInformation.ModelLeafBufferSize;
    }


    //
    // Now resubmit the Irb with the appropriate pointers inside
    //

    packet->Irb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetConfigurationInformation.ConfigRom = &DeviceExtension->ConfigRom;
    packet->Irb->u.GetConfigurationInformation.UnitDirectory = unitDirectory;
    packet->Irb->u.GetConfigurationInformation.UnitDependentDirectory = unitDependentDirectory;
    packet->Irb->u.GetConfigurationInformation.VendorLeaf = vendorLeaf;
    packet->Irb->u.GetConfigurationInformation.ModelLeaf = modelLeaf;

    status = Sbp2SendRequest(
       (PDEVICE_EXTENSION) DeviceExtension,
       packet,
       SYNC_1394_REQUEST
       );

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: error=x%x getting cfg info (2)\n", status));
        goto exit1394Config;
    }

    //
    // get generation count..
    //

    packet->Irb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    packet->Irb->Flags = 0;

    status = Sbp2SendRequest(
        (PDEVICE_EXTENSION) DeviceExtension,
        packet,
        SYNC_1394_REQUEST
        );

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: err=x%x getting gen #\n", status));
        goto exit1394Config;
    }

    currentGeneration = packet->Irb->u.GetGenerationCount.GenerationCount;

    cromOffset = packet->Irb->u.GetConfigurationInformation.UnitDirectoryLocation;

    if (!Sbp2Req) {

        //
        // run through the list amd free any model leafs we have seen before
        //

        for (i = 0; i < DeviceExtension->DeviceListSize; i++) {

            devInfo = &DeviceExtension->DeviceList[i];

            if (devInfo->uniModelId.Buffer) {

                ExFreePool(devInfo->uniModelId.Buffer);
                devInfo->uniModelId.Length = 0;
                devInfo->uniModelId.Buffer = NULL;
            }
        }

        devListSize = 0;
    }

    //
    // Now dwell deep in the configRom and get Lun number, uniqueId identifiers, etc
    // Since the bus driver returned the unit directory, we can just look at our local buffer
    // for all the info we need. We neeed to find the offsets withtin the unit directory
    //

    directoryLength = packet->Irb->u.GetConfigurationInformation.UnitDirectoryBufferSize >> 2;
    firstDevInfo = &DeviceExtension->DeviceList[0];

    for (i = 1; i < directoryLength; i++) {

        if (Sbp2Req) {

            //
            // look for this particular text leaf..
            //

            if (Sbp2Req->u.RetrieveTextLeaf.fulFlags & SBP2REQ_RETRIEVE_TEXT_LEAF_INDIRECT) {

                if ((*(((PULONG) unitDirectory)+i) & CONFIG_ROM_KEY_MASK) == TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE) {

                    if ((*(((PULONG) unitDirectory-1)+i) & CONFIG_ROM_KEY_MASK) == Sbp2Req->u.RetrieveTextLeaf.Key) {

                        DEBUGPRINT2(("Sbp2Port: Get1394CfgInfo: matched text leaf, req=x%x\n", Sbp2Req));

                        offset = cromOffset.IA_Destination_Offset.Off_Low + i*sizeof(ULONG) + (ULONG) (bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK)
                                       *sizeof(ULONG));

                        cromOffset.IA_Destination_Offset.Off_Low = offset;

                        DEBUGPRINT2(("Sbp2Port: Get1394CfgInfo: unitDir=x%p, offset=x%x, key=x%x\n", unitDirectory,
                                    cromOffset.IA_Destination_Offset.Off_Low, *(((PULONG) unitDirectory)+i) ));

                        Sbp2ParseTextLeaf(DeviceExtension,unitDirectory,
                                          &cromOffset,
                                          &Sbp2Req->u.RetrieveTextLeaf.Buffer);

                        if (Sbp2Req->u.RetrieveTextLeaf.Buffer) {

                            Sbp2Req->u.RetrieveTextLeaf.ulLength = \
                            (bswap(*(PULONG) Sbp2Req->u.RetrieveTextLeaf.Buffer) >> 16) * sizeof(ULONG);
                            status = STATUS_SUCCESS;

                        } else {

                            status = STATUS_UNSUCCESSFUL;
                        }

                        break;
                    }
                }
            }

            continue;
        }

        devInfo = &DeviceExtension->DeviceList[devListSize];

        switch (*(((PULONG) unitDirectory)+i) & CONFIG_ROM_KEY_MASK) {

        case CSR_OFFSET_KEY_SIGNATURE:

            //
            // Found the command base offset.  This is a quadlet offset from
            // the initial register space.
            //

            firstDevInfo->ManagementAgentBaseReg.BusAddress.Off_Low =
                  (ULONG) (bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK)
                           *sizeof(ULONG)) | INITIAL_REGISTER_SPACE_LO;

            sbp2Device = TRUE;

            break;

        case LUN_CHARACTERISTICS_KEY_SIGNATURE:

            firstDevInfo->UnitCharacteristics.QuadPart =
                  (ULONG) bswap(*(((PULONG)unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK);

            unitDirEntries ++;

            break;

        case CMD_SET_ID_KEY_SIGNATURE:

            firstDevInfo->CmdSetId.QuadPart =
                  (ULONG) bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK);

            unitDirEntries ++;

            break;

        case CMD_SET_SPEC_ID_KEY_SIGNATURE :

            firstDevInfo->CmdSetSpecId.QuadPart =
                  (ULONG) bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK);

            unitDirEntries ++;

            break;

        case FIRMWARE_REVISION_KEY_SIGNATURE:

            if ((bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK) >> 8) == LSI_VENDOR_ID) {

                DEBUGPRINT2(("Sbp2Port: Get1394CfgInfo: found LSI bridge, maxXfer=128kb\n"));
                DeviceExtension->MaxClassTransferSize = (SBP2_MAX_DIRECT_BUFFER_SIZE)*2;
            }

            break;

        case LUN_KEY_SIGNATURE:

            devInfo->Lun.QuadPart =
                 (ULONG) bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK);

            if ((devListSize == 0) && modelLeaf) {

                TRACE(TL_PNP_TRACE, ("LUN_KEY_SIGNATURE: Get the modelLeaf"));
                status = Sbp2_ProcessTextualDescriptor( (PTEXTUAL_LEAF)modelLeaf,
                                                        &devInfo->uniModelId
                                                        );
            }
            else {

                devInfo->uniModelId.Length = 0;
                devInfo->uniModelId.Buffer = NULL;
            }

            if (vendorLeaf) {

                TRACE(TL_PNP_TRACE, ("LUN_KEY_SIGNATURE: Get the vendorLeaf"));
                status = Sbp2_ProcessTextualDescriptor( (PTEXTUAL_LEAF)vendorLeaf,
                                                        &devInfo->uniVendorId
                                                        );
            }
            else {

                devInfo->uniVendorId.Length = 0;
                devInfo->uniVendorId.Buffer = NULL;
            }
            devInfo->ConfigRom = &DeviceExtension->ConfigRom;

            devListSize++;

            devInfo->ManagementAgentBaseReg.BusAddress.Off_Low = \
                firstDevInfo->ManagementAgentBaseReg.BusAddress.Off_Low;

            devInfo->CmdSetId.QuadPart = firstDevInfo->CmdSetId.QuadPart;
            devInfo->CmdSetSpecId.QuadPart =
                firstDevInfo->CmdSetSpecId.QuadPart;

            devInfo->UnitCharacteristics.QuadPart = firstDevInfo->UnitCharacteristics.QuadPart;

            unitDirEntries ++;

            break;

        case LU_DIRECTORY_KEY_SIGNATURE:

            //
            // this device has logical unit subdirectories within its unit. Probably
            // has multiple units..
            // calculate offset to that LU dir..
            // If this is the first one, ignore it, we already got through the
            // GetConfiguration call..
            //

            if (firstOne == FALSE) {

                firstOne = TRUE;
                depDirLength = packet->Irb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize >> 2;

                //
                // parse the unit dep dir..we are looking for the LUN entry and the model leaf
                //

                for (j = 0;j < depDirLength; j++) {

                    if ((*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_KEY_MASK) == LUN_KEY_SIGNATURE) {

                        devInfo->Lun.QuadPart =
                             (ULONG) bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK);

                        devInfo->ConfigRom = &DeviceExtension->ConfigRom;

                        if (devListSize > 0) {

                            devInfo->uniModelId.Length = 0;
                            devInfo->uniModelId.Buffer = NULL;

                        } else if (modelLeaf){

                            TRACE(TL_PNP_TRACE, ("LU_DIRECTORY_KEY_SIGNATURE: get the modelLeaf"));
                            status = Sbp2_ProcessTextualDescriptor( (PTEXTUAL_LEAF)modelLeaf,
                                                                    &devInfo->uniModelId
                                                                    );
                        }

                        if (vendorLeaf) {

                            TRACE(TL_PNP_TRACE, ("LU_DIRECTORY_KEY_SIGNATURE: get the vendorLeaf"));
                            status = Sbp2_ProcessTextualDescriptor( (PTEXTUAL_LEAF)vendorLeaf,
                                                                    &devInfo->uniVendorId
                                                                    );
                        }
                        else {

                            devInfo->uniVendorId.Length = 0;
                            devInfo->uniVendorId.Buffer = NULL;
                        }

                        devListSize++;

                        devInfo->ManagementAgentBaseReg.BusAddress.Off_Low =
                            firstDevInfo->ManagementAgentBaseReg.BusAddress.Off_Low;

                        if (devInfo->CmdSetId.QuadPart == 0 ) {

                            devInfo->CmdSetId.QuadPart = firstDevInfo->CmdSetId.QuadPart;
                        }

                        if (devInfo->CmdSetSpecId.QuadPart == 0 ) {

                            devInfo->CmdSetSpecId.QuadPart = firstDevInfo->CmdSetSpecId.QuadPart;
                        }

                        if (devInfo->UnitCharacteristics.QuadPart == 0 ) {

                            devInfo->UnitCharacteristics.QuadPart = firstDevInfo->UnitCharacteristics.QuadPart;
                        }

                        unitDirEntries ++;
                    }

                    switch (*(((PULONG) unitDependentDirectory)+j) &
                                CONFIG_ROM_KEY_MASK) {

                    case CMD_SET_ID_KEY_SIGNATURE:

                        devInfo->CmdSetId.QuadPart =
                              (ULONG) bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK);

                        unitDirEntries ++;

                        break;

                    case CMD_SET_SPEC_ID_KEY_SIGNATURE:

                        devInfo->CmdSetSpecId.QuadPart =
                              (ULONG) bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK);

                        unitDirEntries ++;

                        break;

                    case TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE:

                        if ((*(((PULONG) unitDependentDirectory)+j-1) & CONFIG_ROM_KEY_MASK) == MODEL_ID_KEY_SIGNATURE) {

                            if (devInfo->uniModelId.Buffer == NULL) {

                                PTEXTUAL_LEAF   ModelLeaf = NULL;

                                //
                                // special case. if the first LU is only present in unit dir, then the second
                                // LU will be the first unit dependent dir , which means we have to parse
                                // its model text
                                //

                                cromOffset1 = packet->Irb->u.GetConfigurationInformation.UnitDependentDirectoryLocation;

                                cromOffset1.IA_Destination_Offset.Off_Low += j*sizeof(ULONG) + (ULONG) (bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK)
                                               *sizeof(ULONG));

                                Sbp2ParseTextLeaf(DeviceExtension,unitDependentDirectory,
                                                  &cromOffset1,
                                                  &ModelLeaf);

                                // convert it to unicode
                                if (ModelLeaf) {

                                    status = Sbp2_ProcessTextualDescriptor(ModelLeaf, &devInfo->uniModelId);
                                    ExFreePool(ModelLeaf);
                                    TRACE(TL_PNP_TRACE, ("1:TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE: uniModelId = %ws", devInfo->uniModelId.Buffer));
                                }
                            }
                        }

                        break;

                    default:

                        break;

                    } // switch
                }

            } else {

                //
                // read the crom and retrieve the unit dep dir
                //

                offset = cromOffset.IA_Destination_Offset.Off_Low + i*sizeof(ULONG) + (ULONG) (bswap(*(((PULONG) unitDirectory)+i) & CONFIG_ROM_OFFSET_MASK)
                               *sizeof(ULONG));

                //
                // read LU dir header..
                //

                packet->Irb->u.AsyncRead.Mdl = IoAllocateMdl(unitDependentDirectory,
                                                             depDirLength,
                                                             FALSE,
                                                             FALSE,
                                                             NULL);

                MmBuildMdlForNonPagedPool(packet->Irb->u.AsyncRead.Mdl);

                packet->Irb->FunctionNumber = REQUEST_ASYNC_READ;
                packet->Irb->Flags = 0;
                packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
                packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = offset;
                packet->Irb->u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
                packet->Irb->u.AsyncRead.nBlockSize = 0;
                packet->Irb->u.AsyncRead.fulFlags = 0;
                packet->Irb->u.AsyncRead.ulGeneration = currentGeneration;
                packet->Irb->u.AsyncRead.nSpeed = SCODE_100_RATE;

                status = Sbp2SendRequest(
                    (PDEVICE_EXTENSION)DeviceExtension,
                    packet,
                    SYNC_1394_REQUEST
                    );

                if (!NT_SUCCESS(status)) {

                    DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: err=x%x getting cfg info (3)\n", status));

                    IoFreeMdl (packet->Irb->u.AsyncRead.Mdl);
                    goto exit1394Config;
                }

                dirInfoQuad = bswap (*(PULONG) unitDependentDirectory) >> 16;
                depDirLength = dirInfoQuad * sizeof(ULONG);

                IoFreeMdl (packet->Irb->u.AsyncRead.Mdl);

                if (depDirLength > 0x100) {

                    DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: unitDep dir 2 too big, len=x%x\n", depDirLength));
                    goto exit1394Config;
                }

                ExFreePool (unitDependentDirectory);

                unitDependentDirectory = ExAllocatePoolWithTag(NonPagedPool,depDirLength+sizeof(ULONG),'2pbs');

                if (!unitDependentDirectory) {

                    goto exit1394Config;
                }

                packet->Irb->u.AsyncRead.Mdl = IoAllocateMdl(unitDependentDirectory,
                                                             depDirLength+sizeof(ULONG),
                                                             FALSE,
                                                             FALSE,
                                                             NULL);

                MmBuildMdlForNonPagedPool (packet->Irb->u.AsyncRead.Mdl);

                //
                // read the rest of the unit dependent dir, one quadlet at a time...
                // parse as you read..
                //

                j = 1;

                do {

                    packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = offset+j*sizeof(ULONG);
                    ((PULONG) (((PMDL) (packet->Irb->u.AsyncRead.Mdl))->MappedSystemVa))++;
                    ((PULONG) (((PMDL) (packet->Irb->u.AsyncRead.Mdl))->StartVa))++;

                    status = Sbp2SendRequest(
                        (PDEVICE_EXTENSION)DeviceExtension,
                        packet,
                        SYNC_1394_REQUEST
                        );

                    if (!NT_SUCCESS(status)) {

                        DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: err=x%x getting cfg info (4)\n", status));

                        IoFreeMdl (packet->Irb->u.AsyncRead.Mdl);

                        goto exit1394Config;
                    }

                    if ((*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_KEY_MASK) == LUN_KEY_SIGNATURE) {

                        devInfo->Lun.QuadPart =
                             (ULONG) bswap(*(((PULONG) unitDependentDirectory+j)) & CONFIG_ROM_OFFSET_MASK);

                        devInfo->uniModelId.Length = 0;
                        devInfo->uniModelId.Buffer = NULL;

                        if (vendorLeaf) {

                            TRACE(TL_PNP_TRACE, ("ELSE: get vendorLeaf"));
                            status = Sbp2_ProcessTextualDescriptor( (PTEXTUAL_LEAF)vendorLeaf,
                                                                    &devInfo->uniVendorId
                                                                    );
                        }
                        else {

                            devInfo->uniVendorId.Length = 0;
                            devInfo->uniVendorId.Buffer = NULL;
                        }

                        devInfo->ConfigRom = &DeviceExtension->ConfigRom;

                        devListSize++;

                        devInfo->ManagementAgentBaseReg.BusAddress.Off_Low =
                            firstDevInfo->ManagementAgentBaseReg.BusAddress.Off_Low;

                        if (devInfo->CmdSetId.QuadPart == 0 ) {

                            devInfo->CmdSetId.QuadPart = firstDevInfo->CmdSetId.QuadPart;
                        }

                        if (devInfo->CmdSetSpecId.QuadPart == 0 ) {

                            devInfo->CmdSetSpecId.QuadPart = firstDevInfo->CmdSetSpecId.QuadPart;
                        }

                        if (devInfo->UnitCharacteristics.QuadPart == 0 ) {

                            devInfo->UnitCharacteristics.QuadPart = firstDevInfo->UnitCharacteristics.QuadPart;
                        }

                        unitDirEntries ++;
                    }

                    switch (*(((PULONG) unitDependentDirectory)+j) &
                                CONFIG_ROM_KEY_MASK) {

                    case CMD_SET_ID_KEY_SIGNATURE:

                        devInfo->CmdSetId.QuadPart =
                              (ULONG) bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK);

                        unitDirEntries ++;

                        break;

                    case CMD_SET_SPEC_ID_KEY_SIGNATURE:

                        devInfo->CmdSetSpecId.QuadPart =
                              (ULONG) bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK);

                        unitDirEntries ++;

                        break;

                    case TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE:

                        //
                        // oh man, we run into a textual descriptor..
                        // this means we need to parse a LU model descriptor from this..
                        // make sure the quad behind it is a MODEL_ID...
                        //

                        if ((*(((PULONG) unitDependentDirectory)+j-1) & CONFIG_ROM_KEY_MASK) == MODEL_ID_KEY_SIGNATURE) {

                            PTEXTUAL_LEAF   ModelLeaf = NULL;

                            cromOffset1.IA_Destination_Offset.Off_Low = offset + j*sizeof(ULONG) + (ULONG) (bswap(*(((PULONG) unitDependentDirectory)+j) & CONFIG_ROM_OFFSET_MASK)
                                           *sizeof(ULONG));

                            Sbp2ParseTextLeaf(DeviceExtension,unitDependentDirectory,
                                              &cromOffset1,
                                              &ModelLeaf);

                            // convert it to unicode
                            if (ModelLeaf) {

                                status = Sbp2_ProcessTextualDescriptor(ModelLeaf, &devInfo->uniModelId);
                                ExFreePool(ModelLeaf);
                                TRACE(TL_PNP_TRACE, ("2:TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE: uniModelId = %ws", devInfo->uniModelId.Buffer));
                            }
                        }

                        break;

                    default:

                        break;
                    }

                    j++;

                } while (j <= depDirLength / sizeof(ULONG));

                IoFreeMdl (packet->Irb->u.AsyncRead.Mdl);
            }

            break;

        default:

            break;

        } // switch
    }

    if (!Sbp2Req) {

        if (!sbp2Device || (unitDirEntries < SBP2_MIN_UNIT_DIR_ENTRIES)) {

            DEBUGPRINT1(("Sbp2Port: Get1394CfgInfo: bad/non-SBP2 dev, cRom missing unitDir info\n"));

            status = STATUS_BAD_DEVICE_TYPE;
        }
    }

exit1394Config:

    if (packet) {

        DeAllocateIrpAndIrb ((PDEVICE_EXTENSION) DeviceExtension, packet);
    }

    if (unitDirectory) {

        ExFreePool (unitDirectory);
    }

    if (unitDependentDirectory) {

        ExFreePool (unitDependentDirectory);
    }

    // always free vendorLeaf
    if (vendorLeaf)
        ExFreePool(vendorLeaf);

    // always free modelLeaf
    if (modelLeaf)
        ExFreePool(modelLeaf);

    if (!Sbp2Req) {

        DeviceExtension->DeviceListSize = devListSize;
    }

    return status;
}


VOID
Sbp2ParseTextLeaf(
    PFDO_DEVICE_EXTENSION DeviceExtension,
    PVOID UnitDepDir,
    PIO_ADDRESS ModelLeafLocation,
    PVOID *ModelLeaf
    )
{
    PIRBIRP packet = NULL;
    PVOID tModelLeaf;
    PTEXTUAL_LEAF leaf;
    ULONG leafLength,i, currentGeneration;
    ULONG temp;
    NTSTATUS status;


    AllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,&packet);

    if (!packet) {

        return;
    }

    //
    // get generation count..
    //

    packet->Irb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    packet->Irb->Flags = 0;

    status = Sbp2SendRequest(
        (PDEVICE_EXTENSION) DeviceExtension,
        packet,
        SYNC_1394_REQUEST
        );

    if (!NT_SUCCESS(status)) {

        DeAllocateIrpAndIrb ((PDEVICE_EXTENSION) DeviceExtension, packet);
        DEBUGPRINT1(("Sbp2Port:Sbp2ParseModelLeaf: Error %x while trying to get generation number\n", status));
        return;
    }

    currentGeneration = packet->Irb->u.GetGenerationCount.GenerationCount;

    tModelLeaf = ExAllocatePoolWithTag(NonPagedPool,32,'2pbs');

    if (!tModelLeaf) {

        DeAllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,packet);
        return;
    }

    //
    // find out how big the model leaf is
    //

    packet->Irb->u.AsyncRead.Mdl = IoAllocateMdl(tModelLeaf,
                                                 32,
                                                 FALSE,
                                                 FALSE,
                                                 NULL);

    MmBuildMdlForNonPagedPool(packet->Irb->u.AsyncRead.Mdl);

    packet->Irb->FunctionNumber = REQUEST_ASYNC_READ;
    packet->Irb->Flags = 0;
    packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
    packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = \
        ModelLeafLocation->IA_Destination_Offset.Off_Low;

    packet->Irb->u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
    packet->Irb->u.AsyncRead.nBlockSize = 0;
    packet->Irb->u.AsyncRead.fulFlags = 0;
    packet->Irb->u.AsyncRead.ulGeneration = currentGeneration;
    packet->Irb->u.AsyncRead.nSpeed = SCODE_100_RATE;

    status = Sbp2SendRequest(
        (PDEVICE_EXTENSION) DeviceExtension,
        packet,
        SYNC_1394_REQUEST
        );

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1(("Sbp2Get1394ConfigInfo: Error %x while trying to get LU dir model LEAF\n", status));

        ExFreePool(tModelLeaf);
        IoFreeMdl(packet->Irb->u.AsyncRead.Mdl);

        DeAllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,packet);
        return;
    }

    leafLength = (bswap(*(PULONG) tModelLeaf) >> 16) * sizeof(ULONG);
    temp = *((PULONG) tModelLeaf);

    if ((leafLength+sizeof(ULONG)) > 32) {

        //
        // re allocate the mdl to fit the whole leaf
        //

        IoFreeMdl(packet->Irb->u.AsyncRead.Mdl);
        ExFreePool(tModelLeaf);

        tModelLeaf = ExAllocatePoolWithTag(NonPagedPool,leafLength+sizeof(ULONG),'2pbs');

        if (!tModelLeaf) {

            DeAllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,packet);
            return;
        }


        packet->Irb->u.AsyncRead.Mdl = IoAllocateMdl(tModelLeaf,
                                                     leafLength+sizeof(ULONG),
                                                     FALSE,
                                                     FALSE,
                                                     NULL);

        MmBuildMdlForNonPagedPool(packet->Irb->u.AsyncRead.Mdl);
    }

    //
    // read the entire model leaf...
    //

    i=1;
    *((PULONG)tModelLeaf) = temp;

    do {

        packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = \
            ModelLeafLocation->IA_Destination_Offset.Off_Low+i*sizeof(ULONG);

        ((PULONG) (((PMDL) (packet->Irb->u.AsyncRead.Mdl))->MappedSystemVa))++;
        ((PULONG) (((PMDL) (packet->Irb->u.AsyncRead.Mdl))->StartVa))++;


        status = Sbp2SendRequest(
            (PDEVICE_EXTENSION) DeviceExtension,
            packet,
            SYNC_1394_REQUEST
            );

        if (!NT_SUCCESS(status)) {

            DEBUGPRINT1(("Sbp2Get1394ConfigInfo: Error %x while trying to get LU dir model LEAF\n", status));

            ExFreePool(tModelLeaf);
            IoFreeMdl(packet->Irb->u.AsyncRead.Mdl);

            DeAllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,packet);
            return;
        }

        i++;

    } while (i<= leafLength/4);

    leaf = (PTEXTUAL_LEAF) tModelLeaf;
    leaf->TL_Length = (USHORT)leafLength;

    *ModelLeaf = tModelLeaf;

    IoFreeMdl(packet->Irb->u.AsyncRead.Mdl);
    DeAllocateIrpAndIrb((PDEVICE_EXTENSION)DeviceExtension,packet);
}


NTSTATUS
Sbp2UpdateNodeInformation(
    PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Gets node ID and generation information, volatile between bus resets

Arguments:

    DeviceExtension - Pointer to device extension.

Return Value:

    NTSTATUS

--*/
{
    KIRQL                   oldIrql;
    PIRBIRP                 packet = NULL;
    NTSTATUS                status;
    PASYNC_REQUEST_CONTEXT  nextListItem,currentListItem ;


    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Make a call to determine what the generation # is on the bus,
    // followed by a call to find out about ourself (config rom info)
    //

    packet->Irb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    packet->Irb->Flags = 0;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1((
            "Sbp2Port: UpdateNodeInfo: ext=%p, err=x%x getting gen(2)\n",
            DeviceExtension,
            status
            ));

        goto exitGetNodeInfo;
    }

    KeAcquireSpinLock (&DeviceExtension->ExtensionDataSpinLock, &oldIrql);

    DeviceExtension->CurrentGeneration =
        packet->Irb->u.GetGenerationCount.GenerationCount;

    KeReleaseSpinLock(&DeviceExtension->ExtensionDataSpinLock,oldIrql);

    //
    // Get the initiator id (Sbp2port is the initiator in all 1394
    // transactions)
    //

    packet->Irb->FunctionNumber = REQUEST_GET_ADDR_FROM_DEVICE_OBJECT;
    packet->Irb->u.Get1394AddressFromDeviceObject.fulFlags = USE_LOCAL_NODE;
    packet->Irb->Flags = 0;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1((
            "Sbp2Port: UpdateNodeInfo: ext=%p, err=x%x getting node id\n",
            DeviceExtension,
            status
            ));

        goto exitGetNodeInfo;
    }

    KeAcquireSpinLock (&DeviceExtension->ExtensionDataSpinLock, &oldIrql);

    DeviceExtension->InitiatorAddressId =
        packet->Irb->u.Get1394AddressFromDeviceObject.NodeAddress;

    KeReleaseSpinLock (&DeviceExtension->ExtensionDataSpinLock, oldIrql);

    DEBUGPRINT2((
        "Sbp2Port: UpdateNodeInfo: ext=x%p, gen=%d, initiatorId=x%x\n",
        DeviceExtension,
        DeviceExtension->CurrentGeneration,
        DeviceExtension->InitiatorAddressId
        ));

    //
    // If we have active requests pending, we have to traverse the
    // list and update their addresses...
    //

    KeAcquireSpinLock (&DeviceExtension->OrbListSpinLock, &oldIrql);

    if (!IsListEmpty (&DeviceExtension->PendingOrbList)) {

        nextListItem = RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Flink,OrbList);

        do {

            currentListItem = nextListItem;

            //
            // Now update the cmdOrb fields with the new addresses...
            // Since they are stored in BigEndian (awaiting to be fetched)
            // so when we correct their address, this taken into consideration
            //

            // update the data descriptor address

            octbswap (currentListItem->CmdOrb->DataDescriptor);

            currentListItem->CmdOrb->DataDescriptor.BusAddress.NodeId = DeviceExtension->InitiatorAddressId;

            octbswap (currentListItem->CmdOrb->DataDescriptor);

            nextListItem = (PASYNC_REQUEST_CONTEXT) currentListItem->OrbList.Flink;

        } while (currentListItem != RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Blink,OrbList));
    }

    KeReleaseSpinLock (&DeviceExtension->OrbListSpinLock, oldIrql);


exitGetNodeInfo:

    DeAllocateIrpAndIrb (DeviceExtension, packet);

    return status;
}


NTSTATUS
Sbp2ManagementTransaction(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG Type
    )
/*++

Routine Description:
    This routine creates and sends down management ORB's. According to the ORB type
    it will send the request synch/asynchronously. After a management ORB completes
    the bus driver will call the SBp2ManagementStatusCallback

Arguments:

    deviceExtension - Sbp2 device extension
    Type - Type of Managament SBP2 transaction

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT deviceObject = DeviceExtension->DeviceObject;

    NTSTATUS status;
    KIRQL cIrql;

    PORB_MNG    sbpRequest = DeviceExtension->ManagementOrb;
    PORB_QUERY_LOGIN queryOrb;
    PORB_LOGIN loginOrb;

    LARGE_INTEGER waitValue;
    LONG temp;


    if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED)) {

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    RtlZeroMemory (sbpRequest, sizeof (ORB_MNG));

    //
    // Get the 1394 address for our request ORB and the responce ORB's(for login) from the target
    // setup the Type in the status context
    //

    DeviceExtension->GlobalStatusContext.TransactionType = Type;

    switch (Type) {

    case TRANSACTION_LOGIN:

        loginOrb = (PORB_LOGIN) sbpRequest;

        //
        // indicate in our device extension that we are doing a login
        //

        KeAcquireSpinLock(&DeviceExtension->ExtensionDataSpinLock,&cIrql);
        SET_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_LOGIN_IN_PROGRESS);
        KeReleaseSpinLock(&DeviceExtension->ExtensionDataSpinLock, cIrql);

        RtlZeroMemory (DeviceExtension->LoginResponse, sizeof(LOGIN_RESPONSE));

        //
        // Fill in the login ORB, the address of the response buffer
        //

        loginOrb->LoginResponseAddress.BusAddress = DeviceExtension->LoginRespContext.Address.BusAddress;
        loginOrb->LengthInfo.u.HighPart= 0 ; // password length is 0
        loginOrb->LengthInfo.u.LowPart= sizeof(LOGIN_RESPONSE); //set size of response buffer

        //
        // Set the notify bit ot one, Exclusive bit to 0, rq_fmt bit to 0
        // Then set our LUN number
        //

        loginOrb->OrbInfo.QuadPart =0;
        loginOrb->OrbInfo.u.HighPart |= (ORB_NOTIFY_BIT_MASK | ORB_MNG_RQ_FMT_VALUE);

        //
        // If this is an rbc or direct access device then set the exclusive
        // login bit.
        //
        // NOTE: Win2k & Win98SE are checking InquiryData.DeviceType,
        //       but during StartDevice() we are doing a login before we
        //       do an INQUIRY, so this field was always zeroed & we log
        //       in exclusively on those platforms
        //

        switch (DeviceExtension->DeviceInfo->Lun.u.HighPart & 0x001f) {

        case RBC_DEVICE:
        case DIRECT_ACCESS_DEVICE:

             loginOrb->OrbInfo.u.HighPart |= ORB_MNG_EXCLUSIVE_BIT_MASK;
             break;
        }

        loginOrb->OrbInfo.u.LowPart = DeviceExtension->DeviceInfo->Lun.u.LowPart;

        //
        // We don't support passwords yet
        //

#if PASSWORD_SUPPORT

        if (DeviceExtension->Exclusive & EXCLUSIVE_FLAG_SET) {

            loginOrb->Password.u.HighQuad.QuadPart =
                DeviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[1];
            loginOrb->Password.u.LowQuad.QuadPart =
                DeviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[0];

            DEBUGPRINT1(("Sbp2Port: MgmtXact: password=x%x%x, len=x%x\n",
                loginOrb->Password.u.HighQuad.QuadPart,
                loginOrb->Password.u.LowQuad.QuadPart,
                loginOrb->LengthInfo.u.HighPart));

        } else {

            loginOrb->Password.OctletPart = 0;
        }

#else
        loginOrb->Password.OctletPart = 0;
#endif

        //
        // Set the type of the management transaction in the ORB
        //

        loginOrb->OrbInfo.u.HighPart |=0x00FF & Type;

#if PASSWORD_SUPPORT
        octbswap(loginOrb->Password);
#endif
        octbswap(loginOrb->LoginResponseAddress);
        loginOrb->OrbInfo.QuadPart = bswap(loginOrb->OrbInfo.QuadPart);
        loginOrb->LengthInfo.QuadPart = bswap(loginOrb->LengthInfo.QuadPart);

        sbpRequest->StatusBlockAddress.BusAddress = DeviceExtension->GlobalStatusContext.Address.BusAddress;
        octbswap(loginOrb->StatusBlockAddress);

        //
        // write to the Management Agent register, to signal that a management ORB is ready
        // if we are doing this during a reset, it will have to be done asynchronously
        //

        if (!TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_RESET_IN_PROGRESS)) {

            //
            // Synchronous login case. We will wait on an event until our DPC associated with the login status, fires and sets the event
            //

            ASSERT(InterlockedIncrement(&DeviceExtension->ulPendingEvents) == 1);

            KeInitializeEvent(&DeviceExtension->ManagementEvent, NotificationEvent, FALSE);

            DEBUGPRINT2(("Sbp2Port: MgmtXact: waiting for login status\n"));
            status = Sbp2AccessRegister(DeviceExtension,&DeviceExtension->ManagementOrbContext.Address,MANAGEMENT_AGENT_REG | REG_WRITE_SYNC);

            if (!NT_SUCCESS(status)) {

                DEBUGPRINT2(("Sbp2Port: MgmtXact: can't access mgmt reg ext=x%p, FAIL LOGIN\n", DeviceExtension));

                ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);
                return status;
            }

            //
            // set the login timeout value, to what we read from the registry (LOGIN_TIMEOUT)
            // divide by 2, to convert to seconds
            //

            temp = max (SBP2_LOGIN_TIMEOUT, (DeviceExtension->DeviceInfo->UnitCharacteristics.u.LowPart >> 9));
            waitValue.QuadPart = -temp * 1000 * 1000 * 10;

            status = KeWaitForSingleObject(&DeviceExtension->ManagementEvent,Executive,KernelMode,FALSE,&waitValue);

            ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);

            if (status == STATUS_TIMEOUT) {

                if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_LOGIN_IN_PROGRESS)) {

                    DEBUGPRINT1(("Sbp2Port: MgmtXact: login timed out, ext=x%p\n", DeviceExtension));

                    //
                    // In Win2k, etc we would mark the device stopped here &
                    // turn off the login in progress flag. Since this timeout
                    // might be the result of a bus reset, we want to allow
                    // for a retry here.
                    //

                    status = STATUS_UNSUCCESSFUL;

                }  else {

                    status = STATUS_SUCCESS;
                }
            }

            if (!NT_SUCCESS(DeviceExtension->LastTransactionStatus)) {

                status = DeviceExtension->LastTransactionStatus;

            } else if (!DeviceExtension->LoginResponse->Csr_Off_Low.QuadPart) {

                status = STATUS_UNSUCCESSFUL;
            }

            return status;

        } else {

            //
            // Asynchronous login case. Start a timer to track the login..
            //

            // get the Management_Timeout values from the ConfigRom LUN Characteristics entry
            //

            DeviceExtension->DueTime.HighPart = -1;
            DeviceExtension->DueTime.LowPart = -(DeviceExtension->DeviceInfo->UnitCharacteristics.u.LowPart >> 9) * 1000 * 1000 * 10; // divide by 2, to convert to seconds;
            KeSetTimer(&DeviceExtension->DeviceManagementTimer,DeviceExtension->DueTime,&DeviceExtension->DeviceManagementTimeoutDpc);

            status = Sbp2AccessRegister(DeviceExtension,&DeviceExtension->ManagementOrbContext.Address,MANAGEMENT_AGENT_REG | REG_WRITE_ASYNC);

            if (!NT_SUCCESS(status)) {

                DEBUGPRINT2((
                    "Sbp2Port: MgmtXact: can't access mgmt reg ext=x%p, FAIL LOGIN\n",
                    DeviceExtension
                    ));

                return status;
            }

            //
            // for now return pending. the callback will complete this request
            //

            return STATUS_PENDING;
        }

        break;

    case TRANSACTION_QUERY_LOGINS:

        queryOrb = (PORB_QUERY_LOGIN) sbpRequest;

        RtlZeroMemory(
            DeviceExtension->QueryLoginResponse,
            sizeof(QUERY_LOGIN_RESPONSE)
            );

        //
        // Fill in the login ORB, the address of the response buffer
        //

        queryOrb->QueryResponseAddress.BusAddress = DeviceExtension->QueryLoginRespContext.Address.BusAddress;


        queryOrb->LengthInfo.u.HighPart= 0 ; // password length is 0
        queryOrb->LengthInfo.u.LowPart= sizeof(QUERY_LOGIN_RESPONSE); //set size of response buffer

        //
        // Set the notify bit ot one, Exclusive bit to 0, rq_fmt bit to 0
        // Then set our LUN number
        //

        queryOrb->OrbInfo.QuadPart =0;
        queryOrb->OrbInfo.u.HighPart |= (ORB_NOTIFY_BIT_MASK | ORB_MNG_RQ_FMT_VALUE);

        queryOrb->OrbInfo.u.LowPart = DeviceExtension->DeviceInfo->Lun.u.LowPart;

        queryOrb->Reserved.OctletPart = 0;

        //
        // Set the type of the management transaction in the ORB
        //

        queryOrb->OrbInfo.u.HighPart |=0x00FF & Type;

        octbswap(queryOrb->QueryResponseAddress);
        queryOrb->OrbInfo.QuadPart = bswap(queryOrb->OrbInfo.QuadPart);
        queryOrb->LengthInfo.QuadPart = bswap(queryOrb->LengthInfo.QuadPart);

        queryOrb->StatusBlockAddress.BusAddress = DeviceExtension->ManagementOrbStatusContext.Address.BusAddress;
        octbswap(queryOrb->StatusBlockAddress);

        //
        // write to the Management Agent register, to signal that a management ORB is ready
        //

        ASSERT(InterlockedIncrement(&DeviceExtension->ulPendingEvents) == 1);

        waitValue.QuadPart = -8 * 1000 * 1000 * 10;
        KeInitializeEvent(&DeviceExtension->ManagementEvent, NotificationEvent, FALSE);
        status = Sbp2AccessRegister(DeviceExtension,&DeviceExtension->ManagementOrbContext.Address,MANAGEMENT_AGENT_REG | REG_WRITE_SYNC);

        if (!NT_SUCCESS(status)) {

            DEBUGPRINT2((
                "Sbp2Port: MgmtXact: QUERY_LOGIN, can't access mgmt reg, sts=x%x\n",
                status
                ));

            ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);
            return status;
        }

        status = KeWaitForSingleObject(&DeviceExtension->ManagementEvent,Executive,KernelMode,FALSE,&waitValue);

        ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);

        if (status == STATUS_TIMEOUT) {

            DEBUGPRINT2((
                "Sbp2Port: MgmtXact: QUERY_LOGIN: req timed out, ext=x%p\n",
                DeviceExtension
                ));

            return STATUS_UNSUCCESSFUL;
        }

        return status;

        break;

    case TRANSACTION_RECONNECT:

        DEBUGPRINT2((
            "Sbp2Port: MgmXact: reconnecting to ext=x%p\n",
            DeviceExtension
            ));

    default:

        status = IoAcquireRemoveLock(&DeviceExtension->RemoveLock, NULL);

        if (!NT_SUCCESS(status)) {

            return(status);
        }

        sbpRequest->OrbInfo.QuadPart = 0;
        sbpRequest->OrbInfo.u.HighPart |= (ORB_NOTIFY_BIT_MASK | ORB_MNG_RQ_FMT_VALUE);

        //
        // login ID
        //

        sbpRequest->OrbInfo.u.LowPart = DeviceExtension->LoginResponse->LengthAndLoginId.u.LowPart;

        //
        // Set the type of the management transaction in the ORB
        //

        sbpRequest->OrbInfo.u.HighPart |= 0x00FF & Type;

        //
        // Convert to big endian
        //

        sbpRequest->OrbInfo.QuadPart = bswap (sbpRequest->OrbInfo.QuadPart);

        sbpRequest->StatusBlockAddress.BusAddress = DeviceExtension->ManagementOrbStatusContext.Address.BusAddress;
        octbswap(sbpRequest->StatusBlockAddress);

        if (KeGetCurrentIrql() < DISPATCH_LEVEL) {

            ASSERT(InterlockedIncrement(&DeviceExtension->ulPendingEvents) == 1);

            waitValue.QuadPart = -8 * 1000 * 1000 * 10;

            KeInitializeEvent(&DeviceExtension->ManagementEvent, NotificationEvent, FALSE);

            status = Sbp2AccessRegister(DeviceExtension,&DeviceExtension->ManagementOrbContext.Address,MANAGEMENT_AGENT_REG | REG_WRITE_SYNC);

            if (!NT_SUCCESS(status)) {

                DEBUGPRINT2(("Sbp2Port: MgmtXact: type=%d, can't access mgmt reg, sts=x%x\n",Type,status));
                IoReleaseRemoveLock(&DeviceExtension->RemoveLock, NULL);

                ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);
                return status;
            }

            status = KeWaitForSingleObject(&DeviceExtension->ManagementEvent,Executive,KernelMode,FALSE,&waitValue);

            ASSERT(InterlockedDecrement(&DeviceExtension->ulPendingEvents) == 0);

            if (status == STATUS_TIMEOUT) {

                DEBUGPRINT2(("Sbp2Port: MgmtXact: type=%d, ext=x%p, req timeout\n",Type, DeviceExtension));
                IoReleaseRemoveLock(&DeviceExtension->RemoveLock, NULL);
                return STATUS_UNSUCCESSFUL;
            }

        } else {

            status = Sbp2AccessRegister(DeviceExtension,&DeviceExtension->ManagementOrbContext.Address,MANAGEMENT_AGENT_REG | REG_WRITE_ASYNC);
        }

        IoReleaseRemoveLock(&DeviceExtension->RemoveLock, NULL);
        return status;

        break;
    }

    //
    // all MANAGEMENT ORBs except login,query login, are done asynchronously
    //

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return STATUS_PENDING;
}


#if PASSWORD_SUPPORT

NTSTATUS
Sbp2SetPasswordTransaction(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN ULONG                Type
    )
/*++

Routine Description:
    This routine creates and sends down set password transaction.

Arguments:

    deviceExtension - Sbp2 device extension

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT      deviceObject = DeviceExtension->DeviceObject;
    NTSTATUS            status;
    KIRQL               cIrql;

    PORB_SET_PASSWORD   passwordOrb = DeviceExtension->PasswordOrb;

    LARGE_INTEGER       waitValue;
    LONG                temp;


    if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED)) {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
        goto Exit_Sbp2SetPasswordTransaction;
    }

    RtlZeroMemory(passwordOrb, sizeof(ORB_SET_PASSWORD));

    //
    // Password
    //

    if (Type == SBP2REQ_SET_PASSWORD_EXCLUSIVE) {

        passwordOrb->Password.u.HighQuad.QuadPart =
            DeviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[1];
        passwordOrb->Password.u.LowQuad.QuadPart =
            DeviceExtension->DeviceInfo->ConfigRom->CR_Node_UniqueID[0];

    } else {

        passwordOrb->Password.OctletPart = 0;
    }

    //
    // Reserved
    //

    passwordOrb->Reserved.OctletPart = 0;

    //
    // OrbInfo
    //

    passwordOrb->OrbInfo.QuadPart = 0;

    passwordOrb->OrbInfo.u.HighPart |=
        (ORB_NOTIFY_BIT_MASK | ORB_MNG_RQ_FMT_VALUE);
    passwordOrb->OrbInfo.u.HighPart |=
        0x00FF & TRANSACTION_SET_PASSWORD;

    passwordOrb->OrbInfo.u.LowPart =
        DeviceExtension->LoginResponse->LengthAndLoginId.u.LowPart;

    //
    // LengthInfo
    //

    passwordOrb->LengthInfo.u.HighPart = 0;

    //
    // StatusBlockAddress
    //

    passwordOrb->StatusBlockAddress.BusAddress =
        DeviceExtension->PasswordOrbStatusContext.Address.BusAddress;

    //
    // Bswap everything...
    //

    octbswap (passwordOrb->Password);
    passwordOrb->OrbInfo.QuadPart = bswap (passwordOrb->OrbInfo.QuadPart);
    passwordOrb->LengthInfo.QuadPart = bswap(passwordOrb->LengthInfo.QuadPart);
    octbswap (passwordOrb->StatusBlockAddress);

    //
    // Write to the Management Agent register, to signal that
    // a management ORB is ready
    //

    waitValue.LowPart  = SBP2_SET_PASSWORD_TIMEOUT;
    waitValue.HighPart = -1;

    KeInitializeEvent(
        &DeviceExtension->PasswordEvent,
        NotificationEvent,
        FALSE
        );

    status = Sbp2AccessRegister(
        DeviceExtension,
        &DeviceExtension->PasswordOrbContext.Address,
        MANAGEMENT_AGENT_REG | REG_WRITE_SYNC
        );

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1((
            "Sbp2Port: SetPasswdXact: can't access mgmt reg, sts=x%x\n",
            status
            ));

        goto Exit_Sbp2SetPasswordTransaction;
    }

    status = KeWaitForSingleObject(
        &DeviceExtension->PasswordEvent,
        Executive,
        KernelMode,
        FALSE,
        &waitValue
        );

    if (status == STATUS_TIMEOUT) {

        DEBUGPRINT1((
            "Sbp2Port: SetPasswdXact: req timed out, ext=x%p\n",
            DeviceExtension
            ));

        status = STATUS_UNSUCCESSFUL;

        goto Exit_Sbp2SetPasswordTransaction;
    }

    status = CheckStatusResponseValue(&DeviceExtension->PasswordOrbStatusBlock);

Exit_Sbp2SetPasswordTransaction:

    return(status);
}

#endif

///////////////////////////////////////////////////////////////////////////////
// Callback routines
///////////////////////////////////////////////////////////////////////////////

RCODE
Sbp2GlobalStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    )
/*++

Routine Description:

    Callback routine for writes to our login Status Block. the 1394 driver will call this routine, after
    the target has updated the status in our memory.

Arguments:

    (Check 1394Bus.doc) or 1394.h

Return Value:

    0

--*/
{
    PIRP        requestIrp, irp;
    ULONG       temp, rcode;
    ULONG       currentOrbListDepth, initialOrbListDepth;
    PVOID       *tempPointer;
    PUCHAR      senseBuffer;
    BOOLEAN     cancelledTimer;
    NTSTATUS    status;
    PLIST_ENTRY             entry;
    PDEVICE_OBJECT          deviceObject;
    PDEVICE_EXTENSION       deviceExtension;
    PSTATUS_FIFO_BLOCK      statusBlock;
    PASYNC_REQUEST_CONTEXT  orbContext, nextListItem;

    //
    // NOTE: Uncomment these when enabling ordered execution code below
    //
    // ULONG        completedPrecedingOrbs;
    // LIST_ENTRY   listHead;
    // PLIST_ENTRY  nextEntry;
    //

    if (NotificationInfo->Context != NULL) {

        deviceObject = ((PADDRESS_CONTEXT)NotificationInfo->Context)->DeviceObject;
        deviceExtension = deviceObject->DeviceExtension;

    } else {

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: NotifyInfo %p Context NULL!!\n", NotificationInfo));
        return RCODE_RESPONSE_COMPLETE;
    }

    statusBlock = MmGetMdlVirtualAddress (NotificationInfo->Fifo->FifoMdl);

    octbswap (statusBlock->AddressAndStatus);

    status = CheckStatusResponseValue (statusBlock);

    //
    // check if we got a remove before the DPC fired.
    // If we did, dont do anything....
    //

    if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED )) {

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: dev removed and got status=x%x, State=%x\n",
                    statusBlock,deviceExtension->DeviceFlags));

        ExInterlockedPushEntrySList(&deviceExtension->StatusFifoListHead,
                        &NotificationInfo->Fifo->FifoList,
                        &deviceExtension->StatusFifoLock);

        return RCODE_RESPONSE_COMPLETE;
    }


    if ((statusBlock->AddressAndStatus.BusAddress.Off_Low ==
        deviceExtension->ManagementOrbContext.Address.BusAddress.Off_Low) &&
        (statusBlock->AddressAndStatus.BusAddress.Off_High ==
        deviceExtension->ManagementOrbContext.Address.BusAddress.Off_High)) {

        //
        // Management status callback
        //

        Sbp2LoginCompletion (NotificationInfo, status);

        rcode = RCODE_RESPONSE_COMPLETE;

        goto exitGlobalCallback;
    }


    //
    // Data( Command ORB) status callback
    //

    if (statusBlock->AddressAndStatus.u.HighQuad.u.HighPart &
        STATUS_BLOCK_UNSOLICITED_BIT_MASK) {

        DEBUGPRINT3(("Sbp2Port: GlobalStatusCb: unsolicited recv'd\n"));

        //
        // this is a status unrelated to any pending ORB's, reenable the unsolicited reg
        //

        Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,UNSOLICITED_STATUS_REG | REG_WRITE_ASYNC);

        //
        // intepret the unsolicited status and take appropriate action
        //

        Sbp2HandleUnsolicited(deviceExtension,statusBlock);

        rcode= RCODE_RESPONSE_COMPLETE;
        goto exitGlobalCallback;
    }

    if (deviceExtension->OrbPoolContext.Reserved == NULL) {

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: Stopped or Removed and got status %x, State %x.\n",
                    statusBlock, deviceExtension->DeviceFlags));

        ExInterlockedPushEntrySList(&deviceExtension->StatusFifoListHead,
                        &NotificationInfo->Fifo->FifoList,
                        &deviceExtension->StatusFifoLock);

        return RCODE_RESPONSE_COMPLETE;
    }

    //
    // This GOT to be a NORMAL command ORB
    // calculate base address of the ORB, relative to start address of ORB pool
    //

    temp = statusBlock->AddressAndStatus.BusAddress.Off_Low -
           deviceExtension->OrbPoolContext.Address.BusAddress.Off_Low;

    if (temp > (MAX_ORB_LIST_DEPTH * sizeof (ARCP_ORB))) {

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: status has invalid addr=x%x\n",temp));
        //ASSERT(temp <= (MAX_ORB_LIST_DEPTH * sizeof (ARCP_ORB)));

        Sbp2CreateRequestErrorLog(deviceExtension->DeviceObject,NULL,STATUS_DEVICE_PROTOCOL_ERROR);

        rcode = RCODE_ADDRESS_ERROR;
        goto exitGlobalCallback;
    }

    //
    // Retrieve the pointer to the context which wraps this ORB.
    // The pointer is stored sizeof(PVOID) bytes behind the ORB's
    // buffer address in host memory.
    //

    tempPointer = (PVOID) (((PUCHAR) deviceExtension->OrbPoolContext.Reserved)
        + temp - FIELD_OFFSET (ARCP_ORB, Orb));

    orbContext = (PASYNC_REQUEST_CONTEXT) *tempPointer;

    if (!orbContext || (orbContext->Tag != SBP2_ASYNC_CONTEXT_TAG)) {

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: status has invalid addr(2)=x%x\n",temp));
        //ASSERT(orbContext!=NULL);

        Sbp2CreateRequestErrorLog(deviceExtension->DeviceObject,NULL,STATUS_DEVICE_PROTOCOL_ERROR);

        rcode = RCODE_ADDRESS_ERROR;
        goto exitGlobalCallback;
    }

    DEBUGPRINT4(("Sbp2Port: GlobalStatusCb: ctx=x%p compl\n", orbContext));

    KeAcquireSpinLockAtDpcLevel (&deviceExtension->OrbListSpinLock);

    if (TEST_FLAG (orbContext->Flags, ASYNC_CONTEXT_FLAG_COMPLETED)) {

        //
        // request marked completed before we got the chance to do so. means our lists got hosed or the target
        // finised same request twice..
        //

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

        DEBUGPRINT1(("Sbp2Port: GlobalStatusCb: req=x%p already marked compl??\n",orbContext));
        ASSERT(orbContext->Srb == NULL);

        rcode= RCODE_RESPONSE_COMPLETE;
        goto exitGlobalCallback;
    }

    SET_FLAG (orbContext->Flags, ASYNC_CONTEXT_FLAG_COMPLETED);

    requestIrp = (PIRP) orbContext->Srb->OriginalRequest;

#if 1

    //
    // If this is the oldest request in the queue then cancel the timer
    //

    if ((PASYNC_REQUEST_CONTEXT) deviceExtension->PendingOrbList.Flink ==
            orbContext) {

        KeCancelTimer (&orbContext->Timer);
        CLEAR_FLAG (orbContext->Flags,ASYNC_CONTEXT_FLAG_TIMER_STARTED);
        cancelledTimer = TRUE;

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

    } else  {

        //
        // Older request(s) still in progress, no timer associated with
        // this request
        //

        cancelledTimer = FALSE;

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);
    }

#else

    //
    // ISSUE: The following is #if'd out for Windows XP because
    //        it's possible with MP machines & ordered execution
    //        devices for requests to complete in order, yet have
    //        completion notifications show up here out of order due
    //        to multiple DPCs firing. This can cause problems because
    //        by the time we get here on thread #1 thread #2 might
    //        have already completed this request (in the ordered exec
    //        handler below), and the request context object may have
    //        been reallocated for a new request, and it could get
    //        erroneously completed here. (There's currently no way
    //        to associate a request instance with a completion
    //        notification instance.)
    //
    //        This means that we might incur some timeouts if some
    //        vendor chooses to implement an ordered execution device
    //        which will actually complete a request & assume implicit
    //        completion of older requests.  At this time, Oxford Semi
    //        is the only vendor we know of that does ordered execution,
    //        and they guarantee one completion per request.
    //
    // NOTE:  !! When enabling this code make sure to uncomment other
    //        refs (above & below) to the "completedPrecedingOrbs", etc
    //        variables.
    //
    //        DanKn, 21-July-2001
    //

    //
    // If this is the oldest request in the queue then cancel the timer,
    // else check the ordered execution bit in the LUN (0x14) key to see
    // whether we need to complete preceding requests or not
    //

    completedPrecedingOrbs = 0;

    if ((PASYNC_REQUEST_CONTEXT) deviceExtension->PendingOrbList.Flink ==
            orbContext) {

        KeCancelTimer (&orbContext->Timer);
        CLEAR_FLAG (orbContext->Flags,ASYNC_CONTEXT_FLAG_TIMER_STARTED);
        cancelledTimer = TRUE;

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

    } else if (!(deviceExtension->DeviceInfo->Lun.QuadPart & 0x00400000)) {

        //
        // Unordered execution device, older request(s) still in progress,
        // no timer associated with this request
        //

        cancelledTimer = FALSE;

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

    } else  {

        //
        // Ordered execution device. Per section 4.6 of spec :
        // "A consequence of ordering is that completion status for one
        // task implicitly indicates successful completion status for
        // all tasks that preceded it in the ordered list."
        //

        //
        // Cancel the oldest request's timer if necessary
        //

        nextListItem = RETRIEVE_CONTEXT(
            deviceExtension->PendingOrbList.Flink,
            OrbList
            );

        if (nextListItem->Flags & ASYNC_CONTEXT_FLAG_TIMER_STARTED) {

            KeCancelTimer (&nextListItem->Timer);
            CLEAR_FLAG (nextListItem->Flags, ASYNC_CONTEXT_FLAG_TIMER_STARTED);
            cancelledTimer = TRUE;

            ASSERT (!(orbContext->Flags & ASYNC_CONTEXT_FLAG_COMPLETED));

        } else {

            cancelledTimer = FALSE;
        }

        //
        // Remove preceding, uncompleted entries from the
        // PendingOrbList and put them in a local list
        //

        InitializeListHead (&listHead);

        for(
            entry = deviceExtension->PendingOrbList.Flink;
            entry != (PLIST_ENTRY) &orbContext->OrbList;
            entry = nextEntry
            )
        {
            nextEntry = entry->Flink;

            nextListItem = RETRIEVE_CONTEXT (entry, OrbList);

            if (!(nextListItem->Flags & ASYNC_CONTEXT_FLAG_COMPLETED)) {

                RemoveEntryList (entry);

                InsertTailList (&listHead, entry);
            }
        }

        KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

        //
        // Now complete the entries in the local list
        //

        while (!IsListEmpty (&listHead)) {

            nextListItem = RETRIEVE_CONTEXT (listHead.Flink, OrbList);

            RemoveEntryList (listHead.Flink);

            nextListItem->Srb->SrbStatus = SRB_STATUS_SUCCESS;
            nextListItem->Srb->ScsiStatus = SCSISTAT_GOOD;

            Sbp2_SCSI_RBC_Conversion (nextListItem); // unwind RBC hacks

            irp = (PIRP) nextListItem->Srb->OriginalRequest;

            DEBUGPRINT2((
                "Sbp2Port: GlobalStatusCb: IMPLICIT COMPL arc=x%p\n",
                nextListItem
                ));

            DEBUGPRINT2((
                "Sbp2Port: GlobalStatusCb: ... irp=x%p, cdb=x%x\n",
                irp,
                nextListItem->Srb->Cdb[0]
                ));

            irp->IoStatus.Information = // ISSUE: only set this !=0 on reads?
                nextListItem->Srb->DataTransferLength;

            nextListItem->Srb = NULL;

            FreeAsyncRequestContext (deviceExtension, nextListItem);

            irp->IoStatus.Status = STATUS_SUCCESS;

            IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
            IoCompleteRequest (irp, IO_NO_INCREMENT);

            completedPrecedingOrbs++;
        }
    }

#endif

    //
    // Get sense data if length is larger than 1 (indicates error status).
    //
    // Annex B.2 of SBP2 spec : "When a command completes with GOOD status,
    // only the first two quadlets of the status block shall be stored at
    // the status_FIFO address; the len field shall be 1."
    //

    if (((statusBlock->AddressAndStatus.u.HighQuad.u.HighPart >> 8) & 0x07) > 1) {

        orbContext->Srb->SrbStatus = SRB_STATUS_ERROR;
        orbContext->Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
        orbContext->Srb->SrbStatus &= ~SRB_STATUS_AUTOSENSE_VALID;

        if (orbContext->Srb->SenseInfoBuffer && !TEST_FLAG(orbContext->Srb->SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE)) {

            if (TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_SPC_CMD_SET)) {

                if (ConvertSbp2SenseDataToScsi(statusBlock,
                                               orbContext->Srb->SenseInfoBuffer,
                                               orbContext->Srb->SenseInfoBufferLength) ){

                    orbContext->Srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                }

                senseBuffer = (PUCHAR) orbContext->Srb->SenseInfoBuffer;

                if ((orbContext->Srb->Cdb[0] != SCSIOP_TEST_UNIT_READY) ||
                    (senseBuffer[2] != SCSI_SENSE_NOT_READY) ||
                    (senseBuffer[12] != SCSI_ADSENSE_NO_MEDIA_IN_DEVICE)) {

                    DEBUGPRINT2((
                        "Sbp2Port: GlobalStatusCb: ERROR, ext=x%p, cdb=x%x s/a/q=x%x/%x/%x\n",
                        deviceExtension,
                        orbContext->Srb->Cdb[0],
                        senseBuffer[2],
                        senseBuffer[12],
                        senseBuffer[13]
                        ));
                }

            } else {

                DEBUGPRINT2((
                    "Sbp2Port: GlobalStatusCb: ERROR, ext=x%p, cdb=x%x, cmd set NOT SCSI\n",\
                    deviceExtension,
                    orbContext->Srb->Cdb[0]
                    ));

                if (orbContext->Srb->SenseInfoBuffer) {

                    RtlCopyMemory(orbContext->Srb->SenseInfoBuffer,statusBlock,min(sizeof(STATUS_FIFO_BLOCK),orbContext->Srb->SenseInfoBufferLength));
                }
            }

        } else {

            DEBUGPRINT2(("Sbp2Port: GlobalStatusCb: ext=x%p, cdb=x%x, ERROR no sense buf\n",
                        deviceExtension,
                        orbContext->Srb->Cdb[0]));
        }

    } else if (((statusBlock->AddressAndStatus.u.HighQuad.u.HighPart & 0x3000) == 0x1000) ||
               ((statusBlock->AddressAndStatus.u.HighQuad.u.HighPart & 0x3000) == 0x2000)) {

        //
        // Per section 5.3 of SBP2 spec, values of 1 or 2 in the resp
        // field indicate TRANSPORT FAILURE and ILLEGAL REQUEST,
        // respectively.
        //
        // For now we'll continue to consider a resp value of 3
        // (VENDOR DEPENDENT) a success, like we did in Win2k & WinMe.
        //

        DEBUGPRINT2((
            "Sbp2Port: GlobalStatusCb: ERROR, ext=x%p, cdb=x%x, sts=x%x\n",\
            deviceExtension,
            orbContext->Srb->Cdb[0],
            statusBlock->AddressAndStatus.u.HighQuad.u.HighPart
            ));

        orbContext->Srb->SrbStatus = SRB_STATUS_ERROR;
        orbContext->Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
        orbContext->Srb->SrbStatus &= ~SRB_STATUS_AUTOSENSE_VALID;

    } else {

        orbContext->Srb->SrbStatus = SRB_STATUS_SUCCESS;
        orbContext->Srb->ScsiStatus = SCSISTAT_GOOD;
    }

    Sbp2_SCSI_RBC_Conversion (orbContext); // unwind RBC hacks

    requestIrp->IoStatus.Information = // ISSUE: only set this !=0 on read ok?
        (orbContext->Srb->SrbStatus == SRB_STATUS_SUCCESS ?
        orbContext->Srb->DataTransferLength : 0);

    Free1394DataMapping (deviceExtension, orbContext);


    //
    // Pull the request out of the list & see if we need to set a timer
    //

    KeAcquireSpinLockAtDpcLevel (&deviceExtension->OrbListSpinLock);

    RemoveEntryList (&orbContext->OrbList);

    if (cancelledTimer) {

        //
        // Make the oldest, non-completed request track the timeout
        // (iff one exists)
        //

        for(
            entry = deviceExtension->PendingOrbList.Flink;
            entry != &deviceExtension->PendingOrbList;
            entry = entry->Flink
            )
        {
            nextListItem = RETRIEVE_CONTEXT (entry, OrbList);

            if (!(nextListItem->Flags & ASYNC_CONTEXT_FLAG_COMPLETED)) {

                deviceExtension->DueTime.QuadPart = ((LONGLONG) orbContext->Srb->TimeOutValue) * (-10*1000*1000);
                SET_FLAG(nextListItem->Flags, ASYNC_CONTEXT_FLAG_TIMER_STARTED);
                KeSetTimer(&nextListItem->Timer, deviceExtension->DueTime, &nextListItem->TimerDpc);
                break;
            }
        }
    }

    orbContext->Srb = NULL;

    //
    // Check if the target transitioned to the dead state because of a failed command
    // If it did, do a reset...
    //

#if 1

    initialOrbListDepth = deviceExtension->OrbListDepth;

#else

    // NOTE: use this path when enabling ordered execution code above

    initialOrbListDepth = deviceExtension->OrbListDepth +
        completedPrecedingOrbs;
#endif

    if (statusBlock->AddressAndStatus.u.HighQuad.u.HighPart & STATUS_BLOCK_DEAD_BIT_MASK) {

        //
        // reset the target fetch agent .
        //

        Sbp2AccessRegister (deviceExtension, &deviceExtension->Reserved, AGENT_RESET_REG | REG_WRITE_ASYNC);

        //
        // in order to wake up the agent we now need to write to ORB_POINTER with the head of lined list
        // of un-processed ORBS.
        //

        FreeAsyncRequestContext (deviceExtension, orbContext);

        if (deviceExtension->NextContextToFree) {

            FreeAsyncRequestContext(
                deviceExtension,
                deviceExtension->NextContextToFree
                );

            deviceExtension->NextContextToFree = NULL;
        }

        if (!IsListEmpty (&deviceExtension->PendingOrbList)) {

            //
            // signal target to restart processing at the head of the list
            //

            orbContext = RETRIEVE_CONTEXT(
                deviceExtension->PendingOrbList.Flink,
                OrbList
                );

            Sbp2AccessRegister(
                deviceExtension,
                &orbContext->CmdOrbAddress,
                ORB_POINTER_REG | REG_WRITE_ASYNC
                );
        }

    } else {

         if (statusBlock->AddressAndStatus.u.HighQuad.u.HighPart & STATUS_BLOCK_ENDOFLIST_BIT_MASK) {

             //
             // At the time this ORB was most recently fetched by the
             // target the next_ORB field was "null",
             //
             // so we can't free this context yet since the next ORB we
             // submit may have to "piggyback" on it (but we can free the
             // previous request, if any, that was in the same situation)
             //

             if (deviceExtension->NextContextToFree) {

                 FreeAsyncRequestContext(
                     deviceExtension,
                     deviceExtension->NextContextToFree
                     );
             }

             deviceExtension->NextContextToFree = orbContext;

             //
             // This was the end of list at the time the device completed
             // it, but it may not be end of list now (in which case we
             // don't want to append to it again).  Check to see if
             // the NextOrbAddress is "null" or not.
             //

             if (orbContext->CmdOrb->NextOrbAddress.OctletPart ==
                     0xFFFFFFFFFFFFFFFF) {

                 deviceExtension->AppendToNextContextToFree = TRUE;

             } else {

                 deviceExtension->AppendToNextContextToFree = FALSE;
             }

         } else {

             //
             // At the time this ORB was most recently fetched by the
             // target the next_ORB field was not "null",
             //
             // so we can safely free this context since target already
             // knows about the next ORB in the list
             //

             FreeAsyncRequestContext (deviceExtension, orbContext);
         }
    }

    currentOrbListDepth = deviceExtension->OrbListDepth;

    deviceExtension->LastStatusBlock = *statusBlock;

    KeReleaseSpinLockFromDpcLevel (&deviceExtension->OrbListSpinLock);

    requestIrp->IoStatus.Status = status;

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
    IoCompleteRequest (requestIrp, IO_NO_INCREMENT);

    //
    // Only start another packet if the Ext.OrbListDepth was initially
    // maxed and we then freed at least one request context above.
    // In this case the last orb that was placed on the list was
    // not followed (in Sbp2InsertTailList) by a call to StartNextPacket,
    // so we have to do that here to restart the queue.
    //

    if ((initialOrbListDepth == deviceExtension->MaxOrbListDepth) &&
        (initialOrbListDepth > currentOrbListDepth)) {

        Sbp2StartNextPacketByKey(
            deviceObject,
            deviceExtension->CurrentKey
            );
    }


    DEBUGPRINT3(("Sbp2Port: GlobalStatusCb: leaving callback, depth=%d\n",deviceExtension->OrbListDepth));
    rcode = RCODE_RESPONSE_COMPLETE;

exitGlobalCallback:

    //
    // return the status fifo back to the list
    //

    ExInterlockedPushEntrySList(&deviceExtension->StatusFifoListHead,
                                &NotificationInfo->Fifo->FifoList,
                                &deviceExtension->StatusFifoLock);


    return (ULONG) rcode;
}


RCODE
Sbp2ManagementOrbStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    )
/*++

Routine Description:

    Callback routine for writes to our Task Status Block. the 1394 driver will call this routine, after
    the target has updated the status in our memory. A Task function is usually a recovery attempt.

Arguments:

    (Check 1394Bus.doc)

Return Value:

    0

--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PADDRESS_CONTEXT context = (PADDRESS_CONTEXT) NotificationInfo->Context;
    NTSTATUS status;


    if (NotificationInfo->Context != NULL ) {

        deviceObject = ((PADDRESS_CONTEXT)NotificationInfo->Context)->DeviceObject;
        deviceExtension = deviceObject->DeviceExtension;

    } else {

        return RCODE_RESPONSE_COMPLETE;
    }

    if (TEST_FLAG(NotificationInfo->fulNotificationOptions, NOTIFY_FLAGS_AFTER_READ)){

        //
        // This shouldn't happen since we set our flags to NOTIFY_AFTER_WRITE
        //

        return RCODE_TYPE_ERROR;
    }

    octbswap(deviceExtension->ManagementOrbStatusBlock.AddressAndStatus);
    deviceExtension->ManagementOrb->OrbInfo.QuadPart =
        bswap(deviceExtension->ManagementOrb->OrbInfo.QuadPart);

    status = CheckStatusResponseValue(&deviceExtension->ManagementOrbStatusBlock);

    switch (deviceExtension->ManagementOrb->OrbInfo.u.HighPart & 0x00FF) {

    case TRANSACTION_RECONNECT:

        //
        // If there was a pending reset, cancel it
        //

        KeAcquireSpinLockAtDpcLevel(&deviceExtension->ExtensionDataSpinLock);

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_RECONNECT)) {

            DEBUGPRINT1((
                "Sbp2Port: MgmtOrbStatusCb: RECONNECT, sts=x%x, ext=x%p, fl=x%x\n",
                status,
                deviceExtension,
                deviceExtension->DeviceFlags
                ));

            KeCancelTimer(&deviceExtension->DeviceManagementTimer);

            if (NT_SUCCESS(status)) {

                CLEAR_FLAG(deviceExtension->DeviceFlags,(DEVICE_FLAG_RESET_IN_PROGRESS | DEVICE_FLAG_DEVICE_FAILED | DEVICE_FLAG_RECONNECT | DEVICE_FLAG_STOPPED));

                KeReleaseSpinLockFromDpcLevel(&deviceExtension->ExtensionDataSpinLock);

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->OrbListSpinLock);

                if (TEST_FLAG(
                        deviceExtension->DeviceFlags,
                        DEVICE_FLAG_QUEUE_LOCKED
                        ) &&

                        (deviceExtension->DeferredPowerRequest != NULL)
                        ) {

                    //
                    // A START_STOP_UNIT was caught in the middle of a bus
                    // reset and was deferred until after we reconnected.
                    // Complete here so the class driver never knew anything
                    // happened..
                    //

                    PIRP pIrp = deviceExtension->DeferredPowerRequest;


                    deviceExtension->DeferredPowerRequest = NULL;

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->OrbListSpinLock
                        );

                    Sbp2StartIo (deviceObject, pIrp);

                } else {

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->OrbListSpinLock
                        );

                    Sbp2StartNextPacketByKey(
                        deviceExtension->DeviceObject,
                        deviceExtension->CurrentKey
                        );
                }

                KeSetEvent(&deviceExtension->ManagementEvent,IO_NO_INCREMENT,FALSE);

            } else {

                //
                // probably too late, we need to a re-login
                //

                CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_RECONNECT);
                SET_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_LOGIN_IN_PROGRESS);

                KeCancelTimer(&deviceExtension->DeviceManagementTimer);

                KeReleaseSpinLockFromDpcLevel(&deviceExtension->ExtensionDataSpinLock);

                Sbp2UpdateNodeInformation(deviceExtension);

                //
                // see if can access the device
                //

                DEBUGPRINT1((
                    "Sbp2Port: MgmtOrbStatusCb: ...(RECONNECT err) " \
                        "trying re-login\n"
                    ));

                Sbp2ManagementTransaction(deviceExtension, TRANSACTION_LOGIN);
            }

        } else {

            KeReleaseSpinLockFromDpcLevel(&deviceExtension->ExtensionDataSpinLock);
        }

        break;

    case TRANSACTION_QUERY_LOGINS:

        //
        // set the management event, indicating that the request was processed
        //

        DEBUGPRINT1((
            "Sbp2Port: MgmtOrbStatusCb: QUERY_LOGIN, sts=x%x, ext=x%p, fl=x%x\n",
            status,
            deviceExtension,
            deviceExtension->DeviceFlags
            ));

        if (NT_SUCCESS(status)) {

            //
            // check if there somebody logged in..
            //

            deviceExtension->QueryLoginResponse->LengthAndNumLogins.QuadPart =
                bswap(deviceExtension->QueryLoginResponse->LengthAndNumLogins.QuadPart);

            if ((deviceExtension->QueryLoginResponse->LengthAndNumLogins.u.LowPart == 1) &&
                (deviceExtension->QueryLoginResponse->LengthAndNumLogins.u.HighPart > 4)){

                //
                // exclusive login so we have to worry about it...
                //

                deviceExtension->QueryLoginResponse->Elements[0].NodeAndLoginId.QuadPart =
                    bswap(deviceExtension->QueryLoginResponse->Elements[0].NodeAndLoginId.QuadPart);

                //
                // Assume the only initiator logged in is the bios...
                // Log out the bios using it login ID...
                //

                deviceExtension->LoginResponse->LengthAndLoginId.u.LowPart =
                deviceExtension->QueryLoginResponse->Elements[0].NodeAndLoginId.u.LowPart;

                //
                // Dont set the vent, so we stall and the BIOS is implicitly logged out
                // since it cant reconnect..
                //

                DEBUGPRINT1(("\nSbp2Port: MgmtOrbStatusCb: somebody else logged in, stalling so it gets logged out\n"));
            }

        } else {

            KeSetEvent(&deviceExtension->ManagementEvent,IO_NO_INCREMENT,FALSE);
        }

        break;

    case TRANSACTION_LOGIN:

        //
        // Per the Sbp2 spec we'd normally expect all login notifications
        // to show up at Sbp2GlobalStatusCallback.  In practice, however,
        // we see completion notifications showing up here when an
        // async login is submitted after a failed reconnect.
        //

        Sbp2LoginCompletion (NotificationInfo, status);

        DEBUGPRINT1((
            "Sbp2Port: MgmtOrbStatusCb: ...wrong place for login completions!\n"
            ));

        break;

    default:

        DEBUGPRINT1((
            "Sbp2Port: MgmtOrbStatusCb: type=%d, sts=x%x, ext=x%p, fl=x%x\n",
            deviceExtension->ManagementOrb->OrbInfo.u.HighPart & 0x00FF,
            status,
            deviceExtension,
            deviceExtension->DeviceFlags
            ));

        KeSetEvent(&deviceExtension->ManagementEvent,IO_NO_INCREMENT,FALSE);

        break;
    }

    return RCODE_RESPONSE_COMPLETE;
}


#if PASSWORD_SUPPORT

RCODE
Sbp2SetPasswordOrbStatusCallback(
    IN PNOTIFICATION_INFO   NotificationInfo
    )
{
    RCODE               returnCode = RCODE_RESPONSE_COMPLETE;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension;
    PADDRESS_CONTEXT    context = (PADDRESS_CONTEXT) NotificationInfo->Context;
    NTSTATUS            status;


    if (NotificationInfo->Context != NULL ) {

        deviceObject = ((PADDRESS_CONTEXT)NotificationInfo->Context)->
            DeviceObject;

        deviceExtension = deviceObject->DeviceExtension;

    } else {

        return RCODE_RESPONSE_COMPLETE;
    }

    if (TEST_FLAG(
            NotificationInfo->fulNotificationOptions,
            NOTIFY_FLAGS_AFTER_READ
            )){

        //
        // This shouldn't happen since we set our flags to NOTIFY_AFTER_WRITE
        //

        returnCode = RCODE_TYPE_ERROR;
        goto Exit_Sbp2SetPasswordOrbStatusCallback;
    }

    octbswap(deviceExtension->PasswordOrbStatusBlock.AddressAndStatus);
    deviceExtension->PasswordOrb->OrbInfo.QuadPart =
        bswap(deviceExtension->PasswordOrb->OrbInfo.QuadPart);

    status = CheckStatusResponseValue(
        &deviceExtension->PasswordOrbStatusBlock
        );

    if ((deviceExtension->PasswordOrb->OrbInfo.u.HighPart & 0x00FF) ==
            TRANSACTION_SET_PASSWORD) {

        DEBUGPRINT1(("Sbp2Port: TRANSACTION_SET_PASSWORD Callback\n"));

        DEBUGPRINT1((
            "Sbp2Port: PasswdOrbStatusCb: type=%d, sts=x%x, ext=x%p, fl=x%x\n",
            deviceExtension->PasswordOrb->OrbInfo.u.HighPart & 0x00FF,
            status,
            deviceExtension,
            deviceExtension->DeviceFlags
            ));
    }
    else {

        DEBUGPRINT1(("Sbp2Port: PasswdOrbStatusCb: Wrong xact type=x%x\n",
            (deviceExtension->PasswordOrb->OrbInfo.u.HighPart & 0x00FF)));
    }

Exit_Sbp2SetPasswordOrbStatusCallback:

    KeSetEvent(
        &deviceExtension->PasswordEvent,
        IO_NO_INCREMENT,
        FALSE
        );

    return returnCode;
}

#endif

VOID
Sbp2LoginCompletion(
    PNOTIFICATION_INFO  NotificationInfo,
    NTSTATUS            Status
    )
{
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension;


    if (NotificationInfo->Context != NULL ) {

        deviceObject = ((PADDRESS_CONTEXT) NotificationInfo->Context)->
            DeviceObject;

        deviceExtension = deviceObject->DeviceExtension;

    } else {

        return;
    }

    KeCancelTimer (&deviceExtension->DeviceManagementTimer);

    KeAcquireSpinLockAtDpcLevel (&deviceExtension->ExtensionDataSpinLock);

    if (TEST_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_LOGIN_IN_PROGRESS)){

        if (Status != STATUS_SUCCESS) {

            //
            // Login failed... We can't to much else.
            //

            CLEAR_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_RECONNECT | DEVICE_FLAG_LOGIN_IN_PROGRESS)
                );

            SET_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_STOPPED | DEVICE_FLAG_DEVICE_FAILED)
                );

            deviceExtension->LastTransactionStatus = Status;

            KeReleaseSpinLockFromDpcLevel(
                &deviceExtension->ExtensionDataSpinLock
                );

            DEBUGPRINT1((
                "Sbp2Port: LoginCompl: sts=x%x, ext=x%p, fl=x%x\n",
                Status,
                deviceExtension,
                deviceExtension->DeviceFlags
                ));

            deviceExtension->LoginResponse->Csr_Off_Low.QuadPart = 0;

            if (!TEST_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_RESET_IN_PROGRESS
                      )) {

                KeSetEvent(
                    &deviceExtension->ManagementEvent,
                    IO_NO_INCREMENT,
                    FALSE
                    );

            } else {

                if (deviceExtension->DeferredPowerRequest) {

                    PIRP    irp = deviceExtension->DeferredPowerRequest;

                    deviceExtension->DeferredPowerRequest = NULL;

                    Sbp2StartIo (deviceObject, irp);

                } else {

                    Sbp2StartNextPacketByKey(
                        deviceObject,
                        deviceExtension->CurrentKey
                        );
                }

                IoInvalidateDeviceState (deviceObject);
            }

            return;
        }

        //
        // Succesful login, read the response buffer (it has our login ID)
        //


        DEBUGPRINT2((
            "Sbp2Port: LoginCompl: success, ext=x%p, fl=x%x\n",
            deviceExtension,
            deviceExtension->DeviceFlags
            ));

        deviceExtension->LastTransactionStatus = Status;

        deviceExtension->LoginResponse->LengthAndLoginId.QuadPart =
            bswap(deviceExtension->LoginResponse->LengthAndLoginId.QuadPart);

        deviceExtension->LoginResponse->Csr_Off_High.QuadPart =
            bswap(deviceExtension->LoginResponse->Csr_Off_High.QuadPart);

        deviceExtension->LoginResponse->Csr_Off_Low.QuadPart =
            bswap(deviceExtension->LoginResponse->Csr_Off_Low.QuadPart);

        //
        // Store the register base for target fetch agents
        //

        deviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_High =
            deviceExtension->LoginResponse->Csr_Off_High.u.LowPart;

        deviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low =
            deviceExtension->LoginResponse->Csr_Off_Low.QuadPart;

        //
        // this callback fired becuase the asynchronous login succeeded
        // clear our device flags to indicate the device is operating fine
        //

        CLEAR_FLAG(
            deviceExtension->DeviceFlags,
            (DEVICE_FLAG_LOGIN_IN_PROGRESS | DEVICE_FLAG_STOPPED |
                DEVICE_FLAG_REMOVED | DEVICE_FLAG_DEVICE_FAILED)
            );

        if (!TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_RESET_IN_PROGRESS
                )) {

            KeReleaseSpinLockFromDpcLevel(
                &deviceExtension->ExtensionDataSpinLock
                );

            KeSetEvent(
                &deviceExtension->ManagementEvent,
                IO_NO_INCREMENT,
                FALSE
                );

        } else {

            CLEAR_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_RESET_IN_PROGRESS
                );

            KeReleaseSpinLockFromDpcLevel(
                &deviceExtension->ExtensionDataSpinLock
                );

            if (TEST_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_QUEUE_LOCKED
                      )) {

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->OrbListSpinLock);

                if (deviceExtension->DeferredPowerRequest) {

                    //
                    // A request was caught in the middle of a bus reset
                    // and was deferred until after we reconnected.
                    // Complete here so the class driver never knew anything
                    // happened.
                    //

                    PIRP pIrp = deviceExtension->DeferredPowerRequest;

                    deviceExtension->DeferredPowerRequest = NULL;

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->OrbListSpinLock
                        );

                    Sbp2StartIo (deviceObject, pIrp);

                } else {

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->OrbListSpinLock
                        );

                    Sbp2StartNextPacketByKey(
                        deviceObject,
                        deviceExtension->CurrentKey
                        );
                }

            } else {

                Sbp2StartNextPacketByKey(
                    deviceObject,
                    deviceExtension->CurrentKey
                    );
            }
        }

        //
        // make retry limit high for busy transactions
        //

        deviceExtension->Reserved = BUSY_TIMEOUT_SETTING;

        Sbp2AccessRegister(
            deviceExtension,
            &deviceExtension->Reserved,
            CORE_BUSY_TIMEOUT_REG | REG_WRITE_ASYNC
            );

    } else {

        KeReleaseSpinLockFromDpcLevel(
            &deviceExtension->ExtensionDataSpinLock
            );
    }
}


RCODE
Sbp2TaskOrbStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    )
/*++

Routine Description:

    Callback routine for writes to our Task Status Block. the 1394 driver will call this routine, after
    the target has updated the status in our memory. A Task function is an ABORT_TASK_SET or TARGET_RESET,
    for this implementation

Arguments:

    NotificationInfo - bus supplied context for this notification

Return Value:

    0

--*/
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PADDRESS_CONTEXT context = (PADDRESS_CONTEXT) NotificationInfo->Context;
    NTSTATUS status;


    if (NotificationInfo->Context != NULL ) {

        deviceObject = ((PADDRESS_CONTEXT)NotificationInfo->Context)->DeviceObject;
        deviceExtension = deviceObject->DeviceExtension;

    } else {
        return RCODE_RESPONSE_COMPLETE;
    }

    if (TEST_FLAG(NotificationInfo->fulNotificationOptions, NOTIFY_FLAGS_AFTER_READ)){

        //
        // This shouldn't happen since we set our flags to NOTIFY_AFTER_WRITE
        //

        return RCODE_TYPE_ERROR;

    } else if (NotificationInfo->fulNotificationOptions & NOTIFY_FLAGS_AFTER_WRITE){

        //
        // now cleanup our lists, if the abort task set completed succesfully ( if not rejected)
        //

        if (!TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_RESET_IN_PROGRESS)) {

            DEBUGPRINT1(("Sbp2Port: TaskOrbStatusCb: bogus call, rejected\n"));
            return (ULONG)RCODE_RESPONSE_COMPLETE;
        }

        KeCancelTimer(&deviceExtension->DeviceManagementTimer);

        octbswap(deviceExtension->TaskOrbStatusBlock.AddressAndStatus);
        status = CheckStatusResponseValue(&deviceExtension->TaskOrbStatusBlock);

        if (status!=STATUS_SUCCESS) {

            if (deviceExtension->TaskOrbContext.TransactionType != TRANSACTION_TARGET_RESET) {

                DEBUGPRINT1(("Sbp2Port: TaskOrbStatusCb: ABORT TASK SET func err\n"));

            } else {

                //
                // a target reset didn't complete succesfully. Fatal error...
                //

                DEBUGPRINT1(("Sbp2Port: TaskOrbStatusCb: Target RESET err, try CMD_RESET & relogin\n"));

                Sbp2CreateRequestErrorLog(deviceExtension->DeviceObject,NULL,STATUS_DEVICE_OFF_LINE);
                deviceExtension->Reserved = 0;
                Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,CORE_RESET_REG | REG_WRITE_ASYNC);

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->ExtensionDataSpinLock);
                SET_FLAG(deviceExtension->DeviceFlags,(DEVICE_FLAG_RECONNECT | DEVICE_FLAG_STOPPED));
                KeReleaseSpinLockFromDpcLevel(&deviceExtension->ExtensionDataSpinLock);

                deviceExtension->DueTime.HighPart = -1;
                deviceExtension->DueTime.LowPart = SBP2_RELOGIN_DELAY;
                KeSetTimer(&deviceExtension->DeviceManagementTimer,deviceExtension->DueTime, &deviceExtension->DeviceManagementTimeoutDpc);

                return (ULONG) RCODE_RESPONSE_COMPLETE;
            }
        }

        deviceExtension->Reserved = BUSY_TIMEOUT_SETTING;
        Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,CORE_BUSY_TIMEOUT_REG | REG_WRITE_ASYNC);

        //
        // reset the fetch agent
        //

        Sbp2AccessRegister(deviceExtension,&deviceExtension->Reserved,AGENT_RESET_REG | REG_WRITE_ASYNC);

        DEBUGPRINT2(("Sbp2Port: TaskOrbStatusCb: TASK func succes\n"));

        KeAcquireSpinLockAtDpcLevel(&deviceExtension->ExtensionDataSpinLock);

        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_RESET_IN_PROGRESS);

        if (deviceExtension->TaskOrbContext.TransactionType == TRANSACTION_TARGET_RESET) {

            CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_STOPPED);
        }

        //
        // decrease number of possible outstanding requests.
        //

        deviceExtension->MaxOrbListDepth = max(MIN_ORB_LIST_DEPTH,deviceExtension->MaxOrbListDepth/2);

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->ExtensionDataSpinLock);

        CleanupOrbList(deviceExtension,STATUS_REQUEST_ABORTED);

        Sbp2StartNextPacketByKey (deviceExtension->DeviceObject, 0);
    }

    return (ULONG) RCODE_RESPONSE_COMPLETE;
}


VOID
Sbp2HandleUnsolicited(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSTATUS_FIFO_BLOCK StatusFifo
    )
/*++

Routine Description:

    Inteprets the unsolicited status recieved and takes action if necessery
    If the unsolicted requets called for power transition, request a power irp
    ..

Arguments:

    DeviceExtension - Pointer to device extension.

    StatusFifo - fifo send by the device

Return Value:



--*/
{
    UCHAR senseBuffer[SENSE_BUFFER_SIZE];
    POWER_STATE state;
    NTSTATUS status;


    if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_SPC_CMD_SET)) {

        switch (DeviceExtension->DeviceInfo->Lun.u.HighPart & 0x001F) {

        case RBC_DEVICE:

            //
            // use RBC spec for intepreting status contents
            // the sense keys tells us what type of status this was
            //

            if (ConvertSbp2SenseDataToScsi(StatusFifo, senseBuffer,sizeof(senseBuffer))) {

                if ((senseBuffer[2] == 0x06) && (senseBuffer[12] == 0x7F)) {

                    switch (senseBuffer[13]) {

                    case RBC_UNSOLICITED_CLASS_ASQ_DEVICE:
                    case RBC_UNSOLICITED_CLASS_ASQ_MEDIA:

                        break;

                    case RBC_UNSOLICITED_CLASS_ASQ_POWER:

                        //
                        // initiate power transtion, per device request
                        //

                        state.DeviceState = PowerDeviceD0;
                        DEBUGPRINT1(("Sbp2Port: HandleUnsolicited: send D irp state=x%x\n ",state));

                        status = PoRequestPowerIrp(
                                     DeviceExtension->DeviceObject,
                                     IRP_MN_SET_POWER,
                                     state,
                                     NULL,
                                     NULL,
                                     NULL);

                        if (!NT_SUCCESS(status)) {

                            //
                            // not good, we cant power up the device..
                            //

                            DEBUGPRINT1(("Sbp2Port: HandleUnsolicited: D irp err=x%x\n ",status));
                        }

                        break;
                    }
                }
            }

            break;
        }
    }
}


NTSTATUS
Sbp2GetControllerInfo(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Find the maximum packet size that can be sent across. If there is
    any error, return the minimum size.

Arguments:

    DeviceExtension - Pointer to device extension.

    IrP - Pointer to Irp. If this is NULL, we have to allocate our own.

    Irb - Pointer to Irb. If this is NULL, we have to allocate our own.

Return Value:

    NTSTATUS

--*/

{
    PIRBIRP                 packet = NULL;
    NTSTATUS                status;
    GET_LOCAL_HOST_INFO7    getLocalHostInfo7;


    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get the max speed between devices so that we can calculate the
    // maximum number of bytes we can send
    //

    packet->Irb->FunctionNumber = REQUEST_GET_SPEED_BETWEEN_DEVICES;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetMaxSpeedBetweenDevices.ulNumberOfDestinations = 0;
    packet->Irb->u.GetMaxSpeedBetweenDevices.fulFlags = USE_LOCAL_NODE;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS (status)) {

        goto exitFindHostInfo;
    }

    //
    // Calculate the max block size based on the speed
    //

    DeviceExtension->MaxControllerPhySpeed = packet->Irb->u.GetMaxSpeedBetweenDevices.fulSpeed >> 1;

    switch (DeviceExtension->MaxControllerPhySpeed) {

    case SCODE_100_RATE:

        DeviceExtension->OrbWritePayloadMask = (0x00F0 & 0x0070);
        DeviceExtension->OrbReadPayloadMask = (0x00F0 & 0x0070);
        break;

    case SCODE_200_RATE:

        DeviceExtension->OrbWritePayloadMask = (0x00F0 & 0x0080);
        DeviceExtension->OrbReadPayloadMask = (0x00F0 & 0x0080);
        break;

    case SCODE_400_RATE:

        DeviceExtension->OrbWritePayloadMask = (0x00F0 & 0x0090);
        DeviceExtension->OrbReadPayloadMask = (0x00F0 & 0x0090);
        break;
    }

    //
    // find what the host adaptor below us supports...
    // it might support less than the payload for this phy speed
    //

    packet->Irb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetLocalHostInformation.nLevel = GET_HOST_CAPABILITIES;
    packet->Irb->u.GetLocalHostInformation.Information = &DeviceExtension->HostControllerInformation;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        goto exitFindHostInfo;
    }

    switch (DeviceExtension->HostControllerInformation.MaxAsyncWriteRequest) {

    case ASYNC_PAYLOAD_100_RATE:

        DeviceExtension->OrbWritePayloadMask = min((0x00F0 & 0x0070),DeviceExtension->OrbWritePayloadMask);
        break;

    case ASYNC_PAYLOAD_200_RATE:

        DeviceExtension->OrbWritePayloadMask = min((0x00F0 & 0x0080),DeviceExtension->OrbWritePayloadMask);
        break;
    }

    switch (DeviceExtension->HostControllerInformation.MaxAsyncReadRequest) {

    case ASYNC_PAYLOAD_100_RATE:

        DeviceExtension->OrbReadPayloadMask = min((0x00F0 & 0x0070),DeviceExtension->OrbReadPayloadMask);
        break;

    case ASYNC_PAYLOAD_200_RATE:

        DeviceExtension->OrbReadPayloadMask = min((0x00F0 & 0x0080),DeviceExtension->OrbReadPayloadMask);
        break;
    }

    //
    // Get the direct mapping routine from the host adaptor(if it support this)
    // status is not important in this case sinc this is an optional capability
    //

    packet->Irb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetLocalHostInformation.nLevel = GET_PHYS_ADDR_ROUTINE;
    packet->Irb->u.GetLocalHostInformation.Information = &DeviceExtension->HostRoutineAPI;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        //
        // the host controller under us is no supported..
        //

        DEBUGPRINT1(("Sbp2Port: GetCtlrInfo: failed to get phys map rout, fatal\n"));
        goto exitFindHostInfo;
    }

    //
    // find what the host adaptor below us supports...
    // it might support less than the payload for this phy speed
    //

    packet->Irb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    packet->Irb->Flags = 0;
    packet->Irb->u.GetLocalHostInformation.nLevel = GET_HOST_DMA_CAPABILITIES;
    packet->Irb->u.GetLocalHostInformation.Information = &getLocalHostInfo7;

    status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

    if (!NT_SUCCESS(status)) {

        DEBUGPRINT1(("Sbp2Port: GetCtlrInfo: err getting DMA info, def MaxXfer = 64k\n"));
        DeviceExtension->DeviceInfo->MaxClassTransferSize = SBP2_MAX_DIRECT_BUFFER_SIZE;
        status = STATUS_SUCCESS;

    } else {

        if (getLocalHostInfo7.MaxDmaBufferSize.QuadPart == 0) {

            DeviceExtension->DeviceInfo->MaxClassTransferSize = (ULONG) min( DeviceExtension->DeviceInfo->MaxClassTransferSize,
                                                                             SBP2_MAX_TRANSFER_SIZE
                                                                             );
        }
        else {

            DeviceExtension->DeviceInfo->MaxClassTransferSize = (ULONG) min( DeviceExtension->DeviceInfo->MaxClassTransferSize,
                                                                             min( getLocalHostInfo7.MaxDmaBufferSize.QuadPart,
                                                                                  SBP2_MAX_TRANSFER_SIZE)
                                                                             );
        }

        DEBUGPRINT2(("Sbp2Port: GetCtlrInfo: ctlr maxDma=x%x%08x, maxXfer=x%x\n",
                    getLocalHostInfo7.MaxDmaBufferSize.HighPart,
                    getLocalHostInfo7.MaxDmaBufferSize.LowPart,
                    DeviceExtension->DeviceInfo->MaxClassTransferSize));
    }

exitFindHostInfo:

    DeAllocateIrpAndIrb(DeviceExtension,packet);

    return status;
}


NTSTATUS
Sbp2AccessRegister(
    PDEVICE_EXTENSION DeviceExtension,
    PVOID Data,
    USHORT RegisterAndDirection
    )
/*++

Routine Description:

    Knows the how to access SBP2 and 1394 specific target registers. It wills send requests
    of the appropriate size and of the supported type (READ or WRITE) for the specific register

Arguments:

    DeviceExtension - Pointer to device extension.

    Data - Calue to write to the register

    RegisterAndDirection - BitMask that indicates which register to write and if its a WRITE or a READ

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;

    PIRBIRP packet = NULL;


    if (TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED)) {

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    AllocateIrpAndIrb(DeviceExtension,&packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // update SBP specific registers at the node
    // We better have all the addressing info before this function is called
    //

    packet->Irb->Flags = 0;

    //
    // check which register we need to whack
    //

    switch (RegisterAndDirection & REG_TYPE_MASK) {

    //
    // write only quadlet sized registers
    //
    case TEST_REG:
    case CORE_BUSY_TIMEOUT_REG:
    case CORE_RESET_REG:
    case UNSOLICITED_STATUS_REG:
    case DOORBELL_REG:
    case AGENT_RESET_REG:

        packet->Irb->FunctionNumber = REQUEST_ASYNC_WRITE;
        packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High =
                        INITIAL_REGISTER_SPACE_HI;

        packet->Irb->u.AsyncWrite.fulFlags = 0;

        switch(RegisterAndDirection & REG_TYPE_MASK) {

        case TEST_REG:

            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low = INITIAL_REGISTER_SPACE_LO
                                                                                 | TEST_REG_OFFSET;

            *((PULONG)Data) = bswap(*((PULONG)Data));

            break;

        case CORE_BUSY_TIMEOUT_REG:

            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low = INITIAL_REGISTER_SPACE_LO
                                                                                 | 0x00000210;

            *((PULONG)Data) = bswap(*((PULONG)Data));

            break;

        case CORE_RESET_REG:

            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low = INITIAL_REGISTER_SPACE_LO
                                                                                 | 0x0000000C;
            break;

        case DOORBELL_REG:

            //
            // we dont care if this suceeds or not, and also we dont want to take an INT hit when this is send
            //

            packet->Irb->u.AsyncWrite.fulFlags |= ASYNC_FLAGS_NO_STATUS;
            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =
            (DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low + DOORBELL_REG_OFFSET) | INITIAL_REGISTER_SPACE_LO;
            break;

        case AGENT_RESET_REG:

            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =
            (DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low + AGENT_RESET_REG_OFFSET) | INITIAL_REGISTER_SPACE_LO;
            break;

        case UNSOLICITED_STATUS_REG:

            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =
            (DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low + UNSOLICITED_STATUS_REG_OFFSET) | INITIAL_REGISTER_SPACE_LO;
            break;
        }

        //
        // for all of the above writes, where the data is not signigficant(ping)
        // we have reserved an mdl so we dont have to allocate each time
        //

        packet->Irb->u.AsyncWrite.Mdl = DeviceExtension->ReservedMdl;

        packet->Irb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(QUADLET);
        packet->Irb->u.AsyncWrite.nBlockSize = 0;
        packet->Irb->u.AsyncWrite.ulGeneration = DeviceExtension->CurrentGeneration;
        break;

    case MANAGEMENT_AGENT_REG:
    case ORB_POINTER_REG:

        if ((RegisterAndDirection & REG_WRITE_SYNC) || (RegisterAndDirection & REG_WRITE_ASYNC) ){

            //
            // Swap the stuff we want ot write to the register.
            // the caller always passes the octlet in little endian
            //

            packet->Octlet = *(POCTLET)Data;
            octbswap(packet->Octlet);

            packet->Irb->FunctionNumber = REQUEST_ASYNC_WRITE;
            packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High =
                          INITIAL_REGISTER_SPACE_HI;

            if (RegisterAndDirection & ORB_POINTER_REG) {

                packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =
                (DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low + ORB_POINTER_REG_OFFSET) | INITIAL_REGISTER_SPACE_LO;

            } else {

                packet->Irb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =
                 DeviceExtension->DeviceInfo->ManagementAgentBaseReg.BusAddress.Off_Low | INITIAL_REGISTER_SPACE_LO;
            }

            packet->Irb->u.AsyncWrite.Mdl = IoAllocateMdl(&packet->Octlet, sizeof(OCTLET),FALSE,FALSE,NULL);

            if (!packet->Irb->u.AsyncWrite.Mdl) {

                DeAllocateIrpAndIrb(DeviceExtension,packet);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            packet->Irb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(OCTLET);
            packet->Irb->u.AsyncWrite.nBlockSize = 0;
            packet->Irb->u.AsyncWrite.fulFlags = 0;
            packet->Irb->u.AsyncWrite.ulGeneration = DeviceExtension->CurrentGeneration;
            MmBuildMdlForNonPagedPool(packet->Irb->u.AsyncWrite.Mdl);

        } else {

            packet->Irb->FunctionNumber = REQUEST_ASYNC_READ;

            if (RegisterAndDirection & ORB_POINTER_REG) {

                packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low =
                (DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_Low + ORB_POINTER_REG_OFFSET);

            } else {

                packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low =
                            DeviceExtension->DeviceInfo->ManagementAgentBaseReg.BusAddress.Off_Low;
            }

            packet->Irb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High =
                            DeviceExtension->DeviceInfo->CsrRegisterBase.BusAddress.Off_High;

            packet->Irb->u.AsyncRead.Mdl = IoAllocateMdl(Data, sizeof(OCTLET),FALSE,FALSE,NULL);

            if (!packet->Irb->u.AsyncRead.Mdl) {

                DeAllocateIrpAndIrb(DeviceExtension,packet);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            packet->Irb->u.AsyncRead.nNumberOfBytesToRead = sizeof(OCTLET);
            packet->Irb->u.AsyncRead.nBlockSize = 0;
            packet->Irb->u.AsyncRead.fulFlags = 0;
            packet->Irb->u.AsyncRead.ulGeneration = DeviceExtension->CurrentGeneration;
            MmBuildMdlForNonPagedPool(packet->Irb->u.AsyncRead.Mdl);
        }

        break;
    }

    if (RegisterAndDirection & REG_WRITE_ASYNC) {

        status = Sbp2SendRequest (DeviceExtension, packet, ASYNC_1394_REQUEST);

    } else {

        status = Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);

        if (NT_SUCCESS(status)) {

            if (RegisterAndDirection & REG_READ_SYNC) {

                //
                // convert from big -> little endian for read data
                //

                switch (RegisterAndDirection & REG_TYPE_MASK) {

                case ORB_POINTER_REG:
                case MANAGEMENT_AGENT_REG:

                    packet->Octlet = *((POCTLET)Data);
                    octbswap(packet->Octlet);
                    *((POCTLET)Data) = packet->Octlet;
                    break;
                }
            }
        }

        if (packet->Irb->u.AsyncWrite.nNumberOfBytesToWrite == sizeof(OCTLET)) {

            IoFreeMdl(packet->Irb->u.AsyncRead.Mdl);
        }

        DeAllocateIrpAndIrb(DeviceExtension,packet);
    }

    return status;
}

//
// IEEE 1212 Directory definition
//
typedef struct _DIRECTORY_INFO {
    union {
        USHORT          DI_CRC;
        USHORT          DI_Saved_Length;
    } u;
    USHORT              DI_Length;
} DIRECTORY_INFO, *PDIRECTORY_INFO;


NTSTATUS
Sbp2_ProcessTextualDescriptor(
    IN PTEXTUAL_LEAF            TextLeaf,
    IN OUT PUNICODE_STRING      uniString
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PULONG              pData = NULL;
    ULONG               DataLength, i, n;
    ULONG               ulUnicode;

    ULONG               ulQuadlet;

    union {
        ULONG           asUlong;
        UCHAR           asUchar[4];
        DIRECTORY_INFO  DirectoryHeader;
    } u;

    UCHAR               uChar;

    if ((uniString->Length) || (uniString->Buffer)) {

        TRACE(TL_PNP_TRACE, ("(already exists) uniString = %ws", (PWCHAR)uniString->Buffer));
        return(ntStatus);
    }

    // number of entries
    u.asUlong = bswap(*((PULONG)TextLeaf));
    DataLength = u.DirectoryHeader.DI_Length-2;

    // save spec type
    ulUnicode = bswap(*((PULONG)TextLeaf+1));

    pData = ExAllocatePool(NonPagedPool, DataLength*sizeof(ULONG)+2);

    if (pData == NULL) {
        TRACE(TL_1394_ERROR, ("Failed to allocate pData"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2_ProcessTextualDescriptor;
    }

    RtlZeroMemory(pData, DataLength*sizeof(ULONG)+2);
    RtlCopyMemory(pData, &TextLeaf->TL_Data, DataLength*sizeof(ULONG));

    TRACE(TL_1394_INFO, ("pData = %s", (PWCHAR)pData));

    // now we need to verify the characters in pData
    for (i=0; i<(DataLength*sizeof(ULONG)); i++) {

        uChar = *((PUCHAR)pData+i);

        // we should be done if the char equals 0x00
        if (uChar == 0x00)
            break;

        if ((uChar == 0x2C) || (uChar < 0x20) || (uChar > 0x7F)) {

            TRACE(TL_1394_WARNING, ("Invalid Character = 0x%x", uChar));

            // set it to space
            *((PUCHAR)pData+i) = 0x20;
        }

        if (ulUnicode & 0x80000000)
            i++;
    }

    {
        ANSI_STRING     ansiString;

        uniString->Length = 0;
        uniString->MaximumLength = DEVICE_NAME_MAX_CHARS;
        uniString->Buffer = ExAllocatePool(NonPagedPool, uniString->MaximumLength);

        if (!uniString->Buffer) {

            TRACE(TL_1394_ERROR, ("Failed to allocate uniString.Buffer!"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit_Sbp2_ProcessTextualDescriptor;
        }
        RtlZeroMemory(uniString->Buffer, uniString->MaximumLength);

        // unicode??
        if (ulUnicode & 0x80000000) {

            RtlAppendUnicodeToString(uniString, ((PWSTR)pData));
        }
        else {

            RtlInitAnsiString(&ansiString, (PUCHAR)pData);
            RtlAnsiStringToUnicodeString(uniString, &ansiString, FALSE);
        }
    }

    TRACE(TL_1394_INFO, ("uniString = %ws", (PWCHAR)uniString->Buffer));

Exit_Sbp2_ProcessTextualDescriptor:

    if (pData)
        ExFreePool(pData);

    return(ntStatus);
} // Sbp2_ProcessTextualDescriptor
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sbp2port\sbp2port.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    sbp2port.h

Abstract:

    Definitions for SBP2 protocol

Author:

    georgioc 22-Jan-97

Environment:

    Kernel mode only

Revision History:


--*/


#ifndef _SBP2PORT_
#define _SBP2PORT_

#include "sbp2.h"
#include "debug.h"
#include "ntddsbp2.h"
#include <ntddscsi.h>
#include "portlib.h"

//
// define this if we a re running on a TI controller
//

#if DBG

extern ULONG Sbp2DebugLevel;

#define DEBUGPRINT1(_x_)        {if (Sbp2DebugLevel >= 1) \
                                KdPrint (_x_);}

#define DEBUGPRINT2(_x_)        {if (Sbp2DebugLevel >= 2) \
                                KdPrint (_x_);}

#define DEBUGPRINT3(_x_)        {if (Sbp2DebugLevel >= 3) \
                                KdPrint (_x_);}
#define DEBUGPRINT4(_x_)        {if (Sbp2DebugLevel >= 4) \
                                KdPrint (_x_);}

#else

#define DEBUGPRINT1(_x_)
#define DEBUGPRINT2(_x_)
#define DEBUGPRINT3(_x_)
#define DEBUGPRINT4(_x_)

#endif

//
// Remove lock definitions
//

#define REMLOCK_TIMEOUT         2       // minutes
#define REMLOCK_HIGH_WATERMARK  0x2000  // # irps, devctl.exe test sends *alot*

//
// The following FILE_CHARACTERISTICS_XXX constants are copied from
// NTDDK.H and dup'd here, since we include WDM.H and that doesn't
// support these constants.
//
// The FILE_EXPECT flags will only exist for WinXP. After that they will be
// ignored and an IRP will be sent in their place.
//

#define FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL     0x00000200
#define FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL    0x00000300
#define FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK        0x00000300

//
// pool of preallocate async contexts. Has to be less than
// ((PAGE_SIZE / (SBP2_MIN_ORB_SIZE+sizeof(PASYNC_REQUEST_CONTEXT)))
// The numbers below are chosen so they can work as boundary check masks that are ANDed
// with the current pointer into the continious pool
//

#define MAX_ORB_LIST_DEPTH 8
#define MIN_ORB_LIST_DEPTH 5



typedef struct _IRBIRP {

    SLIST_ENTRY ListPointer;
    PIRB    Irb;
    PIRP    Irp;
    OCTLET  Octlet;

} IRBIRP, *PIRBIRP;


typedef struct _ADDRESS_CONTEXT {

    PDEVICE_OBJECT  DeviceObject;
    OCTLET          Address;
    OCTLET          ReservedAddr;
    HANDLE          AddressHandle;
    PMDL            RequestMdl;
    ULONG           TransactionType;
    PVOID           Reserved;

} ADDRESS_CONTEXT, *PADDRESS_CONTEXT;


typedef struct _PAGE_TABLE_CONTEXT {

    ULONG            MaxPages;
    ULONG            NumberOfPages;
    POCTLET          PageTable;
    ADDRESS_CONTEXT  AddressContext;

} PAGE_TABLE_CONTEXT, *PPAGE_TABLE_CONTEXT;


#define SBP2_ASYNC_CONTEXT_TAG 0xADEAFFAB

typedef struct _ASYNC_REQUEST_CONTEXT {

    LIST_ENTRY          OrbList;
    SLIST_ENTRY         LookasideList;
    ULONG               Tag;

    PDEVICE_OBJECT      DeviceObject;
    PSCSI_REQUEST_BLOCK Srb;
    ULONG               Flags;
    PORB_NORMAL_CMD     CmdOrb;

    OCTLET              CmdOrbAddress;
    PMDL                    PartialMdl;
    PMDL                RequestMdl;

    PAGE_TABLE_CONTEXT  PageTableContext;
    HANDLE              DataMappingHandle;

    KDPC                TimerDpc;
    KTIMER              Timer;

    PIRBIRP             Packet;
    PVOID               OriginalSrb;

    ULONG               OrbListDepth;

} ASYNC_REQUEST_CONTEXT, *PASYNC_REQUEST_CONTEXT;


#define ASYNC_CONTEXT_FLAG_TIMER_STARTED        0x00000001
#define ASYNC_CONTEXT_FLAG_COMPLETED            0x00000002
#define ASYNC_CONTEXT_FLAG_PAGE_ALLOC           0x00000004
#define ASYNC_CONTEXT_FLAG_DATA_ALLOC           0x00000008
#define ASYNC_CONTEXT_FLAG_DATA_ALLOC_FAILED    0x00000010
#define ASYNC_CONTEXT_FLAG_RANG_DOORBELL        0x00000020

#define SBP2_PDO                ((ULONG) 'ODPs')
#define SBP2_PDO_DELETED        ((ULONG) 'ODPx')
#define SBP2_FDO                ((ULONG) 'ODFs')
#define SBP2_MAX_LUNS_PER_NODE  10
#define MAX_GENERIC_NAME_LENGTH 16*sizeof(WCHAR)

// begin new
#define DEVICE_NAME_MAX_CHARS           100*sizeof(WCHAR)
#define UNIQUE_ID_MAX_CHARS             50*sizeof(WCHAR)

#define BASE_SBP2_DEVICE_NAME           L"SBP2\\"

// end new

typedef struct _DEVICE_INFORMATION {

    PDEVICE_OBJECT      DeviceObject;
    QUADLET             Lun;
    QUADLET             CmdSetId;
    QUADLET             CmdSetSpecId;

    QUADLET             UnitCharacteristics;
    PCONFIG_ROM         ConfigRom;

    OCTLET              ManagementAgentBaseReg;
    OCTLET              CsrRegisterBase;

    ULONG               MaxClassTransferSize;

    UNICODE_STRING      uniVendorId;        // replaces ModelLeaf
    UNICODE_STRING      uniModelId;         // replaces VendorLeaf
    UNICODE_STRING      uniGenericName;     // replaces GenericName

} DEVICE_INFORMATION, *PDEVICE_INFORMATION;


typedef struct _FDO_DEVICE_EXTENSION {

    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      LowerDeviceObject;
    ULONG               Type;
    ULONG               DeviceFlags;

    ULONG               MaxClassTransferSize;
    HANDLE              Sbp2ObjectDirectory;
    PDEVICE_OBJECT      Pdo;
    PIRP                SystemPowerIrp;
    DEVICE_POWER_STATE  DevicePowerState;
    SYSTEM_POWER_STATE  SystemPowerState;
    ULONG               NumPDOsStarted;
    KMUTEX              EnableBusResetNotificationMutex;
    ULONG               DeviceListSize;
    KSPIN_LOCK          DeviceListLock;
    DEVICE_INFORMATION  DeviceList[SBP2_MAX_LUNS_PER_NODE];
    CONFIG_ROM          ConfigRom;

    FAST_MUTEX          ResetMutex;
    IO_REMOVE_LOCK      RemoveLock;

#if DBG
    ULONG               ulWorkItemCount;
    ULONG               ulBusResetMutexCount;
#endif

} FDO_DEVICE_EXTENSION, *PFDO_DEVICE_EXTENSION;


typedef struct _ARCP_ORB {

    PASYNC_REQUEST_CONTEXT  AsyncReqCtx;
    ORB_NORMAL_CMD          Orb;

} ARCP_ORB, *PARCP_ORB;


typedef struct _COMMON_BUFFER_DATA {

    ORB_TASK_MNG        TaskOrb;
    ORB_MNG             ManagementOrb;
    LOGIN_RESPONSE      LoginResponse;
    QUERY_LOGIN_RESPONSE QueryLoginResponse;

#if PASSWORD_SUPPORT
    ORB_SET_PASSWORD    PasswordOrb;
#endif

    ARCP_ORB            CmdOrbs[MAX_ORB_LIST_DEPTH];

} COMMON_BUFFER_DATA, *PCOMMON_BUFFER_DATA;


typedef struct _DEVICE_EXTENSION {

    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      LowerDeviceObject;
    ULONG               Type;
    ULONG               DeviceFlags;

    PDEVICE_OBJECT      BusFdo;
    PDEVICE_INFORMATION DeviceInfo;
    ULONG               MaxOrbListDepth;
    KSPIN_LOCK          OrbListSpinLock;

    LIST_ENTRY          PendingOrbList;
    ULONG               OrbListDepth;
    ULONG               CurrentKey;

    STATUS_FIFO_BLOCK   LastStatusBlock;

    PASYNC_REQUEST_CONTEXT  NextContextToFree;
    BOOLEAN                 AppendToNextContextToFree;
    DEVICE_POWER_STATE      DevicePowerState;
    SYSTEM_POWER_STATE      SystemPowerState;

    PIRP                PowerDeferredIrp;
    PIRP                DeferredPowerRequest;
    ULONG               PagingPathCount;
    ULONG               HibernateCount;

    ULONG               CrashDumpCount;
    ULONG               HandleCount;
    PULONG              IdleCounter;
    ULONG               Reserved;

    NTSTATUS            LastTransactionStatus;
    LARGE_INTEGER       DueTime;
    PMDL                ReservedMdl;  // quadlet only requests

    //
    // inquiry Data
    //

    INQUIRYDATA InquiryData;

    //
    // RBC Device Parameters page
    //

    MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE DeviceModeHeaderAndPage;

    //
    // 1394 addresses to node registers
    //

    NODE_ADDRESS InitiatorAddressId;
    ULONG   CurrentGeneration;

    //
    // node and controller capabilities
    //

    ULONG   MaxControllerPhySpeed;
    USHORT  OrbReadPayloadMask;
    USHORT  OrbWritePayloadMask;

    GET_LOCAL_HOST_INFO2 HostControllerInformation;
    GET_LOCAL_HOST_INFO4 HostRoutineAPI;

    //
    // Keep a dummy, task and management ORBs around
    //

    ORB_NORMAL_CMD          Dummy;
    ADDRESS_CONTEXT         DummyContext;

    //
    //
    //

    PCOMMON_BUFFER_DATA     CommonBuffer;
    ADDRESS_CONTEXT         CommonBufferContext;


    PORB_TASK_MNG           TaskOrb;
    ADDRESS_CONTEXT         TaskOrbContext;

    PORB_MNG                ManagementOrb;
    ADDRESS_CONTEXT         ManagementOrbContext;
    KEVENT                  ManagementEvent;

    PLOGIN_RESPONSE         LoginResponse;
    ADDRESS_CONTEXT         LoginRespContext;

    PQUERY_LOGIN_RESPONSE   QueryLoginResponse;
    ADDRESS_CONTEXT         QueryLoginRespContext;

#if PASSWORD_SUPPORT

    PORB_SET_PASSWORD       PasswordOrb;
    ADDRESS_CONTEXT         PasswordOrbContext;

#endif

    ADDRESS_CONTEXT         OrbPoolContext;

    //
    //
    //

    STATUS_FIFO_BLOCK   ManagementOrbStatusBlock;
    ADDRESS_CONTEXT     ManagementOrbStatusContext;

    STATUS_FIFO_BLOCK   TaskOrbStatusBlock;
    ADDRESS_CONTEXT     TaskOrbStatusContext;

    ADDRESS_CONTEXT     GlobalStatusContext;

#if PASSWORD_SUPPORT

    STATUS_FIFO_BLOCK   PasswordOrbStatusBlock;
    ADDRESS_CONTEXT     PasswordOrbStatusContext;
    KEVENT              PasswordEvent;

#endif


    //
    // single list containing status fifos
    //

    SLIST_HEADER StatusFifoListHead;
    KSPIN_LOCK StatusFifoLock;

    //
    // pool with the actuall fifo buffer and address_fifo structs
    //

    PVOID StatusFifoBase;

    SLIST_HEADER FreeContextListHead;

    //
    // look aside for request contexts, and other fixed size requests
    //

    NPAGED_LOOKASIDE_LIST       BusRequestContextPool; // a real lookaside! what a concept...

    SLIST_HEADER BusRequestIrpIrbListHead;
    KSPIN_LOCK  BusRequestLock;

    //
    // this spin locks are never used on advanced x86s or alphas ( other than 486' than cant do 64 atomic exchange)
    //

    KSPIN_LOCK FreeContextLock;

    //
    // The driver keeps a pool of request contexts, and CMD ORBs in its deviceExtension
    // We use to lookaside list for the bus driver Irps, Irp request contexts
    // and the ORB contexts that have pointers to the SRB, etc
    //

    PASYNC_REQUEST_CONTEXT AsyncContextBase;

    //
    // the base va for the pool of orbs is int he reserved field of the address_Context struct
    //

    KSPIN_LOCK  ExtensionDataSpinLock;

    //
    // used to track time outs in resets, reconnects, etc...
    //

    KDPC DeviceManagementTimeoutDpc;
    KTIMER DeviceManagementTimer;

    UNICODE_STRING UniSymLinkName;

    //
    // Tracks the number of outstanding/deferred calls to
    // Sbp2StartNextPacketByKey
    //

    LONG StartNextPacketCount;

    IO_REMOVE_LOCK RemoveLock;

#if DBG
    ULONG           ulPendingEvents;
    ULONG           ulInternalEventCount;
#endif

#if PASSWORD_SUPPORT

    ULONG Exclusive;

#endif

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _REQUEST_CONTEXT {

    PDEVICE_EXTENSION   DeviceExtension;
    KEVENT              Event;
    ULONG               RequestType;
    PIRBIRP             Packet;
    ULONG               Complete;

} REQUEST_CONTEXT, *PREQUEST_CONTEXT;


//
// Useful macros
//

#define octbswap(octlet)                {octlet.u.HighQuad.QuadPart = bswap(octlet.u.HighQuad.QuadPart); \
                                         octlet.u.LowQuad.QuadPart =  bswap(octlet.u.LowQuad.QuadPart); }

#define min(a,b)                        (((a) < (b)) ? (a) : (b))
#define max(a,b)                        (((a) > (b)) ? (a) : (b))

#define RETRIEVE_CONTEXT(pointer,fieldname) \
            CONTAINING_RECORD(pointer,ASYNC_REQUEST_CONTEXT,fieldname)




#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

//
// One status fifo element for every possible outstanding orb, and a few
// more for unsolicited status
//

#define NUM_PREALLOCATED_STATUS_FIFO_ELEMENTS (2*MAX_ORB_LIST_DEPTH)


#define MIN_PAGE_TABLE_ALLOC_SIZE   64


#define SBP2_ENERGY_IDLE_TIMEOUT    60
#define SBP2_PERF_IDLE_TIMEOUT      60


//
// symbolic link stuff
//

#define SBP2_BASE_DEVICE_NAME                        L"\\Device\\Sbp2port"
#define SBP2_BASE_SYMBOLIC_LINK_NAME                 L"\\DosDevices\\Sbp2"
#define SBP2_MAX_SUFFIX_SIZE                         5*sizeof(WCHAR)
#define BASE_SBP2_PNP_ID_DEVICE_NAME                 L"SBP2\\"
#define SBP2_MAX_TEXT_LEAF_LENGTH                    0x100

//
// Device state flags
//

#define DEVICE_FLAG_STOPPED                 0x00000001
#define DEVICE_FLAG_RESET_IN_PROGRESS       0x00000002
#define DEVICE_FLAG_REMOVED                 0x00000004
#define DEVICE_FLAG_LOGIN_IN_PROGRESS       0x00000008
#define DEVICE_FLAG_RECONNECT               0x00000010
#define DEVICE_FLAG_CLAIMED                 0x00000020
#define DEVICE_FLAG_INITIALIZING            0x00000040
#define DEVICE_FLAG_QUEUE_LOCKED            0x00000080
#define DEVICE_FLAG_SPC_CMD_SET             0x00000100
#define DEVICE_FLAG_INITIALIZED             0x00000200
#define DEVICE_FLAG_REMOVE_PENDING          0x00000400
#define DEVICE_FLAG_DEVICE_FAILED           0x00000800
#define DEVICE_FLAG_UNSTARTED_AND_REMOVED   0x00001000
#define DEVICE_FLAG_ABSENT_ON_POWER_UP      0x00002000
#define DEVICE_FLAG_SURPRISE_REMOVED        0x00004000
#define DEVICE_FLAG_PNP_STOPPED             0x00008000
#define DEVICE_FLAG_REPORTED_FAILED         0x00010000


//
// timeout values
//

#define SBP2_LOGIN_TIMEOUT 20 // secs

#define SBP2_RELOGIN_DELAY        (ULONG)(-1*10*1000*1000) // 1s, 100 ns units
#define SBP2_RECONNECT_TIMEOUT    (ULONG)(-2*10*1000*1000) // 2s, 100 ns units
#define SBP2_HARD_RESET_TIMEOUT   (ULONG)(-2*10*1000*1000) // 2s, 100 ns units
#define SBP2_RESET_TIMEOUT        (ULONG)(-2*10*1000*1000) // 2s, 100 ns units
#define SBP2_MAX_REQUEST_DELAY    (ULONG)(-7*10*1000*1000) // 7s, 100 ns units

#if PASSWORD_SUPPORT
#define SBP2_SET_PASSWORD_TIMEOUT (ULONG)(-4*10*1000*1000) // 4s, 100 ns units
#endif

//
// Our pre-allocated page tables must fit in one page of memory (each entry
// is an OCTLET in size).  So, the max xfer size equals the number of table
// entries (minus one, in case 1st entry is not a full page of data) times
// the page size
//

#define SBP2_NUM_PAGE_TABLE_ENTRIES (ULONG) (PAGE_SIZE / sizeof (OCTLET))
#define SBP2_MAX_TRANSFER_SIZE (ULONG) \
                                ((SBP2_NUM_PAGE_TABLE_ENTRIES - 1) * PAGE_SIZE)
#define SBP2_MAX_CDB_SIZE 12

#define SBP2_LOGIN_RETRIES          2
#define SBP2_SYNCHRONOUS_RETRIES    3
#define SBP2_ASYNC_RETRIES          2


//
// Minimum unit directory entries that will make this device a proper SBP-2 device
//

#define SBP2_MIN_UNIT_DIR_ENTRIES   2



//
// Masks used to decode the status block and for setting up the ORB flags
//

#define STATUS_BLOCK_UNSOLICITED_BIT_MASK   0x8000 // bit 15
#define STATUS_BLOCK_ENDOFLIST_BIT_MASK     0x4000 // bit 14
#define STATUS_BLOCK_RESP_MASK              0x3000 // protect bits 12-13 (0-15)
#define STATUS_BLOCK_SBP_STATUS_MASK        0x00FF // protect bits 0-7 (0-15)
#define STATUS_BLOCK_DEAD_BIT_MASK          0x0800 // protect bits 0-7 (0-15)


#define STATUS_BLOCK_LEN_MASK   0x0800  // protect bits 0-7 (0-15)

#define STATUS_BLOCK_SFMT_MASK  0xC0    // protect bits 15,14 of second octlet

#define SBP2_ALIGNMENT_MASK         FILE_LONG_ALIGNMENT


//
// status type , if the SFMT field is 0 or 1
//
#define SENSE_DATA_STATUS_BLOCK         0x00
#define SENSE_DATA_DEFF_STATUS_BLOCK    0x01

//
// Status types
//

#define DUMMY_ORB_STATUS_BLOCK      0x01
#define TASK_STATUS_BLOCK           0x02
#define MANAGEMENT_STATUS_BLOCK     0x04
#define CMD_ORB_STATUS_BLOCK        0x08
#define UNSOLICITED_STATUS_BLOCK    0x10

#if PASSWORD_SUPPORT
#define PASSWORD_STATUS_BLOCK       0x20
#endif

#define ORB_PAGE_TABLE_BIT_MASK     0x0008
#define ORB_DIRECTION_BIT_MASK      0x0800


#define ORB_NOTIFY_BIT_MASK         0x8000
#define ORB_DUMMY_RQ_FMT_VALUE      0x6000
#define ORB_MNG_RQ_FMT_VALUE        0x0000
#define ORB_MNG_EXCLUSIVE_BIT_MASK  0x1000

//
// 1394 transaction layer allowed timeouts
//

#define BUSY_TIMEOUT_SETTING 0x0000000F


//
// Values used to indicate what data structure we are swapping (little->Big->little endian)
//

#define SWAP_LOGIN_RESPONSE_BLOCK   0
#define SWAP_LOGIN_ORB              1
#define SWAP_NORMAL_CMD_ORB         2
#define SWAP_STATUS_BLOCK           3


//
// request types for sending small read/writes to the bus driver
//

#define ASYNC_1394_REQUEST      0x01
#define SYNC_1394_REQUEST       0x02
#define ASYNC_SYNC_1394_REQUEST 0x03

//
// different values for exclusive flag
//
#if PASSWORD_SUPPORT
#define EXCLUSIVE_FLAG_CLEAR        0x00000000  // no password
#define EXCLUSIVE_FLAG_SET          0x00000001  // password is set
#define EXCLUSIVE_FLAG_ENABLE       0x00000002  // password needs to be enabled
#endif

//
// Function definitions
//

VOID
AllocateIrpAndIrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRBIRP *Packet
    );


NTSTATUS
AllocateAddressForStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PADDRESS_CONTEXT Context,
    IN UCHAR StatusType
    );

NTSTATUS
AllocateSingle1394Address(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG AccessType,
    IN OUT PADDRESS_CONTEXT Context
    );


NTSTATUS
CheckStatusResponseValue(
    IN PSTATUS_FIFO_BLOCK Status
    );


VOID
CleanupOrbList(
    PDEVICE_EXTENSION   DeviceExtension,
    NTSTATUS CompletionStatus
    );


BOOLEAN
ConvertSbp2SenseDataToScsi(
    IN PSTATUS_FIFO_BLOCK StatusBlock,
    OUT PVOID SenseBuffer,
    IN ULONG SenseBufferLength
    );

VOID
Create1394TransactionForSrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PASYNC_REQUEST_CONTEXT *Context
    );


VOID
DeAllocateIrpAndIrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRBIRP Packet
    );

VOID
Free1394DataMapping(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT Context
    );

VOID
FreeAddressRange(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PADDRESS_CONTEXT Context
    );

ULONG
FreeAsyncRequestContext(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT Context
    );

NTSTATUS
Sbp2_SCSI_RBC_Conversion(
    IN PASYNC_REQUEST_CONTEXT Context
    );

NTSTATUS
Sbp2AccessRegister(
    PDEVICE_EXTENSION DeviceExtension,
    PVOID Data,
    USHORT Register
    );

NTSTATUS
Sbp2BusMapTransfer(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT CallbackContext
    );

void
Sbp2BusResetNotification(
    PFDO_DEVICE_EXTENSION   FdoExtension
    );

BOOLEAN
Sbp2CleanDeviceExtension(
    IN PDEVICE_OBJECT DeviceObject,
    BOOLEAN DeviceRemoved
);


VOID
Sbp2ConvertScsiToReducedCommandSet(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
Sbp2AllocComplete(
    IN PASYNC_REQUEST_CONTEXT CallbackContext
    );


VOID
Sbp2CreateRequestErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN PASYNC_REQUEST_CONTEXT Context,
    IN NTSTATUS Status
    );

VOID
Sbp2DeferPendingRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
Sbp2DeviceManagementTimeoutDpc(
    IN PKDPC Dpc,
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
Sbp2Get1394ConfigInfo(
    PFDO_DEVICE_EXTENSION DeviceExtension,
    PSBP2_REQUEST Sbp2Req
    );

RCODE
Sbp2GlobalStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    );

NTSTATUS
Sbp2GetControllerInfo(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
Sbp2HandleApiRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
Sbp2HandleRemove(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
Sbp2HandleUnsolicited(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSTATUS_FIFO_BLOCK StatusFifo
    );

NTSTATUS
Sbp2IssueInternalCommand(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN UCHAR Scsiop
    );


NTSTATUS
Sbp2InitializeDeviceExtension(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
Sbp2InitializeOrb(
    IN PDEVICE_EXTENSION DeviceExtendion,
    PASYNC_REQUEST_CONTEXT CallbackContext
    );

VOID
Sbp2InsertTailList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PASYNC_REQUEST_CONTEXT Context
    );

NTSTATUS
Sbp2Issue1394BusReset (
    IN PDEVICE_EXTENSION DeviceExtension
    );


NTSTATUS
Sbp2ManagementTransaction(
    IN PDEVICE_EXTENSION DeviceExtension,
    ULONG Type
    );

#if PASSWORD_SUPPORT

NTSTATUS
Sbp2SetPasswordTransaction(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN ULONG                Type
    );

RCODE
Sbp2SetPasswordOrbStatusCallback(
    IN PNOTIFICATION_INFO   NotificationInfo
    );

#endif

RCODE
Sbp2ManagementOrbStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    );

VOID
Sbp2ParseTextLeaf(
    PFDO_DEVICE_EXTENSION DeviceExtension,
    PVOID UnitDepDir,
    PIO_ADDRESS ModelLeafLocation,
    PVOID *ModelLeaf
    );

NTSTATUS
Sbp2PreAllocateLists(
    IN PDEVICE_EXTENSION DeviceExtension
    );


NTSTATUS
Sbp2QueryProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    );

VOID
Sbp2RequestTimeoutDpc(
    IN PKDPC Dpc,
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
Sbp2Reset(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN Cleanup
);

NTSTATUS
Sbp2RequestCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PREQUEST_CONTEXT Context
    );

VOID
Sbp2PdoDIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
Sbp2ScsiRequests
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
Sbp2StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



NTSTATUS
Sbp2SendRequest(
    PDEVICE_EXTENSION DeviceExtension,
    PIRBIRP Packet,
    ULONG TransferMode
    );

RCODE
Sbp2TaskOrbStatusCallback(
    IN PNOTIFICATION_INFO NotificationInfo
    );


NTSTATUS
Sbp2UpdateNodeInformation(
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
Sbp2FdoSIrpCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Unused
    );

VOID
Sbp2FdoDIrpCompletion(
    IN PDEVICE_OBJECT           TargetDeviceObject,
    IN UCHAR                    MinorFunction,
    IN POWER_STATE              PowerState,
    IN PFDO_DEVICE_EXTENSION    FdoExtension,
    IN PIO_STATUS_BLOCK         IoStatus
    );

BOOLEAN
Sbp2EnableBusResetNotification(
    PDEVICE_EXTENSION   DeviceExtension,
    BOOLEAN             Enable
    );

VOID
Sbp2LoginCompletion(
    PNOTIFICATION_INFO  NotificationInfo,
    NTSTATUS            Status
    );

VOID
Sbp2StartNextPacketByKey(
    IN PDEVICE_OBJECT   DeviceObject,
    IN ULONG            Key
    );

VOID
Sbp2StartPacket(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PULONG           Key OPTIONAL
    );

PKDEVICE_QUEUE_ENTRY
Sbp2RemoveByKeyDeviceQueueIfBusy (
    IN PKDEVICE_QUEUE   DeviceQueue,
    IN ULONG            SortKey
    );

BOOLEAN
Sbp2InsertByKeyDeviceQueue(
    PKDEVICE_QUEUE          DeviceQueue,
    PKDEVICE_QUEUE_ENTRY    DeviceQueueEntry,
    ULONG                   SortKey
    );

NTSTATUS
Sbp2GetExclusiveValue(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    OUT PULONG          Exclusive
    );

NTSTATUS
Sbp2SetExclusiveValue(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PULONG           Exclusive
    );

void
Sbp2BusResetNotificationWorker(
    PDEVICE_OBJECT      DeviceObject,
    PIO_WORKITEM        WorkItem
    );

//
// sbp2scsi.c
//
NTSTATUS
Sbp2_ScsiPassThrough(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          Direct
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\control.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    control.c

Abstract:

    This module contains support routines for the port driver to access 
    the miniport's HwAdapterControl functionality.

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpGetSupportedAdapterControlFunctions)
#endif

#define SIZEOF_CONTROL_TYPE_LIST (sizeof(SCSI_SUPPORTED_CONTROL_TYPE_LIST) +\
                                  sizeof(BOOLEAN) * (ScsiAdapterControlMax + 1))

VOID
SpGetSupportedAdapterControlFunctions(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will query the miniport to determine which adapter control 
    types are supported for the specified adapter.  The 
    SupportedAdapterControlBitmap in the adapter extension will be updated with
    the data returned by the miniport.  These flags are used to determine 
    what functionality (for power management and such) the miniport will 
    support.
    
Arguments:    

    Adapter - the adapter to query
    
Return Value:

    none
    
--*/        

{
    UCHAR buffer[SIZEOF_CONTROL_TYPE_LIST]; 
    SCSI_ADAPTER_CONTROL_STATUS status;

    PSCSI_SUPPORTED_CONTROL_TYPE_LIST typeList = 
        (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) &buffer[0];

    PAGED_CODE();

    //
    // Must initialize the bitmap header before using it.
    //

    RtlInitializeBitMap(&(Adapter->SupportedControlBitMap), 
                        Adapter->SupportedControlBits,
                        ScsiAdapterControlMax);

    //
    // Zero all the bits in the bitmap.
    //

    RtlClearAllBits(&(Adapter->SupportedControlBitMap));

    //
    // If the miniport does not support the adapter control function or if the
    // adapter is not PNP, the array has already been cleared so we can quit.
    //

    if ((Adapter->HwAdapterControl == NULL) || (Adapter->IsPnp == FALSE)) {
        return;
    }

    //
    // Zero the list of supported control types.
    //

    RtlZeroMemory(typeList, SIZEOF_CONTROL_TYPE_LIST); 

    //
    // Initialize the max control type to signal the end of the array.
    //

    typeList->MaxControlType = ScsiAdapterControlMax;

#if DBG
    typeList->SupportedTypeList[ScsiAdapterControlMax] = 0x63;
#endif

    //
    // Call into the miniport to get the list of supported control types.
    //

    status = Adapter->HwAdapterControl(Adapter->HwDeviceExtension,
                                       ScsiQuerySupportedControlTypes,
                                       typeList);

    //
    // If the call into the miniport succeeded, walk the list of supported
    // types and for each type supported by the miniport, set the associated
    // bit in the bitmap.
    //

    if (status == ScsiAdapterControlSuccess) {

        ULONG i;

        ASSERT(typeList->SupportedTypeList[ScsiAdapterControlMax] == 0x63);

        for (i = 0; i < ScsiAdapterControlMax; i++) {
            if (typeList->SupportedTypeList[i] == TRUE) {
                RtlSetBits(&(Adapter->SupportedControlBitMap), i, 1);
            }
        }
    }

    return;
}


BOOLEAN
SpIsAdapterControlTypeSupported(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType
    )
{
    return RtlAreBitsSet(&(AdapterExtension->SupportedControlBitMap),
                         ControlType,
                         1);
}


SCSI_ADAPTER_CONTROL_STATUS 
SpCallAdapterControl(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
{
    ASSERT(TEST_FLAG(AdapterExtension->InterruptData.InterruptFlags, 
                     PD_ADAPTER_REMOVED) == FALSE);

    ASSERT(SpIsAdapterControlTypeSupported(AdapterExtension, ControlType));    

    return AdapterExtension->HwAdapterControl(
                AdapterExtension->HwDeviceExtension,
                ControlType,
                Parameters);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\enable.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    power.c

Abstract:

    This module contains the routines for port driver power support

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

#define __FILE_ID__ 'enab'

typedef struct _REINIT_CONTEXT {
    IN PADAPTER_EXTENSION Adapter;
    IN BOOLEAN UseAdapterControl;
    OUT NTSTATUS Status;
} REINIT_CONTEXT, *PREINIT_CONTEXT;

NTSTATUS
SpReinitializeAdapter(
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpReinitializeAdapterSynchronized(
    IN PREINIT_CONTEXT Context
    );

NTSTATUS
SpShutdownAdapter(
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpShutdownAdapterSynchronized(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpEnableDisableCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


NTSTATUS
SpEnableDisableAdapter(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine will synchronously enable or disable the specified adapter.
    It should be called from the adapter's StartIo routine when a power
    irp is processed for the controller.

    When the adapter is disabled the state of the adapter will be saved and
    the miniport will be shut-down.  When the adapter is re-enabled the
    miniport will be reinitialized.

Arguments:

    Adapter - the adapter to be [en|dis]abled.
    Enable - whether to enable or disable the adapter.

Return Value:

    status of the adapter enable/disable action.

--*/

{
    ULONG count;
    KIRQL oldIrql;

    NTSTATUS status = STATUS_SUCCESS;

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

    DebugPrint((1, "SpEnableDisableAdapter: Adapter %#p %s\n",
                Adapter, Enable ? "enable":"disable"));

    if(Enable) {
        count = --Adapter->DisableCount;

        DebugPrint((1, "SpEnableDisableAdapter: DisableCount is %d\n",
                       count));

        if(count == 0) {

            //
            // Re-initialize the adapter.
            //

            status = SpReinitializeAdapter(Adapter);
        }

    } else {

        count = Adapter->DisableCount++;

        DebugPrint((1, "SpEnableDisableAdapter: DisableCount was %d\n",
                    count));

        if(count == 0) {

            //
            // Shut-down the adapter.
            //

            status = SpShutdownAdapter(Adapter);
        }
    }

    KeLowerIrql(oldIrql);
    return status;
}


NTSTATUS
SpEnableDisableLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Enable,
    IN PSP_ENABLE_DISABLE_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine will enable the specified logical unit.  An unlock queue
    request will be issued to the logical unit - if the lock count drops
    to zero then the device will be re-enabled and i/o processing can be
    restarted.

    If STATUS_PENDING is returned then the completion routine will be run
    when the unlock has been processed.  The routine will be called with
    the status of the unlock request (note that STATUS_SUCCESS does not
    necessarily indicate that the device is ready for use - just that the
    lock count has been decremented) and the specified context.

Arguments:

    LogicalUnit - the logical unit to be enabled.

    Enable - whether the routine should enable or disable the logical unit

    CompletionRoutine - the completion routine to be run when the unlock
                        request has succeeded.

    Context - arbitrary context value/pointer which will be passed into the
              enable completion routine.

Return Value:

    STATUS_PENDING if the request to send an unlock succeeds and the
                   completion routine will be called.

    error if the attempt to send the irp fails.  In this case the completion
          routine will not be called.

--*/

{
    USHORT srbSize;
    USHORT size;

    PIRP irp;
    PSCSI_REQUEST_BLOCK srb;
    PIO_STACK_LOCATION nextStack;

    NTSTATUS status;

    DebugPrint((4, "SpEnableDisableLun: Lun %#p %s context %#p\n",
                LogicalUnit, Enable ? "enable":"disable", Context));

    srbSize = sizeof(SCSI_REQUEST_BLOCK);
    srbSize += sizeof(ULONG) - 1;
    srbSize &= ~(sizeof(ULONG) - 1);

    size = srbSize + IoSizeOfIrp(LogicalUnit->DeviceObject->StackSize + 1);

    srb = SpAllocatePool(NonPagedPool,
                         size,
                         SCSIPORT_TAG_ENABLE,
                         LogicalUnit->DeviceObject->DriverObject);

    if(srb == NULL) {

        //
        // Already failed.  Call the completion routine will the failure status
        // and let it clean up the request.
        //

        DebugPrint((1, "SpEnableDisableLogicalUnit: failed to allocate SRB\n"));

        if(CompletionRoutine != NULL) {
            CompletionRoutine(LogicalUnit->DeviceObject,
                              STATUS_INSUFFICIENT_RESOURCES,
                              Context);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp = (PIRP) (srb + 1);

    IoInitializeIrp(irp,
                    (USHORT) (size - srbSize),
                    (CCHAR)(LogicalUnit->DeviceObject->StackSize + 1));

    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->Parameters.Others.Argument1 = LogicalUnit->DeviceObject;
    nextStack->Parameters.Others.Argument2 = CompletionRoutine;
    nextStack->Parameters.Others.Argument3 = Context;
    nextStack->Parameters.Others.Argument4 = 0;     // retry count

    IoSetNextIrpStackLocation(irp);

    IoSetCompletionRoutine(irp,
                           SpEnableDisableCompletionRoutine,
                           srb,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_SCSI;
    nextStack->MinorFunction = 1;

    nextStack->Parameters.Scsi.Srb = srb;

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->OriginalRequest = irp;

    srb->SrbFlags = SRB_FLAGS_BYPASS_LOCKED_QUEUE;

    srb->Function = Enable ? SRB_FUNCTION_UNLOCK_QUEUE :
                             SRB_FUNCTION_LOCK_QUEUE;

    status = IoCallDriver(LogicalUnit->DeviceObject, irp);

    return status;
}


NTSTATUS
SpEnableDisableCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PIO_STACK_LOCATION irpStack;
    PSP_ENABLE_DISABLE_COMPLETION_ROUTINE routine;
    PVOID context;
    NTSTATUS status;

    DebugPrint((4, "SpEnableDisableCompletionRoutine: irp %#p completed "
                   "with status %#08lx\n",
                Irp, Irp->IoStatus.Status));

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    routine = irpStack->Parameters.Others.Argument2;
    context = irpStack->Parameters.Others.Argument3;

    DeviceObject = irpStack->Parameters.Others.Argument1;

    status = Irp->IoStatus.Status;

    //
    // Free the srb which will also release the irp.
    //

    ExFreePool(Srb);

    if(routine != NULL) {
        routine(DeviceObject, status, context);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SpReinitializeAdapter(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will allow the miniport to restore any state or configuration
    information and then to restart it's adapter.  Adapter interrupts will
    be re-enabled at the return of this routine and scsiport may begin issuing
    new requests to the miniport.

Arguments:

    Adapter - the adapter to be re-initialized.

Return Value:

    status

--*/

{
    ULONG oldDebug;

    KIRQL oldIrql;

    ULONG result;
    BOOLEAN again;

    BOOLEAN useAdapterControl;

    NTSTATUS status;

    UCHAR string[] = {'W', 'A', 'K', 'E', 'U', 'P', '\0'};

    //
    // Give the miniport a chance to restore it's bus-data to a state which
    // allows the miniport to operate.
    //

    if(SpIsAdapterControlTypeSupported(Adapter, ScsiRestartAdapter) == TRUE) {
        DebugPrint((1, "SpReinitializeAdapter: using AdapterControl\n"));
        useAdapterControl = TRUE;
    } else {
        DebugPrint((1, "SpReinitializeAdapter: using init routines\n"));
        useAdapterControl = FALSE;
    }

    oldIrql = KeRaiseIrqlToDpcLevel();

    KeAcquireSpinLockAtDpcLevel(&(Adapter->SpinLock));

    //
    // Since we may be reinitializing the miniport at DISPATCH_LEVEL we need
    // to set the miniport reinitializing flag for some of the SCSIPORT api's
    // to modify their behavior.
    //

    SET_FLAG(Adapter->Flags, PD_MINIPORT_REINITIALIZING);

    result = SP_RETURN_FOUND;

    if(useAdapterControl == FALSE) {

        result = Adapter->HwFindAdapter(Adapter->HwDeviceExtension,
                                        NULL,
                                        NULL,
                                        string,
                                        Adapter->PortConfig,
                                        &again);
    } else if(SpIsAdapterControlTypeSupported(Adapter,
                                             ScsiSetRunningConfig) == TRUE) {
        SCSI_ADAPTER_CONTROL_STATUS b;

        b = SpCallAdapterControl(Adapter, ScsiSetRunningConfig, NULL);

        ASSERT(b == ScsiAdapterControlSuccess);

    }

    if(result == SP_RETURN_FOUND) {

        REINIT_CONTEXT context;

        context.Adapter = Adapter;
        context.UseAdapterControl = useAdapterControl;

        Adapter->SynchronizeExecution(Adapter->InterruptObject,
                                      SpReinitializeAdapterSynchronized,
                                      &context);

        status = context.Status;
    } else {
        status = STATUS_DRIVER_INTERNAL_ERROR;
    }

    if(NT_SUCCESS(status)) {

        //
        // We had better be ready for another request by now.
        //

        ScsiPortNotification(NextRequest,
                             Adapter->HwDeviceExtension);

        if (Adapter->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

            //
            // Request a completion DPC so that we clear out any existing
            // attempts to do things like reset the bus.
            //

            SpRequestCompletionDpc(Adapter->DeviceObject);
        }
    }

    KeReleaseSpinLockFromDpcLevel(&(Adapter->SpinLock));

    ASSERT(NT_SUCCESS(status));

    KeLowerIrql(oldIrql);

    return status;
}


BOOLEAN
SpReinitializeAdapterSynchronized(
    IN PREINIT_CONTEXT Context
    )
{
    PADAPTER_EXTENSION adapter = Context->Adapter;
    BOOLEAN result;

    DebugPrint((1, "SpReinitializeAdapterSynchronized: calling "
                   "HwFindAdapter\n"));

    if(Context->UseAdapterControl) {
        SCSI_ADAPTER_CONTROL_TYPE status;

        status = SpCallAdapterControl(adapter, ScsiRestartAdapter, NULL);
        result = (status == ScsiAdapterControlSuccess);

    } else {
        result = adapter->HwInitialize(adapter->HwDeviceExtension);
    }

    if(result == TRUE) {
        Context->Status = STATUS_SUCCESS;
    } else {
        Context->Status = STATUS_ADAPTER_HARDWARE_ERROR;
    }

    DebugPrint((1, "SpReinitializeAdapterSynchronized: enabling interrupts\n"));

    adapter->InterruptData.InterruptFlags &= ~PD_DISABLE_INTERRUPTS;

    CLEAR_FLAG(adapter->Flags, PD_MINIPORT_REINITIALIZING);
    CLEAR_FLAG(adapter->Flags, PD_UNCACHED_EXTENSION_RETURNED);

    return TRUE;
}


NTSTATUS
SpShutdownAdapter(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will shutdown the miniport and save away any state information
    necessary to restart it.  Adapter interrupts will be disabled at the
    return of this routine - scsiport will not issue any new requests to the
    miniport until it has been reinitialized.

Arguments:

    Adapter - the adapter to be shut down.

Return Value:

    status

--*/

{
    //
    // Acquire the adapter spinlock and set state to indicate that a 
    // shutdown is in progress.  This will prevent us from starting
    // operations that shouldn't be started while shutting down.
    //

    KeAcquireSpinLockAtDpcLevel(&Adapter->SpinLock);
    SET_FLAG(Adapter->Flags, PD_SHUTDOWN_IN_PROGRESS);
    KeReleaseSpinLockFromDpcLevel(&Adapter->SpinLock);

    //
    // Cancel the miniport timer so that we don't call into it after we've 
    // shut down.
    //

    KeCancelTimer(&(Adapter->MiniPortTimer));

    //
    // Currently we don't give the miniport any chance to save any sort of
    // state information.  We just stop any i/o going into it and then do
    // a shutdown.
    //

    Adapter->SynchronizeExecution(Adapter->InterruptObject,
                                  SpShutdownAdapterSynchronized,
                                  Adapter);

    if(SpIsAdapterControlTypeSupported(Adapter, ScsiSetBootConfig))  {

        //
        // Allow the miniport a chance to reset its PCI bus data before we
        // power it off.
        //

        SpCallAdapterControl(Adapter, ScsiSetBootConfig, NULL);
    }

    return STATUS_SUCCESS;
}


BOOLEAN
SpShutdownAdapterSynchronized(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine performs the ISR synchronized part of shutting down the
    miniport.  This includes disabling the interrupt and request a shutdown
    of the miniport.

Arguments:

    Adapter - the adapter to shut down.

Return Value:

    TRUE

--*/

{
    SpCallAdapterControl(Adapter, ScsiStopAdapter, NULL);
    DebugPrint((1, "SpShutdownAdapterSynchronized: Disabling interrupts\n"));
    Adapter->InterruptData.InterruptFlags |= PD_DISABLE_INTERRUPTS;
    CLEAR_FLAG(Adapter->Flags, PD_SHUTDOWN_IN_PROGRESS);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\enum.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    enum.c

Abstract:

    This module contains device enumeration code for the scsi port driver

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

#define __FILE_ID__ 'enum'

ULONG EnumDebug = 2;

#if DBG
static const char *__file__ = __FILE__;
#endif

#define MINIMUM_BUS_SCAN_INTERVAL ((ULONGLONG) (30 * SECONDS))

ULONG BreakOnTarget = (ULONG) -1;
ULONG BreakOnScan = TRUE;

ULONG BreakOnMissingLun = FALSE;

typedef struct {
    UCHAR LunListLength[4]; // sizeof LunSize * 8
    UCHAR Reserved[4];
    UCHAR Luns[16][8];
} SP_DEFAULT_LUN_LIST;

SP_DEFAULT_LUN_LIST ScsiPortDefaultLunList = {
    {0, 0, 0, sizeof(ScsiPortDefaultLunList.Luns)}, // LunListLength
    {0, 0, 0, 0},                                   // Reserved
    {{ 0, 0, 0, 0, 0, 0, 0, 0},                     // Luns
     { 0, 1, 0, 0, 0, 0, 0, 0},
     { 0, 2, 0, 0, 0, 0, 0, 0},
     { 0, 3, 0, 0, 0, 0, 0, 0},
     { 0, 4, 0, 0, 0, 0, 0, 0},
     { 0, 5, 0, 0, 0, 0, 0, 0},
     { 0, 6, 0, 0, 0, 0, 0, 0},
     { 0, 7, 0, 0, 0, 0, 0, 0}}};

NTSTATUS
SpInquireLogicalUnit(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN OPTIONAL PLOGICAL_UNIT_EXTENSION RescanLun,
    OUT PLOGICAL_UNIT_EXTENSION *LogicalUnit,
    OUT PBOOLEAN CheckNextLun
    );

VOID
SpSignalEnumerationCompletion (
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN NTSTATUS Status
    );

BOOLEAN
SpRemoveLogicalUnitFromBinSynchronized(
    IN PVOID ServiceContext                 // PLOGICAL_UNIT_EXTENSION
    );

BOOLEAN
SpAddLogicalUnitToBinSynchronized(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension
    );

ULONG
SpCountLogicalUnits(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
IssueReportLuns(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    OUT PLUN_LIST *LunList
    );

PLUN_LIST
AdjustReportLuns(
    IN PDRIVER_OBJECT DriverObject,
    IN PLUN_LIST RawList
    );

VOID
SpScanAdapter(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpScanBus(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN PLOGICAL_UNIT_EXTENSION RescanLun
    );

NTSTATUS
SpScanTarget(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN PLOGICAL_UNIT_EXTENSION RescanLun
    );

NTSTATUS
IssueInquiry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN EnableVitalProductData,
    IN UCHAR PageCode,
    OUT PVOID InquiryData,
    OUT PUCHAR BytesReturned
    );

VOID
SpSetVerificationMarks(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId
    );

VOID
SpClearVerificationMark(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpPurgeTarget(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId
    );

NTSTATUS
SpCloneAndSwapLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PINQUIRYDATA InquiryData,
    IN ULONG InquiryDataSize,
    OUT PLOGICAL_UNIT_EXTENSION *NewLun
    );

VOID
SpSetLogicalUnitAddress(
    IN PLOGICAL_UNIT_EXTENSION RescanLun,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    );

VOID
SpClearLogicalUnitAddress(
    IN PLOGICAL_UNIT_EXTENSION RescanLun
    );

NTSTATUS
SpPrepareLogicalUnitForReuse(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

NTSTATUS
SpCreateLogicalUnit(
    IN PADAPTER_EXTENSION Adapter,
    IN OPTIONAL UCHAR PathId,
    IN OPTIONAL UCHAR TargetId,
    IN OPTIONAL UCHAR Lun,
    IN BOOLEAN Temporary,
    IN BOOLEAN Scsi1,
    OUT PLOGICAL_UNIT_EXTENSION *NewLun
    );

NTSTATUS
SpSendSrbSynchronous(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OPTIONAL PIRP Irp,
    IN OPTIONAL PMDL Mdl,
    IN PVOID DataBuffer,
    IN ULONG TransferLength,
    IN PVOID SenseInfoBuffer,
    IN UCHAR SenseInfoBufferLength,
    OUT PULONG BytesReturned
    );

BOOLEAN
SpGetDeviceIdentifiers(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN NewDevice
    );

BOOLEAN
FASTCALL
SpCompareInquiryData(
    IN PUCHAR InquiryData1,
    IN PUCHAR InquiryData2
    );

PLOGICAL_UNIT_EXTENSION
SpCreateInitiatorLU(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpEnumerateAdapterSynchronous)
#pragma alloc_text(PAGE, SpEnumerateAdapterAsynchronous)
#pragma alloc_text(PAGE, SpSignalEnumerationCompletion)
#pragma alloc_text(PAGE, SpEnumerationWorker)

#pragma alloc_text(PAGE, SpScanAdapter)
#pragma alloc_text(PAGE, SpScanBus)
#pragma alloc_text(PAGE, SpScanTarget)
#pragma alloc_text(PAGE, SpCreateInitiatorLU)

#pragma alloc_text(PAGE, SpCompareInquiryData)
#pragma alloc_text(PAGE, SpInquireLogicalUnit)
#pragma alloc_text(PAGE, SpExtractDeviceRelations)

#pragma alloc_text(PAGELOCK, SpCountLogicalUnits)
#pragma alloc_text(PAGELOCK, GetNextLuRequestWithoutLock)
#pragma alloc_text(PAGELOCK, IssueReportLuns)

#pragma alloc_text(PAGELOCK, SpSetVerificationMarks)
#pragma alloc_text(PAGELOCK, SpPurgeTarget)

#pragma alloc_text(PAGE, SpClearVerificationMark)

#pragma alloc_text(PAGE, SpGetInquiryData)
#pragma alloc_text(PAGE, IssueInquiry)

#pragma alloc_text(PAGE, AdjustReportLuns)

#pragma alloc_text(PAGE, SpCreateLogicalUnit)
#pragma alloc_text(PAGE, SpCloneAndSwapLogicalUnit)
#pragma alloc_text(PAGE, SpSetLogicalUnitAddress)
#pragma alloc_text(PAGE, SpClearLogicalUnitAddress)
#pragma alloc_text(PAGE, SpPrepareLogicalUnitForReuse)

#pragma alloc_text(PAGE, SpGetDeviceIdentifiers)

LONG SpPAGELOCKLockCount = 0;
#endif


NTSTATUS
SpExtractDeviceRelations(
    PADAPTER_EXTENSION Adapter,
    DEVICE_RELATION_TYPE RelationType,
    PDEVICE_RELATIONS *DeviceRelations
    )

/*++

Routine Description:

    This routine will allocate a device relations structure and fill in the
    count and object array with referenced object pointers

Arguments:

    Adapter - the adapter to extract relations from.

    RelationType - what type of relationship is being retrieved

    DeviceRelations - a place to store the relationships

--*/

{
    PDEVICE_OBJECT fdo = Adapter->DeviceObject;
    ULONG count = 0;

    ULONG relationsSize;
    PDEVICE_RELATIONS deviceRelations = NULL;

    UCHAR bus, target, lun;
    PLOGICAL_UNIT_EXTENSION luExtension;

    ULONG i;

    NTSTATUS status;

    PAGED_CODE();

    status = KeWaitForMutexObject(
                &(Adapter->EnumerationDeviceMutex),
                Executive,
                KernelMode,
                FALSE,
                NULL);

    if(status == STATUS_USER_APC) {
        status = STATUS_REQUEST_ABORTED;
    }

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Find out how many devices there are
    //

    for(bus = 0; bus < Adapter->NumberOfBuses; bus++) {
        for(target = 0; target < Adapter->MaximumTargetIds; target++) {
            for(lun = 0; lun < SCSI_MAXIMUM_LUNS_PER_TARGET; lun++) {

                luExtension = GetLogicalUnitExtension(
                                Adapter,
                                bus,
                                target,
                                lun,
                                FALSE,
                                TRUE);

                if(luExtension == NULL) {
                    continue;
                }

                //
                // Temporary luns only exist while the bus scanning code is
                // holding the device lock.  we've got it now so we should
                // never find one.
                //

                ASSERT(luExtension->IsTemporary == FALSE);

                if(luExtension->IsMissing) {
                    continue;
                }

                if(luExtension->IsVisible == FALSE) {
                    continue;
                }

                if(luExtension->CommonExtension.IsRemoved >= REMOVE_COMPLETE) {
                    ASSERT(FALSE);
                    continue;
                }

                count++;
            }
        }
    }

    //
    // Allocate the structure
    //

    relationsSize = sizeof(DEVICE_RELATIONS) + (count * sizeof(PDEVICE_OBJECT));

    deviceRelations = SpAllocatePool(PagedPool,
                                     relationsSize,
                                     SCSIPORT_TAG_DEVICE_RELATIONS,
                                     fdo->DriverObject);

    if(deviceRelations == NULL) {

        DebugPrint((1, "SpExtractDeviceRelations: unable to allocate "
                       "%d bytes for device relations\n", relationsSize));

        KeReleaseMutex(&(Adapter->EnumerationDeviceMutex), FALSE);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(deviceRelations, relationsSize);

    i = 0;

    for(bus = 0; bus < Adapter->NumberOfBuses; bus++) {
        for(target = 0; target < Adapter->MaximumTargetIds; target++) {
            for(lun = 0; lun < SCSI_MAXIMUM_LUNS_PER_TARGET; lun++) {

                luExtension = GetLogicalUnitExtension(
                                Adapter,
                                bus,
                                target,
                                lun,
                                FALSE,
                                TRUE);

                if(luExtension == NULL) {

                    continue;

                }

                //
                // Temporary luns only exist while the bus scanning code is
                // holding the device lock.  we've got it now so we should
                // never find one.
                //

                ASSERT(luExtension->IsTemporary == FALSE);

                if(luExtension->IsMissing) {

                    DebugPrint((1, "SpExtractDeviceRelations: PDO %p logical unit "
                                   "(%d,%d,%d) is missing and will not be "
                                   "returned\n",
                                luExtension->DeviceObject, bus, target, lun));

                    luExtension->IsEnumerated = FALSE;
                    continue;

                } else if(luExtension->CommonExtension.IsRemoved >= REMOVE_COMPLETE) {

                    ASSERT(FALSE);
                    luExtension->IsEnumerated = FALSE;
                    continue;

                } else if(luExtension->IsVisible == FALSE) {
                    luExtension->IsEnumerated = FALSE;
                    continue;
                }

                status = ObReferenceObjectByPointer(
                            luExtension->CommonExtension.DeviceObject,
                            0,
                            NULL,
                            KernelMode);

                if(!NT_SUCCESS(status)) {

                    DebugPrint((1, "SpFdoExtractDeviceRelations: status %#08lx "
                                   "while referenceing object %#p\n",
                                   status,
                                   deviceRelations->Objects[i]));
                    continue;
                }

                deviceRelations->Objects[i] =
                    luExtension->CommonExtension.DeviceObject;

                i++;
                luExtension->IsEnumerated = TRUE;
            }
        }
    }

    deviceRelations->Count = i;
    *DeviceRelations = deviceRelations;

    KeReleaseMutex(&(Adapter->EnumerationDeviceMutex), FALSE);

    return STATUS_SUCCESS;
}


NTSTATUS
IssueReportLuns(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    OUT PLUN_LIST *LunList
    )

/*++

Routine Description:

    Build IRP, SRB and CDB for SCSI REPORT LUNS command.

Arguments:

    LogicalUnit - address of target's device object extension.
    LunList - address of buffer for LUN_LIST information.

Return Value:

    NTSTATUS

--*/

{
    PMDL mdl;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    SCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    KEVENT event;
    KIRQL currentIrql;
    PLUN_LIST lunListDataBuffer;
    PSENSE_DATA senseInfoBuffer = NULL;
    NTSTATUS status;
    ULONG retryCount = 0;
    ULONG lunListSize;
    ULONG i;

    PAGED_CODE();

#if 0
    if ((LogicalUnit->InquiryData.Versions & 7) < 3) {

        //
        // make sure the device supports scsi3 commands
        // without this check, we may hang some scsi2 devices
        //

        return STATUS_INVALID_DEVICE_REQUEST;
    }
#endif

    //
    // start with the minilun of 16 byte for the lun list
    //
    lunListSize = 16;

    status = STATUS_INVALID_DEVICE_REQUEST;

    senseInfoBuffer = LogicalUnit->AdapterExtension->InquirySenseBuffer;
    irp = LogicalUnit->AdapterExtension->InquiryIrp;
    mdl = NULL;

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);

    //
    // This is a two pass operation - for the first pass we just try to figure
    // out how large the list should be.  On the second pass we'll actually
    // reallocate the buffer and try to get the entire lun list.
    //
    // NOTE - we may want to set an arbitrary limit here so we don't soak up all 
    // of non-paged pool when some device hands us back a buffer filled 
    // with 0xff.
    //

    for (i=0; i<2; i++) {

        //
        // Allocate a cache aligned LUN_LIST structure.
        //

        lunListDataBuffer = SpAllocatePool(
                                NonPagedPoolCacheAligned,
                                lunListSize,
                                SCSIPORT_TAG_REPORT_LUNS,
                                LogicalUnit->DeviceObject->DriverObject);

        if (lunListDataBuffer == NULL) {

            DebugPrint((1,"IssueReportLuns: Can't allocate report luns data buffer\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        mdl = SpAllocateMdl(lunListDataBuffer,
                            lunListSize,
                            FALSE,
                            FALSE,
                            NULL,
                            LogicalUnit->DeviceObject->DriverObject);

        if(mdl == NULL) {
            DebugPrint((1,"IssueReportLuns: Can't allocate data buffer MDL\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;

        }

        MmBuildMdlForNonPagedPool(mdl);

        //
        // number of retry
        //
        retryCount = 3;
        while (retryCount--) {

            //
            // Build IRP for this request.
            //

            IoInitializeIrp(irp,
                            IoSizeOfIrp(INQUIRY_STACK_LOCATIONS),
                            INQUIRY_STACK_LOCATIONS);

            irp->MdlAddress = mdl;

            irpStack = IoGetNextIrpStackLocation(irp);

            //
            // Fill in SRB fields.
            //

            RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

            //
            // Mark the minor function to indicate that this is an internal scsiport
            // request and that the start state of the device can be ignored.
            //

            irpStack->MajorFunction = IRP_MJ_SCSI;
            irpStack->MinorFunction = 1;

            irpStack->Parameters.Scsi.Srb = &srb;

            IoSetCompletionRoutine(irp,
                                   SpSignalCompletion,
                                   &event,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            srb.PathId = LogicalUnit->PathId;
            srb.TargetId = LogicalUnit->TargetId;
            srb.Lun = LogicalUnit->Lun;

            srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
            srb.Length = sizeof(SCSI_REQUEST_BLOCK);

            //
            // Set flags to disable synchronous negociation.
            //

            srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

            srb.SrbStatus = srb.ScsiStatus = 0;

            srb.NextSrb = 0;

            srb.OriginalRequest = irp;

            //
            // Set timeout to 2 seconds.
            //

            srb.TimeOutValue = LogicalUnit->AdapterExtension->SrbTimeout;

            srb.CdbLength = 12;

            //
            // Enable auto request sense.
            //

            srb.SenseInfoBuffer = senseInfoBuffer;
            srb.SenseInfoBufferLength = SENSE_BUFFER_SIZE;

            srb.DataBuffer = MmGetMdlVirtualAddress(irp->MdlAddress);
            srb.DataTransferLength = lunListSize;

            cdb = (PCDB)srb.Cdb;

            //
            // Set CDB operation code.
            //

            cdb->REPORT_LUNS.OperationCode = SCSIOP_REPORT_LUNS;
            cdb->REPORT_LUNS.AllocationLength[0] = (UCHAR) ((lunListSize >> 24) & 0xff);
            cdb->REPORT_LUNS.AllocationLength[1] = (UCHAR) ((lunListSize >> 16) & 0xff);
            cdb->REPORT_LUNS.AllocationLength[2] = (UCHAR) ((lunListSize >>  8) & 0xff);
            cdb->REPORT_LUNS.AllocationLength[3] = (UCHAR) ((lunListSize >>  0) & 0xff);

            //
            // Call port driver to handle this request.
            //

            status = IoCallDriver(LogicalUnit->DeviceObject, irp);

            //
            // Wait for request to complete.
            //

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = irp->IoStatus.Status;

            if (SRB_STATUS(srb.SrbStatus) != SRB_STATUS_SUCCESS) {

                DebugPrint((2,"IssueReportLuns: failed SRB status %x\n",
                    srb.SrbStatus));

                //
                // Unfreeze queue if necessary
                //

                if (srb.SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

                    DebugPrint((3, "IssueInquiry: Unfreeze Queue TID %d\n",
                        srb.TargetId));

                    LogicalUnit->LuFlags &= ~LU_QUEUE_FROZEN;

                    KeAcquireSpinLock(
                        &(LogicalUnit->AdapterExtension->SpinLock),
                        &currentIrql);

                    GetNextLuRequest(LogicalUnit);
                    KeLowerIrql(currentIrql);
                }

                if ((srb.SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                     senseInfoBuffer->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST){

                     //
                     // A sense key of illegal request was recieved.  This indicates
                     // that the logical unit number of not valid but there is a
                     // target device out there.
                     //

                     status = STATUS_INVALID_DEVICE_REQUEST;
                     break;

                } else if ((SRB_STATUS(srb.SrbStatus) == SRB_STATUS_SELECTION_TIMEOUT) ||
                           (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_NO_DEVICE)) {

                    //
                    // If the selection times out then give up
                    //
                    status = STATUS_NO_SUCH_DEVICE;
                    break;
                }

                //
                // retry...
                //

            } else {

                status = STATUS_SUCCESS;
                break;
            }
        }

        IoFreeMdl(mdl);

        if (NT_SUCCESS(status)) {

            ULONG listLength;

            listLength  = lunListDataBuffer->LunListLength[3] <<  0;
            listLength |= lunListDataBuffer->LunListLength[2] <<  8;
            listLength |= lunListDataBuffer->LunListLength[1] << 16;
            listLength |= lunListDataBuffer->LunListLength[0] << 24;

            if (lunListSize < (listLength + sizeof (LUN_LIST))) {

                lunListSize = listLength + sizeof (LUN_LIST);

                //
                // try report lun with a bigger buffer
                //

                ExFreePool(lunListDataBuffer);
                lunListDataBuffer = NULL;
                status = STATUS_INVALID_DEVICE_REQUEST;

            } else {

                //
                // lun list is good
                //
                break;
            }
        }
    }

    //
    // Return the lun list
    //

    if(NT_SUCCESS(status)) {

        //
        // AdjustReportLuns returns lunListDataBuffer if it cannot allocate
        // a new list.
        //

        *LunList = AdjustReportLuns(LogicalUnit->DeviceObject->DriverObject, 
                                    lunListDataBuffer);

        //
        // Only delete lunListDataBuffer if we didn't return it from 
        // AdjustReportLuns.
        //

        ASSERT(*LunList != NULL);
        ASSERT(lunListDataBuffer != NULL);
        if (*LunList != lunListDataBuffer) {
            ExFreePool(lunListDataBuffer);
        }
    } else {
        *LunList = NULL;
        if (lunListDataBuffer) {
            ExFreePool(lunListDataBuffer);
        }
    }

    return status;

} // end IssueReportLuns()



VOID
GetNextLuRequestWithoutLock(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    KIRQL oldIrql;

    PAGED_CODE();
    ASSERT(SpPAGELOCKLockCount != 0);
    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    KeAcquireSpinLockAtDpcLevel(&(LogicalUnit->AdapterExtension->SpinLock));
    GetNextLuRequest(LogicalUnit);
    KeLowerIrql(oldIrql);
    PAGED_CODE();
    return;
}


ULONG
SpCountLogicalUnits(
    IN PADAPTER_EXTENSION Adapter
    )
{
    ULONG numberOfLus = 0;
    PLOGICAL_UNIT_EXTENSION luExtension;
    KIRQL oldIrql;

    ULONG bin;

#ifdef ALLOC_PRAGMA
    PVOID sectionHandle;
#endif
    //
    // Code is paged until locked down.
    //

    PAGED_CODE();

    //
    // Lock this routine down before grabbing the spinlock.
    //

#ifdef ALLOC_PRAGMA
    sectionHandle = MmLockPagableCodeSection(SpCountLogicalUnits);
#endif

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

    for(bin = 0; bin < NUMBER_LOGICAL_UNIT_BINS; bin++) {

        KeAcquireSpinLockAtDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));

        for(luExtension = Adapter->LogicalUnitList[bin].List;
            luExtension != NULL;
            luExtension = luExtension->NextLogicalUnit) {

            if(luExtension->IsMissing == FALSE) {
                numberOfLus++;
            }
        }

        KeReleaseSpinLockFromDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));
    }

    KeLowerIrql(oldIrql);

#ifdef ALLOC_PRAGMA
    MmUnlockPagableImageSection(sectionHandle);
#endif

    return numberOfLus;
}


NTSTATUS
SpGetInquiryData(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This functions copies the inquiry data to the system buffer.  The data
    is translate from the port driver's internal format to the user mode
    format.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    Irp - Supplies a pointer to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PUCHAR bufferStart;
    PIO_STACK_LOCATION irpStack;

    UCHAR bin;
    PLOGICAL_UNIT_EXTENSION luExtension;
    PSCSI_ADAPTER_BUS_INFO  adapterInfo;
    PSCSI_INQUIRY_DATA inquiryData;
    ULONG inquiryDataSize;
    ULONG length;
    PLOGICAL_UNIT_INFO lunInfo;
    ULONG numberOfBuses;
    ULONG numberOfLus;
    ULONG j;
    UCHAR pathId;
    UCHAR targetId;
    UCHAR lun;

    NTSTATUS status;

    PAGED_CODE();

    ASSERT_FDO(DeviceExtension->CommonExtension.DeviceObject);

    status = KeWaitForMutexObject(&(DeviceExtension->EnumerationDeviceMutex),
                                  UserRequest,
                                  KernelMode,
                                  FALSE,
                                  NULL);

    if(status == STATUS_USER_APC) {
        status = STATUS_REQUEST_ABORTED;
    }

    if(!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        return status;
    }

    DebugPrint((3,"SpGetInquiryData: Enter routine\n"));

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    bufferStart = Irp->AssociatedIrp.SystemBuffer;

    //
    // Determine the number of SCSI buses and logical units.
    //

    numberOfBuses = DeviceExtension->NumberOfBuses;
    numberOfLus = 0;

    numberOfLus = SpCountLogicalUnits(DeviceExtension);

    //
    // Caculate the size of the logical unit structure and round it to a word
    // alignment.
    //

    inquiryDataSize = ((sizeof(SCSI_INQUIRY_DATA) - 1 + INQUIRYDATABUFFERSIZE +
        sizeof(ULONG) - 1) & ~(sizeof(ULONG) - 1));

    // Based on the number of buses and logical unit, determine the minimum
    // buffer length to hold all of the data.
    //

    length = sizeof(SCSI_ADAPTER_BUS_INFO) +
        (numberOfBuses - 1) * sizeof(SCSI_BUS_DATA);
    length += inquiryDataSize * numberOfLus;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < length) {

        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        KeReleaseMutex(&(DeviceExtension->EnumerationDeviceMutex), FALSE);
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Set the information field.
    //

    Irp->IoStatus.Information = length;

    //
    // Fill in the bus information.
    //

    adapterInfo = (PSCSI_ADAPTER_BUS_INFO) bufferStart;

    adapterInfo->NumberOfBuses = (UCHAR) numberOfBuses;
    inquiryData = (PSCSI_INQUIRY_DATA)(bufferStart +
                                       sizeof(SCSI_ADAPTER_BUS_INFO) +
                                       ((numberOfBuses - 1) *
                                        sizeof(SCSI_BUS_DATA)));

    for (pathId = 0; pathId < numberOfBuses; pathId++) {

        PSCSI_BUS_DATA busData;

        busData = &adapterInfo->BusData[pathId];
        busData->InitiatorBusId = DeviceExtension->PortConfig->InitiatorBusId[pathId];
        busData->NumberOfLogicalUnits = 0;
        busData->InquiryDataOffset = (ULONG)((PUCHAR) inquiryData - bufferStart);

        for(targetId = 0;
            targetId < DeviceExtension->MaximumTargetIds;
            targetId++) {
            for(lun = 0;
                lun < SCSI_MAXIMUM_LUNS_PER_TARGET;
                lun++) {

                luExtension = GetLogicalUnitExtension(DeviceExtension,
                                                      pathId,
                                                      targetId,
                                                      lun,
                                                      Irp,
                                                      TRUE);

                if(luExtension == NULL) {
                    continue;
                }


                if((luExtension->IsMissing) ||
                   (luExtension->CommonExtension.IsRemoved)) {

                    SpReleaseRemoveLock(
                        luExtension->CommonExtension.DeviceObject,
                        Irp);

                    continue;
                }

                busData->NumberOfLogicalUnits++;

                DebugPrint((1, "InquiryData for (%d, %d, %d) - ",
                               pathId,
                               targetId,
                               lun));
                DebugPrint((1, "%d units found\n", busData->NumberOfLogicalUnits));

                inquiryData->PathId = pathId;
                inquiryData->TargetId = targetId;
                inquiryData->Lun = lun;
                inquiryData->DeviceClaimed = luExtension->IsClaimed;
                inquiryData->InquiryDataLength = INQUIRYDATABUFFERSIZE;
                inquiryData->NextInquiryDataOffset = (ULONG)((PUCHAR) inquiryData + inquiryDataSize - bufferStart);

                RtlCopyMemory(inquiryData->InquiryData,
                              &(luExtension->InquiryData),
                              INQUIRYDATABUFFERSIZE);

                inquiryData = (PSCSI_INQUIRY_DATA) ((PUCHAR) inquiryData + inquiryDataSize);

                SpReleaseRemoveLock(luExtension->CommonExtension.DeviceObject,
                                    Irp);
            }
        }

        if(busData->NumberOfLogicalUnits == 0) {
            busData->InquiryDataOffset = 0;
        } else {
            ((PSCSI_INQUIRY_DATA) ((PCHAR) inquiryData - inquiryDataSize))->NextInquiryDataOffset = 0;
        }

    }

    Irp->IoStatus.Status = STATUS_SUCCESS;

    KeReleaseMutex(&(DeviceExtension->EnumerationDeviceMutex), FALSE);
    return(STATUS_SUCCESS);
}


VOID
SpAddLogicalUnitToBin (
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension
    )

/*++

Routine Description:

    This routine will synchronize with any interrupt or miniport routines and
    add the specified logical unit to the appropriate logical unit list.
    The logical unit must not already be in the list.

    This routine acquires the bin spinlock and calls the SynchronizeExecution
    routine.  It cannot be called when the bin spinlock is held or from a
    miniport API.

Arguments:

    AdapterExtension - the adapter to add this logical unit to.

    LogicalUnitExtension - the logical unit to be added.

Return Value:

    none

--*/

{
    UCHAR hash = ADDRESS_TO_HASH(LogicalUnitExtension->PathId,
                                 LogicalUnitExtension->TargetId,
                                 LogicalUnitExtension->Lun);

    PLOGICAL_UNIT_BIN bin = &AdapterExtension->LogicalUnitList[hash];

    PLOGICAL_UNIT_EXTENSION lun;

    KIRQL oldIrql;

    KeAcquireSpinLock(&AdapterExtension->SpinLock, &oldIrql);
    KeAcquireSpinLockAtDpcLevel(&bin->Lock);

    //
    // Run through the list quickly and make sure this lun isn't already there
    //

    lun = bin->List;

    while(lun != NULL) {

        if(lun == LogicalUnitExtension) {
            break;
        }
        lun = lun->NextLogicalUnit;
    }

    ASSERTMSG("Logical Unit already in list: ", lun == NULL);

    ASSERTMSG("Logical Unit not properly initialized: ",
              (LogicalUnitExtension->AdapterExtension == AdapterExtension));

    ASSERTMSG("Logical Unit is already on a list: ",
              LogicalUnitExtension->NextLogicalUnit == NULL);

    LogicalUnitExtension->NextLogicalUnit = bin->List;

    bin->List = LogicalUnitExtension;

    KeReleaseSpinLockFromDpcLevel(&bin->Lock);
    KeReleaseSpinLock(&AdapterExtension->SpinLock, oldIrql);
    return;
}


VOID
SpRemoveLogicalUnitFromBin (
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension
    )

/*++

Routine Description:

    This routine will synchronize with any interrupt or miniport routines and
    remove the specified logical unit from the appropriate logical unit list.
    The logical unit MUST be in the logical unit list.

    This routine acquires the bin spinlock and calls the SynchronizeExecution
    routine.  It cannot be called when the bin spinlock is held or from
    a miniport exported routine.

Arguments:

    AdapterExtension - The adapter from which to remove this logical unit

    LogicalUnitExtension - the logical unit to be removed

Return Value:

    none

--*/

{
    KIRQL oldIrql;
    PLOGICAL_UNIT_BIN bin =
        &AdapterExtension->LogicalUnitList[ADDRESS_TO_HASH(
                                                LogicalUnitExtension->PathId,
                                                LogicalUnitExtension->TargetId,
                                                LogicalUnitExtension->Lun)];

    KeAcquireSpinLock(&AdapterExtension->SpinLock, &oldIrql);
    KeAcquireSpinLockAtDpcLevel(&bin->Lock);

    AdapterExtension->SynchronizeExecution(
        AdapterExtension->InterruptObject,
        SpRemoveLogicalUnitFromBinSynchronized,
        LogicalUnitExtension
        );

    KeReleaseSpinLockFromDpcLevel(&bin->Lock);
    KeReleaseSpinLock(&AdapterExtension->SpinLock, oldIrql);

    if(LogicalUnitExtension->IsMismatched) {
        DebugPrint((1, "SpRemoveLogicalUnitFromBin: Signalling for rescan "
                       "after removal of mismatched lun %#p\n",
                    LogicalUnitExtension));
        IoInvalidateDeviceRelations(AdapterExtension->LowerPdo,
                                    BusRelations);
    }
}


BOOLEAN
SpRemoveLogicalUnitFromBinSynchronized(
    IN PVOID ServiceContext
    )

{
    PLOGICAL_UNIT_EXTENSION logicalUnitExtension =
        (PLOGICAL_UNIT_EXTENSION) ServiceContext;
    PADAPTER_EXTENSION adapterExtension =
        logicalUnitExtension->AdapterExtension;

    UCHAR hash = ADDRESS_TO_HASH(
                    logicalUnitExtension->PathId,
                    logicalUnitExtension->TargetId,
                    logicalUnitExtension->Lun);

    PLOGICAL_UNIT_BIN  bin;

    PLOGICAL_UNIT_EXTENSION *lun;

    ASSERT(hash < NUMBER_LOGICAL_UNIT_BINS);

    adapterExtension->CachedLogicalUnit = NULL;

    bin = &adapterExtension->LogicalUnitList[hash];

    lun = &bin->List;

    while(*lun != NULL) {

        if(*lun == logicalUnitExtension) {

            //
            // Found a match - unlink it from the list.
            //

            *lun = logicalUnitExtension->NextLogicalUnit;
            logicalUnitExtension->NextLogicalUnit = NULL;
            return TRUE;
        }

        lun = &((*lun)->NextLogicalUnit);
    }

    return TRUE;
}


PLUN_LIST
AdjustReportLuns(
    IN PDRIVER_OBJECT DriverObject,
    IN PLUN_LIST RawList
    )
{
    ULONG newLength;
    ULONG numberOfEntries;
    ULONG maxLun = 8;

    PLUN_LIST newList;

    //
    // Derive the length of the list and the number of entries currently in
    // the list.
    //

    newLength  = RawList->LunListLength[3] <<  0;
    newLength |= RawList->LunListLength[2] <<  8;
    newLength |= RawList->LunListLength[1] << 16;
    newLength |= RawList->LunListLength[0] << 24;

    numberOfEntries = newLength / sizeof (RawList->Lun[0]);

    newLength += sizeof(LUN_LIST);
    newLength += maxLun * sizeof(RawList->Lun[0]);

    //
    // Allocate a list with "maxLun" extra entries in it.  This might waste
    // some space if we have duplicates but it's easy.
    //
    //
    // ALLOCATION
    //


    newList = SpAllocatePool(NonPagedPool,
                             newLength,
                             SCSIPORT_TAG_REPORT_LUNS,
                             DriverObject);

    if(newList == NULL){

        newList = RawList;
    } else {

        UCHAR lunNumber;
        ULONG entry;
        ULONG newEntryCount = 0;

        RtlZeroMemory(newList, newLength);

        //
        // First make a fake entry for each of the luns from 0 to maxLun - 1
        //

        for(lunNumber = 0; lunNumber < maxLun; lunNumber++) {
            newList->Lun[lunNumber][1] = lunNumber;
            newEntryCount++;
        };

        //
        // Now iterate through the entries in the remaining list.  For each
        // one copy it over iff it's not already a lun 0 -> (maxLun - 1)
        //

        for(entry = 0; entry < numberOfEntries; entry++) {
            USHORT l;

            l = (RawList->Lun[entry][0] << 8);
            l |= RawList->Lun[entry][1];
            l &= 0x3fff;

            if(l >= maxLun) {
                RtlCopyMemory(&(newList->Lun[lunNumber]),
                              &(RawList->Lun[entry]),
                              sizeof(newList->Lun[0]));
                lunNumber++;
                newEntryCount++;
            }
        }

        //
        // Copy over the reserved bytes for the cases where they aren't all
        // that reserved.
        //

        RtlCopyMemory(newList->Reserved,
                      RawList->Reserved,
                      sizeof(RawList->Reserved));

        //
        // Subtract out the number of duplicate entries we found.
        //

        newLength = newEntryCount * sizeof(RawList->Lun[0]);

        newList->LunListLength[0] = (UCHAR) ((newLength >> 24) & 0xff);
        newList->LunListLength[1] = (UCHAR) ((newLength >> 16) & 0xff);
        newList->LunListLength[2] = (UCHAR) ((newLength >> 8) & 0xff);
        newList->LunListLength[3] = (UCHAR) ((newLength >> 0) & 0xff);
    }

    return newList;
}

VOID
SpCompleteEnumRequest(
    IN PADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine completes our handling of an asynchronous bus scan.  If the
    supplied IRP has been completed successfully, we pass it down to the 
    driver below.  If the IRP was failed, we complete the request here.

Arguments:

    Adapter - The adapter we're scanning.

    Irp     - The IRP that prompted this asynchronous bus scan true then a 
              scan will be done even if one has happend within the minimum 
              bus scan delta time.

Return Value:

    none.

--*/
{
    ULONG tempLock;
    
    //
    // Acquire a temporary remove lock so we can release the lock acquired
    // on behalf of the IRP.
    //

    SpAcquireRemoveLock(Adapter->DeviceObject, &tempLock);

    //
    // Release the IRP's remove lock because holding it across completion
    // could trip up our remove tracking code since it is based on the
    // IRP address which can be recycled.
    //

    SpReleaseRemoveLock(Adapter->DeviceObject, Irp);

    //
    // Call down or complete the IRP, depending on the request's completion 
    // status.
    //

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoCallDriver(Adapter->CommonExtension.LowerDeviceObject, Irp);

    } else {

        SpCompleteRequest(Adapter->DeviceObject, 
                          Irp, 
                          NULL, 
                          IO_NO_INCREMENT);

    }

    //
    // Release the temporary lock.
    //

    SpReleaseRemoveLock(Adapter->DeviceObject, &tempLock);
}

NTSTATUS
SpEnumerateAdapterSynchronous(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Force
    )
/*++

Routine Description:

    This routine will call SpEnumerateAdapterAsynchronous and wait for it to
    complete.

Arguments:

    Adapter - the adapter we're scanning.

    Force - if true then a scan will be done even if one has happend within
            the minimum bus scan delta time.

Return Value:

    none.

--*/
{
    SP_ENUMERATION_REQUEST request;
    KEVENT event;

    NTSTATUS status;

    RtlZeroMemory(&request, sizeof(SP_ENUMERATION_REQUEST));

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    request.CompletionRoutine = SpSignalEnumerationCompletion;
    request.Context = &event;
    request.CompletionStatus = &status;
    request.Synchronous = TRUE;

    SpEnumerateAdapterAsynchronous(Adapter, &request, Force);

    KeWaitForSingleObject(&(event),
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    return status;
}

VOID
SpEnumerateAdapterAsynchronous(
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN BOOLEAN Force
    )

/*++
Routine Description:

    This routine will queue a bus scan and return.  When the scan completes the
    worker thread will run the callback in the Request passed in by the caller.

Details:

    If the force flag (or the ForceNextBusScan flag in the adapter) is set or
    the minimum interval between bus scans has passed then this routine will
    queue this enumeration request to the work list and, if necessary, start
    a new worker thread to process them.

    Otherwise it will attempt to acquire the EnumerationDeviceMutex in order to
    run the completion routine.  If this is not available then it will also
    queue the work item and start the thread if necessary.

Arguments:

    Adapter - the adapter to be scanned.

    Request - the request to be processed when the scan is complete.  The
              completion routine in this request may free the request structure.

    Force - hint as to whether or not we should honor the minimum bus scan
            interval.

Return Value:

    none

--*/

{
    ULONG forceNext;
    LONGLONG rescanInterval;

    PAGED_CODE();

    ASSERT(Request->CompletionRoutine != NULL);
    ASSERT(Request->NextRequest == NULL);

    ExAcquireFastMutex(&(Adapter->EnumerationWorklistMutex));

    //
    // Swap out the ForceNextBusScan value for FALSE.
    //

    forceNext = InterlockedExchange(&(Adapter->ForceNextBusScan), FALSE);

    //
    // Force the bus scan to happen either way.
    //

    Force = (Force || forceNext || Adapter->EnumerationRunning) ? TRUE : FALSE;

    //
    // Calculate the time between bus enumerations.
    //

    if(Force == FALSE) {
        LARGE_INTEGER currentSystemTime;
        LONGLONG lastTime;

        KeQuerySystemTime(&currentSystemTime);

        lastTime = Adapter->LastBusScanTime.QuadPart;

        rescanInterval = currentSystemTime.QuadPart - lastTime;
    }

    //
    // If we're required to do the bus scan then queue this request and
    // schedule a work item to run in (if necessary).
    //

    if((Force == TRUE) || (rescanInterval > MINIMUM_BUS_SCAN_INTERVAL)) {

        //
        // Grab the remove lock for this device so we know it (and the
        // associated code) can't be removed.
        //

        SpAcquireRemoveLock(Adapter->DeviceObject, Request);

        //
        // Queue the entry to the work list.
        //

        Request->NextRequest = Adapter->EnumerationWorkList;
        Adapter->EnumerationWorkList = Request;

        if(Adapter->EnumerationRunning == FALSE) {

            //
            // Start a new worker thread to run the enumeration.
            //

            Adapter->EnumerationRunning = TRUE;

            ExQueueWorkItem(&(Adapter->EnumerationWorkItem), DelayedWorkQueue);
        }

        ExReleaseFastMutex(&(Adapter->EnumerationWorklistMutex));

    } else {

        NTSTATUS status;
        PIRP irp = NULL;

        //
        // We're going to try and satisfy this request immediately.
        // If there is currently an enumeration running then we'll try to
        // acquire the EnumerationDeviceMutex.  If that fails we'll just
        // queue the request for the worker to complete.  If the worker is
        // not running then we just acquire the mutex and process the request.
        //

        ASSERT(Adapter->EnumerationRunning == FALSE);

        ExReleaseFastMutex(&(Adapter->EnumerationWorklistMutex));

        status = KeWaitForMutexObject(&(Adapter->EnumerationDeviceMutex),
                                      UserRequest,
                                      KernelMode,
                                      FALSE,
                                      NULL);

        //
        // If this is an async request, save the IRP so we can complete
        // it after we've filled in the completion information.  We can't
        // touch the request after we return from our completion callback.
        //

        if (Request->Synchronous == FALSE) {
            irp = (PIRP) Request->Context;
        }

        //
        // Either we got the mutex (STATUS_SUCCESS) or the thread is being
        // terminated (STATUS_USER_APC - since we're not alertable a
        // user-mode APC can't be run except in certain special cases).
        //
        // Either way the completion routine will do the correct thing.
        //

        Request->CompletionRoutine(Adapter, Request, status);

        //
        // If we acquired the mutex, release it.
        //

        if (status == STATUS_SUCCESS) {
            KeReleaseMutex(&(Adapter->EnumerationDeviceMutex), FALSE);
        }

        //
        // If this is an async request, complete the IRP or pass it down
        // depending on the status.
        //

        if (irp != NULL) {
            SpCompleteEnumRequest(Adapter, irp);
        }
    }

    return;
}


VOID
SpSignalEnumerationCompletion(
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN NTSTATUS Status
    )
{
    if(ARGUMENT_PRESENT(Request->CompletionStatus)) {
        *(Request->CompletionStatus) = Status;
    }

    KeSetEvent((PKEVENT) Request->Context, IO_NO_INCREMENT, FALSE);

    return;
}


VOID
SpEnumerationWorker(
    IN PADAPTER_EXTENSION Adapter
    )
{
    NTSTATUS status;
    PSP_ENUMERATION_REQUEST request;
    PKTHREAD thread;
    PIRP currentIrp;
    PLIST_ENTRY currentEntry;
    LIST_ENTRY completedListHead;

    PAGED_CODE();

    ASSERT_FDO(Adapter->DeviceObject);

    ASSERT(Adapter->EnumerationRunning == TRUE);

    //
    // Initialize the list of completed IRPs.
    //

    InitializeListHead(&completedListHead);

    Adapter->EnumerationWorkThread = KeGetCurrentThread();

    //
    // Grab the device mutex and enumerate the bus.
    //

    KeWaitForMutexObject(&(Adapter->EnumerationDeviceMutex),
                         UserRequest,
                         KernelMode,
                         FALSE,
                         NULL);

    SpScanAdapter(Adapter);

    //
    // Drop the device mutex & grab the WorkList mutex.
    //

    KeReleaseMutex(&(Adapter->EnumerationDeviceMutex), FALSE);
    ExAcquireFastMutex(&(Adapter->EnumerationWorklistMutex));

    //
    // Update the time of this bus scan.
    //

    KeQuerySystemTime(&(Adapter->LastBusScanTime));

    //
    // Grab a temporary remove lock.  Use the address of the work item as a
    // cheap way of ensuring that we haven't requeued the work item while the
    // thread is still running.
    //

    SpAcquireRemoveLock(Adapter->DeviceObject, &(Adapter->EnumerationWorkItem));

    //
    // Run through the list of enumeration requests.  For each one:
    //  * remove it from the work list.
    //  * save the irp if it's an async request
    //  * call its completion routine
    //

    for(request = Adapter->EnumerationWorkList;
        request != NULL;
        request = Adapter->EnumerationWorkList) {

        //
        // Remove this entry from the list.  Clear the next request pointer
        // as a bugcatcher.
        //

        Adapter->EnumerationWorkList = request->NextRequest;
        request->NextRequest = NULL;

        //
        // If this is an asynchronous request, add the IRP to the completed list.
        //

        if (request->Synchronous == FALSE) {
            currentIrp = (PIRP)request->Context;
            InsertTailList(&completedListHead, &currentIrp->Tail.Overlay.ListEntry);
        }

        //
        // Release the remove lock we acquired on behalf of the request object
        // before we call the completion routine.  The temporary lock we
        // acquired above protects us.
        //

        SpReleaseRemoveLock(Adapter->DeviceObject, request);

        //
        // Call our completion callback routine.
        //

        request->CompletionRoutine(Adapter, request, STATUS_SUCCESS);
        request = NULL;
    }

    //
    // Indicate that the work item is no longer running.
    //

    Adapter->EnumerationRunning = FALSE;
    Adapter->EnumerationWorkThread = NULL;

    //
    // Release the lock.
    //

    ExReleaseFastMutex(&(Adapter->EnumerationWorklistMutex));

    //
    // For asynchronous bus scans, we must wait until we've released the fast
    // mutex to complete the IRPs.  Doing so while holding the fast mutex
    // completes the IRP at APC_LEVEL and this opens the door to filter
    // drivers completion routines calling one of our dispatch routines at
    // elevated IRQL.  This is a problem because some of these dispatch
    // routines process requests synchronously by blocking the thread and
    // waiting for the IO Manager to set an event upon request completion.
    // The problem is that the IO Manager, for synchronous operations,
    // schedules an APC for the original thread in order to set the event
    // and do buffer copying in the caller's thread context.  This of course
    // deadlocks because the waiting thread is already at APC_LEVEL.
    //
    // By releasing the mutex first, we drop the thread's IRQL back to
    // PASSIVE_LEVEL and the problem is solved.
    //
    // The completion callback set the IRP's status and information fields;
    // all we have to do is either forward the IRP down the stack if the
    // status indicates success or complete it if the request failed.
    //

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    while (IsListEmpty(&completedListHead) == FALSE) {

        //
        // Get the next entry from the list.
        //

        currentEntry = RemoveHeadList(&completedListHead);

        //
        // Extract a pointer to the IRP.
        //
        
        currentIrp = CONTAINING_RECORD(currentEntry,
                                       IRP,
                                       Tail.Overlay.ListEntry);

        //
        // Complete the IRP.
        //

        SpCompleteEnumRequest(Adapter, currentIrp);
    }

    //
    // Release the temporary remove lock we acquired above.
    //

    SpReleaseRemoveLock(Adapter->DeviceObject, &(Adapter->EnumerationWorkItem));

    return;
}


VOID
SpScanAdapter(
    IN PADAPTER_EXTENSION Adapter
    )

/*++

Routine Description:

    This routine scans all of the busses on an adapter.  It locks down the
    necessary memory pages, checks the registry to see if we should be
    exposing disconnected luns, powers up the controller (if needed) and
    then scans each bus for devices.

    This routine is very much non-reenterant and should not be called outside
    of the enumeration mutex (ie. outside of an enumeration request).

Arguments:

    Adapter - a pointer to the adapter being enumerated.

Return Value:

    none

--*/

{
    PDEVICE_OBJECT deviceObject = Adapter->DeviceObject;

    UCHAR i;

    BOOLEAN exposeDisconnectedLuns = FALSE;

    PLOGICAL_UNIT_EXTENSION rescanLun;

#ifdef ALLOC_PRAGMA
    PVOID sectionHandle;
#endif

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugPrint((EnumDebug, "SpScanAdapter: Beginning scan of adapter %#p\n", Adapter));

    //
    // Try to allocate a logical unit to use for probeing new bus addresses.
    // Assume that it's going to be a SCSI-2 device.
    //

    status = SpCreateLogicalUnit(Adapter, 
                                 0xff, 
                                 0xff, 
                                 0xff, 
                                 TRUE, 
                                 FALSE, 
                                 &rescanLun);

    if(!NT_SUCCESS(status)) {
        return;
    }

    //
    // Lock down the PAGELOCK section - we'll need it in order to call
    // IssueInquiry.
    //

#ifdef ALLOC_PRAGMA
    sectionHandle = MmLockPagableCodeSection(GetNextLuRequestWithoutLock);
    InterlockedIncrement(&SpPAGELOCKLockCount);
#endif

    //
    // Check to see if we should be exposing disconnected LUNs.
    //

    for(i = 0; i < 3; i++) {

        PWCHAR locations[] = {
            L"Scsiport",
            SCSIPORT_CONTROL_KEY,
            DISK_SERVICE_KEY
        };

        UNICODE_STRING unicodeString;
        OBJECT_ATTRIBUTES objectAttributes;
        HANDLE instanceHandle = NULL;
        HANDLE handle;
        PKEY_VALUE_FULL_INFORMATION key = NULL;

        if(i == 0) {
            status = IoOpenDeviceRegistryKey(Adapter->LowerPdo,
                                             PLUGPLAY_REGKEY_DEVICE,
                                             KEY_READ,
                                             &instanceHandle);

            if(!NT_SUCCESS(status)) {
                DebugPrint((2, "SpScanAdapter: Error %#08lx opening device registry key\n", status));
                continue;
            }
        }

        RtlInitUnicodeString(&unicodeString, locations[i]);

        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            instanceHandle,
            NULL);

        status = ZwOpenKey(&handle,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {
            DebugPrint((2, "SpScanAdapter: Error %#08lx opening %wZ key\n", status, &unicodeString));
            if(instanceHandle != NULL) {
                ZwClose(instanceHandle);
                instanceHandle = NULL;
            }
            continue;
        }

        status = SpGetRegistryValue(deviceObject->DriverObject,
                                    handle,
                                    L"ScanDisconnectedDevices",
                                    &key);

        ZwClose(handle);
        if(instanceHandle != NULL) {
            ZwClose(instanceHandle);
            instanceHandle = NULL;
        }

        if(NT_SUCCESS(status)) {
            if(key->Type == REG_DWORD) {
                PULONG value;
                value = (PULONG) ((PUCHAR) key + key->DataOffset);
                if(*value) {
                    exposeDisconnectedLuns = TRUE;
                }
            }
            ExFreePool(key);
            break;
        } else {
            DebugPrint((2, "SpScanAdapter: Error %#08lx opening %wZ\\ScanDisconnectedDevices value\n", status, &unicodeString));
        }
    }

    //
    // We need to be powered up in order to do a bus enumeration - make
    // sure that we are.  This is because we create new PDO's and new
    // PDO's are assumed to be at D0.
    //

    status = SpRequestValidAdapterPowerStateSynchronous(Adapter);

    if(NT_SUCCESS(status)) {
        UCHAR pathId;

        //
        // Check if we are supposed to create a logical unit for the initiator.  If
        // so, try to create one if we haven't done so yet.
        //

        if (Adapter->CreateInitiatorLU == TRUE) {
            if (Adapter->InitiatorLU[0] == NULL) {
                Adapter->InitiatorLU[0] = SpCreateInitiatorLU(Adapter, Adapter->NumberOfBuses - 1);
                if (Adapter->InitiatorLU[0] == NULL) {
                    DebugPrint((0, "SpScanBus: failed to create initiator LUN "
                                "for FDO %p bus %d\n",
                                Adapter->DeviceObject,
                                Adapter->NumberOfBuses - 1));
                }
            }
        }

        for (pathId = 0; pathId < Adapter->NumberOfBuses; pathId++) {
            status = SpScanBus(Adapter, pathId, exposeDisconnectedLuns, rescanLun);

            if(!NT_SUCCESS(status)) {
                break;
            }
        }
    }

#ifdef ALLOC_PRAGMA
    InterlockedDecrement(&SpPAGELOCKLockCount);
    MmUnlockPagableImageSection(sectionHandle);
#endif

    SpDeleteLogicalUnit(rescanLun);
    ASSERT(Adapter->RescanLun == NULL);

    return;
}


NTSTATUS
SpScanBus(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN PLOGICAL_UNIT_EXTENSION RescanLun
    )
{
    UCHAR targetIndex;
    NTSTATUS status = STATUS_SUCCESS;

    DebugPrint((EnumDebug, "SpScanBus: Beginning scan of bus %x\n", PathId));

    for(targetIndex = 0; targetIndex < Adapter->MaximumTargetIds; targetIndex++) {

        UCHAR targetId;

        if(Adapter->Capabilities.AdapterScansDown) {
            targetId = Adapter->MaximumTargetIds - targetIndex - 1;
        } else {
            targetId = targetIndex;
        }

        DebugPrint((EnumDebug, "SpScanBus: targetIndex = %x -> targetId = %x\n",
                    targetIndex, targetId));

        ASSERT(targetId != 255);
        ASSERT(Adapter->PortConfig);

        if(targetId == Adapter->PortConfig->InitiatorBusId[PathId]) {
            DebugPrint((EnumDebug, "SpScanBus:   Target ID matches initiator ID - skipping\n"));
            continue;
        }

        //
        // Mark all of the logical units as needing verification.  At the
        // end of scanning the target and LUNs which still need to be verified
        // will be purged (marked as missing).
        //

        SpSetVerificationMarks(Adapter, PathId, targetId);
        RescanLun->NeedsVerification = TRUE;

        status = SpScanTarget(Adapter,
                              PathId,
                              targetId,
                              ExposeDisconnectedLuns,
                              RescanLun);

        SpPurgeTarget(Adapter, PathId, targetId);

        if(!NT_SUCCESS(status)) {
            break;
        }
    }

    return status;
}


NTSTATUS
SpScanTarget(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN PLOGICAL_UNIT_EXTENSION RescanLun
    )
{
    BOOLEAN sparseLun = FALSE;

    PLOGICAL_UNIT_EXTENSION lunZero;
    BOOLEAN checkNextLun;

    BOOLEAN scsi1 = FALSE;

    PLUN_LIST lunList = NULL;
    BOOLEAN saveLunList = FALSE;
    ULONG numLunsReported;

    UCHAR maxLuCount;
    ULONG lunIndex;

    NTSTATUS resetStatus;
    NTSTATUS status;

    DebugPrint((EnumDebug, "SpScanTarget:   Beginning scan of target %x\n", TargetId));

    //
    // Use the SCSI-2 dispatch table when checking LUN 0.
    //

    ASSERT(RescanLun->CommonExtension.MajorFunction == DeviceMajorFunctionTable);

    //
    // Issue an inquiry to LUN 0.
    //

    status = SpInquireLogicalUnit(Adapter,
                                  PathId,
                                  TargetId,
                                  (UCHAR) 0,
                                  TRUE,
                                  RescanLun,
                                  &lunZero,
                                  &checkNextLun);

    //
    // reset the rescan lun so that we can safely use it again.  If this fails
    // we still continue as far as possible with this target, but we return the
    // reset status to the caller so it can abort its scan.
    //

    resetStatus = SpPrepareLogicalUnitForReuse(RescanLun);

    if(!NT_SUCCESS(resetStatus)) {
        RescanLun = NULL;
    }

    if(!NT_SUCCESS(status) &&
       !((checkNextLun == TRUE) && (lunZero != NULL))) {

        //
        // There is no device present at LUN 0.  Skip to the next target.
        // Even if sparse luns is enabled there MUST be a LUN 0 for us to
        // continue scanning the target.
        //

        DebugPrint((EnumDebug, "SpScanTarget:    Lun 0 not found - terminating scan "
                       "(status %#08lx)\n", status));

        return resetStatus;
    }

    //
    // Indicate that lun 0 does not require verification.
    //

    SpClearVerificationMark(lunZero);

    //
    // Check for the special case of only having one LUN on this target.
    //

    if(lunZero->SpecialFlags.OneLun) {

        DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) is listed as having "
                       "only one lun\n", PathId, TargetId));
        return resetStatus;
    }

    //
    // Set the rescan LUN to use whatever lun zero uses for a dispatch table.
    // 

    RescanLun->CommonExtension.MajorFunction = 
        lunZero->CommonExtension.MajorFunction;

    //
    // Determine if we should be handling sparse LUNs on this target.
    //

    sparseLun = TEST(lunZero->SpecialFlags.SparseLun);

    if(sparseLun) {
        DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) will be checked for "
                       "sparse luns\n", PathId, TargetId));
    }

    //
    // Issue a report luns command to the device if it supports it.
    // If it doesn't support it then use the default LUN list.
    //

    if((lunZero->InquiryData.HiSupport || lunZero->SpecialFlags.LargeLuns)) {

        DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) may support REPORT_LUNS\n", PathId, TargetId));

        //
        // Indicate that we should indeed save the lun list.  If it turns out
        // that we're unable to retrieve one to be saved then we will
        // clear the flag below.
        //

        saveLunList = TRUE;

        status = IssueReportLuns(lunZero, &lunList);

        //
        // If the request fails for some reason then try to use the lun list
        // which was saved for this target (in the extension of logical unit
        // zero).  If that hasn't been set either then we'll use the default
        // one down below.
        //

        if(!NT_SUCCESS(status)) {
            DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) returned  %#08lx to REPORT_LUNS command - using old list\n", PathId, TargetId, status));
            lunList = lunZero->TargetLunList;
        }

        //
        // If we can now or have in the past gotten a report luns list from the
        // device then enable sparse lun scanning.  In this case we also assume
        // that up to 255 luns can be supported on this target.
        //

        if(lunList != NULL) {
            sparseLun = TRUE;
            DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) will be checked for "
                           "sparse luns(2)\n", PathId, TargetId));
        }
    }

    //
    // if we still don't have a lun list then use the "default" one.  In that
    // event don't save it.
    //

    if(lunList == NULL) {
        DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) will use default lun list\n", PathId, TargetId));
        lunList = (PLUN_LIST) &(ScsiPortDefaultLunList);
        saveLunList = FALSE;
    }

    numLunsReported  = lunList->LunListLength[3] <<  0;
    numLunsReported |= lunList->LunListLength[2] <<  8;
    numLunsReported |= lunList->LunListLength[1] << 16;
    numLunsReported |= lunList->LunListLength[0] << 24;
    numLunsReported /= sizeof (lunList->Lun[0]);

    DebugPrint((EnumDebug, "SpScanTarget:    Target (%x,%x,*) has reported %d luns\n", PathId, TargetId, numLunsReported));

    //
    // Walk through each entry in the LUN list.  Stop when we run out of entries
    // or the logical unit number is > MaximumNumberOfLogicalUnits (the lun
    // list is assumed to be sorted in increasing order).  For each entry,
    // issue an inquiry.  If the inquiry succeeds then clear the verification
    // mark.
    //

    for(lunIndex = 0; lunIndex < numLunsReported; lunIndex++) {
        PULONGLONG largeLun;
        USHORT lun;
        PLOGICAL_UNIT_EXTENSION logicalUnit;

        largeLun = (PULONGLONG) (lunList->Lun[lunIndex]);

        lun  = lunList->Lun[lunIndex][1] << 0;
        lun |= lunList->Lun[lunIndex][0] << 8;
        lun &= 0x3fff;

        //
        // If the target reports a lun 0 just skip it.
        //

        DebugPrint((EnumDebug, "SpScanTarget:     Checking lun %I64lx (%x): ",  *largeLun, lun));

        if(lun == 0) {
            DebugPrint((EnumDebug, "Skipping LUN 0\n"));
            continue;
        }

        //
        // If the target reports a lun outside the range the driver can support
        // then skip it.
        //

        if(lun >= Adapter->PortConfig->MaximumNumberOfLogicalUnits) {
            DebugPrint((EnumDebug, "Skipping LUN out of range (> %x)\n", 
                        Adapter->PortConfig->MaximumNumberOfLogicalUnits));
            continue;
        }

        //
        // Issue an inquiry to each logical unit in the system.
        //

        status = SpInquireLogicalUnit(Adapter,
                                      PathId,
                                      TargetId,
                                      (UCHAR) lun,
                                      ExposeDisconnectedLuns,
                                      RescanLun,
                                      &logicalUnit,
                                      &checkNextLun);

        if(RescanLun != NULL) {
            resetStatus = SpPrepareLogicalUnitForReuse(RescanLun);

            if(!NT_SUCCESS(resetStatus)) {
                RescanLun = NULL;
            }
        }

        if(NT_SUCCESS(status)) {

            DebugPrint((EnumDebug, "Inquiry succeeded\n"));
            SpClearVerificationMark(logicalUnit);

        } else {

            DebugPrint((EnumDebug, "inquiry returned %#08lx.", status));

            if((sparseLun == FALSE)&&(checkNextLun == FALSE)) {
                DebugPrint((EnumDebug, "Aborting\n"));
                break;
            } else {
                DebugPrint((EnumDebug, " - checking next (%c%c)\n",
                            sparseLun ? 's' : ' ',
                            checkNextLun ? 'c' : ' '));
            }
        }
    }

    //
    // If we're supposed to save the lun list then replace the one in lun0
    // with this one.
    //

    if(saveLunList) {

        DebugPrint((EnumDebug, "SpScanTarget:   Saving LUN list %#08lx\n", lunList));
        ASSERT(lunZero->TargetLunList != (PLUN_LIST) &(ScsiPortDefaultLunList));
        if(lunZero->TargetLunList != NULL && lunZero->TargetLunList != lunList) {
            DebugPrint((EnumDebug, "SpScanTarget:   Freeing old LUN list %#08lx\n", lunZero->TargetLunList));
            ExFreePool(lunZero->TargetLunList);
        }

        lunZero->TargetLunList = lunList;

    } else {
        ASSERT(lunList == (PLUN_LIST) &(ScsiPortDefaultLunList));
    }

    //
    // reset the rescan LUN to use the scsi 2 dispatch table.
    //

    RescanLun->CommonExtension.MajorFunction = DeviceMajorFunctionTable;

    return resetStatus;
}


VOID
SpSetVerificationMarks(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId
    )
{
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    KIRQL oldIrql;

    ULONG bin;

    //
    // Code is paged until locked down.
    //

    PAGED_CODE();
    ASSERT(SpPAGELOCKLockCount != 0);

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

    for(bin = 0; bin < NUMBER_LOGICAL_UNIT_BINS; bin++) {

        KeAcquireSpinLockAtDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));

        for(logicalUnit = Adapter->LogicalUnitList[bin].List;
            logicalUnit != NULL;
            logicalUnit = logicalUnit->NextLogicalUnit) {

            ASSERT(logicalUnit->IsTemporary == FALSE);

            if((logicalUnit->PathId == PathId) &&
               (logicalUnit->TargetId == TargetId)) {

                logicalUnit->NeedsVerification = TRUE;
            }
        }

        KeReleaseSpinLockFromDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));
    }

    KeLowerIrql(oldIrql);

    return;
}


VOID
SpClearVerificationMark(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    PAGED_CODE();

    ASSERT(LogicalUnit->IsTemporary == FALSE);
    ASSERT(LogicalUnit->NeedsVerification == TRUE);
    LogicalUnit->NeedsVerification = FALSE;
    return;
}


VOID
SpPurgeTarget(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId
    )
{
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    KIRQL oldIrql;

    ULONG bin;

    //
    // Code is paged until locked down.
    //

    PAGED_CODE();
    ASSERT(SpPAGELOCKLockCount != 0);

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

    for(bin = 0; bin < NUMBER_LOGICAL_UNIT_BINS; bin++) {

        KeAcquireSpinLockAtDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));

        for(logicalUnit = Adapter->LogicalUnitList[bin].List;
            logicalUnit != NULL;
            logicalUnit = logicalUnit->NextLogicalUnit) {

            ASSERT(logicalUnit->IsTemporary == FALSE);

            if((logicalUnit->PathId == PathId) &&
               (logicalUnit->TargetId == TargetId) &&
               (logicalUnit->NeedsVerification == TRUE)) {


                //
                // This device was not found to be present during our bus scan.
                //

                DebugPrint((EnumDebug, "SpPurgeTarget:   Lun (%x,%x,%x) is still marked and will be made missing\n", logicalUnit->PathId, logicalUnit->TargetId, logicalUnit->Lun));
                logicalUnit->IsMissing = TRUE;
            }
        }

        KeReleaseSpinLockFromDpcLevel(&(Adapter->LogicalUnitList[bin].Lock));
    }

    KeLowerIrql(oldIrql);

    return;
}


NTSTATUS
SpCreateLogicalUnit(
    IN PADAPTER_EXTENSION Adapter,
    IN OPTIONAL UCHAR PathId,
    IN OPTIONAL UCHAR TargetId,
    IN OPTIONAL UCHAR Lun,
    IN BOOLEAN Temporary,
    IN BOOLEAN Scsi1,
    OUT PLOGICAL_UNIT_EXTENSION *NewLun
    )

/*++

Routine Description:

    This routine will create a physical device object for the specified device

Arguments:

    Adapter - the parent adapter for this new lun

    PathId, TargetId, Lun - the address of this lun.  Not used if Temporary is
                            TRUE (see below).

    Temporary - indicates whether this device is real (FALSE) or simply for
                the purposes of scanning the bus (TRUE).  If TRUE then the
                address info is ignored and this lun is NOT inserted into the
                logical unit list.

    Scsi1 - indicates that this LUN is a scsi1 lun and needs to use the 
            dispatch routines which stick the LUN number into the CDB itself.               

    NewLun - a location to store the pointer to the new lun

Return Value:

    status

--*/

{
    PIRP senseIrp;

    PDEVICE_OBJECT pdo = NULL;
    PLOGICAL_UNIT_EXTENSION logicalUnitExtension;

    WCHAR wideDeviceName[64];
    UNICODE_STRING unicodeDeviceName;

    PVOID hwExtension = NULL;

    PVOID serialNumberBuffer = NULL;
    PVOID idBuffer = NULL;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Attempt to allocate all the persistent resources we need before we
    // try to create the device object itself.
    //

    //
    // Allocate a request sense irp.
    //

    senseIrp = SpAllocateIrp(1, FALSE, Adapter->DeviceObject->DriverObject);

    if(senseIrp == NULL) {
        DebugPrint((0, "SpCreateLogicalUnit: Could not allocate request sense "
                       "irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the name for the device
    //

    if(Temporary == FALSE) {

        swprintf(wideDeviceName,
                 L"%wsPort%xPath%xTarget%xLun%x",
                 Adapter->DeviceName,
                 Adapter->PortNumber,
                 PathId,
                 TargetId,
                 Lun);
    } else {
        swprintf(wideDeviceName,
                 L"%wsPort%xRescan",
                 Adapter->DeviceName,
                 Adapter->PortNumber);

        PathId = 0xff;
        TargetId = 0xff;
        Lun = 0xff;

        ASSERT(Adapter->RescanLun == NULL);
    }

    RtlInitUnicodeString(&unicodeDeviceName, wideDeviceName);

    //
    // Round the size of the Hardware logical extension to the size of a
    // PVOID and add it to the port driver's logical extension.
    //

    if(Adapter->HwLogicalUnitExtensionSize != 0) {
        hwExtension = SpAllocatePool(
                          NonPagedPoolCacheAligned,
                          Adapter->HwLogicalUnitExtensionSize,
                          SCSIPORT_TAG_LUN_EXT,
                          Adapter->DeviceObject->DriverObject);

        if(hwExtension == NULL) {
            
            *NewLun = NULL;
            IoFreeIrp(senseIrp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(hwExtension,
                      Adapter->HwLogicalUnitExtensionSize);
    }

    //
    // If this is a temporary lun then allocate a large buffer to store the
    // identify data.
    //

    if(Temporary) {
        serialNumberBuffer = SpAllocatePool(
                                PagedPool,
                                VPD_MAX_BUFFER_SIZE,
                                SCSIPORT_TAG_TEMP_ID_BUFFER,
                                Adapter->DeviceObject->DriverObject);

        if(serialNumberBuffer == NULL) {

            if (hwExtension != NULL) {
                ExFreePool(hwExtension);
            }
            IoFreeIrp(senseIrp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        idBuffer = SpAllocatePool(PagedPool,
                                  VPD_MAX_BUFFER_SIZE,
                                  SCSIPORT_TAG_TEMP_ID_BUFFER,
                                  Adapter->DeviceObject->DriverObject);

        if(idBuffer == NULL) {

            if (hwExtension != NULL) {
                ExFreePool(hwExtension);
            }
            IoFreeIrp(senseIrp);
            ExFreePool(serialNumberBuffer);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(serialNumberBuffer, VPD_MAX_BUFFER_SIZE);
        RtlZeroMemory(idBuffer, VPD_MAX_BUFFER_SIZE);
    }

    //
    // Create a physical device object
    //

    status = IoCreateDevice(
                Adapter->DeviceObject->DriverObject,
                sizeof(LOGICAL_UNIT_EXTENSION),
                &unicodeDeviceName,
                FILE_DEVICE_MASS_STORAGE,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                &pdo
                );

    if(NT_SUCCESS(status)) {

        PCOMMON_EXTENSION commonExtension;
        UCHAR i;
        ULONG bin;

        UCHAR rawDeviceName[64];
        ANSI_STRING ansiDeviceName;

        //
        // Set the device object's stack size
        //

        //
        // We need one stack location for the PDO to do lock tracking and
        // one stack location to issue scsi request to the FDO.
        //

        pdo->StackSize = 1;

        pdo->Flags |= DO_BUS_ENUMERATED_DEVICE;

        pdo->Flags |= DO_DIRECT_IO;

        pdo->AlignmentRequirement = Adapter->DeviceObject->AlignmentRequirement;

        //
        // Initialize the device extension for the root device
        //

        commonExtension = pdo->DeviceExtension;
        logicalUnitExtension = pdo->DeviceExtension;

        RtlZeroMemory(logicalUnitExtension, sizeof(LOGICAL_UNIT_EXTENSION));

        commonExtension->DeviceObject = pdo;
        commonExtension->IsPdo = TRUE;
        commonExtension->LowerDeviceObject = Adapter->DeviceObject;

        if(Scsi1) {
            commonExtension->MajorFunction = Scsi1DeviceMajorFunctionTable;
        } else {
            commonExtension->MajorFunction = DeviceMajorFunctionTable;
        }

        commonExtension->WmiInitialized            = FALSE;
        commonExtension->WmiMiniPortSupport        =
            Adapter->CommonExtension.WmiMiniPortSupport;

        commonExtension->WmiScsiPortRegInfoBuf     = NULL;
        commonExtension->WmiScsiPortRegInfoBufSize = 0;

        //
        // Initialize value to zero.  It will be incremented once pnp is aware
        // of its existance.
        //

        commonExtension->RemoveLock = 0;
#if DBG
        KeInitializeSpinLock(&commonExtension->RemoveTrackingSpinlock);
        commonExtension->RemoveTrackingList = NULL;

        ExInitializeNPagedLookasideList(
            &(commonExtension->RemoveTrackingLookasideList),
            NULL,
            NULL,
            0,
            sizeof(REMOVE_TRACKING_BLOCK),
            SCSIPORT_TAG_LOCK_TRACKING,
            64);

        commonExtension->RemoveTrackingLookasideListInitialized = TRUE;
#else
        commonExtension->RemoveTrackingSpinlock = (ULONG) -1L;
        commonExtension->RemoveTrackingList = (PVOID) -1L;
#endif

        commonExtension->CurrentPnpState = 0xff;
        commonExtension->PreviousPnpState = 0xff;

        //
        // Initialize the remove lock event.
        //

        KeInitializeEvent(
            &(logicalUnitExtension->CommonExtension.RemoveEvent),
            SynchronizationEvent,
            FALSE);

        logicalUnitExtension->PortNumber = Adapter->PortNumber;

        logicalUnitExtension->PathId = 0xff;
        logicalUnitExtension->TargetId = 0xff;
        logicalUnitExtension->Lun = 0xff;

        logicalUnitExtension->HwLogicalUnitExtension = hwExtension;

        logicalUnitExtension->AdapterExtension = Adapter;

        //
        // Give the caller the benefit of the doubt.
        //

        logicalUnitExtension->IsMissing = FALSE;

        //
        // The device cannot have been enumerated yet.
        //

        logicalUnitExtension->IsEnumerated = FALSE;

        //
        // Set timer counters to -1 to inidicate that there are no outstanding
        // requests.
        //

        logicalUnitExtension->RequestTimeoutCounter = -1;

        //
        // Initialize the maximum queue depth size.
        //

        logicalUnitExtension->MaxQueueDepth = 0xFF;

        //
        // Initialize the request list.
        //

        InitializeListHead(&logicalUnitExtension->RequestList);

        //
        // Initialize the blocked request list.
        //

        InitializeListHead(&logicalUnitExtension->SrbDataBlockedRequests);

        //
        // Initialize the push/pop list of SRB_DATA blocks for use with bypass
        // requests.
        //

        KeInitializeSpinLock(&(logicalUnitExtension->BypassSrbDataSpinLock));
        ExInitializeSListHead(&(logicalUnitExtension->BypassSrbDataList));
        for(i = 0; i < NUMBER_BYPASS_SRB_DATA_BLOCKS; i++) {
            ExInterlockedPushEntrySList(
                &(logicalUnitExtension->BypassSrbDataList),
                &(logicalUnitExtension->BypassSrbDataBlocks[i].Reserved),
                &(logicalUnitExtension->BypassSrbDataSpinLock));
        }

        //
        // Assume devices are powered on by default.
        //

        commonExtension->CurrentDeviceState = PowerDeviceD0;
        commonExtension->DesiredDeviceState = PowerDeviceUnspecified;

        //
        // Assume that we're being initialized in a working system.
        //

        commonExtension->CurrentSystemState = PowerSystemWorking;

        //
        // Setup the request sense resources.
        //

        logicalUnitExtension->RequestSenseIrp = senseIrp;

        //
        // If this is temporary record that fact in the logical unit extension
        // and save a pointer in the adapter (cleared when the LUN is
        // destroyed).  If it's real then stick it into the logical unit list.
        //

        logicalUnitExtension->IsTemporary = Temporary;

#if defined (NEWQUEUE)
        //
        // Initialize the LU Capacity and Zone params with default values:
        //   Capacity : 0xffffffff blocks
        //   Zones    : 4
        //

        {
            ULONG zoneLen = SP_DEFAULT_MAX_CAPACITY / SP_DEFAULT_ZONES;
                
            logicalUnitExtension->Capacity   = SP_DEFAULT_MAX_CAPACITY;
            logicalUnitExtension->Zones      = SP_DEFAULT_ZONES;
            logicalUnitExtension->ZoneLength = zoneLen;

            logicalUnitExtension->FirstSector[0] = 0;
            logicalUnitExtension->FirstSector[1] = zoneLen;
            logicalUnitExtension->FirstSector[2] = zoneLen * 2;
            logicalUnitExtension->FirstSector[3] = zoneLen * 3;
            
            logicalUnitExtension->LastSector[0] = zoneLen - 1;
            logicalUnitExtension->LastSector[1] = (zoneLen * 2) - 1;
            logicalUnitExtension->LastSector[2] = (zoneLen * 3) - 1;
            logicalUnitExtension->LastSector[3] = SP_DEFAULT_MAX_CAPACITY - 1;

            logicalUnitExtension->NextSequentialZone[0] = 1;
            logicalUnitExtension->NextSequentialZone[1] = 2;
            logicalUnitExtension->NextSequentialZone[2] = 3;
            logicalUnitExtension->NextSequentialZone[3] = 0;
        }
#endif // NEWQUEUE

        //
        // Initialize

        RtlInitAnsiString(&(logicalUnitExtension->SerialNumber), serialNumberBuffer);

        if(serialNumberBuffer != NULL) {
            logicalUnitExtension->SerialNumber.MaximumLength = VPD_MAX_BUFFER_SIZE;
        }

        logicalUnitExtension->DeviceIdentifierPage = idBuffer;

        //
        // I guess this is as ready to be opened as it ever will be.
        //

        pdo->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        // Initialize the lock & unlock request queue.
        //

        KeInitializeDeviceQueue(&(logicalUnitExtension->LockRequestQueue));
        logicalUnitExtension->CurrentLockRequest = NULL;

    } else {

        DebugPrint((1, "ScsiBusCreatePdo: Error %#08lx creating device object\n",
                       status));

        logicalUnitExtension = NULL;

        if(hwExtension != NULL) {
            ExFreePool(hwExtension);
        }
        IoFreeIrp(senseIrp);

        ExFreePool(serialNumberBuffer);
        ExFreePool(idBuffer);
    }

    *NewLun = logicalUnitExtension;

    return status;
}


VOID
SpSetLogicalUnitAddress(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
{
    UCHAR i;
    ULONG bin;

    ASSERT_PDO(LogicalUnit->DeviceObject);

    ASSERT(LogicalUnit->PathId == 0xff);
    ASSERT(LogicalUnit->TargetId == 0xff);
    ASSERT(LogicalUnit->Lun == 0xff);

    LogicalUnit->PathId = PathId;
    LogicalUnit->TargetId = TargetId;
    LogicalUnit->Lun = Lun;

    SpAddLogicalUnitToBin(LogicalUnit->AdapterExtension, LogicalUnit);

    return;
}


VOID
SpClearLogicalUnitAddress(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    ASSERT_PDO(LogicalUnit->DeviceObject);
    ASSERT(LogicalUnit->IsTemporary == TRUE);

    SpRemoveLogicalUnitFromBin(LogicalUnit->AdapterExtension, LogicalUnit);

    LogicalUnit->PathId = 0xff;
    LogicalUnit->TargetId = 0xff;
    LogicalUnit->Lun = 0xff;

    return;
}


NTSTATUS
SpCloneAndSwapLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION TemplateLun,
    IN PINQUIRYDATA InquiryData,
    IN ULONG InquiryDataSize,
    OUT PLOGICAL_UNIT_EXTENSION *NewLun
    )
/*++

Routine Description:

    This routine will create a new logical unit object with the properties of
    TemplateLun.  The supplied inquiry data will be assigned to the new
    logical unit.  Finally the new logical unit will be swapped for
    TemplateLun in the adapter's logical unit list.

    TemplateLun must be a temporary logical unit which has been assigned an
    address and is present in the logical unit lists.

    Regardless of whether this function succeeds, the TemplateLun will be
    removed from the logical unit list (effectively swapped with nothing).

Arguments:

    TemplateLun - the logical unit to be cloned

    InquiryData, InquiryDataSize - the inquiry data to be used for the new
                                   logical unit

    NewLun - a location to store the pointer to the new logical unit.

Return Value:

    STATUS_SUCCESS indicates that a new lun has been created and swapped in
                   the logical unit list.

    error status indicates that the new logical unit could not be created for
    some reason.

--*/
{
    PADAPTER_EXTENSION adapter = TemplateLun->AdapterExtension;
    PSCSIPORT_DRIVER_EXTENSION driverExtension = 
                                IoGetDriverObjectExtension(
                                    adapter->DeviceObject->DriverObject,
                                    ScsiPortInitialize);

    UCHAR pathId, targetId, lun;

    PVOID serialNumber = NULL;
    USHORT serialNumberLength = 0;

    PVOID identifier = NULL;
    ULONG identifierLength = 0;

    PLOGICAL_UNIT_EXTENSION newLun;

    BOOLEAN scsi1;

    NTSTATUS status;

    ASSERT_PDO(TemplateLun->DeviceObject);
    ASSERT(TemplateLun->IsTemporary);

    *NewLun = NULL;

#if DBG
    newLun = GetLogicalUnitExtension(adapter,
                                     TemplateLun->PathId,
                                     TemplateLun->TargetId,
                                     TemplateLun->Lun,
                                     NULL,
                                     TRUE);
    ASSERT(newLun == TemplateLun);
#endif

    //
    // Wait for any outstanding i/o on the template lun to complete.
    //

    SpReleaseRemoveLock(TemplateLun->DeviceObject, SpInquireLogicalUnit);
    SpWaitForRemoveLock(TemplateLun->DeviceObject, SP_BASE_REMOVE_LOCK);

    //
    // Save the address away and then remove the template object from the
    // logical unit list.
    //

    pathId = TemplateLun->PathId;
    targetId = TemplateLun->TargetId;
    lun = TemplateLun->Lun;

    SpClearLogicalUnitAddress(TemplateLun);

    //
    // Before creating a named object, preallocate any resources we'll need
    // that SpCreateLogicalUnit doesn't provide.
    //

    if(TemplateLun->SerialNumber.Length != 0) {
        serialNumberLength = (TemplateLun->SerialNumber.Length +
                              sizeof(UNICODE_NULL));

        serialNumber = SpAllocatePool(PagedPool,
                                      serialNumberLength,
                                      SCSIPORT_TAG_ID_BUFFER,
                                      TemplateLun->DeviceObject->DriverObject);

        if(serialNumber == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if(TemplateLun->DeviceIdentifierPageLength != 0) {

        identifier = SpAllocatePool(
                        PagedPool,
                        TemplateLun->DeviceIdentifierPageLength,
                        SCSIPORT_TAG_ID_BUFFER,
                        TemplateLun->DeviceObject->DriverObject);

        if(identifier == NULL) {

            if(serialNumber != NULL) {
                ExFreePool(serialNumber);
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // If the lun is scsi-1 or if the magic registry flag was set then use the 
    // scsi 1 dispatch table for this device.
    //

    if((driverExtension->BusType == BusTypeScsi) && 
       ((InquiryData->ANSIVersion == 0) || 
        (InquiryData->ANSIVersion == 1) ||
        (TemplateLun->SpecialFlags.SetLunInCdb))) {
        scsi1 = TRUE;
    } else {
        scsi1 = FALSE;
    }

    //
    // Now create a new logical unit with the same address.
    //

    status = SpCreateLogicalUnit(adapter,
                                 pathId,
                                 targetId,
                                 lun,
                                 FALSE,
                                 scsi1,
                                 &newLun);

    if(!NT_SUCCESS(status)) {
        if(serialNumber != NULL) {
            ExFreePool(serialNumber);
        }
        if(identifier) {
            ExFreePool(identifier);
        }
        return status;
    }

    //
    // Copy the important information from the template logical unit over to
    // the new one.  Zero out the original so that we know to reallocate one
    // later.
    //

    newLun->HwLogicalUnitExtension = TemplateLun->HwLogicalUnitExtension;

    TemplateLun->HwLogicalUnitExtension = NULL;

    newLun->LuFlags = TemplateLun->LuFlags;
    newLun->IsVisible = TemplateLun->IsVisible;
    newLun->TargetLunList = TemplateLun->TargetLunList;
    newLun->SpecialFlags = TemplateLun->SpecialFlags;

    newLun->NeedsVerification = TemplateLun->NeedsVerification;

    newLun->CommonExtension.SrbFlags = TemplateLun->CommonExtension.SrbFlags;

    //
    // Copy over any characteristics flags which were set during enumeration.
    //

    newLun->DeviceObject->Characteristics |=
        (TemplateLun->DeviceObject->Characteristics & FILE_REMOVABLE_MEDIA);

    //
    // Copy the list of supported vital product data pages.
    //

    newLun->DeviceIdentifierPageSupported = TemplateLun->DeviceIdentifierPageSupported;
    newLun->SerialNumberPageSupported = TemplateLun->SerialNumberPageSupported;

    //
    // If this device reports a serial number in it's vital product data then
    // copy it in to the new lun.
    //

    if(serialNumber != NULL) {
        newLun->SerialNumber.Length = TemplateLun->SerialNumber.Length;
        newLun->SerialNumber.MaximumLength = serialNumberLength;
        newLun->SerialNumber.Buffer = serialNumber;
        RtlCopyMemory(newLun->SerialNumber.Buffer,
                      TemplateLun->SerialNumber.Buffer,
                      serialNumberLength);
    }

    //
    // If this has a device identifier page then copy it over two.
    //

    if(identifier != NULL) {
        newLun->DeviceIdentifierPage = identifier;
        newLun->DeviceIdentifierPageLength =
            TemplateLun->DeviceIdentifierPageLength;

        RtlCopyMemory(newLun->DeviceIdentifierPage,
                      TemplateLun->DeviceIdentifierPage,
                      newLun->DeviceIdentifierPageLength);
    }

    //
    // Copy the inquiry data over.
    //

    ASSERT(InquiryDataSize <= sizeof(INQUIRYDATA));
    RtlCopyMemory(&(newLun->InquiryData), InquiryData, InquiryDataSize);

    //
    // Acquire the appropriate remove locks on the new logical unit.
    //

    SpAcquireRemoveLock(newLun->DeviceObject, SP_BASE_REMOVE_LOCK);
    SpAcquireRemoveLock(newLun->DeviceObject, SpInquireLogicalUnit);

    //
    // Now insert this new lun into the logical unit list.
    //

    SpSetLogicalUnitAddress(newLun, pathId, targetId, lun);

    *NewLun = newLun;

    return status;
}


NTSTATUS
SpPrepareLogicalUnitForReuse(
    PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    PADAPTER_EXTENSION adapter = LogicalUnit->AdapterExtension;
    PCOMMON_EXTENSION commonExtension = &(LogicalUnit->CommonExtension);

    PVOID hwExtension = NULL;

    NTSTATUS status;

    ASSERT_PDO(LogicalUnit->DeviceObject);

    ASSERT(LogicalUnit->CommonExtension.WmiInitialized == FALSE);
    ASSERT(LogicalUnit->CommonExtension.WmiScsiPortRegInfoBuf == NULL);
    ASSERT(LogicalUnit->CommonExtension.WmiScsiPortRegInfoBufSize == 0);

    //
    // Clear the remove lock event.
    //

    ASSERT(LogicalUnit->CommonExtension.RemoveLock == 0);

    //
    // Initialize the remove lock event.
    //

    KeClearEvent(&(LogicalUnit->CommonExtension.RemoveEvent));

    LogicalUnit->PathId = 0xff;
    LogicalUnit->TargetId = 0xff;
    LogicalUnit->Lun = 0xff;

    //
    // Round the size of the Hardware logical extension to the size of a
    // PVOID and add it to the port driver's logical extension.
    //

    if((LogicalUnit->HwLogicalUnitExtension == NULL) &&
       (adapter->HwLogicalUnitExtensionSize != 0)) {
        hwExtension = SpAllocatePool(NonPagedPoolCacheAligned,
                                     adapter->HwLogicalUnitExtensionSize,
                                     SCSIPORT_TAG_LUN_EXT,
                                     LogicalUnit->DeviceObject->DriverObject);

        if(hwExtension == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        LogicalUnit->HwLogicalUnitExtension = hwExtension;
    }

    if(LogicalUnit->HwLogicalUnitExtension != NULL) {
        RtlZeroMemory(LogicalUnit->HwLogicalUnitExtension,
                      adapter->HwLogicalUnitExtensionSize);
    }

    LogicalUnit->IsMissing = FALSE;
    LogicalUnit->IsVisible = FALSE;

    ASSERT(LogicalUnit->IsEnumerated == FALSE);

    //
    // Device has no longer been removed.
    //

    LogicalUnit->CommonExtension.IsRemoved = NO_REMOVE;

    //
    // Clear cached infomation about the device identifier(s).
    //

    LogicalUnit->DeviceIdentifierPageSupported = FALSE;
    LogicalUnit->SerialNumberPageSupported = FALSE;

    RtlZeroMemory(LogicalUnit->SerialNumber.Buffer,
                  LogicalUnit->SerialNumber.MaximumLength);
    LogicalUnit->SerialNumber.Length = 0;

    return STATUS_SUCCESS;
}


BOOLEAN
FASTCALL
SpCompareInquiryData(
    IN PUCHAR InquiryData1,
    IN PUCHAR InquiryData2
    )

/*++

Routine Description:

    This routine compares two sets of inquiry data for equality.

Arguments:

    InquiryData1 - Supplies a pointer to the first inquiry data to compare.

    InquiryData2 - Supplies a pointer to the second inquiry data to compare.

Return Value:

    TRUE if the supplied inquiry data sets match, else FALSE.

--*/

{
    BOOLEAN match;
    UCHAR save1; 
    UCHAR save2;

    PAGED_CODE();

    if (((PINQUIRYDATA)InquiryData1)->ANSIVersion == 3) {

        //
        // SCSI3 Specific:
        // Save bytes 6 and 7.  These bytes contain vendor specific bits which
        // we're going to exclude from the comparison by just setting them equal 
        // to the corresponding bits in InquiryData2.  We'll restore them after 
        // the comparison.
        //

        save1 = InquiryData1[6];
        save2 = InquiryData1[7];

        //
        // Force the vendor specific bits in InquiryData1 to match the
        // corresponsing bits in InquiryData2.
        //

        InquiryData1[6] &= ~0x20;
        InquiryData1[7] &= ~0x01;
        InquiryData1[6] |= (InquiryData2[6] & 0x20);
        InquiryData1[7] |= (InquiryData2[7] & 0x01);
    }
    
    //
    // Compare the entire inquiry data blob.
    //

    match = RtlEqualMemory((((PUCHAR) InquiryData1) + 1), 
                           (((PUCHAR) InquiryData2) + 1), 
                           (INQUIRYDATABUFFERSIZE - 1));

    if (((PINQUIRYDATA)InquiryData1)->ANSIVersion == 3) {

        //
        // SCSI3 Specific:
        // Restore bytes 6 and 7 to their original state.
        //

        InquiryData1[6] = save1;
        InquiryData1[7] = save2;
    }

    return match;
}

NTSTATUS
SpInquireLogicalUnit(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN BOOLEAN ExposeDisconnectedLuns,
    IN OPTIONAL PLOGICAL_UNIT_EXTENSION RescanLun,
    OUT PLOGICAL_UNIT_EXTENSION *LogicalUnit,
    OUT PBOOLEAN CheckNextLun
    )

/*++

Routine Description:

    This routine will issue an inquiry to the logical unit at the specified
    address.  If there is not already a device object allocated for that
    logical unit, it will create one.  If it turns out the device does not
    exist, the logical unit can be destroyed before returning.

    If the logical unit exists, this routine will clear the PD_RESCAN_ACTIVE
    flag in the LuFlags to indicate that the unit is safe.

    If it does not respond, the IsMissing flag will be set to indicate that the
    unit should not be reported during enumeration.  If the IsRemoved flag has
    already been set on the logical unit extension, the device object will be
    destroyed.  Otherwise the device object will not be destroyed until a
    remove can be issued.

Arguments:

    Adapter - the adapter which this device would exist on

    PathId, TargetId, Lun - the address of the lun to inquire.

    ExposeDisconnectedLuns - indicates whether luns with a qualifier of
                             disconnected should be instantiated.

    RescanLun - a pointer to the logical unit extension to be used when
                checking logical unit numbers which do not currently have an
                extension associated with them.

    LogicalUnit - the logical unit created for this address - valid if
                  success is returned.

    CheckNextLun - indicates whether the caller should check the next
                   address for a logical unit.

Return Value:

    STATUS_NO_SUCH_DEVICE if the device does not exist.

    STATUS_SUCCESS if the device does exist.

    error description otherwise.

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    INQUIRYDATA inquiryData;

    BOOLEAN newDevice = FALSE;
    BOOLEAN deviceMismatch = FALSE;

    UCHAR bytesReturned;

    NTSTATUS status;

    *LogicalUnit = NULL;
    *CheckNextLun = TRUE;

    PAGED_CODE();

    ASSERT(TargetId != BreakOnTarget);

    //
    // Find or create the device object for this address.  if it exists we'll
    // grab a temporary lock (using SpInquireLogicalUnit as a tag).
    //

    logicalUnit = GetLogicalUnitExtension(Adapter,
                                          PathId,
                                          TargetId,
                                          Lun,
                                          SpInquireLogicalUnit,
                                          TRUE);

    if(logicalUnit == NULL) {

        if(!ARGUMENT_PRESENT(RescanLun)) {

            //
            // No RescanLun was provided (generally means we're low on memory).
            // Don't scan this logical unit.
            //

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ASSERT(RescanLun->IsTemporary == TRUE);

        //
        // Acquire the temporary lock for the rescan lun.  We also grab the
        // base lock here.
        //

        SpAcquireRemoveLock(RescanLun->DeviceObject, SP_BASE_REMOVE_LOCK);
        SpAcquireRemoveLock(RescanLun->DeviceObject, SpInquireLogicalUnit);

        //
        // Set the address of the RescanLun appropriately - this operation
        // will make the logical unit available for our use.
        //

        SpSetLogicalUnitAddress(RescanLun, PathId, TargetId, Lun);

        logicalUnit = RescanLun;
        newDevice = TRUE;

    } else {
        ASSERT(logicalUnit->IsTemporary == FALSE);

        if(logicalUnit->IsMissing) {

            DebugPrint((1, "SpInquireLogicalUnit: logical unit @ (%d,%d,%d) "
                           "(%#p) is marked as missing and will not be "
                           "rescanned\n",
                           PathId, TargetId, Lun,
                           logicalUnit->DeviceObject));

            SpReleaseRemoveLock(logicalUnit->DeviceObject, SpInquireLogicalUnit);

            return STATUS_DEVICE_DOES_NOT_EXIST;
        }
    }

    //
    // Issue an inquiry to the potential logical unit.
    //

    DebugPrint((2, "SpInquireTarget: Try %s device @ Bus %d, Target %d, "
                   "Lun %d\n",
                   (newDevice ? "new" : "existing"),
                   PathId,
                   TargetId,
                   Lun));

    status = IssueInquiry(logicalUnit, FALSE, 0, &inquiryData, &bytesReturned);

    //
    // If the inquiry succeeds then check the data returned to determine if
    // there's a device there we should expose.
    //

    if(NT_SUCCESS(status)) {

        UCHAR qualifier;
        BOOLEAN present = FALSE;

        //
        // Check in the registry for special device flags for this lun.
        // If this is disconnected then set the qualifier to be 0 so that we
        // use the normal hardware ids instead of the "disconnected" ones.
        //

        qualifier = inquiryData.DeviceTypeQualifier;

        SpCheckSpecialDeviceFlags(logicalUnit, &(inquiryData));

        //
        // The inquiry was successful.  Determine whether a device is present.
        //

        switch(qualifier) {
            case DEVICE_QUALIFIER_ACTIVE: {

                //
                // Active devices are always present.
                //

                present = TRUE;
                break;
            }

            case DEVICE_QUALIFIER_NOT_ACTIVE: {

                if (Lun == 0) { 
                    //
                    // If we're using REPORT_LUNS commands for LUN 0 of a target
                    // then we should always indicate that LUN 0 is present.
                    //

                    if ((inquiryData.HiSupport == TRUE) ||
                        (logicalUnit->SpecialFlags.LargeLuns == TRUE)) {
                        present = TRUE;
                    }
                } else {
                    //
                    // Expose inactive luns only if the caller has requested that
                    // we do so.
                    //

                    present = ExposeDisconnectedLuns;
                }
                
                break;
            }

            case DEVICE_QUALIFIER_NOT_SUPPORTED: {
                present = FALSE;
                break;
            }

            default: {
                present = TRUE;
                break;
            }
        };

        if(present == FALSE) {

            //
            // setup an error value so we'll clean up the logical unit.
            // No need to do any more processing in this case.
            //

            status =  STATUS_NO_SUCH_DEVICE;

        } else if(newDevice == FALSE) {

            //
            // Verify that the inquiry data hasn't changed since the last time
            // we did a rescan.  Ignore the device type qualifier in this
            // check.
            //

            deviceMismatch = FALSE;

            if(inquiryData.DeviceType != logicalUnit->InquiryData.DeviceType) {

                DebugPrint((1, "SpInquireTarget: Found different type of "
                               "device @ (%d,%d,%d)\n",
                            PathId,
                            TargetId,
                            Lun));

                deviceMismatch = TRUE;
                status = STATUS_NO_SUCH_DEVICE;

            } else if(inquiryData.DeviceTypeQualifier !=
                      logicalUnit->InquiryData.DeviceTypeQualifier) {

                //
                // The device qualifiers don't match.  This isn't necessarily
                // a device mismatch if the existing device just went offline.
                // lower down we'll check the remaining inquiry data to
                // ensure that the LUN hasn't changed.
                //

                DebugPrint((1, "SpInquireLogicalUnit: Device @ (%d,%d,%d) type "
                               "qualifier was %d is now %d\n",
                            PathId,
                            TargetId,
                            Lun,
                            logicalUnit->InquiryData.DeviceTypeQualifier,
                            inquiryData.DeviceTypeQualifier
                            ));

                //
                // If the device was offline but no longer is then we
                // treat this as a device mismatch.  If the device has gone
                // offline then we pretend it's the same device.
                //
                // the goal is to provide PNP with a new device object when
                // bringing a device online, but to reuse the same device
                // object when bringing the device offline.
                //

                if(logicalUnit->InquiryData.DeviceTypeQualifier ==
                   DEVICE_QUALIFIER_NOT_ACTIVE) {

                    DebugPrint((1, "SpInquireLogicalUnit: device mismatch\n"));
                    deviceMismatch = TRUE;
                    status = STATUS_NO_SUCH_DEVICE;

                } else {

                    DebugPrint((1, "SpInquireLogicalUnit: device went offline\n"));
                    deviceMismatch = FALSE;
                    status = STATUS_SUCCESS;
                }
            }

            if (deviceMismatch == FALSE) {

                //
                // Ok, the device type and qualifier are compatible.  Now we
                // need to compare all applicable parts of the inquiry
                // data with the data we already have on the device at this
                // address to see if the device that answered this time is the
                // same one we found last time.
                //

                BOOLEAN same = SpCompareInquiryData(
                                   (PUCHAR)&(inquiryData),
                                   (PUCHAR)&(logicalUnit->InquiryData));

                if (same == FALSE) {

                    //
                    // Despite the fact that the device type & qualifier are
                    // compatible, a mismatch still occurred.
                    //

                    deviceMismatch = TRUE;
                    status = STATUS_NO_SUCH_DEVICE;

                    DebugPrint((1, "SpInquireLogicalUnit: Device @ (%d,%d,%d) has "
                                   "changed\n",
                                PathId,
                                TargetId,
                                Lun));
                } else {

                    //
                    // The device that answered is the same one we found
                    // earlier.  Depending on the SCSI version of the device, 
                    // we might need to update the vendor specific portions of
                    // the existing inquiry data for this device.
                    //
                    
                    if (inquiryData.ANSIVersion == 3) {

                        //
                        // For SCSI 3 devices, bytes 6 and 7 contain vendor
                        // specific bits that may differ between bus scans.
                        // Update these bytes of the existing inquiry data.
                        // 

                        ((PUCHAR)&(logicalUnit->InquiryData))[6] = 
                            ((PUCHAR)&(inquiryData))[6];
                        ((PUCHAR)&(logicalUnit->InquiryData))[7] = 
                            ((PUCHAR)&(inquiryData))[7];
                    }
                }
            }

        } else {

            DebugPrint((1, "SpInquireTarget: Found new %sDevice at address "
                           "(%d,%d,%d)\n",
                           (inquiryData.RemovableMedia ? "Removable " : ""),
                           PathId,
                           TargetId,
                           Lun));


        }

        if(NT_SUCCESS(status) && (deviceMismatch == FALSE)) {

            deviceMismatch = SpGetDeviceIdentifiers(logicalUnit, newDevice);

            if(deviceMismatch == FALSE) {
                ASSERT(newDevice);
                status = STATUS_NO_SUCH_DEVICE;
            }
        }

    } else {
        *CheckNextLun = FALSE;
    }

    if(!NT_SUCCESS(status)) {

        //
        // Nothing was found at this address. If it's a new lun which hasn't
        // been enumerated yet then just destroy it here.  If, however, it
        // has been enumerated we have to mark it as missing and wait for
        // PNP to learn that it's gone and ask us to remove it.  Then we can
        // destroy it.
        //
        // If we were just using the RescanLun to check this address then do
        // nothing - the rescan lun will be reset down below.
        //

        logicalUnit->IsMissing = TRUE;

        if(newDevice) {

            //
            // Release the temporary lock.  the base one will be released at
            // the end of this routine.
            //

            SpReleaseRemoveLock(logicalUnit->DeviceObject,
                                SpInquireLogicalUnit);
            logicalUnit = NULL;

        } else if (logicalUnit->IsEnumerated == FALSE) {

            //
            // It's safe to destroy this device object ourself since it's not
            // a device PNP is aware of.  However we may have outstanding i/o
            // due to pass-through requests or legacy class driver so we need
            // to properly wait for all i/o to complete.
            //

            logicalUnit->CommonExtension.CurrentPnpState =
                IRP_MN_REMOVE_DEVICE;

            SpReleaseRemoveLock(logicalUnit->DeviceObject, SpInquireLogicalUnit);

            //
            // Mark this device temporarily as visible so that
            // SpRemoveLogicalUnit will do the right thing.  Since the rescan
            // active bit is set the enumeration code won't return this device.
            //

            logicalUnit->IsVisible = TRUE;

            ASSERT(logicalUnit->IsEnumerated == FALSE);
            ASSERT(logicalUnit->IsMissing == TRUE);
            ASSERT(logicalUnit->IsVisible == TRUE);

            SpRemoveLogicalUnit(logicalUnit, IRP_MN_REMOVE_DEVICE);

            if(deviceMismatch) {

                //
                // Call this routine again.  This is the only recursion and
                // since we've deleted the device object there should be no
                // cause for a mismatch there.
                //

                status = SpInquireLogicalUnit(Adapter,
                                         PathId,
                                         TargetId,
                                         Lun,
                                         ExposeDisconnectedLuns,
                                         RescanLun,
                                         LogicalUnit,
                                         CheckNextLun);
            }

            return status;

        } else {

            //
            // CODEWORK - freeze and flush the queue.  This way we don't need
            // to deal with handling get next request calls
            //

            //
            // Mark the device as being mismatched so that it's destruction
            // will cause us to rescan the bus (and pickup the new device).
            //

            if(deviceMismatch) {
                logicalUnit->IsMismatched = TRUE;
            }
        }

    } else {

        logicalUnit->IsMissing = FALSE;

        if(newDevice) {

            status = SpCloneAndSwapLogicalUnit(logicalUnit,
                                               &(inquiryData),
                                               bytesReturned,
                                               &logicalUnit);

            if(!NT_SUCCESS(status)) {
                logicalUnit = NULL;
            }

            ASSERT(logicalUnit != RescanLun);

            //
            // Clear the new device flag so we don't attempt to clear the
            // address of the RescanLun down below.
            //

            newDevice = FALSE;

        } else {

            //
            // Update the state of the device and the device map entry if
            // necessary.
            //

            if(logicalUnit->InquiryData.DeviceTypeQualifier !=
               inquiryData.DeviceTypeQualifier) {

                logicalUnit->InquiryData.DeviceTypeQualifier =
                    inquiryData.DeviceTypeQualifier;

                SpUpdateLogicalUnitDeviceMapEntry(logicalUnit);
            }
        }

        if(logicalUnit != NULL) {

            if(logicalUnit->InquiryData.DeviceTypeQualifier ==
               DEVICE_QUALIFIER_NOT_ACTIVE) {
                logicalUnit->IsVisible = FALSE;

                //
                // Scsiport won't create a device-map entry for this device since
                // it's never been exposed to PNP (and definately won't be now).
                // Create one here.  If the init-device routine tries to generate
                // one later on down the road it will deal with this case just fine.
                //

                SpBuildDeviceMapEntry(&(logicalUnit->CommonExtension));
            } else {
                logicalUnit->IsVisible = TRUE;
            }

            if(inquiryData.RemovableMedia) {
                SET_FLAG(logicalUnit->DeviceObject->Characteristics,
                         FILE_REMOVABLE_MEDIA);
            }

            ASSERT(logicalUnit->IsTemporary != TRUE);
        }

        *LogicalUnit = logicalUnit;
    }

    //
    // If this was a new device then clean up the RescanLun.
    //

    if(newDevice) {
        SpWaitForRemoveLock(RescanLun->DeviceObject, SP_BASE_REMOVE_LOCK);
        SpClearLogicalUnitAddress(RescanLun);
    }

    if(logicalUnit) {
        ASSERT(logicalUnit != RescanLun);
        SpReleaseRemoveLock(logicalUnit->DeviceObject, SpInquireLogicalUnit);
    }

    return status;
}


NTSTATUS
SpSendSrbSynchronous(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OPTIONAL PIRP Irp,
    IN OPTIONAL PMDL Mdl,
    IN PVOID DataBuffer,
    IN ULONG TransferLength,
    IN OPTIONAL PVOID SenseInfoBuffer,
    IN OPTIONAL UCHAR SenseInfoBufferLength,
    OUT PULONG BytesReturned
    )
{
    KEVENT event;

    BOOLEAN irpAllocated = FALSE;
    BOOLEAN mdlAllocated = FALSE;

    PIO_STACK_LOCATION irpStack;

    PSENSE_DATA senseInfo = SenseInfoBuffer;

    ULONG retryCount = 0;

    NTSTATUS status;

SendSrbSynchronousRetry:

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // If the caller provided an IRP we'll use it - if not we allocate one
    // here.
    //

    if(!ARGUMENT_PRESENT(Irp)) {

        Irp = SpAllocateIrp(LogicalUnit->DeviceObject->StackSize, 
                            FALSE, 
                            LogicalUnit->DeviceObject->DriverObject);

        if(Irp == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        irpAllocated = TRUE;
    }

    if(ARGUMENT_PRESENT(DataBuffer)) {
        ASSERT(TransferLength != 0);

        if(!ARGUMENT_PRESENT(Mdl)) {

            Mdl = SpAllocateMdl(DataBuffer,
                                TransferLength,
                                FALSE,
                                FALSE,
                                NULL,
                                LogicalUnit->DeviceObject->DriverObject);

            if(Mdl == NULL) {
                IoFreeIrp(Irp);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            MmBuildMdlForNonPagedPool(Mdl);
        }

        Irp->MdlAddress = Mdl;
    } else {
        ASSERT(TransferLength == 0);
        ASSERT(!ARGUMENT_PRESENT(Mdl));
    }

    irpStack = IoGetNextIrpStackLocation(Irp);

    //
    // Mark the minor function to indicate that this is an internal scsiport
    // request and that the start state of the device can be ignored.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    irpStack->Parameters.Scsi.Srb = Srb;

    Srb->SrbStatus = Srb->ScsiStatus = 0;

    Srb->OriginalRequest = Irp;

    //
    // Enable auto request sense.
    //

    if(ARGUMENT_PRESENT(SenseInfoBuffer)) {
        Srb->SenseInfoBuffer = SenseInfoBuffer;
        Srb->SenseInfoBufferLength = SenseInfoBufferLength;
    } else {
        Srb->SenseInfoBuffer = NULL;
        Srb->SenseInfoBufferLength = 0;
        SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE);
    }

    if(ARGUMENT_PRESENT(Mdl)) {
        Srb->DataBuffer = MmGetMdlVirtualAddress(Mdl);
        Srb->DataTransferLength = TransferLength;
    } else {
        Srb->DataBuffer = NULL;
        Srb->DataTransferLength = 0;
    }

    //
    // Call port driver to handle this request.
    //

    IoSetCompletionRoutine(Irp,
                           SpSignalCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    KeEnterCriticalRegion();

    status = IoCallDriver(LogicalUnit->DeviceObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = Irp->IoStatus.Status;

    *BytesReturned = (ULONG) Irp->IoStatus.Information;

    if(Srb->SrbStatus == SRB_STATUS_PENDING) {

        //
        // Request was never even issued to the controller.
        //

        ASSERT(!NT_SUCCESS(status));

    } else if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        DebugPrint((2,"SpSendSrbSynchronous: Command failed SRB status %x\n",
                    Srb->SrbStatus));

        //
        // Unfreeze queue if necessary
        //

        if (Srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

            DebugPrint((3, "SpSendSrbSynchronous: Unfreeze Queue TID %d\n",
                Srb->TargetId));

            LogicalUnit->LuFlags &= ~LU_QUEUE_FROZEN;

            GetNextLuRequestWithoutLock(LogicalUnit);
        }

        //
        // NOTE: if INQUIRY fails with a data underrun,
        //      indicate success and let the class drivers
        //      determine whether the inquiry information
        //      is useful.
        //

        if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

            //
            // Copy INQUIRY buffer to LUNINFO.
            //

            DebugPrint((1,"SpSendSrbSynchronous: Data underrun at TID %d\n",
                        LogicalUnit->TargetId));

            status = STATUS_SUCCESS;

        } else if ((Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                   (senseInfo->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST)) {

             //
             // A sense key of illegal request was recieved.  This indicates
             // that the logical unit number of not valid but there is a
             // target device out there.
             //

             status = STATUS_INVALID_DEVICE_REQUEST;

        } else {
            //
            // If the selection did not time out then retry the request.
            //

            if ((SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SELECTION_TIMEOUT) &&
                (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_NO_DEVICE) &&
                (retryCount++ < INQUIRY_RETRY_COUNT)) {

                DebugPrint((2,"SpSendSrbSynchronous: Retry %d\n", retryCount));
                KeLeaveCriticalRegion();
                goto SendSrbSynchronousRetry;
            }

            status = SpTranslateScsiStatus(Srb);
        }

    } else {

        status = STATUS_SUCCESS;
    }

    KeLeaveCriticalRegion();

    return status;
}

NTSTATUS
IssueInquiry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN EnableVitalProductData,
    IN UCHAR PageCode,
    OUT PVOID InquiryData,
    OUT PUCHAR BytesReturned
    )

/*++

Routine Description:

    Build IRP, SRB and CDB for SCSI INQUIRY command.

    This routine MUST be called while holding the enumeration lock.

Arguments:

    LogicalUnit - address of the logical unit extension

    EnableVitalProductData - indicates whether the EVPD bit should be set in 
                             the inquiry data causing the LUN to return product
                             data pages (specified by page code below) rather
                             than the standard inquiry data.

    PageCode - which VPD page to retrieve

    InquiryData - the location to store the inquiry data for the LUN.

    BytesReturned - the number of bytes of inquiry data returned.


Return Value:

    NTSTATUS

--*/

{
    PIRP irp;
    SCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    PVOID dataBuffer;
    PSENSE_DATA senseInfoBuffer;

    UCHAR allocationLength;
    ULONG bytesReturned;

    NTSTATUS status;

    PAGED_CODE();

    dataBuffer = LogicalUnit->AdapterExtension->InquiryBuffer;
    senseInfoBuffer = LogicalUnit->AdapterExtension->InquirySenseBuffer;

    ASSERT(dataBuffer != NULL);
    ASSERT(senseInfoBuffer != NULL);

    irp = LogicalUnit->AdapterExtension->InquiryIrp;

    IoInitializeIrp(irp,
                    IoSizeOfIrp(INQUIRY_STACK_LOCATIONS),
                    INQUIRY_STACK_LOCATIONS);

    //
    // Fill in SRB fields.
    //

    RtlZeroMemory(dataBuffer, SP_INQUIRY_BUFFER_SIZE);
    RtlZeroMemory(senseInfoBuffer, SENSE_BUFFER_SIZE);
    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb.Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //

    srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    srb.TimeOutValue = LogicalUnit->AdapterExtension->SrbTimeout;

    srb.CdbLength = 6;

    cdb = (PCDB)srb.Cdb;

    //
    // Set CDB operation code.
    //

    cdb->CDB6INQUIRY3.OperationCode = SCSIOP_INQUIRY;

    //
    // Set allocation length to inquiry data buffer size.
    //

    if(EnableVitalProductData) {
        allocationLength = VPD_MAX_BUFFER_SIZE;
    } else {
        allocationLength = INQUIRYDATABUFFERSIZE;
    }

    cdb->CDB6INQUIRY3.AllocationLength = allocationLength;

    cdb->CDB6INQUIRY3.EnableVitalProductData = TEST(EnableVitalProductData);

    if(EnableVitalProductData == FALSE) {
        ASSERT(PageCode == 0);
    }

    cdb->CDB6INQUIRY3.PageCode = PageCode;

    status = SpSendSrbSynchronous(LogicalUnit,
                                  &srb,
                                  irp,
                                  LogicalUnit->AdapterExtension->InquiryMdl,
                                  dataBuffer,
                                  allocationLength,
                                  senseInfoBuffer,
                                  SENSE_BUFFER_SIZE,
                                  &bytesReturned
                                  );

    ASSERT(bytesReturned <= allocationLength);

    //
    // Return the inquiry data for the device if the call was successful.
    // Otherwise cleanup.
    //

    if(NT_SUCCESS(status)) {

        //
        // If the caller passed in the inquiry buffer then don't bother to copy
        // the data.
        //

        if(InquiryData != dataBuffer) {
            RtlCopyMemory(InquiryData, dataBuffer, bytesReturned);
        }
        *BytesReturned = (UCHAR) bytesReturned;
    } else if(BreakOnMissingLun) {
       ASSERT(LogicalUnit->IsTemporary == TRUE);
    }
    return status;
}


BOOLEAN
SpGetDeviceIdentifiers(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN NewDevice
    )
/*++

Routine Description:

    This routine retreives the device identifiers supported by the logical
    unit in question and compares them to the ones (if any) which are currently
    saved in the LogicalUnit extension.  If they do not match this routine
    will return false to indicate a device mismatch.

    As a side effect this routine will save the serial numbers for new devices
    in the logical unit extension, as well as a list of the supported vital
    product data pages.

Arguments:

    LogicalUnit - the logical unit being prodded.

    NewDevice - whether this device has been prodded before or not.  If it has
                not been then the list of supported EVPD pages will need to be
                retreived.

Return Value:

    TRUE if the data retrieved matches the data which was stored in the
         logical unit extension (TRUE is always returned for a new device).

    FALSE otherwise.
--*/
{
    PVOID buffer = LogicalUnit->AdapterExtension->InquiryBuffer;

    UCHAR bytesReturned;

    NTSTATUS status;

    PAGED_CODE();

    //
    // If this is a new device or if the existing device supports the
    // device identifier page, then get the list of supported VPD pages 
    // and process it.
    //

    if (NewDevice || LogicalUnit->DeviceIdentifierPageSupported) {
        PVPD_SUPPORTED_PAGES_PAGE supportedPages = buffer;
        UCHAR i;

        //
        // If this device is a known non-compliant device that does not support
        // VPD 0x00 but does support VPDs 0x80 and/or 0x83, bypass the INQUIRY
        // and just indicate that the LU does support the other VPDs based on
        // the special flags.
        //

        if (LogicalUnit->SpecialFlags.NonStandardVPD == 0) {

            status = IssueInquiry(LogicalUnit,
                                  TRUE,
                                  VPD_SUPPORTED_PAGES,
                                  buffer,
                                  &bytesReturned);

            if(!NT_SUCCESS(status)) {
                return TRUE;
            }

            if(bytesReturned < sizeof(VPD_SUPPORTED_PAGES_PAGE)) {
                
                //
                // If the device didn't return enough data to include any pages
                // then we're done.
                //
                
                return TRUE;
            }

            for (i = 0; i < supportedPages->PageLength; i++) {

                switch (supportedPages->SupportedPageList[i]) {

                   case VPD_SERIAL_NUMBER: 
                       if (NewDevice) {
                           LogicalUnit->SerialNumberPageSupported = TRUE;
                       }
                       break;

                   case VPD_DEVICE_IDENTIFIERS: 
                       LogicalUnit->DeviceIdentifierPageSupported = TRUE;
                       break;

                   default: 
                       break;
                }
            }

        } else {

            ULONG vpdFlags = LogicalUnit->SpecialFlags.NonStandardVPD;

            //
            // This is one of the devices that does not support VPD 0x00 but
            // does support one or more of the other VPD pages.
            //

            LogicalUnit->SerialNumberPageSupported = 
                (vpdFlags & NON_STANDARD_VPD_SUPPORTS_PAGE80) ? TRUE : FALSE;
            
            LogicalUnit->DeviceIdentifierPageSupported = 
                (vpdFlags & NON_STANDARD_VPD_SUPPORTS_PAGE83) ? TRUE : FALSE;
        }
    }

    //
    // If this device supports the serial number page then retrieve it,
    // convert it into an ansi string, and compare it to the one previously
    // retreived (if there was a previous attempt).
    //

    if(LogicalUnit->SerialNumberPageSupported) {
        PVPD_SERIAL_NUMBER_PAGE serialNumberPage = buffer;
        ANSI_STRING serialNumber;

        status = IssueInquiry(LogicalUnit,
                              TRUE,
                              VPD_SERIAL_NUMBER,
                              serialNumberPage,
                              &bytesReturned);

        if(!NT_SUCCESS(status)) {

            DebugPrint((0, "SpGetDeviceIdentifiers: Error %#08lx retreiving "
                           "serial number page from lun %#p\n",
                        status, LogicalUnit));

            //
            // We can't get the serial number - give this device the benefit
            // of the doubt.
            //

            return TRUE;
        }

        //
        // Fix for bug #143313:
        // On rare occasions, junk appears to get copied into the serial
        // number buffer.  This causes us problems because the junk is 
        // interpreted as part of the serial number.  When we compare the
        // string containing junk to a previously acquired serial number, the
        // comparison fails.  In an effort to fix, I'll zero out all bytes
        // in the buffer following the actual serial number.  This will only
        // work if the PageSize reported by the device does NOT include the
        // junk bytes.
        //

        RtlZeroMemory(
            serialNumberPage->SerialNumber + serialNumberPage->PageLength,
            SP_INQUIRY_BUFFER_SIZE - 4 - serialNumberPage->PageLength);

        //
        // If this is a device known to return binary SN data, convert the
        // returned bytes to ascii.  
        //
        // Note: It is assumed that the SN data is numeric.  Any bytes that 
        // cannot be converted to an ASCII hex number, are left alone.
        //

        if (LogicalUnit->SpecialFlags.BinarySN != 0) {
            int i;
            PUCHAR p = serialNumberPage->SerialNumber;
            for (i = 0; i < serialNumberPage->PageLength; i++) {
                if (*p < 0xa) {
                    *p += '0';
                } else if (*p < 0x10) {
                    *p += 'A';
                } else {
                    ASSERT(FALSE && "Data out of range");
                }
                p++;
            }
        }

        //
        // Create a string using the serial number.  The buffer was zeroed
        // before transfer (and is one character longer than the max buffer
        // which can be returned) so the string is null terminated.
        //

        RtlInitAnsiString(&(serialNumber), serialNumberPage->SerialNumber);
        
        if(NewDevice) {

            //
            // A new device will always have a large buffer into which we can
            // copy the string.  The clone & swap process will take care of
            // moving this into a smaller sized buffer.
            //

            ASSERT(LogicalUnit->SerialNumber.MaximumLength != 0);
            ASSERT(LogicalUnit->SerialNumber.Buffer != NULL);

            RtlCopyString(&(LogicalUnit->SerialNumber), &serialNumber);

        } else if(LogicalUnit->SerialNumber.Buffer == NULL &&
                  serialNumber.Length != 0) {

            //
            // ISSUE-2000-25-02-peterwie
            // We didn't previously have a serial number.  Since the device
            // claimed that it supported one it's likely we got an error back
            // when we tried to retreive it.  Since we didn't get back one
            // now it was a transient error (ie. not likely to be a violation
            // of the spec).  Should we assign the serial number to the device
            // here?  Or should we have failed to instantiate a device with
            // a serial number we couldn't retreive?
            //

            ASSERT(FALSE);

        } else if(RtlEqualString(&serialNumber,
                                 &(LogicalUnit->SerialNumber),
                                 FALSE) == FALSE) {
            DebugPrint((1, "SpInquireLogicalUnit: serial number mismatch\n"));
            return FALSE;
        }
    }

    //
    // If this device supports the device identifiers page then read it out.
    // We don't use this page to check for mismatches at the moment, so we
    // just read it out of the device if this is a new device.
    //

    if (LogicalUnit->DeviceIdentifierPageSupported) {

        status = IssueInquiry(LogicalUnit,
                              TRUE,
                              VPD_DEVICE_IDENTIFIERS,
                              buffer,
                              &bytesReturned);

        if(NT_SUCCESS(status)) {

            //
            // Copy the page into the buffer allocated in the template logical
            // unit.  The clone & swap process will take care of moving this
            // into an appropriately sized buffer in the new lun.
            //

            ASSERT(LogicalUnit->DeviceIdentifierPage != NULL);

            RtlCopyMemory(LogicalUnit->DeviceIdentifierPage,
                          buffer,
                          bytesReturned);
            LogicalUnit->DeviceIdentifierPageLength = bytesReturned;
        } else {
            DebugPrint((1, "SpGetDeviceIdentifiers: Error %#08lx retreiving "
                        "serial number page from lun %#p\n",
                        status, LogicalUnit));
            LogicalUnit->DeviceIdentifierPageLength = 0;
        }
    } else {

        LogicalUnit->DeviceIdentifierPageLength = 0;

    }

    return TRUE;
}

PLOGICAL_UNIT_EXTENSION
SpCreateInitiatorLU(
    IN PADAPTER_EXTENSION Adapter,
    IN UCHAR PathId
    )
/*++

Routine Description:

    This routine creates a logical unit to represent the initiator on the bus
    identified by the supplied PathId.  This device will be used to send
    WMI and IOCTL requests to the adapter.

Arguments:

    Adapter   - Pointer to the adapter device extension.

    PathId    - Identifies a particular bus supported by the adapter.

Return Value:

    A pointer to the logical unit extension of the initiator PDO if the
    device is successfully created. 

    NULL otherwise.

--*/
{
    NTSTATUS status;
    PLOGICAL_UNIT_EXTENSION newLun;
    UCHAR targetId;
    UCHAR lun;
    
    //
    // Extract the ID of the initiator device from the array of per-adapter 
    // initiator IDs.
    //
    
    targetId = Adapter->PortConfig->InitiatorBusId[PathId];

    //
    // Set the logical unit number to 0.
    //

    lun = 0;

    //
    // Try to create a logical unit for the initiator.
    //

    status = SpCreateLogicalUnit(Adapter,
                                 PathId,
                                 targetId,
                                 lun,
                                 FALSE,
                                 FALSE,
                                 &newLun);

    if (!NT_SUCCESS(status)) {
        
        newLun = NULL;
        
    } else {

        //
        // Initialize WMI on this initiator LUN.
        //

        ScsiPortInitPdoWmi(newLun);

        //
        // Acquire the appropriate remove locks on the new logical unit.
        //

        SpAcquireRemoveLock(newLun->DeviceObject, SP_BASE_REMOVE_LOCK);

        //
        // Now insert this new lun into the logical unit list.
        //

        SpSetLogicalUnitAddress(newLun, PathId, targetId, lun);
    }

    return newLun;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sbp2port\util.c ===
/*++


Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    util.c

Abstract:

    Utility functions for the SBP-2 port driver

    Author:

    George Chrysanthakopoulos January-1997

Environment:

    Kernel mode

Revision History :

--*/


#include "sbp2port.h"


VOID
AllocateIrpAndIrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRBIRP *Packet
    )
{
    PIRBIRP pkt;


    if (DeviceExtension->Type == SBP2_PDO) {

        *Packet = (PIRBIRP) ExInterlockedPopEntrySList (&DeviceExtension->BusRequestIrpIrbListHead,
                                                        &DeviceExtension->BusRequestLock);

    } else {

        *Packet = NULL;
    }

    if (*Packet == NULL) {

        //
        // run out , allocate a new one
        //

        pkt = ExAllocatePoolWithTag(NonPagedPool,sizeof(IRBIRP),'2pbs');

        if (pkt) {

            pkt->Irb = NULL;
            pkt->Irb = ExAllocatePoolWithTag(NonPagedPool,sizeof(IRB),'2pbs');

            if (!pkt->Irb) {

                ExFreePool(pkt);
                return;
            }

            pkt->Irp = NULL;
            pkt->Irp = IoAllocateIrp(DeviceExtension->LowerDeviceObject->StackSize,FALSE);

            if (!pkt->Irp) {

                ExFreePool(pkt->Irb);
                ExFreePool(pkt);
                return;
            }

            DEBUGPRINT3((
                "Sbp2Port: AllocPkt: %sdo, new irp=x%p, irb=x%p\n",
                (DeviceExtension->Type == SBP2_PDO ? "p" : "f"),
                pkt->Irp,
                pkt->Irb
                ));

        } else {

            return;
        }

        *Packet = pkt;
    }

    pkt = *Packet;
}


VOID
DeAllocateIrpAndIrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRBIRP Packet
    )
{
    if (DeviceExtension->Type == SBP2_PDO) {

        ExInterlockedPushEntrySList (&DeviceExtension->BusRequestIrpIrbListHead,
                                     &Packet->ListPointer,
                                     &DeviceExtension->BusRequestLock);

    } else {

        IoFreeIrp(Packet->Irp);
        ExFreePool(Packet->Irb);
        ExFreePool(Packet);
    }
}


NTSTATUS
AllocateSingle1394Address(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG AccessType,
    IN OUT PADDRESS_CONTEXT Context
    )

/*++

Routine Description:

    A wrapper to the bus driver AllocateAddressRange call, for Async Requests
    or ORB's that dont use callbacks.

Arguments:

    DeviceObject - Sbp2 device object
    Buffer - Data buffer to mapped to 1394 address space
    Length - Size of buffer in bytes
    AccessType - 1394 bus access  to allocated range
    Address - Returned Address, from 1394 address space
    AddressHanle - Handle associated with the 1394 address
    RequestMedl - Mdl associated with this range

Return Value:
    NTSTATUS

--*/

{
    ULONG               finalTransferMode;
    PIRBIRP             packet;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;


    AllocateIrpAndIrb (deviceExtension, &packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    packet->Irb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;
    packet->Irb->Flags = 0;

    packet->Irb->u.AllocateAddressRange.MaxSegmentSize = 0;
    packet->Irb->u.AllocateAddressRange.nLength = Length;
    packet->Irb->u.AllocateAddressRange.fulAccessType = AccessType;
    packet->Irb->u.AllocateAddressRange.fulNotificationOptions = NOTIFY_FLAGS_NEVER;

    packet->Irb->u.AllocateAddressRange.Callback = NULL;
    packet->Irb->u.AllocateAddressRange.Context = NULL;

    packet->Irb->u.AllocateAddressRange.FifoSListHead = NULL;
    packet->Irb->u.AllocateAddressRange.FifoSpinLock = NULL;

    packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_High = 0;
    packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_Low = 0;

    packet->Irb->u.AllocateAddressRange.AddressesReturned = 0;
    packet->Irb->u.AllocateAddressRange.DeviceExtension = deviceExtension;
    packet->Irb->u.AllocateAddressRange.p1394AddressRange = (PADDRESS_RANGE) &Context->Address;

    if (Buffer) {

        packet->Irb->u.AllocateAddressRange.fulFlags = 0;

        Context->RequestMdl = IoAllocateMdl (Buffer, Length, FALSE, FALSE, NULL);

        if (!Context->RequestMdl) {

            DeAllocateIrpAndIrb (deviceExtension,packet);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool (Context->RequestMdl);

        packet->Irb->u.AllocateAddressRange.Mdl = Context->RequestMdl;

    } else {

        packet->Irb->u.AllocateAddressRange.fulFlags =
            ALLOCATE_ADDRESS_FLAGS_USE_COMMON_BUFFER;

        packet->Irb->u.AllocateAddressRange.Mdl = NULL;
    }

    status = Sbp2SendRequest (deviceExtension, packet, SYNC_1394_REQUEST);

    if (NT_SUCCESS(status)) {

        Context->AddressHandle =
            packet->Irb->u.AllocateAddressRange.hAddressRange;
        Context->Address.BusAddress.NodeId =
            deviceExtension->InitiatorAddressId;

        if (!Buffer) {

            //
            // For common buffers we get an mdl *back* from the
            // bus/port driver, & need to retrieve a corresponding VA
            //

            Context->RequestMdl = packet->Irb->u.AllocateAddressRange.Mdl;

            Context->Reserved = MmGetMdlVirtualAddress (Context->RequestMdl);
        }
    }

    DeAllocateIrpAndIrb (deviceExtension, packet);

    return status;
}


NTSTATUS
AllocateAddressForStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PADDRESS_CONTEXT Context,
    IN UCHAR StatusType
    )

/*++

Routine Description:

    A wrapper to 1394 bus IOCTL AllocateAddressRange for status blocks that
    need a Callback notification when the device access the 1394 range...

Arguments:

    DeviceObject - Device Object for the sbp2 driver
    ADDRESS_CONTEXT - Mini Context for an individual 1394 request

Return Value:
    NTSTATUS

--*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIRBIRP packet = NULL;


    AllocateIrpAndIrb (deviceExtension,&packet);

    if (!packet) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    packet->Irb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;
    packet->Irb->Flags = 0;
    packet->Irb->u.AllocateAddressRange.nLength = sizeof(STATUS_FIFO_BLOCK);
    packet->Irb->u.AllocateAddressRange.fulAccessType = ACCESS_FLAGS_TYPE_WRITE;
    packet->Irb->u.AllocateAddressRange.fulNotificationOptions = NOTIFY_FLAGS_AFTER_WRITE;

    packet->Irb->u.AllocateAddressRange.FifoSListHead = NULL;
    packet->Irb->u.AllocateAddressRange.FifoSpinLock = NULL;
    packet->Irb->u.AllocateAddressRange.fulFlags = 0;

    packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_High = 0;
    packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_Low = 0;

    packet->Irb->u.AllocateAddressRange.AddressesReturned = 0;
    packet->Irb->u.AllocateAddressRange.MaxSegmentSize = 0;
    packet->Irb->u.AllocateAddressRange.DeviceExtension = deviceExtension;

    switch (StatusType) {

    case TASK_STATUS_BLOCK:

        packet->Irb->u.AllocateAddressRange.Callback = Sbp2TaskOrbStatusCallback;

        Context->RequestMdl = IoAllocateMdl(&deviceExtension->TaskOrbStatusBlock, sizeof (STATUS_FIFO_BLOCK),FALSE,FALSE,NULL);

        if (!Context->RequestMdl) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitAllocateAddress;
        }

        break;

    case MANAGEMENT_STATUS_BLOCK:

        packet->Irb->u.AllocateAddressRange.Callback = Sbp2ManagementOrbStatusCallback;

        Context->RequestMdl = IoAllocateMdl(&deviceExtension->ManagementOrbStatusBlock, sizeof (STATUS_FIFO_BLOCK),FALSE,FALSE,NULL);

        if (!Context->RequestMdl) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitAllocateAddress;
        }

        break;

    case CMD_ORB_STATUS_BLOCK:

        //
        // setup the FIFO list that will receive the status blocks
        //

        packet->Irb->u.AllocateAddressRange.Callback = Sbp2GlobalStatusCallback;

        Context->RequestMdl = packet->Irb->u.AllocateAddressRange.Mdl = NULL;

        packet->Irb->u.AllocateAddressRange.FifoSListHead = &deviceExtension->StatusFifoListHead;
        packet->Irb->u.AllocateAddressRange.FifoSpinLock = &deviceExtension->StatusFifoLock;

        break;

#if PASSWORD_SUPPORT

    case PASSWORD_STATUS_BLOCK:

        packet->Irb->u.AllocateAddressRange.Callback =
            Sbp2SetPasswordOrbStatusCallback;

        Context->RequestMdl = IoAllocateMdl(
            &deviceExtension->PasswordOrbStatusBlock,
            sizeof(STATUS_FIFO_BLOCK),
            FALSE,
            FALSE,
            NULL
            );

        if (!Context->RequestMdl) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitAllocateAddress;
        }

        break;
#endif
    }

    if (Context->RequestMdl) {

        MmBuildMdlForNonPagedPool(Context->RequestMdl);
    }

    packet->Irb->u.AllocateAddressRange.Mdl = Context->RequestMdl;
    packet->Irb->u.AllocateAddressRange.Context = Context;

    packet->Irb->u.AllocateAddressRange.p1394AddressRange = (PADDRESS_RANGE)&Context->Address;

    status = Sbp2SendRequest (deviceExtension, packet, SYNC_1394_REQUEST);

    if (NT_SUCCESS(status)) {

        //
        // Setup the address context for the status block
        //
        Context->AddressHandle = packet->Irb->u.AllocateAddressRange.hAddressRange;
        Context->DeviceObject = DeviceObject;

        Context->Address.BusAddress.NodeId = deviceExtension->InitiatorAddressId;
    }

exitAllocateAddress:

    DeAllocateIrpAndIrb (deviceExtension, packet);

    return status;
}


VOID
CleanupOrbList(
    PDEVICE_EXTENSION   DeviceExtension,
    NTSTATUS CompletionStatus
    )
/*++

Routine Description:

    This routine will free a linked list of RequestContexts
    and will also free the 1394 addresses associated with the
    buffers in the context. If the DEVICE_FLAG_RECONNECT i set
    instead of completing pending irps, it will requeue them...

Arguments:

    DeviceExtension - Device Extension of the sbp2 device
    CompletionSTATUS - If one of the linked requests is not completed,
                        complete it with this status
Return Value:
    None
--*/

{
    PIRP requestIrp;
    PASYNC_REQUEST_CONTEXT currentListItem;
    PASYNC_REQUEST_CONTEXT lastItem,nextItem;

    KIRQL oldIrql;

    //
    // Go through the linked list, complete its original Irp and
    // free all the associated memory and 1394 resources...
    // Since this function is called when we get a REMOVE irp,
    // all irps will be terminated with error status
    //

    KeAcquireSpinLock(&DeviceExtension->OrbListSpinLock,&oldIrql);

    if (DeviceExtension->NextContextToFree) {

        FreeAsyncRequestContext(DeviceExtension,DeviceExtension->NextContextToFree);

        DeviceExtension->NextContextToFree = NULL;
    }

    if (IsListEmpty (&DeviceExtension->PendingOrbList)) {

        //
        // nothing to do
        //

        KeReleaseSpinLock (&DeviceExtension->OrbListSpinLock,oldIrql);
        return;

    } else {

        nextItem = RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Flink,OrbList);

        lastItem = RETRIEVE_CONTEXT(DeviceExtension->PendingOrbList.Blink,OrbList);

        InitializeListHead(&DeviceExtension->PendingOrbList);

        KeReleaseSpinLock(&DeviceExtension->OrbListSpinLock,oldIrql);
    }


    //
    // Qe have essentially detached this pending context list from
    // the main list so we can now free it without holding the lock
    // and allowing other requests to be processed.
    //

    do {

        currentListItem = nextItem;
        nextItem = (PASYNC_REQUEST_CONTEXT) currentListItem->OrbList.Flink;
        if (!TEST_FLAG(currentListItem->Flags,ASYNC_CONTEXT_FLAG_COMPLETED)) {

            SET_FLAG(currentListItem->Flags,ASYNC_CONTEXT_FLAG_COMPLETED);

            CLEAR_FLAG(currentListItem->Flags, ASYNC_CONTEXT_FLAG_TIMER_STARTED);

            Sbp2_SCSI_RBC_Conversion (currentListItem); // unwind MODE_SENSE hacks

            KeCancelTimer(&currentListItem->Timer);

            requestIrp =(PIRP)currentListItem->Srb->OriginalRequest;
            requestIrp->IoStatus.Status = CompletionStatus;

            switch (CompletionStatus) {

            case STATUS_DEVICE_DOES_NOT_EXIST:

                currentListItem->Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                break;

            case STATUS_REQUEST_ABORTED:

                currentListItem->Srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
                break;

            case STATUS_IO_TIMEOUT:

                currentListItem->Srb->SrbStatus = SRB_STATUS_TIMEOUT;
                break;

            default:

                currentListItem->Srb->SrbStatus = SRB_STATUS_ERROR;
                break;
            }

            if (requestIrp->Type == IO_TYPE_IRP) {

                if (TEST_FLAG(DeviceExtension->DeviceFlags, DEVICE_FLAG_RECONNECT)) {

                    Sbp2StartPacket(
                        DeviceExtension->DeviceObject,
                        requestIrp,
                        &currentListItem->Srb->QueueSortKey
                        );

                    //
                    // free everything related to this request
                    //

                    currentListItem->Srb = NULL;

                    FreeAsyncRequestContext (DeviceExtension, currentListItem);

                } else {

                    //
                    // free everything related to this request
                    //

                    currentListItem->Srb = NULL;

                    FreeAsyncRequestContext (DeviceExtension, currentListItem);

                    DEBUGPRINT2(("Sbp2Port: CleanupOrbList: aborted irp x%p compl\n", requestIrp));

                    IoReleaseRemoveLock (&DeviceExtension->RemoveLock, NULL);

                    IoCompleteRequest (requestIrp, IO_NO_INCREMENT);
                }
            }

        } else {

            //
            // free everything related to this request
            //

            FreeAsyncRequestContext (DeviceExtension, currentListItem);
        }

    } while (lastItem != currentListItem); // while loop

    return;
}


VOID
FreeAddressRange(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PADDRESS_CONTEXT Context
    )
/*++

Routine Description:

    1394 BUS IOCTL call for freeing an address range.

Arguments:

    DeviceExtension - Pointer to sbp2 deviceExtension.

    context - address context

Return Value:
    NTSTATUS
--*/

{
    PIRBIRP packet ;


    if (Context->AddressHandle == NULL) {

        return;
    }

    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        return;
    }

    //
    // FreeAddressRange is synchronous call
    //

    packet->Irb->FunctionNumber = REQUEST_FREE_ADDRESS_RANGE;
    packet->Irb->Flags = 0;

    //
    // We always free one address handle even it refers to multiple
    // 1394 addresses.  The mdl associated with the original Allocate
    // is freed by the port driver.
    //

    packet->Irb->u.FreeAddressRange.nAddressesToFree = 1;
    packet->Irb->u.FreeAddressRange.p1394AddressRange = (PADDRESS_RANGE) &Context->Address;
    packet->Irb->u.FreeAddressRange.pAddressRange = &Context->AddressHandle;

    if (Context->RequestMdl) {

        if (Context == &DeviceExtension->CommonBufferContext) {

            Context->RequestMdl = NULL; // common buffer, we didn't alloc mdl

        } else {

            packet->Irb->u.FreeAddressRange.p1394AddressRange->AR_Length =
                (USHORT) MmGetMdlByteCount(Context->RequestMdl);
        }

    } else if (Context == (PADDRESS_CONTEXT) &DeviceExtension->GlobalStatusContext) {

        packet->Irb->u.FreeAddressRange.p1394AddressRange->AR_Length = sizeof(STATUS_FIFO_BLOCK);
    }

    packet->Irb->u.FreeAddressRange.DeviceExtension = DeviceExtension;

    if ((KeGetCurrentIrql() >= DISPATCH_LEVEL) && !Context->Address.BusAddress.Off_High) {

        PPORT_PHYS_ADDR_ROUTINE routine = DeviceExtension->HostRoutineAPI.PhysAddrMappingRoutine;

        (*routine) (DeviceExtension->HostRoutineAPI.Context,packet->Irb);

    } else {

        //
        // dont care about the status of this op
        //

        Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);
    }

    Context->AddressHandle = NULL;

    if (Context->RequestMdl) {

        IoFreeMdl (Context->RequestMdl);
        Context->RequestMdl = NULL;
    }

    DeAllocateIrpAndIrb (DeviceExtension, packet);
}


VOID
Free1394DataMapping(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT Context
    )
{
    PIRBIRP packet ;


    if (Context->DataMappingHandle == NULL) {

        return;
    }

    AllocateIrpAndIrb (DeviceExtension, &packet);

    if (!packet) {

        return;
    }

    //
    // Free the data buffer's 1394 address range
    //

    packet->Irb->FunctionNumber = REQUEST_FREE_ADDRESS_RANGE;
    packet->Irb->Flags = 0;
    packet->Irb->u.FreeAddressRange.nAddressesToFree = 1;
    packet->Irb->u.FreeAddressRange.p1394AddressRange = (PADDRESS_RANGE) NULL;
    packet->Irb->u.FreeAddressRange.pAddressRange = &Context->DataMappingHandle;
    packet->Irb->u.FreeAddressRange.DeviceExtension = DeviceExtension;

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {

        PPORT_PHYS_ADDR_ROUTINE routine = DeviceExtension->HostRoutineAPI.PhysAddrMappingRoutine;

        (*routine) (DeviceExtension->HostRoutineAPI.Context, packet->Irb);

    } else {

        //
        // dont care about the status of this op
        //

        Sbp2SendRequest (DeviceExtension, packet, SYNC_1394_REQUEST);
    }

    if (Context->PartialMdl) {

        IoFreeMdl (Context->PartialMdl);
        Context->PartialMdl = NULL;
    }

    Context->DataMappingHandle = NULL;

    DeAllocateIrpAndIrb (DeviceExtension, packet);
}


ULONG
FreeAsyncRequestContext(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT Context
    )
/*++

Routine Description:

    This routine will free a single RequestContext and will cleanup all
    its buffers and 1394 ranges, ONLY of the device is marked as STOPPED.
    Otherwise it will add the context to the FreeList, so it can be reused
    later one by another request. This way we are drastically speeding up
    each request.

Arguments:

    DeviceExtension - Device Extension of the sbp2 device
    Context - Context to freed or returned to FreeList

Return Value:

    None - The result of the decrement of DeviceExtension->OrbListDepth

--*/

{
    //
    // This ORB can now be freed along with its data descriptor,
    // page tables and context
    //

    if (!Context || (Context->Tag != SBP2_ASYNC_CONTEXT_TAG)) {

        DEBUGPRINT2((
            "Sbp2Port: FreeAsyncReqCtx: attempt to push freed ctx=x%p\n",
            Context
            ));

        ASSERT(FALSE);
        return 0;
    }

    ASSERT(Context->Srb == NULL);

    if (Context->DataMappingHandle) {

        Free1394DataMapping(DeviceExtension,Context);
        ASSERT(Context->DataMappingHandle==NULL);
    }

    //
    // Re-initiliaze this context so it can be reused
    // This context is still part on our FreeAsyncContextPool
    // All we have to do is initialize some flags, so next time
    // we try to retrieve it, we think its empty
    //

    Context->Flags |= ASYNC_CONTEXT_FLAG_COMPLETED;
    Context->Tag = 0;

    if (Context->OriginalSrb) {

        ExFreePool(Context->OriginalSrb);
        Context->OriginalSrb = NULL;
    }

    DEBUGPRINT3(("Sbp2Port: FreeAsyncReqCtx: push ctx=x%p on free list\n",Context));

    ExInterlockedPushEntrySList(&DeviceExtension->FreeContextListHead,
                                &Context->LookasideList,
                                &DeviceExtension->FreeContextLock);

    return InterlockedDecrement (&DeviceExtension->OrbListDepth);
}


NTSTATUS
Sbp2SendRequest(
    PDEVICE_EXTENSION   DeviceExtension,
    PIRBIRP             RequestPacket,
    ULONG               TransferMode
    )
/*++

Routine Description:

    Function used to send requests to the 1394 bus driver. It attaches
    a completion routine to each request it sends down, and it also wraps
    them in a small context, so we can track their completion

Arguments:

    DeviceExtension - Sbp2 device extension
    Irp - Irp to send to the bus driver
    Irb - Bus driver packet, in the Irp
    TransferMode - Indicates if we want ot send this request synchronously
        or asynchronously
    FinalTransferMode - Indicates whether the request was sent synchronously
        or asynchronously

Return Value:

    NTSTATUS

--*/

{
    ULONG               originalTransferMode = TransferMode;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject = DeviceExtension->DeviceObject;
    PREQUEST_CONTEXT    requestContext = NULL;
    PIO_STACK_LOCATION  nextIrpStack;


    if (DeviceExtension->Type == SBP2_PDO) {

        //
        // if device is removed, dont send any requests down
        //

        if (TEST_FLAG(DeviceExtension->DeviceFlags,DEVICE_FLAG_REMOVED)  &&
            (RequestPacket->Irb->FunctionNumber != REQUEST_FREE_ADDRESS_RANGE)) {

            return STATUS_UNSUCCESSFUL;
        }

        //
        // get a context for this request, from our pool
        //

        requestContext = ExAllocateFromNPagedLookasideList(&DeviceExtension->BusRequestContextPool);

    } else {

        requestContext = ExAllocatePool (NonPagedPool,sizeof(REQUEST_CONTEXT));
    }

    if (!requestContext) {

        DEBUGPRINT2((
            "Sbp2Port: SendReq: ERROR, couldn't allocate bus req ctx\n"
            ));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (TransferMode == SYNC_1394_REQUEST) {

        if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {

            //
            // Since we can't block at this level, we will have to do the
            // synch request asynchronously
            //

            TransferMode = ASYNC_SYNC_1394_REQUEST;
            requestContext->Complete = 0;

        } else {

            KeInitializeEvent(
                &requestContext->Event,
                NotificationEvent,
                FALSE
                );
        }
    }

    requestContext->DeviceExtension = DeviceExtension;
    requestContext->RequestType = TransferMode;

    if (TransferMode == SYNC_1394_REQUEST){

        requestContext->Packet = NULL;

    } else {

        requestContext->Packet = RequestPacket;
    }

    nextIrpStack = IoGetNextIrpStackLocation (RequestPacket->Irp);

    nextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    nextIrpStack->Parameters.Others.Argument1 = RequestPacket->Irb;

    IoSetCompletionRoutine(RequestPacket->Irp,
                           Sbp2RequestCompletionRoutine,
                           requestContext,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    status = IoCallDriver(
                DeviceExtension->LowerDeviceObject,
                RequestPacket->Irp
                );

    if (status == STATUS_INVALID_GENERATION) {

        DEBUGPRINT1(("Sbp2Port: SendReq: Bus drv ret'd invalid generation\n"));
        RequestPacket->Irp->IoStatus.Status = STATUS_REQUEST_ABORTED;
    }

    if (originalTransferMode == SYNC_1394_REQUEST ) {

        if (TransferMode == SYNC_1394_REQUEST) {

            if (status == STATUS_PENDING) {

                //
                // < DISPATCH_LEVEL so wait on an event
                //

                KeWaitForSingleObject(
                    &requestContext->Event,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );
             }

        } else { // ASYNC_SYNC_1394_REQUEST

            //
            // >= DISPATCH_LEVEL so we can't wait, do the nasty...
            //

            volatile ULONG *pComplete = &requestContext->Complete;

            while (*pComplete == 0);

            status = RequestPacket->Irp->IoStatus.Status;
        }

        //
        // Free the context (the Irp.Irb will be returnd by the caller)
        //

        if (DeviceExtension->Type == SBP2_PDO) {

            ExFreeToNPagedLookasideList(&DeviceExtension->BusRequestContextPool, requestContext);

        } else {

            ExFreePool (requestContext);
        }

        return RequestPacket->Irp->IoStatus.Status;
    }

    return status;
}


NTSTATUS
Sbp2RequestCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PREQUEST_CONTEXT Context
    )

/*++

Routine Description:

    Completion routine used for all requests to 1394 bus driver

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp - Irp that just completed

    Event - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{
    ASSERT(Context!=NULL);
    ASSERT(Context->DeviceExtension);

    if (Context->RequestType == SYNC_1394_REQUEST) {

        //
        // Synch request completion (either synch, or synch at DPC)
        //

        KeSetEvent (&Context->Event, IO_NO_INCREMENT, FALSE);

    } else if (Context->RequestType == ASYNC_1394_REQUEST) {

        //
        // Asynchronous request completion, so do any necessary
        // post-processing & return the context and the Irp/Irb
        // to the free lists.
        //

        if (Context->Packet) {

            switch (Context->Packet->Irb->FunctionNumber) {

            case REQUEST_ASYNC_READ:
            case REQUEST_ASYNC_WRITE:

                if (Context->Packet->Irb->u.AsyncWrite.nNumberOfBytesToWrite ==
                        sizeof(OCTLET)) {

                    IoFreeMdl (Context->Packet->Irb->u.AsyncRead.Mdl);

                    Context->Packet->Irb->u.AsyncRead.Mdl = NULL;
                }

                break;
            }

            DeAllocateIrpAndIrb (Context->DeviceExtension, Context->Packet);
        }

        if (Context->DeviceExtension->Type == SBP2_PDO) {

            ExFreeToNPagedLookasideList(&Context->DeviceExtension->BusRequestContextPool, Context);

        } else {

            ExFreePool (Context);
        }

    } else { // ASYNC_SYNC_1394_REQUEST

        //
        // Just set the Complete flag to unblock Sbp2SendRequest
        //

        Context->Complete = 1;
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
Sbp2CreateRequestErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN PASYNC_REQUEST_CONTEXT Context,
    IN NTSTATUS Status
    )

{
    PIO_ERROR_LOG_PACKET errorLogEntry;


    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        DeviceObject,
        sizeof(IO_ERROR_LOG_PACKET) + sizeof(ORB_NORMAL_CMD)
        );

    if (errorLogEntry) {

        switch (Status) {

        case STATUS_DEVICE_POWER_FAILURE:

            errorLogEntry->ErrorCode = IO_ERR_NOT_READY;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:

            errorLogEntry->ErrorCode = IO_ERR_INSUFFICIENT_RESOURCES;
            break;

        case STATUS_TIMEOUT:

            errorLogEntry->ErrorCode = IO_ERR_TIMEOUT;
            break;

        case STATUS_DEVICE_PROTOCOL_ERROR:

            errorLogEntry->ErrorCode = IO_ERR_BAD_FIRMWARE;
            break;


        case STATUS_INVALID_PARAMETER:
        case STATUS_INVALID_DEVICE_REQUEST:

            errorLogEntry->ErrorCode = IO_ERR_INVALID_REQUEST;
            break;

        case STATUS_REQUEST_ABORTED:

            errorLogEntry->ErrorCode = IO_ERR_RESET;
            break;

        default:

            errorLogEntry->ErrorCode = IO_ERR_BAD_FIRMWARE;
            break;
        }

        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = IRP_MJ_SCSI;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = Status;

        if (Context) {

            errorLogEntry->DumpDataSize = sizeof(ORB_NORMAL_CMD);
            RtlCopyMemory(&(errorLogEntry->DumpData[0]),Context->CmdOrb,sizeof(ORB_NORMAL_CMD));

        } else {

            errorLogEntry->DumpDataSize = 0;
        }

        IoWriteErrorLogEntry(errorLogEntry);

        DEBUGPRINT2((
            "Sbp2Port: ErrorLog: dev=x%p, status=x%x, ctx=x%p\n",
            DeviceObject,
            Status,
            Context
            ));

    } else {

        DEBUGPRINT2 (("Sbp2Port: ErrorLog: failed to allocate log entry\n"));
    }
}


NTSTATUS
CheckStatusResponseValue(
    IN PSTATUS_FIFO_BLOCK StatusBlock
    )
/*++

Routine Description:

    It checks the status block result bits and maps the errors to
    NT status errors

Arguments:

    DeviceExtension - Sbp2 device extension

    ManagementStatus - If true then we check the management orb status

Return Value:

    NTSTATUS

++*/

{
    NTSTATUS status;
    UCHAR   resp;
    USHORT  statusFlags = StatusBlock->AddressAndStatus.u.HighQuad.u.HighPart;


    if (statusFlags & STATUS_BLOCK_UNSOLICITED_BIT_MASK) {

        //
        // The unsolicited bit is set, which means this status is
        // not related to anything...
        //

        return STATUS_NOT_FOUND;
    }

    resp = ((statusFlags & STATUS_BLOCK_RESP_MASK) >> 12);

    switch (resp) {

    case 0:

        //
        // Request complete, check sbp_status field for more info
        //

        switch ((statusFlags & STATUS_BLOCK_SBP_STATUS_MASK)) {

        case 0x00: // no additional status to report

            status = STATUS_SUCCESS;
            break;

        case 0x01: // request type not supported
        case 0x02: // speed not supported
        case 0x03: // page size not supported

            status = STATUS_NOT_SUPPORTED;
            break;

        case 0x04: // access denied
        case 0x05: // LUN not supported

            status = STATUS_ACCESS_DENIED;
            break;

        case 0x08: // resource unavailable

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;

        case 0x09: // function rejected

            status = STATUS_ILLEGAL_FUNCTION;
            break;

        case 0x0a: // login id not recognized

            status = STATUS_TRANSACTION_INVALID_ID;
            break;

        default:

            status = STATUS_UNSUCCESSFUL;
            break;
        }

        break;

    case 1:

        //
        // Transport failure, check the redefined sbp-status field
        // for serial-bus errors
        //

        resp = statusFlags & 0x0F;

        switch (resp) {

        case 0x02: // time out
        case 0x0C: // conflict error
        case 0x0D: // data error

            status = STATUS_DEVICE_PROTOCOL_ERROR;
            break;

        case 0x04: // busy retry limit exceeded
        case 0x05: // busy retry limit exceeded
        case 0x06: // busy retry limit exceeded

            status = STATUS_DEVICE_BUSY;
            break;

        case 0x0E: // type error

            status = STATUS_INVALID_PARAMETER;
            break;

        case 0x0F: // address error

            status = STATUS_INVALID_ADDRESS;
            break;

        default:

            status = STATUS_UNSUCCESSFUL;
            break;
        }

        break;

    case 2: // illegal request

        status =  STATUS_ILLEGAL_FUNCTION;
        break;

    default: // case 3:, vendor dependent

        status = STATUS_UNSUCCESSFUL; // ISSUE: dankn, 02-Aug-2001
        break;
    }

    return status;
}

VOID
Sbp2StartNextPacketByKey(
    IN PDEVICE_OBJECT   DeviceObject,
    IN ULONG            Key
    )
/*++

Routine Description:

    This routine was lifted from the Io sources
    (IopStartNextPacketByKey), and duplicated/modifed here for
    two reasons: 1) we got tired of hitting the queue-not-busy assert
    in KeRemoveXxx, and 2) we needed a way to prevent stack-blowing
    recursion, for example, arising from a bunch of requests sent to
    a stopped device (all failed in StartIo, which calls this func).

    These routines were originally designed with the idea that there
    would only be one outstanding request at a time, but this driver
    can have multiple outstanding requests, and it frequently ends up
    making redundant calls to XxStartNextPacket(ByKey), which result
    in the aforementioned assert.

    Rolling our own version of this also allows us to get rid the
    the cancel overhead, since we do not (currently) support cancels.

Arguments:

    DeviceObject - Pointer to device object itself

    Key - Specifics the Key used to remove the entry from the queue

Return Value:

    None

--*/
{
    PIRP                 irp;
    PDEVICE_EXTENSION    deviceExtension = (PDEVICE_EXTENSION)
                             DeviceObject->DeviceExtension;
    PKDEVICE_QUEUE_ENTRY packet;


    //
    // Increment the StartNextPacketCount, and if result is != 1
    // then just return because we don't want to worry about
    // recursion & blowing the stack.  The instance of this
    // function that caused the SNPCount 0 to 1 transition
    // will eventually make another pass through the loop below
    // on this instance's behalf.
    //

    if (InterlockedIncrement (&deviceExtension->StartNextPacketCount) != 1) {

        return;
    }

    do {

        //
        // Attempt to remove the indicated packet according to the key
        // from the device queue.  If one is found, then process it.
        //

        packet = Sbp2RemoveByKeyDeviceQueueIfBusy(
            &DeviceObject->DeviceQueue,
            Key
            );

        if (packet) {

            irp = CONTAINING_RECORD (packet,IRP,Tail.Overlay.DeviceQueueEntry);

            Sbp2StartIo (DeviceObject, irp);
        }

    } while (InterlockedDecrement (&deviceExtension->StartNextPacketCount));
}


VOID
Sbp2StartPacket(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PULONG           Key OPTIONAL
    )
/*++

Routine Description:

    (See routine description for Sbp2StartNextPacketByKey)

Arguments:

    DeviceObject - Pointer to device object itself

    Irp - I/O Request Packet which should be started on the device

Return Value:

    None

--*/
{
    KIRQL                oldIrql;
    BOOLEAN              inserted;
    PLIST_ENTRY          nextEntry;
    PKDEVICE_QUEUE       queue = &DeviceObject->DeviceQueue;
    PKDEVICE_QUEUE_ENTRY queueEntry = &Irp->Tail.Overlay.DeviceQueueEntry,
                         queueEntry2;


    //
    // Raise the IRQL of the processor to dispatch level for synchronization
    //

    KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);

    KeAcquireSpinLockAtDpcLevel (&queue->Lock);

    if (Key) {

        //
        // Insert the specified device queue entry in the device queue at the
        // position specified by the sort key if the device queue is busy.
        // Otherwise set the device queue busy an don't insert the device
        // queue entry.
        //

        queueEntry->SortKey = *Key;

        if (queue->Busy == TRUE) {

            inserted = TRUE;

            nextEntry = queue->DeviceListHead.Flink;

            while (nextEntry != &queue->DeviceListHead) {

                queueEntry2 = CONTAINING_RECORD(
                    nextEntry,
                    KDEVICE_QUEUE_ENTRY,
                    DeviceListEntry
                    );

                if (*Key < queueEntry2->SortKey) {

                    break;
                }

                nextEntry = nextEntry->Flink;
            }

            nextEntry = nextEntry->Blink;

            InsertHeadList (nextEntry, &queueEntry->DeviceListEntry);

        } else {

            queue->Busy = TRUE;
            inserted = FALSE;
        }

    } else {

        //
        // Insert the specified device queue entry at the end of the device
        // queue if the device queue is busy. Otherwise set the device queue
        // busy and don't insert the device queue entry.
        //

        if (queue->Busy == TRUE) {

            inserted = TRUE;

            InsertTailList(
                &queue->DeviceListHead,
                &queueEntry->DeviceListEntry
                );

        } else {

            queue->Busy = TRUE;
            inserted = FALSE;
        }
    }

    queueEntry->Inserted = inserted;

    KeReleaseSpinLockFromDpcLevel (&queue->Lock);

    //
    // If the packet was not inserted into the queue, then this request is
    // now the current packet for this device.  Indicate so by storing its
    // address in the current IRP field, and begin processing the request.
    //

    if (!inserted) {

        //
        // Invoke the driver's start I/O routine to get the request going
        // on the device
        //

        Sbp2StartIo (DeviceObject, Irp);
    }

    //
    // Restore the IRQL back to its value upon entry to this function before
    // returning to the caller
    //

    KeLowerIrql (oldIrql);
}


PKDEVICE_QUEUE_ENTRY
Sbp2RemoveByKeyDeviceQueueIfBusy(
    IN PKDEVICE_QUEUE   DeviceQueue,
    IN ULONG            SortKey
    )
/*++

Routine Description:

    This routine was lifted directly from Ke sources
    (KeRemoveByKeyDeviceQueueIfBusy) to allow this driver to maintain
    WDM compatibility, since the Ke API does not exist on Win9x or Win2k.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    SortKey - Supplies the sort key by which the position to remove the device
        queue entry is to be determined.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/
{
    PLIST_ENTRY             nextEntry;
    PKDEVICE_QUEUE_ENTRY    queueEntry;


    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KeAcquireSpinLockAtDpcLevel (&DeviceQueue->Lock);

    //
    // If the device queue is busy, then attempt to remove an entry from
    // the queue using the sort key. Otherwise, set the device queue not
    // busy.
    //

    if (DeviceQueue->Busy != FALSE) {

        if (IsListEmpty (&DeviceQueue->DeviceListHead) != FALSE) {

            DeviceQueue->Busy = FALSE;
            queueEntry = NULL;

        } else {

            nextEntry = DeviceQueue->DeviceListHead.Flink;

            while (nextEntry != &DeviceQueue->DeviceListHead) {

                queueEntry = CONTAINING_RECORD(
                    nextEntry,
                    KDEVICE_QUEUE_ENTRY,
                    DeviceListEntry
                    );

                if (SortKey <= queueEntry->SortKey) {

                    break;
                }

                nextEntry = nextEntry->Flink;
            }

            if (nextEntry != &DeviceQueue->DeviceListHead) {

                RemoveEntryList (&queueEntry->DeviceListEntry);

            } else {

                nextEntry = RemoveHeadList (&DeviceQueue->DeviceListHead);

                queueEntry = CONTAINING_RECORD(
                    nextEntry,
                    KDEVICE_QUEUE_ENTRY,
                    DeviceListEntry
                    );
            }

            queueEntry->Inserted = FALSE;
        }

    } else {

        queueEntry = NULL;
    }

    //
    // Unlock specified device queue and return address of device queue
    // entry.
    //

    KeReleaseSpinLockFromDpcLevel (&DeviceQueue->Lock);

    return queueEntry;
}


BOOLEAN
Sbp2InsertByKeyDeviceQueue(
    PKDEVICE_QUEUE          DeviceQueue,
    PKDEVICE_QUEUE_ENTRY    DeviceQueueEntry,
    ULONG                   SortKey
    )
/*++

Routine Description:

    (Again, stolen from Ke src to maintain consistent use of spinlocks.)

    This function inserts a device queue entry into the specified device
    queue according to a sort key. If the device is not busy, then it is
    set busy and the entry is not placed in the device queue. Otherwise
    the specified entry is placed in the device queue at a position such
    that the specified sort key is greater than or equal to its predecessor
    and less than its successor.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry.

    SortKey - Supplies the sort key by which the position to insert the device
        queue entry is to be determined.

Return Value:

    If the device is not busy, then a value of FALSE is returned. Otherwise a
    value of TRUE is returned.

--*/
{
    BOOLEAN              inserted;
    PLIST_ENTRY          nextEntry;
    PKDEVICE_QUEUE       queue = DeviceQueue;
    PKDEVICE_QUEUE_ENTRY queueEntry = DeviceQueueEntry,
                         queueEntry2;


    KeAcquireSpinLockAtDpcLevel (&queue->Lock);

    //
    // Insert the specified device queue entry in the device queue at the
    // position specified by the sort key if the device queue is busy.
    // Otherwise set the device queue busy an don't insert the device
    // queue entry.
    //

    queueEntry->SortKey = SortKey;

    if (queue->Busy == TRUE) {

        inserted = TRUE;

        nextEntry = queue->DeviceListHead.Flink;

        while (nextEntry != &queue->DeviceListHead) {

            queueEntry2 = CONTAINING_RECORD(
                nextEntry,
                KDEVICE_QUEUE_ENTRY,
                DeviceListEntry
                );

            if (SortKey < queueEntry2->SortKey) {

                break;
            }

            nextEntry = nextEntry->Flink;
        }

        nextEntry = nextEntry->Blink;

        InsertHeadList (nextEntry, &queueEntry->DeviceListEntry);

    } else {

        queue->Busy = TRUE;
        inserted = FALSE;
    }

    KeReleaseSpinLockFromDpcLevel (&queue->Lock);

    return inserted;
}

#if PASSWORD_SUPPORT

NTSTATUS
Sbp2GetExclusiveValue(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    OUT PULONG          Exclusive
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    HANDLE              RootHandle = NULL;
    UNICODE_STRING      uniTempName;


    // set default value...

    *Exclusive = EXCLUSIVE_FLAG_CLEAR;

    uniTempName.Buffer = NULL;

    ntStatus = IoOpenDeviceRegistryKey( PhysicalDeviceObject,
                                        PLUGPLAY_REGKEY_DEVICE,
                                        KEY_ALL_ACCESS,
                                        &RootHandle
                                        );

    if (!NT_SUCCESS(ntStatus)) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2GetExclusiveValue;
    }

    uniTempName.Length = 0;
    uniTempName.MaximumLength = 128;

    uniTempName.Buffer = ExAllocatePool(
        NonPagedPool,
        uniTempName.MaximumLength
        );

    if (!uniTempName.Buffer) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2GetExclusiveValue;
    }

    {
        PKEY_VALUE_PARTIAL_INFORMATION      KeyInfo;
        ULONG                               KeyLength;
        ULONG                               ResultLength;

        KeyLength = sizeof (KEY_VALUE_PARTIAL_INFORMATION) + sizeof (ULONG);

        KeyInfo = ExAllocatePool (NonPagedPool, KeyLength);

        if (KeyInfo == NULL) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit_Sbp2GetExclusiveValue;
        }

        RtlZeroMemory(uniTempName.Buffer, uniTempName.MaximumLength);
        uniTempName.Length = 0;
        RtlAppendUnicodeToString(&uniTempName, L"Exclusive");

        ntStatus = ZwQueryValueKey( RootHandle,
                                    &uniTempName,
                                    KeyValuePartialInformation,
                                    KeyInfo,
                                    KeyLength,
                                    &ResultLength
                                    );

        if (NT_SUCCESS(ntStatus)) {

            *Exclusive = *((PULONG) &KeyInfo->Data);

            DEBUGPRINT1 (("Sbp2Port: GetExclVal: excl=x%x\n", *Exclusive));

        } else {

            DEBUGPRINT1((
                "Sbp2Port: GetExclVal: QueryValueKey err=x%x\n",
                ntStatus
                ));
        }

        ExFreePool (KeyInfo);
    }

Exit_Sbp2GetExclusiveValue:

    if (RootHandle) {

        ZwClose (RootHandle);
    }

    if (uniTempName.Buffer) {

        ExFreePool (uniTempName.Buffer);
    }

    return ntStatus;
}


NTSTATUS
Sbp2SetExclusiveValue(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PULONG           Exclusive
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    HANDLE              RootHandle = NULL;
    UNICODE_STRING      uniTempName;


    uniTempName.Buffer = NULL;

    ntStatus = IoOpenDeviceRegistryKey( PhysicalDeviceObject,
                                        PLUGPLAY_REGKEY_DEVICE,
                                        KEY_ALL_ACCESS,
                                        &RootHandle
                                        );

    if (!NT_SUCCESS(ntStatus)) {

        goto Exit_Sbp2SetExclusiveValue;
    }

    uniTempName.Length = 0;
    uniTempName.MaximumLength = 128;

    uniTempName.Buffer = ExAllocatePool(
        NonPagedPool,
        uniTempName.MaximumLength
        );

    if (!uniTempName.Buffer) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2SetExclusiveValue;
    }

    RtlZeroMemory (uniTempName.Buffer, uniTempName.MaximumLength);
    uniTempName.Length = 0;
    RtlAppendUnicodeToString(&uniTempName, L"Exclusive");

    ntStatus = ZwSetValueKey( RootHandle,
                              &uniTempName,
                              0,
                              REG_DWORD,
                              Exclusive,
                              sizeof(ULONG)
                              );

    if (!NT_SUCCESS(ntStatus)) {

        DEBUGPRINT1(("Sbp2Port: SetExclVal: SetValueKey err=x%x\n", ntStatus));
        *Exclusive = 0;
    }
    else {

        DEBUGPRINT1(("Sbp2Port: SetExclVal: excl=x%x\n", *Exclusive));
    }

Exit_Sbp2SetExclusiveValue:

    if (RootHandle) {

        ZwClose(RootHandle);
    }

    if (uniTempName.Buffer) {

        ExFreePool(uniTempName.Buffer);
    }

    return ntStatus;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sbp2port\sbp2scsi.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    sbp2scsi.c

Abstract:

    module for the SBP-2 SCSI interface routines

    Author:

    George Chrysanthakopoulos January-1997 (started)

Environment:

    Kernel mode

Revision History :

--*/

#include "sbp2port.h"

NTSTATUS
Sbp2ScsiRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles all IRP_MJ_SCSI requests and queues them on
    our device queue. Then it calls StartNextPacket so our StartIo
    will run and process the request.

Arguments:

    DeviceObject - this driver's device object
    Irp - the class driver request

Return Value:
    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb;
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    KIRQL cIrql;

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);

    //
    // Get a pointer to the SRB.
    //
    srb = irpStack->Parameters.Scsi.Srb;

    if (!NT_SUCCESS (status)) {

        srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        srb->InternalStatus = status;

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (srb->Function) {

    case SRB_FUNCTION_EXECUTE_SCSI:

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                (DEVICE_FLAG_REMOVED | DEVICE_FLAG_PNP_STOPPED |
                    DEVICE_FLAG_DEVICE_FAILED)
                )) {

            //
            // we got a REMOVE/STOP, we can't accept any more requests...
            //

            status = STATUS_DEVICE_DOES_NOT_EXIST;

            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->InternalStatus = status;


            DEBUGPRINT2((
                "Sbp2Port: ScsiReq: ext=x%p rmv/stop (fl=x%x), status=x%x\n",
                deviceExtension,
                deviceExtension->DeviceFlags,
                status
                ));

            Irp->IoStatus.Status = srb->InternalStatus;
            IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
            IoCompleteRequest (Irp,IO_NO_INCREMENT);
            return status;
        }

        //
        // check if this is a request that can be failed if we are powered down..
        //

        if (TEST_FLAG(srb->SrbFlags,SRB_FLAGS_NO_KEEP_AWAKE)) {

            //
            // if we are in d3 punt this irp...
            //

            if (deviceExtension->DevicePowerState == PowerDeviceD3) {

                DEBUGPRINT2((
                    "Sbp2Port: ScsiReq: ext=x%p power down, punt irp=x%p\n",
                    deviceExtension,
                    Irp
                    ));

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                srb->SrbStatus = SRB_STATUS_NOT_POWERED;
                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
                return STATUS_UNSUCCESSFUL;
            }
        }

        IoMarkIrpPending (Irp);

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_QUEUE_LOCKED) &&
            TEST_FLAG(srb->SrbFlags,SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {

            //
            // by pass queueing, this guy has to be processed immediately.
            // Since queue is locked, no other requests are being processed
            //

            if (TEST_FLAG(deviceExtension->DeviceFlags,(DEVICE_FLAG_LOGIN_IN_PROGRESS | DEVICE_FLAG_RECONNECT))){

                //
                // we are in the middle of a bus reset reconnect..
                // defere this until after we have established a connection again
                //

                Sbp2DeferPendingRequest (deviceExtension, Irp);

            } else {

                KeRaiseIrql (DISPATCH_LEVEL, &cIrql);
                Sbp2StartIo (DeviceObject, Irp);
                KeLowerIrql (cIrql);
            }

        } else {

            Sbp2StartPacket (DeviceObject, Irp, &srb->QueueSortKey);
        }

        return STATUS_PENDING;
        break;

    case SRB_FUNCTION_CLAIM_DEVICE:

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);

        if (TEST_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_CLAIMED)) {

            status = STATUS_DEVICE_BUSY;
            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->InternalStatus = STATUS_DEVICE_BUSY;

        } else {

            SET_FLAG(deviceExtension->DeviceFlags, DEVICE_FLAG_CLAIMED);
            srb->DataBuffer = DeviceObject;
            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;
        }

        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);
        break;

    case SRB_FUNCTION_RELEASE_DEVICE:

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_CLAIMED);
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        srb->SrbStatus = SRB_STATUS_SUCCESS;
        status = STATUS_SUCCESS;
        break;

    case SRB_FUNCTION_FLUSH_QUEUE:
    case SRB_FUNCTION_FLUSH:

        DEBUGPRINT3(("Sbp2Port: ScsiReq: Flush Queue/ORB list\n" ));

        if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_STOPPED)) {

            CleanupOrbList(deviceExtension,STATUS_REQUEST_ABORTED);

            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;

        } else {

            //
            // ISSUE-georgioc-2000/02/20  FLUSH_QUEUE should be failed if they
            //      cannot be handled.
            //

            DEBUGPRINT3(("Sbp2Port: ScsiReq: Cannot Flush active queue\n" ));
            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;
        }

        break;

    case SRB_FUNCTION_RESET_BUS:

        status = Sbp2Issue1394BusReset(deviceExtension);

        DEBUGPRINT3(("Sbp2Port: ScsiReq: Issuing a 1394 bus reset. \n" ));

        if (!NT_SUCCESS(status)) {

            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->InternalStatus = status;

        } else {

            srb->SrbStatus = SRB_STATUS_SUCCESS;
        }

        break;

    case SRB_FUNCTION_LOCK_QUEUE:

        //
        // lock the queue
        //

        if (TEST_FLAG(deviceExtension->DeviceFlags,(DEVICE_FLAG_REMOVED | DEVICE_FLAG_STOPPED)) ) {

            status = STATUS_DEVICE_DOES_NOT_EXIST;
            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->InternalStatus = STATUS_DEVICE_DOES_NOT_EXIST;

        } else {

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            SET_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_QUEUE_LOCKED);
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            status = STATUS_SUCCESS;
            srb->SrbStatus = SRB_STATUS_SUCCESS;

            DEBUGPRINT2(("Sbp2Port: ScsiReq: ext=x%p, LOCK_QUEUE\n", deviceExtension));
        }

        break;

    case SRB_FUNCTION_UNLOCK_QUEUE:

        //
        // re-enable the device queue...
        //

        DEBUGPRINT2(("Sbp2Port: ScsiReq: ext=x%p, UNLOCK_QUEUE\n", deviceExtension));

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        CLEAR_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_QUEUE_LOCKED);
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        //
        // check if there was a request that was deferred until we were powerd up..
        //
        //

        if (deviceExtension->PowerDeferredIrp) {

            PIRP tIrp = deviceExtension->PowerDeferredIrp;

            DEBUGPRINT2((
                "Sbp2Port: ScsiReq: restart powerDeferredIrp=x%p\n",
                tIrp
                ));

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->PowerDeferredIrp = NULL;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            Sbp2StartPacket (DeviceObject, tIrp, NULL);
        }

        if (deviceExtension->DevicePowerState == PowerDeviceD0) {

            //
            // the queue was just unlocked and we are in D0, which means we can resume
            // packet processing...
            //

            KeRaiseIrql (DISPATCH_LEVEL, &cIrql);

            Sbp2StartNextPacketByKey(
                DeviceObject,
                deviceExtension->CurrentKey
                );

            KeLowerIrql (cIrql);
        }

        if (TEST_FLAG (deviceExtension->DeviceFlags, DEVICE_FLAG_REMOVED)) {

            status = STATUS_DEVICE_DOES_NOT_EXIST;
            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->InternalStatus = STATUS_DEVICE_DOES_NOT_EXIST;
            break;

        } else if (deviceExtension->DevicePowerState == PowerDeviceD3) {

            //
            // Clean up any deferred FREEs so we HAVE to use the ORB_POINTER
            // write on the next insertion to the pending list
            //

            KeAcquireSpinLock(&deviceExtension->OrbListSpinLock,&cIrql);

            if (deviceExtension->NextContextToFree) {

                FreeAsyncRequestContext(deviceExtension,deviceExtension->NextContextToFree);
                deviceExtension->NextContextToFree = NULL;
            }

            KeReleaseSpinLock (&deviceExtension->OrbListSpinLock,cIrql);

            if (deviceExtension->SystemPowerState != PowerSystemWorking) {

                KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);

                //
                // we need to invalidate our generation because on resume we might try to issue
                // a request BEFORE we get the bus reset notification..
                //

                deviceExtension->CurrentGeneration = 0xFFFFFFFF;
                KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            }

            srb->SrbStatus = SRB_STATUS_SUCCESS;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);

            if (deviceExtension->SystemPowerState == PowerSystemWorking) {
#if DBG
                if (!IsListEmpty (&DeviceObject->DeviceQueue.DeviceListHead)) {

                    DEBUGPRINT2((
                        "\nSbp2Port: ScsiReq: ext=x%p, RESTARTING NON-EMPTY " \
                            "DEV_Q AT D3!\n",
                        deviceExtension
                        ));
                }
#endif
                KeRaiseIrql (DISPATCH_LEVEL, &cIrql);

                Sbp2StartNextPacketByKey(
                    DeviceObject,
                    deviceExtension->CurrentKey
                    );

                KeLowerIrql (cIrql);
            }

            IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);

            return STATUS_SUCCESS;
        }

        status = STATUS_SUCCESS;
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        break;

    default:

        status = STATUS_NOT_SUPPORTED;
        srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        srb->InternalStatus = STATUS_NOT_SUPPORTED;
        DEBUGPRINT3(("Sbp2Port: ScsiReq: SRB Function not handled, srb->CdbLength %x, Exiting.\n",srb->CdbLength ));
        break;
    }

    if (!NT_SUCCESS(status)) {

        //
        // it'll either have gone to the StartIo routine or have been
        // failed before hitting the device.  Therefore ensure that
        // srb->InternalStatus is set correctly.
        //

        ASSERT(srb->SrbStatus == SRB_STATUS_INTERNAL_ERROR);
        ASSERT((LONG)srb->InternalStatus == status);
    }

    Irp->IoStatus.Status = status;
    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}


VOID
Sbp2StartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Takes incoming, queued requests, and sends them down to the 1394 bus

Arguments:
    DeviceObject - Our device object
    Irp - Request from class drivers,

Return Value:

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb;
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PASYNC_REQUEST_CONTEXT context;


    //
    // Get a pointer to the SRB.
    //

    srb = irpStack->Parameters.Scsi.Srb;

    Irp->IoStatus.Status = STATUS_PENDING;
    srb->SrbStatus = SRB_STATUS_PENDING;

    if (TEST_FLAG(
            deviceExtension->DeviceFlags,
            (DEVICE_FLAG_REMOVED | DEVICE_FLAG_PNP_STOPPED |
                DEVICE_FLAG_DEVICE_FAILED | DEVICE_FLAG_ABSENT_ON_POWER_UP)
            )) {

        //
        // Removed, stopped, or absent, so can't accept any more requests
        //

        status = STATUS_DEVICE_DOES_NOT_EXIST;
        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        DEBUGPRINT2((
            "Sbp2Port: StartIo: dev stopped/removed/absent, fail irp=x%p\n",
            Irp
            ));

       Sbp2StartNextPacketByKey (DeviceObject, 0);

       IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);

       return;
    }

    if (TEST_FLAG(deviceExtension->DeviceFlags,DEVICE_FLAG_QUEUE_LOCKED)) {

        if (!TEST_FLAG(srb->SrbFlags,SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {

            if (!Sbp2InsertByKeyDeviceQueue(
                    &DeviceObject->DeviceQueue,
                    &Irp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey)) {

                //
                // ISSUE-georgioc-2000/02/20  deadlock possible because
                //    queue is now busy and noone has called StartIo().
                //    should instead queue the request and then later,
                //    after an UNLOCK arrives, process this queue of
                //    requests that occurred when the queue was locked.
                //    OR should comment why this is not a deadlock
                //

                DEBUGPRINT2((
                    "Sbp2Port: StartIo: insert failed, compl irp=x%p\n",
                    Irp
                    ));

                srb->SrbStatus = SRB_STATUS_BUSY;
                Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                IoCompleteRequest(Irp,IO_NO_INCREMENT);
            }

            return;
        }

    } else {

        //
        // CASE 1: Device powered Down, but system running.
        //
        // Queue this request, Power up device, then when done start
        // processing requests
        //

        if ((deviceExtension->DevicePowerState == PowerDeviceD3) &&
            (deviceExtension->SystemPowerState == PowerSystemWorking)) {

            BOOLEAN     queued;
            POWER_STATE state;


            queued = Sbp2InsertByKeyDeviceQueue(
                &DeviceObject->DeviceQueue,
                &Irp->Tail.Overlay.DeviceQueueEntry,
                srb->QueueSortKey
                );

            if (!queued) {

                DEBUGPRINT2((
                    "Sbp2Port: StartIo: dev q not busy, defer irp=x%p\n",
                    Irp
                    ));

                ASSERT(deviceExtension->PowerDeferredIrp == NULL);

                KeAcquireSpinLockAtDpcLevel(
                    &deviceExtension->ExtensionDataSpinLock
                    );

                deviceExtension->PowerDeferredIrp = Irp;

                KeReleaseSpinLockFromDpcLevel(
                    &deviceExtension->ExtensionDataSpinLock
                    );
            }

            //
            // We need to send our own stack a d0 irp, so the device
            // powers up and can process this request.
            // Block until the Start_STOP_UNIT to start, is called.
            // This has to happen in two steps:
            // 1: Send D Irp to stack, which might power up the controller
            // 2: Wait for completion of START UNIT send by class driver,
            //    if success start processing requests...
            //

            DEBUGPRINT2((
                "Sbp2Port: StartIo: dev powered down, q(%x) irp=x%p " \
                    "til power up\n",
                queued,
                Irp
                ));

            state.DeviceState = PowerDeviceD0;

            DEBUGPRINT1((
                "Sbp2Port: StartIo: sending D irp for state %x\n",
                state
                ));

            status = PoRequestPowerIrp(
                         deviceExtension->DeviceObject,
                         IRP_MN_SET_POWER,
                         state,
                         NULL,
                         NULL,
                         NULL);

            if (!NT_SUCCESS(status)) {

                //
                // not good, we cant power up the device..
                //

                DEBUGPRINT1(("Sbp2Port: StartIo: D irp err=x%x\n", status));

                if (!queued) {

                    KeAcquireSpinLockAtDpcLevel(
                        &deviceExtension->ExtensionDataSpinLock
                        );

                    if (deviceExtension->PowerDeferredIrp == Irp) {

                        deviceExtension->PowerDeferredIrp = NULL;

                    } else {

                        Irp = NULL;
                    }

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->ExtensionDataSpinLock
                        );

                } else {

                    //
                    // If the irp is still in the device queue then remove it.
                    // Don't worry about the queue's busy flag - if irp found
                    // then queue gets restarted by StartNextPacket below,
                    // else another thread processed the irp, thereby
                    // restarting the queue.
                    //

                    PIRP            qIrp = NULL;
                    PLIST_ENTRY     entry;
                    PKDEVICE_QUEUE  queue = &DeviceObject->DeviceQueue;


                    KeAcquireSpinLockAtDpcLevel (&queue->Lock);

                    for(
                        entry = queue->DeviceListHead.Flink;
                        entry != &queue->DeviceListHead;
                        entry = entry->Flink
                        ) {

                        qIrp = CONTAINING_RECORD(
                            entry,
                            IRP,
                            Tail.Overlay.DeviceQueueEntry.DeviceListEntry
                            );

                        if (qIrp == Irp) {

                            RemoveEntryList (entry);
                            break;
                        }
                    }

                    KeReleaseSpinLockFromDpcLevel (&queue->Lock);

                    if (qIrp != Irp) {

                        Irp = NULL;
                    }
                }

                if (Irp) {

                    srb->SrbStatus = SRB_STATUS_ERROR;
                    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                    IoCompleteRequest (Irp,IO_NO_INCREMENT);

                    Sbp2StartNextPacketByKey (DeviceObject, 0);

                    IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);

                } else {

                    //
                    // Another thread processed this irp, it will take
                    // care of the cleanup
                    //

                    DEBUGPRINT1(("Sbp2Port: StartIo: ... irp NOT FOUND!\n"));
                }
            }

            return;
        }

        //
        // case 2: Reset in progress (either reconnect or login in progress)
        //
        // Queue request until we are done. When reset over, start
        // processing again.
        //

        if (TEST_FLAG(
                deviceExtension->DeviceFlags,
                DEVICE_FLAG_RESET_IN_PROGRESS
                )) {

            //
            // Queue request (twice, in case queue wasn't busy the 1st time).
            // We acquire the spinlock to prevent the case where we try to
            // insert to a non-busy queue, then a 2nd thread completing
            // the reset calls StartNextPacket (which would reset the q busy
            // flag), then we try to insert again and fail - the result
            // being deadlock since no one will restart the queue.
            //

            KeAcquireSpinLockAtDpcLevel(
                &deviceExtension->ExtensionDataSpinLock
                );

            if (TEST_FLAG(
                    deviceExtension->DeviceFlags,
                    DEVICE_FLAG_RESET_IN_PROGRESS
                    )) {

                if (Sbp2InsertByKeyDeviceQueue(
                        &DeviceObject->DeviceQueue,
                        &Irp->Tail.Overlay.DeviceQueueEntry,
                        srb->QueueSortKey
                        ) ||

                    Sbp2InsertByKeyDeviceQueue(
                        &DeviceObject->DeviceQueue,
                        &Irp->Tail.Overlay.DeviceQueueEntry,
                        srb->QueueSortKey
                        )) {

                    KeReleaseSpinLockFromDpcLevel(
                        &deviceExtension->ExtensionDataSpinLock
                        );

                    DEBUGPRINT2((
                        "Sbp2Port: StartIo: ext=x%p resetting, q irp=x%p\n",
                        deviceExtension,
                        Irp
                        ));

                    return;
                }

                KeReleaseSpinLockFromDpcLevel(
                    &deviceExtension->ExtensionDataSpinLock
                    );

                DEBUGPRINT1((
                    "Sbp2Port: StartIo: ext=x%p 2xQ err, fail irp=x%p\n",
                    deviceExtension,
                    Irp
                    ));

                ASSERT (FALSE); // should never get here

                srb->SrbStatus = SRB_STATUS_BUSY;
                Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                IoCompleteRequest(Irp,IO_NO_INCREMENT);

                return;
            }

            KeReleaseSpinLockFromDpcLevel(
                &deviceExtension->ExtensionDataSpinLock
                );
        }

        //
        // CASE 3: System is powered down, and so is device (better be).
        // Queue all requests until system comes up from sleep
        //

        if ((deviceExtension->DevicePowerState != PowerDeviceD0) &&
            (deviceExtension->SystemPowerState != PowerSystemWorking)) {

            //
            // our device is powered down AND the system is powered down.
            // just queue this request...
            //

            if (!Sbp2InsertByKeyDeviceQueue(
                    &DeviceObject->DeviceQueue,
                    &Irp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey)) {

                ASSERT(deviceExtension->PowerDeferredIrp == NULL);

                KeAcquireSpinLockAtDpcLevel(
                    &deviceExtension->ExtensionDataSpinLock
                    );

                deviceExtension->PowerDeferredIrp = Irp;

                KeReleaseSpinLockFromDpcLevel(
                    &deviceExtension->ExtensionDataSpinLock
                    );

                DEBUGPRINT2((
                    "Sbp2Port: StartIo: powered down, defer irp=x%p\n",
                    Irp
                    ));

            } else {

                DEBUGPRINT2((
                    "Sbp2Port: StartIo: powered down, q irp=%p\n",
                    Irp
                    ));
            }

            return;
        }
    }

    if (!TEST_FLAG (srb->SrbFlags, SRB_FLAGS_NO_KEEP_AWAKE)) {

        if (deviceExtension->IdleCounter) {

            PoSetDeviceBusy (deviceExtension->IdleCounter);
        }
    }

    //
    // create a context ,a CMD orb and the appropriate data descriptor
    //

    Create1394TransactionForSrb (deviceExtension, srb, &context);

    return;
}


VOID
Create1394TransactionForSrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PASYNC_REQUEST_CONTEXT *RequestContext
    )
/*++

Routine Description:

    Always called at DPC level...
    This routine is responsible for allocating all the data structures and
    getting all the 1394 addresses required for incoming scsi requests.
    It will fill in Command ORBs, create page table if necessery, and
    most importantly setup a request Context, so when the status callback
    is called, we can find the srb Associated with completed ORB. Since we
    have a FreeList, this request will always use pre-allocated contexts
    and page tables, so we dont have to do it dynamically...

Arguments:

    DeviceObject - Our device object
    Srb - SRB from class drivers,
    RequestContext - Pointer To Context used for this request.
    Mdl - MDL with data buffer for this request

Return Value:

--*/
{
    NTSTATUS status= STATUS_SUCCESS;
    PMDL requestMdl;

    PASYNC_REQUEST_CONTEXT callbackContext;

    PVOID mdlVa;

    //
    // Allocate a context for this requestfrom our freeList
    //

    callbackContext  = (PASYNC_REQUEST_CONTEXT) ExInterlockedPopEntrySList(
        &DeviceExtension->FreeContextListHead,
        &DeviceExtension->FreeContextLock
        );

    if (callbackContext) {

        callbackContext = RETRIEVE_CONTEXT(callbackContext,LookasideList);

    } else {

        DEBUGPRINT1((
            "Sbp2Port: Create1394XactForSrb: ERROR! ext=x%p, no ctx's\n",
            DeviceExtension
            ));

        status = STATUS_INSUFFICIENT_RESOURCES;
        Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        Srb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

        Sbp2CreateRequestErrorLog(DeviceExtension->DeviceObject,NULL,status);

        goto exitCreate1394ReqForSrb;
    }

    //
    // Acquire the OrbListSpinLock to serialize this OrbListDepth
    // change & save with those done in Sbp2GlobalStatusCallback
    // (when freeing async requests), to insure we won't make too
    // many or too few calls to StartNextPacket
    //

    KeAcquireSpinLockAtDpcLevel (&DeviceExtension->OrbListSpinLock);

    callbackContext->OrbListDepth = InterlockedIncrement(
        &DeviceExtension->OrbListDepth
        );

    KeReleaseSpinLockFromDpcLevel (&DeviceExtension->OrbListSpinLock);


    *RequestContext = callbackContext;

    //
    // Initialize srb-related entries in our context
    //

    callbackContext->OriginalSrb = NULL;
    callbackContext->DataMappingHandle = NULL;
    callbackContext->Packet = NULL;
    callbackContext->Tag = SBP2_ASYNC_CONTEXT_TAG;
    callbackContext->Srb = Srb;
    callbackContext->DeviceObject = DeviceExtension->DeviceObject;

    callbackContext->Flags = 0;

    //
    // filter commands so they conform to RBC..
    //

    status = Sbp2_SCSI_RBC_Conversion(callbackContext);

    if (status != STATUS_PENDING){

        //
        // the call was handled immediately. Complete the irp here...
        //

        callbackContext->Srb = NULL;
        FreeAsyncRequestContext(DeviceExtension,callbackContext);

        if (NT_SUCCESS(status)) {

            Srb->SrbStatus = SRB_STATUS_SUCCESS;

            ((PIRP) Srb->OriginalRequest)->IoStatus.Information = Srb->DataTransferLength;

        } else {

            DEBUGPRINT1((
                "Sbp2Port: Create1394XactForSrb: RBC translation failed!!!\n"
                ));

            //
            // since translation errors are always internal errors,
            // set SRB_STATUS to reflect an internal (not device) error
            //

            Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            Srb->InternalStatus = status;
            ((PIRP)Srb->OriginalRequest)->IoStatus.Information = 0;
        }

        ((PIRP)Srb->OriginalRequest)->IoStatus.Status = status;
        IoCompleteRequest (((PIRP) Srb->OriginalRequest), IO_NO_INCREMENT);

        Sbp2StartNextPacketByKey(
            DeviceExtension->DeviceObject,
            DeviceExtension->CurrentKey
            );

        IoReleaseRemoveLock (&DeviceExtension->RemoveLock, NULL);

        return;
    }

    status = STATUS_SUCCESS;

    //
    // Figure the maximum number of different 1394 addresses we need to span this request's data buffer
    //

    if ((Srb->DataTransferLength == 0) || (Srb->SrbFlags == SRB_FLAGS_NO_DATA_TRANSFER)) {

        //
        // No need to get a 1394 address for data, since there is none
        //

        Sbp2InitializeOrb (DeviceExtension, callbackContext);

    } else {

        //
        // if this request is apart of split request, we need to make our own mdl...
        //

        requestMdl = ((PIRP) Srb->OriginalRequest)->MdlAddress;

        mdlVa = MmGetMdlVirtualAddress (requestMdl);

        if (mdlVa != (PVOID) Srb->DataBuffer) {

            //
            // split request
            //

            callbackContext->PartialMdl = IoAllocateMdl(Srb->DataBuffer,Srb->DataTransferLength,FALSE,FALSE,NULL);

            if (!callbackContext->PartialMdl) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
                Srb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

                DEBUGPRINT1((
                    "Sbp2Port: Create1394XactForSrb: REQ_ALLOC addr err!\n"
                    ));

                goto exitCreate1394ReqForSrb;
            }

            IoBuildPartialMdl(requestMdl,callbackContext->PartialMdl,Srb->DataBuffer, Srb->DataTransferLength );
            requestMdl = callbackContext->PartialMdl;
            DEBUGPRINT4(("Sbp2Port: Create1394TransactionForSrb: Allocating Partial Mdl %p\n",requestMdl));

        } else {

            callbackContext->PartialMdl = NULL;
        }

        callbackContext->RequestMdl = requestMdl;

        //
        // according to what the port driver can handle, map the data buffer to 1394 addresses and create
        // an sbp2 page table if necessery
        //

        status = Sbp2BusMapTransfer(DeviceExtension,callbackContext);

        //
        // NOTE: On success, above returns STATUS_PENDING
        // all errors are internal errors.
        //

        if (!NT_SUCCESS(status)) {

            DEBUGPRINT1(("\n Sbp2Create1394TransactionForSrb failed %x\n",status));

            if (callbackContext->PartialMdl) {

                IoFreeMdl(callbackContext->PartialMdl);

                callbackContext->PartialMdl = NULL;
            }
        }
    }

exitCreate1394ReqForSrb:

    if (status == STATUS_PENDING) {

        //
        // Sbp2StartNextPacketByKey will be called when the
        // notification alloc callback is called
        //

        return;

    } else if (status == STATUS_SUCCESS) { // ISSUE-geogioc-2000/02/20 - NT_SUCCESS(status) should be used

        //
        // SUCCESS, place
        //

        Sbp2InsertTailList(DeviceExtension,callbackContext);
        return;

    } else {

        //
        // since the request could not have actually been processed by
        // the device, this is an internal error and should be propogated
        // up the stack as such.
        //

        if (callbackContext) {

            callbackContext->Srb = NULL;
            FreeAsyncRequestContext(DeviceExtension,callbackContext);
        }

        Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        Srb->InternalStatus = status;

        ((PIRP)Srb->OriginalRequest)->IoStatus.Status = status;
        ((PIRP)Srb->OriginalRequest)->IoStatus.Information = 0;

        IoCompleteRequest(((PIRP)Srb->OriginalRequest),IO_NO_INCREMENT);

        Sbp2StartNextPacketByKey (DeviceExtension->DeviceObject, 0);

        IoReleaseRemoveLock (&DeviceExtension->RemoveLock, NULL);

        return;
    }

    return;
}


NTSTATUS
Sbp2_SCSI_RBC_Conversion(
    IN PASYNC_REQUEST_CONTEXT Context
    )
/*++

Routine Description:

    Always called at DPC level...
    It translates scsi commands to their RBC equivalents, ONLY if they differ in each spec
    The translation is done before request is issued and in some cases, after the request is
    completed

Arguments:

    DeviceExtension - Sbp2 extension
    RequestContext - Pointer To Context used for this request.

Return Value:

--*/
{
    PCDB cdb;


    if (TEST_FLAG(Context->Flags, ASYNC_CONTEXT_FLAG_COMPLETED)) {

        //
        // completed request translation
        //

        if ( ((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->InquiryData.DeviceType == \
            RBC_DEVICE){

            return Rbc_Scsi_Conversion(Context->Srb,
                                &(PSCSI_REQUEST_BLOCK)Context->OriginalSrb,
                                &((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->DeviceModeHeaderAndPage,
                                FALSE,
                                ((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->InquiryData.RemovableMedia
                                );
        }

    } else {

        //
        // outgoing request translation
        //

        if (((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->InquiryData.DeviceType == \
            RBC_DEVICE){

            return Rbc_Scsi_Conversion(Context->Srb,
                                &(PSCSI_REQUEST_BLOCK)Context->OriginalSrb,
                                &((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->DeviceModeHeaderAndPage,
                                TRUE,
                                ((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->InquiryData.RemovableMedia
                                );

        } else if (((PDEVICE_EXTENSION)Context->DeviceObject->DeviceExtension)->InquiryData.DeviceType == \
            READ_ONLY_DIRECT_ACCESS_DEVICE){

            switch (Context->Srb->Cdb[0]) {

            case SCSIOP_MODE_SENSE10:

                //
                // mmc2 type of device..
                //

                cdb = (PCDB) &Context->Srb->Cdb[0];
                cdb->MODE_SENSE10.Dbd = 1;

                break;
            }
        }
    }

    return STATUS_PENDING;
}


NTSTATUS
Sbp2BusMapTransfer(
    PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT CallbackContext
    )
/*++

Routine Description:

    Always called at DPC level...
    It calls the port driver to map the data buffer to physical/1394 addresses

Arguments:

    DeviceExtension - Sbp2 extension
    RequestContext - Pointer To Context used for this request.
    Mdl - MDL with data buffer for this request

Return Value:

--*/
{
    NTSTATUS status;

#if DBG

    ULONG maxNumberOfPages;


    maxNumberOfPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
        CallbackContext->Srb->DataBuffer,
        CallbackContext->Srb->DataTransferLength
        );

    ASSERT (CallbackContext->PageTableContext.PageTable != NULL);
    ASSERT (maxNumberOfPages <= SBP2_NUM_PAGE_TABLE_ENTRIES);

#endif

    //
    // Do the DATA alloc.
    //

    SET_FLAG(CallbackContext->Flags, ASYNC_CONTEXT_FLAG_PAGE_ALLOC);
    CallbackContext->Packet = NULL;
    Sbp2AllocComplete (CallbackContext);

    DEBUGPRINT4((
        "Sbp2Port: Sbp2MapAddress: alloc done, ctx=x%p, dataHandle=x%p\n",
        CallbackContext,
        CallbackContext->DataMappingHandle
        ));

    if (TEST_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC_FAILED)) {

        CLEAR_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC);
        CLEAR_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC_FAILED);

        DEBUGPRINT1((
            "Sbp2Port: Sbp2MapAddress: (page table present) REQ_ALLOC data " \
                "err, ctx=x%p\n",
            CallbackContext
            ));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_PENDING;
}


VOID
Sbp2AllocComplete(
    IN PASYNC_REQUEST_CONTEXT CallbackContext
    )
{

    PDEVICE_EXTENSION deviceExtension = CallbackContext->DeviceObject->DeviceExtension;
    PIRBIRP packet = CallbackContext->Packet;
    PPORT_PHYS_ADDR_ROUTINE routine = deviceExtension->HostRoutineAPI.PhysAddrMappingRoutine;
    PSCSI_REQUEST_BLOCK srb;

    NTSTATUS status;
    BOOLEAN bDirectCall = FALSE;

    DEBUGPRINT4(("Sbp2AllocateComplete: ctx=x%p, flags=x%x\n",CallbackContext,CallbackContext->Flags));

    //
    // this same function is used for the alloc complete notification of a pagetable
    // AND of the actuall data tranfser. So we have to check which case this is
    // This is a simple state machine with two states:
    // startIo-> A: PAGE TABLE ALLOC -> B
    // B: DATA ALLOC ->exit
    //

    if (TEST_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_PAGE_ALLOC)) {

        CLEAR_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_PAGE_ALLOC);

        if (CallbackContext->Packet) {

            //
            // we have just received the page table alloc...
            //

            ASSERT (FALSE); // should never get here any more

        } else {

            //
            // We were called directly since a sufficient page table was
            // already in the context
            //

            AllocateIrpAndIrb (deviceExtension,&packet);

            if (!packet) {

                return;
            }

            CallbackContext->Packet = packet;
            bDirectCall = TRUE;
        }

        //
        // indicate that now we are in the DATA transfer alloc case
        //

        SET_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC);

        //
        // reuse the same irb/irp
        // prepare the irb for calling the 1394 bus/port driver synchronously
        //

        packet->Irb->FunctionNumber = REQUEST_ALLOCATE_ADDRESS_RANGE;

        //
        // we only want a call back when we get a status from the target
        // Now allocate 1394 addresses for the data buffer with no notification
        //

        packet->Irb->u.AllocateAddressRange.nLength = CallbackContext->Srb->DataTransferLength;
        packet->Irb->u.AllocateAddressRange.fulNotificationOptions = NOTIFY_FLAGS_NEVER;

        if (TEST_FLAG(CallbackContext->Srb->SrbFlags,SRB_FLAGS_DATA_IN)) {

            packet->Irb->u.AllocateAddressRange.fulAccessType = ACCESS_FLAGS_TYPE_WRITE;

        } else {

            packet->Irb->u.AllocateAddressRange.fulAccessType = ACCESS_FLAGS_TYPE_READ;
        }

        packet->Irb->u.AllocateAddressRange.fulFlags = ALLOCATE_ADDRESS_FLAGS_USE_BIG_ENDIAN;

        //
        // the callback for physical address is used to notify that the async allocate request
        // is now complete..
        //

        packet->Irb->u.AllocateAddressRange.Callback= Sbp2AllocComplete;
        packet->Irb->u.AllocateAddressRange.Context= CallbackContext;

        packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_High = 0;
        packet->Irb->u.AllocateAddressRange.Required1394Offset.Off_Low = 0;

        packet->Irb->u.AllocateAddressRange.FifoSListHead = NULL;
        packet->Irb->u.AllocateAddressRange.FifoSpinLock = NULL;

        packet->Irb->u.AllocateAddressRange.AddressesReturned = 0;
        packet->Irb->u.AllocateAddressRange.DeviceExtension = deviceExtension;
        packet->Irb->u.AllocateAddressRange.p1394AddressRange = (PADDRESS_RANGE) &(CallbackContext->PageTableContext.PageTable[0]);

        packet->Irb->u.AllocateAddressRange.Mdl = CallbackContext->RequestMdl; //MDL from original request
        packet->Irb->u.AllocateAddressRange.MaxSegmentSize = (SBP2_MAX_DIRECT_BUFFER_SIZE)/2;

        CallbackContext->Packet = packet;

        //
        // Send allocateRange request to bus driver , indicating that we dont want the irp to be freed
        // If the port driver supports a direct mapping routine, call that instead
        //

        status = (*routine) (deviceExtension->HostRoutineAPI.Context,packet->Irb);

        if (status == STATUS_SUCCESS) {

            return;

        } else {

            DEBUGPRINT1(("Sbp2Port: Sbp2AllocComplete: REQUEST_ALLOCATE Address failed, ctx=x%p, direct=%x!!\n",CallbackContext,bDirectCall));

            DeAllocateIrpAndIrb(deviceExtension,packet);
            CallbackContext->Packet = NULL;
            CallbackContext->DataMappingHandle = NULL;
            SET_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC_FAILED);

            if (bDirectCall) {

                return;

            } else {

                //
                // we were indirectly called, so the irp has already been marked pending..
                // we must abort it here and complete the context with error...
                //

                srb = CallbackContext->Srb;
                CallbackContext->Srb = NULL;

                FreeAsyncRequestContext(deviceExtension,CallbackContext);

                srb->SrbStatus = SRB_STATUS_ERROR;

                ((PIRP)srb->OriginalRequest)->IoStatus.Status = status;
                ((PIRP)srb->OriginalRequest)->IoStatus.Information = 0;

                IoCompleteRequest(((PIRP)srb->OriginalRequest),IO_NO_INCREMENT);

                Sbp2StartNextPacketByKey (deviceExtension->DeviceObject, 0);

                IoReleaseRemoveLock (&deviceExtension->RemoveLock, NULL);
                return;
            }
        }
    }

    if (TEST_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC)) {

        //
        // we have a page table so this means we just been notified that the DATA alloc is over
        // Save the handle to the data descriptor's memory range
        //

        CLEAR_FLAG(CallbackContext->Flags,ASYNC_CONTEXT_FLAG_DATA_ALLOC);

        CallbackContext->DataMappingHandle = CallbackContext->Packet->Irb->u.AllocateAddressRange.hAddressRange;

        //
        // number of page table elements required
        //

        CallbackContext->PageTableContext.NumberOfPages = CallbackContext->Packet->Irb->u.AllocateAddressRange.AddressesReturned;

        DeAllocateIrpAndIrb(deviceExtension,CallbackContext->Packet);
        CallbackContext->Packet = NULL;

        Sbp2InitializeOrb(deviceExtension,CallbackContext);
        Sbp2InsertTailList(deviceExtension,CallbackContext);
    }

    return;
}


VOID
Sbp2InitializeOrb(
    IN PDEVICE_EXTENSION DeviceExtension,
    PASYNC_REQUEST_CONTEXT CallbackContext
    )
{
    ULONG   i, size;


    //
    // zero the ORB CDB and ORB Flags fields
    //

    CallbackContext->CmdOrb->OrbInfo.QuadPart = 0;


    if (!CallbackContext->DataMappingHandle) {

        CallbackContext->PageTableContext.NumberOfPages = 0;
        CallbackContext->CmdOrb->DataDescriptor.OctletPart = 0xFFFFFFFFFFFFFFFF;

    } else {

        if (CallbackContext->PageTableContext.NumberOfPages > 1) {

            CallbackContext->CmdOrb->DataDescriptor.BusAddress = \
                CallbackContext->PageTableContext.AddressContext.Address.BusAddress;

            octbswap(CallbackContext->CmdOrb->DataDescriptor);

            //
            // If the host does not convert the table to big endian (or
            // there's an associated scatter gather list), do it here
            //

            if ((DeviceExtension->HostRoutineAPI.PhysAddrMappingRoutine == NULL)
                    ||  (CallbackContext->RequestMdl == NULL)) {

                for (i=0;i<CallbackContext->PageTableContext.NumberOfPages;i++) {

                    octbswap(CallbackContext->PageTableContext.PageTable[i]); // convert to big endian
                }
            }


            //
            // setup the cmd orb for a page table
            //

            CallbackContext->CmdOrb->OrbInfo.u.HighPart |= ORB_PAGE_TABLE_BIT_MASK;

            //
            // we define a data size equal (since we are in page table mode)
            // to number of pages. The page table has already been allocated .
            //

            CallbackContext->CmdOrb->OrbInfo.u.LowPart = (USHORT) CallbackContext->PageTableContext.NumberOfPages;

        } else {

            CallbackContext->CmdOrb->DataDescriptor = CallbackContext->PageTableContext.PageTable[0];

            //
            // If the host does not convert the table to big endian (or
            // there's an associated scatter gather list), do it here
            //

            if ((DeviceExtension->HostRoutineAPI.PhysAddrMappingRoutine == NULL)
                    ||  (CallbackContext->RequestMdl == NULL)) {

                CallbackContext->CmdOrb->DataDescriptor.BusAddress.NodeId = DeviceExtension->InitiatorAddressId;

                octbswap(CallbackContext->CmdOrb->DataDescriptor);

            } else {

                //
                // address already in big endian, just put the NodeID in the proper place
                //

                CallbackContext->CmdOrb->DataDescriptor.ByteArray.Byte0 = *((PUCHAR)&DeviceExtension->InitiatorAddressId+1);
                CallbackContext->CmdOrb->DataDescriptor.ByteArray.Byte1 = *((PUCHAR)&DeviceExtension->InitiatorAddressId);
            }

            //
            // Data size of buffer data descriptor points to
            //

            CallbackContext->CmdOrb->OrbInfo.u.LowPart = (USHORT) CallbackContext->Srb->DataTransferLength;
        }
    }

    //
    // Start building the ORB used to carry this srb
    // By default notify bit, rq_fmt field and page_size field are all zero..
    // Also the nextOrbAddress is NULL ( which is 0xFFFF..F)
    //

    CallbackContext->CmdOrb->NextOrbAddress.OctletPart = 0xFFFFFFFFFFFFFFFF;

    //
    // Max speed supported
    //

    CallbackContext->CmdOrb->OrbInfo.u.HighPart |= (0x0700 & ((DeviceExtension->MaxControllerPhySpeed) << 8));

    //
    // set notify bit for this command ORB
    //

    CallbackContext->CmdOrb->OrbInfo.u.HighPart |= ORB_NOTIFY_BIT_MASK;

    if (TEST_FLAG(CallbackContext->Srb->SrbFlags,SRB_FLAGS_DATA_IN)) {

        //
        // Read request. Set direction bit to 1
        //

        CallbackContext->CmdOrb->OrbInfo.u.HighPart |= ORB_DIRECTION_BIT_MASK;

        // Max payload size, (its entered in the orb, in the form of  2^(size+2)

        CallbackContext->CmdOrb->OrbInfo.u.HighPart |= DeviceExtension->OrbReadPayloadMask ;

    } else {

        //
        // Write request, direction bit is zero
        //

        CallbackContext->CmdOrb->OrbInfo.u.HighPart &= ~ORB_DIRECTION_BIT_MASK;
        CallbackContext->CmdOrb->OrbInfo.u.HighPart |= DeviceExtension->OrbWritePayloadMask ;
    }

    //
    // Now copy the CDB from the SRB to our ORB
    //

    ASSERT (CallbackContext->Srb->CdbLength >= 6);
    ASSERT (CallbackContext->Srb->CdbLength <= SBP2_MAX_CDB_SIZE);

    size = min (SBP2_MAX_CDB_SIZE, CallbackContext->Srb->CdbLength);

    RtlZeroMemory(&CallbackContext->CmdOrb->Cdb, SBP2_MAX_CDB_SIZE);
    RtlCopyMemory(&CallbackContext->CmdOrb->Cdb, CallbackContext->Srb->Cdb,size);

    //
    // we are done here.... convert command ORB to Big Endian...
    //

    CallbackContext->CmdOrb->OrbInfo.QuadPart = bswap(CallbackContext->CmdOrb->OrbInfo.QuadPart);
}


VOID
Sbp2InsertTailList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PASYNC_REQUEST_CONTEXT Context
    )
{
    ULONG                   orbListDepth, timeOutValue;
    OCTLET                  newAddr ;
    NTSTATUS                status;
    PASYNC_REQUEST_CONTEXT  prevCtx;


    orbListDepth = Context->OrbListDepth;

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->OrbListSpinLock);

    DeviceExtension->CurrentKey = Context->Srb->QueueSortKey+1;

    if (IsListEmpty (&DeviceExtension->PendingOrbList)) {

        //
        // Empty list, this is the first request
        // This ORB is now at end-of-list, its next_ORB address is set to NULL
        //

        Context->CmdOrb->NextOrbAddress.OctletPart = 0xFFFFFFFFFFFFFFFF;

        //
        // start the timer tracking this request
        // If the list is non empty, only the head of the list is timed...
        //

        timeOutValue = Context->Srb->TimeOutValue;

        DeviceExtension->DueTime.QuadPart =
            ((LONGLONG) timeOutValue) * (-10*1000*1000);

        SET_FLAG(Context->Flags, ASYNC_CONTEXT_FLAG_TIMER_STARTED);

        KeSetTimer(
            &Context->Timer,
            DeviceExtension->DueTime,
            &Context->TimerDpc
            );

        InsertTailList (&DeviceExtension->PendingOrbList,&Context->OrbList);
        newAddr = Context->CmdOrbAddress;

        //
        // ISSUE: Seems like we should always be able to write to the
        //        dev's orb pointer at this point, but we were seeing
        //        timeouts on some devices if we did that (notably
        //        hd's with Oxford Semiconductor silicon doing dv cam
        //        captures), so am sticking with the piggyback logic
        //        for WinXP.  This is a perf hit, because dev has to
        //        read in the old orb to get the next orb addr, then
        //        fetch the new orb.   DanKn 25-Jun-2001
        //

        if (DeviceExtension->NextContextToFree  &&
            DeviceExtension->AppendToNextContextToFree) {

            DeviceExtension->AppendToNextContextToFree = FALSE;

            //
            // There is an end-of-list ORB, just piggy back on it
            //

            octbswap (newAddr);

            DeviceExtension->NextContextToFree->CmdOrb->NextOrbAddress =
                newAddr;
            DeviceExtension->NextContextToFree->CmdOrb->NextOrbAddress.
                ByteArray.Byte0 = 0; // make Null bit zero
            DeviceExtension->NextContextToFree->CmdOrb->NextOrbAddress.
                ByteArray.Byte1 = 0; // make Null bit zero

            //
            // The guy that was the end of the list cannot be freed
            // until this ORB is fetched
            //

            KeReleaseSpinLockFromDpcLevel (&DeviceExtension->OrbListSpinLock);

            DEBUGPRINT3((
                "Sbp2Port: InsertTailList: empty, ring bell, ctx=x%p\n",
                Context
                ));

            status = Sbp2AccessRegister(
                DeviceExtension,
                &DeviceExtension->Reserved,
                DOORBELL_REG | REG_WRITE_ASYNC
                );

        } else {

            //
            // list is empty, write directly to orb_pointer
            //

            KeReleaseSpinLockFromDpcLevel (&DeviceExtension->OrbListSpinLock);

            DEBUGPRINT3((
                "Sbp2Port: InsertTailList: write ORB_PTR, ctx=x%p\n",
                Context
                ));

            status = Sbp2AccessRegister(
                DeviceExtension,
                &newAddr,
                ORB_POINTER_REG | REG_WRITE_ASYNC
                );
        }

        //
        // The following handles the case where a device is removed
        // while machine is on standby, and then machine is resumed.
        // In the storage case, classpnp.sys sends down a start unit
        // srb (in reponse to the power D-irp) with a timeout of
        // 240 seconds.  The problem is that sbp2port.sys does not get
        // notified of the remove until *after* the start unit has
        // timed out (the power irp blocks the pnp irp), and the user
        // gets a bad 240-second wait experience.
        //
        // So what we do here in the case of an invalid generation error
        // & a lengthy timeout is to reset the timer with a more reasonable
        // timeout value.  If the device is still around the bus reset
        // notification routine should get called & clean everything up
        // anyway, and same goes for normal remove (while machine is not
        // hibernated).
        //

        if (status == STATUS_INVALID_GENERATION) {

            KeAcquireSpinLockAtDpcLevel (&DeviceExtension->OrbListSpinLock);

            if ((DeviceExtension->PendingOrbList.Flink == &Context->OrbList) &&
                (timeOutValue > 5)) {

                KeCancelTimer (&Context->Timer);

                DeviceExtension->DueTime.QuadPart = (-5 * 10 * 1000 * 1000);

                KeSetTimer(
                    &Context->Timer,
                    DeviceExtension->DueTime,
                    &Context->TimerDpc
                    );
#if DBG
                timeOutValue = 1;

            } else {

                timeOutValue = 0;
#endif
            }

            KeReleaseSpinLockFromDpcLevel (&DeviceExtension->OrbListSpinLock);

            if (timeOutValue) {

                DEBUGPRINT1((
                    "Sbp2port: InsertTailList: ext=x%p, lowered req timeout\n",
                    DeviceExtension
                    ));
            }
        }

    } else {

        //
        // We have already a list in memory. Append this request to list,
        // modify last request's ORB to point to this ORB.
        //

        newAddr = Context->CmdOrbAddress;

        //
        // Init the list pointer for this request context
        //

        Context->CmdOrb->NextOrbAddress.OctletPart = 0xFFFFFFFFFFFFFFFF;

        //
        // Modify the previous request's command ORB next_ORB address,
        // to point to this ORB.  Convert our address to BigEndian first,
        // since the prev command ORB is stored in BigEndian.
        //
        // Note that the previous end-of-list orb may be the completed
        // one pointed at by NextContextToFree (rather the last one in
        // the PendingOrbList), and AppendToNextContextToFree will tell
        // whether that is really the case.
        //

        octbswap (newAddr);

        if (DeviceExtension->NextContextToFree  &&
            DeviceExtension->AppendToNextContextToFree) {

            prevCtx = DeviceExtension->NextContextToFree;

            DeviceExtension->AppendToNextContextToFree = FALSE;

        } else {

            prevCtx = (PASYNC_REQUEST_CONTEXT)
                DeviceExtension->PendingOrbList.Blink;
        }

        prevCtx->CmdOrb->NextOrbAddress = newAddr;
        prevCtx->CmdOrb->NextOrbAddress.ByteArray.Byte0 = 0; //make addr active
        prevCtx->CmdOrb->NextOrbAddress.ByteArray.Byte1 = 0;

        //
        // update the end of list
        //

        InsertTailList (&DeviceExtension->PendingOrbList, &Context->OrbList);

        KeReleaseSpinLockFromDpcLevel (&DeviceExtension->OrbListSpinLock);

        DEBUGPRINT3((
            "Sbp2Port: InsertTailList: ring bell, !empty, dep=%d, ctx=x%p\n",
            DeviceExtension->OrbListDepth,
            Context
            ));

        //
        // Ring the door bell to notify the target that our linked list
        // of ORB's has changed
        //

        Sbp2AccessRegister(
            DeviceExtension,
            &DeviceExtension->Reserved,
            DOORBELL_REG | REG_WRITE_ASYNC
            );
    }

    if (orbListDepth < DeviceExtension->MaxOrbListDepth) {

        Sbp2StartNextPacketByKey(
            DeviceExtension->DeviceObject,
            DeviceExtension->CurrentKey
            );
    }
}


NTSTATUS
Sbp2IssueInternalCommand(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN UCHAR Scsiop
    )
/*++

Routine Description:

    This routine will a SCSI inquiry command to the target, so we can retireve information about the device
    It should be called only after login and BEFORE we start issueing requests to the device
    It copies the inquiry data into the device extension, for future use

Arguments:

    DeviceExtension - extension for sbp2 driver

Return Value:

--*/

{
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    PSENSE_DATA         senseInfoBuffer;
    NTSTATUS            status = STATUS_INSUFFICIENT_RESOURCES;
    ULONG               retryCount = 0;
    PREQUEST_CONTEXT    context = NULL;
    PMDL                inquiryMdl;
    PIRP                irp;
    PIO_STACK_LOCATION  irpStack;
    PMDL                modeMdl;
    KEVENT              event;
    LARGE_INTEGER       waitValue;
    ULONG               i;

    //
    // Sense buffer is in non-paged pool.
    //

    context = ExAllocateFromNPagedLookasideList(&DeviceExtension->BusRequestContextPool);

    if (!context) {

        DEBUGPRINT1(("Sbp2Port: IssueIntl: can't allocate request context\n"));
        return status;
    }

    context->RequestType = SYNC_1394_REQUEST;
    context->DeviceExtension = DeviceExtension;
    context->Packet = NULL;

    senseInfoBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                      SENSE_BUFFER_SIZE,'2pbs');

    if (senseInfoBuffer == NULL) {

        DEBUGPRINT1(("Sbp2Port: IssueIntl: can't allocate request sense buffer\n"));
        return status;
    }

    srb = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                         sizeof(SCSI_REQUEST_BLOCK),'2pbs');

    if (srb == NULL) {

        ExFreePool(senseInfoBuffer);

        ExFreeToNPagedLookasideList(&DeviceExtension->BusRequestContextPool, context);

        DEBUGPRINT1(("Sbp2Port: IssueIntl: can't allocate request sense buffer\n"));
        return status;
    }

    irp = IoAllocateIrp((CCHAR)(DeviceExtension->DeviceObject->StackSize), FALSE);

    if (irp == NULL) {

        ExFreePool(senseInfoBuffer);
        ExFreePool(srb);

        ExFreeToNPagedLookasideList(&DeviceExtension->BusRequestContextPool, context);

        DEBUGPRINT1(("Sbp2Port: IssueIntl: can't allocate IRP\n"));
        return status;
    }

    do {

        //
        // Construct the IRP stack for the lower level driver.
        //

        irpStack = IoGetNextIrpStackLocation(irp);
        irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
        irpStack->Parameters.Scsi.Srb = srb;

        //
        // Fill in SRB fieldsthat Create1394RequestFromSrb needs.
        //

        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->Length = sizeof(SCSI_REQUEST_BLOCK);

        //
        // Set flags to disable synchronous negociation.
        //

        srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

        srb->SrbStatus = srb->ScsiStatus = 0;

        //
        // Set timeout to 12 seconds.
        //

        srb->TimeOutValue = 24;

        srb->CdbLength = 6;

        //
        // Enable auto request sense.
        //

        srb->SenseInfoBuffer = senseInfoBuffer;
        srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

        cdb = (PCDB)srb->Cdb;

        switch (Scsiop) {

        case SCSIOP_INQUIRY:

            srb->DataBuffer = &DeviceExtension->InquiryData;
            srb->DataTransferLength = INQUIRYDATABUFFERSIZE;

            //
            // Set CDB LUN.
            //

            cdb->CDB6INQUIRY.LogicalUnitNumber = (UCHAR) DeviceExtension->DeviceInfo->Lun.u.LowPart;
            cdb->CDB6INQUIRY.Reserved1 = 0;
            cdb->CDB6INQUIRY.AllocationLength = INQUIRYDATABUFFERSIZE;


            //
            // Zero reserve field and
            // Set EVPD Page Code to zero.
            // Set Control field to zero.
            // (See SCSI-II Specification.)
            //

            cdb->CDB6INQUIRY.PageCode = 0;
            cdb->CDB6INQUIRY.IReserved = 0;
            cdb->CDB6INQUIRY.Control = 0;

            if (!retryCount) {

                inquiryMdl = IoAllocateMdl(&DeviceExtension->InquiryData, INQUIRYDATABUFFERSIZE,FALSE,FALSE,NULL);

                if (!inquiryMdl) {

                    goto exitSbp2Internal;
                }

                MmBuildMdlForNonPagedPool(inquiryMdl);
            }

            irp->MdlAddress = inquiryMdl;

            break;

        case SCSIOP_MODE_SENSE:

            srb->DataBuffer = &DeviceExtension->DeviceModeHeaderAndPage;
            srb->DataTransferLength = sizeof(DeviceExtension->DeviceModeHeaderAndPage);

            //
            // Setup CDB.
            //

            cdb->MODE_SENSE.Dbd      = 1;   // disable block descriptors
            cdb->MODE_SENSE.PageCode = MODE_PAGE_RBC_DEVICE_PARAMETERS;
            cdb->MODE_SENSE.Pc       = 0;   // get current values
            cdb->MODE_SENSE.AllocationLength = sizeof(DeviceExtension->DeviceModeHeaderAndPage);

            if (!retryCount) {

                modeMdl = IoAllocateMdl(
                    &DeviceExtension->DeviceModeHeaderAndPage,
                    sizeof (DeviceExtension->DeviceModeHeaderAndPage),
                    FALSE,
                    FALSE,
                    NULL
                    );

                if (!modeMdl) {

                    goto exitSbp2Internal;
                }

                MmBuildMdlForNonPagedPool(modeMdl);
            }

            irp->MdlAddress = modeMdl;

            break;
        }

        //
        // Set CDB operation code.
        //

        cdb->CDB6GENERIC.OperationCode = Scsiop;

        srb->OriginalRequest = irp;

        KeInitializeEvent(&context->Event,
                          NotificationEvent,
                          FALSE);

        IoSetCompletionRoutine(irp,
                               Sbp2RequestCompletionRoutine,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);

        DEBUGPRINT2(("Sbp2Port: IssueIntl: sending scsiop x%x, irp=x%p\n", Scsiop, irp));

        status = IoCallDriver(DeviceExtension->DeviceObject, irp);


        if(!NT_SUCCESS(irp->IoStatus.Status) && status!=STATUS_PENDING) {

            status = irp->IoStatus.Status;
            DEBUGPRINT1(("Sbp2Port: IssueIntl: scsiop=x%x irp=x%p err, sts=x%x srbSts=x%x\n",Scsiop,irp, status,srb->SrbStatus));
            break;
        }

        KeWaitForSingleObject (&context->Event, Executive, KernelMode, FALSE, NULL);

        if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

            DEBUGPRINT3(("Sbp2Port: IssueIntl: scsiop=x%x err, srbSts=%x\n",Scsiop, srb->SrbStatus));

            if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

                DEBUGPRINT1(("Sbp2Port: IssueIntl: Data underrun \n"));

                status = STATUS_SUCCESS;

            } else if ((srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                 senseInfoBuffer->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST){

                 //
                 // A sense key of illegal request was recieved.  This indicates
                 // that the logical unit number of not valid but there is a
                 // target device out there.
                 //

                 status = STATUS_INVALID_DEVICE_REQUEST;
                 retryCount++;

            } else {

                //
                // If the device timed out the request chances are the
                // irp will have been completed by CleanupOrbList with
                // and SRB...FLUSHED error, and we don't want to
                // entertain any devices which are timing out requests
                //

                if ((SRB_STATUS(srb->SrbStatus) ==
                        SRB_STATUS_REQUEST_FLUSHED) &&

                    (retryCount > 0)) {

                    status = STATUS_DEVICE_BUSY;
                    break;
                }

                retryCount++;

                DEBUGPRINT1((
                    "Sbp2Port: IssueIntl: ext=x%p, cdb=x%x, retry %d\n",
                    DeviceExtension,
                    Scsiop,
                    retryCount
                    ));

                status = STATUS_UNSUCCESSFUL;
            }

            //
            // If unsuccessful & a reset is in progress & retries not max'd
            // then give things some time to settle before retry. Check at
            // one second intervals for a few seconds to give soft & hard
            // resets time to complete  :
            //
            //     SBP2_RESET_TIMEOUT + SBP2_HARD_RESET_TIMEOUT + etc
            //

            if ((status != STATUS_SUCCESS)  &&

                (DeviceExtension->DeviceFlags &
                    DEVICE_FLAG_RESET_IN_PROGRESS) &&

                (retryCount < 3)) {

                DEBUGPRINT1((
                    "Sbp2Port: IssueIntl: ext=x%p, reset in progress, " \
                        "so wait...\n",
                    DeviceExtension,
                    Scsiop,
                    retryCount
                    ));

                for (i = 0; i < 6; i++) {

                    ASSERT(InterlockedIncrement(&DeviceExtension->ulInternalEventCount) == 1);

                    KeInitializeEvent (&event, NotificationEvent, FALSE);

                    waitValue.QuadPart = -1 * 1000 * 1000 * 10;

                    KeWaitForSingleObject(
                        &event,
                        Executive,
                        KernelMode,
                        FALSE,
                        &waitValue
                        );

                    ASSERT(InterlockedDecrement(&DeviceExtension->ulInternalEventCount) == 0);

                    if (!(DeviceExtension->DeviceFlags &
                            DEVICE_FLAG_RESET_IN_PROGRESS)) {

                        break;
                    }
                }
            }

        } else {

            status = STATUS_SUCCESS;
        }

    } while ((retryCount < 3)  &&  (status != STATUS_SUCCESS));

exitSbp2Internal:

    //
    // Free request sense buffer.
    //

    ExFreePool(senseInfoBuffer);
    ExFreePool(srb);

    IoFreeMdl(irp->MdlAddress);
    IoFreeIrp(irp);

    ExFreeToNPagedLookasideList(&DeviceExtension->BusRequestContextPool, context);

    return status;
}

NTSTATUS
Sbp2_ScsiPassThrough(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          Direct
    )
{
    PDEVICE_EXTENSION       PdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS                ntStatus;
    PIO_SCSI_CAPABILITIES   ioCapabilities;

    PAGED_CODE();

    TRACE(TL_SCSI_INFO, ("DeviceObject = 0x%x  PdoExtension = 0x%x", DeviceObject, PdoExtension));

    if (TEST_FLAG(PdoExtension->DeviceFlags, DEVICE_FLAG_CLAIMED)) {

        TRACE(TL_SCSI_WARNING, ("Sbp2_ScsiPassThrough: device is claimed."));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        goto Exit_Sbp2_ScsiPassThrough;
    }

    //  TODO: save this in the device extension
    ioCapabilities = ExAllocatePool(NonPagedPool, sizeof(IO_SCSI_CAPABILITIES));

    if (!ioCapabilities) {

        TRACE(TL_SCSI_ERROR, ("Failed to allocate ioCapabilities!"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit_Sbp2_ScsiPassThrough;
    }

    RtlZeroMemory(ioCapabilities, sizeof(IO_SCSI_CAPABILITIES));

    ioCapabilities->Length = sizeof(IO_SCSI_CAPABILITIES);
    ioCapabilities->MaximumTransferLength = PdoExtension->DeviceInfo->MaxClassTransferSize;
    ioCapabilities->MaximumPhysicalPages = ioCapabilities->MaximumTransferLength/PAGE_SIZE;
    ioCapabilities->SupportedAsynchronousEvents = 0; // ??
    ioCapabilities->AlignmentMask = DeviceObject->AlignmentRequirement;
    ioCapabilities->TaggedQueuing = FALSE; // ??
    ioCapabilities->AdapterScansDown = FALSE;
    ioCapabilities->AdapterUsesPio = FALSE;

    ntStatus = PortSendPassThrough( DeviceObject,
                                    Irp,
                                    Direct,
                                    0,
                                    ioCapabilities
                                    );

    if (!NT_SUCCESS(ntStatus)) {

        TRACE(TL_SCSI_ERROR, ("PortSendPassThrough Failed = 0x%x", ntStatus));
    }

    ExFreePool(ioCapabilities);

Exit_Sbp2_ScsiPassThrough:

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(ntStatus);
} // Sbp2_ScsiPassThrough

BOOLEAN
ConvertSbp2SenseDataToScsi(
    IN PSTATUS_FIFO_BLOCK StatusBlock,
    OUT PUCHAR SenseBuffer,
    ULONG SenseBufferLength
    )
/*++

Routine Description:

    This routine will convert the sense information returned in an SBP-2 status block, to SCSI-2/3 sense data
    and put them the translated on the SenseBuffer passed as an argument

Arguments:

    StatusBlock - Sbp2 staus for completed ORB
    SenseBuffer - Buffer to fill in with translated Sense Data. This buffer comes with the original SRB

Return Value:

--*/
{
    BOOLEAN validSense = FALSE;

    if (!SenseBuffer || (SenseBufferLength < 0xE) ) {

        return FALSE;
    }

    RtlZeroMemory(SenseBuffer,SenseBufferLength);

    //
    // determine sense error code
    //

    if ((StatusBlock->Contents[0].ByteArray.Byte0 & STATUS_BLOCK_SFMT_MASK) == SENSE_DATA_STATUS_BLOCK ) {

        SenseBuffer[0] = 0x70;
        validSense = TRUE;

    } else if ((StatusBlock->Contents[0].ByteArray.Byte0 & STATUS_BLOCK_SFMT_MASK) == SENSE_DATA_DEFF_STATUS_BLOCK){

        SenseBuffer[0] = 0x71;
        validSense = TRUE;
    }

    if (validSense) {

        SenseBuffer[0] |= 0x80 & StatusBlock->Contents[0].ByteArray.Byte1; // valid bit

        SenseBuffer[1] = 0; // segment number not supported in sbp2

        SenseBuffer[2] = (0x70 & StatusBlock->Contents[0].ByteArray.Byte1) << 1; // filemark bit, eom bit, ILI bit
        SenseBuffer[2] |= 0x0f & StatusBlock->Contents[0].ByteArray.Byte1; // sense key

        SenseBuffer[3] = StatusBlock->Contents[0].ByteArray.Byte4; // Information field
        SenseBuffer[4] = StatusBlock->Contents[0].ByteArray.Byte5;
        SenseBuffer[5] = StatusBlock->Contents[0].ByteArray.Byte6;
        SenseBuffer[6] = StatusBlock->Contents[0].ByteArray.Byte7;

        SenseBuffer[7] = 0xb; // additional sense length

        SenseBuffer[8] = StatusBlock->Contents[1].ByteArray.Byte0; // Command Block dependent bytes
        SenseBuffer[9] = StatusBlock->Contents[1].ByteArray.Byte1;
        SenseBuffer[10] = StatusBlock->Contents[1].ByteArray.Byte2;
        SenseBuffer[11] = StatusBlock->Contents[1].ByteArray.Byte3;

        SenseBuffer[12] = StatusBlock->Contents[0].ByteArray.Byte2; // sense code
        SenseBuffer[13] = StatusBlock->Contents[0].ByteArray.Byte3; // additional sense code qualifier

        if (SenseBufferLength >= SENSE_BUFFER_SIZE ) {

            // FRU byte

            SenseBuffer[14] |= StatusBlock->Contents[1].ByteArray.Byte4;

            // Sense key dependent bytes

            SenseBuffer[15] = StatusBlock->Contents[1].ByteArray.Byte5;
            SenseBuffer[16] = StatusBlock->Contents[1].ByteArray.Byte6;
            SenseBuffer[17] = StatusBlock->Contents[1].ByteArray.Byte7;
        }
    }

    return validSense;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\init.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    port.c

Abstract:

    This is the NT SCSI port driver.  This file contains the initialization
    code.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "port.h"

#define __FILE_ID__ 'init'

#if DBG
static const char *__file__ = __FILE__;
#endif

//
// Instantiate GUIDs for this module
//
#include <initguid.h>
#include <devguid.h>
#include <ntddstor.h>
#include <wdmguid.h>

ULONG ScsiPortLegacyAdapterDetection = FALSE;
PVOID ScsiDirectory = NULL;

//
// Global list of adapter device objects.  This is used to maintain a tag
// value for all the adapters.  This tag is used as a lookup key by the
// lookaside list allocators in order to find the device object.
//

KSPIN_LOCK ScsiGlobalAdapterListSpinLock;
PDEVICE_OBJECT *ScsiGlobalAdapterList = (PVOID) -1;
ULONG ScsiGlobalAdapterListElements = 0;

//
// Indicates that the system can handle 64 bit physical addresses.
//

ULONG Sp64BitPhysicalAddresses = FALSE;

//
// Debugging switches.
//

ULONG SpRemapBuffersByDefault = FALSE;

#if defined(NEWQUEUE)
//
// Default values that dictate the number of requests we will handle per zone
// before advancing to the next zone and the number of consecutive requests we
// will handle to a given sector before advancing off that sector.  These
// values may be modified through through registry settings.
// 

ULONG SpPerZoneLimit = 1000;
ULONG SpPerBlockLimit = 5;
#endif // NEWQUEUE

VOID
SpCreateScsiDirectory(
    VOID
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

ULONG
SpGetBusData(
    IN PADAPTER_EXTENSION Adapter,
    IN PDEVICE_OBJECT Pdo OPTIONAL,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

NTSTATUS
SpAllocateDriverExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PSCSIPORT_DRIVER_EXTENSION *DriverExtension
    );

ULONG
SpQueryPnpInterfaceFlags(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN INTERFACE_TYPE InterfaceType
    );

NTSTATUS
SpInitializeSrbDataLookasideList(
    IN PDEVICE_OBJECT AdapterObject
    );

VOID
SpInitializeRequestSenseParams(
    IN PADAPTER_EXTENSION AdapterExtension
    );

VOID
SpInitializePerformanceParams(
    IN PADAPTER_EXTENSION AdapterExtension
    );

VOID
SpInitializePowerParams(
    IN PADAPTER_EXTENSION AdapterExtension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortInitialize)
#pragma alloc_text(PAGE, SpAllocateDriverExtension)

#pragma alloc_text(PAGE, SpGetCommonBuffer)
#pragma alloc_text(PAGE, SpInitializeConfiguration)
#pragma alloc_text(PAGE, SpBuildResourceList)
#pragma alloc_text(PAGE, SpParseDevice)
#pragma alloc_text(PAGE, GetPciConfiguration)
#pragma alloc_text(PAGE, SpBuildConfiguration)

#pragma alloc_text(PAGE, SpQueryPnpInterfaceFlags)
#pragma alloc_text(PAGE, SpConfigurationCallout)

#pragma alloc_text(PAGE, SpReportNewAdapter)
#pragma alloc_text(PAGE, SpCreateAdapter)
#pragma alloc_text(PAGE, SpInitializeAdapterExtension)
#pragma alloc_text(PAGE, ScsiPortInitLegacyAdapter)
#pragma alloc_text(PAGE, SpAllocateAdapterResources)
#pragma alloc_text(PAGE, SpOpenDeviceKey)
#pragma alloc_text(PAGE, SpOpenParametersKey)
#pragma alloc_text(PAGE, SpInitializeRequestSenseParams)
#pragma alloc_text(PAGE, SpInitializePerformanceParams)
#pragma alloc_text(PAGE, SpInitializePowerParams)

#pragma alloc_text(PAGE, SpGetRegistryValue)

#pragma alloc_text(PAGELOCK, SpInitializeSrbDataLookasideList)

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SpCreateScsiDirectory)

#endif


ULONG
ScsiPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext OPTIONAL
    )

/*++

Routine Description:

    This routine initializes the port driver.

Arguments:

    Argument1 - Pointer to driver object created by system
    HwInitializationData - Miniport initialization structure
    HwContext - Value passed to miniport driver's config routine

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PDRIVER_OBJECT    driverObject = Argument1;
    PSCSIPORT_DRIVER_EXTENSION driverExtension;

    PUNICODE_STRING   registryPath = (PUNICODE_STRING) Argument2;

    ULONG pnpInterfaceFlags;

    NTSTATUS status;

    PAGED_CODE();
    
    //
    // If the global adapter list pointer is negative one then we need to do
    // our global initialization.  This includes creating the scsi directory
    // and initializing the spinlock for protecting the global adapter list.
    //

    if(((LONG_PTR)ScsiGlobalAdapterList) == -1) {

        ScsiGlobalAdapterList = NULL;
        ScsiGlobalAdapterListElements = 0;

        KeInitializeSpinLock(&ScsiGlobalAdapterListSpinLock);

        ScsiPortInitializeDispatchTables();

        SpCreateScsiDirectory();

        status = SpInitializeGuidInterfaceMapping(driverObject);

        if(!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Create the SCSI device map in the registry.
        //

        SpInitDeviceMap();

        //
        // Determine if the system can do 64-bit physical addresses.
        //

        Sp64BitPhysicalAddresses = SpDetermine64BitSupport();
    }

    //
    // Check that the length of this structure is equal to or less than
    // what the port driver expects it to be. This is effectively a
    // version check.
    //

    if (HwInitializationData->HwInitializationDataSize > sizeof(HW_INITIALIZATION_DATA)) {

        DebugPrint((0,"ScsiPortInitialize: Miniport driver wrong version\n"));
        return (ULONG) STATUS_REVISION_MISMATCH;
    }

    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwInitialize) ||
        (!HwInitializationData->HwFindAdapter) ||
        (!HwInitializationData->HwStartIo) ||
        (!HwInitializationData->HwResetBus)) {

        DebugPrint((0,
            "ScsiPortInitialize: Miniport driver missing required entry\n"));

        return (ULONG) STATUS_REVISION_MISMATCH;
    }

    //
    // Try to allocate a driver extension
    //

    driverExtension = IoGetDriverObjectExtension(driverObject,
                                                 ScsiPortInitialize);

    if (driverExtension == NULL) {

        //
        // None exists for this key so we need to initialize the new one
        //

        status = SpAllocateDriverExtension(driverObject,
                                           registryPath,
                                           &driverExtension);

        if(!NT_SUCCESS(status)) {

            //
            // Something else went wrong - we cannot continue.
            //

            DebugPrint((0, "ScsiPortInitialize: Error %#08lx allocating driver "
                           "extension - cannot continue\n", status));

            return status;
        }

    }

    //
    // Set up the device driver entry points.
    //

    driverObject->DriverStartIo = ScsiPortStartIo;

    driverObject->MajorFunction[IRP_MJ_SCSI] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_CREATE] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_CLOSE] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_PNP] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ScsiPortGlobalDispatch;
    driverObject->MajorFunction[IRP_MJ_POWER] = ScsiPortGlobalDispatch;

    //
    // Set up the device driver's pnp-power routine, add routine and unload
    // routine
    //

    driverObject->DriverExtension->AddDevice = ScsiPortAddDevice;
    driverObject->DriverUnload = ScsiPortUnload;

    //
    // Find out if this interface type is safe for this adapter
    //

    pnpInterfaceFlags = SpQueryPnpInterfaceFlags(
                            driverExtension,
                            HwInitializationData->AdapterInterfaceType);

    //
    // Special handling for the "Internal" interface type
    //

    if(HwInitializationData->AdapterInterfaceType == Internal) {

        if (TEST_FLAG(pnpInterfaceFlags, SP_PNP_IS_SAFE) == SP_PNP_NOT_SAFE) {
            return STATUS_NO_SUCH_DEVICE;
        }
    }

    //
    // If there's a chance this interface can handle pnp then store away
    // the interface information.
    //

    if(TEST_FLAG(pnpInterfaceFlags, SP_PNP_IS_SAFE)) {

        PSP_INIT_CHAIN_ENTRY entry = NULL;
        PSP_INIT_CHAIN_ENTRY *nextEntry = &(driverExtension->InitChain);

        //
        // Run to the end of the chain and make sure we don't have any information
        // about this interface type already
        //

        while(*nextEntry != NULL) {

            if((*nextEntry)->InitData.AdapterInterfaceType ==
               HwInitializationData->AdapterInterfaceType) {

                //
                // We already have enough information about this interface type
                //

                return STATUS_SUCCESS;
            }

            nextEntry = &((*nextEntry)->NextEntry);

        }

        //
        // Allocate an init chain entry to store the config information away in
        //

        entry = SpAllocatePool(NonPagedPool,
                               sizeof(SP_INIT_CHAIN_ENTRY),
                               SCSIPORT_TAG_INIT_CHAIN,
                               driverObject);

        if(entry == NULL) {
            
            DebugPrint((1, "ScsiPortInitialize: couldn't allocate chain entry\n"));

            return (ULONG) STATUS_INSUFFICIENT_RESOURCES;

        }

        RtlCopyMemory(&(entry->InitData),
                      HwInitializationData,
                      sizeof(HW_INITIALIZATION_DATA));

        //
        // Stick this entry onto the end of the chain
        //

        entry->NextEntry = NULL;
        *nextEntry = entry;
    }

    //
    // There are two possible reasons we might be doing this in legacy
    // mode.  If it's an internal bus type we always detect.  Otherwise, if
    // the interface isn't safe for pnp we'll use the legacy path.  Or if
    // the registry indicates we should do detection for this miniport AND
    // the pnp interface flags indicate that this bus may not be enumerable
    // we'll hit the legacy path.
    //

#if !defined(NO_LEGACY_DRIVERS)

    if((TEST_FLAG(pnpInterfaceFlags, SP_PNP_IS_SAFE) == FALSE) ||
       (driverExtension->LegacyAdapterDetection &&
        TEST_FLAG(pnpInterfaceFlags, SP_PNP_NON_ENUMERABLE))) {

        //
        // If we're supposed to detect this device then just call directly into
        // SpInitLegacyAdapter to find what we can find
        //

        DebugPrint((1, "ScsiPortInitialize: flags = %#08lx & LegacyAdapterDetection = %d\n",
                    pnpInterfaceFlags, driverExtension->LegacyAdapterDetection));

        DebugPrint((1, "ScsiPortInitialize: Doing Legacy Adapter detection\n"));

        status = ScsiPortInitLegacyAdapter(driverExtension,
                                           HwInitializationData,
                                           HwContext);

    }

#endif // NO_LEGACY_DRIVERS

    //
    // Always return success if there's an interface which can handle pnp,
    // even if the detection fails.
    //

    if(driverExtension->SafeInterfaceCount != 0) {
        status = STATUS_SUCCESS;
    }

    return status;
}


PVOID
ScsiPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    SCSI_PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine maps an IO address to system address space.
    Use ScsiPortFreeDeviceBase to unmap address.

Arguments:

    HwDeviceExtension - used to find port device extension.
    BusType - what type of bus - eisa, mca, isa
    SystemIoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.
    InIoSpace - indicates an IO address.

Return Value:

    Mapped address.

--*/

{
    PADAPTER_EXTENSION adapter = GET_FDO_EXTENSION(HwDeviceExtension);
    BOOLEAN isReinit;
    PHYSICAL_ADDRESS cardAddress;
    ULONG addressSpace = InIoSpace;
    PVOID mappedAddress = NULL;
    PMAPPED_ADDRESS newMappedAddress;
    BOOLEAN b = FALSE;

    isReinit = (TEST_FLAG(adapter->Flags, PD_MINIPORT_REINITIALIZING) ==
                PD_MINIPORT_REINITIALIZING);

    //
    // If a set of resources was provided to the miniport for this adapter then
    // get the translation out of the resource lists provided.
    //

    if(!adapter->IsMiniportDetected) {

        CM_PARTIAL_RESOURCE_DESCRIPTOR translation;

        b = SpFindAddressTranslation(adapter,
                                     BusType,
                                     SystemIoBusNumber,
                                     IoAddress,
                                     NumberOfBytes,
                                     InIoSpace,
                                     &translation);

        if(b) {

            cardAddress = translation.u.Generic.Start;
            addressSpace = (translation.Type == CmResourceTypePort) ? 1 : 0;
        } else {

            DebugPrint((1, "ScsiPortGetDeviceBase: SpFindAddressTranslation failed. %s Address = %lx\n",
            InIoSpace ? "I/O" : "Memory", IoAddress.LowPart));

        }
    }

    if((isReinit == FALSE) && (b == FALSE)) {

        //
        // This isn't a reinitialization.  Either the miniport is not pnp
        // or it asked for something that it wasn't assigned.  Unfortunately
        // we need to deal with both cases for the time being.
        //

        b = HalTranslateBusAddress(
                BusType,
                SystemIoBusNumber,
                IoAddress,
                &addressSpace,
                &cardAddress
                );
    }

    if (b == FALSE) {

        //
        // Still no translated address.  Error
        //

        DebugPrint((1, "ScsiPortGetDeviceBase: Translate bus address "
                       "failed. %s Address = %lx\n",
        InIoSpace ? "I/O" : "Memory", IoAddress.LowPart));
        return NULL;
    }

    //
    // Map the device base address into the virtual address space
    // if the address is in memory space.
    //

    if ((isReinit == FALSE) && (addressSpace == FALSE)) {

        //
        // We're not reinitializing and we need to map the address space.
        // Use MM to do the mapping.
        //

        newMappedAddress = SpAllocateAddressMapping(adapter);

        if(newMappedAddress == NULL) {
            DebugPrint((0, "ScsiPortGetDeviceBase: could not find free block "
                           "to track address mapping - returning NULL\n"));
            return NULL;
        }

        mappedAddress = MmMapIoSpace(cardAddress,
                                     NumberOfBytes,
                                     FALSE);

        //
        // Store mapped address, bytes count, etc.
        //

        newMappedAddress->MappedAddress = mappedAddress;
        newMappedAddress->NumberOfBytes = NumberOfBytes;
        newMappedAddress->IoAddress = IoAddress;
        newMappedAddress->BusNumber = SystemIoBusNumber;

    } else if ((isReinit == TRUE) && (addressSpace == FALSE)) {

        ULONG i;

        //
        // This is a reinitialization - we should already have the mapping
        // for the address saved away in our list.
        //

        newMappedAddress = SpFindMappedAddress(adapter,
                                               IoAddress,
                                               NumberOfBytes,
                                               SystemIoBusNumber);

        if(newMappedAddress != NULL) {
            mappedAddress = newMappedAddress->MappedAddress;
            return mappedAddress;
        }

        //
        // We should always find the mapped address here if the miniport
        // is behaving itself.
        //

        KeBugCheckEx(PORT_DRIVER_INTERNAL,
                     0,
                     0,
                     0,
                     0);

    } else {

        mappedAddress = (PVOID)(ULONG_PTR)cardAddress.QuadPart;
    }

    return mappedAddress;

} // end ScsiPortGetDeviceBase()


VOID
ScsiPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )

/*++

Routine Description:

    This routine unmaps an IO address that has been previously mapped
    to system address space using ScsiPortGetDeviceBase().

Arguments:

    HwDeviceExtension - used to find port device extension.
    MappedAddress - address to unmap.
    NumberOfBytes - number of bytes mapped.
    InIoSpace - address is in IO space.

Return Value:

    None

--*/

{
    PADAPTER_EXTENSION adapter;
    ULONG i;
    PMAPPED_ADDRESS nextMappedAddress;
    PMAPPED_ADDRESS lastMappedAddress;

    adapter = GET_FDO_EXTENSION(HwDeviceExtension);
    SpFreeMappedAddress(adapter, MappedAddress);
    return;

} // end ScsiPortFreeDeviceBase()


PVOID
ScsiPortGetUncachedExtension(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a common buffer to be used as the uncached device
    extension for the miniport driver.  This function will also allocate any
    required SRB extensions.  The DmaAdapter is allocated if it has not been
    allocated previously.

Arguments:

    DeviceExtension - Supplies a pointer to the miniports device extension.

    ConfigInfo - Supplies a pointer to the partially initialized configuraiton
        information.  This is used to get an DMA adapter object.

    NumberOfBytes - Supplies the size of the extension which needs to be
        allocated

Return Value:

    A pointer to the uncached device extension or NULL if the extension could
    not be allocated or was previously allocated.

--*/

{
    PADAPTER_EXTENSION adapter = GET_FDO_EXTENSION(HwDeviceExtension);
    DEVICE_DESCRIPTION deviceDescription;
    ULONG numberOfMapRegisters;
    NTSTATUS status;
    PVOID SrbExtensionBuffer;

    //
    // If the miniport is being reinitialized then just return the current
    // uncached extension (if any).
    //

    if (TEST_FLAG(adapter->Flags, PD_MINIPORT_REINITIALIZING)) {
        DebugPrint((1, "ScsiPortGetUncachedExtension - miniport is "
                       "reinitializing returning %#p\n",
                    adapter->NonCachedExtension));
        if(TEST_FLAG(adapter->Flags, PD_UNCACHED_EXTENSION_RETURNED)) {

            //
            // The miniport asked for it's uncached extension once during
            // reinitialization - simulate the behavior on the original second
            // call and return NULL.
            //

            return NULL;
        } else {

            //
            // The miniport only gets one non-cached extension - keep track
            // of the fact that we returned it and don't give them a pointer
            // to it again.  This flag is cleared once the initialization
            // is complete.
            //

            SET_FLAG(adapter->Flags, PD_UNCACHED_EXTENSION_RETURNED);
            return(adapter->NonCachedExtension);
        }
    }

    //
    // Make sure that a common buffer has not already been allocated.
    //

    SrbExtensionBuffer = SpGetSrbExtensionBuffer(adapter);
    if (SrbExtensionBuffer != NULL) {
        return(NULL);
    }

    //
    // If there no adapter object then try and get one.
    //

    if (adapter->DmaAdapterObject == NULL) {

        RtlZeroMemory(&deviceDescription, sizeof(DEVICE_DESCRIPTION));

        deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
        deviceDescription.DmaChannel = ConfigInfo->DmaChannel;
        deviceDescription.InterfaceType = ConfigInfo->AdapterInterfaceType;
        deviceDescription.DmaWidth = ConfigInfo->DmaWidth;
        deviceDescription.DmaSpeed = ConfigInfo->DmaSpeed;
        deviceDescription.ScatterGather = ConfigInfo->ScatterGather;
        deviceDescription.Master = ConfigInfo->Master;
        deviceDescription.DmaPort = ConfigInfo->DmaPort;
        deviceDescription.Dma32BitAddresses = ConfigInfo->Dma32BitAddresses;

        adapter->Dma32BitAddresses = ConfigInfo->Dma32BitAddresses;

        //
        // If the miniport puts anything in here other than 0x80 then we
        // assume it wants to support 64-bit addresses.
        //

        DebugPrint((1, "ScsiPortGetUncachedExtension: Dma64BitAddresses = "
                       "%#0x\n",
                    ConfigInfo->Dma64BitAddresses));

        adapter->RemapBuffers = (BOOLEAN) (SpRemapBuffersByDefault != 0);

        if((ConfigInfo->Dma64BitAddresses & ~SCSI_DMA64_SYSTEM_SUPPORTED) != 0){
            DebugPrint((1, "ScsiPortGetUncachedExtension: will request "
                           "64-bit PA's\n"));
            deviceDescription.Dma64BitAddresses = TRUE;
            adapter->Dma64BitAddresses = TRUE;
        } else if(Sp64BitPhysicalAddresses == TRUE) {
            DebugPrint((1, "ScsiPortGetUncachedExtension: Will remap buffers for adapter %#p\n", adapter));
            adapter->RemapBuffers = TRUE;
        }

        deviceDescription.BusNumber = ConfigInfo->SystemIoBusNumber;
        deviceDescription.AutoInitialize = FALSE;

        //
        // If we get here then it's unlikely that the adapter is doing
        // slave mode DMA - if it were it wouldn't need a shared memory segment
        // to share with it's controller (because it's unlikely it could use it)
        //

        deviceDescription.DemandMode = FALSE;
        deviceDescription.MaximumLength = ConfigInfo->MaximumTransferLength;

        adapter->DmaAdapterObject = IoGetDmaAdapter(adapter->LowerPdo,
                                                    &deviceDescription,
                                                    &numberOfMapRegisters
                                                    );

        //
        // If an adapter could not be allocated then return NULL.
        //

        if (adapter->DmaAdapterObject == NULL) {
            return(NULL);

        }

        //
        // Determine the number of page breaks allowed.
        //

        if (numberOfMapRegisters > ConfigInfo->NumberOfPhysicalBreaks &&
            ConfigInfo->NumberOfPhysicalBreaks != 0) {

            adapter->Capabilities.MaximumPhysicalPages =
                ConfigInfo->NumberOfPhysicalBreaks;
        } else {

            adapter->Capabilities.MaximumPhysicalPages =
                numberOfMapRegisters;
        }
    }

    //
    // Set auto request sense in device extension.
    //

    adapter->AutoRequestSense = ConfigInfo->AutoRequestSense;

    //
    // Initialize power parameters.
    //

    SpInitializePowerParams(adapter);

    //
    // Initialize configurable performance parameters.
    //

    SpInitializePerformanceParams(adapter);

    //
    // Initialize configurable request sense parameters.
    //

    SpInitializeRequestSenseParams(adapter);

    //
    // Update SrbExtensionSize, if necessary. The miniport's FindAdapter routine
    // has the opportunity to adjust it after being called, depending upon
    // it's Scatter/Gather List requirements.
    //

    if (adapter->SrbExtensionSize != ConfigInfo->SrbExtensionSize) {
        adapter->SrbExtensionSize = ConfigInfo->SrbExtensionSize;
    }

    //
    // If the adapter supports AutoRequestSense or needs SRB extensions
    // then an SRB list needs to be allocated.
    //

    if (adapter->SrbExtensionSize != 0  ||
        ConfigInfo->AutoRequestSense) {

        adapter->AllocateSrbExtension = TRUE;
    }

    //
    // Allocate the common buffer.
    //

    status = SpGetCommonBuffer( adapter, NumberOfBytes);

    if (!NT_SUCCESS(status)) {
        return(NULL);
    }

    return(adapter->NonCachedExtension);
}

NTSTATUS
SpGetCommonBuffer(
    PADAPTER_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    )
/*++

Routine Description:

    This routine determines the required size of the common buffer.  Allocates
    the common buffer and finally sets up the srb extension list.  This routine
    expects that the adapter object has already been allocated.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    NonCachedExtensionSize - Supplies the size of the noncached device
        extension for the miniport driver.

Return Value:

    Returns the status of the allocate operation.

--*/

{
    PVOID buffer;
    ULONG length;
    ULONG blockSize;
    PVOID *srbExtension;
    ULONG uncachedExtAlignment = 0;

    PAGED_CODE();

    //
    // Round the uncached extension up to a page boundary so the srb 
    // extensions following it begin page aligned.
    //

    if (NonCachedExtensionSize != 0) {
        uncachedExtAlignment = DeviceExtension->UncachedExtAlignment;
        NonCachedExtensionSize = ROUND_UP_COUNT(NonCachedExtensionSize, 
                                                PAGE_SIZE);
        DeviceExtension->NonCachedExtensionSize = NonCachedExtensionSize;
    }

    //
    // If verifier is enabled and configured to allocate common buffer space in
    // separate blocks, call out to the verifier routine to do the allocation.
    //

    if (SpVerifyingCommonBuffer(DeviceExtension)) {
        return SpGetCommonBufferVrfy(DeviceExtension,NonCachedExtensionSize);
    }

    //
    // Calculate the size of the entire common buffer block.
    //

    length = SpGetCommonBufferSize(DeviceExtension, 
                                   NonCachedExtensionSize,
                                   &blockSize);

    //
    // If the adapter has an alignment requirement for its uncached extension,
    // round the size of the entire common buffer up to the required boundary.
    //

    if (uncachedExtAlignment != 0 && NonCachedExtensionSize != 0) {
        length = ROUND_UP_COUNT(length, uncachedExtAlignment);
    }

    //
    // Allocate the common buffer.
    //

    if (DeviceExtension->DmaAdapterObject == NULL) {

        //
        // Since there is no adapter just allocate from non-paged pool.
        //

        buffer = SpAllocatePool(NonPagedPool,
                                length,
                                SCSIPORT_TAG_COMMON_BUFFER,
                                DeviceExtension->DeviceObject->DriverObject);

    } else {

        //
        // If the controller can do 64-bit addresses or if the adapter has 
        // alignment requirements for its uncached extension, then we need to
        // specifically force the uncached extension area below the 4GB mark
        // and force it to be aligned on the appropriate boundary.
        //

        if( ((Sp64BitPhysicalAddresses) && 
             (DeviceExtension->Dma64BitAddresses == TRUE)) ||
            (uncachedExtAlignment != 0)) {

            PHYSICAL_ADDRESS boundary;

            if (uncachedExtAlignment != 0) {
                boundary.QuadPart = length;
            } else {
                boundary.HighPart = 1;
                boundary.LowPart = 0;
            }

            //
            // We'll get page aligned memory out of this which is probably 
            // better than the requirements of the adapter.
            //

            buffer = MmAllocateContiguousMemorySpecifyCache(
                        length,
                        (DeviceExtension->MinimumCommonBufferBase),
                        (DeviceExtension->MaximumCommonBufferBase),
                        boundary,
                        MmCached);

            if(buffer != NULL) {
                DeviceExtension->PhysicalCommonBuffer =
                    MmGetPhysicalAddress(buffer);
            }

            DeviceExtension->UncachedExtensionIsCommonBuffer = FALSE;

        } else {

            buffer = AllocateCommonBuffer(
                        DeviceExtension->DmaAdapterObject,
                        length,
                        &DeviceExtension->PhysicalCommonBuffer,
                        FALSE );

            DeviceExtension->UncachedExtensionIsCommonBuffer = TRUE;

        }
    }

    DebugPrint((1, "SpGetCommonBuffer: buffer:%p PhysicalCommonBuffer:%p\n", 
                buffer, DeviceExtension->PhysicalCommonBuffer));

    if (buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Clear the common buffer.
    //

    RtlZeroMemory(buffer, length);

    //
    // Save the size of the common buffer.
    //

    DeviceExtension->CommonBufferSize = length;

    //
    // Set the Srb Extension to the start of the buffer.  This address
    // is used to deallocate the common buffer, so it must be
    // set whether the device is using an Srb Extension or not.
    //

    DeviceExtension->SrbExtensionBuffer = buffer;

    //
    // Initialize the noncached extension.
    //

    if (NonCachedExtensionSize != 0) {
        DeviceExtension->NonCachedExtension = buffer;
    } else {
        DeviceExtension->NonCachedExtension = NULL;
    }

    //
    // Initialize the SRB extension list.
    //

    if (DeviceExtension->AllocateSrbExtension) {

        ULONG i = 0;

        //
        // Subtract the length of the non-cached extension from the common
        // buffer block.
        //

        length -= DeviceExtension->NonCachedExtensionSize;

        //
        // Initialize the SRB extension list.
        //

        srbExtension = 
           (PVOID*)((PUCHAR)buffer + DeviceExtension->NonCachedExtensionSize);
        DeviceExtension->SrbExtensionListHeader = srbExtension;

        while (length >= blockSize * 2) {

            *srbExtension = (PVOID *)((PCHAR) srbExtension + blockSize);
            srbExtension = *srbExtension;

            length -= blockSize;
            i++;
        }

        DebugPrint((1, "SpGetCommonBuffer: %d entries put onto "
                       "SrbExtension list\n", i));

        DeviceExtension->NumberOfRequests = i;
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Temporary entry point needed to initialize the scsi port driver.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

   STATUS_SUCCESS

--*/

{
    //
    // NOTE: This routine should not be needed ! DriverEntry is defined
    // in the miniport driver.
    //

    UNREFERENCED_PARAMETER(DriverObject);

    return STATUS_SUCCESS;

} // end DriverEntry()


NTSTATUS
SpInitializeConfiguration(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PHW_INITIALIZATION_DATA HwInitData,
    IN PCONFIGURATION_CONTEXT Context
    )
/*++

Routine Description:

    This routine initializes the port configuration information structure.
    Any necessary information is extracted from the registery.

Arguments:

    DeviceExtension - Supplies the device extension.

    HwInitData - Supplies the initial miniport data.

    Context - Supplies the context data used access calls.

Return Value:

    NTSTATUS - Success if requested bus type exists and additional
               configuration information is available.

--*/

{
    ULONG j;
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    PCONFIGURATION_INFORMATION configurationInformation;

    HANDLE deviceKey;
    HANDLE generalKey;

    BOOLEAN found;
    ANSI_STRING  ansiString;
    CCHAR deviceBuffer[16];
    CCHAR nodeBuffer[SP_REG_BUFFER_SIZE];

    //
    // If this is the initial call then zero the information and set
    // the structure to the uninitialized values.
    //

    RtlZeroMemory(&Context->PortConfig, sizeof(PORT_CONFIGURATION_INFORMATION));

    ASSERT(Context->AccessRanges != NULL);

    RtlZeroMemory(
        Context->AccessRanges,
        HwInitData->NumberOfAccessRanges * sizeof(ACCESS_RANGE)
        );

    Context->PortConfig.Length = sizeof(PORT_CONFIGURATION_INFORMATION);
    Context->PortConfig.AdapterInterfaceType = HwInitData->AdapterInterfaceType;
    Context->PortConfig.InterruptMode = Latched;
    Context->PortConfig.MaximumTransferLength = SP_UNINITIALIZED_VALUE;
    Context->PortConfig.DmaChannel = SP_UNINITIALIZED_VALUE;
    Context->PortConfig.DmaPort = SP_UNINITIALIZED_VALUE;
    Context->PortConfig.NumberOfAccessRanges = HwInitData->NumberOfAccessRanges;
    Context->PortConfig.MaximumNumberOfTargets = 8;
    Context->PortConfig.MaximumNumberOfLogicalUnits = SCSI_MAXIMUM_LOGICAL_UNITS;
    Context->PortConfig.WmiDataProvider = FALSE;

    //
    // If the system indicates it can do 64-bit physical addressing then tell
    // the miniport it's an option.
    //

    if(Sp64BitPhysicalAddresses == TRUE) {
        Context->PortConfig.Dma64BitAddresses = SCSI_DMA64_SYSTEM_SUPPORTED;
    } else {
        Context->PortConfig.Dma64BitAddresses = 0;
    }

    //
    // Save away the some of the attributes.
    //

    Context->PortConfig.NeedPhysicalAddresses = HwInitData->NeedPhysicalAddresses;
    Context->PortConfig.MapBuffers = HwInitData->MapBuffers;
    Context->PortConfig.AutoRequestSense = HwInitData->AutoRequestSense;
    Context->PortConfig.ReceiveEvent = HwInitData->ReceiveEvent;
    Context->PortConfig.TaggedQueuing = HwInitData->TaggedQueuing;
    Context->PortConfig.MultipleRequestPerLu = HwInitData->MultipleRequestPerLu;

    //
    // Indicate the current AT disk usage.
    //

    configurationInformation = IoGetConfigurationInformation();

    Context->PortConfig.AtdiskPrimaryClaimed = configurationInformation->AtDiskPrimaryAddressClaimed;
    Context->PortConfig.AtdiskSecondaryClaimed = configurationInformation->AtDiskSecondaryAddressClaimed;

    for (j = 0; j < 8; j++) {
        Context->PortConfig.InitiatorBusId[j] = (UCHAR)SP_UNINITIALIZED_VALUE;
    }

    Context->PortConfig.NumberOfPhysicalBreaks = SP_DEFAULT_PHYSICAL_BREAK_VALUE;

    //
    // Clear some of the context information.
    //

    Context->DisableTaggedQueueing = FALSE;
    Context->DisableMultipleLu = FALSE;

    //
    // Record the system bus number.
    //

    Context->PortConfig.SystemIoBusNumber = Context->BusNumber;

    //
    // Initialize the adapter number on the context.
    //

    Context->AdapterNumber = DeviceExtension->AdapterNumber - 1;
    ASSERT((LONG)Context->AdapterNumber > -1);

    //
    // Check for device parameters.
    //

    if (Context->Parameter) {
        ExFreePool(Context->Parameter);
        Context->Parameter = NULL;
    }

    generalKey = SpOpenDeviceKey(RegistryPath, -1);

    //
    // First parse the device information.
    //

    if (generalKey != NULL) {
        SpParseDevice(DeviceExtension, generalKey, Context, nodeBuffer);
        ZwClose(generalKey);
    }

    //
    // Next parse the specific device information so that it can override the
    // general device information. This node is not used if the last adapter
    // was not found.
    //

    deviceKey = SpOpenDeviceKey(RegistryPath, Context->AdapterNumber);

    if (deviceKey != NULL) {
        SpParseDevice(DeviceExtension, deviceKey, Context, nodeBuffer);
        ZwClose(deviceKey);
    }

    DeviceExtension->SrbTimeout = SRB_DEFAULT_TIMEOUT;   
    PortGetDiskTimeoutValue(&DeviceExtension->SrbTimeout);

    //
    // Determine if the requested bus type is on this system.
    //

    if(HwInitData->AdapterInterfaceType != PNPBus) {
    
        found = FALSE;
    
        if(HwInitData->AdapterInterfaceType != MicroChannel) {
    
            status = IoQueryDeviceDescription(&HwInitData->AdapterInterfaceType,
                                              &Context->BusNumber,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL,
                                              SpConfigurationCallout,
                                              &found);
        }
    
        //
        // If the request failed, then assume this type of bus is not here.
        //
    
        if (!found) {
    
            INTERFACE_TYPE interfaceType = Eisa;
    
            if (HwInitData->AdapterInterfaceType == Isa) {
    
                //
                // Check for an Eisa bus.
                //
    
                status = IoQueryDeviceDescription(&interfaceType,
                                                  &Context->BusNumber,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  SpConfigurationCallout,
                                                  &found);
    
                //
                // If the request failed, then assume this type of bus is not here.
                //
    
                if (found) {
                    return(STATUS_SUCCESS);
                } else {
                    return(STATUS_DEVICE_DOES_NOT_EXIST);
                }
    
            } else {
                return(STATUS_DEVICE_DOES_NOT_EXIST);
            }
    
        } else {
            return(STATUS_SUCCESS);
        }
    } else {
        return STATUS_SUCCESS;
    }
}

PCM_RESOURCE_LIST
SpBuildResourceList(
    PADAPTER_EXTENSION DeviceExtension,
    PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
/*++

Routine Description:

    Creates a resource list which is used to query or report resource usage
    in the system

Arguments:

    DeviceExtension - Pointer to the port's deviceExtension.

    ConfigInfo - Pointer to the information structure filled out by the
        miniport findAdapter routine.

Return Value:

    Returns a pointer to a filled up resource list, or 0 if the call failed.

Note:

    Memory is allocated by the routine for the resourcelist. It must be
    freed up by the caller by calling ExFreePool();

--*/
{
    PCM_RESOURCE_LIST resourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDescriptor;
    PCONFIGURATION_INFORMATION configurationInformation;
    PACCESS_RANGE accessRange;
    ULONG listLength = 0;
    ULONG hasInterrupt;
    ULONG i;
    BOOLEAN hasDma;

    PAGED_CODE();

    //
    // Indicate the current AT disk usage.
    //

    configurationInformation = IoGetConfigurationInformation();

    if (ConfigInfo->AtdiskPrimaryClaimed) {
        configurationInformation->AtDiskPrimaryAddressClaimed = TRUE;
    }

    if (ConfigInfo->AtdiskSecondaryClaimed) {
        configurationInformation->AtDiskSecondaryAddressClaimed = TRUE;
    }

    //
    // Determine if adapter uses DMA. Only report the DMA channel if a
    // channel number is used.
    //

    if (ConfigInfo->DmaChannel != SP_UNINITIALIZED_VALUE ||
        ConfigInfo->DmaPort != SP_UNINITIALIZED_VALUE) {

       hasDma = TRUE;
       listLength++;

    } else {

        hasDma = FALSE;
    }

    DeviceExtension->HasInterrupt = FALSE;

    if (DeviceExtension->HwInterrupt == NULL ||
        (ConfigInfo->BusInterruptLevel == 0 &&
        ConfigInfo->BusInterruptVector == 0)) {

        hasInterrupt = 0;

    } else {

        hasInterrupt = 1;
        listLength++;
    }

    //
    // Detemine whether the second interrupt is used.
    //

    if (DeviceExtension->HwInterrupt != NULL &&
        (ConfigInfo->BusInterruptLevel2 != 0 ||
        ConfigInfo->BusInterruptVector2 != 0)) {

        hasInterrupt++;
        listLength++;
    }

    if(hasInterrupt) {
        DeviceExtension->HasInterrupt = TRUE;
    }

    //
    // Determine the number of access ranges used.
    //

    accessRange = &((*(ConfigInfo->AccessRanges))[0]);
    for (i = 0; i < ConfigInfo->NumberOfAccessRanges; i++) {

        if (accessRange->RangeLength != 0) {
            listLength++;
        }

        accessRange++;
    }

    resourceList = (PCM_RESOURCE_LIST)
        SpAllocatePool(PagedPool,
                       (sizeof(CM_RESOURCE_LIST) + 
                        ((listLength - 1) * 
                         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR))),
                       SCSIPORT_TAG_RESOURCE_LIST,
                       DeviceExtension->DeviceObject->DriverObject);

    //
    // Return NULL if the structure could not be allocated.
    // Otherwise, fill it out.
    //

    if (!resourceList) {

        return NULL;

    } else {

        //
        // Clear the resource list.
        //

        RtlZeroMemory(
            resourceList,
            sizeof(CM_RESOURCE_LIST) + (listLength - 1)
            * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            );

        //
        // Initialize the various fields.
        //

        resourceList->Count = 1;
        resourceList->List[0].InterfaceType = ConfigInfo->AdapterInterfaceType;
        resourceList->List[0].BusNumber = ConfigInfo->SystemIoBusNumber;
        resourceList->List[0].PartialResourceList.Count = listLength;
        resourceDescriptor =
            resourceList->List[0].PartialResourceList.PartialDescriptors;

        //
        // For each entry in the access range, fill in an entry in the
        // resource list
        //

        for (i = 0; i < ConfigInfo->NumberOfAccessRanges; i++) {

            accessRange = &((*(ConfigInfo->AccessRanges))[i]);

            if  (accessRange->RangeLength == 0) {

                //
                // Skip the empty ranges.
                //

                continue;
            }

            if (accessRange->RangeInMemory) {
                resourceDescriptor->Type = CmResourceTypeMemory;
                resourceDescriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
            } else {
                resourceDescriptor->Type = CmResourceTypePort;
                resourceDescriptor->Flags = CM_RESOURCE_PORT_IO;

                if(ConfigInfo->AdapterInterfaceType == Eisa) {
                    resourceDescriptor->Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
                }
            }

            resourceDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;

            resourceDescriptor->u.Memory.Start = accessRange->RangeStart;
            resourceDescriptor->u.Memory.Length = accessRange->RangeLength;


            resourceDescriptor++;
        }

        //
        // Fill in the entry for the interrupt if it was present.
        //

        if (hasInterrupt) {

            resourceDescriptor->Type = CmResourceTypeInterrupt;

            if (ConfigInfo->AdapterInterfaceType == MicroChannel ||
                ConfigInfo->InterruptMode == LevelSensitive) {
               resourceDescriptor->ShareDisposition = CmResourceShareShared;
               resourceDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            } else {
               resourceDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
               resourceDescriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
            }

            resourceDescriptor->u.Interrupt.Level =
                        ConfigInfo->BusInterruptLevel;
            resourceDescriptor->u.Interrupt.Vector =
                        ConfigInfo->BusInterruptVector;
            resourceDescriptor->u.Interrupt.Affinity = 0;

            resourceDescriptor++;
            --hasInterrupt;
        }

        if (hasInterrupt) {

            resourceDescriptor->Type = CmResourceTypeInterrupt;

            if (ConfigInfo->AdapterInterfaceType == MicroChannel ||
                ConfigInfo->InterruptMode2 == LevelSensitive) {
               resourceDescriptor->ShareDisposition = CmResourceShareShared;
               resourceDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            } else {
               resourceDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
               resourceDescriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
            }

            resourceDescriptor->u.Interrupt.Level =
                        ConfigInfo->BusInterruptLevel2;
            resourceDescriptor->u.Interrupt.Vector =
                        ConfigInfo->BusInterruptVector2;
            resourceDescriptor->u.Interrupt.Affinity = 0;

            resourceDescriptor++;
        }

        if (hasDma) {

            //
            // Fill out DMA information;
            //

            resourceDescriptor->Type = CmResourceTypeDma;
            resourceDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
            resourceDescriptor->u.Dma.Channel = ConfigInfo->DmaChannel;
            resourceDescriptor->u.Dma.Port = ConfigInfo->DmaPort;
            resourceDescriptor->Flags = 0;

            //
            // Set the initialized values to zero.
            //

            if (ConfigInfo->DmaChannel == SP_UNINITIALIZED_VALUE) {
                resourceDescriptor->u.Dma.Channel = 0;
            }

            if (ConfigInfo->DmaPort == SP_UNINITIALIZED_VALUE) {
                resourceDescriptor->u.Dma.Port = 0;
            }
        }

        return resourceList;
    }

} // end SpBuildResourceList()


VOID
SpParseDevice(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN HANDLE Key,
    IN PCONFIGURATION_CONTEXT Context,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine parses a device key node and updates the configuration
    information.

Arguments:

    DeviceExtension - Supplies the device extension.

    Key - Supplies an open key to the device node.

    ConfigInfo - Supplies the configuration information to be
        initialized.

    Context - Supplies the configuration context.

    Buffer - Supplies a scratch buffer for temporary data storage.

Return Value:

    None

--*/

{
    PKEY_VALUE_FULL_INFORMATION     keyValueInformation;
    NTSTATUS                        status = STATUS_SUCCESS;
    PCM_FULL_RESOURCE_DESCRIPTOR    resource;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
    PCM_SCSI_DEVICE_DATA            scsiData;
    UNICODE_STRING                  unicodeString;
    ANSI_STRING                     ansiString;
    ULONG                           length;
    ULONG                           index = 0;
    ULONG                           rangeCount = 0;
    ULONG                           count;

    PAGED_CODE();

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

    //
    // Look at each of the values in the device node.
    //

    while(TRUE){

        status = ZwEnumerateValueKey(
            Key,
            index,
            KeyValueFullInformation,
            Buffer,
            SP_REG_BUFFER_SIZE,
            &length
            );


        if (!NT_SUCCESS(status)) {
#if DBG
            if (status != STATUS_NO_MORE_ENTRIES) {
                DebugPrint((1, "SpParseDevice: ZwEnumerateValueKey failed. Status: %lx", status));
            }
#endif
            return;
        }

        //
        // Update the index for the next time around the loop.
        //

        index++;

        //
        // Check that the length is reasonable.
        //

        if (keyValueInformation->Type == REG_DWORD &&
            keyValueInformation->DataLength != sizeof(ULONG)) {
            continue;
        }

        //
        // Check for a maximum lu number.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"MaximumLogicalUnit",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "SpParseDevice:  Bad data type for MaximumLogicalUnit.\n"));
                continue;
            }

            DeviceExtension->MaxLuCount = *((PUCHAR)
                (Buffer + keyValueInformation->DataOffset));
            DebugPrint((1, "SpParseDevice:  MaximumLogicalUnit = %d found.\n",
                DeviceExtension->MaxLuCount));

            //
            // If the value is out of bounds, then reset it.
            //

            if (DeviceExtension->MaxLuCount > SCSI_MAXIMUM_LOGICAL_UNITS) {
                DeviceExtension->MaxLuCount = SCSI_MAXIMUM_LOGICAL_UNITS;
            }
        }

        if (_wcsnicmp(keyValueInformation->Name, L"InitiatorTargetId",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "SpParseDevice:  Bad data type for InitiatorTargetId.\n"));
                continue;
            }

            Context->PortConfig.InitiatorBusId[0] = *((PUCHAR)
                (Buffer + keyValueInformation->DataOffset));
            DebugPrint((1, "SpParseDevice:  InitiatorTargetId = %d found.\n",
                Context->PortConfig.InitiatorBusId[0]));

            //
            // If the value is out of bounds, then reset it.
            //

            if (Context->PortConfig.InitiatorBusId[0] > Context->PortConfig.MaximumNumberOfTargets - 1) {
                Context->PortConfig.InitiatorBusId[0] = (UCHAR)SP_UNINITIALIZED_VALUE;
            }
        }

        if (_wcsnicmp(keyValueInformation->Name, L"ScsiDebug",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "SpParseDevice:  Bad data type for ScsiDebug.\n"));
                continue;
            }
#if DBG
            ScsiDebug = *((PULONG) (Buffer + keyValueInformation->DataOffset));
#endif
        }

        if (_wcsnicmp(keyValueInformation->Name, L"BreakPointOnEntry",
            keyValueInformation->NameLength/2) == 0) {

            DebugPrint((0, "SpParseDevice: Break point requested on entry.\n"));
            DbgBreakPoint();
        }

        //
        // Check for disabled synchonous tranfers.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DisableSynchronousTransfers",
            keyValueInformation->NameLength/2) == 0) {

            DeviceExtension->CommonExtension.SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
            DebugPrint((1, "SpParseDevice: Disabling synchonous transfers\n"));
        }

        //
        // Check for disabled disconnects.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DisableDisconnects",
            keyValueInformation->NameLength/2) == 0) {

            DeviceExtension->CommonExtension.SrbFlags |= SRB_FLAGS_DISABLE_DISCONNECT;
            DebugPrint((1, "SpParseDevice: Disabling disconnects\n"));
        }

        //
        // Check for disabled tagged queuing.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DisableTaggedQueuing",
            keyValueInformation->NameLength/2) == 0) {

            Context->DisableTaggedQueueing = TRUE;
            DebugPrint((1, "SpParseDevice: Disabling tagged queueing\n"));
        }

        //
        // Check for disabled multiple requests per logical unit.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DisableMultipleRequests",
            keyValueInformation->NameLength/2) == 0) {

            Context->DisableMultipleLu = TRUE;
            DebugPrint((1, "SpParseDevice: Disabling multiple requests\n"));
        }

        //
        // Check for the minimum & maximum physical addresses that this 
        // controller can use for it's uncached extension.  If none is provided 
        // assume it must be in the first 4GB of memory.
        //

        if(_wcsnicmp(keyValueInformation->Name, L"MinimumUCXAddress",
                     keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type == REG_BINARY) {
                DeviceExtension->MinimumCommonBufferBase.QuadPart = 
                    *((PULONGLONG) (Buffer + keyValueInformation->DataOffset));
            }
        }

        if(_wcsnicmp(keyValueInformation->Name, L"MaximumUCXAddress",
                     keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type == REG_BINARY) {
                DeviceExtension->MaximumCommonBufferBase.QuadPart = 
                    *((PULONGLONG) (Buffer + keyValueInformation->DataOffset));
            }
        }

        if(DeviceExtension->MaximumCommonBufferBase.QuadPart == 0) {
            DeviceExtension->MaximumCommonBufferBase.LowPart = 0xffffffff;
            DeviceExtension->MaximumCommonBufferBase.HighPart = 0x0;
        }

        //
        // Make sure that the minimum and maximum parameters are valid.
        // If there's not at least one valid page between them then reset 
        // the minimum to zero.
        //

        if(DeviceExtension->MinimumCommonBufferBase.QuadPart >= 
           (DeviceExtension->MaximumCommonBufferBase.QuadPart - PAGE_SIZE)) {
            DebugPrint((0, "SpParseDevice: MinimumUCXAddress %I64x is invalid\n",
                        DeviceExtension->MinimumCommonBufferBase.QuadPart));
            DeviceExtension->MinimumCommonBufferBase.QuadPart = 0;
        }

        //
        // Check for driver parameters tranfers.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DriverParameters",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->DataLength == 0) {
                continue;
            }

            //
            // Free any previous driver parameters.
            //

            if (Context->Parameter != NULL) {
                ExFreePool(Context->Parameter);
            }

            Context->Parameter =
                SpAllocatePool(NonPagedPool,
                               keyValueInformation->DataLength,
                               SCSIPORT_TAG_MINIPORT_PARAM,
                               DeviceExtension->DeviceObject->DriverObject);

            if (Context->Parameter != NULL) {

                if (keyValueInformation->Type != REG_SZ) {

                    //
                    // This is some random information just copy it.
                    //

                    RtlCopyMemory(
                        Context->Parameter,
                        (PCCHAR) keyValueInformation + keyValueInformation->DataOffset,
                        keyValueInformation->DataLength
                        );

                } else {

                    //
                    // This is a unicode string. Convert it to a ANSI string.
                    // Initialize the strings.
                    //

                    unicodeString.Buffer = (PWSTR) ((PCCHAR) keyValueInformation +
                        keyValueInformation->DataOffset);
                    unicodeString.Length = (USHORT) keyValueInformation->DataLength;
                    unicodeString.MaximumLength = (USHORT) keyValueInformation->DataLength;

                    ansiString.Buffer = (PCHAR) Context->Parameter;
                    ansiString.Length = 0;
                    ansiString.MaximumLength = (USHORT) keyValueInformation->DataLength;

                    status = RtlUnicodeStringToAnsiString(
                        &ansiString,
                        &unicodeString,
                        FALSE
                        );

                    if (!NT_SUCCESS(status)) {

                        //
                        // Free the context.
                        //

                        ExFreePool(Context->Parameter);
                        Context->Parameter = NULL;
                    }

                }
            }

            DebugPrint((1, "SpParseDevice: Found driver parameter.\n"));
        }

        //
        // See if an entry for Maximum Scatter-Gather List has been
        // set.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"MaximumSGList",
            keyValueInformation->NameLength/2) == 0) {

            ULONG maxBreaks, minBreaks;

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "SpParseDevice:  Bad data type for MaximumSGList.\n"));
                continue;
            }

            Context->PortConfig.NumberOfPhysicalBreaks = *((PUCHAR)(Buffer + keyValueInformation->DataOffset));
            DebugPrint((1, "SpParseDevice:  MaximumSGList = %d found.\n",
                        Context->PortConfig.NumberOfPhysicalBreaks));

            //
            // If the value is out of bounds, then reset it.
            //

            if ((Context->PortConfig.MapBuffers) && (!Context->PortConfig.Master)) {
                maxBreaks = SP_UNINITIALIZED_VALUE;
                minBreaks = SCSI_MINIMUM_PHYSICAL_BREAKS;
            } else {
                maxBreaks = SCSI_MAXIMUM_PHYSICAL_BREAKS;
                minBreaks = SCSI_MINIMUM_PHYSICAL_BREAKS;
            }

            if (Context->PortConfig.NumberOfPhysicalBreaks > maxBreaks) {
                Context->PortConfig.NumberOfPhysicalBreaks = maxBreaks;
            } else if (Context->PortConfig.NumberOfPhysicalBreaks < minBreaks) {
                Context->PortConfig.NumberOfPhysicalBreaks = minBreaks;
            }

        }

        //
        // See if an entry for Number of request has been set.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"NumberOfRequests",
            keyValueInformation->NameLength/2) == 0) {

            ULONG value;

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "SpParseDevice:  Bad data type for NumberOfRequests.\n"));
                continue;
            }

            value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

            //
            // If the value is out of bounds, then reset it.
            //

            if (value < MINIMUM_SRB_EXTENSIONS) {
                DeviceExtension->NumberOfRequests = MINIMUM_SRB_EXTENSIONS;
            } else if (value > MAXIMUM_SRB_EXTENSIONS) {
                DeviceExtension->NumberOfRequests = MAXIMUM_SRB_EXTENSIONS;
            } else {
                DeviceExtension->NumberOfRequests = value;
            }

            DebugPrint((1, "SpParseDevice:  Number Of Requests = %d found.\n",
                        DeviceExtension->NumberOfRequests));
        }

        //
        // Check for resource list.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"ResourceList",
                keyValueInformation->NameLength/2) == 0 ||
            _wcsnicmp(keyValueInformation->Name, L"Configuration Data",
                keyValueInformation->NameLength/2) == 0 ) {

            if (keyValueInformation->Type != REG_FULL_RESOURCE_DESCRIPTOR ||
                keyValueInformation->DataLength < sizeof(REG_FULL_RESOURCE_DESCRIPTOR)) {

                DebugPrint((1, "SpParseDevice:  Bad data type for ResourceList.\n"));
                continue;
            } else {
                DebugPrint((1, "SpParseDevice:  ResourceList found!\n"));
            }

            resource = (PCM_FULL_RESOURCE_DESCRIPTOR)
                (Buffer + keyValueInformation->DataOffset);

            //
            // Set the bus number equal to the bus number for the
            // resouce.  Note the context value is also set to the
            // new bus number.
            //

            Context->BusNumber = resource->BusNumber;
            Context->PortConfig.SystemIoBusNumber = resource->BusNumber;

            //
            // Walk the resource list and update the configuration.
            //

            for (count = 0; count < resource->PartialResourceList.Count; count++) {
                descriptor = &resource->PartialResourceList.PartialDescriptors[count];

                //
                // Verify size is ok.
                //

                if ((ULONG)((PCHAR) (descriptor + 1) - (PCHAR) resource) >
                    keyValueInformation->DataLength) {

                    DebugPrint((1, "SpParseDevice: Resource data too small.\n"));
                    break;
                }

                //
                // Switch on descriptor type;
                //

                switch (descriptor->Type) {
                case CmResourceTypePort:

                    if (rangeCount >= Context->PortConfig.NumberOfAccessRanges) {
                        DebugPrint((1, "SpParseDevice: Too many access ranges.\n"));
                        continue;
                    }

                    Context->AccessRanges[rangeCount].RangeStart =
                        descriptor->u.Port.Start;
                    Context->AccessRanges[rangeCount].RangeLength =
                        descriptor->u.Port.Length;
                    Context->AccessRanges[rangeCount].RangeInMemory = FALSE;
                    rangeCount++;

                    break;

                case CmResourceTypeMemory:

                    if (rangeCount >= Context->PortConfig.NumberOfAccessRanges) {
                        DebugPrint((1, "SpParseDevice: Too many access ranges.\n"));
                        continue;
                    }

                    Context->AccessRanges[rangeCount].RangeStart =
                        descriptor->u.Memory.Start;

                    Context->AccessRanges[rangeCount].RangeLength =
                        descriptor->u.Memory.Length;
                    Context->AccessRanges[rangeCount].RangeInMemory = TRUE;
                    rangeCount++;

                    break;

                case CmResourceTypeInterrupt:

                    Context->PortConfig.BusInterruptVector =
                        descriptor->u.Interrupt.Vector;
                    Context->PortConfig.BusInterruptLevel =
                        descriptor->u.Interrupt.Level;
                    break;

                case CmResourceTypeDma:

                    Context->PortConfig.DmaChannel = descriptor->u.Dma.Channel;
                    Context->PortConfig.DmaPort = descriptor->u.Dma.Port;
                    break;

                case CmResourceTypeDeviceSpecific:

                    if (descriptor->u.DeviceSpecificData.DataSize <
                        sizeof(CM_SCSI_DEVICE_DATA) ||
                        (PCHAR) (descriptor + 1) - (PCHAR) resource +
                        descriptor->u.DeviceSpecificData.DataSize >
                        keyValueInformation->DataLength) {

                        DebugPrint((1, "SpParseDevice: Device specific resource data too small.\n"));
                        break;

                    }

                    //
                    // The actual data follows the descriptor.
                    //

                    scsiData = (PCM_SCSI_DEVICE_DATA) (descriptor+1);
                    Context->PortConfig.InitiatorBusId[0] = scsiData->HostIdentifier;
                    break;

                }
            }
        }

        //
        // See if an entry for uncached extension alignment has been set.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"UncachedExtAlignment", 
                      keyValueInformation->NameLength/2) == 0) {

            ULONG value;

            if (keyValueInformation->Type != REG_DWORD) {
                DebugPrint((1, "SpParseDevice:  Bad data type for "
                            "UncachedExtAlignment.\n"));
                continue;
            }

            value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

            //
            // Specified alignment must be 3 to 16, which equates to 8-byte and
            // 64k-byte alignment, respectively.
            //

            if (value > 16) {
                value = 16;
            } else if (value < 3) {
                value = 3;
            }

	    DeviceExtension->UncachedExtAlignment = 1 << value;

            DebugPrint((1, "SpParseDevice:  Uncached ext alignment = %d.\n",
                        DeviceExtension->UncachedExtAlignment));
        } // UncachedExtAlignment

        //
        // Look for an override to the default reset hold period.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"ResetHoldTime", 
                      keyValueInformation->NameLength/2) == 0) {

            ULONG value;

            if (keyValueInformation->Type != REG_DWORD) {
                DebugPrint((1, "SpParseDevice:  Bad data type for "
                            "ResetHoldTime.\n"));
                continue;
            }

            value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

            DeviceExtension->ResetHoldTime = (value <= 60) ? value : 60;

        } // ResetHoldPeriod

        //
        // Look for setting instructing us to create an initiator LU.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"CreateInitiatorLU", 
                      keyValueInformation->NameLength/2) == 0) {

            ULONG value;

            if (keyValueInformation->Type != REG_DWORD) {
                DebugPrint((1, "SpParseDevice:  Bad data type for "
                            "CreateInitiatorLU.\n"));
                continue;
            }

            value = *((PULONG)(Buffer + keyValueInformation->DataOffset));

            DeviceExtension->CreateInitiatorLU = (value == 0) ? FALSE : TRUE;

        } // CreateInitiatorLU
    }
}

NTSTATUS
SpConfigurationCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This routine indicate that the requested perpherial data was found.

Arguments:

    Context - Supplies a pointer to boolean which is set to TURE when this
        routine is call.

    The remaining arguments are unsed.

Return Value:

    Returns success.

--*/

{
    PAGED_CODE();
    *(PBOOLEAN) Context = TRUE;
    return(STATUS_SUCCESS);
}


NTSTATUS
SpGetRegistryValue(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE Handle,
    IN PWSTR KeyString,
    OUT PKEY_VALUE_FULL_INFORMATION *KeyInformation
    )

/*++

Routine Description:

    This routine retrieve's any data associated with a registry key.
    The key is queried with a zero-length buffer to get it's actual size
    then a buffer is allocated and the actual query takes place.
    It is the responsibility of the caller to free the buffer.

Arguments:

    Handle - Supplies the key handle whose value is to be queried

    KeyString - Supplies the null-terminated Unicode name of the value.

    KeyInformation - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString(&unicodeString, KeyString);

    //
    // Query with a zero-length buffer, to get the size needed.
    //

    status = ZwQueryValueKey( Handle,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength);

    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        *KeyInformation = NULL;
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = SpAllocatePool(NonPagedPool,
                                keyValueLength,
                                SCSIPORT_TAG_REGISTRY,
                                DriverObject);
    if(!infoBuffer) {
        *KeyInformation = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( Handle,
                              &unicodeString,
                              KeyValueFullInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength);

    if(!NT_SUCCESS(status)) {
        ExFreePool(infoBuffer);
        *KeyInformation = NULL;
        return status;
    }

    *KeyInformation = infoBuffer;
    return STATUS_SUCCESS;
}


VOID
SpBuildConfiguration(
    IN PADAPTER_EXTENSION    AdapterExtension,
    IN PHW_INITIALIZATION_DATA         HwInitializationData,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInformation
    )

/*++

Routine Description:

    Given a full resource description, fill in the port configuration
    information.

Arguments:

    HwInitializationData - to know maximum resources for device.
    ControllerData - the CM_FULL_RESOURCE list for this configuration
    ConfigInformation - the config info structure to be filled in

Return Value:

    None

--*/

{
    ULONG             rangeNumber;
    ULONG             index;
    PACCESS_RANGE     accessRange;

    PCM_FULL_RESOURCE_DESCRIPTOR resourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialData;

    PAGED_CODE();

    rangeNumber = 0;

    ASSERT(!AdapterExtension->IsMiniportDetected);
    ASSERT(AdapterExtension->AllocatedResources);

    resourceList = AdapterExtension->AllocatedResources->List;

    for (index = 0; index < resourceList->PartialResourceList.Count; index++) {
        partialData = &resourceList->PartialResourceList.PartialDescriptors[index];

        switch (partialData->Type) {
        case CmResourceTypePort:

           //
           // Verify range count does not exceed what the
           // miniport indicated.
           //

           if (HwInitializationData->NumberOfAccessRanges > rangeNumber) {

                //
                // Get next access range.
                //

                accessRange =
                          &((*(ConfigInformation->AccessRanges))[rangeNumber]);

                accessRange->RangeStart = partialData->u.Port.Start;
                accessRange->RangeLength = partialData->u.Port.Length;

                accessRange->RangeInMemory = FALSE;
                rangeNumber++;
            }
            break;

        case CmResourceTypeInterrupt:
            ConfigInformation->BusInterruptLevel = partialData->u.Interrupt.Level;
            ConfigInformation->BusInterruptVector = partialData->u.Interrupt.Vector;

            //
            // Check interrupt mode.
            //

            if (partialData->Flags == CM_RESOURCE_INTERRUPT_LATCHED) {
                ConfigInformation->InterruptMode = Latched;
            } else if (partialData->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
                ConfigInformation->InterruptMode = LevelSensitive;
            }

            AdapterExtension->HasInterrupt = TRUE;
            break;

        case CmResourceTypeMemory:

            //
            // Verify range count does not exceed what the
            // miniport indicated.
            //

            if (HwInitializationData->NumberOfAccessRanges > rangeNumber) {

                 //
                 // Get next access range.
                 //

                 accessRange =
                          &((*(ConfigInformation->AccessRanges))[rangeNumber]);

                 accessRange->RangeStart = partialData->u.Memory.Start;
                 accessRange->RangeLength = partialData->u.Memory.Length;

                 accessRange->RangeInMemory = TRUE;
                 rangeNumber++;
            }
            break;

        case CmResourceTypeDma:
            ConfigInformation->DmaChannel = partialData->u.Dma.Channel;
            ConfigInformation->DmaPort = partialData->u.Dma.Port;
            break;
        }
    }
}

#if !defined(NO_LEGACY_DRIVERS)

BOOLEAN
GetPciConfiguration(
    IN PDRIVER_OBJECT          DriverObject,
    IN OUT PDEVICE_OBJECT      DeviceObject,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID                   RegistryPath,
    IN ULONG                   BusNumber,
    IN OUT PPCI_SLOT_NUMBER    SlotNumber
    )

/*++

Routine Description:

    Walk PCI slot information looking for Vendor and Product ID matches.
    Get slot information for matches and register with hal for the resources.

Arguments:

    DriverObject - Miniport driver object.
    DeviceObject - Represents this adapter.
    HwInitializationData - Miniport description.
    RegistryPath - Service key path.
    BusNumber - PCI bus number for this search.
    SlotNumber - Starting slot number for this search.

Return Value:

    TRUE if card found. Slot and function numbers will return values that
    should be used to continue the search for additional cards, when a card
    is found.

--*/

{
    PADAPTER_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    ULONG               rangeNumber = 0;
    ULONG               pciBuffer;
    ULONG               slotNumber;
    ULONG               functionNumber;
    ULONG               status;
    PCI_SLOT_NUMBER     slotData;
    PPCI_COMMON_CONFIG  pciData;
    UNICODE_STRING      unicodeString;
    UCHAR               vendorString[5];
    UCHAR               deviceString[5];

    PAGED_CODE();

    pciData = (PPCI_COMMON_CONFIG)&pciBuffer;

    //
    //
    // typedef struct _PCI_SLOT_NUMBER {
    //     union {
    //         struct {
    //             ULONG   DeviceNumber:5;
    //             ULONG   FunctionNumber:3;
    //             ULONG   Reserved:24;
    //         } bits;
    //         ULONG   AsULONG;
    //     } u;
    // } PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;
    //

    slotData.u.AsULONG = 0;

    //
    // Look at each device.
    //

    for (slotNumber = (*SlotNumber).u.bits.DeviceNumber;
         slotNumber < 32;
         slotNumber++) {

        slotData.u.bits.DeviceNumber = slotNumber;

        //
        // Look at each function.
        //

        for (functionNumber= (*SlotNumber).u.bits.FunctionNumber;
             functionNumber < 8;
             functionNumber++) {

            slotData.u.bits.FunctionNumber = functionNumber;

            //
            // Make sure that the function number loop restarts at function
            // zero, not what was passed in.  If we find an adapter we'll
            // reset this value to contain the next function number to
            // be tested.
            //

            (*SlotNumber).u.bits.FunctionNumber = 0;

            if (!HalGetBusData(PCIConfiguration,
                               BusNumber,
                               slotData.u.AsULONG,
                               pciData,
                               sizeof(ULONG))) {

                //
                // Out of PCI data.
                //

                return FALSE;
            }

            if (pciData->VendorID == PCI_INVALID_VENDORID) {

                //
                // No PCI device, or no more functions on device
                // move to next PCI device.
                //

                break;
            }

            //
            // Translate hex ids to strings.
            //

            sprintf(vendorString, "%04x", pciData->VendorID);
            sprintf(deviceString, "%04x", pciData->DeviceID);

            DebugPrint((1,
                       "GetPciConfiguration: Bus %x Slot %x Function %x Vendor %s Product %s\n",
                       BusNumber,
                       slotNumber,
                       functionNumber,
                       vendorString,
                       deviceString));

            //
            // Compare strings.
            //

            if (_strnicmp(vendorString,
                        HwInitializationData->VendorId,
                        HwInitializationData->VendorIdLength) ||
                _strnicmp(deviceString,
                        HwInitializationData->DeviceId,
                        HwInitializationData->DeviceIdLength)) {

                //
                // Not our PCI device. Try next device/function
                //

                continue;
            }

            //
            // This is the miniport drivers slot. Allocate the
            // resources.
            //

            RtlInitUnicodeString(&unicodeString, L"ScsiAdapter");
            status = HalAssignSlotResources(
                        RegistryPath,
                        &unicodeString,
                        DriverObject,
                        DeviceObject,
                        PCIBus,
                        BusNumber,
                        slotData.u.AsULONG,
                        &(fdoExtension->AllocatedResources));

            if (!NT_SUCCESS(status)) {

                //
                // ToDo: Log this error.
                //

                DebugPrint((0, "SCSIPORT - GetPciConfiguration:  Resources for "
                               "bus %d slot %d could not be retrieved [%#08lx]\n",
                               BusNumber,
                               slotData.u.AsULONG,
                               status));

                break;
            }

            //
            // Record PCI slot number for miniport.
            //

            slotData.u.bits.FunctionNumber++;

            *SlotNumber = slotData;

            //
            // Translate the resources
            //

            status = SpTranslateResources(DriverObject,
                                          fdoExtension->AllocatedResources,
                                          &(fdoExtension->TranslatedResources));

            return TRUE;

        }   // next PCI function

    }   // next PCI slot

    return FALSE;

} // GetPciConfiguration()
#endif // NO_LEGACY_DRIVERS


ULONG
ScsiPortSetBusDataByOffset(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns writes bus data to a specific offset within a slot.

Arguments:

    DeviceExtension - State information for a particular adapter.

    BusDataType - Supplies the type of bus.

    SystemIoBusNumber - Indicates which system IO bus.

    SlotNumber - Indicates which slot.

    Buffer - Supplies the data to write.

    Offset - Byte offset to begin the write.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Number of bytes written.

--*/

{

    PADAPTER_EXTENSION fdoExtension =
        GET_FDO_EXTENSION(DeviceExtension);

    if(!fdoExtension->IsInVirtualSlot) {

#if defined(NO_LEGACY_DRIVERS)

        DebugPrint((1,"ScsiPortSetBusDataByOffset: !fdoExtension->"
                    "IsInVirtualSlot, not supported for 64-bits.\n"));

        return STATUS_INVALID_PARAMETER;

#else

        return(HalSetBusDataByOffset(BusDataType,
                                     SystemIoBusNumber,
                                     SlotNumber,
                                     Buffer,
                                     Offset,
                                     Length));

#endif // NO_LEGACY_DRIVERS

    } else {

        //
        // ThePCI bus interface SetBusData routine only accepts read requests
        // from PCIConfiguration space.  We do not support anything else.
        //
        
        if (BusDataType != PCIConfiguration) {
            ASSERT(FALSE && "Invalid PCI_WHICHSPACE_ parameter");
            return 0;
        }
        
        ASSERT(fdoExtension->LowerBusInterfaceStandardRetrieved == TRUE);

        return fdoExtension->LowerBusInterfaceStandard.SetBusData(
                    fdoExtension->LowerBusInterfaceStandard.Context,
                    PCI_WHICHSPACE_CONFIG,
                    Buffer,
                    Offset,
                    Length);
    }

} // end ScsiPortSetBusDataByOffset()


VOID
SpCreateScsiDirectory(
    VOID
    )

{
    UNICODE_STRING unicodeDirectoryName;
    OBJECT_ATTRIBUTES objectAttributes;

    HANDLE directory;

    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString(
        &unicodeDirectoryName,
        L"\\Device\\Scsi");

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeDirectoryName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL);

    status = ZwCreateDirectoryObject(&directory,
                                     DIRECTORY_ALL_ACCESS,
                                     &objectAttributes);

    if(NT_SUCCESS(status)) {

        ObReferenceObjectByHandle(directory,
                                  FILE_READ_ATTRIBUTES,
                                  NULL,
                                  KernelMode,
                                  &ScsiDirectory,
                                  NULL);
        ZwClose(directory);

    }
    return;
}


NTSTATUS
SpReportNewAdapter(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine will report an adapter discovered while sniffing through the
    system to plug and play in order to get an add device call for it

    This is done by:

        * calling IoReportDetectedDevice to inform PnP about the new device
        * storing the returned PDO pointer into the device extension as the
          lower device object so we can match PDO to FDO when the add device
          rolls around

Arguments:

    DeviceObject - a pointer to the device object that was "found"

Return Value:

    status

--*/

{
    PDRIVER_OBJECT driverObject = DeviceObject->DriverObject;
    PADAPTER_EXTENSION functionalExtension = DeviceObject->DeviceExtension;
    PPORT_CONFIGURATION_INFORMATION configInfo =
        functionalExtension->PortConfig;
    PDEVICE_OBJECT pdo = NULL;

    BOOLEAN resourceAssigned;

    NTSTATUS status;

    PAGED_CODE();

    ASSERT(functionalExtension->AllocatedResources != NULL);
    ASSERT(functionalExtension->IsPnp == FALSE);

    if(functionalExtension->IsMiniportDetected) {

        //
        // We haven't claimed the resources yet and we need pnp to give them
        // to us the next time around.
        //

        resourceAssigned = FALSE;
    } else {

        //
        // The port driver located this device using the HAL to scan all
        // appropriate bus slots.  It's already claimed those resources and
        // on the next boot we'll hopefully have a duplicate PDO to use
        // for the device.  Don't let pnp grab the resources on our behalf.
        //

        resourceAssigned = TRUE;
    }

    status = IoReportDetectedDevice(driverObject,
                                    configInfo->AdapterInterfaceType,
                                    configInfo->SystemIoBusNumber,
                                    configInfo->SlotNumber,
                                    functionalExtension->AllocatedResources,
                                    NULL,
                                    resourceAssigned,
                                    &pdo);

    //
    // If we got a PDO then setup information about slot and bus numbers in
    // the devnode in the registry.  These may not be valid but we assume that
    // if the miniport asks for slot info then it's on a bus that supports it.
    //

    if(NT_SUCCESS(status)) {

        HANDLE instanceHandle;
        NTSTATUS writeStatus;

        writeStatus = SpWriteNumericInstanceValue(
                            pdo,
                            L"BusNumber",
                            configInfo->SystemIoBusNumber);

        status = min(writeStatus, status);

        writeStatus = SpWriteNumericInstanceValue(
                            pdo,
                            L"SlotNumber",
                            configInfo->SlotNumber);

        status = min(writeStatus, status);

        writeStatus = SpWriteNumericInstanceValue(
                            pdo,
                            L"LegacyInterfaceType",
                            configInfo->AdapterInterfaceType);

        status = min(writeStatus, status);
    }

    if(NT_SUCCESS(status)) {

        PDEVICE_OBJECT newStack;

        newStack = IoAttachDeviceToDeviceStack( DeviceObject, pdo);

        functionalExtension->CommonExtension.LowerDeviceObject = newStack;
        functionalExtension->LowerPdo = pdo;

        if(newStack == NULL) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            status = STATUS_SUCCESS;
        }
    }
    return status;
}

NTSTATUS
SpCreateAdapter(
    IN PDRIVER_OBJECT DriverObject,
    OUT PDEVICE_OBJECT *Fdo
    )

/*++

Routine Description:

    This routine will allocate a new functional device object for an adapter.
    It will allocate the device and fill in the common and functional device
    extension fields which can be setup without any information about the
    adapter this device object is for.

    This routine will increment the global ScsiPortCount

Arguments:

    DriverObject - a pointer to the driver object for this device

    Fdo - a location to store the FDO pointer if the routine is successful

Return Value:

    status

--*/

{
    PSCSIPORT_DRIVER_EXTENSION driverExtension;

    LONG adapterNumber;
    ULONG i, j;

    PUNICODE_STRING registryPath;
    WCHAR wideBuffer[128];
    ULONG serviceNameIndex = 0;
    ULONG serviceNameChars;

    WCHAR wideDeviceName[64];
    UNICODE_STRING unicodeDeviceName;

    PWCHAR savedDeviceName = NULL;

    PADAPTER_EXTENSION fdoExtension;
    PCOMMON_EXTENSION commonExtension;

    NTSTATUS status;

    PAGED_CODE();

    driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                 ScsiPortInitialize);

    adapterNumber = InterlockedIncrement(&driverExtension->AdapterCount);

    RtlZeroMemory(wideBuffer, sizeof(wideBuffer));

    registryPath = &(driverExtension->RegistryPath);

    for(i = 0; i < (registryPath->Length / sizeof(WCHAR)); i++) {

        if(registryPath->Buffer[i] == UNICODE_NULL) {
            i--;
            break;
        }

        if((registryPath->Buffer[i] == L'\\') ||
           (registryPath->Buffer[i] == L'/')) {
            serviceNameIndex = i+1;
        }
    }

    serviceNameChars = (i - serviceNameIndex) + 1;

    DebugPrint((2, "SpCreateAdapter: Registry buffer %#p\n", registryPath));
    DebugPrint((2, "SpCreateAdapter: Starting offset %d chars\n",
                serviceNameIndex));
    DebugPrint((2, "SpCreateAdapter: Ending offset %d chars\n", i));
    DebugPrint((2, "SpCreateAdapter: %d chars or %d bytes will be copied\n",
                serviceNameChars, (serviceNameChars * sizeof(WCHAR))));

    DebugPrint((2, "SpCreateAdapter: Name is \""));

    for(j = 0; j < serviceNameChars; j++) {
        DebugPrint((2, "%wc", registryPath->Buffer[serviceNameIndex + j]));
    }
    DebugPrint((2, "\"\n"));

    RtlCopyMemory(wideBuffer,
                  &(registryPath->Buffer[serviceNameIndex]),
                  serviceNameChars * sizeof(WCHAR));

    swprintf(wideDeviceName,
             L"\\Device\\Scsi\\%ws%d",
             wideBuffer,
             adapterNumber);

    RtlInitUnicodeString(&unicodeDeviceName, wideDeviceName);

    DebugPrint((1, "SpCreateFdo: Device object name is %wZ\n",
                &unicodeDeviceName));

    status = IoCreateDevice(
                DriverObject,
                ADAPTER_EXTENSION_SIZE + unicodeDeviceName.MaximumLength,
                &unicodeDeviceName,
                FILE_DEVICE_CONTROLLER,
                FILE_DEVICE_SECURE_OPEN,
                FALSE,
                Fdo);

    ASSERTMSG("Name isn't unique: ", status != STATUS_OBJECT_NAME_COLLISION);

    if(!NT_SUCCESS(status)) {

        DebugPrint((1, "ScsiPortAddDevice: couldn't allocate new FDO "
                       "[%#08lx]\n", status));

        return status;
    }

    fdoExtension = (*Fdo)->DeviceExtension;
    commonExtension = &(fdoExtension->CommonExtension);

    RtlZeroMemory(fdoExtension, ADAPTER_EXTENSION_SIZE);

    commonExtension->DeviceObject = *Fdo;
    commonExtension->IsPdo = FALSE;

    commonExtension->MajorFunction = AdapterMajorFunctionTable;

    commonExtension->WmiInitialized            = FALSE;
    commonExtension->WmiMiniPortSupport        = FALSE;
    commonExtension->WmiScsiPortRegInfoBuf     = NULL;
    commonExtension->WmiScsiPortRegInfoBufSize = 0;

    commonExtension->CurrentPnpState = 0xff;
    commonExtension->PreviousPnpState = 0xff;

    commonExtension->CurrentDeviceState = PowerDeviceD0;
    commonExtension->DesiredDeviceState = PowerDeviceUnspecified;
    commonExtension->CurrentSystemState = PowerSystemWorking;

    KeInitializeEvent(&commonExtension->RemoveEvent,
                      SynchronizationEvent,
                      FALSE);

    //
    // Initialize remove lock to zero.  It will be incremented once pnp is aware
    // of its existance.
    //

    commonExtension->RemoveLock = 0;

#if DBG
    KeInitializeSpinLock(&commonExtension->RemoveTrackingSpinlock);
    commonExtension->RemoveTrackingList = NULL;

    ExInitializeNPagedLookasideList(
        &(commonExtension->RemoveTrackingLookasideList),
        NULL,
        NULL,
        0,
        sizeof(REMOVE_TRACKING_BLOCK),
        SCSIPORT_TAG_LOCK_TRACKING,
        64);

    commonExtension->RemoveTrackingLookasideListInitialized = TRUE;
#else
    commonExtension->RemoveTrackingSpinlock = (ULONG) -1L;
    commonExtension->RemoveTrackingList = (PVOID) -1L;
#endif


    SpAcquireRemoveLock(*Fdo, *Fdo);

    //
    // Initialize the logical unit list locks.
    //

    for(i = 0; i < NUMBER_LOGICAL_UNIT_BINS; i++) {
        KeInitializeSpinLock(&fdoExtension->LogicalUnitList[i].Lock);
    }

    //
    // Don't set port number until the device has been started.
    //

    fdoExtension->PortNumber = (ULONG) -1;
    fdoExtension->AdapterNumber = adapterNumber;

    //
    // Copy the device name for later use.
    //

    fdoExtension->DeviceName = (PWSTR) (fdoExtension + 1);
    RtlCopyMemory(fdoExtension->DeviceName,
                  unicodeDeviceName.Buffer,
                  unicodeDeviceName.MaximumLength);

    //
    // Initialize the enumeration synchronization event.
    //

    KeInitializeMutex(&(fdoExtension->EnumerationDeviceMutex), 0);
    ExInitializeFastMutex(&(fdoExtension->EnumerationWorklistMutex));

    ExInitializeWorkItem(&(fdoExtension->EnumerationWorkItem),
                         SpEnumerationWorker,
                         fdoExtension);

    //
    // Initialize the power up mutex.
    //

    ExInitializeFastMutex(&(fdoExtension->PowerMutex));

    //
    // Set uncached extension limits to valid values.
    //

    fdoExtension->MaximumCommonBufferBase.HighPart = 0;
    fdoExtension->MaximumCommonBufferBase.LowPart = 0xffffffff;

    //
    // Initialize the adapter BlockedLogicalUnit to point to itself 
    //
    
    fdoExtension->BlockedLogicalUnit = (PLOGICAL_UNIT_EXTENSION)
        &fdoExtension->BlockedLogicalUnit;

    (*Fdo)->Flags |= DO_DIRECT_IO;
    (*Fdo)->Flags &= ~DO_DEVICE_INITIALIZING;

    // fdoExtension->CommonExtension.IsInitialized = TRUE;

    return status;
}


VOID
SpInitializeAdapterExtension(
    IN PADAPTER_EXTENSION FdoExtension,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN OUT PHW_DEVICE_EXTENSION HwDeviceExtension OPTIONAL
    )

/*++

Routine Description:

    This routine will setup the miniport entry points and initialize values
    in the port driver device extension.  It will also setup the pointers
    to the HwDeviceExtension if supplied

Arguments:

    FdoExtension - the fdo extension being initialized

    HwInitializationData - the init data we are using to initalize the fdo
                           extension

    HwDeviceExtension - the miniport's private extension

Return Value:

    none

--*/

{
    PSCSIPORT_DRIVER_EXTENSION DrvExt;

    PAGED_CODE();

    FdoExtension->HwFindAdapter = HwInitializationData->HwFindAdapter;
    FdoExtension->HwInitialize = HwInitializationData->HwInitialize;
    FdoExtension->HwStartIo = HwInitializationData->HwStartIo;
    FdoExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    FdoExtension->HwResetBus = HwInitializationData->HwResetBus;
    FdoExtension->HwDmaStarted = HwInitializationData->HwDmaStarted;
    FdoExtension->HwLogicalUnitExtensionSize =
        HwInitializationData->SpecificLuExtensionSize;

    FdoExtension->HwAdapterControl = NULL;

    if(HwInitializationData->HwInitializationDataSize >=
       (FIELD_OFFSET(HW_INITIALIZATION_DATA, HwAdapterControl) +
        sizeof(PHW_ADAPTER_CONTROL)))  {

        //
        // This miniport knows about the stop adapter routine.  Store the
        // pointer away.
        //

        FdoExtension->HwAdapterControl = HwInitializationData->HwAdapterControl;
    }

    //
    // If scsiport's verifier is configured, initialize the verifier extension.
    //

    DrvExt = IoGetDriverObjectExtension(
                 FdoExtension->DeviceObject->DriverObject,
                 ScsiPortInitialize);
    if (DrvExt != NULL && DrvExt->Verifying == 1) {
        SpDoVerifierInit(FdoExtension, HwInitializationData);
    }

    //
    // Check if the miniport driver requires any noncached memory.
    // SRB extensions will come from this memory.  Round the size
    // a multiple of quadwords
    //

    FdoExtension->SrbExtensionSize =
        (HwInitializationData->SrbExtensionSize + sizeof(LONGLONG) - 1) &
        ~(sizeof(LONGLONG) - 1);

    //
    // Initialize the maximum lu count
    //

    FdoExtension->MaxLuCount = SCSI_MAXIMUM_LOGICAL_UNITS;

    FdoExtension->NumberOfRequests = MINIMUM_SRB_EXTENSIONS;

    if(ARGUMENT_PRESENT(HwDeviceExtension)) {
        HwDeviceExtension->FdoExtension = FdoExtension;
        FdoExtension->HwDeviceExtension = HwDeviceExtension->HwDeviceExtension;
    }

#if defined(FORWARD_PROGRESS)
    //
    // Initialize the reserved pages which we use to ensure that forward progress
    // can be made in low-memory conditions.
    //

    FdoExtension->ReservedPages = MmAllocateMappingAddress(
                                      SP_RESERVED_PAGES * PAGE_SIZE, 
                                      SCSIPORT_TAG_MAPPING_LIST);

    //
    // Allocate a spare MDL for use in low memory conditions.  Note that we 
    // pass NULL as the VirtualAddress.  We do this because we're reinitialize
    // the MDL everytime we use it with the appropriate VA and size.
    // 
 
    FdoExtension->ReservedMdl = IoAllocateMdl(NULL,
                                              SP_RESERVED_PAGES * PAGE_SIZE,
                                              FALSE,
                                              FALSE,
                                              NULL);
                                              
#endif

    FdoExtension->SrbTimeout = SRB_DEFAULT_TIMEOUT;

    //
    // Initialize the reset hold period to default 4 seconds.
    //

    FdoExtension->ResetHoldTime = 4;

    return;
}

#if !defined(NO_LEGACY_DRIVERS)

NTSTATUS
ScsiPortInitLegacyAdapter(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext
    )

/*++

Routine Description:

    This routine will locate the adapters attached to a given bus type and
    then report them (and their necessary resources) to the pnp system to
    be initialized later.

    If adapters are found, this routine will pre-initialize their device
    extensions and place them into one of the init chains for use during
    Add/Start device routines.

Arguments:

    DriverExtension - a pointer to the driver extension for this miniport

    HwInitializationData - the init data that the miniport handed to
                           ScsiPortInitialize

Return Value:

    status

--*/

{
    CONFIGURATION_CONTEXT configurationContext;

    PPORT_CONFIGURATION_INFORMATION configInfo = NULL;

    PUNICODE_STRING registryPath = &(DriverExtension->RegistryPath);

    PHW_DEVICE_EXTENSION hwDeviceExtension = NULL;

    PDEVICE_OBJECT fdo;
    PADAPTER_EXTENSION fdoExtension;

    BOOLEAN callAgain = FALSE;
    BOOLEAN isPci = FALSE;

    PCI_SLOT_NUMBER slotNumber;

    OBJECT_ATTRIBUTES objectAttributes;

    PCM_RESOURCE_LIST resourceList;

    ULONG uniqueId;

    BOOLEAN attached = FALSE;

    NTSTATUS returnStatus = STATUS_DEVICE_DOES_NOT_EXIST;
    NTSTATUS status;

    PAGED_CODE();

    slotNumber.u.AsULONG = 0;

    RtlZeroMemory(&configurationContext, sizeof(configurationContext));

    if(HwInitializationData->NumberOfAccessRanges != 0) {

        configurationContext.AccessRanges =
            SpAllocatePool(PagedPool,
                           (HwInitializationData->NumberOfAccessRanges *
                            sizeof(ACCESS_RANGE)),
                           SCSIPORT_TAG_ACCESS_RANGE,
                           DriverExtension->DriverObject);

        if(configurationContext.AccessRanges == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Keep calling the miniport's find adapter routine until the miniport
    // indicates it is doen and there is no more configuration information.
    // The loop is terminated when the SpInitializeConfiguration routine
    // inidcates ther eis no more configuration information or an error occurs.
    //

    do {

        ULONG hwDeviceExtensionSize = HwInitializationData->DeviceExtensionSize +
                                      sizeof(HW_DEVICE_EXTENSION);

        attached = FALSE;


        fdo = NULL;
        fdoExtension = NULL;

        //
        // Allocate the HwDeviceExtension first - it's easier to deallocate :)
        //

        hwDeviceExtension = SpAllocatePool(NonPagedPool,
                                           hwDeviceExtensionSize,
                                           SCSIPORT_TAG_DEV_EXT,
                                           DriverExtension->DriverObject);


        if(hwDeviceExtension == NULL) {
            DebugPrint((1, "SpInitLegacyAdapter: Could not allocate "
                           "HwDeviceExtension\n"));
            fdoExtension = NULL;
            uniqueId = __LINE__;
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(hwDeviceExtension, hwDeviceExtensionSize);

        status = SpCreateAdapter(DriverExtension->DriverObject,
                                 &fdo);

        if(!NT_SUCCESS(status)) {
            DebugPrint((1, "SpInitLegacyAdapter: Could not allocate "
                           "fdo [%#08lx]\n", status));
            ExFreePool(hwDeviceExtension);
            uniqueId = __LINE__;
            break;
        }

        fdoExtension = fdo->DeviceExtension;

        fdoExtension->IsMiniportDetected = TRUE;

        //
        // Setup device extension pointers
        //

        SpInitializeAdapterExtension(fdoExtension,
                                     HwInitializationData,
                                     hwDeviceExtension);

        hwDeviceExtension = NULL;

        fdoExtension->CommonExtension.IsInitialized = TRUE;

NewConfiguration:

        //
        // initialize the miniport config info buffer
        //

        status = SpInitializeConfiguration(
                    fdoExtension,
                    &DriverExtension->RegistryPath,
                    HwInitializationData,
                    &configurationContext);


        if(!NT_SUCCESS(status)) {

            uniqueId = __LINE__;
            break;
        }

        //
        // Allocate a config-info structure and access ranges for the
        // miniport drivers to use
        //

        configInfo = SpAllocatePool(
                        NonPagedPool,
                        ((sizeof(PORT_CONFIGURATION_INFORMATION) +
                          (HwInitializationData->NumberOfAccessRanges *
                           sizeof(ACCESS_RANGE)) + 7) & ~7),
                        SCSIPORT_TAG_ACCESS_RANGE,
                        DriverExtension->DriverObject);

        if(configInfo == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            uniqueId = __LINE__;
            break;
        }

        fdoExtension->PortConfig = configInfo;

        //
        // Copy the current structure to the writable copy
        //

        RtlCopyMemory(configInfo,
                      &configurationContext.PortConfig,
                      sizeof(PORT_CONFIGURATION_INFORMATION));

        //
        // Copy the SrbExtensionSize from device extension to ConfigInfo.
        // A check will be made later to determine if the miniport updated
        // this value
        //

        configInfo->SrbExtensionSize = fdoExtension->SrbExtensionSize;
        configInfo->SpecificLuExtensionSize = fdoExtension->HwLogicalUnitExtensionSize;

        //
        // initialize the access range array
        //

        if(HwInitializationData->NumberOfAccessRanges != 0) {

            configInfo->AccessRanges = (PVOID) (configInfo + 1);

            //
            // Quadword align this
            //

            (ULONG_PTR) (configInfo->AccessRanges) += 7;
            (ULONG_PTR) (configInfo->AccessRanges) &= ~7;

            RtlCopyMemory(configInfo->AccessRanges,
                          configurationContext.AccessRanges,
                          (HwInitializationData->NumberOfAccessRanges *
                           sizeof(ACCESS_RANGE)));
        }

        ASSERT(HwInitializationData->AdapterInterfaceType != Internal);

        //
        // If PCI bus initialize configuration information with
        // slot information.
        //

        if(HwInitializationData->AdapterInterfaceType == PCIBus &&
           HwInitializationData->VendorIdLength > 0 &&
           HwInitializationData->DeviceIdLength > 0 &&
           HwInitializationData->DeviceId &&
           HwInitializationData->VendorId) {

            PCI_SLOT_NUMBER tmp;

            isPci = TRUE;

            configInfo->BusInterruptLevel = 0;
            if(!GetPciConfiguration(DriverExtension->DriverObject,
                                    fdo,
                                    HwInitializationData,
                                    registryPath,
                                    configurationContext.BusNumber,
                                    &slotNumber)) {


                //
                // Adapter not found.  Continue search with next bus
                //

                configurationContext.BusNumber++;
                slotNumber.u.AsULONG = 0;
                fdoExtension->PortConfig = NULL;
                ExFreePool(configInfo);
                callAgain = FALSE;
                goto NewConfiguration;

            }

            fdoExtension->IsMiniportDetected = FALSE;

            //
            // GetPciConfiguration increments the function number when it
            // finds something.  We need to be looking at the previous
            // function number.
            //

            tmp.u.AsULONG = slotNumber.u.AsULONG;
            tmp.u.bits.FunctionNumber--;
            configInfo->SlotNumber = tmp.u.AsULONG;

            SpBuildConfiguration(fdoExtension,
                                 HwInitializationData,
                                 configInfo);

            if(!configInfo->BusInterruptLevel) {

                //
                // No interrupt was assigned - skip this slot and call
                // again
                //

                fdoExtension->PortConfig = NULL;
                ExFreePool(configInfo);
                goto NewConfiguration;
            }

        }

        //
        // Get the miniport configuration inofmraiton
        //

        callAgain = FALSE;

        status = SpCallHwFindAdapter(fdo,
                                     HwInitializationData,
                                     HwContext,
                                     &configurationContext,
                                     configInfo,
                                     &callAgain);


        if(NT_SUCCESS(status)) {

            status = SpAllocateAdapterResources(fdo);

            if(NT_SUCCESS(status)) {
                status = SpCallHwInitialize(fdo);
            }

            attached = TRUE;

        } else if (status == STATUS_DEVICE_DOES_NOT_EXIST) {

            PCM_RESOURCE_LIST emptyResources = NULL;

            configurationContext.BusNumber++;
            fdoExtension->PortConfig = NULL;
            ExFreePool(configInfo);
            callAgain = FALSE;

            //
            // Release the resources we've allocated for this device object
            // if it's a PCI system.
            //

            IoAssignResources(registryPath,
                              NULL,
                              DriverExtension->DriverObject,
                              fdo,
                              NULL,
                              &emptyResources);

            if(emptyResources != NULL) {
                ExFreePool(emptyResources);
            }

            goto NewConfiguration;
        }

        if(NT_SUCCESS(status)) {

            //
            // Try to start the adapter
            //

            status = ScsiPortStartAdapter(fdo);

            if(NT_SUCCESS(status)) {
                fdoExtension->CommonExtension.CurrentPnpState =
                    IRP_MN_START_DEVICE;
            }
        }

        if(!NT_SUCCESS(returnStatus)) {

            //
            // if no devices were found then just return the current status
            //

            returnStatus = status;

        }

        if(!NT_SUCCESS(status)) {
            break;
        }

        SpEnumerateAdapterSynchronous(fdoExtension, TRUE);

        //
        // update the local adapter count
        //

        configurationContext.AdapterNumber++;

        //
        // Bump the bus number if miniport inidicated that it should not be
        // called again on this bus.
        //

        if(!callAgain) {
            configurationContext.BusNumber++;
        }

        //
        // Set the return status to STATUS_SUCCESS to indicate that one HBA
        // was found.
        //

        returnStatus = STATUS_SUCCESS;

    } while(TRUE);

    if(!NT_SUCCESS(status)) {

        //
        // If the device existed but some other error occurred then log it.
        //

        if(status != STATUS_DEVICE_DOES_NOT_EXIST) {

            PIO_ERROR_LOG_PACKET errorLogEntry;

            //
            // An error occured - log it.
            //

            errorLogEntry = (PIO_ERROR_LOG_PACKET)
                                IoAllocateErrorLogEntry(
                                    fdo,
                                    sizeof(IO_ERROR_LOG_PACKET));

            if(errorLogEntry != NULL) {
                errorLogEntry->ErrorCode = IO_ERR_DRIVER_ERROR;
                errorLogEntry->UniqueErrorValue = uniqueId;
                errorLogEntry->FinalStatus = status;
                errorLogEntry->DumpDataSize = 0;
                IoWriteErrorLogEntry(errorLogEntry);
            }
        }

        if(attached) {

            //
            // Tell PNP that this device should be destroyed.
            //

            fdoExtension->DeviceState = PNP_DEVICE_DISABLED | PNP_DEVICE_FAILED;
            fdoExtension->CommonExtension.CurrentPnpState = IRP_MN_REMOVE_DEVICE;
            IoInvalidateDeviceState(fdoExtension->LowerPdo);

        } else {

            //
            // If the HwDeviceExtension hasn't been deleted or assigned to the
            // adapter yet then delete it.
            //

            if(hwDeviceExtension != NULL) {
                ExFreePool(hwDeviceExtension);
            }

            //
            // Clean up the last device object which is not used.
            //

            if (fdoExtension != NULL) {
                fdoExtension->CommonExtension.IsRemoved = REMOVE_PENDING;
                fdoExtension->CommonExtension.CurrentPnpState = IRP_MN_REMOVE_DEVICE;
                SpReleaseRemoveLock(fdoExtension->DeviceObject,
                                    fdoExtension->DeviceObject);
                SpDestroyAdapter(fdoExtension, FALSE);
            }

            //
            // Delete it.
            //

            IoDeleteDevice(fdo);

        }

        if (configurationContext.AccessRanges != NULL) {
            ExFreePool(configurationContext.AccessRanges);
        }

        if (configurationContext.Parameter != NULL) {
            ExFreePool(configurationContext.Parameter);
        }

    }

    return returnStatus;
}
#endif // NO_LEGACY_DRIVERS


NTSTATUS
SpCallHwFindAdapter(
    IN PDEVICE_OBJECT Fdo,
    IN PHW_INITIALIZATION_DATA HwInitData,
    IN PVOID HwContext OPTIONAL,
    IN OUT PCONFIGURATION_CONTEXT ConfigurationContext,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN CallAgain
    )

/*++

Routine Description:

    This routine will issue a call to the miniport's find adapter routine

Arguments:

    Fdo - the fdo for the adapter being found.  This fdo must have already
          had it's device extension initialized and a HwDeviceExtension
          allocated

    HwInitData - a pointer to the HwINitializationData block passed in by the
                 miniport

    HwContext - the context information passed into ScsiPortInitialize by
                the miniport if it's still available

    ConfigurationContext - A configuration context structure which contains
                           state information during a device detection

    ConfigInfo - the config info structure for the miniport's resources

    CallAgain - a boolean flag indicating whether the miniport said to call it
                again for this interface type

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapter = Fdo->DeviceExtension;
    PSCSIPORT_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(Fdo->DriverObject,
                                                     ScsiPortInitialize);

    NTSTATUS status;

    PCM_RESOURCE_LIST resourceList;

    *CallAgain = FALSE;

    //
    // Preallocate space for 20 address mappings.  This should be enough
    // to handle any miniport.  We'll shrink down the allocation and
    // setup the appropriate "next" pointers once the adapter has been
    // initialized.
    //

    SpPreallocateAddressMapping(adapter, 20);

    status = adapter->HwFindAdapter(adapter->HwDeviceExtension,
                                       HwContext,
                                       NULL,
                                       ConfigurationContext->Parameter,
                                       ConfigInfo,
                                       CallAgain);

    if(adapter->InterruptData.InterruptFlags & PD_LOG_ERROR) {

        adapter->InterruptData.InterruptFlags &=
            ~(PD_LOG_ERROR | PD_NOTIFICATION_REQUIRED);

        LogErrorEntry(adapter, &(adapter->InterruptData.LogEntry));
    }

    //
    // Free the pointer to the bus data at map register base.  This was
    // allocated by ScsiPortGetBusData
    //

    if(adapter->MapRegisterBase) {

        ExFreePool(adapter->MapRegisterBase);
        adapter->MapRegisterBase = NULL;
    }

    //
    // If the device/driver doesn't support bus mastering then it cannot run
    // on a system with 64-bit addresses.
    //

    if((status == SP_RETURN_FOUND) &&
       (ConfigInfo->Master == FALSE) &&
       (Sp64BitPhysicalAddresses == TRUE)) {

        DebugPrint((0, "SpCallHwFindAdapter: Driver does not support bus "
                       "mastering for adapter %#08lx - this type of adapter is "
                       "not supported on systems with 64-bit physical "
                       "addresses\n", adapter));
        return STATUS_NOT_SUPPORTED;
    }

    //
    // If no device was found then return an error
    //

    if(status != SP_RETURN_FOUND) {

        DebugPrint((1, "SpFindAdapter: miniport find adapter routine reported "
                       "an error %d\n", status));

        switch(status) {

            case SP_RETURN_NOT_FOUND: {

                //
                // The driver could not find any devices on this bus.
                // Try the next bus.
                //

                *CallAgain = FALSE;
                return STATUS_DEVICE_DOES_NOT_EXIST;
            }

            case SP_RETURN_BAD_CONFIG: {
                return STATUS_INVALID_PARAMETER;
            }

            case SP_RETURN_ERROR: {
                return STATUS_ADAPTER_HARDWARE_ERROR;
            }

            default: {
                return STATUS_INTERNAL_ERROR;
            }
        }

        return status;

    } else {
        status = STATUS_SUCCESS;
    }

    //
    // Cleanup the mapped address list.
    //

    SpPurgeFreeMappedAddressList(adapter);

    DebugPrint((1, "SpFindAdapter: SCSI Adapter ID is %d\n",
                   ConfigInfo->InitiatorBusId[0]));

    //
    // Check the resource requirements against the registry.  This will
    // check for conflicts and store the information if none were found.
    //

    if(!adapter->IsPnp) {

        UNICODE_STRING unicodeString;
        BOOLEAN conflict;

        RtlInitUnicodeString(&unicodeString, L"ScsiAdapter");

        adapter->AllocatedResources =
            SpBuildResourceList(adapter, ConfigInfo);

        status = SpReportNewAdapter(Fdo);

        if(!NT_SUCCESS(status)) {

            return status;
        }
    }

    //
    // Update SrbExtensionSize and SpecificLuExtensionSize, if necessary.
    // If the common buffer has already been allocated, this has already
    // been done
    //

    if(!adapter->NonCachedExtension &&
       (ConfigInfo->SrbExtensionSize != adapter->SrbExtensionSize)) {

        adapter->SrbExtensionSize =
            (ConfigInfo->SrbExtensionSize + sizeof(LONGLONG)) &
             ~(sizeof(LONGLONG) - 1);

    }

    if(ConfigInfo->SpecificLuExtensionSize !=
       adapter->HwLogicalUnitExtensionSize) {

        adapter->HwLogicalUnitExtensionSize =
            ConfigInfo->SpecificLuExtensionSize;
    }

    //
    // Get maximum target IDs.
    //

    if(ConfigInfo->MaximumNumberOfTargets > SCSI_MAXIMUM_TARGETS_PER_BUS) {
        adapter->MaximumTargetIds = SCSI_MAXIMUM_TARGETS_PER_BUS;
    } else {
        adapter->MaximumTargetIds = ConfigInfo->MaximumNumberOfTargets;
    }

    //
    // Get number of SCSI buses.
    //

    adapter->NumberOfBuses = ConfigInfo->NumberOfBuses;

    //
    // Remember if the adapter caches data.
    //

    adapter->CachesData = ConfigInfo->CachesData;

    //
    // Save away some of the attributes.
    //

    adapter->ReceiveEvent = ConfigInfo->ReceiveEvent;
    adapter->TaggedQueuing = ConfigInfo->TaggedQueuing;
    adapter->MultipleRequestPerLu = ConfigInfo->MultipleRequestPerLu;
    adapter->CommonExtension.WmiMiniPortSupport = ConfigInfo->WmiDataProvider;

    //
    // Clear those options which have been disabled in the registry.
    //

    if(ConfigurationContext->DisableMultipleLu) {
        adapter->MultipleRequestPerLu =
            ConfigInfo->MultipleRequestPerLu = FALSE;
    }

    if(ConfigurationContext->DisableTaggedQueueing) {
        adapter->TaggedQueuing =
            ConfigInfo->TaggedQueuing = 
            ConfigInfo->MultipleRequestPerLu = FALSE;
    }

    //
    // If the adapter supports tagged queuing or multiple requests per logical
    // unit, SRB data needs to be allocated.
    //

    if (adapter->TaggedQueuing || adapter->MultipleRequestPerLu) {
        adapter->SupportsMultipleRequests = TRUE;
    } else {
        adapter->SupportsMultipleRequests = FALSE;
    }

    return status;
}


NTSTATUS
SpAllocateAdapterResources(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will allocate and initialize any necessary resources for the
    adapter.  It handles one time initialization of the srb data blocks,
    srb extensions, etc...

Arguments:

    Fdo - a pointer to the functional device object being initialized

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_SCSI_CAPABILITIES capabilities;
    PPORT_CONFIGURATION_INFORMATION configInfo =
        fdoExtension->PortConfig;

    NTSTATUS status = STATUS_SUCCESS;
    PVOID SrbExtensionBuffer;

    PAGED_CODE();

    //
    // Initialize the capabilities pointer
    //

    capabilities = &fdoExtension->Capabilities;

    //
    // Set indicator as to whether adapter needs kernel mapped buffers
    //

    fdoExtension->MapBuffers = configInfo->MapBuffers;
    capabilities->AdapterUsesPio = configInfo->MapBuffers;

    //
    // Determine if a DMA Adapter must be allocated
    //

    if((fdoExtension->DmaAdapterObject == NULL) &&
       (configInfo->Master ||
        configInfo->DmaChannel != SP_UNINITIALIZED_VALUE)) {

        DEVICE_DESCRIPTION deviceDescription;
        ULONG numberOfMapRegisters;

        //
        // Get the adapter object for this card
        //

        RtlZeroMemory(&deviceDescription, sizeof(deviceDescription));

        deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;

        deviceDescription.DmaChannel = configInfo->DmaChannel;
        deviceDescription.InterfaceType = configInfo->AdapterInterfaceType;
        deviceDescription.BusNumber = configInfo->SystemIoBusNumber;
        deviceDescription.DmaWidth = configInfo->DmaWidth;
        deviceDescription.DmaSpeed = configInfo->DmaSpeed;
        deviceDescription.ScatterGather = configInfo->ScatterGather;
        deviceDescription.Master = configInfo->Master;
        deviceDescription.DmaPort = configInfo->DmaPort;
        deviceDescription.Dma32BitAddresses = configInfo->Dma32BitAddresses;
        deviceDescription.AutoInitialize = FALSE;
        deviceDescription.DemandMode = configInfo->DemandMode;
        deviceDescription.MaximumLength = configInfo->MaximumTransferLength;

        fdoExtension->Dma32BitAddresses = configInfo->Dma32BitAddresses;

        //
        // If the miniport puts anything in here other than 0x80 then we
        // assume it wants to support 64-bit addresses.
        //

        DebugPrint((1, "SpAllocateAdapterResources: Dma64BitAddresses = "
                       "%#0x\n",
                    configInfo->Dma64BitAddresses));

        fdoExtension->RemapBuffers = (BOOLEAN) (SpRemapBuffersByDefault != 0);

        if((configInfo->Dma64BitAddresses & ~SCSI_DMA64_SYSTEM_SUPPORTED) != 0){
            DebugPrint((1, "SpAllocateAdapterResources: will request "
                           "64-bit PA's\n"));
            deviceDescription.Dma64BitAddresses = TRUE;
            fdoExtension->Dma64BitAddresses = TRUE;
        } else if(Sp64BitPhysicalAddresses == TRUE) {
            DebugPrint((1, "SpAllocateAdapterResources: Will remap buffers for adapter %#p\n", fdoExtension));
            fdoExtension->RemapBuffers = TRUE;
        }

        fdoExtension->DmaAdapterObject = IoGetDmaAdapter(fdoExtension->LowerPdo,
                                                         &deviceDescription,
                                                         &numberOfMapRegisters);

        ASSERT(fdoExtension->DmaAdapterObject);

        //
        // Set maximum number of page breaks
        //

        if(numberOfMapRegisters > configInfo->NumberOfPhysicalBreaks) {
            capabilities->MaximumPhysicalPages =
                configInfo->NumberOfPhysicalBreaks;
        } else {
            capabilities->MaximumPhysicalPages = numberOfMapRegisters;
        }
    }

    status = SpAllocateTagBitMap(fdoExtension);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Initialize power parameters.
    //

    SpInitializePowerParams(fdoExtension);

    //
    // Initialize tunable per-adapter performance parameters.
    //

    SpInitializePerformanceParams(fdoExtension);

    //
    // Allocate memory for the noncached extension if it has not already
    // been allocated.  If the adapter supports AutoRequestSense or
    // needs SRB extensions then an SRB list needs to be allocated.
    //

    SrbExtensionBuffer = SpGetSrbExtensionBuffer(fdoExtension);
    if(((fdoExtension->SrbExtensionSize != 0) || (configInfo->AutoRequestSense)) &&
       (SrbExtensionBuffer == NULL))  {

        //
        // Initialize configurable request sense parameters.
        //

        SpInitializeRequestSenseParams(fdoExtension);

        //
        // Capture the auto request sense flag when the common buffer is
        // allocated.
        //

        fdoExtension->AutoRequestSense = configInfo->AutoRequestSense;

        fdoExtension->AllocateSrbExtension = TRUE;

        status = SpGetCommonBuffer(fdoExtension, 0);

        if(!NT_SUCCESS(status)) {
            return status;
        }
    }

    status = SpInitializeSrbDataLookasideList(Fdo);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Initialize the emergency SRB_DATA structures.
    //

    fdoExtension->EmergencySrbData = SpAllocateSrbData(fdoExtension, NULL, NULL);

    if(fdoExtension->EmergencySrbData == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we are re-initializing a stopped adapter, we must not wipe out any 
    // existing blocked requests.
    //

    if (fdoExtension->SrbDataBlockedRequests.Flink == NULL &&
        fdoExtension->SrbDataBlockedRequests.Blink == NULL) {
        InitializeListHead(&fdoExtension->SrbDataBlockedRequests);
    }

    KeInitializeSpinLock(&fdoExtension->EmergencySrbDataSpinLock);

    //
    // Initialize the pointer to the enumeration request block.
    //

    fdoExtension->PnpEnumRequestPtr = &(fdoExtension->PnpEnumerationRequest);

    //
    // Allocate buffers needed for bus scans.
    //

    fdoExtension->InquiryBuffer = SpAllocatePool(
                                    NonPagedPoolCacheAligned,
                                    SP_INQUIRY_BUFFER_SIZE,
                                    SCSIPORT_TAG_INQUIRY,
                                    Fdo->DriverObject);

    if(fdoExtension->InquiryBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    fdoExtension->InquirySenseBuffer = 
        SpAllocatePool(
            NonPagedPoolCacheAligned,
            SENSE_BUFFER_SIZE + fdoExtension->AdditionalSenseBytes,
            SCSIPORT_TAG_INQUIRY,
            Fdo->DriverObject);

    if(fdoExtension->InquirySenseBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Preallocate an irp for inquiries.  Since this is only used for scsi
    // operations we should only need one stack location.
    //

    fdoExtension->InquiryIrp = SpAllocateIrp(INQUIRY_STACK_LOCATIONS, FALSE, Fdo->DriverObject);

    if(fdoExtension->InquiryIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build an MDL for the inquiry buffer.
    //

    fdoExtension->InquiryMdl = SpAllocateMdl(fdoExtension->InquiryBuffer,
                                             INQUIRYDATABUFFERSIZE,
                                             FALSE,
                                             FALSE,
                                             NULL,
                                             Fdo->DriverObject);

    if(fdoExtension->InquiryMdl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmBuildMdlForNonPagedPool(fdoExtension->InquiryMdl);

    //
    // Initialize the capabilities structure.
    //

    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);
    capabilities->MaximumTransferLength = configInfo->MaximumTransferLength;

    if(configInfo->ReceiveEvent) {
        capabilities->SupportedAsynchronousEvents |=
            SRBEV_SCSI_ASYNC_NOTIFICATION;
    }

    capabilities->TaggedQueuing = fdoExtension->TaggedQueuing;
    capabilities->AdapterScansDown = configInfo->AdapterScansDown;

    //
    // Update the device object alignment if necessary.
    //

    if(configInfo->AlignmentMask > Fdo->AlignmentRequirement) {
        Fdo->AlignmentRequirement = configInfo->AlignmentMask;
    }

    capabilities->AlignmentMask = Fdo->AlignmentRequirement;

    //
    // Make sure maximum number of pages is set to a reasonable value.
    // This occurs for miniports with no Dma adapter.
    //

    if(capabilities->MaximumPhysicalPages == 0) {

        capabilities->MaximumPhysicalPages =
            BYTES_TO_PAGES(capabilities->MaximumTransferLength);

        //
        // Honor any limit requested by the miniport
        //

        if(configInfo->NumberOfPhysicalBreaks < capabilities->MaximumPhysicalPages) {
            capabilities->MaximumPhysicalPages =
                configInfo->NumberOfPhysicalBreaks;
        }

    }

    return status;
}


NTSTATUS
SpCallHwInitialize(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will initialize the specified adapter, connect the interrupts,
    and initialize any necessary resources

Arguments:

    Fdo - a pointer to the functional device object being initialized

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PPORT_CONFIGURATION_INFORMATION configInfo =
        fdoExtension->PortConfig;

    KIRQL irql;
    NTSTATUS status;

    //
    // Allocate spin lock for critical sections.
    //

    KeInitializeSpinLock(&fdoExtension->SpinLock);

    //
    // Initialize DPC routine.
    //

    IoInitializeDpcRequest(fdoExtension->CommonExtension.DeviceObject,
                           ScsiPortCompletionDpc);

    //
    // Initialize the port timeout counter.
    //

    fdoExtension->PortTimeoutCounter = PD_TIMER_STOPPED;

    //
    // Initialize the device object timer only if it doesn't already exist
    // (there's no way to delete a timer without deleting the device so if
    // we are stopped and restarted then the timer stays around.  Reinitializing
    // it could cause the timer list to go circular)
    //

    if(Fdo->Timer == NULL) {
        IoInitializeTimer(Fdo, ScsiPortTickHandler, NULL);
    }

    //
    // Initialize miniport timer and timer DPC
    //

    KeInitializeTimer(&fdoExtension->MiniPortTimer);

    KeInitializeDpc(&fdoExtension->MiniPortTimerDpc,
                    SpMiniPortTimerDpc,
                    Fdo);

    KeInitializeSpinLock(&fdoExtension->InterruptSpinLock);

    if((fdoExtension->HwInterrupt == NULL) ||
       (fdoExtension->HasInterrupt == FALSE)) {

        //
        // There is no interrupt so use the dummy routine.
        //

        fdoExtension->SynchronizeExecution = SpSynchronizeExecution;
        fdoExtension->InterruptObject = (PVOID) fdoExtension;

        DebugPrint((1, "ScsiPortInitialize: Adapter has no interrupt.\n"));

    } else {

        KIRQL syncIrql = 0;
        KIRQL irql2 = 0;
        ULONG vector = 0, vector2 = 0;
        KAFFINITY affinity = 0, affinity2 = 0;
        BOOLEAN interruptSharable = FALSE;
        BOOLEAN secondInterrupt = FALSE;

        DebugPrint((1, "ScsiPortInitialize: Interrupt Info for adapter %#p\n", Fdo));

        DebugPrint((1, "ScsiPortInitialize: AdapterInterfaceType = %d\n", configInfo->AdapterInterfaceType));
        DebugPrint((1, "ScsiPortInitialize: BusInterruptLevel = %d\n", configInfo->BusInterruptLevel));
        DebugPrint((1, "ScsiPortInitialize: BusInterruptVector = %d\n", configInfo->BusInterruptVector));
        DebugPrint((1, "ScsiPortInitialize: BusInterruptLevel2 = %d\n", configInfo->BusInterruptLevel2));
        DebugPrint((1, "ScsiPortInitialize: BusInterruptVector2 = %d\n", configInfo->BusInterruptVector2));

        irql = 0;

        //
        // Determine if 2 interrupt sync. is needed.
        //

        if(fdoExtension->HwInterrupt != NULL &&
           (configInfo->BusInterruptLevel != 0 ||
            configInfo->BusInterruptVector != 0) &&
           (configInfo->BusInterruptLevel2 != 0 ||
            configInfo->BusInterruptVector2 != 0)) {

            secondInterrupt = TRUE;
        }

        //
        // Save the interrupt level.
        //

        fdoExtension->InterruptLevel = configInfo->BusInterruptLevel;

        //
        // Set up for a real interrupt.
        //

        fdoExtension->SynchronizeExecution = KeSynchronizeExecution;

        //
        // Call HAL to get system interrupt parameters for the first
        // interrupt.
        //

        if(fdoExtension->IsMiniportDetected) {

#if defined(NO_LEGACY_DRIVERS)

            DbgPrint("SpCallHwInitialize:  fdoExtension->IsMiniportDetected "
                     "not supported for 64 bits!\n");
#else

            vector = HalGetInterruptVector(
                        configInfo->AdapterInterfaceType,
                        configInfo->SystemIoBusNumber,
                        configInfo->BusInterruptLevel,
                        configInfo->BusInterruptVector,
                        &irql,
                        &affinity);

            if(secondInterrupt) {

                //
                // Spin lock to sync. multiple IRQ's (PCI IDE).
                //

                KeInitializeSpinLock(&fdoExtension->MultipleIrqSpinLock);

                //
                // Call HAL to get system interrupt parameters for the
                // second interrupt.
                //

                vector2 = HalGetInterruptVector(
                            configInfo->AdapterInterfaceType,
                            configInfo->SystemIoBusNumber,
                            configInfo->BusInterruptLevel2,
                            configInfo->BusInterruptVector2,
                            &irql2,
                            &affinity2);
            }

            ASSERT(affinity != 0);

            if(configInfo->AdapterInterfaceType == MicroChannel ||
               configInfo->InterruptMode == LevelSensitive) {
               interruptSharable = TRUE;
            }

#endif // NO_LEGACY_DRIVERS

        } else {

            ULONG i, j;

            ASSERT(secondInterrupt == FALSE);

            for(i = 0; i < fdoExtension->TranslatedResources->Count; i++) {

                for(j = 0;
                    j < fdoExtension->TranslatedResources->List[i].PartialResourceList.Count;
                    j++) {

                    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor =
                        &fdoExtension->TranslatedResources->List[i].PartialResourceList.PartialDescriptors[j];

                    if(descriptor->Type == CmResourceTypeInterrupt) {

                        vector = descriptor->u.Interrupt.Vector;
                        affinity = descriptor->u.Interrupt.Affinity;
                        irql = (KIRQL) descriptor->u.Interrupt.Level;

                        if(descriptor->ShareDisposition == CmResourceShareShared) {
                            interruptSharable = TRUE;
                        }

                        break;
                    }
                }
            }
        }

        syncIrql = (irql > irql2) ? irql : irql2;

        DebugPrint((1, "SpInitializeAdapter: vector = %d\n", vector));
        DebugPrint((1, "SpInitializeAdapter: irql = %d\n", irql));
        DebugPrint((1, "SpInitializeAdapter: affinity = %#08lx\n", affinity));

        status = IoConnectInterrupt(
                    &fdoExtension->InterruptObject,
                    (PKSERVICE_ROUTINE) ScsiPortInterrupt,
                    Fdo,
                    (secondInterrupt ?
                        (&fdoExtension->MultipleIrqSpinLock) : NULL),
                    vector,
                    irql,
                    syncIrql,
                    configInfo->InterruptMode,
                    interruptSharable,
                    affinity,
                    FALSE);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1, "SpInitializeAdapter: Can't connect "
                           "interrupt %d\n", vector));
            fdoExtension->InterruptObject = NULL;
            return status;
        }

        if(secondInterrupt) {

            DebugPrint((1, "SpInitializeAdapter: SCSI adapter second IRQ is %d\n",
                           configInfo->BusInterruptLevel2));

            DebugPrint((1, "SpInitializeAdapter: vector = %d\n", vector));
            DebugPrint((1, "SpInitializeAdapter: irql = %d\n", irql));
            DebugPrint((1, "SpInitializeAdapter: affinity = %#08lx\n", affinity));

            status = IoConnectInterrupt(
                        &fdoExtension->InterruptObject2,
                        (PKSERVICE_ROUTINE) ScsiPortInterrupt,
                        Fdo,
                        &fdoExtension->MultipleIrqSpinLock,
                        vector2,
                        irql2,
                        syncIrql,
                        configInfo->InterruptMode2,
                        interruptSharable,
                        affinity2,
                        FALSE);

            if(!NT_SUCCESS(status)) {

                //
                // If we needed both interrupts, we will continue but not
                // claim any of the resources for the second one
                //

                DebugPrint((1, "SpInitializeAdapter: Can't connect "
                               "second interrupt %d\n", vector2));
                fdoExtension->InterruptObject2 = NULL;

                configInfo->BusInterruptVector2 = 0;
                configInfo->BusInterruptLevel2 = 0;
            }
        }
    }

    //
    // Record first access range if it exists.
    //

    if(configInfo->NumberOfAccessRanges != 0) {
        fdoExtension->IoAddress =
            ((*(configInfo->AccessRanges))[0]).RangeStart.LowPart;

        DebugPrint((1, "SpInitializeAdapter: IO Base address %x\n",
                       fdoExtension->IoAddress));
    }

    //
    // Indicate that a disconnect allowed command running.  This bit is
    // normally on.
    //

    fdoExtension->Flags |= PD_DISCONNECT_RUNNING;

    //
    // Initialize the request count to -1.  This count is biased by -1 so
    // that a value of zero indicates the adapter must be allocated
    //

    fdoExtension->ActiveRequestCount = -1;

    //
    // Indiciate if a scatter/gather list needs to be built.
    //

    if(fdoExtension->DmaAdapterObject != NULL &&
       configInfo->Master &&
       configInfo->NeedPhysicalAddresses) {
        fdoExtension->MasterWithAdapter = TRUE;
    } else {
        fdoExtension->MasterWithAdapter = FALSE;
    }

    //
    // Call the hardware dependant driver to do it's initialization.
    // This routine must be called at DISPATCH_LEVEL.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &irql);

    if(!fdoExtension->SynchronizeExecution(fdoExtension->InterruptObject,
                                           fdoExtension->HwInitialize,
                                           fdoExtension->HwDeviceExtension)) {

        DebugPrint((1, "SpInitializeAdapter: initialization failed\n"));
        KeLowerIrql(irql);
        return STATUS_ADAPTER_HARDWARE_ERROR;
    }

    //
    // Check for miniport work requests.  Note this is an unsynchronized
    // test on the bit that can be set by the interrupt routine;  However,
    // the worst that can happen is that the completion DPC checks for work
    // twice.
    //

    if(fdoExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        //
        // Call the completion DPC directly.  It must be called at dispatch
        // level.
        //

        SpRequestCompletionDpc(Fdo);
    }

    KeLowerIrql(irql);

    return STATUS_SUCCESS;
}


HANDLE
SpOpenDeviceKey(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber
    )

/*++

Routine Description:

    This routine will open the services keys for the miniport and put handles
    to them into the configuration context structure.

Arguments:

    RegistryPath - a pointer to the service key name for this miniport

    DeviceNumber - which device too search for under the service key.  -1
                   indicates that the default device key should be opened.

Return Value:

    status

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;

    WCHAR buffer[64];
    UNICODE_STRING unicodeString;

    HANDLE serviceKey;
    HANDLE deviceKey = NULL;

    NTSTATUS status;

    PAGED_CODE();

    serviceKey = SpOpenParametersKey(RegistryPath);

    if(serviceKey != NULL) {

        //
        // Check for a Device Node.  The device node applies to every device
        //

        if(DeviceNumber == (ULONG) -1) {
            swprintf(buffer, L"Device");
        } else {
            swprintf(buffer, L"Device%d", DeviceNumber);
        }

        RtlInitUnicodeString(&unicodeString, buffer);

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   serviceKey,
                                   (PSECURITY_DESCRIPTOR) NULL);

        //
        // It doesn't matter if this call fails or not.  If it fails, then there
        // is no default device node.  If it works then the handle will be set.
        //

        ZwOpenKey(&deviceKey,
                  KEY_READ,
                  &objectAttributes);

        ZwClose(serviceKey);
    }

    return deviceKey;
}

HANDLE
SpOpenParametersKey(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine will open the services keys for the miniport and put handles
    to them into the configuration context structure.

Arguments:

    RegistryPath - a pointer to the service key name for this miniport

Return Value:

    status

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;

    UNICODE_STRING unicodeString;

    HANDLE serviceKey;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Open the service node
    //

    InitializeObjectAttributes(&objectAttributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&serviceKey, KEY_READ, &objectAttributes);

    if(!NT_SUCCESS(status)) {

        DebugPrint((1, "SpOpenParameterKey: cannot open service key node for "
                       "driver.  Name: %wZ Status: %08lx\n",
                       RegistryPath, status));
    }

    //
    // Try to open the parameters key.  If it exists then replace the service
    // key with the new key.  This allows the device nodes to be placed
    // under DriverName\Parameters\Device or DriverName\Device
    //

    if(serviceKey != NULL) {

        HANDLE parametersKey;

        //
        // Check for a device node.  The device node applies to every device
        //

        RtlInitUnicodeString(&unicodeString, L"Parameters");

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   serviceKey,
                                   (PSECURITY_DESCRIPTOR) NULL);

        //
        // Attempt to open the parameters key
        //

        status = ZwOpenKey(&parametersKey,
                           KEY_READ,
                           &objectAttributes);

        if(NT_SUCCESS(status)) {

            //
            // There is a Parameters key.  Use that instead of the service
            // node key.  Close the service node and set the new value
            //

            ZwClose(serviceKey);
            serviceKey = parametersKey;
        }
    }

    return serviceKey;
}


ULONG
SpQueryPnpInterfaceFlags(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN INTERFACE_TYPE InterfaceType
    )

/*++

Routine Description:

    This routine will look up the interface type in the PnpInterface value
    in the service's parameters key.  If the interface is found in this binary
    value the routine will return TRUE.  If the interface type is not there or
    if any errors occur reading the data, this routine will return FALSE.

Arguments:

    ConfigurationContext - a pointer to the configuration context for this
                           miniport

    InterfaceType - the interface type we are searching for

Return Value:

    TRUE if the interface type is in the safe list

    FALSE if the interface type is not in the safe list or if the value cannot
    be found

--*/

{
    ULONG i;

    PAGED_CODE();

    for(i = 0; i < DriverExtension->PnpInterfaceCount; i++) {

        if(DriverExtension->PnpInterface[i].InterfaceType == InterfaceType) {

            DebugPrint((2, "SpQueryPnpInterfaceFlags: interface %d has flags "
                           "%#08lx\n",
                        InterfaceType,
                        DriverExtension->PnpInterface[i].Flags));

            return DriverExtension->PnpInterface[i].Flags;
        }

    }

    DebugPrint((2, "SpQueryPnpInterfaceFlags: No interface flags for %d\n",
                InterfaceType));
    return SP_PNP_NOT_SAFE;
}


ULONG
ScsiPortGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the bus data for an adapter slot or CMOS address.

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/

{
    PADAPTER_EXTENSION fdoExtension = GET_FDO_EXTENSION(DeviceExtension);
    PDEVICE_OBJECT lowerDevice = NULL;
    CM_EISA_SLOT_INFORMATION slotInformation;

    //
    // If this is in a virtualized slot then setup the lower device object
    // pointer to go to the PDO
    //

    if(fdoExtension->IsInVirtualSlot) {

        //
        // Make sure the bus and slot number are correct
        //

        if(SlotNumber != fdoExtension->VirtualSlotNumber.u.AsULONG) {
            ASSERT(BusDataType == PCIConfiguration);
            return 2;
        }

        lowerDevice = fdoExtension->CommonExtension.LowerDeviceObject;
    }

    //
    // If the length is nonzero, retrieve the requested data.
    //

    if (Length != 0) {

        return SpGetBusData(fdoExtension,
                            lowerDevice,
                            BusDataType,
                            SystemIoBusNumber,
                            SlotNumber,
                            Buffer,
                            Length);
    }

    //
    // Free any previously allocated data.
    //

    if (fdoExtension->MapRegisterBase != NULL) {
        ExFreePool(fdoExtension->MapRegisterBase);
        fdoExtension->MapRegisterBase = NULL;
    }

    if (BusDataType == EisaConfiguration) {

        //
        // Determine the length to allocate based on the number of functions
        // for the slot.
        //

        Length = SpGetBusData( fdoExtension,
                               lowerDevice,
                               BusDataType,
                               SystemIoBusNumber,
                               SlotNumber,
                               &slotInformation,
                               sizeof(CM_EISA_SLOT_INFORMATION));


        if (Length < sizeof(CM_EISA_SLOT_INFORMATION)) {

            //
            // The data is messed up since this should never occur
            //

            return 0;
        }

        //
        // Calculate the required length based on the number of functions.
        //

        Length = sizeof(CM_EISA_SLOT_INFORMATION) +
            (sizeof(CM_EISA_FUNCTION_INFORMATION) * slotInformation.NumberFunctions);

    } else if (BusDataType == PCIConfiguration) {

        //
        // Read only the header.
        //

        Length = PCI_COMMON_HDR_LENGTH;

    } else {

        Length = PAGE_SIZE;
    }

    fdoExtension->MapRegisterBase = 
        SpAllocatePool(NonPagedPool,
                       Length,
                       SCSIPORT_TAG_BUS_DATA,
                       fdoExtension->DeviceObject->DriverObject);

    ASSERT_FDO(fdoExtension->DeviceObject);
    if (fdoExtension->MapRegisterBase == NULL) {
        return 0;
    }

    //
    // Return the pointer to the miniport driver.
    //

    *((PVOID *)Buffer) = fdoExtension->MapRegisterBase;

    return SpGetBusData(fdoExtension,
                        lowerDevice,
                        BusDataType,
                        SystemIoBusNumber,
                        SlotNumber,
                        fdoExtension->MapRegisterBase,
                        Length);

}


ULONG
SpGetBusData(
    IN PADAPTER_EXTENSION Adapter,
    IN PDEVICE_OBJECT Pdo OPTIONAL,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine will retrieve bus data from the specified slot and bus number
    or from the supplied physical device object.  If bus and slot number are
    supplied it will tranlate into a call to HalGetBusData.

    If a PDO is supplied instead this will issue an IRP_MN_READ_CONFIG to the
    lower level driver.

    This routine allocates memory and waits for irp completion - it should not
    be called above passive level.

Arguments:

    Pdo - if this is non-NULL then it should be a pointer to the top of the
          device object stack for the PDO representing this adapter

    BusNumber - if PDO is NULL then this should be the bus number the adapter
                sits on - zero otherwise

    SlotNumber - if PDO is NULL then this is the number of the slot the
                 adapter is installed into - zero otherwise

    Buffer - location to store the returned data

    Length - size of above

Return Value:

    status

--*/

{

    //
    // if the user didn't specify a PDO to query then just throw this request
    // to the HAL
    //

    if(Pdo == NULL) {

#if defined(NO_LEGACY_DRIVERS)

        DebugPrint((1,"SpGetBusData: NULL PDO, not supported for 64-bits.\n"));
        return STATUS_INVALID_PARAMETER;

#else

        return HalGetBusData(BusDataType,
                             BusNumber,
                             SlotNumber,
                             Buffer,
                             Length);

#endif // NO_LEGACY_DRIVERS

    } else {

        //
        // ThePCI bus interface GetBusData routine only accepts read requests
        // from PCIConfiguration space.  We do not support anything else.
        //

        if (BusDataType != PCIConfiguration) {
            ASSERT(FALSE && "Invalid PCI_WHICHSPACE_ parameter");
            return 0;
        }

        ASSERT(Adapter->LowerBusInterfaceStandardRetrieved == TRUE);

        return Adapter->LowerBusInterfaceStandard.GetBusData(
                    Adapter->LowerBusInterfaceStandard.Context,
                    PCI_WHICHSPACE_CONFIG,
                    Buffer,
                    0L,
                    Length);
    }
}


NTSTATUS
SpInitializeSrbDataLookasideList(
    IN PDEVICE_OBJECT AdapterObject
    )
{
    KIRQL oldIrql;
    ULONG adapterTag;
    PDEVICE_OBJECT *newAdapterList;
    PDEVICE_OBJECT *oldAdapterList = NULL;

    NTSTATUS status = STATUS_SUCCESS;

#ifdef ALLOC_PRAGMA
    PVOID sectionHandle = MmLockPagableCodeSection(
                            SpInitializeSrbDataLookasideList);
    InterlockedIncrement(&SpPAGELOCKLockCount);
#endif

    //
    // Add our device object to the global adapter list.  This will require
    // increasing the size of the list.
    //

    KeAcquireSpinLock(&ScsiGlobalAdapterListSpinLock, &oldIrql);

    try {
        adapterTag = ScsiGlobalAdapterListElements;

        newAdapterList = SpAllocatePool(
                            NonPagedPool,
                            (sizeof(PDEVICE_OBJECT) * (adapterTag + 1)),
                            SCSIPORT_TAG_GLOBAL,
                            AdapterObject->DriverObject);

        if(newAdapterList == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        ScsiGlobalAdapterListElements += 1;

        if(ScsiGlobalAdapterList != NULL) {
            RtlCopyMemory(newAdapterList,
                          ScsiGlobalAdapterList,
                          (sizeof(PDEVICE_OBJECT) * adapterTag));

        }

        newAdapterList[adapterTag] = AdapterObject;

        oldAdapterList = ScsiGlobalAdapterList;
        ScsiGlobalAdapterList = newAdapterList;

        if(oldAdapterList != NULL) {
            ExFreePool(oldAdapterList);
        }

    } finally {
        KeReleaseSpinLock(&ScsiGlobalAdapterListSpinLock, oldIrql);
    }

#ifdef ALLOC_PRAGMA
    MmUnlockPagableImageSection(sectionHandle);
    InterlockedDecrement(&SpPAGELOCKLockCount);
#endif

    if(NT_SUCCESS(status)) {

        PADAPTER_EXTENSION adapterExtension = AdapterObject->DeviceExtension;

        //
        // Create the lookaside list for SRB_DATA blobs.  Make sure there's
        // enough space for a small scatter gather list allocated in the
        // structure as well.
        //

        ExInitializeNPagedLookasideList(
            &adapterExtension->SrbDataLookasideList,
            (PALLOCATE_FUNCTION) SpAllocateSrbDataBackend,
            (PFREE_FUNCTION) SpFreeSrbDataBackend,
            0L,
            sizeof(SRB_DATA),
            adapterTag,
            SRB_LIST_DEPTH);

        adapterExtension->SrbDataListInitialized = TRUE;
    }

    return status;
}

#define SP_KEY_VALUE_BUFFER_SIZE  255


NTSTATUS
SpAllocateDriverExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PSCSIPORT_DRIVER_EXTENSION *DriverExtension
    )

/*++

Routine Description:

    This routine will determine the proper size for the scsiport driver
    extension (based on the number of PnpInterface flags recorded in the
    services key)

--*/

{
    PSCSIPORT_DRIVER_EXTENSION driverExtension = NULL;

    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;

    HANDLE serviceKey = NULL;
    HANDLE parametersKey = NULL;
    HANDLE interfaceKey = NULL;

    STORAGE_BUS_TYPE busType;

    ULONG passes;

    NTSTATUS status;

    PAGED_CODE();

    *DriverExtension = NULL;

    DebugPrint((1, "SpAllocateDriverExtension: Allocating extension for "
                   "driver %wZ\n", &DriverObject->DriverName));

    try {

        //
        // Try to open the services key first
        //

        InitializeObjectAttributes(
            &objectAttributes,
            RegistryPath,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        status = ZwOpenKey(&serviceKey, KEY_READ, &objectAttributes);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1, "SpAllocateDriverExtension: Unable to open registry "
                           "key %wZ [%#08lx]\n",
                           RegistryPath,
                           status));
            leave;
        }


        //
        // Open the parameters key
        //

        RtlInitUnicodeString(&unicodeString, L"Parameters");

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   serviceKey,
                                   NULL);

        status = ZwOpenKey(&parametersKey, KEY_READ, &objectAttributes);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1, "SpAllocateDriverExtension: Unable to open "
                           "parameters key of %wZ [%#08lx]\n",
                           RegistryPath,
                           status));
            leave;

        }

        //
        // Try to determine the bus type for this driver.
        //

        RtlInitUnicodeString(&(unicodeString), L"BusType");

        {
            ULONG tmp;
            status = SpReadNumericValue(parametersKey,
                                        NULL,
                                        &unicodeString,
                                        &tmp);
            busType = (STORAGE_BUS_TYPE) tmp;
        }


        if(NT_SUCCESS(status)) {
            switch(busType) {
                case BusTypeScsi:
                case BusTypeAtapi:
                case BusTypeAta:
                case BusTypeSsa:
                case BusTypeFibre:
                case BusTypeRAID: {
                    DebugPrint((1, "SpAllocateDriverExtension: Bus type set to %d\n", busType));
                    break;
                }
                default: {
                    busType = BusTypeScsi;
                    break;
                }
            }
        } else {
            busType = BusTypeScsi;
        }


        //
        // got that one - now open the pnpinterface key.
        //

        RtlInitUnicodeString(&unicodeString, L"PnpInterface");

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   parametersKey,
                                   NULL);

        status = ZwOpenKey(&interfaceKey, KEY_READ, &objectAttributes);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1, "SpAllocateDriverExtension: Unable to open "
                           "PnpInterface key of %wZ [%#08lx]\n",
                           &RegistryPath,
                           status));
            leave;

        }

        //
        // Now that we have the pnpinterface key open we enumerate the entries in
        // two steps.  The first is to count up the number of entries.  We then
        // allocate an appropriately sized driver object extension, zero it out,
        // and copy the values into the PnpInterface section at the end.
        //

        for(passes = 0; passes < 2; passes++) {

            ULONG count;

            status = STATUS_SUCCESS;

            for(count = 0; TRUE; count++) {

                UCHAR buffer[SP_KEY_VALUE_BUFFER_SIZE];

                PKEY_VALUE_FULL_INFORMATION keyValue =
                    (PKEY_VALUE_FULL_INFORMATION) buffer;

                ULONG resultLength;

                ASSERTMSG("ScsiPort configuration error - possibly too many "
                          "count entries: ",
                          count != MaximumInterfaceType);

                RtlZeroMemory(buffer, sizeof(UCHAR) * SP_KEY_VALUE_BUFFER_SIZE);

                status = ZwEnumerateValueKey(
                            interfaceKey,
                            count,
                            (passes == 0) ? KeyValueBasicInformation :
                                            KeyValueFullInformation,
                            keyValue,
                            sizeof(buffer),
                            &resultLength);

                if(status == STATUS_NO_MORE_ENTRIES) {

                    status = STATUS_SUCCESS;
                    break;

                } else if(!NT_SUCCESS(status)) {

                    DebugPrint((1, "SpAllocateDriverExtension: Fatal error %#08lx "
                                   "enumerating PnpInterface key under %wZ.",
                                status,
                                RegistryPath));

                    leave;
                }

                if(passes == 1) {

                    PSCSIPORT_INTERFACE_TYPE_DATA interface =
                        &(driverExtension->PnpInterface[count]);
                    ULONG t;

                    ASSERTMSG("ScsiPort internal error - too many pnpinterface "
                              "entries on second pass: ",
                              count <= driverExtension->PnpInterfaceCount);

                    //
                    // First turn the name of the entry into a numerical value
                    // so we can match it to an interface type.
                    //

                    RtlInitUnicodeString(&unicodeString, keyValue->Name);

                    if((keyValue->Type != REG_DWORD) &&
                       (keyValue->Type != REG_NONE)) {

                        DbgPrint("SpAllocateDriverExtension: Fatal error parsing "
                                 "PnpInterface under %wZ - entry %wZ is not "
                                 "a REG_DWORD or REG_NONE entry (%d instead)\n",
                                 status,
                                 RegistryPath,
                                 &unicodeString);

                        status = STATUS_DEVICE_CONFIGURATION_ERROR;
                        leave;
                    }

                    status = RtlUnicodeStringToInteger(
                                &unicodeString,
                                0L,
                                &t);

                    if(!NT_SUCCESS(status)) {

                        DbgPrint("SpAllocateDriverExtension: Fatal error %#08lx "
                                 "parsing PnpInterface under %wZ - entry %wZ is "
                                 "not a valid interface type name\n",
                                 status,
                                 RegistryPath,
                                 &unicodeString);

                        leave;
                    }

                    if(t > MaximumInterfaceType) {

                        DbgPrint("SpAllocateDriverExtension: Fatal error "
                                 "parsing PnpInterface under %wZ - entry %wZ is "
                                 "> MaximumInterfaceType (%d)\n",
                                 status,
                                 RegistryPath,
                                 &unicodeString);

                        interface->InterfaceType = InterfaceTypeUndefined;
                        status = STATUS_DEVICE_CONFIGURATION_ERROR;
                        leave;
                    }

                    interface->InterfaceType = (INTERFACE_TYPE) t;

                    if(keyValue->Type == REG_NONE) {

                        interface->Flags = 0L;

                    } else {

                        interface->Flags = *(((PUCHAR) keyValue) +
                                             keyValue->DataOffset);

                        if(interface->Flags & SP_PNP_IS_SAFE) {
                            ASSERT(driverExtension != NULL);
                            driverExtension->SafeInterfaceCount++;
                        }

                        switch(interface->InterfaceType) {
                            case PCIBus: {
                                SET_FLAG(interface->Flags,
                                         SP_PNP_NEEDS_LOCATION);
                                SET_FLAG(interface->Flags,
                                         SP_PNP_INTERRUPT_REQUIRED);

                                CLEAR_FLAG(interface->Flags,
                                           SP_PNP_NON_ENUMERABLE);
                                break;
                            }

                            case Internal:
                            case PNPISABus:
                            case PNPBus:
                            case PCMCIABus: {

                                //
                                // These buses don't ever do detection.
                                //

                                CLEAR_FLAG(interface->Flags,
                                           SP_PNP_NON_ENUMERABLE);
                                break;
                            }

                            default: {

                                //
                                // The other bus types will always do detection
                                // if given the chance.
                                //

                                if(!TEST_FLAG(interface->Flags,
                                              SP_PNP_NO_LEGACY_DETECTION)) {
                                    SET_FLAG(interface->Flags,
                                             SP_PNP_NON_ENUMERABLE);
                                }

                                break;
                            }
                        }
                    }

                    DebugPrint((1, "SpAllocateDriverExtension: Interface %d has "
                                   "flags %#08lx\n",
                                interface->InterfaceType,
                                interface->Flags));

                }
            }

            if(passes == 0) {

                ULONG extensionSize;

                //
                // We know how much extra space we need so go ahead and allocate
                // the extension.
                //

                DebugPrint((2, "SpAllocateDriverExtension: Driver has %d interface "
                               "entries\n",
                            count));

                extensionSize = sizeof(SCSIPORT_DRIVER_EXTENSION) +
                                (sizeof(SCSIPORT_INTERFACE_TYPE_DATA) * count);

                DebugPrint((2, "SpAllocateDriverExtension: Driver extension will "
                               "be %d bytes\n",
                            extensionSize));

                status = IoAllocateDriverObjectExtension(DriverObject,
                                                         ScsiPortInitialize,
                                                         extensionSize,
                                                         &driverExtension);

                if(!NT_SUCCESS(status)) {
                    DebugPrint((1, "SpAllocateDriverExtension: Fatal error %#08lx "
                                   "allocating driver extension\n", status));
                    leave;
                }

                RtlZeroMemory(driverExtension, extensionSize);

                driverExtension->PnpInterfaceCount = count;
            }
        }

        ASSERTMSG("ScsiPortAllocateDriverExtension internal error: left first "
                  "section with non-success status: ",
                  NT_SUCCESS(status));

    } finally {

        //
        // If the driver extension has not been allocated then go ahead and
        // do that here.
        //

        if(driverExtension == NULL) {

            DebugPrint((1, "SpAllocateDriverExtension: Driver has 0 interface "
                           "entries\n"));

            DebugPrint((2, "SpAllocateDriverExtension: Driver extension will "
                           "be %d bytes\n",
                        sizeof(SCSIPORT_DRIVER_EXTENSION)));

            status = IoAllocateDriverObjectExtension(DriverObject,
                                                     ScsiPortInitialize,
                                                     sizeof(SCSIPORT_DRIVER_EXTENSION),
                                                     &driverExtension);

            if(!NT_SUCCESS(status)) {
                DebugPrint((1, "SpAllocateDriverExtension: Fatal error %#08lx "
                               "allocating driver extension\n", status));

                goto Finally_Cleanup;
            }

            RtlZeroMemory(driverExtension, sizeof(SCSIPORT_DRIVER_EXTENSION));

        } else {

            driverExtension->BusType = busType;

        }

        status = STATUS_SUCCESS;
Finally_Cleanup:;
    }

    if (status != STATUS_SUCCESS)
        goto Cleanup;

    //
    // initialize the remaining fields in the driver object extension.
    //

    driverExtension->ReserveAllocFailureLogEntry = SpAllocateErrorLogEntry(DriverObject);

    driverExtension->UnusedPage = NULL;

    driverExtension->UnusedPageMdl = NULL;

    driverExtension->InvalidPage = NULL;

    driverExtension->DriverObject = DriverObject;

    driverExtension->RegistryPath = *RegistryPath;

    driverExtension->RegistryPath.MaximumLength += sizeof(WCHAR);

    driverExtension->RegistryPath.Buffer =
        SpAllocatePool(PagedPool,
                       driverExtension->RegistryPath.MaximumLength,
                       SCSIPORT_TAG_REGISTRY,
                       DriverObject);

    if(driverExtension->RegistryPath.Buffer == NULL) {

        DebugPrint((1, "SpAllocateDriverExtension: Fatal error "
                       "allocating copy of registry path\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyUnicodeString(&(driverExtension->RegistryPath),
                         RegistryPath);

    //
    // Now get the values of the LegacyAdapterDetection flags.
    //

    //
    // Set it to a good default value in case we error out getting the flags
    //

    if(ScsiPortLegacyAdapterDetection) {

        //
        // Global flag breaks scissors
        //

        driverExtension->LegacyAdapterDetection = TRUE;

    } else {

        if(parametersKey != NULL) {

            UNICODE_STRING valueName;
            UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
            PKEY_VALUE_PARTIAL_INFORMATION keyValueInformation =
                (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
            ULONG length;

            RtlInitUnicodeString(&valueName, L"LegacyAdapterDetection");

            status = ZwQueryValueKey(parametersKey,
                                     &valueName,
                                     KeyValuePartialInformation,
                                     keyValueInformation,
                                     sizeof(buffer),
                                     &length);

            if(NT_SUCCESS(status) &&
               (length >= sizeof(KEY_VALUE_PARTIAL_INFORMATION)) &&
               (keyValueInformation->Type == REG_DWORD)) {

                ULONG data = *((PULONG) keyValueInformation->Data);

                driverExtension->LegacyAdapterDetection = (data == 1);

                //
                // Rewrite a zero in to the value.
                //

                data = 0;

                status = ZwSetValueKey(parametersKey,
                                       &valueName,
                                       keyValueInformation->TitleIndex,
                                       REG_DWORD,
                                       &data,
                                       sizeof(data));

                if(!NT_SUCCESS(status)) {
                    DebugPrint((1, "SpAllocateDriverExtension: Error %#08lx "
                                   "setting LegacyAdapterDetection value to "
                                   "zero\n", status));
                    status = STATUS_SUCCESS;
                }

            } else {
                driverExtension->LegacyAdapterDetection = FALSE;
            }
        }

        if(driverExtension->LegacyAdapterDetection == FALSE) {

            UNICODE_STRING unicodeKeyName;
            UNICODE_STRING unicodeClassGuid;

            HANDLE controlClassKey = NULL;
            HANDLE scsiAdapterKey = NULL;

            RtlInitUnicodeString(&unicodeClassGuid, NULL);

            //
            // Miniport doesn't want to do detection.  Check to see if the
            // global port driver flag has been switched on.
            //

            RtlInitUnicodeString(
                &unicodeString,
                L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class");

            RtlZeroMemory(&objectAttributes, sizeof(OBJECT_ATTRIBUTES));

            InitializeObjectAttributes(
                &objectAttributes,
                &unicodeString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            try {

                status = ZwOpenKey(&controlClassKey,
                                   KEY_READ,
                                   &objectAttributes);

                if(!NT_SUCCESS(status)) {

                    DebugPrint((1, "SpAllocateDriverExtension: Error %#08lx "
                                   "opening key %wZ\n",
                                status,
                                &unicodeString));

                    leave;
                }

                //
                // Now open up the GUID key for our device.
                //

                status = RtlStringFromGUID(&GUID_DEVCLASS_SCSIADAPTER,
                                           &unicodeClassGuid);

                if(!NT_SUCCESS(status)) {

                    DebugPrint((1, "SpAllocateDriverExtension: Error %#08lx "
                                   "converting GUID to unicode string\n",
                                status));
                    leave;
                }

                RtlZeroMemory(&objectAttributes, sizeof(OBJECT_ATTRIBUTES));
                InitializeObjectAttributes(&objectAttributes,
                                           &unicodeClassGuid,
                                           OBJ_CASE_INSENSITIVE,
                                           controlClassKey,
                                           NULL);

                status = ZwOpenKey(&scsiAdapterKey,
                                   KEY_READ,
                                   &objectAttributes);

                if(!NT_SUCCESS(status)) {

                    DebugPrint((1, "SpAllocateDriverExtension: Error %#08lx "
                                   "opening class key %wZ\n",
                                status,
                                &unicodeClassGuid));

                    leave;

                } else {

                    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                 sizeof(ULONG)];
                    PKEY_VALUE_PARTIAL_INFORMATION keyInfo =
                        (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
                    ULONG infoLength;

                    RtlInitUnicodeString(&unicodeString,
                                         L"LegacyAdapterDetection");

                    status = ZwQueryValueKey(scsiAdapterKey,
                                             &unicodeString,
                                             KeyValuePartialInformation,
                                             keyInfo,
                                             sizeof(buffer),
                                             &infoLength);

                    if(!NT_SUCCESS(status)) {

                        DebugPrint((2, "SpAllocateDriverExtension: Error "
                                       "%#08lx reading key %wZ\n",
                                    status,
                                    &unicodeString));

                        status = STATUS_SUCCESS;
                        leave;
                    }

                    if(*((PULONG) keyInfo->Data) == 0) {
                        driverExtension->LegacyAdapterDetection = FALSE;
                    } else {
                        driverExtension->LegacyAdapterDetection = TRUE;
                    }
                }

            } finally {

                if(controlClassKey != NULL) {
                    ZwClose(controlClassKey);
                }

                if(scsiAdapterKey != NULL) {
                    ZwClose(scsiAdapterKey);
                }

                RtlFreeUnicodeString(&unicodeClassGuid);

            }
        }

        status = STATUS_SUCCESS;
    }

Cleanup:

    //
    // If we got out of everything above and didn't allocate a driver
    // extension then

    if(serviceKey) {
        ZwClose(serviceKey);
    }

    if(parametersKey) {
        ZwClose(parametersKey);
    }

    if(interfaceKey) {
        ZwClose(interfaceKey);
    }

    if(NT_SUCCESS(status)) {
        *DriverExtension = driverExtension;
    }

    return status;
}

extern ULONG ScsiPortVerifierInitialized;

NTSTATUS DllInitialize(
    IN PUNICODE_STRING RegistryPath
    )
{
    HANDLE VerifierKey;
    UNICODE_STRING Name;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    ULONG ResultLength;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

    //
    // Check the verification level first; someone may have poked the value
    // from the debugger to prevent us from doing any verifier initialization.
    //

    if (SpVrfyLevel == SP_VRFY_NONE) {
        return STATUS_SUCCESS;
    }

    //
    // Read the global verification level from the registry.  If the value is
    // not present or if the value indicates 'no verification', we don't want
    // to do any verifier initialization at all.
    //

    RtlInitUnicodeString(&Name, SCSIPORT_CONTROL_KEY SCSIPORT_VERIFIER_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &Name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&VerifierKey, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&Name, L"VerifyLevel");
        Status = ZwQueryValueKey(VerifierKey,
                                 &Name,
                                 KeyValuePartialInformation,
                                 ValueInfo,
                                 sizeof(buffer),
                                 &ResultLength);

        if (NT_SUCCESS(Status)) {

            if (ValueInfo->Type == REG_DWORD) {

                if (ResultLength >= sizeof(ULONG)) {

                    SpVrfyLevel |= ((PULONG)(ValueInfo->Data))[0];

                    if (SpVrfyLevel != SP_VRFY_NONE &&
                        ScsiPortVerifierInitialized == 0) {

                        //
                        // Ok, we found a verifier level and it did not tell us
                        // not to verify.  Go ahead and initialize scsiport's
                        // verifier.
                        //

                        if (SpVerifierInitialization()) {
                            ScsiPortVerifierInitialized = 1;
                        }
                    }
                }
            }
        }

        ZwClose(VerifierKey);
    }

#if defined(NEWQUEUE)
    //
    // Read the global queue parameters.  These values override the default
    // settings for the number of requests we handle per zone and the number
    // of consecutive requests we handle to a particular sector.
    //

    RtlInitUnicodeString(&Name, SCSIPORT_CONTROL_KEY L"QueueParams");
    InitializeObjectAttributes(&ObjectAttributes,
                               &Name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&VerifierKey, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&Name, L"PerZoneLimit");
        Status = ZwQueryValueKey(VerifierKey,
                                 &Name,
                                 KeyValuePartialInformation,
                                 ValueInfo,
                                 sizeof(buffer),
                                 &ResultLength);

        if (NT_SUCCESS(Status)) {
            if (ValueInfo->Type == REG_DWORD) {
                if (ResultLength >= sizeof(ULONG)) {
                    SpPerZoneLimit = ((PULONG)(ValueInfo->Data))[0];
                }
            }
        }

        RtlInitUnicodeString(&Name, L"PerBlockLimit");
        Status = ZwQueryValueKey(VerifierKey,
                                 &Name,
                                 KeyValuePartialInformation,
                                 ValueInfo,
                                 sizeof(buffer),
                                 &ResultLength);

        if (NT_SUCCESS(Status)) {
            if (ValueInfo->Type == REG_DWORD) {
                if (ResultLength >= sizeof(ULONG)) {
                    SpPerBlockLimit = ((PULONG)(ValueInfo->Data))[0];
                }
            }
        }

        ZwClose(VerifierKey);
    }

    DebugPrint((1, "ScsiPort: SpPerZoneLimit:%x SpPerBlockLimit:%x\n", 
                SpPerZoneLimit, SpPerBlockLimit));
#endif // NEWQUEUE

    return STATUS_SUCCESS;
}
VOID
SpInitializePowerParams(
    IN PADAPTER_EXTENSION AdapterExtension
    )

/*++

Routine Description:

    This routine initializes per-adapter power parameters.

Arguments:

    Adapter - Points to an adapter extension.

Return Value:

Notes:

--*/

{
    NTSTATUS status;
    ULONG needsShutdown;

    PAGED_CODE();

    //
    // If this is not a pnp device, don't attempt to read registry info.
    //

    if (AdapterExtension->IsPnp == FALSE) {
        AdapterExtension->NeedsShutdown = FALSE;
        return;
    }

    status = SpReadNumericInstanceValue(AdapterExtension->LowerPdo,
                                        L"NeedsSystemShutdownNotification",
                                        &needsShutdown);

    if (!NT_SUCCESS(status)) {
        AdapterExtension->NeedsShutdown = 0;
    } else {
        AdapterExtension->NeedsShutdown = (needsShutdown == 0) ? FALSE : TRUE; 
    }
}

VOID
SpInitializePerformanceParams(
    IN PADAPTER_EXTENSION AdapterExtension
    )

/*++

Routine Description:

    This routine initializes per-adapter tunable performance parameters.

Arguments:

    Adapter - Points to an adapter extension.

Return Value:

Notes:

--*/

{
    NTSTATUS status;
    ULONG remainInReducedMaxQueueState;

    PAGED_CODE();

    //
    // If this isn't a pnp device, don't attempt to get parameters.
    //

    if (AdapterExtension->IsPnp == FALSE) {
        AdapterExtension->RemainInReducedMaxQueueState = 0xffffffff;
        return;
    }

    status = SpReadNumericInstanceValue(AdapterExtension->LowerPdo,
                                        L"RemainInReducedMaxQueueState",
                                        &remainInReducedMaxQueueState);

    if (!NT_SUCCESS(status)) {
        AdapterExtension->RemainInReducedMaxQueueState = 0xffffffff;
    } else {
        AdapterExtension->RemainInReducedMaxQueueState = remainInReducedMaxQueueState;
    }
}

VOID
SpInitializeRequestSenseParams(
    IN PADAPTER_EXTENSION AdapterExtension
    )

/*++

Routine Description:

    This routine returns the number of additonal sense bytes supported
    by the specified adapter.  By default, an adapter will support
    zero additional sense bytes.  The default is overridden by
    specifying an alternative via the registry.

Arguments:

    Adapter - Points to an adapter extension.

Return Value:

Notes:

--*/

{
    NTSTATUS status;
    ULONG TotalSenseDataBytes;

    PAGED_CODE();

    //
    // If this isn't a pnp device, don't attempt to determine
    // if it supports additional sense data.
    //

    if (AdapterExtension->IsPnp == FALSE) {
        AdapterExtension->AdditionalSenseBytes = 0;
        return;
    }

    status = SpReadNumericInstanceValue(AdapterExtension->LowerPdo,
                                        L"TotalSenseDataBytes",
                                        &TotalSenseDataBytes);
    if (!NT_SUCCESS(status)) {

        //
        // Value is absent.  No additional sense bytes.
        //

        AdapterExtension->AdditionalSenseBytes = 0;

    } else {

        //
        // The acceptable range of values is [18..255].
        //

        if (TotalSenseDataBytes <= SENSE_BUFFER_SIZE) {
            AdapterExtension->AdditionalSenseBytes = 0;
        } else if (TotalSenseDataBytes >= MAX_SENSE_BUFFER_SIZE) {
            AdapterExtension->AdditionalSenseBytes = MAX_ADDITIONAL_SENSE_BYTES;
        } else {

            //
            // The value in the registry is valid.  The number of additional
            // sense bytes is TotalSize - StandardSize.
            //

            AdapterExtension->AdditionalSenseBytes =
                (UCHAR)(TotalSenseDataBytes - SENSE_BUFFER_SIZE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\dispatch.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1998

Module Name:

    pnp.c

Abstract:

    This is the NT SCSI port driver.  This file contains the self-contained plug
    and play code.

Authors:

    Peter Wieland

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "port.h"

#if DBG
static const char *__file__ = __FILE__;
#endif

PDRIVER_DISPATCH AdapterMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];
PDRIVER_DISPATCH DeviceMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];
PDRIVER_DISPATCH Scsi1DeviceMajorFunctionTable[IRP_MJ_MAXIMUM_FUNCTION + 1];

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortInitializeDispatchTables)
#endif

NTSTATUS
ScsiPortDispatchUnimplemented(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
//
// Routines start
//


VOID
ScsiPortInitializeDispatchTables(
    VOID
    )

{
    ULONG i;

    //
    // Initialize the PDO dispatch table
    //

    for(i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DeviceMajorFunctionTable[i] = ScsiPortDispatchUnimplemented;
    }

    DeviceMajorFunctionTable[IRP_MJ_DEVICE_CONTROL] = ScsiPortPdoDeviceControl;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_DEVICE_CONTROL] = ScsiPortPdoDeviceControl;
    
    DeviceMajorFunctionTable[IRP_MJ_SCSI] = ScsiPortPdoScsi;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_SCSI] = ScsiPortScsi1PdoScsi;
    
    DeviceMajorFunctionTable[IRP_MJ_PNP] = ScsiPortPdoPnp;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_PNP] = ScsiPortPdoPnp;
    
    DeviceMajorFunctionTable[IRP_MJ_CREATE] = ScsiPortPdoCreateClose;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_CREATE] = ScsiPortPdoCreateClose;
    
    DeviceMajorFunctionTable[IRP_MJ_CLOSE] = ScsiPortPdoCreateClose;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_CLOSE] = ScsiPortPdoCreateClose;
    
    DeviceMajorFunctionTable[IRP_MJ_SYSTEM_CONTROL] = ScsiPortSystemControlIrp;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_SYSTEM_CONTROL] = ScsiPortSystemControlIrp;
    
    DeviceMajorFunctionTable[IRP_MJ_POWER] = ScsiPortDispatchPower;
    Scsi1DeviceMajorFunctionTable[IRP_MJ_POWER] = ScsiPortDispatchPower;

    //
    // Initialize the adapter dispatch table
    //

    for(i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        AdapterMajorFunctionTable[i] = ScsiPortDispatchUnimplemented;
    }

    AdapterMajorFunctionTable[IRP_MJ_DEVICE_CONTROL] = ScsiPortFdoDeviceControl;
    AdapterMajorFunctionTable[IRP_MJ_SCSI] = ScsiPortFdoDispatch;
    AdapterMajorFunctionTable[IRP_MJ_PNP] = ScsiPortFdoPnp;
    AdapterMajorFunctionTable[IRP_MJ_CREATE] = ScsiPortFdoCreateClose;
    AdapterMajorFunctionTable[IRP_MJ_CLOSE] = ScsiPortFdoCreateClose;
    AdapterMajorFunctionTable[IRP_MJ_SYSTEM_CONTROL] = ScsiPortSystemControlIrp;
    AdapterMajorFunctionTable[IRP_MJ_POWER] = ScsiPortDispatchPower;

    return;
}


NTSTATUS
ScsiPortGlobalDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    return (commonExtension->MajorFunction[irpStack->MajorFunction])(DeviceObject, Irp);

}

NTSTATUS
ScsiPortDispatchUnimplemented(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PCOMMON_EXTENSION commonExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG isRemoved;

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);
    if(isRemoved) {
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        SpReleaseRemoveLock(DeviceObject, Irp);
        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    commonExtension = DeviceObject->DeviceExtension;

    DebugPrint((1, "ScsiPortDispatchUnimplemented: request %#p\n", Irp));
    DebugPrint((1, "/t/tFunction Code (%d, %d)\n",
                   irpStack->MajorFunction,
                   irpStack->MinorFunction));
    DebugPrint((1, "/t/tFor %s %#p\n",
                   (commonExtension->IsPdo ? "PDO" : "FDO"),
                   DeviceObject));

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

    return STATUS_INVALID_DEVICE_REQUEST;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\pdo.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    pdo.c

Abstract:

    This module contains the dispatch routines for scsiport's physical device
    objects

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#define KEEP_COMPLETE_REQUEST

#include "port.h"

#define __FILE_ID__ 'pdo '

#if DBG
static const char *__file__ = __FILE__;
#endif

LONG SpPowerIdleTimeout = -1;      // use system default

NTSTATUS
SpPdoHandleIoctlStorageQueryProperty(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    );

NTSTATUS
SpPdoHandleIoctlScsiGetAddress(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    );

NTSTATUS
SpPdoHandleIoctlScsiPassthrough(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    );

NTSTATUS
SpPdoHandleIoctlScsiPassthroughDirect(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    );

NTSTATUS
SpPagingPathNotificationCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP LowerIrp,
    IN PDEVICE_OBJECT Fdo
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortPdoPnp)
#pragma alloc_text(PAGE, ScsiPortPdoCreateClose)
#pragma alloc_text(PAGE, ScsiPortStartLogicalUnit)
#pragma alloc_text(PAGE, ScsiPortInitPdoWmi)
#pragma alloc_text(PAGE, SpPdoHandleIoctlStorageQueryProperty)
#pragma alloc_text(PAGE, SpPdoHandleIoctlScsiGetAddress)
#pragma alloc_text(PAGE, SpPdoHandleIoctlScsiPassthrough)
#pragma alloc_text(PAGE, SpPdoHandleIoctlScsiPassthroughDirect)
#endif

NTSTATUS
SpPdoHandleIoctlStorageQueryProperty(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_STORAGE_QUERY_PROPERTY request for a PDO.
    It validates the input buffer and passes calls a helper routine to do the
    work.  The helper routine handles completing or forwarding the request and
    releasing the remove lock.

Arguments:

    Pdo - Supplies a pointer to the physical device object

    Irp - Supplies a pointer to the io request packet

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(STORAGE_PROPERTY_QUERY)) {

        //
        // The input buffer is not big enough to hold a STORAGE_PROPERTY_QUERY
        // structure.  Fail the request.
        //

        status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Status = status;
        SpReleaseRemoveLock(Pdo, Irp);
        SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);
    } else {

        //
        // Call helper routine to do the bulk of the work.  The helper completes
        // or forwards the request down the stack and releases the remove lock.
        // 

        status = ScsiPortQueryPropertyPdo(Pdo, Irp);
    }

    return status;
}

NTSTATUS
SpPdoHandleIoctlScsiGetAddress(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_SCSI_GET_ADDRESS.  It validates the input 
    that the output buffer is big enough to hold a SCSI_ADDRESS structure.  If
    the buffer is big enough, it copies the address information into the buffer.

Arguments:

    Pdo - Supplies a pointer to the physical device object

    Irp - Supplies a pointer to the io request packet

Return Value:

    STATUS_SUCCESS if the supplied buffer is big enough to hold the address.

    STATUS_BUFFER_TOO_SMALL if the supplied buffer is too small.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PLOGICAL_UNIT_EXTENSION luExtension = Pdo->DeviceExtension;
    PSCSI_ADDRESS scsiAddress = Irp->AssociatedIrp.SystemBuffer;

    PAGED_CODE();
    
    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(SCSI_ADDRESS)) {

        //
        // The output buffer is too small to hold a SCSI_ADDRESS structure,
        // so we fail the request.
        //
        
        status = STATUS_BUFFER_TOO_SMALL;
    } else {

        //
        // Fill in the address information and set the IoStatus.Information
        // to the sizeof the SCSI_ADDRESS structure.
        //

        scsiAddress->Length = sizeof(SCSI_ADDRESS);
        scsiAddress->PortNumber = (UCHAR) luExtension->PortNumber;
        scsiAddress->PathId = luExtension->PathId;
        scsiAddress->TargetId = luExtension->TargetId;
        scsiAddress->Lun = luExtension->Lun;

        status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(SCSI_ADDRESS);
    }

    //
    // Complete the request and release the remove lock.
    //

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(Pdo, Irp);
    SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
SpPdoHandleIoctlScsiPassthrough(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles IOCTL_SCSI_PASS_THROUGH.  It checks that the input 
    buffer is big enough to hold a SCSI_PASS_THROUGH structure, fills in the
    address information for this LU and passes the request down to the FDO
    handler to do the real work.

Arguments:

    Pdo - Supplies a pointer to the physical device object

    Irp - Supplies a pointer to the io request packet

Return Value:

    NTSTATUS

--*/
{
    PLOGICAL_UNIT_EXTENSION luExtension = Pdo->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the address of the SCSI_PASS_THROUGH structure embedded
    // in the supplied IRP.  This routine verifies that the size of the
    // SystemBuffer is big enough to hold a SCSI_PASS_THROUGH structure
    // before it touches it.
    //

    status = PortSetPassThroughAddress(
                 Irp,
                 luExtension->PathId,
                 luExtension->TargetId,
                 luExtension->Lun
                 );

    if (status != STATUS_SUCCESS) {

        Irp->IoStatus.Status = status;
        SpReleaseRemoveLock(Pdo, Irp);
        SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);

    } else {

        //
        // Forward the request down to the FDO handler.
        //

        PCOMMON_EXTENSION commonExtension = Pdo->DeviceExtension;

        IoSkipCurrentIrpStackLocation(Irp);
        SpReleaseRemoveLock(Pdo, Irp);
        status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
    }

    return status;
}

NTSTATUS
SpPdoHandleIoctlScsiPassthroughDirect(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles IOCTL_SCSI_PASS_THROUGH_DIRECT.  It simply delegates
    to the handler for IOCTL_SCSI_PASS_THROUGH since they both do exactly the
    same thing.

Arguments:

    Pdo - Supplies a pointer to the physical device object

    Irp - Supplies a pointer to the io request packet

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    return SpPdoHandleIoctlScsiPassthrough(Pdo, Irp);
}


NTSTATUS
ScsiPortPdoDeviceControl(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles device control requests for scsi target devices

Arguments:

    Pdo - a pointer to the physical device object

    Irp - a pointer to the io request packet

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    PCOMMON_EXTENSION commonExtension = Pdo->DeviceExtension;
    NTSTATUS status;
    ULONG isRemoved;

    //
    // If the device has been removed or is in the process of being removed,
    // we must fail this request.
    //

    isRemoved = SpAcquireRemoveLock(Pdo, Irp);
    if (isRemoved) {
        SpReleaseRemoveLock(Pdo, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    ASSERT(commonExtension->IsPdo);

    //
    // Initialize the status.
    //

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    switch (ioControlCode) {

        case IOCTL_STORAGE_QUERY_PROPERTY: 
            status = SpPdoHandleIoctlStorageQueryProperty(Pdo, Irp);
            break;

        case IOCTL_SCSI_GET_ADDRESS: 
            status = SpPdoHandleIoctlScsiGetAddress(Pdo, Irp);
            break;

        case IOCTL_SCSI_PASS_THROUGH:
            status = SpPdoHandleIoctlScsiPassthrough(Pdo, Irp);
            break;

        case IOCTL_SCSI_PASS_THROUGH_DIRECT: 
            status = SpPdoHandleIoctlScsiPassthroughDirect(Pdo, Irp);
            break;

        case IOCTL_SCSI_GET_DUMP_POINTERS:
            IoSkipCurrentIrpStackLocation(Irp);
            SpReleaseRemoveLock(Pdo, Irp);
            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
            break;

        default: {

            DebugPrint((1, "ScsiPortPdoDeviceControl: unsupported IOCTL %08x\n",
                        ioControlCode));

            SpReleaseRemoveLock(Pdo, Irp);
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);
            break;
        }
    }

    return status;
}

NTSTATUS
ScsiPortPdoPnp(
    IN PDEVICE_OBJECT LogicalUnit,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles pnp-power requests.  Currently it will just be
    successful

Arguments:

    LogicalUnit - pointer to the physical device object
    Irp - pointer to the io request packet

Return Value:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnitExtension = LogicalUnit->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = LogicalUnit->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    static ULONG i = 0;

    NTSTATUS status = STATUS_SUCCESS;

    ULONG isRemoved;

    PAGED_CODE();

    isRemoved = SpAcquireRemoveLock(LogicalUnit, Irp);

#if 0
    if(isRemoved != ) {

        ASSERT(isRemoved != REMOVE_PENDING);

        status = STATUS_DEVICE_DOES_NOT_EXIST;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
#else
    ASSERT(isRemoved != REMOVE_COMPLETE);
#endif

    switch(irpStack->MinorFunction) {

        case IRP_MN_QUERY_PNP_DEVICE_STATE: {

            //
            // If the device is in the paging path then mark it as
            // not-disableable.
            //

            PPNP_DEVICE_STATE deviceState =
                (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);

            DebugPrint((1, "ScsiPortPdoPnp: QUERY_DEVICE_STATE for PDO %#x\n", LogicalUnit));

            if(commonExtension->PagingPathCount != 0) {
                SET_FLAG((*deviceState), PNP_DEVICE_NOT_DISABLEABLE);
                DebugPrint((1, "ScsiPortPdoPnp: QUERY_DEVICE_STATE: %#x - not disableable\n",
                            LogicalUnit));
            }

            Irp->IoStatus.Status = STATUS_SUCCESS;
            SpReleaseRemoveLock(LogicalUnit, Irp);
            SpCompleteRequest(LogicalUnit, Irp, NULL, IO_NO_INCREMENT);
            return STATUS_SUCCESS;
        }

        case IRP_MN_START_DEVICE: {

            if(commonExtension->CurrentPnpState == IRP_MN_START_DEVICE) {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;
            }

            if(commonExtension->IsInitialized == FALSE) {
                status = ScsiPortInitLogicalUnit(logicalUnitExtension);
            }

            if(NT_SUCCESS(status)) {
                commonExtension->IsInitialized = TRUE;
                status = ScsiPortStartLogicalUnit(logicalUnitExtension);
            }

            if(NT_SUCCESS(status)) {
                commonExtension->CurrentPnpState = IRP_MN_START_DEVICE;
                commonExtension->PreviousPnpState = 0xff;
            }

            Irp->IoStatus.Status = status;

            break;
        }

        case IRP_MN_QUERY_ID: {

            UCHAR rawIdString[64] = "UNKNOWN ID TYPE";
            ANSI_STRING ansiIdString;
            UNICODE_STRING unicodeIdString;
            BOOLEAN multiStrings;

            PINQUIRYDATA inquiryData = &(logicalUnitExtension->InquiryData);

            //
            // We've been asked for the id of one of the physical device objects
            //

            DebugPrint((2, "ScsiPortPnp: got IRP_MN_QUERY_ID\n"));

            RtlInitUnicodeString(&unicodeIdString, NULL);
            RtlInitAnsiString(&ansiIdString, NULL);

            switch(irpStack->Parameters.QueryId.IdType) {

                case BusQueryDeviceID: {

                    status = ScsiPortGetDeviceId(LogicalUnit, &unicodeIdString);
                    multiStrings = FALSE;

                    break;
                }

                case BusQueryInstanceID: {

                    status = ScsiPortGetInstanceId(LogicalUnit, &unicodeIdString);
                    multiStrings = FALSE;

                    break;
                }

                case BusQueryHardwareIDs: {

                    status = ScsiPortGetHardwareIds(
                                LogicalUnit->DriverObject,
                                &(logicalUnitExtension->InquiryData),
                                &unicodeIdString);
                    multiStrings = TRUE;
                    break;
                }

                case BusQueryCompatibleIDs: {

                    status = ScsiPortGetCompatibleIds(
                                LogicalUnit->DriverObject,
                                &(logicalUnitExtension->InquiryData),
                                &unicodeIdString);
                    multiStrings = TRUE;

                    break;
                }

                default: {

                    status = Irp->IoStatus.Status;
                    Irp->IoStatus.Information = 0;
                    multiStrings = FALSE;

                    break;

                }
            }

            Irp->IoStatus.Status = status;

            if(NT_SUCCESS(status)) {

                PWCHAR idString;

                //
                // fix up all invalid characters
                //
                idString = unicodeIdString.Buffer;
                while (*idString) {

                    if ((*idString <= L' ')  ||
                        (*idString > (WCHAR)0x7F) ||
                        (*idString == L',')) {
                        *idString = L'_';
                    }
                    idString++;

                    if ((*idString == L'\0') && multiStrings) {
                        idString++;
                    }
                }

                Irp->IoStatus.Information = (ULONG_PTR) unicodeIdString.Buffer;
            } else {
                Irp->IoStatus.Information = (ULONG_PTR) NULL;
            }

            SpReleaseRemoveLock(LogicalUnit, Irp);
            SpCompleteRequest(LogicalUnit, Irp, NULL, IO_NO_INCREMENT);

            return status;
            break;
        }

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: {

            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR) NULL;
            SpReleaseRemoveLock(LogicalUnit, Irp);
            SpCompleteRequest(LogicalUnit, Irp, NULL, IO_NO_INCREMENT);
            return STATUS_SUCCESS;
        }

        case IRP_MN_SURPRISE_REMOVAL:
        case IRP_MN_REMOVE_DEVICE: {

            BOOLEAN destroyed;

            //
            // Release the lock for this IRP before going in.
            //

            if(commonExtension->IsRemoved == NO_REMOVE) {
                commonExtension->IsRemoved = REMOVE_PENDING;
            }

            SpReleaseRemoveLock(LogicalUnit, Irp);

            destroyed = SpRemoveLogicalUnit(logicalUnitExtension,
                                            irpStack->MinorFunction);

            if(destroyed) {
                commonExtension->PreviousPnpState =
                    commonExtension->CurrentPnpState;
                commonExtension->CurrentPnpState = irpStack->MinorFunction;
            } else {
                commonExtension->CurrentPnpState = 0xff;
                commonExtension->PreviousPnpState = irpStack->MinorFunction;
            }

            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }

        case IRP_MN_QUERY_DEVICE_TEXT: {

            Irp->IoStatus.Status =
                SpQueryDeviceText(
                    LogicalUnit,
                    irpStack->Parameters.QueryDeviceText.DeviceTextType,
                    irpStack->Parameters.QueryDeviceText.LocaleId,
                    (PWSTR *) &Irp->IoStatus.Information
                    );

            break;
        }

        case IRP_MN_QUERY_CAPABILITIES: {

            PDEVICE_CAPABILITIES capabilities =
                irpStack->Parameters.DeviceCapabilities.Capabilities;

            PSCSIPORT_DEVICE_TYPE deviceType = NULL;

            capabilities->RawDeviceOK = 1;

            deviceType = SpGetDeviceTypeInfo(
                            logicalUnitExtension->InquiryData.DeviceType
                            );

            if((deviceType != NULL) && (deviceType->IsStorage)) {
                capabilities->SilentInstall = 1;
            }

            capabilities->Address = logicalUnitExtension->TargetId;

            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE: {

            if ((commonExtension->PagingPathCount != 0) ||
                (logicalUnitExtension->IsLegacyClaim == TRUE)) {
                Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
            } else {
                Irp->IoStatus.Status = STATUS_SUCCESS;

                commonExtension->PreviousPnpState =
                    commonExtension->CurrentPnpState;
                commonExtension->CurrentPnpState = irpStack->MinorFunction;
            }
            break;
        }

        case IRP_MN_CANCEL_STOP_DEVICE: {

            if(commonExtension->CurrentPnpState == IRP_MN_QUERY_STOP_DEVICE) {
                commonExtension->CurrentPnpState =
                    commonExtension->PreviousPnpState;
                commonExtension->PreviousPnpState = 0xff;
            }

            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_CANCEL_REMOVE_DEVICE: {

            if(commonExtension->CurrentPnpState == IRP_MN_QUERY_REMOVE_DEVICE) {
                commonExtension->CurrentPnpState =
                    commonExtension->PreviousPnpState;
                commonExtension->PreviousPnpState = 0xff;
            }

            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_STOP_DEVICE: {

            ASSERT(commonExtension->CurrentPnpState == IRP_MN_QUERY_STOP_DEVICE);

            status = ScsiPortStopLogicalUnit(logicalUnitExtension);

            ASSERT(NT_SUCCESS(status));

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = (ULONG_PTR) NULL;

            if(NT_SUCCESS(status)) {
                commonExtension->CurrentPnpState = IRP_MN_STOP_DEVICE;
                commonExtension->PreviousPnpState = 0xff;
            }

            SpReleaseRemoveLock(LogicalUnit, Irp);
            SpCompleteRequest(LogicalUnit, Irp, NULL, IO_NO_INCREMENT);

            return status;
        }

        case IRP_MN_QUERY_DEVICE_RELATIONS: {

            PDEVICE_RELATIONS deviceRelations;

            if(irpStack->Parameters.QueryDeviceRelations.Type !=
               TargetDeviceRelation) {

                break;
            }

            //
            // DEVICE_RELATIONS definition contains one object pointer.
            //

            deviceRelations = SpAllocatePool(PagedPool,
                                             sizeof(DEVICE_RELATIONS),
                                             SCSIPORT_TAG_DEVICE_RELATIONS,
                                             LogicalUnit->DriverObject);

            if(deviceRelations == NULL) {

                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlZeroMemory(deviceRelations, sizeof(DEVICE_RELATIONS));

            deviceRelations->Count = 1;
            deviceRelations->Objects[0] = LogicalUnit;

            ObReferenceObject(deviceRelations->Objects[0]);

            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

            break;
        }

        case IRP_MN_DEVICE_USAGE_NOTIFICATION: {

            PIRP newIrp;
            PIO_STACK_LOCATION nextStack;

            DebugPrint((1, "Pdo - IRP_MN_DEVICE_USAGE_NOTIFICATION %#p received for "
                           "logical unit %#p\n",
                        Irp,
                        LogicalUnit));

            newIrp = SpAllocateIrp(
                        commonExtension->LowerDeviceObject->StackSize,
                        FALSE,
                        LogicalUnit->DriverObject);

            if(newIrp == NULL) {

                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            newIrp->AssociatedIrp.MasterIrp = Irp;

            newIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

            nextStack = IoGetNextIrpStackLocation(newIrp);
            *nextStack = *IoGetCurrentIrpStackLocation(Irp);

            IoSetCompletionRoutine(newIrp,
                                   SpPagingPathNotificationCompletion,
                                   commonExtension->LowerDeviceObject,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            status = IoCallDriver(commonExtension->LowerDeviceObject,
                                  newIrp);
            return status;
            break;
        }
    }

    SpReleaseRemoveLock(LogicalUnit, Irp);

    status = Irp->IoStatus.Status;
    SpCompleteRequest(LogicalUnit, Irp, NULL, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
SpPagingPathNotificationCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP LowerIrp,
    IN PDEVICE_OBJECT Fdo
    )
{
    PIRP upperIrp = LowerIrp->AssociatedIrp.MasterIrp;

    PIO_STACK_LOCATION lowerStack = IoGetCurrentIrpStackLocation(LowerIrp);
    PIO_STACK_LOCATION upperStack = IoGetCurrentIrpStackLocation(upperIrp);

    PDEVICE_OBJECT pdo = upperStack->DeviceObject;

    PADAPTER_EXTENSION lowerExtension;
    PLOGICAL_UNIT_EXTENSION upperExtension;

    ASSERT(Fdo != NULL);
    ASSERT(pdo != NULL);

    DebugPrint((1, "Completion - IRP_MN_DEVICE_USAGE_NOTIFICATION: Completion of "
                   "paging notification irp %#p sent due to irp %#p\n",
                LowerIrp, upperIrp));

    lowerExtension = (PADAPTER_EXTENSION) Fdo->DeviceExtension;
    upperExtension = (PLOGICAL_UNIT_EXTENSION) pdo->DeviceExtension;

    ASSERT_FDO(lowerExtension->DeviceObject);
    ASSERT_PDO(upperExtension->DeviceObject);

    DebugPrint((1, "Completion - IRP_MN_DEVICE_USAGE_NOTIFICATION: irp status %#08lx\n",
                LowerIrp->IoStatus.Status));

    if(NT_SUCCESS(LowerIrp->IoStatus.Status)) {

        PUCHAR typeName = "INSERT TYPE HERE";
        PULONG lowerCount;
        PULONG upperCount;

        //
        // The parameters have already been erased from the lower irp stack
        // location - use the parameters from the upper once since they're
        // just a copy.
        //

        switch(upperStack->Parameters.UsageNotification.Type) {

            case DeviceUsageTypePaging: {

                lowerCount = &(lowerExtension->CommonExtension.PagingPathCount);
                upperCount = &(upperExtension->CommonExtension.PagingPathCount);
                typeName = "PagingPathCount";
                break;
            }

            case DeviceUsageTypeHibernation: {

                lowerCount = &(lowerExtension->CommonExtension.HibernatePathCount);
                upperCount = &(upperExtension->CommonExtension.HibernatePathCount);
                typeName = "HibernatePathCount";
                break;
            }

            case DeviceUsageTypeDumpFile: {

                lowerCount = &(lowerExtension->CommonExtension.DumpPathCount);
                upperCount = &(upperExtension->CommonExtension.DumpPathCount);
                typeName = "DumpPathCount";
                break;
            }

            default: {

                typeName = "unknown type";
                lowerCount = upperCount = NULL;
                break;
            }
        }

        if(lowerCount != NULL) {
            IoAdjustPagingPathCount(
                lowerCount,
                upperStack->Parameters.UsageNotification.InPath
                );
            DebugPrint((1, "Completion - IRP_MN_DEVICE_USAGE_NOTIFICATION: "
                           "Fdo %s count - %d\n",
                        typeName, *lowerCount));
            IoInvalidateDeviceState(lowerExtension->LowerPdo);
        }

        if(upperCount != NULL) {
            IoAdjustPagingPathCount(
                upperCount,
                upperStack->Parameters.UsageNotification.InPath
                );
            DebugPrint((1, "Completion - IRP_MN_DEVICE_USAGE_NOTIFICATION: "
                           "Pdo %s count - %d\n",
                        typeName, *upperCount));
            IoInvalidateDeviceState(upperExtension->DeviceObject);
        }
    }

    upperIrp->IoStatus = LowerIrp->IoStatus;

    SpReleaseRemoveLock(upperExtension->CommonExtension.DeviceObject, upperIrp);

    SpCompleteRequest(upperExtension->CommonExtension.DeviceObject,
                      upperIrp,
                      NULL,
                      IO_NO_INCREMENT);

    IoFreeIrp(LowerIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ScsiPortPdoCreateClose(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles creates and closes for bus device pdo's

Arguments:

    Pdo - a pointer to the physical device object
    Irp - a pointer to the io request packet

Return Value:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = Pdo->DeviceExtension;

    ULONG isRemoved;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT_PDO(Pdo);

    isRemoved = SpAcquireRemoveLock(Pdo, Irp);

    if(IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_CREATE) {

        if(isRemoved) {
            status = STATUS_DEVICE_DOES_NOT_EXIST;
        } else if(logicalUnit->IsTemporary == TRUE) {
            status = STATUS_DEVICE_NOT_READY;
        }
    }

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(Pdo, Irp);
    SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
ScsiPortScsi1PdoScsi(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is a wrapper around ScsiPortPdoScsi.  It inserts the LUN number
    into the CDB before calling the generic version.  this is for use with 
    older target controllers which don't pay attention to the identify message
    sent before the command phase.

Arguments:

    Pdo - a pointer to the physical device object
    Irp - a pointer to the io request packet

Return Value:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION lun = Pdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    //
    // NOTICE:  The SCSI-II specification indicates that this field should be
    // zero; however, some target controllers ignore the logical unit number
    // in the INDENTIFY message and only look at the logical unit number field
    // in the CDB.
    //

    srb->Cdb[1] |= lun->Lun << 5;

    return ScsiPortPdoScsi(Pdo, Irp);
}

NTSTATUS
ScsiPortPdoScsi(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches SRB's for a particular target device.  It will fill
    in the Port, Path, Target and Lun values and then forward the request
    through to the FDO for the bus

Arguments:

    Pdo - a pointer to the physical device object
    Irp - a pointer to the io request packet

Return Value:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION lun = Pdo->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

#if DBG
    PDRIVER_OBJECT lowerDriverObject =
                        lun->CommonExtension.LowerDeviceObject->DriverObject;
#endif

    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    ULONG isRemoved;

    PSRB_DATA srbData;
    BOOLEAN isLock = FALSE;

    NTSTATUS status;

    isRemoved = SpAcquireRemoveLock(Pdo, Irp);

    if(isRemoved &&
       !IS_CLEANUP_REQUEST(irpStack) &&
       (srb->Function != SRB_FUNCTION_CLAIM_DEVICE)) {

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

        SpReleaseRemoveLock(Pdo, Irp);
        SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    srb->PathId = lun->PathId;
    srb->TargetId = lun->TargetId;
    srb->Lun = lun->Lun;

    //
    // Queue tags should be assigned only by the StartIo routine.  Set it to
    // a benign value here so we can tell later on that we don't have to
    // clear the tag value in the bitmap.
    //

    srb->QueueTag = SP_UNTAGGED;

#if DBG
    ASSERT(lowerDriverObject->MajorFunction[IRP_MJ_SCSI] != NULL);
    ASSERT(lowerDriverObject->MajorFunction[IRP_MJ_SCSI] == ScsiPortGlobalDispatch);
#endif

    switch(srb->Function) {


        case SRB_FUNCTION_ABORT_COMMAND: {

            status = STATUS_NOT_SUPPORTED;
            break;

        }

        case SRB_FUNCTION_CLAIM_DEVICE:
        case SRB_FUNCTION_RELEASE_DEVICE:
        case SRB_FUNCTION_REMOVE_DEVICE: {

            status = SpClaimLogicalUnit(
                        lun->CommonExtension.LowerDeviceObject->DeviceExtension,
                        lun,
                        Irp,
                        FALSE);
            break;
        }

        case SRB_FUNCTION_UNLOCK_QUEUE:
        case SRB_FUNCTION_LOCK_QUEUE: {

            SpStartLockRequest(lun, Irp);

            return STATUS_PENDING;
        }

        case SRB_FUNCTION_RELEASE_QUEUE:
        case SRB_FUNCTION_FLUSH_QUEUE: {

            srbData = SpAllocateBypassSrbData(lun);
            ASSERT(srbData != NULL);

            goto RunSrb;
        }

        default: {

            if(TEST_FLAG(srb->SrbFlags, (SRB_FLAGS_BYPASS_LOCKED_QUEUE |
                                         SRB_FLAGS_BYPASS_FROZEN_QUEUE))) {

                srbData = SpAllocateBypassSrbData(lun);
                ASSERT(srbData != NULL);
            } else {
                srbData = SpAllocateSrbData( lun->AdapterExtension, Irp, lun);

                if(srbData == NULL) {

                    //
                    // There wasn't an SRB_DATA block available for this
                    // request so it's been queued waiting for resources -
                    // leave the logical unit remove-locked and return pending.
                    //

                    DebugPrint((1, "ScsiPortPdoScsi: Insufficient resources "
                                   "to allocate SRB_DATA structure\n"));
                    return STATUS_PENDING;
                }
            }
RunSrb:
            srbData->CurrentIrp = Irp;
            srbData->CurrentSrb = srb;
            srbData->LogicalUnit = lun;

            srb->OriginalRequest = srbData;
            return SpDispatchRequest(lun, Irp);
        }
    }

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(Pdo, Irp);
    SpCompleteRequest(Pdo, Irp, NULL, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
ScsiPortStartLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

    This routine will attempt to start the specified device object.

    Currently this involves clearing the INITIALIZING flag if it was set,
    and running through to the device node and marking itself as started.  This
    last is a kludge

Arguments:

    LogicalUnit - a pointer to the PDO being started

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapterExtension = LogicalUnit->AdapterExtension;

    HANDLE instanceHandle;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Open the devnode for this PDO and see if anyone's given us some
    // default SRB flags.
    //

    status = IoOpenDeviceRegistryKey(LogicalUnit->DeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ,
                                     &instanceHandle);

    if(NT_SUCCESS(status)) {

        RTL_QUERY_REGISTRY_TABLE queryTable[2];
        ULONG zero = 0;

        RtlZeroMemory(queryTable, sizeof(queryTable));

        queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[0].Name = L"DefaultRequestFlags";
        queryTable[0].EntryContext = &(LogicalUnit->CommonExtension.SrbFlags);
        queryTable[0].DefaultType = REG_DWORD;
        queryTable[0].DefaultData = &zero;
        queryTable[0].DefaultLength = sizeof(ULONG);

        status = RtlQueryRegistryValues(
                    RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                    (PWSTR) instanceHandle,
                    queryTable,
                    NULL,
                    NULL);

        //
        // CODEWORK: need a way to turn off tagged queuing and caching.  Ie.
        // keep track of negative flags as well.
        //

        LogicalUnit->CommonExtension.SrbFlags &=
            ( SRB_FLAGS_DISABLE_DISCONNECT |
              SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
              SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

        DebugPrint((1, "SpStartDevice: Default SRB flags for (%d,%d,%d) are "
                       "%#08lx\n",
                    LogicalUnit->PathId,
                    LogicalUnit->TargetId,
                    LogicalUnit->Lun,
                    LogicalUnit->CommonExtension.SrbFlags));

        ZwClose(instanceHandle);

    } else {

        DebugPrint((1, "SpStartDevice: Error opening instance key for pdo "
                       "[%#08lx]\n",
                    status));
    }

    //
    // If the queue is locked then unlock it to start i/o processing.
    //

    if(LogicalUnit->QueueLockCount > 0) {
        status = SpLockUnlockQueue(LogicalUnit->DeviceObject,
                                   FALSE,
                                   TRUE);
    }

    return status;
}


VOID
ScsiPortInitPdoWmi(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

    This routine will attempt WMI initialization for the PDO.

Arguments:

    DeviceObject - a pointer to the PDO being started

Return Value:

    status

--*/

{
    PCOMMON_EXTENSION commonExtension = &(LogicalUnit->CommonExtension);
    PADAPTER_EXTENSION adapterExtension = LogicalUnit->AdapterExtension;

    PAGED_CODE();

    //
    // Now that we have a LUN, we can initialize WMI support for the adapter if
    // the miniport supports WMI.  This may be a re-register if we've already
    // registered on behalf of scsiport itself.  We have to wait until we have
    // a LUN when the miniport supports WMI because we send it an SRB to do
    // its own initialization. We can't send it an SRB until we have a logical
    // unit.
    //

    if (adapterExtension->CommonExtension.WmiMiniPortInitialized == FALSE &&
        adapterExtension->CommonExtension.WmiMiniPortSupport == TRUE) {

        ULONG action;

        //
        // Decide whether we are registering or reregistering WMI for the FDO.
        //

        action = (adapterExtension->CommonExtension.WmiInitialized == FALSE) ?
           WMIREG_ACTION_REGISTER : WMIREG_ACTION_REREGISTER;

        //
        // Register/reregister. We can get WMI irps as soon as we do this.
        //
        
        IoWMIRegistrationControl(adapterExtension->DeviceObject, action);
        adapterExtension->CommonExtension.WmiMiniPortInitialized = TRUE;
        adapterExtension->CommonExtension.WmiInitialized = TRUE;
    }
    
    //
    // Initialize WMI support.
    //

    if (commonExtension->WmiInitialized == FALSE) {

        //
        // Build the SCSIPORT WMI registration information buffer for this PDO.
        //

        SpWmiInitializeSpRegInfo(LogicalUnit->DeviceObject);

        //
        // Register this device object only if the miniport supports WMI and/or
        // SCSIPORT will support certain WMI GUIDs on behalf of the miniport.
        //

        if (commonExtension->WmiMiniPortSupport ||
            commonExtension->WmiScsiPortRegInfoBuf) {

            //
            // Register this physical device object as a WMI data provider,
            // instructing WMI that it is ready to receive WMI IRPs.
            //

            IoWMIRegistrationControl(LogicalUnit->DeviceObject, 
                                     WMIREG_ACTION_REGISTER);
            commonExtension->WmiInitialized = TRUE;

        }

        //
        // Allocate several WMI_MINIPORT_REQUEST_ITEM blocks to satisfy a
        // potential onslaught of WMIEvent notifications by the miniport.
        //

        if (commonExtension->WmiMiniPortSupport) {

            //
            // Currently we only allocate two per new SCSI target (PDO).
            //
            SpWmiInitializeFreeRequestList(LogicalUnit->DeviceObject, 2);
        }
    }

    return;
}


NTSTATUS
ScsiPortInitLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

    This routine will attempt to start the specified device object.

Arguments:

    DeviceObject - a pointer to the PDO being started

Return Value:

    status

--*/

{
    PCOMMON_EXTENSION commonExtension = &(LogicalUnit->CommonExtension);
    PADAPTER_EXTENSION adapterExtension = LogicalUnit->AdapterExtension;

    HANDLE instanceHandle;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Initialize the idle detection timer.  Tell the system to put us into a
    // D3 state when we're not being used.
    //

    LogicalUnit->CommonExtension.IdleTimer =
        PoRegisterDeviceForIdleDetection(LogicalUnit->DeviceObject,
                                         SpPowerIdleTimeout,
                                         SpPowerIdleTimeout,
                                         PowerDeviceD3);

    ScsiPortInitPdoWmi(LogicalUnit);

    //
    // Build a device map entry for this logical unit.
    //

    SpBuildDeviceMapEntry(commonExtension);

    return status;
}

VOID
SpStartLockRequest(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PIRP Irp OPTIONAL
    )
/*++

Routine Description:

    This routine is responsible for queueing, starting or restarting a lock 
    request.  

    If Irp is provided then it will dispatched iff no existing lock or unlock
    request is already running.  If one is already running this request will 
    be queued.

    If Irp is not provided then the next request on the LockRequestQueue will 
    be removed and dispatched.
    
    This routine relies on the device queue to provide synchronization.  Since 
    we can only have one request get past the device queue at any given time we 
    should only have one call at any given time with Irp set to NULL.
    
Arguments:

    LogicalUnit - the logical unit to which this lock request was sent.
    
    Irp - the irp for the lock request.

Return Value:

    none    
--*/
    
{
    KIRQL oldIrql;

    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;

    PSRB_DATA srbData;

    BOOLEAN lock;

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    // If no IRP was provided then get one out of the device queue.
    // Otherwise make sure the device queue is not busy.
    //

    if(Irp == NULL) {
        PKDEVICE_QUEUE_ENTRY entry;

        ASSERT(LogicalUnit->CurrentLockRequest != NULL);
        LogicalUnit->CurrentLockRequest = NULL;

        entry = KeRemoveDeviceQueue(&(LogicalUnit->LockRequestQueue));

        if(entry == NULL) {

            //
            // No more requests have come in while processing this one - 
            // we can just return.
            //

            KeLowerIrql(oldIrql);
            return;

        } else {
            Irp = CONTAINING_RECORD(entry, 
                                    IRP,
                                    Tail.Overlay.DeviceQueueEntry);
            irpStack = IoGetCurrentIrpStackLocation(Irp);
            srb = irpStack->Parameters.Scsi.Srb;

            lock = (srb->Function == SRB_FUNCTION_LOCK_QUEUE);

        }

    } else {
        irpStack = IoGetCurrentIrpStackLocation(Irp);
        srb = irpStack->Parameters.Scsi.Srb;

        lock = (srb->Function == SRB_FUNCTION_LOCK_QUEUE);


        DebugPrint((2, "SpStartLockRequest: called to %s queue %#p\n",
                       lock ? "lock" : "unlock",
                       LogicalUnit));

        //
        // See if we can let this request keep processing or if we'll 
        // have to queue it.
        //

        IoMarkIrpPending(Irp);
        if(KeInsertDeviceQueue(&(LogicalUnit->LockRequestQueue),
                               &(Irp->Tail.Overlay.DeviceQueueEntry))) {
            KeLowerIrql(oldIrql);
            return;
        }
    }

    ASSERT(Irp != NULL);
    ASSERT(LogicalUnit->CurrentLockRequest == NULL);

    //
    // This srb function is only valid as part of a power up request
    // and will be ignored if the power state is D0.
    //

    CLEAR_FLAG(srb->SrbFlags, SRB_FLAGS_QUEUE_ACTION_ENABLE);
    SET_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE);

    //
    // Throw this request down so it gets processed as a real
    // request.  We need to get the completion dpc to start
    // things running again.  there are too many flags to set
    // to do it from here.
    //

    DebugPrint((2, "SpStartLockRequest: %s %#p into "
                   "queue %#p ... issuing request\n",
                lock ? "lock" : "unlock", srb, LogicalUnit));

    //
    // There are four bypass srb data blocks available - we should have at most
    // one lock request awaiting completion and the one we're about to start 
    // so this call should never, ever fail.
    //

    srbData = SpAllocateBypassSrbData(LogicalUnit);
    ASSERT(srbData != NULL);

    //
    // Set the current lock request.  As long as this is cleared
    // before the next item is removed from the queue everything
    // will be happy.
    //

    ASSERT(LogicalUnit->CurrentLockRequest == NULL);
    LogicalUnit->CurrentLockRequest = srbData;

    srbData->CurrentIrp = Irp;
    srbData->CurrentSrb = srb;
    srbData->LogicalUnit = LogicalUnit;
    srb->OriginalRequest = srbData;

    SpDispatchRequest(LogicalUnit, Irp);

    KeLowerIrql(oldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\internal.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    internal.c

Abstract:

    This is the NT SCSI port driver.  This file contains the internal
    code.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "port.h"
#include "wmilib.h"

#define __FILE_ID__ 'intr'

#if DBG
static const char *__file__ = __FILE__;
#endif

#if DBG
ULONG ScsiCheckInterrupts = 1;

// These counters keep track of succesfull (and failed) calls to
// IoWMIWriteEvent in the ScsiPortCompletionDpc function
LONG ScsiPortWmiWriteCalls = 0;
LONG ScsiPortWmiWriteCallsFailed = 0;

#else
ULONG ScsiCheckInterrupts = 0;
#endif

#if DBG
ULONG ScsiSimulateNoVaCounter = 0;
ULONG ScsiSimulateNoVaInterval = 0;
ULONG ScsiSimulateNoVaBreak = TRUE;

PVOID
SpGetSystemAddressForMdlSafe(
    IN PMDL Mdl,
    IN MM_PAGE_PRIORITY Priority
    )
{
    ScsiSimulateNoVaCounter++;

    if((ScsiSimulateNoVaInterval != 0) &&
       (Priority != HighPagePriority) &&
       ((ScsiSimulateNoVaCounter % ScsiSimulateNoVaInterval) == 0)) {
        if(TEST_FLAG(Mdl->MdlFlags, (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL))) {
            DbgPrint("SpGetSystemAddressForMdlSafe - not failing since MDL %#08p is already mapped\n", Mdl);
            return Mdl->MappedSystemVa;
        } else {
            DbgPrint("SpGetSystemAddressForMdlSafe - failing this MDL mapping (%#08p %x %x)\n", Mdl, ScsiSimulateNoVaInterval, ScsiSimulateNoVaCounter);
            ASSERT(ScsiSimulateNoVaBreak == FALSE);
            return NULL;
        }
    }
    return MmGetSystemAddressForMdlSafe(Mdl, Priority);
}
#else
#define SpGetSystemAddressForMdlSafe MmGetSystemAddressForMdlSafe
#endif

//
// module-local type declarations
//

typedef struct _REROUTE_CONTEXT {
    PIRP OriginalIrp;
    PLOGICAL_UNIT_EXTENSION LogicalUnit;
} REROUTE_CONTEXT, *PREROUTE_CONTEXT;

typedef struct _SP_ENUMERATION_CONTEXT {
    KEVENT Event;
    PIO_WORKITEM WorkItem;
    NTSTATUS Status;
} SP_ENUMERATION_CONTEXT, *PSP_ENUMERATION_CONTEXT;

//
// Prototypes
//

NTSTATUS
SpSendMiniPortIoctl(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

VOID
SpReceiveScatterGather(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    );

NTSTATUS
SpSendResetCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PRESET_COMPLETION_CONTEXT Context
    );

NTSTATUS
SpSendReset(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP RequestIrp,
    IN ULONG Ioctl,
    IN OUT PBOOLEAN Complete
    );

NTSTATUS
SpRerouteLegacyRequest(
    IN PDEVICE_OBJECT AdapterObject,
    IN PIRP Irp
    );

VOID
SpLogInterruptFailure(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpDelayedWmiRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context);

VOID
SpCompletionDpcProcessWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PINTERRUPT_DATA savedInterruptData
    );

NTSTATUS
IssueRequestSenseCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpSendRequestSenseIrp(
    IN PADAPTER_EXTENSION Adapter,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    );

NTSTATUS
SpFireSenseDataEvent(
    PSCSI_REQUEST_BLOCK Srb, 
    PDEVICE_OBJECT DeviceObject
    );
#if defined(FORWARD_PROGRESS)
PMDL
SpPrepareReservedMdlForUse(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData,
    IN PSCSI_REQUEST_BLOCK srb,
    IN ULONG ScatterListLength
    );

PVOID
SpMapLockedPagesWithReservedMapping(
    IN PADAPTER_EXTENSION Adapter,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PSRB_DATA SrbData,
    IN PMDL Mdl
    );
#endif

NTSTATUS
SpHandleIoctlScsiGetCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpHandleIoctlScsiPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN Direct
    );

NTSTATUS
SpHandleIoctlScsiMiniport(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpHandleIoctlScsiGetInquiryData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpHandleIoctlScsiRescanBus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpHandleIoctlScsiGetDumpPointers(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpHandleIoctlStorageResetBus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpHandleIoctlStorageBreakReservation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpSendPassThrough(
    IN PADAPTER_EXTENSION Adapter,
    IN PIRP RequestIrp,
    IN BOOLEAN Direct
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortFdoDeviceControl)
#pragma alloc_text(PAGE, SpSendMiniPortIoctl)
#pragma alloc_text(PAGE, ScsiPortFdoCreateClose)
#pragma alloc_text(PAGE, SpSendReset)
#pragma alloc_text(PAGE, SpHandleIoctlScsiGetCapabilities)
#pragma alloc_text(PAGE, SpHandleIoctlScsiPassThrough)
#pragma alloc_text(PAGE, SpHandleIoctlScsiMiniport)
#pragma alloc_text(PAGE, SpHandleIoctlScsiGetInquiryData)
#pragma alloc_text(PAGE, SpHandleIoctlScsiRescanBus)
#pragma alloc_text(PAGE, SpHandleIoctlScsiGetDumpPointers)
#pragma alloc_text(PAGE, SpHandleIoctlStorageResetBus)
#pragma alloc_text(PAGE, SpHandleIoctlStorageBreakReservation)
#pragma alloc_text(PAGE, SpSendPassThrough)

#pragma alloc_text(PAGELOCK, SpClaimLogicalUnit)

#endif

//
// Routines start
//


NTSTATUS
ScsiPortFdoDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Address of device object.
    Irp - Address of I/O request packet.

Return Value:

    Status.

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PSRB_DATA srbData;

    PKDEVICE_QUEUE_ENTRY packet;
    PIRP nextIrp;
    PIRP listIrp;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    NTSTATUS status;
    KIRQL currentIrql;

    ULONG isRemoved;

    //
    // If an SRB_DATA block has been setup then use it.
    //

    if(srb->OriginalRequest == Irp) {
        srbData = NULL;
    } else {
        srbData = srb->OriginalRequest;
    }

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);

    if(isRemoved && !IS_CLEANUP_REQUEST(irpStack)) {

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

        SpReleaseRemoveLock(DeviceObject, Irp);

        SpCompleteRequest(DeviceObject,
                          Irp,
                          srbData,
                          IO_NO_INCREMENT);

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // If the adapter is configured to handle power-down requests during 
    // shutdown, it is possible for it to be powered off and for the PDOs 
    // to be powered up.  We will fail requests when this condition arises.
    //
    // This should only occur at shutdown.
    //

    if (deviceExtension->CommonExtension.CurrentSystemState > PowerSystemHibernate &&
        deviceExtension->CommonExtension.CurrentDeviceState != PowerDeviceD0) {       

        //
        // This should only occur if the adapter is configured to receive
        // power-down requests at shutdown.
        //

        ASSERT(deviceExtension->NeedsShutdown == TRUE);

        //
        // Lock and unlock commands don't require power and will work
        // regardless of the current power state.
        //

        if ((srb->Function != SRB_FUNCTION_UNLOCK_QUEUE &&
             srb->Function != SRB_FUNCTION_LOCK_QUEUE)) {

            Irp->IoStatus.Status = STATUS_POWER_STATE_INVALID;
            SpReleaseRemoveLock(DeviceObject, Irp);
            SpCompleteRequest(DeviceObject, Irp, srbData, IO_NO_INCREMENT);
            return STATUS_POWER_STATE_INVALID;
        }
    }

    //
    // If there's no SRB_DATA block for this request yet then we need to
    // allocate one.
    //

    if(srbData == NULL) {
        logicalUnit = GetLogicalUnitExtension(deviceExtension,
                                              srb->PathId,
                                              srb->TargetId,
                                              srb->Lun,
                                              FALSE,
                                              TRUE);

        if(logicalUnit == NULL) {
            DebugPrint((1, "ScsiPortFdoDispatch: Bad logical unit address.\n"));

            //
            // Fail the request. Set status in Irp and complete it.
            //

            srb->SrbStatus = SRB_STATUS_NO_DEVICE;
            Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
            SpReleaseRemoveLock(DeviceObject, Irp);

            SpCompleteRequest(DeviceObject, Irp, srbData, IO_NO_INCREMENT);
            return STATUS_NO_SUCH_DEVICE;
        }

        if((srb->Function == SRB_FUNCTION_IO_CONTROL) ||
           (srb->Function == SRB_FUNCTION_EXECUTE_SCSI) ||
           (srb->Function == SRB_FUNCTION_RELEASE_QUEUE) ||
           (srb->Function == SRB_FUNCTION_FLUSH_QUEUE)) {

            //
            // These are the only two types of requests which should
            // be able to get here without an SRB_DATA block.  Any
            // other will need to be rerouted.
            //

            return SpRerouteLegacyRequest(DeviceObject, Irp);
        }

    } else {

        ASSERT_SRB_DATA(srbData);
        ASSERT(srbData->CurrentIrp == Irp);

        logicalUnit = srbData->LogicalUnit;

        ASSERT(logicalUnit != NULL);
    }

    switch (srb->Function) {


        case SRB_FUNCTION_SHUTDOWN:
        case SRB_FUNCTION_FLUSH: {

            //
            // Do not send shutdown requests unless the adapter
            // supports caching.
            //

            if (!deviceExtension->CachesData) {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                srb->SrbStatus = SRB_STATUS_SUCCESS;

                SpReleaseRemoveLock(DeviceObject, Irp);
                SpCompleteRequest(DeviceObject, Irp, srbData, IO_NO_INCREMENT);
                return STATUS_SUCCESS;
            }

            DebugPrint((2, "ScsiPortFdoDispatch: Sending flush or shutdown "
                           "request.\n"));

            goto ScsiPortFdoDispatchRunCommand;
        }

        case SRB_FUNCTION_LOCK_QUEUE:
        case SRB_FUNCTION_UNLOCK_QUEUE:
        case SRB_FUNCTION_IO_CONTROL:
        case SRB_FUNCTION_EXECUTE_SCSI:
        case SRB_FUNCTION_WMI: {

ScsiPortFdoDispatchRunCommand:

            //
            // Mark Irp status pending.
            //

            IoMarkIrpPending(Irp);

            if(SpSrbIsBypassRequest(srb, logicalUnit->LuFlags)) {

                //
                // Call start io directly.  This will by-pass the
                // frozen queue.
                //

                DebugPrint((2,
                    "ScsiPortFdoDispatch: Bypass frozen queue, IRP %#p\n",
                    Irp));

                srbData->TickCount = deviceExtension->TickCount;
                IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);

            } else {

#if defined(NEWQUEUE) && DBG
                ULONG zone;
#endif // NEWQUEUE && DBG

                //
                // Queue the packet normally.
                //

                KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

#if DBG
                // ASSERT(srb->Function != SRB_FUNCTION_UNLOCK_QUEUE);

                if (SpIsQueuePaused(logicalUnit)) {
                    DebugPrint((1,"ScsiPortFdoDispatch: Irp %#p put in "
                                  "frozen queue %#p!\n", Irp, logicalUnit));
                }

                // ASSERT((srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) == 0);
#endif

                //
                // Set the tick count so we know how long this request has
                // been queued.
                //

                srbData->TickCount = deviceExtension->TickCount;

#if defined(NEWQUEUE) && DBG
                //
                // Increment the per-zone request counter.  This is purely 
                // informational; shows the distribution of IO across
                // the medium.
                //

                zone = srb->QueueSortKey / logicalUnit->ZoneLength;
                if (zone >= logicalUnit->Zones) {
                    DebugPrint((0, "ScsiPortFdoDispatch: zone out of range "
                                "srb:%p lu:%p zone:%d\n", srb, logicalUnit, 
                                zone));
                    zone = logicalUnit->Zones - 1;
                }
                logicalUnit->RequestCount[zone]++;
#endif // NEWQUEUE && DBG

                if (!KeInsertByKeyDeviceQueue(
                        &logicalUnit->DeviceObject->DeviceQueue,
                        &Irp->Tail.Overlay.DeviceQueueEntry,
                        srb->QueueSortKey)) {

                    //
                    // Clear the retry count.
                    //

                    logicalUnit->RetryCount = 0;

                    //
                    // Queue is empty; start request.
                    //

#if DBG
                    if(SpIsQueuePaused(logicalUnit)) {
                        DebugPrint((1, "ScsiPortFdoDispatch: Queue was empty - "
                                       "issuing request anyway\n"));
                    }
#endif
                    IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);
                }

                KeLowerIrql(currentIrql);
            }

            return STATUS_PENDING;
        }

        case SRB_FUNCTION_RELEASE_QUEUE:
        case SRB_FUNCTION_FLUSH_QUEUE: {

            status = SpFlushReleaseQueue(
                        logicalUnit,
                        (BOOLEAN) (srb->Function == SRB_FUNCTION_FLUSH_QUEUE),
                        FALSE);

            ASSERT(NT_SUCCESS(status));

            if(NT_SUCCESS(status)) {
                srb->SrbStatus = SRB_STATUS_SUCCESS;
            } else {
                srb->SrbStatus = SRB_STATUS_ERROR;
            }

            break;
        }

        case SRB_FUNCTION_RESET_BUS: {

            RESET_CONTEXT resetContext;

            //
            // Acquire the spinlock to protect the flags structure and the saved
            // interrupt context.
            //

            KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

            resetContext.DeviceExtension = deviceExtension;
            resetContext.PathId = srb->PathId;

            if (!deviceExtension->SynchronizeExecution(deviceExtension->InterruptObject,
                                                       SpResetBusSynchronized,
                                                       &resetContext)) {

                DebugPrint((1,"ScsiPortFdoDispatch: Reset failed\n"));
                srb->SrbStatus = SRB_STATUS_PHASE_SEQUENCE_FAILURE;
                status = STATUS_IO_DEVICE_ERROR;

            } else {

                SpLogResetMsg(deviceExtension, srb, ('R'<<24) | 256);

                srb->SrbStatus = SRB_STATUS_SUCCESS;
                status = STATUS_SUCCESS;
            }

            KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

            break;
        }

        case SRB_FUNCTION_ABORT_COMMAND: {

            DebugPrint((3, "ScsiPortFdoDispatch: SCSI Abort or Reset command\n"));

            //
            // Mark Irp status pending.
            //

            IoMarkIrpPending(Irp);

            //
            // Don't queue these requests in the logical unit
            // queue, rather queue them to the adapter queue.
            //

            KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

            IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);

            KeLowerIrql(currentIrql);

            return STATUS_PENDING;

            break;
        }

        case SRB_FUNCTION_ATTACH_DEVICE:
        case SRB_FUNCTION_CLAIM_DEVICE:
        case SRB_FUNCTION_RELEASE_DEVICE: {

            SpAcquireRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                                (PVOID) ((ULONG_PTR) Irp + 2));

            status = SpClaimLogicalUnit(deviceExtension, logicalUnit, Irp, TRUE);

            SpReleaseRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                                (PVOID) ((ULONG_PTR) Irp + 2));

            break;
        }

        default: {

            //
            // Found unsupported SRB function.
            //

            DebugPrint((1,"ScsiPortFdoDispatch: Unsupported function, SRB %p\n",
                srb));

            srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    //
    // Set status in Irp.
    //

    Irp->IoStatus.Status = status;

    //
    // Complete request at raised IRQ.
    //

    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, srbData, IO_NO_INCREMENT);

    return status;

} // end ScsiPortFdoDispatch()


NTSTATUS
ScsiPortFdoCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    I/O system disk create routine.  This is called by the I/O system
    when the device is opened.

    If the fdo has not been started yet, this routine will try to start it.
    If the fdo cannot be started successfully this routine will return an error.

Arguments:

    DriverObject - Pointer to driver object created by system.
    Irp - IRP involved.

Return Value:

    NT Status

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status = STATUS_SUCCESS;

    ULONG isRemoved;

    PAGED_CODE();

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);

    //
    // Check to see if the adapter's been started first.
    //

    if(irpStack->MajorFunction == IRP_MJ_CREATE) {

        if(isRemoved != NO_REMOVE) {
            status = STATUS_DEVICE_DOES_NOT_EXIST;
        } else if(commonExtension->CurrentPnpState != IRP_MN_START_DEVICE) {
            status = STATUS_DEVICE_NOT_READY;
        }
    }

    Irp->IoStatus.Status = status;

    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_DISK_INCREMENT);
    return status;

} // end ScsiPortCreateClose()


VOID
ScsiPortStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Supplies pointer to Adapter device object.
    Irp - Supplies a pointer to an IRP.

Return Value:

    Nothing.

--*/

{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    PSCSI_REQUEST_BLOCK srb;
    PSRB_DATA srbData;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    LONG interlockResult;
    NTSTATUS status;
    PVOID sgBuffer;
    ULONG sgBufferLen;
    BOOLEAN taggedRequest;

    DebugPrint((3,"ScsiPortStartIo: Enter routine\n"));

    if(irpStack->MajorFunction != IRP_MJ_SCSI) {

        //
        // Special processing.
        //

        if(irpStack->MajorFunction == IRP_MJ_POWER) {
            ScsiPortProcessAdapterPower(DeviceObject, Irp);
        } else {

            ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
            ASSERT(Irp->IoStatus.Information != (ULONG_PTR) NULL);

            //
            // The start-io routine is blocked now - signal the PNP code
            // so it can continue its processing.
            //

            KeSetEvent((PKEVENT) Irp->IoStatus.Information,
                       IO_NO_INCREMENT,
                       FALSE);
        }
        return;
    }

    srb = irpStack->Parameters.Scsi.Srb;
    srbData = srb->OriginalRequest;

    ASSERT_SRB_DATA(srbData);

    //
    // Start the srb status out as pending.  If the srb is successful by the
    // end of this routine then it will be completed and the next request
    // will be fetched rather than issuing it to the miniport.
    //

    srb->SrbStatus = SRB_STATUS_PENDING;

    //
    // Clear the SCSI status if this is a scsi request.
    //

    if(srb->Function == SRB_FUNCTION_EXECUTE_SCSI) {
        srb->ScsiStatus = SCSISTAT_GOOD;
    }

    //
    // Get logical unit extension.  The logical unit should have already been
    // locked with this IRP so we don't need to acquire it here.
    //

    logicalUnit = srbData->LogicalUnit;

    ASSERT(logicalUnit != NULL);

    //
    // We're already holding the remove lock so just check the is removed flag
    // to see if we should continue. If we were surprise removed, flush the LUN
    // Queue.
    //

    if((deviceExtension->CommonExtension.IsRemoved)) {

        if(SpSrbIsBypassRequest(srb, logicalUnit->LuFlags) ||
          (deviceExtension->CommonExtension.IsRemoved == REMOVE_PENDING)) {

            if( (deviceExtension->CommonExtension.IsRemoved == REMOVE_PENDING) 
                && (deviceExtension->CommonExtension.CurrentPnpState == 
                    IRP_MN_START_DEVICE) ) {

                //
                //We got a surprise remove. Flush the Lun Queue, and complete
                //this request.
                //

                SpFlushReleaseQueue(logicalUnit, TRUE, TRUE);
        
            }

            SpAcquireRemoveLock(DeviceObject, ScsiPortStartIo);
            SpReleaseRemoveLock(DeviceObject, Irp);
            Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
            srb->SrbStatus = SRB_STATUS_NO_DEVICE;

            SpCompleteRequest(DeviceObject, Irp, srbData, IO_DISK_INCREMENT);

            SpStartNextPacket(DeviceObject, FALSE);
            SpReleaseRemoveLock(DeviceObject, ScsiPortStartIo);
            return;

        }
    }

    //
    // Check to see if there's a reason this shouldn't have made it into the
    // startio routine.  if there is then requeue the request.  This is a
    // stopgap measure to fix some cases where the miniport entices scsiport
    // into inserting multiple requests for a logical unit into the adapter
    // queue at one time.
    //
    // The one exception to this case is with bypass requests since there
    // may be a request pending for a power-up or queue-thaw condition.  In
    // these cases we will let the command run.
    //
    // We can do a check for LU_PENDING_LU_REQUEST synchronously since the
    // only routines which set it are part of the startio process.  If we
    // think it's set then we need to acquire the port spinlock and verify
    //

    if(TEST_FLAG(logicalUnit->LuFlags, LU_PENDING_LU_REQUEST)) {

        KeAcquireSpinLockAtDpcLevel(&(deviceExtension->SpinLock));

        if(TEST_FLAG(logicalUnit->LuFlags, LU_PENDING_LU_REQUEST) &&
           !SpSrbIsBypassRequest(srb, logicalUnit->LuFlags)) {

            BOOLEAN t;

            //
            // Since there's an outstanding command the queue should be
            // busy.  However we've found that there are some times where it
            // isn't (with adapters which ask for more requests before
            // dispatching the ones they have).  Here if it's not busy we
            // can force the request in anyway since we know that something
            // is still outstanding and thus will take the next request out
            // of the queue.
            //

            t = KeInsertByKeyDeviceQueue(
                    &logicalUnit->DeviceObject->DeviceQueue,
                    &Irp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey);

            if(t == FALSE) {
                KeInsertByKeyDeviceQueue(
                    &logicalUnit->DeviceObject->DeviceQueue,
                    &Irp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey);
            }

            //
            // Now set the lun's current key to the value we just inserted
            // so that it's the next one to get pulled out.
            //

            logicalUnit->CurrentKey = srb->QueueSortKey;

            KeReleaseSpinLockFromDpcLevel(&(deviceExtension->SpinLock));

            IoStartNextPacket(deviceExtension->DeviceObject, FALSE);

            return;
        }

        //
        // False alarm.
        //

        KeReleaseSpinLockFromDpcLevel(&(deviceExtension->SpinLock));

    }

    //
    // Set the default flags in the SRB.
    //

    srb->SrbFlags |= deviceExtension->CommonExtension.SrbFlags;

    //
    // If we're not in a valid power state for the request then block the
    // i/o and request that PO put us in such a state.
    //

    status = SpRequestValidPowerState(deviceExtension, logicalUnit, srb);

    if(status == STATUS_PENDING) {

        SpStartNextPacket(DeviceObject, FALSE);
        return;

    }

    if(srb->SrbFlags & SRB_FLAGS_BYPASS_LOCKED_QUEUE) {
        DebugPrint((1, "ScsiPortStartIo: Handling power bypass IRP %#p\n",
                    Irp));
    }

    ASSERT(Irp == DeviceObject->CurrentIrp);

    if (deviceExtension->AllocateSrbExtension ||
        deviceExtension->SupportsMultipleRequests) {

        BOOLEAN StartNextPacket = FALSE;

        //
        // Allocate the special extensions or SRB data structure.
        // If NULL is returned then this request cannot be excuted at this
        // time so just return.  This occurs when one the the data structures
        // could not be allocated or when unqueued request could not be
        // started because of actived queued requests.
        //
        //

        if(SpAllocateSrbExtension(deviceExtension,
                                  logicalUnit,
                                  srb,
                                  &StartNextPacket,
                                  &taggedRequest) == FALSE) {

            //
            // If the request could not be started on the logical unit,
            // then call SpStartNextPacket.  Note that this may cause this
            // to be entered recursively; however, no resources have been
            // allocated, it is a tail recursion and the depth is limited by
            // the number of requests in the device queue.
            //

            if (StartNextPacket == TRUE) {
                SpStartNextPacket(DeviceObject, FALSE);
            }
            return;
        }

    } else {

        //
        // No special resources are required.
        //

        taggedRequest = FALSE;
        srb->SrbExtension = NULL;
    }

    //
    // Assign a queuetag to the srb
    //

    if (taggedRequest == TRUE) {

        //
        // If we get an SRB with an invalid QueueAction, fix it up here
        // to prevent problems.
        //

        if (srb->Function == SRB_FUNCTION_EXECUTE_SCSI &&
            !(srb->QueueAction == SRB_SIMPLE_TAG_REQUEST ||
              srb->QueueAction == SRB_HEAD_OF_QUEUE_TAG_REQUEST ||
              srb->QueueAction == SRB_ORDERED_QUEUE_TAG_REQUEST)) {
            
            DebugPrint((1,"ScsiPortStartIo: Invalid QueueAction (%02x) SRB:%p irp:%p\n", 
                        srb->QueueAction, srb, Irp));

            srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
        }

        srb->QueueTag = (UCHAR)srbData->QueueTag;

    } else {

        srb->QueueTag = SP_UNTAGGED;

    }

    //
    // Save the original SRB values away so that we can restore them
    // later if it becomes necessary to retry the request.
    //

    srbData->OriginalDataTransferLength = srb->DataTransferLength;

    //
    // Update the sequence number for this request if there is not already one
    // assigned.
    //

    if (!srbData->SequenceNumber) {

        //
        // Assign a sequence number to the request and store it in the logical
        // unit.
        //

        srbData->SequenceNumber = deviceExtension->SequenceNumber++;

    }

    //
    // If this is not an ABORT request the set the current srb.
    // NOTE: Lock should be held here!
    //

    if (srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

        //
        // Only abort requests can be started when there is a current request
        // active.
        //

        ASSERT(logicalUnit->AbortSrb == NULL);
        logicalUnit->AbortSrb = srb;

    } else if((srb->Function == SRB_FUNCTION_LOCK_QUEUE) ||
              (srb->Function == SRB_FUNCTION_UNLOCK_QUEUE)) {

        BOOLEAN lock = (srb->Function == SRB_FUNCTION_LOCK_QUEUE);
        ULONG lockCount;

        //
        // Process power requests
        //

        DebugPrint((1, "ScsiPortStartIo: Power %s request %#p in "
                       "start-io routine\n",
                    lock ? "lock" : "unlock",
                    Irp));

        KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

        if(lock) {
            lockCount = InterlockedIncrement(&(logicalUnit->QueueLockCount));
            SET_FLAG(logicalUnit->LuFlags, LU_QUEUE_LOCKED);
        } else {
            if(TEST_FLAG(logicalUnit->LuFlags, LU_QUEUE_LOCKED)) {
                ASSERT(logicalUnit->QueueLockCount != 0);
                lockCount = InterlockedDecrement(&(logicalUnit->QueueLockCount));
                if(lockCount == 0) {
                    CLEAR_FLAG(logicalUnit->LuFlags, LU_QUEUE_LOCKED);
                }
            }
        }

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        srb->SrbStatus = SRB_STATUS_SUCCESS;

    }

    //
    // Flush the data buffer if necessary.
    //

    if (srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {

        //
        // Save the current data buffer away in the srb data.  We will always
        // restore it afterwards - partially because the miniport might change
        // it and partially because scsiport might.  The tape drivers appear
        // to expect the same data buffer pointer back.
        //

        srbData->OriginalDataBuffer = srb->DataBuffer;

        //
        // Assuming that srb's data buffer uses the mdl's VA as a base address,
        // calculate the offset from the base.  This offset will be used to
        // calculate VAs from derived system addresses.
        //

        srbData->DataOffset =
            (ULONG_PTR) ((ULONG_PTR) srb->DataBuffer -
                         (ULONG_PTR) MmGetMdlVirtualAddress(Irp->MdlAddress));

        if (deviceExtension->DmaAdapterObject) {

            BOOLEAN dataIn;

            //
            // If the buffer is not mapped then the I/O buffer must be flushed.
            //

            dataIn = (srb->SrbFlags & SRB_FLAGS_DATA_IN) ? TRUE : FALSE;

            KeFlushIoBuffers(Irp->MdlAddress, dataIn, TRUE);
        }

        //
        // Determine if this adapter needs map registers
        //

        if (deviceExtension->MasterWithAdapter) {

            //
            // Calculate the number of map registers required for the
            // transfer.
            //

            srbData->NumberOfMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                                srb->DataBuffer,
                                                srb->DataTransferLength);

            //
            // If the data will fit into our preallocated SG list, use it,
            // else we let the HAL allocate the buffer.
            //

            if (srbData->NumberOfMapRegisters <= SP_SMALL_PHYSICAL_BREAK_VALUE) {

                //
                // If we have not yet calcuated the SG buffer length, do
                // it now.
                //
                // NB: We utilize the fact that if you call BuildScatterGather-
                // List with NULL buffer and 0 length it will allocate the
                // buffer for you. Since this is undocumented behavior, we
                // would be better not to use this.
                //

                if (deviceExtension->SgBufferLen == 0) {
                    status = CalculateScatterGatherList(
                                 deviceExtension->DmaAdapterObject,
                                 NULL,
                                 0, 
                                 PAGE_SIZE * SP_SMALL_PHYSICAL_BREAK_VALUE,
                                 &deviceExtension->SgBufferLen,
                                 NULL);
                }

                if (deviceExtension->SgBufferLen <= 
                    sizeof(SRB_SCATTER_GATHER_LIST)) {

                    sgBuffer = &srbData->SmallScatterGatherList;
                    sgBufferLen = deviceExtension->SgBufferLen;
                } else {

                    sgBuffer = NULL;
                    sgBufferLen = 0;
                }

            } else {

                sgBuffer = NULL;
                sgBufferLen = 0;
            }

            //
            // Allocate the adapter channel with sufficient map registers
            // for the transfer.
            //

            status = BuildScatterGatherList(
                         deviceExtension->DmaAdapterObject,
                         deviceExtension->DeviceObject,
                         Irp->MdlAddress,
                         srb->DataBuffer,
                         srb->DataTransferLength,
                         SpReceiveScatterGather,
                         srbData,
                         (BOOLEAN) (srb->SrbFlags & SRB_FLAGS_DATA_OUT ? TRUE : FALSE),
                         sgBuffer,
                         sgBufferLen);

            if (!NT_SUCCESS(status)) {
                DebugPrint((0, "ScsiPortStartIo: BuildScatterGatherList failed: adapter %p "
                            "srb %p SgListSize %d sgBufferLen %d mapRegs %d (%08x)\n",
                            deviceExtension,
                            srb,
                            deviceExtension->SgBufferLen,
                            sgBufferLen,
                            srbData->NumberOfMapRegisters,
                            status));
                srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
                srb->ScsiStatus = 0xff;
                srbData->InternalStatus = status;
                goto ScsiPortStartIoFailedRequest;
            }

            //
            // The execution routine called by IoAllocateChannel will do the
            // rest of the work so just return.
            //

            return;

        } else if ((deviceExtension->MapBuffers == TRUE) ||
                   (IS_MAPPED_SRB(srb) == TRUE)) {

            //
            // Determine if the adapter needs mapped memory.
            //

            if (Irp->MdlAddress) {

                PVOID systemAddress;

                //
                // Get the mapped system address and calculate offset into MDL.
                // At the moment don't allow KernelMode requests to fail since
                // not all scsiport's internally sent requests are correctly
                // marked as coming from non-paged pool.
                //

                systemAddress = SpGetSystemAddressForMdlSafe(
                                    Irp->MdlAddress,
                                    ((Irp->RequestorMode == KernelMode) ?
                                     HighPagePriority :
                                     NormalPagePriority));

#if defined(FORWARD_PROGRESS)
                if (systemAddress == NULL && deviceExtension->ReservedPages != NULL) {            

                    //
                    // The system could not map the pages necessary to complete this
                    // request.  We need to ensure forward progress, so we'll try to
                    // use the reserve pages we allocated at initialization time.
                    //

                    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);
            
                    systemAddress = SpMapLockedPagesWithReservedMapping(
                                        deviceExtension,
                                        srb,
                                        srbData,
                                        Irp->MdlAddress);
                    
                    if (systemAddress == (PVOID)-1) {

                        DebugPrint((1, "ScsiPortStartIo: reserved pages in use - pending DevExt:%p srb:%p\n", 
                                    deviceExtension, srb));

                        //
                        // The spare pages are already in use.  At this point, this
                        // request is still the current IRP on the adapter device
                        // object, so let's pend it until the spare comes available.
                        //

                        ASSERT(Irp == DeviceObject->CurrentIrp);
                        SET_FLAG(deviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);

                        //
                        // If we allocated an SRB extension for this request, free
                        // it now.  I do this because when the request gets restarted
                        // we'll try to allocate the SRB extension again and without
                        // adding more state, there isn't a safe way to check if the 
                        // extension has already been allocated.  Besides, it makes
                        // sense to make the extension available for some other
                        // request since it also is a limited resource.
                        //

                        if (srb->SrbExtension != NULL) {

                            //
                            // Restore the SenseInfoBuffer pointer in the srb.
                            //

                            if ((srb->Function != SRB_FUNCTION_WMI) &&
                                deviceExtension->AutoRequestSense &&
                                (srb->SenseInfoBuffer != NULL)) {

                                ASSERT(srbData->RequestSenseSave != NULL ||
                                       srb->SenseInfoBuffer == NULL);

                                srb->SenseInfoBufferLength = 
                                    srbData->RequestSenseLengthSave;
                                srb->SenseInfoBuffer = 
                                    srbData->RequestSenseSave;
                            }

                            SpFreeSrbExtension(deviceExtension, srb->SrbExtension);
                        }

                        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                        return;
                    }

                    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                }
#endif

                if(systemAddress != NULL) {

                    //
                    // Since we mapped the original MDL rather we have to
                    // compensate for the data buffer offset.
                    //

                    srb->DataBuffer =
                        (PVOID) ((ULONG_PTR) systemAddress +
                                 (ULONG_PTR) srbData->DataOffset);
                } else {
                    DebugPrint((1, "ScsiPortStartIo: Couldn't get system "
                                   "VA for irp %#08p\n", Irp));

                    srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
                    srb->ScsiStatus = 0xff;
                    srbData->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

                    goto ScsiPortStartIoFailedRequest;
                }
            }
        }
    }

    //
    // Increment the active request count.  If the count is zero, the adapter 
    // object needs to be allocated. Note that at this point a slave device is
    // assumed since master with adapter has already been checked.
    //

    interlockResult =
        InterlockedIncrement(&deviceExtension->ActiveRequestCount);

    if (interlockResult == 0 &&
        !deviceExtension->MasterWithAdapter &&
        deviceExtension->DmaAdapterObject != NULL) {

        //
        // Allocate the AdapterObject.  The number of registers is equal to the
        // maximum transfer length supported by the adapter + 1.  This insures
        // that there will always be a sufficient number of registers.
        //

        AllocateAdapterChannel(
            deviceExtension->DmaAdapterObject,
            DeviceObject,
            deviceExtension->Capabilities.MaximumPhysicalPages,
            ScsiPortAllocationRoutine,
            logicalUnit
            );

        //
        // The execution routine called by IoAllocateChannel will do the
        // rest of the work so just return.
        //

        return;

    }

ScsiPortStartIoFailedRequest:

    //
    // Acquire the spinlock to protect the various structures.
    // SpStartIoSynchronized must be called with the spinlock held.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    deviceExtension->SynchronizeExecution(
        deviceExtension->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    return;

} // end ScsiPortStartIO()

BOOLEAN
ScsiPortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:


Arguments:

    Interrupt

    Device Object

Return Value:

    Returns TRUE if interrupt expected.

--*/

{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PINTERRUPT_DATA interruptData = &(deviceExtension->InterruptData);
    BOOLEAN returnValue;

    UNREFERENCED_PARAMETER(Interrupt);

    //
    // If interrupts have been disabled then this should not be our interrupt,
    // so just return.
    //

    if (TEST_FLAG(interruptData->InterruptFlags,
                  (PD_DISABLE_INTERRUPTS | PD_ADAPTER_REMOVED))) {
#if DGB
        static int interruptCount;

        interruptCount++;
        ASSERT(interruptCount < 1000);
#endif

        return(FALSE);
    }

    returnValue =
        deviceExtension->HwInterrupt(deviceExtension->HwDeviceExtension);

    //
    // Update the watchdog and record the current tick count.  This helps
    // figure out if interrupts are not getting delivered to the adapter
    // or if the adapter is creating an interrupt storm.
    //

    if(returnValue) {
        interruptData->TickCountAtLastInterruptAck = deviceExtension->TickCount;
        deviceExtension->WatchdogInterruptCount = 1;
    } else {
        interruptData->TickCountAtLastInterruptNak = deviceExtension->TickCount;
    }

    //
    // Check to see if a DPC needs to be queued.
    //

    if (TEST_FLAG(interruptData->InterruptFlags, PD_NOTIFICATION_REQUIRED)) {

        SpRequestCompletionDpc(DeviceObject);

    }

    return(returnValue);

} // end ScsiPortInterrupt()


VOID
ScsiPortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    Dpc
    DeviceObject
    Irp - not used
    Context - not used

Return Value:

    None.

--*/

{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    INTERRUPT_CONTEXT interruptContext;
    INTERRUPT_DATA savedInterruptData;
    BOOLEAN callStartIo;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSRB_DATA srbData;
    LONG interlockResult;
    LARGE_INTEGER timeValue;
    PSCSI_REQUEST_BLOCK Srb;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Context);

    do {

        //
        // Acquire the spinlock to protect flush adapter buffers
        // information.
        //

        KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

        //
        // Get the interrupt state.  This copies the interrupt
        // state to the saved state where it can be processed.
        // It also clears the interrupt flags.
        //

        interruptContext.DeviceExtension = deviceExtension;
        interruptContext.SavedInterruptData = &savedInterruptData;

        if (!deviceExtension->SynchronizeExecution(
            deviceExtension->InterruptObject,
            SpGetInterruptState,
            &interruptContext)) {

            KeReleaseSpinLockFromDpcLevel(
                &deviceExtension->SpinLock);

            //
            // There wasn't anything to do that time.  Test the
            // DPC flags and try again
            //

            continue;
        }

        if(savedInterruptData.InterruptFlags &
           (PD_FLUSH_ADAPTER_BUFFERS |
            PD_MAP_TRANSFER |
            PD_TIMER_CALL_REQUEST |
            PD_WMI_REQUEST |
            PD_BUS_CHANGE_DETECTED |
            PD_INTERRUPT_FAILURE)) {

            //
            // Check for a flush DMA adapter object request.
            //

            if (savedInterruptData.InterruptFlags &
                PD_FLUSH_ADAPTER_BUFFERS) {

                if(Sp64BitPhysicalAddresses) {
                    KeBugCheckEx(PORT_DRIVER_INTERNAL,
                                 3,
                                 STATUS_NOT_SUPPORTED,
                                 (ULONG_PTR) deviceExtension->HwDeviceExtension,
                                 (ULONG_PTR) deviceExtension->DeviceObject->DriverObject);
                }

                //
                // Call IoFlushAdapterBuffers using the parameters
                // saved from the last IoMapTransfer call.
                //

                FlushAdapterBuffers(
                    deviceExtension->DmaAdapterObject,
                    deviceExtension->FlushAdapterParameters.SrbData->CurrentIrp->MdlAddress,
                    deviceExtension->MapRegisterBase,
                    deviceExtension->FlushAdapterParameters.LogicalAddress,
                    deviceExtension->FlushAdapterParameters.Length,
                    (BOOLEAN)(deviceExtension->FlushAdapterParameters.SrbFlags
                        & SRB_FLAGS_DATA_OUT ? TRUE : FALSE));
            }

            //
            // Check for an IoMapTransfer DMA request.  Don't do
            // anything if the adapter's been removed in the time
            // since it requested this service.
            //

            if (TEST_FLAG(savedInterruptData.InterruptFlags, PD_MAP_TRANSFER) &&
                !TEST_FLAG(savedInterruptData.InterruptFlags, PD_ADAPTER_REMOVED)) {

                PADAPTER_TRANSFER mapTransfer;
                ULONG_PTR address;
                PMDL mdl;

                if(Sp64BitPhysicalAddresses) {
                    KeBugCheckEx(PORT_DRIVER_INTERNAL,
                                 4,
                                 STATUS_NOT_SUPPORTED,
                                 (ULONG_PTR) deviceExtension->HwDeviceExtension,
                                 (ULONG_PTR) deviceExtension->DeviceObject->DriverObject);
                }

                mapTransfer = &savedInterruptData.MapTransferParameters;
                srbData = mapTransfer->SrbData;

                ASSERT_SRB_DATA(srbData);

                Srb = srbData->CurrentSrb;
                mdl = srbData->CurrentIrp->MdlAddress;

                //
                // Adjust the logical address.  This is necessary because the
                // address in the srb may be a mapped system address rather
                // than the virtual address for the MDL.
                //

                address = (ULONG_PTR) mapTransfer->LogicalAddress;
                address -= (ULONG_PTR) Srb->DataBuffer;
                address += (ULONG_PTR) srbData->DataOffset;
                address += (ULONG_PTR) MmGetMdlVirtualAddress(mdl);

                mapTransfer->LogicalAddress = (PCHAR) address;

                //
                // Call IoMapTransfer using the parameters saved from the
                // interrupt level.
                //

                MapTransfer(
                    deviceExtension->DmaAdapterObject,
                    mdl,
                    deviceExtension->MapRegisterBase,
                    mapTransfer->LogicalAddress,
                    &mapTransfer->Length,
                    (BOOLEAN)(mapTransfer->SrbFlags & SRB_FLAGS_DATA_OUT ?
                        TRUE : FALSE));

                //
                // Save the paramters for IoFlushAdapterBuffers.
                //

                deviceExtension->FlushAdapterParameters =
                    savedInterruptData.MapTransferParameters;

                //
                // If necessary notify the miniport driver that the DMA has been
                // started.
                //

                if (deviceExtension->HwDmaStarted) {
                    deviceExtension->SynchronizeExecution(
                        deviceExtension->InterruptObject,
                        (PKSYNCHRONIZE_ROUTINE) deviceExtension->HwDmaStarted,
                        deviceExtension->HwDeviceExtension);
                }

                //
                // Check for miniport work requests. Note this is an unsynchonized
                // test on a bit that can be set by the interrupt routine; however,
                // the worst that can happen is that the completion DPC checks for work
                // twice.
                //

                if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

                    //
                    // Mark that there's more work to be processed so that we
                    // restart the DPC rather than exiting it.
                    //

                    InterlockedExchange(&(deviceExtension->DpcFlags),
                                        (PD_DPC_RUNNING | PD_NOTIFICATION_REQUIRED));
                }

            }

            //
            // Check for timer requests.
            // If the adapter is being removed then don't do anything.
            //

            if ((savedInterruptData.InterruptFlags & PD_TIMER_CALL_REQUEST) &&
                (!TEST_FLAG(savedInterruptData.InterruptFlags, PD_ADAPTER_REMOVED))) {

                //
                // The miniport wants a timer request. Save the timer parameters.
                //

                if (SpVerifierActive(deviceExtension)) {
                    deviceExtension->VerifierExtension->RealHwTimerRequest = 
                       savedInterruptData.HwTimerRequest;
                    deviceExtension->HwTimerRequest = SpHwTimerRequestVrfy;
                } else {
                    deviceExtension->HwTimerRequest = savedInterruptData.HwTimerRequest;
                }

                //
                // If the requested timer value is zero, then cancel the timer.
                //

                if (savedInterruptData.MiniportTimerValue == 0) {

                    KeCancelTimer(&deviceExtension->MiniPortTimer);

                } else {

                    //
                    // We don't set the timer if we're in the process of shutting down.
                    //
                    
                    if (!TEST_FLAG(deviceExtension->Flags, PD_SHUTDOWN_IN_PROGRESS)) {

                        //
                        // Convert the timer value from mircoseconds to a negative 100
                        // nanoseconds.
                        //

                        timeValue.QuadPart = Int32x32To64(
                                                 savedInterruptData.MiniportTimerValue,
                                                 -10);

                        //
                        // Set the timer.
                        //

                        KeSetTimer(&deviceExtension->MiniPortTimer,
                                   timeValue,
                                   &deviceExtension->MiniPortTimerDpc);

                    }
                }
            }

            //
            // Check for WMI requests from the miniport.
            //

            if (savedInterruptData.InterruptFlags & PD_WMI_REQUEST) {

                SpCompletionDpcProcessWmi(
                    DeviceObject,
                    &savedInterruptData);

            } // wmi request exists from miniport

            if(TEST_FLAG(savedInterruptData.InterruptFlags,
                         PD_BUS_CHANGE_DETECTED)) {

                //
                // Request device enumeration.
                // Force the next bus scan to happen.
                //

                deviceExtension->ForceNextBusScan = TRUE;

                IoInvalidateDeviceRelations(deviceExtension->LowerPdo,
                                            BusRelations);
            }

            if(TEST_FLAG(savedInterruptData.InterruptFlags,
                         PD_INTERRUPT_FAILURE)) {
                SpLogInterruptFailure(deviceExtension);
            }
        }

        //
        // Verify that the ready for next request is ok.
        //

        if (savedInterruptData.InterruptFlags & PD_READY_FOR_NEXT_REQUEST) {

            //
            // If the device busy bit is not set, then this is a duplicate request.
            // If a no disconnect request is executing, then don't call start I/O.
            // This can occur when the miniport does a NextRequest followed by
            // a NextLuRequest.
            //

            if ((deviceExtension->Flags & (PD_DEVICE_IS_BUSY | PD_DISCONNECT_RUNNING))
                == (PD_DEVICE_IS_BUSY | PD_DISCONNECT_RUNNING)) {

                //
                // Clear the device busy flag.  This flag is set by
                // SpStartIoSynchonized.
                //

                deviceExtension->Flags &= ~PD_DEVICE_IS_BUSY;

                if (!(savedInterruptData.InterruptFlags & PD_RESET_HOLD)) {

                    //
                    // The miniport is ready for the next request and there is
                    // not a pending reset hold, so clear the port timer.
                    //

                    deviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;
                }

            } else {

                //
                // If a no disconnect request is executing, then clear the
                // busy flag.  When the disconnect request completes an
                // SpStartNextPacket will be done.
                //

                deviceExtension->Flags &= ~PD_DEVICE_IS_BUSY;

                //
                // Clear the ready for next request flag.
                //

                savedInterruptData.InterruptFlags &= ~PD_READY_FOR_NEXT_REQUEST;
            }
        }

        //
        // Check for any reported resets.
        //

        if (savedInterruptData.InterruptFlags & PD_RESET_REPORTED) {

            //
            // Start the hold timer.
            //

            deviceExtension->PortTimeoutCounter = 
                deviceExtension->ResetHoldTime;
        }

        if (savedInterruptData.ReadyLogicalUnit != NULL) {

            PLOGICAL_UNIT_EXTENSION tmpLogicalUnit;
            //
            // Process the ready logical units.
            //

            for(logicalUnit = savedInterruptData.ReadyLogicalUnit;
                logicalUnit != NULL;
                (tmpLogicalUnit = logicalUnit,
                 logicalUnit = tmpLogicalUnit->ReadyLogicalUnit,
                 tmpLogicalUnit->ReadyLogicalUnit = NULL)) {

                //
                // Get the next request for this logical unit.
                // Note this will release the device spin lock.
                //

                GetNextLuRequest(logicalUnit);

                //
                // Reacquire the device spinlock.
                //

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);
            }
        }

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        //
        // Check for a ready for next packet.
        //

        if (savedInterruptData.InterruptFlags & PD_READY_FOR_NEXT_REQUEST) {

            if (savedInterruptData.InterruptFlags & PD_HELD_REQUEST) {

                //
                // If a request is being held due to a bus reset, do not try
                // to start the next request.  Starting the next request will
                // overwrite the FDO's CurrentIrp field and create problems
                // when the reset hold period expires.
                //
                
            } else {

                //
                // Start the next request.
                //

                SpStartNextPacket(deviceExtension->DeviceObject, FALSE);
            }
        }

        //
        // Check for an error log requests.
        //

        if (savedInterruptData.InterruptFlags & PD_LOG_ERROR) {

            //
            // Process the request.
            //

            LogErrorEntry(deviceExtension,
                          &savedInterruptData.LogEntry);
        }

        //
        // Process any completed requests.  The list has already been cut free
        // and the pointer is never tested except here, so there's no reason to
        // waste cycles unlinking them from the list.  The pointers will be
        // overwritten later.
        //

        callStartIo = FALSE;

        while (savedInterruptData.CompletedRequests != NULL) {

            //
            // Remove the request from the linked-list.
            //

            srbData = savedInterruptData.CompletedRequests;

            ASSERT_SRB_DATA(srbData);
            savedInterruptData.CompletedRequests = srbData->CompletedRequests;
            srbData->CompletedRequests = NULL;

            SpProcessCompletedRequest(deviceExtension,
                                      srbData,
                                      &callStartIo);
        }

        if(callStartIo) {
            ASSERT(DeviceObject->CurrentIrp != NULL);
        }

        //
        // Process any completed abort requests.
        //

        while (savedInterruptData.CompletedAbort != NULL) {

            ASSERT(FALSE);

            logicalUnit = savedInterruptData.CompletedAbort;

            //
            // Remove request from the completed abort list.
            //

            savedInterruptData.CompletedAbort = logicalUnit->CompletedAbort;

            //
            // Acquire the spinlock to protect the flags structure,
            // and the free of the srb extension.
            //

            KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

            //
            // Free SrbExtension to the free list if necessary.
            //

            if (logicalUnit->AbortSrb->SrbExtension) {

                if (SpVerifyingCommonBuffer(deviceExtension)) {

                    SpInsertSrbExtension(deviceExtension,
                                         logicalUnit->AbortSrb->SrbExtension);

                } else { 

                    *((PVOID *) logicalUnit->AbortSrb->SrbExtension) =
                       deviceExtension->SrbExtensionListHeader;

                    deviceExtension->SrbExtensionListHeader =
                       logicalUnit->AbortSrb->SrbExtension;

                }                
            }

            //
            // Note the timer which was started for the abort request is not
            // stopped by the get interrupt routine.  Rather the timer is stopped.
            // when the aborted request completes.
            //

            Irp = logicalUnit->AbortSrb->OriginalRequest;

            //
            // Set IRP status. Class drivers will reset IRP status based
            // on request sense if error.
            //

            if (SRB_STATUS(logicalUnit->AbortSrb->SrbStatus) == SRB_STATUS_SUCCESS) {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            } else {
                Irp->IoStatus.Status = SpTranslateScsiStatus(logicalUnit->AbortSrb);
            }

            Irp->IoStatus.Information = 0;

            //
            // Clear the abort request pointer.
            //

            logicalUnit->AbortSrb = NULL;

            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

            //
            // Decrement the number of active requests.  If the count is negative,
            // and this is a slave with an adapter then free the adapter object and
            // map registers.
            //

            interlockResult = InterlockedDecrement(&deviceExtension->ActiveRequestCount);

            if ( interlockResult < 0 &&
                !deviceExtension->PortConfig->Master &&
                deviceExtension->DmaAdapterObject != NULL ) {

                //
                // Clear the map register base for safety.
                //

                deviceExtension->MapRegisterBase = NULL;

                FreeAdapterChannel(deviceExtension->DmaAdapterObject);

            }

            SpReleaseRemoveLock(DeviceObject, Irp);
            SpCompleteRequest(DeviceObject, Irp, srbData, IO_DISK_INCREMENT);
        }

        //
        // Call the start I/O routine if necessary.
        //

        if (callStartIo) {
            ASSERT(DeviceObject->CurrentIrp != NULL);
            ScsiPortStartIo(DeviceObject, DeviceObject->CurrentIrp);
        }

        //
        // After all of the requested operations have been done check to see
        // if an enable interrupts call request needs to be done.
        //

        if (TEST_FLAG(savedInterruptData.InterruptFlags, PD_ENABLE_CALL_REQUEST) &&
            !TEST_FLAG(savedInterruptData.InterruptFlags, PD_ADAPTER_REMOVED)) {

            //
            // Acquire the spinlock so nothing else starts.
            //

            KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

            deviceExtension->HwRequestInterrupt(deviceExtension->HwDeviceExtension);

            ASSERT(deviceExtension->Flags & PD_DISABLE_CALL_REQUEST);

            //
            // Check to see if interrupts should be enabled again.
            //

            if (deviceExtension->Flags & PD_DISABLE_CALL_REQUEST) {

                //
                // Clear the flag.
                //

                deviceExtension->Flags &= ~PD_DISABLE_CALL_REQUEST;

                //
                // Synchronize with the interrupt routine.
                //

                deviceExtension->SynchronizeExecution(
                    deviceExtension->InterruptObject,
                    SpEnableInterruptSynchronized,
                    deviceExtension
                    );
            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
        }

    } while(((InterlockedCompareExchange(
                        &(deviceExtension->DpcFlags),
                        0L,
                        PD_DPC_RUNNING)) &
             PD_NOTIFICATION_REQUIRED) == PD_NOTIFICATION_REQUIRED);

    return;

} // end ScsiPortCompletionDpc()


BOOLEAN
SpFakeInterrupt(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;

    return ScsiPortInterrupt(adapter->InterruptObject, DeviceObject);
}


VOID
ScsiPortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    PADAPTER_EXTENSION deviceExtension =
        (PADAPTER_EXTENSION) DeviceObject->DeviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PIRP irp;
    ULONG target;
    UNREFERENCED_PARAMETER(Context);

    //
    // Acquire the spinlock to protect the flags structure.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    //
    // Increment the tick count.  This is the only code which will change
    // the count and we're inside a spinlock when we do it so we don't need
    // an interlocked operation.
    //

    deviceExtension->TickCount++;

    //
    // Check whether we need to repopulate the WMI_REQUEST_ITEM
    // free list
    //

    if ((deviceExtension->CommonExtension.WmiInitialized) &&
        (deviceExtension->CommonExtension.WmiMiniPortSupport)) { 

        while (deviceExtension->WmiFreeMiniPortRequestCount <
               deviceExtension->WmiFreeMiniPortRequestWatermark) {

            // Add one to the free list
            if (!NT_SUCCESS(
               SpWmiPushFreeRequestItem(deviceExtension))) {

               //
               // We failed to add, most likely a memory
               // problem, so just stop trying for now
               //

               break;
            }
        }
    }

    //
    // Check for a port timeout or the end of a reset hold period.  Both use
    // the PortTimeoutCounter.  If the counter goes to zero, one of these
    // two conditions has occurred.
    //

    if (deviceExtension->PortTimeoutCounter > 0) {

        BOOLEAN timeout = FALSE;
        BOOLEAN finished = FALSE;

        if (--deviceExtension->PortTimeoutCounter == 0) {

            //
            // On a port timeout or a reset hold termination, we skip the
            // rest of the tick handler processing.
            //

            finished = TRUE;
            
            //
            // Process the port timeout.  If this is really a port timeout
            // and not the termination of a reset hold period, the return
            // value is TRUE.
            //

            timeout = deviceExtension->SynchronizeExecution(
                                           deviceExtension->InterruptObject,
                                           SpTimeoutSynchronized,
                                           DeviceObject);
            
            if (timeout == TRUE) {

                //
                // Log error if SpTimeoutSynchonized indicates this was an error
                // timeout.
                //

                SpLogPortTimeoutError(
                    deviceExtension,
                    256);
            }
        }

        //
        // If we're finished, release the spin lock and return.
        //

        if (finished == TRUE) {
            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
            return;
        }
    }

    //
    // Scan each of the logical units.  If it has an active request then
    // decrement the timeout value and process a timeout if it is zero.
    //

    for (target = 0; target < NUMBER_LOGICAL_UNIT_BINS; target++) {

        PLOGICAL_UNIT_BIN bin;

        bin = &deviceExtension->LogicalUnitList[target];

RestartTimeoutLoop:

        KeAcquireSpinLockAtDpcLevel(&bin->Lock);
        logicalUnit = bin->List;
        while (logicalUnit != NULL) {

            //
            // Check for busy requests.
            //

            if (logicalUnit->LuFlags & LU_LOGICAL_UNIT_IS_BUSY) {

                //
                // If a request sense is needed or the queue is
                // frozen, defer processing this busy request until
                // that special processing has completed. This prevents
                // a random busy request from being started when a REQUEST
                // SENSE needs to be sent.
                //
                // Exception: If the srb is flagged BYPASS_LOCKED_QUEUE, then
                // go ahead and retry it

                PSRB_DATA srbData = logicalUnit->BusyRequest;
                ASSERT_SRB_DATA(srbData);

                if(!(logicalUnit->LuFlags & LU_NEED_REQUEST_SENSE) &&
                   ((!SpIsQueuePaused(logicalUnit)) ||
                    (TEST_FLAG(srbData->CurrentSrb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)))) {

                    DebugPrint((1, "ScsiPortTickHandler: Retrying busy status "
                                "request\n"));

                    //
                    // If there is a pending request, requeue it before we
                    // retry the busy request.  Otherwise, the busy request
                    // will itself get requeued in ScsiPortStartIo because
                    // there is a pending request and if nothing else
                    // remains active, scsiport will stall.
                    //

                    if (logicalUnit->LuFlags & LU_PENDING_LU_REQUEST) {
                        BOOLEAN t;
                        PSRB_DATA pendingRqst;

                        DebugPrint((0, "ScsiPortTickHandler: Requeing pending "
                                    "request %p before starting busy request %p\n",
                                    logicalUnit->PendingRequest,
                                    logicalUnit->BusyRequest->CurrentSrb));

                        CLEAR_FLAG(logicalUnit->LuFlags,
                            LU_PENDING_LU_REQUEST | LU_LOGICAL_UNIT_IS_ACTIVE);

                        pendingRqst = logicalUnit->PendingRequest;
                        logicalUnit->PendingRequest = NULL;

                        t = KeInsertByKeyDeviceQueue(
                                &logicalUnit->DeviceObject->DeviceQueue,
                                &pendingRqst->CurrentIrp->Tail.Overlay.DeviceQueueEntry,
                                pendingRqst->CurrentSrb->QueueSortKey);

                        if (t == FALSE) {
                            KeInsertByKeyDeviceQueue(
                                &logicalUnit->DeviceObject->DeviceQueue,
                                &pendingRqst->CurrentIrp->Tail.Overlay.DeviceQueueEntry,
                                pendingRqst->CurrentSrb->QueueSortKey);
                        }
                    }                    

                    //
                    // Clear the busy flag and retry the request.
                    //

                    logicalUnit->LuFlags &= ~(LU_LOGICAL_UNIT_IS_BUSY |
                                              LU_QUEUE_IS_FULL);

                    //
                    // Clear the busy request.
                    //

                    logicalUnit->BusyRequest = NULL;

                    KeReleaseSpinLockFromDpcLevel(&bin->Lock);
                    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                    
                    srbData->TickCount = deviceExtension->TickCount;

                    //
                    // We must ensure that the busy request gets retried.  If
                    // the busy request is the current IRP on the adapter, then
                    // we just call ScsiPortStartIo directly.  We do this to
                    // ensure that the busy request does not get queued due to
                    // the fact that it is the currently active IRP on the
                    // adapter's device queue.  Otherwise, we just call
                    // IoStartPacket, which will result in the busy request
                    // either queueing on the adapter device queue if another
                    // IRP is currently active or running now if the device
                    // queue is not busy.
                    //

                    if (DeviceObject->CurrentIrp == srbData->CurrentIrp) {
                        ScsiPortStartIo(DeviceObject,
                                        srbData->CurrentIrp);
                    } else {
                        IoStartPacket(DeviceObject,
                                      srbData->CurrentIrp,
                                      NULL,
                                      NULL);
                    }

                    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

                    goto RestartTimeoutLoop;

                } 

            } else if (logicalUnit->RequestTimeoutCounter == 0) {

                RESET_CONTEXT resetContext;

                //
                // Request timed out.
                //

                logicalUnit->RequestTimeoutCounter = PD_TIMER_STOPPED;

                DebugPrint((1,"ScsiPortTickHandler: Request timed out on PDO:%p\n", 
                            logicalUnit->DeviceObject));

                resetContext.DeviceExtension = deviceExtension;
                resetContext.PathId = logicalUnit->PathId;

                //
                // Release the bin spinlock before doing a reset.  There are
                // outstanding requests so the device object shouldn't go away.
                //

                KeReleaseSpinLockFromDpcLevel(&bin->Lock);

                if (!deviceExtension->SynchronizeExecution(
                        deviceExtension->InterruptObject,
                        SpResetBusSynchronized,
                        &resetContext)) {

                    DebugPrint((1,"ScsiPortTickHandler: Reset failed\n"));

                } else {

                    //
                    // Log the reset.
                    //

                    SpLogResetError(deviceExtension, 
                                    logicalUnit, 
                                    ('P'<<24) + 257);
                }

                //
                // List may no longer be valid - restart running the bin.
                //

                goto RestartTimeoutLoop;

            } else if (logicalUnit->RequestTimeoutCounter > 0) {

                //
                // Decrement timeout count.
                //

                logicalUnit->RequestTimeoutCounter--;

            } else if (LU_OPERATING_IN_DEGRADED_STATE(logicalUnit->LuFlags)) {

                //
                // The LU is operating in a degraded performance state.  Update
                // state and restore to full power if conditions permit.
                //

                if (TEST_FLAG(logicalUnit->LuFlags, LU_PERF_MAXQDEPTH_REDUCED)) {

                    //
                    // The LU's maximum queue depth has been reduced because one
                    // or more requests failed with QUEUE FULL status.  If the
                    // adapter is configured to recover from this state it's
                    // RemainInReducedMaxQueueState will be some value other
                    // than the default 0xffffffff.  In this case, we increment
                    // the number of ticks the LU has been in this state and
                    // recover when we've reached the specified period.
                    //

                    if (deviceExtension->RemainInReducedMaxQueueState != 0xffffffff &&
                        ++logicalUnit->TicksInReducedMaxQueueDepthState >=
                        deviceExtension->RemainInReducedMaxQueueState) {

                        CLEAR_FLAG(logicalUnit->LuFlags, LU_PERF_MAXQDEPTH_REDUCED);
                        logicalUnit->MaxQueueDepth = 0xff;

                    }
                }
            }

            logicalUnit = logicalUnit->NextLogicalUnit;
        }

        KeReleaseSpinLockFromDpcLevel(&bin->Lock);
    }

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    //
    // Check to see if there are any requests waiting for memory to free up.
    //

    do {
        PLIST_ENTRY entry;
        PIRP request;
        PSRB_DATA srbData;
        BOOLEAN listIsEmpty;

        //
        // Grab the spinlock long enough to pull a request off the queue.
        // The spinlock needs to be released when we're allocating
        // memory.
        //

        KeAcquireSpinLockAtDpcLevel(
            &deviceExtension->EmergencySrbDataSpinLock);

        if(IsListEmpty(&deviceExtension->SrbDataBlockedRequests)) {
            if(deviceExtension->BlockedLogicalUnit !=
                (PLOGICAL_UNIT_EXTENSION)&deviceExtension->BlockedLogicalUnit) {
                SpTransferBlockedRequestsToAdapter(deviceExtension);
                entry = RemoveHeadList(
                    &(deviceExtension->SrbDataBlockedRequests));
            } else {
                entry = NULL;
            }
        } else {
            entry = RemoveHeadList(&(deviceExtension->SrbDataBlockedRequests));
        }
        
        KeReleaseSpinLockFromDpcLevel(
            &deviceExtension->EmergencySrbDataSpinLock);

        if(entry == NULL) {
            break;
        }

        request = CONTAINING_RECORD(
                    entry,
                    IRP,
                    Tail.Overlay.DeviceQueueEntry);

        ASSERT(request->Type == IO_TYPE_IRP);

        //
        // See if we can get an SRB_DATA for this request.  This will
        // requeue the request if there's still not enough free memory.
        //

        srbData = SpAllocateSrbData(deviceExtension,
                                    request,
                                    NULL);

        if(srbData != NULL) {

            PLOGICAL_UNIT_EXTENSION luExtension;
            PIO_STACK_LOCATION currentIrpStack;
            PSCSI_REQUEST_BLOCK srb;

            currentIrpStack = IoGetCurrentIrpStackLocation(request);
            srb = currentIrpStack->Parameters.Scsi.Srb;
            luExtension = currentIrpStack->DeviceObject->DeviceExtension;

            ASSERT_PDO(currentIrpStack->DeviceObject);

            srbData->CurrentIrp = request;
            srbData->CurrentSrb = srb;
            srbData->LogicalUnit = luExtension;

            srb->OriginalRequest = srbData;

            SpDispatchRequest(currentIrpStack->DeviceObject->DeviceExtension,
                              request);

#if TEST_LISTS
            InterlockedIncrement64(
                &deviceExtension->SrbDataServicedFromTickHandlerCount);
#endif

        } else {
            break;
        }

    } while(TRUE);

    return;

} // end ScsiPortTickHandler()


NTSTATUS
SpHandleIoctlStorageQueryProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    PAGED_CODE();

    //
    // The input buffer must be large enough to hold a valid 
    // STORAGE_PROPERTY_QUERY structure.
    //

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < 
        sizeof(STORAGE_PROPERTY_QUERY)) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        status = ScsiPortQueryProperty(DeviceObject, Irp);
    }

    //
    // Release the remove lock and complete the request.
    //
    
    ASSERT(status != STATUS_PENDING);
    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
        
    return status;
}

NTSTATUS
SpHandleIoctlScsiGetCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
        < sizeof(IO_SCSI_CAPABILITIES)) {
        
        //
        // The output buffer is not large enough to hold an IO_SCSI_CAPABILITIES
        // structure, so we fail.
        //

        status = STATUS_BUFFER_TOO_SMALL;
        
    } else {

        //
        // Output buffer is good. Copy the capabilities data into the supplied
        // buffer and set the Information field to the number of bytes we
        // copy.
        //

        RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer,
                      &deviceExtension->Capabilities,
                      sizeof(IO_SCSI_CAPABILITIES));
        Irp->IoStatus.Information = sizeof(IO_SCSI_CAPABILITIES);
        status = STATUS_SUCCESS;
    }
    
    //
    // Release the remove lock and complete the request.
    //

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
SpHandleIoctlScsiPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN Direct
    )
{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Process the passthrough request.
    //

    status = SpSendPassThrough(deviceExtension, Irp, Direct);

    //
    // Release the remove lock and complete the request.
    //

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
SpHandleIoctlScsiMiniport(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Process the miniport ioctl request.
    //

    status = SpSendMiniPortIoctl(deviceExtension, Irp);

    //
    // Release the remove lock and complete the request.
    //

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
SpHandleIoctlScsiGetInquiryData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Process the request.
    //

    status = SpGetInquiryData(deviceExtension, Irp);

    //
    // Release the remove lock and complete the request.
    //

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
SpHandleIoctlScsiRescanBus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Rescan the adapter.  This scans all buses supported by the adapter.
    //

    status = SpEnumerateAdapterSynchronous(deviceExtension, FALSE);
    
    //
    // Invalidate device relations on the adapter PDO so PNP will query
    // us for our bus relations.
    //

    IoInvalidateDeviceRelations(deviceExtension->LowerPdo, BusRelations);

    //
    // Release the remove lock and complete the request.
    //

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
SpHandleIoctlScsiGetDumpPointers(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PPORT_CONFIGURATION_INFORMATION portConfigCopy;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Get parameters for crash dump driver.
    //

    if (Irp->RequestorMode != KernelMode) {

        status = STATUS_ACCESS_DENIED;

    } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
               < sizeof(DUMP_POINTERS)) {

        status = STATUS_BUFFER_TOO_SMALL;

    } else {

        PDUMP_POINTERS dumpPointers =
            (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

        RtlZeroMemory(dumpPointers, sizeof(DUMP_POINTERS));

        dumpPointers->AdapterObject = (PVOID)deviceExtension->DmaAdapterObject;
        dumpPointers->MappedRegisterBase = &deviceExtension->MappedAddressList;

        portConfigCopy = SpAllocatePool(
                             NonPagedPool,
                             sizeof(PORT_CONFIGURATION_INFORMATION),
                             SCSIPORT_TAG_PORT_CONFIG,
                             DeviceObject->DriverObject);

        if (portConfigCopy == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlCopyMemory(portConfigCopy,
                          deviceExtension->PortConfig,
                          sizeof(PORT_CONFIGURATION_INFORMATION));

            if (deviceExtension->IsInVirtualSlot) {
                portConfigCopy->SlotNumber = deviceExtension->RealSlotNumber;
                portConfigCopy->SystemIoBusNumber = 
                    deviceExtension->RealBusNumber;
            }

            dumpPointers->DumpData = portConfigCopy;
            dumpPointers->CommonBufferVa = deviceExtension->SrbExtensionBuffer;
            dumpPointers->CommonBufferPa = 
                deviceExtension->PhysicalCommonBuffer;

            dumpPointers->CommonBufferSize = 
                SpGetCommonBufferSize(
                    deviceExtension,
                    deviceExtension->NonCachedExtensionSize,
                    NULL);

            dumpPointers->AllocateCommonBuffers = TRUE;

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(DUMP_POINTERS);
        }
    }

    //
    // Release the remove lock and complete the request.
    //

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
SpHandleIoctlStorageBreakReservation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PPORT_CONFIGURATION_INFORMATION portConfigCopy;
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;
    BOOLEAN completeRequest = TRUE;

    PAGED_CODE();

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(STORAGE_BUS_RESET_REQUEST)) {
        ReturnStatus = status = STATUS_INVALID_PARAMETER;
    }

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength >= sizeof(SCSI_ADDRESS)) {
        PSCSI_ADDRESS scsiAddress = (PSCSI_ADDRESS)Irp->AssociatedIrp.SystemBuffer;
        if (scsiAddress->Length != sizeof(SCSI_ADDRESS)) {
            ReturnStatus = status = STATUS_INVALID_PARAMETER;
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Send an asynchronous srb through to ourself to handle this
        // reset then return.  SpSendReset will take care of completing
        // the request when it's done
        //

        IoMarkIrpPending(Irp);

        status = SpSendReset(
                     DeviceObject, 
                     Irp, 
                     irpStack->Parameters.DeviceIoControl.IoControlCode,
                     &completeRequest);

        if (!NT_SUCCESS(status)) {
            DebugPrint((1, "IOCTL_STORAGE_BREAK_RESERVATION - error %#08lx "
                        "from SpSendReset completeRequest=%d\n", status,
                        completeRequest));
        }

        ReturnStatus = STATUS_PENDING;
    } 

    //
    // Release the remove lock and complete the request.
    //

    if (completeRequest) {
        Irp->IoStatus.Status = status;
        SpReleaseRemoveLock(DeviceObject, Irp);
        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
    }

    return ReturnStatus;
}

NTSTATUS
SpHandleIoctlStorageResetBus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PPORT_CONFIGURATION_INFORMATION portConfigCopy;
    NTSTATUS status;
    BOOLEAN completeRequest = TRUE;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;

    PAGED_CODE();

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(STORAGE_BUS_RESET_REQUEST)) {

        ReturnStatus = status = STATUS_INVALID_PARAMETER;

    } else {

        //
        // Send an asynchronous srb through to ourself to handle this
        // reset then return.  SpSendReset will take care of completing
        // the request when it's done
        //

        IoMarkIrpPending(Irp);

        status = SpSendReset(
                     DeviceObject, 
                     Irp, 
                     irpStack->Parameters.DeviceIoControl.IoControlCode,
                     &completeRequest);

        if (!NT_SUCCESS(status)) {
            DebugPrint((1, "IOCTL_STORAGE_RESET_BUS - error %#08lx "
                        "from SpSendReset completeRequest=%d\n", status,
                        completeRequest));
        }
        ReturnStatus = STATUS_PENDING;
    }

    //
    // Release the remove lock and complete the request.
    //

    if (completeRequest) {
        Irp->IoStatus.Status = status;
        SpReleaseRemoveLock(DeviceObject, Irp);
        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
    }

    return ReturnStatus;
}

NTSTATUS
ScsiPortFdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the device control dispatcher.

Arguments:

    DeviceObject
    Irp

Return Value:


    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG isRemoved;

    PAGED_CODE();

    //
    // Initialize the information field.
    //

    Irp->IoStatus.Information = 0;

    //
    // Acquire a remove lock on the adapter on behalf of the IRP.  Each IOCTL
    // handler routine releases the remove lock in a manner appropriate to its
    // behavior.
    //

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);
    if (isRemoved) {

        //
        // The adapter has been removed.  We must fail this request.
        //

        status = STATUS_DEVICE_DOES_NOT_EXIST;
    } else {

        //
        // Set the adapter into a valid power state.  If this fails, we must
        // fail the request.
        //

        status = SpRequestValidAdapterPowerStateSynchronous(deviceExtension);
    }

    //
    // Handle the request if there are no problems.  Else, just complete the
    // request and return.  The respective handler routine will release the
    // remove lock as appropriate.
    //

    if (NT_SUCCESS(status)) {
        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

            case IOCTL_STORAGE_QUERY_PROPERTY: 
                return SpHandleIoctlStorageQueryProperty(DeviceObject, Irp);

            case IOCTL_SCSI_GET_CAPABILITIES: 
                return SpHandleIoctlScsiGetCapabilities(DeviceObject, Irp);

            case IOCTL_SCSI_PASS_THROUGH:
                return SpHandleIoctlScsiPassThrough(DeviceObject, Irp, FALSE);

            case IOCTL_SCSI_PASS_THROUGH_DIRECT:
                return SpHandleIoctlScsiPassThrough(DeviceObject, Irp, TRUE);

            case IOCTL_SCSI_MINIPORT:
                return SpHandleIoctlScsiMiniport(DeviceObject, Irp);

            case IOCTL_SCSI_GET_INQUIRY_DATA: 
                return SpHandleIoctlScsiGetInquiryData(DeviceObject, Irp);

            case IOCTL_SCSI_RESCAN_BUS:
                return SpHandleIoctlScsiRescanBus(DeviceObject, Irp);

            case IOCTL_SCSI_GET_DUMP_POINTERS: 
                return SpHandleIoctlScsiGetDumpPointers(DeviceObject, Irp);

            case IOCTL_STORAGE_RESET_BUS:
            case OBSOLETE_IOCTL_STORAGE_RESET_BUS:
                return SpHandleIoctlStorageResetBus(DeviceObject, Irp);

            case IOCTL_STORAGE_BREAK_RESERVATION: 
                return SpHandleIoctlStorageBreakReservation(DeviceObject, Irp);

            default:
                DebugPrint((
                    1,
                    "ScsiPortDeviceControl: Unsupported IOCTL (%x)\n",
                    irpStack->Parameters.DeviceIoControl.IoControlCode));

                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
        }
    }

    Irp->IoStatus.Status = status;
    SpReleaseRemoveLock(DeviceObject, Irp);
    SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
    return status;
}


BOOLEAN
SpStartIoSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine calls the dependent driver start io routine.
    It also starts the request timer for the logical unit if necesary and
    inserts the SRB data structure in to the requset list.

Arguments:

    ServiceContext - Supplies the pointer to the device object.

Return Value:

    Returns the value returned by the dependent start I/O routine.

Notes:

    The port driver spinlock must be held when this routine is called.  Holding
    this lock will keep any logical unit bins from being changed as well.

--*/

{
    PDEVICE_OBJECT deviceObject = ServiceContext;
    PADAPTER_EXTENSION deviceExtension =  deviceObject->DeviceExtension;
    PINTERRUPT_DATA interruptData = &(deviceExtension->InterruptData);
    PIO_STACK_LOCATION irpStack;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK srb;
    PSRB_DATA srbData;
    BOOLEAN returnValue;

    DebugPrint((3, "ScsiPortStartIoSynchronized: Enter routine\n"));

    irpStack = IoGetCurrentIrpStackLocation(deviceObject->CurrentIrp);
    srb = irpStack->Parameters.Scsi.Srb;
    srbData = srb->OriginalRequest;

    ASSERT_SRB_DATA(srbData);

    //
    // Get the logical unit extension.
    //

    logicalUnit = srbData->LogicalUnit;

    //
    // Cache the logical unit for complete request calls.
    //

    deviceExtension->CachedLogicalUnit = logicalUnit;

    //
    // Check for a reset hold.  If one is in progress then flag it and return.
    // The timer will reset the current request.  This check should be made
    // before anything else is done.
    //

    if(TEST_FLAG(interruptData->InterruptFlags, PD_ADAPTER_REMOVED)) {

        srb->SrbStatus = SRB_STATUS_NO_HBA;
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE |
                                SRB_FLAGS_BYPASS_FROZEN_QUEUE);

    } else if(TEST_FLAG(interruptData->InterruptFlags, PD_RESET_HOLD)) {
        SET_FLAG(interruptData->InterruptFlags, PD_HELD_REQUEST);
        return(TRUE);
    }

    //
    // Set the device busy flag to indicate it is ok to start the next request.
    //

    deviceExtension->Flags |= PD_DEVICE_IS_BUSY;

    if (srb->SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT) {

        //
        // This request does not allow disconnects. Remember that so
        // no more requests are started until this one completes.
        //

        deviceExtension->Flags &= ~PD_DISCONNECT_RUNNING;
    }

    logicalUnit->QueueCount++;

    //
    // Indicate that there maybe more requests queued, if this is not a bypass
    // request.
    //

    if(!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

        logicalUnit->LuFlags |= LU_LOGICAL_UNIT_IS_ACTIVE;

    } else {

        ASSERT(srb->Function != SRB_FUNCTION_ABORT_COMMAND);

        //
        // Any untagged request that bypasses the queue
        // clears the need request sense flag.
        //

        if(SpSrbIsBypassRequest(srb, logicalUnit->LuFlags)) {
            logicalUnit->LuFlags &= ~LU_NEED_REQUEST_SENSE;
        }

        //
        // Set the timeout value in the logical unit.
        //

        logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;
    }

    //
    // Mark the Srb as active.
    //

    srb->SrbFlags |= SRB_FLAGS_IS_ACTIVE;

    //
    // Save away the tick count when we made this active.
    //

    srbData->TickCount = deviceExtension->TickCount;

    //
    // If this request is tagged, insert it into the logical unit
    // request list.  Note that bypass requsts are never never placed on
    // the request list.  In particular ABORT requests which may have
    // a queue tag specified are not placed on the queue.
    //

    if (srb->QueueTag != SP_UNTAGGED) {

        InsertTailList(&logicalUnit->RequestList,
                       &srbData->RequestList);

    } else {

        logicalUnit->CurrentUntaggedRequest = srbData;
    }

    //
    // if the status in the SRB is still pending then we should go ahead and
    // issue this request to to the miniport.  Some error conditions and
    // power requests will mark the srb as successful and then send it through
    // here to clean up and start subsequent requests.  If the status isn't
    // pending then request completion.
    //

    if(srb->SrbStatus != SRB_STATUS_PENDING) {

        DebugPrint((1, "SpStartIoSynchronized: Completeing successful srb "
                       "%#p before miniport\n", srb));

        ScsiPortNotification(RequestComplete,
                             deviceExtension->HwDeviceExtension,
                             srb);

        ScsiPortNotification(NextRequest,
                             deviceExtension->HwDeviceExtension);

        returnValue = srb->SrbStatus;

    } else {

        //
        // Start the port timer.  This ensures that the miniport asks for
        // the next request in a resonable amount of time.
        //

        deviceExtension->PortTimeoutCounter = srb->TimeOutValue;

        //
        // Start the logical unit timer if it is not currently running.
        //

        if (logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

            //
            // Set request timeout value from Srb SCSI extension in Irp.
            //

            logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;
        }

        returnValue = deviceExtension->HwStartIo(
                                        deviceExtension->HwDeviceExtension,
                                        srb);
    }

    //
    // Check for miniport work requests.
    //

    if (TEST_FLAG(interruptData->InterruptFlags, PD_NOTIFICATION_REQUIRED)) {

        SpRequestCompletionDpc(deviceObject);
    }

    return returnValue;

} // end SpStartIoSynchronized()


BOOLEAN
SpTimeoutSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine handles a port timeout.  There are two reason these can occur
    either because of a reset hold or a time out waiting for a read for next
    request notification.  If a reset hold completes, then any held request
    must be started.  If a timeout occurs, then the bus must be reset.

Arguments:

    ServiceContext - Supplies the pointer to the device object.

Return Value:

    TRUE - If a timeout error should be logged.

Notes:

    The port driver spinlock must be held when this routine is called.

--*/

{
    PDEVICE_OBJECT deviceObject = ServiceContext;
    PADAPTER_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PINTERRUPT_DATA interruptData = &(deviceExtension->InterruptData);
    BOOLEAN result;

    DebugPrint((3, "SpTimeoutSynchronized: Enter routine\n"));

    //
    // Make sure the timer is stopped.
    //

    deviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;

    //
    // Check for a reset hold.  If one is in progress then clear it and check
    // for a pending held request
    //

    if (TEST_FLAG(interruptData->InterruptFlags, PD_RESET_HOLD)) {

        CLEAR_FLAG(interruptData->InterruptFlags, PD_RESET_HOLD);

        //
        // If verifier is enabled, make sure the miniport has completed all
        // outstanding requests in the reset hold period.
        //

        if (SpVerifierActive(deviceExtension)) {
            SpEnsureAllRequestsAreComplete(deviceExtension);
        }

        if (TEST_FLAG(interruptData->InterruptFlags, PD_HELD_REQUEST)) {

            //
            // Clear the held request flag and restart the request.
            //

            CLEAR_FLAG(interruptData->InterruptFlags, PD_HELD_REQUEST);
            SpStartIoSynchronized(ServiceContext);
        }

        result = FALSE;

    } else {

        RESET_CONTEXT resetContext;
        BOOLEAN interrupt;
        ULONG interruptCount;

        resetContext.DeviceExtension = deviceExtension;

        //
        // Make a call into the miniport's interrupt routine.  If it says that
        // there's an interrupt pending then break in.
        //

        ASSERT(!TEST_FLAG(interruptData->InterruptFlags,
                          PD_DISABLE_INTERRUPTS));

        if (!TEST_FLAG(interruptData->InterruptFlags, PD_ADAPTER_REMOVED)) {

            interruptCount = deviceExtension->WatchdogInterruptCount;
            deviceExtension->WatchdogInterruptCount = 0;

            if((interruptCount == 0) &&
               (deviceExtension->HwInterrupt != NULL)) {

                interrupt = deviceExtension->HwInterrupt(
                                deviceExtension->HwDeviceExtension);

                if(interrupt) {

                    DbgPrint("SpTimeoutSynchronized: Adapter %#p had interrupt "
                             "pending - the system may not be delivering "
                             "interrupts from this adapter\n",
                             deviceObject);

                    if(ScsiCheckInterrupts) {
                        DbgBreakPoint();
                    }

                    SET_FLAG(interruptData->InterruptFlags,
                             PD_INTERRUPT_FAILURE | PD_NOTIFICATION_REQUIRED);
                    SpRequestCompletionDpc(deviceObject);
                }
            }
        }

        //
        // Miniport is hung and not accepting new requests. So reset the
        // bus to clear things up.
        //

        DebugPrint((1, "SpTimeoutSynchronized: Next request timed out. "
                       "Resetting bus\n"));

        for(resetContext.PathId = 0;
            resetContext.PathId < deviceExtension->NumberOfBuses;
            resetContext.PathId++) {

            result = SpResetBusSynchronized(&resetContext);
        }
    }

    return(result);

} // end SpTimeoutSynchronized()

BOOLEAN
SpEnableInterruptSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine calls the miniport request routine with interrupts disabled.
    This is used by the miniport driver to enable interrupts on the adapter.
    This routine clears the disable interrupt flag which prevents the
    miniport interrupt routine from being called.

Arguments:

    ServiceContext - Supplies the pointer to the device extension.

Return Value:

    TRUE - Always.

Notes:

    The port driver spinlock must be held when this routine is called.

--*/

{
    PADAPTER_EXTENSION deviceExtension =  ServiceContext;
    PINTERRUPT_DATA interruptData = &(deviceExtension->InterruptData);

    //
    // Clear the interrupt disable flag.
    //

    CLEAR_FLAG(interruptData->InterruptFlags, PD_DISABLE_INTERRUPTS);

    if(TEST_FLAG(interruptData->InterruptFlags, PD_ADAPTER_REMOVED)) {
        return FALSE;
    }

    //
    // Call the miniport routine.
    //

    deviceExtension->HwRequestInterrupt(deviceExtension->HwDeviceExtension);

    if(TEST_FLAG(interruptData->InterruptFlags, PD_NOTIFICATION_REQUIRED)) {

        SpRequestCompletionDpc(deviceExtension->CommonExtension.DeviceObject);

    }

    return(TRUE);

} // end SpEnableInterruptSynchronized()

VOID
IssueRequestSense(
    IN PADAPTER_EXTENSION Adapter,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    )

/*++

Routine Description:

    This routine creates a REQUEST SENSE request and uses IoCallDriver to
    renter the driver.  The completion routine cleans up the data structures
    and processes the logical unit queue according to the flags.

    A pointer to failing SRB is stored at the end of the request sense
    Srb, so that the completion routine can find it.

    This routine must be called holding the remove lock.

Arguments:

    DeviceExension - Supplies a pointer to the device extension for this
        SCSI port.

    FailingSrb - Supplies a pointer to the request that the request sense
        is being done for.

Return Value:

    None.

--*/

{
    PSRB_DATA srbData;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    BOOLEAN blocked;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DebugPrint((3,"IssueRequestSense: Enter routine\n"));

    //
    // Find the logical unit for this request and see if there's already a
    // request sense in progress.
    //

    srbData = FailingSrb->OriginalRequest;

    ASSERT_SRB_DATA(srbData);

    logicalUnit = srbData->LogicalUnit;

    KeAcquireSpinLockAtDpcLevel(&(logicalUnit->AdapterExtension->SpinLock));

    //
    // If we already have an active failed request then block this one -
    // the completion routine will issue a new request sense irp when this
    // one is run.
    //

    if(logicalUnit->ActiveFailedRequest == srbData) {
        blocked = FALSE;
    } else if(logicalUnit->BlockedFailedRequest == srbData) {
        blocked = TRUE;
    } else {
        blocked = FALSE;
        DbgPrint("Scsiport: unexpected request sense for srb %#08lx\n", FailingSrb);
        ASSERT(FALSE);
    }

    KeReleaseSpinLockFromDpcLevel(&(logicalUnit->AdapterExtension->SpinLock));

    if(blocked == FALSE) {
        SpSendRequestSenseIrp(Adapter,
                              logicalUnit,
                              FailingSrb);
    }

    return;

} // end IssueRequestSense()


VOID
SpSendRequestSenseIrp(
    IN PADAPTER_EXTENSION Adapter,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    )

/*++

Routine Description:

    This routine creates a REQUEST SENSE request and uses IoCallDriver to
    renter the driver.  The completion routine cleans up the data structures
    and processes the logical unit queue according to the flags.

    This routine must be called holding the remove lock.  The caller must also
    ensure that no other failed request is using the preallocated resources in
    the LogicalUnit extension.

Arguments:

    Adapter - Supplies a pointer to the device extension for this SCSI port.

    LogicalUnit - Supplies a pointer to logical unit on which the CA condition
                  exists.  This extension contains the resources used to send
                  the REQUEST_SENSE irp.

    FailingSrb - the request which failed.  the sense info buffer, address
                 info and flags are pulled out of this request.

Return Value:

    None.

--*/

{
    PIRP irp;
    PSCSI_REQUEST_BLOCK srb;
    PMDL mdl;

    PIO_STACK_LOCATION irpStack;
    PCDB cdb;
    PVOID *pointer;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DebugPrint((3,"SpSendRequestSenseIrp: Enter routine\n"));

    //
    // Check if we are being asked to try to allocate a sense buffer of 
    // the correct size for the adapter.  If the allocation fails, just 
    // use the one passed down to us.  The driver that supplied the buffer 
    // is responsible for freeing the one we allocate.
    //

    if (FailingSrb->SrbFlags & SRB_FLAGS_PORT_DRIVER_ALLOCSENSE) {

        ULONG BufferSize;
        PSENSE_DATA SenseBuffer;
        UCHAR SenseBufferLength;
        
        SenseBufferLength = sizeof(SENSE_DATA) 
                            + Adapter->AdditionalSenseBytes;

        //
        // Include space for the scsi port number in the buffer,
        // aligned on a 4-byte boundary.  In checked builds, a signature
        // will precede the port number.
        //

        BufferSize = (SenseBufferLength + 3) & ~3;
        BufferSize = SenseBufferLength + sizeof(ULONG64);
        
        SenseBuffer = SpAllocatePool(NonPagedPoolCacheAligned,
                                     BufferSize,
                                     SCSIPORT_TAG_SENSE_BUFFER,
                                     Adapter->DeviceObject->DriverObject);

        if (SenseBuffer != NULL) {
        
            PULONG PortNumber;

            //
            // Set a flag in the SRB to indicate that we have allocated
            // a new sense buffer and that the class driver must free
            // it.
            //

            SET_FLAG(FailingSrb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER);

            //
            // Set a flag in the SRB the indicates we are storing the
            // scsi port number at the end of the sense buffer.
            //

            SET_FLAG(FailingSrb->SrbFlags, SRB_FLAGS_PORT_DRIVER_SENSEHASPORT);

            //
            // Copy the port number in the buffer.
            //

            PortNumber = (PULONG)((PUCHAR)SenseBuffer + SenseBufferLength);
            PortNumber = (PULONG)(((ULONG_PTR)PortNumber + 3) & ~3);
            *PortNumber = Adapter->PortNumber;

            FailingSrb->SenseInfoBuffer = SenseBuffer;
            FailingSrb->SenseInfoBufferLength = SenseBufferLength;
        }
    }

    irp = LogicalUnit->RequestSenseIrp;
    srb = &(LogicalUnit->RequestSenseSrb);
    mdl = &(LogicalUnit->RequestSenseMdl);

    IoInitializeIrp(irp, IoSizeOfIrp(1), 1);

    MmInitializeMdl(mdl,
                    FailingSrb->SenseInfoBuffer,
                    FailingSrb->SenseInfoBufferLength);

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // The sense buffer had better be from non-pagable kernel memory.
    //

    MmBuildMdlForNonPagedPool(mdl);

    irp->MdlAddress = mdl;

    IoSetCompletionRoutine(irp,
                           IssueRequestSenseCompletion,
                           LogicalUnit,
                           TRUE,
                           TRUE,
                           TRUE);

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    //
    // Build the REQUEST SENSE CDB.
    //

    srb->CdbLength = 6;
    cdb = (PCDB)srb->Cdb;

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.LogicalUnitNumber = 0;
    cdb->CDB6INQUIRY.Reserved1 = 0;
    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.AllocationLength = FailingSrb->SenseInfoBufferLength;
    cdb->CDB6INQUIRY.Control = 0;

    //
    // Save SRB address in next stack for port driver.
    //

    irpStack->Parameters.Scsi.Srb = srb;

    //
    // Set up IRP Address.
    //

    srb->OriginalRequest = irp;

    //
    // Set up SCSI bus address.
    //

    srb->TargetId = LogicalUnit->TargetId;
    srb->Lun = LogicalUnit->Lun;
    srb->PathId = LogicalUnit->PathId;

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set timeout value.  Default is 10 seconds, but it's configurable.
    //

    srb->TimeOutValue = Adapter->SrbTimeout;

    //
    // Disable auto request sense.
    //

    srb->SenseInfoBufferLength = 0;

    //
    // Sense buffer is in stack.
    //

    srb->SenseInfoBuffer = NULL;

    //
    // Set read and bypass frozen queue bits in flags.
    //

    //
    // Set SRB flags to indicate the logical unit queue should be by
    // passed and that no queue processing should be done when the request
    // completes.  Also disable disconnect and synchronous data
    // transfer if necessary.
    //

    srb->SrbFlags = SRB_FLAGS_DATA_IN |
                    SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                    SRB_FLAGS_DISABLE_DISCONNECT;


    if(TEST_FLAG(FailingSrb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE)) {
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);
    }

    if (TEST_FLAG(FailingSrb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE);
    }

    if (TEST_FLAG(FailingSrb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER)) {
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
    }

    srb->DataBuffer = FailingSrb->SenseInfoBuffer;

    //
    // Set the transfer length.
    //

    srb->DataTransferLength = FailingSrb->SenseInfoBufferLength;

    //
    // Zero out status.
    //

    srb->ScsiStatus = srb->SrbStatus = 0;

    srb->NextSrb = 0;

    IoCallDriver(LogicalUnit->DeviceObject, irp);

    return;

} // end SpSendRequestSenseIrp()


NTSTATUS
IssueRequestSenseCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

Arguments:

    Device object
    IRP
    Context - pointer to SRB

Return Value:

    NTSTATUS

--*/

{
    PSCSI_REQUEST_BLOCK srb = &(LogicalUnit->RequestSenseSrb);
    PSRB_DATA failingSrbData = LogicalUnit->ActiveFailedRequest;
    PSCSI_REQUEST_BLOCK failingSrb;
    PIRP failingIrp;
    PDEVICE_OBJECT deviceObject;
    KIRQL oldIrql;
    BOOLEAN needRequestSense;

    UNREFERENCED_PARAMETER(DeviceObject);

    DebugPrint((3,"IssueRequestSenseCompletion: Enter routine\n"));

    //
    // Request sense completed. If successful or data over/underrun
    // get the failing SRB and indicate that the sense information
    // is valid. The class driver will check for underrun and determine
    // if there is enough sense information to be useful.
    //

    //
    // Get a pointer to failing Irp and Srb.
    //

    ASSERT_SRB_DATA(failingSrbData);
    failingSrb = failingSrbData->CurrentSrb;
    failingIrp = failingSrbData->CurrentIrp;
    deviceObject = LogicalUnit->AdapterExtension->DeviceObject;

    if(failingIrp->PendingReturned) {
        IoMarkIrpPending(failingIrp);
    }

    ASSERT(Irp->IoStatus.Status != STATUS_INSUFFICIENT_RESOURCES);

    if ((SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) ||
        (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN)) {

        //
        // Report sense buffer is valid.
        //

        failingSrb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;

        //
        // Copy bytes transferred to failing SRB
        // request sense length field to communicate
        // to the class drivers the number of valid
        // sense bytes.
        //

        failingSrb->SenseInfoBufferLength = (UCHAR) srb->DataTransferLength;

        //
        // If WMI Sense Data events are enabled for this adapter, fire
        // the event.
        //

        if (LogicalUnit->AdapterExtension->EnableSenseDataEvent) {

            NTSTATUS status;

            status = SpFireSenseDataEvent(failingSrb, deviceObject);
            if (status != STATUS_SUCCESS) {

                DebugPrint((1, "Failed to send SenseData WMI event (%08X)\n", status));

            }                
        }
    }

    //
    // If the failing SRB had the no queue freeze flag set then unfreeze the
    // queue.
    //

    if(TEST_FLAG(failingSrb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE) &&
       TEST_FLAG(failingSrb->SrbStatus, SRB_STATUS_QUEUE_FROZEN)) {

        //
        // Now release the queue.
        //

        SpFlushReleaseQueue(LogicalUnit, FALSE, FALSE);
        CLEAR_FLAG(failingSrb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
    }

    //
    // Clear the active request.  Promote the blocked request (if any) and
    // send out a new request sense if necessary.
    //

    KeAcquireSpinLock(&(LogicalUnit->AdapterExtension->SpinLock), &oldIrql);

    LogicalUnit->ActiveFailedRequest = LogicalUnit->BlockedFailedRequest;
    LogicalUnit->BlockedFailedRequest = NULL;
    needRequestSense = (LogicalUnit->ActiveFailedRequest != NULL);

    KeReleaseSpinLock(&(LogicalUnit->AdapterExtension->SpinLock), oldIrql);

    //
    // Complete the failing request.
    //

    SpReleaseRemoveLock(deviceObject, failingIrp);
    SpCompleteRequest(deviceObject,
                      failingIrp,
                      failingSrbData,
                      IO_DISK_INCREMENT);

    //
    // Reinitialize all the data structures.
    //

    MmPrepareMdlForReuse(&(LogicalUnit->RequestSenseMdl));

    //
    // Since we promoted the blocked request up we can test the active
    // request pointer without holding the spinlock.  Once that's been written
    // in there no one can modify it unless they're completing a request
    // sense irp and we've got the only one right here.
    //

    if(needRequestSense) {

        SpSendRequestSenseIrp(LogicalUnit->AdapterExtension,
                              LogicalUnit,
                              LogicalUnit->ActiveFailedRequest->CurrentSrb);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

} // ScsiPortInternalCompletion()

#if DBG
VOID
SpDetectCycleInCompletedRequestList(
    IN PINTERRUPT_CONTEXT InterruptContext
    )
{
    PSRB_DATA s1, s2;

    DebugPrint((0, "SpDetectCycleInCompletedRequestList: context %p\n", 
                InterruptContext));

    //
    // Initialize two pointers to the head of the list.
    //

    s1 = s2 = InterruptContext->SavedInterruptData->CompletedRequests;

    //
    // We know the list is not empty so there is no need to check for that 
    // case.  The scan will end when either the end of the list is found or 
    // both pointers point to the same item.
    //

    for (;;) {

        //
        // Update the pointers.
        //

        s1 = s1->CompletedRequests;
        s2 = s2->CompletedRequests;
        if (s2 != NULL) {
            s2 = s2->CompletedRequests;
        }

        //
        // If we've found the end of the list, we're done.
        //

        if (s2 == NULL) {
            break;
        }

        //
        // If both pointers point to the same item, we've found a cycle.
        //

        if (s1 == s2) {
            KeBugCheckEx(PORT_DRIVER_INTERNAL,
                         5,
                         STATUS_INTERNAL_ERROR,
                         (ULONG_PTR) InterruptContext,
                         (ULONG_PTR) 0);
        }
    }
}
#endif


BOOLEAN
SpGetInterruptState(
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine saves the InterruptFlags, MapTransferParameters and
    CompletedRequests fields and clears the InterruptFlags.

    This routine also removes the request from the logical unit queue if it is
    tag.  Finally the request time is updated.

Arguments:

    ServiceContext - Supplies a pointer to the interrupt context which contains
        pointers to the interrupt data and where to save it.

Return Value:

    Returns TURE if there is new work and FALSE otherwise.

Notes:

    Called via KeSynchronizeExecution with the port device extension spinlock
    held.

--*/
{
    PINTERRUPT_CONTEXT      interruptContext = ServiceContext;
    ULONG                   limit = 0;
    PADAPTER_EXTENSION       deviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK     srb;
    PSRB_DATA               srbData;
    PSRB_DATA               nextSrbData;
    BOOLEAN                 isTimed;

    deviceExtension = interruptContext->DeviceExtension;

    //
    // Check for pending work.
    //

    if (!(deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED)) {

        //
        // We scheduled a DPC (turned on the PD_NOTIFICATION_REQUIRED bit in
        // the adapter extension's DpcFlags) while the DPC routine was
        // running.  Clear the bit before returning to prevent the completion
        // DPC routine from spinning forever.  The only bit we leave set is
        // PD_DPC_RUNNING.
        //

        deviceExtension->DpcFlags &= PD_DPC_RUNNING;

        return(FALSE);
    }

    //
    // Move the interrupt state to save area.
    //

    *interruptContext->SavedInterruptData = deviceExtension->InterruptData;

    //
    // Clear the interrupt state.
    //

    deviceExtension->InterruptData.InterruptFlags &= PD_INTERRUPT_FLAG_MASK;
    deviceExtension->InterruptData.CompletedRequests = NULL;
    deviceExtension->InterruptData.ReadyLogicalUnit = NULL;
    deviceExtension->InterruptData.CompletedAbort = NULL;
    deviceExtension->InterruptData.WmiMiniPortRequests = NULL;

    //
    // Clear the notification required bit in the DPC flags.
    //

    {
        ULONG oldDpcFlags = 0;

        //
        // If we've been called then the DPC is obviously running.
        //

        oldDpcFlags = (ULONG) InterlockedExchange(&(deviceExtension->DpcFlags),
                                                  PD_DPC_RUNNING);

        //
        // If we got this far then these two flags must have been set.
        //

        ASSERT(oldDpcFlags == (PD_NOTIFICATION_REQUIRED | PD_DPC_RUNNING));
    }

    srbData = interruptContext->SavedInterruptData->CompletedRequests;

    while (srbData != NULL) {

#if DBG
        BOOLEAN alreadyChecked = FALSE;

        //
        // Look for a cycle in the completed request list.  Only need to check 
        // once because the list is static for the duration of this routine.
        //

        if (limit++ > (ULONG)deviceExtension->ActiveRequestCount &&
            alreadyChecked == FALSE) {

            alreadyChecked = TRUE;

            SpDetectCycleInCompletedRequestList(interruptContext);
        }
#endif // DBG

        ASSERT(srbData->CurrentSrb != NULL);

        //
        // Get a pointer to the SRB and the logical unit extension.
        //

        srb = srbData->CurrentSrb;

        ASSERT(!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_IS_ACTIVE));

        logicalUnit = srbData->LogicalUnit;

#if DBG
        {
            PLOGICAL_UNIT_EXTENSION tmp;

            tmp = GetLogicalUnitExtension(
                    (PADAPTER_EXTENSION) deviceExtension,
                    srb->PathId,
                    srb->TargetId,
                    srb->Lun,
                    FALSE,
                    FALSE);

            ASSERT(logicalUnit == srbData->LogicalUnit);
        }
#endif

        //
        // If the request did not succeed, then check for the special cases.
        //

        if (srb->SrbStatus != SRB_STATUS_SUCCESS) {

            //
            // If this request failed and a REQUEST SENSE command needs to
            // be done, then set a flag to indicate this and prevent other
            // commands from being started.
            //

            if (NEED_REQUEST_SENSE(srb)) {

                if (logicalUnit->LuFlags & LU_NEED_REQUEST_SENSE) {

                    //
                    // This implies that requests have completed with a
                    // status of check condition before a REQUEST SENSE
                    // command could be performed.  This should never occur.
                    // Convert the request to another code so that only one
                    // auto request sense is issued.
                    //

                    srb->ScsiStatus = 0;
                    srb->SrbStatus = SRB_STATUS_REQUEST_SENSE_FAILED;

                } else {

                    //
                    // Indicate that an auto request sense needs to be done.
                    //

                    logicalUnit->LuFlags |= LU_NEED_REQUEST_SENSE;

                    //
                    // Save a pointer to the failed request away somewhere.
                    // Caller is holding the port spinlock which is used to
                    // protect these pointers.
                    //

                    ASSERTMSG("Scsiport has more than two failed requests: ",
                              ((logicalUnit->ActiveFailedRequest == NULL) ||
                               (logicalUnit->BlockedFailedRequest == NULL)));

                    ASSERTMSG("Scsiport has blocked but no active failed request: ",
                              (((logicalUnit->ActiveFailedRequest == NULL) &&
                                (logicalUnit->BlockedFailedRequest == NULL)) ||
                               (logicalUnit->ActiveFailedRequest != NULL)));

                    if(logicalUnit->ActiveFailedRequest == NULL) {
                        logicalUnit->ActiveFailedRequest = srbData;
                    } else {
                        logicalUnit->BlockedFailedRequest = srbData;
                    }
                }
            }

            //
            // Check for a QUEUE FULL status.
            //

            if (srb->ScsiStatus == SCSISTAT_QUEUE_FULL) {

                //
                // Set the queue full flag in the logical unit to prevent
                // any new requests from being started.
                //

                logicalUnit->LuFlags |= LU_QUEUE_IS_FULL;

                //
                // Assert to catch queue full condition when there are
                // no requests.
                //

                ASSERT(logicalUnit->QueueCount);

                //
                // Update the maximum queue depth.
                //

                if (logicalUnit->QueueCount < logicalUnit->MaxQueueDepth &&
                    logicalUnit->QueueCount > 2) {

                    //
                    // Set a bit to indicate that we are operating below full
                    // power.  The tick handler will increment a counter every
                    // second we're in this state until which we reach a
                    // tunable value that restores us to full power.
                    //

                    logicalUnit->LuFlags |= LU_PERF_MAXQDEPTH_REDUCED;

                    logicalUnit->MaxQueueDepth = logicalUnit->QueueCount - 1;

                    DebugPrint((1, "SpGetInterruptState: New queue depth %d.\n",
                                logicalUnit->MaxQueueDepth));
                }

                //
                // Reset the number of ticks the LU has been in a reduced
                // performance state due to QUEUE FULL conditions.  This has the
                // effect of keeping us in this state.
                //

                logicalUnit->TicksInReducedMaxQueueDepthState = 0;
                
            }
        }

        //
        // If this is an unqueued request or a request at the head of the queue,
        // then the requset timer count must be updated.
        // Note that the spinlock is held at this time.
        //

        if (srb->QueueTag == SP_UNTAGGED) {

            isTimed = TRUE;

        } else {

            if (logicalUnit->RequestList.Flink == &srbData->RequestList) {

                isTimed = TRUE;

            } else {

                isTimed = FALSE;

            }

            //
            // Remove the SRB data structure from the queue.
            //

            RemoveEntryList(&srbData->RequestList);
        }

        if (isTimed) {

            //
            // The request timeout count needs to be updated.  If the request
            // list is empty then the timer should be stopped.
            //

            if (IsListEmpty(&logicalUnit->RequestList)) {

                logicalUnit->RequestTimeoutCounter = PD_TIMER_STOPPED;

            } else {

                //
                // Start timing the srb at the head of the list.
                //

                nextSrbData = CONTAINING_RECORD(
                    logicalUnit->RequestList.Flink,
                    SRB_DATA,
                    RequestList);

                 srb = nextSrbData->CurrentSrb;
                 logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;
            }
        }

        srbData = srbData->CompletedRequests;
    }

    return(TRUE);
}

#if DBG

PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtensionEx(
    PADAPTER_EXTENSION deviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    PVOID LockTag,
    BOOLEAN AcquireBinLock,
    PCSTR File,
    ULONG Line
    )

/*++

Routine Description:

    Walk logical unit extension list looking for
    extension with matching target id.

Arguments:

    deviceExtension
    TargetId

Return Value:

    Requested logical unit extension if found,
    else NULL.

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    PLOGICAL_UNIT_BIN bin;
    PLOGICAL_UNIT_EXTENSION foundMatch = NULL;

    KIRQL oldIrql;

    //
    // Removing this check because if we create LUs for the initiator, the
    // ID can be larger thn the adapter's MaxiumuTargetIds.
    //

    // if (TargetId >= deviceExtension->MaximumTargetIds) {
    //     return NULL;
    // }

    bin =
        &deviceExtension->LogicalUnitList[ADDRESS_TO_HASH(PathId,
                                                          TargetId,
                                                          Lun)];

    if(AcquireBinLock) {
        KeAcquireSpinLock(&bin->Lock, &oldIrql);
    }

    logicalUnit = bin->List;

    while (logicalUnit != NULL) {

        if ((logicalUnit->TargetId == TargetId) &&
            (logicalUnit->PathId == PathId) &&
            (logicalUnit->Lun == Lun)) {

            if(foundMatch != NULL) {

                DebugPrint((0, "GetLogicalUnitExtension: Found duplicate for "
                               "(%d,%d,%d) in list: %#08lx %s & %#08lx %s\n",
                               PathId, TargetId, Lun,
                               foundMatch, (foundMatch->IsMissing) ? "missing" : "",
                               logicalUnit, (logicalUnit->IsMissing) ? "missing" : ""));
                ASSERTMSG("Duplicate found in lun list - this is bad\n", FALSE);
            }

            foundMatch = logicalUnit;
        }

        logicalUnit = logicalUnit->NextLogicalUnit;
    }

    if((ARGUMENT_PRESENT(LockTag)) && (foundMatch != NULL)) {

        SpAcquireRemoveLockEx(foundMatch->CommonExtension.DeviceObject,
                              LockTag,
                              File,
                              Line);
    }

    if(AcquireBinLock) {
        KeReleaseSpinLock(&bin->Lock, oldIrql);
    }
    return foundMatch;

} // end GetLogicalUnitExtension()
#else

PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtension(
    PADAPTER_EXTENSION deviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    PVOID LockTag,
    BOOLEAN AcquireBinLock
    )
{
    PLOGICAL_UNIT_BIN bin;
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    KIRQL oldIrql;

    //
    // Removing this check because if we create LUs for the initiator, the
    // ID can be larger thn the adapter's MaxiumuTargetIds.
    //

    // if (TargetId >= deviceExtension->MaximumTargetIds) {
    //     return NULL;
    // }

    bin = &deviceExtension->LogicalUnitList[ADDRESS_TO_HASH(PathId,
                                                           TargetId,
                                                           Lun)];

    if(AcquireBinLock) {
        KeAcquireSpinLock(&bin->Lock, &oldIrql);
    }

    logicalUnit = bin->List;

    while (logicalUnit != NULL) {

        if ((logicalUnit->TargetId == TargetId) &&
            (logicalUnit->PathId == PathId) &&
            (logicalUnit->Lun == Lun)) {

            if(ARGUMENT_PRESENT(LockTag)) {

                SpAcquireRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                                    LockTag);
            }

            if(AcquireBinLock) {
                KeReleaseSpinLock(&bin->Lock, oldIrql);
            }
            return logicalUnit;
        }

        logicalUnit = logicalUnit->NextLogicalUnit;
    }

    //
    // Logical unit extension not found.
    //

    if(AcquireBinLock) {
        KeReleaseSpinLock(&bin->Lock, oldIrql);
    }

    return NULL;
}
#endif


IO_ALLOCATION_ACTION
ScsiPortAllocationRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called by IoAllocateAdapterChannel when sufficent resources
    are available to the driver.  This routine saves the MapRegisterBase in the
    device object and starts the currently pending request.

Arguments:

    DeviceObject - Pointer to the device object to which the adapter is being
        allocated.

    Irp - Unused.

    MapRegisterBase - Supplied by the Io subsystem for use in IoMapTransfer.

    Context - Supplies a pointer to the logical unit structure for the next
        current request.


Return Value:

    KeepObject - Indicates the adapter and mapregisters should remain allocated
        after return.

--*/

{
    KIRQL currentIrql;
    PADAPTER_EXTENSION deviceExtension;
    IO_ALLOCATION_ACTION action;

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Initialize the return value.
    //

    action = deviceExtension->PortConfig->Master ?
       DeallocateObjectKeepRegisters : KeepObject;

    //
    // Acquire the spinlock to protect the various structures.
    //

    KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

    //
    // Save the map register base.
    //

    if (deviceExtension->PortConfig->Master) {

        //
        // Note: ScsiPort considers this device a slave even though it really may 
        //       be a master. I won't go into why this is, but if it is really a 
        //       master, we must free the map registers after the request 
        //       completes, so we'll save the map register base and the number of 
        //       map registers in the per-request SRB_DATA structure.

        PIO_STACK_LOCATION irpStack;
        PSCSI_REQUEST_BLOCK srb;
        PSRB_DATA srbData;

        irpStack = IoGetCurrentIrpStackLocation(DeviceObject->CurrentIrp);
        srb = irpStack->Parameters.Scsi.Srb;
        srbData = srb->OriginalRequest;

        ASSERT_SRB_DATA(srbData);        

        srbData->MapRegisterBase = MapRegisterBase;
        srbData->NumberOfMapRegisters = deviceExtension->Capabilities.MaximumPhysicalPages;

    } else {

        deviceExtension->MapRegisterBase = MapRegisterBase;

    }

    deviceExtension->SynchronizeExecution(
        deviceExtension->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

    return action;
}

VOID
SpReceiveScatterGather(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called by the I/O system when an adapter object and map
    registers have been allocated.  This routine then builds a scatter/gather
    list for use by the miniport driver.  Next it sets the timeout and
    the current Irp for the logical unit.  Finally it calls the miniport
    StartIo routine.  Once that routines complete, this routine will return
    requesting that the adapter be freed and but the registers remain allocated.
    The registers will be freed the request completes.

Arguments:

    DeviceObject - Supplies a pointer to the port driver device object.

    Irp - Supplies a pointer to the current Irp.

    MapRegisterBase - Supplies a context pointer to be used with calls the
        adapter object routines.

    Context - Supplies a pointer to the SRB_DATA structure.

Return Value:

    Returns DeallocateObjectKeepRegisters so that the adapter object can be
        used by other logical units.

--*/

{
    KIRQL               currentIrql;
    PSCSI_REQUEST_BLOCK srb;
    PSRB_DATA           srbData         = Context;
    PADAPTER_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

    srb = srbData->CurrentSrb;

    //
    // Save the MapRegisterBase for later use to deallocate the map registers.
    //

    srbData->MapRegisterBase = ScatterGather;
    srbData->ScatterGatherList = ScatterGather->Elements;

    //
    // See if we need to map or remap the buffer.
    //

    if((deviceExtension->MapBuffers == TRUE) ||
       (IS_MAPPED_SRB(srb) == TRUE)) {

        PMDL mdl = Irp->MdlAddress;

        PVOID systemAddress;
        BOOLEAN remap = FALSE;
        
tryRemapping:
        if(deviceExtension->RemapBuffers || remap == TRUE) {

            //
            // Build an MDL for the actual data area being used for this
            // request.  We're using the data buffer address in the srb
            // as the base, not the one in the original MDL so we don't
            // need to compensate for the DataOffset originally calculated.
            //

            mdl = SpBuildMdlForMappedTransfer(
                    DeviceObject,
                    deviceExtension->DmaAdapterObject,
                    srbData->CurrentIrp->MdlAddress,
                    srb->DataBuffer,
                    srb->DataTransferLength,
                    srbData->ScatterGatherList,
                    ScatterGather->NumberOfElements
                    );

#if defined(FORWARD_PROGRESS)
            if (mdl == NULL && deviceExtension->ReservedMdl != NULL) {
                
                //
                // We could not allocate a new MDL for the request and there is
                // a spare one on the adapter extension.  Let's try to use the 
                // spare.
                //

                KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

                mdl = SpPrepareReservedMdlForUse(deviceExtension,
                                                 srbData,
                                                 srb,
                                                 ScatterGather->NumberOfElements);

                if (mdl == (PMDL)-1) {

                    DebugPrint((1, "SpReceiveScatterGather: reserve mdl in use - pending DevExt:%p srb:%p\n",
                                deviceExtension, srb));

                    //
                    // The spare MDL is already in use.  At this point, this
                    // request is still the current IRP on the adapter device
                    // object, so let's pend it until the spare comes available.
                    //

                    ASSERT(Irp == DeviceObject->CurrentIrp);
                    SET_FLAG(deviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);

                    //
                    // If we allocated an SRB extension for this request, free
                    // it now.  I do this because when the request gets restarted
                    // we'll try to allocate the SRB extension again and without
                    // adding more state, there isn't a safe way to check if the 
                    // extension has already been allocated.  Besides, it makes
                    // sense to make the extension available for some other
                    // request since it also is a limited resource.
                    //

                    if (srb->SrbExtension != NULL) {

                        //
                        // Restore the SenseInfoBuffer pointer in the srb.
                        //

                        if ((srb->Function != SRB_FUNCTION_WMI) &&
                            deviceExtension->AutoRequestSense &&
                            (srb->SenseInfoBuffer != NULL)) {

                            ASSERT(srbData->RequestSenseSave != NULL ||
                                   srb->SenseInfoBuffer == NULL);

                            srb->SenseInfoBufferLength = 
                                srbData->RequestSenseLengthSave;
                            srb->SenseInfoBuffer = 
                                srbData->RequestSenseSave;
                        }

                        SpFreeSrbExtension(deviceExtension, srb->SrbExtension);
                    }

                    //
                    // Free the map registers.
                    //

                    PutScatterGatherList(
                        deviceExtension->DmaAdapterObject,
                        srbData->MapRegisterBase,
                        (BOOLEAN)(srb->SrbFlags & SRB_FLAGS_DATA_IN ? 
                                  FALSE : TRUE));
                    srbData->ScatterGatherList = NULL;

                    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                    return;
                }

                KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
            }
#endif
            srbData->RemappedMdl = mdl;
        } else {
            srbData->RemappedMdl = NULL;
        }

        if(mdl == NULL) {

            srbData->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;
            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->ScsiStatus = 0xff;
            goto DoneMapping;
        }

        //
        // Get the mapped system address and calculate offset into MDL.
        // At the moment don't allow KernelMode requests to fail since
        // not all scsiport's internally sent requests are correctly
        // marked as comming from non-paged pool.
        //

        if(srbData->RemappedMdl == NULL) {

            //
            // We're using the original data address for the MDL here - we
            // need to compensate for the data offset.
            //

            systemAddress = SpGetSystemAddressForMdlSafe(
                                mdl,
                                ((Irp->RequestorMode == KernelMode) ?
                                 HighPagePriority : NormalPagePriority));

            //
            // If we could not map the entire MDL, check if we are trying to map
            // more than we need.  We do this when class splits the request
            // because each IRP class sends down points to the orignal MDL
            // that describes the entire buffer. The DataBuffer and TransferLength
            // fields of the SRB, however, do represent the current portion of the 
            // buffer. So we try remapping using the info in the SRB.
            //
            
            if (systemAddress == NULL) {
                if (remap == FALSE) {
                    ULONG mdlByteCount = MmGetMdlByteCount(mdl);
                    if (mdlByteCount > srb->DataTransferLength) {
                        remap = TRUE;
                        goto tryRemapping;
                    }
                }
            }
        } else {
            systemAddress = MmMapLockedPagesSpecifyCache(
                                mdl,
                                KernelMode,
                                MmCached,
                                NULL,
                                FALSE,
                                ((Irp->RequestorMode == KernelMode) ?
                                 HighPagePriority :
                                 NormalPagePriority));
        }

#if defined(FORWARD_PROGRESS)
        if (systemAddress == NULL && deviceExtension->ReservedPages != NULL) {            

            //
            // The system could not map the pages necessary to complete this
            // request.  We need to ensure forward progress, so we'll try to
            // use the reserve pages we allocated at initialization time.
            //

            KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);
            
            systemAddress = SpMapLockedPagesWithReservedMapping(
                                deviceExtension,
                                srb,
                                srbData,
                                mdl);

            if (systemAddress == (PVOID)-1) {

                DebugPrint((1, "SpReceiveScatterGather: reserve range in use - pending DevExt:%p srb:%p\n",
                            deviceExtension, srb));

                //
                // The spare pages are already in use.  At this point, this
                // request is still the current IRP on the adapter device
                // object, so let's pend it until the spare comes available.
                //

                ASSERT(Irp == DeviceObject->CurrentIrp);
                SET_FLAG(deviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);

                //
                // If we allocated an SRB extension for this request, free
                // it now.  I do this because when the request gets restarted
                // we'll try to allocate the SRB extension again and without
                // adding more state, there isn't a safe way to check if the 
                // extension has already been allocated.  Besides, it makes
                // sense to make the extension available for some other
                // request since it also is a limited resource.
                //

                if (srb->SrbExtension != NULL) {

                    //
                    // Restore the SenseInfoBuffer pointer in the srb.
                    //

                    if ((srb->Function != SRB_FUNCTION_WMI) &&
                        deviceExtension->AutoRequestSense &&
                        (srb->SenseInfoBuffer != NULL)) {

                        ASSERT(srbData->RequestSenseSave != NULL ||
                               srb->SenseInfoBuffer == NULL);

                        srb->SenseInfoBufferLength = 
                            srbData->RequestSenseLengthSave;
                        srb->SenseInfoBuffer = 
                            srbData->RequestSenseSave;
                    }

                    SpFreeSrbExtension(deviceExtension, srb->SrbExtension);
                }

                //
                // Free the map registers.
                //

                PutScatterGatherList(
                    deviceExtension->DmaAdapterObject,
                    srbData->MapRegisterBase,
                    (BOOLEAN)(srb->SrbFlags & SRB_FLAGS_DATA_IN ? FALSE : TRUE));
                srbData->ScatterGatherList = NULL;
        
                //
                // If we have a remapping MDL, either one we allocated or
                // the reserve, free it.
                //

                if (srbData->RemappedMdl != NULL) {
                    if (TEST_FLAG(srbData->Flags, SRB_DATA_RESERVED_MDL)) {
                        CLEAR_FLAG(srbData->Flags, SRB_DATA_RESERVED_MDL);
                        CLEAR_FLAG(deviceExtension->Flags, PD_RESERVED_MDL_IN_USE);
                    } else {
                        IoFreeMdl(srbData->RemappedMdl);
                    }
                    srbData->RemappedMdl = NULL;
                }

                KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                return;
                
            }

            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        }
#endif

        if(systemAddress != NULL) {
            srb->DataBuffer = systemAddress;

            if(srbData->RemappedMdl == NULL) {
                //
                // If we didn't remap the MDL then this system address is
                // based on the original MDL's base address.  Account for the
                // offset of the srb's original data buffer pointer.
                //
                (PUCHAR) srb->DataBuffer += srbData->DataOffset;
            }
        } else {
            DebugPrint((1, "SpReceiveScatterGather: Couldn't get system "
                           "VA for irp 0x%08p\n", Irp));

            srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
            srb->ScsiStatus = 0xff;
            srbData->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

            //
            // Free the remapped MDL here - this will keep the completion code
            // from trying to unmap memory we never mapped.
            //

            if(srbData->RemappedMdl) {
                IoFreeMdl(srbData->RemappedMdl);
                srbData->RemappedMdl = NULL;
            }
        }
    } else {
        srbData->RemappedMdl = NULL;
    }

DoneMapping:

    //
    // Update the active request count.
    //

    InterlockedIncrement( &deviceExtension->ActiveRequestCount );

    //
    // Acquire the spinlock to protect the various structures.
    //

    KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

    deviceExtension->SynchronizeExecution(
        deviceExtension->InterruptObject,
        SpStartIoSynchronized,
        DeviceObject
        );

    KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

}

VOID
LogErrorEntry(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PERROR_LOG_ENTRY LogEntry
    )
/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    LogEntry - Supplies a pointer to the scsi port log entry.

Return Value:

    None.

--*/
{
    PIO_ERROR_LOG_PACKET errorLogEntry;

#define ERRLOG_DATA_ENTRIES 4

    errorLogEntry = (PIO_ERROR_LOG_PACKET)
        IoAllocateErrorLogEntry(
            DeviceExtension->CommonExtension.DeviceObject,
            (sizeof(IO_ERROR_LOG_PACKET) +
             (ERRLOG_DATA_ENTRIES * sizeof(ULONG))));

    if (errorLogEntry != NULL) {

        //
        // Translate the miniport error code into the NT I\O driver.
        //

        switch (LogEntry->ErrorCode) {
        case SP_BUS_PARITY_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_PARITY;
            break;

        case SP_UNEXPECTED_DISCONNECT:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_INVALID_RESELECTION:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_BUS_TIME_OUT:
            errorLogEntry->ErrorCode = IO_ERR_TIMEOUT;
            break;

        case SP_PROTOCOL_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_INTERNAL_ADAPTER_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_IRQ_NOT_RESPONDING:
            errorLogEntry->ErrorCode = IO_ERR_INCORRECT_IRQL;
            break;

        case SP_BAD_FW_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_BAD_FIRMWARE;
            break;

        case SP_BAD_FW_WARNING:
            errorLogEntry->ErrorCode = IO_WRN_BAD_FIRMWARE;
            break;

        default:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        }

        errorLogEntry->SequenceNumber = LogEntry->SequenceNumber;
        errorLogEntry->MajorFunctionCode = IRP_MJ_SCSI;
        errorLogEntry->RetryCount = (UCHAR) LogEntry->ErrorLogRetryCount;
        errorLogEntry->UniqueErrorValue = LogEntry->UniqueId;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = ERRLOG_DATA_ENTRIES * sizeof(ULONG);
        errorLogEntry->DumpData[0] = LogEntry->PathId;
        errorLogEntry->DumpData[1] = LogEntry->TargetId;
        errorLogEntry->DumpData[2] = LogEntry->Lun;
        errorLogEntry->DumpData[3] = LogEntry->ErrorCode;
        IoWriteErrorLogEntry(errorLogEntry);

#undef ERRLOG_DATA_ENTRIES

    }

#if SCSIDBG_ENABLED
    {
    PCHAR errorCodeString;

    switch (LogEntry->ErrorCode) {
    case SP_BUS_PARITY_ERROR:
        errorCodeString = "SCSI bus partity error";
        break;

    case SP_UNEXPECTED_DISCONNECT:
        errorCodeString = "Unexpected disconnect";
        break;

    case SP_INVALID_RESELECTION:
        errorCodeString = "Invalid reselection";
        break;

    case SP_BUS_TIME_OUT:
        errorCodeString = "SCSI bus time out";
        break;

    case SP_PROTOCOL_ERROR:
        errorCodeString = "SCSI protocol error";
        break;

    case SP_INTERNAL_ADAPTER_ERROR:
        errorCodeString = "Internal adapter error";
        break;

    default:
        errorCodeString = "Unknown error code";
        break;

    }

    DebugPrint((1,"LogErrorEntry: Logging SCSI error packet. ErrorCode = %s.\n",
        errorCodeString
        ));
    DebugPrint((1,
        "PathId = %2x, TargetId = %2x, Lun = %2x, UniqueId = %x.\n",
        LogEntry->PathId,
        LogEntry->TargetId,
        LogEntry->Lun,
        LogEntry->UniqueId
        ));
    }
#endif
}

#if defined(NEWQUEUE)
VOID
FASTCALL
UpdateQueuePointers(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    ULONG currentZone   = LogicalUnit->CurrentZone;
    ULONG currentSector = LogicalUnit->CurrentKey;
    ULONG nextSector    = Srb->QueueSortKey;
    ULONG skipFactor    = 0;

#if DBG
    ULONG lba = 0;
    if (IS_READ(Srb) || IS_WRITE(Srb)) {
        ((PFOUR_BYTE)&lba)->Byte0 = (UCHAR)(Srb->Cdb[5]);
        ((PFOUR_BYTE)&lba)->Byte1 = (UCHAR)(Srb->Cdb[4]);
        ((PFOUR_BYTE)&lba)->Byte2 = (UCHAR)(Srb->Cdb[3]);
        ((PFOUR_BYTE)&lba)->Byte3 = (UCHAR)(Srb->Cdb[2]);
        if (lba != Srb->QueueSortKey) {
            DebugPrint((1, "UpdateQueuePointers: QueueSortKey != LBA srb:%p "
                        "lba:%x qsk:%x\n", Srb, lba, nextSector));
        }
    }
#endif

    if (nextSector < currentSector || 
        nextSector > LogicalUnit->LastSector[currentZone]) {

        //
        // We've either wrapped or moved into another zone.  Reset the current
        // zone state.  Note that we may very well have wrapped and landed back
        // in the current zone.  In that case, we'll still go ahead and reset 
        // everything since there's no IO anywhere else on the medium.
        //

        LogicalUnit->ZonePointer[currentZone] = 
            LogicalUnit->FirstSector[currentZone];
        LogicalUnit->RedundantRequests[currentZone] = 0;
        LogicalUnit->ZoneCount = 0;

        //
        // Update the current zone and retrieve next sector for the new zone.
        //

        LogicalUnit->CurrentZone = GetZone(LogicalUnit, nextSector);
        nextSector = LogicalUnit->ZonePointer[LogicalUnit->CurrentZone];

        DebugPrint((1, "UpdateQueuePointers: leaving zone:%d entering zone:%d "
                    "nextSector:%08x\n", currentZone, LogicalUnit->CurrentZone,
                    nextSector));

    } else {

        //
        // We're still in the same zone, so ncrement the number of requests
        // we've handled in this zone.
        //

        LogicalUnit->ZoneCount++;

        //
        // Update redundant IO state.  Redundant requests are consecutive 
        // requests for the same sector.  We will process some number of 
        // redundant requests before moving on to the next sector.  This 
        // helps prevent starvation of redundant requests when many occur 
        // along with a high number of IOs distributed across the medium.
        //

        if (nextSector == currentSector) {

            if (++LogicalUnit->RedundantRequests[currentZone] >= SpPerBlockLimit) {

                DebugPrint((1, "UpdateQueuePointers: max dups LU:%p sector:%x "
                            "zone:%d\n", LogicalUnit, nextSector, currentZone));

                //
                // We have handled the maximum allowed number of consecutive
                // requests to the currect sector.  Reset the number of
                // redundant requests and set the skip factor to indicate
                // that we need to skip the currect sector.
                //

                LogicalUnit->RedundantRequests[currentZone] = 0;
                skipFactor = 1;
            }

        } else {

            LogicalUnit->RedundantRequests[currentZone] = 0;

        }

        //
        // Check if we've used up our quota for the current zone.  If so, skip 
        // to the next one. This is done in order to avoid getting bogged down 
        // in hot zones. The theory is that it's better to pick up a number of 
        // requests in each zone than to stay in one place too long.  This may
        // help reduce wait times for requests queued outside the hot zones.
        //

        if (LogicalUnit->ZoneCount >= SpPerZoneLimit) {

            DebugPrint((1, "UpdateQueuePointers: reached quota LU:%p saving:%x"
                        " dups:%x (%d,%d)\n", LogicalUnit, 
                        nextSector + skipFactor,
                        LogicalUnit->RedundantRequests[currentZone], currentZone,
                        LogicalUnit->NextSequentialZone[currentZone]));

            //
            // Save state for the current zone.  Next time we move into this
            // zone we will start at the saved location.
            //

            LogicalUnit->ZonePointer[currentZone] = nextSector + skipFactor;
            LogicalUnit->RedundantRequests[currentZone] = 0;

            //
            // Reset the zone count.
            //
            
            LogicalUnit->ZoneCount = 0;

            //
            // Advance to the next zone.
            //
            
            LogicalUnit->CurrentZone = 
               LogicalUnit->NextSequentialZone[currentZone];

            //
            // Get the saved location from the current zone and clear the
            // skip factor (we don't need to skip because we're moving
            // out of this zone).
            // 

            nextSector = LogicalUnit->ZonePointer[LogicalUnit->CurrentZone];
            skipFactor = 0;
        }
    }

    //
    // Update the LU's current sector (CurrentKey).
    //

    LogicalUnit->CurrentKey = nextSector + skipFactor;
}
#endif // NEWQUEUE

VOID
FASTCALL
GetNextLuRequest(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
/*++

Routine Description:

    This routine get the next request for the specified logical unit.  It does
    the necessary initialization to the logical unit structure and submitts the
    request to the device queue.  The DeviceExtension SpinLock must be held
    when this function called.  It is released by this function.

Arguments:

    LogicalUnit - Supplies a pointer to the logical unit extension to get the
        next request from.

Return Value:

     None.

--*/

{
    PADAPTER_EXTENSION DeviceExtension = LogicalUnit->AdapterExtension;
    PKDEVICE_QUEUE_ENTRY packet;
    PIO_STACK_LOCATION   irpStack;
    PSCSI_REQUEST_BLOCK  srb;
    PIRP                 nextIrp;

    //
    // If the active flag is not set, then the queue is not busy or there is
    // a request being processed and the next request should not be started..
    //

    if (!(LogicalUnit->LuFlags & LU_LOGICAL_UNIT_IS_ACTIVE) ||
         (LogicalUnit->QueueCount >= LogicalUnit->MaxQueueDepth)) {

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        return;
    }

    //
    // Check for pending requests, queue full or busy requests.  Pending
    // requests occur when untagged request is started and there are active
    // queued requests. Busy requests occur when the target returns a BUSY
    // or QUEUE FULL status. Busy requests are started by the timer code.
    // Also if the need request sense flag is set, it indicates that
    // an error status was detected on the logical unit.  No new requests
    // should be started until this flag is cleared.  This flag is cleared
    // by an untagged command that by-passes the LU queue i.e.
    //
    // The busy flag and the need request sense flag have the effect of
    // forcing the queue of outstanding requests to drain after an error or
    // until a busy request gets started.
    //

    if (TEST_FLAG(LogicalUnit->LuFlags, (LU_QUEUE_FROZEN |
                                         LU_QUEUE_LOCKED))) {

#if DBG
         DebugPrint((1, "ScsiPort: GetNextLuRequest: Ignoring a get next lu "
                        "call for %#p - \n", LogicalUnit));

         if(TEST_FLAG(LogicalUnit->LuFlags, LU_QUEUE_FROZEN)) {
             DebugPrint((1, "\tQueue is frozen\n"));
         }

         if(TEST_FLAG(LogicalUnit->LuFlags, LU_QUEUE_LOCKED)) {
             DebugPrint((1, "\tQueue is locked\n"));
         }
 #endif

         //
         // Note the active flag is not cleared.  So the next request
         // will be processed when the other requests have completed.
         // Release the spinlock
         //

         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
         return;
     }

     if (TEST_FLAG(LogicalUnit->LuFlags, LU_PENDING_LU_REQUEST |
                                         LU_LOGICAL_UNIT_IS_BUSY |
                                         LU_QUEUE_IS_FULL |
                                         LU_NEED_REQUEST_SENSE)) {

         //
         // If the request queue is now empty, then the pending request can
         // be started.
         //

         if (IsListEmpty(&LogicalUnit->RequestList) &&
             !TEST_FLAG(LogicalUnit->LuFlags, LU_LOGICAL_UNIT_IS_BUSY |
                                              LU_QUEUE_IS_FULL |
                                              LU_NEED_REQUEST_SENSE)) {
             PSRB_DATA nextSrbData;

             ASSERT(LogicalUnit->CurrentUntaggedRequest == NULL);

             //
             // Clear the pending bit and active flag, release the spinlock,
             // and start the pending request.
             //

             CLEAR_FLAG(LogicalUnit->LuFlags, LU_PENDING_LU_REQUEST |
                                              LU_LOGICAL_UNIT_IS_ACTIVE);

             nextSrbData = LogicalUnit->PendingRequest;
             LogicalUnit->PendingRequest = NULL;
             LogicalUnit->RetryCount = 0;

             //
             // Release the spinlock.
             //

             KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

             nextSrbData->TickCount = DeviceExtension->TickCount;
             IoStartPacket(DeviceExtension->CommonExtension.DeviceObject,
                           nextSrbData->CurrentIrp,
                           (PULONG)NULL,
                           NULL);

             return;

         } else {

             DebugPrint((1, "ScsiPort: GetNextLuRequest:  Ignoring a get next "
                            "lu call.\n"));

             //
             // Note the active flag is not cleared. So the next request
             // will be processed when the other requests have completed.
             // Release the spinlock.
             //

             KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
             return;

         }
     }

     //
     // Clear the active flag.  If there is another request, the flag will be
     // set again when the request is passed to the miniport.
     //

     CLEAR_FLAG(LogicalUnit->LuFlags, LU_LOGICAL_UNIT_IS_ACTIVE);

     //
     // Remove the packet from the logical unit device queue.  We must use the 
     // IfBusy varient here to work around the trivial case where the queue is
     // not actually busy.
     //
     // If a request is returned with scsi BUSY, the device queue busy flag may 
     // have already been cleared by the miniport requests a get next lu request 
     // in the dispatch routine.  In this case, when the busy request is 
     // reissued, SpStartIoSynchronized will set the LU_ACTIVE flag assuming 
     // this request came out of the queue.  Unfortunately it did not and get 
     // next lu request will foolishly come down here looking for an active 
     // queue and assert on a checked build unless we use the IfBusy varient
     //

     packet = KeRemoveByKeyDeviceQueueIfBusy(
                 &LogicalUnit->CommonExtension.DeviceObject->DeviceQueue,
                 LogicalUnit->CurrentKey);

     if (packet != NULL) {
         PSRB_DATA srbData;

         nextIrp = CONTAINING_RECORD(packet, IRP, Tail.Overlay.DeviceQueueEntry);

         //
         // Set the new current key.
         //

         irpStack = IoGetCurrentIrpStackLocation(nextIrp);
         srb = (PSCSI_REQUEST_BLOCK)irpStack->Parameters.Others.Argument1;
         srbData = (PSRB_DATA) srb->OriginalRequest;

         ASSERT_SRB_DATA(srbData);

#if defined(NEWQUEUE)
         
         UpdateQueuePointers(LogicalUnit, srb);

#else // Use the old queuing method.

         //
         // Hack to work-around the starvation led to by numerous requests
         // touching the same sector.
         //
         
         LogicalUnit->CurrentKey = srb->QueueSortKey + 1;

#endif // NEWQUEUE

         //
         // Release the spinlock.
         //

         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

         srbData->TickCount = DeviceExtension->TickCount;
         IoStartPacket(DeviceExtension->DeviceObject,
                       nextIrp,
                       NULL,
                       NULL);

     } else {

         //
         // Release the spinlock.
         //

         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

     }

 } // end GetNextLuRequest()

VOID
SpLogPortTimeoutError(
     IN PADAPTER_EXTENSION DeviceExtension,
     IN ULONG UniqueId
     )

 /*++

 Routine Description:

     This function logs an error when a timeout when a port timeout occurs -
     defined to be an excessive period of inactivity on the port.

 Arguments:

     DeviceExtension - Supplies a pointer to the port device extension.

     UniqueId - Supplies the UniqueId for this error.

 Return Value:

     None.

 Notes:

     The port device extension spinlock should be held when this routine is
     called.

 --*/
{
     PIO_ERROR_LOG_PACKET errorLogEntry;
     ULONG dataEntries = 0;
     UCHAR packetSize;

     packetSize = (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + 
                          (dataEntries * sizeof(ULONG)));

     errorLogEntry = (PIO_ERROR_LOG_PACKET)
                     IoAllocateErrorLogEntry(
                         DeviceExtension->DeviceObject,
                         packetSize);

     if (errorLogEntry != NULL) {
         errorLogEntry->ErrorCode = IO_ERR_PORT_TIMEOUT;
         errorLogEntry->UniqueErrorValue = UniqueId;
         errorLogEntry->FinalStatus = STATUS_SUCCESS;
         errorLogEntry->DumpDataSize = 0;

         IoWriteErrorLogEntry(errorLogEntry);
     }
}

VOID
SpLogResetMsg(
    IN PADAPTER_EXTENSION  DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN ULONG               UniqueId
    )

/*++

Routine Description:

    This function logs a message in the system event log when a bus has
    been reset in response to a request from some caller.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    Srb             - Supplies a pointer to the request which timed-out.

    UniqueId        - Supplies the UniqueId for this error.

Return Value:

    None.

Notes:

    The port device extension spinlock should be held when this routine is
    called.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PIO_STACK_LOCATION   irpStack;
    PSRB_DATA            srbData;
    PIRP                 irp;
    ULONG                dataEntries;
    UCHAR                packetSize;
    ULONG                ioctl;
    UCHAR                function;
    UCHAR                pathId;

    ASSERT(Srb != NULL);

    pathId  = Srb->PathId;
    ioctl   = Srb->TimeOutValue;
    srbData = Srb->OriginalRequest;
    ASSERT(srbData != NULL);
    ASSERT_SRB_DATA(srbData);
    irp = srbData->CurrentIrp;

    if (irp) {
        irpStack = IoGetCurrentIrpStackLocation(irp);
        function = irpStack->MajorFunction;
    } else {
        function = 0;
    }

    dataEntries = 2;
    packetSize = (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + 
                         (dataEntries * sizeof(ULONG))); 

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                                                  DeviceExtension->DeviceObject, 
                                                                  packetSize);

    if (errorLogEntry != NULL) {
        errorLogEntry->ErrorCode         = IO_WARNING_BUS_RESET;
        errorLogEntry->MajorFunctionCode = function;
        errorLogEntry->UniqueErrorValue  = UniqueId;
        errorLogEntry->FinalStatus       = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize      = (USHORT)(dataEntries * sizeof(ULONG));
        errorLogEntry->DumpData[0]       = pathId;
        errorLogEntry->DumpData[1]       = ioctl;

        IoWriteErrorLogEntry(errorLogEntry);
    }
}
 
 VOID
 SpLogResetError(
     IN PADAPTER_EXTENSION DeviceExtension,
     IN PLOGICAL_UNIT_EXTENSION Lun,
     IN ULONG UniqueId
     )

 /*++

 Routine Description:

     This function logs an error when the bus is reset.

 Arguments:

     DeviceExtension - Supplies a pointer to the port device extension.

     Lun - Supplies a pointer to the LUN on which the timeout occurred.

     UniqueId - Supplies the UniqueId for this error.

 Return Value:

     None.

 Notes:

     The port device extension spinlock should be held when this routine is
     called.

 --*/

 {
     PIO_ERROR_LOG_PACKET errorLogEntry;
     PIO_STACK_LOCATION   irpStack;
     PIRP                 irp;
     PSRB_DATA            srbData;
     ULONG                sequenceNumber = 0;
     UCHAR                function       = 0,
                          pathId         = 0,
                          targetId       = 0,
                          lun            = 0,
                          retryCount     = 0;
     PSCSI_REQUEST_BLOCK  srb;

     //
     // Extract the PathId, TargetId, and LUN from the logical unit.
     //

     pathId = Lun->PathId;
     targetId = Lun->TargetId;
     lun = Lun->Lun;

     //
     // If an untagged request is active on the LUN, we know it is the request
     // that timed out.  Otherwise, we can't conclusively say which request it
     // was - if more that one tagged request is active.
     //

     srb = Lun->CurrentUntaggedRequest ?
              Lun->CurrentUntaggedRequest->CurrentSrb : NULL;

     //
     // If we have the SRB, we can extract a little more useful information.
     //

     if (srb) {

         srbData = srb->OriginalRequest;

         ASSERT(srbData != NULL);
         ASSERT_SRB_DATA(srbData);

         irp = srbData->CurrentIrp;

         if (irp) {
             irpStack = IoGetCurrentIrpStackLocation(irp);
             function = irpStack->MajorFunction;
         }

         retryCount     = (UCHAR) srbData->ErrorLogRetryCount;
         sequenceNumber = srbData->SequenceNumber;
     }

 #define ERRLOG_DATA_ENTRIES 4

     errorLogEntry = (PIO_ERROR_LOG_PACKET)
         IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                 (sizeof(IO_ERROR_LOG_PACKET) +
                                  (ERRLOG_DATA_ENTRIES * sizeof(ULONG))));

     if (errorLogEntry != NULL) {
         errorLogEntry->ErrorCode         = IO_ERR_TIMEOUT;
         errorLogEntry->SequenceNumber    = sequenceNumber;
         errorLogEntry->MajorFunctionCode = function;
         errorLogEntry->RetryCount        = retryCount;
         errorLogEntry->UniqueErrorValue  = UniqueId;
         errorLogEntry->FinalStatus       = STATUS_SUCCESS;
         errorLogEntry->DumpDataSize      = ERRLOG_DATA_ENTRIES * sizeof(ULONG);
         errorLogEntry->DumpData[0]       = pathId;
         errorLogEntry->DumpData[1]       = targetId;
         errorLogEntry->DumpData[2]       = lun;
         errorLogEntry->DumpData[3]       = SP_REQUEST_TIMEOUT;

         IoWriteErrorLogEntry(errorLogEntry);
     }
 #undef ERRLOG_DATA_ENTRIES
 }

 
 BOOLEAN
 SpResetBusSynchronized (
     PVOID ServiceContext
     )
 /*++

 Routine Description:

     This function resets the bus and sets up the port timer so the reset hold
     flag is clean when necessary.

 Arguments:

     ServiceContext - Supplies a pointer to the reset context which includes a
         pointer to the device extension and the pathid to be reset.

 Return Value:

     TRUE - if the reset succeeds.

 --*/

 {
     PRESET_CONTEXT resetContext = ServiceContext;
     PADAPTER_EXTENSION deviceExtension;

     BOOLEAN result;

     deviceExtension = resetContext->DeviceExtension;

     if(TEST_FLAG(deviceExtension->InterruptData.InterruptFlags,
                  PD_ADAPTER_REMOVED)) {
         return FALSE;
     }

     result = deviceExtension->HwResetBus(deviceExtension->HwDeviceExtension,
                                          resetContext->PathId);

     //
     // Set the reset hold flag and start the counter.
     //

     deviceExtension->InterruptData.InterruptFlags |= PD_RESET_HOLD;
     deviceExtension->PortTimeoutCounter = 
         deviceExtension->ResetHoldTime;

     //
     // Check for miniport work requests.
     //

     if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

         //
         // Queue a DPC.
         //

         SpRequestCompletionDpc(deviceExtension->CommonExtension.DeviceObject);
     }

     return(result);
 }
 
 VOID
 SpProcessCompletedRequest(
     IN PADAPTER_EXTENSION DeviceExtension,
     IN PSRB_DATA SrbData,
     OUT PBOOLEAN CallStartIo
     )
 /*++
 Routine Description:

     This routine processes a request which has completed.  It completes any
     pending transfers, releases the adapter objects and map registers when
     necessary.  It deallocates any resources allocated for the request.
     It processes the return status, by requeueing busy request, requesting
     sense information or logging an error.

 Arguments:

     DeviceExtension - Supplies a pointer to the device extension for the
         adapter data.

     SrbData - Supplies a pointer to the SRB data block to be completed.

     CallStartIo - This value is set if the start I/O routine needs to be
         called.

 Return Value:

     None.

 --*/

 {

     PLOGICAL_UNIT_EXTENSION  logicalUnit;
     PSCSI_REQUEST_BLOCK      srb;
     PIO_ERROR_LOG_PACKET     errorLogEntry;
     ULONG                    sequenceNumber;
     LONG                     interlockResult;
     PIRP                     irp;
     PDEVICE_OBJECT           deviceObject = DeviceExtension->DeviceObject;
     NTSTATUS                 internalStatus = SrbData->InternalStatus;

     ASSERT_SRB_DATA(SrbData);

     srb = SrbData->CurrentSrb;
     irp = SrbData->CurrentIrp;
     logicalUnit = SrbData->LogicalUnit;

     //
     // If miniport needs mapped system addresses, then the data buffer 
     // address in the SRB must be restored to original unmapped virtual
     // address. Ensure that this request requires a data transfer.
     //

     if (TEST_FLAG(srb->SrbFlags, SRB_FLAGS_UNSPECIFIED_DIRECTION)) {

         //
         // Restore the data buffer pointer to the original value.
         //

         PVOID dataBuffer = srb->DataBuffer;
         srb->DataBuffer = SrbData->OriginalDataBuffer;

         //
         // If we map every transfer then obviously we need to flush now.
         // However, the only way we know that we've forced a mapping for a
         // particular command (like we will for INQUIRY & REQUEST_SENSE...see
         // IS_MAPPED_SRB) is to see if there's a RemappedMdl.
         //
         // NOTE: this will not figure out if a miniport which did not
         // originally request mapped buffers needs to have the caches flushed
         // unless we're remapping buffers. So a 32-bit driver on a 32-bit
         // system will not get through here when completing an INQUIRY command.
         // This should be okay - most drivers which need INQUIRYs mapped do so
         // because they write to the memory normally, not because they're using
         // PIO to get the data from machine registers.
         //

         if (DeviceExtension->MapBuffers || 
             SrbData->RemappedMdl ||
             IS_READ_CAPACITY(srb)) {

             if (irp->MdlAddress) {

                 //
                 // If an IRP is for a transfer larger than a miniport driver
                 // can handle, the request is broken up into multiple smaller
                 // requests. Each request uses the same MDL and the data
                 // buffer address field in the SRB may not be at the
                 // beginning of the memory described by the MDL.
                 //

                 //
                 // Since this driver did programmaged I/O, then the buffer
                 // needs to be flushed if this an data-in transfer.
                 //

                 if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

                     KeFlushIoBuffers(irp->MdlAddress,
                                      TRUE,
                                      FALSE);
                 }
             }

#if defined(NEWQUEUE)
             //
             // In order to distribute IO requests across the medium, the port
             // driver intercepts READ CAPACITY commands so it knows the medium's
             // capacity in sectors.  We ensured that DataBuffer points to a
             // mapping of the buffer by adding SCSIOP_READ_CAPACITY to the
             // IS_MAPPED_SRB macro that forces the buffer to be mapped even if
             // the miniport does not require mapped buffers.
             //

             if (IS_READ_CAPACITY(srb) &&
                 srb->SrbStatus == SRB_STATUS_SUCCESS) {

                 ASSERT(dataBuffer != NULL);
                 if (srb->DataTransferLength == 8) {

                     PREAD_CAPACITY_DATA readCapacityData;
                     ULONG               lastSector;
                     PFOUR_BYTE          tmp;
                     ULONG               zones;
                     ULONG               roundedUpSize;
                  
                     //
                     // Copy last sector in reverse byte order.
                     //

                     readCapacityData = (PREAD_CAPACITY_DATA) dataBuffer;
                     tmp = (PFOUR_BYTE) &readCapacityData->LogicalBlockAddress;

                     ((PFOUR_BYTE)&lastSector)->Byte0 = tmp->Byte3;
                     ((PFOUR_BYTE)&lastSector)->Byte1 = tmp->Byte2;
                     ((PFOUR_BYTE)&lastSector)->Byte2 = tmp->Byte1;
                     ((PFOUR_BYTE)&lastSector)->Byte3 = tmp->Byte0;

                     //
                     // If the capacity has changed, update the zone parameters.
                     //

                     if (((lastSector + 1) != logicalUnit->Capacity) &&
                         ((lastSector + 1) >= logicalUnit->Zones)) {
    
                         //
                         // The media should never have fewer sectors than we have zones.
                         //

                         zones = logicalUnit->Zones;

                         //
                         // Save the new capacity.
                         //
    
                         logicalUnit->Capacity = lastSector + 1;
    
                         //
                         // Round the last sector up to an even multiple of the number
                         // of zones.  Note that this implies that the number of zones 
                         // must be a power of 2.
                         //
    
                         roundedUpSize = lastSector + 1;
                         roundedUpSize = (roundedUpSize + (zones - 1)) & ~(zones - 1);
    
                         //
                         // Initialize the zone length.
                         //
    
                         logicalUnit->ZoneLength = roundedUpSize / logicalUnit->Zones;
    
                         //
                         // Initialize the first sector of each zone.
                         //
    
                         logicalUnit->FirstSector[0] = 0;
                         logicalUnit->FirstSector[1] = logicalUnit->ZoneLength;
                         logicalUnit->FirstSector[2] = logicalUnit->ZoneLength * 2;
                         logicalUnit->FirstSector[3] = logicalUnit->ZoneLength * 3;
    
                         //
                         // Initialize the last sector of each zone.
                         //
    
                         logicalUnit->LastSector[0] = logicalUnit->ZoneLength - 1;
                         logicalUnit->LastSector[1] = (logicalUnit->ZoneLength * 2) - 1;
                         logicalUnit->LastSector[2] = (logicalUnit->ZoneLength * 3) - 1;
                         logicalUnit->LastSector[3] = lastSector;
    
                         DebugPrint((1, "SpProcessCompletedRequest: SRB:%p "
                                     "(p:%d t:%d l:%d) Capacity:%x\n", 
                                     srb, srb->PathId, srb->TargetId, 
                                     srb->Lun, logicalUnit->Capacity));
                     }
                 }
             }
#endif // NEWQUEUE

             //
             // If this request has a remapped buffer then unmap it and release
             // the remapped MDL.
             //

             if(SrbData->RemappedMdl) {
                 PVOID remappedAddress;

                 ASSERT(TEST_FLAG(SrbData->RemappedMdl->MdlFlags,
                                  MDL_MAPPED_TO_SYSTEM_VA));

#if defined(FORWARD_PROGRESS)
                 if (TEST_FLAG(SrbData->Flags, SRB_DATA_RESERVED_PAGES)) {

                     DebugPrint((1, "SpProcessCompletedRequest: unmapping remapped buffer from reserved range DevExt:%p srb:%p\n",
                                 DeviceExtension, srb));

                     //
                     // This request is using the adapter's reserved PTE range
                     // to map the MDL's pages.  Unmap the pages and release
                     // our claim on the reserve range.
                     //

                     KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

                     ASSERT(TEST_FLAG(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE));
                     MmUnmapReservedMapping(DeviceExtension->ReservedPages,
                                            SCSIPORT_TAG_MAPPING_LIST,
                                            SrbData->RemappedMdl);

                     CLEAR_FLAG(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE);
                     KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                     CLEAR_FLAG(SrbData->Flags, SRB_DATA_RESERVED_PAGES);

                 } else {

                     remappedAddress = SpGetSystemAddressForMdlSafe(
                                           SrbData->RemappedMdl,
                                           ((irp->RequestorMode == KernelMode) ? 
                                            HighPagePriority : NormalPagePriority));
                     if (remappedAddress != NULL) {
                         MmUnmapLockedPages(remappedAddress, SrbData->RemappedMdl);
                     }

                 }

                 //
                 // Check if the request is using the adapter's reserved MDL.
                 // If it is, we don't free it.
                 //

                 if (TEST_FLAG(SrbData->Flags, SRB_DATA_RESERVED_MDL)) {

                     DebugPrint((1, "SpProcessCompletedRequest: releasing reserved MDL DevExt:%p srb:%p\n",
                                 DeviceExtension, srb));

                     //
                     // This request is using the adapter's reserved MDL.
                     // Release our claim on it now so another request can
                     // use it.
                     //

                     KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
                     ASSERT(TEST_FLAG(DeviceExtension->Flags, PD_RESERVED_MDL_IN_USE));
                     CLEAR_FLAG(DeviceExtension->Flags, PD_RESERVED_MDL_IN_USE);
                     KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                     CLEAR_FLAG(SrbData->Flags, SRB_DATA_RESERVED_MDL);

                 } else {

                     IoFreeMdl(SrbData->RemappedMdl);

                 }
#else
                 remappedAddress = SpGetSystemAddressForMdlSafe(
                                       SrbData->RemappedMdl,
                                       ((irp->RequestorMode == KernelMode) ?
                                        HighPagePriority : NormalPagePriority));
                 if (remappedAddress != NULL) {
                     MmUnmapLockedPages(remappedAddress, SrbData->RemappedMdl);
                 }
                 IoFreeMdl(SrbData->RemappedMdl);
#endif
                 SrbData->RemappedMdl = NULL;
             }
         }
     }

     //
     // Flush the adapter buffers if necessary.
     //

     if (SrbData->MapRegisterBase) {

         PCHAR dataVirtualAddress;

         //
         // For a master device that scsiport considers a slave, we store the
         // map register base in the SRB_DATA without regard for whether the
         // request is actually an IO request (see ScsiPortAllocationRoutine),
         // so we must check if there is a valid MDL before calling into MM
         // for the VA - passing NULL to MmGetMdlVirtualAddress will crash
         // the system.
         //

         if (irp->MdlAddress != NULL) {

             dataVirtualAddress = (PCHAR)MmGetMdlVirtualAddress(irp->MdlAddress);

             //
             // Because we're using the base address of the original MDL, we
             // compensate for the offset of the srb's data buffer.
             //

             dataVirtualAddress += SrbData->DataOffset;

         } else {

             dataVirtualAddress = 0;
         }

         if (DeviceExtension->MasterWithAdapter == TRUE) {
             PutScatterGatherList(
                 DeviceExtension->DmaAdapterObject,
                 SrbData->MapRegisterBase,
                 (BOOLEAN)(srb->SrbFlags & SRB_FLAGS_DATA_IN ? FALSE : TRUE));

             SrbData->ScatterGatherList = NULL;
         } else {
             //
             // Free the map registers.
             //

             FreeMapRegisters(DeviceExtension->DmaAdapterObject,
                              SrbData->MapRegisterBase,
                              SrbData->NumberOfMapRegisters);
         }

         //
         // Clear the MapRegisterBase.
         //

         SrbData->MapRegisterBase = NULL; 
     }

     //
     // Clear the current untagged request if this one is it.
     //
         
     if(SrbData == logicalUnit->CurrentUntaggedRequest) {
         ASSERT(SrbData->CurrentSrb->QueueTag == SP_UNTAGGED);
         logicalUnit->CurrentUntaggedRequest = NULL;
     }

#if defined(FORWARD_PROGRESS)
     //
     // If we used the adapter's reserved range on this request, we need to
     // unmap the pages and start the next request if the miniport is ready
     // for it.
     //
         
     if (TEST_FLAG(SrbData->Flags, SRB_DATA_RESERVED_PAGES)) {
             
         DebugPrint((1, "SpProcessCompletedRequest: unmapping reserved range DevExt:%p SRB:%p\n", 
                     DeviceExtension, srb));

         KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
             
         //
         // The reserved pages should be in use.
         //
             
         ASSERT(TEST_FLAG(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE));

         //
         // Unmap the reserved pages.
         //
             
         MmUnmapReservedMapping(DeviceExtension->ReservedPages,
                                SCSIPORT_TAG_MAPPING_LIST,
                                irp->MdlAddress);

         //
         // Indicate that the reserved pages are no longer in use so the
         // next request can be started.
         //
             
         CLEAR_FLAG(SrbData->Flags, SRB_DATA_RESERVED_PAGES);
         CLEAR_FLAG(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE);
             
         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
             
     }
#endif

     //
     // If the no disconnect flag was set for this SRB, then check to see
     // if SpStartNextPacket must be called.
     //

     if (TEST_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_DISCONNECT)) {

         //
         // Acquire the spinlock to protect the flags strcuture.
         //

         KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

         //
         // Set the disconnect running flag and check the busy flag.
         //

         SET_FLAG(DeviceExtension->Flags, PD_DISCONNECT_RUNNING);

         //
         // The interrupt flags are checked unsynchonized.  This works because
         // the RESET_HOLD flag is cleared with the spinlock held and the
         // counter is only set with the spinlock held.  So the only case where
         // there is a problem is is a reset occurs before this code get run,
         // but this code runs before the timer is set for a reset hold;
         // the timer will soon set for the new value.
         //

         if (!TEST_FLAG(DeviceExtension->InterruptData.InterruptFlags,
                        PD_RESET_HOLD)) {

             //
             // The miniport is ready for the next request and there is not a
             // pending reset hold, so clear the port timer.
             //

             DeviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;
         }

         //
         // Release the spinlock.
         //

         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

         if (!(*CallStartIo) &&
             !TEST_FLAG(DeviceExtension->Flags, (PD_DEVICE_IS_BUSY |
                                                 PD_PENDING_DEVICE_REQUEST))) {

             //
             // The busy flag is clear so the miniport has requested the
             // next request. Call SpStartNextPacket.
             //

             SpStartNextPacket(DeviceExtension->DeviceObject, FALSE);
         }
     }

     //
     // Move bytes transfered to IRP.
     //

     irp->IoStatus.Information = srb->DataTransferLength;

     //
     // Save the sequence number in case an error needs to be logged later.
     //

     sequenceNumber = SrbData->SequenceNumber;
     SrbData->ErrorLogRetryCount = 0;

     //
     // Acquire the spinlock to protect the flags structure,
     // and the free of the srb extension.
     //

     KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

     //
     // Free SrbExtension to list if necessary.
     //

     if (srb->SrbExtension) {

         if ((srb->Function != SRB_FUNCTION_WMI) &&
             DeviceExtension->AutoRequestSense &&
             (srb->SenseInfoBuffer != NULL)) {

             ASSERT(SrbData->RequestSenseSave != NULL ||
                    srb->SenseInfoBuffer == NULL);

             //
             // If the request sense data is valid then copy the data to the
             // real buffer.
             //

             if (TEST_FLAG(srb->SrbStatus, SRB_STATUS_AUTOSENSE_VALID)) {

                 //
                 // If WMI Sense Data events are enabled for this adapter, fire
                 // the event.
                 //

                 if (DeviceExtension->EnableSenseDataEvent) {

                     NTSTATUS status;

                     status = SpFireSenseDataEvent(srb, deviceObject);
                     if (status != STATUS_SUCCESS) {

                         DebugPrint((1, "Failed to send SenseData WMI event (%08X)\n", status));

                     }                
                 }

                 //
                 // Check the srb flags to see if we are supposed to allocate
                 // the sense data buffer.  The buffer we allocate  will be
                 // freed for us by whoever is requesting us to do the 
                 // allocation.
                 //

                 if (srb->SrbFlags & SRB_FLAGS_PORT_DRIVER_ALLOCSENSE) {

                     PSENSE_DATA ReturnBuffer;
                     UCHAR AlignmentFixup;
                     ULONG BufferSize;

                     //
                     // We communicate the scsi port number to the class driver
                     // by allocating enough space in the sense buffer and
                     // copying it there.  We align the location into which we
                     // copy the port number on a 4-byte boundary.
                     //

                     AlignmentFixup = 
                         ((srb->SenseInfoBufferLength + 3) & ~3)
                         - srb->SenseInfoBufferLength;

                     BufferSize = srb->SenseInfoBufferLength
                                  + AlignmentFixup
                                  + sizeof(ULONG64);

                     ReturnBuffer = SpAllocatePool(
                                        NonPagedPoolCacheAligned,
                                        BufferSize,
                                        SCSIPORT_TAG_SENSE_BUFFER,
                                        deviceObject->DriverObject);

                     if (ReturnBuffer) {

                         PULONG PortNumber;

                         //
                         // Set a flag in the SRB to indicate that we have 
                         // allocated a new sense buffer and that the class
                         // driver must free it.
                         //

                         SET_FLAG(srb->SrbFlags, 
                                  SRB_FLAGS_FREE_SENSE_BUFFER);
                         
                         //
                         // We've successfully allocated a sense buffer.
                         // Set a flag in the srb flags to indicate that
                         // the scsi port number resides adjacent to the
                         // sense info.
                         //

                         srb->SrbFlags |= SRB_FLAGS_PORT_DRIVER_SENSEHASPORT;

                         //
                         // Initialize a pointer to the location at the end of
                         // the sense buffer into which we copy the scsi port
                         // number.
                         //

                         PortNumber = (PULONG)((PUCHAR)ReturnBuffer 
                                               + srb->SenseInfoBufferLength
                                               + AlignmentFixup);
                         *PortNumber = DeviceExtension->PortNumber;

                         //
                         // Overwrite the pointer we've saved to the original
                         // sense buffer passed down to us with the one we've
                         // allocated.  This is where we will copy the sense
                         // data we've collected in our own buffer.
                         //

                         SrbData->RequestSenseSave = ReturnBuffer;

                     } else {

                         srb->SenseInfoBufferLength = 
                             SrbData->RequestSenseLengthSave;

                     }

                 } else {

                     //
                     // Restore the original sense info buffer length which we
                     // modified in SpAllocateSrbExtension.  We modified then
                     // to reflect the adapter specified size.
                     //

                     srb->SenseInfoBufferLength = SrbData->RequestSenseLengthSave;

                 }

                 //
                 // Copy the sense info we've collected in our own buffer into
                 // a buffer that is returned back up the stack.  This may be
                 // the buffer supplied to us, or it may be one we've allocated.
                 //

                 RtlCopyMemory(SrbData->RequestSenseSave,
                               srb->SenseInfoBuffer,
                               srb->SenseInfoBufferLength);

             } else {

                 //
                 // If there is no request sense data, restore the request sense
                 // length.
                 //

                 srb->SenseInfoBufferLength = SrbData->RequestSenseLengthSave;

             }

             //
             // Restore the SenseInfoBuffer pointer in the srb.
             //

             srb->SenseInfoBuffer = SrbData->RequestSenseSave;

         }

         if (SpVerifyingCommonBuffer(DeviceExtension)) {

             SpInsertSrbExtension(DeviceExtension,
                                  srb->SrbExtension);

         } else {

             *((PVOID *) srb->SrbExtension) = DeviceExtension->SrbExtensionListHeader;
             DeviceExtension->SrbExtensionListHeader = srb->SrbExtension;

         }
     }

     //
     // Decrement the queue count for the logical unit.
     //

     logicalUnit->QueueCount--;

     if (DeviceExtension->Flags & PD_PENDING_DEVICE_REQUEST) {

         //
         // The start I/O routine needs to be called because it could not
         // allocate an srb extension.  Clear the pending flag and note
         // that it needs to be called later.
         //

         DebugPrint(((deviceObject->CurrentIrp == NULL) ? 0 : 2,
                     "SpProcessCompletedRequest(%#p): will call start "
                     "i/o when we return to process irp %#p\n",
                     SrbData,
                     deviceObject->CurrentIrp));
         ASSERT(deviceObject->CurrentIrp != NULL);

         DeviceExtension->Flags &= ~PD_PENDING_DEVICE_REQUEST;
         *CallStartIo = TRUE;
     }

     //
     // If success then start next packet.
     // Not starting packet effectively
     // freezes the queue.
     //

     if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) {

         irp->IoStatus.Status = STATUS_SUCCESS;

         //
         // If the queue is being bypassed then keep the queue frozen.
         // If there are outstanding requests as indicated by the timer
         // being active then don't start the then next request.
         //

         if(!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE) &&
             logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

             //
             // This is a normal request start the next packet.
             //

             GetNextLuRequest(logicalUnit);

         } else {

             //
             // Release the spinlock.
             //

             KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

         }

         DebugPrint((3,
                     "SpProcessCompletedRequests: Iocompletion IRP %p\n",
                     irp));

         //
         // Note that the retry count and sequence number are not cleared
         // for completed packets which were generated by the port driver.
         //

         srb->OriginalRequest = irp;

         SpReleaseRemoveLock(deviceObject, irp);
         SpCompleteRequest(deviceObject, irp, SrbData, IO_DISK_INCREMENT);

         //
         // Decrement the number of active requests.  If the count is negitive, and
         // this is a slave with an adapter then free the adapter object and
         // map registers.  Doing this allows another request to be started for
         // this logical unit before adapter is released.
         //

         interlockResult = InterlockedDecrement( &DeviceExtension->ActiveRequestCount );

         if ((interlockResult < 0) &&
             (!DeviceExtension->PortConfig->Master) &&
             (DeviceExtension->DmaAdapterObject != NULL)) {

             //
             // Clear the map register base for safety.
             //

             DeviceExtension->MapRegisterBase = NULL;

             FreeAdapterChannel(DeviceExtension->DmaAdapterObject);
         }

         return;

     }

     //
     // Decrement the number of active requests.  If the count is negative, and
     // this is a slave with an adapter then free the adapter object and
     // map registers.
     //

     interlockResult = InterlockedDecrement( &DeviceExtension->ActiveRequestCount );

     if (interlockResult < 0 &&
         !DeviceExtension->PortConfig->Master &&
         DeviceExtension->DmaAdapterObject != NULL) {

         //
         // Clear the map register base for safety.
         //

         DeviceExtension->MapRegisterBase = NULL;

         FreeAdapterChannel(DeviceExtension->DmaAdapterObject);
     }

     //
     // Set IRP status. Class drivers will reset IRP status based
     // on request sense if error.
     //

     if(srb->SrbStatus != SRB_STATUS_INTERNAL_ERROR) {
         irp->IoStatus.Status = SpTranslateScsiStatus(srb);
     } else {
         ASSERT(srb->ScsiStatus == 0xff);
         ASSERT(logicalUnit->ActiveFailedRequest != SrbData);
         ASSERT(logicalUnit->BlockedFailedRequest != SrbData);
         srb->InternalStatus = internalStatus;
         irp->IoStatus.Status = internalStatus;
    }

    DebugPrint((2, "SpProcessCompletedRequests: Queue frozen TID %d\n",
        srb->TargetId));

    //
    // Perform busy processing if a busy type status was returned and this
    // is not a recovery request.
    //
    // For now we're choosing to complete the SRB's with BYPASS_FROZEN_QUEUE
    // set in them if they are completed as BUSY.
    // Though if we wanted to do busy processing on them, the
    // if statement below should be changed, along with the next if statement
    // to get them to be placed on the lun-extension slot, and then
    // modify the scsiport tick handler so that it will retry SRB's
    // that have the BYPASS_FROZEN_QUEUE flag set when the queue is frozen.
    //

    if ((srb->ScsiStatus == SCSISTAT_BUSY ||
         srb->SrbStatus == SRB_STATUS_BUSY ||
         srb->ScsiStatus == SCSISTAT_QUEUE_FULL) &&
         !(srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

        DebugPrint((1,
                   "SCSIPORT: Busy SRB status %x, SCSI status %x)\n",
                   srb->SrbStatus,
                   srb->ScsiStatus));

        //
        // Restore the request transfer length in case the miniport
        // destroyed it.
        //

        srb->DataTransferLength = SrbData->OriginalDataTransferLength;

        //
        // If the logical unit is already busy then just requeue this request.
        // Unless the SRB is a BYPASS_LOCKED_QUEUE SRB
        //

        if ((TEST_FLAG(logicalUnit->LuFlags, LU_LOGICAL_UNIT_IS_BUSY)) &&
            (!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE))) {

            DebugPrint((1,
                       "SpProcessCompletedRequest: Requeuing busy request\n"));

            srb->SrbStatus = SRB_STATUS_PENDING;
            srb->ScsiStatus = 0;

            //
            // Set the tick count so we know how long this request has
            // been queued.
            //

            SrbData->TickCount = DeviceExtension->TickCount;

            SpForceRequestIntoLuQueue(
                &logicalUnit->DeviceObject->DeviceQueue,
                &irp->Tail.Overlay.DeviceQueueEntry,
                srb->QueueSortKey,
                logicalUnit->BusyRequest);

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            return;

        } else if (logicalUnit->RetryCount++ < BUSY_RETRY_COUNT) {

            PKDEVICE_QUEUE_ENTRY packet;
            PIRP nextIrp;
            
            //
            // If busy status is returned, then indicate that the logical
            // unit is busy.  The timeout code will restart the request
            // when it fires. Reset the status to pending.
            //

            srb->SrbStatus = SRB_STATUS_PENDING;
            srb->ScsiStatus = 0;

            SET_FLAG(logicalUnit->LuFlags, LU_LOGICAL_UNIT_IS_BUSY);
            logicalUnit->BusyRequest = SrbData;

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            return;

        } else {

            //
            // Freeze the queue if it isn't already locked.
            //

            if((!TEST_FLAG(logicalUnit->LuFlags, LU_QUEUE_LOCKED)) &&
                !TEST_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE)) {

                SET_FLAG(srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
                SET_FLAG(logicalUnit->LuFlags, LU_QUEUE_FROZEN);
            }

            //
            // Clear the queue full flag.
            //

            CLEAR_FLAG(logicalUnit->LuFlags, LU_QUEUE_IS_FULL);

            //
            // Log an a timeout erorr.
            //

            #define ERRLOG_DATA_ENTRIES 6

            errorLogEntry = (PIO_ERROR_LOG_PACKET)
                IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                        (sizeof(IO_ERROR_LOG_PACKET) +
                                         (ERRLOG_DATA_ENTRIES * sizeof(ULONG))));

            if (errorLogEntry != NULL) {
                errorLogEntry->ErrorCode = IO_ERR_NOT_READY;
                errorLogEntry->SequenceNumber = sequenceNumber;
                errorLogEntry->MajorFunctionCode =
                   IoGetCurrentIrpStackLocation(irp)->MajorFunction;
                errorLogEntry->RetryCount = logicalUnit->RetryCount;
                errorLogEntry->UniqueErrorValue = 259;
                errorLogEntry->FinalStatus = STATUS_DEVICE_NOT_READY;
                errorLogEntry->DumpDataSize = ERRLOG_DATA_ENTRIES * sizeof(ULONG);
                errorLogEntry->DumpData[0] = srb->PathId;
                errorLogEntry->DumpData[1] = srb->TargetId;
                errorLogEntry->DumpData[2] = srb->Lun;
                errorLogEntry->DumpData[3] = srb->ScsiStatus;
                errorLogEntry->DumpData[4] = SP_REQUEST_TIMEOUT;
                errorLogEntry->DumpData[5] = srb->SrbStatus;

                IoWriteErrorLogEntry(errorLogEntry);
            }
            #undef ERRLOG_DATA_ENTRIES

            irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;

            //
            // Fall through and complete this as a failed request.  This that ensures 
            // we propagate ourselves by handling any queued requests.
            //
        }

    }

    //
    // If the request sense data is valid, or none is needed and this request
    // is not going to freeze the queue, then start the next request for this
    // logical unit if it is idle.
    //

    if (!NEED_REQUEST_SENSE(srb) &&
        TEST_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE)) {

        if (logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

            GetNextLuRequest(logicalUnit);

            //
            // The spinlock is released by GetNextLuRequest.
            //


        } else {

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        }

    } else {

        //
        // NOTE:  This will also freeze the queue.  For a case where there
        // is no request sense.
        //

        //
        // Don't freeze the queue if it's already been locked.  Frozen and
        // locked queue are mutually exclusive.
        //

        if(!TEST_FLAG(logicalUnit->LuFlags, LU_QUEUE_LOCKED)) {

            //
            // If the caller asked us not to freeze the queue and we don't need
            // to do a request sense then don't freeze the queue.  If we do
            // need to do a request sense then the queue will be unfrozen
            // once it's finished.
            //

            if(!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE) ||
               NEED_REQUEST_SENSE(srb)) {
                SET_FLAG(srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
                SET_FLAG(logicalUnit->LuFlags, LU_QUEUE_FROZEN);
            }
        }

        //
        // Determine if a REQUEST SENSE command needs to be done.
        // Check that a CHECK_CONDITION was received, an autosense has not
        // been done already, and that autosense has been requested.
        //

        if (NEED_REQUEST_SENSE(srb)) {

            //
            // If a request sense is going to be issued then any busy
            // requests must be requeue so that the time out routine does
            // not restart them while the request sense is being executed.
            //

            if (TEST_FLAG(logicalUnit->LuFlags, LU_LOGICAL_UNIT_IS_BUSY)) {

                DebugPrint((1, "SpProcessCompletedRequest: Requeueing busy "
                               "request to allow request sense.\n"));

                //
                // Set the tick count so we know how long this request has
                // been queued.
                //

                SrbData->TickCount = DeviceExtension->TickCount;

                if (!KeInsertByKeyDeviceQueue(
                    &logicalUnit->CommonExtension.DeviceObject->DeviceQueue,
                    &logicalUnit->BusyRequest->CurrentIrp->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey)) {

                    //
                    // This should never occur since there is a busy request.
                    // Complete the current request without request sense
                    // informaiton.
                    //

                    ASSERT(FALSE);
                    DebugPrint((3, "SpProcessCompletedRequests: Iocompletion IRP %p\n", irp ));

                    //
                    // Release the spinlock.
                    //

                    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                    SpReleaseRemoveLock(deviceObject, irp);
                    SpCompleteRequest(deviceObject, irp, SrbData, IO_DISK_INCREMENT);
                    return;

                }

                //
                // Clear the busy flag.
                //

                logicalUnit->LuFlags &= ~(LU_LOGICAL_UNIT_IS_BUSY | LU_QUEUE_IS_FULL);

            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            //
            // Call IssueRequestSense and it will complete the request
            // after the REQUEST SENSE completes.
            //

            IssueRequestSense(DeviceExtension, srb);

            return;

        } else {
            ASSERTMSG("Srb is failed request but doesn't indicate needing requests sense: ",
                      ((SrbData != logicalUnit->ActiveFailedRequest) &&
                       (SrbData != logicalUnit->BlockedFailedRequest)));
        }

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    }

    SpReleaseRemoveLock(deviceObject, irp);
    SpCompleteRequest(deviceObject, irp, SrbData, IO_DISK_INCREMENT);
}

PSRB_DATA
SpGetSrbData(
    IN PADAPTER_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    UCHAR QueueTag,
    BOOLEAN AcquireBinLock
    )

/*++

Routine Description:

    This function returns the SRB data for the addressed unit.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    Address - Supplies the address of the logical unit.

    QueueTag - Supplies the queue tag if the request is tagged.

Return Value:

    Returns a pointer to the SRB data.  NULL is returned if the address is not
    valid.

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    //
    // We're going to have to search the appropriate logical unit for this
    // request.
    //

    logicalUnit = GetLogicalUnitExtension(DeviceExtension,
                                          PathId,
                                          TargetId,
                                          Lun,
                                          FALSE,
                                          AcquireBinLock);

    if(logicalUnit == NULL) {
        return NULL;
    }

    //
    // Check for an untagged request.
    //

    if (QueueTag == SP_UNTAGGED) {

        return logicalUnit->CurrentUntaggedRequest;

    } else {

        PLIST_ENTRY listEntry;

        for(listEntry = logicalUnit->RequestList.Flink;
            listEntry != &(logicalUnit->RequestList);
            listEntry = (PLIST_ENTRY) listEntry->Flink) {

            PSRB_DATA srbData;

            srbData = CONTAINING_RECORD(listEntry,
                                        SRB_DATA,
                                        RequestList);

            if(srbData->CurrentSrb->QueueTag == QueueTag) {
                return srbData;
            }
        }
        return NULL;
    }
}



VOID
SpCompleteSrb(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    IN UCHAR SrbStatus
    )
/*++

Routine Description:

    The routine completes the specified request.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    SrbData - Supplies a pointer to the SrbData for the request to be
        completed.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb;

    //
    // Make sure there is a current request.
    //

    srb = SrbData->CurrentSrb;

    if (srb == NULL || !(srb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {
        return;
    }

    //
    // Update SRB status.
    //

    srb->SrbStatus = SrbStatus;

    //
    // Indicate no bytes transferred.
    //

    srb->DataTransferLength = 0;

    //
    // Call notification routine.
    //

    ScsiPortNotification(RequestComplete,
                DeviceExtension->HwDeviceExtension,
                srb);

}

BOOLEAN
SpAllocateSrbExtension(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT BOOLEAN *StartNextRequest,
    OUT BOOLEAN *Tagged
    )
/*++

Routine Description:

    The routine allocates an SRB data structure and/or an SRB extension for
    the request.

    It first determines if the request is can be executed at this time.
    In particular, untagged requests cannot execute if there are any active
    tagged queue requests.  If the request cannot be executed, the pending
    flag is set in the logical unit FALSE is returned.  The request will be
    retried after the last tagged queue request completes.

    If one of the structures cannot be allocated, then the pending flag is
    set in the device extension and FALSE is returned.  The request will be
    retried the next time a request completes.

Arguments:

    DeviceExtension - Supplies a pointer to the devcie extension for this
        adapter.

    LogicalUnit - Supplies a pointer to the logical unit that this request is
        is for.

    Srb - Supplies a pointer to the SCSI request.

    StartNextRequest - Pointer to a BOOLEAN that we'll set to TRUE if the caller
                       needs to start the next packet.

    Tagged - Supplies a pointer to a BOOLEAN that we'll set to TRUE if the
             request is to receive a queue tag and can be dispatched to the
             miniport while other tagged commands are active.

Return Value:

    TRUE if the SRB can be execute currently. If FALSE is returneed the reuqest
    should not be started.

--*/

{
    PSRB_DATA srbData = (PSRB_DATA) Srb->OriginalRequest;
    PCCHAR srbExtension;
    PCCHAR remappedSrbExt;
    ULONG tagValue = 0;

    ASSERT_SRB_DATA(srbData);

    //
    // Acquire the spinlock while the allocations are attempted.
    //
    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    //
    // If the adapter supports mulitple requests, then determine if it can
    // be executed.
    //

    if (DeviceExtension->SupportsMultipleRequests == TRUE) {
        
        //
        // SupportsMultipleRequests means the miniport supports tagged queuing,
        // MultipleRequestPerLu, or both.  Here is the way we handle each
        // case:
        // 1) TaggedQueuing and SupportsMultipleLu:
        //    In this case, if the command's QUEUE_ACTION_ENABLE bit OR the
        //    NO_QUEUE_FREEZE bit is set, we give the command a tag and
        //    hand it to the miniport.
        // 2) TaggedQueuing Only:
        //    In this case the miniport does not expect to receive any
        //    untagged commands while there are active tagged commands, so
        //    we only give the SRB a tag if QUEUE_ACTION_ENABLE is set.
        // 3) MultipleRequestPerLu Only:
        //    This can be treated the same as case 1.  Any command that has
        //    QUEUE_ACTION_ENABLE or NO_QUEUE_FREEZE set can be assigned a
        //    tag and given to the miniport.
        //

        ULONG tagMask = SRB_FLAGS_QUEUE_ACTION_ENABLE;
        if (DeviceExtension->MultipleRequestPerLu == TRUE) {
            tagMask |= SRB_FLAGS_NO_QUEUE_FREEZE;
        }

        if (Srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

            ASSERT(FALSE);
            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            return FALSE;

        } else if (TEST_FLAG(Srb->SrbFlags, tagMask) &&
                   !TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_DISCONNECT)) {
            //
            // If the need request sense flag is set then tagged commands cannot
            // be started and must be marked as pending.
            //

            *Tagged = TRUE;
            if (TEST_FLAG(LogicalUnit->LuFlags, LU_NEED_REQUEST_SENSE)) {
                DebugPrint((1, "SCSIPORT: SpAllocateSrbExtension: "
                               "Marking tagged request as pending.\n"));

                //
                // This request cannot be executed now.  Mark it as pending
                // in the logical unit structure and return.
                // GetNextLogicalUnit will restart the commnad after all of the
                // active commands have completed.
                //

                ASSERT(!(LogicalUnit->LuFlags & LU_PENDING_LU_REQUEST));
                ASSERT(LogicalUnit->PendingRequest == NULL);

                LogicalUnit->LuFlags |= LU_PENDING_LU_REQUEST;
                LogicalUnit->PendingRequest = Srb->OriginalRequest;
                LogicalUnit->PendingRequest->TickCount = DeviceExtension->TickCount;

                //
                // Indicate that the logical unit is still active so that the
                // request will get processed when the request list is empty.
                //

                LogicalUnit->LuFlags |= LU_LOGICAL_UNIT_IS_ACTIVE;

                //  
                // Notify the caller that it needs to start the next request.
                //

                *StartNextRequest = TRUE;

                //
                // Release the spinlock and return.
                //
                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                return FALSE;
            }

        } else {
            //
            // This is an untagged command.  It is only allowed to execute, if
            // logical unit queue is being by-passed or there are no other
            // requests active.
            //

            *Tagged = FALSE;
            if ((!IsListEmpty(&LogicalUnit->RequestList) ||
                LogicalUnit->LuFlags & LU_NEED_REQUEST_SENSE) &&
                !SpSrbIsBypassRequest(Srb, LogicalUnit->LuFlags)) {

                //
                // This request cannot be executed now.  Mark it as pending
                // in the logical unit structure and return.
                // GetNextLogicalUnit will restart the commnad after all of the
                // active commands have completed.
                //

                ASSERT(!(LogicalUnit->LuFlags & LU_PENDING_LU_REQUEST));
                LogicalUnit->LuFlags |= LU_PENDING_LU_REQUEST;
                LogicalUnit->PendingRequest = Srb->OriginalRequest;
                LogicalUnit->PendingRequest->TickCount = DeviceExtension->TickCount;

                //
                // Indicate that the logical unit is still active so that the
                // request will get processed when the request list is empty.
                //

                LogicalUnit->LuFlags |= LU_LOGICAL_UNIT_IS_ACTIVE;

                //
                // Notify the caller that it needs to start the next request.
                //

                *StartNextRequest = TRUE;

                //
                // Release the spinlock and return.
                //
    
                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                return FALSE;
            }

            //
            // Set the QueueTag to SP_UNTAGGED
            // Set use the SRB data in the logical unit extension.
            //
            Srb->QueueTag = SP_UNTAGGED;
            srbData->TickCount = DeviceExtension->TickCount;
            LogicalUnit->CurrentUntaggedRequest = srbData;
        } 
    } else {
        
        //
        // The adapter does not support multiple requests.
        //

        *Tagged = FALSE;
        Srb->QueueTag = SP_UNTAGGED;
        srbData->TickCount = DeviceExtension->TickCount;
        LogicalUnit->CurrentUntaggedRequest = srbData;
    }

    ASSERT(Srb->QueueTag != 0);

    if (DeviceExtension->AllocateSrbExtension) {

        //
        // Allocate SRB extension from list if available.
        //

        srbExtension = DeviceExtension->SrbExtensionListHeader;

        //
        // If the Srb extension cannot be allocated, then special processing
        // is required.
        //

        if (srbExtension == NULL) {

            //
            // Indicate there is a pending request.  The DPC completion routine
            // will call this function again after it has freed at least one
            // Srb extension.
            //

            DeviceExtension->Flags |= PD_PENDING_DEVICE_REQUEST;

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
            return FALSE;
        }

        //
        // Remove SRB extension from list.
        //

        DeviceExtension->SrbExtensionListHeader  = *((PVOID *) srbExtension);

        if (SpVerifyingCommonBuffer(DeviceExtension)) {

            remappedSrbExt = SpPrepareSrbExtensionForUse(DeviceExtension,
                                                         &srbExtension);

        } else {
            remappedSrbExt = NULL;
        }

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        Srb->SrbExtension = (remappedSrbExt != NULL) ? remappedSrbExt : 
                                                       srbExtension;

        //
        // If the adapter supports auto request sense, the SenseInfoBuffer
        // needs to point to the Srb extension.  This buffer is already mapped
        // for the adapter. Note that this is not done for WMI requests.
        //

        if ((Srb->Function != SRB_FUNCTION_WMI) &&
            (DeviceExtension->AutoRequestSense &&
             Srb->SenseInfoBuffer != NULL)) {

            //
            // Save the request sense buffer and the length of the buffer.
            //

            srbData->RequestSenseSave = Srb->SenseInfoBuffer;
            srbData->RequestSenseLengthSave = Srb->SenseInfoBufferLength;

            //
            // Make sure the allocated buffer is large enough for the requested
            // sense buffer.
            //

            if (Srb->SenseInfoBufferLength > 
                (sizeof(SENSE_DATA) + DeviceExtension->AdditionalSenseBytes)) {

                //
                // Auto request sense cannot be done for this request sense 
                // because the buffer is larger than the adapter supports.  
                // Disable auto request sense.
                //

                DebugPrint((1,"SpAllocateSrbExtension: SenseInfoBuffer too big "
                              "SenseInfoBufferLength:%x MaxSupported:%x\n",
                            Srb->SenseInfoBufferLength,
                            (sizeof(SENSE_DATA) + DeviceExtension->AdditionalSenseBytes)));

                Srb->SrbFlags |= SRB_FLAGS_DISABLE_AUTOSENSE;

            } else {

                //
                // Modify the size of the sense buffer to reflect the size of 
                // the one we redirect to.
                //

                Srb->SenseInfoBufferLength = 
                    sizeof(SENSE_DATA) + DeviceExtension->AdditionalSenseBytes;

                //
                // Replace it with the request sense buffer in the Srb
                // extension.
                //

                if (SpVerifyingCommonBuffer(DeviceExtension)) {

                    Srb->SenseInfoBuffer = SpPrepareSenseBufferForUse(
                                               DeviceExtension,
                                               srbExtension);                    
                } else { 
                    Srb->SenseInfoBuffer = srbExtension +
                       DeviceExtension->SrbExtensionSize;
                }
            }
        }

    } else  {

        Srb->SrbExtension = NULL;

        //
        // Release the spinlock before returning.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

    }

    return TRUE;
}

NTSTATUS
SpSendMiniPortIoctl(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    )

/*++

Routine Description:

    This function sends a miniport ioctl to the miniport driver.
    It creates an srb which is processed normally by the port driver.
    This call is synchronous.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    RequestIrp - Supplies a pointe to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PSRB_IO_CONTROL         srbControl;
    SCSI_REQUEST_BLOCK      srb;
    KEVENT                  event;
    LARGE_INTEGER           startingOffset;
    IO_STATUS_BLOCK         ioStatusBlock;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    ULONG                   outputLength;
    ULONG                   length;
    ULONG                   target;

    NTSTATUS                status;

    PAGED_CODE();
    startingOffset.QuadPart = (LONGLONG) 1;

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(RequestIrp);
    srbControl = RequestIrp->AssociatedIrp.SystemBuffer;
    RequestIrp->IoStatus.Information = 0;

    //
    // Validiate the user buffer.
    //

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SRB_IO_CONTROL)){

        RequestIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        return(STATUS_INVALID_PARAMETER);
    }

    if (srbControl->HeaderLength != sizeof(SRB_IO_CONTROL)) {
        RequestIrp->IoStatus.Status = STATUS_REVISION_MISMATCH;
        return(STATUS_REVISION_MISMATCH);
    }

    length = srbControl->HeaderLength + srbControl->Length;
    if ((length < srbControl->HeaderLength) ||
        (length < srbControl->Length)) {

        //
        // total length overflows a ULONG
        //
        return(STATUS_INVALID_PARAMETER);
    }

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < length &&
        irpStack->Parameters.DeviceIoControl.InputBufferLength < length ) {

        RequestIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Set the logical unit addressing to the first logical unit.  This is 
    // merely used for addressing purposes.
    //

    logicalUnit = SpFindSafeLogicalUnit(
                      DeviceExtension->CommonExtension.DeviceObject,
                      0xff,
                      RequestIrp);

    if (logicalUnit == NULL) {
        RequestIrp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    }

    //
    // Must be at PASSIVE_LEVEL to use synchronous FSD.
    //

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Initialize the notification event.
    //

    KeInitializeEvent(&event,
                        NotificationEvent,
                        FALSE);

    //
    // Build IRP for this request.
    // Note we do this synchronously for two reasons.  If it was done
    // asynchonously then the completion code would have to make a special
    // check to deallocate the buffer.  Second if a completion routine were
    // used then an additional IRP stack location would be needed.
    //

    irp = IoBuildSynchronousFsdRequest(
                IRP_MJ_SCSI,
                DeviceExtension->CommonExtension.DeviceObject,
                srbControl,
                length,
                &startingOffset,
                &event,
                &ioStatusBlock);
    if (irp == NULL) {
        SpReleaseRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                            RequestIrp);
        RequestIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set major and minor codes.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    //
    // Fill in SRB fields.
    //

    irpStack->Parameters.Others.Argument1 = &srb;

    //
    // Zero out the srb.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    srb.PathId = logicalUnit->PathId;
    srb.TargetId = logicalUnit->TargetId;
    srb.Lun = logicalUnit->Lun;

    srb.Function = SRB_FUNCTION_IO_CONTROL;
    srb.Length = sizeof(SCSI_REQUEST_BLOCK);

    srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT | 
        SRB_FLAGS_NO_QUEUE_FREEZE;
    srb.QueueAction = SRB_SIMPLE_TAG_REQUEST;

    srb.OriginalRequest = irp;

    //
    // Set timeout to requested value.
    //

    srb.TimeOutValue = srbControl->Timeout;

    //
    // Set the data buffer.
    //

    srb.DataBuffer = srbControl;
    srb.DataTransferLength = length;

    //
    // Flush the data buffer for output. This will insure that the data is
    // written back to memory.  Since the data-in flag is the the port driver
    // will flush the data again for input which will ensure the data is not
    // in the cache.
    //

    KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);

    //
    // Call port driver to handle this request.
    //

    status = IoCallDriver(DeviceExtension->CommonExtension.DeviceObject, irp);

    //
    // Wait for request to complete.
    //

    if(status == STATUS_PENDING) {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
    }

    //
    // Set the information length to the smaller of the output buffer length
    // and the length returned in the srb.
    //

    RequestIrp->IoStatus.Information = srb.DataTransferLength > outputLength ?
        outputLength : srb.DataTransferLength;

    RequestIrp->IoStatus.Status = ioStatusBlock.Status;

    SpReleaseRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                        RequestIrp);

    return RequestIrp->IoStatus.Status;
}


VOID
SpMiniPortTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine calls the miniport when its requested timer fires.
    It interlocks either with the port spinlock and the interrupt object.

Arguments:

    Dpc - Unsed.

    DeviceObject - Supplies a pointer to the device object for this adapter.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PADAPTER_EXTENSION deviceExtension = ((PDEVICE_OBJECT) DeviceObject)->DeviceExtension;

    //
    // Acquire the port spinlock.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    //
    // Make sure we haven't removed the adapter in the meantime.
    //

    if (!TEST_FLAG(deviceExtension->InterruptData.InterruptFlags,
                   PD_ADAPTER_REMOVED)) {

        //
        // Make sure the timer routine is still desired.
        //

        if (deviceExtension->HwTimerRequest != NULL) {

            deviceExtension->SynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) deviceExtension->HwTimerRequest,
                deviceExtension->HwDeviceExtension
                );

        }
    }

    //
    // Release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    // Check for miniport work requests. Note this is an unsynchonized
    // test on a bit that can be set by the interrupt routine; however,
    // the worst that can happen is that the completion DPC checks for work
    // twice.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        SpRequestCompletionDpc(DeviceObject);
    }

}


BOOLEAN
SpSynchronizeExecution (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    This routine calls the miniport entry point which was passed in as
    a parameter.  It acquires a spin lock so that all accesses to the
    miniport's routines are synchronized.  This routine is used as a
    subsitute for KeSynchronizedExecution for miniports which do not use
    hardware interrupts.


Arguments:

    Interrrupt - Supplies a pointer to the port device extension.

    SynchronizeRoutine - Supplies a pointer to the routine to be called.

    SynchronizeContext - Supplies the context to pass to the
        SynchronizeRoutine.

Return Value:

    Returns the returned by the SynchronizeRoutine.

--*/

{
    PADAPTER_EXTENSION deviceExtension = (PADAPTER_EXTENSION) Interrupt;
    BOOLEAN returnValue;
    KIRQL oldIrql;

    KeAcquireSpinLock(&deviceExtension->InterruptSpinLock, &oldIrql);

    returnValue = SynchronizeRoutine(SynchronizeContext);

    KeReleaseSpinLock(&deviceExtension->InterruptSpinLock, oldIrql);

    return(returnValue);
}

NTSTATUS
SpClaimLogicalUnit(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension,
    IN PIRP Irp,
    IN BOOLEAN LegacyClaim
    )

/*++

Routine Description:

    This function finds the specified device in the logical unit information
    and either updates the device object point or claims the device.  If the
    device is already claimed, then the request fails.  If the request succeeds,
    then the current device object is returned in the data buffer pointer
    of the SRB.

    This routine must be called with the remove lock held for the logical
    unit.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    Irp - Supplies a pointer to the Irp which made the original request.

    LegacyClaim - indicates whether the device should be started before being
                  claimed.  Used for to start the device before allowing
                  legacy drivers to claim it.

Return Value:

    Returns the status of the operation.  Either success, no device or busy.

--*/

{
    KIRQL currentIrql;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PDEVICE_OBJECT saveDevice;

    PVOID sectionHandle;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Get SRB address from current IRP stack.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = (PSCSI_REQUEST_BLOCK) irpStack->Parameters.Others.Argument1;

    //
    // Make sure the device can be started - this needs to be done outside
    // of the spinlock.
    //

    if(LegacyClaim) {

        status = ScsiPortStartLogicalUnit(LogicalUnitExtension);

        if(!NT_SUCCESS(status)) {

            srb->SrbStatus = SRB_STATUS_ERROR;
            return status;
        }

        LogicalUnitExtension->IsLegacyClaim = TRUE;
    }

#ifdef ALLOC_PRAGMA
    sectionHandle = MmLockPagableCodeSection(SpClaimLogicalUnit);
    InterlockedIncrement(&SpPAGELOCKLockCount);
#endif

    //
    // Lock the data.
    //

    KeAcquireSpinLock(&AdapterExtension->SpinLock, &currentIrql);

    if (srb->Function == SRB_FUNCTION_RELEASE_DEVICE) {

        LogicalUnitExtension->IsClaimed = FALSE;
        KeReleaseSpinLock(&AdapterExtension->SpinLock, currentIrql);
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        return(STATUS_SUCCESS);
    }

    //
    // Check for a claimed device.
    //

    if (LogicalUnitExtension->IsClaimed) {

        KeReleaseSpinLock(&AdapterExtension->SpinLock, currentIrql);
        srb->SrbStatus = SRB_STATUS_BUSY;
        return(STATUS_DEVICE_BUSY);
    }

    //
    // Save the current device object.
    //

    saveDevice = LogicalUnitExtension->CommonExtension.DeviceObject;

    //
    // Update the lun information based on the operation type.
    //

    if (srb->Function == SRB_FUNCTION_CLAIM_DEVICE) {
        LogicalUnitExtension->IsClaimed = TRUE;
    }

    if (srb->Function == SRB_FUNCTION_ATTACH_DEVICE) {
        ASSERT(FALSE);
        LogicalUnitExtension->CommonExtension.DeviceObject = srb->DataBuffer;
    }

    srb->DataBuffer = saveDevice;

    KeReleaseSpinLock(&AdapterExtension->SpinLock, currentIrql);
    srb->SrbStatus = SRB_STATUS_SUCCESS;

#ifdef ALLOC_PRAGMA
    InterlockedDecrement(&SpPAGELOCKLockCount);
    MmUnlockPagableImageSection(sectionHandle);
#endif

    return(STATUS_SUCCESS);
}


NTSTATUS
SpSendReset(
    IN PDEVICE_OBJECT Adapter,
    IN PIRP RequestIrp,
    IN ULONG Ioctl,
    IN OUT PBOOLEAN Complete
    )

/*++

Routine Description:

    This routine will create an assynchronous request to reset the scsi bus
    and route that through the port driver.  The completion routine on the
    request will take care of completing the original irp

    This call is asynchronous.

Arguments:

    Adapter - the port driver to be reset

    Irp - a pointer to the reset request - this request will already have been
          marked as PENDING.

    Ioctl - Pointer to the IOCTL

    Complete - Address of boolean into which this routine will copy a
               value that tells the caller if it should complete the request.

Return Value:

    STATUS_PENDING if the request is pending
    STATUS_SUCCESS if the request completed successfully
    or an error status

--*/

{
    PADAPTER_EXTENSION adapterExtension = Adapter->DeviceExtension;

    UCHAR pathId;

    PIRP irp = NULL;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(RequestIrp);

    PRESET_COMPLETION_CONTEXT completionContext = NULL;

    BOOLEAN completeRequest = FALSE;
    NTSTATUS status;

    PLOGICAL_UNIT_EXTENSION logicalUnit = NULL;

    PAGED_CODE();

    ASSERT_FDO(Adapter);

    if (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_STORAGE_BREAK_RESERVATION) {
        if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSI_ADDRESS)) {
            pathId = ((PSTORAGE_BUS_RESET_REQUEST)(RequestIrp->AssociatedIrp.SystemBuffer))->PathId;
        } else {
            pathId = ((PSCSI_ADDRESS)(RequestIrp->AssociatedIrp.SystemBuffer))->PathId;
        }
    } else {
        pathId = ((PSTORAGE_BUS_RESET_REQUEST)(RequestIrp->AssociatedIrp.SystemBuffer))->PathId;
    }

    //
    // use finally handler to complete request if necessary
    //

    try {

        //
        // Make sure the path id is valid
        //

        if (pathId >= adapterExtension->NumberOfBuses) {

            status = STATUS_INVALID_PARAMETER;
            completeRequest = TRUE;
            leave;
        }

        //
        // Find a logical unit that's going to be sticking around for a while
        // and lock it using the original request irp.  We'll unlock it in the
        // completion routine.
        //

        logicalUnit = SpFindSafeLogicalUnit(Adapter,
                                            pathId,
                                            RequestIrp);

        if(logicalUnit == NULL) {

            //
            // There's nothing safe on this bus so in this case we won't bother
            // resetting it
            // XXX - this may be a bug
            //

            status = STATUS_DEVICE_DOES_NOT_EXIST;
            completeRequest = TRUE;
            leave;
        }

        //
        // Try to allocate a completion context block
        //

        completionContext = SpAllocatePool(NonPagedPool,
                                           sizeof(RESET_COMPLETION_CONTEXT),
                                           SCSIPORT_TAG_RESET,
                                           Adapter->DriverObject);

        if(completionContext == NULL) {

            DebugPrint((1, "SpSendReset: Unable to allocate completion "
                           "context\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            completeRequest = TRUE;
            leave;
        }

        RtlZeroMemory(completionContext, sizeof(RESET_COMPLETION_CONTEXT));

        completionContext->OriginalIrp = RequestIrp;
        completionContext->SafeLogicalUnit = logicalUnit->DeviceObject;
        completionContext->AdapterDeviceObject = Adapter;

        irp = IoBuildAsynchronousFsdRequest(
                IRP_MJ_FLUSH_BUFFERS,
                logicalUnit->DeviceObject,
                NULL,
                0,
                NULL,
                NULL);

        if(irp == NULL) {
            DebugPrint((1, "SpSendReset: unable to allocate irp\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            completeRequest = TRUE;
            leave;
        }

        //
        // Stick the srb pointer into the irp stack
        //

        irpStack = IoGetNextIrpStackLocation(irp);

        irpStack->MajorFunction = IRP_MJ_SCSI;
        irpStack->MinorFunction = 1;
        irpStack->Parameters.Scsi.Srb = &(completionContext->Srb);

        //
        // Fill in the srb
        //

        completionContext->Srb.Function = SRB_FUNCTION_RESET_BUS;
        completionContext->Srb.SrbStatus = SRB_STATUS_PENDING;

        completionContext->Srb.OriginalRequest = irp;

        completionContext->Srb.TimeOutValue = Ioctl;

        IoSetCompletionRoutine(
            irp,
            SpSendResetCompletion,
            completionContext,
            TRUE,
            TRUE,
            TRUE);

        completeRequest = FALSE;

        status = IoCallDriver(logicalUnit->DeviceObject, irp);

    } finally {

        if (completeRequest) {

            if (completionContext != NULL) {
                ExFreePool(completionContext);
            }

            if (irp != NULL) {
                IoFreeIrp(irp);
            }

            RequestIrp->IoStatus.Status = status;

            if (logicalUnit != NULL) {
                SpReleaseRemoveLock(logicalUnit->DeviceObject,
                                    RequestIrp);
            }
        } 

        //
        // Tell the caller whether it needs to complete the request.
        //

        *Complete = completeRequest;
    }

    return status;
}

NTSTATUS
SpSendResetCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PRESET_COMPLETION_CONTEXT Context
    )

/*++

Routine Description:

    This routine handles completion of the srb generated from an asynchronous
    IOCTL_SCSI_RESET_BUS request.  It will take care of freeing all resources
    allocated during SpSendReset as well as completing the original request.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp sent to the port driver

    Context - a pointer to a reset completion context which contains
              the original request and a pointer to the srb sent down

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PIRP originalIrp = Context->OriginalIrp;

    originalIrp->IoStatus.Status = Irp->IoStatus.Status;

    SpReleaseRemoveLock(Context->SafeLogicalUnit, originalIrp);
    SpReleaseRemoveLock(Context->AdapterDeviceObject, originalIrp);
    SpCompleteRequest(Context->AdapterDeviceObject,
                      originalIrp,
                      NULL,
                      IO_NO_INCREMENT);

    ExFreePool(Context);
    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


PLOGICAL_UNIT_EXTENSION
SpFindSafeLogicalUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR PathId,
    IN PVOID LockTag
    )

/*++

Routine Description:

    This routine will scan the bus in question and return a pointer to the
    first logical unit on the bus that is not involved in a rescan operation.
    This can be used to find a logical unit for ioctls or other requests that
    may not specify one (IOCTL_SCSI_MINIPORT, IOCTL_SCSI_RESET_BUS, etc)

Arguments:

    DeviceObject - a pointer to the device object

    PathId - The path number to be searched for a logical unit.  If this is 0xff
             then the first unit on any path will be found.

Return Value:

    a pointer to a logical unit extension
    NULL if none was found

--*/

{
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    UCHAR target;

    PLOGICAL_UNIT_EXTENSION logicalUnit;

    ASSERT_FDO(DeviceObject);

    //
    // If the miniport supports it, send the request to the logical unit that
    // represents an initiator.  This relieves performance pressure on real
    // devices and obviates the need for the miniport to create a pseudo lun
    // when there are no devices attached.
    //

    if (deviceExtension->CreateInitiatorLU == TRUE) {
        
        ULONG bus;
        ULONG isRemoved;
        
        if (PathId != 0xff) {

            //
            // The caller supplied a specific PathId so only check the 
            // corresponding bus for a logical unit.
            //

            logicalUnit = deviceExtension->InitiatorLU[PathId];
            if (logicalUnit != NULL) {
                isRemoved = SpAcquireRemoveLock(logicalUnit->DeviceObject, LockTag);
                if (isRemoved) {
                    SpReleaseRemoveLock(logicalUnit->DeviceObject, LockTag);
                    logicalUnit = NULL;
                }
            }
        } else {

            //
            // The call did not supply a specific PathId so check all the buses
            // for a logical unit.
            //

            for (bus = 0; bus < 8; bus++) {
                logicalUnit = deviceExtension->InitiatorLU[bus];
                if (logicalUnit != NULL) {
                    isRemoved = SpAcquireRemoveLock(logicalUnit->DeviceObject, LockTag);
                    if (isRemoved) {
                        SpReleaseRemoveLock(logicalUnit->DeviceObject, LockTag);
                        logicalUnit = NULL;
                    } else {
                        break;
                    }
                }
            }
        }
    } else {

        //
        // Since the adapter is not configured to have logical units created
        // for the initiator(s), set logicalUnit to NULL so we'll check for
        // target devices.
        //

        logicalUnit = NULL;
    }

    //
    // If we found an initiator's logical unit, return it.  Else, look for a
    // suitable target.
    //
    
    if (logicalUnit != NULL) {
        DebugPrint((1, "SpFindSafeLogicalUnit: using initiator LU %p\n", logicalUnit));
        return logicalUnit;
    }

    //
    // Set the logical unit addressing to the first logical unit.  This is
    // merely used for addressing purposes.
    //

    for (target = 0; target < NUMBER_LOGICAL_UNIT_BINS; target++) {
        PLOGICAL_UNIT_BIN bin = &deviceExtension->LogicalUnitList[target];
        KIRQL oldIrql;

        KeAcquireSpinLock(&bin->Lock, &oldIrql);

        logicalUnit = bin->List;

        //
        // Walk the logical unit list to the end, looking for a safe one.
        // If it was created for a rescan, it might be freed before this
        // request is complete.
        //

        for(logicalUnit = bin->List;
            logicalUnit != NULL;
            logicalUnit = logicalUnit->NextLogicalUnit) {

            if ((logicalUnit->IsTemporary == FALSE) &&
                ((PathId == 0xff) || (logicalUnit->PathId == PathId))) {

                ULONG isRemoved;

                //
                // This lu isn't being rescanned and if a path id was specified
                // it matches so this must be the right one
                //

                isRemoved = SpAcquireRemoveLock(
                                logicalUnit->DeviceObject,
                                LockTag);
                if(isRemoved) {
                    SpReleaseRemoveLock(
                        logicalUnit->DeviceObject,
                        LockTag);
                    continue;
                }
                KeReleaseSpinLock(&bin->Lock, oldIrql);
                return logicalUnit;
            }
        }
        KeReleaseSpinLock(&bin->Lock, oldIrql);
    }

    return NULL;
}


NTSTATUS
SpRerouteLegacyRequest(
    IN PDEVICE_OBJECT AdapterObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the adapter receives requests which have
    not been assigned SRB_DATA blocks.  The routine will build a new irp
    for the SRB and issue that irp to the appropriate logical unit for
    processing.

    The adapter remove lock should NOT be held when processing this
    request.

Arguments:

    AdapterObject - the adapter which received the request

    Irp - the request

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapter = AdapterObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    ULONG_PTR tag;

    PLOGICAL_UNIT_EXTENSION logicalUnit;

    NTSTATUS status;

    //
    // Acqire a lock on the logical unit we're going to send this through.
    // use IRP+1 so we don't collide with the regular i/o locks.
    //

    tag = ((ULONG_PTR) Irp) + 1;

    logicalUnit = GetLogicalUnitExtension(adapter,
                                          srb->PathId,
                                          srb->TargetId,
                                          srb->Lun,
                                          (PVOID) tag,
                                          TRUE);

    //
    // Release the lock the caller acquired on the adapter.
    //

    SpReleaseRemoveLock(AdapterObject, Irp);

    if(logicalUnit == NULL) {
        status = STATUS_DEVICE_DOES_NOT_EXIST;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    } else {

        //
        // Reference the device object.  That way it won't go away and we
        // don't have to keep a remove lock around.
        //

        ObReferenceObject(logicalUnit->DeviceObject);
        SpReleaseRemoveLock(logicalUnit->DeviceObject, (PVOID) tag);

        //
        // Skip the current irp stack location.  That will cause it
        // to get rerun by the logical unit we call.
        //

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(logicalUnit->DeviceObject, Irp);

        ObDereferenceObject(logicalUnit->DeviceObject);

    }
    return status;
}


NTSTATUS
SpFlushReleaseQueue(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Flush,
    IN BOOLEAN SurpriseRemove

    )
{
    PADAPTER_EXTENSION adapter = LogicalUnit->AdapterExtension;
    KIRQL oldIrql;

    NTSTATUS status = STATUS_SUCCESS;

    DebugPrint((2,"SpFlushReleaseQueue: SCSI unfreeze queue TID %d\n",
        LogicalUnit->TargetId));

    ASSERT(!TEST_FLAG(LogicalUnit->LuFlags, LU_QUEUE_LOCKED));


    KeAcquireSpinLock(&adapter->SpinLock, &oldIrql);

    if (!SurpriseRemove) {
            
        //
        // Make sure the queue is frozen.
        //
        
        if (!TEST_FLAG(LogicalUnit->LuFlags, LU_QUEUE_FROZEN)) {
            
            DebugPrint((1,"ScsiPortFdoDispatch:  Request to unfreeze an "
                        "unfrozen queue!\n"));
            
            KeReleaseSpinLock(&adapter->SpinLock, oldIrql);
            
            if(Flush) {
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            return status;
        }

        CLEAR_FLAG(LogicalUnit->LuFlags, LU_QUEUE_FROZEN);
    }

    if(Flush) {

        PIRP listIrp = NULL;

        PKDEVICE_QUEUE_ENTRY packet;

        PIRP nextIrp;
        PIO_STACK_LOCATION irpStack;
        PSCSI_REQUEST_BLOCK srb;

        //
        // The queue may not be busy so we have to use the IfBusy variant.  
        // Use a zero key to pull items from the head of it (if any are there)
        //

        while ((packet =
                KeRemoveByKeyDeviceQueueIfBusy(
                    &(LogicalUnit->DeviceObject->DeviceQueue),
                    0))
            != NULL) {

            nextIrp = CONTAINING_RECORD(packet,
                                        IRP,
                                        Tail.Overlay.DeviceQueueEntry);

            //
            // Get the srb.
            //

            irpStack = IoGetCurrentIrpStackLocation(nextIrp);
            srb = irpStack->Parameters.Scsi.Srb;

            //
            // Set the status code.
            //

            srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
            nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

            //
            // Link the requests. They will be completed after the
            // spinlock is released.
            //

            nextIrp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY)
                listIrp;

            listIrp = nextIrp;
        }

        //
        // If there is a pending request on the LU, add it to the list so it
        // gets flushed along with the queued requests.
        //

        if (LogicalUnit->PendingRequest != NULL) {

            PIRP irp = LogicalUnit->PendingRequest->CurrentIrp;
            srb = LogicalUnit->PendingRequest->CurrentSrb;

            DebugPrint((1, "SpFlushReleaseQueue: flushing pending request irp:%p srb:%p\n", irp, srb));

            srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
            irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            irp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY) listIrp;
            listIrp = irp;

            LogicalUnit->PendingRequest = NULL;
            ASSERT(LogicalUnit->LuFlags | LU_PENDING_LU_REQUEST);
            CLEAR_FLAG(LogicalUnit->LuFlags, LU_PENDING_LU_REQUEST);

        }

        //
        // If there is a busy request on the LU, add it to the list so it
        // gets flushed along with the queued requests.
        //

        if ( LogicalUnit->BusyRequest && SurpriseRemove ) {

            PIRP irp = LogicalUnit->BusyRequest->CurrentIrp;
            srb = LogicalUnit->BusyRequest->CurrentSrb;

            DebugPrint((1, "SpFlushReleaseQueue: flushing busy request irp:%\
p srb:%p\n", irp, srb));

            srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
            irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            irp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY) listIrp;
            listIrp = irp;

            LogicalUnit->BusyRequest = NULL;
            ASSERT((LU_LOGICAL_UNIT_IS_BUSY | LU_QUEUE_IS_FULL));

            CLEAR_FLAG(LogicalUnit->LuFlags,
                       (LU_LOGICAL_UNIT_IS_BUSY | LU_QUEUE_IS_FULL));

        }

        if(!SurpriseRemove) {
            //
            // Mark the queue as unfrozen.  Since all the requests have
            // been removed and the device queue is no longer busy, it
            // is effectively unfrozen.
            //

            CLEAR_FLAG(LogicalUnit->LuFlags, LU_QUEUE_FROZEN);
        }

        //
        // Release the spinlock.
        //

        KeReleaseSpinLock(&adapter->SpinLock, oldIrql);
        

        //
        // Complete the flushed requests.
        //

        while (listIrp != NULL) {

            PSRB_DATA srbData;

            nextIrp = listIrp;
            listIrp = (PIRP) nextIrp->Tail.Overlay.ListEntry.Flink;

            //
            // Get the srb.
            //

            irpStack = IoGetCurrentIrpStackLocation(nextIrp);
            srb = irpStack->Parameters.Scsi.Srb;
            srbData = srb->OriginalRequest;

            srb->OriginalRequest = nextIrp;

            SpReleaseRemoveLock(adapter->DeviceObject, nextIrp);
            SpCompleteRequest(adapter->DeviceObject,
                              nextIrp,
                              srbData,
                              IO_NO_INCREMENT);
        }

    } else {

        //
        // If there is not an untagged request running then start the
        // next request for this logical unit.  Otherwise free the
        // spin lock.
        //

        if (LogicalUnit->CurrentUntaggedRequest == NULL) {

            //
            // GetNextLuRequest frees the spinlock.
            //

            GetNextLuRequest(LogicalUnit);
            KeLowerIrql(oldIrql);

        } else {

            DebugPrint((1,"SpFlushReleaseQueue:  Request to unfreeze queue "
                          "with active request.\n"));
            KeReleaseSpinLock(&adapter->SpinLock, oldIrql);

        }
    }

    return status;
}



VOID
SpLogInterruptFailure(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This function logs an error when an interrupt has not been delivered.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    Srb - Supplies a pointer to the request which timed-out.

    UniqueId - Supplies the UniqueId for this error.

Return Value:

    None.

Notes:

    The port device extension spinlock should be held when this routine is
    called.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    errorLogEntry = (PIO_ERROR_LOG_PACKET)
        IoAllocateErrorLogEntry(Adapter->DeviceObject,
                                sizeof(IO_ERROR_LOG_PACKET));

    if (errorLogEntry != NULL) {
        errorLogEntry->ErrorCode         = IO_WARNING_INTERRUPT_STILL_PENDING;
        errorLogEntry->SequenceNumber    = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount        = 0;
        errorLogEntry->UniqueErrorValue  = 0x215;
        errorLogEntry->FinalStatus       = STATUS_PENDING;
        errorLogEntry->DumpDataSize      = 0;
        IoWriteErrorLogEntry(errorLogEntry);
    }

    DbgPrint("SpTimeoutSynchronized: Adapter %#p had interrupt "
             "pending - the system may not be delivering "
             "interrupts from this adapter\n",
             Adapter->DeviceObject);

    if(ScsiCheckInterrupts) {
        DbgBreakPoint();
    }

    return;
}


VOID
SpDelayedWmiRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This funciton is a callback for a IOWorkItem that will be queued in the CompltetionDpc
    for scsiport.  The completion DPC cannot call IoWMIRegistrationControl because
    it is running at DPC level.

Arguments:

    DeviceObject        - The device object for which this WorkItem was queued.
    Context             - The context contains a pointer to the IOWorkItem so
                          we can free it.

Return Value:

    This work item has to be called with the remove lock held so that the
    device doesn't go before we get to run.

Notes:

    This routine should be called with the RemoveLock held for the deviceObject

--*/
{
    PIO_WORKITEM    pIOWorkItem = (PIO_WORKITEM) Context;

    IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_REREGISTER);

    // Free the IOWorkItem
    IoFreeWorkItem(pIOWorkItem);

    // Release the remove lock on the device object
    SpReleaseRemoveLock(DeviceObject, pIOWorkItem);
}


VOID
SpCompletionDpcProcessWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PINTERRUPT_DATA savedInterruptData
    )
/*++

Routine Description:

    Will do the processing for WMI events (and registration) for
    completionDpc.

Arguments:

Return Value:

    None

Notes:

--*/
{
    LARGE_INTEGER                currentTime;
    PLOGICAL_UNIT_EXTENSION      logicalUnit;
    PDEVICE_OBJECT               providerDeviceObject;
    PADAPTER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    // Pointers to the WMIEventRequests passed in for execution
    PWMI_MINIPORT_REQUEST_ITEM   wmiMiniPortRequestCurrent;
    PWMI_MINIPORT_REQUEST_ITEM   nextRequest = NULL;

    PWNODE_HEADER                wnodeEventItemHeader;

    //
    // Process the requests in the same order they were posted.  All
    // requests are stamped with the same time.
    //

    KeQuerySystemTime(&currentTime);

    wmiMiniPortRequestCurrent =
        savedInterruptData->WmiMiniPortRequests;


    while (wmiMiniPortRequestCurrent) {

        // Initialize the next request
        nextRequest = wmiMiniPortRequestCurrent->NextRequest;

       //
       // Determine if the WMI data provider is the
       // adapter (FDO; PathId=0xFF) or one of the SCSI
       // targets (PDO; identified by
       // PathId,TargedId,Lun).
       //

       if (wmiMiniPortRequestCurrent->PathId == 0xFF) {                    // [FDO]
          providerDeviceObject = DeviceObject;
       } else {                                                     // [PDO]
          logicalUnit = GetLogicalUnitExtension(
              deviceExtension,
              wmiMiniPortRequestCurrent->PathId,
              wmiMiniPortRequestCurrent->TargetId,
              wmiMiniPortRequestCurrent->Lun,
              FALSE,
              TRUE);

          if (logicalUnit) {
             providerDeviceObject =
                 logicalUnit->CommonExtension.DeviceObject;
          } else {

              // [SCSI target does not exist]
              providerDeviceObject = NULL;

             // The deviceObject is NULL, then we should
             // delete the entry.  Because the deviceObject
             // becomes NULL when the adapter or LUN has
             // been removed.  That means that there is no
             // free list for this cell to go back to,
             // if we dont delete the cell it will be leaked
             ExFreePool(wmiMiniPortRequestCurrent);

          }
       }

       //
       // Ignore this WMI request if we cannot locate
       // the WMI ProviderId (device object pointer) or
       // WMI is not initialized for some reason,
       // therwise process the request.
       //

       if (providerDeviceObject && ((PCOMMON_EXTENSION)
           providerDeviceObject->DeviceExtension)->WmiInitialized) {

           // Do we place the cell back onto the free list
           BOOLEAN      freeCell;

           freeCell = TRUE;

          if (wmiMiniPortRequestCurrent->TypeOfRequest == WMIReregister) {

              //
              // Re-register this device object with WMI, instructing WMI to
              // requery for the GUIDs we support.
              //

              // The Call to IoWMIRegistrationControl is not supported at
              // DPC level (must be made at PASSIVE level, so we will
              // queue a work item.
              PIO_WORKITEM   pIOWorkItem;

              // The remove lock will be release by the IOWorkItem
              // callback
              pIOWorkItem = IoAllocateWorkItem(providerDeviceObject);
              if (pIOWorkItem) {

                  // Acquire the RemoveLock on this deviceObject
                  SpAcquireRemoveLock(providerDeviceObject, pIOWorkItem);

                  // We succesfully allocated the work item
                  IoQueueWorkItem(pIOWorkItem,
                                 SpDelayedWmiRegistrationControl,
                                 DelayedWorkQueue,
                                 pIOWorkItem);

              } else {
                  DebugPrint((1, "ScsiPortCompletionDPC: IoAllocateWorkItem failed for WmiRegistrationControl event\n"));
              }

              //
              // Falling through we'll place the cell into the free list later
              //

          } else if (wmiMiniPortRequestCurrent->TypeOfRequest == WMIEvent) {
              //
              // The miniport posted a WMI event.
              //
              // Make sure we have an event item, then stamp it with
              NTSTATUS                      status;

              wnodeEventItemHeader =
                  (PWNODE_HEADER) wmiMiniPortRequestCurrent->WnodeEventItem;

              ASSERT(wnodeEventItemHeader->Flags & WNODE_FLAG_EVENT_ITEM);

              wnodeEventItemHeader->ProviderId = IoWMIDeviceObjectToProviderId(providerDeviceObject);
              wnodeEventItemHeader->TimeStamp  = currentTime;

              //
              // We will be passing this WMI_MINIPORT_REQUEST_ITEM directly
              // to WMI and allocating a new request item to take its place.
              //
              // Note that WMI is expecting a WNODE_EVENT_ITEM to be passed
              // in, however we are passing it a WMI_MINIPORT_REQUEST_ITEM.
              // This is alright,  since the WNODE_EVENT_ITEM buffer is the
              // very first field in WMI_MINIPORT_REQUEST_ITEM.  This is an
              // optimization to save one copy operation.   The alternative
              // was to allocate a WNODE_EVENT_ITEM and copy in the data.
              //
              status = IoWMIWriteEvent(
                  (PWNODE_EVENT_ITEM)wmiMiniPortRequestCurrent);

              if (NT_SUCCESS(status)) {

                  // Dont put this cell back onto the free list
                  freeCell = FALSE;

                  #if DBG
                  // This is a global counter, it wont
                  // make sense if you have more than
                  // one scsiport adapter
                  ScsiPortWmiWriteCalls++;
                  #endif

              } else {
                  // WMI Wont release the memory that we're
                  // currently pointing to

                  #if DBG
                  // This is a global counter, it wont
                  // make sense if you have more than
                  // one scsiport adapter
                  ScsiPortWmiWriteCallsFailed++;
                  #endif

                  DebugPrint((1, "ScsiPortCompletionDPC: IoWMIWriteEvent failed\n"));
              }

          } else { // unknown TypeOfRequest, ignore the request
                ASSERT(FALSE);
          }

          if (freeCell) {

              //
              // Free the cell back onto the free list.
              //

              SpWmiPushExistingFreeRequestItem(
                  deviceExtension,
                  wmiMiniPortRequestCurrent);
          }
       } // good providerId / WMI initialized

       // Advance the Current request pointer
       wmiMiniPortRequestCurrent = nextRequest;

    } // while more requests exist

    // Clear the Request List
    savedInterruptData->WmiMiniPortRequests = NULL;

    // See if we need to repopulate the free
    // REQUEST_ITEM list
    while (deviceExtension->WmiFreeMiniPortRequestCount <
        deviceExtension->WmiFreeMiniPortRequestWatermark) {

        // Add one to the free list
        if (!NT_SUCCESS(
            SpWmiPushFreeRequestItem(
                deviceExtension))) {

            // We failed to add, most likely a memory
            // problem, so just stop trying for now
            break;
        }
    } // re-populate the free list (REQUEST_ITEMS)

    return;
}

NTSTATUS
SpFireSenseDataEvent(
    PSCSI_REQUEST_BLOCK Srb, 
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine fires a WMI event which contains the SenseData
    returned by a REQUEST SENSE command.
    
    WMI frees the buffer we alloc and pass to it.
    
    This routine must be called at IRQL <= DISPATCH_LEVEL, as
    required by WmiFireEvent.

Arguments:

    Srb - Points to the failed SRB for which a REQUEST SENSE
          was performed.
    
    DeviceObject - Points to the driver's device object.

Return Value:

    STATUS_SUCCESS if successful

Notes:

--*/

{
    typedef struct _SCSIPORTSENSEDATA{
        UCHAR AdapterDeviceName[32];
        ULONG Port;
        UCHAR SrbFunction;
        UCHAR SrbStatus;
        UCHAR PathId;
        UCHAR TargetId;
        UCHAR Lun;
        UCHAR Cdb[16];
        UCHAR SenseData[255];
    } SCSIPORTSENSEDATA, *PSCSIPORTSENSEDATA;

    NTSTATUS status;
    PSCSIPORTSENSEDATA SenseData;
    ULONG SenseDataLength = 255;
    PADAPTER_EXTENSION AdapterExtension;

    //
    // Allocate a buffer into which the event data will be copied.  This
    // buffer gets freed by WMI.
    //

    SenseData = SpAllocatePool(NonPagedPoolCacheAligned,
                               sizeof(SCSIPORTSENSEDATA),
                               SCSIPORT_TAG_SENSE_BUFFER,
                               DeviceObject->DriverObject);

    if (NULL == SenseData) {
        DebugPrint((1, "Unable to alloc buffer for SenseData WMI event\n"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize a pointer to the adapter extension.  We use it below to
    // get information for firing the event and filling out the event
    // data.
    //

    AdapterExtension = DeviceObject->DeviceExtension;

    //
    // Zero the buffer, then copy the event information into it.
    //

    RtlZeroMemory(SenseData, sizeof(SCSIPORTSENSEDATA));

    //
    // Copy the device name into the buffer.
    //

    if (AdapterExtension->DeviceName != NULL) {
        ULONG len = 0;
        UNICODE_STRING uString;
        ULONG i;

        RtlInitUnicodeString(&uString, AdapterExtension->DeviceName);
        if (uString.Length >= 2 * sizeof(WCHAR)) {
            uString.Length -= sizeof(WCHAR);
            for (i = (uString.Length) / sizeof(WCHAR); i > 0; i--) {
                len += 2;
                if (uString.Buffer[i] == 0x005c) {
                    RtlCopyMemory(SenseData->AdapterDeviceName,
                                  &uString.Buffer[i+1],
                                  (len < 31) ? len : 30);
                    break;
                }
            }
        }
    }

    SenseData->Port = AdapterExtension->PortNumber;

    SenseData->SrbFunction = Srb->Function;
    SenseData->SrbStatus = Srb->SrbStatus;
    SenseData->PathId = Srb->PathId;
    SenseData->TargetId = Srb->TargetId;
    SenseData->Lun = Srb->Lun;
    RtlCopyMemory(&SenseData->Cdb,
                  Srb->Cdb,
                  Srb->CdbLength);
    RtlCopyMemory(&SenseData->SenseData,
                  Srb->SenseInfoBuffer,
                  Srb->SenseInfoBufferLength);

    //
    // Fire the event.
    //

    DebugPrint((3, "SpFireSenseDataEvent: DeviceObject %p\n", DeviceObject));

    status = WmiFireEvent(DeviceObject,
                          (LPGUID)&AdapterExtension->SenseDataEventClass,
                          0,
                          sizeof(SCSIPORTSENSEDATA),
                          SenseData);

    return status;
}

#if defined(FORWARD_PROGRESS)
PMDL
SpPrepareReservedMdlForUse(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN ULONG ScatterListLength
    )

/*++

Routine Description:

    This routine attempts to prepare the reserved MDL on the supplied adapter
    for use.

Arguments:

    Adapter           - Points to an adapter extension object.

    SrbData           - Points to the SRB_DATA structure for this request.

    Srb               - Points to the SRB that describes the request for which 
                        we are enabling forward progress.

    ScatterListLength - The size of the SG list.

Return Value:

    Pointer to the reserved MDL if successful.

    NULL if the reserved MDL is too small.

    -1 if the reserved MDL are already in use.

Notes:

    This routine is called with the adapter spinlock held.

--*/

{
    PMDL Mdl;

    //
    // Check if the reserved MDL is already in use by another request.
    //

    if (TEST_FLAG(Adapter->Flags, PD_RESERVED_MDL_IN_USE)) {

        //
        // The spare is already in use.
        //
    
        Mdl = (PMDL)-1;

    } else {
        
        //
        // The spare is available.  Check if it's big enough enough to 
        // accommodate this request.
        //

        ULONG PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                              Srb->DataBuffer, 
                              Srb->DataTransferLength);

        if (PageCount > SP_RESERVED_PAGES) {

            //
            // The spare MDL is not big enough to accommodate the request.
            // return NULL.
            //

            Mdl = NULL;

        } else {
            
            DebugPrint((1, "SpPrepareReservedMdlForUse: using reserved MDL DevExt:%p srb:%p\n",
                        Adapter, Srb));

            //
            // The spare is adequate.  Claim it and prepare it
            // for use with this request.
            //

            SET_FLAG(Adapter->Flags, PD_RESERVED_MDL_IN_USE);
            SET_FLAG(SrbData->Flags, SRB_DATA_RESERVED_MDL);
            Mdl = Adapter->ReservedMdl;

            MmInitializeMdl(Mdl,Srb->DataBuffer,Srb->DataTransferLength);

            SpPrepareMdlForMappedTransfer(
                Mdl,
                Adapter->DeviceObject,
                Adapter->DmaAdapterObject,
                SrbData->CurrentIrp->MdlAddress,
                Srb->DataBuffer,
                Srb->DataTransferLength,
                SrbData->ScatterGatherList,
                ScatterListLength);

        }

    }

    return Mdl;
}

PVOID
SpMapLockedPagesWithReservedMapping(
    IN PADAPTER_EXTENSION Adapter,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PSRB_DATA SrbData,
    IN PMDL Mdl
    )

/*++

Routine Description:

    This routine attempts to map the physical pages represented by the supplied
    MDL using the adapter's reserved page range.

Arguments:

    Adapter - Points to an adapter extension object.

    Srb     - Points to the SRB that describes the request for which we
              are enabling forward progress.

    SrbData - Points to the SRB_DATA structure for this request.

    Mdl     - Points to an MDL that describes the physical range we
              are tring to map.

Return Value:

    Kernel VA of the mapped pages if mapped successfully.

    NULL if the reserved page range is too small or if the pages are 
    not successfully mapped.

    -1 if the reserved pages are already in use.

Notes:

    This routine is called with the adapter spinlock held.

--*/

{
    ULONG_PTR NumberOfPages;
    PVOID StartingVa;
    PVOID SystemAddress;

    //
    // Determine if the reserved range is already in use by another
    // request.
    //

    if (TEST_FLAG(Adapter->Flags, PD_RESERVED_PAGES_IN_USE)) {

        //
        // The reserved range is already in use, return -1.
        //

        SystemAddress = (PVOID)-1;

    } else {

        //
        // The reserved range is available.  Calculate the number of pages
        // spanned by the MDL and determine if the reserved range is large
        // enough to map the pages.
        //

        StartingVa = (PVOID)((PCHAR)Mdl->StartVa + Mdl->ByteOffset);
        NumberOfPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(StartingVa, Mdl->ByteCount);
        
        if (NumberOfPages > SP_RESERVED_PAGES) {

            //
            // Not enough reserved pages to map the required physical memory.
            // Return NULL.
            //

            SystemAddress = NULL;
            
        } else {
                
            DebugPrint((1, "SpMapLockedPagesWithReservedMapping: using reserved range DevExt:%p srb:%p\n",
                        Adapter, Srb));

            //
            // The reserved range is large enough to map all the pages.  Go ahead
            // and try to map them.  Since we are specifying MmCached as cache 
            // type and we've ensured that we have enough reserved pages to
            // cover the request, this should never fail.
            //
            
            SystemAddress = MmMapLockedPagesWithReservedMapping(
                                Adapter->ReservedPages,
                                SCSIPORT_TAG_MAPPING_LIST,
                                Mdl,
                                MmCached);

            if (SystemAddress == NULL) {
                
                ASSERT(FALSE);

            } else {

                //
                // The mapping succeeded.  Claim the reserved range and mark the
                // request so we'll know at completion that it's using the
                // reserved range.
                //
                
                SET_FLAG(Adapter->Flags, PD_RESERVED_PAGES_IN_USE);
                SET_FLAG(SrbData->Flags, SRB_DATA_RESERVED_PAGES);
                
            }       

        } 

    }

    return SystemAddress;
}
#endif

BOOLEAN
SpIsPdoClaimed(
    IN PDEVICE_OBJECT Pdo
    )
{
    PAGED_CODE();
    return ((PLOGICAL_UNIT_EXTENSION)Pdo->DeviceExtension)->IsClaimed;
}

ULONG
SpGetPassThroughSrbFlags(
    IN PDEVICE_OBJECT Pdo
    )
{
    PLOGICAL_UNIT_EXTENSION lu = (PLOGICAL_UNIT_EXTENSION)Pdo->DeviceExtension;
    PADAPTER_EXTENSION adapter = lu->AdapterExtension;

    PAGED_CODE();

    return lu->CommonExtension.SrbFlags |
        (SRB_FLAGS_DISABLE_SYNCH_TRANSFER & adapter->CommonExtension.SrbFlags) |
        SRB_FLAGS_NO_QUEUE_FREEZE;
}

NTSTATUS
SpGetPdo(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN PVOID LockTag,
    OUT PDEVICE_OBJECT* Pdo
    )
{
    PLOGICAL_UNIT_EXTENSION lu;

    PAGED_CODE();

    lu = GetLogicalUnitExtension((PADAPTER_EXTENSION)Fdo->DeviceExtension,
                                 PathId,
                                 TargetId,
                                 Lun,
                                 LockTag,
                                 TRUE);
    if (lu == NULL) {
        return STATUS_NO_SUCH_DEVICE;
    } else {

        //
        // Note that from here on we must release the remove lock acquired on
        // the logical unit extension before returning.
        //

        if (lu->CommonExtension.IsRemoved) {
            SpReleaseRemoveLock(lu->DeviceObject, LockTag);
            return STATUS_DEVICE_DOES_NOT_EXIST;
        }
    }

    *Pdo = lu->DeviceObject;
    return STATUS_SUCCESS;
}


NTSTATUS
SpSendPassThrough (
    IN PADAPTER_EXTENSION Adapter,
    IN PIRP RequestIrp,
    IN BOOLEAN Direct
    )
/*++

Routine Description:

    This function sends a user specified SCSI CDB to the device identified in
    the supplied SCSI_PASS_THROUGH structure.  It creates an srb which is 
    processed normally by the port driver.  This call is synchornous.

Arguments:

    Adapter      - Supplies a pointer to the adapter device extension.

    RequestIrp   - Supplies a pointer to the IRP that made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    BOOLEAN                 tooBig;
    ULONG                   srbFlags;
    PSCSI_PASS_THROUGH      srbControl;
    UCHAR                   pathId;
    UCHAR                   targetId;
    UCHAR                   lun;
    PDEVICE_OBJECT          pdo;

    PAGED_CODE();

    //
    // Initialize a pointer to our IRP stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(RequestIrp);

    //
    // Get a pointer to the SCSI_PASS_THROUGH structure supplied by the caller.
    //

    status = PortGetPassThroughAddress(
                 RequestIrp,
                 &pathId,
                 &targetId,
                 &lun
                 );
    
    if (status != STATUS_SUCCESS) {
        return status;
    }

    //
    // We need a referenced pointer to the PDO to which this passthrough 
    // request will be routed.  We can't proceed if we can't get a pointer to 
    // a PDO.
    // 

    status = SpGetPdo(
                 Adapter->DeviceObject,
                 pathId,
                 targetId,
                 lun,
                 RequestIrp,
                 &pdo
                 );

    if (status != STATUS_SUCCESS) {
        return status;
    }

    //
    // If this request came through a normal device control rather than from
    // class driver then the device must exist and be unclaimed. Class drivers
    // will set the minor function code for the device control.  It is always
    // zero for a user request.
    //

    if ((!irpStack->MinorFunction) && (SpIsPdoClaimed(pdo))) {
        SpReleaseRemoveLock(pdo, RequestIrp);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    srbFlags = SpGetPassThroughSrbFlags(pdo);
    status = PortSendPassThrough(
                 pdo,
                 RequestIrp,
                 Direct,
                 srbFlags,
                 &Adapter->Capabilities
                 );

    //
    // Release the remove lock we acquired on the PDO.
    //

    SpReleaseRemoveLock(pdo, RequestIrp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\lock.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    lock.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Peter Wieland

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#define KEEP_COMPLETE_REQUEST

#if DBG
static const char *__file__ = __FILE__;
#endif

#include "port.h"

LONG LockHighWatermark = 0;
LONG LockLowWatermark = 0;
LONG MaxLockedMinutes = 5;

VOID
FASTCALL
SpFreeSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );

VOID
FASTCALL
SpFreeBypassSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );


#if DBG
ULONG
FASTCALL
SpAcquireRemoveLockEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag,
    IN PCSTR File,
    IN ULONG Line
    )

/*++

Routine Description:

    This routine is called to acquire the remove lock on the device object.
    While the lock is held, the caller can assume that no pending pnp REMOVE
    requests will be completed.

    The lock should be acquired immediately upon entering a dispatch routine.
    It should also be acquired before creating any new reference to the
    device object if there's a chance of releasing the reference before the
    new one is done.

    This routine will return TRUE if the lock was successfully acquired or
    FALSE if it cannot be because the device object has already been removed.

Arguments:

    DeviceObject - the device object to lock

    Tag - Used for tracking lock allocation and release.  If an irp is
          specified when acquiring the lock then the same Tag must be
          used to release the lock before the Tag is completed.

Return Value:

    The value of the IsRemoved flag in the device extension.  If this is
    non-zero then the device object has received a Remove irp and non-cleanup
    IRP's should fail.

    If the value is REMOVE_COMPLETE, the caller should not even release the
    lock.

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    LONG lockValue;

#if DBG
    PREMOVE_TRACKING_BLOCK *removeTrackingList =
        &((PREMOVE_TRACKING_BLOCK) commonExtension->RemoveTrackingList);

    PREMOVE_TRACKING_BLOCK trackingBlock;
#endif

    //
    // Grab the remove lock
    //

    lockValue = InterlockedIncrement(&commonExtension->RemoveLock);

    DebugPrint((4, "SpAcquireRemoveLock: Acquired for Object %#p & irp "
                   "%#p - count is %d\n",
                DeviceObject,
                Tag,
                lockValue));

    ASSERTMSG("SpAcquireRemoveLock - lock value was negative : ",
              (lockValue > 0));

    ASSERTMSG("RemoveLock increased to meet LockHighWatermark",
              ((LockHighWatermark == 0) ||
               (lockValue != LockHighWatermark)));

#if DBG

    if(commonExtension->IsRemoved != REMOVE_COMPLETE) {

        trackingBlock = ExAllocateFromNPagedLookasideList(
                            &(commonExtension->RemoveTrackingLookasideList));

        if(trackingBlock == NULL) {
            KIRQL oldIrql;

            KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                              &oldIrql);
            commonExtension->RemoveTrackingUntrackedCount++;
            DebugPrint((1, ">>>>SpAcquireRemoveLock: Cannot track Tag %#p - "
                           "currently %d untracked requests\n",
                        Tag,
                        commonExtension->RemoveTrackingUntrackedCount));
            KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock,
                              oldIrql);
        } else {

            KIRQL oldIrql;

            trackingBlock->Tag = Tag;

            trackingBlock->File = File;
            trackingBlock->Line = Line;

            KeQueryTickCount((&trackingBlock->TimeLocked));

            KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                              &oldIrql);

            while(*removeTrackingList != NULL) {

                if((*removeTrackingList)->Tag > Tag) {
                    break;
                }

                if((*removeTrackingList)->Tag == Tag) {

                    DebugPrint((0, ">>>>SpAcquireRemoveLock - already tracking "
                                   "Tag %#p\n", Tag));
                    DebugPrint((0, ">>>>SpAcquireRemoveLock - acquired in "
                                   "file %s on line %d\n",
                                    (*removeTrackingList)->File,
                                    (*removeTrackingList)->Line));
                    ASSERT(FALSE);
                }

                removeTrackingList = &((*removeTrackingList)->NextBlock);
            }

            trackingBlock->NextBlock = *removeTrackingList;
            *removeTrackingList = trackingBlock;

            KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock,
                              oldIrql);

        }
    }

#endif
    return (commonExtension->IsRemoved);
}
#endif


VOID
FASTCALL
SpReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PIRP Tag
    )

/*++

Routine Description:

    This routine is called to release the remove lock on the device object.  It
    must be called when finished using a previously locked reference to the
    device object.  If an Tag was specified when acquiring the lock then the
    same Tag must be specified when releasing the lock.

    When the lock count reduces to zero, this routine will signal the waiting
    remove Tag to delete the device object.  As a result the DeviceObject
    pointer should not be used again once the lock has been released.

Arguments:

    DeviceObject - the device object to lock

    Tag - The irp (if any) specified when acquiring the lock.  This is used
          for lock tracking purposes

Return Value:

    none

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    LONG lockValue;

#if DBG
    PREMOVE_TRACKING_BLOCK *listEntry =
        &((PREMOVE_TRACKING_BLOCK) commonExtension->RemoveTrackingList);

    BOOLEAN found = FALSE;

    LONGLONG maxCount;

    KIRQL oldIrql;

    if(commonExtension->IsRemoved == REMOVE_COMPLETE) {
        return;
    }

    //
    // Check the tick count and make sure this thing hasn't been locked
    // for more than MaxLockedMinutes.
    //

    maxCount = KeQueryTimeIncrement() * 10;     // microseconds
    maxCount *= 1000;                           // milliseconds
    maxCount *= 1000;                           // seconds
    maxCount *= 60;                             // minutes
    maxCount *= MaxLockedMinutes;

    DebugPrint((4, "SpReleaseRemoveLock: maxCount = %0I64x\n", maxCount));

    KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                      &oldIrql);

    while(*listEntry != NULL) {

        PREMOVE_TRACKING_BLOCK block;
        LARGE_INTEGER difference;

        block = *listEntry;

        KeQueryTickCount((&difference));

        difference.QuadPart -= block->TimeLocked.QuadPart;

        DebugPrint((4, "SpReleaseRemoveLock: Object %#p (tag %#p) locked "
                       "for %I64d ticks\n", DeviceObject, block->Tag, difference.QuadPart));

        if(difference.QuadPart >= maxCount) {

            DebugPrint((0, ">>>>SpReleaseRemoveLock: Object %#p (tag %#p) locked "
                           "for %I64d ticks - TOO LONG\n", DeviceObject, block->Tag, difference.QuadPart));
            DebugPrint((0, ">>>>SpReleaseRemoveLock: Lock acquired in file "
                           "%s on line %d\n", block->File, block->Line));
            ASSERT(FALSE);
        }

        if((found == FALSE) && ((*listEntry)->Tag == Tag)) {

            *listEntry = block->NextBlock;
            ExFreeToNPagedLookasideList(
                &(commonExtension->RemoveTrackingLookasideList),
                block);
            found = TRUE;

        } else {

            listEntry = &((*listEntry)->NextBlock);

        }
    }

    if(!found) {

        if(commonExtension->RemoveTrackingUntrackedCount == 0) {
            DebugPrint((0, ">>>>SpReleaseRemoveLock: Couldn't find Tag %#p "
                           "in the lock tracking list\n",
                        Tag));
            ASSERT(FALSE);
        } else {

            DebugPrint((1, ">>>>SpReleaseRemoveLock: Couldn't find Tag %#p "
                           "in the lock tracking list - may be one of the "
                           "%d untracked requests still outstanding\n",
                        Tag,
                        commonExtension->RemoveTrackingUntrackedCount));

            commonExtension->RemoveTrackingUntrackedCount--;
            ASSERT(commonExtension->RemoveTrackingUntrackedCount >= 0);
        }
    }

    KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock, oldIrql);

#endif

    lockValue = InterlockedDecrement(&commonExtension->RemoveLock);

    DebugPrint((4, "SpReleaseRemoveLock: Released for Object %#p & irp "
                   "%#p - count is %d\n",
                DeviceObject,
                Tag,
                lockValue));

    ASSERT(lockValue >= 0);

    ASSERTMSG("RemoveLock decreased to meet LockLowWatermark",
              ((LockLowWatermark == 0) || !(lockValue == LockLowWatermark)));

    if(lockValue == 0) {

        ASSERT(commonExtension->IsRemoved);

        //
        // The device needs to be removed.  Signal the remove event
        // that it's safe to go ahead.
        //

        DebugPrint((3, "SpReleaseRemoveLock: Release for object %#p & "
                       "irp %#p caused lock to go to zero\n",
                    DeviceObject,
                    Tag));

        KeSetEvent(&commonExtension->RemoveEvent,
                   IO_NO_INCREMENT,
                   FALSE);

    }
    return;
}


VOID
FASTCALL
SpCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OPTIONAL PSRB_DATA SrbData,
    IN CCHAR PriorityBoost
    )

/*++

Routine Description:

    This routine is a wrapper around IoCompleteRequest.  It is used primarily
    for debugging purposes.  The routine will assert if the Irp being completed
    is still holding the release lock.

Arguments:


Return Value:

    none

--*/

{

    PADAPTER_EXTENSION adapterExtension = DeviceObject->DeviceExtension;
#if DBG
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PREMOVE_TRACKING_BLOCK *listEntry =
        &((PREMOVE_TRACKING_BLOCK) commonExtension->RemoveTrackingList);

    KIRQL oldIrql;

    KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                      &oldIrql);

    while(*listEntry != NULL) {

        if((*listEntry)->Tag == Irp) {
            break;
        }

        listEntry = &((*listEntry)->NextBlock);
    }

    if(*listEntry != NULL) {

        DebugPrint((0, ">>>>SpCompleteRequest: Irp %#p completed while "
                       "still holding the remove lock\n",
                    Irp));
        DebugPrint((0, ">>>>SpReleaseRemoveLock: Lock acquired in file "
                       "%s on line %d\n", (*listEntry)->File, (*listEntry)->Line));
        ASSERT(FALSE);
    }

    KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock, oldIrql);

    if(ARGUMENT_PRESENT(SrbData)) {
        PLOGICAL_UNIT_EXTENSION logicalUnit;

        ASSERT_SRB_DATA(SrbData);
        ASSERT(SrbData->ScatterGatherList == NULL);

        ASSERT_SRB_DATA(SrbData);
        ASSERT(SrbData->CurrentIrp == Irp);

        logicalUnit = SrbData->LogicalUnit;

        ASSERT(logicalUnit != NULL);
        ASSERT(logicalUnit->CurrentUntaggedRequest != SrbData);
        ASSERT_PDO(logicalUnit->CommonExtension.DeviceObject);

        ASSERT(SrbData->RemappedMdl == NULL);
    }

#endif

    //
    // If the caller specified an SRB_DATA structure for the completion then
    // we will free it to the lookaside list, fix the OriginalIrp value in the
    // srb and release the queue-tag value assigned to the device.
    //

    if(ARGUMENT_PRESENT(SrbData)) {
        PLOGICAL_UNIT_EXTENSION logicalUnit;

        logicalUnit = SrbData->LogicalUnit;

        ASSERTMSG("Attempt to complete blocked request: ",
                  ((logicalUnit->ActiveFailedRequest != SrbData) &&
                   (logicalUnit->BlockedFailedRequest != SrbData)));

        if((SrbData->CurrentSrb->Function == SRB_FUNCTION_LOCK_QUEUE) ||
           (SrbData->CurrentSrb->Function == SRB_FUNCTION_UNLOCK_QUEUE)) {
            ASSERT(logicalUnit->CurrentLockRequest == SrbData);
            SpStartLockRequest(logicalUnit, NULL);
        }

        SrbData->CurrentSrb->OriginalRequest = SrbData->CurrentIrp;
        SrbData->CurrentIrp = NULL;
        SrbData->CurrentSrb = NULL;

        ASSERT(SrbData->FreeRoutine != NULL);
        ASSERT((SrbData->FreeRoutine == SpFreeSrbData) ||
               (SrbData->FreeRoutine == SpFreeBypassSrbData));

        SrbData->FreeRoutine(logicalUnit->AdapterExtension, SrbData);
        SpReleaseRemoveLock(logicalUnit->CommonExtension.DeviceObject, Irp);
    }

    IoCompleteRequest(Irp, PriorityBoost);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\pnpstop.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    stop.c

Abstract:

    This is the NT SCSI port driver.  This file contains the initialization
    code.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "port.h"

typedef struct _SP_STOP_DEVICE_CONTEXT {
    OUT NTSTATUS Status;
    IN  KEVENT Event;
} SP_STOP_DEVICE_CONTEXT, *PSP_STOP_DEVICE_CONTEXT;

VOID
SpCallHwStopAdapter(
    IN PDEVICE_OBJECT Adapter
    );

BOOLEAN
SpCallHwStopAdapterSynchronized(
    IN PADAPTER_EXTENSION AdapterExtension
    );

VOID
SpDeviceStoppedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PSP_STOP_DEVICE_CONTEXT Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortStopLogicalUnit)
#pragma alloc_text(PAGE, ScsiPortStopAdapter)
#endif


NTSTATUS
ScsiPortStopLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

    This routine will lock the queue for the given logical unit to make sure
    that all request processing for this device is stopped.  It will clear
    the IsStarted flag once the queue has been locked successfully.  This will
    keep any other requests from being processed until a start has been
    received.

Arguments:

    LogicalUnit - the logical unit to be started.

    Irp - the stop request

Return Value:

    status

--*/

{
    SP_STOP_DEVICE_CONTEXT context;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if(LogicalUnit->CommonExtension.CurrentPnpState == IRP_MN_STOP_DEVICE) {
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&(context.Event), SynchronizationEvent, FALSE);

    status = SpEnableDisableLogicalUnit(LogicalUnit,
                                        FALSE,
                                        SpDeviceStoppedCompletion,
                                        &context);

    KeWaitForSingleObject(&(context.Event),
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    return context.Status;
}


VOID
SpDeviceStoppedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PSP_STOP_DEVICE_CONTEXT Context
    )
{

    Context->Status = Status;
    KeSetEvent(&(Context->Event), IO_NO_INCREMENT, FALSE);
    return;
}


NTSTATUS
ScsiPortStopAdapter(
    IN PDEVICE_OBJECT Adapter,
    IN PIRP StopRequest
    )

/*++

Routine Description:

    This routine will stop an adapter and release it's io and interrupt
    resources.  Pool allocations will not be freed, nor will the various
    miniport extensions.

Arguments:

    Adapter - the device object for the adapter.

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapterExtension = Adapter->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = Adapter->DeviceExtension;

    KEVENT event;

    ULONG bin;

    PAGED_CODE();

    ASSERT(adapterExtension->IsPnp);

    //
    // If we're not started and we weren't started then there's no reason
    // to do any work when stopping.
    //

    if((commonExtension->CurrentPnpState != IRP_MN_START_DEVICE) &&
       (commonExtension->PreviousPnpState != IRP_MN_START_DEVICE)) {

        return STATUS_SUCCESS;
    }

    //
    // Since all the children are stopped no requests can get through to the
    // adapter.
    //

    //
    // Send a request through the start-io routine to shut it down so that we
    // can start it back up later.
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    StopRequest->IoStatus.Information = (ULONG_PTR) &event;

    IoStartPacket(Adapter, StopRequest, 0, NULL);

    KeWaitForSingleObject(&event,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    //
    // Call the miniport and get it to shut the adapter down.
    //

    SpEnableDisableAdapter(adapterExtension, FALSE);

    SpReleaseAdapterResources(adapterExtension, TRUE, FALSE);

    //
    // Zero out all the logical unit extensions.
    //

    for(bin = 0; bin < NUMBER_LOGICAL_UNIT_BINS; bin++) {

        PLOGICAL_UNIT_EXTENSION lun;

        for(lun = adapterExtension->LogicalUnitList[bin].List;
            lun != NULL;
            lun = lun->NextLogicalUnit) {

            RtlZeroMemory(lun->HwLogicalUnitExtension,
                          adapterExtension->HwLogicalUnitExtensionSize);
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\map.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    map.c

Abstract:

    This module contains routines for maintaining the SCSI device map in the
    registry.

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

#define __FILE_ID__ 'map '

HANDLE ScsiDeviceMapKey = (HANDLE) -1;

VOID
SpDeleteLogicalUnitDeviceMapEntry(
    PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpDeleteAdapterDeviceMap(
    PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpBuildAdapterDeviceMap(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpBuildLogicalUnitDeviceMapEntry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

NTSTATUS
SpCreateNumericKey(
    IN HANDLE Root,
    IN ULONG Name,
    IN PWSTR Prefix,
    IN BOOLEAN Create,
    OUT PHANDLE NewKey,
    OUT PULONG Disposition
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpInitDeviceMap)

#pragma alloc_text(PAGE, SpBuildDeviceMapEntry)
#pragma alloc_text(PAGE, SpBuildAdapterDeviceMap)
#pragma alloc_text(PAGE, SpBuildLogicalUnitDeviceMapEntry)

#pragma alloc_text(PAGE, SpDeleteLogicalUnitDeviceMapEntry)
#pragma alloc_text(PAGE, SpDeleteAdapterDeviceMap)

#pragma alloc_text(PAGE, SpUpdateLogicalUnitDeviceMapEntry)

#pragma alloc_text(PAGE, SpCreateNumericKey)
#endif


NTSTATUS
SpInitDeviceMap(
    VOID
    )

/*++

Routine Description:

Arguments:

Return Value:

    status

--*/

{
    UNICODE_STRING name;

    OBJECT_ATTRIBUTES objectAttributes;

    HANDLE mapKey;

    ULONG disposition;

    ULONG i;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Open the SCSI key in the device map.
    //

    RtlInitUnicodeString(&name,
                         L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi");

    InitializeObjectAttributes(&objectAttributes,
                               &name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    //
    // Create or open the key.
    //

    status = ZwCreateKey(&mapKey,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING) NULL,
                         REG_OPTION_VOLATILE,
                         &disposition);

    if(NT_SUCCESS(status)) {
        ScsiDeviceMapKey = mapKey;
    } else {
        ScsiDeviceMapKey = NULL;
    }

    return status;
}


NTSTATUS
SpBuildDeviceMapEntry(
    IN PCOMMON_EXTENSION CommonExtension
    )

/*++

Routine Description:

    This routine will make an entry for the specified adapter or logical
    unit in the SCSI device map in the registry.  This table is maintained for
    debugging and legacy use.

    A handle to the device map key for this device will be stored in the
    common device extension.  This handle should only be used within the
    context of a system thread.

Arguments:

    Extension - the object we are adding to the device map.

Return Value:

    status

--*/

{
    PAGED_CODE();

    if(CommonExtension->IsPdo) {
        return SpBuildLogicalUnitDeviceMapEntry((PLOGICAL_UNIT_EXTENSION) CommonExtension);
    } else {
        return SpBuildAdapterDeviceMap((PADAPTER_EXTENSION) CommonExtension);
    }
}


NTSTATUS
SpBuildLogicalUnitDeviceMapEntry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    PADAPTER_EXTENSION adapter = LogicalUnit->AdapterExtension;

    HANDLE busKey;

    PCWSTR typeString;
    ANSI_STRING ansiString;

    UNICODE_STRING name;
    UNICODE_STRING unicodeString;

    ULONG disposition;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(LogicalUnit->IsTemporary == FALSE);

    DebugPrint((1, "SpBuildDeviceMapEntry: Building map entry for lun %p\n",
                   LogicalUnit));

    if(adapter->BusDeviceMapKeys == NULL) {

        //
        // We don't have keys built for the buses yet.  Bail out.
        //

        return STATUS_UNSUCCESSFUL;
    }

    //
    // If we already have a target or LUN key for this device then we're done.
    //

    if((LogicalUnit->TargetDeviceMapKey != NULL) &&
       (LogicalUnit->LunDeviceMapKey != NULL)) {

        return STATUS_SUCCESS;
    }

    busKey = adapter->BusDeviceMapKeys[LogicalUnit->PathId].BusKey;

    //
    // Create a key for the target
    //

    status = SpCreateNumericKey(busKey,
                                LogicalUnit->TargetId,
                                L"Target Id ",
                                TRUE,
                                &(LogicalUnit->TargetDeviceMapKey),
                                &disposition);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Create the LUN entry
    //

    status = SpCreateNumericKey(LogicalUnit->TargetDeviceMapKey,
                                LogicalUnit->Lun,
                                L"Logical Unit Id ",
                                TRUE,
                                &(LogicalUnit->LunDeviceMapKey),
                                &disposition);

    if(!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Create the identifier value
    //

    RtlInitUnicodeString(&name, L"Identifier");

    //
    // Get the identifier from the inquiry data
    //

    ansiString.MaximumLength = 28;
    ansiString.Length = 28;
    ansiString.Buffer = LogicalUnit->InquiryData.VendorId;

    status = RtlAnsiStringToUnicodeString(&unicodeString,
                                          &ansiString,
                                          TRUE);

    if(NT_SUCCESS(status)) {

        status = ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                               &name,
                               0,
                               REG_SZ,
                               unicodeString.Buffer,
                               unicodeString.Length + sizeof(WCHAR));

        RtlFreeUnicodeString(&unicodeString);
    }

    //
    // Determine the peripheral type
    //

    typeString =
        SpGetDeviceTypeInfo(LogicalUnit->InquiryData.DeviceType)->DeviceMapString;

    //
    // Set type value.
    //

    RtlInitUnicodeString(&name, L"Type");

    status = ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                           &name,
                           0,
                           REG_SZ,
                           (PVOID) typeString,
                           (wcslen(typeString) + 1) * sizeof(WCHAR));

    //
    // Write the inquiry data into the device map for debugging purposes
    //

    RtlInitUnicodeString(&name, L"InquiryData");

    status = ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                           &name,
                           0,
                           REG_BINARY,
                           &(LogicalUnit->InquiryData),
                           INQUIRYDATABUFFERSIZE);

    //
    // Convert the serial number into unicode and write it out to the
    // registry.
    //

    //
    // Get the identifier from the inquiry data
    //

    if(LogicalUnit->SerialNumber.Length != 0) {
        RtlInitUnicodeString(&name, L"SerialNumber");

        status = RtlAnsiStringToUnicodeString(
                    &unicodeString,
                    &(LogicalUnit->SerialNumber),
                    TRUE);

        if(NT_SUCCESS(status)) {

            status = ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                                   &name,
                                   0,
                                   REG_SZ,
                                   unicodeString.Buffer,
                                   unicodeString.Length + sizeof(WCHAR));

            RtlFreeUnicodeString(&unicodeString);
        }
    }

    //
    // If the device identifier page exists then write it out to the registry
    //

    if(LogicalUnit->DeviceIdentifierPage != NULL) {
        RtlInitUnicodeString(&name, L"DeviceIdentifierPage");

        status = ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                               &name,
                               0,
                               REG_BINARY,
                               LogicalUnit->DeviceIdentifierPage,
                               LogicalUnit->DeviceIdentifierPageLength);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SpBuildAdapterDeviceMap(
    IN PADAPTER_EXTENSION Adapter
    )
{
    PSCSIPORT_DRIVER_EXTENSION driverExtension;
    HANDLE mapKey;

    UNICODE_STRING name;

    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    ULONG i;

    NTSTATUS status;

    PUNICODE_STRING servicePath;

    ULONG busNumber;

    PAGED_CODE();

    //
    // Grab the handle to the SCSI device map out of the driver extension.
    //

    driverExtension = IoGetDriverObjectExtension(
                            Adapter->DeviceObject->DriverObject,
                            ScsiPortInitialize);

    ASSERT(driverExtension != NULL);

    mapKey = ScsiDeviceMapKey;

    if(mapKey == NULL) {

        //
        // For some reason we were unable to create the root of the device map
        // during scsiport initialization.
        //

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Create a key beneath this for the port device
    //

    status = SpCreateNumericKey(mapKey,
                                Adapter->PortNumber,
                                L"Scsi Port ",
                                TRUE,
                                &(Adapter->PortDeviceMapKey),
                                &disposition);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Indicate if it's a PCCARD
    //

    if(RtlEqualMemory(&GUID_BUS_TYPE_PCMCIA,
                      &(Adapter->BusTypeGuid),
                      sizeof(GUID))) {

        RtlInitUnicodeString(&name, L"PCCARD");

        i = 1;

        status = ZwSetValueKey(Adapter->PortDeviceMapKey,
                               &name,
                               0,
                               REG_DWORD,
                               &i,
                               sizeof(ULONG));
    }

    //
    // Set the interrupt value
    //

    if(Adapter->InterruptLevel) {
        RtlInitUnicodeString(&name, L"Interrupt");

        i = Adapter->InterruptLevel;

        status = ZwSetValueKey(Adapter->PortDeviceMapKey,
                               &name,
                               0,
                               REG_DWORD,
                               &i,
                               sizeof(ULONG));
    }

    //
    // Set the base I/O address value
    //

    if(Adapter->IoAddress) {

        RtlInitUnicodeString(&name, L"IOAddress");

        i = Adapter->IoAddress;

        status = ZwSetValueKey(Adapter->PortDeviceMapKey,
                               &name,
                               0,
                               REG_DWORD,
                               &i,
                               sizeof(ULONG));

    }

    if(Adapter->Dma64BitAddresses) {
        RtlInitUnicodeString(&name, L"Dma64BitAddresses");
        i = 0x1;
        status = ZwSetValueKey(Adapter->PortDeviceMapKey,
                               &name,
                               0,
                               REG_DWORD,
                               &i,
                               sizeof(ULONG));
    }

    servicePath = &driverExtension->RegistryPath;

    ASSERT(servicePath != NULL);

    //
    // Add identifier value.  This value is equal to the name of the driver
    // in the service key.  Note the service key name is not NULL terminated
    //

    {
        PWSTR start;
        WCHAR buffer[32];

        RtlInitUnicodeString(&name, L"Driver");

        //
        // Get the name of the driver from the service key name.
        //

        start = (PWSTR) ((PCHAR) servicePath->Buffer + servicePath->Length);

        start--;

        while(*start != L'\\' && start > servicePath->Buffer) {
            start--;
        }

        if(*start == L'\\') {
            start++;

            for(i = 0; i < 30; i++) {
                buffer[i] = *start++;

                if(start >= (servicePath->Buffer +
                             (servicePath->Length / sizeof(WCHAR)))) {
                    break;
                }
            }

            i++;

            buffer[i] = L'\0';

            status = ZwSetValueKey(Adapter->PortDeviceMapKey,
                                   &name,
                                   0,
                                   REG_SZ,
                                   buffer,
                                   (i + 1) * sizeof(WCHAR));

        }
    }

    //
    // Allocate storage for all the bus handles.
    //

    Adapter->BusDeviceMapKeys = SpAllocatePool(
                                    PagedPool,
                                    (sizeof(DEVICE_MAP_HANDLES) *
                                     Adapter->NumberOfBuses),
                                    SCSIPORT_TAG_DEVICE_MAP,
                                    Adapter->DeviceObject->DriverObject);

    if(Adapter->BusDeviceMapKeys == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(Adapter->BusDeviceMapKeys,
                  (sizeof(DEVICE_MAP_HANDLES) * Adapter->NumberOfBuses));

    //
    // Create a key for each bus.  In each bus key create an empty key
    // the initiator.
    //

    for(busNumber = 0;
        busNumber < Adapter->NumberOfBuses;
        busNumber++) {

        PDEVICE_MAP_HANDLES busKeys;

        HANDLE busKey;
        HANDLE targetKey;

        busKeys = &(Adapter->BusDeviceMapKeys[busNumber]);

        //
        // Create a key entry for the bus.
        //

        status = SpCreateNumericKey(
                    Adapter->PortDeviceMapKey,
                    busNumber,
                    L"Scsi Bus ",
                    TRUE,
                    &(busKeys->BusKey),
                    &disposition);

        if(!NT_SUCCESS(status)) {
            continue;
        }

        //
        // Now create a key for the initiator.
        //

        i = Adapter->PortConfig->InitiatorBusId[busNumber];

        status = SpCreateNumericKey(busKeys->BusKey,
                                    i,
                                    L"Initiator Id ",
                                    TRUE,
                                    &(busKeys->InitiatorKey),
                                    &disposition);

        if(!NT_SUCCESS(status)) {
            continue;
        }
    }

    return STATUS_SUCCESS;
}


VOID
SpDeleteDeviceMapEntry(
    IN PCOMMON_EXTENSION CommonExtension
    )
{
    if(CommonExtension->IsPdo) {
        SpDeleteLogicalUnitDeviceMapEntry((PLOGICAL_UNIT_EXTENSION) CommonExtension);
    } else {
        SpDeleteAdapterDeviceMap((PADAPTER_EXTENSION) CommonExtension);
    }
    return;
}


VOID
SpDeleteLogicalUnitDeviceMapEntry(
    PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    if(LogicalUnit->LunDeviceMapKey != NULL) {
        ASSERT(LogicalUnit->IsTemporary == FALSE);

        ZwDeleteKey(LogicalUnit->LunDeviceMapKey);
        ZwClose(LogicalUnit->LunDeviceMapKey);
        LogicalUnit->LunDeviceMapKey = NULL;
    }

    if(LogicalUnit->TargetDeviceMapKey != NULL) {
        ASSERT(LogicalUnit->IsTemporary == FALSE);

        ZwDeleteKey(LogicalUnit->TargetDeviceMapKey);
        ZwClose(LogicalUnit->TargetDeviceMapKey);
        LogicalUnit->TargetDeviceMapKey = NULL;
    }

    return;
}


VOID
SpDeleteAdapterDeviceMap(
    PADAPTER_EXTENSION Adapter
    )
{

    if(Adapter->BusDeviceMapKeys != NULL) {

        ULONG busNumber;

        //
        // for each bus on the adapter.
        //

        for(busNumber = 0; busNumber < Adapter->NumberOfBuses; busNumber++) {

            PDEVICE_MAP_HANDLES busKeys;

            busKeys = &(Adapter->BusDeviceMapKeys[busNumber]);

            //
            // Attempt to delete the key for the initiator if it was created.
            //

            if(busKeys->InitiatorKey != NULL) {
                ZwDeleteKey(busKeys->InitiatorKey);
                ZwClose(busKeys->InitiatorKey);
            }

            //
            // Attempt to delete the key for the bus if it was created.
            //

            if(busKeys->BusKey != NULL) {
                ZwDeleteKey(busKeys->BusKey);
                ZwClose(busKeys->BusKey);
            }
        }

        ExFreePool(Adapter->BusDeviceMapKeys);
        Adapter->BusDeviceMapKeys = NULL;
    }

    //
    // Attempt to delete the key for the adapter if it was created.
    //

    if(Adapter->PortDeviceMapKey != NULL) {
        ZwDeleteKey(Adapter->PortDeviceMapKey);
        ZwClose(Adapter->PortDeviceMapKey);
        Adapter->PortDeviceMapKey = NULL;
    }

    return;
}


NTSTATUS
SpCreateNumericKey(
    IN HANDLE Root,
    IN ULONG Name,
    IN PWSTR Prefix,
    IN BOOLEAN Create,
    OUT PHANDLE NewKey,
    OUT PULONG Disposition
    )

/*++

Routine Description:

    This function creates a registry key.  The name of the key is a string
    version of numeric value passed in.

Arguments:

    RootKey - Supplies a handle to the key where the new key should be inserted.

    Name - Supplies the numeric value to name the key.

    Prefix - Supplies a prefix name to add to name.

    Create - if TRUE the key will be created if it does not already exist.

    NewKey - Returns the handle for the new key.

    Disposition - the disposition value set by ZwCreateKey.

Return Value:

   Returns the status of the operation.

--*/

{
    UNICODE_STRING string;
    UNICODE_STRING stringNum;
    OBJECT_ATTRIBUTES objectAttributes;
    WCHAR bufferNum[16];
    WCHAR buffer[64];
    NTSTATUS status;

    PAGED_CODE();

    //
    // Copy the Prefix into a string.
    //

    string.Length = 0;
    string.MaximumLength=64;
    string.Buffer = buffer;

    RtlInitUnicodeString(&stringNum, Prefix);

    RtlCopyUnicodeString(&string, &stringNum);

    //
    // Create a port number key entry.
    //

    stringNum.Length = 0;
    stringNum.MaximumLength = 16;
    stringNum.Buffer = bufferNum;

    status = RtlIntegerToUnicodeString(Name, 10, &stringNum);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Append the prefix and the numeric name.
    //

    RtlAppendUnicodeStringToString(&string, &stringNum);

    InitializeObjectAttributes( &objectAttributes,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                Root,
                                (PSECURITY_DESCRIPTOR) NULL );

    if(Create) {
        status = ZwCreateKey(NewKey,
                            KEY_READ | KEY_WRITE,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            Disposition );
    } else {

        status = ZwOpenKey(NewKey,
                           KEY_READ | KEY_WRITE,
                           &objectAttributes);

        *Disposition = REG_OPENED_EXISTING_KEY;
    }

    return(status);
}


NTSTATUS
SpUpdateLogicalUnitDeviceMapEntry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    UNICODE_STRING name;

    PAGED_CODE();

    if((LogicalUnit->TargetDeviceMapKey == NULL) ||
       (LogicalUnit->LunDeviceMapKey == NULL)) {

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Write the inquiry data into the device map for debugging purposes
    //

    RtlInitUnicodeString(&name, L"InquiryData");

    ZwSetValueKey(LogicalUnit->LunDeviceMapKey,
                  &name,
                  0,
                  REG_BINARY,
                  &(LogicalUnit->InquiryData),
                  INQUIRYDATABUFFERSIZE);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\pnp.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    pnp.c

Abstract:

    This is the NT SCSI port driver.  This file contains the self-contained plug
    and play code.

Authors:

    Peter Wieland

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "port.h"
#include <wdmguid.h>

#define __FILE_ID__ 'pnp '

#if DBG
static const char *__file__ = __FILE__;
#endif

#define NUM_DEVICE_TYPE_INFO_ENTRIES 18

extern SCSIPORT_DEVICE_TYPE DeviceTypeInfo[];

ULONG SpAdapterStopRemoveSupported = TRUE;

NTSTATUS
SpQueryCapabilities(
    IN PADAPTER_EXTENSION Adapter
    );

PWCHAR
ScsiPortAddGenericControllerId(
    IN PDRIVER_OBJECT DriverObject,
    IN PWCHAR IdList
    );

VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    );

NTSTATUS
ScsiPortInitPnpAdapter(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
SpStartLowerDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SpGetSlotNumber(
    IN PDEVICE_OBJECT Fdo,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN PCM_RESOURCE_LIST ResourceList
    );

BOOLEAN
SpGetInterrupt(
    IN PCM_RESOURCE_LIST FullResourceList,
    OUT ULONG *Irql,
    OUT ULONG *Vector,
    OUT KAFFINITY *Affinity
    );

VOID
SpQueryDeviceRelationsCompletion(
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN NTSTATUS Status
    );

NTSTATUS
ScsiPortDetermineGenId(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUCHAR GenericId
    );

//
// Routines start
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortAddDevice)
#pragma alloc_text(PAGE, ScsiPortUnload)
#pragma alloc_text(PAGE, ScsiPortFdoPnp)
#pragma alloc_text(PAGE, ScsiPortStartAdapter)
#pragma alloc_text(PAGE, ScsiPortGetDeviceId)
#pragma alloc_text(PAGE, ScsiPortGetInstanceId)
#pragma alloc_text(PAGE, ScsiPortGetHardwareIds)
#pragma alloc_text(PAGE, ScsiPortGetCompatibleIds)
#pragma alloc_text(PAGE, ScsiPortDetermineGenId)
#pragma alloc_text(PAGE, CopyField)
#pragma alloc_text(PAGE, SpFindInitData)
#pragma alloc_text(PAGE, SpStartLowerDevice)
#pragma alloc_text(PAGE, SpGetSlotNumber)
#pragma alloc_text(PAGE, SpGetDeviceTypeInfo)
#pragma alloc_text(PAGE, ScsiPortAddGenericControllerId)
#pragma alloc_text(PAGE, SpQueryCapabilities)
#pragma alloc_text(PAGE, SpGetInterrupt)
#pragma alloc_text(PAGE, SpQueryDeviceRelationsCompletion)

#pragma alloc_text(PAGELOCK, ScsiPortInitPnpAdapter)
#endif

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

SCSIPORT_DEVICE_TYPE DeviceTypeInfo[NUM_DEVICE_TYPE_INFO_ENTRIES] = {
    {"Disk",        "GenDisk",          L"DiskPeripheral",                  TRUE},
    {"Sequential",  "",                 L"TapePeripheral",                  TRUE},
    {"Printer",     "GenPrinter",       L"PrinterPeripheral",               FALSE},
    {"Processor",   "",                 L"OtherPeripheral",                 FALSE},
    {"Worm",        "GenWorm",          L"WormPeripheral",                  TRUE},
    {"CdRom",       "GenCdRom",         L"CdRomPeripheral",                 TRUE},
    {"Scanner",     "GenScanner",       L"ScannerPeripheral",               FALSE},
    {"Optical",     "GenOptical",       L"OpticalDiskPeripheral",           TRUE},
    {"Changer",     "ScsiChanger",      L"MediumChangerPeripheral",         TRUE},
    {"Net",         "ScsiNet",          L"CommunicationsPeripheral",        FALSE},
    {"ASCIT8",      "ScsiASCIT8",       L"ASCPrePressGraphicsPeripheral",   FALSE},
    {"ASCIT8",      "ScsiASCIT8",       L"ASCPrePressGraphicsPeripheral",   FALSE},
    {"Array",       "ScsiArray",        L"ArrayPeripheral",                 FALSE},
    {"Enclosure",   "ScsiEnclosure",    L"EnclosurePeripheral",             FALSE},
    {"RBC",         "ScsiRBC",          L"RBCPeripheral",                   TRUE},
    {"CardReader",  "ScsiCardReader",   L"CardReaderPeripheral",            FALSE},
    {"Bridge",      "ScsiBridge",       L"BridgePeripheral",                FALSE},
    {"Other",       "ScsiOther",        L"OtherPeripheral",                 FALSE}
};

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif


NTSTATUS
ScsiPortAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine handles add-device requests for the scsi port driver

Arguments:

    DriverObject - a pointer to the driver object for this device

    PhysicalDeviceObject - a pointer to the PDO we are being added to

Return Value:

    STATUS_SUCCESS

--*/

{
    PSCSIPORT_DRIVER_EXTENSION driverExtension;
    PDEVICE_OBJECT newFdo;

    NTSTATUS status;

    PAGED_CODE();

    status = SpCreateAdapter(DriverObject, &newFdo);

    if(newFdo != NULL) {

        PADAPTER_EXTENSION adapter;
        PCOMMON_EXTENSION commonExtension;

        PDEVICE_OBJECT newStack;

        adapter = newFdo->DeviceExtension;
        commonExtension = &(adapter->CommonExtension);

        adapter->IsMiniportDetected = FALSE;
        adapter->IsPnp = TRUE;

        driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                     ScsiPortInitialize);

        switch(driverExtension->BusType) {
#if 0
            case BusTypeFibre: {
                adapter->DisablePower = TRUE;
                adapter->DisableStop = TRUE;
                break;
            }
#endif

            default: {
                adapter->DisablePower = FALSE;
                adapter->DisableStop = FALSE;
                break;
            }
        }

        newStack = IoAttachDeviceToDeviceStack(newFdo, PhysicalDeviceObject);

        adapter->CommonExtension.LowerDeviceObject = newStack;
        adapter->LowerPdo = PhysicalDeviceObject;

        if(newStack == NULL) {

            status =  STATUS_UNSUCCESSFUL;

        } else {

            status =  STATUS_SUCCESS;
        }
    }

    return status;
}


VOID
ScsiPortUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine will shut down all device objects for this miniport and
    clean up all allocated resources

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/

{
    PVOID Packet;
    PSCSIPORT_DRIVER_EXTENSION DriverExtension;
    PVOID CurrentValue;
    PVOID InvalidPage;

    PAGED_CODE();

    //
    // See if there is a driver extension for this driver.  It is possible
    // that one has not been created yet, so this may fail, in which case
    // we give up and return.
    //

    DriverExtension = IoGetDriverObjectExtension(
                          DriverObject,
                          ScsiPortInitialize
                          );

    if (DriverExtension == NULL) {
        return;
    }

    //
    // Get the reserve event in the driver extension.  The reserve event
    // may not have already been used, so it's possible that it is NULL.  If
    // this is the case, we give up and return.
    //

    Packet = DriverExtension->ReserveAllocFailureLogEntry;

    if (Packet != NULL) {

        //
        // We have to ensure that we are the only instance to use this
        // event.  To do so, we attempt to NULL the event in the driver
        // extension.  If somebody else beats us to it, they own the
        // event and we have to give up.
        //

        CurrentValue = InterlockedCompareExchangePointer(
                           &(DriverExtension->ReserveAllocFailureLogEntry),
                           NULL,
                           Packet);

        if (Packet == CurrentValue) {            
            IoFreeErrorLogEntry(Packet);
        }
    }

    //
    // Free the invalid page we created to catch misbehaving miniports.
    //

    InvalidPage = DriverExtension->InvalidPage;

    if (InvalidPage != NULL) {

        CurrentValue = InterlockedCompareExchangePointer(
                           &(DriverExtension->InvalidPage),
                           NULL,
                           InvalidPage);

        if (InvalidPage == CurrentValue) {
            MmProtectMdlSystemAddress(DriverExtension->UnusedPageMdl, PAGE_READWRITE);
            MmUnlockPages(DriverExtension->UnusedPageMdl);
            IoFreeMdl(DriverExtension->UnusedPageMdl);
            ExFreePool(DriverExtension->UnusedPage);
        }
    }

#ifdef ALLOC_PRAGMA
    if (VerifierApiCodeSectionHandle != NULL) {
        PVOID Handle = VerifierApiCodeSectionHandle;
        CurrentValue = InterlockedCompareExchangePointer(
                           &VerifierApiCodeSectionHandle,
                           NULL,
                           Handle);
        if (CurrentValue == Handle) {            
            MmUnlockPagableImageSection(Handle);
        }        
    }
#endif
    
    return;
}


NTSTATUS
ScsiPortFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;

    ULONG isRemoved;

    BOOLEAN sendDown = TRUE;

    PAGED_CODE();

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);

    DebugPrint((2, "ScsiPortFdoPnp: FDO %p IRP %p MinorFunction %x isRemoved %d\n",
                DeviceObject,
                Irp,
                irpStack->MinorFunction,
                isRemoved));

    switch (irpStack->MinorFunction) {

        case IRP_MN_QUERY_PNP_DEVICE_STATE: {

            //
            // Extract the address of the device state buffer from the IRP. 
            //

            PPNP_DEVICE_STATE deviceState;
            deviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);

            //
            // Copy our saved device state into the supplied address.
            //

            *deviceState = adapter->DeviceState;

            //
            // If the device is in the paging path, mark it as not-disableable.
            //

            if (commonExtension->PagingPathCount != 0) {
                SET_FLAG((*deviceState), PNP_DEVICE_NOT_DISABLEABLE);
            }

            //
            // Leave sendDown set to TRUE so request will be forwarded to
            // lower driver below.
            //

            break;
        }

        case IRP_MN_START_DEVICE: {

            PSCSIPORT_DRIVER_EXTENSION driverExtension =
                IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                           ScsiPortInitialize);

            PCM_RESOURCE_LIST allocatedResources =
                irpStack->Parameters.StartDevice.AllocatedResources;
            PCM_RESOURCE_LIST translatedResources =
                irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
            ULONG interfaceFlags;

            irpStack = IoGetCurrentIrpStackLocation(Irp);

            //
            // Override sendDown so we complete this request below instead of
            // forwarding it to the lower driver.
            //

            sendDown = FALSE;

            //
            // Make sure this device was created by an add rather than the
            // one that was found by port or miniport.
            //

            if(adapter->IsPnp == FALSE) {

                DebugPrint((1, "ScsiPortFdoPnp - asked to start non-pnp "
                               "adapter\n"));
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            if(commonExtension->CurrentPnpState == IRP_MN_START_DEVICE) {

                DebugPrint((1, "ScsiPortFdoPnp - already started - nothing "
                               "to do\n"));
                status = STATUS_SUCCESS;
                break;
            }

            //
            // Now make sure that pnp handed us some resources.  It may not
            // if this is a phantom of a PCI device which we reported on a
            // previous boot.  In that case pnp thinks we'll allocate the
            // resources ourselves.
            //

            if(allocatedResources == NULL) {

                //
                // This happens with reported devices when PCI moves them from
                // boot to boot.
                //

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                break;
            }

            ASSERT(allocatedResources->Count);

            //
            // Make sure that adapters with this interface type can be
            // initialized as pnp drivers.
            //

            interfaceFlags = SpQueryPnpInterfaceFlags(
                                driverExtension,
                                allocatedResources->List[0].InterfaceType);

            if(interfaceFlags == SP_PNP_NOT_SAFE) {

                //
                // Nope - not safe.  We cannot start this device so return
                // failure.
                //

                DebugPrint((1, "ScsiPortFdoPnp - Miniport cannot be run in "
                               "pnp mode for interface type %#08lx\n",
                            allocatedResources->List[0].InterfaceType));

                //
                // Mark the device as not being pnp - that way we won't get
                // removed.
                //

                adapter->IsPnp = FALSE;

                status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Check to see if this interface requires slot/function numbers.
            // If not then zero out the virtual slot number.
            //

            if(!TEST_FLAG(interfaceFlags, SP_PNP_NEEDS_LOCATION)) {
                adapter->VirtualSlotNumber.u.AsULONG = 0;
            }


            //
            // Determine if we should have found this device during
            // our detection scan.  We do this by checking to see if the pdo
            // has a pnp bus type.  If not and the detection flag is set then
            // assume duplicate detection has failed and don't start this
            // device.
            //

            {
                status = SpGetBusTypeGuid(adapter);

                if((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
                   ((driverExtension->LegacyAdapterDetection == TRUE) &&
                    (interfaceFlags & SP_PNP_NON_ENUMERABLE))) {

                    DbgPrint("ScsiPortFdoPnp: device has no pnp bus type but "
                             "was not found as a duplicate during "
                             "detection\n");

                    status = STATUS_UNSUCCESSFUL;

                    //
                    // make sure this one doesn't get removed though - if it's
                    // removed then the resources may be disabled for the
                    // ghost.
                    //

                    adapter->IsPnp = FALSE;

                    break;
                }
            }

            //
            // Finally, if this is a PCI adapter make sure we were given
            // an interrupt.  The current assumption is that there aren't
            // any polled-mode PCI SCSI adapters in the market.
            //

            if(TEST_FLAG(interfaceFlags, SP_PNP_INTERRUPT_REQUIRED)) {

                ULONG irql, vector;
                KAFFINITY affinity;

                if(SpGetInterrupt(allocatedResources,
                                  &irql,
                                  &vector,
                                  &affinity) == FALSE) {

                    PIO_ERROR_LOG_PACKET error =
                        IoAllocateErrorLogEntry(DeviceObject,
                                                sizeof(IO_ERROR_LOG_PACKET));

                    status = STATUS_DEVICE_CONFIGURATION_ERROR;

                    if(error != NULL) {
                        error->MajorFunctionCode = IRP_MJ_PNP;
                        error->UniqueErrorValue = 0x418;
                        error->ErrorCode = IO_ERR_INCORRECT_IRQL;
                        IoWriteErrorLogEntry(error);
                    }
                    break;
                }
            }

            status = SpStartLowerDevice(DeviceObject, Irp);

            if(NT_SUCCESS(status)) {

                //
                // If we haven't allocated a HwDeviceExtension for this thing
                // yet then we'll need to set it up
                //

                if(commonExtension->IsInitialized == FALSE) {

                    DebugPrint((1, "ScsiPortFdoPnp - find and init adapter %#p\n",
                                   DeviceObject));

                    if(allocatedResources == NULL) {
                        status = STATUS_INVALID_PARAMETER;
                    } else {

                        adapter->AllocatedResources =
                            RtlDuplicateCmResourceList(
                                DeviceObject->DriverObject,
                                NonPagedPool,
                                allocatedResources,
                                SCSIPORT_TAG_RESOURCE_LIST);

                        adapter->TranslatedResources =
                            RtlDuplicateCmResourceList(
                                DeviceObject->DriverObject,
                                NonPagedPool,
                                translatedResources,
                                SCSIPORT_TAG_RESOURCE_LIST);

                        commonExtension->IsInitialized = TRUE;

                        status = ScsiPortInitPnpAdapter(DeviceObject);
                    }

                    if(!NT_SUCCESS(status)) {

                        DebugPrint((1, "ScsiPortInitializeAdapter failed "
                                       "%#08lx\n", status));
                        break;
                    }

                }

                //
                // Start up the adapter.
                //

                status = ScsiPortStartAdapter(DeviceObject);

                if(NT_SUCCESS(status)) {
                    commonExtension->PreviousPnpState = 0xff;
                    commonExtension->CurrentPnpState = IRP_MN_START_DEVICE;
                }

            }

            break;
        }

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {

            PIO_RESOURCE_REQUIREMENTS_LIST requirements;

            //
            // Grab the bus and slot numbers out of the resource requirements
            // list.
            //

            requirements = irpStack->Parameters.FilterResourceRequirements.
                                                IoResourceRequirementList;

            if (requirements != NULL) {
                adapter->RealBusNumber = requirements->BusNumber;
                adapter->RealSlotNumber = requirements->SlotNumber;
            }

            //
            // Leave sendDown in its default TRUE state so we will forward
            // this request to the lower driver.
            //

            break;
        }

        case IRP_MN_CANCEL_STOP_DEVICE: {

            sendDown = TRUE;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            if(commonExtension->CurrentPnpState == IRP_MN_QUERY_STOP_DEVICE) {
                commonExtension->CurrentPnpState =
                    commonExtension->PreviousPnpState;
                commonExtension->PreviousPnpState = 0xff;
            }
            break;
        }

        case IRP_MN_CANCEL_REMOVE_DEVICE: {

            sendDown = TRUE;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            if(commonExtension->CurrentPnpState == IRP_MN_QUERY_REMOVE_DEVICE) {
                commonExtension->CurrentPnpState =
                    commonExtension->PreviousPnpState;
                commonExtension->PreviousPnpState = 0xff;
            }
            break;
        }

        case IRP_MN_QUERY_STOP_DEVICE: {

            //
            // If stop has been disabled, fail the IRP and override sendDown
            // so we complete the request instead of forwarding it.
            //

            if (adapter->DisableStop) {
                status = STATUS_NOT_SUPPORTED;
                sendDown = FALSE;
                break;
            }

            //
            // Fall through.
            //
        }

        case IRP_MN_QUERY_REMOVE_DEVICE: {

            //
            // No problem with this request on our part.  Just send it down
            // to the next driver.
            //

            if (SpAdapterStopRemoveSupported) {
                if((adapter->IsPnp) &&
                   SpIsAdapterControlTypeSupported(adapter,
                                                   ScsiStopAdapter)) {
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    sendDown = TRUE;
                } else {
                    status = STATUS_UNSUCCESSFUL;
                    sendDown = FALSE;
                }

                if(NT_SUCCESS(status)) {
                    commonExtension->PreviousPnpState =
                        commonExtension->CurrentPnpState;
                    commonExtension->CurrentPnpState = irpStack->MinorFunction;
                }
            } else {
                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                status = STATUS_UNSUCCESSFUL;
                sendDown = FALSE;
            }

            break;
        }

        case IRP_MN_SURPRISE_REMOVAL: {

            PDEVICE_OBJECT lowerDevice = commonExtension->LowerDeviceObject;

            //
            // First mark the device as REMOVE_PENDING - this should keep
            // us from starting up any new i/o requests.
            //

            commonExtension->IsRemoved = REMOVE_PENDING;

            //
            // Terminate the device.  This shuts down the miniport as quickly
            // as possible and aborts all i/o requests.
            //

            if(commonExtension->CurrentPnpState == IRP_MN_START_DEVICE) {
                SpTerminateAdapter(adapter);
            }
            
            //
            // Release the remove lock and wait for any in-flight requests to
            // complete.
            //

            SpReleaseRemoveLock(DeviceObject, Irp);
            SpWaitForRemoveLock(DeviceObject, DeviceObject);

            //
            // Go do the surprise remove portion of removing the adapter.
            //

            ScsiPortRemoveAdapter(DeviceObject, TRUE);

            //
            // Save the new state of this device.
            //

            commonExtension->PreviousPnpState = commonExtension->CurrentPnpState;
            commonExtension->CurrentPnpState = IRP_MN_SURPRISE_REMOVAL;

            //
            // Since we have already released the adapter remove lock, we
            // the request here instead of doing it at the bottom of the
            // function.
            //

            IoCopyCurrentIrpStackLocationToNext(Irp);
            return IoCallDriver(commonExtension->LowerDeviceObject, Irp);
        }

        case IRP_MN_REMOVE_DEVICE: 

            //
            // Asked to remove the adapter.  We'll ask the port driver to
            // stop it's adapter and release it's resources.  We can
            // detach and delete our device object as the lower driver
            // completes the remove request.
            //

            ASSERT(isRemoved != REMOVE_COMPLETE);

            //
            // If the device has been started then make sure we've got the
            // necessary code to disable it.  If it isn't currently started
            // then either it's got the code we need or it's never been
            // started - in either case we can just tear it down.
            //

            if((adapter->IsPnp == FALSE) ||
               ((commonExtension->CurrentPnpState == IRP_MN_START_DEVICE) &&
                (!SpIsAdapterControlTypeSupported(adapter,
                                                  ScsiStopAdapter)))) {

                //
                // the miniport needs to be stopped but we cannot do it.
                // Fail the request.
                //

                status = STATUS_UNSUCCESSFUL;
                sendDown = FALSE;
                break;
            }

            //
            // Clear the interface if it exists.
            //

            if(adapter->InterfaceName.Buffer != NULL) {
                IoSetDeviceInterfaceState(
                    &(adapter->InterfaceName),
                    FALSE);
                RtlFreeUnicodeString(&(adapter->InterfaceName));
                RtlInitUnicodeString(&(adapter->InterfaceName), NULL);
            }

            SpReleaseRemoveLock(DeviceObject, Irp);
            ScsiPortRemoveAdapter(DeviceObject, FALSE);

            //
            // The adapter's been removed.  Set the new state now.
            //

            commonExtension->CurrentPnpState = IRP_MN_REMOVE_DEVICE;
            commonExtension->PreviousPnpState = 0xff;

            //
            // Forward the request down and wait for it to complete.
            //

            status = SpSendIrpSynchronous(
                         commonExtension->LowerDeviceObject, 
                         Irp);

            //
            // Indicate the the adapter is fully removed.
            //

            commonExtension->IsRemoved = REMOVE_COMPLETE;

            //
            // Complete the IRP.
            //

            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            //
            // Detach and delete the FDO.
            //

            IoDetachDevice(commonExtension->LowerDeviceObject);
            IoDeleteDevice(DeviceObject);

            return status;

        case IRP_MN_STOP_DEVICE: {

            sendDown = TRUE;

            ASSERT(adapter->IsPnp);
            ASSERT(adapter->HwAdapterControl != NULL);

            status = ScsiPortStopAdapter(DeviceObject, Irp);

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0L;

            if(!NT_SUCCESS(status)) {
                sendDown = FALSE;
            } else {
                commonExtension->PreviousPnpState = commonExtension->CurrentPnpState;
                commonExtension->CurrentPnpState = IRP_MN_STOP_DEVICE;
            }

            break;
        }

        case IRP_MN_QUERY_DEVICE_RELATIONS: {

            DEVICE_RELATION_TYPE type =
                irpStack->Parameters.QueryDeviceRelations.Type;

            DebugPrint((1, "ScsiPortFdoPnp - got "
                           "IRP_MJ_QUERY_DEVICE_RELATIONS\n"));
            DebugPrint((1, "\ttype is %d\n", type));

            if (type == BusRelations) {

                PSP_ENUMERATION_REQUEST request;

                request = InterlockedCompareExchangePointer(
                              &adapter->PnpEnumRequestPtr,
                              NULL,
                              &(adapter->PnpEnumerationRequest));

                if (request != NULL) {

                    RtlZeroMemory(request, sizeof(SP_ENUMERATION_REQUEST));

                    request->CompletionRoutine = SpQueryDeviceRelationsCompletion;
                    request->Context = Irp;
                    request->CompletionStatus = &(Irp->IoStatus.Status);

                    IoMarkIrpPending(Irp);

                    SpEnumerateAdapterAsynchronous(adapter, request, FALSE);
                    return STATUS_PENDING;

                } else {

                    ASSERT(FALSE && "Unexpected!! Concurrent QDR requests");
                    Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                    Irp->IoStatus.Information = 0L;
                    sendDown = FALSE;

                }
            }

            break;
        }

        case IRP_MN_DEVICE_USAGE_NOTIFICATION: 

            //
            // Send the irp down to the device below us.
            // Since there's a remove lock outstanding on the PDO we can release
            // the lock on the FDO before sending this down.
            //

            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_ID: {

            PWCHAR newIdList;

            //
            // We add the id GEN_SCSIADAPTER to the compatible ID's for any
            // adapters controlled by scsiport.
            //

            DebugPrint((2, "ScsiPortFdoPnp: got IRP_MN_QUERY_ID\n"));

            if(irpStack->Parameters.QueryId.IdType != BusQueryCompatibleIDs) {
                sendDown = TRUE;
                break;
            }

            status = SpSendIrpSynchronous(commonExtension->LowerDeviceObject,
                                          Irp);

            newIdList = ScsiPortAddGenericControllerId(
                            DeviceObject->DriverObject,
                            (PWCHAR) (Irp->IoStatus.Information));

            if(newIdList == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                status = STATUS_SUCCESS;
                if(Irp->IoStatus.Information != 0L) {
                    ExFreePool((PVOID) Irp->IoStatus.Information);
                }
                Irp->IoStatus.Information = (ULONG_PTR) newIdList;
            }

            sendDown = FALSE;
            break;
        }

        default: {

            PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);

            DebugPrint((1, "ScsiPortFdoPnp: Unimplemented PNP/POWER minor "
                           "code %d\n", irpStack->MinorFunction));

            break;
        }
    }

    if (sendDown) {

        IoCopyCurrentIrpStackLocationToNext(Irp);
        SpReleaseRemoveLock(DeviceObject, Irp);
        status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

    } else {

        SpReleaseRemoveLock(DeviceObject, Irp);
        Irp->IoStatus.Status = status;
        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
    }

    return status;
}

NTSTATUS
ScsiPortStartAdapter(
    IN PDEVICE_OBJECT Adapter
    )

/*++

Routine Descripion:

    This routine will start an adapter.

    It is illegal to start the device if it has already been started.

Arguments:

    Adapter - a pointer to the functional device object (adapter) being started

Return Value:

    STATUS_SUCCESS if the device was properly started and enumeration was
                   attempted - or if the device had previously been started.

    error value indicating the cause of the failure otherwise

--*/

{
    PSCSIPORT_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(Adapter->DriverObject,
                                                     ScsiPortInitialize);

    PADAPTER_EXTENSION adapterExtension = Adapter->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = Adapter->DeviceExtension;

    UCHAR pathId;

    PAGED_CODE();

    ASSERT(driverExtension != NULL);
    ASSERT_FDO(Adapter);

    ASSERT(commonExtension->CurrentPnpState != IRP_MN_START_DEVICE);
    ASSERT(commonExtension->IsInitialized);

    ASSERT(((Adapter->Flags & DO_DEVICE_INITIALIZING) == 0));

    DebugPrint((1, "ScsiPortStartAdapter - starting adapter %#p\n", Adapter));

    //
    // Start timer. Request timeout counters
    // in the logical units have already been
    // initialized.
    //

    adapterExtension->TickCount = 0;
    IoStartTimer(Adapter);

    //
    // Initialize WMI support.
    //
    
    if (adapterExtension->CommonExtension.WmiInitialized == FALSE) {

        //
        // Build the SCSIPORT WMI registration information buffer for this FDO.
        //

        SpWmiInitializeSpRegInfo(Adapter);

        //
        // Register this device object only if the miniport supports WMI and/or
        // SCSIPORT will support certain WMI GUIDs on behalf of the miniport.
        //
        
        if (adapterExtension->CommonExtension.WmiScsiPortRegInfoBuf != NULL) {
           
           //
           // Register this functional device object as a WMI data provider,
           // instructing WMI that it is ready to receive WMI IRPs.
           //
            
            DebugPrint((1, "ScsiPortStartAdapter: REGISTER FDO:%p\n", Adapter));
            IoWMIRegistrationControl(Adapter, WMIREG_ACTION_REGISTER);
            adapterExtension->CommonExtension.WmiInitialized = TRUE;
        }

        //
        // Allocate several WMI_MINIPORT_REQUEST_ITEM blocks to satisfy a
        // potential onslaught of WMIEvent notifications by the miniport.
        //
        
        if (adapterExtension->CommonExtension.WmiMiniPortSupport) {
            
            //
            // Currently, we only allocate two per new adapter (FDO).
            //
            
            SpWmiInitializeFreeRequestList(Adapter, 2);
        }
    }

    //
    // Create a well known name for this device object by making a symbolic
    // link to the PDO.  Even if this fails, the start should still succeed.
    //

    if(adapterExtension->PortNumber == -1) {

        NTSTATUS status;

        UNICODE_STRING unicodePdoName;

        ULONG number;

        UNICODE_STRING interfaceName;

        RtlInitUnicodeString(&unicodePdoName, adapterExtension->DeviceName);

        //
        // Start at zero and keep going through all the possible numbers
        // until we find a hole.  This is an unfortunate requirement for
        // legacy support since most old class drivers will give up if
        // they find a hole in the scsiport numbers.
        //

        number = 0;

        do {

            WCHAR wideLinkName[64];
            UNICODE_STRING unicodeLinkName;

            //
            // Create the well known name string first.
            //

            swprintf(wideLinkName, L"\\Device\\ScsiPort%d", number);

            RtlInitUnicodeString(&unicodeLinkName, wideLinkName);

            status = IoCreateSymbolicLink(&unicodeLinkName, &unicodePdoName);

            if(NT_SUCCESS(status)) {

                //
                // Found a spot - mark this one as named so we don't go
                // through this trouble again and save the port number
                //

                adapterExtension->PortNumber = number;

                //
                // Create the dos port driver name.  If there's a collision
                // then just forget it.
                //

                swprintf(wideLinkName, L"\\DosDevices\\Scsi%d:", number);
                RtlInitUnicodeString(&unicodeLinkName, wideLinkName);
                IoCreateSymbolicLink(&unicodeLinkName, &unicodePdoName);
            } else {
                number++;
            }
        } while (status == STATUS_OBJECT_NAME_COLLISION);

        //
        // Increment the count of scsiport device
        //

        IoGetConfigurationInformation()->ScsiPortCount++;

        //
        // Create a device map entry for this adapter.
        //

        SpBuildDeviceMapEntry(commonExtension);

        //
        // Register our device interface.
        //

        status = IoRegisterDeviceInterface(adapterExtension->LowerPdo,
                                           &StoragePortClassGuid,
                                           NULL,
                                           &interfaceName);

        if(NT_SUCCESS(status)) {

            adapterExtension->InterfaceName = interfaceName;

            status = IoSetDeviceInterfaceState(&interfaceName, TRUE);

            if(!NT_SUCCESS(status)) {
                RtlFreeUnicodeString(&interfaceName);
                RtlInitUnicodeString(&(adapterExtension->InterfaceName), NULL);
            }
        }
    }

    //
    // Set the force next bus scan bit.
    //
    adapterExtension->ForceNextBusScan = TRUE;

    return STATUS_SUCCESS;
}


NTSTATUS
ScsiPortGetDeviceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in a device id string for
    the specified Pdo.  This string is generated from the bus type (scsi) and
    the type of the device.

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION physicalExtension = Pdo->DeviceExtension;
    PINQUIRYDATA inquiryData = &(physicalExtension->InquiryData);

    UCHAR buffer[256];
    PUCHAR rawIdString = buffer;
    ANSI_STRING ansiIdString;

    ULONG whichString;

    PAGED_CODE();

    ASSERT(UnicodeString != NULL);

    RtlZeroMemory(buffer, sizeof(buffer));

    sprintf(rawIdString,
            "SCSI\\%s",
            SpGetDeviceTypeInfo(inquiryData->DeviceType)->DeviceTypeString);

    rawIdString += strlen(rawIdString);

    ASSERT(*rawIdString == '\0');

    for(whichString = 0; whichString < 3; whichString++) {

        PUCHAR headerString;
        PUCHAR sourceString;
        ULONG sourceStringLength;

        ULONG i;

        switch(whichString) {

            //
            // Vendor Id
            //
            case 0: {
                sourceString = inquiryData->VendorId;
                sourceStringLength = sizeof(inquiryData->VendorId);
                headerString = "Ven";
                break;
            }

            //
            // Product Id
            //
            case 1: {
                sourceString = inquiryData->ProductId;
                sourceStringLength = sizeof(inquiryData->ProductId);
                headerString = "Prod";
                break;
            }

            //
            // Product Revision Level
            //
            case 2: {
                sourceString = inquiryData->ProductRevisionLevel;
                sourceStringLength = sizeof(inquiryData->ProductRevisionLevel);
                headerString = "Rev";
                break;
            }
        }

        //
        // Start at the end of the source string and back up until we find a
        // non-space, non-null character.
        //

        for(; sourceStringLength > 0; sourceStringLength--) {

            if((sourceString[sourceStringLength - 1] != ' ') &&
               (sourceString[sourceStringLength - 1] != '\0')) {
                break;
            }
        }

        //
        // Throw the header string into the block
        //

        sprintf(rawIdString, "&%s_", headerString);
        rawIdString += strlen(headerString) + 2;

        //
        // Spew the string into the device id
        //

        for(i = 0; i < sourceStringLength; i++) {
            *rawIdString = (sourceString[i] != ' ') ? (sourceString[i]) :
                                                      ('_');
            rawIdString++;
        }
        ASSERT(*rawIdString == '\0');
    }

    RtlInitAnsiString(&ansiIdString, buffer);

    DebugPrint((1, "DeviceId for logical unit %#p is %Z\n",
                Pdo, &ansiIdString));

    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);
}


NTSTATUS
ScsiPortGetInstanceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in an instance id string for
    the specified Pdo.  This string will be generated either from the device
    type + serial number of the device (if it has a serial number) or from
    the address of the device.

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    PLOGICAL_UNIT_EXTENSION physicalExtension = Pdo->DeviceExtension;

    PDRIVER_OBJECT driverObject = Pdo->DriverObject;
    PSCSIPORT_DEVICE_TYPE deviceTypeInfo;

    UCHAR idStringBuffer[64];
    ANSI_STRING ansiIdString;

    PAGED_CODE();

    ASSERT(UnicodeString != NULL);

    //
    // can't use serial number even if it exists since a device which is 
    // multiply connected to the same bus (dual-ported device) will have 
    // the same serial number at each connection and would confuse the PNP.
    //

    sprintf(idStringBuffer,
            "%x%x%x",
            physicalExtension->PathId,
            physicalExtension->TargetId,
            physicalExtension->Lun
            );

    RtlInitAnsiString(&ansiIdString, idStringBuffer);

    return RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);
}


NTSTATUS
ScsiPortGetCompatibleIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in a compatible id multi
    string for the specified Pdo.  This string is generated using the bus and
    device types for the device

Arguments:

    InquiryData - the inquiry data to generate compatible ids from.

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    UCHAR s[sizeof("SCSI\\DEVICE_TYPE_GOES_HERE")];
    PSTR stringBuffer[] = {
        s,
        "SCSI\\RAW",
        NULL};

    //
    // Fill in the scsi specific string
    //

    sprintf(stringBuffer[0],
            "SCSI\\%s",
            SpGetDeviceTypeInfo(InquiryData->DeviceType)->DeviceTypeString);

    //
    // Set up the first id string
    //

    return ScsiPortStringArrayToMultiString(
        DriverObject, 
        UnicodeString, 
        stringBuffer);
}

#define MPIO_DEVICE_LIST L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\MPDEV"


NTSTATUS
ScsiPortDetermineGenId(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUCHAR GenericId
    )
/*++

Routine Description:

    This routine will return the correct Compatible ID for the device in the caller
    supplied 'CompatibleId'. 
    The value will either be a GenXXX or MPIODisk, depending upon results from routines
    exported by portlib.lib

Arguments:

    DriverObject - The port-driver's DriverObject.
    InquiryData - The inquiry data of the device for which a compatID is being built.
    GenericId - Storage for the NULL-terminated buffer that will contain the correct ID.

Returns:

    SUCCESS or some error status from the library routines - (INSUFFICIENT_RESOURCES or some
    registry access error).

--*/
{

    PSCSIPORT_DEVICE_TYPE devTypeInfo;
    PSCSIPORT_DRIVER_EXTENSION driverExtension;
    UNICODE_STRING mpioRegistryPath;
    UCHAR vendorId[9];
    UCHAR productId[17];
    UCHAR genericId[40];
    BOOLEAN mpio = FALSE;
    NTSTATUS status = STATUS_SUCCESS; 

    PAGED_CODE();

    //
    // Init compatibleId, as it will always contain something.
    //
    RtlZeroMemory(genericId, 40);

    //
    // Get the type info for this device.
    // 
    devTypeInfo = SpGetDeviceTypeInfo(InquiryData->DeviceType);

    //
    // Default to the GenXXX of the device. If it's not a disk, errors occur
    // in this routine, or it's a non-mpio supported disk, then this value 
    // will be returned.
    //
    RtlCopyMemory(genericId, 
                  devTypeInfo->GenericTypeString, 
                  strlen(devTypeInfo->GenericTypeString));

    //
    // Check whether this is a disk or not. If not, the generic id
    // built earlier will be used.
    // 
    if (InquiryData->DeviceType == DIRECT_ACCESS_DEVICE) {

        NTSTATUS status2;

        //
        // Get the driverObject extension. This contains storage for the
        // supported device list.
        // 
        driverExtension = IoGetDriverObjectExtension(
                              DriverObject, 
                              ScsiPortInitialize);
        ASSERT(driverExtension != NULL);

        //
        // Determine whether this contains the list, or is uninitialised.
        // 
        if (driverExtension->MPIOSupportedDeviceList.Buffer == NULL) {

            //
            // Build the registry path string.
            // 
            RtlInitUnicodeString(&mpioRegistryPath, MPIO_DEVICE_LIST);

            //
            // Call into the port-driver library to get the list.
            // Any failures here will be dealt with below.
            // 
            status2 = PortGetMPIODeviceList(
                          &mpioRegistryPath,
                          &driverExtension->MPIOSupportedDeviceList);
        } else {

            //
            // Buffer is there, so load up 'success'.
            //
            status2 = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(status2)) {

            //
            // Get NULL terminated copies of Vendor and Product ID from the
            // passed-in inquiry data.
            //
            RtlZeroMemory(vendorId, 9);
            RtlZeroMemory(productId, 17);
            RtlCopyMemory(vendorId, InquiryData->VendorId, 8);
            RtlCopyMemory(productId, InquiryData->ProductId, 16);
    
            //
            // Call into the port-driver library to determine whether this 
            // device is supported under multipath.
            // 
            mpio = PortIsDeviceMPIOSupported(
                       &driverExtension->MPIOSupportedDeviceList,
                       vendorId,
                       productId);
            
            if (mpio) {

                //
                // Build MPIODisk instead of GenDisk. Mpdev.sys loads against 
                // this.
                //
                RtlCopyMemory(genericId, 
                              "MPIODisk", 
                              8);
            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Copy the built ID into the caller's buffer.
        //
        RtlCopyMemory(GenericId,
                      genericId,
                      strlen(genericId));
    }

    return status;
}    
            
NTSTATUS
ScsiPortGetHardwareIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine will allocate space for and fill in a hardware id multi
    string for the specified Pdo.  This string is generated using the device
    type and the inquiry data.

Arguments:

    InquiryData - the inquiry data to be converted into id strings.

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

#define NUMBER_HARDWARE_STRINGS 6

{
    PSCSIPORT_DEVICE_TYPE devTypeInfo =
        SpGetDeviceTypeInfo(InquiryData->DeviceType);

    ULONG i;

    PSTR strings[NUMBER_HARDWARE_STRINGS + 1];
    UCHAR scratch[64];
    UCHAR genericId[40];
    NTSTATUS status;
    SIZE_T len;

    
    PAGED_CODE();

    //
    // Zero out the string buffer
    //

    RtlZeroMemory(strings, sizeof(strings));
    RtlZeroMemory(genericId, 40);

    //
    // Build the compatible ID for this device.
    // 
    status = ScsiPortDetermineGenId(DriverObject,
                                    InquiryData,
                                    genericId);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    try {

        for(i = 0; i < NUMBER_HARDWARE_STRINGS; i++) {

            RtlZeroMemory(scratch, sizeof(scratch));

            //
            // Build each of the hardware id's
            //

            switch(i) {

                //
                // Bus + Dev Type + Vendor + Product + Revision
                //

                case 0: {

                    sprintf(scratch, "SCSI\\%s", devTypeInfo->DeviceTypeString);

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductId,
                              16,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductRevisionLevel,
                              4,
                              '_');
                    break;
                }

                //
                // bus + device + vendor + product
                //

                case 1: {

                    sprintf(scratch, "SCSI\\%s", devTypeInfo->DeviceTypeString);

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductId,
                              16,
                              '_');
                    break;
                }

                //
                // bus + device + vendor
                //

                case 2: {

                    sprintf(scratch, "SCSI\\%s", devTypeInfo->DeviceTypeString);

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    break;
                }

                //
                // bus \ vendor + product + revision[0]
                //

                case 3: {
                    sprintf(scratch, "SCSI\\");

                    //
                    // Fall through to the next set.
                    //
                }

                //
                // vendor + product + revision[0] (win9x)
                //

                case 4: {

                    CopyField(scratch + strlen(scratch),
                              InquiryData->VendorId,
                              8,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductId,
                              16,
                              '_');
                    CopyField(scratch + strlen(scratch),
                              InquiryData->ProductRevisionLevel,
                              1,
                              '_');

                    break;
                }

                case 5: {

                    //
                    // Copy over the previously built generic id.
                    // 
                    RtlCopyMemory(scratch, 
                                  genericId, 
                                  strlen(genericId));
                    break;
                }

                default: {
                    ASSERT(FALSE);
                    break;
                }
            }

            len = strlen(scratch);
            if(len != 0) {
                strings[i] =
                    SpAllocatePool(PagedPool,
                                   strlen(scratch) + sizeof(UCHAR),
                                   SCSIPORT_TAG_PNP_ID,
                                   DriverObject);

                if(strings[i] == NULL) {
                    status =  STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }

                RtlCopyMemory(strings[i], scratch, len+1);

            } else {

                break;
            }
        }

        status = ScsiPortStringArrayToMultiString(DriverObject,
                                                  UnicodeString,
                                                  strings);
        leave;

    } finally {

        for(i = 0; i < NUMBER_HARDWARE_STRINGS; i++) {

            if(strings[i]) {
                ExFreePool(strings[i]);
            }
        }
    }

    return status;
}

#undef NUMBER_HARDWARE_STRINGS

VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    )

/*++

Routine Description:

    This routine will copy Count string bytes from Source to Destination.  If
    it finds a nul byte in the Source it will translate that and any subsequent
    bytes into Change.  It will also replace spaces with the specified character.

Arguments:

    Destination - the location to copy bytes

    Source - the location to copy bytes from

    Count - the number of bytes to be copied

Return Value:

    none

--*/

{
    ULONG i = 0;
    BOOLEAN pastEnd = FALSE;

    PAGED_CODE();

    for(i = 0; i < Count; i++) {

        if(!pastEnd) {

            if(Source[i] == 0) {

                pastEnd = TRUE;

                Destination[i] = Change;

            } else if(Source[i] == ' ') {

                Destination[i] = Change;

            } else {

                Destination[i] = Source[i];

            }
        } else {
            Destination[i] = Change;
        }
    }
    return;
}


NTSTATUS
ScsiPortInitPnpAdapter(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will find and (if found) initialize a specific adapter.  The
    adapter is specified by the ResourceList passed in.

    This routine will initialize a port configuration structure using the
    information provided in the resource list and call the miniport's find
    adapter routine to locate the adapter.  If that completes successfully, the
    miniport's initialize routine will be called.  This will connect the
    interrupts and initialize the timers and DPCs as well as allocating
    common buffers and request data structures.

Arguments:

    Fdo - the device object for the adapter being initialized

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapter = Fdo->DeviceExtension;

    PSCSIPORT_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(Fdo->DriverObject,
                                                     ScsiPortInitialize);

    INTERFACE_TYPE interfaceType;
    ULONG resultLength;

    PHW_INITIALIZATION_DATA hwInitializationData = NULL;

    CONFIGURATION_CONTEXT configurationContext;

    PPORT_CONFIGURATION_INFORMATION configInfo = NULL;

    BOOLEAN callAgain;

    OBJECT_ATTRIBUTES objectAttributes;

    ULONG uniqueId;

    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG hwDeviceExtensionSize;

    PUNICODE_STRING registryPath = &(driverExtension->RegistryPath);

    NTSTATUS status;

    PAGED_CODE();

    //
    // Find the init data for this interface type
    //

    interfaceType = SpGetPdoInterfaceType(adapter->LowerPdo);

    hwInitializationData = SpFindInitData(driverExtension, interfaceType);

    if(hwInitializationData == NULL) {

        //
        // Hmmm.  The miniport never reported this adapter type.  We can't
        // start the device since we don't know what the correct entry points
        // are.  Pretend it doesn't exist
        //

        return STATUS_NO_SUCH_DEVICE;
    }

    hwDeviceExtensionSize = hwInitializationData->DeviceExtensionSize +
                            sizeof(HW_DEVICE_EXTENSION);

    RtlZeroMemory(&configurationContext, sizeof(configurationContext));

    if(hwInitializationData->NumberOfAccessRanges != 0) {

        configurationContext.AccessRanges =
            SpAllocatePool(PagedPool,
                           (hwInitializationData->NumberOfAccessRanges *
                            sizeof(ACCESS_RANGE)),
                           SCSIPORT_TAG_ACCESS_RANGE,
                           Fdo->DriverObject);

        if(configurationContext.AccessRanges == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    try {

        ULONG portConfigSize;

        //
        // Allocate the HwDeviceExtension first - it's easier to deallocate :)
        //

        hwDeviceExtension = SpAllocatePool(NonPagedPool,
                                           hwDeviceExtensionSize,
                                           SCSIPORT_TAG_DEV_EXT,
                                           Fdo->DriverObject);


        if(hwDeviceExtension == NULL) {
            DebugPrint((1, "ScsiPortInitialize: Could not allocate "
                           "HwDeviceExtension\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            uniqueId = __LINE__;
            leave;
        }

        RtlZeroMemory(hwDeviceExtension, hwDeviceExtensionSize);

        //
        // Setup device extension pointers
        //

        SpInitializeAdapterExtension(adapter,
                                     hwInitializationData,
                                     hwDeviceExtension);

        //
        // initialize the miniport config info buffer
        //

        status = SpInitializeConfiguration(
                    adapter,
                    registryPath,
                    hwInitializationData,
                    &configurationContext);

        if(!NT_SUCCESS(status)) {

            uniqueId = __LINE__;
            leave;
        }

        //
        // Allocate a config-info structure and access ranges for the
        // miniport drivers to use
        //

        portConfigSize = sizeof(PORT_CONFIGURATION_INFORMATION);
        portConfigSize += hwInitializationData->NumberOfAccessRanges *
                          sizeof(ACCESS_RANGE);
        portConfigSize += 7;
        portConfigSize &= ~7;

        configInfo = SpAllocatePool(NonPagedPool,
                                    portConfigSize,
                                    SCSIPORT_TAG_PORT_CONFIG,
                                    Fdo->DriverObject);

        if(configInfo == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            uniqueId = __LINE__;
            leave;
        }

        adapter->PortConfig = configInfo;

        //
        // Copy the current structure to the writable copy
        //

        RtlCopyMemory(configInfo,
                      &configurationContext.PortConfig,
                      sizeof(PORT_CONFIGURATION_INFORMATION));

        //
        // Copy the SrbExtensionSize from device extension to ConfigInfo.
        // A check will be made later to determine if the miniport updated
        // this value
        //

        configInfo->SrbExtensionSize = adapter->SrbExtensionSize;
        configInfo->SpecificLuExtensionSize = adapter->HwLogicalUnitExtensionSize;

        //
        // initialize the access range array
        //

        if(hwInitializationData->NumberOfAccessRanges != 0) {

            configInfo->AccessRanges = (PVOID) (configInfo + 1);

            //
            // Quadword align this
            //

            (ULONG_PTR) (configInfo->AccessRanges) += 7;
            (ULONG_PTR) (configInfo->AccessRanges) &= ~7;

            RtlCopyMemory(configInfo->AccessRanges,
                          configurationContext.AccessRanges,
                          (hwInitializationData->NumberOfAccessRanges *
                           sizeof(ACCESS_RANGE)));
        }

        //
        // Set the adapter interface type.
        //

        configInfo->AdapterInterfaceType = interfaceType;

        //
        // Since we've been handed resources we need to build a config info
        // structure before we can call the find adapter routine
        //

        SpBuildConfiguration(adapter,
                             hwInitializationData,
                             configInfo);

        SpGetSlotNumber(Fdo, configInfo, adapter->AllocatedResources);

        //
        // Get the miniport configuration inofmraiton
        //

        status = SpCallHwFindAdapter(Fdo,
                                     hwInitializationData,
                                     NULL,
                                     &configurationContext,
                                     configInfo,
                                     &callAgain);

        if(status == STATUS_DEVICE_DOES_NOT_EXIST) {

            adapter->PortConfig = NULL;
            ExFreePool(configInfo);

        } else if(NT_SUCCESS(status)) {

            status = SpAllocateAdapterResources(Fdo);

            if(NT_SUCCESS(status)) {

                PCOMMON_EXTENSION commonExtension = Fdo->DeviceExtension;
                BOOLEAN stopped;

                //
                // If the device's previous state is IRP_MN_STOP_DEVICE then
                // it should have a disable count of 1.  Clear the disabled
                // state.
                //

                stopped =
                    ((commonExtension->CurrentPnpState == IRP_MN_STOP_DEVICE) ?
                     TRUE :
                     FALSE);

                if(stopped) {

                    ASSERT(adapter->CommonExtension.PreviousPnpState == IRP_MN_START_DEVICE);
                    ASSERT(adapter->DisableCount == 1);

                    adapter->DisableCount = 0;
                    CLEAR_FLAG(adapter->InterruptData.InterruptFlags,
                               PD_DISABLE_INTERRUPTS);
                }

                status = SpCallHwInitialize(Fdo);

                if(stopped) {

                    KIRQL oldIrql;
                    PVOID sectionHandle;

                    //
                    // Restart i/o processing.
                    //

                    sectionHandle =
                        MmLockPagableCodeSection(ScsiPortInitPnpAdapter);

                    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
                    IoStartNextPacket(Fdo, FALSE);
                    KeLowerIrql(oldIrql);
                    MmUnlockPagableImageSection(sectionHandle);
                }
            }

        }

    } finally {

        if(!NT_SUCCESS(status)) {

            PIO_ERROR_LOG_PACKET errorLogEntry;

            //
            // An error occured - log it.
            //

            errorLogEntry = (PIO_ERROR_LOG_PACKET)
                                IoAllocateErrorLogEntry(
                                    Fdo,
                                    sizeof(IO_ERROR_LOG_PACKET));

            if(errorLogEntry != NULL) {
                errorLogEntry->ErrorCode = IO_ERR_DRIVER_ERROR;
                errorLogEntry->UniqueErrorValue = uniqueId;
                errorLogEntry->FinalStatus = status;
                errorLogEntry->DumpDataSize = 0;
                IoWriteErrorLogEntry(errorLogEntry);
            }

            //
            // Clean up the last device object which is not used.
            //

            SpDestroyAdapter(adapter, FALSE);

            if (configurationContext.AccessRanges != NULL) {
                ExFreePool(configurationContext.AccessRanges);
            }

            if (configurationContext.Parameter != NULL) {
                ExFreePool(configurationContext.Parameter);
            }

        } else {

            //
            // Determine which adapter control functions this miniport will
            // support for the adapter.
            //

            SpGetSupportedAdapterControlFunctions(adapter);
        }
    }

    return status;
}


PHW_INITIALIZATION_DATA
SpFindInitData(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN INTERFACE_TYPE InterfaceType
    )

/*++

Routine Description:

    This routine will search the list of chained init structures looking for
    the first one that matches the interface type in the resource list.

Arguments:

    DriverExtension - The driver extension to be searched

    ResourceList - this resource list describes the (interface) type of the
                   adapter we are looking for

Return Value:

    a pointer to the HW_INITIALIZATION_DATA structure for this interface type

    NULL if none was found

--*/

{
    PSP_INIT_CHAIN_ENTRY chainEntry = DriverExtension->InitChain;

    PAGED_CODE();

    while(chainEntry != NULL) {

        if(chainEntry->InitData.AdapterInterfaceType == InterfaceType) {
            return &(chainEntry->InitData);
        }
        chainEntry = chainEntry->NextEntry;
    }

    return NULL;
}


NTSTATUS
SpStartLowerDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine will forward the start request to the next lower device and
    block until it's completion.

Arguments:

    DeviceObject - the device to which the start request was issued.

    Irp - the start request

Return Value:

    status

--*/

{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PKEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    event = SpAllocatePool(NonPagedPool,
                           sizeof(KEVENT),
                           SCSIPORT_TAG_EVENT,
                           DeviceObject->DriverObject);

    if(event == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           SpSignalCompletion,
                           event,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

    if(status == STATUS_PENDING) {

        KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

        status = Irp->IoStatus.Status;
    }

    if(NT_SUCCESS(status)) {

        PIO_STACK_LOCATION irpStack;

        //
        // Now go and retrieve any interfaces we need from the lower device.
        //

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        irpStack = IoGetNextIrpStackLocation(Irp);

        irpStack->Parameters.QueryInterface.InterfaceType =
            (LPGUID) &GUID_BUS_INTERFACE_STANDARD;
        irpStack->Parameters.QueryInterface.Size =
            sizeof(BUS_INTERFACE_STANDARD);
        irpStack->Parameters.QueryInterface.Version = 1;
        irpStack->Parameters.QueryInterface.Interface =
            (PINTERFACE) &(adapter->LowerBusInterfaceStandard);

        irpStack->MajorFunction = IRP_MJ_PNP;
        irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

        KeResetEvent(event);

        IoSetCompletionRoutine(Irp,
                               SpSignalCompletion,
                               event,
                               TRUE,
                               TRUE,
                               TRUE);

        IoCallDriver(commonExtension->LowerDeviceObject, Irp);

        KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

        if(NT_SUCCESS(Irp->IoStatus.Status)) {
            adapter->LowerBusInterfaceStandardRetrieved = TRUE;
        } else {
            DebugPrint((1, "LowerBusInterfaceStandard request returned "
                           "%#08lx\n", Irp->IoStatus.Status));
            adapter->LowerBusInterfaceStandardRetrieved = FALSE;
        }

        Irp->IoStatus.Status = status;
    }

    ExFreePool(event);

    return status;
}


VOID
SpGetSlotNumber(
    IN PDEVICE_OBJECT Fdo,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN PCM_RESOURCE_LIST ResourceList
    )

/*++

Routine Description:

    This routine will open the registry key for the associated Pdo and try
    to retrieve the bus, slot and function numbers that will be stored there
    if this was a device we detected or one that the user has configured by
    hand.  These values will be stored in the ConfigInfo structure for the
    adapter.

    If this information does not exist then the values will be filled with
    zeros and the IsVirtualSlot flag will be set in the Fdo for use by other
    routines.

Arguments:

    Fdo - a pointer to the functional device object for this adapter

    ConfigInfo - the ConfigInfo structure to be changed

Return Value:

    None

--*/

{
    PADAPTER_EXTENSION adapter = Fdo->DeviceExtension;

    HANDLE instanceHandle = NULL;
    HANDLE parametersHandle = NULL;

    NTSTATUS status;

    PAGED_CODE();

    adapter->IsInVirtualSlot = FALSE;

    try {
        OBJECT_ATTRIBUTES objectAttributes;
        UNICODE_STRING unicodeKeyName;


        status = IoOpenDeviceRegistryKey(adapter->LowerPdo,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         KEY_READ,
                                         &instanceHandle);

        if(!NT_SUCCESS(status)) {
            leave;
        }

        RtlInitUnicodeString(&unicodeKeyName, L"Scsiport");
        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeKeyName,
            OBJ_CASE_INSENSITIVE,
            instanceHandle,
            NULL);

        status = ZwOpenKey(&parametersHandle,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {

            leave;

        } else {

            RTL_QUERY_REGISTRY_TABLE queryTable[3];
            ULONG busNumber;
            ULONG slotNumber;
            ULONG negativeOne = 0xffffffff;

            RtlZeroMemory(queryTable, sizeof(queryTable));

            queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
            queryTable[0].Name = L"SlotNumber";
            queryTable[0].EntryContext = &slotNumber;
            queryTable[0].DefaultType = REG_DWORD;
            queryTable[0].DefaultData = &negativeOne;
            queryTable[0].DefaultLength = sizeof(ULONG);

            queryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
            queryTable[1].Name = L"BusNumber";
            queryTable[1].EntryContext = &busNumber;
            queryTable[1].DefaultType = REG_DWORD;
            queryTable[1].DefaultData = &negativeOne;
            queryTable[1].DefaultLength = sizeof(ULONG);

            status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                            (PWSTR) parametersHandle,
                                            queryTable,
                                            NULL,
                                            NULL);

            if(!NT_SUCCESS(status)) {
                leave;
            }

            if((busNumber == negativeOne) || (slotNumber == negativeOne)) {

                ConfigInfo->SystemIoBusNumber = ResourceList->List[0].BusNumber;
                ConfigInfo->SlotNumber = 0;
                adapter->IsInVirtualSlot = TRUE;

            } else {

                ConfigInfo->SystemIoBusNumber = busNumber;
                ConfigInfo->SlotNumber = slotNumber;
                adapter->IsInVirtualSlot = FALSE;
            }

        }

   } finally {

       //
       // If an error occurred then we'll need to try virtualizing this
       // adapter
       //

       if(!NT_SUCCESS(status)) {

           //
           // Send ourself a query capabilities IRP so that we can retrieve
           // slot and function numbers from PCI.
           //

           status = SpQueryCapabilities(adapter);

           if(NT_SUCCESS(status)) {
               ConfigInfo->SystemIoBusNumber = ResourceList->List[0].BusNumber;
               ConfigInfo->SlotNumber = adapter->VirtualSlotNumber.u.AsULONG;
               adapter->IsInVirtualSlot = TRUE;
           }
       }

       if(instanceHandle != NULL) {
           ZwClose(instanceHandle);
       }

       if(parametersHandle != NULL) {
           ZwClose(parametersHandle);
       }
   }

   return;
}

PSCSIPORT_DEVICE_TYPE
SpGetDeviceTypeInfo(
    IN UCHAR DeviceType
    )
{
    PAGED_CODE();

    if(DeviceType >= NUM_DEVICE_TYPE_INFO_ENTRIES) {
        return &(DeviceTypeInfo[NUM_DEVICE_TYPE_INFO_ENTRIES - 1]);
    } else {
        return &(DeviceTypeInfo[DeviceType]);
    }
};


PWCHAR
ScsiPortAddGenericControllerId(
    IN PDRIVER_OBJECT DriverObject,
    IN PWCHAR IdList
    )

/*++

Routine Description:

    This routine will attempt to add the id GEN_SCSIADAPTER to the provided
    list of compatible id's.

Arguments:

    Pdo - a pointer to the physical device object being queried

    UnicodeString - a pointer to an already allocated unicode string structure.
                    This routine will allocate and fill in the buffer of this
                    structure

Returns:

    status

--*/

{
    ULONG stringLength = 0;

    ULONG i = 0;

    PWCHAR addedString = L"GEN_SCSIADAPTER";
    PWCHAR newList;
    PWCHAR p;

    PAGED_CODE();

    //
    // If strings were provided then count them to determine a length for the
    // new id list.
    //

    if(IdList != NULL) {

        i = 0;

        while((IdList[i] != UNICODE_NULL) || (IdList[i+1] != UNICODE_NULL)) {
            i++;
        }

        //
        // Compensate for the fact that we stopped counting just before the
        // first byte of the double-null.
        //

        i += 2;

        stringLength = i;
    }

    stringLength += wcslen(L"GEN_SCSIADAPTER");

    //
    // We'll need to add in yet another NULL to terminate the current ending
    // string.
    //

    stringLength += 2;

    //
    // Allocate a new string list to replace the existing one with.
    //

    newList = SpAllocatePool(PagedPool,
                             (stringLength * sizeof(WCHAR)),
                             SCSIPORT_TAG_PNP_ID,
                             DriverObject);

    if(newList == NULL) {
        return NULL;
    }

    RtlFillMemory(newList, (stringLength * sizeof(WCHAR)), '@');

    //
    // If we were provided with a string then copy it into the buffer we just
    // allocated.
    //

    if(ARGUMENT_PRESENT(IdList)) {

        i = 0;
        while((IdList[i] != UNICODE_NULL) || (IdList[i+1] != UNICODE_NULL)) {
            newList[i] = IdList[i];
            i++;
        }

        //
        // Terminate the string we just wrote.
        //

        newList[i] = UNICODE_NULL;

        p = &(newList[i+1]);
    } else {
        p = newList;
    }

    //
    // Copy the new id string into the buffer.
    //

    for(i = 0; addedString[i] != UNICODE_NULL; i++) {
        *p = addedString[i];
        p++;
    }

    //
    // Write two unicode nulls to the string to terminate it.
    //

    *p = UNICODE_NULL;
    p++;
    *p = UNICODE_NULL;

    //
    // Set up the first id string
    //

    return newList;
}


NTSTATUS
SpQueryCapabilities(
    IN PADAPTER_EXTENSION Adapter
    )
{
    DEVICE_CAPABILITIES capabilities;

    PIRP irp;
    PIO_STACK_LOCATION irpStack;

    KEVENT event;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the capabilities structure.
    //

    RtlZeroMemory(&capabilities, sizeof(DEVICE_CAPABILITIES));
    capabilities.Size = sizeof(DEVICE_CAPABILITIES);
    capabilities.Version = 1;
    capabilities.Address = capabilities.UINumber = (ULONG)-1;

    //
    // Initialize the event we're going to wait on.
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Allocate a new irp.
    //

    irp = SpAllocateIrp((CCHAR) (Adapter->DeviceObject->StackSize + 1), 
                        FALSE, 
                        Adapter->DeviceObject->DriverObject);

    if(irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_PNP;
    irpStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    irpStack->Parameters.DeviceCapabilities.Capabilities = &capabilities;

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    IoSetCompletionRoutine(irp,
                           SpSignalCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Send the irp to ourself ... just in case we ever start modifying
    // the contents of the capabilities in our PNP dispatch routine.
    //

    IoCallDriver(Adapter->DeviceObject, irp);

    KeWaitForSingleObject(&event,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    status = irp->IoStatus.Status;

    if(NT_SUCCESS(status)) {
        USHORT device;
        USHORT function;

        device = (USHORT) (capabilities.Address >> 0x10);
        function = (USHORT) (capabilities.Address & 0x0000ffff);

        Adapter->VirtualSlotNumber.u.bits.DeviceNumber = device;
        Adapter->VirtualSlotNumber.u.bits.FunctionNumber = function;
    } else {
        Adapter->VirtualSlotNumber.u.AsULONG = 0;
    }

    IoFreeIrp(irp);

    return status;
}


BOOLEAN
SpGetInterrupt(
    IN PCM_RESOURCE_LIST FullResourceList,
    OUT ULONG *Irql,
    OUT ULONG *Vector,
    OUT KAFFINITY *Affinity
    )

/*++

Routine Description:

    Given a full resource list returns the interrupt.

Arguments:

    FullResourceList - the resource list.
    Irql - returns the irql for the interrupt.
    Vector - returns the vector for the interrupt.
    Affinity - returns the affinity for the interrupt.

Return Value:

    TRUE if an interrupt is found.
    FALSE if none was found (in which case the output parameters are not valid.

--*/

{
    ULONG             rangeNumber;
    ULONG             index;

    PCM_FULL_RESOURCE_DESCRIPTOR resourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialData;

    PAGED_CODE();

    rangeNumber = 0;

    resourceList = FullResourceList->List;

    for (index = 0; index < resourceList->PartialResourceList.Count; index++) {
        partialData = &resourceList->PartialResourceList.PartialDescriptors[index];

        if(partialData->Type == CmResourceTypeInterrupt) {
            *Irql = partialData->u.Interrupt.Level;
            *Vector = partialData->u.Interrupt.Vector;
            *Affinity = partialData->u.Interrupt.Affinity;

            return TRUE;
        }
    }
    return FALSE;
}



VOID
SpQueryDeviceRelationsCompletion(
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN NTSTATUS Unused
    )
{
    PIRP irp = (PIRP) Request->Context;
    PDEVICE_RELATIONS deviceRelations;

    PDEVICE_OBJECT lowerDevice = Adapter->CommonExtension.LowerDeviceObject;

    NTSTATUS status;

    PAGED_CODE();

    ASSERT_FDO(Adapter->DeviceObject);

    //
    // Pnp is done in a system thread - we shouldn't get a user-mode APC to this
    // thread.
    //

    ASSERT(Unused != STATUS_USER_APC);

    //
    // Return the list of devices on the bus
    //

    status = SpExtractDeviceRelations(Adapter, BusRelations, &deviceRelations);

    if(NT_SUCCESS(status)) {
        ULONG i;

        DebugPrint((2, "SpQueryDeviceRelationsCompletion: Found %d devices "
                       "on adapter %#p\n",
                       deviceRelations->Count,
                       Adapter));

        for(i = 0; i < deviceRelations->Count; i++) {
            DebugPrint((2, "/t#%2d: device %#p\n",
                           i,
                           deviceRelations->Objects[i]));
        }
    }

    //
    // Put the pointer to the enumeration request object back.
    //

    Request = InterlockedCompareExchangePointer(
                  &Adapter->PnpEnumRequestPtr,
                  &(Adapter->PnpEnumerationRequest),
                  NULL);
    ASSERT(Request == NULL);


    //
    // Store the status and the return information in the IRP.
    //

    irp->IoStatus.Status = status;

    if(NT_SUCCESS(status)) {
        irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
    } else {
        irp->IoStatus.Information = (ULONG_PTR) NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\port.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    port.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a dll for the kernel.

Revision History:

--*/



#include "port.h"

#if DBG
static const char *__file__ = __FILE__;
#endif

#if SCSIDBG_ENABLED

ULONG ScsiDebug = 0;
ULONG ScsiPortCheckSrbDataHashTable = 1;
#endif

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'PscS')
#endif


//
// Routines providing service to hardware dependent driver.
//

PVOID
ScsiPortGetLogicalUnit(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )

/*++

Routine Description:

    Walk port driver's logical unit extension list searching
    for entry.

Arguments:

    HwDeviceExtension - The port driver's device extension follows
        the miniport's device extension and contains a pointer to
        the logical device extension list.

    PathId, TargetId and Lun - identify which logical unit on the
        SCSI buses.

Return Value:

    If entry found return miniport driver's logical unit extension.
    Else, return NULL.

--*/

{
    PADAPTER_EXTENSION deviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    DebugPrint((3, "ScsiPortGetLogicalUnit: TargetId %d\n",
        TargetId));

    //
    // Get pointer to port driver device extension.
    //

    deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    //
    // Get a pointer to the logical unit.
    //

    logicalUnit = GetLogicalUnitExtension(deviceExtension,
                                          PathId,
                                          TargetId,
                                          Lun,
                                          FALSE,
                                          FALSE);

    if(logicalUnit != NULL) {

        return logicalUnit->HwLogicalUnitExtension;
    }

    return NULL;

} // end ScsiPortGetLogicalUnit()

BOOLEAN SpLunIoLogActive = TRUE;


VOID
ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSRB_DATA               srbData;
    PSCSI_REQUEST_BLOCK     srb;
    UCHAR                   pathId;
    UCHAR                   targetId;
    UCHAR                   lun;
    va_list                 ap;

    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case NextRequest:

            //
            // Start next packet on adapter's queue.
            //

            deviceExtension->InterruptData.InterruptFlags |= PD_READY_FOR_NEXT_REQUEST;
            break;

        case RequestComplete:

            srb = va_arg(ap, PSCSI_REQUEST_BLOCK);

            ASSERT(srb->SrbStatus != SRB_STATUS_PENDING);

            ASSERT(srb->SrbStatus != SRB_STATUS_SUCCESS ||
                   srb->ScsiStatus == SCSISTAT_GOOD ||
                   srb->Function != SRB_FUNCTION_EXECUTE_SCSI);

            //
            // If this srb has already been completed then return, otherwise
            // clear the active flag.
            //

            if (srb->SrbFlags & SRB_FLAGS_IS_ACTIVE) {
                srb->SrbFlags &= ~SRB_FLAGS_IS_ACTIVE;
            } else {
                va_end(ap);
                return;
            }

            //
            // Treat abort completions as a special case.
            //

            if (srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

                ASSERT(FALSE);
                logicalUnit = GetLogicalUnitExtension(deviceExtension,
                                                      srb->PathId,
                                                      srb->TargetId,
                                                      srb->Lun,
                                                      FALSE,
                                                      FALSE);

                logicalUnit->CompletedAbort =
                    deviceExtension->InterruptData.CompletedAbort;

                deviceExtension->InterruptData.CompletedAbort = logicalUnit;

            } else {

                //
                // Validate the srb data.
                //

                srbData = srb->OriginalRequest;

#if DBG
                ASSERT_SRB_DATA(srbData);

                ASSERT(srbData->CurrentSrb == srb);

                ASSERT(srbData->CurrentSrb != NULL &&
                       srbData->CompletedRequests == NULL);

                if ((srb->SrbStatus == SRB_STATUS_SUCCESS) &&
                    (IS_READ(srb) || IS_WRITE(srb))) {
                    ASSERT(srb->DataTransferLength);
                }
#endif

                //
                // Append this request to the LUN's IO history log.
                //

                if (SpLunIoLogActive == TRUE &&
                    srb->Function == SRB_FUNCTION_EXECUTE_SCSI) {

                    PSP_LUN_IO_LOG ioLogEntry;
                    ULONG index;
                    PLOGICAL_UNIT_EXTENSION luExt = ((PSRB_DATA)(srb->OriginalRequest))->LogicalUnit;

                    index = luExt->IoLogIndex;
                    ioLogEntry = &luExt->IoLog[index];

                    ioLogEntry->TickCount = ((PSRB_DATA)(srb->OriginalRequest))->TickCount;
                    ioLogEntry->SrbStatus = srb->SrbStatus;
                    ioLogEntry->ScsiStatus = srb->ScsiStatus;
                    ioLogEntry->CdbLength = srb->CdbLength;
                    ioLogEntry->Tag = srb->QueueTag;
                    ioLogEntry->SenseDataLength = srb->SenseInfoBufferLength;
                    ioLogEntry->InternalStatus = srb->InternalStatus;
                    RtlMoveMemory(ioLogEntry->Cdb, srb->Cdb, srb->CdbLength);

                    if (ioLogEntry->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
                        RtlMoveMemory(ioLogEntry->SenseData,
                                      srb->SenseInfoBuffer,
                                      (srb->SenseInfoBufferLength <= 18) ?
                                      srb->SenseInfoBufferLength : 18);
                    }

                    index++;
                    if (index == 10) {
                        index = 0;
                    }
                    luExt->IoLogIndex = index;

                    if (luExt->IoLogEntries < 10) {
                        luExt->IoLogEntries++;
                    }
                }

                if (srb->SrbStatus == SRB_STATUS_BUSY) {
                    DebugPrint((0, "ScsiPortNotification: lun is busy (srb %p)\n", srb));
                }

                if(((srb->SrbStatus == SRB_STATUS_SUCCESS) ||
                    (srb->SrbStatus == SRB_STATUS_DATA_OVERRUN)) &&
                   (TEST_FLAG(srb->SrbFlags, SRB_FLAGS_UNSPECIFIED_DIRECTION))) {
                    ASSERT(srbData->OriginalDataTransferLength >=
                           srb->DataTransferLength);
                }

                srbData->CompletedRequests =
                    deviceExtension->InterruptData.CompletedRequests;
                deviceExtension->InterruptData.CompletedRequests = srbData;

                //
                // Cache away the last logical unit we touched in the miniport.
                // This is cleared when we come out of the miniport
                // synchronization but provides a shortcut for finding the
                // logical unit before going into the hash table.
                //

                deviceExtension->CachedLogicalUnit = srbData->LogicalUnit;
            }

            break;

        case ResetDetected:

            //
            // Notifiy the port driver that a reset has been reported.
            //

            deviceExtension->InterruptData.InterruptFlags |=
                PD_RESET_REPORTED | PD_RESET_HOLD;
            break;

        case NextLuRequest:

            //
            // The miniport driver is ready for the next request and
            // can accept a request for this logical unit.
            //

            pathId = va_arg(ap, UCHAR);
            targetId = va_arg(ap, UCHAR);
            lun = va_arg(ap, UCHAR);

            //
            // A next request is impiled by this notification so set the
            // ready for next reqeust flag.
            //

            deviceExtension->InterruptData.InterruptFlags |= PD_READY_FOR_NEXT_REQUEST;

            logicalUnit = deviceExtension->CachedLogicalUnit;

            if((logicalUnit == NULL) ||
               (logicalUnit->TargetId != targetId) ||
               (logicalUnit->PathId != pathId) ||
               (logicalUnit->Lun != lun)) {

                logicalUnit = GetLogicalUnitExtension(deviceExtension,
                                                      pathId,
                                                      targetId,
                                                      lun,
                                                      FALSE,
                                                      FALSE);
            }

            if (logicalUnit != NULL && logicalUnit->ReadyLogicalUnit != NULL) {

                //
                // Since our ReadyLogicalUnit link field is not NULL we must
                // have already been linked onto a ReadyLogicalUnit list.
                // There is nothing to do.
                //

                break;
            }

            //
            // Don't process this as request for the next logical unit, if
            // there is a untagged request for active for this logical unit.
            // The logical unit will be started when untagged request completes.
            //

            if (logicalUnit != NULL && logicalUnit->CurrentUntaggedRequest == NULL) {

                //
                // Add the logical unit to the chain of logical units that
                // another request maybe processed for.
                //

                logicalUnit->ReadyLogicalUnit =
                    deviceExtension->InterruptData.ReadyLogicalUnit;
                deviceExtension->InterruptData.ReadyLogicalUnit = logicalUnit;
            }

            break;

        case CallDisableInterrupts:

            ASSERT(deviceExtension->InterruptData.InterruptFlags &
                   PD_DISABLE_INTERRUPTS);

            //
            // The miniport wants us to call the specified routine
            // with interrupts disabled.  This is done after the current
            // HwRequestInterrutp routine completes. Indicate the call is
            // needed and save the routine to be called.
            //

            deviceExtension->Flags |= PD_DISABLE_CALL_REQUEST;

            if (SpVerifierActive(deviceExtension)) {
                deviceExtension->VerifierExtension->RealHwRequestInterrupt = 
                   va_arg(ap, PHW_INTERRUPT);
                deviceExtension->HwRequestInterrupt = SpHwRequestInterruptVrfy;
            } else {
                deviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);
            }

            break;

        case CallEnableInterrupts:

            //
            // The miniport wants us to call the specified routine
            // with interrupts enabled this is done from the DPC.
            // Disable calls to the interrupt routine, indicate the call is
            // needed and save the routine to be called.
            //

            deviceExtension->InterruptData.InterruptFlags |=
                PD_DISABLE_INTERRUPTS | PD_ENABLE_CALL_REQUEST;

            if (SpVerifierActive(deviceExtension)) {
                deviceExtension->VerifierExtension->RealHwRequestInterrupt = 
                   va_arg(ap, PHW_INTERRUPT);
                deviceExtension->HwRequestInterrupt = SpHwRequestInterruptVrfy;
            } else {
                deviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);
            }

            break;

        case RequestTimerCall:

            //
            // The driver wants to set the miniport timer.
            // Save the timer parameters.
            //

            deviceExtension->InterruptData.InterruptFlags |=
                PD_TIMER_CALL_REQUEST;
            deviceExtension->InterruptData.HwTimerRequest =
                va_arg(ap, PHW_INTERRUPT);
            deviceExtension->InterruptData.MiniportTimerValue =
                va_arg(ap, ULONG);
            break;

        case WMIEvent: {

            //
            // The miniport wishes to post a WMI event for the adapter
            // or a specified SCSI target.
            //

            PWMI_MINIPORT_REQUEST_ITEM lastMiniPortRequest;
            PWMI_MINIPORT_REQUEST_ITEM wmiMiniPortRequest;
            PWNODE_EVENT_ITEM          wnodeEventItem;
            PWNODE_EVENT_ITEM          wnodeEventItemCopy;

            wnodeEventItem     = va_arg(ap, PWNODE_EVENT_ITEM);
            pathId             = va_arg(ap, UCHAR);

            //
            // if pathID is 0xFF, that means that the WmiEevent is from the
            // adapter, no targetId or lun is neccesary
            //
            if (pathId != 0xFF) {
                targetId = va_arg(ap, UCHAR);
                lun      = va_arg(ap, UCHAR);
            }

            //
            // Validate the event first.  Then attempt to obtain a free
            // WMI_MINIPORT_REQUEST_ITEM structure so that we may store
            // this request and process it at DPC level later.  If none
            // are obtained or the event is bad, we ignore the request.
            //

            if ((wnodeEventItem == NULL) ||
                (wnodeEventItem->WnodeHeader.BufferSize >
                 WMI_MINIPORT_EVENT_ITEM_MAX_SIZE)) {

                va_end(ap);    //  size, no free WMI_MINIPORT_REQUEST_ITEMs left]
                return;
            }

            //
            // Remove the WMI_MINIPORT_REQUEST_ITEM from the free list.
            //
            wmiMiniPortRequest = SpWmiPopFreeRequestItem(deviceExtension);

            //
            // Log an error if a free request item could not be dequeued
            // (log only once in the lifetime of this adapter).
            //
            if (wmiMiniPortRequest == NULL) {

                if (!deviceExtension->WmiFreeMiniPortRequestsExhausted) {
                    deviceExtension->WmiFreeMiniPortRequestsExhausted = TRUE;

                    //
                    // If pathId is 0xFF that means that pathId and targetId
                    // will be not be defined
                    // 
                    if (pathId != 0xFF) {
                        ScsiPortLogError(HwDeviceExtension,
                                             NULL,
                                             pathId,
                                             targetId,
                                             lun,
                                             SP_LOST_WMI_MINIPORT_REQUEST,
                                             0);
                    } else {
                        ScsiPortLogError(HwDeviceExtension,
                                             NULL,
                                             pathId,
                                             0,
                                             0,
                                             SP_LOST_WMI_MINIPORT_REQUEST,
                                             0);
                    } // pathId != 0xFF
                }

                va_end(ap);
                return;
            }

            //
            // Save information pertaining to this WMI request for later
            // processing.
            //

            deviceExtension->InterruptData.InterruptFlags |= PD_WMI_REQUEST;

            wmiMiniPortRequest->TypeOfRequest = (UCHAR)WMIEvent;
            wmiMiniPortRequest->PathId        = pathId;

            //
            // If pathId was 0xFF, then there is no defined value for
            // targetId or lun
            //
            if (pathId != 0xFF) {
                wmiMiniPortRequest->TargetId      = targetId;
                wmiMiniPortRequest->Lun           = lun;
            }

            RtlCopyMemory(wmiMiniPortRequest->WnodeEventItem,
                          wnodeEventItem,
                          wnodeEventItem->WnodeHeader.BufferSize);

            //
            // Queue the new WMI_MINIPORT_REQUEST_ITEM to the end of list in the
            // interrupt data structure.
            //
            wmiMiniPortRequest->NextRequest = NULL;

            lastMiniPortRequest =
                deviceExtension->InterruptData.WmiMiniPortRequests;

            if (lastMiniPortRequest) {

                while (lastMiniPortRequest->NextRequest) {
                    lastMiniPortRequest = lastMiniPortRequest->NextRequest;
                }
                lastMiniPortRequest->NextRequest = wmiMiniPortRequest;

            } else {
                deviceExtension->InterruptData.WmiMiniPortRequests =
                    wmiMiniPortRequest;
            }

            break;
        }

        case WMIReregister: {
            //
            // The miniport wishes to re-register the GUIDs for the adapter or
            // a specified SCSI target.
            //

            PWMI_MINIPORT_REQUEST_ITEM lastMiniPortRequest;
            PWMI_MINIPORT_REQUEST_ITEM wmiMiniPortRequest;

            pathId             = va_arg(ap, UCHAR);

            //
            // if pathID is 0xFF, that means that we're re-registering the
            // adapter no targetId or lun is neccesary
            //
            if (pathId != 0xFF) {
                targetId = va_arg(ap, UCHAR);
                lun      = va_arg(ap, UCHAR);
            } 

            //
            // Attempt to obtain a free WMI_MINIPORT_REQUEST_ITEM structure
            // so that we may store this request and process it at DPC
            // level later. If none are obtained or the event is bad, we
            // ignore the request.
            //
            // Remove a WMI_MINPORT_REQUEST_ITEM from the free list.
            //
            wmiMiniPortRequest = SpWmiPopFreeRequestItem(deviceExtension);

            if (wmiMiniPortRequest == NULL) {

                //
                // Log an error if a free request item could not be dequeued
                // (log only once in the lifetime of this adapter).
                //
                if (!deviceExtension->WmiFreeMiniPortRequestsExhausted) {

                    deviceExtension->WmiFreeMiniPortRequestsExhausted = TRUE;

                    //
                    // If pathId is 0xFF that means that pathId and targetId
                    // will be not be defined
                    // 
                    if (pathId != 0xFF) {
                        ScsiPortLogError(HwDeviceExtension,
                                         NULL,
                                         pathId,
                                         targetId,
                                         lun,
                                         SP_LOST_WMI_MINIPORT_REQUEST,
                                         0);
                    } else {
                        ScsiPortLogError(HwDeviceExtension,
                                         NULL,
                                         pathId,
                                         0,
                                         0,
                                         SP_LOST_WMI_MINIPORT_REQUEST,
                                         0);
                    } // pathId != 0xFF
                 }

                va_end(ap);
                return;
            }

            //
            // Save information pertaining to this WMI request for later
            // processing.
            //

            deviceExtension->InterruptData.InterruptFlags |= PD_WMI_REQUEST;
            wmiMiniPortRequest->TypeOfRequest = (UCHAR)WMIReregister;
            wmiMiniPortRequest->PathId        = pathId;

            //
            // If pathId was 0xFF, then there is no defined value for
            // targetId or lun
            //
            if (pathId != 0xFF) {
                wmiMiniPortRequest->TargetId      = targetId;
                wmiMiniPortRequest->Lun           = lun;
            }

            //
            // Queue the new WMI_MINIPORT_REQUEST_ITEM to the end of list in the
            // interrupt data structure.
            //
            wmiMiniPortRequest->NextRequest = NULL;

            lastMiniPortRequest =
                deviceExtension->InterruptData.WmiMiniPortRequests;

            if (lastMiniPortRequest) {

                while (lastMiniPortRequest->NextRequest) {
                    lastMiniPortRequest = lastMiniPortRequest->NextRequest;
                }
                lastMiniPortRequest->NextRequest = wmiMiniPortRequest;

            } else {
                deviceExtension->InterruptData.WmiMiniPortRequests =
                    wmiMiniPortRequest;
            }

            break;
        }

        case BusChangeDetected: {

            SET_FLAG(deviceExtension->InterruptData.InterruptFlags,
                     PD_BUS_CHANGE_DETECTED);
            break;
        }

        default: {
             ASSERT(0);
             break;
        }
    }

    va_end(ap);

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

} // end ScsiPortNotification()


VOID
ScsiPortFlushDma(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine checks to see if the perivious IoMapTransfer has been done
    started.  If it has not, then the PD_MAP_TRANSER flag is cleared, and the
    routine returns; otherwise, this routine schedules a DPC which will call
    IoFlushAdapter buffers.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.


Return Value:

    None.

--*/

{

    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    if(Sp64BitPhysicalAddresses) {
        KeBugCheckEx(PORT_DRIVER_INTERNAL, 
                     0,
                     STATUS_NOT_SUPPORTED,
                     (ULONG_PTR) HwDeviceExtension,
                     (ULONG_PTR) deviceExtension->DeviceObject->DriverObject);
    }

    if (deviceExtension->InterruptData.InterruptFlags & PD_MAP_TRANSFER) {

        //
        // The transfer has not been started so just clear the map transfer
        // flag and return.
        //

        deviceExtension->InterruptData.InterruptFlags &= ~PD_MAP_TRANSFER;
        return;
    }

    deviceExtension->InterruptData.InterruptFlags |= PD_FLUSH_ADAPTER_BUFFERS;

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

    return;

}

VOID
ScsiPortIoMapTransfer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    )
/*++

Routine Description:

    Saves the parameters for the call to IoMapTransfer and schedules the DPC
    if necessary.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.

    Srb - Supplies the particular request that data transfer is for.

    LogicalAddress - Supplies the logical address where the transfer should
        begin.

    Length - Supplies the maximum length in bytes of the transfer.

Return Value:

   None.

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PSRB_DATA srbData = Srb->OriginalRequest;

    ASSERT_SRB_DATA(srbData);

    //
    // If this is a 64-bit system then this call is illegal.  Bugcheck.
    //

    if(Sp64BitPhysicalAddresses) {
        KeBugCheckEx(PORT_DRIVER_INTERNAL, 
                     1,
                     STATUS_NOT_SUPPORTED,
                     (ULONG_PTR) HwDeviceExtension,
                     (ULONG_PTR) deviceExtension->DeviceObject->DriverObject);
    }

    //
    // Make sure this host bus adapter has an Dma adapter object.
    //

    if (deviceExtension->DmaAdapterObject == NULL) {

        //
        // No DMA adapter, no work.
        //

        return;
    }

    ASSERT((Srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) != SRB_FLAGS_UNSPECIFIED_DIRECTION);

    deviceExtension->InterruptData.MapTransferParameters.SrbData = srbData;

    deviceExtension->InterruptData.MapTransferParameters.LogicalAddress = LogicalAddress;
    deviceExtension->InterruptData.MapTransferParameters.Length = Length;
    deviceExtension->InterruptData.MapTransferParameters.SrbFlags = Srb->SrbFlags;

    deviceExtension->InterruptData.InterruptFlags |= PD_MAP_TRANSFER;

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

} // end ScsiPortIoMapTransfer()


VOID
ScsiPortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine saves the error log information, and queues a DPC if necessary.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.

    Srb - Supplies an optional pointer to srb if there is one.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PDEVICE_OBJECT DeviceObject = deviceExtension->CommonExtension.DeviceObject;
    PSRB_DATA srbData;
    PERROR_LOG_ENTRY errorLogEntry;

    //
    // If the error log entry is already full, then dump the error.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_LOG_ERROR) {

#if SCSIDBG_ENABLED
        DebugPrint((1,"ScsiPortLogError: Dumping scsi error log packet.\n"));
        DebugPrint((1,
            "PathId = %2x, TargetId = %2x, Lun = %2x, ErrorCode = %x, UniqueId = %x.",
            PathId,
            TargetId,
            Lun,
            ErrorCode,
            UniqueId
            ));
#endif
        return;
    }

    //
    // Save the error log data in the log entry.
    //

    errorLogEntry = &deviceExtension->InterruptData.LogEntry;

    errorLogEntry->ErrorCode = ErrorCode;
    errorLogEntry->TargetId = TargetId;
    errorLogEntry->Lun = Lun;
    errorLogEntry->PathId = PathId;
    errorLogEntry->UniqueId = UniqueId;

    //
    // Get the sequence number from the SRB data.
    //

    if (Srb != NULL) {

        srbData = Srb->OriginalRequest;

        ASSERT_SRB_DATA(srbData);

        errorLogEntry->SequenceNumber = srbData->SequenceNumber;
        errorLogEntry->ErrorLogRetryCount = srbData->ErrorLogRetryCount++;
    } else {
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->ErrorLogRetryCount = 0;
    }

    //
    // Indicate that the error log entry is in use.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_LOG_ERROR;

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

    return;

} // end ScsiPortLogError()


VOID
ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )

/*++

Routine Description:

    Complete all active requests for the specified logical unit.

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    ULONG binNumber;

    for (binNumber = 0; binNumber < NUMBER_LOGICAL_UNIT_BINS; binNumber++) {

        PLOGICAL_UNIT_BIN bin = &deviceExtension->LogicalUnitList[binNumber];
        PLOGICAL_UNIT_EXTENSION logicalUnit;
        ULONG limit = 0;

        logicalUnit = bin->List;

        DebugPrint((2, "ScsiPortCompleteRequest: Completing requests in "
                       "bin %d [%#p]\n",
                    binNumber, bin));

        for(logicalUnit = bin->List;
            logicalUnit != NULL;
            logicalUnit = logicalUnit->NextLogicalUnit) {

            PLIST_ENTRY entry;

            ASSERT(limit++ < 1000);

            //
            // See if this logical unit matches the pattern.  Check for -1
            // first since this seems to be the most popular way to complete
            // requests.
            //

            if (((PathId == SP_UNTAGGED) || (PathId == logicalUnit->PathId)) &&
                ((TargetId == SP_UNTAGGED) ||
                 (TargetId == logicalUnit->TargetId)) &&
                ((Lun == SP_UNTAGGED) || (Lun == logicalUnit->Lun))) {

                //
                // Complete any pending abort reqeusts.
                //

                if (logicalUnit->AbortSrb != NULL) {
                    logicalUnit->AbortSrb->SrbStatus = SrbStatus;

                    ScsiPortNotification(
                        RequestComplete,
                        HwDeviceExtension,
                        logicalUnit->AbortSrb
                        );
                }

                if(logicalUnit->CurrentUntaggedRequest != NULL) {

                    SpCompleteSrb(deviceExtension,
                                  logicalUnit->CurrentUntaggedRequest,
                                  SrbStatus);
                }

                //
                // Complete each of the requests in the queue.
                //

                entry = logicalUnit->RequestList.Flink;
                while (entry != &logicalUnit->RequestList) {
                    PSRB_DATA srbData;

                    ASSERT(limit++ < 1000);
                    srbData = CONTAINING_RECORD(entry, SRB_DATA, RequestList);
                    SpCompleteSrb(deviceExtension,  srbData, SrbStatus);
                    entry = srbData->RequestList.Flink;
                }

            }
        }
    }

    return;

} // end ScsiPortCompleteRequest()


VOID
ScsiPortMoveMemory(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    Copy from one buffer into another.

Arguments:

    ReadBuffer - source
    WriteBuffer - destination
    Length - number of bytes to copy

Return Value:

    None.

--*/

{

    //
    // See if the length, source and desitination are word aligned.
    //

    if (Length & LONG_ALIGN || (ULONG_PTR) WriteBuffer & LONG_ALIGN ||
        (ULONG_PTR) ReadBuffer & LONG_ALIGN) {

        PCHAR destination = WriteBuffer;
        PCHAR source = ReadBuffer;

        for (; Length > 0; Length--) {
            *destination++ = *source++;
        }
    } else {

        PLONG destination = WriteBuffer;
        PLONG source = ReadBuffer;

        Length /= sizeof(LONG);
        for (; Length > 0; Length--) {
            *destination++ = *source++;
        }
    }

} // end ScsiPortMoveMemory()


#if SCSIDBG_ENABLED

VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for scsi miniports.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None
    
Note:
    Using the new debug API (systemwide API) DebugPrintEx
    renders the variable scsidebug meaningless, since the
    level of debug is now controlled int he debug filter
    the mask for scsiprot is Kd_ScsiMiniPort_Mask

    From the debugger do: ed Kd_ScsiPort_Mask X
    where X is the desired value of debug spew.

    DPFLTR_ERROR_LEVEL      - Are always printed.
    DPFLTR_WARNING_LEVEL    - 0x01  (bit 1)
    DPFLTR_TRACE_LEVEL      - 0x02  (bit 2)
    DPFLTR_INFO_LEVEL       - 0x04  (bit 3)
    
    If you'd like to get WARNING and TRACE, you muyst set bit 1 and 2 (etc)
    
    The Mask is a 32-bit value
    
    I can only see 1 bad thing about changing this function.
    Before the _vsnprintf operations would only occurr if we KNEW
    that the debug message was going to be printed.  Now it
    occurs before we deternime wether it will be printed.  This changes
    the timing of the checked build a bit.

--*/

{
    va_list ap;
    ULONG   DebugLevel;

    //
    // This code should be removed soon
    // Its place here is to remind people debugging scsiport
    // that the methods that control debug spew have changed
    //
    // NOTE - Eventually we should be able to remove this.
    //
    if (ScsiDebug != 0) {
        // This means that someone changed the value of ScsiDebug
        // (ie. they want debug spew)
        DbgPrintEx(DPFLTR_SCSIMINIPORT_ID, DPFLTR_ERROR_LEVEL,
                   "Debug messages in SCSI Miniports are no longer controlled by\n"
                   "scsiport!scsidebug.  Please use the correct debug maski\n\n"
                   "Kd_ScsiPort_Mask -- controls debug msgs from ScsiPort\n"
                   "Kd_ScsiMiniPort_Mask  --  controls debug msgs from SCSI-Miniports\n\n"
                   "\t0x01 - Error Level\t(bit 0)\n"
                   "\t0x02 - Warning Level\t(bit 1)\n"
                   "\t0x04 - Trace Level\t(bit 2)\n"
                   "\t0x08 - Info Level\t(bit 3)\n\n"
                   "To get multiple levels, OR the bit-values\n");
        DbgBreakPoint();
        ScsiDebug = 0;
    }

    va_start(ap, DebugMessage);

    //
    // Map the debugprintlevels of scsiport into the new
    // debug print API
    //
    switch (DebugPrintLevel) {
    case 0:
        DebugLevel = DPFLTR_WARNING_LEVEL;
        break;
    case 1:
    case 2:
        DebugLevel = DPFLTR_TRACE_LEVEL;
        break;

    case 3:
        DebugLevel = DPFLTR_INFO_LEVEL;
        break;

    default:
        DebugLevel = DebugPrintLevel;
        break;

    }

    vDbgPrintExWithPrefix("ScsiMiniport: ",
                          DPFLTR_SCSIMINIPORT_ID, 
                          DebugLevel, 
                          DebugMessage, 
                          ap);

    va_end(ap);

} // end ScsiDebugPrint()

VOID
ScsiDebugPrintInt(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for Internal DebugPrints (SCSIPORT Internal).

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None
    
Note:
    Using the new debug API (systemwide API) DebugPrintEx
    renders the variable scsidebug meaningless, since the
    level of debug is now controlled int he debug filter
    the mask for scsiprot is Kd_ScsiPort_Mask

    From the debugger do: ed Kd_ScsiPort_Mask X
    where X is the desired value of debug spew.

    DPFLTR_ERROR_LEVEL      - Are always printed.
    DPFLTR_WARNING_LEVEL    - 0x01  (bit 1)
    DPFLTR_TRACE_LEVEL      - 0x02  (bit 2)
    DPFLTR_INFO_LEVEL       - 0x04  (bit 3)
    
    The Mask is a 32-bit value
    
    I can only see 1 bad thing about changing this function.
    Before the _vsnprintf operations would only occurr if we KNEW
    that the debug message was going to be printed.  Now it
    occurs before we deternime wether it will be printed.  This changes
    the timing of the checked build a bit.

--*/

{
    va_list ap;
    ULONG   DebugLevel;

    //
    // This code should be removed soon
    // Its place here is to remind people debugging scsiport
    // that the methods that control debug spew have changed
    //
    // NOTE - Eventually we should be able to remove this.
    //
    if (ScsiDebug != 0) {
        // This means that someone changed the value of ScsiDebug
        // (ie. they want debug spew)
        DbgPrintEx(DPFLTR_SCSIPORT_ID, DPFLTR_ERROR_LEVEL,
                   "Debug messages in SCSI Miniports are no longer controlled by\n"
                   "scsiport!scsidebug.  Please use the correct debug maski\n\n"
                   "Kd_ScsiPort_Mask -- controls debug msgs from ScsiPort\n"
                   "Kd_ScsiMiniPort_Mask  --  controls debug msgs from SCSI-Miniports\n\n"
                   "\t0x01 - Error Level\t(bit 0)\n"
                   "\t0x02 - Warning Level\t(bit 1)\n"
                   "\t0x04 - Trace Level\t(bit 2)\n"
                   "\t0x08 - Info Level\t(bit 3)\n\n"
                   "To get multiple levels, OR the bit-values\n");
        DbgBreakPoint();
        ScsiDebug = 0;
    }

    va_start(ap, DebugMessage);

    //
    // Map the debugprintlevels of scsiport into the new
    // debug print API
    //
    switch (DebugPrintLevel) {
    case 0:
        DebugLevel = DPFLTR_ERROR_LEVEL;
        break;
    case 1:
    case 2:
        DebugLevel = DPFLTR_WARNING_LEVEL;
        break;

    case 3:
        DebugLevel = DPFLTR_TRACE_LEVEL;
        break;

    default:
        DebugLevel = DPFLTR_INFO_LEVEL;
        break;

    }

    vDbgPrintExWithPrefix("ScsiPort: ",
                          DPFLTR_SCSIPORT_ID, 
                          DebugLevel, 
                          DebugMessage, 
                          ap);

    va_end(ap);

} // end ScsiDebugPrint()

#else

//
// ScsiDebugPrint stub
//

VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

VOID
ScsiDebugPrintInt(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif

//
// The below I/O access routines are forwarded to the HAL or NTOSKRNL on
// Alpha and Intel platforms.
//
#if !defined(_ALPHA_) && !defined(_X86_)

UCHAR
ScsiPortReadPortUchar(
    IN PUCHAR Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_UCHAR(Port));

}

USHORT
ScsiPortReadPortUshort(
    IN PUSHORT Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_USHORT(Port));

}

ULONG
ScsiPortReadPortUlong(
    IN PULONG Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_ULONG(Port));

}

VOID
ScsiPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
ScsiPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
ScsiPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

UCHAR
ScsiPortReadRegisterUchar(
    IN PUCHAR Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_UCHAR(Register));

}

USHORT
ScsiPortReadRegisterUshort(
    IN PUSHORT Register
    )

/*++

Routine Description:

    Read from the specified register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_USHORT(Register));

}

ULONG
ScsiPortReadRegisterUlong(
    IN PULONG Register
    )

/*++

Routine Description:

    Read from the specified register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_ULONG(Register));

}

VOID
ScsiPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
ScsiPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
ScsiPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
ScsiPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_UCHAR(Port, Value);

}

VOID
ScsiPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_USHORT(Port, Value);

}

VOID
ScsiPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_ULONG(Port, Value);


}

VOID
ScsiPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
ScsiPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
ScsiPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

VOID
ScsiPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_UCHAR(Register, Value);

}

VOID
ScsiPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_USHORT(Register, Value);
}

VOID
ScsiPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
ScsiPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
ScsiPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
ScsiPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_ULONG(Register, Value);
}
#endif  // !defined(_ALPHA_) && !defined(_X86_)


PSCSI_REQUEST_BLOCK
ScsiPortGetSrb(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    )

/*++

Routine Description:

    This routine retrieves an active SRB for a particuliar logical unit.

Arguments:

    HwDeviceExtension
    PathId, TargetId, Lun - identify logical unit on SCSI bus.
    QueueTag - -1 indicates request is not tagged.

Return Value:

    SRB, if one exists. Otherwise, NULL.

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PSRB_DATA srbData;
    PSCSI_REQUEST_BLOCK srb;
    UCHAR pathId;
    UCHAR targetId;
    UCHAR lun;

    srbData = SpGetSrbData(deviceExtension,
                           PathId,
                           TargetId,
                           Lun,
                           (UCHAR)QueueTag,
                           FALSE);

    if (srbData == NULL || srbData->CurrentSrb == NULL) {
        return(NULL);
    }

    srb = srbData->CurrentSrb;

    //
    // If the srb is not active then return NULL;
    //

    if (!(srb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {
        return(NULL);
    }

    return (srb);

} // end ScsiPortGetSrb()


SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
)

/*++

Routine Description:

    Convert virtual address to physical address for DMA.

Arguments:

Return Value:

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    ULONG             byteOffset;
    PHYSICAL_ADDRESS  address;
    ULONG             length;

    if (Srb == NULL || Srb->SenseInfoBuffer == VirtualAddress) {

        byteOffset = (ULONG)((PCCHAR) VirtualAddress - (PCCHAR)
                deviceExtension->SrbExtensionBuffer);

        ASSERT(byteOffset < deviceExtension->CommonBufferSize);
            
        length = deviceExtension->CommonBufferSize - byteOffset;
        address.QuadPart = deviceExtension->PhysicalCommonBuffer.QuadPart + byteOffset;

    } else if (deviceExtension->MasterWithAdapter) {

        PSRB_SCATTER_GATHER scatterList;
        PSRB_DATA srbData;

        //
        // A scatter/gather list has already been allocated use it to determine
        // the physical address and length.  Get the scatter/gather list.
        //

        srbData = Srb->OriginalRequest;

        ASSERT_SRB_DATA(srbData);

        scatterList = srbData->ScatterGatherList;

        //
        // Calculate byte offset into the data buffer.
        //

        byteOffset = (ULONG)((PCHAR) VirtualAddress - (PCHAR) Srb->DataBuffer);

        //
        // Find the appropriate entry in the scatter/gatter list.
        //

        while (byteOffset >= scatterList->Length) {

            byteOffset -= scatterList->Length;
            scatterList++;
        }

        //
        // Calculate the physical address and length to be returned.
        //

        length = scatterList->Length - byteOffset;

        address.QuadPart = scatterList->Address.QuadPart + byteOffset;

    } else {
        length = 0;
        address.QuadPart = (LONGLONG)(SP_UNINITIALIZED_VALUE);
    }

    *Length = length;

    return address;

} // end ScsiPortGetPhysicalAddress()


PVOID
ScsiPortGetVirtualAddress(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:

    This routine is returns a virtual address associated with a
    physical address, if the physical address was obtained by a
    call to ScsiPortGetPhysicalAddress.

Arguments:

    PhysicalAddress

Return Value:

    Virtual address

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PVOID address;
    ULONG smallphysicalBase;
    ULONG smallAddress;

    smallAddress = ScsiPortConvertPhysicalAddressToUlong(PhysicalAddress);

    smallphysicalBase = ScsiPortConvertPhysicalAddressToUlong(deviceExtension->PhysicalCommonBuffer);

    //
    // Check that the physical address is within the proper range.
    //

    if (smallAddress < smallphysicalBase ||
        smallAddress >= smallphysicalBase + deviceExtension->CommonBufferSize) {

        //
        // This is a bugous physical address return back NULL.
        //

        return(NULL);

    }

    address = smallAddress - smallphysicalBase +
       (PUCHAR) deviceExtension->SrbExtensionBuffer;

    return address;

} // end ScsiPortGetVirtualAddress()


BOOLEAN
ScsiPortValidateRange(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine should take an IO range and make sure that it is not already
    in use by another adapter. This allows miniport drivers to probe IO where
    an adapter could be, without worrying about messing up another card.

Arguments:

    HwDeviceExtension - Used to find scsi managers internal structures
    BusType - EISA, PCI, PC/MCIA, MCA, ISA, what?
    SystemIoBusNumber - Which system bus?
    IoAddress - Start of range
    NumberOfBytes - Length of range
    InIoSpace - Is range in IO space?

Return Value:

    TRUE if range not claimed by another driver.

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);

        //
        // This is not implemented in NT.
        //

        return TRUE;
}


SCSI_PHYSICAL_ADDRESS
ScsiPortConvertUlongToPhysicalAddress(
    ULONG_PTR UlongAddress
    )

{
    SCSI_PHYSICAL_ADDRESS physicalAddress;

    physicalAddress.QuadPart = UlongAddress;
    return(physicalAddress);
}


//
// Leave these routines at the end of the file.
//

#undef ScsiPortConvertPhysicalAddressToUlong

ULONG
ScsiPortConvertPhysicalAddressToUlong(
    SCSI_PHYSICAL_ADDRESS Address
    )

/*++

Routine Description:

    This routine converts a 64-bit physical address to a ULONG

Arguments:

    Address - Supplies a 64-bit address to be converted.

Return Value:

    Returns a 32-bit address.

--*/
{
    return(Address.LowPart);
}

VOID
ScsiPortStallExecution(
    ULONG Delay
    )

/*++

Routine Description:

    This routine stalls the process for the specified number of microseconds.

Arguments:

    Delay - the number of microseconds to stall.

Return Value:

--*/

{
    KeStallExecutionProcessor(Delay);
}

#if defined(_AMD64_)

VOID
ScsiPortQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function returns the current system time.

Arguments:

    CurrentTime - Supplies a pointer to a variable that will receive the
        current system time.

Return Value:

    None.

--*/

{

    KeQuerySystemTime(CurrentTime);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\power.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    power.c

Abstract:

    This module contains the routines for port driver power support

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

PUCHAR PowerMinorStrings[] = {
    "IRP_MN_WAIT_WAKE",
    "IRP_MN_POWER_SEQUENCE",
    "IRP_MN_SET_POWER",
    "IRP_MN_QUERY_POWER"
};

VOID
SpProcessAdapterSystemState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SpProcessAdapterDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpQueryTargetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    );

NTSTATUS
SpQueryAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    );

NTSTATUS
SpSetTargetDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE DeviceState
    );

VOID
SpSetTargetDeviceStateLockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    );

VOID
SpSetTargetDeviceStateUnlockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    );

NTSTATUS
SpSetTargetSystemState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN SYSTEM_POWER_STATE SystemState
    );

VOID
SpSetTargetSystemStateLockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    );

VOID
SpSetTargetSystemStateUnlockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    );

VOID
SpSetTargetDeviceStateForSystemStateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
SpSetAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    );

VOID
SpRequestAdapterPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
SpPowerAdapterForTargetCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
SpSetLowerPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
SpSetTargetDesiredPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
SpRequestValidPowerStateCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PIO_STATUS_BLOCK IoStatus
    );

typedef struct {
    NTSTATUS Status;
    KEVENT Event;
} SP_SIGNAL_POWER_COMPLETION_CONTEXT, *PSP_SIGNAL_POWER_COMPLETION_CONTEXT;

VOID
SpSignalPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PSP_SIGNAL_POWER_COMPLETION_CONTEXT Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

#pragma alloc_text(PAGE, SpRequestValidAdapterPowerStateSynchronous)


NTSTATUS
ScsiPortDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for the target device objects.

    N.B. This routine is NOT pageable as it may be called at dispatch level.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    BOOLEAN isPdo = commonExtension->IsPdo;
    NTSTATUS status;

    //
    // Get the current status of the request.
    //

    status = Irp->IoStatus.Status;

    DebugPrint((4, "ScsiPortDispatchPower: irp %p is %s for %s %p\n",
                Irp,
                PowerMinorStrings[irpStack->MinorFunction],
                isPdo ? "pdo" : "fdo",
                DeviceObject));

    switch (irpStack->MinorFunction) {

       case IRP_MN_SET_POWER: {

           POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
           POWER_STATE state = irpStack->Parameters.Power.State;

           DebugPrint((4, "ScsiPortDispatchPower: SET_POWER type %d state %d\n",
                       type, state));

#if DBG
           if (type == SystemPowerState) {
               ASSERT(state.SystemState >= PowerSystemUnspecified);
               ASSERT(state.SystemState < PowerSystemMaximum);
           } else {                
               ASSERT(state.DeviceState >= PowerDeviceUnspecified);
               ASSERT(state.DeviceState < PowerDeviceMaximum);
           }
#endif

           //
           // If this is a power-down request then call PoSetPowerState now
           // while we're not actually holding any resources or locks.
           //

           if ((state.SystemState != PowerSystemWorking) ||
               (state.DeviceState != PowerDeviceD0)) {

               PoSetPowerState(DeviceObject, type, state);

            }

           //
           // Special case system shutdown request.
           //

           if ((type == SystemPowerState) &&
               (state.SystemState > PowerSystemHibernate)) { 

               if (isPdo) {

                   //
                   // Do not pwer-downdown PDOs on shutdown.  There is no 
                   // reliable way to ensure that disks will spin up on restart.
                   //

                   status = STATUS_SUCCESS;
                   break;

               } else {

                   PADAPTER_EXTENSION adapter;

                   //
                   // If the adapter is not configured to receive power-down
                   // requests at shutdown, just pass the request down.
                   // 
                   
                   adapter = (PADAPTER_EXTENSION)commonExtension;
                   if (adapter->NeedsShutdown == FALSE) {

                       PoStartNextPowerIrp(Irp);
                       IoCopyCurrentIrpStackLocationToNext(Irp);
                       return PoCallDriver(commonExtension->LowerDeviceObject, Irp);
                   }
               }
           }

           if (isPdo) {

               if (type == DevicePowerState) {
                   status = SpSetTargetDeviceState(DeviceObject,
                                                   Irp,
                                                   state.DeviceState);
               } else {
                   status = SpSetTargetSystemState(DeviceObject,
                                                   Irp,
                                                   state.SystemState);
               }
           } else {
               
               PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;
               
               //
               // If we have disabled power then ignore any non-working power irps.
               //
               
               if ((adapter->DisablePower) &&
                   ((state.DeviceState != PowerDeviceD0) ||
                    (state.SystemState != PowerSystemWorking))) {

                   status = STATUS_SUCCESS;
                   break;
               } else {
                   status = SpSetAdapterPower(DeviceObject, Irp, type, state);
               }
            }

            if(status == STATUS_PENDING) {
                return status;
            }

            break;
       }

       case IRP_MN_QUERY_POWER: {
           POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
           POWER_STATE state = irpStack->Parameters.Power.State;

           DebugPrint((4, "ScsiPortDispatchPower: QUERY_POWER type %d "
                       "state %d\n",
                       type, state));

           if ((type == SystemPowerState) &&
               (state.SystemState > PowerSystemHibernate)) {

               //
               // Ignore shutdown irps.
               //
               
               DebugPrint((4, "ScsiPortDispatch power - ignoring shutdown "
                           "query irp for level %d\n",
                           state.SystemState));
               status = STATUS_SUCCESS;
               break;
           }

           if (isPdo) {
               if ((type == SystemPowerState) &&
                   (state.SystemState > PowerSystemHibernate)) {

                   //
                   // Ignore shutdown irps.
                   //
                   
                   DebugPrint((4, "ScsiPortDispatch power - ignoring shutdown "
                               "query irp for level %d\n",
                               state.SystemState));
                   status = STATUS_SUCCESS;
               } else {
                   status = SpQueryTargetPower(DeviceObject,
                                               Irp,
                                               type,
                                               state);
               }
           } else {

               PADAPTER_EXTENSION adapter = (PADAPTER_EXTENSION)commonExtension;

               //
               // If we don't support power for this adapter then fail all
               // queries.
               //

               if (adapter->DisablePower) {
                   status = STATUS_NOT_SUPPORTED;
                   break;
               }

               status = SpQueryAdapterPower(DeviceObject, Irp, type, state);

               if (NT_SUCCESS(status)) {
                   
                   //
                   // See what the lower driver wants to do.
                   //
                   
                   PoStartNextPowerIrp(Irp);
                   IoCopyCurrentIrpStackLocationToNext(Irp);
                   return PoCallDriver(commonExtension->LowerDeviceObject, Irp);
               }
           }

           break;
       }

       case IRP_MN_WAIT_WAKE: {

           if (isPdo) {

               //
               // We don't support WAIT WAKE, so just fail the request.
               //

               status = STATUS_INVALID_DEVICE_REQUEST;
               PoStartNextPowerIrp(Irp);
               Irp->IoStatus.Status = status;
               IoCompleteRequest(Irp, IO_NO_INCREMENT);

           } else {

               //
               // Pass the request down.
               //

               PoStartNextPowerIrp(Irp);
               IoSkipCurrentIrpStackLocation(Irp);
               status = PoCallDriver(commonExtension->LowerDeviceObject, Irp);

           }

           return status;
       }

       default: {
           //
           // We pass down FDO requests we don't handle.
           //
           
           if (!isPdo) {
               PoStartNextPowerIrp(Irp);
               IoSkipCurrentIrpStackLocation(Irp);
               return PoCallDriver(commonExtension->LowerDeviceObject, Irp);
           }

           break;
        }
    }

    //
    // Complete the request.
    //

    PoStartNextPowerIrp(Irp);
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
SpSetAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    )
/*++

Routine Description:

    Wrapper routine to dump adapter power requests into the device i/o queue.
    Power requests are processed by the StartIo routine which calls
    SpProcessAdapterPower to do the actual work.

Arguments:

    DeviceObject - the device object being power managed.

    Irp - the power management irp.

    Type - the type of set_power irp (device or system)

    State - the state the adapter is being put into.

Return Value:

    STATUS_PENDING

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;

    NTSTATUS status;

    ASSERT_FDO(DeviceObject);

    DebugPrint((2, "SpSetAdapterPower - starting packet\n"));

    if(SpIsAdapterControlTypeSupported(adapter, ScsiStopAdapter)) {

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, 0L, FALSE);
        return STATUS_PENDING;

    } else if((commonExtension->CurrentPnpState != IRP_MN_START_DEVICE) &&
              (commonExtension->PreviousPnpState != IRP_MN_START_DEVICE)) {

        //
        // Fine, we're in a low power state.  If we get a start or a remove
        // then there's an implicit power transition there so we don't really
        // need to set our current power state.
        //

        IoMarkIrpPending(Irp);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoStartNextPowerIrp(Irp);
        PoCallDriver(commonExtension->LowerDeviceObject, Irp);
        return STATUS_PENDING;

    } else {

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        return Irp->IoStatus.Status;
    }
}


VOID
SpPowerAdapterForTargetCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine is called for a D0 request to a target device after it's
    adapter has been powered back on.  The routine will call back into
    SpSetTargetDeviceState to restart the power request or complete the
    target D request if the adapter power up was not successful.

Arguments:

    DeviceObject - the adapter which was powered up.

    MinorFunction - IRP_MN_SET_POWER

    PowerState - PowerDeviceD0

    OriginalIrp - The original target D0 irp.  This is the irp which will
                  be reprocessed.

    IoStatus - the status of the adapter power up request.

Return Value:

    none.

--*/

{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(OriginalIrp);
    POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
    POWER_STATE state = irpStack->Parameters.Power.State;

    NTSTATUS status = IoStatus->Status;

    DebugPrint((1, "SpPowerAdapterForTargetCompletion: DevObj %#p, Irp "
                   "%#p, Status %#08lx\n",
                DeviceObject, OriginalIrp, IoStatus));

    ASSERT_FDO(DeviceObject);
    ASSERT_PDO(irpStack->DeviceObject);

    ASSERT(type == DevicePowerState);
    ASSERT(state.DeviceState == PowerDeviceD0);

    ASSERT(NT_SUCCESS(status));

    if(NT_SUCCESS(status)) {

        ASSERT(adapter->CommonExtension.CurrentDeviceState == PowerDeviceD0);

        status = SpSetTargetDeviceState(irpStack->DeviceObject,
                                        OriginalIrp,
                                        PowerDeviceD0);
    }

    if(status != STATUS_PENDING) {
        PoStartNextPowerIrp(OriginalIrp);
        OriginalIrp->IoStatus.Status = status;
        IoCompleteRequest(OriginalIrp, IO_NO_INCREMENT);
    }
    return;
}


NTSTATUS
SpQueryAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    )
{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    if((adapter->HwAdapterControl != NULL) && (adapter->IsPnp))  {

        status = STATUS_SUCCESS;

    } else if((commonExtension->CurrentPnpState != IRP_MN_START_DEVICE) &&
              (commonExtension->PreviousPnpState != IRP_MN_START_DEVICE)) {

        //
        // If the adapter's not been started yet then we can blindly go to
        // a lower power state - START irps imply a transition into the D0 state
        //

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_NOT_SUPPORTED;
    }

    return status;
}


NTSTATUS
SpQueryTargetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    )
{
    return STATUS_SUCCESS;
}


NTSTATUS
SpRequestValidPowerState(
    IN PADAPTER_EXTENSION Adapter,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PCOMMON_EXTENSION commonExtension = &(LogicalUnit->CommonExtension);
    PSRB_DATA srbData = Srb->OriginalRequest;

    BOOLEAN needsPower = SpSrbRequiresPower(Srb);

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Make sure we're at a power level which can process this request.  If
    // we aren't then make this a pending request, lock the queues and
    // ask the power system to bring us up to a more energetic level.
    //

    if((Srb->Function == SRB_FUNCTION_UNLOCK_QUEUE) ||
       (Srb->Function == SRB_FUNCTION_LOCK_QUEUE)) {

        //
        // Lock and unlock commands don't require power and will work
        // regardless of the current power state.
        //

        return status;
    }

    //
    // Even if this is a bypass request, the class driver may not request
    // actual miniport operations on the unpowered side of a power sequence.
    // This means that this is either:
    //      * a request to an idle device - powering up the device will power
    //        up the adapter if necessary.
    //      * a request to power down a device - adapter cannot have powered
    //        off until this is done.
    //      * a part of a power up sequence - the only real SCSI commands come
    //        after the power up irp has been processed and that irp will
    //        already have turned the adapter on.
    // This boils down to - we don't need to do anything special here to
    // power up the adapter.  The device power sequences will take care of
    // it automatically.
    //

    //
    // If the device or system isn't working AND this is not a request to
    // unlock the queue then let it go through.  The class driver is going
    // to unlock the queue after sending us a power request so we need to
    // be able to handle one.
    //

    if((commonExtension->CurrentDeviceState != PowerDeviceD0) ||
       ((commonExtension->CurrentSystemState != PowerSystemWorking) &&
        (!TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)))) {

        //
        // This request cannot be executed now.  Mark it as pending
        // in the logical unit structure and return.
        // GetNextLogicalUnit will restart the commnad after all of the
        // active commands have completed.
        //

        ASSERT(!TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE));

        ASSERT(!(LogicalUnit->LuFlags & LU_PENDING_LU_REQUEST));

        DebugPrint((4, "ScsiPortStartIo: logical unit (%d,%d,%d) [%#p] is "
                       "in power state (%d,%d) - must power up for irp "
                       "%#p\n",
                    Srb->PathId,
                    Srb->TargetId,
                    Srb->Lun,
                    commonExtension->DeviceObject,
                    commonExtension->CurrentDeviceState,
                    commonExtension->CurrentSystemState,
                    srbData->CurrentIrp));

        ASSERT(LogicalUnit->PendingRequest == NULL);
        LogicalUnit->PendingRequest = Srb->OriginalRequest;

        //
        // Indicate that the logical unit is still active so that the
        // request will get processed when the request list is empty.
        //

        SET_FLAG(LogicalUnit->LuFlags, LU_PENDING_LU_REQUEST |
                                       LU_LOGICAL_UNIT_IS_ACTIVE);

        if(commonExtension->CurrentSystemState != PowerSystemWorking) {

            DebugPrint((1, "SpRequestValidPowerState: can't power up target "
                           "since it's in system state %d\n",
                        commonExtension->CurrentSystemState));

            //
            // Set the desired D state in the device extension.  This is
            // necessary when we're in a low system state as well as useful for
            // debugging when we're in low D states.
            //

            commonExtension->DesiredDeviceState = PowerDeviceD0;

            //
            // If we aren't in a valid system state then just release the
            // spinlock and return.  The next time we receive a system
            // state irp we'll issue the appropriate D state irp as well.
            //

            return STATUS_PENDING;

        } else if(commonExtension->DesiredDeviceState == PowerDeviceD0) {

            //
            // Scsiport is already asking to power up this lun.  Once that's
            // happened this request will be restarted.  For now just leave
            // it as the pending request.
            //

            return STATUS_PENDING;
        }

        //
        // Tell Po that we're not idle in case this was stuck in the queue
        // for some reason.
        //

        if(commonExtension->IdleTimer != NULL) {
            PoSetDeviceBusy(commonExtension->IdleTimer);
        }

        //
        // Get PO to send a power request to this device stack to put it
        // back into the D0 state.
        //

        {
            POWER_STATE powerState;

            powerState.DeviceState = PowerDeviceD0;

            status = PoRequestPowerIrp(
                        commonExtension->DeviceObject,
                        IRP_MN_SET_POWER,
                        powerState,
                        NULL,
                        NULL,
                        NULL);
        }

        //
        // CODEWORK - if we can't power up the device here we'll need to
        // hang around in the tick handler for a while and try to do
        // it from there.
        //

        ASSERT(NT_SUCCESS(status));

        return STATUS_PENDING;
    }

    ASSERT(Adapter->CommonExtension.CurrentDeviceState == PowerDeviceD0);
    ASSERT(Adapter->CommonExtension.CurrentSystemState == PowerSystemWorking);

    return status;
}


NTSTATUS
SpSetLowerPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
    POWER_STATE state = irpStack->Parameters.Power.State;

    DebugPrint((2, "SpSetLowerPowerCompletion: DevObj %#p Irp %#p "
                   "%sState %d\n",
                DeviceObject, Irp,
                ((type == SystemPowerState) ? "System" : "Device"),
                state.DeviceState - 1));

    if(NT_SUCCESS(Irp->IoStatus.Status)) {

        if(type == SystemPowerState) {

            DebugPrint((2, "SpSetLowerPowerCompletion: Lower device succeeded "
                           "the system state transition.  Reprocessing power "
                           "irp\n"));
            SpProcessAdapterSystemState(DeviceObject, Irp);
        } else {
            DebugPrint((2, "SpSetLowerPowerCompletion: Lower device power up "
                           "was successful.  Reprocessing power irp\n"));

            SpProcessAdapterDeviceState(DeviceObject, Irp);
        }
        return STATUS_MORE_PROCESSING_REQUIRED;
    } else {
        DebugPrint((1, "SpSetLowerPowerCompletion: Lower device power operation"
                       "failed - completing power irp with status %#08lx\n",
                    Irp->IoStatus.Status));
        PoStartNextPowerIrp(Irp);
        SpStartNextPacket(DeviceObject, FALSE);
        return STATUS_SUCCESS;
    }
}


VOID
SpProcessAdapterSystemState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles a system power IRP for the adapter.

Arguments:

    DeviceObject - the device object for the adapter.

    Irp - the power irp.

Return Value:

    none

--*/
{
    PADAPTER_EXTENSION adapterExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    SYSTEM_POWER_STATE state = irpStack->Parameters.Power.State.SystemState;

    SYSTEM_POWER_STATE originalSystemState;

    NTSTATUS status = STATUS_SUCCESS;

    ASSERT_FDO(DeviceObject);
    ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);

    DebugPrint((2, "SpProcessAdapterSystemState: DevObj %#p Irp %#p "
                   "SystemState %d\n",
                   DeviceObject, Irp, state));

    originalSystemState = commonExtension->CurrentSystemState;

    try {

        POWER_STATE newDeviceState;

        if(((commonExtension->CurrentSystemState != PowerSystemWorking) &&
            (state != PowerSystemWorking)) ||
           (commonExtension->CurrentSystemState == state)) {

            DebugPrint((2, "SpProcessAdapterSystemState: no work required for "
                           "transition from system state %d to %d\n",
                        commonExtension->CurrentSystemState,
                        state));
            commonExtension->CurrentSystemState = state;
            leave;
        }

        //
        // Set the new system state.  We'll back it out if any errors occur.
        //

        commonExtension->CurrentSystemState = state;

        if(state != PowerSystemWorking) {

            //
            // Going into a non-working state - power down the device.
            //

            DebugPrint((1, "SpProcessAdapterSystemState: need to power "
                           "down adapter for non-working system state "
                           "%d\n", state));

            newDeviceState.DeviceState = PowerDeviceD3;

            //
            // This system irp cannot be completed until we've successfully
            // powered the adapter off (or on).
            //

            status = PoRequestPowerIrp(DeviceObject,
                                       IRP_MN_SET_POWER,
                                       newDeviceState,
                                       SpRequestAdapterPowerCompletion,
                                       Irp,
                                       NULL);

            DebugPrint((2, "SpProcessAdapterSystemState: PoRequestPowerIrp "
                           "returned %#08lx\n", status));

        } else {

            //
            // Transitioning the device into a system working state.  Just
            // do the enable.  When a child device is put into S0 and has
            // work to process it will request a D0 of the child which will
            // in turn request a D0 of the parent (ie. the adapter).  We can
            // defer adapter power on until that occurs.
            //

            // Going into a working device state.  When the targets are
            // powered on and we have work to do they will request an
            // adapter power up for us.
            //

            DebugPrint((1, "SpProcessAdapterSystemState: going to working "
                           "state - no need to take adapter out of power "
                           "state %d\n",
                        commonExtension->CurrentDeviceState));

            ASSERT(state == PowerSystemWorking);

            status = SpEnableDisableAdapter(adapterExtension, TRUE);

            ASSERT(status != STATUS_PENDING);

            DebugPrint((1, "SpProcessAdapterSystemState: SpEnableDisableAd. "
                           "returned %#08lx\n", status));

        }

    } finally {

        SpStartNextPacket(DeviceObject, FALSE);

        if(status != STATUS_PENDING) {

            if(!NT_SUCCESS(status)) {

                //
                // Something went wrong above.  Restore the original system
                // state.
                //

                commonExtension->CurrentSystemState = originalSystemState;
            }

            PoStartNextPowerIrp(Irp);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            PoCallDriver(adapterExtension->CommonExtension.LowerDeviceObject,
                         Irp);
        }

    }
    return;
}


VOID
SpProcessAdapterDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles a device power IRP for the adapter.

Arguments:

    DeviceObject - the device object for the adapter.

    Irp - the power irp.

Return Value:

    none

--*/
{
    PADAPTER_EXTENSION adapterExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    DEVICE_POWER_STATE state = irpStack->Parameters.Power.State.DeviceState;

    NTSTATUS status = STATUS_SUCCESS;

    ASSERT_FDO(DeviceObject);
    ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    DebugPrint((1, "SpProcessAdapterDevicePower: DevObj %#p Irp %#p "
                   "State %d\n",
                   DeviceObject, Irp, state));

    //
    // First check to see if we actually need to touch the queue.
    // If both the current and new state are working or non-working then
    // we don't have a thing to do.
    //

    if(((commonExtension->CurrentDeviceState != PowerDeviceD0) &&
        (state != PowerDeviceD0)) ||
       (commonExtension->CurrentDeviceState == state)) {

        DebugPrint((2, "SpProcessAdapterDeviceState: no work required "
                       "for transition from device state %d to %d\n",
                    commonExtension->CurrentDeviceState,
                    state));

    } else {

        BOOLEAN enable = (state == PowerDeviceD0);

        status = SpEnableDisableAdapter(adapterExtension, enable);

        ASSERT(status != STATUS_PENDING);

        DebugPrint((2, "SpProcessAdapterDeviceState: SpEnableDisableAd. "
                       "returned %#08lx\n", status));

    }

    ASSERT(status != STATUS_PENDING);

    if(NT_SUCCESS(status)) {
        commonExtension->CurrentDeviceState = state;
    }

    //
    // If this is not a D0 irp then throw it down to the lower driver,
    // otherwise complete it.
    //

    SpStartNextPacket(DeviceObject, FALSE);
    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp(Irp);

    if(irpStack->Parameters.Power.State.DeviceState != PowerDeviceD0) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoCallDriver(commonExtension->LowerDeviceObject, Irp);
    } else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    //
    // If we successfully powered up the adapter, initiate a rescan so our child
    // device state is accurate.
    // 

    if (NT_SUCCESS(status) && (state == PowerDeviceD0)) {

        DebugPrint((1, "SpProcessAdapterDeviceState: powered up.. rescan %p\n",
                       adapterExtension->LowerPdo));

        IoInvalidateDeviceRelations(
            adapterExtension->LowerPdo,
            BusRelations);
    }

    return;
}


VOID
ScsiPortProcessAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT_FDO(DeviceObject);

    //
    // Determine if the irp should be sent to the lower driver first.
    // If so send it down without calling SpStartNextPacket so we'll
    // still have synchronization in the completion routine.
    //
    // The completion routine calls ScsiPortProcessAdapterPower for this
    // irp.
    //

    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        //
        // Process system state irps before we send them down.
        //

        SpProcessAdapterSystemState(DeviceObject, Irp);

    } else if(irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0) {

        NTSTATUS status;

        //
        // System power IRP or a power-up request.  These should be
        // processed by the lower driver before being processed by
        // scsiport.
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(Irp,
                               SpSetLowerPowerCompletion,
                               NULL,
                               TRUE,
                               TRUE,
                               TRUE);

        status = PoCallDriver(
                     adapter->CommonExtension.LowerDeviceObject,
                     Irp);
    } else {
        SpProcessAdapterDeviceState(DeviceObject, Irp);
    }

    return;
}


VOID
SpRequestAdapterPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SystemIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PADAPTER_EXTENSION adapter = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(SystemIrp);
    SYSTEM_POWER_STATE state = irpStack->Parameters.Power.State.SystemState;

    BOOLEAN enable = FALSE;

    NTSTATUS status = IoStatus->Status;

    ASSERT_FDO(DeviceObject);
    ASSERT(IoGetCurrentIrpStackLocation(SystemIrp)->Parameters.Power.Type ==
           SystemPowerState);

    DebugPrint((2, "SpRequestAdapterPowerCompletion: Adapter %#p, "
                   "Irp %#p, State %d, Status %#08lx\n",
                adapter,
                SystemIrp,
                PowerState.DeviceState,
                IoStatus->Status));

    SystemIrp->IoStatus.Status = IoStatus->Status;

    if(NT_SUCCESS(status)) {

        enable = (state == PowerSystemWorking);

        status = SpEnableDisableAdapter(adapter, enable);

        DebugPrint((1, "SpRequestAdapterPowerCompletion: %s adapter call "
                       "returned %#08lx\n",
                    enable ? "Enable" : "Disable",
                    status));

        ASSERT(status != STATUS_PENDING);

        if((NT_SUCCESS(status)) && enable) {

            POWER_STATE setState;

            setState.SystemState = PowerSystemWorking;

            PoSetPowerState(DeviceObject,
                            SystemPowerState,
                            setState);

        }
    }

    IoCopyCurrentIrpStackLocationToNext(SystemIrp);

    PoStartNextPowerIrp(SystemIrp);
    PoCallDriver(adapter->CommonExtension.LowerDeviceObject, SystemIrp);

    return;
}

VOID
SpSetTargetDesiredPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    ASSERT_PDO(DeviceObject);
    ASSERT(MinorFunction == IRP_MN_SET_POWER);
    ASSERT(NT_SUCCESS(IoStatus->Status));
    ASSERT(PowerState.DeviceState == PowerDeviceD0);
    ASSERT(commonExtension->CurrentDeviceState == PowerDeviceD0);
    ASSERT(commonExtension->DesiredDeviceState == PowerState.DeviceState);
    ASSERT(OriginalIrp == NULL);

    DebugPrint((4, "SpSetTargetDesiredPowerCompletion: power irp completed "
                   "with status %#08lx\n", IoStatus->Status));

    commonExtension->DesiredDeviceState = PowerDeviceUnspecified;

    return;
}


VOID
SpSetTargetDeviceStateLockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    )
/*++

Routine Description:

    This routine is called after locking the queue for handling of a device
    state.  The proper device state is set and an unlock request is sent
    to the queue.  The OriginalIrp (whatever it may have been) will be
    completed after the unlock has been completed.

Arguments:

    DeviceObject - the device object

    Status - the status of the enable/disable operation

    OriginalIrp - the original power irp.

Return Value:

    none

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(OriginalIrp);

    ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    DebugPrint((4, "SpSetTargetDeviceStateLockedCompletion: DO %#p Irp %#p "
                   "Status %#08lx\n",
                DeviceObject, OriginalIrp, Status));

    if(NT_SUCCESS(Status)) {

        DEVICE_POWER_STATE newState =
            irpStack->Parameters.Power.State.DeviceState;

        DebugPrint((4, "SpSetTargetDeviceStateLockedCompletion: old device state "
                       "was %d - new device state is %d\n",
                    commonExtension->CurrentDeviceState,
                    irpStack->Parameters.Power.State.DeviceState));

        SpAdjustDisabledBit(logicalUnit,
                            (BOOLEAN) ((newState == PowerDeviceD0) ? TRUE :
                                                                     FALSE));
        commonExtension->CurrentDeviceState = newState;

        SpEnableDisableLogicalUnit(
            logicalUnit,
            TRUE,
            SpSetTargetDeviceStateUnlockedCompletion,
            OriginalIrp);

        return;
    }

    OriginalIrp->IoStatus.Status = Status;
    PoStartNextPowerIrp(OriginalIrp);
    IoCompleteRequest(OriginalIrp, IO_NO_INCREMENT);
    return;
}


VOID
SpSetTargetDeviceStateUnlockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP OriginalIrp
    )
/*++

Routine Description:

    This routine is called after unlocking the queue following the setting
    of the new device state.  It simply completes the original power request.

Arguments:

    DeviceObject - the device object

    Status - the status of the enable/disable operation

    OriginalIrp - the original power irp.

Return Value:

    none

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(OriginalIrp);

    ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    DebugPrint((4, "SpSetTargetDeviceStateUnlockedCompletion: DO %#p Irp %#p "
                   "Status %#08lx\n",
                DeviceObject, OriginalIrp, Status));

    if(NT_SUCCESS(Status) &&
       (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0)) {

        //
        // Power up completed - fire notifications.
        //

        PoSetPowerState(DeviceObject,
                        DevicePowerState,
                        irpStack->Parameters.Power.State);
    }

    OriginalIrp->IoStatus.Status = Status;
    PoStartNextPowerIrp(OriginalIrp);
    IoCompleteRequest(OriginalIrp, IO_NO_INCREMENT);
    return;
}


NTSTATUS
SpSetTargetDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE DeviceState
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PADAPTER_EXTENSION adapter = logicalUnit->AdapterExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    BOOLEAN isHibernation;

    NTSTATUS status = STATUS_SUCCESS;

    ASSERT_PDO(DeviceObject);
    ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    DebugPrint((4, "SpSetTargetDeviceState: device %#p irp %#p\n",
                DeviceObject, Irp));

    //
    // First check to see if we actually need to touch the queue.
    // If both the current and new state are working or non-working then
    // we don't have a thing to do.
    //

    if(((commonExtension->CurrentDeviceState != PowerDeviceD0) &&
        (DeviceState != PowerDeviceD0)) ||
       (commonExtension->CurrentDeviceState == DeviceState)) {

        DebugPrint((4, "SpSetTargetDeviceState: Transition from D%d to D%d "
                       "requires no extra work\n",
                    commonExtension->CurrentDeviceState,
                    DeviceState));

        commonExtension->CurrentDeviceState = DeviceState;

        return STATUS_SUCCESS;
    }

    //
    // We can't power up the target device if the adapter isn't already
    // powered up.
    //

    if((DeviceState == PowerDeviceD0) &&
       (adapter->CommonExtension.CurrentDeviceState != PowerDeviceD0)) {

        POWER_STATE newAdapterState;

        DebugPrint((1, "SpSetTargetPower: Unable to power up target "
                       "before adapter - requesting adapter %#p "
                       "powerup\n",
                    adapter));

        irpStack->DeviceObject = DeviceObject;

        newAdapterState.DeviceState = PowerDeviceD0;

        return PoRequestPowerIrp(adapter->DeviceObject,
                                 IRP_MN_SET_POWER,
                                 newAdapterState,
                                 SpPowerAdapterForTargetCompletion,
                                 Irp,
                                 NULL);
    }

    //
    // Device power operations use queue locks to ensure
    // synchronization with i/o requests.  However they never leave
    // the logical unit queue permenantly locked - otherwise we'd be
    // unable to power-up the device when i/o came in.  Lock the queue
    // so we can set the power state.
    //

    IoMarkIrpPending(Irp);

    SpEnableDisableLogicalUnit(
        logicalUnit,
        FALSE,
        SpSetTargetDeviceStateLockedCompletion,
        Irp);

    return STATUS_PENDING;
}



NTSTATUS
SpSetTargetSystemState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN SYSTEM_POWER_STATE SystemState
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    POWER_STATE newDeviceState;

    NTSTATUS status = STATUS_SUCCESS;

    ASSERT_PDO(DeviceObject);
    ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);

    DebugPrint((2, "SpSetTargetSystemState: device %#p irp %#p\n",
                DeviceObject, Irp));

    //
    // First check to see if we actually need to touch the queue.
    // If both the current and new state are working or non-working then
    // we don't have a thing to do.
    //

    if(((commonExtension->CurrentSystemState != PowerSystemWorking) &&
        (SystemState != PowerSystemWorking)) ||
       (commonExtension->CurrentSystemState == SystemState)) {

        DebugPrint((2, "SpSetTargetPower: Transition from S%d to S%d "
                       "requires no extra work\n",
                    commonExtension->CurrentSystemState,
                    SystemState));

        commonExtension->CurrentSystemState = SystemState;

        return STATUS_SUCCESS;
    }

    //
    // Disable the logical unit so we can set it's power state safely.
    //

    IoMarkIrpPending(Irp);

    SpEnableDisableLogicalUnit(
        logicalUnit,
        FALSE,
        SpSetTargetSystemStateLockedCompletion,
        Irp);

    return STATUS_PENDING;
}


VOID
SpSetTargetSystemStateLockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP PowerIrp
    )
/*++

Routine Description:

    This routine is called after the logical unit has been locked and is
    responsible for setting the new system state of the logical unit.  If
    the logical unit currently has a desired power state (other than
    unspecified) this routine will request that the device be put into that
    power state after the logical unit is re-enabled.

    Once the work is done this routine will request that the logical unit
    be re-enabled.  After that the power irp will be completed.

Arguments:

    DeviceObject - the device object which has been disabled

    Status       - the status of the disable request

    PowerIrp     - the power irp we are processing

Return Value:

    none

--*/

{
    PLOGICAL_UNIT_EXTENSION logicalUnit = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(PowerIrp);

    POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
    SYSTEM_POWER_STATE state = irpStack->Parameters.Power.State.SystemState;

    POWER_STATE powerState;

    ASSERT_PDO(DeviceObject);
    ASSERT(type == SystemPowerState);
    ASSERT(PowerIrp != NULL);

    DebugPrint((2, "SpSetTargetSystemStateLockedCompletion: DevObj %#p, "
                   "Status %#08lx PowerIrp %#p\n",
                DeviceObject, Status, PowerIrp));

    //
    // If the enable/disable failed then the power operation is obviously
    // unsuccessful.  Fail the power irp.
    //

    if(!NT_SUCCESS(Status)) {

        ASSERT(FALSE);

        PowerIrp->IoStatus.Status = Status;
        PoStartNextPowerIrp(PowerIrp);
        IoCompleteRequest(PowerIrp, IO_NO_INCREMENT);
        return;
    }

    SpAdjustDisabledBit(
        logicalUnit,
        (BOOLEAN) ((state == PowerSystemWorking) ? TRUE : FALSE));

    commonExtension->CurrentSystemState = state;

    DebugPrint((2, "SpSetTargetSystemStateLockedCompletion: new system state %d "
                   "set - desired device state is %d\n",
                state,
                commonExtension->DesiredDeviceState));

    //
    // Re-enable the logical unit.  We'll put it into the correct D state
    // after it's been turned back on.
    //

    SpEnableDisableLogicalUnit(logicalUnit,
                               TRUE,
                               SpSetTargetSystemStateUnlockedCompletion,
                               PowerIrp);

    return;
}


VOID
SpSetTargetSystemStateUnlockedCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PIRP PowerIrp
    )
/*++

Routine Description:

    This routine is called after the system state of the logical unit has been
    set and it has been re-enabled.  If the device has a desired power state
    or if it needs to be turned off (or on) for hibernation the power irp
    will be sent from here.

Arguments:

    DeviceObject - the logical unit which has been unlocked

    Status - the status of the unlock request

    PowerIrp - the original power irp.

Return Value:

    none

--*/
{
    PLOGICAL_UNIT_EXTENSION logicalUnit = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(PowerIrp);

    POWER_STATE_TYPE type = irpStack->Parameters.Power.Type;
    SYSTEM_POWER_STATE state = irpStack->Parameters.Power.State.SystemState;

    POWER_STATE powerState;

    ASSERT_PDO(DeviceObject);
    ASSERT(type == SystemPowerState);
    ASSERT(PowerIrp != NULL);

    DebugPrint((2, "SpSetTargetSystemStateUnlockedCompletion: DevObj %#p, "
                   "Status %#08lx PowerIrp %#p\n",
                DeviceObject, Status, PowerIrp));

    if(!NT_SUCCESS(Status)) {

        //
        // Oh dear - this device couldn't be re-enabled.  The logical unit is
        // useless until this can be done.
        //

        //
        // CODEWORK - figure out a way to deal with this case.
        //

        ASSERT(FALSE);
        PowerIrp->IoStatus.Status = Status;
        PoStartNextPowerIrp(PowerIrp);
        IoCompleteRequest(PowerIrp, IO_NO_INCREMENT);
        return;
    }

    if(state == PowerSystemWorking) {

        //
        // We're waking up the system.  Check to see if the device needs
        // to be powered immediately as well.
        //

        //
        // Power up - fire notifications.
        //

        powerState.SystemState = state;
        PoSetPowerState(DeviceObject,
                        SystemPowerState,
                        powerState);

        if(commonExtension->DesiredDeviceState != PowerDeviceUnspecified) {

            //
            // Request a power up of the target device now.  We'll complete
            // the system irp immediately without waiting for the device irp
            // to finish.
            //

            powerState.DeviceState = commonExtension->DesiredDeviceState;

            DebugPrint((1, "SpSetTargetSystemStateUnlockedCompletion: Target has "
                           "desired device state of %d - issuing irp to "
                           "request transition\n",
                        powerState.DeviceState));

            Status = PoRequestPowerIrp(DeviceObject,
                                       IRP_MN_SET_POWER,
                                       powerState,
                                       SpSetTargetDesiredPowerCompletion,
                                       NULL,
                                       NULL);

            ASSERT(Status == STATUS_PENDING);

        }

        if(Status != STATUS_PENDING) {
            PowerIrp->IoStatus.Status = Status;
        } else {
            PowerIrp->IoStatus.Status = STATUS_SUCCESS;
        }

        PoStartNextPowerIrp(PowerIrp);
        IoCompleteRequest(PowerIrp, IO_NO_INCREMENT);

    } else {

        //
        // We're going to put the device into a D state based on the current
        // S state.
        //

        DebugPrint((2, "SpSetTargetSystemStateUnlockedCompletion: power down "
                       "target for non-working system state "
                       "transition\n"));

        powerState.DeviceState = PowerDeviceD3;

        //
        // Request the appropriate D irp.  We'll block the S irp until the
        // D transition has been completed.
        //

        Status = PoRequestPowerIrp(
                    DeviceObject,
                    IRP_MN_SET_POWER,
                    powerState,
                    SpSetTargetDeviceStateForSystemStateCompletion,
                    PowerIrp,
                    NULL);

        if(!NT_SUCCESS(Status)) {

            //
            // STATUS_PENDING is still successful.
            //

            PowerIrp->IoStatus.Status = Status;
            PoStartNextPowerIrp(PowerIrp);
            IoCompleteRequest(PowerIrp, IO_NO_INCREMENT);
        }
    }
    return;
}


VOID
SpSetTargetDeviceStateForSystemStateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION irpStack;

    irpStack = IoGetCurrentIrpStackLocation(OriginalIrp);

    ASSERT_PDO(DeviceObject);

    ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);
    ASSERT(irpStack->Parameters.Power.State.SystemState != PowerSystemWorking);

    DebugPrint((2, "SpSetTargetDeviceStateForSystemCompletion: DevObj %#p, "
                   "Irp %#p, Status %#08lx\n",
                DeviceObject, OriginalIrp, IoStatus));

    OriginalIrp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp(OriginalIrp);
    IoCompleteRequest(OriginalIrp, IO_NO_INCREMENT);

    return;
}


VOID
SpRequestValidPowerStateCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PIO_STATUS_BLOCK IoStatus
    )
{

    //
    // re-enable the logical unit.  Don't bother with a completion routine
    // because there's nothing to do.
    //

    ASSERT(NT_SUCCESS(IoStatus->Status));
    SpEnableDisableLogicalUnit(LogicalUnit, TRUE, NULL, NULL);
    return;
}


NTSTATUS
SpRequestValidAdapterPowerStateSynchronous(
    IN PADAPTER_EXTENSION Adapter
    )
{
    PCOMMON_EXTENSION commonExtension = &(Adapter->CommonExtension);
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Interlock with other calls to this routine - there's no reason to have
    // several D0 irps in flight at any given time.
    //

    ExAcquireFastMutex(&(Adapter->PowerMutex));

    try {
        //
        // Check to see if we're already in a working state.  If so we can just
        // continue.
        //

        if((commonExtension->CurrentSystemState == PowerSystemWorking) &&
           (commonExtension->CurrentDeviceState == PowerDeviceD0)) {
            leave;
        }

        //
        // First check the system state.  If the device is in a non-working system
        // state then we'll need to block waiting for the system to wake up.
        //

        if(commonExtension->CurrentSystemState != PowerSystemWorking) {

            //
            // If we're not in a system working state then fail the attempt 
            // to set a new device state.  The caller should retry when the 
            // system is powered on.  Ideally we won't be getting requests 
            // which cause us to try and power up while the system is 
            // suspended.
            //

            status = STATUS_UNSUCCESSFUL;
            leave;
        }

        //
        // Request a power change request.
        //

        {
            POWER_STATE newAdapterState;
            SP_SIGNAL_POWER_COMPLETION_CONTEXT context;

            DebugPrint((1, "SpRequestValidAdapterPowerState: Requesting D0 power "
                           "irp for adapter %p\n", Adapter));

            newAdapterState.DeviceState = PowerDeviceD0;

            KeInitializeEvent(&(context.Event), SynchronizationEvent, FALSE);

            status = PoRequestPowerIrp(Adapter->DeviceObject,
                                       IRP_MN_SET_POWER,
                                       newAdapterState,
                                       SpSignalPowerCompletion,
                                       &context,
                                       NULL);

            if(status == STATUS_PENDING) {
                KeWaitForSingleObject(&(context.Event),
                                      KernelMode,
                                      Executive,
                                      FALSE,
                                      NULL);
            }

            status = context.Status;
            leave;
        }
    } finally {
        ExReleaseFastMutex(&(Adapter->PowerMutex));
    }

    return status;
}


VOID
SpSignalPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PSP_SIGNAL_POWER_COMPLETION_CONTEXT Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    Context->Status = IoStatus->Status;
    KeSetEvent(&(Context->Event), IO_NO_INCREMENT, FALSE);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\prop.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1998

Module Name:

    prop.c

Abstract:

    This is the NT SCSI port driver.  This module contains code relating to
    property queries

Authors:

    Peter Wieland

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

NTSTATUS
SpBuildDeviceDescriptor(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

NTSTATUS
SpBuildDeviceIdDescriptor(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

NTSTATUS
SpBuildAdapterDescriptor(
    IN PADAPTER_EXTENSION Adapter,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpBuildDeviceDescriptor)
#pragma alloc_text(PAGE, SpBuildDeviceIdDescriptor)
#pragma alloc_text(PAGE, SpBuildAdapterDescriptor)
#pragma alloc_text(PAGE, ScsiPortQueryProperty)
#pragma alloc_text(PAGE, ScsiPortQueryPropertyPdo)
#pragma alloc_text(PAGE, SpQueryDeviceText)
#endif


NTSTATUS
ScsiPortQueryPropertyPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    )

/*++

Routine Description:

    This routine will handle a property query request.  It will build the
    descriptor on it's own if possible, or it may forward the request down
    to lower level drivers.

    Since this routine may forward the request downwards the caller should
    not complete the irp

    This routine is asynchronous.
    This routine must be called at <= IRQL_DISPATCH
    This routine must be called with the remove lock held

Arguments:

    DeviceObject - a pointer to the device object being queried

    QueryIrp - a pointer to the irp for the query

Return Value:

    STATUS_PENDING if the request cannot be completed yet
    STATUS_SUCCESS if the query was successful

    STATUS_INVALID_PARAMETER_1 if the property id does not exist
    STATUS_INVALID_PARAMETER_2 if the query type is invalid
    STATUS_INVALID_PARAMETER_3 if an invalid optional parameter was passed

    STATUS_INVALID_DEVICE_REQUEST if this request cannot be handled by this
    device

    other error values as applicable

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(QueryIrp);
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PSTORAGE_PROPERTY_QUERY query = QueryIrp->AssociatedIrp.SystemBuffer;
    ULONG queryLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    BOOLEAN callDown = FALSE;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Make sure the caller has zeroed the Information field and that this is
    // a request to a target device.
    //

    ASSERT(QueryIrp->IoStatus.Information == 0);
    ASSERT(commonExtension->IsPdo);

    switch (query->PropertyId) {

        case StorageDeviceProperty: {

            if (query->QueryType == PropertyExistsQuery) {
                status = STATUS_SUCCESS;
            } else if (query->QueryType == PropertyStandardQuery) {
                status = SpBuildDeviceDescriptor(
                            (PLOGICAL_UNIT_EXTENSION) commonExtension,
                            QueryIrp->AssociatedIrp.SystemBuffer,
                            &queryLength);
                QueryIrp->IoStatus.Information = queryLength;
            } else {
                status = STATUS_INVALID_PARAMETER_1;
            }

            break;
        }

        case StorageAdapterProperty: {

            //
            // Forward it down to the underlying device object.  This lets 
            // filters do their magic.
            //

            callDown = TRUE;
            break;
        }

        case StorageDeviceIdProperty: {

            PLOGICAL_UNIT_EXTENSION logicalUnit;
            logicalUnit = DeviceObject->DeviceExtension;

            //
            // Check to see if we have a device identifier page.  If not then
            // fail any calls for this type of identifier.
            //

            if (logicalUnit->DeviceIdentifierPage != NULL) {
                if (query->QueryType == PropertyExistsQuery) {
                    status = STATUS_SUCCESS;
                } else if (query->QueryType == PropertyStandardQuery) {
                    status = SpBuildDeviceIdDescriptor(
                                logicalUnit,
                                QueryIrp->AssociatedIrp.SystemBuffer,
                                &queryLength);
                    QueryIrp->IoStatus.Information = queryLength;
                } else {
                    status = STATUS_INVALID_PARAMETER_1;
                }
            } else {
                status = STATUS_NOT_SUPPORTED;
            }

            break;
        }

        default: {

            //
            // Some filter beneath us may handle this property.
            //

            callDown = TRUE;
            break;
        }
    }

    if (callDown == TRUE) {
        IoSkipCurrentIrpStackLocation(QueryIrp);
        SpReleaseRemoveLock(DeviceObject, QueryIrp);
        status = IoCallDriver(commonExtension->LowerDeviceObject, QueryIrp);
    } else {
        if(status != STATUS_PENDING) {
            QueryIrp->IoStatus.Status = status;
            SpReleaseRemoveLock(DeviceObject, QueryIrp);
            SpCompleteRequest(DeviceObject, QueryIrp, NULL, IO_DISK_INCREMENT);
        }
    }

    return status;
}


NTSTATUS
ScsiPortQueryProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    )

/*++

Routine Description:

    This routine will handle a property query request.  It will build the
    descriptor on it's own if possible.

    This routine is synchronous.
    This routine must be called at <= IRQL_DISPATCH
    This routine must be called with the remove lock held

Arguments:

    DeviceObject - a pointer to the device object being queried

    QueryIrp - a pointer to the irp for the query

Return Value:

    STATUS_SUCCESS if the query was successful

    STATUS_INVALID_PARAMETER_1 if the property id does not exist
    STATUS_INVALID_PARAMETER_2 if the query type is invalid
    STATUS_INVALID_PARAMETER_3 if an invalid optional parameter was passed

    STATUS_INVALID_DEVICE_REQUEST if this request cannot be handled by this
    device

    other error values as applicable

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(QueryIrp);
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PSTORAGE_PROPERTY_QUERY query = QueryIrp->AssociatedIrp.SystemBuffer;
    ULONG queryLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Make sure the caller has zeroed the Information field.
    //

    ASSERT(!commonExtension->IsPdo);
    ASSERT(QueryIrp->IoStatus.Information == 0);

    //
    // Validate the QueryType.  We don't actually support mask queries.
    //

    if (query->QueryType >= PropertyMaskQuery) {
        status = STATUS_INVALID_PARAMETER_1;
        return status;
    }

    switch (query->PropertyId) {

        case StorageDeviceProperty: {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        case StorageAdapterProperty: {
            if (query->QueryType == PropertyExistsQuery) {
                status = STATUS_SUCCESS;
            } else {
                status = SpBuildAdapterDescriptor(
                            (PADAPTER_EXTENSION) commonExtension,
                            QueryIrp->AssociatedIrp.SystemBuffer,
                            &queryLength);
                QueryIrp->IoStatus.Information = queryLength;
            }
            break;
        }

        case StorageDeviceIdProperty: {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        default: {
            status = STATUS_INVALID_PARAMETER_1;
            break;
        }
    }

    return status;
}

NTSTATUS
SpBuildDeviceDescriptor(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )

/*++

Routine Description:

    This routine will create a device descriptor based on the information in
    it's device extension.  It will copy as much data as possible into
    the Descriptor and will update the DescriptorLength to indicate the
    number of bytes copied

Arguments:

    DeviceObject - a pointer to the PDO we are building a descriptor for

    Descriptor - a buffer to store the descriptor in

    DescriptorLength - the length of the buffer and the number of bytes
                       returned

    QueryIrp - unused

Return Value:

    status

--*/

{
    PSCSIPORT_DRIVER_EXTENSION driverExtension =
        IoGetDriverObjectExtension(LogicalUnit->DeviceObject->DriverObject,
                                   ScsiPortInitialize);

    LONG maxLength = *DescriptorLength;
    LONG bytesRemaining = maxLength;
    LONG realLength = sizeof(STORAGE_DEVICE_DESCRIPTOR);

    LONG serialNumberLength;

    PUCHAR currentOffset = (PUCHAR) Descriptor;

    LONG inquiryLength;

    PINQUIRYDATA inquiryData = &(LogicalUnit->InquiryData);

    STORAGE_DEVICE_DESCRIPTOR tmp;

    PAGED_CODE();

    ASSERT_PDO(LogicalUnit->DeviceObject);
    ASSERT(Descriptor != NULL);

    serialNumberLength = LogicalUnit->SerialNumber.Length + 1;

    //
    // Figure out what the total size of this structure is going to be.
    //

    inquiryLength = 4 + inquiryData->AdditionalLength;

    if(inquiryLength > INQUIRYDATABUFFERSIZE) {
        inquiryLength = INQUIRYDATABUFFERSIZE;
    }

    realLength += inquiryLength + 31;   // 31 = length of the 3 id strings +
                                        // 3 nuls

    //
    // Add the length of the serial number.
    //

    realLength += serialNumberLength;

    //
    // Zero the buffer provided using the length provided by the caller.
    //

    RtlZeroMemory(Descriptor, *DescriptorLength);

    //
    // Build the device descriptor structure on the stack then copy as much as
    // can be copied over
    //

    RtlZeroMemory(&tmp, sizeof(STORAGE_DEVICE_DESCRIPTOR));

    tmp.Version = sizeof(STORAGE_DEVICE_DESCRIPTOR);
    tmp.Size = realLength;
    tmp.DeviceType = inquiryData->DeviceType;
    tmp.DeviceTypeModifier = inquiryData->DeviceTypeModifier;
    tmp.RemovableMedia = inquiryData->RemovableMedia;
    tmp.CommandQueueing = inquiryData->CommandQueue;
    tmp.SerialNumberOffset = 0xffffffff;
    tmp.BusType = driverExtension->BusType;

    RtlCopyMemory(currentOffset,
                  &tmp,
                  min(sizeof(STORAGE_DEVICE_DESCRIPTOR), bytesRemaining));

    bytesRemaining -= sizeof(STORAGE_DEVICE_DESCRIPTOR);

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // Copy over as much inquiry data as we can and update the raw byte count
    //

    RtlCopyMemory(currentOffset, 
                  inquiryData, 
                  min(inquiryLength, bytesRemaining));

    bytesRemaining -= inquiryLength;

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        Descriptor->RawPropertiesLength = 
            maxLength - sizeof(STORAGE_DEVICE_DESCRIPTOR);
        return STATUS_SUCCESS;
    }

    Descriptor->RawPropertiesLength = inquiryLength;

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // Now we need to start copying inquiry strings
    //

    //
    // first the vendor id
    //

    RtlCopyMemory(currentOffset,
                  inquiryData->VendorId,
                  min(bytesRemaining, sizeof(UCHAR) * 8));

    bytesRemaining -= sizeof(UCHAR) * 9;     // include trailing null

    if(bytesRemaining >= 0) {

        Descriptor->VendorIdOffset = (ULONG)((ULONG_PTR) currentOffset -
                                      (ULONG_PTR) Descriptor);

    }

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // now the product id
    //

    RtlCopyMemory(currentOffset,
                  inquiryData->ProductId,
                  min(bytesRemaining, 16));
    bytesRemaining -= 17;                   // include trailing null

    if(bytesRemaining >= 0) {

        Descriptor->ProductIdOffset = (ULONG)((ULONG_PTR) currentOffset -
                                       (ULONG_PTR) Descriptor);
    }

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // And the product revision
    //

    RtlCopyMemory(currentOffset,
                  inquiryData->ProductRevisionLevel,
                  min(bytesRemaining, 4));
    bytesRemaining -= 5;

    if(bytesRemaining >= 0) {
        Descriptor->ProductRevisionOffset = (ULONG)((ULONG_PTR) currentOffset -
                                             (ULONG_PTR) Descriptor);
    }

    if(bytesRemaining <= 0) {
        *DescriptorLength = maxLength;
        return STATUS_SUCCESS;
    }

    currentOffset = ((PUCHAR) Descriptor) + (maxLength - bytesRemaining);

    //
    // If the device provides a SCSI serial number (vital product data page 80)
    // the report it.
    //

    if(LogicalUnit->SerialNumber.Length != 0) {

        //
        // And the product revision
        //

        RtlCopyMemory(currentOffset,
                      LogicalUnit->SerialNumber.Buffer,
                      min(bytesRemaining, serialNumberLength));
        bytesRemaining -= serialNumberLength;

        if(bytesRemaining >= 0) {
            Descriptor->SerialNumberOffset = (ULONG)((ULONG_PTR) currentOffset -
                                                     (ULONG_PTR) Descriptor);
        }

        if(bytesRemaining <= 0) {
            *DescriptorLength = maxLength;
            return STATUS_SUCCESS;
        }
    }

    *DescriptorLength = maxLength - bytesRemaining;
    return STATUS_SUCCESS;
}


NTSTATUS
SpBuildAdapterDescriptor(
    IN PADAPTER_EXTENSION Adapter,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )
{
    STORAGE_ADAPTER_DESCRIPTOR tmp;
    PIO_SCSI_CAPABILITIES capabilities = &(Adapter->Capabilities);
    PSCSIPORT_DRIVER_EXTENSION driverExtension;

    PAGED_CODE();

    ASSERT_FDO(Adapter->DeviceObject);
    
    driverExtension = IoGetDriverObjectExtension(
                          Adapter->DeviceObject->DriverObject,
                          ScsiPortInitialize);
    ASSERT(driverExtension != NULL);

    tmp.Version = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
    tmp.Size = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
    tmp.MaximumTransferLength = capabilities->MaximumTransferLength;
    tmp.MaximumPhysicalPages = capabilities->MaximumPhysicalPages;
    tmp.AlignmentMask = capabilities->AlignmentMask;
    tmp.AdapterUsesPio = capabilities->AdapterUsesPio;
    tmp.AdapterScansDown = capabilities->AdapterScansDown;
    tmp.CommandQueueing = capabilities->TaggedQueuing;
    tmp.AcceleratedTransfer = TRUE;
    tmp.BusType = (UCHAR) driverExtension->BusType;
    tmp.BusMajorVersion = 2;
    tmp.BusMinorVersion = 0;

    RtlCopyMemory(Descriptor,
                  &tmp,
                  min(*DescriptorLength, sizeof(STORAGE_ADAPTER_DESCRIPTOR)));

    *DescriptorLength = min(*DescriptorLength, 
                            sizeof(STORAGE_ADAPTER_DESCRIPTOR));

    return STATUS_SUCCESS;
}


NTSTATUS
SpQueryDeviceText(
    IN PDEVICE_OBJECT LogicalUnit,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    )

{
    PLOGICAL_UNIT_EXTENSION luExtension = LogicalUnit->DeviceExtension;

    UCHAR ansiBuffer[256];
    ANSI_STRING ansiText;

    UNICODE_STRING unicodeText;

    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString(&unicodeText, NULL);

    if(TextType == DeviceTextDescription) {

        PSCSIPORT_DEVICE_TYPE deviceInfo =
            SpGetDeviceTypeInfo(luExtension->InquiryData.DeviceType);

        PUCHAR c;
        LONG i;

        RtlZeroMemory(ansiBuffer, sizeof(ansiBuffer));
        RtlCopyMemory(ansiBuffer,
                      luExtension->InquiryData.VendorId,
                      sizeof(luExtension->InquiryData.VendorId));
        c = ansiBuffer;

        for(i = sizeof(luExtension->InquiryData.VendorId); i >= 0; i--) {
            if((c[i] != '\0') &&
               (c[i] != ' ')) {
                break;
            }
            c[i] = '\0';
        }
        c = &(c[i + 1]);

        sprintf(c, " ");
        c++;

        RtlCopyMemory(c,
                      luExtension->InquiryData.ProductId,
                      sizeof(luExtension->InquiryData.ProductId));

        for(i = sizeof(luExtension->InquiryData.ProductId); i >= 0; i--) {
            if((c[i] != '\0') &&
               (c[i] != ' ')) {
                break;
            }
            c[i] = '\0';
        }
        c = &(c[i + 1]);

        sprintf(c, " SCSI %s Device", deviceInfo->DeviceTypeString);

    } else if (TextType == DeviceTextLocationInformation) {

        sprintf(ansiBuffer, "Bus Number %d, Target ID %d, LUN %d",
                luExtension->PathId,
                luExtension->TargetId,
                luExtension->Lun);

    } else {

        return STATUS_NOT_SUPPORTED;
    }

    RtlInitAnsiString(&ansiText, ansiBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeText,
                                          &ansiText,
                                          TRUE);

    *DeviceText = unicodeText.Buffer;
    return status;
}

NTSTATUS
SpBuildDeviceIdDescriptor(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR Descriptor,
    IN OUT PULONG DescriptorLength
    )

/*++

Routine Description:

    This routine will create a device id descriptor based on the device
    identifier page retrieved during discovery.  It is an error to call this
    routine if no device identifier page exists.

    This routine will copy as much data as possible into the Descriptor and
    will update the DescriptorLength to indicate the number of bytes copied.

Arguments:

    DeviceObject - a pointer to the PDO we are building a descriptor for

    Descriptor - a buffer to store the descriptor in

    DescriptorLength - the length of the buffer and the number of bytes
                       returned

    QueryIrp - unused

Return Value:

    status

--*/

{
    PVPD_IDENTIFICATION_PAGE idPage = LogicalUnit->DeviceIdentifierPage;
    ULONG idOffset;

    ULONG maxLength = *DescriptorLength;
    PUCHAR destOffset;

    LONG identifierLength;
    ULONG identifierCount = 0;

    PAGED_CODE();

    ASSERT_PDO(LogicalUnit->DeviceObject);
    ASSERT(Descriptor != NULL);
    ASSERT(LogicalUnit->DeviceIdentifierPage != NULL);

    if(maxLength < sizeof(STORAGE_DESCRIPTOR_HEADER)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize the header of the descriptor.
    //

    RtlZeroMemory(Descriptor, *DescriptorLength);
    Descriptor->Version = sizeof(STORAGE_DEVICE_ID_DESCRIPTOR);
    Descriptor->Size = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);

    //
    // Prepare to copy the identifiers directly into the buffer.
    //

    destOffset = Descriptor->Identifiers;

    //
    // Walk through the id page.  Count the number of descriptors and
    // calculate the size of the descriptor page.
    //

    for(idOffset = 0; idOffset < idPage->PageLength;) {
        PVPD_IDENTIFICATION_DESCRIPTOR src;
        USHORT identifierSize;

        src = (PVPD_IDENTIFICATION_DESCRIPTOR) &(idPage->Descriptors[idOffset]);

        identifierSize = FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
        identifierSize += src->IdentifierLength;

        //
        // Align the identifier size to 32-bits.
        //

        identifierSize += sizeof(ULONG);
        identifierSize &= ~(sizeof(ULONG) - 1);

        identifierCount += 1;

        Descriptor->Size += identifierSize;

        if(Descriptor->Size <= maxLength) {
            PSTORAGE_IDENTIFIER dest;

            dest = (PSTORAGE_IDENTIFIER) destOffset;

            dest->CodeSet = src->CodeSet;
            dest->Type = src->IdentifierType;
            dest->Association = src->Association;

            dest->IdentifierSize = src->IdentifierLength;
            dest->NextOffset = identifierSize;

            RtlCopyMemory(dest->Identifier,
                          src->Identifier,
                          src->IdentifierLength);

            destOffset += dest->NextOffset;
        }

        idOffset += sizeof(PVPD_IDENTIFICATION_DESCRIPTOR);
        idOffset += src->IdentifierLength;
    }

    if(*DescriptorLength >= FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR,
                                        Identifiers)) {

        Descriptor->NumberOfIdentifiers = identifierCount;
    }

    *DescriptorLength = min(Descriptor->Size, *DescriptorLength);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\utils.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    port.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a dll for the kernel.

Revision History:

--*/

#include "port.h"

#if DBG
static const char *__file__ = __FILE__;
#endif

#define __FILE_ID__ 'util'

typedef struct SP_GUID_INTERFACE_MAPPING {
    GUID Guid;
    INTERFACE_TYPE InterfaceType;
} SP_GUID_INTERFACE_MAPPING, *PSP_GUID_INTERFACE_MAPPING;

PSP_GUID_INTERFACE_MAPPING SpGuidInterfaceMappingList = NULL;

VOID
SpProcessSpecialControllerList(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    IN HANDLE ListKey,
    OUT PSP_SPECIAL_CONTROLLER_FLAGS Flags
    );

VOID
SpProcessSpecialControllerFlags(
    IN HANDLE FlagsKey,
    OUT PSP_SPECIAL_CONTROLLER_FLAGS Flags
    );


NTSTATUS
ScsiPortBuildMultiString(
    IN PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING MultiString,
    ...
    );

NTSTATUS
SpMultiStringToStringArray(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING MultiString,
    OUT PWSTR *StringArray[],
    BOOLEAN Forward
    );

VOID
FASTCALL
SpFreeSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );

VOID
FASTCALL
SpFreeBypassSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortBuildMultiString)
#pragma alloc_text(PAGE, ScsiPortStringArrayToMultiString)
#pragma alloc_text(PAGE, SpMultiStringToStringArray)
#pragma alloc_text(PAGE, RtlDuplicateCmResourceList)
#pragma alloc_text(PAGE, RtlSizeOfCmResourceList)
#pragma alloc_text(PAGE, SpTranslateResources)
#pragma alloc_text(PAGE, SpCheckSpecialDeviceFlags)
#pragma alloc_text(PAGE, SpProcessSpecialControllerList)
#pragma alloc_text(PAGE, SpProcessSpecialControllerFlags)
#pragma alloc_text(PAGE, SpAllocateTagBitMap)
#pragma alloc_text(PAGE, SpGetPdoInterfaceType)
#pragma alloc_text(PAGE, SpReadNumericInstanceValue)
#pragma alloc_text(PAGE, SpWriteNumericInstanceValue)
#pragma alloc_text(PAGE, SpReleaseMappedAddresses)
#pragma alloc_text(PAGE, SpInitializeGuidInterfaceMapping)
#pragma alloc_text(PAGE, SpSendIrpSynchronous)
#pragma alloc_text(PAGE, SpGetBusTypeGuid)
#pragma alloc_text(PAGE, SpDetermine64BitSupport)
#pragma alloc_text(PAGE, SpReadNumericValue)
#pragma alloc_text(PAGE, SpAllocateAddressMapping)
#pragma alloc_text(PAGE, SpPreallocateAddressMapping)
#pragma alloc_text(PAGE, SpPurgeFreeMappedAddressList)
#pragma alloc_text(PAGE, SpFreeMappedAddress)
#endif


NTSTATUS
SpInitializeGuidInterfaceMapping(
    IN PDRIVER_OBJECT DriverObject
    )
{
    ULONG size;

    PAGED_CODE();

    ASSERT(SpGuidInterfaceMappingList == NULL);

    size = sizeof(SP_GUID_INTERFACE_MAPPING) * 5;

    SpGuidInterfaceMappingList = SpAllocatePool(PagedPool,
                                                size,
                                                SCSIPORT_TAG_INTERFACE_MAPPING,
                                                DriverObject);

    if(SpGuidInterfaceMappingList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(SpGuidInterfaceMappingList, size);

    SpGuidInterfaceMappingList[0].Guid = GUID_BUS_TYPE_PCMCIA;
    SpGuidInterfaceMappingList[0].InterfaceType = Isa;

    SpGuidInterfaceMappingList[1].Guid = GUID_BUS_TYPE_PCI;
    SpGuidInterfaceMappingList[1].InterfaceType = PCIBus;

    SpGuidInterfaceMappingList[2].Guid = GUID_BUS_TYPE_ISAPNP;
    SpGuidInterfaceMappingList[2].InterfaceType = Isa;

    SpGuidInterfaceMappingList[3].Guid = GUID_BUS_TYPE_EISA;
    SpGuidInterfaceMappingList[3].InterfaceType = Eisa;

    SpGuidInterfaceMappingList[4].InterfaceType = InterfaceTypeUndefined;

    return STATUS_SUCCESS;
}


NTSTATUS
ScsiPortBuildMultiString(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING MultiString,
    ...
    )

/*++

Routine Description:

    This routine will take a null terminated list of ascii strings and combine
    them together into a unicode multi-string block.

    This routine allocates memory for the string buffer - is the caller's
    responsibility to free it.

Arguments:

    MultiString - a UNICODE_STRING structure into which the multi string will
                  be built.

    ... - a NULL terminated list of narrow strings which will be combined
          together.  This list may not be empty.

Return Value:

    status

--*/

{
    PCSTR rawEntry;
    ANSI_STRING ansiEntry;

    UNICODE_STRING unicodeEntry;
    PWSTR unicodeLocation;

    ULONG multiLength = 0;

    NTSTATUS status;

    va_list ap;

    va_start(ap, MultiString);

    PAGED_CODE();

    //
    // Make sure we aren't going to leak any memory
    //

    ASSERT(MultiString->Buffer == NULL);

    rawEntry = va_arg(ap, PCSTR);

    while(rawEntry != NULL) {

        RtlInitAnsiString(&ansiEntry, rawEntry);

        multiLength += RtlAnsiStringToUnicodeSize(&ansiEntry);

        rawEntry = va_arg(ap, PCSTR);

    }

    ASSERT(multiLength != 0);

    multiLength += sizeof(WCHAR);

    MultiString->Buffer = SpAllocatePool(PagedPool,
                                         multiLength,
                                         SCSIPORT_TAG_PNP_ID,
                                         DriverObject);

    if(MultiString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    unicodeEntry.Buffer = MultiString->Buffer;
    unicodeEntry.MaximumLength = (USHORT) multiLength;

    va_start(ap, MultiString);

    rawEntry = va_arg(ap, PCSTR);

    while(rawEntry != NULL) {


        RtlInitAnsiString(&ansiEntry, rawEntry);

        status = RtlAnsiStringToUnicodeString(
                    &unicodeEntry,
                    &ansiEntry,
                    FALSE);

        //
        // Since we're not allocating any memory the only failure possible
        // is if this function is bad
        //

        ASSERT(NT_SUCCESS(status));

        //
        // Push the buffer location up and reduce the maximum count
        //

        ((PSTR) unicodeEntry.Buffer) += unicodeEntry.Length + sizeof(WCHAR);
        unicodeEntry.MaximumLength -= unicodeEntry.Length + sizeof(WCHAR);

        rawEntry = va_arg(ap, PCSTR);

    };

    ASSERT(unicodeEntry.MaximumLength == sizeof(WCHAR));

    //
    // Stick the final NUL on the end of the multisz
    //

    RtlZeroMemory(unicodeEntry.Buffer, unicodeEntry.MaximumLength);

    return STATUS_SUCCESS;

}

NTSTATUS
ScsiPortStringArrayToMultiString(
    IN PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING MultiString,
    PCSTR StringArray[]
    )

/*++

Routine Description:

    This routine will take a null terminated array of ascii strings and merge
    them together into a unicode multi-string block.

    This routine allocates memory for the string buffer - is the caller's
    responsibility to free it.

Arguments:

    MultiString - a UNICODE_STRING structure into which the multi string will
                  be built.

    StringArray - a NULL terminated list of narrow strings which will be combined
                  together.  This list may not be empty.

Return Value:

    status

--*/

{
    ANSI_STRING ansiEntry;

    UNICODE_STRING unicodeEntry;
    PWSTR unicodeLocation;

    UCHAR i;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Make sure we aren't going to leak any memory
    //

    ASSERT(MultiString->Buffer == NULL);

    RtlInitUnicodeString(MultiString, NULL);

    for(i = 0; StringArray[i] != NULL; i++) {

        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        MultiString->Length += (USHORT) RtlAnsiStringToUnicodeSize(&ansiEntry);
    }

    ASSERT(MultiString->Length != 0);

    MultiString->MaximumLength = MultiString->Length + sizeof(UNICODE_NULL);

    MultiString->Buffer = SpAllocatePool(PagedPool,
                                         MultiString->MaximumLength,
                                         SCSIPORT_TAG_PNP_ID,
                                         DriverObject);

    if(MultiString->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlZeroMemory(MultiString->Buffer, MultiString->MaximumLength);

    unicodeEntry = *MultiString;

    for(i = 0; StringArray[i] != NULL; i++) {

        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        status = RtlAnsiStringToUnicodeString(
                    &unicodeEntry,
                    &ansiEntry,
                    FALSE);

        //
        // Since we're not allocating any memory the only failure possible
        // is if this function is bad
        //

        ASSERT(NT_SUCCESS(status));

        //
        // Push the buffer location up and reduce the maximum count
        //

        ((PSTR) unicodeEntry.Buffer) += unicodeEntry.Length + sizeof(WCHAR);
        unicodeEntry.MaximumLength -= unicodeEntry.Length + sizeof(WCHAR);

    };

    return STATUS_SUCCESS;
}


NTSTATUS
SpMultiStringToStringArray(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING MultiString,
    OUT PWSTR *StringArray[],
    BOOLEAN Forward
    )

{
    ULONG stringCount = 0;
    ULONG stringNumber;
    ULONG i;
    PWSTR *stringArray;

    PAGED_CODE();

    //
    // Pass one: count the number of string elements.
    //

    for(i = 0; i < (MultiString->MaximumLength / sizeof(WCHAR)); i++) {
        if(MultiString->Buffer[i] == UNICODE_NULL) {
            stringCount++;
        }
    }

    //
    // Allocate the memory for a NULL-terminated string array.
    //

    stringArray = SpAllocatePool(PagedPool,
                                 (stringCount + 1) * sizeof(PWSTR),
                                 SCSIPORT_TAG_PNP_ID,
                                 DriverObject);

    if(stringArray == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(stringArray, (stringCount + 1) * sizeof(PWSTR));

    //
    // Pass two : Put the string pointers in place.
    //

    i = 0;

    for(stringNumber = 0; stringNumber < stringCount; stringNumber++) {

        ULONG arrayNumber;

        if(Forward) {
            arrayNumber = stringNumber;
        } else {
            arrayNumber = stringCount - stringNumber - 1;
        }

        //
        // Put a pointer to the head of the string into the array.
        //

        stringArray[arrayNumber] = &MultiString->Buffer[i];

        //
        // Scan for the end of the string.
        //

        while((i < (MultiString->MaximumLength / sizeof(WCHAR))) &&
              (MultiString->Buffer[i] != UNICODE_NULL)) {
            i++;
        }

        //
        // Jump past the NULL.
        //

        i++;
    }

    *StringArray = stringArray;
    return STATUS_SUCCESS;
}

PCM_RESOURCE_LIST
RtlDuplicateCmResourceList(
    IN PDRIVER_OBJECT DriverObject,
    POOL_TYPE PoolType,
    PCM_RESOURCE_LIST ResourceList,
    ULONG Tag
    )

/*++

Routine Description:

    This routine will attempt to allocate memory to copy the supplied
    resource list.  If sufficient memory cannot be allocated then the routine
    will return NULL.

Arguments:

    PoolType - the type of pool to allocate the duplicate from

    ResourceList - the resource list to be copied

    Tag - a value to tag the memory allocation with.  If 0 then untagged
          memory will be allocated.

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/

{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    PVOID buffer;

    PAGED_CODE();

    size = RtlSizeOfCmResourceList(ResourceList);

    buffer = SpAllocatePool(PoolType, 
                            size, 
                            Tag,
                            DriverObject);

    if (buffer != NULL) {
        RtlCopyMemory(buffer,
                      ResourceList,
                      size);
    }

    return buffer;
}

ULONG
RtlSizeOfCmResourceList(
    IN PCM_RESOURCE_LIST ResourceList
    )

/*++

Routine Description:

    This routine returns the size of a CM_RESOURCE_LIST.

Arguments:

    ResourceList - the resource list to be copied

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/

{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    ULONG i;

    PAGED_CODE();

    for(i = 0; i < ResourceList->Count; i++) {

        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor = &(ResourceList->List[i]);
        ULONG j;

        //
        // First descriptor is included in the size of the resource list.
        //

        if(i != 0) {
            size += sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
        }

        for(j = 0; j < fullDescriptor->PartialResourceList.Count; j++) {

            //
            // First descriptor is included in the size of the partial list.
            //

            if(j != 0) {
                size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
            }
        }
    }

    return size;
}

#if !defined(NO_LEGACY_DRIVERS)

BOOLEAN
SpTranslateResources(
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST AllocatedResources,
    OUT PCM_RESOURCE_LIST *TranslatedResources
    )

/*++

Routine Description:

    This routine will call into the Hal to translate any recognizable resources
    in the AllocatedResources list.  This routine allocates the space for the
    translated list - the caller is responsible for freeing this buffer.

    If any errors occur the TranslatedResources will be NULL and the routine
    will return FALSE.

Arguments:

    AllocatedResources - The list of resources to be translated.

    TranslatedResources - A location to store the translated resources.  There
                          will be a one to one mapping between translated and
                          untranslated.  Any non-standard resource types will
                          be blindly copied.

Return Value:

    TRUE if all resources were translated properly.

    FALSE otherwise.

--*/

{
    PCM_RESOURCE_LIST list;

    ULONG listNumber;

    PAGED_CODE();

    (*TranslatedResources) = NULL;

    list = RtlDuplicateCmResourceList(DriverObject,
                                      NonPagedPool,
                                      AllocatedResources,
                                      SCSIPORT_TAG_RESOURCE_LIST);

    if(list == NULL) {
        return FALSE;
    }

    for(listNumber = 0; listNumber < list->Count; listNumber++) {

        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor;
        ULONG resourceNumber;

        fullDescriptor = &(list->List[listNumber]);

        for(resourceNumber = 0;
            resourceNumber < fullDescriptor->PartialResourceList.Count;
            resourceNumber++) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;
            CM_PARTIAL_RESOURCE_DESCRIPTOR tmp;

            partialDescriptor =
                &(fullDescriptor->PartialResourceList.PartialDescriptors[resourceNumber]);

            switch(partialDescriptor->Type) {

                case CmResourceTypePort:
                case CmResourceTypeMemory: {

                    ULONG addressSpace;

                    if(partialDescriptor->Type == CmResourceTypePort) {
                        addressSpace = 1;
                    } else {
                        addressSpace = 0;
                    }

                    tmp = *partialDescriptor;

                    if(HalTranslateBusAddress(
                            fullDescriptor->InterfaceType,
                            fullDescriptor->BusNumber,
                            partialDescriptor->u.Generic.Start,
                            &addressSpace,
                            &(tmp.u.Generic.Start))) {

                        tmp.Type = (addressSpace == 0) ? CmResourceTypeMemory :
                                                         CmResourceTypePort;

                    } else {

                        ExFreePool(list);
                        return FALSE;
                    }

                    break;
                }

                case CmResourceTypeInterrupt: {

                    tmp = *partialDescriptor;

                    tmp.u.Interrupt.Vector =
                        HalGetInterruptVector(
                            fullDescriptor->InterfaceType,
                            fullDescriptor->BusNumber,
                            partialDescriptor->u.Interrupt.Level,
                            partialDescriptor->u.Interrupt.Vector,
                            &((UCHAR) tmp.u.Interrupt.Level),
                            &(tmp.u.Interrupt.Affinity));

                    if(tmp.u.Interrupt.Affinity == 0) {

                        //
                        // Translation failed.
                        //

                        ExFreePool(list);
                        return FALSE;
                    }

                    break;
                }

            };

            *partialDescriptor = tmp;
        }
    }

    *TranslatedResources = list;
    return TRUE;
}
#endif // NO_LEGACY_DRIVERS


BOOLEAN
SpFindAddressTranslation(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS RangeStart,
    IN ULONG RangeLength,
    IN BOOLEAN InIoSpace,
    IN OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Translation
    )

/*++

Routine Description:

    This routine will search the resource lists in the AdapterExtension to
    translate the given memory or i/o range using the resources provided by
    pnp or the Hal.

Arguments:

    AdapterExtesnion - the device extension for the adapter making the request

    RangeStart - the starting address of the memory range

    RangeLength - the number of bytes in the memory range

    InIoSpace - whether the untranslated range is in io or memory space.

Return Value:

    a pointer to a partial resource descriptor describing the proper range to
    be used or NULL if no matching range of sufficient length can be found.

--*/

{
    PCM_RESOURCE_LIST list;

    ULONG listNumber;

    list = AdapterExtension->AllocatedResources;

    ASSERT(!AdapterExtension->IsMiniportDetected);
    ASSERT(AdapterExtension->AllocatedResources);
    ASSERT(AdapterExtension->TranslatedResources);

    for(listNumber = 0; listNumber < list->Count; listNumber++) {

        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor;
        ULONG resourceNumber;

        fullDescriptor = &(list->List[listNumber]);

        if((fullDescriptor->InterfaceType != BusType) ||
           (fullDescriptor->BusNumber != BusNumber)) {
            continue;
        }

        for(resourceNumber = 0;
            resourceNumber < fullDescriptor->PartialResourceList.Count;
            resourceNumber++) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;

            UCHAR desiredType =
                InIoSpace ? CmResourceTypePort : CmResourceTypeMemory;

            partialDescriptor =
                &(fullDescriptor->PartialResourceList.PartialDescriptors[resourceNumber]);

            if(partialDescriptor->Type == desiredType) {

                ULONGLONG requestedStart = (ULONGLONG) RangeStart.QuadPart;
                ULONGLONG requestedEnd =
                    ((ULONGLONG) RangeStart.QuadPart) + RangeLength;

                ULONGLONG testStart =
                    (ULONGLONG) partialDescriptor->u.Generic.Start.QuadPart;
                ULONGLONG testEnd =
                    testStart + partialDescriptor->u.Generic.Length;

                ULONGLONG requestedOffset = requestedStart - testStart;

                ULONG rangeOffset;

                //
                // Make sure the base address is within the current range.
                //

                if((requestedStart < testStart) ||
                   (requestedStart >= testEnd)) {
                    continue;
                }

                //
                // Make sure the end of the requested range is within this
                // descriptor.
                //

                if(requestedEnd > testEnd) {
                    continue;
                }

                //
                // We seem to have found a match.  Copy the equivalent resource
                // in the translated resource list.
                //

                *Translation =
                    AdapterExtension->TranslatedResources->List[listNumber].
                        PartialResourceList.PartialDescriptors[resourceNumber];

                //
                // Return an offset into the translated range equivalent to the
                // offset in the untranslated range.
                //

                requestedStart = Translation->u.Generic.Start.QuadPart;
                requestedStart += requestedOffset;

                Translation->u.Generic.Start.QuadPart = requestedStart;

                return TRUE;

            };

        }
    }

    return FALSE;
}


NTSTATUS
SpLockUnlockQueue(
    IN PDEVICE_OBJECT LogicalUnit,
    IN BOOLEAN LockQueue,
    IN BOOLEAN BypassLockedQueue
    )

/*++

Routine Description:

    This routine will lock or unlock the logical unit queue.

    This routine is synchronous.

Arguments:

    LogicalUnit - the logical unit to be locked or unlocked

    LockQueue - whether the queue should be locked or unlocked

    BypassLockedQueue - whether the operation should bypass other locks or
                        whether it should sit in the queue.  Must be true for
                        unlock requests.

Return Value:

    STATUS_SUCCESS if the operation was successful

    error status otherwise.

--*/

{
    PLOGICAL_UNIT_EXTENSION luExtension = LogicalUnit->DeviceExtension;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PKEVENT event = NULL;

    NTSTATUS status;

    ASSERTMSG("Must bypass locked queue when unlocking: ",
              (LockQueue || BypassLockedQueue));

    DebugPrint((1, "SpLockUnlockQueue: %sing queue for logical unit extension "
                   "%#p\n",
                LockQueue ? "Lock" : "Unlock",
                luExtension));

    //
    // Build an IRP to send to the logical unit.  We need one stack
    // location for our completion routine and one for the irp to be
    // processed with.  This irp should never be dispatched to the
    //

    irp = SpAllocateIrp((CCHAR) (LogicalUnit->StackSize + 1),
                        FALSE,
                        LogicalUnit->DriverObject);

    if(irp == NULL) {
        DebugPrint((1, "SpLockUnlockQueue: Couldn't allocate IRP\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        srb = SpAllocatePool(NonPagedPool,
                             sizeof(SCSI_REQUEST_BLOCK),
                             SCSIPORT_TAG_ENABLE,
                             LogicalUnit->DriverObject);

        if(srb == NULL) {

            DebugPrint((1, "SpLockUnlockQueue: Couldn't allocate SRB\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        event = SpAllocatePool(NonPagedPool,
                               sizeof(KEVENT),
                               SCSIPORT_TAG_EVENT,
                               LogicalUnit->DriverObject);

        if(event == NULL) {

            DebugPrint((1, "SpLockUnlockQueue: Couldn't allocate Context\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        KeInitializeEvent(event, NotificationEvent, FALSE);

        srb->Length = sizeof(SCSI_REQUEST_BLOCK);

        srb->Function = LockQueue ? SRB_FUNCTION_LOCK_QUEUE :
                                    SRB_FUNCTION_UNLOCK_QUEUE;

        srb->OriginalRequest = irp;
        srb->DataBuffer = NULL;

        srb->QueueTag = SP_UNTAGGED;

        if(BypassLockedQueue) {
            srb->SrbFlags |= SRB_FLAGS_BYPASS_LOCKED_QUEUE;
        }

        IoSetCompletionRoutine(irp,
                               SpSignalCompletion,
                               event,
                               TRUE,
                               TRUE,
                               TRUE);

        irpStack = IoGetNextIrpStackLocation(irp);

        irpStack->Parameters.Scsi.Srb = srb;
        irpStack->MajorFunction = IRP_MJ_SCSI;

        status = IoCallDriver(LogicalUnit, irp);

        if(status == STATUS_PENDING) {

            KeWaitForSingleObject(event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = irp->IoStatus.Status;
        }

    } finally {

        if(irp != NULL) {
            IoFreeIrp(irp);
        }

        if(srb != NULL) {
            ExFreePool(srb);
        }

        if(event != NULL) {
            ExFreePool(event);
        }

    }

    return status;
}


NTSTATUS
SpCheckSpecialDeviceFlags(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PINQUIRYDATA InquiryData
    )

/*++

Routine Description:

    This routine will check the registry to determine what sort of special
    handling a target device requires.  If there is a device-node then the
    routine will check under the device parameters for this particular logical
    unit.

    If there is no device node for the logical unit the hardware id will be
    looked up (first) under the devnode for the adapter or (if not found) the
    bad controller list stored under the scsiport Control key.

    The flags tested for include (this list should be updated as more are
    added):

        * OneLun    - used to keep from enumerating past LUN 0 on a particular
                      device.
        * SparseLun - used to indicate the device may have holes in the LUN
                      numbers.
        * NonStandardVPD - used to indicate that a target does not support VPD 0x00
                           but does support VPD 0x80 and 0x83.
        * BinarySN  - used to indicate that the target supplied a binary
                      serial number and that we need to convert it to ascii.



    These values are REG_DWORD's.  REG_NULL can be used to return a value
    to it's default.

Arguments:

    LogicalUnit - the logical unit

    InquiryData - the inquiry data retreived for the lun

Return Value:

    status

--*/

{
    HANDLE baseKey = NULL;
    HANDLE listKey = NULL;
    HANDLE entryKey = NULL;

    UNICODE_STRING keyName;
    OBJECT_ATTRIBUTES objectAttributes;

    SP_SPECIAL_CONTROLLER_FLAGS flags = {
        0,                                   // SparseLun
        0,                                   // OneLun
        0,                                   // LargeLuns   
        0,                                   // SetLunInCdb
        0,                                   // NonStandardVPD
        0                                    // BinarySN
    };

    NTSTATUS status;

    PAGED_CODE();

    DebugPrint((1, "SpCheckSpecialDeviceFlags - checking flags for %#p\n",
                LogicalUnit));

    //
    // Check the bad controller list in the scsiport control key
    //

    try {

        DebugPrint((2, "SpCheckSpecialDeviceFlags - trying control list\n"));

        RtlInitUnicodeString(&keyName,
                             SCSIPORT_CONTROL_KEY SCSIPORT_SPECIAL_TARGET_KEY);

        InitializeObjectAttributes(&objectAttributes,
                                   &keyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        status = ZwOpenKey(&listKey,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {
            DebugPrint((2, "SpCheckSpecialDeviceFlags - error %#08lx opening "
                           "key %wZ\n",
                        status,
                        &keyName));
            leave;
        }

        SpProcessSpecialControllerList(
            LogicalUnit->DeviceObject->DriverObject,
            InquiryData, 
            listKey, 
            &flags);

    } finally {

        if(listKey != NULL) {
            ZwClose(listKey);
            listKey = NULL;
        }
    }

    //
    // Next check the special list in the adapter's devnode.
    //

    try {

        PDEVICE_OBJECT adapterPdo = LogicalUnit->AdapterExtension->LowerPdo;

        DebugPrint((2, "SpCheckSpecialDeviceFlags - trying adapter list\n"));

        status = IoOpenDeviceRegistryKey(adapterPdo,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         KEY_READ,
                                         &baseKey);

        if(!NT_SUCCESS(status)) {

            DebugPrint((2, "SpCheckSpecialDeviceFlags - error %#08lx opening "
                           "adapter devnode key\n", status));
            leave;
        }

        RtlInitUnicodeString(&keyName,
                             L"ScsiPort\\" SCSIPORT_SPECIAL_TARGET_KEY);

        InitializeObjectAttributes(&objectAttributes,
                                   &keyName,
                                   OBJ_CASE_INSENSITIVE,
                                   baseKey,
                                   NULL);

        status = ZwOpenKey(&listKey,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {
            DebugPrint((2, "SpCheckSpecialDeviceFlags - error %#08lx opening "
                           "adapter devnode key %wZ\n", status, &keyName));
            leave;
        }

        SpProcessSpecialControllerList(
            LogicalUnit->DeviceObject->DriverObject,
            InquiryData, 
            listKey, 
            &flags);

    } finally {

        if(baseKey != NULL) {
            ZwClose(baseKey);
            baseKey = NULL;

            if(listKey != NULL) {
                ZwClose(listKey);
                listKey = NULL;
            }
        }
    }

    //
    // Finally check the devnode (if any) for the logical unit.  This one is
    // special - the hardware id already matchs so the key just contains the
    // values to be used, not a database of values.
    //

    try {

        status = IoOpenDeviceRegistryKey(LogicalUnit->CommonExtension.DeviceObject,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         KEY_READ,
                                         &baseKey);

        if(!NT_SUCCESS(status)) {
            DebugPrint((2, "SpCheckSpecialDeviceFlags - error %#08lx opening "
                           "device devnode key\n", status));
            leave;
        }

        RtlInitUnicodeString(&keyName,
                             L"ScsiPort\\" SCSIPORT_SPECIAL_TARGET_KEY);

        InitializeObjectAttributes(&objectAttributes,
                                   &keyName,
                                   OBJ_CASE_INSENSITIVE,
                                   baseKey,
                                   NULL);

        status = ZwOpenKey(&listKey,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {
            DebugPrint((2, "SpCheckSpecialDeviceFlags - error %#08lx opening "
                           "device devnode key %wZ\n", status, &keyName));
            leave;
        }

        SpProcessSpecialControllerFlags(listKey, &flags);

    } finally {
        if(baseKey != NULL) {
            ZwClose(baseKey);
            baseKey = NULL;

            if(listKey != NULL) {
                ZwClose(listKey);
                listKey = NULL;
            }
        }
    }

    LogicalUnit->SpecialFlags = flags;

    return STATUS_SUCCESS;
}

VOID
SpProcessSpecialControllerList(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    IN HANDLE ListKey,
    OUT PSP_SPECIAL_CONTROLLER_FLAGS Flags
    )

/*++

Routine Description:

    This routine will match the specified logical unit to a set of special
    controller flags stored in the registry key ListKey.  These flags will
    be written into the Flags structure, overwriting any flags which already
    exist.

    If no logical unit is provided then the ListKey handle is assumed to point
    at the appropriate list entry and the values stored there will be copied
    into the Flags structure.

Arguments:

    InquiryData - The inquiry data for the logical unit.  This is used to
                  match strings in the special target list.

    ListKey - a handle to the special controller list to locate the logical
              unit in, or a handle to a list of flags if the LogicalUnit value
              is not present.

    Flags - a location to store the flags.

Return Value:

    None

--*/

{
    UNICODE_STRING hardwareIds;
    PWSTR *hardwareIdList;

    ULONG idNumber;

    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString(&hardwareIds, NULL);

    status = ScsiPortGetHardwareIds(DriverObject, InquiryData, &hardwareIds);

    if(!NT_SUCCESS(status)) {
        DebugPrint((2, "SpProcessSpecialControllerList: Error %#08lx getting "
                       "hardware id's\n", status));
        return;
    }

    status = SpMultiStringToStringArray(DriverObject,
                                        &hardwareIds,
                                        &hardwareIdList,
                                        FALSE);

    if(!NT_SUCCESS(status)) {
        RtlFreeUnicodeString(&hardwareIds);
        return;
    }

    for(idNumber = 0; hardwareIdList[idNumber] != NULL; idNumber++) {

        PWSTR hardwareId = hardwareIdList[idNumber];
        ULONG j;
        UNICODE_STRING keyName;
        OBJECT_ATTRIBUTES objectAttributes;
        HANDLE flagsKey;

        DebugPrint((2, "SpProcessSpecialControllerList: processing id %ws\n",
                    hardwareId));

        //
        // Remove the leading slash from the name.
        //

        for(j = 0; hardwareId[j] != UNICODE_NULL; j++) {
            if(hardwareId[j] == L'\\') {
                hardwareId = &(hardwareId[j+1]);
                break;
            }
        }

        //
        // Process the hardware id that we just found the end of.
        //

        RtlInitUnicodeString(&keyName, hardwareId);

        DebugPrint((2, "SpProcessSpecialControllerList: Finding match for "
                       "%wZ - id %d\n", &keyName, idNumber));

        InitializeObjectAttributes(&objectAttributes,
                                   &keyName,
                                   OBJ_CASE_INSENSITIVE,
                                   ListKey,
                                   NULL);

        status = ZwOpenKey(&flagsKey,
                           KEY_READ,
                           &objectAttributes);

        if(NT_SUCCESS(status)) {
            SpProcessSpecialControllerFlags(flagsKey, Flags);
            ZwClose(flagsKey);
        } else {
            DebugPrint((2, "SpProcessSpecialControllerList: Error %#08lx "
                           "opening key\n", status));
        }

    }

    ExFreePool(hardwareIdList);
    RtlFreeUnicodeString(&hardwareIds);

    return;
}


VOID
SpProcessSpecialControllerFlags(
    IN HANDLE FlagsKey,
    OUT PSP_SPECIAL_CONTROLLER_FLAGS Flags
    )
{
    RTL_QUERY_REGISTRY_TABLE queryTable[7];
    NTSTATUS status;

    PAGED_CODE();

    RtlZeroMemory(queryTable, sizeof(queryTable));

    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = L"SparseLUN";
    queryTable[0].EntryContext = &(Flags->SparseLun);

    queryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[1].Name = L"OneLUN";
    queryTable[1].EntryContext = &(Flags->OneLun);

    queryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[2].Name = L"LargeLuns";
    queryTable[2].EntryContext = &(Flags->LargeLuns);

    queryTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[3].Name = L"SetLunInCdb";
    queryTable[3].EntryContext = &(Flags->SetLunInCdb);

    queryTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[4].Name = L"NonStandardVPD";
    queryTable[4].EntryContext = &(Flags->NonStandardVPD);

    queryTable[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[5].Name = L"BinarySN";
    queryTable[5].EntryContext = &(Flags->BinarySN);

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    FlagsKey,
                                    queryTable,
                                    NULL,
                                    NULL);

    if(!NT_SUCCESS(status)) {
        DebugPrint((2, "SpProcssSpecialControllerFlags: Error %#08lx reading "
                       "values\n", status));
    } else {
        DebugPrint((2, "SpProcessSpecialControllerFlags: %s%s%s%s%s\n",
                    ((Flags->SparseLun ||
                      Flags->OneLun ||
                      Flags->LargeLuns ||
                      Flags->SetLunInCdb ||
                      Flags->NonStandardVPD ||
                      Flags->BinarySN) ? "" : "none"),
                    (Flags->SparseLun ? "SparseLun " : ""),
                    (Flags->OneLun ? "OneLun " : ""),
                    (Flags->LargeLuns ? "LargeLuns " : ""),
                    (Flags->SetLunInCdb ? "SetLunInCdb" : ""),
                    (Flags->NonStandardVPD ? "NonStandardVPD" : ""),
                    (Flags->BinarySN ? "BinarySN" : "")));
    }

    return;
}


PSRB_DATA
FASTCALL
SpAllocateSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN OPTIONAL PIRP Request,
    IN OPTIONAL PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

{
    PSRB_DATA srbData;

    srbData = ExAllocateFromNPagedLookasideList(
                &Adapter->SrbDataLookasideList);

#if TEST_LISTS
    if(srbData != NULL) {
        InterlockedIncrement64(&Adapter->SrbDataAllocationCount);
    }
#endif

    if((srbData == NULL) && (Request != NULL)) {

        KIRQL oldIrql;
        PSRB_DATA emergencySrbData;

        //
        // Use the emergency srb data if it's not already in use.
        //

        KeAcquireSpinLock(&Adapter->EmergencySrbDataSpinLock,
                          &oldIrql);

        emergencySrbData =
            (PSRB_DATA) InterlockedExchangePointer(
                            (PVOID) &(Adapter->EmergencySrbData),
                            NULL);

        if(emergencySrbData == NULL) {

            if(LogicalUnit == NULL ) {
             
                //
                // It's in use - queue the request until an srb data block
                // goes free.
                //

                InsertTailList(
                    &Adapter->SrbDataBlockedRequests,
                    &Request->Tail.Overlay.DeviceQueueEntry.DeviceListEntry);

            } else {
                
                if( LogicalUnit->BlockedLogicalUnit == NULL ){
                    LogicalUnit->BlockedLogicalUnit = Adapter->BlockedLogicalUnit; 
                    Adapter->BlockedLogicalUnit = LogicalUnit;
                }
                
                InsertTailList(
                    &LogicalUnit->SrbDataBlockedRequests,
                    &Request->Tail.Overlay.DeviceQueueEntry.DeviceListEntry);
            }

        } else {

            //
            // There is an SRB_DATA block available after all.
            //

            srbData = emergencySrbData;

#if TEST_LISTS
            InterlockedIncrement64(&Adapter->SrbDataEmergencyFreeCount);
#endif

        }

        KeReleaseSpinLock(&Adapter->EmergencySrbDataSpinLock,
                          oldIrql);
    }

    return srbData;
}


VOID
FASTCALL
SpFreeSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    )

{
    PSRB_DATA emergencySrbData = NULL;
    BOOLEAN startedRequest = FALSE;
    LONG depth;
    BOOLEAN Inserted ;

    ASSERT_SRB_DATA(SrbData);
    ASSERT(SrbData->CurrentIrp == NULL);
    ASSERT(SrbData->CurrentSrb == NULL);
    ASSERT(SrbData->CompletedRequests == NULL);

    //
    // Determine if there are any other instances of this routine running.  If
    // there are, don't start a blocked request.
    //

    depth = InterlockedIncrement(&Adapter->SrbDataFreeRunning);

    //
    // Clear out some of the flags so we don't get confused when we reuse this
    // request.
    //

    SrbData->Flags = 0;

    //
    // See if we need to store away a new emergency SRB_DATA block
    //

    emergencySrbData = InterlockedCompareExchangePointer(
                           &(Adapter->EmergencySrbData),
                           SrbData,
                           NULL);

    //
    // If we stored this SRB_DATA block as the new emergency block AND if this
    // routine is not recursively nested, check if there are any blocked
    // requests waiting to be started.
    //

    if(emergencySrbData == NULL && depth == 1) {

        KIRQL oldIrql;

CheckForBlockedRequest:

        //
        // We did - now grab the spinlock and see if we can use it to issue
        // a new request.
        //

        KeAcquireSpinLock(&(Adapter->EmergencySrbDataSpinLock), &oldIrql);

        //
        // First check to see if we have a request to process.
        //

        if( IsListEmpty(&(Adapter->SrbDataBlockedRequests)) ) {

            Inserted = SpTransferBlockedRequestsToAdapter(Adapter);
            if(!Inserted) {
                KeReleaseSpinLock(&(Adapter->EmergencySrbDataSpinLock), oldIrql);
                InterlockedDecrement(&Adapter->SrbDataFreeRunning);
                return;
            }

        }

        //
        // make sure the emergency request is still there (doesn't really
        // matter if it's the one we were called with or another one - just
        // make sure one is available).
        //

        emergencySrbData = (PSRB_DATA)
                            InterlockedExchangePointer(
                                (PVOID) &(Adapter->EmergencySrbData),
                                NULL);

        if(emergencySrbData == NULL) {

            //
            // Our work here is done.
            //

            KeReleaseSpinLock(&(Adapter->EmergencySrbDataSpinLock), oldIrql);
            InterlockedDecrement(&Adapter->SrbDataFreeRunning);
            return;

        } else {
            PIRP request;
            PIO_STACK_LOCATION currentIrpStack;
            PSCSI_REQUEST_BLOCK srb;
            PLIST_ENTRY entry;

            entry = RemoveHeadList(&(Adapter->SrbDataBlockedRequests));

            ASSERT(entry != NULL);

            request =
                CONTAINING_RECORD(
                    entry,
                    IRP,
                    Tail.Overlay.DeviceQueueEntry);

            KeReleaseSpinLock(&(Adapter->EmergencySrbDataSpinLock), oldIrql);

            currentIrpStack = IoGetCurrentIrpStackLocation(request);
            srb = currentIrpStack->Parameters.Scsi.Srb;

            ASSERT_PDO(currentIrpStack->DeviceObject);

            emergencySrbData->CurrentIrp = request;
            emergencySrbData->CurrentSrb = srb;
            emergencySrbData->LogicalUnit =
                currentIrpStack->DeviceObject->DeviceExtension;
            
            srb->OriginalRequest = emergencySrbData;

            startedRequest = TRUE;
            SpDispatchRequest(emergencySrbData->LogicalUnit,
                              request);

#if TEST_LISTS
            InterlockedIncrement64(&Adapter->SrbDataResurrectionCount);
#endif
        }

        //
        // If we started a blocked request, go back and see if another one
        // needs to be started.
        //
        
        if (startedRequest == TRUE) {
            startedRequest = FALSE;
            goto CheckForBlockedRequest;
        }

    } else if (emergencySrbData != NULL) {

        //
        // We did not store this SRB_DATA block as the emergency block, so
        // we need to free it back to the lookaside list.
        //

        ExFreeToNPagedLookasideList(
            &Adapter->SrbDataLookasideList,
            SrbData);
    }

    InterlockedDecrement(&Adapter->SrbDataFreeRunning);   
    return;
}

PVOID
SpAllocateSrbDataBackend(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG AdapterIndex
    )

{
    KIRQL oldIrql;
    PADAPTER_EXTENSION Adapter;
    PSRB_DATA srbData;
    ULONG tag;

    KeAcquireSpinLock(&ScsiGlobalAdapterListSpinLock, &oldIrql);

    Adapter = ScsiGlobalAdapterList[AdapterIndex]->DeviceExtension;

    KeReleaseSpinLock(&ScsiGlobalAdapterListSpinLock, oldIrql);

    ASSERT_FDO(Adapter->DeviceObject);

    tag = SpAllocateQueueTag(Adapter);

    if(tag == -1) {
        return NULL;
    }

    srbData = SpAllocatePool(PoolType,
                             NumberOfBytes,
                             SCSIPORT_TAG_SRB_DATA,
                             Adapter->DeviceObject->DriverObject);

    if(srbData == NULL) {
        SpReleaseQueueTag(Adapter, tag);
        return NULL;
    }

    RtlZeroMemory(srbData, sizeof(SRB_DATA));
    srbData->Adapter = Adapter;
    srbData->QueueTag = tag;
    srbData->Type = SRB_DATA_TYPE;
    srbData->Size = sizeof(SRB_DATA);
    srbData->Flags = 0;
    srbData->FreeRoutine = SpFreeSrbData;

    return srbData;
}

VOID
SpFreeSrbDataBackend(
    IN PSRB_DATA SrbData
    )
{
    ASSERT_SRB_DATA(SrbData);
    ASSERT_FDO(SrbData->Adapter->DeviceObject);
    ASSERT(SrbData->QueueTag != 0);

    SpReleaseQueueTag(SrbData->Adapter, SrbData->QueueTag);
    SrbData->Type = 0;
    ExFreePool(SrbData);
    return;
}


NTSTATUS
SpAllocateTagBitMap(
    IN PADAPTER_EXTENSION Adapter
    )

{
    ULONG size;         // number of bits
    PRTL_BITMAP bitMap;

    PAGED_CODE();

    //
    // Initialize the queue tag bitMap.
    //

    if(Adapter->MaxQueueTag == 0) {
#if SMALL_QUEUE_TAG_BITMAP
        if(Adapter->NumberOfRequests <= 240) {
            Adapter->MaxQueueTag = (UCHAR) (Adapter->NumberOfRequests) + 10;
        } else {
            Adapter->MaxQueueTag = 254;
        }
#else
        Adapter->MaxQueueTag = 254;
#endif
    } else if (Adapter->MaxQueueTag < Adapter->NumberOfRequests) {
        DbgPrint("SpAllocateTagBitmap: MaxQueueTag %d < NumberOfRequests %d\n"
                 "This will negate the advantage of having increased the "
                 "number of requests.\n",
                 Adapter->MaxQueueTag,
                 Adapter->NumberOfRequests);
    }

    DebugPrint((1, "SpAllocateAdapterResources: %d bits in queue tag "
                   "bitMap\n",
                Adapter->MaxQueueTag));

    size = (Adapter->MaxQueueTag + 1);
    size /= 8;
    size += 1;
    size *= sizeof(UCHAR);
    size += sizeof(RTL_BITMAP);

    bitMap = SpAllocatePool(NonPagedPool,
                            size,
                            SCSIPORT_TAG_QUEUE_BITMAP,
                            Adapter->DeviceObject->DriverObject);

    if(bitMap == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeBitMap(bitMap,
                        (PULONG) (bitMap + 1),
                        Adapter->MaxQueueTag);

    RtlClearAllBits(bitMap);

    //
    // Queue tag 0 is invalid and should never be returned by the allocator.
    //

    RtlSetBits(bitMap, 0, 1);

    Adapter->QueueTagBitMap = bitMap;
    Adapter->QueueTagHint = 1;

    //
    // Create a spinlock to protect our queue tag bitmap.  There's no reason
    // for this to contend with the regular port spinlock.
    //

    KeInitializeSpinLock(&(Adapter->QueueTagSpinLock));

    return STATUS_SUCCESS;
}

ULONG
SpAllocateQueueTag(
    IN PADAPTER_EXTENSION Adapter
    )
{
    KIRQL oldIrql;
    ULONG tagValue;

    ASSERT_FDO(Adapter->DeviceObject);

    KeAcquireSpinLock(&(Adapter->QueueTagSpinLock), &oldIrql);

    //
    // Find an available queue tag.
    //

    tagValue = RtlFindClearBitsAndSet(Adapter->QueueTagBitMap,
                                      1,
                                      Adapter->QueueTagHint);

    KeReleaseSpinLock(&(Adapter->QueueTagSpinLock), oldIrql);

    ASSERT(Adapter->QueueTagHint < Adapter->MaxQueueTag);
    ASSERT(tagValue != 0);

    if(tagValue != -1) {

        ASSERT(tagValue <= Adapter->MaxQueueTag);

        //
        // This we can do unsynchronized.  if we nuke the hint accidentally it
        // will just increase the cost of the next lookup which should
        // hopefully occur rarely.
        //

        Adapter->QueueTagHint = (tagValue + 1) % Adapter->MaxQueueTag;
    }

    return tagValue;
}

VOID
SpReleaseQueueTag(
    IN PADAPTER_EXTENSION Adapter,
    IN ULONG QueueTag
    )
{
    KIRQL oldIrql;

    KeAcquireSpinLock(&(Adapter->QueueTagSpinLock), &oldIrql);
    RtlClearBits(Adapter->QueueTagBitMap,
                 QueueTag,
                 1);
    KeReleaseSpinLock(&(Adapter->QueueTagSpinLock), oldIrql);
    return;
}


INTERFACE_TYPE
SpGetPdoInterfaceType(
    IN PDEVICE_OBJECT Pdo
    )
{
    ULONG value;

    GUID busTypeGuid;
    INTERFACE_TYPE interfaceType = InterfaceTypeUndefined;
    ULONG result;

    NTSTATUS status;

    PAGED_CODE();

    status = SpReadNumericInstanceValue(Pdo,
                                        L"LegacyInterfaceType",
                                        &value);

    if(NT_SUCCESS(status)) {
        interfaceType = value;
        return interfaceType;
    }

    //
    // Attempt to get and interpret the bus type GUID.
    //

    status = IoGetDeviceProperty(Pdo,
                                 DevicePropertyBusTypeGuid,
                                 sizeof(GUID),
                                 &busTypeGuid,
                                 &result);

    if(NT_SUCCESS(status)) {

        ULONG i;

        for(i = 0;
            (SpGuidInterfaceMappingList[i].InterfaceType !=
             InterfaceTypeUndefined);
            i++) {

            if(RtlEqualMemory(&(SpGuidInterfaceMappingList[i].Guid),
                              &busTypeGuid,
                              sizeof(GUID))) {

                //
                // We have a legacy interface type for this guid already.
                //

                interfaceType = SpGuidInterfaceMappingList[i].InterfaceType;
                break;
            }
        }
    }

    if(interfaceType != InterfaceTypeUndefined) {
        return interfaceType;
    }

    status = IoGetDeviceProperty(Pdo,
                                 DevicePropertyLegacyBusType,
                                 sizeof(INTERFACE_TYPE),
                                 &interfaceType,
                                 &result);

    if(NT_SUCCESS(status)) {
        ASSERT(result == sizeof(INTERFACE_TYPE));

        //
        // Munge the interface type for the case of PCMCIA cards to allow SCSI
        // pccards (i.e. sparrow) to be recognized. Much better would be a way
        // to get the interface type correct before we enter this routine.
        //

        if (interfaceType == PCMCIABus) {
            interfaceType = Isa;
        }

    }

    if(interfaceType != InterfaceTypeUndefined) {

        return interfaceType;

    } else {

        //
        // No idea what the interface type is - guess isa.
        //

        DebugPrint((1, "SpGetPdoInterfaceType: Status %#08lx getting legacy "
                       "bus type - assuming device is ISA\n", status));
        return Isa;
    }
}


NTSTATUS
SpReadNumericInstanceValue(
    IN PDEVICE_OBJECT Pdo,
    IN PWSTR ValueName,
    OUT PULONG Value
    )
{
    ULONG value;

    HANDLE baseKey = NULL;
    HANDLE scsiportKey = NULL;

    NTSTATUS status;

    PAGED_CODE();

    ASSERT(Value != NULL);
    ASSERT(ValueName != NULL);
    ASSERT(Pdo != NULL);

    status = IoOpenDeviceRegistryKey(Pdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ,
                                     &baseKey);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    try {
        UNICODE_STRING unicodeKeyName;
        OBJECT_ATTRIBUTES objectAttributes;

        RtlInitUnicodeString(&unicodeKeyName, L"Scsiport");
        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   baseKey,
                                   NULL);

        status = ZwOpenKey(&scsiportKey,
                           KEY_READ,
                           &objectAttributes);

        if(!NT_SUCCESS(status)) {
            leave;
        } else {
            UNICODE_STRING unicodeValueName;

            UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];

            PKEY_VALUE_PARTIAL_INFORMATION keyValue =
                (PKEY_VALUE_PARTIAL_INFORMATION) buffer;

            ULONG result;

            RtlInitUnicodeString(&unicodeValueName, ValueName);

            status = ZwQueryValueKey(scsiportKey,
                                     &unicodeValueName,
                                     KeyValuePartialInformation,
                                     keyValue,
                                     sizeof(buffer),
                                     &result);

            if(!NT_SUCCESS(status)) {
                leave;
            }

            if(keyValue->Type != REG_DWORD) {
                status = STATUS_OBJECT_TYPE_MISMATCH;
                leave;
            }

            if(result < sizeof(ULONG)) {
                status = STATUS_OBJECT_TYPE_MISMATCH;
                leave;
            }

            value = ((PULONG) (keyValue->Data))[0];
        }

    } finally {
        if(baseKey != NULL) {ZwClose(baseKey);}
        if(scsiportKey != NULL) {ZwClose(scsiportKey);}
    }

    *Value = value;
    return status;
}


NTSTATUS
SpWriteNumericInstanceValue(
    IN PDEVICE_OBJECT Pdo,
    IN PWSTR ValueName,
    IN ULONG Value
    )
{
    ULONG value;

    HANDLE baseKey = NULL;
    HANDLE scsiportKey = NULL;

    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName != NULL);
    ASSERT(Pdo != NULL);

    status = IoOpenDeviceRegistryKey(Pdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ | KEY_WRITE,
                                     &baseKey);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    try {
        UNICODE_STRING unicodeKeyName;
        OBJECT_ATTRIBUTES objectAttributes;

        RtlInitUnicodeString(&unicodeKeyName, L"Scsiport");
        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   baseKey,
                                   NULL);

        status = ZwCreateKey(&scsiportKey,
                             KEY_READ | KEY_WRITE,
                             &objectAttributes,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             NULL
                             );

        if(!NT_SUCCESS(status)) {
            leave;
        } else {
            UNICODE_STRING unicodeValueName;

            ULONG result;

            RtlInitUnicodeString(&unicodeValueName, ValueName);

            status = ZwSetValueKey(scsiportKey,
                                   &unicodeValueName,
                                   0,
                                   REG_DWORD,
                                   &Value,
                                   sizeof(ULONG));

        }

    } finally {
        if(baseKey != NULL) {ZwClose(baseKey);}
        if(scsiportKey != NULL) {ZwClose(scsiportKey);}
    }

    return status;
}


PMAPPED_ADDRESS
SpAllocateAddressMapping(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will attempt to allocate a free address mapping block and 
    place it on the adapter's MappedAddressList.  If there is an available 
    block in the free list then it will be used.  Otherwise it will attempt 
    to allocate a block from non-paged pool.

Arguments:

    Adapter - the adapter we are allocating the mapping for.

    Preallocate - indicates that the caller is trying to preallocate buffers.
                  
    
Return Value:

    a pointer to the new mapping (which has been inserted into the address 
    mapping list) or NULL if none could be allocated.
    
--*/            
{
    PMAPPED_ADDRESS mapping;

    PAGED_CODE();

    //
    // First check the free address mapping list.  If there's one there 
    // unlink it and return.
    //

    if(Adapter->FreeMappedAddressList != NULL) {
        mapping = Adapter->FreeMappedAddressList;
        Adapter->FreeMappedAddressList = mapping->NextMappedAddress;
    } else {
        mapping = SpAllocatePool(NonPagedPool,
                                 sizeof(MAPPED_ADDRESS),
                                 SCSIPORT_TAG_MAPPING_LIST,
                                 Adapter->DeviceObject->DriverObject);
    }

    if(mapping == NULL) {
        DebugPrint((0, "SpAllocateAddressMapping: Unable to allocate "
                       "mapping\n"));

        return NULL;
    }

    RtlZeroMemory(mapping, sizeof(MAPPED_ADDRESS));

    mapping->NextMappedAddress = Adapter->MappedAddressList;
    Adapter->MappedAddressList = mapping;

    return mapping;
}

BOOLEAN
SpPreallocateAddressMapping(
    PADAPTER_EXTENSION Adapter,
    IN UCHAR NumberOfBlocks
    )
/*++

Routine Description:

    This routine will allocate a number of address mapping structures and 
    place them on the free mapped address list.

Arguments:

    Adapter - the adapter we are allocating the mapping for.

    NumberOfBlocks - the number of blocks to allocate
                  
    
Return Value:

    TRUE if the requested number of blocks was successfully allocated, 

    FALSE if there was not sufficient memory to allocate them all.  The caller 
          is still responsible for freeing them in this case.
    
--*/            
{
    PMAPPED_ADDRESS mapping;
    ULONG i;

    PAGED_CODE();

    for(i = 0; i < NumberOfBlocks; i++) {
        mapping = SpAllocatePool(NonPagedPool,
                                 sizeof(MAPPED_ADDRESS),
                                 SCSIPORT_TAG_MAPPING_LIST,
                                 Adapter->DeviceObject->DriverObject);

        if(mapping == NULL) {

            return FALSE;
        }

        RtlZeroMemory(mapping, sizeof(MAPPED_ADDRESS));

        mapping->NextMappedAddress = Adapter->FreeMappedAddressList;
        Adapter->FreeMappedAddressList = mapping;
    }

    return TRUE;
}

VOID
SpPurgeFreeMappedAddressList(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:
    
    This routine frees all of the mapped address blocks on the 
    FreeMappedAddressList.
   
Arguments:

    Adapter - the adapter who's FreeMappedAddressList is to be dumped.
    
Return Value:

    none

--*/    
{
    PMAPPED_ADDRESS mapping;

    PAGED_CODE();

    while(Adapter->FreeMappedAddressList != NULL) {
        mapping = Adapter->FreeMappedAddressList;
        Adapter->FreeMappedAddressList = mapping->NextMappedAddress;

        ExFreePool(mapping);
    }
    return;
}


BOOLEAN
SpFreeMappedAddress(
    IN PADAPTER_EXTENSION Adapter,
    IN PVOID MappedAddress
    )
/*++

Routine Description:

    This routine will unmap the specified mapping and then return the mapping
    block to the free list.  If no mapped address was specified then this 
    will simply free the first mapping on the MappedAddressList.

Arguments:

    Adapter - the adapter which has the mapping
    
    MappedAddress - the base address of the mapping we're attempting to free.
                    ignored if FreeSpecificBlock is false.
                    
Return Value:

    TRUE if a matching list element was found.
    FALSE otherwise.
    
--*/
{
    PMAPPED_ADDRESS *mapping;

    PAGED_CODE();

    for(mapping = &(Adapter->MappedAddressList);
        *mapping != NULL;
        mapping = &((*mapping)->NextMappedAddress)) {

        if((*mapping)->MappedAddress == MappedAddress) {
    
            PMAPPED_ADDRESS tmp = *mapping;

            //
            // Unmap address.
            //
    
            MmUnmapIoSpace(tmp->MappedAddress, tmp->NumberOfBytes);

            //
            // Unlink this entry from the mapped address list.  Stick it on 
            // the free mapped address list.  Then return.
            //

            *mapping = tmp->NextMappedAddress;

            tmp->NextMappedAddress = Adapter->FreeMappedAddressList;
            Adapter->FreeMappedAddressList = tmp;

            return TRUE;
        }
    }

    return FALSE;
}

PMAPPED_ADDRESS
SpFindMappedAddress(
    IN PADAPTER_EXTENSION Adapter,
    IN LARGE_INTEGER IoAddress,
    IN ULONG NumberOfBytes,
    IN ULONG SystemIoBusNumber
    )
{
    PMAPPED_ADDRESS mapping;

    for(mapping = Adapter->MappedAddressList;
        mapping != NULL;
        mapping = mapping->NextMappedAddress) {

        if((mapping->IoAddress.QuadPart == IoAddress.QuadPart) && 
           (mapping->NumberOfBytes == NumberOfBytes) && 
           (mapping->BusNumber == SystemIoBusNumber)) {
            return mapping;
        }
    }
    return NULL;
}


VOID
SpReleaseMappedAddresses(
    IN PADAPTER_EXTENSION Adapter
    )
{
    ULONG i;

    PAGED_CODE();

    //
    // Iterate through the mapped address list and punt every entry onto the 
    // free list.
    //

    while(Adapter->MappedAddressList != NULL) {
        SpFreeMappedAddress(Adapter, Adapter->MappedAddressList->MappedAddress);
    }

    //
    // Now dump the free list.
    //

    SpPurgeFreeMappedAddressList(Adapter);

    return;
}


NTSTATUS
SpSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SpSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    KEVENT event;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           SpSignalCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    IoCallDriver(DeviceObject, Irp);

    KeWaitForSingleObject(&event,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    return Irp->IoStatus.Status;
}


NTSTATUS
SpGetBusTypeGuid(
    IN PADAPTER_EXTENSION Adapter
    )
{
    ULONG result;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Grab the bus interface GUID and save it away in the adapter extension.
    //

    status = IoGetDeviceProperty(Adapter->LowerPdo,
                                 DevicePropertyBusTypeGuid,
                                 sizeof(GUID),
                                 &(Adapter->BusTypeGuid),
                                 &result);

    if(!NT_SUCCESS(status)) {
        RtlZeroMemory(&(Adapter->BusTypeGuid), sizeof(GUID));
    }

    return status;
}


BOOLEAN
SpDetermine64BitSupport(
    VOID
    )
/*++

Routine Description:

    This routine determines if 64-bit physical addressing is supported by
    the system to be saved in the global Sp64BitPhysicalAddressing.  Eventually
    this routine can be removed and the scsiport global will just point to the
    one exported by MM.  However the global isn't hooked up for PAE36 at the
    moment so we need to do some x86 specific tricks.

Arguments:

    none

Return Value:

    Does the system support 64-bit (or something over 32-bit) addresses?

--*/

{
    PAGED_CODE();

    if((*Mm64BitPhysicalAddress) == TRUE) {
        DbgPrintEx(DPFLTR_SCSIPORT_ID,
                   DPFLTR_INFO_LEVEL,
                   "SpDetermine64BitSupport: Mm64BitPhysicalAddress is TRUE\n");

        return TRUE;
    }

    return FALSE;
}

VOID
SpAdjustDisabledBit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Enable
    )
{
    ULONG newCount;
    KIRQL oldIrql;

    KeAcquireSpinLock(&(LogicalUnit->AdapterExtension->SpinLock), &oldIrql);
    if(Enable) {
        if(LogicalUnit->QueuePauseCount != 0) {
            LogicalUnit->QueuePauseCount -= 1;
        }

        if(LogicalUnit->QueuePauseCount == 0) {
            CLEAR_FLAG(LogicalUnit->LuFlags, LU_QUEUE_PAUSED);
        }
    } else {
        LogicalUnit->QueuePauseCount += 1;
        SET_FLAG(LogicalUnit->LuFlags, LU_QUEUE_PAUSED);
    }
    KeReleaseSpinLock(&(LogicalUnit->AdapterExtension->SpinLock), oldIrql);
    return;
}

NTSTATUS
SpReadNumericValue(
    IN OPTIONAL HANDLE Root,
    IN OPTIONAL PUNICODE_STRING KeyName,
    IN PUNICODE_STRING ValueName,
    OUT PULONG Value
    )
/*++

Routine Description:

    This routine will read a REG_DWORD value from the specified registry
    location.  The caller can specify the key by providing a handle to a root
    registry key and the name of a subkey.

    The caller must supply either Root or KeyName.  Both may be supplied.

Arguments:

    Root - the key the value resides in (if KeyName is NULL), a parent
           key of the one the value resides in, or NULL if KeyName specifies
           the entire registry path.

    KeyName - the name of the subkey (either from the root of the registry or
              from the key specified in Root.

    ValueName - the name of the value to be read

    Value - returns the value in the key.  this will be zero if an error occurs

Return Value:

    STATUS_SUCCESS if successful.
    STATUS_UNSUCCESSFUL if the specified value is not a REG_DWORD value.
    other status values explaining the cause of the failure.

--*/

{
    ULONG value = 0;

    HANDLE key = Root;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(Value != NULL);
    ASSERT(ValueName != NULL);

    ASSERT((KeyName != NULL) || (Root != NULL));

    if(ARGUMENT_PRESENT(KeyName)) {
        OBJECT_ATTRIBUTES objectAttributes;

        InitializeObjectAttributes(&(objectAttributes),
                                   KeyName,
                                   OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                   Root,
                                   NULL);

        status = ZwOpenKey(&(key), KEY_QUERY_VALUE, &objectAttributes);
    }

    if(NT_SUCCESS(status)) {
        UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
        PKEY_VALUE_PARTIAL_INFORMATION data;
        ULONG result;

        RtlZeroMemory(buffer, sizeof(buffer));
        data = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;

        status = ZwQueryValueKey(key,
                                 ValueName,
                                 KeyValuePartialInformation,
                                 data,
                                 sizeof(buffer),
                                 &result);

        if(NT_SUCCESS(status)) {
            if (data->Type != REG_DWORD) {
                status = STATUS_UNSUCCESSFUL;
            } else {
                value = ((PULONG) data->Data)[0];
            }
        }
    }

    *Value = value;

    if(key != Root) {
        ZwClose(key);
    }

    return status;
}


PMDL
SpBuildMdlForMappedTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDMA_ADAPTER AdapterObject,
    IN PMDL OriginalMdl,
    IN PVOID StartVa,
    IN ULONG ByteCount,
    IN PSRB_SCATTER_GATHER ScatterGatherList,
    IN ULONG ScatterGatherEntries
    )
{
    ULONG size;
    PMDL mdl;

    ULONG pageCount;

    PPFN_NUMBER pages;
    ULONG sgPage;
    ULONG mdlPage;
    ULONG sgSpan;

    mdl = SpAllocateMdl(StartVa,
                        ByteCount,
                        FALSE,
                        FALSE,
                        NULL,
                        DeviceObject->DriverObject);

    if (mdl == NULL) {
        return NULL;
    }

    pageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(StartVa, ByteCount);

    //
    // Indicate that the memory has already been locked down.
    //

    //
    // Indicate that the memory is "I/O space" so that MM doesn't won't 
    // reference the (nonexistent) PFNs for this buffer.  We have to do this 
    // for the time being because MM isn't aware of the pages the HAL is using 
    // for bounce buffers.
    //

    SET_FLAG(mdl->MdlFlags, MDL_PAGES_LOCKED | MDL_IO_SPACE);

    //
    // Run through our scatter gather list and build the page list based
    // on that.
    //

    pages = (PPFN_NUMBER) (mdl + 1);

    for(sgPage = 0, mdlPage = 0; sgPage < ScatterGatherEntries; sgPage++) {

        PVOID pa;
        ULONG sgLength;

        ASSERT(ScatterGatherList[sgPage].Length != 0);

        pa = (PVOID) ScatterGatherList[sgPage].Address.QuadPart;

        sgLength =
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(pa, 
                                           ScatterGatherList[sgPage].Length);

        for(sgSpan = 0; sgSpan < sgLength; sgSpan++, mdlPage++) {
            ULONGLONG pageAddr;
            pageAddr = ScatterGatherList[sgPage].Address.QuadPart;
            pageAddr += sgSpan * PAGE_SIZE;
            pageAddr >>= PAGE_SHIFT;
            pages[mdlPage] = (PFN_NUMBER) (pageAddr);
        }
    }
    pages = (PPFN_NUMBER) (mdl + 1);
    pages = (PPFN_NUMBER) (OriginalMdl + 1);

    ASSERT(mdlPage == pageCount);

    return mdl;
}

#if defined(FORWARD_PROGRESS)
VOID
SpPrepareMdlForMappedTransfer(
    IN PMDL mdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDMA_ADAPTER AdapterObject,
    IN PMDL OriginalMdl,
    IN PVOID StartVa,
    IN ULONG ByteCount,
    IN PSRB_SCATTER_GATHER ScatterGatherList,
    IN ULONG ScatterGatherEntries
    )
{
    ULONG size;

    ULONG pageCount;

    PPFN_NUMBER pages;
    ULONG sgPage;
    ULONG mdlPage;
    ULONG sgSpan;

    pageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(StartVa, ByteCount);

    //
    // Indicate that the memory has already been locked down.
    //

    //
    // Indicate that the memory is "I/O space" so that MM doesn't won't 
    // reference the (nonexistent) PFNs for this buffer.  We have to do this 
    // for the time being because MM isn't aware of the pages the HAL is using 
    // for bounce buffers.
    //

    SET_FLAG(mdl->MdlFlags, MDL_PAGES_LOCKED | MDL_IO_SPACE);

    //
    // Run through our scatter gather list and build the page list based
    // on that.
    //

    pages = (PPFN_NUMBER) (mdl + 1);

    for(sgPage = 0, mdlPage = 0; sgPage < ScatterGatherEntries; sgPage++) {

        PVOID pa;
        ULONG sgLength;

        ASSERT(ScatterGatherList[sgPage].Length != 0);

        pa = (PVOID) ScatterGatherList[sgPage].Address.QuadPart;

        sgLength =
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(pa, 
                                           ScatterGatherList[sgPage].Length);

        for(sgSpan = 0; sgSpan < sgLength; sgSpan++, mdlPage++) {
            ULONGLONG pageAddr;
            pageAddr = ScatterGatherList[sgPage].Address.QuadPart;
            pageAddr += sgSpan * PAGE_SIZE;
            pageAddr >>= PAGE_SHIFT;
            pages[mdlPage] = (PFN_NUMBER) (pageAddr);
        }
    }
    pages = (PPFN_NUMBER) (mdl + 1);
    pages = (PPFN_NUMBER) (OriginalMdl + 1);

    ASSERT(mdlPage == pageCount);
}
#endif

PSRB_DATA
FASTCALL
SpAllocateBypassSrbData(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    PSLIST_ENTRY entry;
    PSRB_DATA srbData;

    entry = ExInterlockedPopEntrySList(&(LogicalUnit->BypassSrbDataList),
                                       &(LogicalUnit->BypassSrbDataSpinLock));

    if(entry == NULL) {
        KeBugCheckEx(PORT_DRIVER_INTERNAL,
                     5,
                     NUMBER_BYPASS_SRB_DATA_BLOCKS,
                     (ULONG_PTR) LogicalUnit->BypassSrbDataBlocks,
                     0);
    }

    srbData = CONTAINING_RECORD(entry, SRB_DATA, Reserved);

    srbData->Adapter = LogicalUnit->AdapterExtension;
    srbData->QueueTag = SP_UNTAGGED;
    srbData->Type = SRB_DATA_TYPE;
    srbData->Size = sizeof(SRB_DATA);
    srbData->Flags = SRB_DATA_BYPASS_REQUEST;
    srbData->FreeRoutine = SpFreeBypassSrbData;

    return srbData;
}

VOID
FASTCALL
SpFreeBypassSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    )

{
    PLOGICAL_UNIT_EXTENSION lu = SrbData->LogicalUnit;

    ASSERT_SRB_DATA(SrbData);
    ASSERT(SrbData->CurrentIrp == NULL);
    ASSERT(SrbData->CurrentSrb == NULL);
    ASSERT(SrbData->CompletedRequests == NULL);
    ASSERT(TEST_FLAG(SrbData->Flags, SRB_DATA_BYPASS_REQUEST));

    RtlZeroMemory(SrbData, sizeof(SRB_DATA));

    ExInterlockedPushEntrySList(&(lu->BypassSrbDataList),
                                &(SrbData->Reserved),
                                &(lu->BypassSrbDataSpinLock));
    return;
}

PVOID
SpAllocateErrorLogEntry(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PVOID Packet;

    ASSERT(DriverObject);
    Packet = IoAllocateErrorLogEntry(
                 DriverObject,
                 sizeof(IO_ERROR_LOG_PACKET) + sizeof(SCSIPORT_ALLOCFAILURE_DATA));

    return Packet;
}

VOID
FASTCALL
SpLogAllocationFailureFn(
    IN PDRIVER_OBJECT DriverObject,
    IN POOL_TYPE PoolType,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN ULONG FileId,
    IN ULONG LineNumber
    )

/*++

Routine Description:

    This routine writes a message to the event log indicating that an
    allocation failure has occurred.

Arguments:

    DriverObject - pointer to the driver object for which the allocation
                   failure event is being logged.

    PoolType     - identifies the pool the failed allocation attempt was from.

    Size         - indicates the number of bytes that the failed allocation 
                   attempt tried to obtain.

    Tag          - identifies the pool tag associated with the failed 
                   allocation.
    
    AllocId      - uniquely identifies this allocation w/in scsiport.

Return Value:

    VOID

--*/

{
    NTSTATUS status;
    PIO_ERROR_LOG_PACKET Packet;
    PIO_ERROR_LOG_PACKET CurrentValue;
    SCSIPORT_ALLOCFAILURE_DATA *Data;
//    PSCSIPORT_ALLOCFAILURE_ENTRY Entry;
//    PSCSIPORT_ALLOCFAILURE_ENTRY CurrentValue;
    PSCSIPORT_DRIVER_EXTENSION DriverExtension;

    DebugPrint((2, "SpLogAllocationFailureFn: DriverObject:%p\nId:%08X|%08X\n", 
                DriverObject,
                FileId, LineNumber));

    //
    // Try to allocate a new error log event.
    //

    Packet = (PIO_ERROR_LOG_PACKET) 
       SpAllocateErrorLogEntry(DriverObject);

    //
    // If we could not allocate a log event, we check the driver extension to
    // see if it has a reserve event we can use.  If we cannot get the driver
    // extension or if it does not contain a reserve event, we return
    // without logging the allocation failure.
    //

    if (Packet == NULL) {

        //
        // See if there is a driver extension for this driver.  It is possible
        // that one has not been created yet, so this may fail, in which case
        // we give up and return.
        //

        DriverExtension = IoGetDriverObjectExtension(
                              DriverObject,
                              ScsiPortInitialize
                              );

        if (DriverExtension == NULL) {
            DebugPrint((1, "SpLogAllocationFailureFn: no driver extension\n"));
            return;
        }

        //
        // Get the reserve event in the driver extension.  The reserve event
        // may have already been used, so it's possible that it is NULL.  If
        // this is the case, we give up and return.
        //

        Packet = (PIO_ERROR_LOG_PACKET)
                DriverExtension->ReserveAllocFailureLogEntry;

        if (Packet == NULL) {
            DebugPrint((1, "SpLogAllocationFailureFn: no reserve packet\n"));
            return;
        }

        //
        // We have to ensure that we are the only instance to use this
        // event.  To do so, we attempt to NULL the event in the driver
        // extension.  If somebody else beats us to it, they own the
        // event and we have to give up.
        //

        CurrentValue = InterlockedCompareExchangePointer(
                            DriverExtension->ReserveAllocFailureLogEntry,
                            NULL,
                            Packet
                            );

        if (Packet != CurrentValue) {
            DebugPrint((1, "SpLogAllocationFailureFn: someone already owns packet\n"));
            return;
        }
    }

    //
    // Initialize the error log packet.
    //

    Packet->ErrorCode = IO_WARNING_ALLOCATION_FAILED;
    Packet->SequenceNumber = 0;
    Packet->MajorFunctionCode = 0;
    Packet->RetryCount = 0;
    Packet->UniqueErrorValue = 0x10;
    Packet->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
    Packet->DumpDataSize = sizeof(ULONG) * 4;
    Packet->NumberOfStrings = 0;
    Packet->DumpData[0] = Tag;

    Data = (SCSIPORT_ALLOCFAILURE_DATA*) &Packet->DumpData[1];

    Data->Size = (ULONG) Size;
    Data->FileId = FileId;
    Data->LineNumber = LineNumber;

    //
    // Queue the error log entry.
    //

    IoWriteErrorLogEntry(Packet);
}

PVOID
SpAllocatePoolEx(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    )
{
    PVOID Block;

    if (NumberOfBytes == 0) {
        return NULL;
    }

    Block = ExAllocatePoolWithTag(PoolType,
                                  NumberOfBytes,
                                  Tag);
    if (Block == NULL) {

        SpLogAllocationFailureFn(DriverObject, 
                                 PoolType,
                                 NumberOfBytes,
                                 Tag,
                                 FileId,
                                 LineNumber);
    }

    return Block;
}

PMDL
SpAllocateMdlEx(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    )
{
    PMDL mdl = IoAllocateMdl(VirtualAddress,
                             Length,
                             SecondaryBuffer,
                             ChargeQuota,
                             Irp);
    if (mdl == NULL) {
        SpLogAllocationFailureFn(DriverObject,
                                 NonPagedPool,
                                 0,
                                 SCSIPORT_TAG_ALLOCMDL,
                                 FileId,
                                 LineNumber);
    }
    return mdl;
}

PIRP
SpAllocateIrpEx(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    )
{
    PIRP irp = IoAllocateIrp(StackSize, ChargeQuota);
    if (irp == NULL) {
        SpLogAllocationFailureFn(DriverObject,
                                 NonPagedPool,
                                 0,
                                 SCSIPORT_TAG_ALLOCIRP,
                                 FileId,
                                 LineNumber);
    }
    return irp;
}

BOOLEAN
SpTransferBlockedRequestsToAdapter(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will transfer the blocked requests from the Lun Queue to the
    Adapter queue. This is necessary, so as to give a fair(fairness on lun 
    level as opposed to previous scheme of adapter level) chance for all 
    blocked lun requests to be processed.

    This routine must be called with the EmergencySpinLock held.

Arguments:

    Adapter - The Adapter extension to which the lun blocked requests would be
    transferred.         

Return Value:

    TRUE - If any blocked-requests were transfered to the Adapter Blocked Queue.
    FALSE - Otherwise

--*/
{
    PLIST_ENTRY entry;
    PLOGICAL_UNIT_EXTENSION LogicalUnit,PrevLogicalUnit;

    LogicalUnit = Adapter->BlockedLogicalUnit;
    PrevLogicalUnit = Adapter->BlockedLogicalUnit;
    
    while(LogicalUnit != (PLOGICAL_UNIT_EXTENSION)&Adapter->BlockedLogicalUnit){

        entry = RemoveHeadList(&(LogicalUnit->SrbDataBlockedRequests));
        InsertHeadList(&(Adapter->SrbDataBlockedRequests),entry);
        if(IsListEmpty(&(LogicalUnit->SrbDataBlockedRequests))){
            if(LogicalUnit == Adapter->BlockedLogicalUnit){
                Adapter->BlockedLogicalUnit = 
                    LogicalUnit->BlockedLogicalUnit;
                LogicalUnit->BlockedLogicalUnit = NULL;
                LogicalUnit=Adapter->BlockedLogicalUnit;
            } else {
                PrevLogicalUnit->BlockedLogicalUnit =
                    LogicalUnit->BlockedLogicalUnit;
                LogicalUnit->BlockedLogicalUnit = NULL;
                LogicalUnit=PrevLogicalUnit->BlockedLogicalUnit;
            }
        }else{
            PrevLogicalUnit = LogicalUnit;
            LogicalUnit = LogicalUnit->BlockedLogicalUnit;
        }

    }
    return (!IsListEmpty(&(Adapter->SrbDataBlockedRequests)));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\remove.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    pdo.c

Abstract:

    This module contains the dispatch routines for scsiport's physical device
    objects

Authors:

    Peter Wieland

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "port.h"

#if DBG
static const char *__file__ = __FILE__;
#endif

VOID
SpAdapterCleanup(
    IN PADAPTER_EXTENSION DeviceExtension
    );

VOID
SpReapChildren(
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpTerminateAdapterSynchronized (
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpRemoveAdapterSynchronized(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpFlushAllRequests(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpDeleteLogicalUnit)
#pragma alloc_text(PAGE, SpRemoveLogicalUnit)
#pragma alloc_text(PAGE, SpWaitForRemoveLock)
#pragma alloc_text(PAGE, SpAdapterCleanup)
#pragma alloc_text(PAGE, SpReapChildren)

#pragma alloc_text(PAGELOCK, ScsiPortRemoveAdapter)
#endif


BOOLEAN
SpRemoveLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN UCHAR RemoveType
    )

{
    PADAPTER_EXTENSION adapterExtension = LogicalUnit->AdapterExtension;

    ULONG isRemoved;
    ULONG oldDebugLevel;

    PAGED_CODE();

    if(LogicalUnit->CommonExtension.IsRemoved != REMOVE_COMPLETE) {

        if(RemoveType == IRP_MN_REMOVE_DEVICE) {

            SpWaitForRemoveLock(LogicalUnit->DeviceObject, SP_BASE_REMOVE_LOCK );

            //
            // If the device was claimed we should release it now.
            //

            if(LogicalUnit->IsClaimed) {
                LogicalUnit->IsClaimed = FALSE;
                LogicalUnit->IsLegacyClaim = FALSE;
            }

        }

        DebugPrint((1, "SpRemoveLogicalUnit - %sremoving device %#p\n",
                    (RemoveType == IRP_MN_SURPRISE_REMOVAL) ? "surprise " : "",
                    LogicalUnit));

        //
        // If the lun isn't marked as missing yet or is marked as missing but
        // PNP hasn't been informed yet then we cannot delete it.  Set it back
        // to the NO_REMOVE state so that we'll be able to attempt a rescan.
        //
        // Likewise if the lun is invisible then just swallow the remove
        // operation now that we've cleared any existing claims.
        //

        if(RemoveType == IRP_MN_REMOVE_DEVICE) {

            //
            // If the device is not missing or is missing but is still
            // enumerated then don't finish destroying it.
            //

            if((LogicalUnit->IsMissing == TRUE) &&
               (LogicalUnit->IsEnumerated == FALSE)) {

                // do nothing here - fall through and destroy the device.

            } else {

                DebugPrint((1, "SpRemoveLogicalUnit - device is not missing "
                               "and will not be destroyed\n"));

                SpAcquireRemoveLock(LogicalUnit->DeviceObject, SP_BASE_REMOVE_LOCK);

                LogicalUnit->CommonExtension.IsRemoved = NO_REMOVE;

                return FALSE;
            }

        } else if((LogicalUnit->IsVisible == FALSE) &&
                  (LogicalUnit->IsMissing == FALSE)) {

            //
            // The surprise remove came because the device is no longer
            // visible.  We don't want to destroy it.
            //

            return FALSE;
        }

        //
        // Mark the device as uninitialized so that we'll go back and
        // recreate all the necessary stuff if it gets restarted.
        //

        LogicalUnit->CommonExtension.IsInitialized = FALSE;

        //
        // Delete the device map entry for this one (if any).
        //

        SpDeleteDeviceMapEntry(&(LogicalUnit->CommonExtension));

        if(RemoveType == IRP_MN_REMOVE_DEVICE) {

            ASSERT(LogicalUnit->RequestTimeoutCounter == -1);
            ASSERT(LogicalUnit->ReadyLogicalUnit == NULL);
            ASSERT(LogicalUnit->PendingRequest == NULL);
            ASSERT(LogicalUnit->BusyRequest == NULL);
            ASSERT(LogicalUnit->QueueCount == 0);

            LogicalUnit->CommonExtension.IsRemoved = REMOVE_COMPLETE;

            //
            // Yank this out of the logical unit list.
            //

            SpRemoveLogicalUnitFromBin(LogicalUnit->AdapterExtension,
                                       LogicalUnit);

            LogicalUnit->PathId = 0xff;
            LogicalUnit->TargetId = 0xff;
            LogicalUnit->Lun = 0xff;

            //
            // If this device wasn't temporary then delete it.
            //

            if(LogicalUnit->IsTemporary == FALSE) {
                SpDeleteLogicalUnit(LogicalUnit);
            }
        }
    }

    return TRUE;
}


VOID
SpDeleteLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )

/*++

Routine Description:

    This routine will release any resources held for the logical unit, mark the
    device extension as deleted, and call the io system to actually delete
    the object.  The device object will be deleted once it's reference count
    drops to zero.

Arguments:

    LogicalUnit - the device object for the logical unit to be deleted.

Return Value:

    none

--*/

{
    PAGED_CODE();

    ASSERT(LogicalUnit->ReadyLogicalUnit == NULL);
    ASSERT(LogicalUnit->PendingRequest == NULL);
    ASSERT(LogicalUnit->BusyRequest == NULL);
    ASSERT(LogicalUnit->QueueCount == 0);

    ASSERT(LogicalUnit->PathId == 0xff);
    ASSERT(LogicalUnit->TargetId == 0xff);
    ASSERT(LogicalUnit->Lun == 0xff);

    //
    // Unregister with WMI.
    //

    if(LogicalUnit->CommonExtension.WmiInitialized == TRUE) {

        //
        // Destroy all our WMI resources and unregister with WMI.
        //

        IoWMIRegistrationControl(LogicalUnit->DeviceObject,
                                 WMIREG_ACTION_DEREGISTER);

        // 
        // We should be asking the WmiFreeRequestList of remove some
        // free cells.

        LogicalUnit->CommonExtension.WmiInitialized = FALSE;
        SpWmiDestroySpRegInfo(LogicalUnit->DeviceObject);
    }

#if DBG
    // ASSERT(LogicalUnit->CommonExtension.RemoveTrackingList == NULL);
    ExDeleteNPagedLookasideList(
        &(LogicalUnit->CommonExtension.RemoveTrackingLookasideList));
#endif

    //
    // If the request sense irp still exists, delete it.
    //

    if(LogicalUnit->RequestSenseIrp != NULL) {
        IoFreeIrp(LogicalUnit->RequestSenseIrp);
        LogicalUnit->RequestSenseIrp = NULL;
    }

    if(LogicalUnit->HwLogicalUnitExtension != NULL) {
        ExFreePool(LogicalUnit->HwLogicalUnitExtension);
        LogicalUnit->HwLogicalUnitExtension = NULL;
    }

    if(LogicalUnit->SerialNumber.Buffer != NULL) {
        ExFreePool(LogicalUnit->SerialNumber.Buffer);
        RtlInitAnsiString(&(LogicalUnit->SerialNumber), NULL);
    }

    if(LogicalUnit->DeviceIdentifierPage != NULL) {
        ExFreePool(LogicalUnit->DeviceIdentifierPage);
        LogicalUnit->DeviceIdentifierPage = NULL;
    }

    //
    // If this lun is temporary then clear the RescanLun field in the adapter.
    //

    if(LogicalUnit->IsTemporary) {
        ASSERT(LogicalUnit->AdapterExtension->RescanLun = LogicalUnit);
        LogicalUnit->AdapterExtension->RescanLun = NULL;
    } else {
        ASSERT(LogicalUnit->AdapterExtension->RescanLun != LogicalUnit);
    }

    IoDeleteDevice(LogicalUnit->DeviceObject);

    return;
}


VOID
ScsiPortRemoveAdapter(
    IN PDEVICE_OBJECT AdapterObject,
    IN BOOLEAN Surprise
    )
{
    PADAPTER_EXTENSION adapter = AdapterObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = AdapterObject->DeviceExtension;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT_FDO(AdapterObject);
    ASSERT(adapter->IsPnp);

    //
    // Set the flag PD_ADAPTER_REMOVED to keep scsiport from calling into the
    // miniport after we've started this teardown.
    //

    if(Surprise == FALSE) {
        PVOID sectionHandle;
        KIRQL oldIrql;

        //
        // Wait until all outstanding requests have been completed.  If the
        // adapter was surprise removed, we don't need to wait on the remove
        // lock again, since we already waited for it in the surprise remove
        // path.
        //

        if (commonExtension->CurrentPnpState != IRP_MN_SURPRISE_REMOVAL) {
            SpWaitForRemoveLock(AdapterObject, AdapterObject);
        }

        //
        // If the device is started we should uninitialize the miniport and
        // release it's resources.  Fortunately this is exactly what stop does.
        //

        if((commonExtension->CurrentPnpState != IRP_MN_SURPRISE_REMOVAL) &&
           ((commonExtension->CurrentPnpState == IRP_MN_START_DEVICE) ||
            (commonExtension->PreviousPnpState == IRP_MN_START_DEVICE))) {

            //
            // Okay.  If this adapter can't support remove then we're dead
            //

            ASSERT(SpIsAdapterControlTypeSupported(adapter, ScsiStopAdapter) == TRUE);

            //
            // Stop the miniport now that it's safe.
            //

            SpEnableDisableAdapter(adapter, FALSE);

            //
            // Mark the adapter as removed.
            //

    #ifdef ALLOC_PRAGMA
            sectionHandle = MmLockPagableCodeSection(ScsiPortRemoveAdapter);
            InterlockedIncrement(&SpPAGELOCKLockCount);
    #endif
            KeAcquireSpinLock(&(adapter->SpinLock), &oldIrql);
            adapter->SynchronizeExecution(adapter->InterruptObject,
                                          SpRemoveAdapterSynchronized,
                                          adapter);

            KeReleaseSpinLock(&(adapter->SpinLock), oldIrql);

    #ifdef ALLOC_PRAGMA
            InterlockedDecrement(&SpPAGELOCKLockCount);
            MmUnlockPagableImageSection(sectionHandle);
    #endif

        }
        SpReapChildren(adapter);
    }

    if(commonExtension->WmiInitialized == TRUE) {

        //
        // Destroy all our WMI resources and unregister with WMI.
        //

        IoWMIRegistrationControl(AdapterObject, WMIREG_ACTION_DEREGISTER);
        SpWmiRemoveFreeMiniPortRequestItems(adapter);
        commonExtension->WmiInitialized = FALSE;
        commonExtension->WmiMiniPortInitialized = FALSE;
    }

    //
    // If we are surprise removed, the following gets executed twice, but
    // it's safe to do so.
    //

    SpDeleteDeviceMapEntry(commonExtension);
    SpDestroyAdapter(adapter, Surprise);

    return;
}


VOID
SpWaitForRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID LockTag
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // Mark the thing as removing
    //

    commonExtension->IsRemoved = REMOVE_PENDING;

    //
    // Release our outstanding lock.
    //

    SpReleaseRemoveLock(DeviceObject, LockTag);

    DebugPrint((4, "SpWaitForRemoveLock - Reference count is now %d\n",
                commonExtension->RemoveLock));

    KeWaitForSingleObject(&(commonExtension->RemoveEvent),
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    DebugPrint((4, "SpWaitForRemoveLock - removing device %#p\n",
                DeviceObject));

    return;
}


VOID
SpDestroyAdapter(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Surprise
    )
{
    SpReleaseAdapterResources(Adapter, FALSE, Surprise);
    SpAdapterCleanup(Adapter);
    return;
}


VOID
SpAdapterCleanup(
    IN PADAPTER_EXTENSION Adapter
    )

/*++

Routine Description:

    This routine cleans up the names associated with the specified adapter
    and the i/o system counts.

Arguments:

    Adapter - Supplies a pointer to the device extension to be deleted.

Return Value:

    None.

--*/

{
    PCOMMON_EXTENSION commonExtension = &(Adapter->CommonExtension);

    PAGED_CODE();

    //
    // If we assigned a port number to this adapter then attempt to delete the
    // symbolic links we created to it.
    //

    if(Adapter->PortNumber != -1) {

        PWCHAR wideNameStrings[] = {L"\\Device\\ScsiPort%d",
                                    L"\\DosDevices\\Scsi%d:"};
        ULONG i;

        for(i = 0; i < (sizeof(wideNameStrings) / sizeof(PWCHAR)); i++) {
            WCHAR wideLinkName[64];
            UNICODE_STRING unicodeLinkName;

            swprintf(wideLinkName, wideNameStrings[i], Adapter->PortNumber);
            RtlInitUnicodeString(&unicodeLinkName, wideLinkName);
            IoDeleteSymbolicLink(&unicodeLinkName);
        }

        Adapter->PortNumber = -1;

        //
        // Decrement the scsiport count.
        //

        IoGetConfigurationInformation()->ScsiPortCount--;
    }

    return;
}


VOID
SpReleaseAdapterResources(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Stop,
    IN BOOLEAN Surprise
    )

/*++

Routine Description:

    This function deletes all of the storage associated with a device
    extension, disconnects from the timers and interrupts and then deletes the
    object.   This function can be called at any time during the initialization.

Arguments:

    Adapter - Supplies a pointer to the device extesnion to be deleted.
    Surprise - This is redundant, but is used by stop, remove and surprise-remove
    SurpriseRemoved - Indicates that the adapter has been surprise-removed

Return Value:

    None.

--*/

{

    PCOMMON_EXTENSION commonExtension = &(Adapter->CommonExtension);
    ULONG j;
    PVOID tempPointer;

    PAGED_CODE();

#if DBG

    if(!Surprise && !Stop) {

        //
        // Free the Remove tracking lookaside list.
        //

        ExDeleteNPagedLookasideList(&(commonExtension->RemoveTrackingLookasideList));
    }
#endif

    //
    // Stop the time and disconnect the interrupt if they have been
    // initialized.  The interrupt object is connected after
    // timer has been initialized, and the interrupt object is connected, but
    // before the timer is started.
    //

    if(Adapter->DeviceObject->Timer != NULL) {
        IoStopTimer(Adapter->DeviceObject);
        KeCancelTimer(&(Adapter->MiniPortTimer));
    }

    if(Adapter->SynchronizeExecution != SpSynchronizeExecution) {

        if (Adapter->InterruptObject) {
            IoDisconnectInterrupt(Adapter->InterruptObject);
        }

        if (Adapter->InterruptObject2) {
            IoDisconnectInterrupt(Adapter->InterruptObject2);
            Adapter->InterruptObject2 = NULL;
        }

        //
        // SpSynchronizeExecution expects to get a pointer to the
        // adapter extension as the "interrupt" parameter.
        //

        Adapter->InterruptObject = (PVOID) Adapter;
        Adapter->SynchronizeExecution = SpSynchronizeExecution;
    }

    //
    // Delete the miniport's device extension
    //

    if (Adapter->HwDeviceExtension != NULL) {

        PHW_DEVICE_EXTENSION devExt =
            CONTAINING_RECORD(Adapter->HwDeviceExtension,
                              HW_DEVICE_EXTENSION,
                              HwDeviceExtension);

        ExFreePool(devExt);
        Adapter->HwDeviceExtension = NULL;
    }

    //
    // Free the configuration information structure.
    //

    if (Adapter->PortConfig) {
        ExFreePool(Adapter->PortConfig);
        Adapter->PortConfig = NULL;
    }

    //
    // Deallocate SCSIPORT WMI REGINFO information, if any.
    //

    SpWmiDestroySpRegInfo(Adapter->DeviceObject);

    //
    // Free the common buffer.
    //

    if (SpVerifyingCommonBuffer(Adapter)) {

        SpFreeCommonBufferVrfy(Adapter);

    } else {

        if (Adapter->SrbExtensionBuffer != NULL &&
            Adapter->CommonBufferSize != 0) {

            if (Adapter->DmaAdapterObject == NULL) {

                //
                // Since there is no adapter just free the non-paged pool.
                //

                ExFreePool(Adapter->SrbExtensionBuffer);

            } else {

                if(Adapter->UncachedExtensionIsCommonBuffer == FALSE) {
                    MmFreeContiguousMemorySpecifyCache(Adapter->SrbExtensionBuffer,
                                                       Adapter->CommonBufferSize,
                                                       MmCached);
                } else {

                    FreeCommonBuffer(
                        Adapter->DmaAdapterObject,
                        Adapter->CommonBufferSize,
                        Adapter->PhysicalCommonBuffer,
                        Adapter->SrbExtensionBuffer,
                        FALSE);
                }

            }
            Adapter->SrbExtensionBuffer = NULL;
        }
    }

    //
    // Get rid of our dma adapter.
    //

    if(Adapter->DmaAdapterObject != NULL) {
        PutDmaAdapter(Adapter->DmaAdapterObject);
        Adapter->DmaAdapterObject = NULL;
    }

    //
    // Free the SRB data array, if this is not a surprise remove. We should
    // not free the lookaside list in case of a surprise remove, as some 
    // requests might have allocated SRB_DATA blocks w/o holding the adapter 
    // remove lock. All other resources are required only if we ere able to 
    // acquire the adapter remove lock, which we guarantee we won't at this point.
    // It is safe to free the array during remove, because we delete all the LUN's
    // before realeasing adapters resources

    if( !Surprise ){ 

        if (Adapter->SrbDataListInitialized) {

            if(Adapter->EmergencySrbData != NULL) {

                ExFreeToNPagedLookasideList(
                    &Adapter->SrbDataLookasideList,
                    Adapter->EmergencySrbData);
                Adapter->EmergencySrbData = NULL;

            }

            ExDeleteNPagedLookasideList(&Adapter->SrbDataLookasideList);
            Adapter->SrbDataListInitialized = FALSE;
        }
    }


    if (Adapter->InquiryBuffer != NULL) {
        ExFreePool(Adapter->InquiryBuffer);
        Adapter->InquiryBuffer = NULL;
    }

    if (Adapter->InquirySenseBuffer != NULL) {
        ExFreePool(Adapter->InquirySenseBuffer);
        Adapter->InquirySenseBuffer = NULL;
    }
    
    if (Adapter->InquiryIrp != NULL) {
        IoFreeIrp(Adapter->InquiryIrp);
        Adapter->InquiryIrp = NULL;
    }
    
    if (Adapter->InquiryMdl != NULL) {
        IoFreeMdl(Adapter->InquiryMdl);
        Adapter->InquiryMdl = NULL;
    }

    //
    // Unmap any mapped areas.
    //

    SpReleaseMappedAddresses(Adapter);

    //
    // If we've got any resource lists allocated still we should free them
    // now.
    //

    if(Adapter->AllocatedResources != NULL) {
        ExFreePool(Adapter->AllocatedResources);
        Adapter->AllocatedResources = NULL;
    }

    if(Adapter->TranslatedResources != NULL) {
        ExFreePool(Adapter->TranslatedResources);
        Adapter->TranslatedResources = NULL;
    }

    //
    // Cleanup verifier resources.
    //

    if (SpVerifierActive(Adapter)) {
        SpDoVerifierCleanup(Adapter);
    }

#if defined(FORWARD_PROGRESS)
    //
    // Cleanup the adapter's reserved pages.
    //

    if (Adapter->ReservedPages != NULL) {
        MmFreeMappingAddress(Adapter->ReservedPages,
                             SCSIPORT_TAG_MAPPING_LIST);
        Adapter->ReservedPages = NULL;        
    }

    if (Adapter->ReservedMdl != NULL) {   
        IoFreeMdl(Adapter->ReservedMdl);
        Adapter->ReservedMdl = NULL;
    }
#endif

    Adapter->CommonExtension.IsInitialized = FALSE;

    return;
}


VOID
SpReapChildren(
    IN PADAPTER_EXTENSION Adapter
    )
{
    ULONG j;

    PAGED_CODE();

    //
    // Run through the logical unit bins and remove any child devices which
    // remain.
    //

    for(j = 0; j < NUMBER_LOGICAL_UNIT_BINS; j++) {

        while(Adapter->LogicalUnitList[j].List != NULL) {

            PLOGICAL_UNIT_EXTENSION lun =
                Adapter->LogicalUnitList[j].List;

            lun->IsMissing = TRUE;
            lun->IsEnumerated = FALSE;

            SpRemoveLogicalUnit(lun, IRP_MN_REMOVE_DEVICE);
        }
    }

    //
    // Remove the initiator LUs.
    //

    for (j = 0; j < 8; j++) {
        PLOGICAL_UNIT_EXTENSION lu = Adapter->InitiatorLU[j];
        if (lu != NULL) {
            Adapter->InitiatorLU[j] = NULL;
        }
    }

    return;
}


VOID
SpTerminateAdapter(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine will terminate the miniport's control of the adapter.  It
    does not cleanly shutdown the miniport and should only be called when
    scsiport is notified that the adapter has been surprise removed.

    This works by synchronizing with the miniport and setting flags to
    disable any new calls into the miniport.  Once this has been done it can
    run through and complete any i/o requests which may still be inside
    the miniport.

Arguments:

    Adapter - the adapter to terminate.

Return Value:

    none

--*/

{
    KIRQL oldIrql;

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

    KeAcquireSpinLockAtDpcLevel(&(Adapter->SpinLock));

    if (Adapter->CommonExtension.CurrentPnpState == IRP_MN_START_DEVICE) {

        //
        // TA synchronized will stop all calls into the miniport and complete
        // all active requests.
        //

        Adapter->SynchronizeExecution(Adapter->InterruptObject,
                                      SpTerminateAdapterSynchronized,
                                      Adapter);

        Adapter->CommonExtension.PreviousPnpState = 0xff;


        SpFlushAllRequests(Adapter->HwDeviceExtension,
                           0xff,
                           0xff,
                           0xff,
                           SRB_STATUS_NO_HBA);
        

        //
        // Stop the miniport timer
        //

        KeCancelTimer(&(Adapter->MiniPortTimer));

        //
        // We keep the device object timer running so that any held, busy or
        // otherwise deferred requests will have a chance to get flushed out.
        // We can give the whole process a boost by setting the adapter timeout
        // counter to 1 (it will go to zero in the tick handler) and running
        // the tick handler by hand here.
        //

        Adapter->PortTimeoutCounter = 1;
        ScsiPortTickHandler(Adapter->DeviceObject, NULL);

    } else {
        KeReleaseSpinLockFromDpcLevel(&(Adapter->SpinLock));
    }

    KeLowerIrql(oldIrql);

    return;
}


BOOLEAN
SpTerminateAdapterSynchronized(
    IN PADAPTER_EXTENSION Adapter
    )
{
    //
    // Disable the interrupt from coming in.
    //

    SET_FLAG(Adapter->InterruptData.InterruptFlags, PD_ADAPTER_REMOVED);


    ScsiPortCompleteRequest(Adapter->HwDeviceExtension,
                            0xff,
                            0xff,
                            0xff,
                            SRB_STATUS_NO_HBA);

    //
    //This needs to be done to start the next request sitting in the adapter
    //queue, otherwise surprise remove will wait forever for the remove
    //lockcount to be zero.
    //

    ScsiPortNotification(NextRequest,
                         Adapter->HwDeviceExtension);

    //
    // Run the completion DPC.
    //

    if(TEST_FLAG(Adapter->InterruptData.InterruptFlags, 
                 PD_NOTIFICATION_REQUIRED)) {
        SpRequestCompletionDpc(Adapter->DeviceObject);
    }

    return TRUE;
}

BOOLEAN
SpRemoveAdapterSynchronized(
    PADAPTER_EXTENSION Adapter
    )
{
    //
    // Disable the interrupt from coming in.
    //

    SET_FLAG(Adapter->InterruptData.InterruptFlags, PD_ADAPTER_REMOVED);

    return TRUE;
}

VOID
SpFlushAllRequests(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )

/*++

Routine Description:

    Flushes all requests in all the Lun device queues, busy and pending 
    requests on all Luns. The request stuck in the adapter's CurrentIrp
    field of the adapter due to PD_RESET_HELD will be taken care of by 
    the tick handler. In short all the requests stuck anywhere in ScsiPort 
    will be flushed. Unfortunately this is not enough to handle Surprise 
    Remove. We also need a small check in Startio so that we flush all 
    requests on the lun for which we got a request. 

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

    Note: This routine must be called with the Adapter SpinLock held, and
          the lock would be released by this routine.    

--*/

{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    ULONG binNumber;
    PIRP listIrp = NULL;
    PIRP nextIrp;
    PKDEVICE_QUEUE_ENTRY packet;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;

    for (binNumber = 0; binNumber < NUMBER_LOGICAL_UNIT_BINS; binNumber++) {

        PLOGICAL_UNIT_BIN bin = &deviceExtension->LogicalUnitList[binNumber];
        PLOGICAL_UNIT_EXTENSION LogicalUnit;
        ULONG limit = 0;

        LogicalUnit = bin->List;

        DebugPrint((2, "ScsiPortCompleteRequest: Completing requests in "
                       "bin %d [%#p]\n",
                    binNumber, bin));

        for(LogicalUnit = bin->List;
            LogicalUnit != NULL;
            LogicalUnit = LogicalUnit->NextLogicalUnit) {

            PLIST_ENTRY entry;

            ASSERT(limit++ < 1000);

            //
            // See if this logical unit matches the pattern.  Check for -1
            // first since this seems to be the most popular way to complete
            // requests.
            //

            if (((PathId == SP_UNTAGGED) || (PathId == LogicalUnit->PathId)) &&
                ((TargetId == SP_UNTAGGED) ||
                 (TargetId == LogicalUnit->TargetId)) &&
                ((Lun == SP_UNTAGGED) || (Lun == LogicalUnit->Lun))) {   

                //
                // The queue may not be busy so we have to use the IfBusy variant.  
                // Use a zero key to pull items from the head of it (if any are there)
                //

                while ((packet =
                        KeRemoveByKeyDeviceQueueIfBusy(
                            &(LogicalUnit->DeviceObject->DeviceQueue),
                            0))
                       != NULL) {

                    nextIrp = CONTAINING_RECORD(packet,
                                                IRP,
                                                Tail.Overlay.DeviceQueueEntry);

                    //
                    // Get the srb.
                    //

                    irpStack = IoGetCurrentIrpStackLocation(nextIrp);
                    srb = irpStack->Parameters.Scsi.Srb;

                    //
                    // Set the status code.
                    //  

                    srb->SrbStatus = SrbStatus;
                    nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                    //  
                    // Link the requests. They will be completed after the
                    // spinlock is released.
                    //

                    nextIrp->Tail.Overlay.ListEntry.Flink = 
                        (PLIST_ENTRY)listIrp;

                    listIrp = nextIrp;
                }

                //
                // If there is a pending request on the LU, add it to the list so it
                // gets flushed along with the queued requests.
                //

                if (LogicalUnit->PendingRequest != NULL) {

                    PIRP irp = LogicalUnit->PendingRequest->CurrentIrp;
                    srb = LogicalUnit->PendingRequest->CurrentSrb;

                    DebugPrint((1, "SpFlushReleaseQueue: flushing pending request irp:%p srb:%p\n", irp, srb));

                    srb->SrbStatus = SrbStatus;
                    irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                    irp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY) listIrp;
                    listIrp = irp;

                    LogicalUnit->PendingRequest = NULL;
                    ASSERT(LogicalUnit->LuFlags | LU_PENDING_LU_REQUEST);
                    CLEAR_FLAG(LogicalUnit->LuFlags, LU_PENDING_LU_REQUEST);

                }

                //
                // If there is a busy request on the LU, add it to the list so it
                // gets flushed along with the queued requests.
                //

                if ( LogicalUnit->BusyRequest ) {

                    PIRP irp = LogicalUnit->BusyRequest->CurrentIrp;
                    srb = LogicalUnit->BusyRequest->CurrentSrb;

                    DebugPrint((1, "SpFlushReleaseQueue: flushing busy request irp:%\
p srb:%p\n", irp, srb));

                    srb->SrbStatus = SrbStatus;
                    irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                    irp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY) listIrp;
                    listIrp = irp;

                    LogicalUnit->BusyRequest = NULL;
                    ASSERT((LU_LOGICAL_UNIT_IS_BUSY | LU_QUEUE_IS_FULL));

                    CLEAR_FLAG(LogicalUnit->LuFlags,
                               (LU_LOGICAL_UNIT_IS_BUSY | LU_QUEUE_IS_FULL));

                }

            }
        }
    }

    KeReleaseSpinLockFromDpcLevel(&(deviceExtension->SpinLock));

    //
    // Complete the flushed requests.
    //

    while (listIrp != NULL) {

        PSRB_DATA srbData;

        nextIrp = listIrp;
        listIrp = (PIRP) nextIrp->Tail.Overlay.ListEntry.Flink;

        //
        // Get the srb.
        //

        irpStack = IoGetCurrentIrpStackLocation(nextIrp);
        srb = irpStack->Parameters.Scsi.Srb;
        srbData = srb->OriginalRequest;

        srb->OriginalRequest = nextIrp;

        SpReleaseRemoveLock(deviceExtension->DeviceObject, nextIrp);
        SpCompleteRequest(deviceExtension->DeviceObject,
                          nextIrp,
                          srbData,
                          IO_NO_INCREMENT);
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\port.h ===
/*++

Copyright (C) 1990-4  Microsoft Corporation

Module Name:

    port.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the common SCSI port driver.

Author:

    Jeff Havens  (jhavens) 28-Feb-1991
    Mike Glass

Revision History:

--*/


#ifndef _PORT_H_
#define _PORT_H_

#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "string.h"

#include "ntddk.h"
#include "scsi.h"

#include <ntddscsi.h>
#include <ntdddisk.h>
#include "ntddstor.h"

#include "wmistr.h"

#include "wdmguid.h"
#include "devguid.h"
#include "portlib.h"

//
// feature/debugginging #define switches
//

#define TEST_LISTS 0

//
// ScsiPort global variable declarations.  These should be static data (like
// lookup tables) to avoid synchronization problems.
//

extern PDRIVER_DISPATCH AdapterMajorFunctionTable[];
extern PDRIVER_DISPATCH DeviceMajorFunctionTable[];
extern PDRIVER_DISPATCH Scsi1DeviceMajorFunctionTable[];

//
// Global list of scsi adapters.  This is used by the srb data allocator routine
// to convert the "tag" provided into a pointer to the device object.
//

extern KSPIN_LOCK ScsiGlobalAdapterListSpinLock;
extern PDEVICE_OBJECT *ScsiGlobalAdapterList;
extern ULONG ScsiGlobalAdapterListElements;

//
// Count of how many times we've locked down the PAGELOCK section.
//

extern LONG SpPAGELOCKLockCount;

//
// Whether the system can do 64 bit PA's or not.
//

extern ULONG Sp64BitPhysicalAddresses;

//
// Handle to pageable verifier code section.  We manually lock the verify
// code into memory iff we need it.
//

extern PVOID VerifierCodeSectionHandle;
extern PVOID VerifierApiCodeSectionHandle;
extern ULONG SpVrfyLevel;

//
// Constants and macros to enforce good use of Ex[Allocate|Free]PoolWithTag.
// Remeber that all pool tags will display in the debugger in reverse order
//

#if USE_EXFREEPOOLWITHTAG_ONLY
#define TAG(x)  (x | 0x80000000)
#else
#define TAG(x)  (x)
#endif

#define SCSIPORT_TAG_MINIPORT_PARAM     TAG('aPcS')  // Hold registry data
#define SCSIPORT_TAG_ACCESS_RANGE       TAG('APcS')  // Access Ranges
#define SCSIPORT_TAG_BUS_DATA           TAG('bPcS')  // Get Bus Data holder
#define SCSIPORT_TAG_QUEUE_BITMAP       TAG('BPcS')  // QueueTag BitMap
#define SCSIPORT_TAG_COMMON_BUFFER      TAG('cPcS')  // Fake Common Buffer
#define SCSIPORT_TAG_RESET              TAG('CPcS')  // reset bus code
#define SCSIPORT_TAG_PNP_ID             TAG('dPcS')  // Pnp id strings
#define SCSIPORT_TAG_SRB_DATA           TAG('DPcS')  // SRB_DATA allocations
#define SCSIPORT_TAG_PAE                TAG('ePcS')  // MDLs allocated for PAE requests
#define SCSIPORT_TAG_EMERGENCY_SG_ENTRY TAG('EPcS')  // Scatter gather lists
#define SCSIPORT_TAG_VERIFIER           TAG('fPcS')  // Scsiport verifier entry
#define SCSIPORT_TAG_GLOBAL             TAG('GPcS')  // Global memory
#define SCSIPORT_TAG_DEV_EXT            TAG('hPcS')  // HwDevice Ext
#define SCSIPORT_TAG_LUN_EXT            TAG('HPcS')  // HwLogicalUnit Extension
#define SCSIPORT_TAG_SENSE_BUFFER       TAG('iPcS')  // Sense info
#define SCSIPORT_TAG_INIT_CHAIN         TAG('IPcS')  // Init data chain
#define SCSIPORT_TAG_LOCK_TRACKING      TAG('lPcS')  // remove lock tracking
#define SCSIPORT_TAG_LARGE_SG_ENTRY     TAG('LPcS')  // Scatter gather lists
#define SCSIPORT_TAG_MAPPING_LIST       TAG('mPcS')  // Address mapping lists
#define SCSIPORT_TAG_MEDIUM_SG_ENTRY    TAG('MPcS')  // Scatter gather lists
#define SCSIPORT_TAG_ENABLE             TAG('pPcS')  // device & adapter enable
#define SCSIPORT_TAG_PORT_CONFIG        TAG('PpcS')  // Scsi PortConfig copies
#define SCSIPORT_TAG_INQUIRY            TAG('qPcS')  // inquiry data
#define SCSIPORT_TAG_REQUEST_SENSE      TAG('QPcS')  // request sense
#define SCSIPORT_TAG_RESOURCE_LIST      TAG('rPcS')  // resource list copy
#define SCSIPORT_TAG_REGISTRY           TAG('RPcS')  // registry allocations
#define SCSIPORT_TAG_STOP_DEVICE        TAG('sPcS')  // stop device
#define SCSIPORT_TAG_STOP_ADAPTER       TAG('SPcS')  // stop Adapter
#define SCSIPORT_TAG_REROUTE            TAG('tPcS')  // Legacy request rerouting
#define SCSIPORT_TAG_INTERFACE_MAPPING  TAG('TPcS')  // Interface Mapping
#define SCSIPORT_TAG_DEVICE_RELATIONS   TAG('uPcS')  // device relation structs
#define SCSIPORT_TAG_EVENT              TAG('vPcS')  // KEVENT
#define SCSIPORT_TAG_DEVICE_MAP         TAG('VPcS')  // Device map allocations

#define SCSIPORT_TAG_WMI_EVENT          TAG('wPcS')  // WMI Events
#define SCSIPORT_TAG_WMI_REQUEST        TAG('WPcS')  // WMI Requests

#define SCSIPORT_TAG_REPORT_LUNS        TAG('xPcS')  // Report Luns
#define SCSIPORT_TAG_REPORT_TARGETS     TAG('XPcS')  // Report Targets
#define SCSIPORT_TAG_TEMP_ID_BUFFER     TAG('yPcS')  // Temporary id buffer
#define SCSIPORT_TAG_ID_BUFFER          TAG('YPcS')  // Id buffer
#define SCSIPORT_TAG_SYMBOLIC_LINK      TAG('zPcS')  // Symbolic link strings
#define SCSIPORT_TAG_DEVICE_NAME        TAG('ZPcS')  // Device name buffer

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool #assert(0)
#endif

#if defined(FORWARD_PROGRESS)
#define SP_RESERVED_PAGES 4
#endif

//
// The tag to use for the base remove lock.  This lock is only released when
// the device is finally ready to be destroyed.
//

#define SP_BASE_REMOVE_LOCK (UIntToPtr(0xabcdabcd))


//
// I/O System API routines which should not be called inside scsiport -
// these generally have scsiport versions which perform sanity checks before
// calling the real i/o routine in checked builds.
//

#if 0
#ifdef IoCompleteRequest
#ifndef KEEP_COMPLETE_REQUEST
#undef IoCompleteRequest
#endif
#endif
#endif

// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~(((LONG)(Pow2))-1)) )

// LPVOID
// ROUND_UP_POINTER(
//     IN LPVOID Ptr,
//     IN DWORD Pow2
//     );

// If Ptr is not already aligned, then round it up until it is.
#define ROUND_UP_POINTER(Ptr,Pow2) \
        ( (PVOID) ( (((ULONG_PTR)(Ptr))+(Pow2)-1) & (~(((LONG)(Pow2))-1)) ) )


//
// Macros, constants and declarations for debug code and debug print
// routines.
//

#define DEBUG_BUFFER_LENGTH 256

#if SCSIDBG_ENABLED
extern ULONG ScsiDebug;

#ifdef DebugPrint
#undef DebugPrint
#endif

#if SCSIDBG_ENABLED

//
// Forward definition of ScsiDebugPrintInt (internal and not exported)
//
VOID
ScsiDebugPrintInt(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define DebugPrint(x) ScsiDebugPrintInt x
#else
#define DebugPrint(x)
#endif

#endif

#define ASSERT_FDO(x) ASSERT(!(((PCOMMON_EXTENSION) (x)->DeviceExtension)->IsPdo))
#define ASSERT_PDO(x) ASSERT((((PCOMMON_EXTENSION) (x)->DeviceExtension)->IsPdo))
#define ASSERT_SRB_DATA(x) ASSERT(((PSRB_DATA)(x))->Type == SRB_DATA_TYPE)

#if DBG
#define SpStartNextPacket(DevObj, Cancelable)                       \
    {                                                               \
        PADAPTER_EXTENSION ext = (DevObj)->DeviceExtension;         \
        ASSERT(!(TEST_FLAG(ext->Flags, PD_PENDING_DEVICE_REQUEST)));\
        IoStartNextPacket((DevObj), (Cancelable));                  \
    }
#else
#define SpStartNextPacket IoStartNextPacket
#endif

//
// Some type defines and random macros which don't seem to be in the
// header files i've included (or didn't exist at all)
//

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#if 0   // DBG
#undef INLINE
#define INLINE
#else
#define INLINE __inline
#endif

#define INTERLOCKED /* Should only be accessed using InterlockedXxx routines*/

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

#define TEST(Value)             ((BOOLEAN) ((Value) ? TRUE : FALSE));

#define ARRAY_ELEMENTS_FOR_BITMAP(NumberOfBits, ArrayType) \
        ((NumberOfBits) / sizeof(ArrayType))

//
// Assorted constant definifitions
//
#define NUMBER_LOGICAL_UNIT_BINS 8

#define SP_DEFAULT_PHYSICAL_BREAK_VALUE 17
#define SP_SMALL_PHYSICAL_BREAK_VALUE 17
#define SP_LARGE_PHYSICAL_BREAK_VALUE (SP_DEFAULT_PHYSICAL_BREAK_VALUE + 1)

#define SCSIPORT_CONTROL_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ScsiPort\\"
#define DISK_SERVICE_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Disk"
#define SCSIPORT_SPECIAL_TARGET_KEY L"SpecialTargetList"
#define SCSIPORT_VERIFIER_KEY L"Verifier"

//
// WMI constants
//
#define SPMOFRESOURCENAME      L"SCSIPORTWMI"
#define SPMOFREGISTRYPATH      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ScsiPort"

//
// NT uses a system time measured in 100 nanosecond intervals.  define
// conveninent constants for setting the timer.
//

#define MICROSECONDS        10              // 10 nanoseconds
#define MILLISECONDS        (MICROSECONDS * 1000)
#define SECONDS             (MILLISECONDS * 1000)
#define MINUTES             (SECONDS * 60)

#define TIMEOUT(x)          ((x) * -1)

//
// Possible values for the IsRemoved flag
//

#define NO_REMOVE       0
#define REMOVE_PENDING  1
#define REMOVE_COMPLETE 2

#define NUMBER_HARDWARE_STRINGS 6

#define SRB_DATA_TYPE 'wp'
#define SRB_LIST_DEPTH 20

#define NUMBER_BYPASS_SRB_DATA_BLOCKS 4

#define WMI_MINIPORT_EVENT_ITEM_MAX_SIZE 128

//
// Define the mimimum and maximum number of srb extensions which will be allocated.
//

#define MINIMUM_SRB_EXTENSIONS        16
#define MAXIMUM_SRB_EXTENSIONS       255

//
// Size of the buffer used for registry operations.
//

#define SP_REG_BUFFER_SIZE 512

//
// Number of times to retry when a BUSY status is returned.
//

#define BUSY_RETRY_COUNT 20

//
// Number of times to retry an INQUIRY request.
//

#define INQUIRY_RETRY_COUNT 2

//
// Number of irp stack locations to allocate for an INQUIRY command.
//

#define INQUIRY_STACK_LOCATIONS 1

//
// Default Srb Timeout value
//

#define SRB_DEFAULT_TIMEOUT 10

//
// Bitmask used for aligning values.
//

#define LONG_ALIGN (sizeof(LONG) - 1)

//
// Size of the ADAPTER_EXTENSION
//

#define ADAPTER_EXTENSION_SIZE sizeof(ADAPTER_EXTENSION)

//
// Size of the buffer used for inquiry operations.  This is one more than the
// max bytes which can be requested from an inquiry operation so that we can
// zero out the buffer and be sure that the last string is null terminated.
//

#define SP_INQUIRY_BUFFER_SIZE (VPD_MAX_BUFFER_SIZE + 1)

//
// Assorted macros.
//

#define NEED_REQUEST_SENSE(Srb) (Srb->ScsiStatus == SCSISTAT_CHECK_CONDITION \
        && !(Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&                 \
        Srb->SenseInfoBuffer && Srb->SenseInfoBufferLength )

#define GET_FDO_EXTENSION(HwExt) ((CONTAINING_RECORD(HwExt, HW_DEVICE_EXTENSION, HwDeviceExtension))->FdoExtension)

#define ADDRESS_TO_HASH(PathId, TargetId, Lun) (((TargetId) + (Lun)) % NUMBER_LOGICAL_UNIT_BINS)

#define IS_CLEANUP_REQUEST(irpStack)                                                                    \
        (((irpStack)->MajorFunction == IRP_MJ_CLOSE) ||                                                 \
         ((irpStack)->MajorFunction == IRP_MJ_CLEANUP) ||                                               \
         ((irpStack)->MajorFunction == IRP_MJ_SHUTDOWN) ||                                              \
         (((irpStack)->MajorFunction == IRP_MJ_SCSI) &&                                                 \
          (((irpStack)->Parameters.Scsi.Srb->Function == SRB_FUNCTION_RELEASE_DEVICE) ||                \
           ((irpStack)->Parameters.Scsi.Srb->Function == SRB_FUNCTION_FLUSH_QUEUE) ||                   \
           (TEST_FLAG((irpStack)->Parameters.Scsi.Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE |        \
                                                                 SRB_FLAGS_BYPASS_LOCKED_QUEUE)))))


#define IS_INQUIRY(Srb)                                       \
    ((Srb)->Cdb[0] == SCSIOP_INQUIRY)
#define IS_REQUEST_SENSE(Srb)                                 \
    ((Srb)->Cdb[0] == SCSIOP_REQUEST_SENSE)
#define IS_READ_CAPACITY(Srb)                                 \
    ((Srb)->Cdb[0] == SCSIOP_READ_CAPACITY)
#define IS_READ(Srb)                                          \
    ((Srb)->Cdb[0] == SCSIOP_READ)
#define IS_WRITE(Srb)                                         \
    ((Srb)->Cdb[0] == SCSIOP_WRITE)
#define IS_COPY(Srb)                                          \
    ((Srb)->Cdb[0] == SCSIOP_COPY)
#define IS_COMPARE(Srb)                                       \
    ((Srb)->Cdb[0] == SCSIOP_COMPARE)
#define IS_COPY_COMPARE(Srb)                                  \
    ((Srb)->Cdb[0] == SCSIOP_COPY_COMPARE)
    
#define IS_MAPPED_SRB(Srb)                                    \
        (((Srb)->Function == SRB_FUNCTION_IO_CONTROL) ||      \
         (((Srb)->Function == SRB_FUNCTION_EXECUTE_SCSI) &&   \
          ((IS_INQUIRY((Srb))) ||                             \
           (IS_REQUEST_SENSE((Srb))) ||                       \
           (IS_READ_CAPACITY((Srb))))))

#define IS_ILLEGAL_COMMAND(Srb)                               \
    (IS_COPY((Srb)) ||                                        \
     IS_COMPARE((Srb)) ||                                     \
     IS_COPY_COMPARE((Srb)))

#define LU_OPERATING_IN_DEGRADED_STATE(luFlags)               \
        ((luFlags) & LU_PERF_MAXQDEPTH_REDUCED)


//
// SpIsQueuePausedForSrb(lu, srb) -
//  determines if the queue has been paused for this particular type of
//  srb.  This can be used with SpSrbIsBypassRequest to determine whether the
//  srb needs to be handled specially.
//

#define SpIsQueuePausedForSrb(luFlags, srbFlags)                                                            \
    ((BOOLEAN) ((((luFlags) & LU_QUEUE_FROZEN) && !(srbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE)) ||           \
                (((luFlags) & LU_QUEUE_PAUSED) && !(srbFlags & SRB_FLAGS_BYPASS_LOCKED_QUEUE))))

#define SpIsQueuePaused(lu) ((lu)->LuFlags & (LU_QUEUE_FROZEN           |   \
                                              LU_QUEUE_LOCKED))

#define SpSrbRequiresPower(srb)                                             \
    ((BOOLEAN) ((srb->Function == SRB_FUNCTION_EXECUTE_SCSI) ||             \
                 (srb->Function == SRB_FUNCTION_IO_CONTROL) ||              \
                 (srb->Function == SRB_FUNCTION_SHUTDOWN) ||                \
                 (srb->Function == SRB_FUNCTION_FLUSH) ||                   \
                 (srb->Function == SRB_FUNCTION_ABORT_COMMAND) ||           \
                 (srb->Function == SRB_FUNCTION_RESET_BUS) ||               \
                 (srb->Function == SRB_FUNCTION_RESET_DEVICE) ||            \
                 (srb->Function == SRB_FUNCTION_TERMINATE_IO) ||            \
                 (srb->Function == SRB_FUNCTION_REMOVE_DEVICE) ||           \
                 (srb->Function == SRB_FUNCTION_WMI)))

//
// Forward declarations of data structures
//

typedef struct _SRB_DATA SRB_DATA, *PSRB_DATA;

typedef struct _REMOVE_TRACKING_BLOCK
               REMOVE_TRACKING_BLOCK,
               *PREMOVE_TRACKING_BLOCK;

typedef struct _LOGICAL_UNIT_EXTENSION LOGICAL_UNIT_EXTENSION, *PLOGICAL_UNIT_EXTENSION;
typedef struct _ADAPTER_EXTENSION ADAPTER_EXTENSION, *PADAPTER_EXTENSION;

typedef struct _SP_INIT_CHAIN_ENTRY SP_INIT_CHAIN_ENTRY, *PSP_INIT_CHAIN_ENTRY;

typedef struct _HW_DEVICE_EXTENSION HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;
//
// Macros for using the DMA functions.
//

#define AllocateCommonBuffer(DmaAdapter, Length,                        \
                               LogicalAddress, CacheEnabled)            \
            ((DmaAdapter)->DmaOperations->AllocateCommonBuffer)(        \
                (DmaAdapter),                                           \
                (Length),                                               \
                (LogicalAddress),                                       \
                (CacheEnabled))
#define FreeCommonBuffer(DmaAdapter, Length, LogicalAddress,            \
                         VirtualAddress, CacheEnabled)                  \
            ((DmaAdapter)->DmaOperations->FreeCommonBuffer)(            \
                (DmaAdapter),                                           \
                (Length),                                               \
                (LogicalAddress),                                       \
                (VirtualAddress),                                       \
                (CacheEnabled))

#define GetScatterGatherList(DmaAdapter, DeviceObject, Mdl, CurrentVa,      \
                             Length, ExecutionRoutine, Context,             \
                             WriteToDevice)                                 \
            ((DmaAdapter)->DmaOperations->GetScatterGatherList)(            \
                (DmaAdapter),                                               \
                (DeviceObject),                                             \
                (Mdl),                                                      \
                (CurrentVa),                                                \
                (Length),                                                   \
                (ExecutionRoutine),                                         \
                (Context),                                                  \
                (WriteToDevice))

#define PutScatterGatherList(DmaAdapter, ScatterGather, WriteToDevice)      \
            ((DmaAdapter)->DmaOperations->PutScatterGatherList)(            \
                (DmaAdapter),                                               \
                (ScatterGather),                                            \
                (WriteToDevice))

#define AllocateAdapterChannel(DmaAdapter, DeviceObject,                    \
                               NumberOfMapRegisters, ExecutionRoutine,      \
                               Context)                                     \
            ((DmaAdapter)->DmaOperations->AllocateAdapterChannel)(          \
                (DmaAdapter),                                               \
                (DeviceObject),                                             \
                (NumberOfMapRegisters),                                     \
                (ExecutionRoutine),                                         \
                (Context))

#define FlushAdapterBuffers(DmaAdapter, Mdl, MapRegisterBase, CurrentVa,    \
                            Length, WriteToDevice)                          \
            ((DmaAdapter)->DmaOperations->FlushAdapterBuffers)(             \
                (DmaAdapter),                                               \
                (Mdl),                                                      \
                (MapRegisterBase),                                          \
                (CurrentVa),                                                \
                (Length),                                                   \
                (WriteToDevice))

#define MapTransfer(DmaAdapter, Mdl, MapRegisterBase, CurrentVa, Length,    \
                    WriteToDevice)                                          \
            ((DmaAdapter)->DmaOperations->MapTransfer)(                     \
                (DmaAdapter),                                               \
                (Mdl),                                                      \
                (MapRegisterBase),                                          \
                (CurrentVa),                                                \
                (Length),                                                   \
                (WriteToDevice))

#define FreeAdapterChannel(DmaAdapter)                                      \
            ((DmaAdapter)->DmaOperations->FreeAdapterChannel)((DmaAdapter))

#define FreeMapRegisters(DmaAdapter, MapRegisterBase, NumberOfMapRegisters) \
            ((DmaAdapter)->DmaOperations->FreeMapRegisters)(                \
                (DmaAdapter),                                               \
                (MapRegisterBase),                                          \
                (NumberOfMapRegisters))

#define PutDmaAdapter(DmaAdapter)                                           \
            ((DmaAdapter)->DmaOperations->PutDmaAdapter)((DmaAdapter))


#define BuildScatterGatherList(DmaAdapter, DevObj, Mdl, DataBuffer,         \
                               DataTransferLength, ExecutionRoutine,        \
                               Context, Write, Buffer, BufSize)             \
    ((DmaAdapter)->DmaOperations->BuildScatterGatherList)(                  \
        (DmaAdapter),                                                       \
        (DevObj),                                                           \
        (Mdl),                                                              \
        (DataBuffer),                                                       \
        (DataTransferLength),                                               \
        (ExecutionRoutine),                                                 \
        (Context),                                                          \
        (Write),                                                            \
        (Buffer),                                                           \
        (BufSize))

#define CalculateScatterGatherList(DmaAdapter, Mdl, CurrentVa, Length,      \
                                       SGListSize, NumberOfMapRegs)         \
    ((DmaAdapter)->DmaOperations->CalculateScatterGatherList)(              \
        (DmaAdapter),                                                       \
        (Mdl),                                                              \
        (CurrentVa),                                                        \
        (Length),                                                           \
        (SGListSize),                                                       \
        (NumberOfMapRegs))

//
// Type Definitions
//

//
// Structure used for tracking remove lock allocations in checked builds
//

struct _REMOVE_TRACKING_BLOCK {
    PREMOVE_TRACKING_BLOCK NextBlock;
    PVOID Tag;
    LARGE_INTEGER TimeLocked;
    PCSTR File;
    ULONG Line;
};

#if DBG
#define SpAcquireRemoveLock(devobj, tag) \
    SpAcquireRemoveLockEx(devobj, tag, __file__, __LINE__)
#endif

typedef struct _RESET_COMPLETION_CONTEXT {
    PIRP           OriginalIrp;
    PDEVICE_OBJECT SafeLogicalUnit;
    PDEVICE_OBJECT AdapterDeviceObject;

    SCSI_REQUEST_BLOCK Srb;
} RESET_COMPLETION_CONTEXT, *PRESET_COMPLETION_CONTEXT;

//
// Define a pointer to the synchonize execution routine.
//

typedef
BOOLEAN
(*PSYNCHRONIZE_ROUTINE) (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

typedef
VOID
(*PSP_ENABLE_DISABLE_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    );

typedef
VOID
(*PSP_POWER_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

//
// device type table to build id's from
//

typedef const struct _SCSIPORT_DEVICE_TYPE {

    const PCSTR DeviceTypeString;

    const PCSTR GenericTypeString;

    const PCWSTR DeviceMapString;

    const BOOLEAN IsStorage;

} SCSIPORT_DEVICE_TYPE, *PSCSIPORT_DEVICE_TYPE;

//
// SCSI Get Configuration Information
//
// LUN Information
//

typedef struct _LOGICAL_UNIT_INFO {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    BOOLEAN DeviceClaimed;
    struct _LOGICAL_UNIT_INFO *NextLunInfo;
    UCHAR InquiryData[INQUIRYDATABUFFERSIZE];
} LOGICAL_UNIT_INFO, *PLOGICAL_UNIT_INFO;

typedef struct _SCSI_BUS_SCAN_DATA {
    USHORT Length;
    UCHAR InitiatorBusId;
    UCHAR NumberOfLogicalUnits;
    PLOGICAL_UNIT_INFO LunInfoList;
} SCSI_BUS_SCAN_DATA, *PSCSI_BUS_SCAN_DATA;

typedef struct _SCSI_CONFIGURATION_INFO {
    UCHAR NumberOfBuses;
    PSCSI_BUS_SCAN_DATA BusScanData[1];
} SCSI_CONFIGURATION_INFO, *PSCSI_CONFIGURATION_INFO;

//
// Adapter object transfer information.
//

typedef struct _ADAPTER_TRANSFER {
    PSRB_DATA SrbData;
    ULONG SrbFlags;
    PVOID LogicalAddress;
    ULONG Length;
}ADAPTER_TRANSFER, *PADAPTER_TRANSFER;

//
// NOTE: When the hal is performing double buffering (e.g. a 32-bit HBA on a
// 64-bit machine) the HalContext (below) is necessary. Otherwise, this is
// wasted space. It would be nice to detect this and only allocate the
// extra memory when necessary.
//

typedef struct _SRB_SCATTER_GATHER_LIST {
    ULONG                  NumberOfElements;
    ULONG_PTR              Reserved;
    SCATTER_GATHER_ELEMENT Elements[SP_SMALL_PHYSICAL_BREAK_VALUE];
    UCHAR                  HalContext[sizeof (INTERNAL_WAIT_CONTEXT_BLOCK)];
} SRB_SCATTER_GATHER_LIST, *PSRB_SCATTER_GATHER_LIST;

typedef SCATTER_GATHER_ELEMENT SRB_SCATTER_GATHER, *PSRB_SCATTER_GATHER;

//
// Port driver error logging
//

typedef struct _ERROR_LOG_ENTRY {
    UCHAR MajorFunctionCode;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    ULONG ErrorCode;
    ULONG UniqueId;
    ULONG ErrorLogRetryCount;
    ULONG SequenceNumber;
} ERROR_LOG_ENTRY, *PERROR_LOG_ENTRY;

typedef struct _SP_LUN_IO_LOG {
    UCHAR SrbStatus;                // +0
    UCHAR ScsiStatus;               // +1
    UCHAR CdbLength;                // +2
    UCHAR Tag;                      // +3
    UCHAR Cdb[16];                  // +4
    UCHAR SenseData[18];            // +20
    UCHAR SenseDataLength;          // +38
    union {                         // +40
        ULONG InternalStatus; 
        ULONG QueueSortKey; 
    };
    ULONG TickCount;                // +44
} SP_LUN_IO_LOG, *PSP_LUN_IO_LOG;

//
// Context item for asynchronous enumerators.
//

typedef struct _SP_ENUMERATION_REQUEST SP_ENUMERATION_REQUEST, *PSP_ENUMERATION_REQUEST;

typedef
VOID
(*PSP_ENUMERATION_COMPLETION_ROUTINE) (
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST Request,
    IN NTSTATUS Status
    );

struct _SP_ENUMERATION_REQUEST {

    //
    // A pointer to the next enumeration request on the list.
    //

    PSP_ENUMERATION_REQUEST NextRequest;

    //
    // The completion routine to be run.  This routine will be run regardless
    // of whether the enumeration actually succeeds.  The
    // EnumerationDeviceMutex and the EnumerationWorklistMutex will both be
    // held when this is called.  The completion routine should free the Request
    // structure if necessary.
    //

    PSP_ENUMERATION_COMPLETION_ROUTINE CompletionRoutine;

    //
    // If this filed contains a pointer to an IO_STATUS_BLOCK then the
    // completion routine should write it's status value out.  This is so a
    // synchronous waiter can return something other than STATUS_PENDING to the
    // caller.  If this field is NULL then there is no consumer for the status
    // value.
    //

    PNTSTATUS OPTIONAL CompletionStatus;

    //
    // Arbitrary context value for the completion routine to use.  In most cases
    // this will be an IRP or an event.
    //

    PVOID Context;

    //
    // Indicates whether this request is being handled synchronously.
    //

    BOOLEAN Synchronous;
};

//
// SCSI request extension for port driver.
//

typedef
VOID
(FASTCALL *PSRB_DATA_FREE_ROUTINE) (
    IN PADAPTER_EXTENSION Adapter,
    IN PSRB_DATA SrbData
    );

struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _SRB_DATA {

    //
    // Single list entry.  The lookaside list will be maintained in this
    // memory.
    //

    SLIST_ENTRY Reserved;

    //
    // Header for debugging purposes.
    //

    CSHORT Type;
    USHORT Size;

    //
    // The free routine for this srb data block.
    //

    PSRB_DATA_FREE_ROUTINE FreeRoutine;

    //
    // The list of requests for a particular logical unit.
    //

    LIST_ENTRY RequestList;

    //
    // The logical unit this request is intended for.
    //

    PLOGICAL_UNIT_EXTENSION LogicalUnit;

    //
    // The irp for the CurrentSrb.
    //

    PIRP CurrentIrp;

    //
    // The srb this is block is tracking.
    //

    PSCSI_REQUEST_BLOCK CurrentSrb;

    //
    // The chain of requests which have been completed by the miniport and are
    // waiting for the CompletionDpc to be run.
    //

    struct _SRB_DATA *CompletedRequests;
    ULONG ErrorLogRetryCount;
    ULONG SequenceNumber;

    PSCATTER_GATHER_LIST MapRegisterBase;

    ULONG NumberOfMapRegisters;

    //
    // The offset between the  data buffer for this request and the data
    // buffer described by the MDL in the irp.
    //

    ULONG_PTR DataOffset;

    PVOID RequestSenseSave;

    //
    // These data values will be restored to the SRB when it is retried within
    // the port driver.
    //

    ULONG OriginalDataTransferLength;

    //
    // SRB Data flags.
    //

    ULONG Flags;

    //
    // Pointer to the adapter this block was allocated from.  This is used
    // when freeing srbdata blocks from the lookaside list back to pool.
    //

    PADAPTER_EXTENSION Adapter;

    //
    // The queue tag which was initially allocated for this srb_data block.
    // This tag will be used for any tagged srb's which are associated with
    // this block.
    //

    ULONG QueueTag;

    //
    // Internal status value - only returned if srb->SrbStatus is set to
    // SRBP_STATUS_INTERNAL_ERROR.
    //

    NTSTATUS InternalStatus;

    //
    // The tick count when this request was last touched.
    //

    ULONG TickCount;

    //
    // The MDL of the remapped buffer (per IoMapTransfer or GET_SCATTER_GATHER)
    //

    PMDL RemappedMdl;

    //
    // The original data buffer pointer for this request - this will be
    // restored when the request is completed.
    //

    PVOID OriginalDataBuffer;

    //
    // Pointer to the scatter gather list for this request
    //

    PSRB_SCATTER_GATHER ScatterGatherList;

    //
    // The original length of the sense data buffer supplied by the above
    // driver.
    //

    UCHAR RequestSenseLengthSave;

    //
    // Pointer to the orignal SRB DataBuffer.  We use this to store
    // the original when we replace it with our buffer to unmapped
    // memory in the case where the MapBuffer is FALSE.
    //

    PVOID UnmappedDataBuffer;

    //
    // The "small" scatter gather list for this request.  Small
    // by the constant SP_SMALL_PHYSICAL_BREAK_VALUE - small lists contain
    // this many entries or less.
    //

    SRB_SCATTER_GATHER_LIST SmallScatterGatherList;

};

typedef struct _LOGICAL_UNIT_BIN {
    KSPIN_LOCK Lock;
    PLOGICAL_UNIT_EXTENSION List;
} LOGICAL_UNIT_BIN, *PLOGICAL_UNIT_BIN;

//
// WMI request item, queued on a miniport request.
//

typedef struct _WMI_MINIPORT_REQUEST_ITEM {
   //
   // WnodeEventItem MUST be the first field in WMI_MINIPORT_REQUEST_ITEM, in
   // order to accommodate a copy optimization in ScsiPortCompletionDpc().
   //
   UCHAR  WnodeEventItem[WMI_MINIPORT_EVENT_ITEM_MAX_SIZE];
   UCHAR  TypeOfRequest;                                  // [Event/Reregister]
   UCHAR  PathId;                                         // [0xFF for adapter]
   UCHAR  TargetId;
   UCHAR  Lun;
   struct _WMI_MINIPORT_REQUEST_ITEM * NextRequest;
} WMI_MINIPORT_REQUEST_ITEM, *PWMI_MINIPORT_REQUEST_ITEM;

//
// WMI parameters.
//

typedef struct _WMI_PARAMETERS {
   ULONG_PTR ProviderId; // ProviderId parameter from IRP
   PVOID DataPath;      // DataPath parameter from IRP
   ULONG BufferSize;    // BufferSize parameter from IRP
   PVOID Buffer;        // Buffer parameter from IRP
} WMI_PARAMETERS, *PWMI_PARAMETERS;

//
// SpInsertFreeWmiMiniPortItem context structure.
//

typedef struct _WMI_INSERT_CONTEXT {
   PDEVICE_OBJECT             DeviceObject;                     // [FDO or PDO]
   PWMI_MINIPORT_REQUEST_ITEM ItemsToInsert;
} WMI_INSERT_CONTEXT, *PWMI_INSERT_CONTEXT;

//
// SpRemoveFreeWmiMiniPortItem context structure.
//

typedef struct _WMI_REMOVE_CONTEXT {
   PDEVICE_OBJECT             DeviceObject;                     // [FDO or PDO]
   USHORT                     NumberToRemove;
} WMI_REMOVE_CONTEXT, *PWMI_REMOVE_CONTEXT;

//
// Define data storage for access at interrupt Irql.
//

typedef struct _INTERRUPT_DATA {

    //
    // SCSI port interrupt flags
    //

    ULONG InterruptFlags;

    //
    // List head for singlely linked list of complete IRPs.
    //

    PSRB_DATA CompletedRequests;

    //
    // Adapter object transfer parameters.
    //

    ADAPTER_TRANSFER MapTransferParameters;

    //
    // Error log information.
    //

    ERROR_LOG_ENTRY  LogEntry;

    //
    // Logical unit to start next.
    //

    PLOGICAL_UNIT_EXTENSION ReadyLogicalUnit;

    //
    // List of completed abort reqeusts.
    //

    PLOGICAL_UNIT_EXTENSION CompletedAbort;

    //
    // Miniport timer request routine.
    //

    PHW_INTERRUPT HwTimerRequest;

    //
    // Mini port timer request time in micro seconds.
    //

    ULONG MiniportTimerValue;

    //
    // Queued WMI request items.
    //

    PWMI_MINIPORT_REQUEST_ITEM WmiMiniPortRequests;

    //
    // A couple of counters used to keep track of when the last interrupt
    // occurred on this device.
    //

    ULONG TickCountAtLastInterruptAck;
    ULONG TickCountAtLastInterruptNak;

} INTERRUPT_DATA, *PINTERRUPT_DATA;

#define NON_STANDARD_VPD_SUPPORTS_PAGE80 0x00000001
#define NON_STANDARD_VPD_SUPPORTS_PAGE83 0x00000002

typedef struct {
    ULONG SparseLun;
    ULONG OneLun;
    ULONG LargeLuns;
    ULONG SetLunInCdb;
    ULONG NonStandardVPD;
    ULONG BinarySN;
} SP_SPECIAL_CONTROLLER_FLAGS, *PSP_SPECIAL_CONTROLLER_FLAGS;

typedef struct _CONFIGURATION_CONTEXT {
    BOOLEAN DisableTaggedQueueing;
    BOOLEAN DisableMultipleLu;
    ULONG AdapterNumber;
    ULONG BusNumber;
    PVOID Parameter;
    PACCESS_RANGE AccessRanges;
    UNICODE_STRING RegistryPath;
    PORT_CONFIGURATION_INFORMATION PortConfig;
}CONFIGURATION_CONTEXT, *PCONFIGURATION_CONTEXT;

typedef struct _DEVICE_MAP_HANDLES {
    HANDLE BusKey;
    HANDLE InitiatorKey;
} DEVICE_MAP_HANDLES, *PDEVICE_MAP_HANDLES;

typedef struct _COMMON_EXTENSION {

    //
    // Back pointer to the device object
    //

    PDEVICE_OBJECT DeviceObject;

    struct {

        //
        // True if this device object is a physical device object
        //

        BOOLEAN IsPdo : 1;

        //
        // True if this device object has processed it's first start and
        // has been initialized.
        //

        BOOLEAN IsInitialized : 1;

        //
        // Has WMI been initialized for this device object?
        //

        BOOLEAN WmiInitialized : 1;

        //
        // Has the miniport associated with this FDO or PDO indicated WMI
        // support?
        //

        BOOLEAN WmiMiniPortSupport : 1;

        //
        // Has the miniport been initialized for WMI.
        //

        BOOLEAN WmiMiniPortInitialized : 1;

    };

    //
    // Current plug and play state or 0xff if no state operations have been
    // sent yet.
    //

    UCHAR CurrentPnpState;

    //
    // Previous plug and play state or 0xff if there is no requirement that we
    // be able to roll back in the current state (current state is not a query)
    //

    UCHAR PreviousPnpState;

    //
    // Interlocked counter indicating that the device has been removed.
    //

    ULONG IsRemoved;


    //
    // Pointer to the device object this is on top of
    //

    PDEVICE_OBJECT LowerDeviceObject;

    //
    // Srb flags to OR into all SRBs coming through this device object.
    //

    ULONG SrbFlags;

    //
    // Pointer to the dispatch table for this object
    //

    PDRIVER_DISPATCH *MajorFunction;


    //
    // Current and desired power state for this device and the system.
    //

    SYSTEM_POWER_STATE CurrentSystemState;

    DEVICE_POWER_STATE CurrentDeviceState;

    DEVICE_POWER_STATE DesiredDeviceState;

    //
    // Idle timer for this device
    //

    PULONG IdleTimer;

    //
    // Pointer to the SCSIPORT-provided WMIREGINFO structures registered on
    // behalf of the miniport for this device object.  Size is the size of the
    // entire WMIREGINFO buffer in bytes.
    //

    PWMIREGINFO WmiScsiPortRegInfoBuf;
    ULONG       WmiScsiPortRegInfoBufSize;

    //
    // INTERLOCKED counter of the number of consumers of this device object.
    // When this count goes to zero the RemoveEvent will be set.
    //

    //
    // This variable is only manipulated by SpAcquireRemoveLock and
    // SpReleaseRemoveLock.
    //

    LONG RemoveLock;

    //
    // This event will be signalled when it is safe to remove the device object
    //

    KEVENT RemoveEvent;

    //
    // The spinlock and the list are only used in checked builds to track who
    // has acquired the remove lock.  Free systems will leave these initialized
    // to 0xff (they are still in the structure to make debugging easier)
    //

    KSPIN_LOCK RemoveTrackingSpinlock;

    PVOID RemoveTrackingList;

    LONG RemoveTrackingUntrackedCount;

    NPAGED_LOOKASIDE_LIST RemoveTrackingLookasideList;

    BOOLEAN RemoveTrackingLookasideListInitialized;

    //
    // Count of different services this device is being used for (ala
    // IRP_MN_DEVICE_USAGE_NOTIFICATION)
    //

    ULONG PagingPathCount;
    ULONG HibernatePathCount;
    ULONG DumpPathCount;

} COMMON_EXTENSION, *PCOMMON_EXTENSION;

typedef struct _VERIFIER_EXTENSION {

    //
    // Miniport routines we verify.
    //

    PHW_FIND_ADAPTER    RealHwFindAdapter;
    PHW_INITIALIZE      RealHwInitialize;
    PHW_STARTIO         RealHwStartIo;
    PHW_INTERRUPT       RealHwInterrupt;
    PHW_RESET_BUS       RealHwResetBus;
    PHW_DMA_STARTED     RealHwDmaStarted;
    PHW_INTERRUPT       RealHwRequestInterrupt;
    PHW_INTERRUPT       RealHwTimerRequest;
    PHW_ADAPTER_CONTROL RealHwAdapterControl;

    //
    // Indicates the number of common buffer blocks that have been allocated.
    //

    ULONG CommonBufferBlocks;

    //
    // Points to an array that holds the VAs of all the common blocks.
    //

    PVOID* CommonBufferVAs;

    //
    // Points to an array that holds the PAs of all the common blocks.
    //

    PHYSICAL_ADDRESS* CommonBufferPAs;

    //
    // Indicates the size of the non-cached extension.
    //

    ULONG NonCachedBufferSize;

    //
    // Controls how aggressively we verify.
    //

    ULONG VrfyLevel;

    //
    // Pointer to an invalid page of memory.  Used to catch miniports
    // that touch memory when they're not supposed to.
    //

    PVOID InvalidPage;

    //
    // Indicates whether the common buffer blocks were allocated using
    // DMA common buffer allocation routine.
    //

    BOOLEAN IsCommonBuffer;

} VERIFIER_EXTENSION, *PVERIFIER_EXTENSION;


struct _ADAPTER_EXTENSION {

    union {
        PDEVICE_OBJECT DeviceObject;
        COMMON_EXTENSION CommonExtension;
    };

    //
    // Pointer to the PDO we attached to - necessary for PnP routines
    //

    PDEVICE_OBJECT LowerPdo;

#if TEST_LISTS

    //
    // Some simple performance counters to determine how often we use the
    // small vs. medium vs. large scatter gather lists.
    //

    ULONGLONG ScatterGatherAllocationCount;

    //
    // Counters used to calculate the average size of a small medium and
    // large allocation.  There are two values for each counter - a total
    // count and an overflow count.  The total count will be right-shifted one
    // bit if it overflows on an increment.  When this happens the overflow
    // count will also be incremented.  This count is used to adjust the
    // allocation count when determining averages.
    //

    ULONGLONG SmallAllocationSize;
    ULONGLONG MediumAllocationSize;
    ULONGLONG LargeAllocationSize;

    ULONG SmallAllocationCount;
    ULONG LargeAllocationCount;

    //
    // Counters to determine how often we can service a request off the
    // srb data list, how often we need to queue a request and how often
    // we can resurrect a free'd srb data to service something off the queue.
    //

    INTERLOCKED ULONGLONG SrbDataAllocationCount;
    INTERLOCKED ULONGLONG SrbDataQueueInsertionCount;
    INTERLOCKED ULONGLONG SrbDataEmergencyFreeCount;
    INTERLOCKED ULONGLONG SrbDataServicedFromTickHandlerCount;
    INTERLOCKED ULONGLONG SrbDataResurrectionCount;

#endif

    //
    // Device extension for miniport routines.
    //

    PVOID HwDeviceExtension;

    //
    // Miniport noncached device extension
    //

    PVOID NonCachedExtension;
    ULONG NonCachedExtensionSize;

    ULONG PortNumber;

    ULONG AdapterNumber;

    //
    // Active requests count.  This count is biased by -1 so a value of -1
    // indicates there are no requests out standing.
    //

    LONG ActiveRequestCount;

    //
    // Binary Flags
    //

    typedef struct {

        //
        // Did pnp or the port driver detect this device and provide resources
        // to the miniport, or did the miniport detect the device for us.  This
        // flag also indicates whether the AllocatedResources list is non-null
        // going into the find adapter routine.
        //

        BOOLEAN IsMiniportDetected : 1;

        //
        // Do we need to virtualize this adapter and make it look like the only
        // adapter on it's own bus?
        //

        BOOLEAN IsInVirtualSlot : 1;

        //
        // Is this a pnp adapter?
        //

        BOOLEAN IsPnp : 1;

        //
        // Was an interrupt assigned to this device by the system?
        //

        BOOLEAN HasInterrupt : 1;

        //
        // Can this device be powered off?
        //

        BOOLEAN DisablePower : 1;

        //
        // Can this device be stopped?
        //

        BOOLEAN DisableStop : 1;

        //
        // Does this device need power notification on shutdown?
        //

        BOOLEAN NeedsShutdown : 1;

    };

    //
    // For most virtual slot devices this will be zero.  However for some
    // the real slot/function number is needed by the miniport to access
    // hardware shared by multiple slots/functions.
    //

    PCI_SLOT_NUMBER VirtualSlotNumber;

    //
    // The bus and slot number of this device as returned by the PCI driver.
    // This is used when building the ConfigInfo block for crashdump so that
    // the dump drivers can talk directly with the hal.  These are only
    // valid if IsInVirtualSlot is TRUE above.
    //

    ULONG RealBusNumber;

    ULONG RealSlotNumber;

    //
    // Number of SCSI buses
    //

    UCHAR NumberOfBuses;
    UCHAR MaximumTargetIds;
    UCHAR MaxLuCount;

    //
    // SCSI port driver flags
    //

    ULONG Flags;

    INTERLOCKED ULONG DpcFlags;

    //
    // The number of times this adapter has been disabled.
    //

    ULONG DisableCount;

    LONG PortTimeoutCounter;

    //
    // A pointer to the interrupt object to be used with
    // the SynchronizeExecution routine.  If the miniport is
    // using SpSynchronizeExecution then this will actually point
    // back to the adapter extension.
    //

    PKINTERRUPT InterruptObject;

    //
    // Second Interrupt object (PCI IDE work-around)
    //

    PKINTERRUPT InterruptObject2;

    //
    // Routine to call to synchronize execution for the miniport.
    //

    PSYNCHRONIZE_ROUTINE  SynchronizeExecution;

    //
    // Global device sequence number.
    //

    ULONG SequenceNumber;
    KSPIN_LOCK SpinLock;

    //
    // Second spin lock (PCI IDE work-around).  This is only initalized
    // if the miniport has requested multiple interrupts.
    //

    KSPIN_LOCK MultipleIrqSpinLock;

    //
    // Dummy interrupt spin lock.
    //

    KSPIN_LOCK InterruptSpinLock;

    //
    // Dma Adapter information.
    //

    PVOID MapRegisterBase;
    PDMA_ADAPTER DmaAdapterObject;
    ADAPTER_TRANSFER FlushAdapterParameters;

    //
    // miniport's copy of the configuraiton informaiton.
    // Used only during initialization.
    //

    PPORT_CONFIGURATION_INFORMATION PortConfig;

    //
    // Resources allocated and translated for this particular adapter.
    //

    PCM_RESOURCE_LIST AllocatedResources;

    PCM_RESOURCE_LIST TranslatedResources;

    //
    // Common buffer size.  Used for HalFreeCommonBuffer.
    //

    ULONG CommonBufferSize;
    ULONG SrbExtensionSize;

    //
    // Indicates whether the common buffer was allocated using
    // ALLOCATE_COMMON_BUFFER or MmAllocateContiguousMemorySpecifyCache.
    //

    BOOLEAN UncachedExtensionIsCommonBuffer;

    //
    // The number of srb extensions which were allocated.
    //

    ULONG SrbExtensionCount;

    //
    // Placeholder for the minimum number of requests to allocate for.
    // This can be a registry parameter.
    //

    ULONG NumberOfRequests;

    //
    // SrbExtension and non-cached common buffer
    //

    PVOID SrbExtensionBuffer;

    //
    // List head of free SRB extentions.
    //

    PVOID SrbExtensionListHeader;

    //
    // A bitmap for keeping track of which queue tags are in use.
    //

    KSPIN_LOCK QueueTagSpinLock;
    PRTL_BITMAP QueueTagBitMap;

    UCHAR MaxQueueTag;

    //
    // Hint for allocating queue tags.  Value will be the last queue
    // tag allocated + 1.
    //

    ULONG QueueTagHint;

    //
    // Logical Unit Extensions
    //

    ULONG HwLogicalUnitExtensionSize;

    //
    // List of mapped address entries for use when powering up the adapter
    // or cleaning up its mappings.
    //

    PMAPPED_ADDRESS MappedAddressList;

    //
    // List of free mapped address blocks preallocated by scsiport before 
    // calling HwFindAdapter.  One is allocated for each memory range in the 
    // miniport's resource list.  As ranges are unmapped their blocks will 
    // be placed here for potential reuse by the miniport's HwFindAdapter 
    // routine.
    //

    PMAPPED_ADDRESS FreeMappedAddressList;

    //
    // Miniport service routine pointers.
    //

    PHW_FIND_ADAPTER HwFindAdapter;
    PHW_INITIALIZE HwInitialize;
    PHW_STARTIO HwStartIo;
    PHW_INTERRUPT HwInterrupt;
    PHW_RESET_BUS HwResetBus;
    PHW_DMA_STARTED HwDmaStarted;
    PHW_INTERRUPT HwRequestInterrupt;
    PHW_INTERRUPT HwTimerRequest;
    PHW_ADAPTER_CONTROL HwAdapterControl;

    ULONG InterruptLevel;
    ULONG IoAddress;

    //
    // BitMap containing the list of supported adapter control types for this
    // adapter/miniport.
    //

    RTL_BITMAP SupportedControlBitMap;
    ULONG SupportedControlBits[ARRAY_ELEMENTS_FOR_BITMAP(
                                    (ScsiAdapterControlMax),
                                    ULONG)];

    //
    // Array of logical unit extensions.
    //

    LOGICAL_UNIT_BIN LogicalUnitList[NUMBER_LOGICAL_UNIT_BINS];

    //
    // The last logical unit for which the miniport completed a request.  This
    // will give us a chance to stay out of the LogicalUnitList for the common
    // completion type.
    //
    // This value is set by ScsiPortNotification and will be cleared by
    // SpRemoveLogicalUnitFromBin.
    //

    PLOGICAL_UNIT_EXTENSION CachedLogicalUnit;

    //
    // Interrupt level data storage.
    //

    INTERRUPT_DATA InterruptData;

    //
    // Whether or not an interrupt has occured since the last timeout.
    // Used to determine if interrupts may not be getting delivered.
    // This value must be set within KeSynchronizeExecution
    //

    ULONG WatchdogInterruptCount;

    //
    // SCSI Capabilities structure
    //

    IO_SCSI_CAPABILITIES Capabilities;

    //
    // Miniport timer object.
    //

    KTIMER MiniPortTimer;

    //
    // Miniport DPC for timer object.
    //

    KDPC MiniPortTimerDpc;

    //
    // Physical address of common buffer
    //

    PHYSICAL_ADDRESS PhysicalCommonBuffer;

    //
    // Buffers must be mapped into system space.
    //

    BOOLEAN MapBuffers;

    //
    // Buffers must be remapped into system space after IoMapTransfer has been
    // called.
    //

    BOOLEAN RemapBuffers;

    //
    // Is this device a bus master and does it require map registers.
    //

    BOOLEAN MasterWithAdapter;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Supports auto request sense.
    //

    BOOLEAN AutoRequestSense;

    //
    // Supports multiple requests per logical unit.
    //

    BOOLEAN MultipleRequestPerLu;

    //
    // Support receive event function.
    //

    BOOLEAN ReceiveEvent;

    //
    // Indicates an srb extension needs to be allocated.
    //

    BOOLEAN AllocateSrbExtension;

    //
    // Indicates the contorller caches data.
    //

    BOOLEAN CachesData;

    //
    // Indicates that the adapter can handle 64-bit DMA.
    //

    BOOLEAN Dma64BitAddresses;

    //
    // Indicates that the adapter can handle 32-bit DMA.
    //

    BOOLEAN Dma32BitAddresses;

    //
    // Queued WMI request items that are not in use.
    //
    INTERLOCKED SLIST_HEADER    WmiFreeMiniPortRequestList;
    KSPIN_LOCK                  WmiFreeMiniPortRequestLock;
    INTERLOCKED ULONG           WmiFreeMiniPortRequestWatermark;
    INTERLOCKED ULONG           WmiFreeMiniPortRequestCount;
    BOOLEAN                     WmiFreeMiniPortRequestInitialized;

    //
    // Free WMI request items were exhausted at least once in the lifetime
    // of this adapter (used to log error only once).
    //

    BOOLEAN                    WmiFreeMiniPortRequestsExhausted;

    //
    // This mutex is used to synchronize access & modification of the list
    // of devices during enumeration & reporting.
    //

    KMUTEX EnumerationDeviceMutex;

    //
    // This fast-mutex is used to protect the enumeration work-item and
    // the list of completion routines to be run once an enumeration is
    // finished.
    //

    FAST_MUTEX EnumerationWorklistMutex;

    //
    // System time of the last bus scan.  This is protected by the
    // EnumerationWorkListMutex.
    //

    LARGE_INTEGER LastBusScanTime;

    //
    // Indicates that the next rescan which comes in should be "forced", ie.
    // it should rescan no matter how recent the last one was.
    //

    INTERLOCKED LONG ForceNextBusScan;

    //
    // A work item to use in enumerating the bus.
    //

    WORK_QUEUE_ITEM EnumerationWorkItem;

    //
    // A pointer to the thread the workitem is running on.  This is for
    // debugging purposes.
    //

    PKTHREAD EnumerationWorkThread;

    //
    // If this is TRUE then there is already an enumeration worker thread
    // running.  If FALSE then the work item must be requeued.  This flag is
    // protected by the EnumerationWorklistMutex
    //

    BOOLEAN EnumerationRunning;

    //
    // A list of enumeration requests.  When an bus scan is completed the
    // scanner should run through the list of enumeration requests and complete
    // each one.  This list is protected by the EnumerationWorklistMutex.
    //

    PSP_ENUMERATION_REQUEST EnumerationWorkList;

    //
    // A pointer to the PNP enumeration request object.  This is used so
    // so we can use interlocked exchange to determine if the block is
    // in use.
    //

    PSP_ENUMERATION_REQUEST PnpEnumRequestPtr;

    //
    // An enumeration request to use for PNP enumeration requests.  Since there
    // will only be one of these outstanding at any time we can statically
    // allocate one for that case.
    //

    SP_ENUMERATION_REQUEST PnpEnumerationRequest;

    //
    // A lookaside list to pull SRB_DATA blocks off of.
    //

    NPAGED_LOOKASIDE_LIST SrbDataLookasideList;

    //
    // The following members are used to keep an SRB_DATA structure allocated
    // for emergency use and to queue requests which need to use it.  The
    // structures are synchronized with the EmergencySrbDataSpinLock.
    // The routines Sp[Allocate|Free]SrbData & ScsiPortTickHandler will
    // handle queueing and eventual restarting of these requests.
    //

    //
    // This spinlock protects the blocked request list.
    //

    KSPIN_LOCK EmergencySrbDataSpinLock;

    //
    // Contains a queue of irps which could not be dispatched because of
    // low memory conditions and because the EmergencySrbData block is already
    // allocated.
    //

    LIST_ENTRY SrbDataBlockedRequests;

    //
    // The SRB_DATA reserved for "emergency" use.  This pointer should be set
    // to NULL if the SRB_DATA is in use.  Any SRB_DATA block may be used
    // for the emergency request.
    //

    INTERLOCKED PSRB_DATA EmergencySrbData;

    //
    // Flags to indicate whether the srbdata and scatter gather lookaside
    // lists have been allocated already.
    //

    BOOLEAN SrbDataListInitialized;

    //
    // Bus standard interface.  Retrieved from the lower driver immediately
    // after it completes the start irp.
    //

    BOOLEAN LowerBusInterfaceStandardRetrieved;
    BUS_INTERFACE_STANDARD LowerBusInterfaceStandard;

    //
    // Handles into the device map for the various entries this adapter will
    // have created.
    //

    //
    // An array of handles for each

    HANDLE PortDeviceMapKey;

    PDEVICE_MAP_HANDLES BusDeviceMapKeys;

    //
    // Unicode string containing the device name of this object
    //

    PWSTR DeviceName;

    //
    // The guid for the underlying bus.  Saved here so we don't have to
    // retrieve it so often.
    //

    GUID BusTypeGuid;

    //
    // The pnp interface name for this device.
    //

    UNICODE_STRING InterfaceName;

    //
    // The device state for this adapter.
    //

    PNP_DEVICE_STATE DeviceState;

    //
    // The number of calls to ScsiPortTickHandler for this adapter since
    // the machine was booted.
    //

    INTERLOCKED ULONG TickCount;

    //
    // Preallocated memory to use for IssueInquiry.  The InquiryBuffer is used
    // to retreive the inquiry data and the serial number for the device.
    //

    PVOID InquiryBuffer;
    PSENSE_DATA InquirySenseBuffer;
    PIRP InquiryIrp;
    PMDL InquiryMdl;

    //
    // Mutex used to synchronize multiple threads all synchronously waiting for
    // a power up to occur.
    //

    FAST_MUTEX PowerMutex;

    //
    // A pointer to a logical unit which is used to scan empty locations on the
    // bus.
    //

    PLOGICAL_UNIT_EXTENSION RescanLun;

    //
    // The number of additional sense bytes supported by this adapter.
    //

    UCHAR AdditionalSenseBytes;

    //
    // Indicates whether the SenseData WMI event is enabled.
    //

    BOOLEAN EnableSenseDataEvent;

    //
    // Identifies the event class used to generate sense data wmi events.
    //

    GUID SenseDataEventClass;

    //
    // Pointer to verifier state that gets allocated and initialized when
    // scsiport's verifier is enabled.
    //

    PVERIFIER_EXTENSION VerifierExtension;

    //
    // The minimum & maximum addresses for common buffer.  These are loaded 
    // from [Minimum|Maximum]UCXAddress in the registry.
    //

    PHYSICAL_ADDRESS MinimumCommonBufferBase;
    PHYSICAL_ADDRESS MaximumCommonBufferBase;

#if defined(FORWARD_PROGRESS)
    //
    // Pointer to a block of reserved pages we use to make forward progress
    // in low memory conditons.
    //

    PVOID ReservedPages;

    //
    // Pointer to an emergency MDL we can use if we cannot allocate one
    //

    PMDL ReservedMdl;
#endif

    //
    // Identified how many successfully completed requests are required to
    // restore a LUN on this adapter from a degraded performation state
    // with respect to MaxQueueDepth.
    //

    ULONG RemainInReducedMaxQueueState;

    //
    // This value dictates on what type of boundary an adapter's uncached extension
    // must be aligned.
    //

    ULONG UncachedExtAlignment;

    //
    // This value is used to keep track of the number of instances of the
    // SRB_DATA free routine is running.  This helps us avoid a nasty recursion
    // brought on by synchronously completing requests and starting blocked
    // requests waiting for SRB_DATA objects.
    //

    LONG SrbDataFreeRunning;

    //
    // This is the timeout value we put into INQUIRY SRBs.  Some devices are
    // known to take longer than the default 4 seconds to respond.
    //

    ULONG SrbTimeout;

    //
    // This boolean indicates whether the adapter supports multiple concurrent
    // requests.  This means it either supports tagged queuing or multiple
    // requests per logical unit.
    //

    BOOLEAN SupportsMultipleRequests;

    //
    // This is the size of the preallocated SG buffer contained in each
    // SRB_DATA structure allocated for this adapter.  We pass this value to
    // the HAL when we supply our own SG buffer.
    //

    ULONG SgBufferLen;

    //
    // This is the number of seconds we hold requests for following a bus 
    // reset.
    //

    ULONG ResetHoldTime;

    //
    // Array of LU extensions representing the initiator for each bus.
    //

    PLOGICAL_UNIT_EXTENSION InitiatorLU[8];

    //
    // Inidicates whether the adapter is configured to have a logical unit
    // created for the initiator on each supported bus.
    //

    BOOLEAN CreateInitiatorLU;

    //
    // Used to chain Logical units having blocked requests.
    //

    PLOGICAL_UNIT_EXTENSION BlockedLogicalUnit;
};

struct _LOGICAL_UNIT_EXTENSION {

    union {
        PDEVICE_OBJECT DeviceObject;
        COMMON_EXTENSION CommonExtension;
    };

    //
    // Logical Unit flags
    //

    ULONG LuFlags;

    //
    // The adapter number this device is attached to
    //

    ULONG PortNumber;

    //
    // Has this device been claimed by a driver (legacy or pnp)
    //

    BOOLEAN IsClaimed;

    BOOLEAN IsLegacyClaim;

    //
    // Has this device been enumerated yet?  If so then we cannot actually
    // delete it until we've explicitly told the PNP system that it's gone
    // (by not enumerating it)
    //

    BOOLEAN IsEnumerated;

    //
    // Has this device gone missing?
    //

    BOOLEAN IsMissing;

    //
    // Is this device visible - should it be exposed to PNP?
    //

    BOOLEAN IsVisible;

    //
    // Was this device marked missing because we found something different at
    // it's bus location?  If so then the removal of this device from the
    // logical unit bins will trigger a new bus scan.
    //

    BOOLEAN IsMismatched;

    //
    // Is this lun temporary?  Temporary luns are used to scan bus locations
    // which are believed to be empty.  They are the only luns which can be
    // swapped out of the logical unit list.
    //

    BOOLEAN IsTemporary;

    //
    // Indicates that this device needs to have an inquiry sent to it to
    // determine if it's still present.  This flag is cleared if the inquiry
    // succeeds and the inquiry data matches what was previously read at that
    // address.  If this flag is set when SpPurgeTarget is called then the
    // lun will be marked as missing.
    //

    ULONG NeedsVerification;

    //
    // The bus address of this device.
    //

    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;

    //
    // The number of times the current busy request has been retried
    //

    UCHAR RetryCount;

    //
    // The current queue sort key
    //

    ULONG CurrentKey;

    //
    // A pointer to the miniport's logical unit extension.
    //

    PVOID HwLogicalUnitExtension;

    //
    // A pointer to the device extension for the adapter.
    //

    PADAPTER_EXTENSION AdapterExtension;

    //
    // The number of unreleased queue locks on this device
    //

    ULONG QueueLockCount;

    //
    // Reference counts for pausing & unpausing the queue (see LU_QUEUE_PAUSED)
    //

    ULONG QueuePauseCount;

    //
    // List of lock & unlock requests which are waiting to be dispatched.
    //

    KDEVICE_QUEUE LockRequestQueue;

    //
    // The currently operating lock request.
    //

    PSRB_DATA CurrentLockRequest;

    //
    // A pointer to the next logical unit extension in the logical unit bin.
    //

    PLOGICAL_UNIT_EXTENSION NextLogicalUnit;

    //
    // Used to chain logical units in the interrupt data block.
    //

    PLOGICAL_UNIT_EXTENSION ReadyLogicalUnit;

    //
    // Used to chain completed abort requests in the interrupt data block.
    //

    PLOGICAL_UNIT_EXTENSION CompletedAbort;

    //
    // The current abort request for this logical unit
    //

    PSCSI_REQUEST_BLOCK AbortSrb;

    //
    // Timeout counter for this logical unit
    //

    LONG RequestTimeoutCounter;

    //
    // The list of requests for this logical unit.
    //

    LIST_ENTRY RequestList;

    //
    // The next request to be executed.
    //

    PSRB_DATA PendingRequest;

    //
    // This irp could not be executed before because the
    // device returned BUSY.
    //

    PSRB_DATA BusyRequest;

    //
    // The current untagged request for this logical unit.
    //

    PSRB_DATA CurrentUntaggedRequest;

    //
    // The maximum number of request which we will issue to the device
    //

    UCHAR MaxQueueDepth;

    //
    // The current number of outstanding requests.
    //

    UCHAR QueueCount;

    //
    // The inquiry data for this logical unit.
    //

    INQUIRYDATA InquiryData;

    //
    // The handles for the target & logical unit keys in the device map.
    //

    HANDLE TargetDeviceMapKey;
    HANDLE LunDeviceMapKey;

    //
    // Our fixed set of SRB_DATA blocks for use when processing bypass requests.
    // If this set is exhausted then scsiport will bugcheck - this should be
    // okay since bypass requests are only sent in certain extreme conditions
    // and should never be overlapped (we should only see one bypass request
    // at a time).
    //

    SRB_DATA BypassSrbDataBlocks[NUMBER_BYPASS_SRB_DATA_BLOCKS];

    //
    // A list of the free bypass SRB_DATA blocks.
    //

    KSPIN_LOCK BypassSrbDataSpinLock;
    SLIST_HEADER BypassSrbDataList;

    //
    // A pointer to the request for which we have issued a request-sense irp
    // (if any).  This field is protected by the port spinlock.
    //

    PSRB_DATA ActiveFailedRequest;

    //
    // A pointer to the request for which we need to issue a request-sense irp
    // (if any).  RequestSenseCompletion will promote this to the active
    // failed request and issue a new RS operation when it runs.
    // This field is protected by the port spinlock.
    //

    PSRB_DATA BlockedFailedRequest;

    //
    // Resources for issuing request-sense commands.
    //

    PIRP RequestSenseIrp;
    SCSI_REQUEST_BLOCK RequestSenseSrb;

    struct {
        MDL RequestSenseMdl;
        PFN_NUMBER RequestSenseMdlPfn1;
        PFN_NUMBER RequestSenseMdlPfn2;
    };

    //
    // The "lun-list" associated with this target.  SpIssueReportLuns will
    // store this value in the logical unit extension for LUN 0 of each target
    // for use in the event that we are unable to retrieve it from the LUN.
    //

    PLUN_LIST TargetLunList;

    //
    // The special controller flags for this target.  These flags are valid
    // for LUN 0 only.
    //

    SP_SPECIAL_CONTROLLER_FLAGS SpecialFlags;

    //
    // Flags to keep track of what EVPD pages this device supports.
    //

    BOOLEAN DeviceIdentifierPageSupported : 1;
    BOOLEAN SerialNumberPageSupported : 1;

    //
    // The vital product data for this device - this buffer contains the
    // device serial number.  The other fields contain the length of the
    // data in the buffer and the page code used to retrieve this buffer.
    //

    ANSI_STRING SerialNumber;

    //
    // The device identifier page retreived from the device's vital product
    // data.
    //

    PVPD_IDENTIFICATION_PAGE DeviceIdentifierPage;
    ULONG DeviceIdentifierPageLength;

    //
    // If we reduce the MaxQueueDepth, track how long we remain in the degraded
    // state.  If we reach a configurable number of ticks we restore ourselves
    // to full power.
    //

    ULONG TicksInReducedMaxQueueDepthState;

#if defined(NEWQUEUE)
    //
    // Capacity of this LU in sectors.
    //

    ULONG Capacity;

    //
    // The number of zones we divide the LU into.
    //

    ULONG Zones;

    //
    // The number of sectors per zone.
    //

    ULONG ZoneLength;

    //
    // This array holds each zone's first sector.
    //

    ULONG FirstSector[4];

    //
    // This array holds each zone's last sector.
    //

    ULONG LastSector[4];

    //
    // Tracks the number of requests per zone.
    //

    ULONG64 RequestCount[4];

    //
    // The media is divided into a number of zones.  This value identifies 
    // which zone the port driver is currently servicing.
    //

    ULONG CurrentZone;

    //
    // The value tracks the number of requests we perform in each zone.
    //

    ULONG ZoneCount;

    //
    // Tracks the current location in each zone.
    //

    ULONG ZonePointer[4];

    //
    // Tracks the number of consecutive requests for the same sector.
    //

    UCHAR RedundantRequests[4];

    //
    // Table mapping current zone to next zone.
    //

    ULONG NextSequentialZone[4];
#endif // NEWQUEUE

    //
    // Maintain a circular buffer of the last 10 IO requests.
    //

    ULONG IoLogIndex;
    ULONG IoLogEntries;
    SP_LUN_IO_LOG IoLog[10];

    //
    // Used to chain Logical units having blocked requests.
    //
    
    PLOGICAL_UNIT_EXTENSION BlockedLogicalUnit;
    
    //
    // Contains a queue of irps which could not be dispatched because of
    // low memory conditions and because the EmergencySrbData block is already
    // allocated.
    //

    LIST_ENTRY SrbDataBlockedRequests;
};

#if defined(NEWQUEUE)
ULONG
INLINE
GetZone(
    IN PLOGICAL_UNIT_EXTENSION Lun,
    IN ULONG Sector
    )
{
    ULONG i;
    for (i = 0; i < Lun->Zones; i++) {
        if (Sector <= Lun->LastSector[i]) {
            return i;
        }
    }    
    ASSERT(FALSE);
    return (Lun->Zones - 1);
}
#endif // NEWQUEUE

//
// Miniport specific device extension wrapper
//

struct _HW_DEVICE_EXTENSION {
    PADAPTER_EXTENSION FdoExtension;
    UCHAR HwDeviceExtension[0];
};

typedef struct _INTERRUPT_CONTEXT {
    PADAPTER_EXTENSION DeviceExtension;
    PINTERRUPT_DATA SavedInterruptData;
}INTERRUPT_CONTEXT, *PINTERRUPT_CONTEXT;

typedef struct _RESET_CONTEXT {
    PADAPTER_EXTENSION DeviceExtension;
    UCHAR PathId;
}RESET_CONTEXT, *PRESET_CONTEXT;

//
// Used in LUN rescan determination.
//

typedef struct _UNICODE_LUN_LIST {
    UCHAR TargetId;
    struct _UNICODE_LUN_LIST *Next;
    UNICODE_STRING UnicodeInquiryData;
} UNICODE_LUN_LIST, *PUNICODE_LUN_LIST;

typedef struct _POWER_CHANGE_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    POWER_STATE_TYPE Type;
    POWER_STATE State;
    PIRP OriginalIrp;
    PSCSI_REQUEST_BLOCK Srb;
} POWER_CHANGE_CONTEXT, *PPOWER_CHANGE_CONTEXT;

//
// Driver extension
//

struct _SP_INIT_CHAIN_ENTRY {
    HW_INITIALIZATION_DATA InitData;
    PSP_INIT_CHAIN_ENTRY NextEntry;
};

typedef struct _SCSIPORT_INTERFACE_TYPE_DATA {
    INTERFACE_TYPE InterfaceType;
    ULONG Flags;
} SCSIPORT_INTERFACE_TYPE_DATA, *PSCSIPORT_INTERFACE_TYPE_DATA;

typedef struct _SCSIPORT_DRIVER_EXTENSION {

    //
    // Pointer back to the driver object
    //

    PDRIVER_OBJECT DriverObject;

    //
    // Unicode string containing the registry path information
    // for this driver
    //

    UNICODE_STRING RegistryPath;

    UNICODE_STRING MPIOSupportedDeviceList;

    //
    // the chain of HwInitializationData structures that were passed in during
    // the miniport's initialization
    //

    PSP_INIT_CHAIN_ENTRY InitChain;

    //
    // A count of the number of adapter which are using scsiport.  This is
    // used for generating unique Id's
    //

    ULONG AdapterCount;

    //
    // The bus type for this driver.
    //

    STORAGE_BUS_TYPE BusType;

    //
    // Flag indicating whether this miniport is set to do device detection.
    // This flag will be initialized out of the registry when the driver
    // extension is setup.
    //

    BOOLEAN LegacyAdapterDetection;

    //
    // The list of pnp interface values we read out of the registry for this
    // device.  The number of entries here can vary.
    //

    ULONG PnpInterfaceCount;

    //
    // The number of interfaces which are safe for pnp.
    //

    ULONG SafeInterfaceCount;

    //
    // A pointer to a reserve error log entry for the driver.  This entry will
    // be used to log an allocation failure if the logging routine cannot
    // allocate the necessary memory for an error log entry.
    //

    PVOID ReserveAllocFailureLogEntry;

    //
    // Indicates whether the driver is being verified.
    //

    ULONG Verifying;

    //
    // When verifying, we occasionally set pointers so they point to a page
    // of invalid memory so the system will bugcheck if a miniport attempts
    // to access the memory.  The following 3 variables are used to maintain
    // this invalid page.
    //

    PVOID UnusedPage;
    PMDL UnusedPageMdl;
    PVOID InvalidPage;

    SCSIPORT_INTERFACE_TYPE_DATA PnpInterface[0];

    //
    // The remaining pnp interface flags trail the defined structure
    //

} SCSIPORT_DRIVER_EXTENSION, *PSCSIPORT_DRIVER_EXTENSION;


//
// Port driver extension flags.
// These flags are protected by the adapter spinlock.
//

//
// This flag indicates that a request has been passed to the miniport and the
// miniport has not indicated it is ready for another request.  It is set by
// SpStartIoSynchronized. It is cleared by ScsiPortCompletionDpc when the
// miniport asks for another request.  Note the port driver will defer giving
// the miniport driver a new request if the current request disabled disconnects.
//

#define PD_DEVICE_IS_BUSY            0X00001

//
// Indicates there is a pending request for which resources
// could not be allocated.  This flag is set by SpAllocateRequestStructures
// which is called from ScsiPortStartIo.  It is cleared by
// SpProcessCompletedRequest when a request completes which then calls
// ScsiPortStartIo to try the request again.
//

#define PD_PENDING_DEVICE_REQUEST    0X00800

//
// This flag indicates that there are currently no requests executing with
// disconnects disabled.  This flag is normally on.  It is cleared by
// SpStartIoSynchronized when a request with disconnect disabled is started
// and is set when that request completes.  SpProcessCompletedRequest will
// start the next request for the miniport if PD_DEVICE_IS_BUSY is clear.
//

#define PD_DISCONNECT_RUNNING        0X01000

//
// Indicates the miniport wants the system interrupts disabled.  Set by
// ScsiPortNofitication and cleared by ScsiPortCompletionDpc.  This flag is
// NOT stored in the interrupt data structure.  The parameters are stored in
// the device extension.
//

#define PD_DISABLE_CALL_REQUEST      0X02000

//
// Indicates that the miniport is being reinitialized.  This is set and
// cleared by SpReinitializeAdapter is is tested by some of the ScsiPort APIs.
//

#define PD_MINIPORT_REINITIALIZING          0x40000
#define PD_UNCACHED_EXTENSION_RETURNED      0x80000

//
// Interrupt Data Flags
// These flags are protected by the interrupt spinlock.
//

//
// Indicates that ScsiPortCompletionDpc needs to be run.  This is set when
// A miniport makes a request which must be done at DPC and is cleared when
// when the request information is gotten by SpGetInterruptState.
//

#define PD_NOTIFICATION_REQUIRED     0X00004

//
// Indicates the miniport is ready for another request.  Set by
// ScsiPortNotification and cleared by SpGetInterruptState.  This flag is
// stored in the interrupt data structure.
//

#define PD_READY_FOR_NEXT_REQUEST    0X00008

//
// Indicates the miniport wants the adapter channel flushed.  Set by
// ScsiPortFlushDma and cleared by SpGetInterruptState.  This flag is
// stored in the data interrupt structure.  The flush adapter parameters
// are saved in the device object.
//

#define PD_FLUSH_ADAPTER_BUFFERS     0X00010

//
// Indicates the miniport wants the adapter channel programmed.  Set by
// ScsiPortIoMapTransfer and cleared by SpGetInterruptState or
// ScsiPortFlushDma.  This flag is stored in the interrupt data structure.
// The I/O map transfer parameters are saved in the interrupt data structure.
//

#define PD_MAP_TRANSFER              0X00020

//
// Indicates the miniport wants to log an error.  Set by
// ScsiPortLogError and cleared by SpGetInterruptState.  This flag is
// stored in the interrupt data structure.  The error log parameters
// are saved in the interrupt data structure.  Note at most one error per DPC
// can be logged.
//

#define PD_LOG_ERROR                 0X00040

//
// Indicates that no request should be sent to the miniport after
// a bus reset. Set when the miniport reports a reset or the port driver
// resets the bus. It is cleared by SpTimeoutSynchronized.  The
// PortTimeoutCounter is used to time the length of the reset hold.  This flag
// is stored in the interrupt data structure.
//

#define PD_RESET_HOLD                0X00080

//
// Indicates a request was stopped due to a reset hold.  The held request is
// stored in the current request of the device object.  This flag is set by
// SpStartIoSynchronized and cleared by SpTimeoutSynchronized which also
// starts the held request when the reset hold has ended.  This flag is stored
// in the interrupt data structure.
//

#define PD_HELD_REQUEST              0X00100

//
// Indicates the miniport has reported a bus reset.  Set by
// ScsiPortNotification and cleared by SpGetInterruptState.  This flag is
// stored in the interrupt data structure.
//

#define PD_RESET_REPORTED            0X00200

//
// Indicates that system interrupts have been enabled and that the miniport
// has disabled its adapter from interruptint.  The miniport's interrupt
// routine is not called while this flag is set.  This flag is set by
// ScsiPortNotification when a CallEnableInterrupts request is made and
// cleared by SpEnableInterruptSynchronized when the miniport requests that
// system interrupts be disabled.  This flag is stored in the interrupt data
// structure.
//

#define PD_DISABLE_INTERRUPTS        0X04000

//
// Indicates the miniport wants the system interrupt enabled.  Set by
// ScsiPortNotification and cleared by SpGetInterruptState.  This flag is
// stored in the interrupt data structure.  The call enable interrupts
// parameters are saved in the device extension.
//

#define PD_ENABLE_CALL_REQUEST       0X08000

//
// Indicates the miniport is wants a timer request.  Set by
// ScsiPortNotification and cleared by SpGetInterruptState.  This flag is
// stored in the interrupt data structure. The timer request parameters are
// stored in the interrupt data structure.
//

#define PD_TIMER_CALL_REQUEST        0X10000

//
// Indicates the miniport has a WMI request.  Set by ScsiPortNotification
// and cleared by SpGetInterruptState.  This flag is stored in the interrupt
// data structure.    The WMI request parameters are stored in the interrupt
// data structure.
//

#define PD_WMI_REQUEST               0X20000

//
// Indicates that the miniport has detected some sort of change on the bus -
// usually device arrival or removal - and wishes the port driver to rescan
// the bus.
//

#define PD_BUS_CHANGE_DETECTED       0x40000

//
// Indicates that the adapter has disappeared.  If this flag is set then no
// calls should be made into the miniport.
//

#define PD_ADAPTER_REMOVED           0x80000

//
// Indicates that interrupts from the miniport do not appear to be getting
// delivered to scsiport.  This flag is set by SpTimeoutSynchronized and
// will cause the DPC routine to log an error to this effect.
//

#define PD_INTERRUPT_FAILURE         0x100000

#if defined(FORWARD_PROGRESS)
//
// Indicates that the adapter's reserved pages are currently in use.  The 
// reserved pages is a special VA range set aside by MM in order for devices
// to make forward progress in low memory conditions.
//

#define PD_RESERVED_PAGES_IN_USE     0x200000

//
// Indicates that the adapter's reserved MDL is currently in use.
//
#define PD_RESERVED_MDL_IN_USE       0x400000
#endif

//
// Indicates that the adapter is in the process of shutting down.  Certain
// operations must not be started when this is the case.
//
#define PD_SHUTDOWN_IN_PROGRESS      0x800000

//
// The following flags should not be cleared from the interrupt data structure
// by SpGetInterruptState.
//

#define PD_INTERRUPT_FLAG_MASK (PD_RESET_HOLD | PD_HELD_REQUEST | PD_DISABLE_INTERRUPTS | PD_ADAPTER_REMOVED)

//
// Adapter extension flags for DPC routine.
//

//
// Indicates that the completion DPC is either already running or has been
// queued to service completed requests.  This flag is checked when the
// completion DPC needs to be run - the DPC should only be started if this
// flag is already clear.  It will be cleared when the DPC has completed
// processing any work items.
//

#define PD_DPC_RUNNING              0x20000

//
// Logical unit extension flags.
//

//
// Indicates the logical unit queue is frozen.  Set by
// SpProcessCompletedRequest when an error occurs and is cleared by the class
// driver.
//

#define LU_QUEUE_FROZEN              0X0001

//
// Indicates that the miniport has an active request for this logical unit.
// Set by SpStartIoSynchronized when the request is started and cleared by
// GetNextLuRequest.  This flag is used to track when it is ok to start another
// request from the logical unit queue for this device.
//

#define LU_LOGICAL_UNIT_IS_ACTIVE    0X0002

//
// Indicates that a request for this logical unit has failed and a REQUEST
// SENSE command needs to be done. This flag prevents other requests from
// being started until an untagged, by-pass queue command is started.  This
// flag is cleared in SpStartIoSynchronized.  It is set by
// SpGetInterruptState.
//

#define LU_NEED_REQUEST_SENSE  0X0004

//
// Indicates that a request for this logical unit has completed with a status
// of BUSY or QUEUE FULL.  This flag is set by SpProcessCompletedRequest and
// the busy request is saved in the logical unit structure.  This flag is
// cleared by ScsiPortTickHandler which also restarts the request.  Busy
// request may also be requeued to the logical unit queue if an error occurs
// on the device (This will only occur with command queueing.).  Not busy
// requests are nasty because they are restarted asynchronously by
// ScsiPortTickHandler rather than GetNextLuRequest. This makes error recovery
// more complex.
//

#define LU_LOGICAL_UNIT_IS_BUSY      0X0008

//
// This flag indicates a queue full has been returned by the device.  It is
// similar to PD_LOGICAL_UNIT_IS_BUSY but is set in SpGetInterruptState when
// a QUEUE FULL status is returned.  This flag is used to prevent other
// requests from being started for the logical unit before
// SpProcessCompletedRequest has a chance to set the busy flag.
//

#define LU_QUEUE_IS_FULL             0X0010

//
// Indicates that there is a request for this logical unit which cannot be
// executed for now.  This flag is set by SpAllocateRequestStructures.  It is
// cleared by GetNextLuRequest when it detects that the pending request
// can now be executed. The pending request is stored in the logical unit
// structure.  A new single non-queued reqeust cannot be executed on a logical
// that is currently executing queued requests.  Non-queued requests must wait
// unit for all queued requests to complete.  A non-queued requests is one
// which is not tagged and does not have SRB_FLAGS_NO_QUEUE_FREEZE set.
// Normally only read and write commands can be queued.
//

#define LU_PENDING_LU_REQUEST        0x0020

//
// Indicates that the logical unit queue has been paused due to an error.  Set
// by SpProcessCompletedRequest when an error occurs and is cleared by the
// class driver either by unfreezing or flushing the queue.  This flag is used
// with the following one to determine why the logical unit queue is paused.
//

#define LU_QUEUE_LOCKED             0x0040

//
// Indicates that this LUN has been "paused".  This flag is set and cleared by
// the power management code while changing the power state.  It causes
// GetNextLuRequest to return without starting another request and is used
// by SpSrbIsBypassRequest to determine that a bypass request should get
// shoved to the front of the line.
//

#define LU_QUEUE_PAUSED             0x0080

//
// Indicates that the LUN is operating in a degraded state.  The maximum queue
// depth has been reduced because the LUN has returned QUEUE FULL status.  We
// track this because in the event that the QUEUE FULL was transient, we want
// to restore the queue depth to it's original maximum.

#define LU_PERF_MAXQDEPTH_REDUCED   0x0100

//
// SRB_DATA flags.
//

//
// Indicates that the srb_data block was for a bypass request
//

#define SRB_DATA_BYPASS_REQUEST     0x10000000

#if defined(FORWARD_PROGRESS)
//
// Indicates that the request is using reserved pages that enable
// forward progress in low-memory condition.
//

#define SRB_DATA_RESERVED_PAGES     0x20000000

//
// Indicates that the request is using a reserved MDL that enables
// forward progress in low-memory conditions.
//
#define SRB_DATA_RESERVED_MDL       0x40000000
#endif

//
// Port Timeout Counter values.
//

#define PD_TIMER_STOPPED             -1

//
// Possible registry flags for pnp interface key
//

//
// The absence of any information about a particular interface in the
// PnpInterface key in the registry indicates that pnp is not safe for this
// particular card.
//

#define SP_PNP_NOT_SAFE             0x00000000

//
// Indicates that pnp is a safe operation for this device.  If this flag is
// set then the miniport will not be allowed to do detection and will always
// be handed resources provided by the pnp system.  This flag may or may not
// be set in the registry - the fact that a value for a particular interface
// exists is enough to indicate that pnp is safe and this flag will always
// be set.
//

#define SP_PNP_IS_SAFE              0x00000001

//
// Indicates that we should take advantage of a chance to enumerate a particular
// bus type using the miniport.  This flag is set for all non-enumerable legacy
// buses (ISA, EISA, etc...) and is cleared for the non-legacy ones and for the
// PnpBus type.
//

#define SP_PNP_NON_ENUMERABLE       0x00000002

//
// Indicates that we need to include some sort of location information in the
// config data to discern this adapter from any others.
//

#define SP_PNP_NEEDS_LOCATION       0x00000004

//
// Indicates that this type of adapter must have an interrupt for us to try
// and start it.  If PNP doesn't provide an interrupt then scsiport will
// log an error and fail the start operation.  If this flag is set then
// SP_PNP_IS_SAFE must also be set.
//

#define SP_PNP_INTERRUPT_REQUIRED   0x00000008

//
// Indicates that legacy detection should not be done.
//

#define SP_PNP_NO_LEGACY_DETECTION  0x00000010

//
// Internal scsiport srb status codes.
// these must be between 0x38 and 0x3f (inclusive) and should never get
// returned to a class driver.
//
// These values are used after the srb has been put on the adapter's
// startio queue and thus cannot be completed without running it through the
// completion DPC.
//

#ifndef KDBG_EXT
//
// Function declarations
//

NTSTATUS
ScsiPortGlobalDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortFdoCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortFdoDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortPdoScsi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortScsi1PdoScsi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ScsiPortStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
ScsiPortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ScsiPortFdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortPdoDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortPdoCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortPdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ScsiPortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID
IssueRequestSense(
    IN PADAPTER_EXTENSION deviceExtension,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    );

BOOLEAN
SpStartIoSynchronized (
    PVOID ServiceContext
    );

BOOLEAN
SpResetBusSynchronized (
    PVOID ServiceContext
    );

BOOLEAN
SpTimeoutSynchronized (
    PVOID ServiceContext
    );

BOOLEAN
SpEnableInterruptSynchronized (
    PVOID ServiceContext
    );

VOID
IssueAbortRequest(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

BOOLEAN
SpGetInterruptState(
    IN PVOID ServiceContext
    );

#if DBG

#define GetLogicalUnitExtension(fdo, path, target, lun, lock, getlock) \
    GetLogicalUnitExtensionEx(fdo, path, target, lun, lock, getlock, __file__, __LINE__)

PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtensionEx(
    PADAPTER_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    PVOID LockTag,
    BOOLEAN AcquireBinLock,
    PCSTR File,
    ULONG Line
    );

#else

PLOGICAL_UNIT_EXTENSION
GetLogicalUnitExtension(
    PADAPTER_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    PVOID LockTag,
    BOOLEAN AcquireBinLock
    );

#endif

IO_ALLOCATION_ACTION
ScsiPortAllocationRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

VOID
LogErrorEntry(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PERROR_LOG_ENTRY LogEntry
    );

VOID
FASTCALL
GetNextLuRequest(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
GetNextLuRequestWithoutLock(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpLogPortTimeoutError(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN ULONG UniqueId
    );

VOID
SpProcessCompletedRequest(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    OUT PBOOLEAN CallStartIo
    );

PSRB_DATA
SpGetSrbData(
    IN PADAPTER_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    UCHAR QueueTag,
    BOOLEAN AcquireBinLock
    );

VOID
SpCompleteSrb(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    IN UCHAR SrbStatus
    );

BOOLEAN
SpAllocateSrbExtension(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT BOOLEAN *StartNextRequest,
    OUT BOOLEAN *Tagged
    );

NTSTATUS
SpSendMiniPortIoctl(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

NTSTATUS
SpGetInquiryData(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
SpClaimLogicalUnit(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension,
    IN PIRP Irp,
    IN BOOLEAN StartDevice
    );

VOID
SpMiniPortTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
SpSynchronizeExecution (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

NTSTATUS
SpGetCommonBuffer(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN ULONG NonCachedExtensionSize
    );

VOID
SpDestroyAdapter(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Surprise
    );

VOID
SpReleaseAdapterResources(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Stop,
    IN BOOLEAN Surprise
    );

NTSTATUS
SpInitializeConfiguration(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PHW_INITIALIZATION_DATA HwInitData,
    IN PCONFIGURATION_CONTEXT Context
    );

VOID
SpParseDevice(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN HANDLE Key,
    IN PCONFIGURATION_CONTEXT Context,
    IN PUCHAR Buffer
    );

NTSTATUS
SpConfigurationCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

PCM_RESOURCE_LIST
SpBuildResourceList(
    PADAPTER_EXTENSION DeviceExtension,
    PPORT_CONFIGURATION_INFORMATION MiniportConfigInfo
    );

BOOLEAN
GetPciConfiguration(
    IN PDRIVER_OBJECT          DriverObject,
    IN OUT PDEVICE_OBJECT      DeviceObject,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID                   RegistryPath,
    IN ULONG                   BusNumber,
    IN OUT PPCI_SLOT_NUMBER    SlotNumber
    );

NTSTATUS
ScsiPortAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
ScsiPortUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ScsiPortFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ScsiPortStartAdapter(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ScsiPortStopAdapter(
    IN PDEVICE_OBJECT Adapter,
    IN PIRP StopRequest
    );

NTSTATUS
ScsiPortStartLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

NTSTATUS
ScsiPortInitLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

NTSTATUS
ScsiPortStopLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

NTSTATUS
SpEnumerateAdapterSynchronous(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Force
    );

VOID
SpEnumerateAdapterAsynchronous(
    IN PADAPTER_EXTENSION Adapter,
    IN PSP_ENUMERATION_REQUEST EnumerationRequest,
    IN BOOLEAN Force
    );

VOID
SpEnumerationWorker(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpExtractDeviceRelations(
    IN PADAPTER_EXTENSION Adapter,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

VOID
ScsiPortInitializeDispatchTables(
    VOID
    );

NTSTATUS
ScsiPortStringArrayToMultiString(
    IN PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING MultiString,
    PCSTR StringArray[]
    );

NTSTATUS
ScsiPortGetDeviceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
ScsiPortGetInstanceId(
    IN PDEVICE_OBJECT Pdo,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
ScsiPortGetCompatibleIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
ScsiPortGetHardwareIds(
    IN PDRIVER_OBJECT DriverObject,
    IN PINQUIRYDATA InquiryData,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
ScsiPortStartAdapterCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SpReportNewAdapter(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ScsiPortQueryPropertyPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    );

NTSTATUS
ScsiPortQueryProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP QueryIrp
    );

NTSTATUS
ScsiPortInitLegacyAdapter(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext
    );

NTSTATUS
SpCreateAdapter(
    IN PDRIVER_OBJECT DriverObject,
    OUT PDEVICE_OBJECT *Fdo
    );

VOID
SpInitializeAdapterExtension(
    IN PADAPTER_EXTENSION FdoExtension,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN OUT PHW_DEVICE_EXTENSION HwDeviceExtension OPTIONAL
    );

PHW_INITIALIZATION_DATA
SpFindInitData(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN INTERFACE_TYPE InterfaceType
    );

VOID
SpBuildConfiguration(
    IN PADAPTER_EXTENSION    AdapterExtension,
    IN PHW_INITIALIZATION_DATA         HwInitializationData,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInformation
    );

NTSTATUS
SpCallHwFindAdapter(
    IN PDEVICE_OBJECT Fdo,
    IN PHW_INITIALIZATION_DATA HwInitData,
    IN PVOID HwContext OPTIONAL,
    IN OUT PCONFIGURATION_CONTEXT ConfigurationContext,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN CallAgain
    );

NTSTATUS
SpCallHwInitialize(
    IN PDEVICE_OBJECT Fdo
    );

HANDLE
SpOpenParametersKey(
    IN PUNICODE_STRING RegistryPath
    );

HANDLE
SpOpenDeviceKey(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG DeviceNumber
    );

ULONG
SpQueryPnpInterfaceFlags(
    IN PSCSIPORT_DRIVER_EXTENSION DriverExtension,
    IN INTERFACE_TYPE InterfaceType
    );

NTSTATUS
SpGetRegistryValue(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE Handle,
    IN PWSTR KeyString,
    OUT PKEY_VALUE_FULL_INFORMATION *KeyInformation
    );

NTSTATUS
SpInitDeviceMap(
    VOID
    );

NTSTATUS
SpBuildDeviceMapEntry(
    IN PCOMMON_EXTENSION CommonExtension
    );

VOID
SpDeleteDeviceMapEntry(
    IN PCOMMON_EXTENSION CommonExtension
    );

NTSTATUS
SpUpdateLogicalUnitDeviceMapEntry(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpLogResetMsg(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN ULONG UniqueId
    );

VOID
SpLogResetError(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION Lun,
    IN ULONG UniqueId
    );

VOID
SpRemoveLogicalUnitFromBin (
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension
    );

VOID
SpAddLogicalUnitToBin (
    IN PADAPTER_EXTENSION AdapterExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnitExtension
    );

PSCSIPORT_DEVICE_TYPE
SpGetDeviceTypeInfo(
    IN UCHAR DeviceType
    );

BOOLEAN
SpRemoveLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN UCHAR RemoveType
    );

VOID
SpDeleteLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

PLOGICAL_UNIT_EXTENSION
SpFindSafeLogicalUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR PathId,
    IN PVOID LockTag
    );

NTSTATUS
ScsiPortSystemControlIrp(
    IN     PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP           Irp);

NTSTATUS
SpWmiIrpNormalRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters);

NTSTATUS
SpWmiIrpRegisterRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PWMI_PARAMETERS WmiParameters);

NTSTATUS
SpWmiHandleOnMiniPortBehalf(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters);

NTSTATUS
SpWmiPassToMiniPort(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters);

VOID
SpWmiInitializeSpRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject);

VOID
SpWmiGetSpRegInfo(
    IN  PDEVICE_OBJECT DeviceObject,
    OUT PWMIREGINFO  * SpRegInfoBuf,
    OUT ULONG        * SpRegInfoBufSize);

VOID
SpWmiDestroySpRegInfo(
    IN  PDEVICE_OBJECT DeviceObject);

NTSTATUS
SpWmiInitializeFreeRequestList(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG          NumberOfItems
    );

VOID
SpWmiPushExistingFreeRequestItem(
    IN PADAPTER_EXTENSION Adapter,
    IN PWMI_MINIPORT_REQUEST_ITEM WmiRequestItem
    );

NTSTATUS
SpWmiPushFreeRequestItem(
    IN PADAPTER_EXTENSION           Adapter
    );

PWMI_MINIPORT_REQUEST_ITEM
SpWmiPopFreeRequestItem(
    IN PADAPTER_EXTENSION           Adapter
    );

BOOLEAN
SpWmiRemoveFreeMiniPortRequestItems(
    IN PADAPTER_EXTENSION   fdoExtension
    );

#if DBG
ULONG
FASTCALL
FASTCALL
SpAcquireRemoveLockEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag,
    IN PCSTR File,
    IN ULONG Line
    );
#else
ULONG
INLINE
SpAcquireRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    )
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    InterlockedIncrement(&commonExtension->RemoveLock);
    return (commonExtension->IsRemoved);
}
#endif

VOID
FASTCALL
SpReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag
    );

VOID
FASTCALL
FASTCALL
SpCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OPTIONAL PSRB_DATA SrbData,
    IN CCHAR PriorityBoost
    );

NTSTATUS
ScsiPortDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SpDefaultPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP OriginalIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

PCM_RESOURCE_LIST
RtlDuplicateCmResourceList(
    IN PDRIVER_OBJECT DriverObject,
    POOL_TYPE PoolType,
    PCM_RESOURCE_LIST ResourceList,
    ULONG Tag
    );

ULONG
RtlSizeOfCmResourceList(
    IN PCM_RESOURCE_LIST ResourceList
    );

BOOLEAN
SpTranslateResources(
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST AllocatedResources,
    OUT PCM_RESOURCE_LIST *TranslatedResources
    );

BOOLEAN
SpFindAddressTranslation(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS RangeStart,
    IN ULONG RangeLength,
    IN BOOLEAN InIoSpace,
    IN OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Translation
    );

NTSTATUS
SpAllocateAdapterResources(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
SpLockUnlockQueue(
    IN PDEVICE_OBJECT LogicalUnit,
    IN BOOLEAN LockQueue,
    IN BOOLEAN BypassLockedQueue
    );

VOID
ScsiPortRemoveAdapter(
    IN PDEVICE_OBJECT Adapter,
    IN BOOLEAN Surprise
    );

VOID
SpTerminateAdapter(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpQueryDeviceText(
    IN PDEVICE_OBJECT LogicalUnit,
    IN DEVICE_TEXT_TYPE TextType,
    IN LCID LocaleId,
    IN OUT PWSTR *DeviceText
    );

NTSTATUS
SpCheckSpecialDeviceFlags(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PINQUIRYDATA InquiryData
    );

PSRB_DATA
FASTCALL
SpAllocateSrbData(
    IN PADAPTER_EXTENSION Adapter,
    IN OPTIONAL PIRP Request,
    IN OPTIONAL PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

PSRB_DATA
FASTCALL
SpAllocateBypassSrbData(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

VOID
SpCheckSrbLists(
    IN PADAPTER_EXTENSION Adapter,
    IN PUCHAR FailureString
    );

VOID
ScsiPortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SpAllocateTagBitMap(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpRequestValidPowerState(
    IN PADAPTER_EXTENSION Adapter,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
SpRequestValidAdapterPowerStateSynchronous(
    IN PADAPTER_EXTENSION Adapter
    );

NTSTATUS
SpEnableDisableAdapter(
    IN PADAPTER_EXTENSION Adapter,
    IN BOOLEAN Enable
    );

NTSTATUS
SpEnableDisableLogicalUnit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Enable,
    IN PSP_ENABLE_DISABLE_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context
    );

VOID
ScsiPortProcessAdapterPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

INTERFACE_TYPE
SpGetPdoInterfaceType(
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
SpReadNumericInstanceValue(
    IN PDEVICE_OBJECT Pdo,
    IN PWSTR ValueName,
    OUT PULONG Value
    );

NTSTATUS
SpWriteNumericInstanceValue(
    IN PDEVICE_OBJECT Pdo,
    IN PWSTR ValueName,
    IN ULONG Value
    );

VOID
SpGetSupportedAdapterControlFunctions(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpReleaseMappedAddresses(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpGetSupportedAdapterControlFunctions(
    PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpIsAdapterControlTypeSupported(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType
    );

SCSI_ADAPTER_CONTROL_STATUS
SpCallAdapterControl(
    IN PADAPTER_EXTENSION AdapterExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );

PVOID
SpAllocateSrbDataBackend(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG AdapterIndex
    );

VOID
SpFreeSrbDataBackend(
    IN PSRB_DATA SrbData
    );

ULONG
SpAllocateQueueTag(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpReleaseQueueTag(
    IN PADAPTER_EXTENSION Adapter,
    IN ULONG QueueTag
    );

NTSTATUS
SpInitializeGuidInterfaceMapping(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SpSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
SpSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpGetBusTypeGuid(
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpDetermine64BitSupport(
    VOID
    );

VOID
SpAdjustDisabledBit(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Enable
    );

NTSTATUS
SpReadNumericValue(
    IN OPTIONAL HANDLE Root,
    IN OPTIONAL PUNICODE_STRING KeyName,
    IN PUNICODE_STRING ValueName,
    OUT PULONG Value
    );

VOID
SpWaitForRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID LockTag
    );

VOID
SpStartLockRequest(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PIRP Irp OPTIONAL
    );

BOOLEAN
SpAdapterConfiguredForSenseDataEvents(
    IN PDEVICE_OBJECT DeviceObject,
    OUT GUID *SenseDataClass
    );
        
NTSTATUS
SpInitAdapterWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject
    );

PMAPPED_ADDRESS
SpAllocateAddressMapping(
    PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpPreallocateAddressMapping(
    PADAPTER_EXTENSION Adapter,
    IN UCHAR NumberOfBlocks
    );

VOID
SpPurgeFreeMappedAddressList(
    IN PADAPTER_EXTENSION Adapter
    );

BOOLEAN
SpFreeMappedAddress(
    IN PADAPTER_EXTENSION Adapter,
    IN PVOID MappedAddress
    );

PMAPPED_ADDRESS
SpFindMappedAddress(
    IN PADAPTER_EXTENSION Adapter,
    IN LARGE_INTEGER IoAddress,
    IN ULONG NumberOfBytes,
    IN ULONG SystemIoBusNumber
    );

BOOLEAN
SpTransferBlockedRequestsToAdapter(
    PADAPTER_EXTENSION Adapter
    );

//
// SCSIPORT specified verifier error codes.
// 
#define SCSIPORT_VERIFIER_BAD_INIT_PARAMS          0x1000
#define SCSIPORT_VERIFIER_STALL_TOO_LONG           0x1001
#define SCSIPORT_VERIFIER_MINIPORT_ROUTINE_TIMEOUT 0x1002
#define SCSIPORT_VERIFIER_REQUEST_COMPLETED_TWICE  0x1003
#define SCSIPORT_VERIFIER_BAD_SRBSTATUS            0x1004
#define SCSIPORT_VERIFIER_UNTAGGED_REQUEST_ACTIVE  0x1005
#define SCSIPORT_VERIFIER_BAD_VA                   0x1006
#define SCSIPORT_VERIFIER_RQSTS_NOT_COMPLETE       0x1007
#define SCSIPORT_VERIFIER_BAD_BUSDATATYPE          0x1008

#define SP_VRFY_NONE                               (ULONG)-1
#define SP_VRFY_COMMON_BUFFERS                     0x00000001

typedef struct _SP_VA_MAPPING_INFO {
      PVOID OriginalSrbExtVa;
      ULONG SrbExtLen;
      PMDL SrbExtMdl;
      PVOID RemappedSrbExtVa;
      PVOID OriginalSenseVa;
      ULONG SenseLen;
      PMDL SenseMdl;
      PVOID RemappedSenseVa;
} SP_VA_MAPPING_INFO, *PSP_VA_MAPPING_INFO;

#define GET_VA_MAPPING_INFO(adapter, block)\
    (PSP_VA_MAPPING_INFO)((PUCHAR)(block) + ((adapter)->CommonBufferSize - PAGE_SIZE))

BOOLEAN
SpVerifierInitialization(
    VOID
    );

VOID
SpVerifySrbStatus(
    PVOID HwDeviceExtension,
    PSCSI_REQUEST_BLOCK srb
    );

ULONG
SpHwFindAdapterVrfy (
    IN PVOID DeviceExtension,
    IN PVOID HwContext,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

BOOLEAN
SpHwInitializeVrfy (
    IN PVOID DeviceExtension
    );

BOOLEAN
SpHwStartIoVrfy (
    IN PVOID DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
SpHwInterruptVrfy (
    IN PVOID DeviceExtension
    );

BOOLEAN
SpHwResetBusVrfy (
    IN PVOID DeviceExtension,
    IN ULONG PathId
    );

VOID
SpHwDmaStartedVrfy (
    IN PVOID DeviceExtension
    );

BOOLEAN
SpHwRequestInterruptVrfy (
    IN PVOID DeviceExtension
    );

BOOLEAN
SpHwTimerRequestVrfy (
    IN PVOID DeviceExtension
    );

SCSI_ADAPTER_CONTROL_STATUS
SpHwAdapterControlVrfy (
    IN PVOID DeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );

NTSTATUS
SpGetCommonBufferVrfy(
    PADAPTER_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    );

VOID
SpFreeCommonBufferVrfy(
    PADAPTER_EXTENSION Adapter
    );

PVOID
SpGetOriginalSrbExtVa(
    PADAPTER_EXTENSION Adapter,
    PVOID Va
    );

VOID
SpInsertSrbExtension(
    PADAPTER_EXTENSION Adapter,
    PCCHAR SrbExtension
    );

PVOID
SpPrepareSrbExtensionForUse(
    PADAPTER_EXTENSION Adapter,
    PCCHAR *SrbExtension
    );

PCCHAR
SpPrepareSenseBufferForUse(
    PADAPTER_EXTENSION Adapter,
    PCCHAR SrbExtension
    );

PVOID
SpGetInaccessiblePage(
    PADAPTER_EXTENSION Adapter
    );

VOID
SpEnsureAllRequestsAreComplete(
    PADAPTER_EXTENSION Adapter
    );

VOID
SpDoVerifierCleanup(
    IN PADAPTER_EXTENSION Adapter
    );

VOID
SpDoVerifierInit(
    IN PADAPTER_EXTENSION Adapter,
    IN PHW_INITIALIZATION_DATA HwInitializationData
    );

VOID
ScsiPortInitPdoWmi(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

PMDL
INLINE
SpGetRemappedSrbExt(
    PADAPTER_EXTENSION Adapter,
    PVOID Block
    )
{
    PSP_VA_MAPPING_INFO MappingInfo = GET_VA_MAPPING_INFO(Adapter, Block);
    return MappingInfo->SrbExtMdl;
}

PMDL
INLINE
SpGetRemappedSenseBuffer(
    PADAPTER_EXTENSION Adapter,
    PVOID Block
    )
{
    PSP_VA_MAPPING_INFO MappingInfo = GET_VA_MAPPING_INFO(Adapter, Block);
    return MappingInfo->SenseMdl;
}

BOOLEAN
INLINE
SpVerifierActive(
    IN PADAPTER_EXTENSION Adapter
    )
{
    return (Adapter->VerifierExtension != NULL) ? TRUE : FALSE;
}

BOOLEAN
INLINE
SpVerifyingCommonBuffer(
    IN PADAPTER_EXTENSION Adapter
    )
{
    return (Adapter->VerifierExtension == NULL) ? FALSE :
       (Adapter->VerifierExtension->VrfyLevel & SP_VRFY_COMMON_BUFFERS) ? TRUE :
       FALSE;
}

//
// Definitions and declarations used for logging allocation failures.  When
// enabled, all allocation failures are logged to the system event log
// as warnings.
//

PVOID
SpAllocateErrorLogEntry(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
FASTCALL
SpLogAllocationFailureFn(
    IN PDRIVER_OBJECT DriverObject,
    IN POOL_TYPE PoolType,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN ULONG FileId,
    IN ULONG LineNumber
    );

PVOID
SpAllocatePoolEx(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    );

PMDL
SpAllocateMdlEx(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    );

PIRP
SpAllocateIrpEx(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota,
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG FileId,
    IN ULONG LineNumber
    );

#define SCSIPORT_TAG_ALLOCMDL  TAG('LDMs')
#define SCSIPORT_TAG_ALLOCIRP  TAG('PRIs')
#define SCSIPORT_TAG_LOOKASIDE TAG('LALs')

#define SpAllocatePool(type, size, tag, drvObj) \
    SpAllocatePoolEx((type), (size), (tag), (drvObj), __FILE_ID__, __LINE__)

#define SpAllocateMdl(va, len, secbuf, cq, irp, drvobj) \
    SpAllocateMdlEx((va), (len), (secbuf), (cq), (irp), (drvobj), __FILE_ID__, __LINE__)

#define SpAllocateIrp(ss, cq, drvobj) \
    SpAllocateIrpEx((ss), (cq), (drvobj), __FILE_ID__, __LINE__)

//
// This structure makes it easy to allocate a contiguous chunk of memory
// for an event log entry with room for the insertion strings.
//
typedef struct _SCSIPORT_ALLOCFAILURE_DATA {
    ULONG Size;
    ULONG FileId;
    ULONG LineNumber;
} SCSIPORT_ALLOCFAILURE_DATA;

//
// Inline functions
//

ULONG
INLINE
SpGetCommonBufferSize(
    IN PADAPTER_EXTENSION DeviceExtension,
    IN ULONG NonCachedExtensionSize,
    OUT OPTIONAL PULONG BlockSize
    )
{
    ULONG length;
    ULONG blockSize;

    //
    // To ensure that we never transfer normal request data to the SrbExtension
    // (ie. the case of Srb->SenseInfoBuffer == VirtualAddress in
    // ScsiPortGetPhysicalAddress) on some platforms where an inconsistency in
    // MM can result in the same Virtual address supplied for 2 different
    // physical addresses, bump the SrbExtensionSize if it's zero.
    //

    if (DeviceExtension->SrbExtensionSize == 0) {
        DeviceExtension->SrbExtensionSize = 16;
    }

    //
    // Calculate the block size for the list elements based on the Srb
    // Extension.
    //

    blockSize = DeviceExtension->SrbExtensionSize;

    //
    // If auto request sense is supported then add in space for the request
    // sense data.
    //

    if (DeviceExtension->AutoRequestSense) {        
        blockSize += sizeof(SENSE_DATA) + 
                     DeviceExtension->AdditionalSenseBytes;
    }

    //
    // Round blocksize up to the size of a PVOID.
    //

    blockSize = (blockSize + sizeof(LONGLONG) - 1) & ~(sizeof(LONGLONG) - 1);

    //
    // The length of the common buffer should be equal to the size of the
    // noncached extension and a minimum number of srb extension
    //

    length = NonCachedExtensionSize + 
             (blockSize * DeviceExtension->NumberOfRequests);

    //
    // Round the length up to a page size, since HalAllocateCommonBuffer
    // allocates in pages anyway.
    //

    length = (ULONG)ROUND_TO_PAGES(length);

    //
    // If the user is interested in the block size, copy it into the provided
    // buffer.
    //

    if (BlockSize != NULL) {
        *BlockSize = blockSize;
    }

    return length;
}

NTSTATUS
INLINE
SpDispatchRequest(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PIRP Irp
    )
{
    PCOMMON_EXTENSION commonExtension = &(LogicalUnit->CommonExtension);
    PCOMMON_EXTENSION lowerCommonExtension =
        commonExtension->LowerDeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    ASSERT_PDO(LogicalUnit->CommonExtension.DeviceObject);
    ASSERT_SRB_DATA(srb->OriginalRequest);

    if((LogicalUnit->CommonExtension.IdleTimer != NULL) &&
       (SpSrbRequiresPower(srb)) &&
       !(srb->SrbFlags & SRB_FLAGS_BYPASS_LOCKED_QUEUE) &&
       !(srb->SrbFlags & SRB_FLAGS_NO_KEEP_AWAKE)) {
       PoSetDeviceBusy(LogicalUnit->CommonExtension.IdleTimer);
    }

    ASSERT(irpStack->MajorFunction == IRP_MJ_SCSI);
    return (lowerCommonExtension->MajorFunction[IRP_MJ_SCSI])(
                commonExtension->LowerDeviceObject,
                Irp);
}


BOOLEAN
INLINE
SpSrbIsBypassRequest(
    PSCSI_REQUEST_BLOCK Srb,
    ULONG LuFlags
    )
/*++

Routine Description:

    This routine determines whether a request is a "bypass" request - one which
    should skip the lun queueing and be injected straight into the startio
    queue.

    Bypass requests do not start the next LU request when they complete.  This
    ensures that no new i/o is run until the condition being bypassed is
    cleared.

    Note: LOCK & UNLOCK requests are not bypass requests unless the queue
          is already locked.  This ensures that the first LOCK request will
          get run after previously queued requests, but that additional LOCK
          requests will not get stuck in the lun queue.

          Likewise any UNLOCK request sent when the queue is locked will be
          run immediately.  However since SpStartIoSynchronized checks to
          see if the request is a bypass request AFTER ScsiPortStartIo has
          cleared the QUEUE_LOCKED flag this will force the completion dpc
          to call GetNextLuRequest which will take the next operation out of
          the lun queue.  This is how i/o is restarted after a lock sequence
          has been completed.

Arguments:

    Srb - the srb in question

    LuFlags - the flags for the lun.

Return Value:

    TRUE if the request should bypass the lun queue, be injected into the
         StartIo queue and if GetNextLuRequest should not be called after this
         request has completed.

    FALSE otherwise

--*/

{
    ULONG flags = Srb->SrbFlags & (SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                                   SRB_FLAGS_BYPASS_LOCKED_QUEUE);

    ASSERT(TEST_FLAG(LuFlags, LU_QUEUE_FROZEN | LU_QUEUE_LOCKED) !=
           (LU_QUEUE_FROZEN | LU_QUEUE_LOCKED));

    if(flags == 0) {
        return FALSE;
    }

    if(flags & SRB_FLAGS_BYPASS_LOCKED_QUEUE) {

        DebugPrint((2, "SpSrbIsBypassRequest: Srb %#08lx is marked to bypass "
                       "locked queue\n", Srb));

        if(TEST_FLAG(LuFlags, LU_QUEUE_LOCKED | LU_QUEUE_PAUSED)) {

            DebugPrint((1, "SpSrbIsBypassRequest: Queue is locked - %#08lx is "
                           "a bypass srb\n", Srb));
            return TRUE;
        } else {
            DebugPrint((3, "SpSrbIsBypassRequest: Queue is not locked - not a "
                           "bypass request\n"));
            return FALSE;
        }
    }

    return TRUE;
}

VOID
INLINE
SpRequestCompletionDpc(
    IN PDEVICE_OBJECT Adapter
    )

/*++

Routine Description:

    This routine will request that the Completion DPC be queued if there isn't
    already one queued or in progress.  It will set the DpcFlags
    PD_DPC_NOTIFICATION_REQUIRED and PD_DPC_RUNNING.  If the DPC_RUNNING flag
    was not already set then it will request a DPC from the system as well.

Arguments:

    Adapter - the Adapter to request the DPC for

Return Value:

    none

--*/

{
    PADAPTER_EXTENSION adapterExtension = Adapter->DeviceExtension;
    ULONG oldDpcFlags;

    //
    // Set the DPC flags to indicate that there is work to be processed
    // (otherwise we wouldn't queue the DPC) and that the DPC is queued.
    //

    oldDpcFlags = InterlockedExchange(
                    &(adapterExtension->DpcFlags),
                    (PD_NOTIFICATION_REQUIRED | PD_DPC_RUNNING));

    //
    // If the DPC was already queued or running then don't bother requesting
    // a new one - the current one will pickup the work itself.
    //

    if(TEST_FLAG(oldDpcFlags, PD_DPC_RUNNING) == FALSE) {
        IoRequestDpc(Adapter, NULL, NULL);
    }

    return;
}


NTSTATUS
INLINE
SpTranslateScsiStatus(
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    This routine translates an srb status into an ntstatus.

Arguments:

    Srb - Supplies a pointer to the failing Srb.

Return Value:

    An nt status approprate for the error.

--*/

{
    switch (SRB_STATUS(Srb->SrbStatus)) {
    case SRB_STATUS_INVALID_LUN:
    case SRB_STATUS_INVALID_TARGET_ID:
    case SRB_STATUS_NO_DEVICE:
    case SRB_STATUS_NO_HBA:
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    case SRB_STATUS_COMMAND_TIMEOUT:
    case SRB_STATUS_TIMEOUT:
        return(STATUS_IO_TIMEOUT);
    case SRB_STATUS_SELECTION_TIMEOUT:
        return(STATUS_DEVICE_NOT_CONNECTED);
    case SRB_STATUS_BAD_FUNCTION:
    case SRB_STATUS_BAD_SRB_BLOCK_LENGTH:
        return(STATUS_INVALID_DEVICE_REQUEST);
    case SRB_STATUS_DATA_OVERRUN:
        return(STATUS_BUFFER_OVERFLOW);
    default:
        return(STATUS_IO_DEVICE_ERROR);
    }

    return(STATUS_IO_DEVICE_ERROR);
}

PVOID
INLINE
SpGetSrbExtensionBuffer(
    IN PADAPTER_EXTENSION Adapter
    )

/*++

Routine Description:

    This routine returns a pointer to the adapter's SrbExtensionBuffer.

Arguments:

    Adapter - Supplies a pointer to the adapter's ADAPTER_EXTNENSION.

Return Value:

    A pointer to the adapter's SrbExtensionBuffer.

--*/

{
    return (SpVerifyingCommonBuffer(Adapter)) ?
       Adapter->VerifierExtension->CommonBufferVAs :
       Adapter->SrbExtensionBuffer;
}

VOID
INLINE
SpForceRequestIntoLuQueue(
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey,
    IN PVOID BusyRequest
    )
{
    if (!KeInsertByKeyDeviceQueue(
             DeviceQueue,
             DeviceQueueEntry,
             SortKey)) {

        //
        // The LU says it is busy, so there should be a busy request.
        //

        ASSERT(BusyRequest != NULL);

        //
        // We can arrive here if the LU's device queue was drained by
        // the DCP routine prior to calling us, transitioning the queue
        // from busy to not busy.  It is safe for us to force the
        // request into the queue because we know we have a busy
        // request that will get restarted by our TickHandler routine.
        //

        KeInsertByKeyDeviceQueue(
            DeviceQueue,
            DeviceQueueEntry,
            SortKey);
    }
}

PMDL
SpBuildMdlForMappedTransfer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDMA_ADAPTER AdapterObject,
    IN PMDL OriginalMdl,
    IN PVOID StartVa,
    IN ULONG ByteCount,
    IN PSRB_SCATTER_GATHER ScatterGatherList,
    IN ULONG ScatterGatherEntries
    );

NTSTATUS
SpFlushReleaseQueue(
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN BOOLEAN Flush,
    IN BOOLEAN SurpriseRemove 
    );

#if defined(FORWARD_PROGRESS)
VOID
SpPrepareMdlForMappedTransfer(
    IN PMDL mdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDMA_ADAPTER AdapterObject,
    IN PMDL OriginalMdl,
    IN PVOID StartVa,
    IN ULONG ByteCount,
    IN PSRB_SCATTER_GATHER ScatterGatherList,
    IN ULONG ScatterGatherEntries
    );

VOID
INLINE
SpFreeSrbExtension(
    IN PADAPTER_EXTENSION Adapter, 
    IN PVOID SrbExtension
    )
{
    if (SpVerifyingCommonBuffer(Adapter)) {
        
        SpInsertSrbExtension(Adapter, SrbExtension);
        
    } else {
        
        *((PVOID *) SrbExtension) = Adapter->SrbExtensionListHeader;
        Adapter->SrbExtensionListHeader = SrbExtension;
        
    }    
}
#endif // FORWARD_PROGRESS

#endif

#if defined(NEWQUEUE)
#define SP_DEFAULT_MAX_CAPACITY 0xffffffff
#define SP_DEFAULT_ZONES        4

extern ULONG SpPerZoneLimit;
extern ULONG SpPerBlockLimit;
#endif // NEWQUEUE

#endif // _PORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\verify.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 2000

Module Name:

    verify.c

Abstract:

    This module implements a driver verifier extension for the SCSI port 
    driver.  Scsiport adds some of its exports to the list of apis that get 
    thunked by the system driver verifier, thus enabling scsiport-specific 
    verification of miniport drivers.

Authors:

    John Strange (JohnStra)

Environment:

    kernel mode only

Revision History:

--*/

#include "port.h"

#if DBG
static const char *__file__ = __FILE__;
#endif

#define __FILE_ID__ 'vfry'

SCSIPORT_API
ULONG
ScsiPortInitializeVrfy(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
    IN PVOID HwContext
    );

SCSIPORT_API
VOID
ScsiPortCompleteRequestVrfy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    );

SCSIPORT_API
PSCSI_REQUEST_BLOCK
ScsiPortGetSrbVrfy(
    IN PVOID DeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    );

SCSIPORT_API
PVOID
ScsiPortGetDeviceBaseVrfy(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    );

SCSIPORT_API
VOID
ScsiPortNotificationVrfy(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    );

SCSIPORT_API
VOID
ScsiPortFlushDmaVrfy(
    IN PVOID DeviceExtension
    );

SCSIPORT_API
VOID
ScsiPortFreeDeviceBaseVrfy(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    );

SCSIPORT_API
ULONG
ScsiPortGetBusDataVrfy(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

SCSIPORT_API
PVOID
ScsiPortGetLogicalUnitVrfy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    );

SCSIPORT_API
SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddressVrfy(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    );

SCSIPORT_API
PVOID
ScsiPortGetUncachedExtensionVrfy(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    );

SCSIPORT_API
PVOID
ScsiPortGetVirtualAddressVrfy(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    );

SCSIPORT_API
VOID
ScsiPortIoMapTransferVrfy(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    );

SCSIPORT_API
VOID
ScsiPortMoveMemoryVrfy(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    );

SCSIPORT_API
ULONG
ScsiPortSetBusDataByOffsetVrfy(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

SCSIPORT_API
BOOLEAN
ScsiPortValidateRangeVrfy(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    );

SCSIPORT_API
VOID
ScsiPortStallExecutionVrfy(
    IN ULONG Delay
    );

PVOID
SpAllocateContiguousChunk(
    IN PDRIVER_OBJECT DriverObject,
    IN PDMA_ADAPTER DmaAdapterObject,
    IN BOOLEAN Dma64BitAddresses,
    IN ULONG Length,
    IN ULONG Align,
    OUT PHYSICAL_ADDRESS *PhysicalCommonBuffer,
    OUT BOOLEAN *CommonBuffer
    );

PVOID
SpRemapBlock(
    IN PVOID BlockVa,
    IN ULONG BlockSize,
    OUT PMDL* Mdl
    );

BOOLEAN
SpCheckForActiveRequests(
    IN PADAPTER_EXTENSION
    );

ULONG
SpGetAdapterVerifyLevel(
    IN PADAPTER_EXTENSION Adapter
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpVerifierInitialization)
#pragma alloc_text(PAGE, ScsiPortInitializeVrfy)
#pragma alloc_text(PAGE, SpGetAdapterVerifyLevel)
#pragma alloc_text(PAGE, SpDoVerifierInit)

#pragma alloc_text(PAGEVRFY1, ScsiPortGetSrbVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortCompleteRequestVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetDeviceBaseVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortNotificationVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortFlushDmaVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortFreeDeviceBaseVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetBusDataVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetLogicalUnitVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetPhysicalAddressVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetUncachedExtensionVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortGetVirtualAddressVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortMoveMemoryVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortSetBusDataByOffsetVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortValidateRangeVrfy)
#pragma alloc_text(PAGEVRFY1, ScsiPortStallExecutionVrfy)

#pragma alloc_text(PAGEVRFY, SpHwFindAdapterVrfy)
#pragma alloc_text(PAGEVRFY, SpHwInitializeVrfy)
#pragma alloc_text(PAGEVRFY, SpHwStartIoVrfy)
#pragma alloc_text(PAGEVRFY, SpHwInterruptVrfy)
#pragma alloc_text(PAGEVRFY, SpHwResetBusVrfy)
#pragma alloc_text(PAGEVRFY, SpHwDmaStartedVrfy)
#pragma alloc_text(PAGEVRFY, SpHwRequestInterruptVrfy)
#pragma alloc_text(PAGEVRFY, SpHwTimerRequestVrfy)
#pragma alloc_text(PAGEVRFY, SpHwAdapterControlVrfy)
#pragma alloc_text(PAGEVRFY, SpVerifySrbStatus)
#pragma alloc_text(PAGEVRFY, SpAllocateContiguousChunk)
#pragma alloc_text(PAGEVRFY, SpGetCommonBufferVrfy)
#pragma alloc_text(PAGEVRFY, SpFreeCommonBufferVrfy)
#pragma alloc_text(PAGEVRFY, SpGetOriginalSrbExtVa)
#pragma alloc_text(PAGEVRFY, SpInsertSrbExtension)
#pragma alloc_text(PAGEVRFY, SpPrepareSrbExtensionForUse)
#pragma alloc_text(PAGEVRFY, SpPrepareSenseBufferForUse)
#pragma alloc_text(PAGEVRFY, SpRemapBlock)
#pragma alloc_text(PAGEVRFY, SpGetInaccessiblePage)
#pragma alloc_text(PAGEVRFY, SpEnsureAllRequestsAreComplete)
#pragma alloc_text(PAGEVRFY, SpCheckForActiveRequests)
#endif

//
// Some defines and a macro for conditionally verifying based on the 
// verification level.
//
#define SP_DONT_CHK_HW_INITIALIZE_DURATION     0x80000000
#define SP_DONT_CHK_ACTIVE_UNTAGGED_REQUEST    0x40000000
#define SP_DONT_CHK_REQUESTS_ON_RESET          0x20000000
#define SP_DONT_CHK_HW_ADAPTERCONTROL_DURATION 0x10000000

#define VRFY_DO_CHECK(adapter, chk)\
(((adapter)->VerifierExtension != NULL) &&\
(((adapter)->VerifierExtension->VrfyLevel & (chk)) == 0))


//
// Indicates whether scsiport's verifier functionality has been initialized.
//
ULONG ScsiPortVerifierInitialized = 0;

//
// Handle to pageable verifier code sections.  We manually lock the verify
// code into memory iff we need it.
//
PVOID VerifierCodeSectionHandle = NULL;
PVOID VerifierApiCodeSectionHandle = NULL;

//
// Time increment of the interval timer in 100 ns units.  We use this to
// calculate the time miniport routines execute so we can catch those that
// run longer than they should.
//
ULONG TimeIncrement;

//
// Global variable used to control verification aggressiveness.  This value
// is used in conjuction with a per-adapter registry value, to control what
// type of verification we do on a particular miniport.
//
ULONG SpVrfyLevel = 0;

//
// Global variable used to control how aggressively we seek out stall
// offenders.  Default is a tenth of a second.
//
ULONG SpVrfyMaximumStall = 100000;

//
// When verifier needs a unique address, this is what it uses.
//
ULONG SpMarker = 0x59465256;

//
// This table represents the functions verify will thunk for us.
//
#define SPVERIFIERFUNC(pfn) ((PDRIVER_VERIFIER_THUNK_ROUTINE)(pfn))

const DRIVER_VERIFIER_THUNK_PAIRS ScsiPortVerifierFunctionTable[] =
{
    {SPVERIFIERFUNC(ScsiPortInitialize), SPVERIFIERFUNC(ScsiPortInitializeVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetSrb), SPVERIFIERFUNC(ScsiPortGetSrbVrfy)},
    {SPVERIFIERFUNC(ScsiPortCompleteRequest), SPVERIFIERFUNC(ScsiPortCompleteRequestVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetDeviceBase), SPVERIFIERFUNC(ScsiPortGetDeviceBaseVrfy)},
    {SPVERIFIERFUNC(ScsiPortNotification), SPVERIFIERFUNC(ScsiPortNotificationVrfy)},
    {SPVERIFIERFUNC(ScsiPortFlushDma), SPVERIFIERFUNC(ScsiPortFlushDmaVrfy)},
    {SPVERIFIERFUNC(ScsiPortFreeDeviceBase), SPVERIFIERFUNC(ScsiPortFreeDeviceBaseVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetBusData), SPVERIFIERFUNC(ScsiPortGetBusDataVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetLogicalUnit), SPVERIFIERFUNC(ScsiPortGetLogicalUnitVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetPhysicalAddress), SPVERIFIERFUNC(ScsiPortGetPhysicalAddressVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetUncachedExtension), SPVERIFIERFUNC(ScsiPortGetUncachedExtensionVrfy)},
    {SPVERIFIERFUNC(ScsiPortGetVirtualAddress), SPVERIFIERFUNC(ScsiPortGetVirtualAddressVrfy)},
    {SPVERIFIERFUNC(ScsiPortIoMapTransfer), SPVERIFIERFUNC(ScsiPortIoMapTransferVrfy)},
    {SPVERIFIERFUNC(ScsiPortMoveMemory), SPVERIFIERFUNC(ScsiPortMoveMemoryVrfy)},
    {SPVERIFIERFUNC(ScsiPortSetBusDataByOffset), SPVERIFIERFUNC(ScsiPortSetBusDataByOffsetVrfy)},
    {SPVERIFIERFUNC(ScsiPortValidateRange), SPVERIFIERFUNC(ScsiPortValidateRangeVrfy)},
    {SPVERIFIERFUNC(ScsiPortStallExecution), SPVERIFIERFUNC(ScsiPortStallExecutionVrfy)},
};


BOOLEAN
SpVerifierInitialization(
    VOID
    )

/*++

Routine Description:

    This routine initializes scsiport's verifier functionality.

    Adds several of scsiport's exported functions to the list of routines
    thunked by the system verifier.

Arguments:

    VOID

Return Value:

    TRUE if verifier is successfully initialized.

--*/

{
    ULONG Flags;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Query the system for verifier information.  This is to ensure that 
    // verifier is present and operational on the system.  If this fails, we 
    // give up and return FALSE.
    //

    Status = MmIsVerifierEnabled (&Flags);

    if (NT_SUCCESS(Status)) {

        //
        // Add scsiport APIs to the set that will be thunked by the system
        // for verification.
        //

        Status = MmAddVerifierThunks ((VOID *) ScsiPortVerifierFunctionTable,
                                      sizeof(ScsiPortVerifierFunctionTable));
        if (NT_SUCCESS(Status)) {

            //
            // Set the system query time increment.  Our verifier code uses
            // this to calculate the time miniport routines take to execute.
            //

            TimeIncrement = KeQueryTimeIncrement();

            return TRUE;
        }
    }

    return FALSE;
}

ULONG
ScsiPortInitializeVrfy(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
    IN PVOID HwContext
    )
{
    ULONG Result;
    PDRIVER_OBJECT DriverObject = Argument1;
    PSCSIPORT_DRIVER_EXTENSION DriverExtension;

    PAGED_CODE();

    //
    // Lock the thunked API routines down.
    //

#ifdef ALLOC_PRAGMA
    if (VerifierApiCodeSectionHandle == NULL) {
        VerifierApiCodeSectionHandle = MmLockPagableCodeSection(ScsiPortGetSrbVrfy);
    }
#endif

    if (Argument1 == NULL || Argument2 == NULL) {

        //
        // Argument1 and Argument2 must be non-NULL.
        //

        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      SCSIPORT_VERIFIER_BAD_INIT_PARAMS,
                      (ULONG_PTR)Argument1,
                      (ULONG_PTR)Argument2,
                      0);
    }

    //
    // Forward the call on to ScsiPortInitialize.
    //

    Result = ScsiPortInitialize (Argument1, 
                                 Argument2, 
                                 HwInitializationData, 
                                 HwContext);

    //
    // If initialization was successful, try to initialize verifier settings.
    //

    if (NT_SUCCESS(Result)) {

        DriverExtension = IoGetDriverObjectExtension (DriverObject,
                                                      ScsiPortInitialize);
        if (DriverExtension != NULL) {

            //
            // Indicate that the driver is being verified by scsiport.
            //

            InterlockedExchange(&DriverExtension->Verifying, 1);
        }        
    }

    return Result;
}

PSCSI_REQUEST_BLOCK
ScsiPortGetSrbVrfy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    )
{
    return ScsiPortGetSrb(HwDeviceExtension,
                          PathId,
                          TargetId,
                          Lun,
                          QueueTag);
}

VOID
ScsiPortCompleteRequestVrfy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )
{
    ScsiPortCompleteRequest(HwDeviceExtension,
                            PathId,
                            TargetId,
                            Lun,
                            SrbStatus);
}

PVOID
ScsiPortGetDeviceBaseVrfy(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    SCSI_PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    )
{
    return ScsiPortGetDeviceBase(HwDeviceExtension,
                                 BusType,
                                 SystemIoBusNumber,
                                 IoAddress,
                                 NumberOfBytes,
                                 InIoSpace);
}

VOID
ScsiPortNotificationVrfy(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )
{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK Srb;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    PHW_INTERRUPT HwRequestInterrupt;
    PHW_INTERRUPT HwTimerRequest;
    ULONG MiniportTimerValue;
    PWNODE_EVENT_ITEM WnodeEventItem;
    PSRB_DATA srbData;
    va_list ap;

    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case NextRequest:

            ScsiPortNotification(NotificationType, HwDeviceExtension);
            va_end(ap);
            return;

        case RequestComplete:

            Srb = va_arg(ap, PSCSI_REQUEST_BLOCK);

            //
            // Check that the status makes sense.
            //

            SpVerifySrbStatus(HwDeviceExtension, Srb);

            //
            // Check that this request has not already been completed.
            //

            if ((Srb->SrbFlags & SRB_FLAGS_IS_ACTIVE) == 0) {
                KeBugCheckEx(
                    SCSI_VERIFIER_DETECTED_VIOLATION,
                    SCSIPORT_VERIFIER_REQUEST_COMPLETED_TWICE,
                    (ULONG_PTR)HwDeviceExtension,
                    (ULONG_PTR)Srb, 
                    0);                     
            }

            //
            // Restore the DataBuffer in the SRB if we plugged in our
            // pointer to unmapped memory.  We did this if the adapter
            // does not specify MappedBuffers because the miniport is
            // not supposed to touch the buffer in that case.
            //

            srbData = (PSRB_DATA)Srb->OriginalRequest;
            ASSERT_SRB_DATA(srbData);

            if (srbData->UnmappedDataBuffer != &SpMarker) {
                ASSERT(srbData->UnmappedDataBuffer != NULL);
                Srb->DataBuffer = srbData->UnmappedDataBuffer;
            }
            srbData->UnmappedDataBuffer = NULL;

            //
            // Forward on to the real ScsiPortNotification routine.
            //

            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 Srb);

            va_end(ap);
            return;

        case ResetDetected:

            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension);
            va_end(ap);
            return;

        case NextLuRequest:

            //
            // The miniport driver is ready for the next request and
            // can accept a request for this logical unit.
            //

            PathId = va_arg(ap, UCHAR);
            TargetId = va_arg(ap, UCHAR);
            Lun = va_arg(ap, UCHAR);

            logicalUnit = deviceExtension->CachedLogicalUnit;

            if ((logicalUnit == NULL)
                || (logicalUnit->TargetId != TargetId)
                || (logicalUnit->PathId != PathId)
                || (logicalUnit->Lun != Lun)) {

                logicalUnit = GetLogicalUnitExtension(deviceExtension,
                                                      PathId,
                                                      TargetId,
                                                      Lun,
                                                      FALSE,
                                                      FALSE);
            }

            //
            // Bugcheck if there is an untagged request active for this 
            // logical unit.
            //

            if (VRFY_DO_CHECK(deviceExtension, SP_DONT_CHK_ACTIVE_UNTAGGED_REQUEST) &&
                logicalUnit != NULL &&
                logicalUnit->CurrentUntaggedRequest != NULL &&
                logicalUnit->CurrentUntaggedRequest->CurrentSrb != NULL &&
                logicalUnit->CurrentUntaggedRequest->CurrentSrb->SrbFlags & SRB_FLAGS_IS_ACTIVE) {
                
                KeBugCheckEx (
                    SCSI_VERIFIER_DETECTED_VIOLATION,
                    SCSIPORT_VERIFIER_UNTAGGED_REQUEST_ACTIVE,
                    (ULONG_PTR)HwDeviceExtension,
                    (ULONG_PTR)logicalUnit, 
                    0);
            }

            //
            // Forward on to the real ScsiPortNotification.
            //

            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 PathId,
                                 TargetId,
                                 Lun);
            va_end(ap);
            return;

        case CallDisableInterrupts:

            HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);
            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 HwRequestInterrupt);
            va_end(ap);
            return;

        case CallEnableInterrupts:

            HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);
            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 HwRequestInterrupt);
            va_end(ap);
            return;

        case RequestTimerCall:

            HwTimerRequest = va_arg(ap, PHW_INTERRUPT);
            MiniportTimerValue = va_arg(ap, ULONG);
            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 HwTimerRequest,
                                 MiniportTimerValue);
            va_end(ap);
            return;

        case WMIEvent:

            WnodeEventItem = va_arg(ap, PWNODE_EVENT_ITEM);
            PathId = va_arg(ap, UCHAR);

            if (PathId != 0xFF) {
                TargetId = va_arg(ap, UCHAR);
                Lun = va_arg(ap, UCHAR);
                ScsiPortNotification(NotificationType,
                                     HwDeviceExtension,
                                     WnodeEventItem,
                                     PathId,
                                     TargetId,
                                     Lun);
            } else {
                ScsiPortNotification(NotificationType,
                                     HwDeviceExtension,
                                     WnodeEventItem,
                                     PathId);
            }
            va_end(ap);
            return;

        case WMIReregister:

            PathId = va_arg(ap, UCHAR);

            if (PathId != 0xFF) {
                TargetId = va_arg(ap, UCHAR);
                Lun = va_arg(ap, UCHAR);
                ScsiPortNotification(NotificationType,
                                     HwDeviceExtension,
                                     PathId,
                                     TargetId,
                                     Lun);
            } else {
                ScsiPortNotification(NotificationType,
                                     HwDeviceExtension,
                                     PathId);
            }
            va_end(ap);
            return;

        case BusChangeDetected:

            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension);
            va_end(ap);
            return;

        default:

            ScsiPortNotification(NotificationType,
                                 HwDeviceExtension);
            va_end(ap);
            return;
    }
}

VOID
ScsiPortFlushDmaVrfy(
    IN PVOID DeviceExtension
    )
{
    ScsiPortFlushDma(DeviceExtension);
    return;
}

VOID
ScsiPortFreeDeviceBaseVrfy(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )
{
    ScsiPortFreeDeviceBase(HwDeviceExtension, MappedAddress);
    return;
}

ULONG
ScsiPortGetBusDataVrfy(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    ULONG BusData;

    if (BusDataType != PCIConfiguration) {
        KeBugCheckEx(SCSI_VERIFIER_DETECTED_VIOLATION,
                     SCSIPORT_VERIFIER_BAD_BUSDATATYPE,
                     (ULONG_PTR)BusDataType,
                     (ULONG_PTR)DeviceExtension,
                     (ULONG_PTR)SystemIoBusNumber);
    }

    BusData = ScsiPortGetBusData(DeviceExtension,
                                 BusDataType,
                                 SystemIoBusNumber,
                                 SlotNumber,
                                 Buffer,
                                 Length);
    return BusData;
}

PVOID
ScsiPortGetLogicalUnitVrfy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
{
    PVOID LogicalUnit;
    LogicalUnit = ScsiPortGetLogicalUnit(HwDeviceExtension,
                                         PathId,
                                         TargetId,
                                         Lun);
    return LogicalUnit;
}

SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddressVrfy(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    )
{
    PADAPTER_EXTENSION  deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PHYSICAL_ADDRESS    address;
    PSP_VA_MAPPING_INFO MappingInfo;
    ULONG               byteOffset;
    ULONG               length;

    if ((deviceExtension->VerifierExtension != NULL) &&
        (deviceExtension->VerifierExtension->VrfyLevel & SP_VRFY_COMMON_BUFFERS) &&
        (Srb == NULL || Srb->SenseInfoBuffer == VirtualAddress)) {

        ULONG i;
        PVOID* BlkAddr;
        PUCHAR Beginning, End;
        PHYSICAL_ADDRESS *AddressBlock;

        //
        // Initialize a pointer to our array of common memory block 
        // descriptors.  We use this to locate the block that contains
        // the VA.
        //

        BlkAddr = deviceExtension->VerifierExtension->CommonBufferVAs;
        
        //
        // Look for the block that contains the VA.
        //

        for (i = 0; i < deviceExtension->NumberOfRequests; i++) {

            //
            // First, check if the VA is in the SRB extension.
            //

            MappingInfo = GET_VA_MAPPING_INFO(deviceExtension, BlkAddr[i]);
            if (MappingInfo->RemappedSrbExtVa != NULL) {
                Beginning = MappingInfo->RemappedSrbExtVa;
            } else {
                Beginning = BlkAddr[i];
            }
            End = (PUCHAR)ROUND_TO_PAGES((PUCHAR)Beginning + deviceExtension->SrbExtensionSize);
            
            if ((PUCHAR)VirtualAddress >= Beginning && 
                (PUCHAR)VirtualAddress < End) {
                byteOffset = (ULONG)((PUCHAR)VirtualAddress - Beginning);
                break;
            }

            //
            // Next, check if the VA is in the Sense Data Buffer.
            //

            if (deviceExtension->AutoRequestSense == TRUE) {        

                if (MappingInfo->RemappedSenseVa != NULL) {
                    Beginning = MappingInfo->RemappedSenseVa;
                } else {
                    Beginning = (PUCHAR)BlkAddr[i] + 
                        ROUND_TO_PAGES(deviceExtension->SrbExtensionSize);
                }
                End = Beginning + PAGE_SIZE;

                if ((PUCHAR)VirtualAddress >= Beginning && 
                    (PUCHAR)VirtualAddress < End) {                    
                    byteOffset = (ULONG)((PUCHAR)VirtualAddress - Beginning) +
                       (ULONG)ROUND_TO_PAGES(deviceExtension->SrbExtensionSize);
                    break;
                }
            }
        }
        
        //
        // If we haven't found the VA yet, it must be in the non-cached 
        // extension.
        //
        
        if (i == deviceExtension->NumberOfRequests) {
         
            if (deviceExtension->VerifierExtension->NonCachedBufferSize != 0) {

                Beginning = BlkAddr[i];
                End = (PUCHAR) ROUND_TO_PAGES(
                    (PUCHAR)Beginning + 
                    deviceExtension->VerifierExtension->NonCachedBufferSize);
            
                if ((PUCHAR)VirtualAddress < Beginning && 
                    (PUCHAR)VirtualAddress >= End) {

                    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                                  SCSIPORT_VERIFIER_BAD_VA,
                                  (ULONG_PTR)HwDeviceExtension,
                                  (ULONG_PTR)VirtualAddress,
                                  0);                        
                }

                byteOffset = (ULONG)((PUCHAR)VirtualAddress - Beginning);

            } else {

                KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                              SCSIPORT_VERIFIER_BAD_VA,
                              (ULONG_PTR)HwDeviceExtension,
                              (ULONG_PTR)VirtualAddress,
                              0);
            }
        }
                
        //
        // Get the physical address.
        //
        
        AddressBlock = deviceExtension->VerifierExtension->CommonBufferPAs;
        address.QuadPart = AddressBlock[i].QuadPart + byteOffset;
        
        //
        // Calculate the length of the block.
        //
        
        length = (ULONG)((End - (PUCHAR)VirtualAddress) + 1);

        return address;
    }

    //
    // Forward on to the real routine.
    //

    address = ScsiPortGetPhysicalAddress(HwDeviceExtension,
                                         Srb,
                                         VirtualAddress,
                                         Length);
    return address;
}

PVOID
ScsiPortGetUncachedExtensionVrfy(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    )
{
    PVOID Extension;
    Extension = ScsiPortGetUncachedExtension(HwDeviceExtension,
                                             ConfigInfo,
                                             NumberOfBytes);
    return Extension;
}


PVOID
ScsiPortGetVirtualAddressVrfy(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    )
{
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PVOID* BlkAddr;
    PSP_VA_MAPPING_INFO MappingInfo;
    ULONG smallphysicalBase;
    ULONG smallAddress;
    PVOID address;
    ULONG offset;
    ULONG Size;
    ULONG i;

    //
    // If the adapter is not configured to allocate multiple common buffer 
    // blocks during verification, just call the scsiport routine.
    //

    if ((deviceExtension->VerifierExtension == NULL) ||
        (deviceExtension->VerifierExtension->VrfyLevel & SP_VRFY_COMMON_BUFFERS) == 0) {
        return ScsiPortGetVirtualAddress(HwDeviceExtension, PhysicalAddress);
    }

    BlkAddr = deviceExtension->VerifierExtension->CommonBufferVAs;

    //
    // Convert the 64-bit physical address to a ULONG.
    //

    smallAddress = ScsiPortConvertPhysicalAddressToUlong(PhysicalAddress);

    //
    // Check first if the supplied physical address is in an SRB extension or
    // in a sense buffer.
    //

    for (i = 0; i < deviceExtension->NumberOfRequests; i++) {

        smallphysicalBase = 
           ScsiPortConvertPhysicalAddressToUlong(
               deviceExtension->VerifierExtension->CommonBufferPAs[i]);

        if ((smallAddress < smallphysicalBase) ||
            (smallAddress >= smallphysicalBase + 
             (deviceExtension->CommonBufferSize -
              PAGE_SIZE))) {
            continue;
        }
        
        //
        // Calculate the address of the buffer.
        //

        offset = smallAddress - smallphysicalBase;
        address = offset + (PUCHAR)BlkAddr[i];

        MappingInfo = GET_VA_MAPPING_INFO(deviceExtension, BlkAddr[i]);

        goto GotAddress;
    }

    //
    // Check if the supplied physical address is in the non-cached extension.
    //

    if (deviceExtension->VerifierExtension->NonCachedBufferSize == 0) {

        ASSERT(FALSE);
        return(NULL);

    } else {

        smallphysicalBase = 
           ScsiPortConvertPhysicalAddressToUlong(
               deviceExtension->VerifierExtension->CommonBufferPAs[i]);  

        if ((smallAddress < smallphysicalBase) ||
            (smallAddress >= smallphysicalBase + 
            deviceExtension->VerifierExtension->NonCachedBufferSize)) {

            //
            // This is a bogus physical address return back NULL.
            //

            ASSERT(FALSE);
            return(NULL);
        }

        offset = smallAddress - smallphysicalBase;
        address = offset + (PUCHAR)BlkAddr[i];

        Size = (ULONG)ROUND_TO_PAGES(deviceExtension->VerifierExtension->NonCachedBufferSize);
        MappingInfo = (PSP_VA_MAPPING_INFO)((PUCHAR)BlkAddr[i] + (Size - PAGE_SIZE));

    }

GotAddress:
    //
    // Find out if we've remapped this address.  If we have, give the
    // caller the second mapping.
    //

    if (address < MappingInfo->OriginalSenseVa && 
        MappingInfo->RemappedSrbExtVa != NULL) {
        return(offset + (PUCHAR)MappingInfo->RemappedSrbExtVa);
    }
    else if (MappingInfo->RemappedSenseVa != NULL) {
        return(offset + (PUCHAR)MappingInfo->RemappedSenseVa);
    }

    return(address);
}

VOID
ScsiPortIoMapTransferVrfy(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    )
{
    ScsiPortIoMapTransfer(HwDeviceExtension,
                          Srb,
                          LogicalAddress,
                          Length);
    return;
}

VOID
ScsiPortMoveMemoryVrfy(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    )
{
    ScsiPortMoveMemory(WriteBuffer,
                       ReadBuffer,
                       Length);
    return;
}

ULONG
ScsiPortSetBusDataByOffsetVrfy(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    ULONG Result;

    if (BusDataType != PCIConfiguration) {
        KeBugCheckEx(SCSI_VERIFIER_DETECTED_VIOLATION,
                     SCSIPORT_VERIFIER_BAD_BUSDATATYPE,
                     (ULONG_PTR)BusDataType,
                     (ULONG_PTR)DeviceExtension,
                     (ULONG_PTR)SystemIoBusNumber);
    }

    Result = ScsiPortSetBusDataByOffset(DeviceExtension,
                                        BusDataType,
                                        SystemIoBusNumber,
                                        SlotNumber,
                                        Buffer,
                                        Offset,
                                        Length);
    return Result;
}

BOOLEAN
ScsiPortValidateRangeVrfy(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )
{
    BOOLEAN Result;
    Result = ScsiPortValidateRange(HwDeviceExtension,
                                   BusType,
                                   SystemIoBusNumber,
                                   IoAddress,
                                   NumberOfBytes,
                                   InIoSpace);
    return Result;
}

VOID
ScsiPortStallExecutionVrfy(
    IN ULONG Delay
    )
{
    //
    // Miniports must specify a delay not more than one millisecond.
    //

    if (Delay > SpVrfyMaximumStall) {
        KeBugCheckEx(SCSI_VERIFIER_DETECTED_VIOLATION,
                     SCSIPORT_VERIFIER_STALL_TOO_LONG,
                     (ULONG_PTR)Delay,
                     0,
                     0);
    }

    KeStallExecutionProcessor(Delay);
}

//
// Timeout periods in ticks.  To calculate, we divide the time limit in 100 ns
// units by the TimeIncrement, which is the value returned by 
// KeQueryTimeIncrement.  Since KeQueryTickCount rounds up to the next
// tick, we'll add one tick to the defined limits.
//
#define SP_FIVE_SECOND_LIMIT  ((50000000L / TimeIncrement) + 1)
#define SP_TWO_SECOND_LIMIT   ((20000000L / TimeIncrement) + 1)
#define SP_HALF_SECOND_LIMIT  ((5000000L / TimeIncrement) + 1)

/*++

Macro Description:

    This macro checks the number of ticks elapsed during the execution of a
    miniport routine against a maximum number allowed ticks.  If the routine
    ran longer than the max allowable ticks, we bugcheck.

Arguments:

    Ticks     - number of ticks routine took to execute.

    MaxTicks  - number of ticks the routine is allowed to execute.

    Routine   - address of the routine we are checking.

    Extension - address of the miniport's HwDeviceExtension

Notes:

    The format for the bugcheck is:
        Parameter 1: 0x1002
        Parameter 2: address of routine that ran too long
        Parameter 3: address of miniport's HwDeviceExtension
        Parameter 4: duration of routine in microseconds

--*/
/*
#define SpCheckMiniportRoutineDuration(Ticks, MaxTicks, Routine, Extension) \
{                                                                           \
    if ((Ticks) > (MaxTicks)) {                                             \
        KeBugCheckEx (                                                      \
            SCSI_VERIFIER_DETECTED_VIOLATION,                               \
            SCSIPORT_VERIFIER_MINIPORT_ROUTINE_TIMEOUT,                     \
            (ULONG_PTR)(Routine),                                           \
            (ULONG_PTR)(Extension),                                         \
            (ULONG_PTR)(((Ticks) * TimeIncrement) / 10));                   \
    }                                                                       \
}
*/
#define SpCheckMiniportRoutineDuration(Ticks, MaxTicks, Routine, Extension)

ULONG
SpHwFindAdapterVrfy (
    IN PVOID HwDeviceExtension,
    IN PVOID HwContext,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    ULONG Result;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    Result =  AdapterExtension->VerifierExtension->RealHwFindAdapter(
                                                       HwDeviceExtension,
                                                       HwContext,
                                                       BusInformation,
                                                       ArgumentString,
                                                       ConfigInfo,
                                                       Again);
    return Result;
}

BOOLEAN
SpHwInitializeVrfy (
    IN PVOID HwDeviceExtension
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwInitialize(HwDeviceExtension);
    KeQueryTickCount(&Duration);
    Duration.QuadPart -= Start.QuadPart;

    if (VRFY_DO_CHECK(AdapterExtension, SP_DONT_CHK_HW_INITIALIZE_DURATION)) {
        SpCheckMiniportRoutineDuration(
            Duration.LowPart,
            SP_FIVE_SECOND_LIMIT,
            AdapterExtension->VerifierExtension->RealHwInitialize,
            HwDeviceExtension);
    }

    return Result;
}

BOOLEAN
SpHwStartIoVrfy (
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PSRB_DATA srbData;

    //
    // If MapBuffers is not set, the miniport is not supposed to touch
    // the DataBuffer field in the SRB.  To verify this, we'll set
    // DataBuffer to point to memory that will fault if the miniport tries
    // to touch it.
    //

    ASSERT(Srb != NULL);
    srbData = (PSRB_DATA)Srb->OriginalRequest;
    ASSERT_SRB_DATA(srbData);

    if (AdapterExtension->MapBuffers == FALSE 
        && !IS_MAPPED_SRB(Srb)
        && Srb->Function != SRB_FUNCTION_WMI
        && Srb->DataBuffer != NULL
        && AdapterExtension->VerifierExtension->InvalidPage != NULL
        && Srb->Cdb[0] != SCSIOP_INQUIRY
        && Srb->Cdb[0] != SCSIOP_REPORT_LUNS) {

        if (Srb->DataBuffer != AdapterExtension->VerifierExtension->InvalidPage) {
            srbData->UnmappedDataBuffer = Srb->DataBuffer;
            Srb->DataBuffer = AdapterExtension->VerifierExtension->InvalidPage;
        } else {
            ASSERT(srbData->UnmappedDataBuffer != &SpMarker);
            ASSERT(srbData->UnmappedDataBuffer != NULL);
        }

    } else {

        srbData->UnmappedDataBuffer = &SpMarker;

    }

    //
    // Call the miniport's StartIo function and calculate the call's duration.
    //

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwStartIo(
                                                      HwDeviceExtension,
                                                      Srb);
    KeQueryTickCount(&Duration);
    Duration.QuadPart -= Start.QuadPart;

    //
    // Bugcheck if the call took more than .5 seconds.
    //

    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwStartIo,
        HwDeviceExtension);

    //
    // If the HwStartIo returns failure, undo any fixups we performed on the SRB.
    //

    if (Result == FALSE 
        && srbData->UnmappedDataBuffer != &SpMarker) {

        ASSERT(srbData->UnmappedDataBuffer != NULL);
        Srb->DataBuffer = srbData->UnmappedDataBuffer;
        srbData->UnmappedDataBuffer = NULL; 

    }

    return Result;
}


BOOLEAN
SpHwInterruptVrfy (
    IN PVOID HwDeviceExtension
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    if (AdapterExtension->VerifierExtension->RealHwInterrupt == NULL) {
        return FALSE;
    }

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwInterrupt (
                                                      HwDeviceExtension);
    KeQueryTickCount(&Duration);

    Duration.QuadPart -= Start.QuadPart;
    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwInterrupt,
        HwDeviceExtension);

    return Result;
}

BOOLEAN
SpHwResetBusVrfy (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwResetBus(
                                                      HwDeviceExtension,
                                                      PathId);
    KeQueryTickCount(&Duration);

    Duration.QuadPart -= Start.QuadPart;
    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwResetBus,
        HwDeviceExtension);

    return Result;
}

VOID
SpHwDmaStartedVrfy (
    IN PVOID HwDeviceExtension
    )
{
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    AdapterExtension->VerifierExtension->RealHwDmaStarted(
                                             HwDeviceExtension);
    KeQueryTickCount(&Duration);

    Duration.QuadPart -= Start.QuadPart;
    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwDmaStarted,
        HwDeviceExtension);
}

BOOLEAN
SpHwRequestInterruptVrfy (
    IN PVOID HwDeviceExtension
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwRequestInterrupt(
                                                      HwDeviceExtension);
    KeQueryTickCount(&Duration);

    Duration.QuadPart -= Start.QuadPart;
    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwRequestInterrupt,
        HwDeviceExtension);

    return Result;
}

BOOLEAN
SpHwTimerRequestVrfy (
    IN PVOID HwDeviceExtension
    )
{
    BOOLEAN Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount(&Start);
    Result = AdapterExtension->VerifierExtension->RealHwTimerRequest(
                                                      HwDeviceExtension);
    KeQueryTickCount(&Duration);

    Duration.QuadPart -= Start.QuadPart;
    SpCheckMiniportRoutineDuration(
        Duration.LowPart,
        SP_HALF_SECOND_LIMIT,
        AdapterExtension->VerifierExtension->RealHwTimerRequest,
        HwDeviceExtension);

    return Result;
}

SCSI_ADAPTER_CONTROL_STATUS
SpHwAdapterControlVrfy (
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
{
    SCSI_ADAPTER_CONTROL_STATUS Result;
    LARGE_INTEGER Start;
    LARGE_INTEGER Duration;
    PADAPTER_EXTENSION AdapterExtension = GET_FDO_EXTENSION(HwDeviceExtension);

    KeQueryTickCount (&Start);
    Result = AdapterExtension->VerifierExtension->RealHwAdapterControl(
                                                      HwDeviceExtension,
                                                      ControlType,
                                                      Parameters);
    KeQueryTickCount(&Duration);
    Duration.QuadPart -= Start.QuadPart;

    if (VRFY_DO_CHECK(AdapterExtension, SP_DONT_CHK_HW_ADAPTERCONTROL_DURATION)) {
        SpCheckMiniportRoutineDuration(
            Duration.LowPart,
            SP_HALF_SECOND_LIMIT,
            AdapterExtension->VerifierExtension->RealHwAdapterControl,
            HwDeviceExtension);
    }

    return Result;
}

VOID
SpVerifySrbStatus(
    PVOID HwDeviceExtension,
    PSCSI_REQUEST_BLOCK srb
    )

/*++

Routine Description:

    Verify that the SRB's status as set by the miniport driver is valid.

Arguments:

    HwDeviceExtension - The port driver's device extension follows the 
                        miniport's device extension and contains a pointer to
                        the logical device extension list.

    srb               - Points to the SRB.

Return Value:

    VOID

--*/

{
    UCHAR SrbStatus;

    //
    // Turn off internal bits used by scsiport.
    //

    SrbStatus = srb->SrbStatus & ~(SRB_STATUS_QUEUE_FROZEN | 
                                   SRB_STATUS_AUTOSENSE_VALID);

    //
    // Miniports may never set the status to SRB_STATUS_PENDING.
    //

    if (SrbStatus == SRB_STATUS_PENDING) {
        goto BadStatus;
    }

    //
    // If the function is SRB_FUNCTION_EXECUTE_SCSI, then the command must be
    // either completed successfully, or ScsiStatus must be set to
    // SCSISTAT_GOOD.
    //

    if (!(SrbStatus != SRB_STATUS_SUCCESS ||
          srb->ScsiStatus == SCSISTAT_GOOD ||
          srb->Function != SRB_FUNCTION_EXECUTE_SCSI)) {
        goto BadStatus;
    }

    //
    // Make sure the status is within the valid range.
    //

    if ((SrbStatus) == 0x0C ||
        (SrbStatus > 0x16 && srb->SrbStatus < 0x20) ||
        (SrbStatus > 0x23)) {
        goto BadStatus;
    }

    //
    // The SRB Status is ok.
    //

    return;

BadStatus:
    //
    // Bugcheck if the status is bad.
    //

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  SCSIPORT_VERIFIER_BAD_SRBSTATUS,
                  (ULONG_PTR)srb,
                  (ULONG_PTR)HwDeviceExtension,
                  0);
}

PVOID
SpRemapBlock(
    IN PVOID BlockVa,
    IN ULONG BlockSize,
    OUT PMDL* Mdl
    )
/*++

Routine Description:

    This function attempts to remap the supplied VA range.  If the block is
    remapped, it will be made invalid for reading and writing.

Arguments:

    BlockVa   - Supplies the address of the block of memory to remap.

    BlockSize - Supplies the size of the block of memory to remap.

    Mdl       - Supplies the address into which the function will store
                a pointer to the MDL for the remapped range.  If the MDL
                cannot be allocated or if the range cannot be remapped,
                this will be NULL upon return.

Return Value:

    If the range is successfully remapped, the address of the beginning of
    the remapped range is returned.  Else, NULL is returned.

--*/
{
    PVOID MappedRange;
    NTSTATUS Status;
    PMDL LocalMdl;

    //
    // Try to allocate a new MDL for the range we're trying to remap.
    //

    LocalMdl = IoAllocateMdl(BlockVa, BlockSize, FALSE, FALSE, NULL);
    if (LocalMdl == NULL) {
        *Mdl = NULL;
        return NULL;
    }

    //
    // Try to lock the pages.  This initializes the MDL properly.
    //

    __try {
        MmProbeAndLockPages(LocalMdl, KernelMode, IoModifyAccess);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) {
        IoFreeMdl(LocalMdl);
        *Mdl = NULL;
        return NULL;
    }

    //
    // Try to remap the range represented by the new MDL.
    //

    MappedRange = MmMapLockedPagesSpecifyCache(LocalMdl,
                                               KernelMode,
                                               MmCached,
                                               NULL,
                                               FALSE,
                                               NormalPagePriority);
    if (MappedRange == NULL) {
        IoFreeMdl(LocalMdl);
        *Mdl = NULL;
        return NULL;
    }

    //
    // If we've gotten this far, we have successfully remapped the range.
    // Now we want to invalidate the entire range so any accesses to it
    // will be trapped by the system.
    //

    Status = MmProtectMdlSystemAddress(LocalMdl, PAGE_NOACCESS);
#if DBG==1
    if (!NT_SUCCESS(Status)) {
        DebugPrint((0, "SpRemapBlock: failed to remap block:%p mdl:%p (%x)\n", 
                    BlockVa, LocalMdl, Status));
    }
#endif

    //
    // Copy the MDL we allocated into the supplied address and return the
    // address of the beginning of the remapped range.
    //

    *Mdl = LocalMdl;
    return MappedRange;
}

VOID
SpRemapCommonBufferForMiniport(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine attempts to remap all of the common buffer blocks allocated
    for a particular adapter.

Arguments:

    DeviceExtension - Supplies a pointer to the adapter device extension.

--*/
{
    PVOID* BlkAddr = Adapter->VerifierExtension->CommonBufferVAs;
    PSP_VA_MAPPING_INFO MappingInfo;
    PVOID RemappedVa;
    ULONG Size;
    PMDL Mdl;
    ULONG i;

    //
    // Iterate through all of the common buffer blocks, and attempt to remap
    // the SRB extension and the sense buffer within each block.
    //

    for (i = 0; i < Adapter->VerifierExtension->CommonBufferBlocks; i++) {

        //
        // Get a pointer to the mapping info we keep at the end of the block.
        //

        MappingInfo = GET_VA_MAPPING_INFO(Adapter, BlkAddr[i]);
      
        //
        // Initialize the original VA info for the SRB extension.
        //

        MappingInfo->OriginalSrbExtVa = BlkAddr[i];
        MappingInfo->SrbExtLen = (ULONG)ROUND_TO_PAGES(Adapter->SrbExtensionSize);

        //
        // Initialize the original VA info for the sense buffer.
        //

        MappingInfo->OriginalSenseVa = (PUCHAR)BlkAddr[i] + MappingInfo->SrbExtLen;
        MappingInfo->SenseLen = PAGE_SIZE;

        //
        // Try to remap the SRB extension.  If successful, initialize the
        // remapped VA info for the SRB extension.
        //

        RemappedVa = SpRemapBlock(MappingInfo->OriginalSrbExtVa, 
                                  MappingInfo->SrbExtLen, 
                                  &Mdl);
        if (RemappedVa != NULL) {
            MappingInfo->RemappedSrbExtVa = RemappedVa;
            MappingInfo->SrbExtMdl = Mdl;
        }

#if 0
        //
        // Try to remap the sense buffer.  If successful, initialize the
        // remapped VA info for the sense buffer.
        //
        // For now, I think we can live without this.  I don't know of any
        // issues where overruns etc. occur in a sense buffer.
        //

        RemappedVa = SpRemapBlock(MappingInfo->OriginalSenseVa, 
                                  MappingInfo->SenseLen, 
                                  &Mdl);
        if (RemappedVa != NULL) {
            MappingInfo->RemappedSenseVa = RemappedVa;
            MappingInfo->SenseMdl = Mdl;
        }
#endif
    }

    if (Adapter->VerifierExtension->NonCachedBufferSize != 0) {
        //
        // Init uncached extension mapping info.
        //

        Size = (ULONG)ROUND_TO_PAGES(Adapter->VerifierExtension->NonCachedBufferSize);
        MappingInfo = (PSP_VA_MAPPING_INFO)((PUCHAR)BlkAddr[i] + (Size - PAGE_SIZE));
        MappingInfo->OriginalSrbExtVa = BlkAddr[i];
        MappingInfo->SrbExtLen = Adapter->VerifierExtension->NonCachedBufferSize;
        MappingInfo->OriginalSenseVa = (PUCHAR)BlkAddr[i] + Adapter->VerifierExtension->NonCachedBufferSize;
    }
}

PVOID
SpAllocateContiguousChunk(
    IN PDRIVER_OBJECT     DriverObject,
    IN PDMA_ADAPTER       DmaAdapterObject,
    IN BOOLEAN            Dma64BitAddresses,
    IN ULONG              Length,
    IN ULONG              Align,
    OUT PHYSICAL_ADDRESS *PhysicalCommonBuffer,
    OUT BOOLEAN          *CommonBuffer
    )

/*++

Routine Description:

    This routine allocates a chunk of memory which can be used for common
    buffer io.  Where the memory is allocated from depends on several 
    parameters.  If no adapter object is specified, the memory is simply
    allocated from non-paged pool.  Else, the memory is allocated such
    that it can be used in DMA operations.

Arguments:

    DriverObject           - Supplies a pointer to the driver object.

    DmaAdapterObject       - Supplies a pointer to the adapter's DMA adapter
                             object.

    Dma64BitAddresses      - Specifies whether the adapter supports 64-bit.

    Length                 - Specifies the number of bytes to allocate.

    Align                  - Alignment requirement for uncached extension.

    PhysicalCommonBuffer   - Specifies a pointer into which the physical
                             address of the allocated memory is to be copied
                             if the memory is allocated for DMA operations.

    CommonBuffer           - Supplies a pointer to a boolean that we set if the
                             memory is allocated using AllocateCommonBuffer.

Return Value:

    Returns the VA of the allocated memory if the allocation succeeds.  Else,
    returns NULL.

--*/

{
    PVOID Buffer;

    if (DmaAdapterObject == NULL) {

        //
        // Since there is no adapter object just allocate from non-paged pool.
        //

        Buffer = SpAllocatePool(
                     NonPagedPool,
                     Length,
                     SCSIPORT_TAG_COMMON_BUFFER,
                     DriverObject);
    } else {

        ASSERT(PhysicalCommonBuffer != NULL);

        //
        // If the controller can do 64-bit addresses then we need to
        // specifically force the uncached extension area below the 4GB mark.
        //

        if (((Sp64BitPhysicalAddresses) && (Dma64BitAddresses == TRUE)) ||
            Align != 0) {

            PHYSICAL_ADDRESS low;
            PHYSICAL_ADDRESS high;
            PHYSICAL_ADDRESS boundary;

            if (Align != 0) {
                boundary.QuadPart = Length;
            } else {
                boundary.QuadPart = 0;
            }

            low.QuadPart = 0;
            high.HighPart = 0;
            high.LowPart = 0xffffffff;

            //
            // We'll get page aligned memory out of this which is probably 
            // better than the requirements of the adapter.
            //

            Buffer = MmAllocateContiguousMemorySpecifyCache(
                         Length,
                         low,
                         high,
                         boundary,
                         MmCached);

            if (Buffer != NULL) {
                *PhysicalCommonBuffer = MmGetPhysicalAddress(Buffer);
            }

            if (CommonBuffer != NULL) {
                *CommonBuffer = FALSE;
            }

        } else {
            Buffer = AllocateCommonBuffer(
                         DmaAdapterObject,
                         Length,
                         PhysicalCommonBuffer,
                         FALSE);

            if (CommonBuffer != NULL) {
                *CommonBuffer = TRUE;
            }
        }
    }

    return Buffer;
}

NTSTATUS
SpGetCommonBufferVrfy(
    PADAPTER_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    )
/*++

Routine Description:

    This function allocates multiple common buffer blocks instead of one
    big one.  The verifier does this so it can remap VA ranges within
    each block in order to control their protection attributes.  This
    enables us to invalidate key VA ranges and catch miniports that attempt
    to access these ranges when they should not.

    If the remapping succeeds, the SCSI port driver hands out the remapped
    VA ranges to miniports instead of the original ranges.  If the remapping
    fails, it just hands out the original ranges.

Arguments:

    DeviceExtension        - Supplies a pointer to the device extension.

    NonCachedExtensionSize - Supplies the size of the noncached device
                             extension for the miniport driver.

Return Value:

    Returns the status of the allocate operation.

--*/
{
    NTSTATUS Status;
    PVOID buffer;
    ULONG length;
    ULONG blockSize;
    PVOID *srbExtension;
    PVOID buffer2;
    PMDL  mdl;
    ULONG TotalSize;
    ULONG i;
    PVOID* BlkAddr;
    PHYSICAL_ADDRESS *PhysicalCommonBuffer;
    PCCHAR InvalidRegion;
    BOOLEAN commonBuffer;    

    PAGED_CODE();

    DebugPrint((1, "SpGetCommonBufferVrfy: DeviceExtension:%p NonCachedExtensionSize:%d\n",
                DeviceExtension, NonCachedExtensionSize));

    //
    // Now fixup the size if the adapter has special alignment requirements so
    // the buffer we allocate may be aligned as required.
    //

    if (DeviceExtension->UncachedExtAlignment != 0) {
	NonCachedExtensionSize = 
           ROUND_UP_COUNT(NonCachedExtensionSize, 
                          DeviceExtension->UncachedExtAlignment);
    }

    //
    // We maintain a couple of arrays in order to find our common
    // buffer blocks at various times.  Calculate the amount of space we
    // need for these arrays.  This amount depends on the number of
    // simultaneous requests the adapter supports.  We add one to the
    // number of requests in order to accommodate the non-cached extension.
    //

    ASSERT(DeviceExtension->VerifierExtension->CommonBufferVAs == NULL);

    i = DeviceExtension->NumberOfRequests + 1;
    length = sizeof(PVOID) * i;

    if (DeviceExtension->DmaAdapterObject != NULL) {
        ASSERT(DeviceExtension->VerifierExtension->CommonBufferPAs == NULL);
        length += (sizeof(PHYSICAL_ADDRESS) * i);
    }

    //
    // Allocate a block of memory for these arrays.  If this allocation fails,
    // we return failure.
    //

    BlkAddr = SpAllocatePool(NonPagedPool,
                            length,
                            SCSIPORT_TAG_COMMON_BUFFER,
                            DeviceExtension->DeviceObject->DriverObject);

    if (BlkAddr == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Save the number of common buffer blocks.
    //

    DeviceExtension->VerifierExtension->CommonBufferBlocks =
       DeviceExtension->NumberOfRequests;

    //
    // Zero the entire block so when we're freeing resources we can tell if we
    // have valid buffers to free.
    //

    RtlZeroMemory(BlkAddr, length);

    //
    // Save a pointer to the array of addresses in the adapter extension and,
    // if there is an adapter object, initialize a pointer to the beginning of
    // the physical address array and save a pointer to the array in the
    // adapter extension.
    //

    DeviceExtension->VerifierExtension->CommonBufferVAs = (PVOID *)BlkAddr;
    if (DeviceExtension->DmaAdapterObject != NULL) {
        PhysicalCommonBuffer = (PHYSICAL_ADDRESS*) &BlkAddr[i];
        DeviceExtension->VerifierExtension->CommonBufferPAs = PhysicalCommonBuffer;
    }

    //
    // To ensure that we never transfer normal request data to the SrbExtension
    // (ie. the case of Srb->SenseInfoBuffer == VirtualAddress in
    // ScsiPortGetPhysicalAddress) on some platforms where an inconsistency in
    // MM can result in the same Virtual address supplied for 2 different
    // physical addresses, bump the SrbExtensionSize if it's zero.
    //

    if (DeviceExtension->SrbExtensionSize == 0) {
        DeviceExtension->SrbExtensionSize = 16;
    }

    //
    // Calculate the block size for an SRB extension/sense buffer block. If
    // AutoRequestSense is FALSE, allocate 1 page anyway as a placeholder.
    //

    blockSize = (ULONG)ROUND_TO_PAGES(DeviceExtension->SrbExtensionSize);
    if (DeviceExtension->AutoRequestSense == TRUE) {        
        blockSize += sizeof(SENSE_DATA) + DeviceExtension->AdditionalSenseBytes;
        blockSize = (ULONG)ROUND_TO_PAGES(blockSize);                   
    } else {
        blockSize += PAGE_SIZE;
    }

    //
    // Add a page for holding bookkeeping information.
    //

    blockSize += PAGE_SIZE;

    //
    // Allocate each block individually and link them all together into a
    // list.  If we fail to allocate any of the blocks, we clean everything up 
    // and return failure.
    //

    DeviceExtension->CommonBufferSize = blockSize;
    srbExtension = NULL;

    for (i = 0; i < DeviceExtension->NumberOfRequests; i++) {

        //
        // Allocate a contiguous chunk of memory for the block.
        //

        buffer = SpAllocateContiguousChunk(
            DeviceExtension->DeviceObject->DriverObject,
            DeviceExtension->DmaAdapterObject,
            DeviceExtension->Dma64BitAddresses,
            blockSize,
            0,
            (DeviceExtension->DmaAdapterObject) ? &PhysicalCommonBuffer[i] : NULL,
            &commonBuffer);
                                           
        if (buffer == NULL) {

            //
            // Free everything we've allocated so far and return failure.  This
            // will also free the arrays we allocated at the beginning of this
            // function.
            //
            
            DeviceExtension->VerifierExtension->IsCommonBuffer = commonBuffer;
            SpFreeCommonBufferVrfy(DeviceExtension);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Zero the entire block and save a pointer to it in our array.
        //

        RtlZeroMemory(buffer, blockSize);
        BlkAddr[i] = buffer;

        //
        // Link the new block onto the front of the chain.
        //

        *((PVOID *) buffer) = srbExtension;
        srbExtension = (PVOID *) buffer;
    }

    //
    // Indicate whether the buffer was allocated as common buffer.
    //

    DeviceExtension->VerifierExtension->IsCommonBuffer = commonBuffer;
   
    //
    // Allocate the non-cached extension.  Note that we align the uncached
    // buffer on the next page boundary and allocate enough for a scratch page.
    // If the allocation fails, free everything we've allocated so far and
    // return failure.
    //

    if (NonCachedExtensionSize != 0) {

        DeviceExtension->VerifierExtension->NonCachedBufferSize = NonCachedExtensionSize;
        length = (ULONG)(ROUND_TO_PAGES(NonCachedExtensionSize));

        BlkAddr[i] =
           SpAllocateContiguousChunk(
               DeviceExtension->DeviceObject->DriverObject,
               DeviceExtension->DmaAdapterObject,
               DeviceExtension->Dma64BitAddresses,
               length,
               DeviceExtension->UncachedExtAlignment,
               (DeviceExtension->DmaAdapterObject) ? &PhysicalCommonBuffer[i] : NULL,
               &DeviceExtension->UncachedExtensionIsCommonBuffer);
        
        if (BlkAddr[i] == NULL) {

            //
            // Free everything we've allocated so far and return failure.  This
            // will also free the arrays we allocated at the beginning of this
            // function.
            //
            
            SpFreeCommonBufferVrfy(DeviceExtension);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Zero the entire block.
        //

        RtlZeroMemory(BlkAddr[i], length);

        //
        // Save a pointer to the beginning of the non-cached extension data.  
        // Note that the data is positioned such that it ends on a page 
        // boundary so if the miniport overwrites the buffer, the system will
        // fault.
        //

        DeviceExtension->NonCachedExtension = 
           (PCCHAR)BlkAddr[i] + 
           (ROUND_TO_PAGES(NonCachedExtensionSize) - NonCachedExtensionSize);

    } else {

        DeviceExtension->NonCachedExtension = NULL;
        DeviceExtension->VerifierExtension->NonCachedBufferSize = 0;

    }

    //
    // If the miniport asked for an SRB Extension, point the SRB Extension List
    // at the beginning of the list of blocks we allocated and chained together 
    // above.
    //

    if (DeviceExtension->AllocateSrbExtension == TRUE) {
        DeviceExtension->SrbExtensionListHeader = srbExtension;
    } else {
        ASSERT(DeviceExtension->SrbExtensionListHeader == NULL);
    }

    //
    // Create a second VA mapping of the common buffer area so we can make the
    // range of addresses invalid when the miniport is not supposed to touch it.
    // This will allow us to catch mis-behaving miniports.
    // 

    SpRemapCommonBufferForMiniport(DeviceExtension);

    DebugPrint((1, "SpGetCommonBufferVrfy: returning STATUS_SUCCESS\n"));
    return(STATUS_SUCCESS);
}

VOID
SpFreeCommonBufferVrfy(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine frees all of the common buffer space we've allocated for the
    miniport on the supplied adapter.  If only partially allocated, the routine 
    correctly cleans up the parts that are present.  On exit, all the memory has 
    been freed and the associated pointers have been NULLed.

Arguments:

    DeviceExtension - Supplies a pointer to the adapter device extension.

Return Value:

    VOID

--*/
{
    ULONG i;
    PVOID* BlkAddr;
    NTSTATUS Status;
    PSP_VA_MAPPING_INFO MappingInfo;

    ASSERT(Adapter->SrbExtensionBuffer == NULL);

    if (Adapter->VerifierExtension != NULL &&
        Adapter->VerifierExtension->CommonBufferVAs != NULL) {
        //
        // Initialize a pointer to the array of pointers we use to track and
        // manage the common buffer blocks.
        //

        BlkAddr = Adapter->VerifierExtension->CommonBufferVAs;

        //
        // Cycle through the array of common memory descriptors, freeing each
        // one.  What we are freeing here is the SRB Extension/Sense Data
        // buffers.  Stop when we've deleted all the blocks.
        //

        for (i = 0; i < Adapter->VerifierExtension->CommonBufferBlocks && BlkAddr[i]; i++) {

            //
            // If there is a second VA range for the common block, free the 
            // MDL(s).
            // 

            MappingInfo = GET_VA_MAPPING_INFO(Adapter, BlkAddr[i]);
            
            if (MappingInfo->SrbExtMdl != NULL) {
                MmProtectMdlSystemAddress(MappingInfo->SrbExtMdl, PAGE_READWRITE);
                MmUnlockPages(MappingInfo->SrbExtMdl);
                IoFreeMdl(MappingInfo->SrbExtMdl);
            }

            if (MappingInfo->SenseMdl != NULL) {
                MmProtectMdlSystemAddress(MappingInfo->SrbExtMdl, PAGE_READWRITE);
                MmUnlockPages(MappingInfo->SenseMdl);
                IoFreeMdl(MappingInfo->SenseMdl);
            }

            //
            // Free the memory.  The method we use depends on how the memory
            // was allocated.
            //

            if (Adapter->DmaAdapterObject == NULL) {
                ExFreePool(BlkAddr[i]);            
            } else {
                if (Adapter->VerifierExtension->IsCommonBuffer == FALSE) {
                    MmFreeContiguousMemorySpecifyCache(
                        BlkAddr[i],
                        Adapter->CommonBufferSize,
                        MmCached);
                } else {
                    FreeCommonBuffer(
                        Adapter->DmaAdapterObject,
                        Adapter->CommonBufferSize,
                        Adapter->VerifierExtension->CommonBufferPAs[i],
                        BlkAddr[i],
                        FALSE);
                }
            }
        }

        //
        // Free the uncached extension if we allocated one.
        //

        if (Adapter->NonCachedExtension != NULL) {
            
            ULONG Length;

            //
            // Calculate the total length of the non-cached extension block we
            // allocated.  This is the non-cached buffer size asked for by the
            // miniport rounded up to the next page boundary plus one full page.
            //

            Length = (ULONG)(ROUND_TO_PAGES(Adapter->VerifierExtension->NonCachedBufferSize));
            
            //
            // Free the memory.  The method we use depends on how the memory
            // was allocated.
            //
            
            if (Adapter->DmaAdapterObject == NULL) {        
                ExFreePool(BlkAddr[i]);
            } else {
                if (Adapter->UncachedExtensionIsCommonBuffer == FALSE) {
                    MmFreeContiguousMemorySpecifyCache(
                        BlkAddr[i],
                        Length,
                        MmCached);
                } else {
                    FreeCommonBuffer(
                        Adapter->DmaAdapterObject,
                        Length,
                        Adapter->VerifierExtension->CommonBufferPAs[i],
                        BlkAddr[i],
                        FALSE);
                }
            }

            Adapter->NonCachedExtension = NULL;
        }

        //
        // Free the arrays we allocated to manage the common buffer area.
        //
        
        ExFreePool(Adapter->VerifierExtension->CommonBufferVAs);
        Adapter->VerifierExtension->CommonBufferVAs = NULL;
        Adapter->VerifierExtension->CommonBufferPAs = NULL;
        Adapter->VerifierExtension->CommonBufferBlocks = 0;
        Adapter->SrbExtensionListHeader = NULL;
    }
}

PVOID
SpGetOriginalSrbExtVa(
    PADAPTER_EXTENSION Adapter,
    PVOID Va
    )
/*++

Routine Description:

    This function returns the original mapped virtual address of a common
    block if the supplied VA is for one of the common buffer blocks we've
    allocated.

Arguments:

    Adapter - the adapter device extension

    Va - virtual address of a common buffer block

Return Value:

    If the supplied VA is the address of one of the common buffer blocks,
    returns the original VA of the block.  Else, returns NULL.

--*/
{
    PVOID* BlkAddr = Adapter->VerifierExtension->CommonBufferVAs;
    PSP_VA_MAPPING_INFO MappingInfo;
    ULONG i;
    
    for (i = 0; i < Adapter->VerifierExtension->CommonBufferBlocks; i++) {
        MappingInfo = GET_VA_MAPPING_INFO(Adapter, *BlkAddr++);
        if (Va == MappingInfo->RemappedSrbExtVa || 
            Va == MappingInfo->OriginalSrbExtVa)
            return MappingInfo->OriginalSrbExtVa;
    }

    return NULL;
}

VOID
SpInsertSrbExtension(
    PADAPTER_EXTENSION Adapter,
    PCCHAR SrbExtension
    )
/*++

Routine Description:

    This routine inserts the supplied SRB extension back into the SRB extension
    list.  The VA of the supplied extension lies within one of our common buffer
    blocks and it may be a remapped VA.  If it is a remapped address, this
    routine invalidates the page(s) comprising the extension after it links the
    extension back into the list.

Arguments:

    Adapter      - Pointer to an adapter device extension.

    SrbExtension - Pointer to the beginning of an SRB extension within one of
                   our common buffer blocks.  May or may not be within a
                   remapped range.

--*/
{
    //
    // Round the srb extension pointer down to the beginning of the page
    // and link the block back into the list.  Note that we're careful
    // to point the list header at the original VA of the block.
    //

    SrbExtension = (PVOID)((ULONG_PTR)SrbExtension & ~(PAGE_SIZE - 1));
    *((PVOID *) SrbExtension) = Adapter->SrbExtensionListHeader;    
    Adapter->SrbExtensionListHeader = SpGetOriginalSrbExtVa(
                                          Adapter, 
                                          SrbExtension);
    
    //
    // If the original VA differs from the one supplied, the supplied
    // one is one of our remapped VAs.  In this case, we want to invalidate
    // the range so the system will bugcheck if anyone tries to access it.
    //
                    
    if (Adapter->SrbExtensionListHeader != SrbExtension) {
        PMDL Mdl = SpGetRemappedSrbExt(Adapter, Adapter->SrbExtensionListHeader);
        ASSERT(Mdl != NULL);
        MmProtectMdlSystemAddress(Mdl, PAGE_NOACCESS);

        //
        // Just because we remapped the SRB extension does not mean we
        // necessarily remapped the sense buffer.
        //

        Mdl = SpGetRemappedSenseBuffer(Adapter, Adapter->SrbExtensionListHeader);
        if (Mdl != NULL) {
            MmProtectMdlSystemAddress(Mdl, PAGE_NOACCESS);
        }
    }
}

#if DBG
ULONG SpVerbose = 0;
#endif

PVOID
SpPrepareSrbExtensionForUse(
    IN PADAPTER_EXTENSION Adapter,
    IN OUT PCCHAR *SrbExtension
    )
/*++

Routine Description:

    This function accepts a pointer to the beginning of one of the individual 
    common-buffer blocks allocated by the verifier for SRB extensions, sense 
    buffers, and non-cached extensions.  It calculates the beginning of the 
    SRB extension within the block and, if the block has been remapped, makes 
    the page(s) of the SRB extension read/write valid.

Arguments:

    Adapter      - Pointer to an adapter device extension.

    SrbExtension - Pointer to the beginning of a common-buffer block.

Return Value:

    If the common buffer block containing the SRB extension has been remapped, 
    returns the address of the beginning of the remapped srb extension, valid 
    for reading and writing.  

    If the block has not been remapped, returns NULL.

    Regardless of whether the block is remapped or not, the supplied pointer
    is fixed up to point to the beginning of the SRB extension within the
    original VA range.

--*/
{
    PCCHAR RemappedSrbExt = NULL;
    NTSTATUS Status;
    PMDL Mdl;
    ULONG srbExtensionSize = ROUND_UP_COUNT(Adapter->SrbExtensionSize, 8);

    //
    // If we've remapped the SRB extension, get the second mapping and make it
    // valid.  If we get the second mapping, but cannot make it valid, we just
    // use the original mapping.
    //

    Mdl = SpGetRemappedSrbExt(Adapter, *SrbExtension);
    if (Mdl != NULL) {
        Status = MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);
        if (NT_SUCCESS(Status)) {
            RemappedSrbExt = MmGetSystemAddressForMdlSafe(
                                 Mdl, 
                                 NormalPagePriority);

            //
            // Adjust the remapped srb extension pointer so the end of the 
            // buffer falls on a page boundary.
            //

            RemappedSrbExt += 
                ((Adapter->CommonBufferSize - 
                  (PAGE_SIZE * 2)) - srbExtensionSize);
        }
    }
    
    //
    // Adjust the original srb extension pointer so it also ends on a page 
    // boundary.
    //

    *SrbExtension += ((Adapter->CommonBufferSize - (PAGE_SIZE * 2)) - 
                      srbExtensionSize);
#if DBG
    if (SpVerbose == 1) {
        DebugPrint((0, "SpPrepareSrbExtensionForUse: SrbExt %p SrbExtSize %x\n",
                    *SrbExtension, srbExtensionSize));
    }
#endif
    return RemappedSrbExt;
}

PCCHAR
SpPrepareSenseBufferForUse(
    PADAPTER_EXTENSION Adapter,
    PCCHAR SrbExtension
    )
/*++

Routine Description:

    This function accepts a pointer to the beginning of an SRB extension
    within one of the individual common-buffer blocks allocated by the 
    verifier for SRB extensions, sense buffers, and non-cached extensions.
    It calculates the beginning of the sense buffer within the block and,
    if the block has been remapped, makes the page read/write valid.

    It is assumed that a sense buffer will never be larger than one page.

Arguments:

    Adapter      - Pointer to an adapter device extension.

    SrbExtension - Pointer to the beginning of the SRB extension within a 
                   common-buffer block.

Return Value:

    Returns the address of the beginning of a sense buffer valid for
    reading and writing.

--*/
{
    PVOID BeginningOfBlock;
    ULONG SenseDataSize;
    PCCHAR Base;
    NTSTATUS Status;
    PMDL Mdl;
    ULONG srbExtensionSize = (ULONG)ROUND_TO_PAGES(Adapter->SrbExtensionSize);

    //
    // Initialize the size of the sense buffer and the base of the sense buffer
    // within the originally allocated block.  The base of the sense buffer
    // immediately follows the srb extension and resides on a page boundary
    // within a common buffer block.
    //

    SenseDataSize = sizeof(SENSE_DATA) + Adapter->AdditionalSenseBytes;
    SenseDataSize = ROUND_UP_COUNT(SenseDataSize, 8);
    Base = SrbExtension + ROUND_UP_COUNT(Adapter->SrbExtensionSize, 8);

    //
    // Initialize a pointer to the beginning of the common block the sense 
    // buffer resides in.  This is needed in order to determine if the
    // sense buffer has been remapped.
    //

    BeginningOfBlock = 
        (PVOID)(((ULONG_PTR)SrbExtension + 
                 ROUND_UP_COUNT(Adapter->SrbExtensionSize, 8)) - 
                srbExtensionSize);

    //
    // If we've remapped the sense buffer, make the range valid and reset base
    // to point to the beginning of the range.
    //

    Mdl = SpGetRemappedSenseBuffer(Adapter, BeginningOfBlock);
    if (Mdl != NULL) {
        Status = MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);
        if (NT_SUCCESS(Status)) {
            Base = MmGetSystemAddressForMdlSafe(Mdl, NormalPagePriority);
            ASSERT(Base != NULL);
        }
    }
    
#if DBG
    if (SpVerbose == 1) {
        DebugPrint((0, "SpPrepareSenseBufferForUse: SrbExt %p Base %p BOB %p "
                    "SenseBuffer %p SrbExtSize %x\n",
                    SrbExtension,
                    Base,
                    BeginningOfBlock,
                    (Base + PAGE_SIZE - SenseDataSize),
                    srbExtensionSize));
    }
#endif
    
    //
    // Return a pointer into the block such that the sense buffer ends aligned
    // on a page boundary.
    //

    return (Base + PAGE_SIZE - SenseDataSize);
}

PVOID
SpGetInaccessiblePage(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This function returns a pointer to a page of memory that is not valid
    for reading or writing.  This page is a shared resource, used by all
    adapters that are actively verifying.  The page is hung off of the driver
    extension.  The page is faulted in as needed, so if we haven't initialized
    it yet, we try to do so here in an interlocked fashion.

Arguments:

    Adapter - Pointer to an adapter device extension.

Return Value:

    Either returns a pointer to an invalid page of VAs or NULL if the page
    could not be allocated.

--*/
{
    PSCSIPORT_DRIVER_EXTENSION DriverExtension;
    PVOID UnusedPage;
    PVOID InvalidPage;
    PMDL UnusedPageMdl;
    PVOID CurrentValue;

    //
    // Retrieve the driver extension.  We must have it to proceed.
    //

    DriverExtension = IoGetDriverObjectExtension(
                          Adapter->DeviceObject->DriverObject,
                          ScsiPortInitialize);
    if (DriverExtension == NULL) {
        return NULL;
    }

    //
    // If the invalid page is not yet initialized, go ahead and try to 
    // initialize it now.
    //

    if (DriverExtension->InvalidPage == NULL) {

        //
        // Allocate a page of memory.
        //

        UnusedPage = SpAllocatePool(NonPagedPool,
                                    PAGE_SIZE,
                                    SCSIPORT_TAG_VERIFIER,
                                    Adapter->DeviceObject->DriverObject);

        if (UnusedPage != NULL) {
            
            //
            // Zero the page and remap it.  The remapped range will be inaccessible.
            // If the remapping fails, just free the page; we just won't have an
            // inaccessible page to work with.
            //
            
            RtlZeroMemory(UnusedPage, PAGE_SIZE);
            InvalidPage = SpRemapBlock(UnusedPage,
                                       PAGE_SIZE,
                                       &UnusedPageMdl);

            if (InvalidPage != NULL) {

                //
                // If nobody else has beaten us to it, init the pointer to the
                // invalid page in the driver extension.  If somebody has already
                // done it, just free the page we created.  This page is freed
                // when scsiport is unloaded.
                //

                CurrentValue = InterlockedCompareExchangePointer(
                                   &DriverExtension->InvalidPage,
                                   InvalidPage,
                                   NULL);
                if (CurrentValue == NULL) {

                    DriverExtension->UnusedPage = UnusedPage;
                    DriverExtension->UnusedPageMdl = UnusedPageMdl;
    
                } else {

                    MmProtectMdlSystemAddress(UnusedPageMdl, PAGE_READWRITE);
                    UnusedPageMdl->MdlFlags &= ~MDL_MAPPED_TO_SYSTEM_VA;
                    IoFreeMdl(UnusedPageMdl);
                    ExFreePool(UnusedPage);

                }

            } else {

                //
                // Couldn't make the page inaccessible, just free it.
                //

                ExFreePool(UnusedPage);
            }
        }
    }

    return DriverExtension->InvalidPage;
}

BOOLEAN
SpCheckForActiveRequests(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This function walks through all of the logical units connected to the
    supplied adapter looking for any outstanding requests.  If it finds
    any, it returns TRUE immediately.

Arguments:

    Adapter - Pointer to an adapter device extension.

Return Value:

    TRUE  - If an outstanding requests is found on one of the logical units
            connected to the adapter.

    FALSE - If no outstanding requests on the adapter.

--*/
{
    PLOGICAL_UNIT_EXTENSION LogicalUnit;
    PLOGICAL_UNIT_BIN Bin;
    ULONG BinNumber;

    //
    // Iterate through each LU bin.  For each bin, if there are any LUs, iterate
    // through each of those looking for an oustanding request.  If we find one
    // terminate the search and return TRUE.
    //

    for (BinNumber = 0; BinNumber < NUMBER_LOGICAL_UNIT_BINS; BinNumber++) {

        Bin = &Adapter->LogicalUnitList[BinNumber];

        LogicalUnit = Bin->List;
        while (LogicalUnit != NULL) {

            if (LogicalUnit->AbortSrb != NULL &&
                LogicalUnit->AbortSrb->SrbFlags & SRB_FLAGS_IS_ACTIVE) {
                    return TRUE;
            } else if (LogicalUnit->CurrentUntaggedRequest != NULL &&
                       LogicalUnit->CurrentUntaggedRequest->CurrentSrb->SrbFlags & SRB_FLAGS_IS_ACTIVE) {
                return TRUE;
            } else if (LogicalUnit->RequestList.Flink != &LogicalUnit->RequestList) {
                PSRB_DATA srbData;
                PVOID nextEntry = LogicalUnit->RequestList.Flink;
                while (nextEntry != &LogicalUnit->RequestList) {
                    srbData = CONTAINING_RECORD(nextEntry, SRB_DATA, RequestList);
                    if (srbData->CurrentSrb->SrbFlags & SRB_FLAGS_IS_ACTIVE) {
                        return TRUE;
                    }
                    nextEntry = srbData->RequestList.Flink;
                }    
            }

            LogicalUnit = LogicalUnit->NextLogicalUnit;
        }
    }

    return FALSE;
}

VOID
SpEnsureAllRequestsAreComplete(
    PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine bugchecks the system if there are any outstanding requests
    on the supplied adapter.  If the SP_DONT_CHK_REQUESTS_ON_RESET bit is
    set on the adapter's verification level, don't do the check.

Arguments:

    Adapter - Points to an adapter device extension.

--*/
{
    //
    // If there are any outstanding requests on any of the LUs connected to the
    // adapter, bugcheck the system.  Note that we only do this check if it
    // has not been turned off.
    //

    if (VRFY_DO_CHECK(Adapter, SP_DONT_CHK_REQUESTS_ON_RESET)) {
        BOOLEAN ActiveRequests = SpCheckForActiveRequests(Adapter);
        if (ActiveRequests == TRUE) {
            KeBugCheckEx(SCSI_VERIFIER_DETECTED_VIOLATION,
                         SCSIPORT_VERIFIER_RQSTS_NOT_COMPLETE,
                         (ULONG_PTR)Adapter,
                         (ULONG_PTR)Adapter->HwDeviceExtension,
                         0);
        }            
    }
}

VOID
SpDoVerifierInit(
    IN PADAPTER_EXTENSION Adapter,
    IN PHW_INITIALIZATION_DATA HwInitializationData
    )
/*++

Routine Description:

    This routine allocates and initializes a verifier extension for the 
    supplied adapter.  A per-adapter verification level is read from the
    registry before allocating the extension.  A verfication level of -1
    means "don't verify this adapter".  If we do allocate the extension,
    we also lock the verifier code section into memory.

Arguments:

    Adapter              - The adapter device extension.

    HwInitializationData - A pointer to the HW_INITIALIZATION_DATA for
                           the adapter.

--*/
{        
    ULONG VerifyLevel;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Read adapter's verification level from the registry.  If the adapter is
    // configured for no verification, just return.
    //

    VerifyLevel = SpGetAdapterVerifyLevel(Adapter);
    if (VerifyLevel == SP_VRFY_NONE) {
        return;
    }

    //
    // Go ahead and try to allocate the extension.
    //

    Adapter->VerifierExtension = 
       SpAllocatePool(NonPagedPool,
                      sizeof(VERIFIER_EXTENSION),
                      SCSIPORT_TAG_VERIFIER,
                      Adapter->DeviceObject->DriverObject);
    
    if (Adapter->VerifierExtension != NULL) {
        
        //
        // Zero the extension.
        //

        RtlZeroMemory(Adapter->VerifierExtension, sizeof(VERIFIER_EXTENSION));
        
        //
        // Lock the pageable verifier code section into memory.
        //

#ifdef ALLOC_PRAGMA
        if (VerifierCodeSectionHandle == NULL) {
            VerifierCodeSectionHandle = MmLockPagableCodeSection(SpHwFindAdapterVrfy);
        } else {
            MmLockPagableSectionByHandle(VerifierCodeSectionHandle);
        }
#endif

        //
        // Set the verification level for this adapter.  This value is the sum
        // of the global verifier level and the per-adapter value we read above.
        //
            
        Adapter->VerifierExtension->VrfyLevel = (VerifyLevel | SpVrfyLevel);
            
        //
        // Initialize function pointers in the verifier extension to
        // to point to the real miniport routines.
        //
            
        Adapter->VerifierExtension->RealHwFindAdapter = HwInitializationData->HwFindAdapter;
        Adapter->VerifierExtension->RealHwInitialize = HwInitializationData->HwInitialize;
        Adapter->VerifierExtension->RealHwStartIo = HwInitializationData->HwStartIo;
        Adapter->VerifierExtension->RealHwInterrupt = HwInitializationData->HwInterrupt;
        Adapter->VerifierExtension->RealHwResetBus = HwInitializationData->HwResetBus;
        Adapter->VerifierExtension->RealHwDmaStarted = HwInitializationData->HwDmaStarted;
        Adapter->VerifierExtension->RealHwAdapterControl = HwInitializationData->HwAdapterControl;
            
        //
        // Redirect the miniport routines to verifier routines.
        //
            
        Adapter->HwFindAdapter = SpHwFindAdapterVrfy;
        Adapter->HwInitialize = SpHwInitializeVrfy;
        Adapter->HwStartIo = SpHwStartIoVrfy;
        Adapter->HwInterrupt = SpHwInterruptVrfy;
        Adapter->HwResetBus = SpHwResetBusVrfy;
        Adapter->HwDmaStarted = SpHwDmaStartedVrfy;
        Adapter->HwAdapterControl = SpHwAdapterControlVrfy;

        //
        // Get a pointer to an invalid page of memory so we can catch
        // miniports trying to touch memory when they shouldn't be.
        //

        Adapter->VerifierExtension->InvalidPage = SpGetInaccessiblePage(Adapter);
    }
}

VOID
SpDoVerifierCleanup(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This routine frees the supplied adapter's verifier extension and releases
    its reference on the verifier code section.

    This routine gets called as part of the adapter resource cleanup.  When
    called, all the actual resources allocated for the verifier have already
    been cleaned up.

Arguments:

    Adapter - the adapter device extension

--*/
{
    //
    // We should never arrive here if the scsiport verifier is not active.
    // And when we get here we should have freed all the resources hanging
    // off the extension.
    //

    ASSERT(Adapter->VerifierExtension != NULL);
    ASSERT(Adapter->VerifierExtension->CommonBufferVAs == NULL);
    ASSERT(Adapter->VerifierExtension->CommonBufferPAs == NULL);
    ASSERT(Adapter->VerifierExtension->CommonBufferBlocks == 0);

    //
    // Free and NULL the verifier extension for this adapter.
    //

    ExFreePool(Adapter->VerifierExtension);
    Adapter->VerifierExtension = NULL;

    //
    // Release our reference on the verifier code section.
    //

#ifdef ALLOC_PRAGMA
    ASSERT(VerifierCodeSectionHandle != NULL);
    MmUnlockPagableImageSection(VerifierCodeSectionHandle);
#endif
}

ULONG
SpGetAdapterVerifyLevel(
    IN PADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    This function returns the verification level for the supplied adapter.    

Arguments:

    Adapter - Pointer to an adapter device extension.

Return Value:

    The supplied adapter's verification level.

--*/
{
    PSCSIPORT_DRIVER_EXTENSION DrvExt;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE ParametersKey;
    HANDLE ServiceKey;
    ULONG VerifyLevel = 0;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // We need the driver extension to get the adapter's registry path.  We use
    // this to look up the adapter settings in the registry.  If we cannot get
    // the driver extension, we have to abort.
    //

    DrvExt = IoGetDriverObjectExtension(
        Adapter->DeviceObject->DriverObject,
        ScsiPortInitialize);
    if (DrvExt == NULL) {
        return 0;
    }

    //
    // Try to open the adapter's registry key.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DrvExt->RegistryPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = ZwOpenKey(&ServiceKey, KEY_READ, &ObjectAttributes);
    if (NT_SUCCESS(Status)) {

        //
        // Try to open the adapter's parameters key.
        //

        RtlInitUnicodeString(&UnicodeString, L"Parameters");
        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            ServiceKey,
            NULL);

        Status = ZwOpenKey(&ParametersKey, KEY_READ, &ObjectAttributes);
        if (NT_SUCCESS(Status)) {

            //
            // Try to read the verification level value under the adapter's
            // parameters key.
            //

            RtlInitUnicodeString(&UnicodeString, L"VerifyLevel");
            SpReadNumericValue(
                ParametersKey,
                NULL,
                &UnicodeString,
                &VerifyLevel);

            ZwClose(ParametersKey);
        }
        
        ZwClose(ServiceKey);
    }

    return VerifyLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sffdisk\debug.c ===
/*++      

Copyright (c) 1999 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module provides debugging support.

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Revision History:


--*/


#include "pch.h"

#if DBG

ULONG SffDiskDebugLevel = SFFDISKFAIL | SFFDISKWARN;
//  SFFDISKINFO | SFFDISKSHOW;
//  SFFDISKIOCTL;

VOID
SffDiskDebugPrint(
                ULONG  DebugMask,
                PCCHAR DebugMessage,
                ...
                )

/*++

Routine Description:

    Debug print for SFFDISK.

Arguments:

    Check the mask value to see if the debug message is requested.

Return Value:

    None

--*/

{
    va_list ap;
    char    buffer[256];

    va_start(ap, DebugMessage);

    if (DebugMask & SffDiskDebugLevel) {
       vsprintf(buffer, DebugMessage, ap);
       DbgPrint(buffer);
    }

    va_end(ap);
} 




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiprnt\printpnp.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    prntpnp.c

Abstract:

    printer class driver defines and functions decl.

Author:

    George Chrysanthakopoulos (georgioc)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ntddk.h"
#include "scsi.h"
#include "classpnp.h"

#ifndef _PRINTPNP_
#define _PRINTPNP_

#if DBG

ULONG PrintDebugLevel;

#define DEBUGPRINT1(_x_)        {if (PrintDebugLevel >= 1) \
                                KdPrint (_x_);}

#define DEBUGPRINT2(_x_)        {if (PrintDebugLevel >= 2) \
                                KdPrint (_x_);}

#define DEBUGPRINT3(_x_)        {if (PrintDebugLevel >= 3) \
                                KdPrint (_x_);}
#define DEBUGPRINT4(_x_)        {if (PrintDebugLevel >= 4) \
                                KdPrint (_x_);}

#else

#define DEBUGPRINT1(_x_)
#define DEBUGPRINT2(_x_)
#define DEBUGPRINT3(_x_)
#define DEBUGPRINT4(_x_)

#endif

NTSTATUS
PrinterAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
PrinterEnumerateDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
PrinterQueryId(
    IN PDEVICE_OBJECT Pdo,
    IN BUS_QUERY_ID_TYPE IdType,
    IN PUNICODE_STRING UnicodeIdString
    );

NTSTATUS
PrinterCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
PrinterGetId
(
    IN PUCHAR DeviceIdString,
    IN ULONG Type,
    OUT PUCHAR resultString,
    OUT PUCHAR descriptionString
);

NTSTATUS
PrinterStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
PrinterInitPdo(
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
PrinterInitFdo(
    IN PDEVICE_OBJECT Fdo
    );



VOID
PrinterRegisterPort(
    IN PPHYSICAL_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
PrinterStartPdo(
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
PrinterQueryPnpCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_CAPABILITIES Capabilities
    );


NTSTATUS
CreatePrinterDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PULONG         DeviceCount
    );

NTSTATUS
PrinterDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PrinterStartDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
PrinterCreatePdo(
    IN PDEVICE_OBJECT Fdo,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
PrinterRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
PrinterSystemControl(
    PDEVICE_OBJECT Fdo,
    PIRP Irp
    );

NTSTATUS
PrinterPowerControl(
    PDEVICE_OBJECT Fdo,
    PIRP Irp
    );

NTSTATUS
PrinterOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PrinterReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PrinterIssueCommand(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR Scsiop
    );

VOID
SplitRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG MaximumBytes
    );

NTSTATUS
PrinterWriteComplete(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp,
    IN PVOID            Context
    );

VOID
PrinterRetryRequest(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                Irp,
    PSCSI_REQUEST_BLOCK Srb
    );

VOID
PrinterWriteTimeoutDpc(
    IN PKDPC                    Dpc,
    IN PVOID                    Context,
    IN PVOID                    SystemArgument1,
    IN PVOID                    SystemArgument2
    );

VOID
PrinterResubmitWrite(
    PDEVICE_OBJECT  DeviceObject,
    PVOID           Context
    );



#define DEVICE_EXTENSION_SIZE       sizeof(FUNCTIONAL_DEVICE_EXTENSION) + sizeof(PRINTER_DATA)
#define PRINTER_TIMEOUT             100
#define PRINTER_SRB_LIST_SIZE       4
#define PRINTER_TAG                 'tnrp'
#define BLOCKED_WRITE_TIMEOUT       3       // seconds

#define PORT_NUM_VALUE_NAME L"Port Number"
#define BASE_PORT_NAME_VALUE_NAME L"Base Name"
#define BASE_PORT_DESCRIPTION L"IEEE 1394 Printer Port"
#define BASE_PORT_DESCRIPTION_VALUE_NAME L"Port Description"
#define RECYCLABLE_VALUE_NAME L"Recyclable"


#define BASE_1394_PORT_NAME L"1394_"
#define BASE_SCSI_PORT_NAME L"SCSI"

#define MAX_PRINT_XFER 0x00ffffff
#define MAX_NUM_PRINTERS 20

typedef struct _PRINTER_DATA {

    ULONG          DeviceFlags;
    KSPIN_LOCK     SplitRequestSpinLock;
    UNICODE_STRING UnicodeLinkName;
    UNICODE_STRING UnicodeDeviceString;
    UCHAR          DeviceName[256];
    PUCHAR         DeviceIdString;
    ULONG          PortNumber;
    ULONG          LptNumber;

    //
    // See comments in PrinterWriteComplete() for a description
    // of the following fields
    //

    PIO_COMPLETION_ROUTINE  WriteCompletionRoutine;
    KTIMER                  Timer;
    LARGE_INTEGER           DueTime;
    KDPC                    TimerDpc;

    /*
     *  Queued write irp and associated srb.
     */
    PIRP                    WriteIrp;
    PSCSI_REQUEST_BLOCK WriteSrb;
    
    NTSTATUS                LastWriteStatus;

} PRINTER_DATA, *PPRINTER_DATA;


static const GUID PNPPRINT_GUID = 
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };


//
// Support for the following ioctl allows SCSIPRNT to behave like the
// USB, etc printing stacks, to keep USBMON.DLL happy
//
// From ntos\dd\usbprint\ioctl.h & windows\spooler\monitors\dynamon\ioctl.h
//

#define USBPRINT_IOCTL_INDEX 0x0000

#define IOCTL_USBPRINT_GET_LPT_STATUS CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                               USBPRINT_IOCTL_INDEX+12, \
                                               METHOD_BUFFERED,         \
                                               FILE_ANY_ACCESS)

//
// The following ioctl allows a smart client / port monitor to en/disable
// the blocking write behavior on 1394 printers
//

#define SCSIPRNT_IOCTL_INDEX 0x123

#define IOCTL_SCSIPRNT_1394_BLOCKING_WRITE  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                     SCSIPRNT_IOCTL_INDEX, \
                                                     METHOD_BUFFERED,      \
                                                     FILE_ANY_ACCESS)


BOOLEAN SetWriteIrp(PPRINTER_DATA PrinterData, PIRP WriteIrp, PSCSI_REQUEST_BLOCK Srb);
PIRP GetWriteIrp(PPRINTER_DATA PrinterData, PSCSI_REQUEST_BLOCK *Srb);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiprnt\print.c ===
/*++

Copyright (C) 1992-9  Microsoft Corporation

Module Name:

    print.c

Abstract:

    The printer class driver tranlates IRPs to SRBs with embedded CDBs
    and sends them to its devices through the port driver.

Author:

    Mike Glass (mglass)

Environment:

    kernel mode only

Notes:

Revision History:

    georgioc - Made into a pnp class driver independent of the underlying storage bus
               using the new storage/classpnp

    dankn, 22-Jul-99 : Added ability to block & resubmit failed writes for
                       1394 printers to behave more like other print stacks
                       (i.e. USB) and therefore keep USBMON.DLL (the Win2k
                       port monitor) happy.  USBMON does not deal well
                       with failed writes.

--*/

#include "printpnp.h"
#include "ntddser.h"



NTSTATUS
PrinterOpenClose(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to establish a connection to the printer
    class driver. It does no more than return STATUS_SUCCESS.

Arguments:

    DeviceObject - Device object for a printer.
    Irp - Open or Close request packet

Return Value:

    NT Status - STATUS_SUCCESS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Set status in Irp.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // forward irp.
    //

    ClassReleaseRemoveLock (Fdo, Irp);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    return IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, Irp);

} // end PrinterOpenClose()


NTSTATUS
BuildPrintRequest(
        PDEVICE_OBJECT Fdo,
        PIRP Irp
        )

/*++

Routine Description:

    Build SRB and CDB requests to scsi printer.

Arguments:

    DeviceObject - Device object representing this printer device.
    Irp - System IO request packet.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension = Fdo->DeviceExtension;
    PIO_COMPLETION_ROUTINE completionRoutine;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    ULONG transferLength;

    //
    // Allocate Srb from nonpaged pool.
    // This call must succeed.
    //

    srb = ExAllocatePool(NonPagedPool, SCSI_REQUEST_BLOCK_SIZE);
    if (srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb->SrbFlags = 0;

    //
    // Write length to SRB.
    //

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set up IRP Address.
    //

    srb->OriginalRequest = Irp;

    //
    // Set up target id and logical unit number.
    //

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    srb->DataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);

    //
    // Save byte count of transfer in SRB Extension.
    //

    srb->DataTransferLength = currentIrpStack->Parameters.Write.Length;

    //
    // Transfer length should never be greater than MAX_PRINT_XFER
    //

    ASSERT(srb->DataTransferLength <= MAX_PRINT_XFER);

    //
    // Initialize the queue actions field.
    //

    srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;

    //
    // Queue sort key is not used.
    //

    srb->QueueSortKey = 0;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    srb->SenseInfoBuffer = deviceExtension->SenseData;

    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Set timeout value in seconds.
    //

    srb->TimeOutValue = deviceExtension->TimeOutValue;

    //
    // Zero statuses.
    //

    srb->SrbStatus = srb->ScsiStatus = 0;

    srb->NextSrb = 0;

    //
    // Get number of bytes to transfer.
    //

    transferLength = currentIrpStack->Parameters.Write.Length;

    //
    // Get pointer to CDB in SRB.
    //

    cdb = (PCDB) srb->Cdb;

    //
    // Init 10-byte READ CDB's for reads (per scanner device READ spec
    // in SCSI-2), and 6-byte PRINT CDB's for writes
    //

    if (currentIrpStack->MajorFunction == IRP_MJ_READ) {

        srb->CdbLength = 10;
        srb->SrbFlags  = SRB_FLAGS_DATA_IN;

        RtlZeroMemory (cdb, 10);

        cdb->CDB10.OperationCode = SCSIOP_READ;

        //
        // Move little endian values into CDB in big endian format.
        //

        cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE) &transferLength)->Byte0;
        cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE) &transferLength)->Byte1;
        cdb->CDB10.Reserved2         = ((PFOUR_BYTE) &transferLength)->Byte2;

        //
        // For read's we always use the ClassIoComplete completion routine
        //

        completionRoutine = ClassIoComplete;

    } else {

        srb->CdbLength = 6;
        srb->SrbFlags  = SRB_FLAGS_DATA_OUT;

        cdb->PRINT.OperationCode = SCSIOP_PRINT;
        cdb->PRINT.Reserved = 0;
        cdb->PRINT.LogicalUnitNumber = 0;

        //
        // Move little endian values into CDB in big endian format.
        //

        cdb->PRINT.TransferLength[2] = ((PFOUR_BYTE) &transferLength)->Byte0;
        cdb->PRINT.TransferLength[1] = ((PFOUR_BYTE) &transferLength)->Byte1;
        cdb->PRINT.TransferLength[0] = ((PFOUR_BYTE) &transferLength)->Byte2;

        cdb->PRINT.Control = 0;

        //
        // Set the appropriate write/print completion routine
        //

        completionRoutine = ((PPRINTER_DATA) deviceExtension->
            CommonExtension.DriverData)->WriteCompletionRoutine;
    }

    //
    // Or in the default flags from the device object.
    //

    srb->SrbFlags |= deviceExtension->SrbFlags;

    //
    // Set up major SCSI function.
    //

    nextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    nextIrpStack->Parameters.Scsi.Srb = srb;

    //
    // Save retry count in current IRP stack.
    //

    currentIrpStack->Parameters.Others.Argument4 = (PVOID)MAXIMUM_RETRIES;

    //
    // Set up IoCompletion routine address.
    //

    IoSetCompletionRoutine(Irp, completionRoutine, srb, TRUE, TRUE, TRUE);

    return STATUS_SUCCESS;

} // end BuildPrintRequest()


NTSTATUS
PrinterReadWrite(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the entry called by the I/O system for print requests.
    It builds the SRB and sends it to the port driver.

Arguments:

    DeviceObject - the system object for the device.
    Irp - IRP involved.

Return Value:

    NT Status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension = Fdo->DeviceExtension;

    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG transferByteCount = currentIrpStack->Parameters.Write.Length;
    ULONG maximumTransferLength;
    ULONG transferPages;
    NTSTATUS Status;

    DEBUGPRINT3(("PrinterReadWrite: Enter routine\n"));


    if (deviceExtension->AdapterDescriptor == NULL) {

        //
        // device removed..
        //

        DEBUGPRINT3(("PrinterReadWrite: Device removed(!!)\n"));

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        Irp->IoStatus.Information = 0;

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    maximumTransferLength = deviceExtension->AdapterDescriptor->MaximumTransferLength;


    //
    // Calculate number of pages in this transfer.
    //

    transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                        MmGetMdlVirtualAddress(Irp->MdlAddress),
                        currentIrpStack->Parameters.Write.Length);

    //
    // Check if hardware maximum transfer length is larger than SCSI
    // print command can handle.  If so, lower the maximum allowed to
    // the SCSI print maximum.
    //

    if (maximumTransferLength > MAX_PRINT_XFER)
        maximumTransferLength = MAX_PRINT_XFER;

    //
    // Check if request length is greater than the maximum number of
    // bytes that the hardware can transfer.
    //

    if (currentIrpStack->Parameters.Write.Length > maximumTransferLength ||
        transferPages > deviceExtension->AdapterDescriptor->MaximumPhysicalPages) {

         transferPages =
            deviceExtension->AdapterDescriptor->MaximumPhysicalPages - 1;

         if (maximumTransferLength > transferPages << PAGE_SHIFT ) {
             maximumTransferLength = transferPages << PAGE_SHIFT;
         }

        //
        // Check that maximum transfer size is not zero.
        //

        if (maximumTransferLength == 0) {
            maximumTransferLength = PAGE_SIZE;
        }

        //
        // Mark IRP with status pending.
        //

        IoMarkIrpPending(Irp);

        //
        // Request greater than port driver maximum.
        // Break up into smaller routines.
        //

        SplitRequest(Fdo,
                     Irp,
                     maximumTransferLength);

        return STATUS_PENDING;
    }

    //
    // Build SRB and CDB for this IRP.
    //

    Status = BuildPrintRequest(Fdo, Irp);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Return the results of the call to the port driver.
    //

    return IoCallDriver(deviceExtension->CommonExtension.LowerDeviceObject, Irp);

} // end ScsiPrinterWrite()


NTSTATUS
PrinterDeviceControl(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the NT device control handler for Printers.

Arguments:

    DeviceObject - for this Printer

    Irp - IO Request packet

Return Value:

    NTSTATUS

--*/

{
    PVOID                        buffer = Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                     status;
    PIO_STACK_LOCATION           irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension = Fdo->DeviceExtension;



    DEBUGPRINT2 (("PrinterDeviceControl: enter, Fdo=x%p, Ioctl=", Fdo));

    //
    // Zero CDB in SRB on stack.
    //

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_SERIAL_SET_TIMEOUTS: {

            PSERIAL_TIMEOUTS newTimeouts = ((PSERIAL_TIMEOUTS) buffer);


            DEBUGPRINT2 (("SET_TIMEOUTS\n"));

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_TIMEOUTS)) {

                status = STATUS_BUFFER_TOO_SMALL;

            } else if (newTimeouts->WriteTotalTimeoutConstant < 2000) {

                status = STATUS_INVALID_PARAMETER;

            } else {

                deviceExtension->TimeOutValue =
                    newTimeouts->WriteTotalTimeoutConstant / 1000;
                status = STATUS_SUCCESS;
            }

            break;
        }

        case IOCTL_SERIAL_GET_TIMEOUTS:

            DEBUGPRINT2(("GET_TIMEOUTS\n"));

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_TIMEOUTS)) {

                status = STATUS_BUFFER_TOO_SMALL;

            } else {

                RtlZeroMemory (buffer, sizeof (SERIAL_TIMEOUTS));

                Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

                ((PSERIAL_TIMEOUTS) buffer)->WriteTotalTimeoutConstant =
                    deviceExtension->TimeOutValue * 1000;

                status = STATUS_SUCCESS;
            }

            break;

        case IOCTL_USBPRINT_GET_LPT_STATUS:

            //
            // We support this ioctl for USBMON.DLL's sake. Other print
            // stacks will block failed writes, and eventually USBMON
            // will send them this ioctl to see if the printer is out
            // of paper, which will be indicated by the state of the
            // 0x20 bit in the returned UCHAR value.
            //

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(UCHAR)) {

                status = STATUS_BUFFER_TOO_SMALL;

            } else if (deviceExtension->AdapterDescriptor->BusType !=
                       BusType1394) {

                status = STATUS_INVALID_PARAMETER;

            } else {

                PPRINTER_DATA   printerData;


                printerData = (PPRINTER_DATA)
                    deviceExtension->CommonExtension.DriverData;

                Irp->IoStatus.Information = sizeof (UCHAR);

                *((UCHAR *) buffer) = (printerData->LastWriteStatus ==
                    STATUS_NO_MEDIA_IN_DEVICE ? 0x20 : 0);

                DEBUGPRINT2((
                    "GET_LPT_STATUS (=x%x)\n",
                    (ULONG) *((UCHAR *) buffer)
                    ));

                status = STATUS_SUCCESS;
            }

            break;

        case IOCTL_SCSIPRNT_1394_BLOCKING_WRITE:

            //
            // This ioctl en/disables the blocking write functionality
            // (for failed writes) on 1394 devices.  By default we
            // block writes which fail on 1394 devices (until the write
            // finally succeeds or is cancelled), but a smart port
            // monitor could send this ioctl down to disable blocking
            // so it would get write error notifications asap.
            //

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(UCHAR)) {

                status = STATUS_BUFFER_TOO_SMALL;

            } else if (deviceExtension->AdapterDescriptor->BusType !=
                       BusType1394) {

                status = STATUS_INVALID_PARAMETER;

            } else {

                PPRINTER_DATA   printerData;


                printerData = (PPRINTER_DATA)
                    deviceExtension->CommonExtension.DriverData;

                printerData->WriteCompletionRoutine = (*((UCHAR *) buffer) ?
                    PrinterWriteComplete : ClassIoComplete);

                status = STATUS_SUCCESS;
            }

            break;

        default:

            //
            // Pass the request to the common device control routine.
            //

            DEBUGPRINT2((
                "x%x\n",
                irpStack->Parameters.DeviceIoControl.IoControlCode
                ));

            return(ClassDeviceControl(Fdo, Irp));

            break;

    } // end switch()

    //
    // Update IRP with completion status.
    //

    Irp->IoStatus.Status = status;

    //
    // Complete the request.
    //

    IoCompleteRequest(Irp, IO_DISK_INCREMENT);

    //
    // Release the remove lock (which ClassDeviceControl does)
    //

    ClassReleaseRemoveLock(Fdo, Irp);

    DEBUGPRINT2(( "PrinterDeviceControl: Status is %lx\n", status));
    return status;

} // end ScsiPrinterDeviceControl()



VOID
SplitRequest(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN ULONG MaximumBytes
    )

/*++

Routine Description:

    Break request into smaller requests.  Each new request will be the
    maximum transfer size that the port driver can handle or if it
    is the final request, it may be the residual size.

    The number of IRPs required to process this request is written in the
    current stack of the original IRP. Then as each new IRP completes
    the count in the original IRP is decremented. When the count goes to
    zero, the original IRP is completed.

Arguments:

    DeviceObject - Pointer to the class device object to be addressed.

    Irp - Pointer to Irp the orginal request.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension = Fdo->DeviceExtension;

    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    ULONG transferByteCount = currentIrpStack->Parameters.Read.Length;
    LARGE_INTEGER startingOffset = currentIrpStack->Parameters.Read.ByteOffset;
    PVOID dataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);
    ULONG dataLength = MaximumBytes;
    ULONG irpCount = (transferByteCount + MaximumBytes - 1) / MaximumBytes;
    PSCSI_REQUEST_BLOCK srb;
    ULONG i;
    NTSTATUS Status;

    DEBUGPRINT2(( "SplitRequest: Requires %d IRPs\n", irpCount));
    DEBUGPRINT2(( "SplitRequest: Original IRP %p\n", Irp));

    //
    // If all partial transfers complete successfully then the status and
    // bytes transferred are already set up. Failing a partial-transfer IRP
    // will set status to error and bytes transferred to 0 during
    // IoCompletion. Setting bytes transferred to 0 if an IRP fails allows
    // asynchronous partial transfers. This is an optimization for the
    // successful case.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = transferByteCount;

    //
    // Save number of IRPs to complete count on current stack
    // of original IRP.
    //

    nextIrpStack->Parameters.Others.Argument1 = ULongToPtr( irpCount );

    for (i = 0; i < irpCount; i++) {

        PIRP newIrp;
        PIO_STACK_LOCATION newIrpStack;

        //
        // Allocate new IRP.
        //

        newIrp = IoAllocateIrp(Fdo->StackSize, FALSE);

        if (newIrp == NULL) {

            DEBUGPRINT1(("SplitRequest: Can't allocate Irp\n"));

            //
            // If an Irp can't be allocated then the orginal request cannot
            // be executed.  If this is the first request then just fail the
            // orginal request; otherwise just return.  When the pending
            // requests complete, they will complete the original request.
            // In either case set the IRP status to failure.
            //

            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;

            if (i == 0) {

                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }

            return;
        }

        DEBUGPRINT2(( "SplitRequest: New IRP %p\n", newIrp));

        //
        // Write MDL address to new IRP. In the port driver the SRB data
        // buffer field is used as an offset into the MDL, so the same MDL
        // can be used for each partial transfer. This saves having to build
        // a new MDL for each partial transfer.
        //

        newIrp->MdlAddress = Irp->MdlAddress;

        //
        // At this point there is no current stack. IoSetNextIrpStackLocation
        // will make the first stack location the current stack so that the
        // SRB address can be written there.
        //

        IoSetNextIrpStackLocation(newIrp);
        newIrpStack = IoGetCurrentIrpStackLocation(newIrp);

        newIrpStack->MajorFunction = currentIrpStack->MajorFunction;
        newIrpStack->Parameters.Read.Length = dataLength;
        newIrpStack->Parameters.Read.ByteOffset = startingOffset;
        newIrpStack->DeviceObject = Fdo;

        //
        // Build SRB and CDB.
        //

        Status = BuildPrintRequest(Fdo, newIrp);
        if (!NT_SUCCESS (Status)) {
            IoFreeIrp (newIrp);

            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;

            if (i == 0) {

                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }

            return;
        }

        //
        // Adjust SRB for this partial transfer.
        //

        newIrpStack = IoGetNextIrpStackLocation(newIrp);

        srb = newIrpStack->Parameters.Others.Argument1;
        srb->DataBuffer = dataBuffer;

        //
        // Write original IRP address to new IRP.
        //

        newIrp->AssociatedIrp.MasterIrp = Irp;

        //
        // Set the completion routine to ScsiClassIoCompleteAssociated.
        //

        IoSetCompletionRoutine(newIrp,
                               ClassIoCompleteAssociated,
                               srb,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Call port driver with new request.
        //

        IoCallDriver(deviceExtension->CommonExtension.LowerDeviceObject, newIrp);

        //
        // Set up for next request.
        //

        dataBuffer = (PCHAR)dataBuffer + MaximumBytes;

        transferByteCount -= MaximumBytes;

        if (transferByteCount > MaximumBytes) {

            dataLength = MaximumBytes;

        } else {

            dataLength = transferByteCount;
        }

        //
        // Adjust disk byte offset.
        //

        startingOffset.QuadPart = startingOffset.QuadPart + MaximumBytes;
    }

    return;

} // end SplitRequest()



NTSTATUS
PrinterWriteComplete(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp,
    IN PVOID            Context
    )

/*++

Routine Description:

    Ideally we should be should be able to use ClassIoComplete for
    all write completion notifications, but alas...

    (Code borrowed from classpnp!ClassIoComplete)

    This is the special, 1394 bus-specific write completion routine
    required to keep USBMON.DLL happy in the case of failed write
    requests.  The other stacks that USBMON talks to all pend
    unsuccessful writes forever, rather than simply completing them
    with an error.  When a write blocks for a long time USBMON will
    issue a sideband ioctl, namely IOCTL_USBPRINT_GET_LPT_STATUS,
    to determine if the printer is out of paper or not.  Eventually
    USBMON may cancel a blocked write.  However, it simply doesn't
    expect writes to just fail, so we have to fake out the behavior
    of the other stacks to keep it happy.  We'll retry blocked
    writes every so often, & mark the irp as cancellable in between
    retries.

    At least USBMON will only send down one 10k (or so) write at a
    time, so we don't have to worry about queue-ing >1 write at a
    time for a device, nor do we have to deal with handling failed
    sub-requests of a split write.

Arguments:

    Fdo - Supplies the device object which represents the logical unit.

    Irp - Supplies the Irp which has completed.

    Context - Supplies a pointer to the SRB.

Return Value:

    NT status

--*/

{
    ULONG               retryInterval;
    KIRQL               oldIrql;
    BOOLEAN             retry;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation (Irp);
    PSCSI_REQUEST_BLOCK srb = Context;
    PCOMMON_DEVICE_EXTENSION    extension = Fdo->DeviceExtension;
    NTSTATUS status;

    ASSERT(extension->IsFdo);

    if (extension->IsRemoved == NO_REMOVE){

        if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS){
            /*
             *  Call ClassIoComplete to free the SRB, release the remove lock, and propagate the pending bit;
             *  then let the irp continue completing.
             */
            status = ClassIoComplete(Fdo, Irp, Context);
        }
        else {
            PPRINTER_DATA printerData = (PPRINTER_DATA)extension->DriverData;

            //
            // Note that ClassInterpretSenseInfo will return (retry=)
            // FALSE if it determines there's no media in device
            //
            retry = ClassInterpretSenseInfo(
                        Fdo,
                        srb,
                        irpStack->MajorFunction,
                        0,
                        MAXIMUM_RETRIES - ((ULONG)(ULONG_PTR)
                            irpStack->Parameters.Others.Argument4),
                        &printerData->LastWriteStatus,
                        &retryInterval
                        );

            if (retry && ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4)--){
                PrinterRetryRequest (Fdo, Irp, srb);
                status = STATUS_MORE_PROCESSING_REQUIRED;
            } 
            else {
                BOOLEAN queuedWriteIrp;
                
                if (printerData->LastWriteStatus == STATUS_NO_MEDIA_IN_DEVICE) {

                    //
                    // At the current time Epson is returning
                    // SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED for both
                    // the out-of-paper & offline cases.  The EndOfMedia
                    // bit wil be set if the printer is truly out of paper,
                    // but if it's not then we want to change the
                    // LastWriteStatus so that we won't set the out-of-paper
                    // bit in the IOCTL_USBPRINT_GET_LPT_STATUS handler.
                    //

                    PSENSE_DATA senseBuffer = srb->SenseInfoBuffer;


                    if ((senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED)  &&
                        !senseBuffer->EndOfMedia) {
                        
                        printerData->LastWriteStatus = STATUS_IO_DEVICE_ERROR;
                    }
                }

                printerData->DueTime.HighPart = -1;
                printerData->DueTime.LowPart = BLOCKED_WRITE_TIMEOUT * (-10 * 1000 * 1000);

                queuedWriteIrp = SetWriteIrp(printerData, Irp, srb);
                if (queuedWriteIrp){
                    KeSetTimer(&printerData->Timer, printerData->DueTime, &printerData->TimerDpc);
                    status = STATUS_MORE_PROCESSING_REQUIRED;
                }
                else {
                    /*
                     *  There is already a WriteIrp set, so we have to complete this one.
                     *  Call ClassIoComplete to free the SRB, release the remove lock, and propagate the pending bit;
                     *  then let the irp continue completing.
                     */
                    status = ClassIoComplete(Fdo, Irp, Context);
                }
            }
        }
    }
    else {
        /*
         *  Call ClassIoComplete to free the SRB, release the remove lock, and propagate the pending bit;
         *  then let the irp continue completing.
         */
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        Irp->IoStatus.Information = 0;
        status = ClassIoComplete(Fdo, Irp, Context);
    }      

    return status;
} 



VOID
PrinterRetryRequest(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                Irp,
    PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    (Code borrowed from classpnp!ClassIoComplete, since we need to
    set a different completion routine)

    This routine reinitalizes the necessary fields, and sends the request
    to the lower driver.

Arguments:

    DeviceObject - Supplies the device object associated with this request.

    Irp - Supplies the request to be retried.

    Srb - Supplies a Pointer to the SCSI request block to be retied.

Return Value:

    None

--*/

{
    ULONG transferByteCount;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PCOMMON_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;


    //
    // Determine the transfer count of the request.  If this is a read or a
    // write then the transfer count is in the Irp stack.  Otherwise assume
    // the MDL contains the correct length.  If there is no MDL then the
    // transfer length must be zero.
    //

    if (currentIrpStack->MajorFunction == IRP_MJ_READ ||
        currentIrpStack->MajorFunction == IRP_MJ_WRITE) {

        transferByteCount = currentIrpStack->Parameters.Read.Length;

    } else if (Irp->MdlAddress != NULL) {

        //
        // Note this assumes that only read and write requests are spilt and
        // other request do not need to be.  If the data buffer address in
        // the MDL and the SRB don't match then transfer length is most
        // likely incorrect.
        //

        ASSERT(Srb->DataBuffer == MmGetMdlVirtualAddress(Irp->MdlAddress));
        transferByteCount = Irp->MdlAddress->ByteCount;

    } else {

        transferByteCount = 0;
    }

    //
    // Reset byte count of transfer in SRB Extension.
    //

    Srb->DataTransferLength = transferByteCount;

    //
    // Zero SRB statuses.
    //

    Srb->SrbStatus = Srb->ScsiStatus = 0;

    //
    // Set the no disconnect flag, disable synchronous data transfers and
    // disable tagged queuing. This fixes some errors.
    //

    Srb->SrbFlags |= SRB_FLAGS_DISABLE_DISCONNECT |
                     SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    Srb->SrbFlags &= ~SRB_FLAGS_QUEUE_ACTION_ENABLE;
    Srb->QueueTag = SP_UNTAGGED;

    //
    // Set up major SCSI function.
    //

    nextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    nextIrpStack->Parameters.Scsi.Srb = Srb;

    //
    // Set up IoCompletion routine address.
    //

    IoSetCompletionRoutine (Irp, PrinterWriteComplete, Srb, TRUE, TRUE, TRUE);

    //
    // Pass the request to the port driver.
    //

    IoCallDriver (extension->LowerDeviceObject, Irp);

    return;
} // end PrinterRetryRequest()



VOID
PrinterWriteTimeoutDpc(
    IN PKDPC                    Dpc,
    IN PVOID                    Context,
    IN PVOID                    SystemArgument1,
    IN PVOID                    SystemArgument2
    )

/*++

Routine Description:

    Gets called when the blocking-write timer expires.  Allocates &
    queues a low-priority work item (to resubmit the write) if
    there's an outstanding write, & if the allocation fails justs
    resets the time to try again later. (We're running at raised
    irql here, when it's not necesarily safe to re-submit the write,
    hence the work item which gets processed later at passive level.)

Arguments:

    Dpc -

    Extension -

    SystemArgument1 -

    SystemArgument2 -

Return Value:

    None

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Context;
    PCOMMON_DEVICE_EXTENSION commonExtension = &fdoExtension->CommonExtension;
    PPRINTER_DATA   printerData = commonExtension->DriverData;
    PIRP writeIrp;
    PSCSI_REQUEST_BLOCK srb;

    if (commonExtension->IsRemoved == NO_REMOVE){

        if (printerData->WriteIrp){
            PIO_WORKITEM workItem;

            workItem = IoAllocateWorkItem(commonExtension->DeviceObject);
            if (workItem) {
                IoQueueWorkItem(workItem, PrinterResubmitWrite, DelayedWorkQueue, workItem);
            } 
            else {
                writeIrp = GetWriteIrp(printerData, &srb);
                if (writeIrp){
                    ExFreePool(srb);
                    writeIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    writeIrp->IoStatus.Information = 0;
                    ClassReleaseRemoveLock(commonExtension->DeviceObject, writeIrp);
                    if (writeIrp->PendingReturned){
                        IoMarkIrpPending(writeIrp);
                    }                    
                    IoCompleteRequest(writeIrp, IO_NO_INCREMENT);
                }
            }
        }
    }
    else {
        /*
         *  We're being removed.  Don't issue the workItem.  
         *  If we have a queued writeIrp, complete the irp and free the srb.
         */
        writeIrp = GetWriteIrp(printerData, &srb);
        if (writeIrp){
            ExFreePool(srb);
            writeIrp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
            writeIrp->IoStatus.Information = 0;
            ClassReleaseRemoveLock(commonExtension->DeviceObject, writeIrp);
            if (writeIrp->PendingReturned){
                IoMarkIrpPending(writeIrp);
            }                    
            IoCompleteRequest(writeIrp, IO_NO_INCREMENT);
        }
    }
} 


VOID
PrinterResubmitWrite(
    PDEVICE_OBJECT  DeviceObject,
    PVOID           Context
    )

/*++

Routine Description:

    Work item handler routine, gets called at passive level in an
    arbitrary thread context. Simply resubmits an outstanding write,
    if any.

Arguments:

    DeviceObject -

    Context - pointer to the IO_WORKITEM

Return Value:

    None

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PPRINTER_DATA printerData = (PPRINTER_DATA)commonExtension->DriverData;
    PIRP writeIrp;
    PSCSI_REQUEST_BLOCK srb;

    IoFreeWorkItem ((PIO_WORKITEM)Context);

    writeIrp = GetWriteIrp(printerData, &srb);
    if (writeIrp){

        ExFreePool(srb);

        if (commonExtension->IsRemoved == NO_REMOVE){
            PrinterReadWrite(DeviceObject, writeIrp);
        }   
        else {
            writeIrp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
            writeIrp->IoStatus.Information = 0;
            ClassReleaseRemoveLock(DeviceObject, writeIrp);
            if (writeIrp->PendingReturned){
                IoMarkIrpPending(writeIrp);
            }                    
            IoCompleteRequest(writeIrp, IO_NO_INCREMENT);
        }
    }
        
} // end PrinterWriteTimeoutDpc


BOOLEAN SetWriteIrp(PPRINTER_DATA PrinterData, PIRP WriteIrp, PSCSI_REQUEST_BLOCK Srb)
{
    BOOLEAN didSet;
    KIRQL oldIrql;

    KeAcquireSpinLock(&PrinterData->SplitRequestSpinLock, &oldIrql);

    if (!PrinterData->WriteIrp){
        /*
         *  This is not perfect irp queuing with cancellation, 
         *  but it works here since the irp will not be cancelled before we receive it.
         *  Since we're queuing the irp, it may complete on a different thread than it was issues on; so set the pending bit.
         */
        ASSERT(!PrinterData->WriteSrb);         
        IoMarkIrpPending(WriteIrp);
        PrinterData->WriteIrp = WriteIrp;
        PrinterData->WriteSrb = Srb;
        didSet = TRUE;
    }
    else if (PrinterData->WriteIrp == WriteIrp){
        /*
         *  This can happen on retry (??)
         */
        ASSERT(PrinterData->WriteSrb == Srb);         
        didSet = TRUE;
    }
    else {
        didSet = FALSE;
    }
    
    KeReleaseSpinLock(&PrinterData->SplitRequestSpinLock, oldIrql);

    return didSet;
}


PIRP GetWriteIrp(PPRINTER_DATA PrinterData, PSCSI_REQUEST_BLOCK *Srb)
{
    PIRP writeIrp;
    KIRQL oldIrql;
    
    KeAcquireSpinLock(&PrinterData->SplitRequestSpinLock, &oldIrql);

    if (PrinterData->WriteIrp){
        writeIrp = PrinterData->WriteIrp;
        PrinterData->WriteIrp = NULL;        
        
        ASSERT(PrinterData->WriteSrb);
        *Srb = PrinterData->WriteSrb;
        PrinterData->WriteSrb = NULL;
    }
    else {
        writeIrp = NULL;
        ASSERT(!PrinterData->WriteSrb);
        *Srb = NULL;
    }
    
    KeReleaseSpinLock(&PrinterData->SplitRequestSpinLock, oldIrql);

    return writeIrp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiprnt\pnp.c ===
/*++


Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    pnp.c

Abstract:

    pnp code for the pnp print class

Author:

    George Chrysanthakopoulos May-1998

Environment:

    Kernel mode

Revision History :

    dankn, 22-Jul-99 : Added ability to block & resubmit failed writes for
                       1394 printers to behave more like other print stacks
                       (i.e. USB) and therefore keep USBMON.DLL (the Win2k
                       port monitor) happy.  USBMON does not deal well
                       with failed writes.
--*/

#include "printpnp.h"
#include "1394.h"
#include "ntddsbp2.h"
#include "stdarg.h"
#include "stdio.h"
#include "string.h"


VOID
PrinterUnload(
    IN PDRIVER_OBJECT DriverObject
    );


NTSTATUS
GetPortNumber(
    HANDLE hFdoKey,
    PUNICODE_STRING uni,
    PULONG ulReturnNumber
    );



VOID
PrinterFindDeviceIdKeys
(
    PUCHAR   *lppMFG,
    PUCHAR   *lppMDL,
    PUCHAR   *lppCLS,
    PUCHAR   *lppDES,
    PUCHAR   *lppAID,
    PUCHAR   *lppCID,
    PUCHAR   lpDeviceID
);

VOID
GetCheckSum(
    PUCHAR Block,
    USHORT Len,
    PUSHORT CheckSum
    );

PUCHAR
StringChr(PCHAR string, CHAR c);


VOID
StringSubst
(
    PUCHAR lpS,
    UCHAR chTargetChar,
    UCHAR chReplacementChar,
    USHORT cbS
);

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );



#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, PrinterUnload)
#pragma alloc_text(PAGE, PrinterAddDevice)
#pragma alloc_text(PAGE, PrinterStartDevice)
#pragma alloc_text(PAGE, PrinterStartPdo)
#pragma alloc_text(PAGE, PrinterCreatePdo)
#pragma alloc_text(PAGE, PrinterQueryId)
#pragma alloc_text(PAGE, PrinterGetId)
#pragma alloc_text(PAGE, GetCheckSum)
#pragma alloc_text(PAGE, PrinterEnumerateDevice)
#pragma alloc_text(PAGE, PrinterRemoveDevice)
#pragma alloc_text(PAGE, CreatePrinterDeviceObject)
#pragma alloc_text(PAGE, PrinterInitFdo)
#pragma alloc_text(PAGE, GetPortNumber)
#pragma alloc_text(PAGE, PrinterRegisterPort)
#pragma alloc_text(PAGE, PrinterQueryPnpCapabilities)
#pragma alloc_text(PAGE, PrinterFindDeviceIdKeys)
#pragma alloc_text(PAGE, StringChr)
#pragma alloc_text(PAGE, StringSubst)

#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the printer class driver. The driver
    opens the port driver by name and then receives configuration
    information used to attach to the Printer devices.

Arguments:

    DriverObject

Return Value:

    NT Status

--*/

{

    CLASS_INIT_DATA InitializationData;

    PAGED_CODE();

    DEBUGPRINT1(("\n\nSCSI/SBP2 Printer Class Driver\n"));

    //
    // Zero InitData
    //

    RtlZeroMemory (&InitializationData, sizeof(CLASS_INIT_DATA));

    //
    // Set sizes
    //

    InitializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);
    InitializationData.FdoData.DeviceExtensionSize = sizeof(FUNCTIONAL_DEVICE_EXTENSION) + sizeof(PRINTER_DATA);
    InitializationData.FdoData.DeviceType = FILE_DEVICE_PRINTER;
    InitializationData.FdoData.DeviceCharacteristics = 0;

    //
    // Set entry points
    //

    InitializationData.FdoData.ClassInitDevice = PrinterInitFdo;
    InitializationData.FdoData.ClassStartDevice = PrinterStartDevice;

    InitializationData.FdoData.ClassReadWriteVerification = PrinterReadWrite;
    InitializationData.FdoData.ClassDeviceControl = PrinterDeviceControl;
    InitializationData.FdoData.ClassRemoveDevice = PrinterRemoveDevice;
    InitializationData.FdoData.ClassStopDevice = PrinterStopDevice;


    InitializationData.FdoData.ClassShutdownFlush = NULL;
    InitializationData.FdoData.ClassCreateClose = PrinterOpenClose;

    InitializationData.PdoData.DeviceExtensionSize = sizeof(PHYSICAL_DEVICE_EXTENSION);
    InitializationData.PdoData.DeviceType = FILE_DEVICE_PRINTER;
    InitializationData.PdoData.DeviceCharacteristics = 0;

    InitializationData.PdoData.ClassStartDevice = PrinterStartPdo;
    InitializationData.PdoData.ClassInitDevice = PrinterInitPdo;
    InitializationData.PdoData.ClassRemoveDevice = PrinterRemoveDevice;
    InitializationData.PdoData.ClassStopDevice = PrinterStopDevice;

    InitializationData.PdoData.ClassPowerDevice = NULL;

    InitializationData.PdoData.ClassError = NULL;
    InitializationData.PdoData.ClassReadWriteVerification = PrinterReadWrite;
    InitializationData.PdoData.ClassCreateClose = NULL;

    InitializationData.PdoData.ClassDeviceControl = PrinterDeviceControl;

    InitializationData.PdoData.ClassQueryPnpCapabilities = PrinterQueryPnpCapabilities;

    InitializationData.ClassEnumerateDevice = PrinterEnumerateDevice;

    InitializationData.ClassQueryId = PrinterQueryId;

    InitializationData.ClassAddDevice = PrinterAddDevice;
    InitializationData.ClassUnload = PrinterUnload;

    //
    // Call the class init routine
    //

    return ClassInitialize( DriverObject, RegistryPath, &InitializationData);

} // end DriverEntry()


VOID
PrinterUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Does nothing really...

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/

{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    return;
}



NTSTATUS
PrinterAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - Printer class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{
    ULONG printerCount = 0;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Get the address of the count of the number of cdroms already initialized.
    //

    do {

        status = CreatePrinterDeviceObject(
                    DriverObject,
                    PhysicalDeviceObject,
                    &printerCount);

        printerCount++;

    } while (status == STATUS_OBJECT_NAME_COLLISION);

    DEBUGPRINT1(("SCSIPRNT: AddDevice, exit with status %x\n",status));
    return status;
}


NTSTATUS
CreatePrinterDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PULONG         DeviceCount
    )

/*++

Routine Description:

    This routine creates an object for the device.

Arguments:

    DriverObject - Pointer to driver object created by system.
    PortDeviceObject - to connect to the port driver.
    DeviceCount - Number of previously installed devices of this type.

Return Value:

    NTSTATUS

--*/
{
    UCHAR ntNameBuffer[64];
    STRING ntNameString;
    NTSTATUS status;
    PCLASS_DRIVER_EXTENSION driverExtension = ClassGetDriverExtension(DriverObject);

    PDEVICE_OBJECT lowerDevice = NULL;
    PDEVICE_OBJECT deviceObject = NULL;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;
    PCOMMON_DEVICE_EXTENSION commonExtension = NULL;

    CCHAR           dosNameBuffer[64];
    CCHAR           deviceNameBuffer[64];
    STRING          deviceNameString;
    STRING          dosString;
    UNICODE_STRING  unicodeString;
    PCLASS_DEV_INFO devInfo;
    PPRINTER_DATA   printerData;
    ULONG           lptNumber;

    PAGED_CODE();

    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);

    status = ClassClaimDevice(lowerDevice, FALSE);

    if(!NT_SUCCESS(status)) {

        DEBUGPRINT1(("SCSIPRINT!CreatePrinterDeviceObject: Failed to claim device %x\n",status));
        ObDereferenceObject(lowerDevice);
        return status;
    }

    //
    // initialize our driver extension..
    //

    devInfo = &(driverExtension->InitData.FdoData);
    devInfo->DeviceType = FILE_DEVICE_PRINTER;
    devInfo->DeviceCharacteristics = 0;

    //
    // Create device object for this device.
    //

    sprintf(ntNameBuffer, "\\Device\\Printer%d", *DeviceCount);

    status = ClassCreateDeviceObject(DriverObject,
                                     ntNameBuffer,
                                     PhysicalDeviceObject,
                                     TRUE,
                                     &deviceObject);

    if (!NT_SUCCESS(status)) {
        DEBUGPRINT1(("SCSIPRINT!CreatePrinterDeviceObjects: Can not create device %s, status %x\n",
                    ntNameBuffer,status));

        goto CreateDeviceObjectExit;
    }

    deviceObject->Flags |= DO_DIRECT_IO;

    fdoExtension = deviceObject->DeviceExtension;
    commonExtension = deviceObject->DeviceExtension;

    printerData = (PPRINTER_DATA)(commonExtension->DriverData);

    RtlZeroMemory(printerData,sizeof(PRINTER_DATA));
    printerData->DeviceIdString = NULL;

    //
    // Back pointer to device object.
    //

    fdoExtension->CommonExtension.DeviceObject = deviceObject;

    //
    // This is the physical device.
    //

    fdoExtension->CommonExtension.PartitionZeroExtension = fdoExtension;

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism when media is mounted.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system printer number
    //

    fdoExtension->DeviceNumber = *DeviceCount;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (lowerDevice->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = lowerDevice->AlignmentRequirement;
    }

    //
    // Save the device descriptors
    //

    fdoExtension->AdapterDescriptor = NULL;

    fdoExtension->DeviceDescriptor = NULL;

    //
    // Clear the SrbFlags and disable synchronous transfers
    //

    fdoExtension->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Finally, attach to the PDO
    //

    fdoExtension->LowerPdo = PhysicalDeviceObject;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        DEBUGPRINT1(("SCSIPRINT!CreatePrinterDeviceObjects: Failed attach\n"));
        status = STATUS_UNSUCCESSFUL;
        goto CreateDeviceObjectExit;
    }

    //
    // Recreate the deviceName
    //

    sprintf(deviceNameBuffer,
            "\\Device\\Printer%d",
            fdoExtension->DeviceNumber);

    RtlInitString(&deviceNameString,
                  deviceNameBuffer);

    status = RtlAnsiStringToUnicodeString(&unicodeString,
                                          &deviceNameString,
                                          TRUE);
    ASSERT(NT_SUCCESS(status));

    //
    // offset the lptnumber to avoid parallel port numbers.
    // note that there is an increment at the beginning of the do
    // loop below as well.
    //

    lptNumber = fdoExtension->DeviceNumber+1;

    do {

        lptNumber++;
        sprintf(dosNameBuffer,
                "\\DosDevices\\LPT%d",
                lptNumber);

        RtlInitString(&dosString, dosNameBuffer);

        status = RtlAnsiStringToUnicodeString(&printerData->UnicodeLinkName,
                                              &dosString,
                                              TRUE);

        if(!NT_SUCCESS(status)) {

           printerData->UnicodeLinkName.Buffer = NULL;
           break;

        }

        if ((printerData->UnicodeLinkName.Buffer != NULL) && (unicodeString.Buffer != NULL)) {

            status = IoAssignArcName(&printerData->UnicodeLinkName, &unicodeString);

        } else {

            status = STATUS_UNSUCCESSFUL;

        }

        if (!NT_SUCCESS(status)) {
            RtlFreeUnicodeString(&printerData->UnicodeLinkName);
            DEBUGPRINT1(("SCSIPRINT!CreatePrinterDeviceObjects: Failed creating Arc Name, status %x\n",status));
        }

    } while (status == STATUS_OBJECT_NAME_COLLISION);

    if (unicodeString.Buffer != NULL ) {
        RtlFreeUnicodeString(&unicodeString);
    }

    if (!NT_SUCCESS(status)) {
        goto CreateDeviceObjectExit;
    }

    printerData->LptNumber = lptNumber;

    ObDereferenceObject(lowerDevice);

    //
    // The device is initialized properly - mark it as such.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;

CreateDeviceObjectExit:

    ClassClaimDevice(lowerDevice, TRUE);
    ObDereferenceObject(lowerDevice);

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    DEBUGPRINT1(("SCSIPRINT!CreatePrinterDeviceObjects: Exiting with status %x\n",status));
    return status;

} // end CreateDeviceObject()


NTSTATUS
PrinterInitFdo(
    IN PDEVICE_OBJECT Fdo
    )
{

    return STATUS_SUCCESS;
}



NTSTATUS
PrinterStartDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will complete the cd-rom initialization.  This includes
    allocating sense info buffers and srb s-lists, reading drive capacity
    and setting up Media Change Notification (autorun).

    This routine will not clean up allocate resources if it fails - that
    is left for device stop/removal

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCLASS_DRIVER_EXTENSION driverExtension = ClassGetDriverExtension(Fdo->DriverObject);
    UNICODE_STRING dosUnicodeString;

    STORAGE_PROPERTY_ID propertyId;

    PVOID senseData = NULL;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT event;

    PPRINTER_DATA printerData = NULL;
    GUID * printerGuid;
    HANDLE hInterfaceKey;

    UCHAR rawString[256];
    PUCHAR vendorId, productId;

    ULONG timeOut;
    NTSTATUS status;
    PSBP2_REQUEST sbp2Request = NULL;

    //
    // Allocate request sense buffer.
    //

    senseData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                      SENSE_BUFFER_SIZE,
                                      PRINTER_TAG);

    if (senseData == NULL) {

        //
        // The buffer cannot be allocated.
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    //
    // Build the lookaside list for srb'. Should only
    // need a couple.
    //

    ClassInitializeSrbLookasideList(&(fdoExtension->CommonExtension), PRINTER_SRB_LIST_SIZE);

    //
    // Set the sense data pointer in the device extension.
    //

    fdoExtension->SenseData = senseData;

    //
    // printers are not partitionable so starting offset is 0.
    //

    fdoExtension->CommonExtension.StartingOffset.LowPart = 0;
    fdoExtension->CommonExtension.StartingOffset.HighPart = 0;

    //
    // Set timeout value in seconds.
    //

    timeOut = ClassQueryTimeOutRegistryValue(Fdo);
    if (timeOut) {
        fdoExtension->TimeOutValue = timeOut;
    } else {
        fdoExtension->TimeOutValue = PRINTER_TIMEOUT;
    }

    printerData = (PPRINTER_DATA)(fdoExtension->CommonExtension.DriverData);

    KeInitializeSpinLock(&printerData->SplitRequestSpinLock);

    //
    // Call port driver to get adapter capabilities.
    //

    propertyId = StorageAdapterProperty;

    status = ClassGetDescriptor(fdoExtension->CommonExtension.LowerDeviceObject,
                                &propertyId,
                                &(fdoExtension->AdapterDescriptor));

    if(!NT_SUCCESS(status)) {
        DEBUGPRINT1(( "PrinterStartDevice: unable to retrieve adapter descriptor "
                       "[%#08lx]\n", status));

        ExFreePool(senseData);
        return status;
    }

    //
    // Call port driver to get device capabilities.
    //

    propertyId = StorageDeviceProperty;

    status = ClassGetDescriptor(fdoExtension->CommonExtension.LowerDeviceObject,
                                &propertyId,
                                &(fdoExtension->DeviceDescriptor));

    if(!NT_SUCCESS(status)) {
        DEBUGPRINT1(( "PrinterStartAddDevice: unable to retrieve device descriptor "
                       "[%#08lx]\n", status));

        ExFreePool(senseData);
        return status;
    }

    if (printerData->DeviceIdString == NULL) {

        printerData->DeviceIdString = ExAllocatePool(PagedPool,256);

        if (!printerData->DeviceIdString) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {

            //
            // to retrieve the model/vendor id from the port driver below, send a queryId
            // to our PDO
            //

            sbp2Request = ExAllocatePool(NonPagedPool,sizeof(SBP2_REQUEST));
            if (sbp2Request == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            irp = IoAllocateIrp((CCHAR)(Fdo->StackSize), FALSE);

            if (irp == NULL) {
                DEBUGPRINT1(("PrinterQueryId: Can't allocate irp\n"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlZeroMemory(sbp2Request,sizeof(SBP2_REQUEST));

            //
            // set the sbp2 api call
            //

            sbp2Request->RequestNumber = SBP2_REQUEST_RETRIEVE_TEXT_LEAFS;
            sbp2Request->u.RetrieveTextLeaf.fulFlags |= SBP2REQ_RETRIEVE_TEXT_LEAF_INDIRECT;
            sbp2Request->u.RetrieveTextLeaf.Key = 0x14; // LUN key, followed 0x81 key w/ 1284 ID

            //
            // Construct the IRP stack for the lower level driver.
            //

            irpStack = IoGetNextIrpStackLocation(irp);
            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SBP2_REQUEST;
            irpStack->Parameters.Others.Argument1  = sbp2Request;

            KeInitializeEvent(&event,
                              NotificationEvent,
                              FALSE);

            IoSetCompletionRoutine(irp,
                                   PrinterCompletionRoutine,
                                   &event,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            status = IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            if(!NT_SUCCESS(status) || !NT_SUCCESS(irp->IoStatus.Status) ||
                (sbp2Request->u.RetrieveTextLeaf.Buffer == NULL)) {

                status = irp->IoStatus.Status;
                DEBUGPRINT1(("PrinterStartDevice: 1284 retrieve failed status %xx\n",status));
                sprintf(printerData->DeviceIdString,"1394 Printer");

            } else {

                //
                // A pointer to the 1284 id TEXTUAL_LEAF is now stored in the
                // sbp2Request->u.RetrieveTextLeaf.Buffer field.
                //
                // We want to make sure it's NULL terminated before we parse
                // it, so we'll move contents of TL_Data (the actual string)
                // back to the front of the buffer (overwriting all existing
                // TL_Xxx fields), then zero the following 4 bytes.
                //
                // Note that sbp2Req->u.RetrTextLeaf.ulLength is the size in
                // bytes of the entire leaf & data, minus the TL_CRC and
                // TL_Length fields.
                //

                RtlMoveMemory(
                    sbp2Request->u.RetrieveTextLeaf.Buffer,
                    ((PUCHAR) sbp2Request->u.RetrieveTextLeaf.Buffer +
                        FIELD_OFFSET(TEXTUAL_LEAF,TL_Data)),
                    sbp2Request->u.RetrieveTextLeaf.ulLength -
                        2 * sizeof (ULONG)  // TL_Spec_Id & TL_Lang_Id fields
                    );

                *((PULONG) ((PUCHAR) sbp2Request->u.RetrieveTextLeaf.Buffer +
                    sbp2Request->u.RetrieveTextLeaf.ulLength -
                    2 * sizeof (ULONG))) = 0;

                status  = PrinterGetId(sbp2Request->u.RetrieveTextLeaf.Buffer,BusQueryDeviceID,rawString,NULL);

                if (!NT_SUCCESS(status)) {

                    sprintf(printerData->DeviceIdString,"1394 Printer");
                    status = STATUS_SUCCESS;

                } else {

                    RtlCopyMemory(printerData->DeviceIdString,rawString,256);

                }

                ExFreePool(sbp2Request->u.RetrieveTextLeaf.Buffer);

            }

            IoFreeIrp(irp);
            ExFreePool(sbp2Request);

            //
            // register with the pnp GUID so the pnp printer port enumerator loads and finds us...
            //

            printerGuid=(GUID *)&PNPPRINT_GUID;
            status=IoRegisterDeviceInterface(fdoExtension->LowerPdo,printerGuid,NULL,&printerData->UnicodeDeviceString);

            if (NT_SUCCESS(status)) {
                status=IoSetDeviceInterfaceState(&printerData->UnicodeDeviceString,TRUE);

                if (!NT_SUCCESS(status)) {
                    DEBUGPRINT1(("PrinterStartDevice: Failed setting interfaceState %x\n",status));
                    return status;
                }

            } else {
                printerData->UnicodeDeviceString.Buffer = NULL;
            }

            //
            // retrieve available port number and write it in our registry key..
            // the key is closed in GetPortNumber
            //

            status = IoOpenDeviceInterfaceRegistryKey(&printerData->UnicodeDeviceString,KEY_ALL_ACCESS,&hInterfaceKey);

            if (NT_SUCCESS(status)) {
                status = GetPortNumber(hInterfaceKey, &printerData->UnicodeDeviceString, &printerData->PortNumber);
            } else {
                DEBUGPRINT1(("PrinterStartDevice Failed opening registry key%x\n",status));
            }

        } else {

            vendorId = (PUCHAR) fdoExtension->DeviceDescriptor + fdoExtension->DeviceDescriptor->VendorIdOffset;
            productId = (PUCHAR) fdoExtension->DeviceDescriptor + fdoExtension->DeviceDescriptor->ProductIdOffset;

            printerData->PortNumber = fdoExtension->DeviceNumber;
            sprintf(printerData->DeviceIdString,"Printer&Ven_%s&Prod_%s",
                    vendorId,
                    productId);


        }

    }

    //
    // If this is a 1394 printer then we want to enable blocking
    // writes by default (to keep USBMON.DLL happy)
    //

    if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {

        printerData->WriteCompletionRoutine = PrinterWriteComplete;

        KeInitializeTimer (&printerData->Timer);

        KeInitializeDpc(
            &printerData->TimerDpc,
            PrinterWriteTimeoutDpc,
            fdoExtension
            );

    } else {

        printerData->WriteCompletionRoutine = ClassIoComplete;
    }

    ClassUpdateInformationInRegistry(Fdo, "LPT", printerData->LptNumber, NULL, 0);
    return status;

} // end PrinterStartDevice()


NTSTATUS
GetPortNumber(
    HANDLE hFdoKey,
    PUNICODE_STRING fdoUnicodeString,
    PULONG ulReturnNumber
    )

{
    UCHAR buf[sizeof (KEY_VALUE_PARTIAL_INFORMATION) + sizeof (ULONG)];

    PWSTR pDeviceList;
    PWSTR pWalkDevice;
    HANDLE hInterfaceKey;

    UCHAR baseNameString[32];
    ANSI_STRING ansiBaseNameString;

    UNICODE_STRING uncValueName,uncLinkName,uncBaseNameValueName;
    UNICODE_STRING uncBaseName, uncRecyclableValueName;
    UNICODE_STRING uncPortDescription, uncPortDescriptionValueName;

    ULONG dwPortNum;
    ULONG ulSizeUsed;
    ULONG i;

    ULONG ulPortNumber=0;
    UCHAR portArray[MAX_NUM_PRINTERS] ;


    NTSTATUS status=STATUS_SUCCESS;
    NTSTATUS qStatus;

    PKEY_VALUE_PARTIAL_INFORMATION valueStruct;
    GUID *printerGuid = (GUID *) &PNPPRINT_GUID;


    for (i=0;i<MAX_NUM_PRINTERS;i++) {
        portArray[i] = 0;
    }

    RtlInitUnicodeString(&uncValueName,PORT_NUM_VALUE_NAME);

    RtlInitUnicodeString(&uncBaseName,BASE_1394_PORT_NAME);
    RtlInitUnicodeString(&uncBaseNameValueName,BASE_PORT_NAME_VALUE_NAME);
    RtlInitUnicodeString(&uncRecyclableValueName,RECYCLABLE_VALUE_NAME);
    RtlInitUnicodeString(&uncPortDescription,BASE_PORT_DESCRIPTION);
    RtlInitUnicodeString(&uncPortDescriptionValueName,BASE_PORT_DESCRIPTION_VALUE_NAME);

    ulSizeUsed = sizeof (buf); //this is a byte to much.  Oh well
    valueStruct = (PKEY_VALUE_PARTIAL_INFORMATION) buf;

    //
    // first check if our own key, has already a port value..
    //

    status=ZwQueryValueKey(hFdoKey,&uncValueName,KeyValuePartialInformation,(PVOID)valueStruct,ulSizeUsed,&ulSizeUsed);

    if (NT_SUCCESS(status)) {

        DEBUGPRINT1(("\'PRINTER:GetPortNumber: Found existing port in our Own key\n"));
        ulPortNumber=*((ULONG *)&(valueStruct->Data));
        ZwClose(hFdoKey);

    } else {

        ZwClose (hFdoKey);

        //
        // search the registry for all ports present. If you find a hole, take it
        // if no holes are found, take the next available slot
        //

        status=IoGetDeviceInterfaces(printerGuid,NULL,DEVICE_INTERFACE_INCLUDE_NONACTIVE,&pDeviceList);

        if (!NT_SUCCESS(status)) {
            DEBUGPRINT1(("\'PRINTER:GetPortNumber: Failed to retrive interfaces\n"));
            return status;
        }

        pWalkDevice=pDeviceList;

        while((*pWalkDevice!=0) && (NT_SUCCESS(status))) {

            RtlInitUnicodeString(&uncLinkName,pWalkDevice);

            if (!RtlCompareUnicodeString(fdoUnicodeString,&uncLinkName,FALSE)) {

                //
                // this key is the same as ours, skip it
                //

                pWalkDevice=pWalkDevice+wcslen(pWalkDevice)+1;
                continue;

            }

            status=IoOpenDeviceInterfaceRegistryKey(&uncLinkName,KEY_ALL_ACCESS,&hInterfaceKey);

            if (NT_SUCCESS(status)) {

                qStatus = ZwQueryValueKey(hInterfaceKey,&uncValueName,KeyValuePartialInformation,valueStruct,ulSizeUsed,&ulSizeUsed);

                if (NT_SUCCESS(qStatus)) {

                    dwPortNum = *((ULONG *)&(valueStruct->Data));

                    qStatus = ZwQueryValueKey(hInterfaceKey,&uncRecyclableValueName,KeyValuePartialInformation,valueStruct,ulSizeUsed,&ulSizeUsed);
                    if (!NT_SUCCESS(qStatus)) {

                        //
                        // port cant be recycled, mark as used so we dont try to grab it..
                        //

                        portArray[dwPortNum-1] = 1;

                    } else {

                        //
                        // port was marked recycled so we can reuse it..
                        //

                        DEBUGPRINT1(("\'GetPortNumber, Recyclable value found for port number %d\n",dwPortNum));

                    }

                }

            }

            pWalkDevice=pWalkDevice+wcslen(pWalkDevice)+1;
            ZwClose(hInterfaceKey);
        }

        ExFreePool(pDeviceList);

        //
        // now find the first hole, and use that port number as our port...
        //

        for (i=0;i<MAX_NUM_PRINTERS;i++) {
            if (portArray[i]) {

                ulPortNumber++;

            } else {

                ulPortNumber++;
                break;
            }
        }

        status = IoOpenDeviceInterfaceRegistryKey(fdoUnicodeString,KEY_ALL_ACCESS,&hFdoKey);
        if (NT_SUCCESS(status)) {

            //
            // write the new port we just found under our FDO reg key..
            //

            status=ZwSetValueKey(hFdoKey,&uncValueName,0,REG_DWORD,&ulPortNumber,sizeof(ulPortNumber));
            DEBUGPRINT1(("\'GetPortNumber, setting port number %d in fdo key status %x\n",ulPortNumber,status));

            //
            // also write our base port name
            //

            if (NT_SUCCESS(status)) {

                status=ZwSetValueKey(hFdoKey,
                                     &uncBaseNameValueName,
                                     0,REG_SZ,
                                     uncBaseName.Buffer,
                                     uncBaseName.Length);

                DEBUGPRINT1(("\'GetPortNumber, setting port name in fdo key status %x\n",status));

            }

            //
            // write out our port description
            //

            if (NT_SUCCESS(status)) {

                status=ZwSetValueKey(hFdoKey,
                                     &uncPortDescriptionValueName,
                                     0,REG_SZ,
                                     uncPortDescription.Buffer,
                                     uncPortDescription.Length);

                DEBUGPRINT1(("\'GetPortNumber, setting port description in fdo key status %x\n",status));

            }


            ZwClose(hFdoKey);

        }

    }

    DEBUGPRINT1(("\'GetPortNumber, grabbing port %d\n",ulPortNumber));
    *ulReturnNumber = ulPortNumber;

    return status;

}



NTSTATUS
PrinterInitPdo(
    IN PDEVICE_OBJECT Fdo
    )
{

    return STATUS_SUCCESS;
}



NTSTATUS
PrinterStartPdo(
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine will create the well known names for a PDO and register
    it's device interfaces.

--*/

{
    return STATUS_SUCCESS;
}



NTSTATUS
PrinterEnumerateDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine is called by the class driver to update the PDO list off
    of this FDO.

    Since we always only have one static PDO, this is pretty simple..

Arguments:

    Fdo - a pointer to the FDO being re-enumerated

Return Value:

    status

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PPHYSICAL_DEVICE_EXTENSION pdoExtension = NULL;

    PDEVICE_OBJECT pdo = NULL;

    ULONG numberListElements = 0;

    NTSTATUS status;

    ASSERT(commonExtension->IsFdo);

    PAGED_CODE();

    if (fdoExtension->AdapterDescriptor == NULL) {

        //
        // device removed..
        //

        return STATUS_UNSUCCESSFUL;
    }

    if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {

        if(fdoExtension->CommonExtension.ChildList == NULL) {

            DebugPrint((1, "PrinterEnumerateDevice: Creating PDO\n"));

            status = PrinterCreatePdo(Fdo, &pdo);

        } else {
            status = STATUS_SUCCESS;
        }

    } else {

        status = STATUS_NOT_SUPPORTED;

    }

    return status;

} // end printerEnumerateDevice()


NTSTATUS
PrinterCreatePdo(
    IN PDEVICE_OBJECT Fdo,
    OUT PDEVICE_OBJECT *Pdo
    )

/*++

Routine Description:

    This routine will create and initialize a new device object
    (PDO) and insert it into the FDO partition list.
    Note that the PDO is actually never used. We create so the printer class
    installer will run after the LPTENUM ids for this PDO were matched to the
    printer inf..

Arguments:

    Fdo - a pointer to the functional device object this PDO will be a child
          of

    Pdo - a location to store the pdo pointer upon successful completion

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;

    PDEVICE_OBJECT pdo = NULL;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension = NULL;
    PPRINTER_DATA printerData = fdoExtension->CommonExtension.DriverData;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugPrint((2, "PrinterCreatePdo: Create device object %s\n",
                   printerData->DeviceName));

    status = ClassCreateDeviceObject(Fdo->DriverObject,
                                     printerData->DeviceName,
                                     Fdo,
                                     FALSE,
                                     &pdo);

    if (!NT_SUCCESS(status)) {

        DebugPrint((1, "printerEnumerateDevice: Can't create device object for %s\n", printerData->DeviceName));

        return status;
    }

    //
    // Set up device extension fields.
    //

    pdoExtension = pdo->DeviceExtension;
    commonExtension = pdo->DeviceExtension;

    //
    // Set up device object fields.
    //

    pdo->Flags |= DO_DIRECT_IO;

    pdo->StackSize = (CCHAR)
        commonExtension->LowerDeviceObject->StackSize + 1;

    pdoExtension->IsMissing = FALSE;

    commonExtension->DeviceObject = pdo;
    commonExtension->PartitionZeroExtension = fdoExtension;

    pdo->Flags &= ~DO_DEVICE_INITIALIZING;

    *Pdo = pdo;

    return status;
}

NTSTATUS
PrinterStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
{
    DEBUGPRINT2((
        "SCSIPRNT: PrinterStopDevice: DevObj=x%p, Type=%d\n",
        DeviceObject,
        (ULONG) Type
        ));

    return STATUS_SUCCESS;
}


NTSTATUS
PrinterRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

/*++

Routine Description:

    This routine is responsible for releasing any resources in use by the
    driver and shutting down it's timer routine.  This routine is called
    when all outstanding requests have been completed and the device has
    disappeared - no requests may be issued to the lower drivers.

Arguments:

    DeviceObject - the device object being removed

Return Value:

    none - this routine may not fail

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension =
        DeviceObject->DeviceExtension;

    PPRINTER_DATA printerData = deviceExtension->CommonExtension.DriverData;


    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE)) {
        return STATUS_SUCCESS;
    }

    if (commonExtension->IsFdo){

        if (Type == IRP_MN_REMOVE_DEVICE){
            if (printerData->DeviceIdString) {
                ExFreePool(printerData->DeviceIdString);
                printerData->DeviceIdString = NULL;
            }

            if (deviceExtension->DeviceDescriptor) {
                ExFreePool(deviceExtension->DeviceDescriptor);
                deviceExtension->DeviceDescriptor = NULL;
            }

            if (deviceExtension->AdapterDescriptor) {
                ExFreePool(deviceExtension->AdapterDescriptor);
                deviceExtension->AdapterDescriptor = NULL;
            }

            if (deviceExtension->SenseData) {
                ExFreePool(deviceExtension->SenseData);
                deviceExtension->SenseData = NULL;
            }
            
            ClassDeleteSrbLookasideList(commonExtension);
        }            

        if (printerData->UnicodeLinkName.Buffer != NULL ) {

            IoDeassignArcName(&printerData->UnicodeLinkName);
            RtlFreeUnicodeString(&printerData->UnicodeLinkName);
            printerData->UnicodeLinkName.Buffer = NULL;
        }

        if (printerData->UnicodeDeviceString.Buffer != NULL ) {
            IoSetDeviceInterfaceState(&printerData->UnicodeDeviceString,FALSE);
            RtlFreeUnicodeString(&printerData->UnicodeDeviceString);
            printerData->UnicodeDeviceString.Buffer = NULL;
        }

    }

    return STATUS_SUCCESS;
}

NTSTATUS
PrinterQueryId(
    IN PDEVICE_OBJECT Pdo,
    IN BUS_QUERY_ID_TYPE IdType,
    IN PUNICODE_STRING UnicodeIdString
    )

{
    ANSI_STRING ansiIdString;
    UCHAR rawString[256];
    UCHAR finalString[256];

    NTSTATUS status;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Pdo->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;


    PPRINTER_DATA printerData;


    PAGED_CODE();
    ASSERT_PDO(Pdo);

    fdoExtension = commonExtension->PartitionZeroExtension;

    RtlZeroMemory(rawString,256);
    RtlZeroMemory(finalString,256);

    //
    // FDOs printer data
    //

    printerData = fdoExtension->CommonExtension.DriverData;

    if(IdType == BusQueryDeviceID) {

        if (fdoExtension->AdapterDescriptor->BusType != BusType1394) {

            sprintf(finalString,"SCSI\\%s",printerData->DeviceIdString);

        } else {

            //
            // we want to fake our ids it so we use the legacy printing inf.
            //

            sprintf(finalString,"LPTENUM\\%s",printerData->DeviceIdString);

        }

        RtlCopyMemory(printerData->DeviceName,finalString,256);

        DEBUGPRINT1(("\'PrinterQueryId, DeviceId =%s\n",printerData->DeviceName));
        RtlInitAnsiString(&ansiIdString,finalString);

        return RtlAnsiStringToUnicodeString(UnicodeIdString, &ansiIdString, TRUE);
    }

    if(IdType == BusQueryInstanceID) {

        if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {
            sprintf(finalString,"1394_%03u",printerData->PortNumber);
        } else {
            sprintf(finalString,"SCSI%03u", printerData->PortNumber);
        }

        RtlInitAnsiString(&ansiIdString, finalString);

        return RtlAnsiStringToUnicodeString(UnicodeIdString, &ansiIdString, TRUE);
    }

    if((IdType == BusQueryHardwareIDs) || (IdType == BusQueryCompatibleIDs)) {

        strcpy(rawString,printerData->DeviceIdString);
        strcpy(finalString,printerData->DeviceIdString);

        if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {

            status  = PrinterGetId(printerData->DeviceIdString,IdType,rawString,NULL);

            if (IdType == BusQueryHardwareIDs) {

                PrinterRegisterPort(Pdo->DeviceExtension);

            }

            if (NT_SUCCESS(status)) {

                RtlZeroMemory(finalString,256);
                strcpy(finalString,rawString);

            }
        }

        DEBUGPRINT1(("\'PrinterQueryId, Combatible/Hw Id =%s\n",finalString));

        RtlInitAnsiString(&ansiIdString, finalString);

        UnicodeIdString->MaximumLength = (USHORT) RtlAnsiStringToUnicodeSize(&ansiIdString) + sizeof(UNICODE_NULL);

        UnicodeIdString->Buffer = ExAllocatePoolWithTag(PagedPool,
                                                        UnicodeIdString->MaximumLength,
                                                        PRINTER_TAG);

        if(UnicodeIdString->Buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(UnicodeIdString->Buffer, UnicodeIdString->MaximumLength);

        return RtlAnsiStringToUnicodeString(UnicodeIdString,
                                            &ansiIdString,
                                            FALSE);


    }

    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
PrinterCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
PrinterQueryPnpCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_CAPABILITIES Capabilities
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Capabilities);

    if(commonExtension->IsFdo) {
        return STATUS_NOT_IMPLEMENTED;
    } else {

        Capabilities->RawDeviceOK = 1;
        Capabilities->SurpriseRemovalOK = 1;

    }

    return STATUS_SUCCESS;
}


VOID
PrinterRegisterPort(
    IN PPHYSICAL_DEVICE_EXTENSION DeviceExtension
    )
{

    HANDLE          KeyHandle;
    UCHAR           RawString[256];
    ANSI_STRING     AnsiIdString;
    NTSTATUS        status;
    UNICODE_STRING  UnicodeTemp;
    UNICODE_STRING  UnicodeRegValueName;
    PCOMMON_DEVICE_EXTENSION commonExtension = &DeviceExtension->CommonExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =
        commonExtension->PartitionZeroExtension;

    PDEVICE_OBJECT deviceObject = DeviceExtension->DeviceObject;

    PPRINTER_DATA printerData = fdoExtension->CommonExtension.DriverData;

    //
    // register with the printer guid and create a Port value in the registry
    // for talking to this printer (legacy junk, because the spooler expects it..)
    //

    status = IoOpenDeviceRegistryKey (deviceObject,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      KEY_ALL_ACCESS,
                                      &KeyHandle );

    if (NT_SUCCESS(status)) {

        //
        // Create a new value under our instance, for the port number
        //

        sprintf(RawString,"PortName");
        RtlInitAnsiString(&AnsiIdString,RawString);
        RtlAnsiStringToUnicodeString(&UnicodeRegValueName,&AnsiIdString,TRUE);

        if (fdoExtension->AdapterDescriptor->BusType == BusType1394) {
            sprintf(RawString,"1394_%03u",printerData->PortNumber);
        } else {
            sprintf(RawString,"SCSI%03u",printerData->PortNumber);
        }

        RtlInitAnsiString(&AnsiIdString,RawString);
        RtlAnsiStringToUnicodeString(&UnicodeTemp,&AnsiIdString,TRUE);

        status = ZwSetValueKey(KeyHandle,
                      &UnicodeRegValueName,
                      0,
                      REG_SZ,
                      UnicodeTemp.Buffer,
                      UnicodeTemp.Length*sizeof(UCHAR));

        ZwClose(KeyHandle);

        RtlFreeUnicodeString(&UnicodeRegValueName);
        RtlFreeUnicodeString(&UnicodeTemp);

    }

}


NTSTATUS
PrinterGetId
(
    IN PUCHAR DeviceIdString,
    IN ULONG Type,
    OUT PUCHAR resultString,
    OUT PUCHAR descriptionString
)
/*
    Description:

        Creates Id's from the device id retrieved from the printer

    Parameters:

        DeviceId - String with raw device id
        Type - What of id we want as a result
        Id - requested id

    Return Value:
        NTSTATUS

*/
{
    NTSTATUS status;
    USHORT          checkSum=0;                     // A 16 bit check sum
    UCHAR           nodeName[16] = "LPTENUM\\";
    // The following are used to generate sub-strings from the Device ID string
    // to get the DevNode name, and to update the registry
    PUCHAR          MFG = NULL;                   // Manufature name
    PUCHAR          MDL = NULL;                   // Model name
    PUCHAR          CLS = NULL;                   // Class name
    PUCHAR          AID = NULL;                   // Hardare ID
    PUCHAR          CID = NULL;                   // Compatible IDs
    PUCHAR          DES = NULL;                   // Device Description

    status = STATUS_SUCCESS;

    switch(Type) {

    case BusQueryDeviceID:

        // Extract the usefull fields from the DeviceID string.  We want
        // MANUFACTURE (MFG):
        // MODEL (MDL):
        // AUTOMATIC ID (AID):
        // COMPATIBLE ID (CID):
        // DESCRIPTION (DES):
        // CLASS (CLS):

        PrinterFindDeviceIdKeys(&MFG, &MDL, &CLS, &DES, &AID, &CID, DeviceIdString);

        // Check to make sure we got MFG and MDL as absolute minimum fields.  If not
        // we cannot continue.
        if (!MFG || !MDL)
        {
            status = STATUS_NOT_FOUND;
            goto GetId_Cleanup;
        }
        //
        // Concatenate the provided MFG and MDL P1284 fields
        // Checksum the entire MFG+MDL string
        //
        sprintf(resultString, "%s%s\0",MFG,MDL);

        if (descriptionString) {
            sprintf(descriptionString, "%s %s\0",MFG,MDL);
        }

        break;

    case BusQueryHardwareIDs:

        GetCheckSum(DeviceIdString, (USHORT)strlen(DeviceIdString), &checkSum);
        sprintf(resultString,"%s%.20s%4X",nodeName,DeviceIdString,checkSum);
        break;

    case BusQueryCompatibleIDs:

        //
        // return only 1 id
        //
        GetCheckSum(DeviceIdString, (USHORT)strlen(DeviceIdString), &checkSum);
        sprintf(resultString,"%.20s%4X",DeviceIdString,checkSum);

        break;
    }

    if (Type!=BusQueryDeviceID) {

        //
        // Convert and spaces in the Hardware ID to underscores
        //
        StringSubst ((PUCHAR) resultString, ' ', '_', (USHORT)strlen(resultString));
    }

GetId_Cleanup:

    return(status);
}

VOID
PrinterFindDeviceIdKeys
(
    PUCHAR   *lppMFG,
    PUCHAR   *lppMDL,
    PUCHAR   *lppCLS,
    PUCHAR   *lppDES,
    PUCHAR   *lppAID,
    PUCHAR   *lppCID,
    PUCHAR   lpDeviceID
)
/*

    Description:
        This function will parse a P1284 Device ID string looking for keys
        of interest to the LPT enumerator. Got it from win95 lptenum

    Parameters:
        lppMFG      Pointer to MFG string pointer
        lppMDL      Pointer to MDL string pointer
        lppMDL      Pointer to CLS string pointer
        lppDES      Pointer to DES string pointer
        lppCIC      Pointer to CID string pointer
        lppAID      Pointer to AID string pointer
        lpDeviceID  Pointer to the Device ID string

    Return Value:
        no return VALUE.
        If found the lpp parameters are set to the approprate portions
        of the DeviceID string, and they are NULL terminated.
        The actual DeviceID string is used, and the lpp Parameters just
        reference sections, with appropriate null thrown in.

*/

{
    PUCHAR   lpKey = lpDeviceID;     // Pointer to the Key to look at
    PUCHAR   lpValue;                // Pointer to the Key's value
    USHORT   wKeyLength;             // Length for the Key (for stringcmps)

    // While there are still keys to look at.

    lpValue = StringChr(lpKey, '&');
    if (lpValue) {
        ++lpValue;
        lpKey = lpValue;
    }

    while (lpKey != NULL)
    {
        while (*lpKey == ' ')
            ++lpKey;

        // Is there a terminating COLON character for the current key?

        if (!(lpValue = StringChr(lpKey, ':')) )
        {
            // N: OOPS, somthing wrong with the Device ID
            return;
        }

        // The actual start of the Key value is one past the COLON

        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //

        wKeyLength = (USHORT)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //

        switch (*lpKey)
        {
            case 'M':
                // Look for MANUFACTURE (MFG) or MODEL (MDL)
                if ((RtlCompareMemory(lpKey, "MANUFACTURER", wKeyLength)>5) ||
                    (RtlCompareMemory(lpKey, "MFG", wKeyLength)==3) )
                {
                    *lppMFG = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=NULL)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else if ((RtlCompareMemory(lpKey, "MODEL", wKeyLength)==5) ||
                         (RtlCompareMemory(lpKey, "MDL", wKeyLength)==3) )
                {
                    *lppMDL = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'C':
                // Look for CLASS (CLS)
                if ((RtlCompareMemory(lpKey, "CLASS", wKeyLength)==5) ||
                    (RtlCompareMemory(lpKey, "CLS", wKeyLength)==3) )
                {
                    *lppCLS = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else if ((RtlCompareMemory(lpKey, "COMPATIBLEID", wKeyLength)>5) ||
                         (RtlCompareMemory(lpKey, "CID", wKeyLength)==3) )
                {
                    *lppCID = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue,';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'D':
                // Look for DESCRIPTION (DES)
                if (RtlCompareMemory(lpKey, "DESCRIPTION", wKeyLength) ||
                    RtlCompareMemory(lpKey, "DES", wKeyLength) )
                {
                    *lppDES = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'A':
                // Look for AUTOMATIC ID (AID)
                if (RtlCompareMemory(lpKey, "AUTOMATICID", wKeyLength) ||
                    RtlCompareMemory(lpKey, "AID", wKeyLength) )
                {
                    *lppAID = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            default:
                // The key is uninteresting.  Go to the next Key
                if ((lpKey = StringChr(lpValue, ';'))!=0)
                {
                    *lpKey = '\0';
                    ++lpKey;
                }
                break;
        }
    }
}


VOID
GetCheckSum(
    PUCHAR Block,
    USHORT Len,
    PUSHORT CheckSum
    )
{
    USHORT i;
    UCHAR lrc;
    USHORT crc = 0;

    unsigned short crc16a[] = {
        0000000,  0140301,  0140601,  0000500,
        0141401,  0001700,  0001200,  0141101,
        0143001,  0003300,  0003600,  0143501,
        0002400,  0142701,  0142201,  0002100,
    };
    unsigned short crc16b[] = {
        0000000,  0146001,  0154001,  0012000,
        0170001,  0036000,  0024000,  0162001,
        0120001,  0066000,  0074000,  0132001,
        0050000,  0116001,  0104001,  0043000,
    };

    //
    // Calculate CRC using tables.
    //

    UCHAR tmp;
    for ( i=0; i<Len;  i++) {
         tmp = Block[i] ^ (UCHAR)crc;
         crc = (crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4];
    }

    *CheckSum = crc;

}

PUCHAR
StringChr(PCHAR string, CHAR c)
{
    ULONG   i=0;

    if (!string)
        return(NULL);

    while (*string) {
        if (*string==c)
            return(string);
        string++;
        i++;
    }

    return(NULL);

}



VOID
StringSubst
(
    PUCHAR lpS,
    UCHAR chTargetChar,
    UCHAR chReplacementChar,
    USHORT cbS
)
{
    USHORT  iCnt = 0;

    while ((lpS != '\0') && (iCnt++ < cbS))
        if (*lpS == chTargetChar)
            *lpS++ = chReplacementChar;
        else
            ++lpS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiport\wmi.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    wmi.c

Abstract:

    This module contains the WMI support code for SCSIPORT's functional and
    physical device objects.

Authors:

    Dan Markarian

Environment:

    Kernel mode only.

Notes:

    None.

Revision History:

    19-Mar-1997, Original Writing, Dan Markarian

--*/

#include "port.h"

#define __FILE_ID__ 'wmi '

#if DBG
static const char *__file__ = __FILE__;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ScsiPortSystemControlIrp)
#pragma alloc_text(PAGE, SpWmiIrpNormalRequest)
#pragma alloc_text(PAGE, SpWmiIrpRegisterRequest)

#pragma alloc_text(PAGE, SpWmiHandleOnMiniPortBehalf)
#pragma alloc_text(PAGE, SpWmiPassToMiniPort)

#pragma alloc_text(PAGE, SpWmiDestroySpRegInfo)
#pragma alloc_text(PAGE, SpWmiGetSpRegInfo)
#pragma alloc_text(PAGE, SpWmiInitializeSpRegInfo)

#pragma alloc_text(PAGE, SpWmiInitializeFreeRequestList)

#pragma alloc_text(PAGE, SpAdapterConfiguredForSenseDataEvents)
#pragma alloc_text(PAGE, SpInitAdapterWmiRegInfo)
#endif

#define SP_WMI_EVENT 1


NTSTATUS
ScsiPortSystemControlIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )

/*++

Routine Description:

   Process an IRP_MJ_SYSTEM_CONTROL request packet.

Arguments:

   DeviceObject - Pointer to the functional or physical device object.

   Irp          - Pointer to the request packet.

Return Value:

   NTSTATUS result code.

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION       irpSp;
    NTSTATUS                 status          = STATUS_SUCCESS;
    WMI_PARAMETERS           wmiParameters;

    ULONG isRemoved;

    PAGED_CODE();

    isRemoved = SpAcquireRemoveLock(DeviceObject, Irp);

    if (isRemoved) {
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        SpReleaseRemoveLock(DeviceObject, Irp);
        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Obtain a pointer to the current IRP stack location.
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpSp->MajorFunction == IRP_MJ_SYSTEM_CONTROL);

    //
    // Determine if this WMI request was destined to us.  If not, pass the IRP
    // down.
    //

    if ( (PDEVICE_OBJECT)irpSp->Parameters.WMI.ProviderId == DeviceObject) {
        BOOLEAN forwardDown = FALSE;

        DebugPrint((SP_WMI_EVENT, "ScsiPortSystemControlIrp: MinorFunction %x\n", 
                    irpSp->MinorFunction));
    
        //
        // Copy the WMI parameters into our local WMISRB structure.
        //
        wmiParameters.ProviderId = irpSp->Parameters.WMI.ProviderId;
        wmiParameters.DataPath   = irpSp->Parameters.WMI.DataPath;
        wmiParameters.Buffer     = irpSp->Parameters.WMI.Buffer;
        wmiParameters.BufferSize = irpSp->Parameters.WMI.BufferSize;
    
        //
        // Determine what the WMI request wants of us.
        //
        switch (irpSp->MinorFunction) {
            case IRP_MN_QUERY_ALL_DATA:
                //
                // Query for all instances of a data block.
                //
            case IRP_MN_QUERY_SINGLE_INSTANCE:
                //
                // Query for a single instance of a data block.
                //
            case IRP_MN_CHANGE_SINGLE_INSTANCE:
                //
                // Change all data items in a data block for a single instance.
                //
            case IRP_MN_CHANGE_SINGLE_ITEM:
                //
                // Change a single data item in a data block for a single instance.
                //
            case IRP_MN_ENABLE_EVENTS:
                //
                // Enable events.
                //
            case IRP_MN_DISABLE_EVENTS:
                //
                // Disable events.
                //
            case IRP_MN_ENABLE_COLLECTION:
                //
                // Enable data collection for the given GUID.
                //
            case IRP_MN_DISABLE_COLLECTION:
                //
                // Disable data collection for the given GUID.
                //
                status = SpWmiIrpNormalRequest(DeviceObject,
                                               irpSp->MinorFunction,
                                               &wmiParameters);
                break;
    
            case IRP_MN_EXECUTE_METHOD:
                //
                // Execute method
                //
                status = SpWmiIrpNormalRequest(DeviceObject,
                                               irpSp->MinorFunction,
                                               &wmiParameters);
                break;
    
            case IRP_MN_REGINFO:
                //
                // Query for registration and registration update information.
                //
                status = SpWmiIrpRegisterRequest(DeviceObject, &wmiParameters);
                break;
    
            default:
                //
                // Unsupported WMI request.  According to some rule in the WMI 
                // spec we're supposed to send unsupported WMI requests down 
                // the stack even if we're marked as the provider.
                //
                forwardDown = TRUE;
                break;
        }

        if(forwardDown == FALSE) {
            //
            // Complete this WMI IRP request.
            //
            Irp->IoStatus.Status     = status;
            Irp->IoStatus.Information= (NT_SUCCESS(status) ? 
                                        wmiParameters.BufferSize : 0);
            SpReleaseRemoveLock(DeviceObject, Irp);
            SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);

            return status;
        }
    }

    //
    // Request should be forwarded down the stack.  If we're a pdo that means 
    // we should complete it as is.
    //

    SpReleaseRemoveLock(DeviceObject, Irp);

    if(commonExtension->IsPdo) {
        //
        // Get the current status out of the irp.
        // 

        status = Irp->IoStatus.Status;

        //
        // Complete the irp.
        //

        SpCompleteRequest(DeviceObject, Irp, NULL, IO_NO_INCREMENT);
    } else {
        //
        // Copy parameters from our stack location to the next stack location.
        //
    
        IoCopyCurrentIrpStackLocationToNext(Irp);
    
        //
        // Pass the IRP on to the next driver.
        //

        status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
    }

    return status;
}


NTSTATUS
SpWmiIrpNormalRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters
    )

/*++

Routine Description:

    Process an IRP_MJ_SYSTEM_CONTROL request packet (for all requests except registration
    IRP_MN_REGINFO requests).

Arguments:

    DeviceObject  - Pointer to the functional or physical device object.

    WmiMinorCode  - WMI action to perform.

    WmiParameters - Pointer to the WMI request parameters.

Return Value:

    NTSTATUS result code to complete the WMI IRP with.

Notes:

    If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
    BufferSize field will reflect the actual size of the WMI return buffer.

--*/

{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    NTSTATUS                 status          = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Determine if SCSIPORT will repond to this WMI request on behalf of
    // the miniport driver.
    //
    status = SpWmiHandleOnMiniPortBehalf(DeviceObject,
                                         WmiMinorCode,
                                         WmiParameters);

    //
    // If not, pass the request onto the miniport driver, provided the
    // miniport driver does support WMI.
    //
    if (status == STATUS_WMI_GUID_NOT_FOUND && 
        commonExtension->WmiMiniPortSupport) {

        //
        // Send off the WMI request to the miniport.
        //
        status = SpWmiPassToMiniPort(DeviceObject,
                                     WmiMinorCode,
                                     WmiParameters);

        if (NT_SUCCESS(status)) {

            //
            // Fill in fields miniport cannot fill in for itself.
            //
            if ( WmiMinorCode == IRP_MN_QUERY_ALL_DATA ||
                 WmiMinorCode == IRP_MN_QUERY_SINGLE_INSTANCE ) {
                PWNODE_HEADER wnodeHeader = WmiParameters->Buffer;

                ASSERT( WmiParameters->BufferSize >= sizeof(WNODE_HEADER) );

                KeQuerySystemTime(&wnodeHeader->TimeStamp);
            }
        } else {

            //
            // Translate SRB status into a meaningful NTSTATUS status.
            //
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    return status;
}


NTSTATUS
SpWmiIrpRegisterRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PWMI_PARAMETERS WmiParameters
    )

/*++

Routine Description:

   Process an IRP_MJ_SYSTEM_CONTROL registration request.

Arguments:

   DeviceObject  - Pointer to the functional or physical device object.

   WmiParameters - Pointer to the WMI request parameters.

Return Value:

   NTSTATUS result code to complete the WMI IRP with.

Notes:

   If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
   BufferSize field will reflect the actual size of the WMI return buffer.

--*/

{
    PCOMMON_EXTENSION   commonExtension = DeviceObject->DeviceExtension;
    PSCSIPORT_DRIVER_EXTENSION driverExtension = NULL;

    ULONG                      countedRegistryPathSize = 0;
    ULONG                      retSz;
    PWMIREGINFO                spWmiRegInfoBuf;
    ULONG                      spWmiRegInfoBufSize;
    NTSTATUS                   status = STATUS_SUCCESS;
    BOOLEAN                    wmiUpdateRequest;
    ULONG                      i;
    PDEVICE_OBJECT             pDO;

    WMI_PARAMETERS  paranoidBackup = *WmiParameters;

    PAGED_CODE();

    DebugPrint((SP_WMI_EVENT, "SpWmiRegisterRequest: DO %p WMIParams %p\n",
                DeviceObject, WmiParameters));

    //
    // Validate our assumptions for this function's code.
    //
    ASSERT(WmiParameters->BufferSize >= sizeof(ULONG));

    //
    // Validate the registration mode.
    //
    switch ( (ULONG)(ULONG_PTR)WmiParameters->DataPath ) {
        case WMIUPDATE:
            //
            // No SCSIPORT registration information will be piggybacked
            // on behalf of the miniport for a WMIUPDATE request.
            //
            wmiUpdateRequest = TRUE;
            break;

        case WMIREGISTER:
            wmiUpdateRequest = FALSE;
            break;

        default:
            //
            // Unsupported registration mode.
            //
            ASSERT(FALSE);
            return STATUS_INVALID_PARAMETER;
    }

    //
    // Obtain the driver extension for this miniport (FDO/PDO).
    //
    driverExtension = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                                 ScsiPortInitialize);

    ASSERT(driverExtension != NULL);
    //
    // Make Prefix Happy -- we'll quit if
    // driverExtension is NULL
    //
    if (driverExtension == NULL) {
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // Obtain a pointer to the SCSIPORT WMI registration information
    // buffer, which is registered on behalf of the miniport driver.
    //
    SpWmiGetSpRegInfo(DeviceObject, &spWmiRegInfoBuf,
                      &spWmiRegInfoBufSize);

    DebugPrint((SP_WMI_EVENT, "SpWmiIrpRegisterRequest: spWmiRegInfoBuf %p SpWmiReginfoBufSize %d\n",
                spWmiRegInfoBuf, spWmiRegInfoBufSize));

    //
    // Pass the WMI registration request to the miniport.  This is not
    // necessary if we know the miniport driver does not support WMI.
    //
    if (commonExtension->WmiMiniPortSupport == TRUE &&
        (commonExtension->WmiMiniPortInitialized == TRUE ||
         commonExtension->IsPdo == TRUE)) {

        DebugPrint((SP_WMI_EVENT, "SpWmiIrpRegisterRequest: add miniport data\n"));
        
        //
        // Note that we shrink the buffer size by the size necessary
        // to hold SCSIPORT's own registration information, which we
        // register on behalf of the miniport.   This information is
        // piggybacked into the WMI return buffer after the call  to
        // the miniport.  We ensure that the BufferSize passed to the
        // miniport is no smaller than "sizeof(ULONG)" so that it can
        // tell us the required buffer size should the buffer be too
        // small [by filling in this ULONG].
        //
        // Note that we must also make enough room for a copy of the
        // miniport registry path in the buffer, since the WMIREGINFO
        // structures from the miniport DO NOT set their registry
        // path fields.
        //

        if (WmiParameters->BufferSize < sizeof(ULONG)) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Calculate size of required miniport registry path.
        //
        countedRegistryPathSize = driverExtension->RegistryPath.Length
                                  + sizeof(USHORT);

        //
        // Shrink buffer by the appropriate size. Note that the extra
        // 7 bytes (possibly extraneous) is subtracted to ensure that
        // the piggybacked data added later on is 8-byte aligned (if
        // any).
        //
        if (spWmiRegInfoBufSize && !wmiUpdateRequest) {
            WmiParameters->BufferSize =
                (WmiParameters->BufferSize > spWmiRegInfoBufSize + countedRegistryPathSize + 7 + sizeof(ULONG)) ?
                WmiParameters->BufferSize - spWmiRegInfoBufSize - countedRegistryPathSize - 7 :
            sizeof(ULONG);
        } else { // no data to piggyback
            WmiParameters->BufferSize =
                (WmiParameters->BufferSize > countedRegistryPathSize + sizeof(ULONG)) ?
                WmiParameters->BufferSize - countedRegistryPathSize :
            sizeof(ULONG);
        }

        //
        // Call the minidriver.
        //
        status = SpWmiPassToMiniPort(DeviceObject,
                                     IRP_MN_REGINFO,
                                     WmiParameters);

        ASSERT(WmiParameters->ProviderId == paranoidBackup.ProviderId);
        ASSERT(WmiParameters->DataPath == paranoidBackup.DataPath);
        ASSERT(WmiParameters->Buffer == paranoidBackup.Buffer);
        ASSERT(WmiParameters->BufferSize <= paranoidBackup.BufferSize);

        //
        // Assign WmiParameters->BufferSize to retSz temporarily.
        //
        // Note that on return from the above call, the wmiParameters'
        // BufferSize field has been _modified_ to reflect the current
        // size of the return buffer.
        //
        retSz = WmiParameters->BufferSize;

    } else if (WmiParameters->BufferSize < spWmiRegInfoBufSize &&
               !wmiUpdateRequest) {

        //
        // Insufficient space to hold SCSIPORT WMI registration information
        // alone.  Inform WMI appropriately of the required buffer size.
        //
        *((ULONG*)WmiParameters->Buffer) = spWmiRegInfoBufSize;
        WmiParameters->BufferSize = sizeof(ULONG);

        return STATUS_SUCCESS;

    } else { // no miniport support for WMI, sufficient space for scsiport info

        //
        // Fake having the miniport return zero WMIREGINFO structures.
        //
        retSz = 0;
    }

    //
    // Piggyback SCSIPORT's registration information into the WMI
    // registration buffer.
    //

    if ((status == STATUS_BUFFER_TOO_SMALL) ||
        (NT_SUCCESS(status) && (retSz == sizeof(ULONG)))) {
        
        //
        // Miniport could not fit registration information into the
        // pre-shrunk buffer.
        //
        // Buffer currently contains a ULONG specifying required buffer
        // size of miniport registration info, but does not include the
        // SCSIPORT registration info's size.  Add it in.
        //
        if (spWmiRegInfoBufSize && !wmiUpdateRequest) {

            *((ULONG*)WmiParameters->Buffer) += spWmiRegInfoBufSize;

            //
            // Add an extra 7 bytes (possibly extraneous) which is used to
            // ensure that the piggybacked data structure 8-byte aligned.
            //
            *((ULONG*)WmiParameters->Buffer) += 7;
        }

        //
        // Add in size of the miniport registry path.
        //
        *((ULONG*)WmiParameters->Buffer) += countedRegistryPathSize;

        //
        // Return STATUS_SUCCESS, even though this is a BUFFER TOO
        // SMALL failure, while ensuring retSz = sizeof(ULONG), as
        // the WMI protocol calls us to do.
        //
        retSz  = sizeof(ULONG);
        status = STATUS_SUCCESS;

    } else if ( NT_SUCCESS(status) ) {

        DebugPrint((SP_WMI_EVENT, "SpWmiIrpRegisterRequest: add scsiport stuff...\n"));
        
        //
        // Zero or more WMIREGINFOs exist in buffer from miniport.
        //

        //
        // Piggyback the miniport registry path transparently, if at least one
        // WMIREGINFO was returned by the minport.
        //
        if (retSz) {

            ULONG offsetToRegPath  = retSz;
            PWMIREGINFO wmiRegInfo = WmiParameters->Buffer;

            DebugPrint((SP_WMI_EVENT, "SpWmiIrpRegisterRequest: piggybacking...\n"));

            //
            // Build a counted wide-character string, containing the
            // registry path, into the WMI buffer.
            //
            *( (PUSHORT)( (PUCHAR)WmiParameters->Buffer + retSz ) ) =
                driverExtension->RegistryPath.Length,
            RtlCopyMemory( (PUCHAR)WmiParameters->Buffer + retSz + sizeof(USHORT),
                           driverExtension->RegistryPath.Buffer,
                           driverExtension->RegistryPath.Length);

            //
            // Traverse the WMIREGINFO structures returned by the mini-
            // driver and set the missing RegistryPath fields to point
            // to our registry path location. We also jam in the PDO for
            // the device stack so that the device instance name is used for
            // the wmi instance names.
            //
            pDO = commonExtension->IsPdo ? DeviceObject :
                            ((PADAPTER_EXTENSION)commonExtension)->LowerPdo;

            while (1) {
                wmiRegInfo->RegistryPath = offsetToRegPath;

                for (i = 0; i < wmiRegInfo->GuidCount; i++)
                {
                    if ((wmiRegInfo->WmiRegGuid[i].Flags & (WMIREG_FLAG_INSTANCE_BASENAME |
                                                           WMIREG_FLAG_INSTANCE_LIST)) != 0)
                    {
                        wmiRegInfo->WmiRegGuid[i].InstanceInfo = (ULONG_PTR)pDO;
                        wmiRegInfo->WmiRegGuid[i].Flags &= ~(WMIREG_FLAG_INSTANCE_BASENAME |
                                                          WMIREG_FLAG_INSTANCE_LIST);
                        wmiRegInfo->WmiRegGuid[i].Flags |= WMIREG_FLAG_INSTANCE_PDO;
                    }
                }

                if (wmiRegInfo->NextWmiRegInfo == 0) {
                    break;
                }

                offsetToRegPath -= wmiRegInfo->NextWmiRegInfo;
                wmiRegInfo = (PWMIREGINFO)( (PUCHAR)wmiRegInfo +
                                            wmiRegInfo->NextWmiRegInfo );
            }

            //
            // Adjust retSz to reflect new size of the WMI buffer.
            //
            retSz += countedRegistryPathSize;
            wmiRegInfo->BufferSize = retSz;
        } // else, no WMIREGINFOs registered whatsoever, nothing to piggyback

        //
        // Do we have any SCSIPORT WMIREGINFOs to piggyback?
        //
        if (spWmiRegInfoBufSize && !wmiUpdateRequest) {

            //
            // Adjust retSz so that the data we piggyback is 8-byte aligned
            // (safe if retSz = 0).
            //
            retSz = (retSz + 7) & ~7;

            //
            // Piggyback SCSIPORT's registration info into the buffer.
            //
            RtlCopyMemory( (PUCHAR)WmiParameters->Buffer + retSz,
                           spWmiRegInfoBuf,
                           spWmiRegInfoBufSize);

            //
            // Was at least one WMIREGINFO returned by the minidriver?
            // Otherwise, we have nothing else to add to the WMI buffer.
            //
            if (retSz) { // at least one WMIREGINFO returned by minidriver
                PWMIREGINFO wmiRegInfo = WmiParameters->Buffer;

                //
                // Traverse to the end of the WMIREGINFO structures returned
                // by the miniport.
                //
                while (wmiRegInfo->NextWmiRegInfo) {
                    wmiRegInfo = (PWMIREGINFO)( (PUCHAR)wmiRegInfo +
                                                wmiRegInfo->NextWmiRegInfo );
                }

                //
                // Chain minidriver's WMIREGINFO structures to SCSIPORT's
                // WMIREGINFO structures.
                //
                wmiRegInfo->NextWmiRegInfo = retSz -
                                             (ULONG)((PUCHAR)wmiRegInfo - (PUCHAR)WmiParameters->Buffer);
            }

            //
            // Adjust retSz to reflect new size of the WMI buffer.
            //
            retSz += spWmiRegInfoBufSize;

        } // we had SCSIPORT REGINFO data to piggyback
    } // else, unknown error, complete IRP with this error status

    //
    // Save new buffer size to WmiParameters->BufferSize.
    //
    WmiParameters->BufferSize = retSz;

    DebugPrint((SP_WMI_EVENT, "SpWmiIrpRegisterRequest: done status %08x WMIParams %p\n",
                status, WmiParameters));

    return status;
}


NTSTATUS
SpWmiHandleOnMiniPortBehalf(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters
    )

/*++

Routine Description:

   Handle the WMI request on the miniport's behalf, if possible.

Arguments:

   DeviceObject  - Pointer to the functional or physical device object.

   WmiMinorCode  - WMI action to perform.

   WmiParameters - WMI parameters.

Return Value:

   If STATUS_UNSUCCESSFUL is returned, SCSIPORT did not handle this WMI
   request.  It must be passed on to the miniport driver for processing.

   Otherwise, this function returns an NTSTATUS code describing the result
   of handling the WMI request.  Complete the IRP with this status.

Notes:

   If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
   BufferSize field will reflect the actual size of the WMI return buffer.

--*/
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    if (commonExtension->IsPdo) {
        //
        /// Placeholder for code to check if this is a PDO-relevant GUID which
        //  SCSIPORT must handle, and handle it if so.
        //
    } else { // FDO

        NTSTATUS status;
        GUID guid = *(GUID*)WmiParameters->DataPath;
        PADAPTER_EXTENSION Adapter = (PADAPTER_EXTENSION) commonExtension;
        SIZE_T size;

        DebugPrint((SP_WMI_EVENT, "SpWmiHandleOnMiniPortBehalf: WmiMinorCode:%x guid:"
                       "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\n",
                    WmiMinorCode,
                    guid.Data1,
                    guid.Data2,
                    guid.Data3,
                    guid.Data4[0],
                    guid.Data4[1],
                    guid.Data4[2],
                    guid.Data4[3],
                    guid.Data4[4],
                    guid.Data4[5],
                    guid.Data4[6],
                    guid.Data4[7]));

        //
        // Check the guid to verify that it represents a data block supported
        // by scsiport.  If it does not, we return failure and let the
        // miniports have a look at it.
        //

        size = RtlCompareMemory(&guid, 
                                &Adapter->SenseDataEventClass,
                                sizeof(GUID)); 
        if (size != sizeof(GUID)) {

            //
            // WMI spec says to fail the irp w/ STATUS_WMI_GUID_NOT_FOUND if the
            // guid does not represent a data block we understand.
            //

            DebugPrint((SP_WMI_EVENT, "SpWmiHandleOnMiniPortBehalf: not handling data block\n"));
            return STATUS_WMI_GUID_NOT_FOUND;
        }

        //
        // Handle the request.  At this point, we've decided that the IRP
        // is intended for this device and that this is a datablock 
        // supported by the device.  Therefore, the code below returns the 
        // appropriate result as per the wmi spec.
        //

        switch (WmiMinorCode) {
        case IRP_MN_QUERY_ALL_DATA:
        case IRP_MN_QUERY_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_ITEM:
        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        case IRP_MN_REGINFO:
        case IRP_MN_EXECUTE_METHOD:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        
        case IRP_MN_ENABLE_EVENTS:
            DebugPrint((SP_WMI_EVENT, "SenseData event enabled\n"));
            Adapter->EnableSenseDataEvent = TRUE;
            WmiParameters->BufferSize = 0;
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_DISABLE_EVENTS:
            DebugPrint((SP_WMI_EVENT, "SenseData event disabled\n"));
            Adapter->EnableSenseDataEvent = FALSE;
            WmiParameters->BufferSize = 0;
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        };

        return status;

    }

    return STATUS_WMI_GUID_NOT_FOUND;
}


NTSTATUS
SpWmiPassToMiniPort(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters
    )
/*++

Routine Description:

   This function pass a WMI request to the miniport driver for processing.
   It creates an SRB which is processed normally by the port driver.  This
   call is synchronous.

   Callers of SpWmiPassToMiniPort must be running at IRQL PASSIVE_LEVEL.

Arguments:

   DeviceObject  - Pointer to the functional or physical device object.

   WmiMinorCode  - WMI action to perform.

   WmiParameters - WMI parameters.

Return Value:

   An NTSTATUS code describing the result of handling the WMI request.
   Complete the IRP with this status.

Notes:

   If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
   BufferSize field will reflect the actual size of the WMI return buffer.

--*/
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PADAPTER_EXTENSION fdoExtension;
    SCSI_WMI_REQUEST_BLOCK   srb;
    LARGE_INTEGER            startingOffset;
    PLOGICAL_UNIT_EXTENSION  logicalUnit;

    ULONG                    commonBufferSize;
    PUCHAR                   commonBuffer;
    PHYSICAL_ADDRESS         physicalAddress;
    PVOID                    removeTag = (PVOID)((ULONG_PTR)WmiParameters+3);
    PWNODE_HEADER            wnode;

    NTSTATUS status;

    PAGED_CODE();

    startingOffset.QuadPart = (LONGLONG) 1;

    //
    // Zero out the SRB.
    //
    RtlZeroMemory(&srb, sizeof(SCSI_WMI_REQUEST_BLOCK));

    //
    // Initialize the SRB for a WMI request.
    //
    if (commonExtension->IsPdo) {                                       // [PDO]

        //
        // Set the logical unit addressing from this PDO's device extension.
        //
        logicalUnit = DeviceObject->DeviceExtension;

        SpAcquireRemoveLock(DeviceObject, removeTag);

        srb.PathId      = logicalUnit->PathId;
        srb.TargetId    = logicalUnit->TargetId;
        srb.Lun         = logicalUnit->Lun;

        fdoExtension = logicalUnit->AdapterExtension;

    } else {                                                            // [FDO]

        //
        // Set the logical unit addressing to the first logical unit.  This is
        // merely used for addressing purposes for adapter requests only.
        // NOTE: SpFindSafeLogicalUnit will acquire the remove lock
        //

        logicalUnit = SpFindSafeLogicalUnit(DeviceObject,
                                            0xff,
                                            removeTag);

        if (logicalUnit == NULL) {
            return(STATUS_DEVICE_DOES_NOT_EXIST);
        }

        fdoExtension = DeviceObject->DeviceExtension;

        srb.WMIFlags    = SRB_WMI_FLAGS_ADAPTER_REQUEST;
        srb.PathId      = logicalUnit->PathId;
        srb.TargetId    = logicalUnit->TargetId;
        srb.Lun         = logicalUnit->Lun;
    }

    //
    // HACK - allocate a chunk of common buffer for the actual request to
    // get processed in. We need to determine the size of buffer to allocate
    // this is the larger of the input or output buffers
    //

    if (WmiMinorCode == IRP_MN_EXECUTE_METHOD)
    {
        wnode = (PWNODE_HEADER)WmiParameters->Buffer;
        commonBufferSize = (WmiParameters->BufferSize > wnode->BufferSize) ?
                            WmiParameters->BufferSize :
                            wnode->BufferSize;
    } else {
        commonBufferSize = WmiParameters->BufferSize;
    }

    commonBuffer = AllocateCommonBuffer(fdoExtension->DmaAdapterObject,
                                        commonBufferSize,
                                        &physicalAddress,
                                        FALSE);

    if(commonBuffer == NULL) {
        DebugPrint((SP_WMI_EVENT, "SpWmiPassToMiniPort: Unable to allocate %#x bytes of "
                       "common buffer\n", commonBufferSize));

        SpReleaseRemoveLock(logicalUnit->DeviceObject, removeTag);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {
        KEVENT event;
        PIRP irp;
        PMDL mdl;
        PIO_STACK_LOCATION irpStack;

        RtlCopyMemory(commonBuffer, WmiParameters->Buffer, commonBufferSize);

        srb.DataBuffer         = commonBuffer;       // [already non-paged]
        srb.DataTransferLength = WmiParameters->BufferSize;
        srb.Function           = SRB_FUNCTION_WMI;
        srb.Length             = sizeof(SCSI_REQUEST_BLOCK);
        srb.WMISubFunction     = WmiMinorCode;
        srb.DataPath           = WmiParameters->DataPath;
        srb.SrbFlags           = SRB_FLAGS_DATA_IN | SRB_FLAGS_NO_QUEUE_FREEZE;
        srb.TimeOutValue       = 10;                                // [ten seconds]

        //
        // Note that the value in DataBuffer may be used regardless of the value
        // of the MapBuffers field.
        //

        //
        // Initialize the notification event.
        //

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        //
        // Build IRP for this request.
        // Note we do this synchronously for two reasons.  If it was done
        // asynchonously then the completion code would have to make a special
        // check to deallocate the buffer.  Second if a completion routine were
        // used then an additional IRP stack location would be needed.
        //

        irp = SpAllocateIrp(logicalUnit->DeviceObject->StackSize, FALSE, DeviceObject->DriverObject);

        if(irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        mdl = SpAllocateMdl(commonBuffer,
                            WmiParameters->BufferSize,
                            FALSE,
                            FALSE,
                            irp,
                            DeviceObject->DriverObject);

        if(mdl == NULL) {
            IoFreeIrp(irp);
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        MmBuildMdlForNonPagedPool(mdl);

        srb.OriginalRequest = irp;

        irpStack = IoGetNextIrpStackLocation(irp);

        //
        // Set major code.
        //
        irpStack->MajorFunction = IRP_MJ_SCSI;

        //
        // Set SRB pointer.
        //
        irpStack->Parameters.Scsi.Srb = (PSCSI_REQUEST_BLOCK)&srb;

        //
        // Setup a completion routine so we know when the request has completed.
        //

        IoSetCompletionRoutine(irp,
                               SpSignalCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Flush the data buffer for output.  This will insure that the data is
        // written back to memory.  Since the data-in flag is the the port driver
        // will flush the data again for input which will ensure the data is not
        // in the cache.
        //
        KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);

        //
        // Call port driver to handle this request.
        //
        IoCallDriver(logicalUnit->CommonExtension.DeviceObject, irp);

        //
        // Wait for request to complete.
        //
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = irp->IoStatus.Status;

        //
        // Relay the return buffer's size to the caller on success.
        //
        if (NT_SUCCESS(status)) {
            WmiParameters->BufferSize = srb.DataTransferLength;
        }

        //
        // Copy back the correct number of bytes into the caller provided buffer.
        //

        RtlCopyMemory(WmiParameters->Buffer,
                      commonBuffer,
                      WmiParameters->BufferSize);

        //
        // Free the irp and MDL.
        //

        IoFreeMdl(mdl);
        IoFreeIrp(irp);

    } finally {

        FreeCommonBuffer(fdoExtension->DmaAdapterObject,
                         commonBufferSize,
                         physicalAddress,
                         commonBuffer,
                         FALSE);

        SpReleaseRemoveLock(logicalUnit->CommonExtension.DeviceObject,
                            removeTag);
    }

    //
    // Return the IRP's status.
    //
    return status;
}


VOID
SpWmiGetSpRegInfo(
    IN  PDEVICE_OBJECT DeviceObject,
    OUT PWMIREGINFO  * SpRegInfoBuf,
    OUT ULONG        * SpRegInfoBufSize
    )
/*++

Routine Description:

   This function retrieves a pointer to the WMI registration information
   buffer for the given device object.

Arguments:

   DeviceObject     - Pointer to the functional or physical device object.

Return Values:

   SpRegInfoBuf     - Pointer to the registration information buffer, which
                      will point to the WMIREGINFO structures that SCSIPORT
                      should register on behalf of the miniport driver.

   SpRegInfoBufSize - Size of the registration information buffer in bytes.

--*/
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // Retrieve a pointer to the WMI registration information buffer for the
    // given device object.
    //
    if (commonExtension->WmiScsiPortRegInfoBuf     == NULL ||
        commonExtension->WmiScsiPortRegInfoBufSize == 0) {
        *SpRegInfoBuf     = NULL;
        *SpRegInfoBufSize = 0;
    } else {
        *SpRegInfoBuf     = commonExtension->WmiScsiPortRegInfoBuf;
        *SpRegInfoBufSize = commonExtension->WmiScsiPortRegInfoBufSize;
    }

    return;
}


VOID
SpWmiInitializeSpRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject
    )

/*++

Routine Description:

   This function allocates space for and builds the WMI registration
   information buffer for this device object.

   The WMI registration information consists of zero or more WMIREGINFO
   structures which are used to register and identify SCSIPORT-handled
   WMI GUIDs on behalf of the miniport driver. This information is not
   the complete set of WMI GUIDs supported by for device object,  only
   the ones supported by SCSIPORT.  It is actually piggybacked onto the
   WMIREGINFO structures provided by the miniport driver during
   registration.

   The WMI registration information is allocated and stored on a
   per-device basis because, concievably, each device may support
   differing WMI GUIDs and/or instances during its lifetime.

Arguments:

   DeviceObject   - Pointer to the functional or physical device object.

Return Value:

   None.

--*/
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    ASSERT(commonExtension->WmiScsiPortRegInfoBuf     == NULL);
    ASSERT(commonExtension->WmiScsiPortRegInfoBufSize == 0);

    if (commonExtension->IsPdo) {

        //
        /// Placeholder for code to build PDO-relevant GUIDs into the
        //  registration buffer.
        //
        /// commonExtension->WmiScsiPortRegInfo     = ExAllocatePool( PagedPool, <size> );
        //  commonExtension->WmiScsiPortRegInfoSize = <size>;
        //  <code to fill in wmireginfo struct(s) into buffer>
        //
        //  * use L"SCSIPORT" as the RegistryPath
    
    } else { // FDO
        
        BOOLEAN DoesSenseEvents;
        GUID SenseDataClass;

        //
        // Determine if the supplied adapter is configured to generate sense
        // data events.  If it is, copy the guid into the adapter extension
        // and initialize the WMIREGINFO structure pointed to by the
        // adapter extension.
        //

        DoesSenseEvents = SpAdapterConfiguredForSenseDataEvents(
                              DeviceObject,
                              &SenseDataClass);
        if (DoesSenseEvents) {
            ((PADAPTER_EXTENSION)commonExtension)->SenseDataEventClass = SenseDataClass;
            SpInitAdapterWmiRegInfo(DeviceObject);
        }
    }

    return;
}


VOID
SpWmiDestroySpRegInfo(
    IN  PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

   This function de-allocates the space for the WMI registration information
   buffer for this device object, if one exists.

Arguments:

   DeviceObject - Pointer to the functional or physical device object.

Return Value:

   None.

--*/
{
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    if (commonExtension->WmiScsiPortRegInfoBuf) {
        ExFreePool(commonExtension->WmiScsiPortRegInfoBuf);
        commonExtension->WmiScsiPortRegInfoBuf = NULL;
    }

    commonExtension->WmiScsiPortRegInfoBufSize = 0;

    return;
}


NTSTATUS
SpWmiInitializeFreeRequestList(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG          NumberOfItems
    )
/*++

Routine Description:

    Call that initializes the WmiFreeMiniPortRequestList, this call MUST
    be completed prior to any manipulatio of the WmiFreeMiniPortRequestList

    The list will be initialized with at most the number of cells requested.

    If the list has already been initialized, we raise the watermark by the number
    of Items requested.

Arguments:

    DeviceObject    - Device Object that this list belongs to
    NumberOfItems   - requested number of free cells

Return Value:

    Return the SUCESS if list was initialized succesfully

    STATUS_INSUFFICIENT_REOSOURCES  - Indicates that we could not allocate
                                      enough memory for the list header

Notes:


--*/
{
    PADAPTER_EXTENSION  fdoExtension;
    ULONG               itemsInserted;
    KIRQL               oldIrql;

    PAGED_CODE();               // Routine is paged until locked down.

    //
    // Obtain a pointer to the functional device extension (for the adapter).
    //
    if ( ((PCOMMON_EXTENSION)DeviceObject->DeviceExtension)->IsPdo ) {
        fdoExtension = ((PLOGICAL_UNIT_EXTENSION)DeviceObject->DeviceExtension)
                       ->AdapterExtension;
    } else {
        fdoExtension = DeviceObject->DeviceExtension;
    }

    // If the list has been initalized increase the watermark
    if (fdoExtension->WmiFreeMiniPortRequestInitialized) {
        DebugPrint((SP_WMI_EVENT, "SpWmiInitializeFreeRequestList:"
                    " Increased watermark for : %p\n", fdoExtension));

        InterlockedExchangeAdd
            (&(fdoExtension->WmiFreeMiniPortRequestWatermark),
             NumberOfItems);

        while (fdoExtension->WmiFreeMiniPortRequestCount <
            fdoExtension->WmiFreeMiniPortRequestWatermark) {

            // Add free cells until the count reaches the watermark
            SpWmiPushFreeRequestItem(fdoExtension);
        }

        return (STATUS_SUCCESS);
    }

    // Only FDO's should be calling when the list has not been initialized
    ASSERT_FDO(DeviceObject);

    // Assignt he list we just initialized to the pointer in the
    // fdoExtension (and save the lock pointer also)
    KeInitializeSpinLock(&(fdoExtension->WmiFreeMiniPortRequestLock));
    ExInitializeSListHead(&(fdoExtension->WmiFreeMiniPortRequestList));

    DebugPrint((SP_WMI_EVENT, "SpWmiInitializeFreeRequestList:"
                " Initialized WmiFreeRequestList for: %p\n", fdoExtension));

    // Set the initialized flag
    fdoExtension->WmiFreeMiniPortRequestInitialized = TRUE;

    // Set the watermark, and the count to 0
    fdoExtension->WmiFreeMiniPortRequestWatermark = 0;
    fdoExtension->WmiFreeMiniPortRequestCount = 0;

    // Attempt to add free cells to the free list
    for (itemsInserted = 0; itemsInserted < NumberOfItems;
         itemsInserted++) {

        // Make a request to push a NULL item, so that the
        // allocation will be done by the next function
        //
        // At this point we don't care about the return value
        // because after we set the watermark, scsiport's free-cell
        // repopulation code will try to get the free list cell count
        // back to the watermark. (So if we fail to add all the requested
        // free cells, the repopulation code will attempt again for us
        // at a later time)
        SpWmiPushFreeRequestItem(fdoExtension);
    }


    // Now set the watermark to the correct value
    fdoExtension->WmiFreeMiniPortRequestWatermark = NumberOfItems;

    return(STATUS_SUCCESS);
}

VOID
SpWmiPushExistingFreeRequestItem(
    IN PADAPTER_EXTENSION Adapter,
    IN PWMI_MINIPORT_REQUEST_ITEM WmiRequestItem
    )
/*++

Routine Description:

    Inserts the entry into the interlocked list of free request items.

Arguments:

    WmiRequestItem - Pointer to the request item to insert into the free list.

Return Value:

    VOID

--*/
{
    //
    // The WMI request list must be initialized.
    //

    if (!Adapter->WmiFreeMiniPortRequestInitialized) {
        ASSERT(FALSE);
        return;
    }

    //
    // This request doesn't point to another one.
    //

    WmiRequestItem->NextRequest = NULL;

    //
    // Insert Cell into interlocked list.
    //

    ExInterlockedPushEntrySList(
        &(Adapter->WmiFreeMiniPortRequestList),
        (PSLIST_ENTRY)WmiRequestItem,
        &(Adapter->WmiFreeMiniPortRequestLock));

    //
    // Increment the value of the free count.
    //
    
    InterlockedIncrement(&(Adapter->WmiFreeMiniPortRequestCount));
}

NTSTATUS
SpWmiPushFreeRequestItem(
    IN PADAPTER_EXTENSION           fdoExtension
    )
/*++

Routine Description:

    Inserts the Entry into the interlocked SLIST.  (Of Free items)

Arguments:

    fdoExtension        - The extension on the adapter

Return Value:

    STATUS_SUCESS                   - If succesful
    STATUS_INSUFFICIENT_RESOURCES   - If memory allocation fails
    STATUS_UNSUCCESSFUL             - Free List not initialized

Notes:

    This code cannot be marked as pageable since it will be called from
    DPC level

    Theoricatlly this call can fail, but no one should call this function
    before we've been initialized

--*/
{
    PWMI_MINIPORT_REQUEST_ITEM      Entry = NULL;

    if (!fdoExtension->WmiFreeMiniPortRequestInitialized) {
        return (STATUS_UNSUCCESSFUL);
    }

    Entry = SpAllocatePool(NonPagedPool,
                           sizeof(WMI_MINIPORT_REQUEST_ITEM),
                           SCSIPORT_TAG_WMI_EVENT,
                           fdoExtension->DeviceObject->DriverObject);

    if (!Entry) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Entry->NextRequest = NULL;

    // Insert Cell into interlocked list
    ExInterlockedPushEntrySList(
        &(fdoExtension->WmiFreeMiniPortRequestList),
        (PSLIST_ENTRY)Entry,
        &(fdoExtension->WmiFreeMiniPortRequestLock));

    // Increment the value of the free count
    InterlockedIncrement(&(fdoExtension->WmiFreeMiniPortRequestCount));

    return(STATUS_SUCCESS);
}


PWMI_MINIPORT_REQUEST_ITEM
SpWmiPopFreeRequestItem(
    IN PADAPTER_EXTENSION           fdoExtension
    )
/*++

Routine Description:

    Pops an Entry from the interlocked SLIST.  (Of Free items)

Arguments:

    fdoExtension     - The extension on the adapter

Return Value:

    A pointer to a REQUEST_ITEM or NULL if none are available

Notes:

    This code cannot be paged, it will be called a DIRLQL

--*/
{
    PWMI_MINIPORT_REQUEST_ITEM              requestItem;

    if (!fdoExtension->WmiFreeMiniPortRequestInitialized) {
        return (NULL);
    }

    // Pop Cell from interlocked list
    requestItem = (PWMI_MINIPORT_REQUEST_ITEM)
        ExInterlockedPopEntrySList(
            &(fdoExtension->WmiFreeMiniPortRequestList),
            &(fdoExtension->WmiFreeMiniPortRequestLock));


    if (requestItem) {
        // Decrement the count of free cells
        InterlockedDecrement(&(fdoExtension->WmiFreeMiniPortRequestCount));

    }

    return (requestItem);
}



BOOLEAN
SpWmiRemoveFreeMiniPortRequestItems(
    IN PADAPTER_EXTENSION   fdoExtension
    )

/*++

Routine Description:

   This function removes WMI_MINIPORT_REQUEST_ITEM structures from the "free"
   queue of the adapter extension.

   It removed all the free cells.

Arguments:

    fdoExtension    - The device_extension

Return Value:

   TRUE always.

--*/

{
    PWMI_MINIPORT_REQUEST_ITEM   tmpRequestItem;
    PWMI_MINIPORT_REQUEST_ITEM   wmiRequestItem;

    //
    // Set the watermark to 0
    // No need to grab a lock we're just setting it
    fdoExtension->WmiFreeMiniPortRequestWatermark = 0;

    DebugPrint((SP_WMI_EVENT, "SpWmiRemoveFreeMiniPortRequestItems: Removing %p", fdoExtension));


    //
    // Walk the queue of items and de-allocate as many as we need to.
    //
    for (;;) {
        // Pop
        wmiRequestItem = SpWmiPopFreeRequestItem(fdoExtension);
        if (wmiRequestItem == NULL) {
            break;
        } else {
            ExFreePool(wmiRequestItem);
        }
    }

    return TRUE;
}

const GUID GUID_NULL = { 0 };

BOOLEAN
SpAdapterConfiguredForSenseDataEvents(
    IN PDEVICE_OBJECT DeviceObject,
    OUT GUID *SenseDataClass
    )

/*++

Routine Description:

   This function answers whether a specified device is configured to generate
   sense data events.  This is determined by the presense of a string value
   containing the GUID for the event class responsible for generating the
   events.

Arguments:

    DeviceObject    - Points to the device object
    
    SenseDataClass  - Points to a GUID into which the sense data class,
                      if found, is copied.  If none is found, GUID_NULL is
                      copied into the location.
                      
                      If the function's return value is FALSE, SenseDataClass
                      will be set to GUID_NULL.

Return Value:

   Answers TRUE if a GUID is registed for the device.  Otherwise, returns
   FALSE.

--*/

{
    NTSTATUS status;
    PADAPTER_EXTENSION adapterExtension = DeviceObject->DeviceExtension;
    HANDLE instanceHandle = NULL;    
    HANDLE handle = NULL;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    UNICODE_STRING unicodeString;
    UNICODE_STRING stringValue;
    OBJECT_ATTRIBUTES objectAttributes;

    //
    // Initialize the guid pointed to by SenseDataClass to GUID_NULL.
    //

    *SenseDataClass = GUID_NULL;

    //
    // If this isn't a pnp device, don't attempt to determine
    // if it supports sense data events.  Just return FALSE.
    //

    if (!adapterExtension->IsPnp) {

        return FALSE;

    }

    //
    // Open the device registry key.
    //

    status = IoOpenDeviceRegistryKey(adapterExtension->LowerPdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_ALL_ACCESS,
                                     &instanceHandle);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // Open the scsiport subkey under the device's Device Parameters key.
    //

    RtlInitUnicodeString(&unicodeString, L"Scsiport");
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        instanceHandle,
        NULL);

    status = ZwOpenKey(&handle,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Read the device's sense data class guid.  We have to initialize the 
    // maximum size of the string and init the buffer to NULL so 
    // RtlQueryRegistryValues will allocate a buffer for us.  If the specified 
    // value is not in the registry, the query will fail
    //

    stringValue.MaximumLength = 40;
    stringValue.Buffer = NULL;
    RtlZeroMemory(queryTable, sizeof(queryTable));

    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = L"SenseDataEventClass";
    queryTable[0].EntryContext = &stringValue;

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                                    (PWSTR) handle,
                                    queryTable,
                                    NULL,
                                    NULL);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }
    
    //
    // Convert the registry string to a GUID.
    //

    ASSERT(stringValue.Buffer);
    status = RtlGUIDFromString(&stringValue, SenseDataClass);
    ExFreePool(stringValue.Buffer);

cleanup:

    if(handle != NULL) {
        ZwClose(handle);
    }

    ASSERT(instanceHandle != NULL);
    ZwClose(instanceHandle);

    return (NT_SUCCESS(status)) ? TRUE : FALSE;
}
        
NTSTATUS
SpInitAdapterWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

   This function initializes a the WMIREGINFO structure pointed to by the
   specified device's extension.  This structure will be used later
   to register scsiport to handle WMI IRPs on behalf of the device.

Arguments:

    DeviceObject    - The device object
    
Return Value:

   STATUS_SUCCESS
   
   STATUS_INSUFFICIENT_RESOURCES

--*/

{
    ULONG TotalSize;
    PWMIREGINFO TempInfo;
    PWCHAR TempString;
    ULONG OffsetToRegPath;
    ULONG OffsetToRsrcName;
    PADAPTER_EXTENSION adapterExtension = DeviceObject->DeviceExtension;
    PCOMMON_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    //
    // The registry path name follows the WMIREGINFO struct and the
    // contiguous array of WMIREGGUIDW structs.
    //

    OffsetToRegPath = sizeof(WMIREGINFO) + sizeof(WMIREGGUIDW);

    //
    // The name of the resource follows the registry path name and
    // its size.
    //

    OffsetToRsrcName = OffsetToRegPath + 
                       sizeof(WCHAR) + 
                       sizeof(SPMOFREGISTRYPATH);

    //
    // The total size of the block of memory we need to allocate is the size
    // of the WMIREGINFO struct, plus the size of however many WMIREGGUIDW
    // structs we need, plus the size of the registry path and and resource
    // name strings.  The size is aligned on an 8 byte boundary.
    //

    TotalSize = OffsetToRsrcName + 
                sizeof(WCHAR) +
                sizeof(SPMOFRESOURCENAME);
    TotalSize = (TotalSize + 7) & ~7;

    //
    // Try to allocate the memory.
    //

    TempInfo = SpAllocatePool(NonPagedPool,
                              TotalSize,
                              SCSIPORT_TAG_WMI_EVENT,
                              DeviceObject->DriverObject);

    if (TempInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the WMIREGINFO struct.
    //

    TempInfo->BufferSize = TotalSize;
    TempInfo->NextWmiRegInfo = 0;
    TempInfo->RegistryPath = OffsetToRegPath;
    TempInfo->MofResourceName = OffsetToRsrcName;

    TempString = (PWCHAR)((ULONG_PTR)TempInfo + OffsetToRegPath);
    *TempString++ = sizeof(SPMOFREGISTRYPATH);
    RtlCopyMemory(TempString, 
                  SPMOFREGISTRYPATH, 
                  sizeof(SPMOFREGISTRYPATH));

    TempString = (PWCHAR)((ULONG_PTR)TempInfo + OffsetToRsrcName);
    *TempString++ = sizeof(SPMOFRESOURCENAME);
    RtlCopyMemory(TempString, 
                  SPMOFRESOURCENAME, 
                  sizeof(SPMOFRESOURCENAME));

    TempInfo->GuidCount = 1;

    TempInfo->WmiRegGuid[0].Guid = adapterExtension->SenseDataEventClass;
    TempInfo->WmiRegGuid[0].Flags = 
        WMIREG_FLAG_INSTANCE_PDO | WMIREG_FLAG_EVENT_ONLY_GUID;
    TempInfo->WmiRegGuid[0].InstanceCount = 1;

    //
    // This must be a physical device object.
    //

    TempInfo->WmiRegGuid[0].Pdo = (ULONG_PTR) adapterExtension->LowerPdo;

    //
    // Update the common extension members.
    //

    commonExtension->WmiScsiPortRegInfoBuf = TempInfo;
    commonExtension->WmiScsiPortRegInfoBufSize = TotalSize;

    DebugPrint((SP_WMI_EVENT, "SpInitAdapterWmiRegInfo: commonExtension %p "
                "WmiScsiPortRegInfoBuf %p WmiScsiPortRegInfoBufSize %x\n",
                commonExtension,
                commonExtension->WmiScsiPortRegInfoBuf,
                commonExtension->WmiScsiPortRegInfoBufSize));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\scsiwmi\wmilib.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    wmilib.c

Abstract:

    WMI library utility functions for SCSI miniports

    CONSIDER adding the following functionality to the library:
        * Different instance names for different guids

Author:

    AlanWar

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "miniport.h"
#include "scsi.h"
#include "wmistr.h"
#include "scsiwmi.h"

typedef enum
{
    ScsiProcessed,    // Srb was processed and possibly completed
    ScsiNotCompleted, // Srb was process and NOT completed
    ScsiNotWmi,       // Srb is not a WMI irp
    ScsiForward       // Srb is wmi irp, but targeted at another device object
} SYSCTL_SCSI_DISPOSITION, *PSYSCTL_SCSI_DISPOSITION;


BOOLEAN
ScsiWmipFindGuid(
    IN PSCSIWMIGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    );

BOOLEAN
ScsiWmipFindGuid(
    IN PSCSIWMIGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid

    *InstanceCount returns the count of instances for the guid

Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, GuidList[i].Guid))
        {
            *GuidIndex = i;
            *InstanceCount = GuidList[i].InstanceCount;

            return(TRUE);
        }
    }

    return(FALSE);
}


UCHAR ScsiWmipPostProcess(
    IN UCHAR MinorFunction,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG BufferUsed,
    IN UCHAR Status,
    OUT PULONG ReturnSize
    )
{    
    ULONG retSize;

    switch(MinorFunction)
    {
        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;
            ULONG instanceCount;
            POFFSETINSTANCEDATAANDLENGTH offsetInstanceDataAndLength;
            ULONG i;
            PULONG instanceLengthArray;
            ULONG dataBlockOffset;

            wnode = (PWNODE_ALL_DATA)Buffer;

            dataBlockOffset = wnode->DataBlockOffset;
            instanceCount = wnode->InstanceCount;
            bufferNeeded = dataBlockOffset + BufferUsed;

            if ((Status == SRB_STATUS_SUCCESS) &&
                (bufferNeeded > BufferSize))
            {
                Status = SRB_STATUS_DATA_OVERRUN;
            }
        
            if (Status != SRB_STATUS_SUCCESS)
            {
                if (Status == SRB_STATUS_DATA_OVERRUN)
                {
                    wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                    wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                    wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                    wnodeTooSmall->SizeNeeded = bufferNeeded;

                    retSize = sizeof(WNODE_TOO_SMALL);
                    Status = SRB_STATUS_SUCCESS;
                } else {
                    retSize = 0;
                }
                break;
            }

            wnode->WnodeHeader.BufferSize = bufferNeeded;
            retSize = bufferNeeded;

            if ((wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) ==
                  WNODE_FLAG_STATIC_INSTANCE_NAMES)
            {
                instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
                offsetInstanceDataAndLength = (POFFSETINSTANCEDATAANDLENGTH)instanceLengthArray;

                for (i = instanceCount; i != 0; i--)
                {
                    offsetInstanceDataAndLength[i-1].LengthInstanceData = instanceLengthArray[i-1];
                }

                for (i = 0; i < instanceCount; i++)
                {
                    offsetInstanceDataAndLength[i].OffsetInstanceData = dataBlockOffset;
                    dataBlockOffset = (dataBlockOffset + offsetInstanceDataAndLength[i].LengthInstanceData + 7) & ~7;
                }
            }

            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_SINGLE_INSTANCE)Buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (Status == SRB_STATUS_SUCCESS)
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;

                ASSERT(wnode->SizeDataBlock == BufferUsed);

            } else if (Status == SRB_STATUS_DATA_OVERRUN) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = SRB_STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_METHOD_ITEM)Buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (Status == SRB_STATUS_SUCCESS)
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                wnode->SizeDataBlock = BufferUsed;

            } else if (Status == SRB_STATUS_DATA_OVERRUN) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = SRB_STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        default:
        {
            //
            // All other requests don't return any data
            retSize = 0;
            break;
        }
    }
    *ReturnSize = retSize;
    return(Status);
}
    

VOID
ScsiPortWmiPostProcess(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN UCHAR Status,
    IN ULONG BufferUsed
    )
{    
    ASSERT(RequestContext != NULL);
    RequestContext->ReturnStatus = ScsiWmipPostProcess(
                                        RequestContext->MinorFunction,
                                        RequestContext->Buffer,
                                        RequestContext->BufferSize,
                                        BufferUsed,
                                        Status,
                                        &RequestContext->ReturnSize);
}
       

UCHAR 
ScsiWmipProcessRequest(
    IN PSCSI_WMILIB_CONTEXT WmiLibInfo,
    IN UCHAR MinorFunction,
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN PUCHAR Buffer,
    OUT PULONG ReturnSize,
    OUT PSYSCTL_SCSI_DISPOSITION IrpDisposition
    )
{
    UCHAR status;
    ULONG retSize;
    ULONG guidIndex;
    ULONG instanceCount;
    ULONG instanceIndex;

    ASSERT(MinorFunction <= IRP_MN_EXECUTE_METHOD);

    *IrpDisposition = ScsiProcessed;

    if (MinorFunction != IRP_MN_REGINFO)
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        ASSERT(WmiLibInfo->GuidList != NULL);
        if (ScsiWmipFindGuid(WmiLibInfo->GuidList,
                            WmiLibInfo->GuidCount,
                            (LPGUID)DataPath,
                            &guidIndex,
                            &instanceCount))
        {
            status = SRB_STATUS_SUCCESS;
        } else {
            status = SRB_STATUS_ERROR;
        }

        if ((status == SRB_STATUS_SUCCESS) &&
            ((MinorFunction == IRP_MN_QUERY_SINGLE_INSTANCE) ||
             (MinorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE) ||
             (MinorFunction == IRP_MN_CHANGE_SINGLE_ITEM) ||
             (MinorFunction == IRP_MN_EXECUTE_METHOD)))
        {
            instanceIndex = ((PWNODE_SINGLE_INSTANCE)Buffer)->InstanceIndex;

            if ( (((PWNODE_HEADER)Buffer)->Flags) &
                                          WNODE_FLAG_STATIC_INSTANCE_NAMES)
            {
                if ( instanceIndex >= instanceCount )
                {
                    status = SRB_STATUS_ERROR;
                }
            }
        }

        //
        // If we couldn't find the guid or the instance name index is out
        // of range then return an error.
        if (status != SRB_STATUS_SUCCESS)
        {
            *ReturnSize = 0;
            *IrpDisposition = ScsiNotCompleted;
            return(status);
        }
    }

    switch(MinorFunction)
    {
        case IRP_MN_REGINFO:
        {
            ULONG guidCount;
            PSCSIWMIGUIDREGINFO guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PWCHAR mofResourceName;
            PWCHAR stringPtr;
            ULONG mofResourceOffset;
            USHORT mofResourceSize;
            ULONG bufferNeeded;
            ULONG i;
            USHORT nameSize;
            ULONG nameOffset, nameFlags;
            USHORT mofResourceNameLen;
            
            //
            // Make sure that the required parts of the WMILIB_INFO structure
            // are filled in.
            ASSERT(WmiLibInfo->QueryWmiRegInfo != NULL);
            ASSERT(WmiLibInfo->QueryWmiDataBlock != NULL);

            status = WmiLibInfo->QueryWmiRegInfo(
                                                    Context,
                                                    RequestContext,
                                                    &mofResourceName);

            if (status == SRB_STATUS_SUCCESS)
            {
                ASSERT(WmiLibInfo->GuidList != NULL);

                guidList = WmiLibInfo->GuidList;
                guidCount = WmiLibInfo->GuidCount;

                nameOffset = sizeof(WMIREGINFO) +
                                      guidCount * sizeof(WMIREGGUIDW);
                                  
                nameFlags = WMIREG_FLAG_INSTANCE_BASENAME;
                nameSize = sizeof(L"ScsiMiniPort");

                mofResourceOffset = nameOffset + nameSize + sizeof(USHORT);
                if (mofResourceName == NULL)
                {
                    mofResourceSize = 0;
                } else {
                    mofResourceNameLen = 0;
                    while (mofResourceName[mofResourceNameLen] != 0)
                    {
                        mofResourceNameLen++;
                    }
                    mofResourceSize = mofResourceNameLen * sizeof(WCHAR);
                }

                bufferNeeded = mofResourceOffset + mofResourceSize + sizeof(USHORT);

                if (bufferNeeded <= BufferSize)
                {
                    retSize = bufferNeeded;

                    wmiRegInfo = (PWMIREGINFO)Buffer;
                    wmiRegInfo->BufferSize = bufferNeeded;
                    wmiRegInfo->NextWmiRegInfo = 0;
                    wmiRegInfo->MofResourceName = mofResourceOffset;
                    wmiRegInfo->RegistryPath = 0;
                    wmiRegInfo->GuidCount = guidCount;

                    for (i = 0; i < guidCount; i++)
                    {
                        wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                        wmiRegGuid->Guid = *guidList[i].Guid;
                        if (guidList[i].InstanceCount != 0xffffffff)
                        {
                            wmiRegGuid->Flags = guidList[i].Flags | nameFlags;
                            wmiRegGuid->InstanceInfo = nameOffset;
                            wmiRegGuid->InstanceCount = guidList[i].InstanceCount;
                        } else {
                            wmiRegGuid->Flags = guidList[i].Flags;
                            wmiRegGuid->InstanceInfo = 0;
                            wmiRegGuid->InstanceCount = 0;
                        }
                    }

                    stringPtr = (PWCHAR)((PUCHAR)Buffer + nameOffset);
                    *stringPtr++ = nameSize;
                    ScsiPortMoveMemory(stringPtr,
                                  L"ScsiMiniPort",
                                  nameSize);

                    stringPtr = (PWCHAR)((PUCHAR)Buffer + mofResourceOffset);
                    *stringPtr++ = mofResourceSize;
                    ScsiPortMoveMemory(stringPtr,
                                  mofResourceName,
                                  mofResourceSize);

                } else {
                    *((PULONG)Buffer) = bufferNeeded;
                    retSize = sizeof(ULONG);
                }
            } else {
                //  QueryWmiRegInfo failed
                retSize = 0;
            }

            *ReturnSize = retSize;
            *IrpDisposition = ScsiNotCompleted;
            return(status);
        }

        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            ULONG bufferAvail;
            PULONG instanceLengthArray;
            PUCHAR dataBuffer;
            ULONG instanceLengthArraySize;
            ULONG dataBlockOffset;

            wnode = (PWNODE_ALL_DATA)Buffer;

            if (BufferSize < sizeof(WNODE_ALL_DATA))
            {
                //
                // The buffer should never be smaller than the size of
                // WNODE_ALL_DATA, however if it is then return with an
                // error requesting the minimum sized buffer.
                ASSERT(FALSE);

                status = SRB_STATUS_ERROR;
                *IrpDisposition = ScsiNotCompleted;
                
                break;
            }

            wnode->InstanceCount = instanceCount;

            wnode->WnodeHeader.Flags &= ~WNODE_FLAG_FIXED_INSTANCE_SIZE;

            instanceLengthArraySize = instanceCount * sizeof(OFFSETINSTANCEDATAANDLENGTH);

            dataBlockOffset = (FIELD_OFFSET(WNODE_ALL_DATA, OffsetInstanceDataAndLength) + instanceLengthArraySize + 7) & ~7;

            wnode->DataBlockOffset = dataBlockOffset;
            if (dataBlockOffset <= BufferSize)
            {
                instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
                dataBuffer = Buffer + dataBlockOffset;
                bufferAvail = BufferSize - dataBlockOffset;
            } else {
                //
                // There is not enough room in the WNODE to complete
                // the query
                instanceLengthArray = NULL;
                dataBuffer = NULL;
                bufferAvail = 0;
            }

            status = WmiLibInfo->QueryWmiDataBlock(
                                             Context,
                                             RequestContext,
                                             guidIndex,
                                             0,
                                             instanceCount,
                                             instanceLengthArray,
                                             bufferAvail,
                                             dataBuffer);
            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            ULONG dataBlockOffset;

            wnode = (PWNODE_SINGLE_INSTANCE)Buffer;

            dataBlockOffset = wnode->DataBlockOffset;

            status = WmiLibInfo->QueryWmiDataBlock(
                                          Context,
                                          RequestContext,
                                          guidIndex,
                                          instanceIndex,
                                          1,
                                          &wnode->SizeDataBlock,
                                          BufferSize - dataBlockOffset,
                                          (PUCHAR)wnode + dataBlockOffset);

            break;
        }

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;

            if (WmiLibInfo->SetWmiDataBlock != NULL)
            {
                wnode = (PWNODE_SINGLE_INSTANCE)Buffer;

                status = WmiLibInfo->SetWmiDataBlock(
                                     Context,
                                     RequestContext,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->SizeDataBlock,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);
                                 
            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = SRB_STATUS_ERROR;
                *IrpDisposition = ScsiNotCompleted;
            }
            
            break;
        }

        case IRP_MN_CHANGE_SINGLE_ITEM:
        {
            PWNODE_SINGLE_ITEM wnode;

            if (WmiLibInfo->SetWmiDataItem != NULL)
            {
                wnode = (PWNODE_SINGLE_ITEM)Buffer;

                status = WmiLibInfo->SetWmiDataItem(
                                     Context,
                                     RequestContext,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->ItemId,
                                     wnode->SizeDataItem,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);

            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = SRB_STATUS_ERROR;
                *IrpDisposition = ScsiNotCompleted;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;

            if (WmiLibInfo->ExecuteWmiMethod != NULL)
            {
                wnode = (PWNODE_METHOD_ITEM)Buffer;

                status = WmiLibInfo->ExecuteWmiMethod(
                                         Context,
                                         RequestContext,
                                         guidIndex,
                                         instanceIndex,
                                         wnode->MethodId,
                                         wnode->SizeDataBlock,
                                         BufferSize - wnode->DataBlockOffset,
                                         Buffer + wnode->DataBlockOffset);
            } else {
                //
                // If method callback is not filled in then it must be error
                status = SRB_STATUS_ERROR;
                *IrpDisposition = ScsiNotCompleted;
            }

            break;
        }

        case IRP_MN_ENABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           Context,
                                                           RequestContext,
                                                           guidIndex,
                                                           ScsiWmiEventControl,
                                                           TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = SRB_STATUS_SUCCESS;
                *IrpDisposition = ScsiNotCompleted;
            }
            break;
        }

        case IRP_MN_DISABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           Context,
                                                           RequestContext,
                                                           guidIndex,
                                                           ScsiWmiEventControl,
                                                           FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = SRB_STATUS_SUCCESS;
                *IrpDisposition = ScsiNotCompleted;
            }
            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         Context,
                                                         RequestContext,
                                                         guidIndex,
                                                         ScsiWmiDataBlockControl,
                                                         TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = SRB_STATUS_SUCCESS;
                *IrpDisposition = ScsiNotCompleted;
            }
            break;
        }

        case IRP_MN_DISABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         Context,
                                                         RequestContext,
                                                         guidIndex,
                                                         ScsiWmiDataBlockControl,
                                                         FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = SRB_STATUS_SUCCESS;
                *IrpDisposition = ScsiNotCompleted;
            }
            break;
        }

        default:
        {
            ASSERT(FALSE);
            status = SRB_STATUS_ERROR;
            *IrpDisposition = ScsiNotCompleted;
            break;
        }

    }
    return(status);
}

BOOLEAN
ScsiPortWmiDispatchFunction(
    IN PSCSI_WMILIB_CONTEXT WmiLibInfo,
    IN UCHAR MinorFunction,
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN PVOID Buffer
    )
/*++

Routine Description:

    Dispatch helper routine for WMI srb requests. Based on the Minor
    function passed the WMI request is processed and this routine 
    invokes the appropriate callback in the WMILIB structure.

Arguments:

    WmiLibInfo has the SCSI WMILIB information control block associated
        with the adapter or logical unit

    DeviceContext is miniport defined context value passed on to the callbacks
        invoked by this api.

    RequestContext is a pointer to a context structure that maintains 
        information about this WMI srb. This request context must remain 
        valid throughout the entire processing of the srb, at least until 
        ScsiPortWmiPostProcess returns with the final srb return status and 
        buffer size. If the srb can pend then memory for this buffer should 
        be allocated from the SRB extension. If not then the memory can be 
        allocated from a stack frame that does not go out of scope, perhaps 
        that of the caller to this api.

    DataPath is value passed in wmi request
    
    BufferSize is value passed in wmi request
        
    Buffer is value passed in wmi request

Return Value:

    TRUE if request is pending else FALSE

--*/
{
    UCHAR status;
    SYSCTL_SCSI_DISPOSITION irpDisposition;
    ULONG retSize;

    ASSERT(RequestContext != NULL);
    
    //
    // First ensure that the irp is a WMI irp
    if (MinorFunction > IRP_MN_EXECUTE_METHOD)
    {
        //
        // This is not a WMI irp, setup error return
        status = SRB_STATUS_ERROR;
        RequestContext->ReturnSize = 0;
        RequestContext->ReturnStatus = status;
    } else {
        //
        // Let SCSIWMI library have a crack at the SRB
        RequestContext->MinorFunction = MinorFunction;
        RequestContext->Buffer = Buffer;
        RequestContext->BufferSize = BufferSize;
        RequestContext->ReturnSize = 0;
        
        status = ScsiWmipProcessRequest(WmiLibInfo,
                                    MinorFunction,
                                    Context,
                                    RequestContext,
                                    DataPath,
                                    BufferSize,
                                    Buffer,
                                    &retSize,
                                    &irpDisposition);
                            
        if (irpDisposition == ScsiNotCompleted)
        {
            //
            // Some error occured while processing the SRB, for example
            // guid not found. Setup the returned error
            RequestContext->ReturnStatus = status;
            if (status != SRB_STATUS_SUCCESS)
            {
                retSize = 0;
            }
            RequestContext->ReturnSize = retSize;
        }        
    }

    return(status == SRB_STATUS_PENDING);
}

VOID
ScsiPortWmiFireLogicalUnitEvent(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LPGUID Guid,
    IN ULONG InstanceIndex,
    IN ULONG EventDataSize,
    IN PVOID EventData
    )
/*++

Routine Description:

    This routine will fire a WMI event using the data buffer passed. This
    routine may be called at or below DPC level

Arguments:

    HwDeviceExtension is the adapter device extension
        
    PathId identifies the SCSI bus if a logical unit is firing the event 
        or is 0xff if the adapter is firing the event.
        
    TargetId identifies the target controller or device on the bus
        
    Lun identifies the logical unit number of the target device

    Guid is pointer to the GUID that represents the event
        
    InstanceIndex is the index of the instance of the event
        
    EventDataSize is the number of bytes of data that is being fired with
       with the event. This size specifies the size of the event data only 
       and does NOT include the 0x40 bytes of preceeding padding.
           
    EventData is the data that is fired with the events. There must be exactly
        0x40 bytes of padding preceeding the event data.

Return Value:

--*/
{
    PWNODE_SINGLE_INSTANCE event;
    UCHAR status;

    ASSERT(EventData != NULL);

    event = (PWNODE_SINGLE_INSTANCE)EventData;

    event->WnodeHeader.Guid = *Guid;
    event->WnodeHeader.Flags =  WNODE_FLAG_SINGLE_INSTANCE |
                                    WNODE_FLAG_EVENT_ITEM |
                                    WNODE_FLAG_STATIC_INSTANCE_NAMES;
    event->WnodeHeader.Linkage = 0;
                
    event->InstanceIndex = InstanceIndex;
    event->SizeDataBlock = EventDataSize;
    event->DataBlockOffset = 0x40;
    event->WnodeHeader.BufferSize = event->DataBlockOffset + 
                                    event->SizeDataBlock;
    
    if (PathId != 0xff)
    {
        ScsiPortNotification(WMIEvent,
                         HwDeviceExtension,
                         event,
                         PathId,
                         TargetId,
                         Lun);
    } else {
        ScsiPortNotification(WMIEvent,
                         HwDeviceExtension,
                         event,
                         PathId);
    }
}

PWCHAR ScsiPortWmiGetInstanceName(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext
    )
/*++

Routine Description:

    This routine will return a pointer to the instance name that was
    used to pass the request. If the request type is one that does not
    use an instance name then NULL is retuened. The instance name is a
    counted string.

Arguments:

    RequestContext is a pointer to a context structure that maintains 
        information about this WMI srb. This request context must remain 
        valid throughout the entire processing of the srb, at least until 
        ScsiPortWmiPostProcess returns with the final srb return status and 
        buffer size. If the srb can pend then memory for this buffer should 
        be allocated from the SRB extension. If not then the memory can be 
        allocated from a stack frame that does not go out of scope, perhaps 
        that of the caller to this api.

Return Value:

    Pointer to instance name or NULL if no instance name is available

--*/
{
    PWCHAR p;
    PWNODE_SINGLE_INSTANCE Wnode;
    
    if ((RequestContext->MinorFunction == IRP_MN_QUERY_SINGLE_INSTANCE) ||
        (RequestContext->MinorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE) ||       
        (RequestContext->MinorFunction == IRP_MN_CHANGE_SINGLE_ITEM) ||       
        (RequestContext->MinorFunction == IRP_MN_EXECUTE_METHOD) )
    {
        Wnode = (PWNODE_SINGLE_INSTANCE)RequestContext->Buffer;
        if ((Wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) == 0)
        {
            p = (PWCHAR)((PUCHAR)Wnode + Wnode->OffsetInstanceName);
        } else {
            p = NULL;
        }
    } else {
        p = NULL;
    }
    return(p);
}


BOOLEAN ScsiPortWmiSetInstanceCount(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG InstanceCount,
    OUT PULONG BufferAvail,
    OUT PULONG SizeNeeded
    )
/*++

Routine Description:

    This routine will update the wnode to indicate the number of
    instances that will be returned by the driver. Note that the values
    for BufferAvail may change after this call. This routine
    may only be called for a WNODE_ALL_DATA. This routine must be
    called before calling ScsiPortWmiSetInstanceName or
    ScsiPortWmiSetData

Arguments:

    RequestContext is a pointer to a context structure that maintains 
        information about this WMI srb. This request context must remain 
        valid throughout the entire processing of the srb, at least until 
        ScsiPortWmiPostProcess returns with the final srb return status and 
        buffer size. If the srb can pend then memory for this buffer should 
        be allocated from the SRB extension. If not then the memory can be 
        allocated from a stack frame that does not go out of scope, perhaps 
        that of the caller to this api.

    InstanceCount is the number of instances to be returned by the
        driver.

    *BufferAvail returns with the number of bytes available for
        instance names and data in the buffer. This may be 0 if there
        is not enough room for all instances.

    *SizeNeeded returns with the number of bytes that are needed so far
        to build the output wnode

Return Value:

    TRUE if successful else FALSE. If FALSE wnode is not a
    WNODE_ALL_DATA or does not have dynamic instance names.

--*/
{
    PWNODE_ALL_DATA wnode;
    ULONG bufferSize;
    ULONG offsetInstanceNameOffsets, dataBlockOffset, instanceLengthArraySize;
    ULONG bufferAvail;
    BOOLEAN b;

    ASSERT(RequestContext->MinorFunction == IRP_MN_QUERY_ALL_DATA);

    *SizeNeeded = 0;
    if (RequestContext->MinorFunction == IRP_MN_QUERY_ALL_DATA)
    {
        wnode = (PWNODE_ALL_DATA)RequestContext->Buffer;

        ASSERT((wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) == 0);
        
        if ((wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) == 0)
        {
            bufferSize = RequestContext->BufferSize;

            wnode->InstanceCount = InstanceCount;

            instanceLengthArraySize = InstanceCount * sizeof(OFFSETINSTANCEDATAANDLENGTH);

            offsetInstanceNameOffsets = FIELD_OFFSET(WNODE_ALL_DATA,
                                                     OffsetInstanceDataAndLength) +
                                        instanceLengthArraySize;
            wnode->OffsetInstanceNameOffsets = offsetInstanceNameOffsets;
            
            dataBlockOffset = (offsetInstanceNameOffsets +
                               (InstanceCount * sizeof(ULONG)) + 7) & ~7;

            wnode->DataBlockOffset = dataBlockOffset;

            *SizeNeeded = 0;
            if (dataBlockOffset <= bufferSize)
            {
                *BufferAvail = bufferSize - dataBlockOffset;
                            memset(wnode->OffsetInstanceDataAndLength, 0,
                                            ((UCHAR)dataBlockOffset-(UCHAR)FIELD_OFFSET(WNODE_ALL_DATA,
                                                     OffsetInstanceDataAndLength)));
            } else {
                //
                // There is not enough room in the WNODE to complete
                // the query
                //
                *BufferAvail = 0;
            }       
            b = TRUE;
        } else {
            b = FALSE;          
        }
    } else {
        b = FALSE;
    }
    
    return(b);
    
}

PWCHAR ScsiPortWmiSetInstanceName(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG InstanceIndex,
    IN ULONG InstanceNameLength,
    OUT PULONG BufferAvail,
    IN OUT PULONG SizeNeeded
    )
/*++

Routine Description:

    This routine will update the wnode header to include the position where an
    instance name is to be written. Note that the values
    for BufferAvail may change after this call. This routine
    may only be called for a WNODE_ALL_DATA.

Arguments:

    RequestContext is a pointer to a context structure that maintains 
        information about this WMI srb. This request context must remain 
        valid throughout the entire processing of the srb, at least until 
        ScsiPortWmiPostProcess returns with the final srb return status and 
        buffer size. If the srb can pend then memory for this buffer should 
        be allocated from the SRB extension. If not then the memory can be 
        allocated from a stack frame that does not go out of scope, perhaps 
        that of the caller to this api.

    InstanceIndex is the index to the instance name being filled in

    InstanceNameLength is the number of bytes (including count) needed
       to write the instance name.

    *BufferAvail returns with the number of bytes available for
        instance names and data in the buffer. This may be 0 if there
        is not enough room for the instance name.

    *SizeNeeded on entry has the number of bytes needed so far to build
        the WNODE and on return has the number of bytes needed to build
        the wnode after including the instance name

Return Value:

    pointer to where the instance name should be filled in. If NULL
    then the wnode is not a WNODE_ALL_DATA or does not have dynamic
    instance names

--*/
{
    PWNODE_ALL_DATA wnode;
    ULONG bufferSize;
    ULONG bufferAvail;
    PULONG offsetInstanceNameOffsets;
    ULONG pos, extra;
    PWCHAR p;
    
    ASSERT(RequestContext->MinorFunction == IRP_MN_QUERY_ALL_DATA);

    if (RequestContext->MinorFunction == IRP_MN_QUERY_ALL_DATA)
    {
        wnode = (PWNODE_ALL_DATA)RequestContext->Buffer;

        ASSERT((wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) == 0);
        if ((wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) == 0)
        {
            ASSERT(InstanceIndex < wnode->InstanceCount);

            pos = (*SizeNeeded + 1) &~1;

            //
            // Update the total size needed for the wnode and number of
            // bytes available
            //
                     extra = pos - *SizeNeeded;
            extra += InstanceNameLength;
            
            *SizeNeeded += extra;
            if (*BufferAvail >= extra)
            {
                *BufferAvail -= extra;
                            //
                            // Fill in offset to the instance name in the wnode header
                            //
                            offsetInstanceNameOffsets = (PULONG)((PUCHAR)wnode +
                                                  wnode->OffsetInstanceNameOffsets);
                            offsetInstanceNameOffsets[InstanceIndex] = (ULONG)pos +(ULONG)wnode->DataBlockOffset;
                    p = (PWCHAR)((PUCHAR)wnode + wnode->DataBlockOffset + pos);
            } else {
                *BufferAvail = 0;
                            p = NULL;
            }
            
        } else {
            p = NULL;
        }
    } else {
        p = NULL;
    }
    return(p);
}

PVOID ScsiPortWmiSetData(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG InstanceIndex,
    IN ULONG DataLength,
    OUT PULONG BufferAvail,
    IN OUT PULONG SizeNeeded
    )
/*++

Routine Description:

    This routine will update the wnode to indicate the position of the
    data for an instance that will be returned by the driver. Note that
    the values for BufferAvail may change after this call. This routine
    may only be called for a WNODE_ALL_DATA.

Arguments:

    RequestContext is a pointer to a context structure that maintains 
        information about this WMI srb. This request context must remain 
        valid throughout the entire processing of the srb, at least until 
        ScsiPortWmiPostProcess returns with the final srb return status and 
        buffer size. If the srb can pend then memory for this buffer should 
        be allocated from the SRB extension. If not then the memory can be 
        allocated from a stack frame that does not go out of scope, perhaps 
        that of the caller to this api.

    InstanceIndex is the index to the instance name being filled in

    DataLength is the number of bytes  needed to write the data.

    *BufferAvail returns with the number of bytes available for
        instance names and data in the buffer. This may be 0 if there
        is not enough room for the data.

    *SizeNeeded on entry has the number of bytes needed so far to build
        the WNODE and on return has the number of bytes needed to build
        the wnode after including the data

Return Value:

    pointer to where the data should be filled in. If NULL
    then the wnode is not a WNODE_ALL_DATA or does not have dynamic
    instance names

--*/
{
    PWNODE_ALL_DATA wnode;
    ULONG bufferSize;
    ULONG bufferAvail;
    POFFSETINSTANCEDATAANDLENGTH offsetInstanceDataAndLength;
    ULONG pos, extra;
    PVOID p;
    
    ASSERT(RequestContext->MinorFunction == IRP_MN_QUERY_ALL_DATA);

    if (RequestContext->MinorFunction == IRP_MN_QUERY_ALL_DATA)
    {
        wnode = (PWNODE_ALL_DATA)RequestContext->Buffer;
        
        ASSERT((wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) == 0);
        if ((wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) == 0)
        {
            ASSERT(InstanceIndex < wnode->InstanceCount);
            
            pos = (*SizeNeeded + 7) &~7;

            //
            // Update the total size needed for the wnode and number of
            // bytes available
            //
                     extra = pos - *SizeNeeded;
            extra += DataLength;
            
            *SizeNeeded += extra;
            if (*BufferAvail >= extra)
            {
                *BufferAvail -= extra;
                            //
                            // Fill in offset and length to the data in the wnode header
                            //
                            offsetInstanceDataAndLength = (POFFSETINSTANCEDATAANDLENGTH)((PUCHAR)wnode + 
                                             FIELD_OFFSET(WNODE_ALL_DATA,
                                                          OffsetInstanceDataAndLength));
                            offsetInstanceDataAndLength[InstanceIndex].OffsetInstanceData = wnode->DataBlockOffset + pos;
                            offsetInstanceDataAndLength[InstanceIndex].LengthInstanceData = DataLength;
                            p = (PVOID)((PUCHAR)wnode + wnode->DataBlockOffset + pos);

            } else {
                *BufferAvail = 0;
            }
            
        } else {
            p = NULL;
        }
    } else {
        p = NULL;
    }
    return(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sffdisk\debug.h ===
/*++

Copyright (c) 1991 - 1993 Microsoft Corporation

Module Name:

    debug.h

Abstract:


Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

Notes:


--*/


#if DBG
//
// For checked kernels, define a macro to print out informational
// messages.
//
// SffDiskDebug is normally 0.  At compile-time or at run-time, it can be
// set to some bit patter for increasingly detailed messages.
//
// Big, nasty errors are noted with FAIL.  Errors that might be
// recoverable are handled by the WARN bit.  More information on
// unusual but possibly normal happenings are handled by the INFO bit.
// And finally, boring details such as routines entered and register
// dumps are handled by the SHOW bit.
//
#define SFFDISKFAIL              ((ULONG)0x00000001)
#define SFFDISKWARN              ((ULONG)0x00000002)
#define SFFDISKINFO              ((ULONG)0x00000004)
#define SFFDISKSHOW              ((ULONG)0x00000008)
#define SFFDISKIRPPATH           ((ULONG)0x00000010)
#define SFFDISKFORMAT            ((ULONG)0x00000020)
#define SFFDISKSTATUS            ((ULONG)0x00000040)
#define SFFDISKPNP               ((ULONG)0x00000080)
#define SFFDISKIOCTL             ((ULONG)0x00000100)
#define SFFDISKRW                ((ULONG)0x00000200)
extern ULONG SffDiskDebugLevel;
#define SffDiskDump(LEVEL,STRING) \
        do { \
            if (SffDiskDebugLevel & (LEVEL)) { \
                DbgPrint STRING; \
            } \
        } while (0)
#else
#define SffDiskDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sffdisk\pch.h ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    pch.h

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/

//
// Include files.
//

#include "stdio.h"
#include <stdarg.h>

#include "ntosp.h"                       // various NT definitions
#include <zwapi.h>
#include "ntdddisk.h"                    // disk device driver I/O control codes
#include "initguid.h"
#include "wdmguid.h"
#include "ntddpcm.h"
#include "mountdev.h"
#include "acpiioct.h"

#include <sffdisk.h>                    // this driver's data declarations
#include <extern.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sffdisk\extern.h ===
/*++

Copyright (c) 1991 - 1993 Microsoft Corporation

Module Name:

    extern.h

Abstract:


Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

Notes:


--*/



//
// Prototypes of driver routines.
//

NTSTATUS
SffDiskDeviceControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
SffDiskAddDevice(
   IN      PDRIVER_OBJECT DriverObject,
   IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
   );

NTSTATUS
SffDiskPnp(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
SffDiskPower(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );
    
   
extern SFFDISK_FUNCTION_BLOCK PcCardSupportFns;
extern SFFDISK_FUNCTION_BLOCK SdCardSupportFns;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\sffdisk\ioctl.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"
#include "ntddvol.h"
#include "ntddft.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SffDiskDeviceControl)
#endif


NTSTATUS
SffDiskDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

   This routine is called by the I/O system to perform a device I/O
   control function.

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
   STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PSFFDISK_EXTENSION sffdiskExtension;
    PDISK_GEOMETRY outputBuffer;
    NTSTATUS status;
    ULONG outputBufferLength;
    UCHAR i;
    ULONG formatExParametersSize;
    PFORMAT_EX_PARAMETERS formatExParameters;
   
    sffdiskExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    SffDiskDump(SFFDISKIOCTL, ("SffDisk: IOCTL - %.8x\n", irpSp->Parameters.DeviceIoControl.IoControlCode));
   
    //
    //  If the device has been removed we will just fail this request outright.
    //
    if ( sffd