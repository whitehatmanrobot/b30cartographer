e executed.
;
;****************************************************************************

	.xlist
	include 	version.inc
EXCONTXT_ASM = ON
	IncludeOnce	architec
	IncludeOnce	conint
	IncludeOnce	context
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	opcontrl
	IncludeOnce	opmin
	IncludeOnce	opstmt
	IncludeOnce	qbimsgs
	IncludeOnce	rtinterp
	IncludeOnce	rtps
	IncludeOnce	rttemp
	IncludeOnce	scanner
	IncludeOnce	txtmgr
	IncludeOnce	ui
	IncludeOnce	variable
	.list

assumes DS, DATA
assumes es, NOTHING
assumes ss, DATA

sBegin	DATA
	externW b$cCSubs	;count of compiled BASIC frames on stack
	externB b$inonerr	;used to check for No RESUME error @ implied END
	externW	b$errnum
	externW b$ErrInfo	;extended error codes (UI <--> Runtime)
	externB fInitialized	;non-zero if we've completed initialization of
				;  quick basic
	externB b$CtrlFlags	;byte of runtime-specific flag bits
	staticW oTxRunSave,0	;!#@$ static location to save oTxCur before
				;RunFile or CHAIN.

sEnd	DATA

	EXTRN	B$IEND:FAR
	EXTRN	B$IEndSt:FAR
	EXTRN	B$SCLR:FAR
	EXTRN	B$ClearRange:FAR
	EXTRN	B$STACKINIT:FAR
	EXTRN	RtError_INI:FAR

	EXTRN	fEditorActive:FAR 

sBegin	CODE
assumes cs, CODE

	EXTRN	DoFBosResetStk:near
	extrn	I4ToU2:near

;***
;exStop, exStEnd, exStSystem - STOP, END, & SYSTEM Statement Executors
;
;	Note that, for STOP, UserInterface will save the CONTinue context
;	we don't have to do that here.
;
;	Note that for compiled BASIC STOP and END/SYSTEM, the runtime
;	will do a jump to B$IStop or exStEnd.
;
;	Note that SI, DI, & ES may not be correctly set on entry to B$IStop.
;
;***************************************************************************
	PUBLIC	B$IStop		;runtime call-back if ctrl-Break is
B$IStop:				;  seen, or compiled Basic STOP stmt
	mov	al,[grs.GRS_fDirect]	
	or	al,al			; in direct mode window?
	jnz	SkipCursorStuff 	; yes, skip cursor positioning
	push	ax			; save direct mode flag because
					;	OtxBosOfOtx hoses fDirect

	call	EnStaticStructs		;bring txdCur up to date
	push	[grs.GRS_otxCur]	;parm to OtxBosOfOtx
	call	OtxBosOfOtx		;ax = oTx of BOS/BOL of current stmt
					;we do this so we don't try to continue
					;execution in the middle of a statement
	xchg	ax, bx			; bx = otx of pcode to skip.
	call	TxtSkipOpFar		;ax = oTx of pcode following BOS/BOL.
					;  we do this so txtmgr can tell for
					;  sure which line to put the cursor on
	xchg	ax,si
	pop	ax
	mov	[grs.GRS_fDirect],al	;in case OtxBosOfOtx changed fDirect
	call	DisStaticStructs
SkipCursorStuff:			
	and	[BosFlags],NOT FBOSSTOP
	mov	bp,[b$curframe]
	SkipExHeader
MakeExe exStStop,opStStop
	or	[debugFlags],DEBUG_STOP ;indicate program stopped
	cmp	[fNonQBI_Active],FALSE	;was QBI code active when we stopped?
	jz	StopGrsContext		;brif so

	;We were stopped in QuickLib code. We cannot CONTinue, but we
	;do want to be able to allow the user to print variables, and stack 
	;trace from the most recent QBI frame back.
	or	[debugFlags],DEBUG_CANT_CONT
	call	ResetSP_BP_Far		; reset SP & BP based as appropriate
					;  depending on whether QBI code
					;  was active or not.
	mov	sp,ax			;set SP based on retval
	jmp	SHORT StopGrsContext

MakeExe exStSystem,opStSystem
	test	[cmdSwitches],CMD_SW_RUN ;/Z filename given on command line?
	jnz	Exit_Basic		 ;  brif so - - always exit

	cmp	[grs.GRS_fDirect],FALSE ;in Direct Mode?
	jz	exStEnd 		;  brif not - - act just like END stmt

Exit_Basic:
	or	[debugFlags],DEBUG_END	; indicate end-of-program, to ensure
					;  error not trappable in case of
					;  I/O error
	cCall	NotSaved		;notify user, get his response.
					; if CANCEL, ax=MSG_GoDirect
					; if user said NO, ax=FFFF
					; if I/O error, ax = error code
					; if files saved ok, ax=0
	jg	J2_RtErrorCODE		;brif runtime error while
					; saving files, or CANCEL
	call B$IEND			;tell runtime to terminate - - never
					;  returns
MakeExe exStEnd,opStEnd
	or	[debugFlags],DEBUG_CANT_CONT
					;make sure UserInterface() doesn't
					; let us continue execution
	mov	[grs.GRS_otxCur],si	; in case of error in closing files
	or	[debugFlags],DEBUG_END	; indicate end-of-program, to ensure
					;  errors aren't trappable
	call	B$IEndSt		;close all user files
	SkipExHeader			;fall through except for closing files,
					;  exEndProg is an implied END executor
;***
;exEot, exEndProg - End of Program Executor
;Purpose:
;	exEndProg is the main interpreter loop control.  It calls the
;	front end to obtain work.  It then executes the current text
;	table.	All text tables contain an exEndProg after the user's pcode.
;	The loop is completed by execution of the exEndProg at the end of some
;	text table.
;
;***************************************************************************
MakeExe exEot,opEot
	SkipExHeader
MakeExe exEndProg,opEndProg
	cmp	[b$inonerr],FALSE
	jz	EndProg1		;brif not in an error trap

	cmp	[grs.GRS_fDirect],FALSE
	jnz	EndProg1		;brif EOT in Direct Mode buffer

	mov	al,ER_NR		;No RESUME error
J2_RtErrorCODE:
	call	RtErrorCODE		;runtime error - doesn't return
EndProg1:
	;if something like NEW happened as the last statement, the stack won't
	;  have been cleared yet (and who knows, we might have something
	;  meaningful on the stack when we hit our next BOS/BOL after
	;  UserInterface(?)
	test	[BosFlags],FBOSRESETSTK
	jz	Ep_Cont

	call	DoFBosResetStk		;reset the stack
Ep_Cont:
	or	[debugFlags],DEBUG_END	;indicate end-of-program
	mov	si,UNDEFINED		;Save context (end of program)
	;fall into StopGrsContext
PUBLIC	StopGrsContext
StopGrsContext:
	mov	[grs.GRS_otxCur],si	;Save text pointer
	mov	[b$curframe],bp	;required by RT error handling code

	DbChk	BpChain			;ensure the bp chain is walkable
	DbAssertRel  sp,a,b$pendchk,CODE,<StopGrsContext: SP below b$pendchk>
					;ensure sufficient stack space for U.I.
	cmp	[b$errnum],ER_OM
	jz	Enter_UI		;brif might already be short on space
	call	GrabSpace		;ensure there's enough free space to
					;  at LEAST do a CLEAR ...
	or	ax,ax
	jnz	Enter_UI		;brif allocations successful
OM_Err:
	mov	al,ER_OM		;don't enter UI if we can't even
	jmp	J2_RtErrorCODE		;  get enough space to do a CLEAR - -
Enter_UI:
	call	ReleaseSpace		;release special space allocated by
					;  GrabSpace
	call	EnStaticStructs 	;activate static prsCur, mrsCur, txdCur

	test	[debugFlags],DEBUG_ERROR OR DEBUG_STOP OR DEBUG_END
	jz	Enter_UI_1		;brif not going back into UI to stay
					;  a while ...
	call	FreeAllUnrefdPrs	;Remove any prs's that arn't ref'd
					;  anywhere AND that don't have text
					;  tables.  This is needed in case
					;  the user called a prs in a QuickLib
					;  from direct mode, and this was the
					;  only reference to the prs.
Enter_UI_1:
	mov	bx,dataOFFSET prsCur
	test	byte ptr [grs.GRS_oRsCur+1],080H
	jnz	PrsIsActive

	mov	bx,dataOFFSET mrsCur
PrsIsActive:
	.errnz	MRS_cbFrameTemp - PRS_cbFrameTemp
	mov	ax,[bx.MRS_cbFrameVars]
	push	ax			;save in case more vars added to frame
	add	ax,[bx.MRS_cbFrameTemp]
	push	ax			;save in case frame size grows
	DbMessTimer	CODE,<Enter UserInterface() - >
	cCall	UserInterface		;Call direct mode for more work
	DbMessTimer	CODE,<Leave UserInterface() - >
	cmp	[grs.GRS_fDirect],FALSE
	jnz	No_Stk_Reinit		;  brif Direct mode

	mov	bx,sp			;reset empty words in stack for FRE(-2).
	sub	bx,4			;so cbFrameVars and cbFrame on stack 
					;  arn't hosed ...
	call	B$STACKINIT		;Must do this here as UserInterface
					;  is called one last time AFTER RunInit
No_Stk_Reinit:
	pop	si			;previous frame size for oRsCur
	pop	di			;previous cbFrameVars for oRsCur
					;(popping this here, as B$STACKINIT 
					;  trashes di ... pfthhhhhhhhhhp!)
	xor	bx,bx
	mov	[fNonQBI_Active],bx	;ensure this flag is reset
	cmp	[grs.GRS_otxCONT],UNDEFINED
	jnz	GetpRsCur		;brif can CONT

	;we must set SP based on BP so direct mode statments have the 
	;required amount of temp and var space on the frame. Prior to
	;doing this, however, we must release any owners on the stack - - -
	;we can't wait for the first BOS/BOL to occur, because resetting
	;sp means that we could overwrite an owner ...
	cmp	[grs.GRS_fDirect],FALSE	;executing in the direct mode buffer?
	jz	GoStartGrsContext    ; brif not - - - can't be any owners
					;  that we could hose here, and parms
					;  from Direct Mode CALL must not be
					;  released (example: call foo("bar")
					;  from direct mode)
	push	[b$pend]		;lomem of range to clear
	push	[b$mainframe]		;himem of range to clear
	call	B$ClearRange		;release any owners in given range
GoStartGrsContext:			; got relative jump out of range
	jmp	short StartGrsContext	

GetpRsCur:
	mov	bx,dataOFFSET prsCur
	test	byte ptr [grs.GRS_oRsCur+1],080H
	jnz	PrsIsActive1

	mov	bx,dataOFFSET mrsCur
PrsIsActive1:
	push	ds			;for later rep mov's and/or sto's
	pop	es
	cmp	[pGosubLast],0		;active pGosubLast chain?
	jz	Check_FrameVar_Size	;  brif not
	cmp	bp,[pGosubLast] 	; is the chain in this proc?
	jb	Check_FrameVar_Size	; no, then it's sure not active!

	.errnz	MRS_cbFrameVars - PRS_cbFrameVars
	.errnz	MRS_cbFrameTemp - PRS_cbFrameTemp
	mov	ax,[bx.MRS_cbFrameVars]
	add	ax,[bx.MRS_cbFrameTemp]
	mov	dx,ax
	sub	dx,si
	jbe	Check_FrameVar_Size	;brif sufficient frame space exists

	;Frame size has been increased; must move all gosub frames down to
	;account for the difference
	;Do this in two steps:
	;	(1) update pGosubLast chain to account for movement
	;	(2) move all gosub frames down.
	;Note that there can be an event gosub frame here, but if so, it
	;	has to be the active mrs frame - - - we can treat this the
	;	same way.
	push	di
	mov	di,[pGosubLast]
Update_Gosub_Ptrs:			;loop for step (1)
	mov	cx,[di]			;fetch ptr to next frame
	jcxz	Move_Gosub_Frames	;brif no more gosub frames
	sub	[di],dx			;update current frame ptr by amount
					;  we're moving frames down by
	mov	di,cx			;go on to next frame
	jmp	short Update_Gosub_Ptrs

Move_Gosub_Frames:			;now step (2), move frames down
	mov	cx,bp
	sub	cx,si			;cx points just past the end (himem)
					;  of range to be moved down
	xchg	ax,dx			;ax = amt to move gosub frames down by
	mov	si,[pGosubLast]		;start of range to move
	mov	di,si
	sub	di,ax
	mov	[pGosubLast],di
	sub	cx,si			;cx = number of bytes to move down
	pop	dx			;must pop this BEFORE we alter sp
	sub	sp,ax			;so interrupts won't overwrite gosub
					;  frames
	rep	movsb
	mov	di,dx			;di = old cbFrameVars
Check_FrameVar_Size:
	.errnz	MRS_cbFrameVars - PRS_cbFrameVars
	mov	dx,di			;dx = old cbFrameVars
	mov	cx,[bx.MRS_cbFrameVars]
	sub	cx,dx                   ;if cx > 0 then new vars have been added
	DbAssertFlags  ae,CODE,<excontxt: cbFrameVars got smaller!>
	jbe	Vars_Okay		;brif none have been added

	;cx = number of bytes worth of new frame vars added to current frame
	mov	al,0
	mov	di,bp
	sub	di,[bx.MRS_cbFrameVars]	;di points to start of new frame vars,
	cmp	sp,di
	jb	Got_SP			;brif sp was moved down when gosub
					;  frames were
	mov	sp,di			;so interrupts won't overwrite this
					;  after the stosb
Got_SP:
	rep	stosb			;initialize new frame vars

Vars_Okay:
	;fall into StartGrsContext
public	StartGrsContext
StartGrsContext:
	call	DisStaticStructs	;ensure static structs deactivated
	call	SetSP			;set SP based on BP	
	ja	StartGrs_Cont		;brif SP is in valid stack range

	mov	[b$ErrInfo],OMErr_STK	;out of stack space error
	jmp	OM_Err
StartGrs_Cont:
	mov	sp,ax		
	mov	si,[grs.GRS_otxCur]	;Load the continuation address
	xor	ax,ax
	mov	[grs.GRS_flagsDir],al	;reset flags which get reset every
					; time we begin executing pcode,
					; or when a runtime error occurs.
public	Start
Start:
	call	GetEsDi
Disp2:
	mov	[b$curframe],bp	;in case b$curframe got changed by
					;  the U.I. and not restored
	DbChk	BpChain			;ensure the bp chain is walkable

	DispMac 			; and begin execution

;***
;exStRunMain - Start program execution of the main module text
;Purpose:
;	Perform the RUN statement (no arguments) - begin program execution.
;
;Input:
;Output:
;Modifies:
;***************************************************************************
MakeExe exStRunMain,opStRunMain
	xor	di,di			;Set context to beginning of text tabl
					;  (put this in di in case of runtime
					;   error)
	mov	ax,[grs.GRS_oMrsMain]
	DbAssertRel ax,ne,UNDEFINED,CODE,<exStRunMain: grs.oMrsMain UNDEFINED>
Run_Otx:
	cCall	RsActivateCODE		;activate the main module
	cmp	[grs.GRS_fDirect],FALSE
	jz	RunMain1		;brif from pcode - - - must reinit stack

	or	[b$CtrlFlags],NoSTACKINIT
					;speed optimization for the case where
					;  RUN is given from UI. Don't bother
					;  to init. stack in RunInit, since
					;  we will go back into UI and init.
					;  the stack on exit when we actually
					;  start running this program.
RunMain1:
	cCall	RunInit 		;context mgmt work to prepare to RUN
	and	[b$CtrlFlags],NOT NoSTACKINIT
					;reset to default
	mov	si,di			;put oTx in si where it belongs
	mov	bp,[b$mainframe]	;reset frame and stack pointers
 	mov	word ptr [bp],0		;reinitialize end of bp chain
 	mov	word ptr [bp].FR_basBpLink,0	
					; reinitialize end of BASIC bp chain
	mov	sp,bp
	mov	[b$curframe],bp	;required by RT error handling code
	mov	bx,[grs.GRS_oMrsCur]	
	RS_BASE add,bx			
	GETRS_SEG es			
	mov	cx,PTRRS[bx.MRS_cbFrameTemp]	
	add	cx,PTRRS[bx.MRS_cbFrameVars]	
	sub	sp,cx			;make room for module level frame stuff
	DbAssertTst   sp,z,1,CODE,<excontxt.asm: (1) SP contains an odd number>
	or	ax,ax			;error return from RunInit?
	jz	ContOTx1		;  brif not
	jmp	short J1_RtErrorCODE	;error occured in RunInit - abort RUN

ContOtx1:
	mov	[grs.GRS_fDirect],FALSE ;Move to program mode
	jmp	Start			;Load segment & msv, check BosFlags & go

;***
; Cont_Otx
; Entry:
;	si = otx to start executing pcode
;****
PUBLIC	Cont_Otx
Cont_Otx:
DbAssertRel grs.GRS_oRsCur,z,grs.GRS_oRsCONT,CODE,<excontxt.asm: attempt to CONTinute where oRsCur != oRsCONT>
	mov	al,ER_CN		;"Cannot Continue" error
	inc	si			;test for UNDEFINED
	je	J1_RtErrorCODE		;brif otx = FFFF (can't continue)
	dec	si			;ax = otx
	call	ContReinit		;compress Bd's & Bdl's, reinit 80[2]87
	jmp	SHORT ContOtx1

page


;***
;SetProgramMode
;Purpose:
;	Common initialization for all executors which (could) cause
;	start of execution in the current text table from Direct Mode.
;Input:
;	global state variables grs.GRS_fDirect, grs.GRS_otxCONT,
;	mrsCur
;Output:
;	CX is set to what grs.GRS_fDirect HAD been on input (fDirect is always
;	set false).
;	ES & DI set by a call to GetEsDi.
;Modifies:
;	ES, DI, BX, CX
;Preserves:
;	ax, si
;**********************************************************************
PUBLIC	SetProgramMode
SetProgramMode	PROC NEAR
	cmp	[grs.GRS_fDirect],FALSE
	jz	Direct_Exit		;brif fDirect already was false

	push	ax			;preserve across call
	call	ContReinit
	pop	ax
Direct_Exit:
	xor	cx,cx
	xchg	cl,[grs.GRS_fDirect]	;set fDirect to FALSE, cl to previous
	call	GetEsDi 		;es = text segment, di = pTVar
					; ax, cx and dx unmodified
					;  fDirect value
	ret
SetProgramMode	ENDP

;***
;exStRunLabel - RUN <line #> executor
;Purpose:
;	Run the current module from the given line number.
;Input:
;	An oTxt in the pcode stream at which to begin execution.
;Output:
;	none.
;Modifies:
;***************************************************************************
MakeExe exStRunLabel,opStRunLabel
	LODSWTX 			;ax = oTx of Ln|Label
	xchg	ax,di			;put oTx in di (not si, in case a
					;  runtime error occurs in Run_Otx)
	mov	ax,[grs.GRS_oMrsCur]	;in case we're in a procedure
	jmp	Run_Otx			;oTx set - start program

J4_RtErrorCODE: 			
; If we have gotten an error from LoadFile before we threw away
; our current context then the error is still trappable.  We
; don't want to reset the stack because an error handler could
; be invoked.
; otxRunSave = otxCur before LoadFile  si = otxCur after LoadFile.
; If they are the same then LoadFile didn't toss our context.

	cmp	[otxRunSave],si 	;can we trap this error?
	je	J1_RtErrorCODE		;brif so, don't blast stack

	mov	[b$ErrNum],ax		;preserve error code across call
	call	DoFBosResetStk		;bash stack so we don't try to
					;  return to code we've thrown out
	mov	ax,[b$ErrNum]		;restore error code

J1_RtErrorCODE:
	call	RtErrorCODE		;error code already in ax

;	Note: Above call does not return

GrabFailed:				
	mov	ax,ER_OM		; set up out of memory return value
	cmp	[fInitialized],FALSE	
J5_RTErrorCODE: 			
	jnz	J4_RtErrorCODE		; brif not a command-line run
	push	ax			; save error code
	call	ShowOutScr		; erase debug screen
	pop	ax			; restore ax = error code
	call	RtError_INI		

;	Note: Above call does not return


;***
;exStChain - CHAIN <filename> executor
;Purpose:
;	Chain to the given program
;Input:
;	psdFileName is on the stack
;Output:
;	none.
;Modifies:
;***************************************************************************
MakeExe exStChain,opStChain
	mov	[fChaining],TRUE
	call	ChainCommon		;replace all user-defined oTyps in
					;  blank COMMON type table with the
					;  size of the record (since we trash
					;  all existing module type tables
					;  prior to loading the new program)
	SkipExHeader			;fall into exStRunFile
;***
;exStRunFile - RUN <filename> executor
;Purpose:
;	Reset the existing context, Load the given file, and run it.
;
;	NOTE: There are two ways into this code -
;		(1) Normal pcode dispatch of 'RUN <filename>'
;		(2) From init.asm in the case that the user specified a
;		    filename on the command line.
;	      In case (2), we must handle an error from LoadFile as a
;	      fatal error.
;Input:
;	psdFileName is on the stack (used by LoadFile).
;Output:
;	none.
;Modifies:
;***************************************************************************
MakeExe exStRunFile,opStRunFile
	call	EnStaticStructs 	;activate static prsCur, mrsCur, txdCur
					; (required for calling LoadFile)
	mov	[grs.GRS_otxCur],si	;LoadFile will reset this to 0002
					; if an error occurs after the existing
					; text table is discarded.
	mov	[otxRunSave],si 	;remember otxCur for error recov
	or	[conFlags],F_CON_RunFile
					;don't make debug screen active

	call	GrabSpace		; make sure we don't overcommit
	jz	GrabFailed		; brif GrabSpace didn't work

	mov	ax,LF_NewDoc		; assume document file
	call	fEditorActive		; is the editor active?
	jnz	RunFileLoad		; brif so, load a document
	mov	ax,LF_NewProg		; else it is a program
RunFileLoad:				
	push	ax			; tell LoadFile what type of file
	call	LoadFile		; and all loaded programs should be
					; discarded before the load
	and	[conFlags],NOT F_CON_RunFile	;reset to default
	mov	si,[grs.GRS_otxCur]
	push	ax			;save retval across call
	call	DisStaticStructs	;ensure static structs deactivated again
	call	ReleaseSpace		; release space grabbed above
	pop	ax
	xor	cx,cx			
	xchg	[fChaining],cl		; ensure flag is set to FALSE here,
					;   and remember (in cx) whether
					;   or not we're chaining
	or	ax,ax			;0 if no error in load/save
	jz	RunFile_No_Error

	cmp	[fInitialized],FALSE
	jnz	J5_RtErrorCODE		;brif not a command-line run [17]
	push	ax			;save error code
	call	ShowOutScr		;erase debug screen before reporting err
	pop	ax			;restore ax = error code
	call	RtError_INI		;fatal error

RunFile_No_Error:
	cmp	[fInitialized],FALSE	;did we get here direct from init.asm?
	jnz	Not_Initializing	;  brif not

	and	[BosFlags],not FBOSRESETSTK
	mov	[fInitialized],TRUE	 ;ensure this flag gets set in case
					 ;we're command-line loading [& running]
					 ;a program
	test	[cmdSwitches],CMD_SW_RUN ;Want to Run program, or just load it?
	jnz	Not_Initializing	 ;  brif we do want to run it
	jmp	EndProg1		 ;just wanted to load program
Not_Initializing:
	mov	ax,codeOFFSET exStRunMain
	jcxz	Run_Or_Chain		;brif this is for RUN, not CHAIN
	mov	ax,codeOFFSET exCont	;so RunInit won't take place
Run_Or_Chain:
	;Don't bother to realloc the direct mode buffer - - - assume there's at
	;  least 2-bytes there, for an opEot which we can simply replace.
	DbAssertRel grs.GRS_bdlDirect_cbLogical,ae,2,CODE,<exStRunFile error>
	GETSEG	es,grs.GRS_bdlDirect_seg ; ax = seg adr of far heap entry
	mov	es:[0],ax
	or	[debugFlags],DEBUG_EXEC_CMD
					;Tell UserInterface to execute what it
					;  finds in the direct mode buffer
	and	[grs.GRS_flagsDir],NOT FDIR_cleared
					;note that world is no longer clear
	mov	[grs.GRS_fDirect],TRUE	;must set this back in case of
					;  something like NEW : PRINT
	jmp	EndProg1		;ends up triggering UserInterface

;***
;exCont - (pseudo) executor for CONTinue
;Purpose:
;	CONTinue program execution.  NOTE: This is not really a
;	statement, and there is no opcode for it.  The only time
;	this can ever execute is after the CHAIN stmt executor
;	stuffs exCont into the direct-mode buffer.
;Entry:
;	grs.oRsCONT, grs.otxCONT indicates where next statement
;	to be executed is.
;Exit:
;	none
;Uses:
;	none
;Exceptions:
;	Can cause "Cant continue" error
;
;***************************************************************************
MakeExe exCont,opStRunMain
;NOTE: opStRunMain for exCont is no mistake; there is no CONT opcode, but
;NOTE: we need this MakeExe because the executor is inserted into the Direct
;NOTE: mode buffer, and there is code which needs the MakeExe to properly
;NOTE: (and safely) determine if exCont can cause execution or not (so the
;NOTE: output screen is made active as appropriate, I believe ... see tomc)
	mov	si,[grs.GRS_otxCONT]
	jmp	Cont_Otx

;***
;exStClear - CLEAR statement executor
;Purpose:
;	Perform the CLEAR statement.
;Input:
;	all of the arguments are already on the stack, except for the
;		(2-byte) count of arguments.
;	Note that both flags and values are I4's. The count of arguments
;	is a count of I4's on the stack.
;
;Input Examples (Stack contents):
;
;	CLEAR ,2000				CLEAR 1000,,3000
;
;              +----+                                 +----+
;              |0000|                                 |FFFF|
;              +----+  Flag  (FALSE)                  +----+  Flag  (TRUE)
;              |0000|                                 |FFFF|
;              +----+                                 +----+
;              |FFFF|                                 |0000|
;              +----+  Flag  (TRUE)                   +----+  Value (1000)
;              |FFFF|                                 |03E8|
;              +----+                                 +----+
;              |0000|                                 |0000|
;              +----+  Value (2000)                   +----+  Flag  (FALSE)
;              |07D0|                                 |0000|
;              +----+                                 +----+
;                                                     |FFFF|
;                                                     +----+  Flag  (TRUE)
;                                                     |FFFF|
;                                                     +----+
;                                                     |0000|
;                                                     +----+  Value (3000)
;                                                     |0BB8|
;                                                     +----+
;
;	Note that this executor blasts and possibly alters the location
;	of the stack.
;Output:
;	none.
;Modifies:
;	sp, bp, b$mainframe, b$curframe, b$pend, b$pendchk
;***************************************************************************
MakeExe exStClear,opStClear
	;must check for Illegal Function Call due to current frame not being
	;set for main level code - - - this duplicates runtime functionality,
	;but we do it here so we don't end up in a partially cleared state
	;when the error occurs (and this way, user can still continue).
	mov	bx,bp
	cmp	[b$inonerr],FALSE	;in an error handler?
	jz	Got_Frame_Ptr		;  brif not

	mov	bx,[bx]			;if so, account for the fact that we've
					;  pushed a frame for the handler
Got_Frame_Ptr:
	cmp	bx,[b$mainframe]
	jz	Clear_Cont

	mov	al,ER_FC		;"Illegal Function Call"
J3_RtErrorCODE:
	jmp	J1_RtErrorCODE

Clear_Cont:
	call	WatchRelease		
	call	GetEsDi			
	call	PStepReset		;If stackSize changes, and user
					; is pStepping (F10) through a
					; CLEAR ,,0 stmt, make sure we stop.
					; Assumes CLEAR stmt never occurs within
					; a procedure (very safe assumption)
	xor	cx,cx			;assume no stack parameter
	xor	bl,bl			;count of parm flags seen so far
	LODSWTX 			;fetch count of args on stack
	or	ax,ax
	jz	StClear1		;brif no parms

	shl	ax,1
	shl	ax,1			;convert cI4Parms to cbParms on stack
	mov	di,sp
	add	di,ax			;di points to word above 1st parm

	;Stack contains I4 flags and I4 values - - - when I4 flag is FALSE,
	;I4 value is not present. The below code moves to the first flag
	;and loops for each flag, fetching or skipping value as appropriate
	;when flag is non-zero.
	;At this point, ONLY the cbStack value is kept, and CX is set to
	;non-zero if it is found.
Clear_Parm_Loop:
	dec	di
	dec	di
	mov	dx,[di]			;get high word of I4 flag
	dec	di
	dec	di
	mov	ax,[di]			;get low word of I4 flag
	inc	bl			;inc count of parm flags seen
	cmp	bl,4			;More than 3 parms?
	jb	Clear_Parm_Cont		;  brif not

	mov	al,ER_ADF		;Advanced feature unavailable error
	jmp	J3_RtErrorCODE
Clear_Parm_Cont:
	or	ax,dx			;test to see if I4 flag is zero or not
					;  if it is, ax will end up non-zero
	jz	No_Value		;brif flag is zero; no value to fetch

	cmp	bl,3			;is cbStack value available?
	jz	Fetch_CbStack		;brif so

	sub	di,4
	jmp	short No_Value		;ignore this value
Fetch_CbStack:
	dec	di
	dec	di
	mov	dx,[di]			;get high word of I4 value
	dec	di
	dec	di
	mov	ax,[di]			;get low word of I4 value
	push	dx
	push	ax
	call	I4toU2			;replace I4 on stack with U2
	pop	ax
	mov	cx,sp			;set fStack non-zero
No_Value:
	cmp	di,sp
	ja	Clear_Parm_Loop		;brif more parms to fetch

	DbAssertRel di,z,sp,CODE,<exStClear: sp and di not the same>
StClear1:
	push	ax			;cbStack or garbage
	push	cx			;fStack
	call	ClearStmt
	call	GrabSpace		;don't let the user grab ALL of avail.
					;  DGROUP for his stack
	mov	[grs.GRS_otxCur],si	;update in case of runtime error
	call	B$SCLR
	mov	[b$mainframe],sp	;reset the main level frame ptr - -
					; (other reset tasks are done by
					;  exBos/exBol)
	mov	bp,sp			;sp set to start of stack by B$SCLR
					;  (whether the stack parm given or not)
	call	ReleaseSpace		;return temporarily grabbed space to
					;  system
	jmp	DispMov			;jump to common dispatch point

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\ir\exrefarg.asm ===
page	49,132
	TITLE	exRefArg - excutors that provide pointers to arguments
;***
;exRefArg - excutors that provide pointers to arguments
;
;	Copyright <C> 1986, Microsoft Corporation
;
;
;****************************************************************************

	.xlist
	include		version.inc
	IncludeOnce	executor
	IncludeOnce	exint
	IncludeOnce	extort
	IncludeOnce	opstmt
	IncludeOnce	rtinterp
	IncludeOnce	variable
	IncludeOnce	context
	IncludeOnce	pointers	
	.list

assumes cs, CODE
assumes es, NOTHING
assumes ss, DATA

sBegin	CODE

extrn	GetTempAddr:near

MakeExe	exPopPopPush,opNoList0
	pop	ax			;Thing to keep
	pop	dx			;Thing to blow off
	push	ax			;Keep it
	DispMac


	;The exPushSeg executor is forced to an odd address so it can not
	;be confused with an oVar or an oElem.	This is used in SsCoerceReg
	;to determine the oTyp of a record from the scan stack pointer.  The
	;exPushSeg may have been inserted if the evaluation of LHS of an
	;assignment to an element of an array of records could cause heap
	;movement.


	even				; Force even address
	db	1 dup(?)		; Force odd address

MakeExe	exPushSeg,opNoList0
	pop	ax			;Get offset
	push	ds			;Push segment
	push	ax			;   in front of offset
	DispMac

MakeExe	exCopyTmpAr,opNoList3		;oTemp,cb,oVar
;Copy array element to stack temp with info for copy back
;Construction of this temp:
;
;	dw	oVar
;	dd	relative position
;	dw	cb
;	db	<item>

	call	GetTempAddr		;Get addr of temp, adjusted for locals
	pop	bx			;Offset of source
	pop	ds			;Segment of source
	xchg	ax,dx			;Save destination in dx
	LODSWTX				;Get count of bytes
	xchg	cx,ax
	LODSWTX				;Get oVar
	push	es			;Save text segment
	push	si			;Save pc
	push	ss
	pop	es			;es = ss
	push	ds			;Save segment of source
	push	ss
	pop	ds			;ds = ss
	xchg	bx,ax			;oVar to bx, source offset to ax
	xchg	si,ax			;Set source
	push	bx
	call	oVarToPAd		;Get pAD in bx
	pop	ax
	xchg	di,dx			;Set dest, save di in dx
	stosw				;Save oVar in temp
	mov	ax,si			;Source offset
	sub	ax,[bx].AD_fhd.FHD_oData
	stosw				;Save relative offset in temp
	pop	ds
assumes	ds,NOTHING
	mov	ax,ds
	jnc	SubSeg
	sub	ah,10H			;Ripple carry into segment
SubSeg:
	sub	ax,ss:[bx].AD_fhd.FHD_hData ;sub phys seg from FHD
	stosw				;Save relative segment in temp
	mov	ax,cx
	stosw				;Save byte count
	mov	bx,di			;Address of value field
	rep	movsb			;Copy array element
	pop	si
	pop	es
	push	bx			;Put near address of value on stack
	mov	di,dx
	push	ss
	pop	ds			;Restore ds = ss
assumes	ds,DATA
	DispMac

MakeExe	exRestoreTmpAr,opNoList1	;oTemp
;Copy back array element that was copied to stack temp
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	push	si
	call	RestoreAddr
	jc	NoArRestore
	push	es
	mov	es,ax
	xchg	dx,di
	rep	movsb			;Copy array element back
	mov	di,dx
	pop	es
NoArRestore:
	pop	si
	DispMac

RestoreAddr:
;Compute address to which to restore an array element passed as parameter
;
;Input:
;	si = address of temp
;Output:
;	CY flag set if array too small
;	ELSE
;	ax:dx = address of array element
;	cx = size of element
;	si = si + 8 (points after temp info)
;
;Temp construction must be:
;	dw	oVar
;	dd	relative position
;	dw	count

	xchg	ax,si			;Temp address to si
	lodsw				;Get oVar from temp
	xchg	ax,bx			;oVar to bx
	call	oVarToPAd
	lodsw				;Relative offset of element
	mov	dx,ax			;Offset to di
	mov	cl,4
	shr	ax,cl			;Convert offset to paragraph count
	xchg	cx,ax
	lodsw				;Relative segment
	add	cx,ax			;Position in paragraphs
	cmp	cx,[bx].AD_fhd.FHD_cPara;Space allocated for it?
	jae	ArrayTooSmall
	add	dx,[bx].AD_fhd.FHD_oData
	jnc	SegOff
	add	ah,10H			;Ripple carry into segment
SegOff:
	add	ax,[bx].AD_fhd.FHD_hData    ;add phys seg to FHD
	xchg	cx,ax
	lodsw				;Get count of bytes
	xchg	cx,ax
	ret

ArrayTooSmall:
	stc
	ret


MakeExe	exCopyTmpArSD,opNoList2		;oTemp,oVar
;Assign string array element to stack temp, with info for copy back
;Construction of this temp
;
;	dd	SD
;	dw	oVar
;	dw	relative offset
;
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	pop	cx			;Get source offset
	push	ax			;Result - pSD
	push	cx			;Source for B$SASS
	push	ax			;Destination for B$SASS
	xchg	ax,bx			;Destination to bx
	xor	ax,ax
	mov	[bx],ax
	mov	[bx+2],ax		;Make sure temp is a null string
	LODSWTX				;Get oVar
	mov	[bx+4],ax
	xchg	bx,ax			;oVar to bx
	xchg	dx,ax			;Destination to dx
	call	oVarToPAd		;Get pAD in bx
	sub	cx,[bx].AD_fhd.FHD_oData;Compute relative offset
	mov	bx,dx
	mov	[bx+6],cx
	CALLRT	B$SASS,DispMov		;Assign string to stack temp

MakeExe	exRestoreTmpArSD,opNoList1	;oTemp
;Assign string array stack temp back to origin
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	xchg	ax,bx			;Source to bx
	push	bx			;This copy for assign (source)
	mov	dx,[bx+6]		;Get relative offset
	mov	bx,[bx+4]		;Get oVar
	call	oVarToPAd		;Get pAD in bx
	cmp	dx,[bx].AD_fhd.FHD_cPara;Within current bounds?  NOTE: cPara 
					;   has byte count for near arrays
	jae	NoSdRestore		;Don't restore if out of range
	add	dx,[bx].AD_fhd.FHD_oData
	push	dx
	push	dx			;Destination
	CALLRT	B$STDL			;De-allocate current string
	pop	ax
	pop	bx			;Source SD
	mov	cx,[bx]
	mov	bx,[bx+2]		;Get SD
	xchg	ax,bx
	mov	[bx],cx
	mov	[bx+2],ax		;Assign SD
	jcxz	NoBack			;If nul, don't adjust backpointer
	xchg	bx,ax			;bx = pointer to string data
	mov	[bx-2],ax		;Set back pointer
NoBack:
	DispMac

NoSdRestore:
;pSD already on stack
	CALLRT	B$STDL			;De-allocate temp string
	jmp	NoBack

MakeExe	exCopyTmpArFS,opNoList2		;oTemp,oVar
;Copy FS array element to SD stack temp with info for copy back
;Construction of this temp:
;
;	dd	SD
;	dw	oVar
;	dd	relative position
;	dw	cb

	call	GetTempAddr		;Get addr of temp, adjusted for locals
	pop	dx			;cb
	pop	bx			;Source offset
	pop	cx			;Source segment
	push	ax			;Result pSD
	add	ax,4			;Point past SD
	push	cx
	push	bx
	push	dx
	xchg	dx,ax			;Save destination in dx
	LODSWTX				;Get oVar
	xchg	bx,ax			;oVar to bx
	push	bx
	call	oVarToPAd		;Get pAD in bx
	pop	ax
	mov	di,dx			;Set dest
	push	ss
	pop	es			;es = ss
	stosw				;Save oVar in temp
	pop	dx			;cb
	pop	ax			;Source offset
	push	ax
	sub	ax,[bx].AD_fhd.FHD_oData
	stosw				;Save relative offset in temp
	xchg	ax,cx
	jnc	SubSegs
	sub	ah,10H			;Ripple carry into segment
SubSegs:
	sub	ax,ss:[bx].AD_fhd.FHD_hData ;sub phys seg from FHD
	stosw				;Save relative segment in temp
	xchg	ax,dx
	stosw				;Save byte count
	sub	di,12			;Point to SD again
	jmp	short CopyFStoSD

MakeExe	exRestoreTmpArFS,opNoList1	;oTemp
;Copy back FS that was copied to SD stack temp
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	push	ax			;pSD for deallocation
	push	ds
	push	ax			;Far address of SD
	xor	cx,cx
	push	cx			;cb=0 means SD
	add	ax,4			;Skip over SD
	push	si
	call	RestoreAddr
	pop	si
	jc	NoFsRestore
	push	ax			;Segment of FS
	push	dx			;Offset of FS
	push	cx			;Count of bytes
	jmp	short RestoreFS

NoFsRestore:
	add	sp,8			;Clean off arguments
	DispMac

MakeExe	exCopyTmpFS,opNoList1		;oTemp
;Copy FS to SD stack temp with info for copy back
;Construction of this temp:
;
;	dd	far address
;	dw	cb
;	dd	SD

	call	GetTempAddr		;Get addr of temp, adjusted for locals
	xchg	ax,di
	pop	dx			;cb of FS
	pop	ax			;offset of FS
	pop	cx			;Segment of FS
	push	ds
	pop	es			;es = ds
	stosw				;Save offset in temp
	xchg	ax,cx
	stosw				;Save segment in temp
	xchg	ax,dx
	stosw				;Save cb in temp
	push	di			;Pointer to SD result
	push	dx			;Segment
	push	cx			;Offset
CopyFStoSD:
	push	ax			;cb
	push	ds
	push	di			;Far pSD
	xor	ax,ax
	stosw
	stosw				;Make sure temp is a null SD
	push	ax			;Flag as SD - cb=0
	CALLRT	B$ASSN,DispMov

MakeExe	exRestoreTmpFS,opNoList1	;oTemp
	call	GetTempAddr		;Get addr of temp, adjusted for locals
	mov	bx,ax
	add	ax,6			;Point to SD
	push	ax			;Save pSD for de-allocation
	push	ds
	push	ax
	xor	cx,cx
	push	cx			;cb=0 means SD
	push	[bx+2]			;Segment
	push	[bx]			;Offset
	push	[bx+4]			;cb
RestoreFS:
	CALLRT	B$ASSN			;Assign to FS - no errors possible
	CALLRT	B$STDL,Disp		;De-allocate string space

MakeExe	exStringTemp,opNoList0
	CALLRT	B$SCPY,DispMovAx

sEnd	CODE
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\ir\init.asm ===
TITLE   INIT - interpreter-specific initialization code
;***
;init.asm - interpreter-specific initialization code
;
;       Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;       This module contains the initial entry point to QBI.
;
;*******************************************************************************

        .xlist
        include         version.inc
        INIT_ASM = ON
        includeOnce     architec
        includeOnce     context
        includeOnce     executor
        includeOnce     heap
        includeOnce     parser
        includeOnce     qbimsgs
        includeOnce     rtps
        includeOnce     rtinterp
        includeOnce     ui
        .list

assumes DS, DATA
assumes ES, NOTHING
assumes SS, DATA

IFNDEF IBMBASIC
;; [QH1] - Max length of topic argument to Dos6 QHelp
ENDIF
cbmaxTOPIC equ 40

sBegin  DATA
        externW __acmdseg
        externW __acmdln
        externB b$CtrlFlags        ;global runtime flag bits
        externB fRecord            ;global flag, set TRUE is /RCD switch seen
        globalW cmdSwitches,0      ;global bit flags for command-line switches
        globalB fInitialized,0     ;set non-zero when initializing completed
        globalW __acmdln_orig,0    ;original value of __acmdln
        globalB fQedit,0
IFNDEF IBMBASIC
; [QH1]
ENDIF
        globalB szCmdLineTopic,0,cbmaxTOPIC     ; Buffer to save topic arg in


sEnd    DATA

        EXTRN   B$IINIT:FAR
        EXTRN   B$LDFS:FAR
        EXTRN   B$IScram:FAR
        EXTRN   B$IInitPrint:FAR
        EXTRN   exEot:FAR
        EXTRN   exStRunFile:FAR
        EXTRN   InitUIStack:FAR

sBegin	RT
externNP B$LH_FROM_SS
externNP B$NHINIT
sEnd	RT

sBegin  RARE
assumes CS, RARE
        subttl  Process MSDOS COMMAND line.
        page

switch_codes equ $
NUM_SWITCHES = 8
        db      'BEGHMNQR',0

; Stored in reverse order to switch_codes.
; NOTE: If you add a switch, update the Invalid Switch message in qbimsgs.txt

switch_jmps  dw offset Proc5_R  ;/RUN load file and run it
             dw offset Proc5_Q  ;/QHELP MS-DOS Help Viewer
             dw offset Proc5_N  ;/NOHI no Highlighted colors
             dw offset Proc5_M  ;/M translate MKS to MKSMBF, CVS to ... etc.
             dw offset Proc5_H  ;/H Highest resolution possible
             dw offset Proc5_G  ;/G Glitch flag for SHELL.
             dw offset Proc5_E  ;/Editor
             dw offset Proc5_B  ;/B Color On/Off.

;***
;_main - Entry point to the Quick Basic Interpreter
;Purpose:
;       Entry point from startup code to QBI.
;       Parses the command line, initializes the runtime, initializes the
;       global context, sets up the stack, and starts the interpreter.
;Input:
;       __acmdseg is a pointer to a pointer to the segment address of cmd line
;       __acmdln is the offset to the cmd line string (can be accessed as
;               a far ptr to command line).
;Output:
;       none; never returns. Program terminates via the runtime.
;*****************************************************************************
cProc   _main,<PUBLIC,FAR,NODATA>

;***************************** NOTE - NOTE - NOTE *****************************
CB_MAIN_LOCALS EQU 12d+2        ;We're resetting SP & BP at the end of _main,
                                ;based on the above number of Local's - - - if
                                ;you add or remove any local's, change this
                                ;constant (note that the constant is too large
                                ;by 2 bytes to account for the PUSH BP that
                                ;occurs at the start of _main).
;***************************** NOTE - NOTE - NOTE *****************************
        localW  cbComBuffer        ;For saving /C:nnn value.
        localW  cbLibName       ;for saving length of library name
        localW  cmdSeg          ;seg part of pointer for command line
        localW  pLibName        ;for saving ptr to library name

        ;NOTE: The order of these first local's is part of the interface
        ;NOTE: to B$IINIT - - we pass a pointer to pLibName, and B$IINIT
        ;NOTE: accesses these directly

        localW  cbFileName      ;for saving length of input program
        localW  pFileName       ;for saving ptr to program to load & run

cBegin

        xor     ax,ax
        mov     es,ax
        mov     al,es:[0417H]
        and     al,0fH
        cmp     al,0fH
        jne     @F
        call    InitUIStack
@@:
        ;
        ; Process the Command Line
        ; Perform the specialized processing of the command line for the QBI

        mov     [pLibName],0    ;default - no /L
        mov     [cbComBuffer],CbComBuf ;default Com Buffer size

        mov     si,[__acmdln]
        mov     [__acmdln_orig],si ;save in case user wants to change his
                                     ; command$ string later - - -
        mov     ds,[__acmdseg]  ;DS:SI == MSDOS Command line buffer.
        mov     [cmdSeg],ds     ;save in case we're passing LibName to runtime
assumes DS, NOTHING

        xor     dx,dx           ;initially, all flags false.
Proc2:
        lodsb
Proc2a:
        cmp     al,9
        je      Proc2           ;brif horizontal tab found

        cmp     al,' '
        je      Proc2
        jb      Proc2c          ;All done parsing command line

        cmp     al,'/'          ;Look for switch character.
        je      Proc3           ;Working on a switch.

Proc2b:
        ;user specified a filename to load [& run if CMD_SW_FLE is set]
        test    dx,CMD_SW_FLE   ;already seen a filename?
        jnz     SYS_Error1      ;brif so - - - error

        or      dx,CMD_SW_FLE   ;remember that we're to load this file
        dec     si
        mov     [pFileName],si  ;save pointer to start of filename
        lea     bx,[cbFileName] ;store size of filename here
Proc2d:
        ;parse and count bytes in a filename. Note that this is used
        ;  for the /L (user library) name as well
        inc     si              ;move back to point to 2nd byte of filename
        xor     di,di           ;initialize name length to zero
Proc2d1:
        inc     di              ;last char was part of filename - count it
        lodsb

        cmp     al,' '
        jb      Proc2d2         ;brif end of cmdline
IFNDEF IBMBASIC
;; [QH1]
ENDIF
        test    dx,CMD_SW_QHELP ; Are we running as QHELP?
        jnz     Proc2d1         ; If so, we allow multi-word topics, so ignore
                                ; whitespace, and any "/" switches after topic.
                                ; WARNING : /QHELP switch MUST be first!
    ; If not QHelp mode, enable normal param error checking
        cmp     al,'/'
        je      Proc2d2         ;brif switch found - end of filename

        cmp     al,9
        je      Proc2d2         ;brif tab found - end of filename

        cmp     al,' '
        ja      Proc2d1         ;brif not end of filename
Proc2d2:
        mov     ss:[bx],di      ;save size of filename
        jmp     short Proc2a    ;All done counting filename - proceed w/parsing

Proc2c:
        jmp     Proc7           ;Control Characters terminate differently.

;
; Process Switch character "/"
;

Proc3:
        lodsb                   ;Get switch type.
        and     al,5Fh          ;Brute force to upper case.
        mov     cx,NUM_SWITCHES ;Only check for active switches.
        mov     di,offset switch_codes
        push    cs
        pop     es              ;es:di set for scasb
        repnz   scasb
        jnz     SYS_Error1      ;Error condition - invalid switch

        shl     cx,1
        mov     bx,cx
        jmp     [switch_jmps+bx]

;
; The actual switch codes are processed here.
;

SYS_Error1:
SYS_Error:
        mov     ax,ER_ISWEDIT   ;begining editor message
        mov     di,ER_ISWEDITEND;ending editor message
        test    dx,CMD_SW_EDCOM ;were we started from EDIT.COM?
        jnz     PrintMsgs       ;brif so, we have proper message set
        mov     ax,ER_ISWQHELP  ;begining qhelp message
        mov     di,ER_ISWQHELPEND;ending qhelp message
        test    dx,CMD_SW_QHELP ;were we started from EDIT.COM?
        jnz     PrintMsgs       ;brif so, we have proper message set
        test    dx,CMD_SW_EDCOM ;were we started from EDIT.COM?
        mov     ax,ER_ISWINTERP ;Use message set for interpreter
        mov     di,ER_ISWINTERPEND
PrintMsgs:
        push    ax              ;save message number
        call    B$IInitPrint    ;print message AX to stdout
        mov     ah,2            ;print character to STDOUT
        mov     dl,13           ;Carriage Return
        int     21h
        mov     dl,10           ;Line Feed
        int     21h
        pop     ax              ;restore ax = message number
        inc     ax              ;move to next message
        cmp     ax,di           ;have we gone beyond last message?
        jbe     PrintMsgs       ;brif not, display another line
        call    B$IScram        ;scram, i.e., get out of town, never returns.
                                ; just sets appropriate error code and exits.
        DbHalt  RARE,<init.asm: B$IScram returned>
Proc5_B:
        or      dx,CMD_SW_MNO   ;remember that /B switch was seen
        jmp     short Proc2_Relay1

Proc2_Relay1:
        lodsb
        cmp     al,' '
        jbe     NextChar_OK

        cmp     al,'/'
        jnz     SYS_Error       ;only whitespace, another switch, or end of
                                ;  command line is valid as the immediately
                                ;  following char after a valid switch
NextChar_OK:
        jmp     Proc2a

Proc5_M:
        lodsw                   ;Get 2 chars
        and     ax,5F5Fh        ;Brute force both chars to upper case.
        cmp     ax,04642H       ;'BF' of '/MBF' switch
        jnz     SYS_Error

        or      dx,CMD_SW_MBF   ;remember that /MBF switch was seen
        jmp     short Proc2_Relay1


Proc5_H:
        or      dx,CMD_SW_HIR   ;remember that /H switch was seen
        jmp     short Proc2_Relay1

Proc5_G:
        or      dx,CMD_SW_GLT   ;remember that /G switch was seen
        jmp     short Proc2_Relay1

Proc5_N:
        lodsw                   ;Get 2 chars
        and     ax,5F5Fh        ;Brute force both chars to upper case.
        cmp     ax,0484FH       ;'OH' of '/NOHI' switch
        jnz     SYS_Error
        lodsb                   ;get third char
        and     al,5Fh          ;force to upper case
        cmp     al,49H          ;'I' of '/NOHI' switch
        jnz     SYS_Error

        or      dx,CMD_SW_NOH   ;remember that /NOHI switch was seen
        jmp     short Proc2_Relay1

Proc5_R:
        lodsw                   ;Get 2 chars
        and     ax,5F5Fh        ;Brute force both chars to upper case.
        cmp     ax,04443H       ;'CD' of '/RCD' switch
        jnz     Proc5_R_Try_RUN ;  brif not '/RCD' switch

        mov     [fRecord],TRUE  ;remember that /RCD switch was seen
Proc2_Relay2:
        jmp     short Proc2_Relay1

Proc5_R_Try_RUN:
        cmp     ax,04E55H       ;'UN' of '/RUN' switch
        jnz     J_SYS_Error
        or      dx,CMD_SW_RUN   ;remember that we're to execute the file
                                ;  that's found
        ;error if filename not found now
Proc5_R1:
        lodsb                   ;Get ascii character.
        cmp     al,9
        je      Proc5_R1        ;brif horizontal tab found

        cmp     al,' '
        je      Proc5_R1        ;brif space found
        jb      J_SYS_Error     ;brif end of command line

        cmp     al,'/'          ;Look for switch character.
        jne     Proc5_R_OK
J_SYS_Error:
        jmp     SYS_Error       ;  brif found - - filename not found after /R

Proc5_R_OK:
        jmp     Proc2b          ;process filename and continue

Proc5_E:
        or      dx,CMD_SW_ED    ;remember that /Editor switch was seen
        lodsb                   ; get next character (must be D)
        mov     bx,offset EditorSwitch  ; ptr to string to match
        mov     cx,si           ; save ptr to source string

Proc5_E1:
        and     al,5fH          ; convert to upper
        cmp     al, cs:[bx]     ; is it the next legal character
        jnz     Proc5_E3        ; no, not /EDITOR
        inc     bx              ; bump pointer
        lodsb                   ; grab next character of switch
        cmp     al,'/'          ; until we see the next switch
        je      Proc5_E2        ;  or
        cmp     al,' '          ; until we see a space or end of line
        ja      Proc5_E1

Proc5_E2:
        dec     si              ; back up one character
Proc2_Relay3:
        jmp     Proc2_Relay1

EditorSwitch:
        db      'DITOR',0       ; valid chars of switch, 0 to catch
                                ; a switch that is too long

Proc5_E3:
        ;/EDITOR not found, look for /EDCOM (all uppercase)
        mov     si,cx           ;restore pointer to source (after D)
        dec     si              ;backup in case second letter was not D
        lodsw                   ;grab two character (DC)
        cmp     ax,'CD'         ;is it correct?
        jne     J_SYS_Error     ;brif not
        lodsw                   ;grab last two chars (OM)
        cmp     ax,'MO'         ;is it correct?
        jne     J_SYS_Error     ;brif not
        or      dx,CMD_SW_EDCOM ;indicate switch seen
        jmp     SHORT Proc2_Relay3 ;go look for more switches


Proc5_Q:
        ; Look for /QHELP (all uppercase)
        ; If we find it, we turn on CMD_SW_ED, too, so that we can
        ; avoid QBASIC code paths by default!
        lodsw                   ;grab two character (HE)
        cmp     ax,'EH'         ;is it correct?
        jne     J_SYS_Error     ;brif not
        lodsw                   ;grab last two chars (LP)
        cmp     ax,'PL'         ;is it correct?
        jne     J_SYS_Error     ;brif not
        or      dx,CMD_SW_QHELP or CMD_SW_ED ;indicate switch seen
        jmp     SHORT Proc2_Relay3 ;go look for more switches

;
; Finished parsing line.
;


Proc7:
        dec     si              ;point to terminating character
Proc7a:
        push    ss
        pop     ds              ;restore ds=ss
assumes DS, DATA
        mov     [__acmdln],si   ;change __acmdln to point past filename
                                ;  to end of buffer, if no filename given

        test    dx,CMD_SW_QHELP ; Are we running as QHELP?
        jz      Proc7b          ;   NO, don't modify flags
        jmp     DoQHelpStuff

DoQHelpDone:
Proc7b:
        mov     [cmdSwitches],dx ;save for global access

        test    dx,CMD_SW_ED    ; are we in editor mode?
        jz      NotEditor       ; brif not
        test    dx,CMD_SW_RUN or CMD_SW_MBF ; conflicting switches?
        jnz     J_SYS_Error     ; brif so, error out
NotEditor:

        push    [cmdSeg]        ;push these 3 bp-relative parms to B$LDFS now,
        push    [pFileName]     ;  because B$IINIT trashes bp
        push    [cbFileName]

        lea     si,[pLibName]   ;pass pointer to parm block to B$IINIT
        or      [b$CtrlFlags],NoSTACKINIT
                                ;speed optimization - - -
                                ;  Don't bother to init. stack, since
                                ;  we will init. the stack when we actually
                                ;  start running a program.
IFDEF ROMBASIC

IFNDEF IBMBASIC

;	The IBM specific version of QBASIC will only run on machines with
;	IBM's BASIC ROM.  The ROM is at F600:0000 in old machines, but with
;	the new machines we need to do a BIOS call to find out where it is.
;	(If the BIOS indicates that call is not supported then we must by
;	on an old machine with the ROM at F600:0000.)
;	The near heap code from B$LH_FROM_SS to B$NHINIT has been
;	XOR'ed with that ROM image.  XOR it again here to restore the
;	near heap code to executable.  If we're not running on an IBM
;	machine we'll end up with garbage code and crash during the
;	first call to the near heap.
;	IBM's new spec for the ROM reduction uses a BIOS call to locate
;	ROM BASIC instead of assuming F600.  It is as follows:
;
;	Interrupt 15H
;		AH = 22H
;	EXIT:
;		ROM resident Basic present
;
;UNDONE: This should be just ES, not ES:BX, because the offset must be zero.
;		(ES:BX) = Pointer to Basic
;		(CY)	= 0
;		(AH)	= 0
;
;		ROM resident portion Basic not present (should never happen)
;
;		(ES:BX) = Undefined
;		(CY)	= 1
;		(AH)	= 1
;
;	Old BIOS versions return:
;
;		(CY) = 1
;		(AH) = 86H
ENDIF

assumes DS,nothing

labelNP <PUBLIC,IBMRom>

	push	ds
	push	si

	mov	ah,22h
	int	15h

	mov	ax,es		; assume new ROM with BASIC
	jnc	j111		; brif new ROM with BASIC
	mov	ax,0F600h	; else assume it's the old ROM
j111:	mov	ds,ax
	xor	si,si		; DS:SI points to ROM image
	mov	bx,RToffset B$LH_FROM_SS
	mov	ax,seg B$LH_FROM_SS
	mov	es,ax		; ES:BX points to code to manipulate
j112:	lodsw
	xor	es:[bx],ax	; do it.
	inc	bx
	inc	bx
	cmp	bx,RToffset B$NHINIT ; done?
	jb	j112		; brif not, keep looping
	pop	si
	pop	ds

assumes DS,data
ENDIF


        call    B$IINIT
        and     [b$CtrlFlags],NOT NoSTACKINIT
                                ;reset to default

        cCall   InitContext
        jnz     OM_Err_In_Init  ; brif error return

        cCall   ParseInit
        cCall   ParseNewInit
        or      ax,ax
        jnz     Main_Done       ;brif no error return
OM_Err_In_Init:
        call    RtErrorOM_INI   ;Out of Memory during init - abort
Main_Done:
        cCall   UiInit          ;read file qb.ini
        xor     cx,cx           ;assume no filename
        mov     dx,4+CB_MAIN_LOCALS+6 ;assume no filename
        test    [cmdSwitches],CMD_SW_FLE
        jz      Exit_main       ;brif no filename given

        ;parms to B$LDFS are already on the stack
        call    B$LDFS          ;ax = psdTemp for user-specified filename
        mov     cl,1            ;remember there was a filename given
        mov     dx,4+CB_MAIN_LOCALS ;B$LDFS took its 3 parms off stack already
Exit_main:
        add     sp,dx
                                ;set sp & bp up as high as we can - - - i.e.,
                                ;eliminate local's and return address from _main
        mov     bp,sp
        mov     [b$mainframe],bp ;frame to reset sp & bp to on RUN/CHAIN/NEW
        mov     [b$curframe],bp ;LoadFile wants this setup in case of error
        mov     [bp],word ptr 0 ;runtime assumes bp chain to be 0-terminated
        jcxz    No_File_Name

        push    ax              ;pass psdFileName
        jmp     exStRunFile     ;load [& start] specified program running

No_File_Name:
        inc     [fInitialized]  ;remember that we're done initializing now
        jmp     exEot           ;start execution - never returns


DoQHelpStuff:
IFNDEF IBMBASIC
;;
;; [QH1], Dos6 QHelp - If topic given on commandline, save it elsewhere and
;;              clear CMD_SW_FLE flag so qbasic doesn't try to load it as a
;;              file!  We'll process it later, in uihelp.c.
;;      (Had to move it down here as it was screwing up everyone's short jumps)
;;
ENDIF
        mov    szCmdLineTopic, 0        ;clear topic buffer

        test    dx,CMD_SW_FLE           ;do we have a topic argument?
        jnz     GetTopic                ; brif so
        jmp     DoQHelpDone

GetTopic:
IFNDEF IBMBASIC
;;
;; Copy topic name to szCmdLineTopic
;;
ENDIF
        and     dx, NOT CMD_SW_FLE      ; Don't want QBASIC to try to run it!
        push    ds
        push    es
        cld
        mov     di, DATAOFFSET szCmdLineTopic

        mov     ax, ds                  ; Load ES with DATA seg
        mov     es, ax
        mov     ds, cmdSeg              ; Load commandline seg
assumes DS, NOTHING
assumes ES, DATA
        mov     si, pFileName
        mov     bx, si
        add     bx, cbFileName

IFNDEF IBMBASIC
    ; BUGBUG - If user stuck tabs in the middle of the topic, the search will
    ;     fail later.  That's too bad.  If someone complains, i'll add in the
    ;     code to strip them out.
ENDIF
StripWhite:

IFNDEF IBMBASIC
    ; Strip off any terminating white-space
ENDIF
        dec     bx                      ; Start with last char, not terminator
        mov     al, BYTE PTR ds:[bx]
        cmp     al, ' '
        je      StripWhite
        cmp     al, 9
        je      StripWhite
IFNDEF IBMBASIC
    ; Now get real length
ENDIF
        inc     bx
        sub     bx, si                  ; length = end - start
        mov     cx, bx

        cmp     cx, cbmaxTOPIC          ; Make sure it's not too long
        jl      TopicNotTooLong
        mov     cx, cbmaxTOPIC-1        ; If so, truncate it
TopicNotTooLong:
        rep     movsb
        mov     BYTE PTR es:[di], 0     ; Make it asciiz

        pop     es                      ; Restore everything.  (Not needed?)
        pop     ds
assumes DS, DATA
assumes ES, NOTHING
        jmp     DoQHelpDone


cEnd    <nogen>

sEnd    RARE

        end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\ir\rterror.asm ===
TITLE	RTERROR - interpreter-specific error handling code
;***
;rterror.asm - interpreter-specific error handling code
;
;	Copyright <C> 1986, 1987 Microsoft Corporation
;
;Purpose:
;	This module contains interpreter-specific code to restore context
;	to a clean state after some runtime error occurs, or to invoke a
;	users error trap if one exists.
;
;
;*******************************************************************************

	.xlist
	include 	version.inc

;set these runtime switches, just so we can include messages.inc (which
;we include just so we can map their internal error constants to ours)
FE_EVENT = TRUE
OM_DOS2  = TRUE
OX_XENIX = FALSE

	RTERROR_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	executor
	includeOnce	exint
	includeOnce	heap
	include 	messages.inc
	includeOnce	names
	includeOnce	opcontrl
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	rtps
	includeOnce	scanner			
	includeOnce	txtmgr
	includeOnce	ui
	includeOnce	util
	.list

assumes DS, DATA
assumes SS, DATA
assumes ES, NOTHING

sBegin	DATA
	externW	b$fInt24Err	; 0 ==> rt gives error on int 24
				; -1 ==> rt saves int24 error code and
				;        ignores it. No errors have occurred
				; NZ ==> an int24 error has occurred
	externB	b$inonerr	;TRUE if currently executing in an error trap
	externW	b$errnum	;standard BASIC error code for error
	externW	b$errlin	;line number of error
	externD	b$erradr	;far address of error if in compiled code
	externD	b$errmod	;far pointer to name of module in which error
				;  occurred
	externW	b$fcomperr	;Set 0 by B$IONERR to tell user interface that
				;  error occured in QB4 code; if non-zero, tells
				;  UI to use b$errmod, b$erradr.
	externW	b$cCSubs	;count of invocations of compiled BASIC code
	externB	b$ErrInfo	;extended error codes (UI <--> Runtime)
	externW RtDispVecHigh	;must be reset on runtime error
	staticW	otxSave,0	
	staticW	oRsSave,0	
	staticW	pGosubSave,0	
	globalB fBreakOnErr,0	
sEnd	DATA

	EXTRN	B$RUNERRINFO:FAR
	EXTRN	B$END:FAR	;call if internal error to force QB4 termination
	EXTRN	B$PUTS:NEAR	;used to output err msg for really fatal errors
	EXTRN	B$ClearRange:FAR ;frees all owners in a given range
	EXTRN	SetSpFar:FAR	;used to restore BOS/BOL SP based on BP
	EXTRN	B$ASSN:FAR	;used to obtain SEG address of runtime entry pts
	EXTRN	B$STDALCALLTMP:NEAR	
				; frees temp strings at or above current levl
	EXTRN	B$RESUMED:far	; RT support code for the RESUME stmt

;	Message numbers used by the UL loader.

	PUBLIC	ER_DMA		;Dos Arena error
	PUBLIC	ER_ULM		;Memory allocation error
	PUBLIC	ER_ULO		;Out of memory error
	PUBLIC	ER_ULI		;Invalid user library format error
	PUBLIC	ER_ULD		;Disk IO error
	PUBLIC	ER_ULF		;Cannot find file error (if redirected IO)
	PUBLIC	ER_ULE		;Error message preamble
	PUBLIC	ER_ULG		;Error message postamble
	PUBLIC	ER_ULP		;Path prompt preamble
	PUBLIC	ER_ULT		;Path prompt postamble

	.errnz	FE_QBINITBASE AND 00FFH
				;assuming that low-byte of FE_QBINITBASE is 0
	QB_RTERR_MASK EQU FE_QBINITBASE SHR 8
				;byte mask to OR into a normal error message
				;  to make it a QB-specific initialization
				;  error code (but print out w/same string)

sBegin	RT
assumes CS, RT

;***
; B$PUTNUM - Print numbered message to the screen
;
;Purpose:
; Prints a string to the console device (B$PTRFIL = 0), as referenced by the
; passed message number
;
;Entry:
; [AX] = Message number
;
;Exit:
; none.
;
;Uses:
;
;******************************************************************************
cProc	B$PUTNUM,<NEAR,PUBLIC>
cBegin
	or	ah,ah			;internal error?
	jz	Got_QB4_Err		;brif not - error number o.k.

	cmp	ah,QB_RTERR_MASK	;error during init noted in own code?
	jnz	Not_QB_Init_Error	; brif not one of ours

	xor	ah,ah			;mask of high byte; al contains a
					; standard runtime error message
	jmp	short Got_QB4_Err
Not_QB_Init_Error:
	DbAssertRel  ax,nz,FE_NOLINEBASE,RT,<B$PUTNUM Error>
	mov	bx,FE_NOTHINGBASE	;first Runtime message # in fourth set
	mov	cx,ER_D21		;first QB4 message # in fourth set
	cmp	ax,bx
	jnb	Get_QB4_Err		;brif in last of 4 internal msg sets

	mov	bx,FE_BASE		;first Runtime message # in middle set
	mov	cx,ER_SSC		;first QB4 message # in middle set
	cmp	ax,bx
	jnb	Get_QB4_Err		;brif in first of 4 internal msg sets

In_First_Set:
	mov	bx,MS_BASE		;first Runtime message # in first set
	mov	cx,ER_RFS		;first QB4 message # in first set
Get_QB4_Err:
	sub	ax,bx			;ax = offset into appropriate group
	add	ax,cx			;add start of QB4 message group
Got_QB4_Err:
	cCall	ListStdMsgFar,<ax>	;put error msg in bufStdMsg
	mov	dx,ds
	mov	ax,dataOFFSET bufStdMsg	;dx:ax points to error message
	cCall	B$PUTS
cEnd

;***
;B$IErrSaveState
;Purpose:
;	This routine added as part of revision [5].
;
;	Save key QB-specific state variables away so that a later call to
;	B$IErrRestState can restore them.
;Entry:
;	none.
;Exit:
;	none.
;*******************************************************************************
cProc	B$IErrSaveState,<PUBLIC,NEAR,NODATA>
cBegin
	mov	ax,[pGosubLast]
	mov	[pGosubSave],ax
	mov	ax,[grs.GRS_otxCur]
	mov	[otxSave],ax
	mov	ax,[grs.GRS_oRsCur]
	mov	[oRsSave],ax
cEnd

;***
;B$IErrRestState
;Purpose:
;	This routine added as part of revision [5].
;
;	Restore QB-specific state variables saved by B$IErrSaveState
;Entry:
;	none.
;Exit:
;	none.
;*******************************************************************************
cProc	B$IErrRestState,<PUBLIC,NEAR,NODATA>
cBegin
	mov	ax,[pGosubSave]
	mov	[pGosubLast],ax
	mov	ax,[otxSave]
	mov	[grs.GRS_otxCur],ax
	push	[oRsSave]
	call	RsActivate
cEnd

;***
;B$IONERR - branch to user's error trap if there is one
;Purpose:
;	This routine greatly reworked as part of revision [5]
;
;	When a runtime error occurs, the runtime first calls B$IErrSaveState
;	so we can preserve grs.oRsCur, grs.otxCur, and pGosubLast. It also
;	preserves such variables as b$curlevel, b$curframe, and b$cNonQBIFrames.
;	Then the stack is walked, using the most recent BASIC frame (via
;	b$curframe); the BASIC-specific chain is used to find each BASIC
;	frame, and b$cCSubs is used to indicate whether the frame is for
;	compiled or interpreted BASIC code (and thus whether B$CONERR or
;	B$IONERR should be called). 
;	
;	When this routine is called, b$curframe, oRsCur, etc. are all set up
;	for the QB-specific frame of current interest. If this frame is for
;	a context for which there is an active error handler (and barring any
;	special cases), all frames below (more recent to) this one get their
;	owners released (i.e., that part of the stack is "blasted"), and
;	the error handler is invoked; ERL is set as if the error occured in
;	this context, and RESUME [NEXT | line#] act the same way.
;
;	If there is no error handler, we return to the runtime; we return
;	a flag that indicates whether the runtime code should keep walking
;	the stack or not. Currently, we say "quit looking" if the current
;	frame is an event frame.
;
;	Eventually, either a frame is found (QB or BC) that has an active
;	error handler and this is invoked, OR, we find an event frame or
;	the end (top) of the stack. In this latter case, the runtime restores
;	the context at which the error occured (with help from the QB callback
;	routine B$IErrRestState) and calls B$FERROR.
;
;	In the event that we find an error trap to invoke, we clean the stack.
;	In order to clean the stack, we set BP to b$curframe, depending on
;	this always being the current frame pointer. Based on the current 
;	context	(and with the help of the procmgr), we restore SP to what 
;	it was at the beginning of the statement in which the error occured 
;	by calculating what it should be based on BP. We also release any
;	owners left on the stack below what should be there for the current
;	frame.
;
;	In order to save the otx for RESUME, we know that, on input to this
;	routine, grs.GRS_otxCur is the value of SI on entry to the runtime 
;	entry point from which the runtime error code was called.
;	Note that the RESUME state cannot get the otx directly; we must
;	call a routine to move that otx back to the last opBOS, and save
;	THAT otx in the RESUME state.
;
;	Note that, to invoke an error trap, this routine will have to
;	deactivate the current prs, if any, load DI and ES for mrsCur,
;	set SI to the otx for the trap, clean the stack (restoring SP
;	and BP from b$curframe), as well as set up the RESUME state.
;
;
;	An exception to the above is the case where some runtime entry point
;	was called from a place in the interpreter that expects to get the
;	error code back, rather than have a runtime error occur. In this
;	case, the global errCodeRet.SPsave will be non-zero. SI, DI, SP, and
;	BP will be restored from the errCodeRet structure, and the interpreter
;	routine at CP:[errCodeRet.retAddr] will be JMP'd to, with the error
;	code in AX.
;
;Entry:
;	Error code is in b$errnum
;	b$curframe assumed valid
;	grs.GRS_otxCur contains the otx prior to runtime call.
;	pFrameErr is the frame pointer 1 level below error time
;Exit:
;	b$errlin	= line number of error
;	AX = 0 if the error must be treated as a fatal error, perhaps because
;		b$errnum > 255, or the current frame is an event frame and
;		has no handler, or ...
;	AX <> 0 means it's okay for the runtime to continue walking the frame
;		chain looking for an invokeable error handler.
;Uses:
;	SI and DI.
;Exceptions:
;	If the user has no error trap, this routine returns, but if
;	there is an error trap or in certain other instances, we'll clean the 
;	stack and never return.
;
;*******************************************************************************
cProc	B$IONERR,<PUBLIC,NEAR,NODATA>
parmW	pFrameErr			;frame pointer 1 level below error time
cBegin
	DbAssertRel  [b$cCSubs],z,0,RT,<B$IONERR: b$cCSubs not 0>
	mov	[executorFlags],0	;reset to BOS state
	mov	[RtDispVecHigh],SEG B$ASSN ;restore default in case of math err
	mov	ax,[b$errnum]
	or	ah,ah			;error number > 255?
	jz	BIONERR_Cont		;  brif not - not an internal error

	DbAssertRel  ax,ae,FE_BASE,RT,<B$IONERR Got bad internal error from RT>
	DbAssertRel  ax,nz,FE_NOLINES,RT,<B$IONERR: FE_NOLINES found> 
	cmp	ax,FE_GODIRECT
	jnz	J1_BIONERR_NoCont_Exit	;internal error, exit QBI
BIONERR_Cont:
	mov	cx,[errCodeRet.ERRRET_saveSP]
	jcxz	No_Err_Ret		;brif not trying to fake an error return

	cmp	ax,FE_GODIRECT
	jnz	RtTrapRet_Jump

	mov	ax,MSG_GoDirect
RtTrapRet_Jump:
	mov	[b$errnum],ax
	jmp	far ptr RtTrapRet	;return to caller from CP segment

No_Err_Ret:
	mov	[b$errnum],ax		;in case of a modified message number
	;we should only find internal errors here when fInitialized is false:
	DbAssertRelB  [fInitialized],nz,0,RT,<B$IONERR: fInitialized is True>

	xor	cx,cx
	mov	[DimAtScanType],cl	; In case of error during Dim
	mov	[grs.GRS_flagsDir],cl	;reset flags which get reset every
					; time we begin executing pcode,
					; or when a runtime error occurs.

	cmp	ax,FE_GODIRECT
	jnz	NotGoDirect

; Some special untrappable error has occurred which gets us back to
;  the user interface.	This currently happens with:
;	   MSG_GoDirect - User presses CANCEL button in response
;	   to some dialog boxes. (NOTE: this is a case where B$IONERR
;	   can be called from the U.I.)

	mov	[b$errnum],MSG_GoDirect
	jmp	short J2_BIONERR_NoCont_Exit

NotGoDirect:
	cmp	[grs.GRS_fDirect],FALSE	;in direct mode?
	jz	BIONERR_Cont1		;  brif not
					;don't trap errors in direct mode 
					;  statements
J2_BIONERR_NoCont_Exit:
 	mov	[otxSave],0		; reset otxCur to zero, since we're
 					; in direct mode
J1_BIONERR_NoCont_Exit:
	sub	ax,ax			;tell runtime to quit looking for 
					;  an error handler to invoke
	jmp	BIONERR_Exit		;brif special error which gets us
					; back to user interface.
BIONERR_Cont1:
	test	[grs.GRS_flags],FG_WatchActive
	jz	@F			; brif WATCH pcode not executing

	call	far ptr B$FERROR	; don't return to runtime, because
					; that would cause b$inonerr to
					; be reset (and user code might
					; be in an error handler)
@@:					
					
	cmp	[grs.GRS_otxCur],UNDEFINED
	jz	J2_BIONERR_NoCont_Exit	; error must not be trapped,
					; report error at start of text tbl
					; (error occurred after end of text
					; or an END or SYSTEM statement)
	cmp	[b$inonerr],FALSE
	jnz	J1_BIONERR_NoCont_Exit	;brif we're already in an error trap

	cmp	[b$errnum],ER_OM	;Out of memory error?
	jnz	BIONERR_Cont3		;  brif not

	cmp	[b$errinfo],OMErr_STK	;was it really a stack overflow error?
	jz	J1_BIONERR_NoCont_Exit	;  brif so - - - untrappable
BIONERR_Cont3:

	mov	di,[grs.GRS_oMrsCur]	; di points to active mrs in table
	RS_BASE add,di			
	GETRS_SEG es			
	cmp	PTRRS[di.MRS_otxHandler],UNDEFINED	
	jnz	BIONERR_Cont3a		;brif there is a trap to invoke

	;Now, use pGosubLast chain to determine if the current frame is
	;  an event frame. If so, set ax = 0 and exit, else set ax <> 0,
	;  and update otxCur, oRsCur, and pGosubLast for previous qb
	;  frame and exit.  Exception: If b$mainframe == b$curframe,
	;  then don't bother - - - leave ax set as it is and just exit
	;  (because there IS no previous qb frame, and runtime will
	;  immediately see that and quit looping).
	mov	si,[b$curframe]
	cmp	si,[b$mainframe]
	jz	BIONERR_Exit1		;brif this is the first frame on stack
					;  (don't care what ax is here ...)
	mov	bx,[pGosubLast]
Examine_Gosubs:
	or	bx,bx
	jz	NotEventFrame		;brif no gosubs (left)

	cmp	bx,si
	ja	NotEventFrame		; brif no gosubs for current frame

	cmp	word ptr [bx+2],1	;is this an event frame?
	jz	J1_BIONERR_NoCont_Exit	;  brif so - runtime should quit looking

	mov	bx,[bx]			;loop for each gosub in current frame
	jmp	Examine_Gosubs

NotEventFrame:
	;At this point, we know that 
	;	(1) the current frame has no error handler,
	;	(2) the current frame is not an event frame
	;	(3) there is at least one QB frame on the stack previous (above)
	;		this one
	;Therefore, we use our knowledge of what QB frames look like to restore
	;oRsCur, otxCur, and pGosubLast for the next previous frame, set ax to
	;tell the runtime to keep looking for an error handler to activate, 
	;and exit.
	mov	ax,[si].FR_pGosubLast	;pGosubLast for previous frame
	mov	[pGosubLast],ax
	push	[si].FR_oRsRet		;oRs part of return address to next
					;	previous frame
	call	RsActivate		;activate that register set
	mov	ax,[si].FR_otxRet	;otx part of return address to next
					;	previous frame
	mov	[grs.GRS_otxCur],ax	
	mov	ax,sp			;signal runtime "okay to keep looking"
BIONERR_Exit1:
	jmp	BIONERR_Exit		
BIONERR_Cont3a:
	;There is an error trap to invoke; start it going - - -

	;release any owners on the stack below those we should keep for
	;  the current frame. This includes possible frame temp owners for the
	;  current frame.
	call	far ptr ResetSP_IONERR	;release all owners on stack below
					;  most recent QBI frame
	push	dx
	popf
	ja	BIONERR_Cont4		;  brif sufficient stack for context

	mov	[b$errnum],ER_OM
	mov	[b$errinfo],OMErr_STK	;note that this is an out of stack err
	jmp	J1_BIONERR_NoCont_Exit
BIONERR_Cont4:
	mov	sp,ax
	call	far ptr SetERL		;set b$errlin, activate static structs
					;sets grs.otxCur beyond opBos of
					; stmt that caused the error.
					; AX = otx of stmt that caused error


	call	DisStaticStructs	;deactivate static structs again
					; (activated by SetERL)

	mov	[b$inonerr],TRUE
	mov	[fNonQBI_Active],0	;regardless of where error occurred,
					; QB code is active now
	push	[pGosubLast]		;save so RESUME can restore
	push	[grs.GRS_oRsCur]	;oRs of return address	
	mov	di,[grs.GRS_oMrsCur]	; di points to active mrs in table
	RS_BASE add,di			
	GETRS_SEG es			
	mov	ax,PTRRS[di.MRS_otxHandler]	


	xchg	ax,[grs.GRS_otxCur]	;Set error trap context, fetch oTx
					;  of BOS/BOL of line error occured in
	push	ax			;oTx of return address (for RESUME)
	push	bp
	mov	bp,sp
	push	[b$curframe]		
	mov	[b$curframe],bp
	push	[grs.GRS_oMrsCur]
	cCall	RsActivate		;deactivate prsCur if a procedure is
					;  active (must use RsActivate here, 
					;  since static structs are inactive)
	;NOTE: No reason to copy existing module frame vars+temps to and back
	;NOTE: from this new frame, nor to zero them. Frame temps are only
	;NOTE: meaningful within the context of a statement. Frame vars are
	;NOTE: only used by FOR loops; not too worried about what happens if
	;NOTE: user jumps into the middle of a FOR loop; we can't match what
	;NOTE: BC does for that case anyway.

	jmp	StartGrsContext 	;jmp to dispatch first opcode in trap
					;  note that this also sets SP based
					;  on BP and current context, and
					;  checks for stack overflow ...

BIONERR_Exit:				;no trap or in trap; ret to RT
cEnd

;***
;ResetSP_BP_Far
;Purpose:
;	Common code called in case non-QBI code is executing and the user
;	hits ctl-BREAK, a STOP statement is executed, or a runtime
;	error occurs that is not trapped by the compiler.
;
;	If fNonQBI_Active == FALSE, just resets SP and BP based on b$curframe
;	and current context and returns.
;
;	If fNonQBI_Active != FALSE, sets BP to fNonQBI_Active (last active
;	QBI frame), sets SP based on this BP, releases all owners on
;	stack below this frame, restores proper b$curlevel value for this 
;	frame, and decrements the count of non-QBI frames on the stack.
;
;	NOTE: doesn't actually set SP, for ease in returning, and because
;	that hoses caller from B$IONERR. Caller must set sp if desired.
;Entry:
;	b$curframe gives pointer to reset BP to if fNonQBI_Active == FALSE.
;	fNonQBI_Active == FALSE or value to reset BP to.
;	if fNonQBI_Active != FALSE, bcurlevel_QBI assumed to contain the
;		value that b$curlevel is to be reset to.
;	grs.GRS_oRsCur assumed to be set for most recently active QBI frame.
;Exit:
;	AX is set to appropriate location for SP to be set to at each
;		BOS based on BP.
;	dx is a copy of PSW flags, because windows can trash
;		PSW on exit from far routines.
;Uses:
;	di,bp
;Exceptions:
;	none.
;*******************************************************************************
cProc	ResetSP_IONERR,<FAR>
cBegin
	mov	di,[b$curframe]
	jmp	short ResetSP_BP_Cont
cEnd	<nogen>

cProc	ResetSP_BP_Far,<PUBLIC,FAR>	
cBegin	ResetSP_BP_Far			
	mov	di,[b$curframe]
	xor	cx,cx
	xchg	[fNonQBI_Active],cx	;error in non-QBI code?
	jcxz	ResetSP_BP_Cont		;  brif not

	mov	di,cx			;reset bp to most recent QBI frame
	push	[bcurlevel_QBI]		;restore b$curlevel to what it was
	pop	[b$curlevel]		;  when most recent QBI frame was active
	DbAssertRel b$cNonQBIFrames,nz,0,RT,<ResetSP_BP: b$cNonQBIFrames == 0>
	dec	[b$cNonQBIFrames]	;decrement count of non-QBI frames on
					;  the stack
ResetSP_BP_Cont:
	mov	[b$curframe],di
	mov	bp,di

	;Don't release owners in local var space on stack if a procedure
	;  is active
	;Note that MODULE frame var space cannot have owners
	sub	bx,bx			
	RS_BASE add,bx			
	GETRS_SEG es			
	mov	ax,[grs.GRS_oRsCur]	
	DbAssertRel ax,nz,UNDEFINED,RT,<ResetSP_BP: grs.GRS_oRsCur == UNDEFINED>
	or	ax,ax
	jns	Proc_Not_Active		;brif oRsCur is a module, not a proc

	and	ah,07FH			; oRs --> oPrs
	DbChk	ConNoStatStructs	;following statement counts on finding
					;  current prs in table, not prsCur
Proc_Not_Active:
	add	bx,ax			
	.errnz	MRS_cbFrameVars - PRS_cbFrameVars	
	sub	di,PTRRS[bx.PRS_cbFrameVars] ; don't release any local proc variable
					;  owners
	jnc	@F			;[J2]
	mov	di,bp			;[J2]
@@:					;[J2]
	dec	di			; point to first potential value
	dec	di			; to release
	push	[b$pend]		;ptr to low word on stack
	push	di			;ptr to top of range to clear
	call	B$ClearRange		;free all owners below latest QBI frame

	mov	ax,[b$curlevel]
	call	B$STDALCALLTMP		;deallocate all string temp.s that were
					; created above the level for this frame
	call	SetSpFar		;ax = clean BOS SP value based on BP
					;return PSW flags as returned by
					;SetSpFar (in dx)
cEnd	ResetSP_BP_Far			

;***
;B$FERROR - interpreter-specific clean-up when runtime error occurs
;Purpose:
;	The runtime calls this routine when a runtime error occurs that is
;	not trapable, or there is no error trap, or the error occured in
;	an error trap. It cleans the stack frame back to b$curframe and
;	the stack pointer back to where it was at the last BOS/BOL,
;	resets si to the opBOS prior to the otx in grs.otxCur (set by
;	B$IONERR), gives the appropriate error message to the user, and puts
;	QBI in direct mode.
;Entry:
;	b$curframe gives pointer to reset BP to.
;	b$errnum contains the BASIC error number.
;	b$cCSubs non-0 if error occured in compiled BASIC code.
;Exit:
;	none.
;Exceptions:
;	Never returns, just sets the stack up, and jumps ...
;*******************************************************************************
cProc	B$FERROR,<PUBLIC,NEAR,NODATA>
cBegin	B$FERROR
	mov	ax,[b$errnum]
	or	ah,ah			;some internal error?
	jz	Normal_Error		; brif not
	cmp	ax,FE_NOSTACK		; convert FE_NOSTACK to ER_OM?
	jne	Term_Error		; brif not
	mov	[b$errnum],ER_OM	; convert to Out of Memory Error
	mov	[b$errinfo],OMErr_STK	; and set Out of Stack Space flag
Normal_Error:				

	jmp	far ptr BFERROR_CONT	;do the rest of this work in CP
Term_Error:
	call	B$PUTNUM		;print error message to stdout

	;NOTE: We don't try to print out module name, ERL, etc. of message
	;NOTE: here, partly to save code (this is an unusual case), and partly
	;NOTE: because it's pretty risky trying to do much of anything after
	;NOTE: an error such as String Space Corrupt, DOS Arena trashed, etc.
	;NOTE: For the same reason we don't give the user the chance to save
	;NOTE: his program after such an error either; we probably couldn't
	;NOTE: do it, and it's just too risky.

	jmp	B$END			;terminate BASIC

cEnd	<nogen>

sEnd	RT

sBegin	CP
assumes CS, CP

BFERROR_CONT:
	call	ReleaseSpace		;just in case GrabSpace had been called
					;  in exStClear
	call	EnStaticStructs 	;required prior to calling txtmgr stuff
	mov	ax,[b$errnum]
	cmp	ax,ER_OM		;out of memory error?
	jz	BFErr_Clear		;  brif so

	cmp	ax,ER_OS		;out of string space error?
	jnz	BFErr_Cont		;  brif not - only clear if need space
BFErr_Clear:
	call	ClearStmt		;clear all variables to free up memory
	mov	ax,[b$mainframe]
	mov	[b$curframe],ax	;reset this now in case of Out of Stack
					;  space error - - - this ensures
					;  enough stack space for UserInterface
	mov	[BosFlags],0		;don't want to leave the 'reset the
					;  stack' bit set ...
	or	[debugFlags],DEBUG_CANT_CONT
					;remember that we can't continue now
BFErr_Cont:
	xor	cx,cx			;note that we're resetting b$cCSubs
	xchg	[b$cCSubs],cx		;here in addition to testing it; this
					;is necessary in case another runtime
					;error occurs (so B$CONERR doesn't
					;get called when it shouldn't ...)
	mov	si,[grs.GRS_otxCur]	
	cmp	[grs.GRS_fDirect],FALSE ; error in Direct Mode?
	jnz	BFerr_Cont2		;	brif so - leave otx alone

	jcxz	BFErr_InQB_Code		;brif error occured in QB code

	;In the event that the most recent BASIC frame on the stack is
	;  for compiled BASIC code and the error was untrapped, we must
	;  leave ERL alone, but must reset oTxCur back to the previous BOS 
	mov	ax,[grs.GRS_otxCur]
	DbAssertRel ax,nz,UNDEFINED,CP,<B$FERROR: otxCur=FFFF, b$cCSubs non-0>

	dec	ax			;move back to opcode that caused the
	dec	ax			;  error, to ensure we're in the same
					;  statement/line.
	push	ax
	cCall	OtxBosOfOtx		;ax = oTx of BOS/BOL of stmt in which 
					;  the error occured
	mov	[grs.GRS_otxCur],ax
	jmp	short BFErr_Cont1
BFErr_InQB_Code:
 	mov	si,[grs.GRS_otxCur]	
 	cmp	[grs.GRS_fDirect],FALSE	; error in Direct Mode?
 	jnz	BFErr_Cont2		;   brif so - leave otx alone
 
	call	far ptr SetERL		;set b$errlin, activate static structs
					;sets grs.otxCur beyond opBos of
					; stmt that caused the error.
BFErr_Cont1:
	sub	ax,ax
	push	[grs.GRS_otxCur]	;oTx of BOS/BOL
	push	ax			;0 = "skip to next pcode, please"
	call	TxtFindNextOp		;ax = oTx of first opcode past BOS/BOL
	xchg	ax,si			;si = otx of first opcode past BOS/BOL

BFErr_Cont2:				
	sub	ax,ax
	mov	[DimAtScanType],al	; In case of error during Dim
	mov	[grs.GRS_flagsDir],al	;reset flags which get reset every
					; time we begin executing pcode,
					; or when a runtime error occurs.
	call	DisStaticStructs	;deactivate stat structs for ResetSP_BP
	call	ResetSP_BP_Far		;reset SP and BP
	push	dx			;[J2]
	popf				;[J2]
	jbe	B$FERROR_Exit		;brif insufficient stack space for
					;  the module frame (special case)
	mov	sp,ax
B$FERROR_Exit:
	or	[debugFlags],DEBUG_ERROR;tell UserInterface an error occured
	mov	[grs.GRS_flagsDir],0
	jmp	far ptr StopGrsContext 	;back to user interface

;***
;SetERL - set up b$errlin for ERL and otxCur of BOS/BOL where error occured.
;Purpose:
;	updates b$errlin and updates GRS_otxCur to the BOS of stmt in which 
;	the error occurred.  If the error occurred during a single line if
;	the otx past the opStIf or opStElse operand will be used.
;	This function is in CP, since it calls txtmgr routines which are
;	NEAR in CP.
;	Note that, if no line number is found prior to the oTx where the error
;	occured, b$errlin is set to 0.
;Entry:
;	[grs.GRS_otxCur] = oTx just past the opcode which caused the error
;Exit:
;	b$errlin set appropriately
;	Static structs active
;	AX = otx of stmt that caused the error
;Modifies:
;	SI,ES
;*******************************************************************************
cProc	SetERL,<FAR>
cBegin	SetERL
	call	EnStaticStructs 	;required prior to calling OtxLabOfOtx
	mov	si,[grs.GRS_otxCur]
	cmp	si,UNDEFINED
	jnz	SetERL_Cont
	;error occured after end of text or an END or SYSTEM statement
	inc	si
	mov	[b$errlin],si		;ERL = 0 in this case
	jmp	short SetERL_Exit	;this will set otxCur to zero, i.e.,
					;  the error will be reported as if it
					;  occured at the start of the txt tbl
SetERL_Cont:
	or	si,si
	jz	No_oTx_Dec		;special case - - - if we've done a
					;  GOSUB back to oTx 0 and then see
					;  we're out of stack space ...
	dec	si			;move back to opcode that caused the
	dec	si			;  error, to ensure we're in the same
					;  statement/line.
No_oTx_Dec:
	DbAssertRel si,b,0FFFDh,CP,<SetERL: bad grs.otxCur>
	push	si			;popped below by OtxResume
LoopForERL:
	xchg	ax,si			;put current oTx in ax, garbage in si
	cCall	OtxLabOfOtx		;ax = oTx of preceding opBolLab or opLab
	mov	si,ax			;si = ax == oTx op preceding opBolLab
	inc	ax			;no more opBolLab's or opLab's?
.errnz	UNDEFINED - 0FFFFH
	jz	ERL_Set 		;  brif so; leave ERL == 0

	GetSegTxtTblCur			;ES = txdCur.TXD_bdlText_seg
	mov	bx,es:[si+2]		;pass oNam of Ln/Lab from pcode in bx
	cCall	LnOfOnam,<bx>		; ax = line # or UNDEFINED if label
	inc	ax
.errnz	UNDEFINED - 0FFFFH
	jz	LoopForERL		;found a label, not a Ln - try again

	dec	ax			;set this back to actual line number
ERL_Set:
	mov	[b$errlin],ax
	cCall	OtxResume		;oTx of error pcode still on stack
	;now ax = oTx of BOS/BOL of statement in which the error occured
SetERL_Exit:
	mov	[grs.GRS_otxCur],ax
cEnd	SetERL

sEnd	CP

sBegin	CODE
assumes CS, CODE

;***
;RtErrorCODE - Near interface for runtime error in CODE segment
;Purpose:
;	This entry point is jumped to from any point in the CODE segment where
;	a runtime error is detected. Having a NEAR interface like this saves
;	code.
;Entry:
;	AL is the error code of the runtime error to generate
;Exit:
;	None - doesn't return
;*******************************************************************************

PUBLIC	RtError_INI
PUBLIC	RtErrorOM_INI
;here for the special case of some internal error
RtError_Initialization	PROC FAR
RtError_INI:
	DbAssertRelB  ah,z,0,CODE,<RtError_INI called with ax GT 255>
	xchg	al,bl			;put error code in bl
	SKIP2_PSW
RtErrorOM_INI:
	mov	bl,ER_OM
					;OM error during initialization
	mov	bh,QB_RTERR_MASK	;special mask - - - fatal error, but
					; allows us to use an existing message
					; string
	push	ss			;in case error occured before DS was
	pop	ds			;  set up originally
	call	B$RUNERRINFO		;doesn't return
	DbHalt	CODE,<B$RUNERRINFO returned when passed a fatal error (1)>
RtError_Initialization	ENDP

PUBLIC	RtErrorCODE
RtErrorCODE PROC NEAR
RtErrorCODE ENDP
	;fall into RtError
PUBLIC	RtError
RtError PROC FAR
	mov	[grs.GRS_otxCur],si	;just as executors save this away prior
					;  to calling runtime ... for error
RtError ENDP				;  recovery
	;fall into RtErrorNoSi
PUBLIC	RtErrorNoSi
RtErrorNoSi PROC FAR
	xor	ah,ah			;so callers only have to set AL
	cmp	al,MSG_GoDirect
	jnz	RtErrorNoSi_Cont1

	mov	ax,FE_GODIRECT
RtErrorNoSi_Cont1:
	xchg	ax,bx
	call	B$RUNERRINFO
	DbHalt	CODE,<B$RUNERRINFO returned when passed a fatal error (2)>
RtErrorNoSi ENDP

;***
;exStOnError, exStResume, exStResume0, exStResumeNext
;
;	Moved to this module as part of revision [18].
;
;****
	EXTRN	SetProgramMode:NEAR	

MakeExe exStOnError,opStOnError
	LODSWTX 			;load oTx of error handler to ax
	mov	bx,[grs.GRS_oMrsCur]
	RS_BASE add,bx			;bx points to mrsCur in the Rs table
	GETRS_SEG es
	mov	PTRRS[bx.MRS_otxHandler],ax  ;save ON ERROR oTx (or UNDEFINED)
	inc	ax
	jz	OnError_GoTo_0		;brif line number 0 specified
OnError_Exit:
	jmp	DispMov 		;ensure es gets restored in dispatch

OnError_GoTo_0:
	cmp	[b$inonerr],0
	jz	OnError_Exit		;brif not in an error handler
					; otxHandler is already set to UNDEFINED
	;ON ERROR GOTO 0 in an error handler - - - cause runtime error.
	mov	al,byte ptr [b$errnum]
	call	RtErrorCODE


MakeExe exStResume,opStResume
	LODSWTX 			;fetch oTx for resume Lab/Ln
	cmp	ax,UNDEFINED
	jz	exStResume0		;brif oTx is UNDEFINED - RESUME 0

	test	[bp+4],08000H		;did error occur in a procedure?
	jnz	Resume_Proc		;  brif so - leave this frame active

	mov	[bp+2],ax		;oTx we want to resume to
	jmp	short exStResume0	;pop back to previous module frame
					;Note that we need to do this so that
					;  a subsequent CLEAR or RUN won't cause
					;  a runtime error.
Resume_Proc:
	push	ax			;ax = oTx to RESUME to (@ module level)
	xor	ax,ax			;tell B$RESUMED to dealloc all string
	mov	[grs.GRS_oTxCur],si	;in case of runtime error
	call	B$RESUMED		;call RT to reset b$inonerr, b$errnum.
					;  if not currently in handler, gives
					;  RT error and doesn't return (note
					;  that AX is a parm to B$RESUMED)
	pop	si			;put oTx to resume at in SI
	jmp	short Resume_Common


MakeExe exStResumeNext,opStResumeNext
	mov	di,sp			;remember this is RESUME NEXT
	jmp	short Resume_Common1
	
MakeExe exStResume0,opStResume0
	xor	di,di			;remember this is RESUME0
Resume_Common1:
	mov	[grs.GRS_oTxCur],si	;in case of runtime error
	DbAssertRel ax,nz,0,CODE,<exStResume<Next|0>: ax == 0>
	call	B$RESUMED		;call RT to reset b$inonerr, b$errnum.
					;  if not currently in handler, gives
					;  RT error and doesn't return (note
					;  that AX is a parm to B$RESUMED)
	mov	sp,bp
	pop	bp	
	pop	si			;oTx part of return address
	mov	[b$curframe],bp
	pop	ax
	call	RsActivateCODE		;activate Rs where error occured
	pop	[pGosubLast]		;update in case any GOSUBs occured and
					;  were not returned from
	or	di,di			;RESUME NEXT, or RESUME [0] ?	
	jz	Resume_Common2		;  brif RESUME [0]

	call	SetProgramMode		;in case of a RETURN from direct mode
					;  must do this prior to call to 
					;  OtxResumeNext to ensure ES setup
					;  for module text table, not directmode
	call	EnStaticStructs		;bring txdCur up to date
	xchg	ax,si
	push	ax			;push otx arg.
	call	OtxResumeNext		;ax = oTx of BOS/BOL of following stmt
	xchg	ax,si
	call	DisStaticStructs
Resume_Common2:	
	call	SetSP			;set SP to where it should be at BOS
					;  based on bp
	mov	sp,ax
Resume_Common:
	call	SetProgramMode		;in case of a RETURN from direct mode
					;  also updates ES & DI for execution
	cmp	[grs.GRS_fDirect],FALSE ;RESUME from Direct Mode?
	jnz	DirectMode_Resume	;  brif so
Disp1:
	DispMac 			; and on with the show.

CantCont_Err:
	mov	al,ER_CN		;"Cant Continue" error
	call	RtErrorCODE


	EXTRN	Cont_Otx:NEAR		;part of exStCont code

DirectMode_Resume:
	cmp	[grs.GRS_otxCONT],UNDEFINED
					;exists context that can be CONTinued?
	jz	CantCont_Err		;  brif not - - issue 'Cant Continue'

	jmp	Cont_Otx		;share code with exStCont

sEnd	CODE
;===============================================================================
subttl	Error Trap Code for Direct Mode Runtime Users
page

sBegin	CP
assumes CS, CP

;***
;CallRtTrap, CallRtTrap_Parm, CallRtTrap_RT, CallRtTrap_CODE
;Purpose:
;	This calls a specified function, trapping runtime errors.
;
;	The current trap handler as set by RtSetTrap is preserved.
;Entry:
;	pFunc = far address of function to call (must be FAR function)
;	si,di	passed to specified function
;	For CallRtTrap_Parm, bx is a parm that must be pushed on the stack,
;		i.e., passed to pFunc.
;Exit:
;	ax =  0 if no runtime error occurred
;	      or
;	      standard error code if runtime error occurred
;	si,di as returned from the specified function if no error.
;	      or garbage
;Exceptions:
;	none
;
;*******************************************************************************
	PUBLIC CallRtTrap_Parm
	PUBLIC CallRtTrap
CallRtTrap_Parm:
	mov	dx,sp			;signal that bx contains a parm to pass
	SKIP2_PSW
CallRtTrap:
	xor	dx,dx			;no parm to pass to pFunc
cProc	CallRtTrap_Common,<FAR>
	parmD	pFunc
cBegin
	call	RtPushHandler		;save current handler on stack
					; NOTE: alters SP
	mov	ax,CPOFFSET CallTrapped
	call	RtSetTrap
	or	dx,dx			;parm to pass to pFunc?
	jz	CallRt_NoParm		;brif not

	push	bx			;pass given parm on to pFunc
CallRt_NoParm:
	call	[pFunc]
	sub	ax,ax			;error code = 0
CallTrapped:
	call	RtPopHandler		;restore caller's handler from stack
					; NOTE: alters SP
cEnd
;start of revision [10]
sEnd	CP

sBegin	RT
assumes CS, RT
cProc	CallRtTrap_RT,<PUBLIC,FAR>
	parmW	pFunc
cBegin
	push	cs
	push	[pFunc]
	call	far ptr CallRtTrap
cEnd
sEnd	RT

sBegin	CODE
assumes CS, CODE
cProc	CallRtTrap_CODE,<PUBLIC,FAR>
	parmW	pFunc
cBegin
	push	cs
	push	[pFunc]
	call	far ptr CallRtTrap
cEnd
sEnd	CODE

sBegin	CP
assumes CS, CP
;end of revision [10]

;***
;RtSetTrap
;Purpose:
;	This is called by a function which is about to make a series
;	of runtime calls, and wants to identify one location to
;	branch to if any of them result in runtime errors.  In BASIC
;	terminology, this is equivalent to doing an ON ERROR GOTO [ax].
;	The handler remains active until RtSetTrap is called again,
;	RtFreeTrap is called, or a runtime error occurs.
;
;	When the handler is branched to, the sp, es and di registers
;	are set as though it had just returned from RtSetTrap.
;	The si and ds registers are set as though it had just returned
;	from the runtime call which resulted in the error.
;	Register al contains the standard QB4 error code.
;
;	NOTE: Internal errors such as String space corrupt ALWAYS cause
;	NOTE: QB4 to print the error message, and terminate.
;Entry:
;	ax = offset into CP segment to error handler
;	bp = value to restore bp to if error is trapped
;	si = value to restore si to if error is trapped (optional)
;	di = value to restore di to if error is trapped (optional)
;Exit:
;	none
;Preserves:
;	bx,cx,dx
;Exceptions:
;	none
;
;*******************************************************************************
PUBLIC	RtSetTrap
RtSetTrap PROC NEAR
;Make sure we aren't over-writing someone else's trap.
;If so, should use RtPushHandler and RtPopHandler
DbAssertRel [errCodeRet.ERRRET_saveSP],e,0,CP,<RtSetTrap: trap already set>
	mov	[errCodeRet.ERRRET_saveBP],bp	;to restore bp on error
	mov	[errCodeRet.ERRRET_saveSI],si	;to restore si on error
	mov	[errCodeRet.ERRRET_saveDI],di	;to restore di on error
	mov	[errCodeRet.ERRRET_retAddr],ax	;return address to handler
DbAssertRel [b$fInt24Err],ne,0,CP,<RtSetTrap: int24 trap already set>	
	mov	[b$fInt24Err],0		; have runtime handle int24 errors
	pop	ax				;ax = ret adr to caller
	mov	[errCodeRet.ERRRET_saveSP],sp	;set SP back to here on error
	jmp	ax				;return to caller
RtSetTrap ENDP

;***
;RtTrapRet
;Purpose:
;	Jumped to from B$IONERR when an error occurs with trap set
;Entry:
;	ax = standard runtime error code
;	cx = errCodeRet.ERRRET_saveSP
;Exit:
;	none
;Exceptions:
;	exits via RtFreeTrap to save code
;
;*******************************************************************************
RtTrapRet PROC FAR

	push	ax			;save error code for return
	push	cx			;save new sp
	push	[b$pend]		;ptr to low word on stack
	dec	cx			;clear range is inclusive...
	dec	cx			;...so adjust to not trash TOS.
	push	cx			;ptr to top of range to clear
	call	B$ClearRange		;free all owners on stack
	pop	cx			;get back new sp
	pop	ax			;recover error code

	;restore bp,si,di,sp as they were on runtime entry
	mov	si,[errCodeRet.ERRRET_saveSI]
	mov	di,[errCodeRet.ERRRET_saveDI]
	mov	bp,[errCodeRet.ERRRET_saveBP]
	mov	sp,cx
	mov	[b$errnum],0			;so ERR is 0 after CHAIN and
						;  RUN <filespec> and to prevent
						;  similar potentially confusing
						;  values of ERR.
	push	[errCodeRet.ERRRET_retAddr]	;set up for near return
	;fall into RtFreeTrap, to free the trap and return to caller with
	;  error code in ax
RtTrapRet ENDP

;***
;RtFreeTrap
;Purpose:
;	Removes the error handler installed by RtSetTrap.  In BASIC
;	terminology, this is equivalent to doing an ON ERROR GOTO 0.
;Entry:
;	none
;Exit:
;	none
;Preserves:
;	AX
;Exceptions:
;	none
;
;*******************************************************************************
PUBLIC	RtFreeTrap
RtFreeTrap PROC NEAR
	mov	[errCodeRet.ERRRET_saveSP],0	;reset, so not used incorrectly
;Comment out this assertion so we can do two RtFreeTrap's in a row
;DbAssertRel [b$fInt24Err],e,0,CP,<RtFreeTrap: int 24 trap not set> 
	mov	[b$fInt24Err],UNDEFINED	; don't have runtime handle int24
					; error processing anymore (trashes
					; any pending int 24 errors)
	ret
RtFreeTrap ENDP

;***
;RtPushHandler
;Purpose:
;	Save the state of the runtime-error-handler (as set by RtSetTrap)
;	on the stack.
;Preserves:
;	ax,bx,dx
;NOTE:
;	Exit SP < Entry SP
;
;*******************************************************************************
PUBLIC	RtPushHandler
RtPushHandler PROC NEAR
	pop	cx			;cx = return address
	push	[b$fInt24Err]		; also save int 24 error handler 
	sub	sp,size ERRRET		;Make space for handler
	push	cx
	push	si
	push	di
	push	es
	mov	si,DATAOFFSET errCodeRet
	mov	cx,size ERRRET/2
	mov	di,sp			;Copy into stack
	add	di,8			;Add 4 pushes above
	push	ss
	pop	es
rep	movsw				;Copy handler into stack frame
	pop	es
	pop	di
	pop	si
	ret
RtPushHandler ENDP

;***
;RtPopHandler
;Purpose:
;	Restore the state of the runtime-error-handler that was saved
;	by RtPushHandler
;Preserves:
;	ax,bx,dx
;NOTE:
;	Exit SP < Entry SP
;
;*******************************************************************************
PUBLIC	RtPopHandler
RtPopHandler PROC NEAR
	push	si
	push	di
	push	es
	mov	di,DATAOFFSET errCodeRet
	mov	cx,size ERRRET/2
	mov	si,sp			;Copy from stack
	add	si,8			;Add 3 pushes above + return addr
	push	ss
	pop	es
rep	movsw				;Copy handler from stack frame
	pop	es
	pop	di
	pop	si
	pop	cx			;Return address
	add	sp,size ERRRET		;Remove space for handler
	pop	[b$fInt24Err]		; also restore int 24 error handler 
	jmp	cx			;Return to caller
RtPopHandler ENDP
sEnd	CP

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\ir\help.asm ===
TITLE	HELP - Loader for DOS Online Help
;***
;HELP - Load QBASIC.EXE with /QHELP switch to start DOS Help Viewer
;
;	Copyright (C) 1990, Microsoft Corporation
;
;Purpose:
;	This file implements HELP.COM.	The purpose of this com file
;	is to invoke QBASIC.EXE with the /QHELP switch, passing on all
;	other command line options
;
;*******************************************************************************

;
; (a-emoryh)
; WARNING - '/QHELP' switch MUST be first switch on cmdline, or else
;       multi-word topics will be broken.
;

	Stack_Size  = 256	; size of stack in bytes
	Path_Size   = 128	; max size of path + filename of QBASIC
	Max_CmdTail = 73	; max size of program options after /QHELP
	OldCmdLine  = 80h	; DS:OldCmdLine = ptr to QHELP command line
	EnvSeg	    = 2ch	; DS:EnvSeg	= ptr to QHELP environment


code	SEGMENT PARA PUBLIC 'CODE'

	ASSUME	cs:code, ds:code, es:code, ss:code

	ORG	0100h

help:
	mov	bx, offset TopOfStack	; BX = ptr to top of stack (end of mem)
	mov	sp,bx			; move stack to perminent memory
	add	bx,000fh		; round up to units of paragraphs
	shr	bx,1
	shr	bx,1
	shr	bx,1
	shr	bx,1			; BX = # paragraphs of memory
	mov	ah,4ah			; modify memory block
	int	21h
	mov	dx, offset ErrART	; assume an error
	jnc	@F
GiveError_Near:
	jmp	GiveError		; brif error
@@:

	; set up the parameter block
	mov	ax,cs
	mov	[PB_CmdLineSeg],ax	; set the segment of the command line

	; set up the command line
	mov	al, ds:[OldCmdLine]	; al = length of old command line
	cmp	al, Max_CmdTail 	; is the command line too long
	mov	dx, offset ErrCmd	; assume so, prepare error
	ja	GiveError_Near		; brif too long

	cbw				; zero extend ax (cant be > 80)
	mov	cx, ax			; save in cx
	inc	cx			; also copy over 0D terminator
	add	ax, CmdTail-CmdLine	; ax = length of new command line
	mov	[CmdLine],al		; and save it
	mov	si, offset OldCmdLine+1 ; DS:SI = ptr to old command line
	mov	di, offset CmdTail	; DS:DI = ptr to new command line
	rep	movsb			; and copy it over

	; set up the program name

	mov	ax, ds:[EnvSeg]		; ax = segment of environment
	mov	es, ax
	xor	di, di			; ES:DI = ptr to environment
	xor	ax, ax			; look for a zero
	mov	pszPATH,-1		; indicate that no PATH found

LocateFname:
	mov	cx, cbPATH		; length of 'PATH='
	mov	si, offset stPATH	; see if this is the PATH specification
	repe	cmpsb
	jne	NotPath 		; brif not PATH
	mov	pszPATH, di		; EnvSeg:pszPATH = ptr to PATH data

NotPath:
	dec	di			; back up a character
	mov	cx, 8000h		; scan a long way for a 0 if needed
	repne	scasb			; skip an environment string
	cmp	es:[di],al		; is next byte a null?
	jne	LocateFname		; not double null term, keep looking

	inc	di			; skip last null
	scasw				; skip word containing 1h

	mov	si, di			; ES:SI = ptr to HELP path & name
	mov	di, offset ProgName	; DS:DI = ptr to QBASIC path & name
	push	es
	pop	ds			; DS:SI = ptr to HELP path & name
	push	cs
	pop	es			; ES:DI = ptr to QBASIC path & name

	mov	ah,30h			; get version number
	int	21h			; are we in DOS 3 or above?

	mov	bx,di			; CS:BX = ptr to first char in HELP
					; name as it is copied over
	cmp	al,3
	jb	HavePath		; brif not DOS 3 or above, no path

CopyName:
	lodsb				; grab a byte
	stosb				; and store it
	cmp	al,'\'                  ; is it a slash
	je	PathChar		;  go remember it
	cmp	al,'/'			; or this slash
	je	PathChar		;  go remember it
	cmp	al,':'			; or a colon
	jne	TestTerminator		; brif not
PathChar:
	mov	bx,di			; set last path character found
TestTerminator:
	or	al,al			; 0 terminator?
	jnz	CopyName		; brif not, more characters to do

HavePath:
	push	cs
	pop	ds			; restore ES = DS = CS

	cmp	bx, offset ProgName	; does it have any path?
	jne	@F			; brif so
	mov	fCurDir,1		; else flag cur directory tried
@@:
	mov	di, bx			; ES:DI = ptr to end of HELP path
	mov	si, offset szQBASIC	; DS:SI = ptr to new file name
	mov	cx, cbQBASIC		; CX = # characters
	rep	movsb			; and copy it over

	; all set up, lets go exec the program

	mov	dx, offset ProgName
	mov	bx, offset ParmBlock
	mov	ax, 4b00h
	int	21h			; Exec program
	jnc	GetRetCode		; brif ok

	mov	dx,offset ErrOM
	cmp	ax,8			; is it out of memory?
	jne	TryPathSearch		; brif not, assume file not found

GiveError:
	push	cs			; set DS=code segment (for error)
	pop	ds

	mov	ah,9
	int	21h			; print error message
	mov	ax,4cffh		; terminate program, return code FF
	int	21h
	;Does not return

GetRetCode:
	mov	ah,4dh
	int	21h			; al = return code of previous prog
	mov	ah,4ch
	int	21h			; exit with return code in al
	;Does not return


; We could not load QBASIC from the directory that HELP was located in.
; We will now try the directories in the PATH.

TryPathSearch:
	cmp	fCurDir,0		; have we looked in current dir?
	mov	bx, offset ProgName	; assume not, setup to try with no path
	jz	HavePath		; brif not, go try it.
	mov	dx, offset ErrFNF	; prepare for error
	mov	ax, cs:[EnvSeg]		; ax = segment of environment
	mov	ds, ax
	mov	si, cs:pszPATH		; DS:SI = ptr to PATH data
	cmp	si,-1			; was there a PATH env variable?
	je	GiveError		; brif not, give File Not Found

	push	cs
	pop	es
	mov	di, offset ProgName	; ES:DI = buffer to construct filename

NextPathChar:
	lodsb				; get a character of a path
	stosb				; save character
	cmp	al,';'			; end of path?
	je	PathEnd 		; brif so
	or	al,al			; end of string
	jne	NextPathChar		; brif not
	mov	si,-1			; indicate no more path
PathEnd:
	mov	cs:pszPATH,si		; set up pointer for next iteration
	dec	di			; back up over the ';' or 0 terminator
	mov	al,'\'                  ; look for a back slash
	cmp	byte ptr es:[di-1],al	; does it end in a backslash?
	je	HaveFullPath		; brif so
	cmp	byte ptr es:[di-1],'/'	; or does it end in a forward slash?
	je	HaveFullPath		; brif so
	stosb				; else, add it
HaveFullPath:
	mov	bx, di			; CS:BX = ptr to where to fill in name
	jmp	HavePath


ErrOM	db	'Out of memory$'
ErrFNF	db	'Can not find file QBASIC.EXE$'
ErrART	db	'DOS memory-arena error$'
ErrCMD	db	'Command line too long$'

szQBASIC db	'QBASIC.EXE', 0
cbQBASIC = $ - szQBASIC

stPATH	db	'PATH='
cbPATH	= $ - stPATH

pszPATH dw	?			; near ptr to PATH data
fCurDir db	0			; have we looked in the current dir?

ParmBlock dw	0			; use HELPs environment
	dw	offset CmdLine		; offset of command line
PB_CmdLineSeg dw	0		; segment of command line
	dd	-1			; use default for FCB 1
	dd	-1			; use default for FCB 2


; NOTE: The command tail, program name, and stack do not have any
; NOTE: representation in this file.  They are allocated after the
; NOTE: command line in the memory that DOS allocates for us.  This
; NOTE: allows the COM file to be only 1 sector in size, thus saving
; NOTE: disk space.

CmdLine db	0			; length of command line
	db	'/QHELP '		; static part of command line
CmdTail db	0			; user specified part of command line

ProgName =	CmdTail + Max_CmdTail -1; program to exec
TopOfStack =	ProgName + Path_Size + Stack_Size ; Top of stack = end of mem


code	ENDS

	END	help
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\qb\uirstubc.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\ir\vardbg.c ===
/*** 
*vardbg.c - non-release code to validate varmgr.c
*
*	Copyright <C> 1986,1987 Microsoft Corporation
*
*Purpose:
*	contains routines used for debugging the variable manager; These routines
*	are pretty verion-specific, and so have been moved out of vardebug.c.
*
*******************************************************************************/
#include "version.h"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\ir\qedit.asm ===
TITLE	QEDIT - Loader for the QEDIT editor
;***
;QEDIT - Loader for the QEDIT editor
;
;	Copyright (C) 1990, Microsoft Corporation
;
;Purpose:
;	This file implements QEDIT.COM.  The purpose of this com file
;	is to invoke QBASIC.EXE with the /editor switch, passing on all
;	other command line options
;
;*******************************************************************************


	Stack_Size  = 256	; size of stack in bytes
	Path_Size   = 128	; max size of path + filename of QBASIC
	Max_CmdTail = 73	; max size of program options after /EDCOM
	OldCmdLine  = 80h	; DS:OldCmdLine = ptr to QEDIT command line
	EnvSeg	    = 2ch	; DS:EnvSeg	= ptr to QEDIT environment


code	SEGMENT PARA PUBLIC 'CODE'

	ASSUME	cs:code, ds:code, es:code, ss:code

	ORG	0100h

qedit:
	mov	bx, offset TopOfStack	; BX = ptr to top of stack (end of mem)
	mov	sp,bx			; move stack to perminent memory
	add	bx,000fh		; round up to units of paragraphs
	shr	bx,1
	shr	bx,1
	shr	bx,1
	shr	bx,1			; BX = # paragraphs of memory
	mov	ah,4ah			; modify memory block
	int	21h
	mov	dx, offset ErrART	; assume an error
	jnc	@F
GiveError_Near:
	jmp	GiveError		; brif error
@@:

	; set up the parameter block
	mov	ax,cs
	mov	[PB_CmdLineSeg],ax	; set the segment of the command line

	; set up the command line
	mov	al, ds:[OldCmdLine]	; al = length of old command line
	cmp	al, Max_CmdTail 	; is the command line too long
	mov	dx, offset ErrCmd	; assume so, prepare error
	ja	GiveError_Near		; brif too long

	cbw				; zero extend ax (cant be > 80)
	mov	cx, ax			; save in cx
	inc	cx			; also copy over 0D terminator
	add	ax, CmdTail-CmdLine	; ax = length of new command line
	mov	[CmdLine],al		; and save it
	mov	si, offset OldCmdLine+1 ; DS:SI = ptr to old command line
	mov	di, offset CmdTail	; DS:DI = ptr to new command line
	rep	movsb			; and copy it over

	; set up the program name

	mov	ax, ds:[EnvSeg]		; ax = segment of environment
	mov	es, ax
	xor	di, di			; ES:DI = ptr to environment
	xor	ax, ax			; look for a zero
	mov	pszPATH,-1		; indicate that no PATH found

LocateFname:
	mov	cx, cbPATH		; length of 'PATH='
	mov	si, offset stPATH	; see if this is the PATH specification
	repe	cmpsb
	jne	NotPath 		; brif not PATH
	mov	pszPATH, di		; EnvSeg:pszPATH = ptr to PATH data

NotPath:
	dec	di			; back up a character
	mov	cx, 8000h		; scan a long way for a 0 if needed
	repne	scasb			; skip an environment string
	cmp	es:[di],al		; is next byte a null?
	jne	LocateFname		; not double null term, keep looking

	inc	di			; skip last null
	scasw				; skip word containing 1h

	mov	si, di			; ES:SI = ptr to QEDIT path & name
	mov	di, offset ProgName	; DS:DI = ptr to QBASIC path & name
	push	es
	pop	ds			; DS:SI = ptr to QEDIT path & name
	push	cs
	pop	es			; ES:DI = ptr to QBASIC path & name

	mov	ah,30h			; get version number
	int	21h			; are we in DOS 3 or above?

	mov	bx,di			; CS:BX = ptr to first char in QEDIT
					; name as it is copied over
	cmp	al,3
	jb	HavePath		; brif not DOS 3 or above, no path

CopyName:
	lodsb				; grab a byte
	stosb				; and store it
	cmp	al,'\'                  ; is it a slash
	je	PathChar		;  go remember it
	cmp	al,'/'			; or this slash
	je	PathChar		;  go remember it
	cmp	al,':'			; or a colon
	jne	TestTerminator		; brif not
PathChar:
	mov	bx,di			; set last path character found
TestTerminator:
	or	al,al			; 0 terminator?
	jnz	CopyName		; brif not, more characters to do

HavePath:
	push	cs
	pop	ds			; restore ES = DS = CS

	cmp	bx, offset ProgName	; does it have any path?
	jne	@F			; brif so
	mov	fCurDir,1		; else flag cur directory tried
@@:
	mov	di, bx			; ES:DI = ptr to end of QEDIT path
	mov	si, offset szQBASIC	; DS:SI = ptr to new file name
	mov	cx, cbQBASIC		; CX = # characters
	rep	movsb			; and copy it over

	; all set up, lets go exec the program

	mov	dx, offset ProgName
	mov	bx, offset ParmBlock
	mov	ax, 4b00h
	int	21h			; Exec program
	jnc	GetRetCode		; brif ok

	mov	dx,offset ErrOM
	cmp	ax,8			; is it out of memory?
	jne	TryPathSearch		; brif not, assume file not found

GiveError:
	push	cs			; set DS=code segment (for error)
	pop	ds

	mov	ah,9
	int	21h			; print error message
	mov	ax,4cffh		; terminate program, return code FF
	int	21h
	;Does not return

GetRetCode:
	mov	ah,4dh
	int	21h			; al = return code of previous prog
	mov	ah,4ch
	int	21h			; exit with return code in al
	;Does not return


; We could not load QBASIC from the directory that QEDIT was located in.
; We will now try the directories in the PATH.

TryPathSearch:
	cmp	fCurDir,0		; have we looked in current dir?
	mov	bx, offset ProgName	; assume not, setup to try with no path
	jz	HavePath		; brif not, go try it.
	mov	dx, offset ErrFNF	; prepare for error
	mov	ax, cs:[EnvSeg]		; ax = segment of environment
	mov	ds, ax
	mov	si, cs:pszPATH		; DS:SI = ptr to PATH data
	cmp	si,-1			; was there a PATH env variable?
	je	GiveError		; brif not, give File Not Found

	push	cs
	pop	es
	mov	di, offset ProgName	; ES:DI = buffer to construct filename

NextPathChar:
	lodsb				; get a character of a path
	stosb				; save character
	cmp	al,';'			; end of path?
	je	PathEnd 		; brif so
	or	al,al			; end of string
	jne	NextPathChar		; brif not
	mov	si,-1			; indicate no more path
PathEnd:
	mov	cs:pszPATH,si		; set up pointer for next iteration
	dec	di			; back up over the ';' or 0 terminator
	mov	al,'\'                  ; look for a back slash
	cmp	byte ptr es:[di-1],al	; does it end in a backslash?
	je	HaveFullPath		; brif so
	cmp	byte ptr es:[di-1],'/'	; or does it end in a forward slash?
	je	HaveFullPath		; brif so
	stosb				; else, add it
HaveFullPath:
	mov	bx, di			; CS:BX = ptr to where to fill in name
	jmp	HavePath


ErrOM	db	'Out of memory$'
ErrFNF	db	'Can not find file QBASIC.EXE$'
ErrART	db	'DOS memory-arena error$'
ErrCMD	db	'Command line too long$'

szQBASIC db	'QBASIC.EXE', 0
cbQBASIC = $ - szQBASIC

stPATH	db	'PATH='
cbPATH	= $ - stPATH

pszPATH dw	?			; near ptr to PATH data
fCurDir db	0			; have we looked in the current dir?

ParmBlock dw	0			; use QEDITs environment
	dw	offset CmdLine		; offset of command line
PB_CmdLineSeg dw	0		; segment of command line
	dd	-1			; use default for FCB 1
	dd	-1			; use default for FCB 2


; NOTE: The command tail, program name, and stack do not have any
; NOTE: representation in this file.  They are allocated after the
; NOTE: command line in the memory that DOS allocates for us.  This
; NOTE: allows the COM file to be only 1 sector in size, thus saving
; NOTE: disk space.

CmdLine db	0			; length of command line
	db	'/EDCOM '		; static part of command line
CmdTail db	0			; user specified part of command line

ProgName =	CmdTail + Max_CmdTail -1; program to exec
TopOfStack =	ProgName + Path_Size + Stack_Size ; Top of stack = end of mem


code	ENDS

	END	qedit
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\ir\varmgrc.c ===
/*** 
*varmgrc.c - Variable Manager for the BASIC 5.0 Interpreter
*
*  Copyright <C> 1985, Microsoft Corporation
*
*Purpose:
*  Includes code for:
*     - creating and searching for variables
*     - creating and searching for user-defined types
*  Includes a description of namespaces in BASIC.
*
**************************************************************************/


/*
The matrix given below is a representation of the namespaces in BASIC.
Each class of names is listed on both the vertical and horizontal axis';
X's in a square indicate that the two classes share a namespace (and
could thus have name conflicts), while blanks in a square indicates that
the two classes have separate namespaces.

An astrisk ('*') (shown on vertical axis only) indicates that
a type character included at the end of the name counts as
part of the name for determining uniqueness.

NOTE: This is a copy of the identical table in basic40.doc. If there's
      any conflict between this table and that one, the one in basic40.doc
      takes precedence.


           COM  LAB  DEF  SUB  FUNC Type Elem Sclr typd Arry typd Const
           Blk        Fn                           Sclr      Arry
          |    |    |    |    |    |    |    |    |    |    |    |    |
        ---------------------------------------------------------------
COMMON Blk| XX |    |    |    |    |    |    |    |    |    |    |    |
          | XX |    |    |    |    |    |    |    |    |    |    |    |
        ---------------------------------------------------------------
Label     |    | XX |    |    |    |    |    |    |    |    |    |    |
          |    | XX |    |    |    |    |    |    |    |    |    |    |
        ---------------------------------------------------------------
DEF Fn*   |    |    | XX | XX | XX |    |    | XX | XX | XX | XX | XX |
          |    |    | XX | XX | XX |    |    | XX | XX | XX | XX | XX |
        ---------------------------------------------------------------
SUB       |    |    | XX | XX | XX |    |    | XX | XX | XX | XX | XX |
          |    |    | XX | XX | XX |    |    | XX | XX | XX | XX | XX |
        ---------------------------------------------------------------
FUNCTION  |    |    | XX | XX | XX |    |    | XX | XX | XX | XX | XX |
          |    |    | XX | XX | XX |    |    | XX | XX | XX | XX | XX |
        ---------------------------------------------------------------
Type      |    |    |    |    |    | XX |    |    |    |    |    |    |
          |    |    |    |    |    | XX |    |    |    |    |    |    |
        ---------------------------------------------------------------
Element   |    |    |    |    |    |    | XX |    |    |    |    |    |
          |    |    |    |    |    |    | XX |    |    |    |    |    |
        ---------------------------------------------------------------
Scaler*   |    |    | XX | XX | XX |    |    | XX | XX |    |    | XX |
          |    |    | XX | XX | XX |    |    | XX | XX |    |    | XX |
        ---------------------------------------------------------------
typed     |    |    | XX | XX | XX |    |    | XX | XX |    |    | XX |
  Scaler  |    |    | XX | XX | XX |    |    | XX | XX |    |    | XX |
        ---------------------------------------------------------------
Array*    |    |    | XX | XX | XX |    |    |    |    | XX | XX |    |
          |    |    | XX | XX | XX |    |    |    |    | XX | XX |    |
        ---------------------------------------------------------------
typed     |    |    | XX | XX | XX |    |    |    |    | XX | XX |    |
  Array   |    |    | XX | XX | XX |    |    |    |    | XX | XX |    |
        ---------------------------------------------------------------
Const     |    |    | XX | XX | XX |    |    | XX | XX |    |    | XX |
          |    |    | XX | XX | XX |    |    | XX | XX |    |    | XX |
        ---------------------------------------------------------------
*/

#include "version.h"
#if !HEAP_H
#include "heap.h"
#endif
#if !CONINT_H
#include "conint.h"
#endif
#if !CONTEXT_H
#include "context.h"
#endif
#if !VARIABLE_H
#include "variable.h"
#endif
#if !QBIMSGS_H
#include "qbimsgs.h"
#endif
#if !NAMES_H
#include "names.h"
#endif
#if !UTIL_H
#include "util.h"
#endif
#if !EXECUTOR_H
#include "executor.h"
#endif
#if !PARSER_H
#include "parser.h"
#endif
#if !TXTMGR_H
#include "txtmgr.h"
#endif
#if !SCANNER_H
#include "scanner.h"
#endif

/* forward reference of functions used only locally */
ushort   NEAR     CreateVar(ushort, ushort);
boolean  FAR      ModSharedChk(VOID);
void     NEAR     ReDirect(VOID);

ushort   NEAR     StdSearch(VOID);
STATICF(VOID) AdjustStatChain(var *, ushort, ushort);
STATICF(ushort) GrowBdVar(ushort);
ushort NEAR FuncSearch(void);
ushort NEAR GetDefaultType(char);

extern   ushort oNamOfPrsCur;    /* set in ssrude.asm                         */

VOID     FAR      B_ISdUpd(sd *, ushort);
                                 /* runtime entry point to update moving sd's */
VOID     FAR      B_IAdUpd(ad *, ushort);
                                 /* runtime entry point to update moving ad's */

/* varmgr-specific data */
ushort  vm_oVarCur;                 /* offset to current variable table entry */
var *vm_pVarCur;                    /* only guaranteed to be setup immediately
                                       after a search or variable creation    */
ushort vm_oVarTmp;                  /* temporary var entry offset             */
boolean vm_fVarFound;               /* return value from var search routines.
                                       note that, if vm_fVarFound is TRUE, the 
                                       offset to the found var will be in 
                                       vm_oVarCur (a static, also used in 
                                       variable creation).                    */
ushort vm_fPVCur;                   /* currently searching tPV if TRUE        */
STATICV uchar nm_mask;              /* mask to apply to tNam flag for variable*/
STATICV ushort errVal;              /* error return - used for those cases
                                       which must return some other value
                                       (such as routines invoked via
                                        ForEachPrsInMrs ...)                  */
STATICV boolean fConvtdToFun;       /* used by FuncSearch to communicate the
                                       fact that it converted an existing
                                       entry to be a FUNCTION entry.          */

/*##############################################################################
#                                                                              #
#                        Variable Storage Scheme                               #
#                                                                              #
##############################################################################*/
/* 
Variables are stored as follows:

      There is one physical variable table per module, and one logical table
      per procedure and module. This is accomplished by having one hash table
      per logical table, all inter-woven in the physical table.

      Each hash table is initialized to zeros, and contains a fixed number
      of fields, each of which is an offset into the physical table to the
      first variable in a chain of variables that hash to the same hash table
      entry.  The hashing function is based on the name table offset (oNam)
      for the variable.   Note that module hash tables are larger than proc.
      hash tables, in anticipation of more variables per module than per
      procedure (i.e., to help give us reasonable search speed for module
      variables).  As of this writing (Aug. '87), there are 16 hash chains 
      per module hash table, and 8 per procedure hash table.

      The links in each hash chain are (physical) variable table offsets to
      the next variable entry in the chain.  The end-of-chain marker is
      EITHER a 0 or a 1 - - - this is because we also store a flag in the
      low bit of the hash link (we use every bit we can get ...).

      Since variables cannot be dynamically removed and/or reused (i.e.,
      one can unlink an entry, but then that space is dead), variable
      entries and hash tables go into the physical table in whatever order 
      they are encountered.

Variable Entries:

      A variable entry looks like one of the below:

                  If oTyp is User-              If oTyp is I2, I4,
                  Defined or a Fixed            R4, R8, or Sd. oTyp
                  Length String                 is stored in low 3
                                                bits of flags field
                  +----------------+      
		  |   oTyp/cbFS    |
                  +----------------+            +----------------+
                  |      oNam      |            |      oNam      |
                  +----------------+            +----------------+ 
                  |   oHashLink    |            |   oHashLink    |
                  +----------------+            +----------------+
                  |     flags      |            |     flags      |
                  +----------------+            +----------------+
          pVar--->+     value      |    pVar--->|     value      |
                  |                |            |                |
                  +----------------+            +----------------+


      The value field is of variable length, depending on what the variable
      represents. The flag bits allow determination of size and use of the
      value field for any given variable.

      All variable entries are of even size, and must fall on even byte
      boundaries, for 2 reasons:
         (1) The runtime requires SD's to fall on even byte boundaries
         (2) We store a flag bit in the low byte of the oHashLink field,
               so each oVar must be even.
                                                                              */


/*##############################################################################
#                                                                              #
#                        Variable Creation                                     #
#                                                                              #
##############################################################################*/
/***
*GrowBdVar(cbGrowVar) - grow variable table
*Purpose:
*  Given an amount by which we wish to grow the active variable table,
*  grow it if possible, returning FALSE if successful or an error code if not.
*
*  In the event that grs.otxCONT != UNDEFINED, don't call BdGrowVar; instead,
*  succeed if sufficient space exists between cbLogical and cbPhysical, fail
*  otherwise, returning ER_CN.
*Entry:
*  cbGrowVar - number of bytes we wish to grow mrsCur.bdVar by.
*Exit:
*  FALSE if successful, in which case mrsCur.bdVar.cbLogical is increased by
*     cbGrowVar
*  Otherwise, returns an error code for use by CreateVar, below.
*******************************************************************************/
STATICF(ushort) GrowBdVar(cbGrowVar)
ushort cbGrowVar;
   {
   /* [13] ensure that oVar < 0x8000					      */
   if ((mrsCur.bdVar.cbLogical + VAR_STRUCT_SIZE + 2) > 0x7FFF) /* [13]       */
      return (PRS_ER_RE | ER_OM);		   /* [13] out of memory      */

   if (grs.otxCONT == UNDEFINED) {                 /* user can't CONTinue     */
      if (!BdGrowVar(&mrsCur.bdVar, cbGrowVar))
         return (PRS_ER_RE | ER_OM);               /* out of memory           */
      }
   else {            
      /* user is able to CONTinue; fail unless space already exists in table  */
      REG1 ushort temp = mrsCur.bdVar.cbLogical + cbGrowVar;
      if (temp > mrsCur.bdVar.cbPhysical) {	   /* would have to actually  */
						   /* grow table	      */
         DbAssert(!(mkVar.flags2 & MV_fTrashTable))
         return (0x8000 | ER_CN);
         }
      else 
         mrsCur.bdVar.cbLogical = temp;            /* success.                */
      }
   return(FALSE); 
   }

/***
*CreateVar(oPVHash, varFlags) - create a new variable
*Purpose:
*  Create a new variable in the mrsCur.bdVar. If 'oPVHASH' is UNDEFINED, 
*  create it in the tMV, else, use the offset to the tPV hash table.
*  
*Entry:
*  oPVHash - UNDEFINED if we're to create var in the tMV, or an offset
*              into mrsCur.bdVar to the hash table for the tPV.
*  varFlags  - Initial settings for the flags word in the new var entry.
*              FVFNNAME, FVFUN, FVCOMMON, FVFORMAL, FVDECLDVAR, FVSHARED, 
*              FVCONST, and FVSTATIC are to be set correctly; FVARRAY & 
*              FVINDEXED will frequently be correct, but may be changed 
*              based on other flags settings; FVVALUESTORED is to
*              be pathologically set to TRUE on input, while 
*              FVEVEREXPLICIT, and FVREDIRECT are to be set FALSE.
*  mkVar - global structure containing MakeVariable inputs for oNam,
*              oTyp, and a(nother) flags word.
*
*  NOTE: All variables are created on even-byte boundaries. This
*        guarantees, in turn, that the value fields of all variables will
*        start on even byte boundaries. We ensure this primarily by the
*        structure definitions in variable.h/.inc.  The primary reason for
*        this is that the shared runtime assumes (and requires) that all
*        string descriptors be on even byte boundaries.
*
*Exit:
*  return value is an error code; either zero is returned (no error),
*  or the same error code as is used by MakeVariable is returned (see
*  MakeVariable, below).
*
*  Also sets module static vm_oVarCur to the offset into mrsCur.bdVar
*  to the new entry, and vm_pVarCur to point to the entry.
*
*Exceptions:
*  none.
*
*******************************************************************************/
ushort NEAR CreateVar(oPVHash, varFlags)
ushort oPVHash;
ushort varFlags;
   {
   var *pVar;
   ushort inFlags = mkVar.flags;	     /* put MakeVariable callers flags
						word in a register	      */
   ushort cbValue = 0;
   ushort cbOTyp;
   ushort *pHash;
   uchar  nmsp_type;
   ushort temp;
   ushort entryFlags;			     /* [11] use this to build up
						[11] the flags word for entry */
   ushort oPrsRef;			     /* [11] 0 or oPrs for function
						[11] ref		      */

   /* if caller to MakeVariable really wanted just a search without modifying
      the variable table, return Internal Error code to indicate that the
      search failed                                                           */
   if (mkVar.flags2 & MV_fDontCreate)
      return (PRS_ER_RP | ER_IER);

   /* The following assertion is made because (if for no other reason ...)
      we assume that the user can still CONTinue if he asks to add a variable
      but we return ER_CN and he backs out of the edit                        */
   DbAssertIf(mkVar.flags & !(FVCOMMON | FVFNNAME | FVFUNCTION), 
                                          !(mkVar.flags2 & MV_fTrashTable))

   if ((mkVar.oTyp == UNDEFINED) && !(mkVar.flags & FVASCLAUSE))
                                    /* reference to a record prior to ...AS...*/
      return (PRS_ER_RP | MSG_BadElemRef); /* [9] */

   /* The following assertion is based on the fact that we're using
      grs.oRsCur in the case that we CAN continue to see if there's an active
      frame on the stack for the active procedure - if so, we return ER_CN    */
   DbAssertIf(oPVHash != UNDEFINED, 
               ((grs.oRsCur & 0x8000) && (prsCur.oVarHash == oPVHash)))
   if ((oPVHash != UNDEFINED) && 
       (grs.otxCONT != UNDEFINED) && 
       !(varFlags & (FVSTATIC | FVSHARED | FVCONST)))
      if (FindORsFrame())           /* TRUE if this proc has an active frame  */
	 return (0x8000 | ER_CN);   /* allow the user to back out of edit     */

   oPrsRef = 0; 		    /* [11] initialize			      */

   entryFlags = varFlags & ~0x07;

   if (inFlags & (FVFORCEARRAY | FVINDEXED))
      if (varFlags & FVFUN)
	 entryFlags |= FVINDEXED;
      else {
	 entryFlags |= (FVARRAY | FVINDEXED);
         /* set the dimension count; if input of zero, assume 1 - - - will end
            up giving Rude Edit later if this turns out to have been wrong    */
         if ((mkVar.cDimensions == 0) && !(inFlags & FVCOMMON))
            cbValue = sizeof(dm);
            /* NOTE: we if a dimension count wasn't specified on a COMMON
                     statement for an array, the execute scanner depends on
                     the cDims field in the variable entry being 0;
                     we depend on that for STATIC arrays, in StdSearch        */
         if ((inFlags & FVSTATIC) && (mkVar.cDimensions > 8))
            return (PRS_ER_RE | MSG_SubCnt); /* 'Wrong number of subscripts'  */
         }
   
   if (!(inFlags & FVIMPLICIT))           /* if pathological input was wrong  */
      entryFlags |= FVEVEREXPLICIT;
                                                      
   inFlags = entryFlags;      /* now use flags as passed BY MakeVariable      */

   /* initialize cbValue for static variable case, to save code later on      */
   cbValue += (inFlags & FVARRAY) ? (sizeof(aStat) + - sizeof(oneChar) +
				     sizeof(dm) * mkVar.cDimensions) :
				    (mkVar.oTyp == ET_FS ? mkVar.fsLength :
				     CbTyp(mkVar.oTyp));

   nmsp_type = NMSP_Variable; /* assume we're not creating a FUNCTION, or 
                                 DEF FN entry                                 */

   if (inFlags & 
      (FVFORMAL | FVCOMMON | FVSTATIC | FVFUNCTION | FVSHARED | FVCONST)) {
      if (inFlags & (FVFORMAL | FVCOMMON | FVFUNCTION)) {
         if (inFlags & FVCOMMON) {
	    entryFlags &= ~FVVALUESTORED;	   /* set that bit to FALSE   */
	    cbValue = (inFlags & FVARRAY ? sizeof(aCom) : sizeof(comRef));
            if (inFlags & FVSHARED)
               nm_mask |= NM_fShared;
            }
         else {                                    /* not COMMON -            */
	    cbValue = sizeof(ushort);
            if (inFlags & FVFUNCTION) {
               nmsp_type = 0;                      /* don't set any name table
                                                      bits                    */
               if ((oPVHash == UNDEFINED) && (mkVar.flags & FVFUNCTION))
                  nm_mask |= NM_fShared;           /* set tNam entry flag  */
               if (mkVar.flags & FVLVAL)           /* retval                  */
		  entryFlags &= ~FVVALUESTORED;    /* set to FALSE for retval */
	       else {
		  if ((oPrsRef =
                     PrsRef(mkVar.oNam,
                            (uchar)((mkVar.flags & FVFUNCTION) ? 
                                       PT_FUNCTION : PT_DEFFN),
			    mkVar.oTyp)) & 0x8000) /* [16] function not found */
                     return (PRS_ER_RP | ER_UF);   /* 'Undefined Function'    */
                  }
               }
            else {   /* FVFORMAL */
	       entryFlags &= ~FVVALUESTORED;	   /* set that bit to FALSE   */
               if (inFlags & FVARRAY)
		  cbValue = sizeof(aFormal);
               }  
            }  /* else - not COMMON */
         }  /* if FORMAL, COMMON, DEF FN, or FUNCTION */
      else                                         /* STATIC,SHARED, or CONST */
         if (inFlags & FVSHARED) {
            if (oPVHash == UNDEFINED)              /* entry going in the tMV  */
               nm_mask |= NM_fShared;
            else {   /* entry going in tPV */
	       entryFlags &= ~FVVALUESTORED;	   /* set to FALSE */
	       cbValue = sizeof(ushort);
               }
            }  /* if SHARED */
         else if (inFlags & FVCONST) {
            if (oPVHash == UNDEFINED)              /* entry going in the tMV  */
               nm_mask = NM_fShared;               /* Always set fShared bit
                                                      so constants are found  */
            }
      }  /* if special case flag is set */
   else {
      if ((grs.oPrsCur != UNDEFINED) && (prsCur.procType == PT_DEFFN))
         oPVHash = UNDEFINED;    /* var ref. belongs in the tMV for DEF's     */
      if ((oPVHash != UNDEFINED) && (!(prsCur.flags & FP_STATIC))) {
	 entryFlags &= ~FVVALUESTORED;	  /* actual value not stored in entry */
         if (inFlags & FVARRAY)
	    cbValue = sizeof(aFrame);
         else
	    cbValue = sizeof(ushort);		   /* size of a frame offset  */
         }
      }  /* no special case flag was set */
   cbValue = ((++cbValue) >> 1) << 1;              /* round up cbValue, to 
                                                      ensure even-byte vars. 
                                                      Note that this MUST be
                                                      done in case of odd-sized
                                                      user-defined types or 
						      fixed-length strings.   */
   cbOTyp = ((mkVar.oTyp > ET_MAX) || (mkVar.oTyp == ET_FS)) ?
		  sizeof(ushort) : 0;

   vm_oVarCur = mrsCur.bdVar.cbLogical + cbOTyp + VAR_STRUCT_SIZE;    /* [11] */

   /* [11] see if namespace ER_DD error BEFORE we try to grow the var table,
      [11] so we don't ask user if he wants to continue and THEN give error   */
   if (nmsp_type)				   /* don't set anything if
                                                      creating a DEF or FUN
                                                      entry (txtmgr does it)  */
      if (CheckONamSpace(mkVar.oNam, nmsp_type))
	 return (PRS_ER_RE | ER_DD);		   /* duplicate definition    */

   temp = cbValue + cbOTyp + VAR_STRUCT_SIZE;
   if (temp < cbValue)			/* [12] 64k wrap occurred	      */
      return (PRS_ER_RE | ER_OM);	/* [12] out of memory		      */
   if (temp = GrowBdVar(temp))
      return (temp);
   pVar = (var *)(mrsCur.bdVar.pb + vm_oVarCur); /* in case table moved    */
   ZeroFill((char *)pVar, cbValue);

   if (cbOTyp) {		      /* oTyp > ET_MAX */
      if (mkVar.oTyp == ET_FS) {
		  *((ushort *)((char *)pVar + VAR_cbFixed)) = mkVar.fsLength;
		  entryFlags |= mkVar.oTyp;
      }
      else
		  *((ushort *)((char *)pVar + VAR_oTyp)) = mkVar.oTyp;
      }
   else
      entryFlags |= mkVar.oTyp;
   
   ONamOf(pVar) = mkVar.oNam;			   /* [11]		      */
   FlagsOf(pVar) = entryFlags;			   /* [11] set entry flags    */
   ValueOf(pVar, oPrs) = oPrsRef;		   /* [11] oPrs or zero       */

   if (nmsp_type) {                                /* don't set anything if
                                                      creating a DEF or FUN
                                                      entry (txtmgr does it)  */
      if (SetONamSpace(mkVar.oNam, nmsp_type))
	 ;					   /* [11] CheckONamSpace will
						      [11] already have caught
						      [11] error, if any      */

      }

   mrsCur.oPastLastVar = mrsCur.bdVar.cbLogical;   /* can always trim table 
                                                      back to oPastLastVar and
                                                      lose no variables       */
   vm_pVarCur = pVar;                              /* an exit value           */

   /* initialize the dim count if:
	the entry is an array AND it's NOT (shared AND in a procedure).
	(If an array is shared and in a procedure it doesn't have a cDims
	field in the var table entry.  The entry is a near pointer to the
	array descriptor defining the array.) */

   if ((FlagsOf(pVar) & FVARRAY) &&
      !((FlagsOf(pVar) & FVSHARED) && (oPVHash != UNDEFINED)))	//[17]
      ValueOf(pVar, aryStat.cDims) = mkVar.cDimensions;
                                                   /* this actually sets
                                                      cDims for all arrays    */

   /* now just have to link the new entry in */

   pHash = (ushort *)(mrsCur.bdVar.pb +
                        ((oPVHash == UNDEFINED) ? 
                              (mkVar.oNam & HASH_MV_NAMMASK) : 
                              (oPVHash + (mkVar.oNam & HASH_PV_NAMMASK))));
   if ((*pHash == 0) || (FlagsOf(pVar) & FVDECLDVAR)) {  
      /* link this entry into start of chain */
      OHashLinkOf(pVar) = *pHash;         /* old start of chain in new entry  */
      *pHash = vm_oVarCur;                /* save offset to new entry         */
      }
   else {   /* link this entry into end of chain */
      OHashLinkOf(pVar) = 0;              /* 0 (or 1) indicates end of chain;
                                             UNDEFINED doesn't do it because
                                             we store a flag in the low bit   */
   pVar = (var *)(mrsCur.bdVar.pb + *pHash);	   /* point to start of chain */
   while (OHashLinkOf(pVar) > 1)		   /* while not end of hash chain	   */
      pVar = (var *)(mrsCur.bdVar.pb + (OHashLinkOf(pVar) & 0xFFFE));
      OHashLinkOf(pVar) |= vm_oVarCur;    /* OR this in rather than assign it
                                             to preserve existing flag value  */
      DbAssert(!(vm_oVarCur & 1))         /* we depend on oVars being on even
                                             byte boundaries for this hashlink
                                             bit flag use, and for SD's       */
      }
   return (vm_fVarFound = FALSE);                  /* var created, not found;
                                                      retval says 'no errors' */
   }  /* CreateVar */


/*##############################################################################
#                                                                              #
#                        Variable Searching                                    #
#                                                                              #
##############################################################################*/

/***
*ReDirect() - unlink entry @ vm_oVarCur, set FVREDIRECT, put vm_oVarTmp in value
*Purpose:
*  'ReDirect' a variable entry, i.e., unlink it from its hash chain, set
*  the FVREDIRECT flag in the entry, and put the offset to the 'real'
*  entry (in vm_oVarTmp) into the value field.
*
*  Redirection is performed whenever an existing entry is made invalid
*  by some new instance of a matching variable, for example, what looked
*  like an array at first encounter might be found to be a FUNCTION at
*  a later encounter - - - all such array entries (in tMV and all tPV's)
*  are redirected to this newly created FUNCTION entry. The scanner
*  can then go through and fix up the pcode for each redirected entry,
*  since we'll put the oVar for the new entry in the redirected entry.
*Entry:
*  vm_fPVCur - module static flag, TRUE if hash table is in tPV, FALSE if tMV.
*  mrsCur.bdVar assumed set up, and if vm_fPVCur is TRUE, prsCur is assumed
*     to be set up, and the oVarHash field to contain an offset into
*     mrsCur.bdVar to the tPV hash table.
*  vm_oVarCur is an offset into mrsCur.bdVar to the entry to be redirected.
*  vm_oVarTmp is an offset into mrsCur.bdVar to the entry it is to be
*     redirected to.
*Exit:
*  none.
*Exceptions:
*  none.
*******************************************************************************/
VOID NEAR ReDirect()
   {
   REG1 var *pVar;                     
   REG2 char *pVarBase = mrsCur.bdVar.pb;
   REG3 ushort *pHash;
   REG4 var *pVarPrev;
   REG5 ushort oHashTmp;

   /*--------------------------------------------------------------------------
   | calculate pointer into hash table to offset to the first entry in the    |
   |  chain; this is just:                                                    |
   |     (base of physical table) + (offset to start of hash table) +         |
   |     (offset into hash table)                                             |
   --------------------------------------------------------------------------*/
   DbAssertIf(vm_fPVCur, prsCur.oVarHash != UNDEFINED)
   pHash = (ushort *)(mrsCur.bdVar.pb +
                     (vm_fPVCur ? 
                           (prsCur.oVarHash + (mkVar.oNam & HASH_PV_NAMMASK)) :
                           (0 + (mkVar.oNam & HASH_MV_NAMMASK))));

   pVar = (var *)(pVarBase + *pHash);           /* point to first entry       */

   if (*pHash == vm_oVarCur)                    /* entry is @ start of chain  */
      *pHash = OHashLinkOf(pVar) & 0xFFFE;      /* unlink first entry         */
   else {
      while ((oHashTmp = OHashLinkOf(pVar) & 0xFFFE) != vm_oVarCur) {
         DbAssert(oHashTmp != 0)                /* better not be end of chain */
         pVar = (var *)(pVarBase + oHashTmp);
         }
      pVarPrev = pVar;                          /* point to entry prior to one
                                                   we wish to unlink          */
      pVar = (var *)(pVarBase + oHashTmp);
      OHashLinkOf(pVarPrev) = OHashLinkOf(pVar);/* unlink the entry           */
      }
   
   /* at this point, pVar points to the entry being redirected                */
   FlagsOf(pVar) |= FVREDIRECT;
   ValueOf(pVar, oMV) = vm_oVarTmp;

   }  /* ReDirect */

/***
*FuncSearch() - search the appropriate hash table for FUNCTION case
*Purpose:
*  Search the appropriate table (tPV or tMV) in the case where we've
*  encountered [DECLARE] FUNCTION.
*Entry:
*  vm_fPVCur - module static flag, TRUE if we're to search tPV, FALSE if tMV.
*  mrsCur.bdVar assumed set up, and if vm_fPVCur is TRUE, prsCur is assumed
*     to be set up, and the oVarHash field is either UNDEFINED (in which
*     case we just return), or contains an offset into mrsCur.bdVar to the 
*     tPV hash table.
*
*  mkVar set up as per MakeVariable (below).
*Exit:
*  FALSE = no error
*  otherwise, the same error code is returned as described for MakeVariable,
*     below.
*  If no error is returned, then the static vm_fVarFound indicates success or
*     failure. 
*  If vm_fVarFound == TRUE, vm_oVarCur is set to the offset into mrsCur.bdVar to
*     the found variable entry, and vm_pVarCur points to the entry.
*  If an existing entry has been converted to a FUNCTION entry by the search,
*     the static flag fConvtdToFun will be set TRUE.
*Exceptions:
*  none.
*******************************************************************************/
ushort NEAR FuncSearch()
   {
   REG1 var *pVar;                     
   REG2 char *pVarBase = mrsCur.bdVar.pb;

   /*--------------------------------------------------------------------------
   | calculate offset into mrsCur.bdVar to first entry in appropriate hash    |
   |  chain; this is the contents of:                                         |
   |     (base of physical table) + (offset to start of hash table) +         |
   |     (offset into hash table)                                             |
   --------------------------------------------------------------------------*/
   REG3 ushort oVar = *(ushort *)(mrsCur.bdVar.pb +
                     (vm_fPVCur ? 
                           (prsCur.oVarHash + (mkVar.oNam & HASH_PV_NAMMASK)) :
                           (0 + (mkVar.oNam & HASH_MV_NAMMASK))));
   fConvtdToFun = vm_fVarFound = FALSE;      /* initialize                    */

   if ((oVar == 0) || (vm_fPVCur && (prsCur.oVarHash == UNDEFINED)))
      return(FALSE);                         /* empty hash chain - not found  */

   for (pVar = (var *)(pVarBase + oVar);     /* loop init.                    */
        pVar != (var *)pVarBase;             /* oVar = 0 ==> end of chain     */
        pVar = (var *)(pVarBase + (OHashLinkOf(pVar) & 0xFFFE))) {   
                                             /* loop re-init   */
      if (mkVar.oNam != ONamOf(pVar))
         continue;
      if (!(FlagsOf(pVar) & FVFUN)) {
         if (FlagsOf(pVar) & (FVFORMAL | FVCOMMON | FVSTATIC | FVCONST |
                                                      FVSHARED | FVDECLDVAR))
            return (PRS_ER_RE | ER_DD);
         if (OTypOf(pVar) != mkVar.oTyp)
            if (FlagsOf(pVar) & FVEVEREXPLICIT)
               return (PRS_ER_RE | ER_DD);
            else {
               DbAssert(mkVar.oTyp <= ET_MAX)
               FlagsOf(pVar) = (FlagsOf(pVar) & ~ 0x07 | mkVar.oTyp);
               }
         fConvtdToFun = TRUE;                /* set flag if converting to FUN */
         ValueOf(pVar, oPrs) = PrsRef(mkVar.oNam, PT_FUNCTION, mkVar.oTyp);
                                             /* set value field               */
         DbAssert(ValueOf(pVar, oPrs) != UNDEFINED)
                                             /* error if prs not found        */
         FlagsOf(pVar) |= (FVFUN | FVDECLDVAR | FVEVEREXPLICIT);
         FlagsOf(pVar) &= ~FVARRAY;
         }  /* if entry flag FVFUN is FALSE */
      if (vm_fVarFound)                      /* is this a second match in the */
         return(PRS_ER_RE | ER_DD);          /*    same chain? If so error    */
      /* now, note that we've found a match and save this oVar, but keep
         looking, in case there's another matching name, which would trigger
         the above error ...                                                  */
      vm_fVarFound = TRUE;
      vm_oVarCur = (char *)pVar - mrsCur.bdVar.pb;
      vm_pVarCur = pVar;
      }  /* while not at end of hash chain */
   return (FALSE);                           /* no errors                     */
   }  /* FuncSearch */

/***
*ModSharedChk() - check tPV for matches to a new module SHARED variable
*Purpose:
*  Check the tPV (of prsCur) for a match to a given (new) module SHARED
*  variable. If a match is found, redirect it, i.e., unlink the tPV entry
*  from its hash chain, set the FVREDIRECT flag in it, and place
*  the offset to the new module SHARED variable in its value field.
*
*  Note: This is now optimized based on the knowledge that it's ONLY used
*        used for FUNCTION declarations or definitions.
*  
*Entry:
*  vm_oVarTmp = offset into mrsCur.bdVar to a new module SHARED variable.
*  vm_fPVCur assumed to be TRUE
*  other inputs set up as for FuncSearch (above)
*Exit:
*  TRUE - no error.
*  FALSE - some error from FuncSearch, assumed to be a rude edit case
*           (so we can count on mrsCur.bdVar being tossed out).
*           In this event, the static variable 'errVal' will be contain the 
*           error return, and (non-RELEASE only) the mkVar.flags2 bit
*           MV_fTrashTable will be set.
*Exceptions:
*  none.
*******************************************************************************/
boolean ModSharedChk()
   {
   if (errVal = FuncSearch()) {
      return(FALSE);                /* some error found - quit looking        */
      }
   if (vm_fVarFound)
      ReDirect();
   return (TRUE);
   }  /* ModSharedChk */

/***
*GetDefaultType - given the logical 1st char of a var name,  get default oTyp
*Purpose:
*  Given the logical first char of a name, return the default oTyp of that name.
*  Note that 'logical first char' implies the third char of a name which starts
*  with 'FN' and the first char of any other name.
*Entry:
*  namChar
*Exit:
*  oTyp
*Exceptions:
*  none.
*
*******************************************************************************/
ushort NEAR GetDefaultType(namChar)
char namChar;
   {
   namChar &= 0xDF;   /* convert to upper case */
   DbAssert ((namChar == ('.' & 0xDF)) ||
             ((namChar >= 'A') && (namChar <= 'Z')));
   return(namChar == ('.' & 0xDF)) ? ET_R4 : (ushort)ps.tEtCur[(namChar) - 'A'];
   } /* GetDefaultType */


/***
*MakeVariable - Search for var, create if req'd, return offset to it
*Purpose:
*  Given a variable encountered by the parser or scanner, search for the
*  variable; if not found (and no error conditions detected), create the
*  variable in the tMV or the appropriate tPV and return an offset into
*  mrsCur.bdVar ('oVar') to the value field in the variable entry; this offset 
*  goes in the pcode stream.
*
*Entry:
*  mrsCur set up; it is assumed that bdVar is a heap owner.
*  prsCur either set up, or grs.oPrsCur is UNDEFINED if no procedure is
*     currently active
*  mkVar.oNam - global name table offset for the name of the input variable
*  mkVar.oTyp - global type table offset for the (perhaps assumed) type of the
*              input variable. In the case of an implicitly typed variable,
*              ET_IMP should be passed; in this instance, MakeVariable will 
*              determine the appropriate default type, based on the oNam.
*              In the case of a reference to a record element, the oTyp of the
*              record variable cannot be set by the caller; in this special 
*              case, mkVar.oTyp must be set to UNDEFINED by the caller.
*  mkVar.flags - global 2-bytes of bit flags used to describe the variable
*              encountered. One byte contains flags which are set in 
*              atypical situations, the other contains flags to be tested
*              in common situations.
*              Note that the FVIMPLICIT and FVFNNAME flags are not inputs,
*              however - - - these can be set or reset on input: MakeVariable
*              (now) sets these based on the oTyp and oNam fields (respectively)
*  mkVar.cDimensions - number of dimensions in an array variable; required
*              for correctly allocating the array descriptor, and setting
*              the dimension count for array variables. Only meaningful
*              when FVINDEXED is set, and FVFUNCTION is not (and the variable
*              name does not start with 'FN') (Note that FVINDEXED is 
*              considered to be set whenever FVFORCEARRAY is set).
*  mkVar.flags2 & MV_fONamInOTyp - set when the oType field is either ET_FS or
*	       ET_FT and the fsLength field is the oNam of a CONSTant
*	       which gives the length of the fixed length string/text.
*  mkVar.flags2 & MV_fDontCreate - set when MakeVariable is called JUST to 
*              search for an existing variable. Does not create a new variable 
*              if one is not found with this flag set. Non-RELEASE code checks 
*              that no other modification of the variable table takes place 
*              when this is TRUE.
*
*Exit:
*  The return value is an oVar if the high bit (bit 15) is clear, and
*  it's an error code if the high bit is set. 
*
*  If the high bit is not set (and retval is an oVar), if the input mkVar.oTyp 
*  was incorrectly assumed by the caller (i.e., implicitly typed), mkVar.oTyp
*  will contain the correct oTyp on exit. 
*
*  If the high bit is not set, if a CONSTant var entry was found, mkVar.flags2 
*  will have the MV_fConstFound bit set (always reset on exit otherwise).
*
*  If the high bit is set, the LSB is a scanner error code and the MSB
*  minus bit 15 is a parser action code.  The scanner error code is an
*  error which the user will see, whereas the parser action code is an
*  indication to the parser of what action it should take. The codes are 
*  listed below:
*
*  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
*  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
*  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
*  | E| P| P| P| P| P| P| P| S| S| S| S| S| S| S| S|
*  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
*
*  E - Error indicator (error if set)
*  P - Parser action code - bits set for different codes (includes bit 15 set):
*        PRS_ER_RE - Module Rude Edit
*        PRS_ER_RP - opReParse placed before statement
*  S - Scanner error code - decimal number in LSB (see basicmsg.doc)
*
*  If the return value is an error code, and the mkVar.flags2 MV_fTrashTable
*  bit is set, then the caller MUST take action to 'throw away' mrsCur.bdVar; 
*  this flag set on error return indicates that the table has been modified
*  somehow and cannot be used dependably. 
*  Note that this is a non-RELEASE flag; assertion code is used to ensure
*  that a rude edit error is returned whenever this flag is TRUE.
*
*  Note that ER_IER ('Internal Error') is used to signal the case where
*  the caller had the mkVar.flags2 MV_fDontCreate bit set on input and a 
*  matching entry was not found.
*
*  Note that an oVar (pVar) is not an offset (pointer) to the start (low word)
*  of the appropriate variable entry, rather it's an offset (pointer) to the
*  value field in the entry. Other fields are referenced from a pVar via 
*  negative offsets.
*  
*  On exit, the following input flag bits are reset to FALSE in mkVar.flags:
*     FVASCLAUSE, FVFNNAME, FVFORCEARRAY, FVFUNCTION, FVIMPLICIT,
*     FVINDEXED, FVLVAL, FVCONST 
*  On exit, the MV_fONamInOTyp and MV_fDontCreate bits are always reset in
*     in mkVar.flags2.
*Exceptions:
*  none.
*
*******************************************************************************/
ushort NEAR MakeVariable()
   {
   REG1 ushort flags;
   REG2 var *pVar;
   REG3 ushort retval;
   REG4 ushort createMask;
   REG5 ushort oHashCreate;
   REG6 ushort oNamPrs;
   REG7 ushort namChar;
   REG8 boolean fCreate;                     /* used to signal that we don't
                                                want to create input variable */
   REG9 ushort inputFlags = mkVar.flags;     /* save input mkVar.flags in case
                                                we must change them locally   */
   ushort mkVarONam;
   ushort mkVarOTyp;
   uchar mkVarCDims;
   boolean fTemp;

   DbAssert(grs.oMrsCur != UNDEFINED)
   DbChkGrs()                    /* sanity check on grs, mrsCur, and prsCur   */

   if (mkVar.flags2 & MV_fONamInOTyp) {
      mkVarONam = mkVar.oNam;
      mkVarOTyp = mkVar.oTyp;
      mkVarCDims = mkVar.cDimensions;
      /* mkVar.fsLength is really an oNam for a CONSTant. We must search local
         var table for this constant (tMV too if we're at proc level) and
         use it's value to set the input oTyp to the appropriate fixed length 
         string constant                                                      */
      DbChkoNam(mkVar.fsLength)
      mkVar.flags2 &= ~MV_fConstFound;
      mkVar.oNam = mkVar.fsLength;
      mkVar.flags = FVIMPLICIT;
      mkVar.oTyp = ET_I2;                    /* CONSTant MUST be an I2     */
      vm_fPVCur = (grs.oPrsCur != UNDEFINED);
      retval = StdSearch();
      if (!vm_fVarFound && !retval && !(vm_fPVCur = !vm_fPVCur))
         /* if we searched tPV and didn't find it, better be in tMV        */
         retval = StdSearch();
      /* restore input values of mkVar struct (must do this here so mkVar.flags
         is correct in case of error)                                         */
      mkVar.oNam = mkVarONam;
      mkVar.oTyp = mkVarOTyp;
      mkVar.flags = inputFlags;
      mkVar.cDimensions = mkVarCDims;
      if (retval || !vm_fVarFound || !(mkVar.flags2 & MV_fConstFound) ||
	  (OTypOf(vm_pVarCur) != ET_I2) || (ValueOf(vm_pVarCur, I2) <= 0)) {
               retval = PRS_ER_RP | MSG_InvConst;
               goto RetValExit;
               }
      mkVar.fsLength = ValueOf(vm_pVarCur, I2);
      }

   mkVar.flags &= ~(FVFNNAME | FVIMPLICIT);  /* Initialize the flags to FALSE */

   DbAssertIf(mkVar.flags & FVCONST, 
	       (mkVar.oTyp != ET_IMP))

   if ((mkVar.oTyp == ET_IMP) || 
         ((mkVar.oTyp == UNDEFINED) && !(mkVar.flags & FVASCLAUSE)))
      mkVar.flags |= FVIMPLICIT;             /* note that an 'UNDEFINED' oTyp
                                                could really be a fixed-length
                                                string of maximal (32K) length.
                                                The FVASCLAUSE bit removes this
                                                ambiguity                     */
   if ((namChar = GetVarNamChar(mkVar.oNam)) & 0xff00)
      mkVar.flags |= FVFNNAME;               /* get first logical char of name
                                                in low byte, & fFNnam in high */

   if (vm_fPVCur = (grs.oPrsCur != UNDEFINED)) {
      DbAssert(prsCur.oVarHash != UNDEFINED)
      DbAssert(prsCur.oVarHash < mrsCur.bdVar.cbLogical)
      if (mkVar.flags & FVCOMMON) {
         retval = PRS_ER_RP | MSG_InvProc;
         goto RetValExit;
         }
      oHashCreate = prsCur.oVarHash;
      /* The below is a speed optimization. oNamOfPrsCur is set by the rude 
         scanner to prevent searching the name table for the proc name for
         each variable reference in the procedure.  When we're called by the
         parser, oNamOfPrsCur will be UNDEFINED and we must do it here.       */
      if ((oNamPrs = oNamOfPrsCur) == UNDEFINED)
         oNamPrs = ONamOfOgNam(prsCur.ogNam);/* [4]                           */
      DbAssert(oNamPrs != 0)                 /* [4] ONamOfOgNam CAN'T ret. OM */
      }
   else {                                    /* no prs active                 */
      if (mkVar.flags & FVSTATIC) {
         retval = PRS_ER_RP | MSG_InvModLev;
         goto RetValExit;
         }
      oHashCreate = 
      oNamPrs = UNDEFINED;
      }

   flags = mkVar.flags;          /* put flags word in a register              */

   if ((flags & FVIMPLICIT) && (mkVar.oTyp != UNDEFINED)) 
         mkVar.oTyp = GetDefaultType((char)namChar);  /* set default type     */

   DbMkVarInp()                  /* special validation code for global inputs */

   /*======================================================================
      'createMask' is a mask used to pass to CreateVar - - - the code below
      depends on the fact that most of the variable entry flags correspond
      in position to the MakeVariable input flags ...                
   =======================================================================*/
   createMask = FVVALUESTORED |
                (flags & ~(FVREDIRECT | FVEVEREXPLICIT | FVDIM | FV_STATICSET));
   
   nm_mask = 0;                              /* initialize                    */
   vm_oVarCur = UNDEFINED;                   /* initialize                    */
   mkVar.flags2 &= ~MV_fConstFound;          /* initialize                    */

   if (!(flags & (FVFORMAL | FVCOMMON | FVSTATIC | FVSHARED | FVFNNAME |
                  FVFUNCTION | FVCONST))) {

      /*==== SEARCHING FOR VARIABLE IN THE TYPICAL CASE ====*/

      if (retval = StdSearch())
         goto RetValExit;                    /* return error code             */

      if (vm_fPVCur) {                       /* a procedure is active         */
         /*====================================================================
         Even though a procedure is active, we must search the tMV as well
         in one of three possible cases:
         1. A match was not found, and the name table entry indicates that
            there is a module shared variable of this oNam.
         2. A match was not found, and the current prs is for a DEF FN.
         3. We've found a retval in the currently active FUNCTION, but input
            FVLVAL is not set, i.e., we've got a case of self-recursion,
            and thus want to find the tMV FUNCTION reference rather than the
            tPV retval. Note that in this case, we KNOW we'll find a match
            in the tMV, as the reference is to the FUNCTION in prsCur.
         ====================================================================*/
         if ((!vm_fVarFound && 
              ((FlagOfONam(mkVar.oNam) & NM_fShared) ||
               (prsCur.procType == PT_DEFFN))) ||
             (vm_fVarFound && !(flags & FVLVAL) && 
              (FlagsOf(vm_pVarCur) & FVFUN) &&
              (mkVar.oNam == oNamPrs) && (prsCur.procType == PT_FUNCTION))) {
            vm_fPVCur = FALSE;               /* search the tMV                */
            if (retval = StdSearch())
               goto RetValExit;              /* return error code             */
            vm_fPVCur = TRUE;                /* reset                         */
            if (vm_fVarFound) {
	       pVar = vm_pVarCur;
	       /* [10] set temp boolean TRUE if there exists a module-level
		  [10] var of this name (not necessarily the var just found!  */
	       fTemp = FlagOfONam(mkVar.oNam) & NM_fShared;	/* [10]       */
	       if (fTemp && !(FlagsOf(pVar) & (FVFUN | FVCONST))) {   /* [10] */
		  if (!(FlagsOf(pVar) & FVSHARED))		      /* [10] */
		      vm_fVarFound = FALSE;  /* [10] not SHARED, so not found */
		  }						      /* [10] */
	       else if (!fTemp && (prsCur.procType != PT_DEFFN))      /* [10] */
		      vm_fVarFound = FALSE;  /* if not SHARED, then not found */
               else if ((FlagsOf(pVar) & FVFUN) && (flags & FVLVAL))
                  if ((mkVar.oNam == oNamPrs) && 
                      (prsCur.procType == PT_FUNCTION)) { 
                     /* not found after all - really want to create a retval  */
                     createMask |= (FVFUN | FVDECLDVAR | FVEVEREXPLICIT);
                     vm_fVarFound = FALSE;
                     }
                  else goto RE_DD_Exit;      /* attempt to assign to a Function
                                                outside of the Function       */
               }  /* if vm_fVarFound */
            }  /* if !vm_fVarFound && tNam entry fShared bit set */
         else if (vm_fVarFound && (FlagsOf(vm_pVarCur) & FVSHARED))
            vm_oVarCur = ValueOf(vm_pVarCur, oMV); 
                                             /* caller doesn't want oVar for 
                                                the SHARED entry in the tPV,
                                                he wants the actual tMV entry */
         }
      else                                   /* no procedure is active        */
         if ((flags & FVLVAL) && vm_fVarFound && (FlagsOf(vm_pVarCur) & FVFUN))
            goto RE_DD_Exit;                 /* attempt to assign to a Function
                                                outside of the Function       */
      if (!vm_fVarFound)
         if (retval = CreateVar(oHashCreate, createMask))
            goto RetValExit;                 /* return error code             */
      }  /* typical case - no special flags set */

   else {

      /*==== SEARCHING FOR SOME SPECIAL VAR (i.e., COMMON, STATIC, etc.) =====*/

      if (flags & (FVFUNCTION | FVFNNAME)) {
         if (flags & FVFUNCTION) {
            DbAssert(vm_fPVCur == FALSE)     /* [DECLARE] FUNCTION only legal
                                                at module level               */
            if (retval = FuncSearch())
               goto RetValExit;
            pVar = vm_pVarCur;
            if ((!vm_fVarFound) || (fConvtdToFun)) {
               if (!fConvtdToFun)         /* function entry doesn't exist yet */
                  if (retval = CreateVar(UNDEFINED, 
                        createMask | FVDECLDVAR | FVEVEREXPLICIT | FVSHARED))
                     goto RetValExit;     /* return error code */
               if ((NMSP_MASK & FlagOfONam(mkVar.oNam)) == NMSP_Variable) {
                  /* there exists at some non-FUNCTION variable(s) of this 
                     oNam somewhere in mrsCur.bdVar                           */
                  /* now set up inputs for each invocation of ModSharedChk    */
                  vm_fPVCur = TRUE; 
                  vm_oVarTmp = vm_oVarCur;
                  
                  errVal = 0;
                  ForEachPrsInMrs(ModSharedChk);
               
                  /* reset static variables */
                  vm_oVarCur = vm_oVarTmp;
                  vm_fPVCur = FALSE;
                  retval = errVal;

                  FlagsOf(vm_pVarCur) |= FVSHARED;
                  /* remember that an entry of this oNam is module shared: */
                  nm_mask |= NM_fShared;
   
                  if (retval)
                     goto RetValExit;  
                  ResetONamMaskTmp(mkVar.oNam,NMSP_Variable);
                                          /* txtmgr depends on us resetting 
                                             this bit in this case            */
                  }
               }
            }  /* if FVFUNCTION */

         else {                  /* must be FVFNNAME */
            if ((!vm_fPVCur) || (mkVar.oNam != oNamPrs))
               if (mkVar.flags & FVLVAL)
                  goto RE_DD_Exit;          
            if (retval = StdSearch())
               goto RetValExit;              /* return error code             */
            if (!vm_fVarFound) {
               if ((vm_fPVCur) && !(mkVar.flags & FVLVAL)) {
                  vm_fPVCur = FALSE;         /* search the tMV                */
                  if (retval = StdSearch())
                     goto RetValExit;        /* return error code             */
                  vm_fPVCur = TRUE;          /* reset                         */
                  }
               if (!vm_fVarFound)
                  if (retval = CreateVar(oHashCreate, createMask | FVFUN))
                     goto RetValExit;        /* return error code             */
               }
            }  /* if FVFNNAME */
         }  /* if FVFUNCTION, of FVFNNAME */

      else {                                 /* must be FORMAL, STATIC, 
                                                COMMON, SHARED, or CONST      */
         if (retval = StdSearch())
            goto RetValExit;                 /* return error code             */

         if (flags & (FVFORMAL | FVSTATIC | FVCONST)) {
            if (vm_fVarFound)
               goto RE_DD_Exit;              /* existing var matches formal,
                                                static, or const              */
            if (retval = CreateVar(oHashCreate, createMask))
               goto RetValExit;              /* return error code             */
            
            if ((flags & FVCONST) && !vm_fPVCur) {
               DbAssert(txdCur.scanState == SS_RUDE)  /* ensure no owners     */
               FlagsOf(vm_pVarCur) |= FVSHARED;

               /* remember that an entry of this oNam is module shared: */
               nm_mask |= NM_fShared;
               }
            }  /* if FVFORMAL, FVSTATIC, or FVCONST */

         else if (flags & FVCOMMON) {
            fCreate = TRUE;                  /* assume we want to create the
                                                variable if not found         */
            if (vm_fVarFound) {
               pVar = vm_pVarCur;
               if (FlagsOf(pVar) & FVARRAY) {
                  DbAssert(txdCur.scanState == SS_RUDE)  /* ensure no owners  */
                  FlagsOf(pVar) |= FVCOMMON; /* convert entry to be a COMMON  */
                  FlagsOf(pVar) &= ~FVVALUESTORED;
                  fCreate = FALSE;           /* don't want to create too ...  */
                  }
	       else			     /* not an array		      */
		  goto RE_DD_Exit;	     /* [14]			      */
               }  /* if found */
            
            if (fCreate)   
               if (retval = CreateVar(UNDEFINED, createMask))
                  goto RetValExit;     /* return error code */

            if (flags & FVSHARED) {
               DbAssert(txdCur.scanState == SS_RUDE)  /* ensure no owners     */
               FlagsOf(vm_pVarCur) |= FVSHARED;

               /* remember that an entry of this oNam is module shared: */
               nm_mask |= NM_fShared;
               }
            }  /* if FVCOMMON */

         else {                              /* must be FVSHARED              */
            DbAssert(flags & FVSHARED)
            /* NOTE: this case MUST be tested AFTER we check for FVCOMMON     */
            if (vm_fPVCur) {                 /* active procedure              */
               if (vm_fVarFound)
		  goto RE_DD_Exit;	     /* [14] in case found entry
						[14] contains an owner	      */
               else {                        /* var not found in the tPV      */
                  vm_fPVCur = FALSE;
                  if (retval = StdSearch())  /* search tMV                    */
                     goto RetValExit;
                  vm_fPVCur = TRUE;          /* reset                         */
                  if (!vm_fVarFound) {
                     if (retval = CreateVar(UNDEFINED, createMask & ~FVSHARED))
                        goto RetValExit;     /* create var a module level     */
                     }
                  FlagsOf(vm_pVarCur) |= FVSHARED; /* scanner needs this bit
                                                      set in module entry.
                                                      Namespace bit keeps
                                                      this case straight.     */
                  vm_oVarTmp = vm_oVarCur;   /* save offset to tMV entry      */
                  if (retval = CreateVar(prsCur.oVarHash, createMask))
                     goto RetValExit;        /* return error code             */
                  pVar = vm_pVarCur;
                  ValueOf(pVar, oMV) = 
                  vm_oVarCur = vm_oVarTmp;
                  }
               }
            else {                           /* no proc active - DIM SHARED   */
               if (!vm_fVarFound)
                  if (retval = CreateVar(UNDEFINED, createMask))
                     goto RetValExit;        /* return error code             */
               /* NOTE: the parser CAN call us here when we're not in SS_RUDE,
                  NOTE: but the txtmgr guarantees us that if a user enters
                  NOTE: or modifies a DIM SHARED statement, it will be a rude
                  NOTE: edit. I.e., we don't need to worry about any proc-level
                  NOTE: variables here, since the rude scanner scans the
                  NOTE: module before any of the procedures in the module     */
               FlagsOf(vm_pVarCur) |= FVSHARED;

               /* remember that an entry of this oNam is module shared: */
               nm_mask |= NM_fShared;
               }
            }  /* if FVSHARED */

         }  /* COMMON, SHARED */

      }  /* some special-case flag(s) is/are set */


   /* var was either explicitly or implicitly typed; set flag accordingly:    */
   if (!(flags & FVIMPLICIT))
      FlagsOf((var *)(mrsCur.bdVar.pb + vm_oVarCur)) |= FVEVEREXPLICIT;

   if (nm_mask != 0)
      SetONamMask(mkVar.oNam, nm_mask);      /* don't set name table flag bits
                                                until no chance of error      */

   DbChkoVar(vm_oVarCur)
   DbChkoTyp(mkVar.oTyp)
   DbMkVarExit(vm_oVarCur,vm_fVarFound,vm_fPVCur)

   /* Reset most of the input flags to their default values (FALSE) - - leave
      the rest as they were on entry                                          */
   mkVar.exitFlags = mkVar.flags;            /* NOTE: can remove exitFlags
                                                      when MakeVariable is
                                                      rewritten in native code*/
   mkVar.flags = inputFlags & ~(FVFNNAME | FVASCLAUSE | FVIMPLICIT | FVLVAL | 
		     FVFORCEARRAY | FVINDEXED | FVFUNCTION | FVCONST);
   mkVar.flags2 &= ~(MV_fONamInOTyp | MV_fDontCreate);

   return(vm_oVarCur);

RE_DD_Exit:
   retval = PRS_ER_RE | ER_DD;
RetValExit:
   DbMkVarExit(retval,vm_fVarFound,vm_fPVCur)
   /* Reset most of the input flags to their default values (FALSE) - - leave
      the rest as they were on entry                                          */
   mkVar.exitFlags = mkVar.flags;            /* NOTE: can remove exitFlags
                                                      when MakeVariable is
                                                      rewritten in native code*/
   mkVar.flags = inputFlags & ~(FVFNNAME | FVASCLAUSE | FVIMPLICIT | FVLVAL | 
		     FVFORCEARRAY | FVINDEXED | FVFUNCTION | FVCONST);
   mkVar.flags2 &= ~(MV_fONamInOTyp | MV_fDontCreate);

   return(retval);
   }  /* MakeVariable */


/*##############################################################################
#                                                                              #
#                 Call-back code, for when a variable table moves              #
#                                                                              #
##############################################################################*/
/***
*AdjustStatChain(pVarTable, oVar, cbAdjust)
*Purpose:
*  Adjust the back pointers to AD's and SD's in all static variables in
*  the current hash chain by cbAdjust bytes.
*  Note that this code is shared by AdjustMrsVarTable and AdjustPrsVarTable.
*
*Entry:
*  pVarTable is the base pointer for the variable table.
*  oVar is an offset into a variable table to the first var in a chain.
*  cbAdjust is an adjustment factor to be added to appropriate backpointers.
*
*Exit:
*  none.
*
*Exceptions:
*  none.
*
*******************************************************************************/
STATICF(VOID) AdjustStatChain(pVarTable, oVar, cbAdjust)
var *pVarTable;
REG2 ushort oVar;
ushort cbAdjust;
   {
   REG1 var *pVar;
   REG3 ushort flags;

   while (oVar != 0) {
      pVar = (var *)((char *)pVarTable + oVar);
      flags = FlagsOf(pVar);
      oVar = (OHashLinkOf(pVar) & 0xFFFE);

      if ((flags & FVFUN) || !(flags & FVVALUESTORED))
         continue;
      if (flags & FVARRAY) {
         if ((ValueOf(pVar, aryStat.aryDsc.fFeatures & FADF_SD)) &&
             (ValueOf(pVar, aryStat.aryDsc.pNext) != NOT_OWNER))
                  B_IAdUpd(&(ValueOf(pVar, aryStat.aryDsc)), cbAdjust);
         }
      else if ((OTypOf(pVar) == ET_SD) && (ValueOf(pVar,sdStr.pb) != NULL)) {
         B_ISdUpd(&(ValueOf(pVar, sdStr)), cbAdjust);
         }
      }  /* while */
   }  /* AdjustStatChain */

/***
*AdjustMrsVarTable(pVarTable, cbAdjust)
*
*Purpose:
*  Adjust the back pointers to AD's and SD's in all static variables in
*  the tMV by cbAdjust bytes.
*
*Entry:
*  pVarTable is the base pointer for the variable table.
*  cbAdjust is an adjustment factor to be added to appropriate backpointers.
*
*Exit:
*  none.
*
*Exceptions:
*  none.
*
*******************************************************************************/
VOID NEAR AdjustMrsVarTable(pVarTable, cbAdjust)
var *pVarTable;
ushort cbAdjust;
   {
   REG1 ushort iHash;
   REG2 ushort *pHash = (ushort *)pVarTable; /* tMV hash tbl @ start    */

   for (iHash = 0; iHash < CBINITMVHASH/2; iHash++)
      AdjustStatChain(pVarTable, *pHash++, cbAdjust);
   }  /* AdjustMrsVarTable */

/***
*AdjustPrsVarTable(pVarTable, oVarHash, cbAdjust)
*
*Purpose:
*  Adjust the back pointers to AD's and SD's in all static variables in
*  the given tPV by cbAdjust bytes.
*
*Entry:
*  pVarTable is the base pointer for the variable table.
*  oVarHash is the offset in the variable table to the tPV hash table.
*  cbAdjust is an adjustment factor to be added to appropriate backpointers.
*
*Exit:
*  none.
*
*Exceptions:
*  none.
*
*******************************************************************************/
VOID NEAR AdjustPrsVarTable(pVarTable, oVarHash, cbAdjust)
var *pVarTable;
ushort oVarHash;
ushort cbAdjust;
   {
   REG1 ushort iHash;
   REG2 ushort *pHash = (ushort *)((char *)pVarTable + oVarHash);
   
   if (oVarHash != UNDEFINED)
      for (iHash = 0; iHash < CBINITPVHASH/2; iHash++)
         AdjustStatChain(pVarTable, *pHash++, cbAdjust);
   }  /* AdjustPrsVarTable */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\qb\qbi0.asm ===
TITLE QBI0 - Segment Organization Declarations

;QBI assumes that the following segments are the only segments
;    within their respective groups.

LOADRTMGROUP	GROUP	LOADRTM ;Runtime Module's EXE Loader must be first!
LOADRTMGROUP	GROUP	FAR_PRESERVED ; also include far data that's preserved
				; across Make-Exe
LOADRTMENDGROUP GROUP	LOADRTMEND ;End of Resident EXE Loader - must be last
				;always resident segment.  RTM loader will
				;toss all code between LOADRTMEND and DGROUP
				;during a Compile Dialog.
CPGROUP		GROUP	CP	;parser, scanner, varmgr, txtmgr, nammgr
UIGROUP		GROUP	UI	;user interface
LISTGROUP	GROUP	LIST	;lister
DBGGROUP	GROUP	DBG	;debug code
ID_STRINGSGROUP	GROUP	ID_STRINGS
				;debug strings
RAREGROUP	GROUP	RARE	;seldom used (error, init, terminate)
CODEGROUP	GROUP	CODE	;runtime
_TEXTGROUP	GROUP	_TEXT	;executors, math

LOADRTM 	SEGMENT BYTE PUBLIC 'CODE'	;must be 1st segment
LOADRTM 	ENDS
FAR_PRESERVED 	SEGMENT BYTE PUBLIC 'CODE'	; must be between LOADRTM
FAR_PRESERVED 	ENDS				; and LOADRTMEND
LOADRTMEND 	SEGMENT PARA PUBLIC 'CODE'	;must be para aligned for loader
LOADRTMEND 	ENDS
CP		SEGMENT BYTE PUBLIC 'CODE'
CP		ENDS
DBG		SEGMENT	BYTE PUBLIC 'CODE'
DBG		ENDS
ID_STRINGS	SEGMENT	BYTE PUBLIC 'CODE'
ID_STRINGS	ENDS
UI		SEGMENT	BYTE PUBLIC 'CODE'
UI		ENDS
LIST		SEGMENT	BYTE PUBLIC 'LIST'
LIST		ENDS
RARE		SEGMENT	BYTE PUBLIC 'CODE'
RARE		ENDS
CODE		SEGMENT	BYTE PUBLIC 'CODE'
CODE		ENDS
_TEXT		SEGMENT	BYTE PUBLIC 'CODE'
_TEXT		ENDS
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\qbas\version.inc ===
;version.inc
include switch.inc
RELEASE         = ON
INCLUDE interp.inc
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\ir\varutil.asm ===
TITLE VarUtil.asm - Variable Management utilities in native code

;***
;VarUtil.asm - Variable Management utilities in native code
;
;	Copyright (C) 1986-1989, Microsoft Corporation
;
;Purpose:
;	Provide utility functions for the variable manager in native code
;
;
;*******************************************************************************

	.xlist
	include version.inc
	VarUtil_ASM = ON	;don't include EXTRNs defined in this file
	includeOnce	architec
	includeOnce	conint
	includeOnce	context
	includeOnce	executor
	includeOnce	heap
	includeOnce	names
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	scanner
	includeOnce	util
	includeOnce	variable
	.list

;	.sall

;These assertions are made because MakeVariable returns two sets of error
;codes on the assumptions that the ER_ and MSG_ messages it uses will all
;fit in a single byte.
.erre	255d GT MSG_COM
.erre	255d GT MSG_BadElemRef 		
.erre	255d GT MSG_UndElem
.erre	255d GT MSG_ASRqd1st

assumes DS,DATA
assumes ES,DATA
assumes SS,DATA
assumes CS,CP

sBegin	DATA
	globalW oValComMax,0		;Max oVal for all BLANK Common
					; declarations
	globalW oTypComMax,0		;Max oTyp for all BLANK Common
					; declarations

	staticW	oVarPrev,0		;oVar returned by last call to
					; FirstVar or NextVar (for NextVar)
	staticW	oVarTHash,UNDEFINED	;offset to start of appropriate
					; hash table          (for NextVar)
	staticW	iHashCur,0		;index in appropriate hash table to
					; current hash chain  (for NextVar)
	staticW	iHashMax,0		;max valid index hash index based
					; on current context  (for NextVar)
	;These two flags are used to share COMMON support code
	staticB	fResetCommon,FALSE	
	staticB	fCreateCommon,TRUE	;FALSE if we just want MakeCommon to
					;  FIND a COMMON block, not make one
	externW	pSsCOMcur		;used by AdjustCommon
	staticB fQlbCommon,0		; set if common in quicklibs

	externW	vm_fVarFound		;these are used by StdSearch
	externW	vm_fPVCur
	externW vm_pVarCur
	externW vm_oVarCur
	externW vm_oVarTmp
	staticW	oTypNew,0		;here instead of localW so StdSearch
					;  doesn't have to push a frame
	staticW	oVarShared,0		;here instead of localW so StdSearch
					;  doesn't have to push a frame
NMALLOC label	BYTE
	DB	"NMALLOC",0		;used by B$GetNMALLOC
	CB_NMALLOC EQU 7		;size of NMALLOC string

;	Create a public sd to NMALLOC for FindNMalloc to use.
	globalW sdNMALLOC,CB_NMALLOC	
	staticW ,<dataOFFSET NMALLOC>	
sEnd	DATA



	externFP B$ULGetCommon 	;finds user library common blocks
	externFP B$IRTCLR		; release all compiled AD's & SD's,
					; and zero QuickLib vars
	externFP B$IERASE		;QB-specific array ERASE routine
	externFP B$STDL 		;releases a given string (sd)

sBegin	CP

;##############################################################################
;#							  		      #
;#			 	Table Allocation       			      #
;#							  		      #
;##############################################################################

;***
;MakeMrsTVar() - Create module variable table & set up tMV hash table
;Purpose:
;	Allocates a buffer of size CBINITMVHASH, with mrsCur.bdVar as the owner.
;	Sets up the first CBINITMVHASH bytes as a hash table for the tMV; the
;	hash table entries are all initialized to 0.
;
;	Also allocates space for typmgr structures, i.e., information regarding
;	user-defined types and elements. This space is managed by the typmgr
;	component, which, like the varmgr, can grow the vartable and add type
;	and element structures and never needs to move or remove these 
;	structures.
;
;	The tMV hash table comes first, followed by CBINIT_TTYP bytes of table
;	overhead required by the typmgr. This overhead consistes of an offset
;	to the first TYP structure, and a count of TYP structures in the table
;	(both of these are initialized to zero).  VAR, TYP, and ELEM struct 
;	space is then allocated by the varmgr and typmgr as required.
;
;Entry:
;	mrsCur is set up; it is assumed that the bdVar field does NOT currently
;	contain a heap owner.
;
;Exit:
;	FALSE is returned if there is insufficient memory,
;	else table is successfully allocated.
;
;Exceptions:
;	none.
;
;******************************************************************************
cProc	MakeMrsTVar,<NEAR,PUBLIC,NODATA>
cBegin	MakeMrsTVar
	mov	bx,dataOFFSET mrsCur.MRS_bdVar
	DbChk	BdNotOwner,bx		;ensure that given bd isn't an owner now
	push	bx
	PUSHI	ax,CBINITMVHASH+CBINIT_TTYP
	PUSHI	ax,IT_VAR		;alloc a table large enough for tMV
	call	BdAllocVar		;  hash table plus typmgr requirements
	or	ax,ax
	jz	MakeMrsTVar_Exit	;brif allocation failed

	.erre	(CBINITMVHASH+CBINIT_TTYP) GT ET_MAX
					;ensure offset to first TYP struct
					;  is larger than biggest predefined
					;  oTyp value
	mov	ax,CBINITMVHASH+CBINIT_TTYP
	mov	[mrsCur.MRS_oPastLastVar],ax
					;initialize to same as cbLogical
	push	[mrsCur.MRS_bdVar.BD_pb] ;start of hash table
	push	ax			;CBINITMVHASH+CBINIT_TTYP
	call	ZeroFill		;initialize module-level hash table
					;  and typmgr data to zeroes
	mov	ax,sp			;non-zero == TRUE == success
MakeMrsTVar_Exit:
cEnd	MakeMrsTVar

;***
;MakePrsTVar - Put a procedure hash table into mrsCur.bdVar for prsCur
;Purpose:
;	To be called when a new prs is created, adds and initializes a hash
;	table of size CBINITPVHASH at the end of mrsCur.bdVar, placing the 
;	offset into bdVar to this hash table into prsCur in the oVarHash field.
;
;	NOTE: We only create a prs hash table for those prs's with text tables,
;	NOTE: plus DEF FN's (i.e., we DON'T create prs hash tables for 
;	NOTE: DECLARE's). This saves DGROUP space for user library DECLARE's. 
;
;Entry:
;	mrsCur is set up; it is assumed that bdVar is a heap owner.
;	prsCur is set up; its oVarHash field is assumed to contain garbage
;
;Exit:
;	FALSE is returned if there is insufficient memory,
;	else table is successfully allocated.
;
;Exceptions:
;	none.
;
;******************************************************************************
cProc	MakePrsTVar,<FAR,PUBLIC,NODATA>,<SI>	
cBegin	MakePrsTVar
	mov	bx,dataOFFSET mrsCur.MRS_bdVar
	DbChk	BdOwner,bx		;ensure that given bd is an owner

	.errnz	MRS_bdVar - MRS_bdVar.BD_cbLogical
	mov	si,[bx]
	
	DbAssertRel	grs.GRS_oPrsCur,nz,UNDEFINED,CP,<MakePrsTVar: err 1>
	DbAssertRel	prsCur.PRS_oVarHash,z,UNDEFINED,CP,<MakePrsTVar: err 2>

	xor	ax,ax			;in case of error return
	cmp	si,08000H - CBINITPVHASH
	jae	MakePrsTVar_Exit	;brif 32k limit on module var table
					;  exceeded

	push	bx			;pointer to mrsCur.MRS_bdVar
	PUSHI	ax,CBINITPVHASH
	call	BdGrowVar		;allocate space for proc. hash table
	or	ax,ax
	je	MakePrsTVar_Exit	;brif error return

	mov	[prsCur.PRS_oVarHash],si ;input cbLogical, i.e., offset to start
					 ;  of procedure hash table
	add	si,[mrsCur.MRS_bdVar.BD_pb]
	push	si
	PUSHI	ax,CBINITPVHASH
	call	ZeroFill
	mov	ax,sp			;non-zero == TRUE, i.e., success
MakePrsTVar_Exit:
cEnd	MakePrsTVar

;***
;FirstVar - return the pVar and oVar of the first var in the current table
;Purpose:
;	This routine is used in conjunction with NextVar (below). It 
;	returns the oVar and pVar to the first variable in the current
;	tPV or tMV, and sets up some static variables for subsequent calls
;	to NextVar.
;
;Input:
;	none.
;Ouptut:
;	if AX = 0, no (more) variables in current table
;	else AX = oVar, BX = pVar.
;Modifies:
;	none
;***************************************************************************
	PUBLIC FirstVar
FirstVar	PROC NEAR
	mov	[iHashMax],CBINITMVHASH	;assume no procedure active
	xor	ax,ax			;assume no procedure active
	cmp	[grs.GRS_oPrsCur],UNDEFINED
	jz	No_Prs_Active

	mov	ax,[prsCur.PRS_oVarHash]
	mov	[iHashMax],CBINITPVHASH
	
No_Prs_Active:
	mov	[oVarTHash],ax		;module hash table starts at offset 0
	mov	[iHashCur],-2		;so shared code will inc to 0
	mov	dx,[mrsCur.MRS_bdVar.BD_pb]
	jmp	short End_Of_Hash_Chain	;share code with NextVar, below
FirstVar	ENDP

;***
;NextVar - return the pVar and oVar of the next var in the current table
;Purpose:
;	This routine is called repetitively to access each variable in
;	the current procedure or module variable table (tPV or tMV).
;
;	Note: This code is written to account for the fact that heap 
;		movement can occur between calls.
;Input:
;	none.
;Ouptut:
;	if AX = 0, no (more) variables in current table
;	else AX = oVar, BX = pVar.
;Modifies:
;	none
;***************************************************************************
	PUBLIC NextVar
NextVar	PROC NEAR
	DbChk	ConStatStructs		;static structs must be active
	mov	dx,[mrsCur.MRS_bdVar.BD_pb]
NextVar_Clear:
	mov	bx,[oVarPrev]
	DbAssertRel bx,nz,0,CP,<NextVar called w/o FirstVar call first>
	add	bx,dx			;bx = pVarPrev
	mov	ax,[bx.VAR_oHashLink]	;ax = oVarNext
	and	ax,0FFFEH		;mask off low bit
	jz	End_Of_Hash_Chain	;brif end of this hash chain

	mov	bx,ax
NextVar_Exit:
	add	bx,dx			;ax = oVar, bx = pVar
	mov	[oVarPrev],ax		;update static
	ret

End_Of_Hash_Chain:			; callable entry point
					; preserves dx, es
	;Search the hash table for the start of the next non-empty chain
	mov	cx,[iHashCur]
	mov	ax,[oVarTHash]
	add	ax,dx			;ax points to base of hash table
TryNextChain:
	mov	bx,ax
	inc	cx
	inc	cx			;increment index
	cmp	cx,[iHashMax]		;have we checked all chains?
	jz	Next_Var_Done		; brif so - - 

	DbAssertRel cx,b,iHashMax,CP,<NextVar - iHashCur or iHashMax hosed>
	add	bx,cx			;bx points to start of next hash chain
	mov	bx,[bx]			;bx = oVar for first var in chain or
					;  0 if chain is empty
	or	bx,bx	
	jz	TryNextChain		;current chain is empty - try the next

	mov	[iHashCur],cx
	mov	ax,bx			;ax = bx = oVar
	jmp	short NextVar_Exit

	
	ret
Next_Var_Done:
	xor	ax,ax
	ret
NextVar	ENDP

;***
;ClearPV, ClearMV - CLEAR all variables in the given procedure
;
;ClearPV:
;	Purpose:
;		Called via ForEachPrsInPlaceCPSav.
;		CLEAR all static variables in the tPV for the given prs.
;	Entry:
;		SI = pPrs to be cleared (which is NOT prsCur - - - it's in 
;		the table).
;ClearMV:
;	Purpose:
;		Called via ForEachCP
;		CLEAR all static variables in the tMV for mrsCur
;	Entry:
;		none.
;
;Exit:
;	AX != 0 (needed for ForEachCP)
;******************************************************************************
cProc	ClearMV,<NEAR,PUBLIC,NODATA>,<di> 
	localW	oMrsCur
cBegin	
	mov	[iHashMax],CBINITMVHASH
	xor	cx,cx
	jmp	short ClearPVorMV	;jump into ClearPV; share exit
cEnd	<nogen>

cProc	ClearPV,<NEAR,PUBLIC,NODATA>,<di> 
	localW	oMrsCur
cBegin	ClearPV
	GETRS_SEG es			
	mov	cx,PTRRS[si.PRS_oVarHash]   
	inc	cx
	.errnz	UNDEFINED - 0FFFFH
	jz	ClearPV_Exit		;brif no hash table for this prs

	dec	cx
	mov	[iHashMax],CBINITPVHASH

	mov	ax,PTRRS[si.PRS_oMrs]	
	mov	[oMrsCur],ax		;save for use by CbTypOTypOMrs
	mov	bx,ax
	RS_BASE add,ax			; ax = pMrs of given prs
	GETRS_SEG es			
	mov	di,sp			; assume prs not in current mrs
	cmp	bx,[grs.GRS_oMrsCur]	;prs in current mrs?
	jnz	Clear_GotPMrs		;  brif not

ClearPVorMV:
	mov	dx,[grs.GRS_oMrsCur]
	mov	[oMrsCur],dx		;save for use by CbTypOTypOMrs
	mov	ax,dataOFFSET mrsCur
	SETSEG_EQ_SS es 		; es = ss if far Rs tables
	sub	di,di			; remember to refresh es == ss
					; after any calls that hose es
Clear_GotPMrs:
	push	si			;preserve for caller
	xchg	ax,si
	mov	[oVarTHash],cx		;module hash table starts at offset 0
	mov	[iHashCur],-2		;so shared code will inc to 0
	mov	dx,PTRRS[si.MRS_bdVar.BD_pb] ;dx points to base of var table
	DbAssertRel dx,nz,0,CP,<ClearMV/ClearPV: no var table in mrsCur (NULL)>
	DbAssertRel dx,nz,UNDEFINED,CP,<ClearMV/ClearPV: no var table in mrsCur>
	call	End_Of_Hash_Chain	;get first var, ax, = oVar, bx = pVar

Clear_Table_Loop:
	SETSEG_EQ_SS es 		; assume we want to refresh es == ss
	or	di,di			; is that assumption correct?
	jz	Clear_Table_Got_Es	;   brif so

	GETRS_SEG es			
Clear_Table_Got_Es:
	or	ax,ax
	jz	Clear_Table_Exit	;brif no more vars in table

	mov	ax,[bx.VAR_flags]	;cache for multiple tests below
	test	al,FVFUN
	jnz	Clear_Table_Next	;brif Function or Def FN entry

	test	ah,FVVALUESTORED SHR 8
	jz	Clear_Table_Next	;brif value not stored in entry

	test	ah,FVCONST SHR 8
	jz	Clear_Table_Cont	;brif not a CONST

	test	BPTRRS[si.MRS_flags],FM_VARNEW	
	jz	Clear_Table_Next	;brif we're not discarding this var 
					;  table (don't clear CONST values)
Clear_Table_Cont:
	test	ah,FVARRAY SHR 8
	jz	Clear_Not_Array		;brif not an array entry

	test	BPTRRS[si.MRS_flags],FM_VARNEW	
	jz	@F			;brif we're not discarding var table
	and	[bx.VAR_value.ASTAT_ad.AD_fFeatures],NOT FADF_STATIC
					;tell runtime to deallocate this
					;array, not just erase it 
@@:
	lea	ax,[bx.VAR_value.ASTAT_ad]
	push	dx			; save across call
	DbHeapMoveOff			;assert no heap movement here
	cCall	B$IErase,<ax>		;erase the array
	DbHeapMoveOn
	pop	dx			
	jmp	short Clear_Table_Next

ClearPV_Exit:
	jmp	short Clear_Exit

Clear_Not_Array:
	lea	cx,[bx.VAR_value]
	GetOtyp	ax,[bx]			;ax = oTyp for this variable

	cmp	ax,ET_SD
	jnz	Clear_Not_SD		;brif not clearing an SD

	push	ax			;preserve across call
	push	cx			; preserve across call
	push	dx			; preserve across call
	cCall	B$STDL,<cx>		;release the SD
	pop	dx			
	pop	cx			
	pop	ax
Clear_Not_SD:
	push	bx			; save pVar
	mov	bx,[oMrsCur]		;in case we're clearing a prs in some
					;  module other than mrsCur
	call	CbTypOTypOMrs		; returns ax = cb for given type
	pop	bx			; restore pVar
	jnz	Clear_ZeroFill		

	; fixed-length string - - - get count of bytes to fill from var entry
	mov	ax,[bx.VAR_cbFixed]	
Clear_ZeroFill:
	push	dx			; preserve across call
	cCall	ZeroFill,<cx,ax>	
	pop	dx			
Clear_Table_Next:
	call	NextVar_Clear		;ax = oVar or UNDEFINED, bx = pVar
	jmp	Clear_Table_Loop
	
Clear_Table_Exit:
	pop	si
Clear_Exit:
	or	ax,sp			;non-zero exit, per interface
cEnd	ClearPV

;***
;CbTyp(oTyp) - Return the size of a value of given type
;Purpose:
;	This routine returns the number of bytes of data required for
;	the input type. Note that this will work for both predefined and
;	user-defined types.
;Input:
;	oTyp
;Output:
;	ax = cbTyp - i.e., the size of a value of the given type.
;Modifies:
;	none
;***************************************************************************
cProc	CbTyp,<NEAR,PUBLIC,NODATA>
	parmW	oTyp
cBegin	CbTyp
	mov	ax,[oTyp]
	call	CbTypOTyp		;returns with result in AX
cEnd	CbTyp

;***
;CbTypOTyp, CbTypOTypOMrs
;Purpose:
;	This routine returns the number of bytes of data required for
;	the input type. Note that this is called directly from the scanner
;	use CbTyp (above) for a C interface to this routine.
;
;	CbTypOTyp assumes that if the oTyp is a user-defined type, it is
;			an offset into mrsCur.MRS_bdVar.
;	CbTypOTypOMrs uses the MRS_bdVar table in the mrs whose oMrs is
;			given in bx.
;Input:
;	ax = oTyp
;	for CbTypOTypOMrs, bx = oMrs of type table
;Output:
;	ax = cbTyp
;	for input oTyp of ET_FS, ax = zero.
;	PSW flags set based on an OR AX,AX on exit
;Prserves:
;	all (even bx)
;***************************************************************************
;The CbTyp code below was significantly reworked throughout for revision [9]
mpCbTyp label byte
	DB	0		;ET_IMP hole
	.errnz	ET_IMP - 0
	DB	2		;ET_I2
	.errnz	ET_I2  - 1
	DB	4		;ET_I4
	.errnz	ET_I4  - 2
	DB	4		;ET_R4
	.errnz	ET_R4  - 3
	DB	8		;ET_R8
	.errnz	ET_R8  - 4
	DB	SIZE SD 	;ET_SD
	DB	0		;ET_FS - - - can't tell size from ET_ type

	.errnz	ET_SD - 5
	.errnz	ET_FS - 6

	.errnz	ET_MAX - ET_FS	;Ensure this is found if someone adds a type.

	PUBLIC	CbTypOTypOMrs
	PUBLIC	CbTypOTyp
CbTypOTypOMrs	PROC	NEAR
	push	bx
	jmp	short CbTypOTyp_Cont
CbTypOTyp:
	push	bx
	mov	bx,[grs.GRS_oMrsCur]	
	DbChk	oTyp,ax 		;sanity check on input oTyp
CbTypOTyp_Cont:
	cmp	ax,ET_MAX		;Is it a fundamental type?
	ja	NotPredefinedType	;  brif not - user defined

	mov	bx,offset mpCbTyp	;base of lookup table in CS
	xlat	byte ptr cs:[bx]	;al == desired size
	pop	bx
	or	ax,ax			;set PSW flags
	ret

NotPredefinedType:
	test	[conFlags],F_CON_StaticStructs
	jz	Mrs_In_Table		;brif mrsCur not set up

	cmp	bx,[grs.GRS_oMrsCur]
	jz	Want_MrsCur		;brif passed oMrs is for mrsCur

Mrs_In_Table:
	RS_BASE add,bx			; bx points into Rs table
	GETRS_SEG es			
	jmp	short Got_pMrs

Want_MrsCur:				;ax is an offset into type table
	lea	bx,mrsCur		;  found in the current mrs
	SETSEG_EQ_SS es 		
Got_pMrs:
	add	ax,PTRRS[bx.MRS_bdVar.BD_pb] ;[2] ax = pTyp
	xchg	bx,ax			;bx = oTyp, ax = garbage
	mov	ax,[bx].TYP_cbData	;ax = cbData from type table entry
	pop	bx
	or	ax,ax			;set PSW flags
	ret
CbTypOTypOMrs	ENDP


;***
;StdSearch() - search the appropriate hash table with standard algorithm
;Purpose:
;	Search the appropriate table (tPV or tMV) in the typical case.
;Entry:
;	vm_fPVCur - module static flag, TRUE if we're to search tPV, FALSE if 
;			tMV.
;	mrsCur.bdVar assumed set up, and if vm_fPVCur is TRUE, prsCur is 
;		assumed	to be set up, and the oVarHash field is either 
;		UNDEFINED (in which case we just return), or contains an 
;		offset into mrsCur.bdVar to the tPV hash table.
;	mkVar set up as per MakeVariable (below).
;Exit:
;	FALSE = no error
;	otherwise, the same error code is returned as described for MakeVariable
;
;	If no error is returned, then the static vm_fVarFound indicates 
;		success or failure. 
;	If vm_fVarFound == TRUE, vm_oVarCur is set to the offset into 
;		mrsCur.bdVar to the found variable entry, and vm_pVarCur 
;		points to the entry.
;Exceptions:
;	none.
;******************************************************************************
	PUBLIC	StdSearch
StdSearch	PROC	NEAR
	mov	[vm_fVarFound],FALSE		;initialize
	mov	bx,[mkVar.MKVAR_oNam]
	and	bx,HASH_MV_NAMMASK
	.errnz	(HASH_MV_NAMMASK AND HASH_PV_NAMMASK) - HASH_PV_NAMMASK
	cmp	[vm_fPVCur],FALSE
	jz	StdSearch_Cont1			;brif no prs active

	and	bx,HASH_PV_NAMMASK
	add	bx,[prsCur.PRS_oVarHash]
StdSearch_Cont1:
	push	si
	mov	si,[mrsCur.MRS_bdVar.BD_pb]	;ptr to base of var table
	mov	ax,[bx][si]
	or	ax,ax				;empty hash chain?
	jz	StdSearch_Exit_2		;brif so; ax already 0 for retvl

	push	di
	mov	di,ax
	mov	WORD PTR [oTypNew],UNDEFINED	;if something else on exit and
						;  search succeeded, set
						;  mkVar.MKVAR_oTyp to oTypNew
	add	di,si
	mov	cx,[mkVar.MKVAR_oNam]
StdSearch_Loop:
	cmp	si,di				;end of hash chain?
	je	False_Exit			;  brif so

	cmp	[di.VAR_oNam],cx
	je	Got_oNam			;brif oNam's match
Next_Var_Entry1:
	mov	di,[di.VAR_oHashLink]		;offset to next entry in chain
	and	di,0FFFEH			;mask off low bit
	add	di,si				;offset ==> pointer
	jmp	short StdSearch_Loop

StdSearch_Exit_2:
	jmp	StdSearch_Exit_1		;ax already 0 for retval

False_Exit:
	sub	ax,ax
	jmp	StdSearch_Exit

Shared_Or_Const:
	TESTX	cx,<FVSTATIC OR FVFORMAL OR FVCONST>	
	jnz	StdSearch_DD_Err		; Duplicate definition
	jmp	short StdSearch_Cont2

Got_oNam:
	;register usage:
	;	BX = oTyp  for current entry
	;	CX = di.VAR_flags 	i.e., flags for current entry
	;	DX = mkVar.MKVAR_flags	i.e., flags from input
	
	mov	dx,[mkVar.MKVAR_flags]
	mov	cx,[di.VAR_flags]
	TESTX	dx,<FVSHARED OR FVCONST>	
	jnz	Shared_Or_Const			;brif input is nmodule shared

StdSearch_Cont2:
	GetOtyp	bx,[di]				;bx = oTyp for this variable
	mov	ax,[mkVar.MKVAR_oTyp]
	cmp	bx,ax				;do types match?
	jnz	StdSearch_Cont2a		; brif not

	cmp	ax,ET_FS			
	jnz	StdSearch_Cont3a		; brif not fixed-length string

	push	ax				
	mov	ax,[di.VAR_cbFixed]		
	cmp	ax,[mkVar.MKVAR_fsLength]	
	pop	ax
	jz	StdSearch_Cont3a		; branch if lengths match

StdSearch_Cont2a:
	TESTX	dx,FVASCLAUSE			
	jnz	StdSearch_DD_Err		; brif input AS bit set

	TESTX	cx,<FVDECLDVAR OR FVCONST>	
	jnz	Has_Name_Space			;brif CONST or declared in an
						;  AS clause or FUNCTION name
	TESTX	dx,FVCONST			
	jnz	RP_DD_Err
	jmp	short Next_Var_Entry		;types don't match


StdSearch_DD_Err:
	mov	ax,PRS_ER_RE OR ER_DD
StdSearch_Err_Exit:
	jmp	StdSearch_Exit

StdSearch_Cont3a:
	TESTX	dx,FVASCLAUSE			
	jz	StdSearch_Cont3 		; brif not AS clause

	TESTX	cx,<FVFUN OR FVCONST>		; brif entry flags have a bit
	jne	StdSearch_DD_Err		;  inconsistent w/AS clause

	mov	ax,PRS_ER_RE OR MSG_ASRqd1st	;assume AS clause NOT in 1st ref
	TESTX	cx,FVDECLDVAR			
	jz	StdSearch_Err_Exit		;brif error
	jmp	short OTyp_Matches

Has_Name_Space:
	TESTX	dx,FVIMPLICIT			
	jnz	Has_Name_Space_1		;brif input implicity typed

	cmp	ax,ET_SD			;is input oTyp ET_SD?
	jnz	RP_DD_Err			;brif not - error

	cmp	bx,ET_FS			;is entry oTyp a Fixed Length
	jnz	RP_DD_Err			;  string? brif not - error
Has_Name_Space_1:
	inc	ax
	.errnz	UNDEFINED - 0FFFFH
	jnz	Has_Name_Space_3		;brif input oTyp != UNDEFINED

	cmp	bx,ET_MAX
	ja	Has_Name_Space_2		;brif entry type not predefined

	TESTX	cx,FVCONST			
	jz	RP_DD_Err			;brif entry not a CONST - error
Has_Name_Space_2:
	cmp	bx,ET_FS			
	jnz	Has_Name_Space_3		; brif entry oTyp not F.L. String
RP_DD_Err:
	mov	ax,PRS_ER_RP OR ER_DD
	jmp	StdSearch_Exit

Owns_Name_Space:
	TESTX	dx,<FVCOMMON OR FVSHARED OR FVDIM OR FVSTATIC>	
	jz	OTyp_Matches

	test	cl,FVFUN
	jnz	StdSearch_DD_Err

	test	dl,FVSTATIC
	jnz	StdSearch_DD_Err

	test	dl,FVCOMMON
	jz	AS_Rqd_Error

	TESTX	cx,FVARRAY			
	jz	StdSearch_DD_Err
AS_Rqd_Error:
	mov	ax,PRS_ER_RE OR MSG_ASRqd
	jmp	StdSearch_Exit
Has_Name_Space_3:
	mov	[oTypNew],bx			;give actual type back to user

StdSearch_Cont3:
	TESTX	cx,FVDECLDVAR			
	jnz	Owns_Name_Space			;brif entry owns name space

;At this point, we know that the oNam and oTyp matches - - - now check flags
OTyp_Matches:
	TESTX	dx,FVFORCEARRAY			
	jnz	Inp_Definite_Array		;brif input is a definite array

StdSearch_Cont4:
	TESTX	dx,FVINDEXED			
	jz	Not_Indexed			;brif input var not indexed

	TESTX	cx,<FVARRAY OR FVFUN>		
	jnz	StdSearch_Cont5

Next_Var_Entry:
	mov	cx,[mkVar.MKVAR_oNam]		;ditto
	jmp	Next_Var_Entry1

Inp_Definite_Array:
	or	dx,FVINDEXED
	mov	[mkVar.MKVAR_flags],dx		;ensure FVINDEXED flag is set

	TESTX	cx,FVFUN			; is entry a FUNCTION?
	jnz	StdSearch_DD_Err1		;brif so - error

	TESTX	cx,FVARRAY			; is entry an array?
	jz	Next_Var_Entry
;[J1]	Check if current entry is VALUESTORED
;[J1]		if NOT VALUE STRORED then it is either a $DYNAMIC or an Auto
;[J1]			array in which case adding a DIM is okay.
;[J1]		if VALUESTORED that means that space for the var has already
;[J1]			been allocated and another check must be made to see
;[J1]			if it is a STATIC or DYNAMIC.
;[J1]	NOTE:  We must perform the this test first before we make the
;[J1]	       next check that tests if current entry is a static array
;[J1]	       because it is not valid if not FVVALUESTORED.
	TESTX	cx,FVVALUESTORED		;[J1] Is there an array desc.?
	jz	StdSearch_Cont5			;[J1] brif no array desc.

;[J1]	There is an array descriptor present so now we have to see if it is
;[J1]	static or dynamic.  If it static then we have to make sure that this
;[J1]	is not a DIM because then this would be a double definition.  If
;[J1]	dynamic then multiple DIMs are okay.
	test	BYTE PTR [di.VAR_value.ASTAT_ad.AD_fFeatures],FADF_STATIC
	jnz	Check_For_Dim_Err		;[J1] Check if this is a DIM
	jmp	short StdSearch_Cont5		;[J1] accept it.

StdSearch_DD_Err1:
	jmp	StdSearch_DD_Err

RP_DD_Err1:
	jmp	RP_DD_Err

Not_Indexed:
	TESTX	dx,FVFORCEARRAY			; is input a definite array?
	jnz	Check_For_Dim_Err		;  brif so

	TESTX	cx,FVARRAY			; is entry an array?
	jnz	Next_Var_Entry			;  brif so - no match

Check_For_Dim_Err:
	TESTX	dx,FVDIM			; input found in a DIM 
						;   statement?
	jnz	StdSearch_DD_Err1		;  brif so - DD error

StdSearch_Cont5:
	TESTX	cx,FVCONST			; is entry a CONST?
	jnz	Entry_Is_Const			;  brif so

	;now ensure that a proc ref. doesn't match a retval:
	cmp	[vm_fPVCur],FALSE
	jz	StdSearch_Cont6			;brif no prs active

	TESTX	cx,FVFUN			; is entry a FUNCTION or 
						;  DEF FN?
	jz	StdSearch_Cont6			;brif not

	TESTX	dx,FVLVAL			; input seen on left side 
						;  of eq.?
	jnz	StdSearch_Cont6			;brif so - - this is a retval
	jmp	Next_Var_Entry			;don't allow a ref. to match
						;  a retval
StdSearch_Cont6:
	TESTX	cx,FVARRAY			; is entry an array?
	jnz	StdSearch_Array_Checks		;brif so
	jmp	StdSearch_Cont7

Entry_Is_Const:
	FVTEMP EQU FVCOMMON OR FVSTATIC OR FVSHARED OR FVFORMAL OR FVFNNAME
						;shorthand, so all will fit on
						;  on line!
	TESTX	dx,<FVTEMP OR FVFUNCTION OR FVLVAL OR FVDIM OR FVASCLAUSE> 
	jnz	RP_DD_Err1			;brif any of the above flags set

	or	[mkVar.MKVAR_flags2],MV_fConstFound
						;remember we've seen a CONST
	jmp	short StdSearch_Cont6

StdSearch_Array_Checks:
	;ensure the existing array entry was built assuming at least as many
	;dimensions as actually exist. In addition, consider that we might
	;have found a module shared entry here, in which case we must make our
	;checks with the actual module level entry

	;new register use: bx = pVarEntry, i.e., ptr to the actual array entry
	;                  cx is updated if bx changes
	;                  dx = 0 if bx doesn't change, oVar of SHARED entry
	;                         if so

	xor	dx,dx				;assume pVar is correct (flag)
	mov	bx,di				;assume pVar is correct (pVar)
	cmp	[vm_fPVCur],FALSE
	jz	Not_PVCur			;brif procedure not active

	TESTX	cx,FVSHARED			; is this a SHARED entry?
	jz	Not_PVCur			;  brif not

	mov	dx,di
	sub	dx,si				;dx = oVar of proc. SHARED entry
	mov	bx,[di.VAR_value]		;ax = oVar
	add	bx,si				;ax = pVar of module entry
	mov	cx,[bx.VAR_flags]		;update for this entry	
Not_PVCur:
	mov	[oVarShared],dx			;0 in typical case
	mov	al,[bx.VAR_value.ASTAT_cDims]
	mov	ah,[mkVar.MKVAR_cDimensions]
	cmp	ah,al
	jz	StdSearch_Cont7a1		;brif entry cDims matches input

	or	ah,ah
	jz	StdSearch_Cont7a1		;brif input cDims == 0 (i.e.,
						;  if we don't want to change
						;  existing entry)
	TESTX	cx,FVVALUESTORED		; is entry a static variable?
	jz	StdSearch_Cont7a1		;  brif not - - no problem,
						;  var entry size is okay
	or	al,al				;entry cDims == 0?
	jnz	Wrong_Num_Subscripts		;  brif not - - - error

	cmp	ah,1				;input cDims == 1?
	jnz	Check_Var_Size			;  brif not

	mov	BYTE PTR [bx.VAR_value.ASTAT_cDims],1
						;already enough space, just
						;update cDims in var entry
StdSearch_Cont7a1:
	jmp	StdSearch_Cont7a
Check_Var_Size:
	test	cl,FVSTATIC			;was var declared STATIC?
	jz	Redirect_Array_Var		;  brif not

	cmp	ah,8
	jbe	Redirect_Array_Var		;brif okay - redirect entry to
						;  one that's big enough for
						;  new cDims count
Wrong_Num_Subscripts:
	mov	ax,PRS_ER_RE OR MSG_SubCnt	;'Wrong number of subscripts'
	jmp	StdSearch_Exit

Redirect_Array_Var:
	and	[bx.VAR_value.ASTAT_ad.AD_fFeatures],NOT FADF_STATIC
						;so B$IErase will deallocate

	mov	ax,bx
	sub	ax,si
	push	ax				;save oVar across call

	push	cx				;save entry flags across call	

	add	bx,VAR_value.ASTAT_ad		;bx points to array descriptor
	push	bx
	call	B$IERASE			;deallocate existing array

	pop	cx				;restore entry flags

	;Now create the new larger entry
	mov	ax,UNDEFINED			;assume module level
	cmp	[oVarShared],0			;special case of SHARED in prs?
	jnz	Create_The_Var			;  brif so

	cmp	[vm_fPVCur],FALSE		;procedure active?
	jz	Create_The_Var			;  brif not

	mov	ax,[prsCur.PRS_oVarHash]
Create_The_Var:
	push	[mkVar.MKVAR_oTyp]		;preserve in case of error
	mov	dx,[oTypNew]
	inc	dx
	.errnz	UNDEFINED - 0FFFFH
	jz	Create_The_Var1			;brif oTyp not changed

	dec	dx
	mov	[mkVar.MKVAR_oTyp],dx		;in case entry oTyp different
						;  from assumed one
Create_The_Var1:
	push	ax				;oVarHash
	push	cx				;entry flags
	call	CreateVar			;create larger array var entry
	pop	[mkVar.MKVAR_oTyp]		;restore in case of error
	pop	bx				;oVar saved from before erase
	or	ax,ax
	jnz	StdSearch_Exit			;brif some error

	mov	ax,[vm_oVarCur]
	mov	[vm_oVarTmp],ax			;oVar for new entry

	mov	[vm_oVarCur],bx			;existing entry
	push	[vm_fPVCur]
	cmp	[oVarShared],0			;found proc. shared entry, but
						;  need to ReDirect the module
						;  entry it points to?
	jz	Redirect_The_Var		;brif not

	mov	[vm_fPVCur],FALSE		;reference tMV if so
Redirect_The_Var:
	call	ReDirect			;redirect old entry
	pop	[vm_fPVCur]			;restore to entry value

	mov	si,[mrsCur.MRS_bdVar.BD_pb]	;in case of heap movement

	mov	bx,[vm_oVarTmp]			;oVar of newly created entry
	mov	di,[oVarShared]
	or	di,di
	jz	Get_oVarEntry			;brif typical case
	;di contains the oVar for the proc. SHARED entry we were searching for
	;  replace the value field in this entry with the oVar of the new
	;  entry and continue
	add	di,si				;pVar = proc SHARED entry
	mov	[di.VAR_value],bx		;replace oVar in SHARED entry
						;  with new value (old entry
						;  got ReDirected)
	add	bx,si				;pVarDims = new entry
	jmp	short Got_oVarEntry
Get_oVarEntry:
	add	bx,si				;pVarDims = new entry
	mov	di,bx				;pVar = new entry
Got_oVarEntry:

StdSearch_Cont7a:
	mov	al,[mkVar.MKVAR_cDimensions]
	or	al,al
	jz	StdSearch_Cont7			;brif input cDims == 0



	mov	[bx.VAR_value.ASTAT_cDims],al
StdSearch_Cont7:
	
	;note: we must do the following check AFTER we check for array vs.
	;      non-array, or we would be flagging some bogus DD errors

	TESTM	mkVar.MKVAR_flags,<FVSHARED OR FVCONST>	
	jnz	StdSearch_Shared_Or_Const	;brif either flag bit is set

StdSearch_Cont8:
	mov	[vm_fVarFound],TRUE
	mov	ax,[oTypNew]
	inc	ax
	.errnz	UNDEFINED - 0FFFFH
	jz	StdSearch_Cont9			;brif oTyp not changed

	mov	ax,[oTypNew]
	mov	[mkVar.MKVAR_oTyp],ax		;in case entry oTyp different
						;  from assumed one
StdSearch_Cont9:
	mov	[vm_pVarCur],di			;a return value
	sub	di,si
	mov	[vm_oVarCur],di

	sub	ax,ax				;return FALSE - no error
StdSearch_Exit:
	pop	di
StdSearch_Exit_1:
	pop	si
	ret

StdSearch_Shared_Or_Const:
	TESTM	di.VAR_flags,<FVFUN OR FVSTATIC OR FVFORMAL OR FVCONST>	
	jz	StdSearch_Cont8			;brif none of the above are set
	jmp	StdSearch_DD_Err1

StdSearch	ENDP

;***
;MakeVariableFar - Same as MakeVariable, but a far entry point
;Purpose:
;	Added as part of revision [12].
;	See MakeVariable.
;Entry:
;	See MakeVariable.
;Exit:
;	See MakeVariable.
;******************************************************************************/
cProc	MakeVariableFar,<FAR,PUBLIC,NODATA>
cBegin	MakeVariableFar
	call	MakeVariable
cEnd	MakeVariableFar


;***
;OVarOfRetVal
;Purpose:
;	In certain cases, the parser will emit the wrong pcode for return
;	values to FUNCTIONs and DEF FNs, with the result that the pcode will
;	be bound instead to the function reference instead of the return
;	value oVar.  The execute scanner will detect this case, and call this
;	routine for such cases to get the oVar for the return value.
;
;	Note: Guaranteed to cause no heap movement
;Entry:
;	AX = oVar is given for the reference (that was erroneously placed in
;		the pcode).
;Exit:
;	Returns AX = oVar for the return value, or AX has high bit set.
;******************************************************************************/
cProc	OVarOfRetVal,<PUBLIC,FAR>,<DI>		
cBegin
	DbChk	ConStatStructs
	DbHeapMoveOff				;depending on no heap movement
						;  in this routine
	xchg	ax,di				;di = oVar 
	mov	ax,[grs.GRS_oPrsCur]
	inc	ax
	.errnz	UNDEFINED - 0FFFFH
	jz	OVarOfRetVal_Err_Exit		;brif no active procedure
	dec	ax
	cCall	FieldsOfPrs,<ax>		;ax = oNam of prs
						;bx = pPrs (== prsCur)
						;dl = procType of prs
	cmp	dl,PT_SUB
	jz	OVarOfRetVal_Err_Exit		;brif active proc is a SUB

	add	di,[mrsCur.MRS_bdVar.BD_pb]	;di = pVar
	cmp	ax,[di.VAR_oNam]		;was given oVar for a ref. to
						;  prsCur?
	jnz	OVarOfRetVal_Err_Exit		;brif not

	mov	[mkVar.MKVAR_oNam],ax		;setup for MakeVariable call
	mov	al,[prsCur.PRS_oType]
	and	ax,M_PT_OTYPE			
	mov	[mkVar.MKVAR_oTyp],ax		;setup for MakeVariable call
	mov	[mkVar.MKVAR_flags],FVLVAL
	call	MakeVariable			;MUST succeed, because we always
						;  create the retval when we
						;  create a function ref. entry
	DbAssertTst  ah,z,080H,CP,<OVarOfRetVal: MakeVariable returned an error>
	jmp	short OVarOfRetVal_Exit

OVarOfRetVal_Err_Exit:
	or	ah,080H				;signal error return
OVarOfRetVal_Exit:
	DbHeapMoveOn				;heap movement allowed again
cEnd

;***
;AdjustVarTable
;Purpose:
;	This routine is called when a variable table is about to be moved.
;	Due to the overhead that would be required for the runtime to update
;	backpointers to AD's and SD's in static variable tables, we do this
;	work here.
;Input:
;	SI = ptr to the MRS_bdVar.BD_pb field in some mrs
;	DI = adjustment factor
;Output:
;	none
;Modifies:
;	SI
;***************************************************************************
cProc	AdjustVarTable,<FAR,PUBLIC,NODATA>
cBegin	
 	;Calculate the oMrs for this variable table, so we can get
	;at the hash tables for all the prs's
	mov	bx,[grs.GRS_oMrsCur]	;assume tVar is for mrsCur
	mov	ax,si
	mov	si,[si]			;si = pVarTable
	sub	ax,[MRS_bdVar.BD_pb]	;ax = pMrs
	cmp	ax,dataOFFSET mrsCur	;is tVar for mrsCur?
	jz	Got_oMrsBx		;  brif so

	sub	ax,[grs.GRS_bdRs.BD_pb] 
	xchg	ax,bx
Got_oMrsBx:				;bx = oMrs
	mov	ax,UNDEFINED		;start w/first prs in module
PrsAdjustLoop:
	xor	cx,cx			;cx == 0 --> include prs's for DEF FN's
	push	bx			;save oMrs
	call	GetNextPrsInMrs		;ax = an oPrs in module
	js	AdjustMrs		;brif no (more) prs's in this module

	push	ax			;save oPrs
	call	PPrsOPrs		;bx = pPrs
	mov	ax,PTRRS[bx.PRS_oVarHash] 
	inc	ax
	.errnz	UNDEFINED - 0FFFFH
	jz	AdjustNextPrs		;brif this prs has no hash table
	dec	ax

	push	si			;ptr to variable table
	push	ax			;offset to tPV hash table
	push	di			;adjustment factor
	call	AdjustPrsVarTable
AdjustNextPrs:
	pop	ax			;current oPrs - use to fetch next oPrs
	pop	bx			;oMrs of vartable
	jmp	short PrsAdjustLoop

AdjustMrs:
	pop	bx			;clean stack
	push	si			;ptr to variable table
	push	di			;adjustment factor
	call	AdjustMrsVarTable
cEnd	

;***
;oTypOfONamDefault
;Purpose:
;	Given an oNam, return the default oTyp of that name.
;	Note that 'logical first char' implies the third char of a
;	name which starts with 'FN' and the first char of any other name.
;Entry:
;	oNam
;	ps.tEtCur is filled with default types for 26 letters
;Exit:
;	ax = oTyp
;Exceptions:
;	none.
;Preserves:
;	ES
;
;******************************************************************************/
cProc	oTypOfONamDefault,<PUBLIC,FAR>,<ES>	
	parmW	oNam			
cBegin
	push	[oNam]			; pass oNam
	call	GetVarNamChar		;al = 1st logical char of name
	push	ax
	call	GetDefaultType		;al = default oTyp
cEnd

;***
;VarRudeReset - reset module Variable/Type table for Rude Edit
;Purpose:
;	This routine is called as part of descanning to SS_RUDE. The module
;	variable and type tables are reset, i.e., existing variables and types
;	are thrown out, and the table reinitialized.
;Entry:
;	mrsCur.bdVar is currently a heap owner.
;Exit:
;	None. Since the table is at least the same size on entry as it will
;	be on exit, Out of Memory is not possible.
;	The table is set to the same state it was at module creation time.
;Exceptions:
;	none.
;******************************************************************************/
cProc	VarRudeReset,<PUBLIC,NEAR>
cBegin
	PUSHI	ax,<dataOFFSET mrsCur.MRS_bdVar>
	cCall	BdFree

	cCall	MakeMrsTVar
	DbAssertRel  ax,nz,0,CP,<VarRudeReset: MakeMrsTVar returned OM error>
cEnd	VarRudeReset


;###############################################################################
;#                                                                             #
;#                            COMMON Support                                   #
;#                                                                             #
;###############################################################################
; For implementation details, see ..\id\common.doc

;***
;ClearCommon() - CLEAR all variables in all COMMON Blocks
;Purpose:
;	CLEAR all COMMON variables; this includes zeroing numeric vars, 
;	releasing all strings, and ERASing all arrays.
;	Note that this also removes all common blocks (except for blank
;	common) when fResetCommon is TRUE.
;	Note that this skips clearing blank common when fChaining is TRUE.
;Key Assumptions:
;	- Blank (a.k.a. unnamed) COMMON is always present, and is always the
;		first COM structure in bdtComBlk
;Entry:
;	grs.bdtComBlk is assumed to be set up.
;	fChaining flag
;	fResetCommon flag
;	fQlbCommon flag false
;Exit:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
cProc	ClearCommon,<PUBLIC,NEAR,NODATA>,<SI,DI>
cBegin
	;Register Use:	SI points to current COM entry in bdtComBlk
	;		DI points just past last allocated COM entry
	mov	si,[grs.GRS_bdtComBlk.BD_pb]
	mov	di,si
	add	di,[grs.GRS_bdtComBlk.BD_cbLogical]

	cmp	[fChaining],FALSE	;Want to clear blank common too?
	jz	ClearCommon_Cont	;  brif so
ClearCommon_Loop:
	add	si,SIZE COM		;skip to next entry	
ClearCommon_Cont:
	cmp	si,di
	jae	ClearCommon_Exit	;brif no more COM entries

	push	di
	xor	di,di			;tell SsAdjustCommon to release owners
					;  rather than to adjust them
	mov	bx,si
	add	bx,COM_bdType		; point to bdType for this block
	call	SsAdjustCommon
	pop	di

	xor	ax,ax
	test	[mrsCur.MRS_flags],FM_VARNEW	; called from VarDealloc?
	jz	NoBashTypeTable 		; brif not
	mov	[si.COM_bdType.BD_cbLogical],ax ; type table no longer valid
NoBashTypeTable:				

	cmp	[fResetCommon],al	;want to release COMMON block tables?
	jz	Zero_Common		;  brif not - - just set values to zero

	;reset tables to size zero in case this is blank common
	mov	[si.COM_bdType.BD_cbLogical],ax
	cmp	[si.COM_bdValue.BD_cbPhysical],UNDEFINED
	jz	ClearCommon_Reset_Cont	;brif bdValue table is for a U.L. block
					; - - - leave U.L. block bdValue alone
	mov	[si.COM_bdValue.BD_cbLogical],ax
ClearCommon_Reset_Cont:

	cmp	si,[grs.GRS_bdtComBlk.BD_pb]
	jz	ClearCommon_Loop	;don't ever release blank COMMON tables

	lea	ax,[si.COM_bdType]
	cCall	BdFree,<ax>		;free the table of oTyps for this block
	cmp	[si.COM_bdValue.BD_cbPhysical],UNDEFINED
	jz	ClearCommon_Loop	;brif bdValue is not an owner (but is
					;  instead used to hold info on U.L. 
					;  block)
	lea	ax,[si.COM_bdValue]
	cCall	BdFree,<ax>		;free the value table for this block
	jmp	short ClearCommon_Loop	;done

Zero_Common:
	cmp	[si.COM_bdValue.BD_cbPhysical],UNDEFINED ; QuickLib common?
	jne	NotQlb			; brif not -- clear it now
	mov	fQlbCommon,TRUE 	; call B$IRTCLR later to clear it
	jmp	short ClearCommon_Loop	; go back for more

NotQlb: 				; clear the non-QLB common block
	push	[si.COM_bdValue.BD_pb]
	push	[si.COM_bdValue.BD_cbLogical]
	call	ZeroFill
	jmp	short ClearCommon_Loop

ClearCommon_Exit:
	xor	cx,cx			; prepare to clear & test fQlbCommon
	xchg	cl,[fQlbCommon] 	; COMMON block that wasn't deleted?
	jcxz	NoZeroVars		; brif not - don't set vars to zero
	cmp	[fChaining],FALSE	; are we chaining?
	jnz	NoZeroVars		; brif so -- B$CHNINI will do the
					; work for us
	call	B$IRTCLR		
NoZeroVars:				
	DbAssertRel si,z,di,CP,<ClearCommon: End of table not where expected>
cEnd

;***
;ResetCommon() - Deallocate all common blocks
;Purpose:
;	Calls ClearCommon to release all strings and arrays, throws out value
;	and type tables for each common block as well as the common block entry
;	itself, and shrinks the global common block table. If 'fChaining' is
;	FALSE, this is done to the unnamed common block as well, otherwise,
;	that block is excluded. Note that, even in the case where the unnamed
;	block is to be reset, it is still not deallocated; it's buffers are just
;	trimmed to zero. This (along with initialization code) allows us to 
;	always assume that the unnamed block exists, and it's buffers allocated,
;	although perhaps to size zero.
;
;	Note that the value field in COMMON entries in existing variable tables
;	will now be garbage; this is okay, because we know that the scanner will
;	explicitly put the correct information in when it is next invoked - - -
;	the variable tables do NOT need to be accessed by this routine.
;Entry:
;	global flag fChaining set appropriately
;Exit:
;	none.
;Exceptions:
;	none.
;*******************************************************************************
cProc	ResetCommon,<PUBLIC,NEAR,NODATA>
cBegin
	mov	[fResetCommon],TRUE
	call	ClearCommon
	xor	ax,ax
	mov	[fResetCommon],al
	mov	[oValComMax],ax 		;reset max oVar of blank common
	mov	[oTypComMax],ax 		;reset max oTyp of blank common
	mov	[grs.GRS_bdtComBlk.BD_cbLogical],SIZE COM
						;trim global table back so it
						;  just contains blank COMMON
cEnd

;***
;MakeCommon(oNam) - Create COMMON Block if req'd, rtn offset to block
;Purpose:
;	Given an oNam for a COMMON Block (UNDEFINED for the unnamed block),
;	creates the COMMON Block if it does not already exist, and returns an
;	offset into the global table of COMMON Blocks for the specified block.
;	If the block is created, this routine also calls the heap manager to
;	allocate buffers of minimal size for the value and type tables.
;
;Entry:
;	oNam - offset into the module name table for the Block name
;		Note: it is assumed that oNam is valid, i.e., represents
;			an actual name in mrsCur.bdlNam. In many cases, things
;			will work out o.k. even if it is not, but not always.
;	It is assumed that the global table of COMMON Blocks (grs.bdtComBlk)
;		is already a valid heap item. 
;
;Exit:
;	ax = offset into grs.bdtComBlk to the specified block, or UNDEFINED
;		if out of memory.
;
;	Special case: if the static flag 'fCreateCommon' is FALSE, then we
;		don't want to create a new entry, but just find if a given
;		entry is present or not. In this case, ax = offset to specified
;		block or UNDEFINED if the block is not found.
;	
;Exceptions:
;	None. If Out-of-Memory occurs, the logical size of grs.bdtComBlk will be
;	unchanged, and no new buffers will have been allocated.
;*******************************************************************************
cProc	MakeCommon,<PUBLIC,FAR,NODATA>,<SI,DI>
	parmW	oNam
	localW	ogNam			
	localV	bdName,%(SIZE BD)
	localV	bdType,%(SIZE BD)
	localV	bdValue,%(SIZE BD)
cBegin	MakeCommon
	mov	ax,[oNam]		
	inc	ax			; UNDEFINED?
	jz	@F			; brif so - - - set ogNam == 0

	dec	ax			
	cCall	OgNamOfONam,<ax>	
	jnz	@F			; brif no error
	jmp	MakeCommon_Exit 	; OM error adding name to
					;	global name table
@@:					
	mov	[ogNam],ax		
	;Register Use:	SI points to current COM entry in bdtComBlk
	;		DI points just past last allocated COM entry
	mov	si,[grs.GRS_bdtComBlk.BD_pb]
	mov	di,si
	add	di,[grs.GRS_bdtComBlk.BD_cbLogical]

	;First, search table to see if a matching entry exists
	sub	si,SIZE COM		;special 1st-time-thru-loop value
MakeCommon_Loop:
	add	si,SIZE COM
	cmp	si,di
	jae	MakeCommon_Grow		;no more entries - - - no match

	mov	ax,[si.COM_ogNam]	
	cmp	ax,[ogNam]		
	jnz	MakeCommon_Loop		;brif match not found
	jmp	MakeCommon_SI_Exit	;match found

MakeCommon_Grow:
	DbAssertRel	si,z,di,CP,<MakeCommon: SI ne DI @ end of table search>
	cmp	[fCreateCommon],FALSE	;Want a new entry?
	jz	MakeCommon_Err_1Exit1	;  brif not - indicate search failure

	mov	di,[grs.GRS_bdtComBlk.BD_cbLogical]
					;save offset of new entry in si (because
					;  bdtComBlk might move during BdGrow)
	PUSHI	ax,<dataOFFSET grs.GRS_bdtComBlk>
	PUSHI	ax,<SIZE COM>
	call	BdCheckFree		;grow common block table for new entry
					;NOTE: we don't increase cbLogical until
					;NOTE: the entry is built; this way,
					;NOTE: heap movement of this table
					;NOTE: doesn't try to treat random
					;NOTE: garbage now in this new entry
					;NOTE: as heap owners
	or	ax,ax
	jnz	MakeCommon_Grow_OK	;brif BdGrow successful
MakeCommon_Err_1Exit1:
	jmp	MakeCommon_Err_Exit1	;BdGrow failed
MakeCommon_Grow_OK:
	mov	[bdName.BD_pb],NULL
					;in case this is for blank COMMON
	mov	ax,[oNam]
	inc	ax
	.errnz	UNDEFINED - 0FFFFH
	jz	MakeCommon_Got_Name	;brif it is blank COMMON - bdName is set

	dec	ax
	lea	bx,[bdName]
	cCall	CopyONamBd,<ax,bx>	;returns ax = 0 if OM error
	or	ax,ax
	jnz	MakeCommon_Got_Name	;brif no error
	jmp	MakeCommon_Err_Exit2
MakeCommon_Got_Name:
	lea	ax,[bdType]
	push	ax
	PUSHI	ax,0
	PUSHI	ax,IT_NO_OWNERS
	call	BdAlloc			;allocate type table
	or	ax,ax
	jz	MakeCommon_OM_Free1	;if OM error, free all bd's

	mov	si,di			;si = di = offset to new COM entry
	;now call runtime to determine if we should create our own value
	;  table for this block, or if we should use an existing U.L. block
	call	RtPushHandler
	mov	ax,CPOFFSET MakeCommon_RT_Return
	call	RtSetTrap
	lea	ax,[bdName]
	cCall	B$ULGetCommon,<ax>	;always returns ax = 0, plus
					;  bx = 0 if no match, or 
					;  bx = pbBlock, dx = cbBlock
MakeCommon_RT_Return:	
	call	RtPopHandler		;note this preserves ax, bx, & dx
	or	ax,ax			
	jnz	MakeCommon_OM_Free1	;brif runtime error

	or	bx,bx
	jz	Alloc_Value_Table	;brif no match - - allocate our own

	add	si,[grs.GRS_bdtComBlk.BD_pb]
	mov	[si.COM_bdValue.BD_pb],bx
	mov	[si.COM_bdValue.BD_cbPhysical],UNDEFINED
					;cbPhysical == UNDEFINED is what
					; indicates this is a U.L. block
	mov	[si.COM_bdValue.BD_cbLogical],dx
	jmp	short Move_Name_n_bdType
Alloc_Value_Table:
	lea	ax,[bdValue]
	push	ax
	PUSHI	ax,0
	PUSHI	ax,IT_COMMON_VALUE
	call	BdAllocVar		;allocate COMMON Value table in var heap
	or	ax,ax
	jnz	MakeCommon_Cont		;brif no OM error
MakeCommon_OM_Free1:
	jmp	short MakeCommon_OM_Free

MakeCommon_Cont:
	;Success. Now just move the owners, and exit
	add	si,[grs.GRS_bdtComBlk.BD_pb]
	lea	ax,[bdValue]
	lea	bx,[si.COM_bdValue]
	cCall	BdChgOwner,<ax,bx>	;move bdValue into bdtComBlk
Move_Name_n_bdType:
	add	[grs.GRS_bdtComBlk.BD_cbLogical],SIZE COM
					;MakeCommon succeeded - reflect new
					;  table size based on addition of
					;  this new entry
					;NOTE: do this BEFORE these next two
					;NOTE: BdChgOwner calls so non-RELEASE
					;NOTE: code won't complain about finding
					;NOTE: owners past cbLogical in the
					;NOTE: grs.GRS_bdtComBlk table
	mov	ax,[ogNam]		
	mov	[si.COM_ogNam],ax	
	lea	ax,[bdName]		
	cCall	BdFree,<ax>		
	lea	ax,[bdType]
	lea	bx,[si.COM_bdType]
	cCall	BdChgOwner,<ax,bx>	;move bdType into bdtComBlk
	xor	ax,ax
	mov	[si.COM_oTypCur],ax	;initialize
	mov	[si.COM_oValCur],ax
MakeCommon_SI_Exit:
	xchg	ax,si			;ax points to COM struct
	sub	ax,[grs.GRS_bdtComBlk.BD_pb] ;retval is offset into bdtComBlk
MakeCommon_Exit:
cEnd	MakeCommon

MakeCommon_OM_Free:
	lea	ax,[bdName]
	cCall	BdFree,<ax>
	lea	ax,[bdType]
	cCall	BdFree,<ax>
MakeCommon_Err_Exit2:
	sub	[grs.GRS_bdtComBlk.BD_cbLogical],SIZE COM
MakeCommon_Err_Exit1:
	mov	ax,UNDEFINED
	jmp	short MakeCommon_Exit


;***
;B$GetNMALLOC
;Purpose:
;	Called by the runtime to find a QB-specific COMMON block named
;	NMALLOC. If found, we return a pointer to the start of the value
;	table and its size.
;Input:
;	none
;Output:
;	AX = 0 if block not found, or is CB (size of block in bytes)
;	DX = PB (DGROUP-relative pointer to start of block) if AX <> 0
;***************************************************************************
cProc	B$GetNMALLOC,<PUBLIC,FAR,NODATA>
cBegin	B$GetNMALLOC	
	call	EnStaticStructs 	
	push	ax			;remember whether we should disable
					;  Static Structs on exit or not
	mov	ax,dataOFFSET NMALLOC	;points to string 'NMALLOC'
	mov	cx,CB_NMALLOC		;length of string
	call	ONamOfPbCb		;ax = oNam for 'NMALLOC' or 0
	jz	GetNMALLOC_Exit		;if ONamOfPbCb returns out of memory
					;  error code, we know there's no
					;  existing nammgr entry by this name,
					;  because nammgr only needs to grow
					;  name table to add a new entry.
	mov	[fCreateCommon],FALSE	;Tell MakeCommon to just search, not
					;  create
	cCall	MakeCommon,<ax>		;returns ax = offset to found common 
					;  block, or UNDEFINED if not found
	mov	[fCreateCommon],TRUE	;Reset static flag to default
	inc	ax			;was given block found?
	.errnz UNDEFINED - 0FFFFH	
	jz	GetNMALLOC_Exit		;  brif not - - - report failure

	dec	ax	
	add	ax,[grs.GRS_bdtComBlk.BD_pb]
	xchg	ax,bx			;bx now points to COM entry
	mov	dx,[bx.COM_bdValue.BD_pb]
	mov	ax,[bx.COM_bdValue.BD_cbLogical]
GetNMALLOC_Exit:
	pop	cx
	jcxz	GetNMALLOC_Exit1	;brif static structs were already
					;  active on entry
	push	ax			;save return values...
	push	dx			;...across DisStaticStructs
	call	DisStaticStructs
	pop	dx
	pop	ax
GetNMALLOC_Exit1:
cEnd	B$GetNMALLOC	

;***
;AdjustCommon
;Purpose:
;	This routine is called when a common value table is about to be moved.
;	Due to the overhead that would be required for the runtime to update
;	backpointers to AD's and SD's in static variable tables, we do this
;	work here.
;Input:
;	SI = ptr to the COM_bdValue.BD_pb field for an entry in 
;		grs.GRS_bdtComBlk
;	DI = adjustment factor
;Output:
;	none
;Modifies:
;	SI
;***************************************************************************
cProc	AdjustCommon,<PUBLIC,FAR,NODATA>
cBegin	AdjustCommon

	mov	ax,[pSsCOMcur]
	mov	bx,ax
	add	ax,8			;ax = ptr to BdValue.BD_bp on stack
	cmp	ax,si
	jz	AdjustIt		;brif this is the block that's moving

	;nope - - - owner of table MUST therefore be in bdtComBlk
Not_Scanning_Common:
	mov	bx,[grs.GRS_bdtComBlk.BD_pb]

	;First, search table to see if a matching entry exists
	sub	bx,SIZE COM		;special 1st-time-thru-loop value
AdjustCommon_Loop:
	add	bx,SIZE COM
	DbAssertRel bx,b,dx,CP,<AdjustCommon: given value table not found>

	lea	ax,[bx.COM_bdValue.BD_pb]
	cmp	si,ax
	jnz	AdjustCommon_Loop	;brif this isn't the right COMMON block

	add	bx,COM_bdType		; point to bdType for this block
AdjustIt:
	call	SsAdjustCommon		;actually adjust the back pointers
					;  to any SD's and AD's in table
cEnd	AdjustCommon



;###############################################################################
;#                                                                             #
;#                            non-RELEASE Code                                 #
;#                                                                             #
;###############################################################################

;***
;CbTypFar
;Purpose:
;	Far interface to CbTyp
;	Added as part of revision [5].
;Entry:
;	parmW = oTyp
;Exit:
;	size of type
;******************************************************************************/
cProc	CbTypFar,<PUBLIC,FAR>
	parmW	oTyp
cBegin
	cCall	CbTyp,<oTyp>
cEnd

sEnd	CP


	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\qb\dshstubc.c ===
/* File: dshstub.c - dumb shell stub routines for QBI */
#include "version.h"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\qbas\version.h ===
/* version.h */
#define VERSION_H
#include "switch.h"	/* set up switch default values */
#define EM_MATH         ON
#include "interp.h"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\defcolor.c ===
/***
*defcolor.c
*
*	Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*	default color table, and color initialization.
*
*******************************************************************************/

#include <version.h>

/* Next, include COW's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>
#include <cw/color.h>
#include <uiext.h>

#ifndef UI_H
#include <ui.h>
#endif

/* Font drawing information */
//[3] Not currently used
//[3] WORD PASCAL mpisaffont[isaUserMax] = {0};

SA PASCAL rgsa[isaUserMax] = {
    /* list : b&w ca, color ca */
    /* isaBackground : all backgrounds */
    { caWhite,			caWhite 			},
    /* isaHilite : Hilited items */
    { caWhite,			caWhite 			},
    /* isaGreyed : greyed items */
    { caBlackOnWhite,		CaMake(coGrey, coWhite) 	},
    /* isaEnabled : enabled items */
    { caBlackOnWhite,		caBlackOnWhite			},
    /* isaDisabled : disabled items */
    { caBlackOnWhite,		CaMake(coGrey, coWhite) 	},

    /* isaAlert : for MessageBox alerts */
    { caBlackOnWhite,		caBlackOnWhite			},

    /* isaDialogBox : background for dialogs */
    { caBlackOnWhite,		caBlackOnWhite			},
    /* isaPushButton : push button color */
    { caBlackOnWhite,		caBlackOnWhite			},
    /* isaButtonDown : pushed button color */
    { caWhite,			caWhite 			},
    /* isaListBox : listbox background */
    { caBlackOnWhite,		caBlackOnWhite			},
    /* isaScrollbar : scroll bar Background & arrows */
    { caBlackOnWhite,		caBlackOnWhite			},
    /* isaElevator : scroll bar elevator */
    { caWhite,			caWhite 			},

    /* isaMenuBox : background for menus */
    { caBlackOnWhite,		caBlackOnWhite			},
    /* isaMenu : menu bar color */
    { caBlackOnWhite,		caBlackOnWhite			},
    /* isaMenuSelected : Selected menus */
    { caWhite,			caWhite 			},
    /* isaMenuHilite : for single character */
    { CaMake(coBrightWhite, coWhite), CaMake(coBrightWhite, coWhite) },
    /* isaMenuHiliteSel : for single character (under selection) */
    { caBrightWhite,		caBrightWhite			},
    /* isaItemHiliteSel : for single character (under selection) */
    { caBrightWhite,		caBrightWhite			},

    /* isaDialogAccel : dialog accelerators */
    { CaMake(coBrightWhite, coWhite), CaMake(coBrightWhite, coWhite) },

    /* isaShadow : shadows */
    { caWhite,			CaMake(coGrey, coBlack) 	},

    /* isaUserMin : 16 USER COLORS */
    /* isaEditWindow : color of edit window */
    { caWhite,			CaMake(coWhite, coBlue) 	},
    /* isaCurStmt : color of current statement */
    { caBrightWhite,		CaMake(coBrightWhite, coBlue)	},
    /* isaBreakpoint : color of breakpoint line */
    { caBlackOnWhite,		CaMake(coWhite, coRed)		},
    /* isaCurBreakpoint : color of current statement if it is a breakpoint line as well */
    { CaMake(coBrightWhite, coWhite), CaMake(coBrightWhite, coRed) },
    /* isaStatusLine : color of status line */
    { caBlackOnWhite,		CaMake(coBlack, coCyan) 	},
    /* isaStatusAlert : color for status line alert messages */
    { caBlackOnWhite, CaMake(coBrightWhite, coCyan)		}, //[5]
    /* isaStatusLock : color of Shift Lock status */
    { caBlackOnWhite,		CaMake(coBlack, coCyan) 	},
    /* isaDebugWindow : color of watch lines */
    { coWhite,			CaMake(coBlack, coCyan) 	},

    /* isaHelpWindow, isaSyntaxHelp : color of help window */
    { caWhite,			caWhite 			},
    /* isaIncludeFileHilite : color of Include File text */
    { caBrightWhite,		CaMake(coYellow, coBlue)	},
    /* isaListBoxHilite : color of list box hilite if different than isaHilite */
    { caWhite,			caWhite 			},
    /* isaWatchpointHilite : color of TRUE watchpoints */
    { caBrightWhite,		CaMake(coBrightWhite, coCyan)	},
    /* isaBold : bold help text */
    { caBrightWhite,		caBrightWhite			},
    /* isaItalic : italic help text */
    { CaMake(coBrightWhite, coWhite), CaMake(CoBright(coGreen), coBlack) },
    /* isaUnderline : underlined help text */
    { caBlackOnWhite,		caBlackOnWhite			},
    /* isaScratch : This is a scratch isa */
    { caWhite,			caWhite 			},
};


// [QH1]
typedef struct {
    WORD isa;
    BYTE caMono;
    BYTE caColor;
    } ISANEW;


//
// isa's to change if LCD or AMDEK, and colors to change them with.
//
ISANEW rgsaNoH[] = {
    { isaDisabled,		caBlackOnWhite, CaMake(coOrange, coWhite)},
    { isaMenuHilite,		caWhite,	CaMake(coRed, coWhite)	 },
    { isaMenuHiliteSel, 	caBlackOnWhite, CaMake(coGreen, coBlack) },
    { isaItemHiliteSel, 	caBlackOnWhite, CaMake(coGreen, coBlack) },
    { isaDialogAccel,		caWhite,	CaMake(coRed, coWhite)	 },
    { isaCurStmt,		caBlackOnWhite, CaMake(coGreen, coBlue)  }, //[5]
    { isaCurBreakpoint, 	caBlackOnWhite, CaMake(coGreen, coRed)	 }, //[5]
    { isaStatusAlert,		caBlackOnWhite, CaMake(coBlack, coCyan)  },
    { isaIncludeFileHilite,	caWhite,	CaMake(coYellow, coBlue) },
    { isaWatchpointHilite,	caBlackOnWhite, CaMake(coRed, coCyan)	 },
    { isaBold,			caBlackOnWhite, CaMake(coRed, coBlack)	 },
    { isaItalic,		caWhite,	CaMake(coGreen, coBlack) }
};


// [QH1]
//
//  ISA's to change if in QHELP mode
//
// WARNING: Remember that QBasic saves the edit window color, and possibly one
//    or two other colors, so be careful which colors you change here!
//
ISANEW rgsaQHelp[] = {
   { isaStatusLine,         caBlackOnWhite,     CaMake(coBlack, coWhite) },
   { isaStatusLock,         caBlackOnWhite,     CaMake(coBlack, coWhite) },
   { isaStatusAlert,        caBlackOnWhite,     CaMake(coBlack, coWhite) },
   { isaItalic,        caBrightWhite,     CaMake(CoBright(coGreen), coBlack) }
};

// [QH1]
// Alternate bold color for /NOHI mode, since the default Red looks awful.
//
ISANEW gsaQHNoH = { isaBold, caBlackOnWhite,     CaMake(coCyan, coBlack) };






/************************************************************************
*WORD FAR PASCAL fInitColorTable () - Initialize User interface color table
*Purpose:
*       Initialize user interface color table based on:
*
*       1. /b command line switch
*       2. /nohi command line switch
*       3. detection of monochrome or color display adapter
*
*Entry:
*       no parameters
*       important global variables:
*               cmdSwitches:
*                       bit flags indicating which command line switches
*                       were used when qb was invoked
*               fMonochrome:
*                       TRUE if monochrome adapter
*                       FALSE if color adapter
*
*Exit:
*	Returns TRUE if we are on an NEC (or a machine that uses the fore
*	ground highlight bit to reverse the colors), and otherwise FALSE.
*
*************************************************************************/
WORD FAR PASCAL
fInitColorTable ()
{
    REG1 short i;

// If /NOHI switch, then set new color options
    if (cmdSwitches & CMD_SW_NOH)
    {
        for (i = 0; i < (sizeof (rgsaNoH) / sizeof (rgsaNoH[0])); i++)
        {
            rgsa[rgsaNoH[i].isa].u.init.caMono  = rgsaNoH[i].caMono;
            rgsa[rgsaNoH[i].isa].u.init.caColor = rgsaNoH[i].caColor;
        }
        // [QH1]
        // QHELP - That Red bold color looks hideous, so change it to Cyan.
        if (cmdSwitches & CMD_SW_QHELP)
        {
            rgsa[isaBold].u.init.caMono  = gsaQHNoH.caMono;
            rgsa[isaBold].u.init.caColor = gsaQHNoH.caColor;
        }
    }

// [QH1]
//
// If QHelp mode, use new online-help colors.
//
    if (cmdSwitches & CMD_SW_QHELP)
    {
	     for (i = 0; i < (sizeof (rgsaQHelp) / sizeof (rgsaQHelp[0])); i++)
        {
	         rgsa[rgsaQHelp[i].isa].u.init.caMono  = rgsaQHelp[i].caMono;
	         rgsa[rgsaQHelp[i].isa].u.init.caColor = rgsaQHelp[i].caColor;
	     }

    }

    if (fMonochrome || (cmdSwitches & CMD_SW_MNO))
        for (i = 0; i < isaUserMax; i++)
            rgsa[i].u.draw.caSa = rgsa[i].u.init.caMono;


    return (FALSE);		// fReverse = FALSE on U.S. IBM
}









=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\intl.inc ===
CCHUNTITLED             EQU 8 ; length of "Untitled" file name string
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\scroll.c ===
#define CC
#define cwExtraWnd	5

#include <cw\cwindows.h>

WND wndScrollH =
    wndScrollBar (1, FALSE, TRUE, 0, 23, 80, 1, NULL, NULL, 2);

WND wndScrollV =
    wndScrollBar (1, TRUE, TRUE, 80, 0, 1, 23, NULL, NULL, 2);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\hengine.asm ===
TITLE	hengine.asm - utilities for new help engine.
;*** 
;hengine.asm
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	Callbacks and utilities for new help engine.
;
;	    Contains:
;		HelpAlloc
;		HelpDealloc
;		HelpLock
;		HelpUnlock
;		ReadHelpFile
;		CloseFile
;
;	    Support routines located elsewhere:
;		OpenFileOnPath (uipaths.asm)
;
;
;*******************************************************************************

	.xlist
	include	version.inc
	.list
	HENGINE_ASM = ON


	include cw/version.inc
	include cw/windows.inc
	include cw/edityp.inc

	IncludeOnce qbimsgs		
	IncludeOnce heap
	IncludeOnce pointers
	IncludeOnce array
	IncludeOnce uiint

assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

	subttl	DATA segment definitions.
	page

sBegin	DATA
	globalW	curHelpFile,0		; REAL file handle of currently-open
					; help file.  0 if none open.
	externB fHelpAlloc		
	externB HelpFlags		
	externW iHelpId			
	externB fHelpAlloc		
sEnd	DATA

externFP GlobalAlloc			
externFP GlobalFree			
externFP OpenCheckDrive			

sBegin	UI
assumes CS,UI

	subttl	Help engine callbacks
	page

externNP RetryError			
externNP CloseFileNear			
externNP NoHelpFile			

;*** 
;HelpAlloc -- Help engine callback.
;
;Purpose:
;	Allocates a block of memory for the help engine.
;
;Entry:
;	cbMem = number of bytes to allocate
;
;Exit:
;	AX = handle to memory block, or NULL if memory could not be allocated.
;
;	NOTE:  Only help callback allowed to cause heap movement
;Uses:
;	Per convention
;
;Exceptions:
;	Returns NULL if OOM
;*******************************************************************************
cProc	HelpAlloc,<FAR,PUBLIC>
parmW	cbMem
cBegin

DbAssertRelB	fHelpAlloc,ne,0,UI,<HelpAlloc:fHelpAlloc not set>

	mov	cx,[cbMem]		; CX = # bytes to allocate
	jcxz	AllocExit		; brif 0 bytes requested -- return NULL

	xor	dx,dx			; DX:CX = # to allocate
	cCall	GlobalAlloc,<dx,dx,cx>	; AX = handle to memory
	xchg	cx,ax			; CX = handle


	or	cx,cx			; did allocation succeed?
	jnz	AllocExit		; yes, exit
	or	HelpFlags,HLP_FAILOOM	; indicate We failed due to OOM
	cCall	GiveHelpOOM		; register OOM error


AllocExit:				; CX = handle, or 0 if unsuccessful
	xchg	ax,cx			; return AX = handle

DbAssertRel	ax,ne,-1,UI,<HelpAlloc:Handle is invalid>
cEnd


;*** 
;HelpDealloc, CloseFile -- Help engine callbacks.
;
;Purpose:
;	Deallocates a block of memory previously allocated by HelpAlloc.
;
;	If 'handle' is NULL, ignores the call.
;
;	CloseFile only needs to deallocate the filename buffer pointed to
;	by the virtual file handle (which is just a memory handle).
;
;Entry:
;	handle = handle of block to deallocate
;
;Exit:
;	None
;
;	NOTE:  CANNOT cause heap movement
;Uses:
;	Per convention
;
;Exceptions:
;	None
;*******************************************************************************
labelFP <PUBLIC, CloseFile>		; TRICKY! just close current help
					; file and do a dealloc
	xor	cx,cx			; prepare to zero and test
	xchg	cx,[curHelpFile]	; CX = real file handle
	jcxz	@F			; brif not open -- nothing to do
	cCall	CloseFileNear,<cx>	; close the file
	call	fInt24Err		; ignore any int 24 errors that may
					; have occurred, reset b$fint24err,
					; and do a disk reset
@@:					

cProc	HelpDealloc,<FAR,PUBLIC>
parmW	handle
cBegin

	DbHeapMoveOff			; callback can't cause movement

	mov	bx,[handle]		; BX = handle of memory to dealloc
	or	bx,bx			; is the handle NULL?
	jz	DeallocExit		; brif NULL -- we're done
	cmp	WORD PTR [bx],NOT_OWNER ; has it already been deallocated?
	je	DeallocExit		; brif so -- we're done

	cCall	GlobalFree,<BX> 	; deallocate the memory


DeallocExit:

	DbHeapMoveOn			; heap movement ok now
cEnd


;*** 
;HelpLock -- Help engine callback.
;
;Purpose:
;	Locks a block of memory for the help engine.
;
;Entry:
;	handle = handle of block to lock
;
;	Supposed to lock down the heap entry.  If 'handle' is NULL, returns
;	(char far *)0.  We don't have to really lock the blocks, so this is
;	just a dereferencing function.
;
;Exit:
;	DX:AX = far address of locked memory block
;
;	NOTE:  CANNOT cause heap movement
;Uses:
;	Per convention
;
;Exceptions:
;	None
;*******************************************************************************
cProc	HelpLock,<FAR,PUBLIC>
parmW	handle
cBegin

	; we don't really need to lock/unlock the blocks, since the help
	; engine doesn't hold any locks between its calls

	mov	dx,[handle]			; BX = handle
	or	dx,dx				; NULL handle?
	jz	NullHandle			; brif so -- return 0
	inc	dx				; is it -1?
	jz	NullHandle			; yes, treat as if 0
	dec	dx				; restore DX
	mov	bx,dx				; BX = handle
	mov	dx,[bx]				; DX:AX = block addr (offset 0)
NullHandle:
	xor	ax,ax
cEnd



;*** 
;HelpUnlock -- Help engine callback.
;
;Purpose:
;	Unlocks a block of memory previously locked by HelpLock.
;
;	Supposed to unlock the heap entry.  If 'handle' is NULL, ignores
;	the call.  NOP for us, since we don't really do locks.
;
;Entry:
;	handle = handle of block to unlock
;
;Exit:
;	None
;
;	NOTE:  CANNOT cause heap movement
;Uses:
;	Per convention
;
;Exceptions:
;	None
;*******************************************************************************
cProc	HelpUnlock,<FAR,PUBLIC>
parmW	handle
cBegin
	; we don't really need to lock/unlock the blocks, since the help
	; engine doesn't hold any locks between its calls
cEnd


;*** 
;ReadHelpFile -- Help engine callback.
;
;Purpose:
;	Reads data from a file previously opened by OpenFileOnPath
;
;Entry:
;	vfhandle = virtual file handle of file to read
;	fpos    = DWORD byte position to read from
;	pData   = where to put the data read
;	cbBytes = # bytes to read
;
;Exit:
;	DX:AX = #bytes actually read if cbBytes != 0
;	DX:AX = file size if cbBytes == 0
;
;	NOTE:  CANNOT cause heap movement
;Uses:
;	Per convention
;
;Exceptions:
;	None
;*******************************************************************************
cProc	ReadHelpFile,<FAR,PUBLIC>
parmW	vfhandle
parmD	fpos
parmD	pData
parmW	cbBytes
cBegin

	DbHeapMoveOff				; callback can't cause movement
DbAssertTst	HelpFlags,z,HLP_INHELP,UI,<ReadHelpFile: Recursion lock set>
	or	HelpFlags,HLP_INHELP		; set recursion lock

	push	b$fInt24Err			; save old int 24 state
	cCall	HookInt24			; ignore int 24 errors, and
						; return error in b$fInt24Err

RetryRead:					
	mov	bx,vfhandle			; BX = virtual file handle
	cCall	ObtainHelpHandle		; AX = real help file handle
	or	ax,ax				; error?
	je	ErrorExit			; brif so -- return 0
	xchg	bx,ax				; BX = real file handle

	mov	cx,cbBytes			; return file size if
	jcxz	ReturnFileSize			;   (cbBytes == 0)
	push	cx				; save for later

	;seek fpos bytes from start in file vfhandle

	mov	dx,word ptr (fpos)		; CX:DX = where to read
	mov	cx,word ptr (fpos+2)
	mov	ax,4200h			; seek from start
	int	21h				; DX:AX = new offset from start

	pop	cx				; CX = #bytes to read
	jc	CheckRetry			; brif error

	;read cbBytes of data into pData from file vfhandle

	push	ds				; save DS
	lds	dx,pData
	mov	ah,3fh				; read CX bytes into DS:DX
	int	21h				; AX = #bytes read
	pop	ds				; restore DS
	jnc	NoError				; brif no error -- exit

CheckRetry:				; handle errors
	cCall	fInt24Err			; AX = error code (or 0)
						; resets b$fInt24Err and
						; does a disk reset
	cCall	RetryError,<ax>			; put up a box asking if
						; we want to retry IF we
						; got an error, and IF we
						; can retry on this error
	cmp	ax,IDRETRY			; was <RETRY> button hit?
	je	RetryRead			; brif so -- try again

ErrorExit:					
	xor	ax,ax				; return NULL (error)
	or	HelpFlags,HLP_FAILFNF		
						; fall through to clear DX,
						; and exit

NoError:
	cmp	b$fInt24Err,UNDEFINED		; did we get an int24 error?
	jne	CheckRetry			; brif so
	xor	dx,dx				; DX:AX = result
	jmp	SHORT ReadExit			

ReturnFileSize:
	xor	dx,dx				; DX:CX = 0
	mov	ax,4202h			; seek from end
	int	21h				; DX:AX = file size
	jc	CheckRetry			; brif error

ReadExit:
	pop	b$fInt24Err			; restore old int 24 state
	and	HelpFlags,NOT HLP_INHELP	; release recursion lock
	DbHeapMoveOn			; heap movement ok now
cEnd

;added with revision [9]
; Guide to VIRTUAL FILE HANDLES in the help system
;
;	Virtual file handles were added to solve 2 major problems:
;	1. Up to 3 system file handles were being used by the help system,
;	   making these unavailable at execution time.
;	2. The users could switch diskettes while one of the help files was
;	   open, causing havoc.  There is no easy way to check that the file
;	   has not been switched since the last access. 
;
;	The value used for the virtual file handle is a pointer to the segment
;	field of a BDL allocated by GlobalAlloc (through HelpAlloc).
;	The BDL contains the fully-qualified pathame of the help file.
;
;	The filename is determined once, in OpenFileOnPath, and placed in this
;	Buffer.  CloseFile has to only delete this buffer.  ObtainHelpHandle
;	returns the real handle if file aleady open, or opens the file and
;	saves the real handle for future lookup.  CloseCurHelpFile closes
;	the currently open help file, if one is open.  CloseCurHelpFile should
;	be called before any user input is possible, and before any other
;	help files can be accessed.


;added with revision [9]
;*** 
;ObtainHelpHandle -- Map virtual handle to real handle
;
;Purpose:
;	If help file isn't already open, open it.  The true file handle is kept
;	in curHelpFile.  The fully-qualified help file name is kept in a BDL,
;	the segment of which is pointed to by the virtual file handle.
;
;Entry:
;	BX = virtual file handle
;
;Exit:
;	AX = file handle, or 0 if error
;
;Uses:
;	Per convention
;
;Exceptions:
;	Calls NoHelpFile if open unsuccessful.
;*******************************************************************************
cProc	ObtainHelpHandle,<NEAR>
cBegin
	push	iHelpId			; save across possible MsgBox
DbAssertRel b$fInt24Err,e,-1,UI,<ObtainHelpHandle: int 24 on entry>

	mov	ax,curHelpFile		; AX = handle of currently-open help
					; file
	or	ax,ax			; help file already open?
	jnz	HandleExit		; brif so -- return this handle

	mov	es,[bx]			; ES = filename segment

RetryOpen:
	cCall	OpenCheckDrive,<es:[0]> ; make sure we don't
					; have to switch diskettes
					; PRESERVES ALL REGISTERS
	push	ds			; save segment
	push	es			; DS = filename segment
	pop	ds
	xor	dx,dx			; DS:DX = * to filename
	mov	ax,3d00h		; open for read access
	int	21h			; AX = file handle
	pop	ds			; restore DS = DGROUP
	jnc	SaveHandleExit		; brif no error
	
;	cmp	al,4			; no file handles left?
;	jne	NotErrNoHandles		; brif not
;   PUSHI	ER_TMF			; give "too many files" msgbox later
;	call	SetUiErr		
;	jmp	SHORT NoHandleExit	; exit with error

NotErrNoHandles:			
	push	es			; save filename segment for later
	push	es			; NoHelpFile parms
	push	dx			; (fInt24Err trashes DX)
	cCall	fInt24Err		; ignore any int 24 errors that may
					; have occurred, reset b$fInt24err,
					; and do a disk reset
	cCall	NoHelpFile		; issue a message to the user,
					; giving them a chance to retry
					; NOTE: PARMS pushed above
	pop	es			; restore filename segment
	cmp	ax,IDRETRY		; retry specified?
	je	RetryOpen		; brif so -- try again

NoHandleExit:				
	xor	ax,ax			; AX = 0 ==> error

SaveHandleExit:
DbAssertRel b$fInt24Err,e,-1,UI,<ObtainHelpHandle: open worked, but got int 24>
	mov	curHelpFile,ax		; save file handle

HandleExit:
	pop	iHelpId			; restore (possibly) trashed iHelpId
cEnd

;added with revision [9]
;*** 
;CloseCurHelpFile -- Close current open help file, if any.
;
;Purpose:
;	Close the currently-open help file, if any.  This frees up a file
;	handle, and eliminates the problem of the user switching disks
;	while the help file is open.
;
;Entry:
;	curHelpFile = REAL file handle of currently-open help file (0 if none)
;
;Exit:
;	None.
;
;Uses:
;	BX,CX,ES
;
;Preserves:
;	AX,DX
;
;Exceptions:
;	None
;*******************************************************************************
cProc	CloseCurHelpFile,<NEAR,PUBLIC>,<DX,AX>	; save caller's return values
cBegin
	xor	cx,cx			; prepare to zero & test
	xchg	cx,[curHelpFile]	; CX = real file handle
	jcxz	CloseExit		; brif not open -- nothing to do

	cCall	CloseFileNear,<cx>	; close the file
	cCall	fInt24Err		; ignore any int 24 errors that may
					; have occurred, reset b$fInt24err,
					; and do a disk reset

CloseExit:
cEnd

sEnd	UI


	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\textmgr.c ===
/***	TXTMGR.C - Text manager for multi-line editing
*
* GLOBAL
*	LoadBuf			Load a file into a buffer
*	FreeBuf			Free a buffer
*	NewBuf			Create a new (blank) buffer
*
*	S_LinesInBuf		LinesInBuf() routine
*	S_CbGetLineBuf		CbGetLineBuf() routine
*	S_ReplaceLineBuf	ReplaceLineBuf() routine
*	S_InsertLineBuf 	InsertLineBuf() routine
*	S_InsertBufInBuf	InsertBufInBuf() routine
*	S_DeleteLinesBuf	DeleteLinesBuf() routine
*
* LOCAL
*	CbFindLineBuf		Find a specified line in a buffer
*	InsSpace		Insert space into a buffer
*	GrowBuf			Increase the size of a buffer
*
* DESCRIPTION
*
*	This module manages the program source and contains all functions
*	that operate directly on the source.
*
*	The source buffer is maintained in a single Global Heap Segment. It
*	may be larger than 64k. Because of this, linear addresses (32 bit) are
*	used. The linear addresses are converted to segmented addresses when
*	actually accessing the buffer.
*
*	The format of the source buffer is:
*
*		+-----------+-----//-----+-----------+-----//-----+
*		| WORD len0 | len0 BYTES | WORD len1 | len1 BYTES |
*		+-----------+-----//-----+-----------+-----//-----+
*
*				    +------+-----//-----+---------+
*				... | lenN | lenN BYTES | WORD -1 |
*				    +------+-----//-----+---------+
*
*/

/*------------------------- Include Files -------------------------*/

#include <version.h>
/* Next, include COW's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>
#include <uiext.h>

#include <..\hd\edit.h>

#ifndef UIINT_H
#include <uiint.h>
#endif

#ifndef HEAP_H
#include <heap.h>
#endif

#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

extern char	szNull[];
       char	*pszNull = szNull;

/*-------------------------- Local Macros --------------------------*/

/* Returns TRUE if the fhd is allocated, zero if it is un-allocated */

#define ALLOCEDFHD(fhd) (fhd.hData != 0)

/* Dereferences a fhd and returns a far pointer to the data	    */

#define MAKELONG(l, h)	((long)(((unsigned)(l)) | ((unsigned long)((unsigned)(h))) << 16))
#define DEREFFHD(fhd)	((char far *) MAKELONG(0, GETSEG(fhd.hData)))

/*----------------------- Forward References -----------------------*/

LOCAL	WORD	NEAR	PASCAL	CbFindLineBuf(PBUFINFO, DWORD, WORD, DWORD *);
LOCAL	DWORD	NEAR	PASCAL	InsSpace(PBUFINFO, WORD, DWORD);
LOCAL	BOOL	NEAR	PASCAL	GrowBuf(PBUFINFO, DWORD);

/*------------------- Global and Local Variables -------------------*/

/* The EDITMGR requires a number of routines to get its work done; it
** does a call back into the application (us) to update the text buffer.
** Such routines as InsertLineBuf(), DeleteLinesBuf(), etc. are among
** these required call-back routines.
*/

/* These are the buffers that acually manage the data and the information
** that is associated with the data
*/

LOCAL	BUFINFO rgbufinfo[CBUFINFO];

/*------------------ S_LinesInBuf() ------------------*/

/***	LinesInBuf - How many lines in VAP's buffer?
*
* SYNOPSIS
*		cln = LinesInBuf(idVap)
*
* ENTRY
*		idVap			ID of VAP which owns buffer
*
* RETURNS
*		Number of lines currently in buffer
*
* DESCRIPTION
*		Examines the .cln field in the BUFINFO structure to determine
*		the number of lines currently in the buffer.
*
* NOTES
*		Required by EDITMGR
*
*/

GLOBAL WORD FAR PASCAL
S_LinesInBuf(PBUFINFO pbufinfo)
{
	DbChkPBufInfo(pbufinfo);
	DbAssert(ALLOCEDFHD(pbufinfo->fhd));

	return(pbufinfo->cln - 1);
}


/*--------------------------- FreeBuf() ---------------------------*/

/***	FreeBuf - Free a buffer
*
* SYNOPSIS
*		FreeBuf(pbufinfo)
*
* ENTRY
*		pbufinfo		pointer to BUFINFO of buffer
*					to deallocate
*
* RETURNS
*		None
*
* DESCRIPTION
*		Release the memory associated with this buffer.
*
* NOTES
*/

GLOBAL VOID FAR PASCAL
FreeBuf(PBUFINFO pbufinfo)
{
	DbChkPBufInfo(pbufinfo);

	if (ALLOCEDFHD(pbufinfo->fhd))
	{
		FhdDealloc(&pbufinfo->fhd);
	}
}

/*------------------------ CbFindLineBuf() ------------------------*/

/***	CbFindLineBuf() - Find a line in a buffer
*
* SYNOPSIS
*		cb = CbFindLineBuf(pbufinfo, obBase, oln, pobLine)
*
* ENTRY
*		pbufinfo		Pointer to a BUFINFO structure
*		obBase		32-bit pointer to start of buffer
*		oln			Line number to find
*		pobLine		Pointer to DWORD (return value)
*
* RETURNS
*		Number of bytes in line found
*		Also returns 32-bit pointer to line found through pobLine
*
*		Note that the "pointer" points to the actual text, NOT the WORD
*		length preceding the text.
*
* DESCRIPTION
*		Basically a higher-level routine for CbFindLine(); most of
*		the work is done there.  Uses and updates the cache (.olnCache
*		and .obCache fields) from the BUFINFO structure.
*
*/

LOCAL WORD NEAR PASCAL
CbFindLineBuf(PBUFINFO pbufinfo, DWORD obBase, WORD oln, DWORD *pobLine)
{
	WORD		cb;
	WORD		olnCache;

	*pobLine = obBase;

	/* If the requested line is farther along in the file than the
	** line last cached, we can save a lot of time by skipping to
	** the cached (known) line.
	*/

	olnCache = pbufinfo->olnCache;
	pbufinfo->olnCache = oln;

	if (oln >= olnCache)
	{
		*pobLine += pbufinfo->obCache;
		oln -= olnCache;
	}

	/* Find the line in the buffer.  pobLine as passed in to CbFindLine()
	** "points to" the WORD length preceding some line; on exit, it will
	** "point to" the actual text of the line found.
	*/

	cb = CbFindLine(pobLine, oln);

	/* Update the cache information for this BUFINFO.
	*/

	pbufinfo->obCache = *pobLine - sizeof(WORD) - obBase;

	return(cb);
}

/*--------------------------- InsSpace() ---------------------------*/

/***	InsSpace - Insert space into a buffer
*
* SYNOPSIS
*		obNewSpace = InsSpace(pbufinfo, oln, cbAdd)
*
* ENTRY
*		pbufinfo		Pointer to a BUFINFO structure
*		oln			Line number within buffer
*		cbAdd			Number of bytes to add
*
* RETURNS
*		32-bit pointer to start of vacated region  (relative
*		to begining of memory block)
*
*		-OR-
*
*		0L if the buffer could not accomodate the additional space
*
* DESCRIPTION
*		This routine will make space in the source buffer for a line of text.
*		The space will be made BEFORE oln. The source is moved down from
*		oln to the end of source.
*
* NOTES
*/		

LOCAL DWORD NEAR PASCAL
InsSpace(PBUFINFO pbufinfo, WORD oln, DWORD cbAdd)
{
	DWORD		obSrc;
	DWORD		obBase;
	DWORD		cbMove;


	/* If adding the requested number of bytes would grow the buffer
	** beyond its current maximum size, try to make the buffer larger.
	** If this fails, return 0L.
	*/

	if (pbufinfo->obNext + cbAdd + 1 > pbufinfo->cb)
	{
		if (!GrowBuf(pbufinfo, cbAdd))
			return(0L);
	}

	/* Lock the buffer down and find the offset (32-bit pointer) of
	** the indicated line.
	*/

	DbHeapMoveOff();

	obBase = LinearAddr(DEREFFHD(pbufinfo->fhd));

	if (oln < pbufinfo->cln)				/* If within range... */
	{
		CbFindLineBuf(pbufinfo, obBase, oln, &obSrc);
		obSrc -= sizeof(WORD);				/* Move back to WORD length */
		cbMove = pbufinfo->obNext - (obSrc - obBase) + 1;

		BigMoveDown(obSrc + cbAdd, obSrc, cbMove);
	}
	else											/* Add to end of file */
		obSrc = obBase + pbufinfo->obNext;

	pbufinfo->obNext += cbAdd;
	pbufinfo->olnCache = 0xFFFF;			/* Destroy cache information */

	DbHeapMoveOn();

	return(obSrc - obBase);
}

/*--------------------------- GrowBuf() ---------------------------*/

/***	GrowBuf - Increase the size of a buffer
*
* SYNOPSIS
*		fStatus = GrowBuf(pbufinfo, cbAdd)
*
* ENTRY
*		pbufinfo		Pointer to BUFINFO
*		cbAdd			Number of bytes to increase size by
*
* RETURNS
*		TRUE if buffer could be grown; FALSE if not
*
* DESCRIPTION
*		Call the SBMGR to reallocate the buffer, rounding the new size
*		to be an even multiple of CBSRCBLK.
*
* NOTES
*/

LOCAL BOOL NEAR PASCAL
GrowBuf(PBUFINFO pbufinfo, DWORD cbAdd)
{
	DWORD		cbNeeded;
	DWORD		cbRequested;

	cbRequested = cbNeeded = pbufinfo->cb + cbAdd + 1;


	cbRequested += CBSRCBLK - 1;
	cbRequested &= ~(CBSRCBLK - 1);

	// Try the alloc with the extra space
	if (FhdRealloc(&(pbufinfo->fhd), cbRequested))
	{
		pbufinfo->cb = cbRequested;
		return(TRUE);
	}

	// Ok, now try it with just the amount that we need
	if (FhdRealloc(&(pbufinfo->fhd), cbNeeded)) {
		pbufinfo->cb = cbNeeded;
		return(TRUE);
	}

	// Unable to get the needed amount of memory, fail
	SetUiErrOm();
	return(FALSE);
}

/*---------------- S_CbGetLineBuf() ----------------*/

/***	S_CbGetLineBuf - Fetch a line of text from a buffer
*
* SYNOPSIS
*		cb = S_CbGetLineBuf(idVap, oln, cbMax, pBuf)
*
* ENTRY
*		idVap			ID of VAP whose buffer this concerns
*		oln			Line number to fetch
*		cbMax			Maximum number of characters to place in buffer
*		pBuf			Buffer to place text in
*
* RETURNS
*		Number of characters placed in buffer (excluding terminating zero)
*
* DESCRIPTION
*		This routine gets the specified line of text even it is the current
*		line. This is used when the ld buffer has been modified and the line
*		needs to be refreshed.
*
* NOTES
*		Required by EDITMGR
*
*		M00SWAP NPCORE
*/

GLOBAL WORD FAR PASCAL
S_CbGetLineBuf(PBUFINFO pbufinfo, WORD oln, WORD cbMax, char *pBuf)
{
	REG2	WORD	cb;
	DWORD		obSrc;

	DbChkPBufInfo(pbufinfo);
	DbAssert(ALLOCEDFHD(pbufinfo->fhd));

	/* Ignore first line of buffer -- it contains the filename.
	*/

	oln++;

	if (oln < pbufinfo->cln)
	{
		DbHeapMoveOff();

		cb = CbFindLineBuf(pbufinfo, LinearAddr(DEREFFHD(pbufinfo->fhd)), oln, &obSrc);
		cb = min(cb, cbMax);
		fmemcpy((char far *)pBuf, SegAddr(obSrc), cb);

		DbHeapMoveOn();
	}
	else
		cb = 0;
	
	pBuf[cb] = '\0';
	
	return(cb);
}


/*-------------- S_ReplaceLineBuf() --------------*/

/***	S_ReplaceLineBuf - Replace a line in a buffer
*
* SYNOPSIS
*		fSuccess = S_ReplaceLineBuf(idVap, oln, cb, pBuf)
*
* ENTRY
*		idVap			ID of VAP whose buffer this concerns
*		oln			Line to replace
*		cb				Size of replacement text
*		pBuf			Point to Pointer to replacement text
*
* RETURNS
*		TRUE if successful; FALSE if not
*
* DESCRIPTION
*		Replace the indicated line in the buffer. The double
*		indirection on the buffer allows us to point to a
*		movable heap entry and still cause heap movement.
*
* NOTES
*		Required by EDITMGR
*/


GLOBAL BOOL NEAR PASCAL
S_ReplaceLineBuf(PBUFINFO pbufinfo, WORD oln, WORD cb, char **pBuf)
{

	DbChkPBufInfo(pbufinfo);
	DbAssert(ALLOCEDFHD(pbufinfo->fhd));


	if (S_InsertLineBuf(pbufinfo, oln + 1, cb, pBuf, TRUE))
	{
		S_DeleteLinesBuf(pbufinfo, oln, 1);
	}

	return(TRUE);
}

/*--------------- S_InsertLineBuf() ---------------*/

/***	S_InsertLineBuf - Insert a line in a buffer
*
* SYNOPSIS
*		fSuccess = S_InsertLineBuf(idVap, oln, cb, pBuf, fOverCommit)
*
* ENTRY
*		pBuf			Buffer to insert into
*		oln			Line to insert text (AFTER)
*		cb			Size of text to insert
*		pBuf			Pointer to pointer to Text to insert
*		fOverCommit		Check for too many lines or not.
*
* RETURNS
*		TRUE if successful; FALSE if not
*
* DESCRIPTION
*		First remove any trailing spaces from the line, then convert
*		any leading spaces to tabs, if possible.  Then call InsSpace()
*		to insert space in the buffer, and copy the line to the vacated
*		region.
*
*		if fOverCommit is true, then we will not check for
*		inserting too many lines into the buffer.  This allows
*		S_ReplaceLineBuf to work properly, as it adds a line
*		then deletes a line.  If we did not allow it too add more
*		lines than the maximum, we would not be able to modify
*		a full text table.
*
*		The double indirection on the buffer allows us to point to a
*		movable heap entry and still cause heap movement.
*
* NOTES
*		Required by EDITMGR
*
*/

GLOBAL BOOL NEAR PASCAL
S_InsertLineBuf(PBUFINFO pbufinfo, WORD oln, WORD cb, char **pBuf, BOOL fOverCommit)
{
	DWORD			obLine;
	char far		*fpData;
	WORD			cbSave = cb;


	DbChkPBufInfo(pbufinfo);
	DbAssert(ALLOCEDFHD(pbufinfo->fhd));

	if (pbufinfo->cln >= CLNMAX && !fOverCommit) {
	    SetUiErr(MSG_DocTooLarge);
	    return (FALSE);
	}

	/* Ignore first line of buffer - it contains the filename.
	*/

	oln++;

	obLine = InsSpace(pbufinfo, oln, (DWORD)(cb + sizeof(WORD)));

	if (obLine)
	{
		DbHeapMoveOff();

		fpData = SegAddr(obLine + LinearAddr(DEREFFHD(pbufinfo->fhd)));
		*(WORD far *)fpData = cb;

		if (cb != 0)
		{
			fmemcpy(fpData+(long)sizeof(WORD), (char far *)*pBuf, cb);

		}

		pbufinfo->cln++;

		DbHeapMoveOn();
	}

	return(obLine != 0L);
}

/*-------------- S_InsertBufInBuf() --------------*/

/***	S_InsertBufInBuf - Insert a buffer into another buffer
*
* SYNOPSIS
*		S_InsertBufInBuf(idVapDst, oln, idVapSrc)
*
* ENTRY
*		idVapDst		ID of VAP whose buffer is to serve as destination
*		oln			Line number in destination buffer
*		idVapSrc		ID of VAP whose buffer is to serve as source
*
* RETURNS
*		None
*
* DESCRIPTION
*		Insert a buffer within another buffer
*
* NOTES
*		Required by EDITMGR
*
*/

GLOBAL VOID NEAR PASCAL
S_InsertBufInBuf(PBUFINFO pbufinfoDst, WORD oln, PBUFINFO pbufinfoSrc)
{
	DWORD		cbAdd;
	WORD		cbBufName;
	DWORD		obDst;
	DWORD		obSrc;


	DbChkPBufInfo(pbufinfoSrc);
	DbAssert(ALLOCEDFHD(pbufinfoSrc->fhd));
	DbChkPBufInfo(pbufinfoDst);
	DbAssert(ALLOCEDFHD(pbufinfoDst->fhd));


	if (pbufinfoSrc->cln + pbufinfoDst->cln >= CLNMAX) {
	    SetUiErr(MSG_DocTooLarge);
	    return;
	}

	/* Ignore first line of buffer - it contains the filename.
	*/

	oln++;

	cbBufName = *(WORD far *) DEREFFHD(pbufinfoSrc->fhd) + sizeof(WORD);

	cbAdd = pbufinfoSrc->obNext - cbBufName; /* - sizeof(WORD); */

	obDst = InsSpace(pbufinfoDst, oln, cbAdd);

	if (obDst)
	{
		DbHeapMoveOff();

		obDst += LinearAddr(DEREFFHD(pbufinfoDst->fhd));
		obSrc = LinearAddr(DEREFFHD(pbufinfoSrc->fhd)) + cbBufName;

		BigMoveUp( obDst, obSrc, cbAdd );

		pbufinfoDst->cln += pbufinfoSrc->cln - 1;

		DbHeapMoveOn();
	}

	return;										/* M00BUG */
}

/*--------------  S_DeleteLinesBuf() --------------*/

/***	S_DeleteLinesBuf - Delete a range of lines from a buffer
*
* SYNOPSIS
*		S_DeleteLinesBuf(pbufinfo, oln, cln)
*
* ENTRY
*		pbufinfo		handle to buffer
*		oln			Starting line number
*		cln			Number of lines to delete
*
* RETURNS
*		None
*
* DESCRIPTION
*		Delete lines oln..oln+cln-1 from the indicated buffer
*
* NOTES
*		Required by EDITMGR
*
*/

GLOBAL VOID NEAR PASCAL
S_DeleteLinesBuf(PBUFINFO pbufinfo, WORD oln, WORD cln)
{
	DWORD			obSrc, obDst;
	DWORD			obBase;
	DWORD			cbMove;
	WORD			clnMax;

	DbChkPBufInfo(pbufinfo);
	DbAssert(ALLOCEDFHD(pbufinfo->fhd));

	/* Ignore first line of buffer - it contains the filename.
	*/

	oln++;

	clnMax = pbufinfo->cln - oln;

	if (cln >= clnMax)
		cln = clnMax;

	if (pbufinfo->cln == cln+1)
	{
		/* Special case:
		**
		** Deleting all the lines in the buffer.
		** Insert a blank line so that there will be a blank
		** line left in the buffer after deleting the lines.
		*/

		S_InsertLineBuf(pbufinfo, pbufinfo->cln, 0, &pszNull, TRUE);
	}

	DbHeapMoveOff();

	obBase = LinearAddr(DEREFFHD(pbufinfo->fhd));

	CbFindLineBuf(pbufinfo, obBase, oln, &obSrc);

	obSrc -= sizeof(WORD);
	CbFindLineBuf(pbufinfo, obBase, oln+cln, &obDst);
	obDst -= sizeof(WORD);

	cbMove = pbufinfo->obNext - (obDst - obBase) + 1;
	BigMoveUp( obSrc, obDst, cbMove );

	pbufinfo->obNext -= obDst - obSrc;

	pbufinfo->cln -= cln;
	pbufinfo->olnCache = 0xFFFF;		/* Trash the cache */

	DbHeapMoveOn();
}

/*---------------------------- NewBuf() ----------------------------*/

/***	NewBuf - Create a new (blank) buffer
*
* SYNOPSIS
*		fSuccess = NewBuf(pbufinfo)
*
* ENTRY
*		pbufinfo	pointer to buffer info block which is to
*				own new buffer
*
* RETURNS
*		PBUFINFO for buffer if successful; FALSE (0) if not
*
* DESCRIPTION
*		then adds a blank line to make sure the EDITMGR doesn't get
*		confused.
*/

GLOBAL PBUFINFO FAR PASCAL
NewBuf()
{
	PBUFINFO pbufinfo;
	int iBufInfo;

	pbufinfo = NULL;

	/* locate a buffer that is not already in use */

	for (iBufInfo = 0; (iBufInfo < CBUFINFO) && !pbufinfo; iBufInfo++)
	    if (!ALLOCEDFHD(rgbufinfo[iBufInfo].fhd))
		pbufinfo = &rgbufinfo[iBufInfo];

	DbAssert(pbufinfo != NULL);

	if (!FhdAlloc(&pbufinfo->fhd, (DWORD)CBSRCBLK))
	{
		SetUiErrOm();
		return(FALSE);
	}


	pbufinfo->cln = 0;
	pbufinfo->cb = CBSRCBLK;
	pbufinfo->obNext = 0;
	pbufinfo->olnCache = 0xFFFF;			/* No line cached yet... */

	if (AppendLineBuf(pbufinfo, &pszNull))
	{
		FreeBuf(pbufinfo);
		return (FALSE);
	}

	return (pbufinfo);

}


/*** AppendLineBuf - append a line to the end of a buffer
*
* SYNOPSIS
*	fSuccess = AppendLineBuf(pbufinfo, pBuf)
*
* ENTRY:
*	pbufinfo	Pointer to buffer to update
*	pBuf		Indirect Pointer to the source line (tab expanded)
*
* EXIT:
*	Returns 0 on success, -1 on failure
*
* NOTES:
*	This routine can cause heap movement.
*
*	This was written for speed, not size. If the added speed is not
*	is not needed for ASCII load, then call S_InsertLineBuf to do all
*	of the work.
*
*	The reason that we take a char ** is so that we can take a pointer
*	to a movable heap item.  This allows us to handle it like an LMEM
*	entry.
*/

GLOBAL WORD FAR PASCAL
AppendLineBuf(PBUFINFO pbufinfo, char **pBuf)
{
	WORD	cbBuf = CbSzUi(*pBuf);
	DWORD	cbNeeded = cbBuf + sizeof(WORD);
	DWORD	cbAvail = pbufinfo->cb - pbufinfo->obNext;
	DWORD	obLine;
	WORD far *fpLineLen;
	char far *fpLine;

	DbChkPBufInfo(pbufinfo);
	DbAssert(ALLOCEDFHD(pbufinfo->fhd));

	if (pbufinfo->cln >= CLNMAX) {
	    SetUiErr(MSG_DocTooLarge);
	    return (UNDEFINED);
	}

	if (cbAvail < cbNeeded)
	    if (!GrowBuf(pbufinfo, cbNeeded - cbAvail))
		return (UNDEFINED);

	obLine = LinearAddr(DEREFFHD(pbufinfo->fhd)) + pbufinfo->obNext;
	fpLineLen = (WORD far *)SegAddr(obLine);
	fpLine = SegAddr(obLine + sizeof(WORD));

	*fpLineLen = cbBuf;
	fmemcpy(fpLine, (char far *)*pBuf, cbBuf);

	pbufinfo->obNext += cbNeeded;
	pbufinfo->cln ++;

	return (0);
}


/*** CompressBufs - Compress Document buffers to minimum size
*
* SYNOPSIS
*	CompressBufs()
*
* ENTRY:
*	None.
*
* EXIT:
*	None.
*
* NOTES:
*	This routine can cause heap movement.
*
*	We keep some slack in the document buffers to allow for fast
*	insertion of text.  However, if we are running out of memory
*	(or just run out), we need to get rid of the slack.  This routine
*	will go through all allocated document buffers, removing any slack.
*/
GLOBAL VOID FAR PASCAL CompressBufs()
{
    int i = 0;

    for (i = 0; i < CBUFINFO; i++)
	if (ALLOCEDFHD(rgbufinfo[i].fhd))
	    if (FhdRealloc(&rgbufinfo[i].fhd, rgbufinfo[i].obNext))
		rgbufinfo[i].cb = rgbufinfo[i].obNext;

}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\text.asm ===
;***	TEXT.ASM - Low level routines for Text Manager
;*
;* GLOBAL
;*	SegAddr		Linear address -> segmented address
;*	CbFindLine	Find a line in the source buffer
;*	BigMoveUp	Move large blocks of memory up (overlapping)
;*	BigMoveDown	Move large blocks of memory down (overlapping)
;*	LinearAddr	Convert from segmented to linear (32-bit) address
;*
;* LOCAL
;*	$LinearAddr	Convert from segmented to linear (32-bit) address
;*	$SegAddr	Convert from linear (32-bit) to segmented address
;*
;* DESCRIPTION
;*	Low level routines for dealing with large blocks of data.
;*
;------------------------------------------------------------

	PAGE	66,132
	TITLE	TEXT.ASM - Low level routines for Text Manager

	.XLIST


	include	version.inc
	.LIST


;------------------------------------------------------------
; DATA segment definitions
;------------------------------------------------------------

assumes DS, DATA
assumes SS, DATA


;------------------------------------------------------------
; CODE segment definitions
;------------------------------------------------------------

sBegin	UI
assumes	CS,UI

;***	SegAddr - Convert from linear to segmented address
;*
;* SYNOPSIS
;*	lp = SegAddr(addr32)
;*
;* ENTRY
;*	addr32		32-bit (linear) address
;*
;* RETURNS
;*	Far pointer (segmented address)
;*
;* DESCRIPTION
;*	Calls internal routine $SegAddr to do the work
;------------------------------------------------------------

cProc	SegAddr, <NEAR, PUBLIC>

	parmD	addr32

cBegin
	mov	dx, word ptr [addr32 + 2]
	mov	ax, word ptr [addr32]
	call	$SegAddr
cEnd

;***	LinearAddr - Convert from segmented to linear (32-bit) address
;*
;* SYNOPSIS
;*	addr32 = LinearAddr(lp)
;*
;* ENTRY
;*	lp		Far pointer
;*
;* RETURNS
;*	32-bit address of converted far pointer
;*
;* DESCRIPTION
;*	Calls local routine $LinearAddr
;------------------------------------------------------------

cProc	LinearAddr, <NEAR, PUBLIC>

	parmD	lp

cBegin
	mov	ax, word ptr [lp]
	mov	dx, word ptr [lp + 2]

	call	$LinearAddr

cEnd


;***	CbFindLine - Find a line in the source buffer
;*
;* SYNOPSIS
;*	cb = CbFindLine(pAddr32, oln)
;*
;* ENTRY
;*	pAddr32		POINTER TO 32-bit address of source buffer
;*	oln		Line number to find
;*
;* RETURNS
;*	Number of bytes in line found
;*	Also stores 32-bit linear address of line found in pAddr32
;*
;* DESCRIPTION
;*	On entry, *pAddr32 "points to" the word count preceding a line of
;*	text.  Simply moves through the source buffer, using the word
;*	count preceding each line to skip to the next line.  On exit,
;*	*pAddr32 "points to" the line found (actual text, NOT the preceding
;*	word count).
;------------------------------------------------------------

cProc	CbFindLine, <NEAR, PUBLIC>, <DI, SI>

	parmDP	pAddr32
	parmW	oln

cBegin
	mov	bx, pAddr32
	mov	ax, [bx]
	mov	dx, [bx+2]
	call	$SegAddr		; Returns DX:AX as far pointer

	mov	es, dx
	mov	di, ax

	mov	cx, oln
	inc	cx			; Filename is always "line 0"

	xor	si, si

NextLine:
	add	di, si

; Normalize es:di

	mov	ax, di
	shr	ax, 1
	shr	ax, 1
	shr	ax, 1
	shr	ax, 1
	mov	bx, es
	add	ax, bx
	mov	es, ax
	and	di, 000Fh

	mov	si, es:[di]
	inc	di			; Skip...
	inc	di			; ...word count
	loop	NextLine

; Convert back to 32-bit address

	mov	ax, di
	mov	dx, es
	call	$LinearAddr

; Store 32-bit address

	mov	bx, pAddr32
	mov	[bx], ax
	mov	[bx+2], dx

	mov	ax, si			; Number of bytes in line
cEnd


;***	BigMoveUp - Moves large blocks of overlapping memory up
;*
;* SYNOPSIS
;*	BigMoveUp(addr32Dst, addr32Src, cb)
;*
;* ENTRY
;*	addr32Dst	32-bit address "pointer" to dest. buffer
;*	addr32Src	32-bit address "pointer" to source buffer
;*	cb		Number of bytes to move
;*
;* RETURNS
;*	None
;*
;* DESCRIPTION
;*	The algorithm moves the data in chunks of FFF0 bytes.
;*
;*	Before starting to do the move, the number of FFF0 length chunks
;*	is calculated, along with the number of bytes that are left over.
;*	(Find i, j such that cb = i*FFF0 + j where j < FFF0).
;*
;*	So i blocks of size FFF0 and one block of size j must be moved.
;*	The i blocks of size FFF0 are moved first, followed by the one
;*	block of size j.
;*
;*	In order to move FFF0 bytes, each of the source, and the destination
;*	addresses must have an offset portion less than 000F (because
;*	we are moving from bottom to top). Before each chunk is moved,
;*	both addresses are normalized to this form.
;*
;* CAVEAT
;*	This routine will not work for blocks which start anywhere in the
;*	last 64K of physical memory.
;*
;*	This routine makes implicit use of the relationship between segment
;*	number, and physical address that exists in the iApx 86 architecture.
;*	This routing assumes that cb >= 2
;------------------------------------------------------------

cProc	BigMoveUp, <NEAR, PUBLIC>, <DS, SI, DI>

	parmD	addr32Dst
	parmD	addr32Src
	parmD	cb

cBegin
	cCall	SegAddr,<addr32Dst>	; Convert from linear to segmented address
	mov	es, dx
	mov	di, ax

	cCall	SegAddr,<addr32Src>	; Convert from linear to segmented address
	mov	ds, dx
	mov	si, ax

; Calulate the number of FFF0-byte chunks to move.
; (Save the remainder for later).

	mov	ax, word ptr [cb]
	mov	dx, word ptr [cb + 2]
	mov	bx, 0FFF0h
	div	bx			; AX == # of chunks, DX == # of bytes
	xchg	dx, ax
	push	ax

NextChunkUp:
	mov	cl, 4			; Normalize DS:SI to form SSSS:000y
	mov	ax, si
	shr	ax, cl
	mov	bx, ds
	add	ax, bx
	mov	ds, ax
	and	si, 000fH

	mov	ax, di			; Normalize ES:DI to form SSSS:000y
	shr	ax, cl
	mov	bx, es
	add	ax, bx
	mov	es, ax
	and	di, 000fH

	or	dx,dx			; See if done moving big blocks
	je	MoveBytesUp		; Yes, move last partial block

	dec	dx			; Moving next big block
	mov	cx, 0FFF0h / 2
	rep	movsw			; Moving words is faster than bytes

	jmp	Short NextChunkUp

; At this point DS:SI and ES:DI are normalized, so we can move the
; remaining bytes in one chunk.

MoveBytesUp:
	pop	cx			; Get back # of bytes
	shr	cx, 1
	jnc	MoveWordsUp

	movsb				; Move odd byte

MoveWordsUp:
	rep	movsw			; Move last chunk of words

cEnd

;***	BigMoveDown - Moves large blocks of overlapping memory down
;*
;* SYNOPSIS
;*	BigMoveDown(addr32Dst, addr32Src, cb)
;*
;* ENTRY
;*	addr32Dst	32-bit address "pointer" to source buffer
;*	addr32Src	32-bit address "pointer" to dest. buffer
;*	cb		Number of bytes to move
;*
;* RETURNS
;*	None
;*
;* DESCRIPTION
;*	Similar in operation to BigMoveUp().
;------------------------------------------------------------

cProc	BigMoveDown, <NEAR, PUBLIC>, <DS, SI, DI>

	parmD	addr32Dst
	parmD	addr32Src
	parmD	cb

cBegin
	mov	ax, word ptr [addr32Dst] ; Point to end of Target string
	mov	dx, word ptr [addr32Dst + 2]
	add	ax, word ptr [cb]
	adc	dx, word ptr [cb + 2]
	sub	ax, 1			; Address must be zero based
	sbb	dx, 0
	call	$SegAddr		; Convert linear to segmented addr
	mov	di, ax			; ES:DI == end of target string
	mov	es, dx

	mov	ax, word ptr [addr32Src] ;Point to end of Source string
	mov	dx, word ptr [addr32Src + 2]
	add	ax, word ptr [cb]
	adc	dx, word ptr [cb + 2]
	sub	ax, 1			; Address is zero based
	sbb	dx, 0
	call	$SegAddr		; Convert linear to segmented addr
	mov	si, ax			; DS:SI == end of source string
	mov	ds, dx

; Calulate the number of FFF0-byte chunks to move.
; (Save the remainder for later).

	mov	ax, word ptr [cb]
	mov	dx, word ptr [cb + 2]
	mov	bx, 0FFF0h
	div	bx			; AX == # of chunks, DX == # of bytes
	xchg	dx, ax
	push	ax			; Save final chunk size in bytes

	std				; Performing a reverse move operation

NextChunkDown:
	mov	cl, 4			; Normalize DS:SI to form SSSS:FFFy
	mov	ax, si
	shr	ax, cl
	mov	bx, 0FFFh
	sub	bx, ax
	mov	ax, ds
	sub	ax, bx
	mov	ds, ax
	or	si, 0FFF0h

	mov	cl, 4			; Normalize ES:DI to form SSSS:FFFy
	mov	ax, di
	shr	ax, cl
	mov	bx, 0FFFh
	sub	bx, ax
	mov	ax, es
	sub	ax, bx
	mov	es, ax
	or	di, 0FFF0h

	or	dx,dx			; See if done moving big blocks
	je	MoveBytesDown		; Yes, move last partial block and quit

	dec	dx			; Keep track of big blocks moved
	movsb				; Can't do a movsw if either SI or...
	movsb				; ...DI is 0FFFFh so do two movsb's...
					; ...to make sure they are not

	dec	si			; Point at the low byte of the words to be moved
	dec	di			; (We are moving words at a time now)
	mov	cx, 0FFF0h / 2 - 1	; Number of words - 1
	rep	movsw

	inc	si			; Repz goes one byte too far
	inc	di
	jmp	Short NextChunkDown

; At this point DS:SI and ES:DI are normalized, so we can move the
; remaining bytes in one chunk.

MoveBytesDown:
	pop	cx			; Get back # of remaining bytes
	shr	cx, 1			; Convert to words
	jnc	MoveWordsDown		; See if odd byte exists

	movsb				; Move odd byte

MoveWordsDown:
	jcxz	MoveDownDone		; No moves on zero length left

	movsb				; Problem with moving last word of block
	movsb

	dec	cx			; Count the Word move

	dec	si			; Point at the low byte of the words to be moved
	dec	di			; (We are moving words at a time now)
	rep	movsw

MoveDownDone:
	cld				; Always restore UP condition flag
cEnd

;------------------------------------------------------------
; LOCAL routines
;------------------------------------------------------------

;***	$LinearAddr - Convert far pointer to linear (32-bit) address
;*
;* ENTRY
;*	DX		Segment of far pointer
;*	AX		Offset of far pointer
;*
;* RETURNS
;*	DX		High word of 32-bit address
;*	AX		Low word of 32-bit address
;*
;* USES
;*	BX
;*	CL
;*
;* DESCRIPTION
;*	Addr32 = (Segment << 4) + Offset
;------------------------------------------------------------

$LinearAddr	proc	near

	mov	bx, ax
	mov	cl, 4
	rol	dx, cl
	mov	ax, dx
	and	dx, 000Fh
	and	ax, 0FFF0h
	add	ax, bx
	adc	dx, 0
	ret

$LinearAddr	endp

;***	$SegAddr - Convert from linear (32-bit) address to far pointer
;*
;* ENTRY
;*	DX		High word of 32-bit address
;*	AX		Low word of 32-bit address
;*
;* RETURNS
;*	DX		Segment of far pointer
;*	AX		Offset of far pointer
;*
;* USES
;*	BX
;*	CL
;*
;* DESCRIPTION
;*	Addr32 = (Segment << 4) + Offset
;------------------------------------------------------------

$SegAddr	proc	near

	and	dx, 000Fh
	mov	bx, ax
	and	ax, 0FFF0h
	or	dx, ax
	mov	cl, 4
	ror	dx, cl
	mov	ax, bx
	and	ax, 000Fh
	ret

$SegAddr	endp


sEnd	UI

;------------------------------------------------------------
; Memory Support routines
;------------------------------------------------------------

sBegin	RT
assumes	CS,RT

extrn	B$IFHAlloc:near
extrn	B$FHRealloc:near
extrn	B$FHDealloc:near


;***	FhdAlloc - Allocate a fhd
;*
;* SYNOPSIS
;*	success = FhdAlloc(pFhd, cb)
;*
;* ENTRY
;*	pFhd		pointer to fhd to allocate
;*	cb		Initial size of fhd
;*
;* RETURNS
;*	FALSE if allocation failed
;*
;* DESCRIPTION
;*	Allocates the fhd by calling the runtime entrypoint for
;*	far heap allocs.
;------------------------------------------------------------

cProc	FhdAlloc,<PUBLIC,FAR>
parmW	pFhd
parmD	cb
cBegin
	mov	bx,pFhd
	mov	dx,WORD PTR cb+2
	mov	ax,WORD PTR cb
	call	B$IFHAlloc
cEnd

;***	FhdReAlloc - Realloc a fhd
;*
;* SYNOPSIS
;*	success = FhdReAlloc(pFhd, cb)
;*
;* ENTRY
;*	pFhd		pointer to fhd to reallocate
;*	cb		new size of fhd
;*
;* RETURNS
;*	FALSE if reallocation failed
;*
;* DESCRIPTION
;*	Reallocates the fhd by calling the runtime entrypoint for
;*	far heap reallocation.
;------------------------------------------------------------

cProc	FhdRealloc,<PUBLIC,FAR>
parmW	pFhd
parmD	cb
cBegin
	mov	bx,pFhd
	mov	dx,WORD PTR cb+2
	mov	ax,WORD PTR cb
	call	B$FHRealloc
cEnd

;***	FhdDealloc - Deallcates a fhd
;*
;* SYNOPSIS
;*	FhdDealloc(pFhd)
;*
;* ENTRY
;*	pFhd		pointer to fhd to deallocate
;*
;* RETURNS
;*	Nothing
;*
;* DESCRIPTION
;------------------------------------------------------------

cProc	FhdDealloc,<PUBLIC,FAR>
parmW	pFhd
cBegin
	mov	bx,pFhd
	call	B$FHDealloc
cEnd

sEnd	RT

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\auxcow.c ===
/*** 
*auxcow.c - CW auxiliary code
*
*	Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*	Support code for CW.
*
*******************************************************************************/

#include <version.h>

/* Next, include COW's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>
#include <cw/color.h>
#include <uiext.h>

/* and the dialog headers */
#include <cw/dlg.h>

/* Next, include QBI's headers */
#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

#define UE_COLORS FALSE 	//[16] set this switch to get color sets
				//[16] for user ed screen shots.

/* these must be exported */
VOID		FAR PASCAL OutOfMemory(void);
VOID *		FAR PASCAL PbAllocWork(WORD);
VOID		FAR PASCAL FreeWork(VOID *);

/* Fake LMEM */
VOID **		FAR PASCAL PpvAllocCb(WORD, WORD);
VOID		FAR PASCAL FreePpv(WORD, VOID **);

VOID FARPUBLIC UpdateShiftKk (WORD, WORD);
VOID FARPUBLIC UpdateShiftKj (WORD, WORD);	// [44]
DWORD FAR PASCAL GlobalHandle (HANDLE);
HANDLE FAR PASCAL GlobalRealloc (HANDLE, DWORD, WORD);
BOOL FAR PASCAL PlayBackMsg(MSG *);
void FAR PASCAL RecordMsg(MSG *);
void NEAR PASCAL DumpScreen(void);
VOID FAR PASCAL BackToCow (WORD);	// [22]


VOID FAR PASCAL ShrinkHelp (VOID);	//[41]
char cGlobalAlloc = 0;			//[41] Net # BDL's GlobalAlloc allocated

BYTE fPlayBack = FALSE, fRecord = FALSE;
BYTE fPlaybackInit = TRUE;	//[41]
BYTE fBdlInit = FALSE;		//[41]

extern BOOL fCapLock, fNumLock;
extern boolean fAccelCmd;
extern BYTE fMono;		//[26] Must have own monochrome flag

extern AX axMouse;		// [45]
extern AY ayMouse;		// [45]

extern SA PASCAL rgsa[];

/*** 
*VOID FARPUBLIC UpdateShiftKk (kkNew, kkOld)
*Purpose:
*	Set Userinterface flags for CAPLOCK and NUMLOCK shift states so that
*	DrawToggles reflects this status properly, and make sure that
*	SCRLOCK changes get a synthesize character to make playback/record
*	screen dumps work properly.
*
*Entry:
*	kkNew		New KK_ shift states.
*	kkOld		Old KK_ shift states.
*
*	fCapLock	flag telling current user interface CAPLOCK status.
*	fNumLock	flag telling current user interface NUMLOCK status.
*
*Exit:
*	fCapLock and fNumLock are set to reflect the shift states in kkNew.
*
*Exceptions:
*	None.
*******************************************************************************/
VOID FARPUBLIC
UpdateShiftKk (kkNew, kkOld)
WORD kkNew, kkOld;
{
    fCapLock = kkNew & KK_CAPLOCK;
    fNumLock = kkNew & KK_NUMLOCK;
    DrawToggles ();

    /* [2] Synthesize VK_SCRLOCK if the shift state changes, so
     * [2] we get screen dumps properly
     */
    kkNew &= KK_SCRLOCK;	/* [4] */
    kkOld &= KK_SCRLOCK;	/* [4] */
    if (kkNew ^ kkOld)
	SynthesizeShiftKeys (kkNew, kkOld);
}


/* [5] Global variable defining the mode we start up in */
WORD iModeCurrent = 0;


/*** 
*void NEAR CwInit ()
*Purpose:
*	Set up screen mode for CW, and initialize window structure.
*
*Entry:
*	None.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
void NEAR CwInit ()
{
    REG1 short i;
    AY ay = 0;
    INST inst;
    extern BYTE fWaitRetrace;	// [23]

    ayMouse = 0;		//[45]
    axMouse = 0;		//[45]

    iModeCurrent = ImodeGuessCurrent ();	/* [5] */

// [12] If the mode is unknown, or we have a flag to get the highest possible
// [12] mode, then loop until we find it.
    if (cmdSwitches & CMD_SW_HIR) {					// [12]
	for (i = 0; FQueryInst (&inst, i); i++) {			// [12]
	    if (inst.finst & finstAvailable) {
		if ((inst.ayMac > ay) ||				// [20]
		    (inst.ayMac == ay && !(inst.finst & finstMonochrome))) { // [20]
		    ay = inst.ayMac;					// [12]
		    iModeCurrent = i;					// [12]
		}
	    }								// [12]
	}								// [12]
    }									// [12]
    if (iModeCurrent == imodeUnknown) { 				// [20]
	ay = 255;		// [26] Set it to be MAXay at start
	for (i = 0; FQueryInst (&inst, i); i++) {			// [20]
	    if (inst.finst & finstAvailable) {				// [20]
		if ((inst.ayMac < ay) ||				// [20]
		    (inst.ayMac == ay && !(inst.finst & finstMonochrome))) { // [20]
		    ay = inst.ayMac;					// [20]
		    iModeCurrent = i;					// [20]
		}							// [20]
	    }								// [20]
	}								// [20]
    }									// [20]
    DbAssert (iModeCurrent != imodeUnknown);

    EnableVidsMonitor (TRUE);	// [38] [39]
    SaveUserScreen ();
    if (!FQueryInst (&inst, iModeCurrent))
	DbAssert (FALSE);
    if (!FInitScreen (&inst))
	DbAssert (FALSE);
    
    DrawDebugScr ();
    fDebugScr = TRUE;

    if ((inst.finst & finstQuestionable) &&	// [23]
	!(cmdSwitches & CMD_SW_GLT))		// [23]
	fWaitRetrace = TRUE;			// [23]

	fInitColorTable ();		// [20]
    // [26] This must follow CwReInit (so fMonochrome is set)
    fMono = (BYTE) (fMonochrome || (cmdSwitches & CMD_SW_MNO));

    // [47] Check for /Editor switch
    if (cmdSwitches & CMD_SW_ED) {
        extern char szWildDefault[];
        extern short iMsgStatusLine;

	strcpy(szWildDefault, "*"); // Default is *.TXT for QEDIT
        iMsgStatusLine = MSG_StatusQEdit;
    }
    WndInit ();
}

/*** 
*void NEAR CwHook ()
*Purpose:
*	Make sure that CW is hooked back in.  This is called when we re-enter
*	the user interface.
*
*Entry:
*	None.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
void NEAR CwHook ()
{
    BackToCow (TRUE);		// [22]
    EnableKeyboard(TRUE);	// [40]Enable keyboard
}

/*** 
*void NEAR CwUnHook ()
*Purpose:
*	Make sure that CW is unhooked.	This is called when we exit the user
*	interface.
*
*Entry:
*	None.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
void NEAR CwUnHook ()
{
    LeaveCow (FALSE);
}

/*** 
*void NEAR CwTerm ()
*Purpose:
*	Terminate CW.  This is called when we are ending the program, or when
*	we shell out.
*
*Entry:
*	None.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
void NEAR CwTerm ()
{
    EnableVidsMonitor (FALSE);	// [38]
    LeaveCow (FALSE);
}

/*** 
*VOID FAR PASCAL OutOfMemory ()
*Purpose:
*	This is called by CW to indicate an out of memory condition.
*
*Entry:
*	None.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
VOID FAR PASCAL
OutOfMemory()
{
    SetUiErrOm ();
}


#define MAX_LOCAL	10 + 2		//[41] Options/Paths + Slop

bd bdlocal[MAX_LOCAL];


/*** 
*VOID ** FAR PASCAL PpvAllocCb (sb, cb)
*Purpose:
*	Return handle to a near memory allocation.
*
*Entry:
*	sb		Unused parameter.
*	cb		Number of bytes to allocate.
*
*	bdlocal is an array of bd's to use to allocate the near memory.
*
*Exit:
*	Returns pointer to bd's pointer to data.
*
*Exceptions:
*	None.
*******************************************************************************/
VOID ** FAR PASCAL
PpvAllocCb (sb, cb)
WORD sb;     /* ignored */
WORD cb;	/* size of block */
{
    bd *pbd = NULL;
    int i;

    Unreferenced (sb);

    for (i = 0; i < MAX_LOCAL; i++) {
	if (bdlocal[i].pb == NULL) {
	    pbd = &bdlocal[i];
	    break;
	}
    }
    DbAssert (pbd != NULL);	//[4] NOTE: when you get this, bump MAX_LOCAL
    if (!BdAlloc (pbd, cb, IT_NO_OWNERS))
	return (NULL);

    return (&(pbd->pb));
}



/*** 
*VOID FAR PASCAL FreePpv (sb, ppv)
*Purpose:
*	Free a handle to near memory.
*
*Entry:
*	sb		Unused parameter.
*	ppv		Pointer to pointer to memory in bd.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
VOID FAR PASCAL
FreePpv (sb, ppv)
/*
  -- free local block (return NULL)
*/
WORD sb;
VOID ** ppv;
{
    bd *pbd = (bd *) (ppv - 1);

    Unreferenced (sb);

    BdFree (pbd);
}


	//[41] If we don't want to have to shrink help down, we must
	//[41] increase MAX_GLOBAL to have 18 extra bdl's for help slop
	//[41] instead of the 11 we have given it.  Doing the compression
	//[41] saves 56 bytes of DGROUP that isn't really needed.
#define MAX_GLOBAL	(3 * 2) + 3 + 3 + 9 + 2		//[41]
			//[41] 3 list boxes at a time @ 2 allocs/box
			//[41] + 3 help file names
			//[41] + 3 help engine FDB's
			//[41] + 9 more for help system (can't always compress)
			//[41] + 2 slop

bdl bdlglobal[MAX_GLOBAL];

/*** 
*HANDLE FAR PASCAL GlobalAlloc (flags, cb)
*Purpose:
*	Allocate a handle to far memory.
*
*	This doesn't return a REAL handle, but GlobalHandle is called to
*	get the segment, so we do the translation ourselves.
*
*Entry:
*	flags		Unused parameter.
*	cb		Number of bytes to allocate.
*
*Exit:
*	Return pointer to bdl's seg.
*
*Exceptions:
*	None.
*******************************************************************************/
HANDLE FAR PASCAL
GlobalAlloc (flags, cb)
WORD flags;
DWORD cb;
{
    int i;
    bdl *pbdl = NULL;

    Unreferenced (flags);

    if (!fBdlInit) {			//[41]
	fBdlInit = TRUE;		//[41]
	for (i = 0; i < MAX_GLOBAL; i++) {
	    bdlglobal[i].seg = NOT_OWNER;
	}
    }
    if (cGlobalAlloc >= MAX_GLOBAL-2)	//[41] if getting close to being full
	ShrinkHelp();			//[41] reduce # of help entries
	//[41] The 2 above is the magic # of items that HelpDecomp allocates
	//[41] Since ShrinkHelp doesn't do anything when called from HelpDecomp,
	//[41] we need to have 2 handles in reserve.

    for (i = 0; i < MAX_GLOBAL; i++) {
	if (bdlglobal[i].seg == NOT_OWNER) {
	    pbdl = &bdlglobal[i];
	    break;
	}
    }
    DbAssert (pbdl != NULL);	//[4] NOTE: when you get this, bump MAX_GLOBAL
    if (!BdlAlloc (pbdl, (WORD) cb))
	return (NULL);

    cGlobalAlloc++;			//[41] one more allocated
    return ((HANDLE) &pbdl->seg);
}

/*** 
*HANDLE FAR PASCAL GlobalFree (hmem)
*Purpose:
*	Free a handle to far memory.
*
*Entry:
*	hmem		Handle to far memory.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
HANDLE FAR PASCAL
GlobalFree (hmem)
HANDLE hmem;
{
    REG1 WORD *h = (WORD *) ((WORD) hmem);
    bdl *pbdl = (bdl *) (h - 1);

    BdlFree (pbdl);

    cGlobalAlloc--;			//[41] one less allocated
    DbAssert (cGlobalAlloc >= 0)	//[41] GlobalFree w/o GlobalAlloc

    return ((HANDLE) NULL);
}


/*** 
*DWORD FAR PASCAL GlobalHandle (hmem)
*Purpose:
*	Called by CW to convert a handle into a DWORD, each WORD of which
*	contains the handle's segment.
*
*Entry:
*	hmem		Handle to far memory.
*
*Exit:
*	Return handle's segment.
*
*Exceptions:
*	None.
*******************************************************************************/
DWORD FAR PASCAL
GlobalHandle (hmem)
HANDLE hmem;
{
    REG1 WORD *h = (WORD *) ((WORD) hmem);
    return ((DWORD) MAKELONG (GETSEG(*h), GETSEG(*h)));
}

/*** 
*HANDLE FAR PASCAL GlobalRealloc (hmem, cb, flags)
*Purpose:
*	Realloc a handle to far memory.
*
*Entry:
*	hmem		Handle to far memory.
*	cb		Number of bytes to reallocate to.
*	flags		Unused parameter.
*
*Exit:
*	Returns reallocated handle.
*
*Exceptions:
*	None.
*******************************************************************************/
HANDLE FAR PASCAL
GlobalRealloc (hmem, cb, flags)
HANDLE hmem;
DWORD cb;
WORD flags;
{
    REG1 WORD *h = (WORD *) ((WORD) hmem);
    bdl *pbdl = (bdl *) (h - 1);

    Unreferenced (flags);

    if (!BdlRealloc (pbdl, (WORD) cb))
	return (NULL);
    return ((HANDLE) &pbdl->seg);
}

/*** 
*VOID NEAR PASCAL DumpScreen ()
*Purpose:
*	Dump the entire screen to disk.
*
*Entry:
*	Description of each formal parameter.
*	Any important global variables used as parameters (implied parameters).
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
VOID NEAR PASCAL
DumpScreen ()
{
    register AY ay;
    WORD pwBuff[80];
    static WORD fdScreen = UNDEFINED;
    static char header[4] = { 2, 0, 0 };
    RRC rrc;

    rrc.rxLeft = 0;
    rrc.rxRight = axMac;
    if (fdScreen == UNDEFINED) {
	fdScreen = CreateFile("screen");
	if (fdScreen == UNDEFINED)
	    return;
	header[3] = ayMac;
	WriteFile (fdScreen, header, 4 );
    }

    for (ay=0; ay < ayMac; ay++) {
	rrc.ryTop = ay;
	rrc.ryBottom = ay+1;
	DbAssert (CwSizeRrc (&rrc) <= 80);
	SaveRrc (NULL, &rrc, (BYTE *) pwBuff);
	WriteFile (fdScreen, (char *) pwBuff, 80 * sizeof (WORD));
    }

    /* Make sure buffer gets flushed right away */
    FlushFile (fdScreen);
}


/*** 
*BOOL FAR PASCAL PlayBackMsg (pmsg)
*Purpose:
*	Try to read input message from playback file.
*
*Entry:
*	pmsg		pointer to structure to contain message read in.
*
*	fRecord 	global flag is TRUE if QB was started with the /rcd
*			flag, and we haven't opened any playback file.
*	fPlayback	global flag is TRUE if we have opened a playback file.
*	fPlaybackInit	static flag is TRUE if we have tried to open a
*			playback file.
*	fdPlayBack	static file descriptor for PlayBackMsg.
*Exit:
*	Returns TRUE if there was a message to be read, otherwise FALSE.
*
*Exceptions:
*	None.
*******************************************************************************/
BOOL FAR PASCAL
PlayBackMsg (pmsg)
MSG *pmsg;
{
    static WORD fdPlayBack = UNDEFINED;

    if (fPlaybackInit) {			//[41]
	fPlaybackInit = FALSE;			//[41]
	if (fRecord) {
	    fdPlayBack = OpenFile ("playback");
	    if (fdPlayBack != UNDEFINED) {
		fPlayBack = TRUE;
		fRecord = FALSE;
	    }
	}
    }

    if (fPlayBack) {
	if (ReadFile (fdPlayBack, (char *) pmsg, sizeof (MSG)) == sizeof (MSG)) {
	    pmsg->time = ClockTicks ();
	    /* [2] Check for VK_SCRLOCK in PlayBackMsg as well as RecordMsg */
	    if (pmsg->message == WM_CHAR && pmsg->wParam == VK_SCRLOCK) {
		DumpScreen ();
	    }
	}
	else {
	    fPlayBack = FALSE;
	    CloseFileNear (fdPlayBack); //[24]
	}
    }

    return (fPlayBack);
}

#define FKeyMsg(x) (((x) >= WM_KEYFIRST) && ((x) <= WM_KEYLAST))
#define FMouseMsg(x) (((x) >= WM_MOUSEFIRST) && ((x) <= WM_MOUSELAST))

/*** 
*VOID NEAR PASCAL RecordMsg (pmsg)
*Purpose:
*	Write the message in pmsg to the record file.
*
*Entry:
*	pmsg		pmsg is a pointer to a message structure to save in
*			the record file.
*
*	fRecord 	global flag is TRUE if QB was started with the /rcd
*			flag, and we haven't opened any playback file.
*	fdRecord	static file descriptor for the record file.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
void FAR PASCAL
RecordMsg(pmsg)
MSG *pmsg;
{
    static WORD fdRecord = UNDEFINED;

    if (fRecord) {
	if (fdRecord == 0xffff)
	    fdRecord = CreateFile ("record");
	if (fdRecord != 0xffff &&
	    (FMouseMsg (pmsg->message) || FKeyMsg (pmsg->message))) {
		/* [2] VK_OEM_SCROLL -> VK_SCRLOCK */
		if (pmsg->message == WM_CHAR && pmsg->wParam == VK_SCRLOCK) {
		    DumpScreen ();
		}
		WriteFile( fdRecord, (char *) pmsg, sizeof(MSG) );
		/* Make sure buffer gets flushed right away */
		FlushFile (fdRecord);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uictl.c ===
/***
*uictl.c - User interface management functions
*
*       Copyright <C> 1985-1988 Microsoft Corporation
*
*Purpose:
*       menu and main window management functions.
*
*******************************************************************************/

/* First, include version definition header */
#include <version.h>

/* Next, include TextWin's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>
#include <uiext.h>

/* Next, include user-interface header */

#ifndef CONTEXT_H
#include <context.h>
#endif

#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef TXTMGR_H
#include <txtmgr.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

#ifndef UINHELP_H
#include <uinhelp.h>
#endif
#include <uihelpid.h>         // definition of help identifiers


#ifndef IBMBASIC
// [QH1] - Binding Escape key to it in Dos6 QHelp
#endif
extern void HelpBack (void);


STATICF(void) ViewOutScrn(void);
STATICF(void) EnsFileRs(void);
void NEAR DoMenu(ushort, ulong);
void NEAR Quit(void);
void NEAR SetDialogTitle(PMENUITEM);
extern void MenuEnable(void);
void NEAR CmdHelpAbout(void);

extern void FAR PASCAL EndMouse(void);
extern bool FAR PASCAL FInitMouse(void);

extern bool   fHelpVisible;
extern bool   fExiting;
extern BYTE   HelpFlags;
extern ushort __acmdseg;
extern ushort __acmdln;
extern ushort __acmdln_orig;

extern unsigned char b_OrgLen;
/* Set by runtime to number of lines visible when QB first came up.
 * Possible values include 25, 43, 60 (others will be added in future).
 * This may be different than the number of lines per screen the
 * first time screen_setup is called, because the user program may
 * execute a SCREEN 1 statement before the user interface code
 * is ever invoked.
 */
extern BYTE fRecord, fPlayBack;
extern boolean fOptionsChanged;

extern WND wnd1, wnd2;     //  needed for WM_RBUTTONDOWN

extern BYTE fBreakOnErr;
boolean fGotCmd;
boolean fAccelCmd;
boolean fGotCmd;
/* TRUE when GetCmd() should return back to UserInterface to execute
   pcode in direct-mode statement buffer */

ushort uierr = 0;
/* 0 = no error needs to be reported by GetCmd,
   UNDEFINED = report error as indicated in txt mgr's txtErr structure,
   else = standard qbi error message code (usually out-of-memory)
   Reset by ReportError()
*/

extern MENUITEM rgMenuItemDebug[];
extern MENUITEM rgMenuItemSearch[];
extern MENUITEM rgMenuItemView[];
extern ushort iHelpId;
extern VOID FAR Help(WORD, WORD, VOID *, WORD);
extern VOID NEAR DoStatusButton(WORD);
char  *szDialogTitle;         //dialog box caption/menu name, or
                              //NULL if we're not to use our own
                              //title
WORD  cbDialogTitle;       //# bytes of szDialogTitle to
                           //display, or 0 if we're not to
                           //truncate it.

char  LQBFiller[17100]; // This reduces the amount of available
                        // DGROUP (FRE ("")) to about 32K for LQB.

BOOL  fQhelpStarting;   // Hack flag for /QHELP; used to prevent edit
                        // from being draw before Help comes up.

/***
*void NEAR GetCmd ()
*Purpose:
*       This is called to interact with the user, allowing him to edit text,
*       select menu options, etc., until some action needs to have pcode
*       executed, at which time, the function returns.  This routine is
*       an event driven state machine.
*
*       If a syntax or runtime error needs to be reported to the user, the
*       global static variable 'uierr' contains an offset into the standard
*       BASIC message table.  If it is UNDEFINED, the error information is
*       contained in the text manager's global structure 'txtErr'.  grs.oRsCur
*       identifies the current text table to be edited.
*
*Entry:
*       None.
*
*Exit:
*       grs.oRsCur may be changed as az result of editing.
*       grs.bdpDirect contains the ASCII source to be executed.
*
*Exceptions:
*       None.
*******************************************************************************/
void NEAR GetCmd()
{
    MSG msgCur;
    extern bool fRightMouseHelp;
    static bool fGreetingBox = TRUE;
    WORD idMsg = 0;
    ClrNonStickyBp ();
    DoStatusMsg(pwndAct);  // draw right status message

    /* This is the main message pump */
    fExiting = (bool)(fGotCmd = FALSE);
    while (!fGotCmd) {
        /* Must call DoDrawDebugScr before AND after ReportError, because
         * ReportError may call DrawDebugScr.
         */
        fAccelCmd = FALSE;

        // Do not paint main window!
        if (fGreetingBox && (cmdSwitches & CMD_SW_QHELP)) {
            fQhelpStarting = TRUE;  // Hack to prevent window drawing
            goto SkipDebugScr;
        }

        DoDrawDebugScr ();
        if (uierr != 0) {
            ReportError ();
            DoDrawDebugScr ();
        }
SkipDebugScr:

// if fGreetingBox not cleared yet, we have easy menus, and the
// we didn't start up with a file, so the current mrs is <UNTITLED>,
// do the greeting box dialog.

        if (fGreetingBox) {
            fGreetingBox = FALSE;

            if (cmdSwitches & CMD_SW_QHELP) { // Go Straight to Help!
                PostMessage (&wndMain, WM_COMMAND, midHelpHelp, 0L);
                goto SkipSetFocus;  // Keep edit window from being drawn
            }

            else {
                UiRsActivateWnd ();      // Make sure proper rs activated
                if (mrsCur.ogNam == OGNAM_UNNAMED) {
                    DoDlgGreetingBox ();
                    CmdFileNew();
                    DoDrawDebugScr();
                    if (fHelpVisible)
                        WndActivate(&wndHelp);
                }
            }
        }

        /* [42] make sure Focus is in pwndAct */
        DbAssert (pwndAct != NULL);
        if (pwndAct->fEnabled)
            SetFocus (pwndAct);
        else
            SetFocus(&wndMain);
SkipSetFocus:

        DbAssert (curHelpFile == 0);  //shouldn't have a help files open

        while (!PeekMessage (&msgCur)) {
            fPollKeyboard = TRUE;
            if (fGotCmd)
                goto ExitCmd;
            else if (fAccelCmd)
                goto ContinueCmd;
        }
        if (fGotCmd)
            goto ExitCmd;

#ifndef IBMBASIC
// [QH1] - Dos6 QHelp - Single click now activates hot-link button
#endif
        if ((cmdSwitches & CMD_SW_QHELP)     &&
            (msgCur.message == WM_LBUTTONUP) &&
            (msgCur.pwnd == &wndHelp))
            PostMessage (&wndHelp, WM_LBUTTONDBLCLK, msgCur.wParam, msgCur.lParam);

#ifndef IBMBASIC
// [QH1]
//    Disable right-mouse-button if in QHelp mode.  Left-mouse now
//    selects hotlinks, as per CUA.  Since F1 always brings up HelpOnHelp
//    now, right-mouse doesn't have a function anymore in QHelp.
//
#endif
        if (!(cmdSwitches & CMD_SW_QHELP))
        {
            if (msgCur.message == WM_RBUTTONDOWN
              || msgCur.message == WM_RBUTTONDBLCLK) {
                /*
                    All right button actions are equivalent
                    to an unshifted left mouse click followed
                    by an additional action.
                */
                msgCur.message += WM_LBUTTONDOWN - WM_RBUTTONDOWN;
                msgCur.wParam &= !MK_SHIFT;
            }
            else if (msgCur.message == WM_RBUTTONUP) {
                msgCur.message = WM_LBUTTONUP;

   //  Only do the translation if we are in a non-immediate edit window
   //  Allow right mouse help in help window
                if (msgCur.pwnd == &wnd1 || msgCur.pwnd == &wnd2
                  || msgCur.pwnd == &wndHelp || msgCur.pwnd == &wndCmd) {
                    EditMgrFlush();
                    uierr = 0;
                    if (fRightMouseHelp)
                        idMsg = midHelpSyntax;
                    else
                        if (msgCur.pwnd == &wnd1 || msgCur.pwnd == &wnd2)
                            idMsg = midGoUntilCursor;
                    if (idMsg)
                        PostMessage (&wndMain, WM_COMMAND, idMsg, 0L);
                }
            }
        }

    /* Move FilterSpecialMessages into Accelerator table in uirsrcc.c
     * leaving only carriage returns to handle.
     * Check for the F1 key.  If it has been hit, call the help system
     */

        if (msgCur.message == WM_CHAR) {
            if (msgCur.wParam == VK_HELP_KEY) {
                EditMgrFlush();
                uierr = 0;
                Help(hemAllWindow, 0, 0, HIWORD(msgCur.lParam));
                goto ContinueCmd;
            }
            if (msgCur.wParam == '\x0d' && CmdEnter())
                goto ContinueCmd;
// Check for ESC here, because accelerator catches it too often.
            if (msgCur.wParam == (VK_ESCAPE - VK_MIN) && fHelpVisible) {

#ifndef IBMBASIC
//
// [QH1] - Have the escape key go back to last topic
//
// (Old code):
#if 0
                // Esc does not cancel help for QHELP, does for EDIT/QBASIC
                if (!(cmdSwitches & CMD_SW_QHELP))
                {
                    CmdHelpClose ();
                }
#endif
#endif
                if (cmdSwitches & CMD_SW_QHELP)
                    HelpBack();
                else
                    CmdHelpClose ();

                goto ContinueCmd;
            }
        }
        DispatchMessage (&msgCur);

ContinueCmd:;
    } /* while */

ExitCmd:
/* make sure next SetFocus (pwndAct) reload ldCur, as DoCmd uses this buffer */
    if (!fExiting)
        SetFocus (&wndMain);
} /* GetCmd */

/***
*void NEAR WaitForEvent ()
*Purpose:
*       Wait until a CW event occurs.  Legal events are non-ALT shifted
*       characters, and left mouse clicks.
*
*Entry:
*       None.
*
*Exit:
*       None.
*
*Exceptions:
*       None.
*******************************************************************************/
void NEAR
WaitForEvent ()
{
    MSG msgCur;

    while (TRUE) {
        if (PeekMessage (&msgCur)) {
            if ((msgCur.message == WM_CHAR &&
              !(HIWORD(msgCur.lParam) & KK_ALT)) ||
              msgCur.message == WM_LBUTTONDOWN ||
              msgCur.message == WM_LBUTTONDBLCLK)
                break;
        }
    }
}

/***
*void NEAR FlushMsgs ()
*Purpose:
*  Flush all message that are in the message queue if we aren't
*  doing record or playback.
*
*Entry:
*  None.
*
*Exit:
*  None.
*
*Exceptions:
*  None.
*******************************************************************************/
void NEAR
FlushMsgs ()
{
    MSG msgCur;
    BOOL  fMenuState;

    if (fRecord || fPlayBack)
        return;

    fMenuState = FEnableMenuBar (FALSE);    // disable menu bar so
                                            // accelerators won't work
                                            // during PeekMessage
    while (PeekMessage (&msgCur)) ;
    FEnableMenuBar (fMenuState);            // restore original state
}

/***
*STATICF(void) ViewOutScrn ()
*Purpose:
*       Make the output screen visible until the user clicks the mouse or
*       presses a key.
*
*Entry:
*       None.
*
*Exit:
*       None.
*
*Exceptions:
*       None.
*******************************************************************************/
STATICF(void)
ViewOutScrn ()
{
    FEnableMouse(FALSE);
    FEnableMenuBar (FALSE);
    FlushMsgs ();

    RestoreUserScreen ();
    fDebugScr = FALSE;
    WaitForEvent ();
    SaveUserScreen ();
    fDebugScr = TRUE;

    FlushMsgs ();
    DrawDebugScr ();
    /*
     * Changing screen modes effects the mouse.
     * Turn it off, and re-initialise.
     */
    EndMouse();
    FInitMouse();
    FEnableMouse(TRUE);
}

/***
*STATICF(void) EnsFileRs ()
*Purpose:
*       If active window is the command window, activate a register set
*       for the top list window.
*
*       This is called when File/Save is selected.
*
*Entry:
*       pwndTop points to the top window.
*
*Exit:
*       None.
*
*Exceptions:
*       None.
*******************************************************************************/
STATICF(void)
EnsFileRs ()
{
    struct ef *pef;

    if (pwndAct == &wndCmd || pwndAct == &wndHelp) {
        if (pwndFull) {
            WndNoFullScreen ();
            DoDrawDebugScr ();
        }
        DbAssert(pwndTop != &wndHelp);
        DbAssert(pwndTop != NULL);
        DbAssert(pwndTop != &wndCmd);
        pef = (struct ef *) pwndTop->pefExtra;
        UiRsActivate (pef->hBuffer);
    }
}

/* Make MenuBarMain, rgMenuMain accessible */
extern MENUBAR MenuBarMain;
extern MENU rgMenuMain[];

/***
*void NEAR DoMenu (menuId, lParam)
*Purpose:
*       A menu item has been selected, take appropriate action.
*
*Entry:
*       menuId      ID of menu to perform action of.
*       lParam      lParam of WM_COMMAND message from menu selection.
*
*Exit:
*       None.
*
*Exceptions:
*       None.
*******************************************************************************/
void NEAR DoMenu (menuId, lParam)
REG1 ushort menuId;
ulong lParam;
{
    static ushort editMsg[] = { WM_UNDO, WM_CUT, WM_COPY, WM_CLEAR, WM_PASTE };


    if (menuId == EN_CURSORMOVED) {
        DrawStatusLine();  // update status line with new cursor pos
        return;     /* all we want do do is update status message */
    }
    if ((menuId == midRunStart) ||
      (menuId == midRunRestart) ||
      (menuId == midFileNew) ||
      (menuId == midFileCreate) ||
      (menuId == midFileOpen) ||
      (menuId == midFileLoad) ||
      (menuId == midFileExit)) {
        /* so we won't put up a pointless AskCantCont dialog box.
         * The reason FILE/OPEN, FILE/LOAD and FILE/CREATE are on the
         * list is because New Module or Include cause variable table allocation,
         * and thus, prevent continuing.
         */
        CantCont();
    }

    if (menuId == midSearchChange) {
        if (!AskCantCONT()) {
            /* changes may prevent CONTinue, ask while we can still back out.
             * We do it here rather than in CmdSearchChange() because AskCantCONT
             * can cause the output screen to be shown (because of RunInit())
             */
            return;   /* user wants to abort action */
        }
    }

    if ((menuId < miEditBase || menuId > midEditPaste) &&
      menuId != midEditCut2 && menuId != midEditClear2) {
        /* Update editor's dirty line (if any).
         * Since SaveFile(), and other functions, uses same buffer
         * that editor uses, we must force edit mgr to purge its cache */
        switch(menuId) {
            case midFileSave:
            case midFileSaveAs:
            case midFileNew:
            case midViewSubs:
                /* These menu functions alter ps.bdpSrc, which edit mgr
                 * also uses to keep its current line in.  EditMgrFlush1
                 * tells edit mgr to forget that ps.bdpSrc contains the
                 * current cached line
                 *
                 * midViewSubs does not modify ps.bdpSrc, but it can change
                 * the text tables (by deleting them) and the edit manager
                 * will think the non-dirty line it has is still valid.
                 */
                EditMgrFlush1 ();
                break;

            default:
                /* All other menu functions need edit mgr to flush its current
                 * cached line (in ps.bdpSrc) to the current text table (i.e.
                 * call ReplaceLineBuf if the current line is modified).
                 * EditMgrFlush does this. */
                EditMgrFlush ();
                break;

        }
        uierr = 0;
    }

    // Avoid drawing edit window if /QHELP is starting
    if (!fQhelpStarting)
        DoDrawDebugScr ();

    /* calling EditMgrFlush, AskCantCONT or CantCont can cause the
     * output screen to be shown (because of RunInit()), in which case,
     * we need to re-draw the list windows now.
     */

    /* load mrsCur, prsCur, txdCur with active window's info */
    UiRsActivateWnd();

    /* If any of the following change, editMsg[] needs to be updated */
    DbAssert (midEditCut - midEditUndo == 1);
    DbAssert (midEditCopy - midEditUndo == 2);
    DbAssert (midEditClear - midEditUndo == 3);
    DbAssert (midEditPaste - midEditUndo == 4);

    if ((menuId >= midEditUndo) && (menuId <= midEditPaste)) {
        SendMessage (pwndAct, editMsg[menuId - midEditUndo], 0, 0L);
    }
    else {
        SetDialogTitle((PMENUITEM)(LOWORD (lParam)));   // set box title
        DbAssert (curHelpFile == 0);        // Shouldn't have help file open
                                            // on entry
        switch (menuId) {

            case midHelpAbout:
                CmdHelpAbout();
                break;

            case midHelpHowToUse:       // QHELP Help.How To Use...
                Help(hemWindowHid,helpHowToUseId,0,0);
                break;

            case midHelpKeyboard:
                Help(hemWindowHid,helpKeyboardId,0,0);
                break;

            case midHelpStarted:
                Help(hemWindowHid,helpStartedId,0,0);
                break;

            case midHelpIndex:
                Help(hemWindowHid,helpIndexId,0,0);
                break;

            case midHelpTable:
                Help(hemWindowHid,helpTableId,0,0);
                break;

            case midHelpSyntax:
                Help(hemAllWindow, 0, 0, 0); //  same as F1
                break;

            case midHelpHelp:                       // [QH1]
                Help(hemAllWindow, 0, 0, KK_SHIFT);         // same as SHIFT-F1
                if (cmdSwitches & CMD_SW_QHELP)
                {
                    if ((HelpFlags & HLP_FAILFNF) || (HelpFlags & HLP_FAILOOM))
                    {   //
                        // If HELP.HLP not found, or out-of-memory, then exit.
                        //
                        CmdFileExit();
                    }
                    else if (fQhelpStarting)
                    {
                        fQhelpStarting = FALSE; // Done with hack
                        WndActivate(&wndHelp);  // Make sure Help window has focus
                    }
                }
                break;

            case midHelpBack:
                SendHelpMsg(WM_HELPBACK,0);
                break;

            case midHelpNext:
                SendHelpMsg(WM_HELPNEXT,0);
                break;


            case midHelpClose:
                CmdHelpClose ();
                break;

            case midFileNew:
                CmdFileNew ();
                break;

            case midFileOpen:
                CmdFileOpen ();
                break;


            case midFileSave:
                EnsFileRs ();
                CmdFileSave ();
                break;

            case midFileSaveAs:
                EnsFileRs ();
                CmdFileSaveAs ();
                break;


            case midFilePrint:
                CmdFilePrint ();
                break;


            case midFileExitQH:
            case midFileExit:
                CmdFileExit ();
                break;

            case midEditClear2:
                /*
                    midEditClear is tied to the menu item. It will not be
                    sent when the menu item is not enabled (i.e. no selection).
                    midEditClear is tied to the DEL key (it is always enabled).
                    EditMgr will distinguish between need to Cut or Del based
                    on existence of selected text.
                */
                SendMessage (pwndAct, WM_CLEAR, 0, 0L);
                break;

            case midEditCut2:
                /*
                    midEditCut is tied to the menu item. It will not be
                    sent when the menu item is not enabled (i.e. no selection).
                    midEditCut2 is tied to the SHIFT+DEL key (it is always enabled).
                    EditMgr will distinguish between need to Cut or Del based
                    on existence of selected text.
                */
                SendMessage (pwndAct, WM_CUT, 0, 0L);
                break;

            case midEditNewSub:
                CmdNewProc (RS_sub);
                break;

            case midEditNewFunc:
                CmdNewProc (RS_function);
                break;

/* keep this for KANJI versions */

            case midViewSubs:
                // Could be invoked from status line, so title set above would
                // be wrong.   Simplest just to always set dialog box title to
                // the proper string.
                DbAssert (rgMenuItemView[0].idItem == midViewSubs);
                SetDialogTitle(&rgMenuItemView[0]);      // set proper title
                CmdViewSubs();
                break;

            case midViewSplit:
                WndSplit();
                break;


            case midViewOutScrn:
                ViewOutScrn ();
                break;


/* keep this for KANJI versions. */


            case midSearchFind:
                CmdSearchFind (TRUE, TRUE, FALSE);
                break;


            case midSearchNext:
                CmdSearchFind (FALSE, FALSE, FALSE);
                break;

            case midSearchChange:
                CmdSearchChange ();
                break;

            case midRunStart:
                CmdGo (TRUE);
                break;

            case midRunRestart:
                CmdRestart ();
                break;

            case midRunContinue:
                CmdGo (FALSE);
                break;


            case midDebugTraceOn:
                fTraceOn = (bool) !fTraceOn;   /* toggle TRACE mode */
                break;


            case midDebugClearAllBp:
                ClrBpAll ();
                DrawDebugScr ();
                break;

            case midDebugSetNextStmt:
                CmdSetNextStmt ();
                break;

            case midDebugToggleBp:
                CmdToggleBp ();
                break;


            case midOptnsDisplay:
                CmdOptnsDisplay ();
                break;

            case midOptnsPaths:
                CmdOptnsPaths ();
                break;


            case midOptnsSyntax:
                fSyntaxCheck = (bool) !fSyntaxCheck;   /* toggle Syntax Checking */
                fOptionsChanged = TRUE;
                break;

            case midStep:
                CmdStep (FALSE);
                break;

            case midPStep:
                CmdStep (TRUE);
                break;


            case midGoUntilCursor:
                CmdGoUntilHere ();
                break;

            case midNextWindow:
                ViewNext ();
                break;

            case midPreviousWindow:
                ViewPrev ();
                break;

            case midViewNextProc:
                WndAssignNext (FALSE);
                break;

            case midViewPrevProc:
                WndAssignNext (TRUE);
                break;

/*  Since Accelerator keys will now handle ALT/? characters, add these
/*  to the list of cases to handle.
 */
            case midWndGrow:
                WndGrow ();
                break;

            case midWndShrink:
                WndShrink ();
                break;

/* Used to be System items */
            case midWndRestore:
                WndNoFullScreen ();
                break;

            case midWndMaximize:
                ViewFull ();
                break;
            case midEnter:
                CmdEnter();
                break;

        } /* switch */
        szDialogTitle = NULL;               // no title to print
        DbAssert (curHelpFile == 0);        // Shouldn't have help file open
                                            // on exit
    } /* if */
} /* DoMenu */


/***
*WORD FAR MainWndProc (pwnd, msg, wParam, lParam)
*Purpose:
*  This routine processes messages for the main window.
*
*Entry:
*  pwnd     window the message is for.
*  msg      message.
*  wParam      word parameter.
*  lParam      long parameter.
*
*Exit:
*      returns FALSE.
*
*Exceptions:
*  None.
*******************************************************************************/
WORD FAR
MainWndProc (pwnd, msg, wParam, lParam)
PWND pwnd;
WORD msg, wParam;
DWORD lParam;
{
    BYTE ax, ay;

    Unreferenced (pwnd);

    if (!fDebugScr) {
        fAccelCmd = TRUE;
        return (0);
    }

    if (msg >= WM_MOUSEFIRST && msg <= WM_MOUSELAST) {
        ax = LOBYTE (HIWORD (lParam));
        ay = HIBYTE (HIWORD (lParam));
        DoCaption (msg, ax, ay);
        return (0);
    }

    switch (msg) {

        case WM_PAINT:
            DrawCaptions ();
            break;

        case WM_VSCROLL:
        case WM_HSCROLL:
            EditWndProc (pwndAct, msg, wParam, lParam);
            break;

        case WM_INITMENUPOPUP:
            MenuEnable();               //  rewrote in asm to reduce size

            KeywordHelpLookup();        //  set up keyword if we have one
            break;

        case WM_MENUSELECT:


            switch (HIWORD(lParam)) {
                case 0:                 // menu item
                    if (wParam == 0) {  // termination
                        DoStatusMsg(pwndAct);   // draw right status message
                        goto StatusMsgShown; // get out of here
                    }
                    else    // display help on selected menu item on status line
                        wParam = wParam - midFileNew + MSG_HelpFileNew;
                    break;
                case 2:     // menu bar
                    wParam = MSG_StatusMenu;  //  display menu bar help
                    break;
            }

            iHelpId = wParam;
            StatusLineMsg (wParam);
StatusMsgShown:
            break;

        case WM_SEARCHFIND:
            wParam = midSearchFind;
            goto DoCmd;

        case WM_SEARCHCHANGE:
            wParam = midSearchChange;
DoCmd:
        case WM_COMMAND:
            DoStatusMsg(pwndAct);  // draw right status line message
            DoMenu (wParam, lParam);
            fAccelCmd = TRUE;
            break;

        case WM_SETBOOKMARK:
            SetBookMark (wParam - '0');
            break;
        case WM_GOTOBOOKMARK:
            GotoBookMark (wParam - '0');
            break;

    } /* switch (msg) */

    return (0);
} /* MainWndProc */

/***
*void NEAR Quit ()
*Purpose:
*  Post quit message to root.
*
*Entry:
*  None.
*
*Exit:
*  None.
*
*Exceptions:
*  None.
*******************************************************************************/
void NEAR Quit ()
{
    PostMessage (NULL, WM_QUIT, 0, 0L);
}


/***
*void NEAR SetDialogTitle ()
*Purpose:
*
*  Sets the dialog box title string from a given menu item.
*
*Entry:
*  pMenuItem = *menu item struture for dialog box we are to display.
*
*Exit:
*  szDialogTitle and cbDialogTitle are updated.
*
*Exceptions:
*  None.
*******************************************************************************/
void NEAR SetDialogTitle (pMenuItem)
PMENUITEM pMenuItem;
{
    if (pMenuItem) {
        szDialogTitle = pMenuItem->CC_USZ.szItem; // set dialog box title
        cbDialogTitle = pMenuItem->wParamUser;    // set # chars to show
    } else
        szDialogTitle = NULL;      // no title to print if null pointer
               // (just to be safe)
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uiedit.asm ===
TITLE	uiedit.asm - Misc user interface functions.
;*** 
;uiedit.asm
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	Interface between CW and parsing code.
;
;
;*******************************************************************************

	.xlist
	include version.inc
	UIEDIT_ASM = ON	
	CONTEXT_NOFUNCS = ON

	include cw/version.inc
	include cw/windows.inc
	include cw/edityp.inc

	IncludeOnce architec
	IncludeOnce context
	IncludeOnce lister
	IncludeOnce heap
	IncludeOnce parser
	IncludeOnce pcode
	IncludeOnce qbimsgs
	IncludeOnce rtps
	IncludeOnce txtmgr
	IncludeOnce ui
	IncludeOnce uiint
	IncludeOnce uinhelp	
	IncludeOnce util
	IncludeOnce edit	

	.list

assumes	DS,DATA
assumes	SS,DATA
assumes	ES,NOTHING


;-------------------------------------------------------------------------
;		DATA Segment Declarations
;-------------------------------------------------------------------------
sBegin	DATA

; oRs of 'command window'
	globalW	hbufOfCmd,UNDEFINED

; oRs of 'scrap' used as temporary buffer
; for Cut/Copy/Paste operations
	globalW	hbufOfScrap,UNDEFINED

; since we list one line after another when refreshing the content
; of a window, these static variables are used to remember where the
; pcode offset for the next line to be listed.  It saves us from
; having to search pcode for the nth line.  It must be discarded
; whenever text changes, or another text table is activated.
	staticW	otxLnLast,0
	staticW	otxGetNext,0
	staticW	lnGetNext,0
	staticW	saveLnGetNext,0
	staticW	saveOtxGetNext,0
	staticW	saveRsCur,UNDEFINED

; The number of the last line entered in the command windows is kept here.
; For error reporting.
	staticW	lnCmdLast,0

; Set to TRUE when a command in the parse buffer should be executed.
	globalW	fDoCmd,0

; Set to TRUE when we have an error that may need the box to be repositioned
; depending upon where the cursor position is (see uimsgbox.c)
	globalB fAdjustMsgBox,0

;cbGetLineBuf sets the following two words for LineAttr
	staticW	colStmtStart,0
	staticW	colStmtEnd,0
	staticB fWndHelp,0

; rgLineAttr is used in GetLineAttrs
	public rgLineAttr
rgLineAttr	label	word
rgLineAttr0	db	size LINEATTR dup(?)
rgLineAttr1	db	size LINEATTR dup(?)
rgLineAttr2	db	size LINEATTR dup(?)
rgLineAttr3	db	size LINEATTR dup(?)


;BOOKMARKS:
;	Each bookmark is specified in the following structure.	Different
;	fields are UNDEFINED (-1) to indicate different conditions or
;	situation with the bookmark
;
;	if BM_oRs == UNDEFINED
;	    bookmark is invalid
;
;	if BM_Nc == NOT_HELPTOPIC
;	    BM_oRs = register set for non-help window
;	    BM_oln = line number in the window
;	    BM_col = column number in the window
;	else if BM_oln == UNDEFINED && FV_VARHELP
;	    BM_oRs = register set of variable help item
;	    BM_Nc  = oName of variable help item
;	    BM_col = column number in the window
;	else
;	    BM_Nc:BM_oRs = context number of help item
;	    BM_oln = line number in the window
;	    BM_col = column number in the window
;
;NOTE:	it is Nc:oRs for help engine help but  oRs:Nc for Variable help
;	(so that we can deallocate based on the oRs).

BookMark struc
BM_Nc		dw   UNDEFINED	; oRs for non-help window.  Otherwise,
BM_oRs		dw   UNDEFINED
BM_oln		dw	0
BM_col		dw	0
BookMark ends

.errnz	(-1) - (UNDEFINED)

NOT_HELPTOPIC	equ	UNDEFINED
MAXBOOKMARK	equ	4

BookMarks	BookMark	MAXBOOKMARK dup(<>)

psSaveLen	dw	0
psSaveChar	db	0
;
; ldEMScratch is used by TWIN's EditMgr.
; Since we want is to be a movable heap entry, the structure overlaps a bd.
;
	public	ldEMScratch
	public	bdEMScratch
	.errnz	(size ld) - 8
	.errnz	(size bd) - 6
ldEMScratch	dw	0	; ld.flags           ---+
		dw	0	; ld.cb                 |--------- ld structure
bdEMScratch	dw	0	; ld.cbMax/bd.cbLogical | ----+
		dw	0	; ld.prgch/bd.pb     ---+     |--- bd Structure
		dw	0	; bd.cbPhysical      ---------+

	;next 4 locations are used to construct special dialog for
	;runtime errors in compiled code (in ReportError()).
	
	EXTRN	b$fCompErr:word	;non-zero if error was in compiled code
	EXTRN	b$ErrLin:word		;line # of last runtime error (ERL)
	EXTRN	b$ErrMod:dword		;far ptr to 0-terminated module name
	EXTRN	b$ErrAdr:dword		;far ptr where runtime call was made
	EXTRN	b$ErrInfo:byte		;extended error code

	EXTRN	iHelpId:word	
	externB HelpFlags	

sEnd	DATA


sBegin UI
assumes CS,UI

	externNP WndHelpOpen		; Open help window to a given size
	externNP DisplayHelpOOM 	

;Extended out-of-memory error messages.
; Moved FAR to save DGROUP
twExtOmErr LABEL WORD
	dw	ER_OM				;"Out of memory"
	dw	MSG_OutNearMem			;"Out of data space"
	dw	ER_OM				;"Out of memory"
	dw	MSG_OutOfStack			;"Out of stack space"
	dw	MSG_ProcTooLarge		;"Procedure too large"
	dw	MSG_ModTooLarge			;"Module level code too large"
	dw	MSG_InclTooLarge		;"Include file too large"
	dw	MSG_DocTooLarge			;"Document too large"
	.errnz	OMErr_OM  -0	;generic OM error
	.errnz	OMErr_NH  -1	;out of near heap space ( DS > 64k )
	.errnz	OMErr_FH  -2	;out or far heap space	( out of system memory )
	.errnz	OMErr_STK -3	;out of stack space
	.errnz	OMErr_Proc-4	;out of Procedure text table space ( > 64k )
	.errnz	OMErr_Mod -5	;out of Module text table space ( > 64k )
	.errnz	OMErr_Inc -6	;out of Include file text table space ( > 64k )
	.errnz	OMErr_Doc -7	;out of Document file text table space ( > 64k )

;**************************************************************************
; EditMgrFlush
; Purpose:
;	Flush the current line out of the editor's internal buffer if
;	it is dirty.
;	Since replacing the line could cause a procedure to be renamed
;	which gives it a different oRs, this routine does not preserve
;	grs.oRsCur (and the caller shouldn't either).  The reason
;	the oRs of the procedure needs to change is because there
;	may be references to the old prs in pcode, so the old prs has
;	to stay.
; EditMgrFlush1 has same entry conditions and purpose, only it
;	flushes the edit mgr's buffer even if edit mgr's buffer isn't dirty.
;	This is used when:
;	 [1] window allocation changes on the screen, so the edit mgr
;	     forces the cursor within the current window.
;	 [2] when QB is going to use the edit mgr's buffer for its own
;	     purposes, so it doesn't want subsequent edit mgr calls
;	     to think what it has cached in this buffer represents its
;	     current line.
; Exit:
;	ReplaceLineBuf will be called if line was dirty, which can
;	   modify ps.bdpSrc among other things...
;	Active window's oRs is active.
;
;**************************************************************************
PUBLIC	EditMgrFlush, EditMgrFlush1
EditMgrFlush1 PROC NEAR
	sub	cx,cx
	SKIP2_PSW
EditMgrFlush1 ENDP
EditMgrFlush PROC NEAR
	mov	cl,1

	DbAssertRel [pwndAct],ne,0,UI,<EditMgrFlush: pwndAct=NULL> 

; brif we're to do it even if no dirty buffer (it causes editmgr
; to force the cursor within the current window).
	jcxz	EfFlushFocus

	;While edit mgr is active, it has local copy of ldFlags.
	DbAssertTst [emFlags],e,EMF_IN_EDITMGR,UI,<EditMgrFlush: EditMgr active>

	mov	bx,[pwndAct]		
	mov	bx,[bx.pefExtra]	
	mov	bx,[bx.EF_pldCur]
	test	[bx.LD_flags],LD_fDirty	;test fDirty flag in window's structure
	je	EfExit			;brif not dirty (speed optimization)
EfFlushFocus:
	cCall	FlushFocus
SkipFocus:
	cCall	UiRsActivateWnd 	;activate active window's oRs
EfExit:
	ret
EditMgrFlush ENDP

cProc	FlushFocus,<NEAR>,<si>
cBegin
	mov	si,[pwndAct]
	mov	bx,WM_FLUSHFOCUS	; New EditMgr message
	sub	cx,cx
	cCall	SendMessage,<si,bx,cx,cx,cx>
cEnd

;**************************************************************************
; void FAR UiFlushCache()
; Purpose:
;  Called by text manager whenever text is changed, or cached text offsets
;  become invalid for any other reason.
;  Also called every time a context change occurs.
;  It resets any variables which speed performance by assuming we're
;  in the same context we were the last time the variables were set.
;  We flush our cache so we don't look at invalid data.
;
; Entry:
;  none
;
; Exit:
;  lnGetNext = 0
;
;**************************************************************************
cProc	UiFlushCache,<PUBLIC,FAR>
cBegin
	mov	[lnGetNext],0		;Clear cache
cEnd

;**************************************************************************
; void KludgePs()
; Purpose:
;  Null terminates ps.bdpSrc.pb and saves info to restore it
;  later via UnKludgePs.
;
; Entry:
;   [ps.bdpSrc.pb]
;   cx - length of string at ps.bdpSrc.pb
; Exit:
;   [psSaveLen]
;   [psSaveChar]
;
;**************************************************************************
cProc KludgePs,<NEAR>
cBegin
	mov	bx,[ps.PS_bdpSrc.BDP_pb]
	add	bx,cx
	xor	al,al
	xchg	al,[bx]
	mov	[psSaveChar],al
	mov	[psSaveLen],cx
cEnd

;**************************************************************************
; void UnKludgePs()
; Purpose:
;  Reverses effects of KludgePs.
;
; Entry:
;   [ps.bdpSrc.pb]
;   [psSaveLen]
;   [psSaveChar]
; Exit:
;   ps.bdpSrc.pb is restored to state before KludgePs
;
;**************************************************************************
cProc UnKludgePs,<NEAR>
cBegin
	mov	bx,[ps.PS_bdpSrc.BDP_pb]
	add	bx,[psSaveLen]
	mov	al,[psSaveChar]
	mov	[bx],al
cEnd

;**************************************************************************
; void near UpdAltListWnd(ax=lnTop, dx=delta)
; Purpose:
;	Update the alternate-list-window if 2 list windows are active
;	and both refering to the same text table.
; Entry:
;	ax=lnTop is the top line affected by the edit
;	dx=delta is the number of lines inserted or deleted
;	For example: inserting 1 line after line 0: lnTop=0, delta=1
;	             deleting 1 line after line 0: lnTop=0, delta=-1
;	             replacing line 5: lnTop=5, delta=0
;
;**************************************************************************
DbPub UpdAltListWnd
cProc	UpdAltListWnd,<NEAR>
cBegin
	cmp	[fWndSplit], 0		
	je	UAltExit		
	mov	bx, DATAOffset wnd1	
	cmp	bx, [pwndAct]		
	jne	@f			
	mov	bx, DATAOffset wnd2	
@@:					
	mov	bx,[bx.pefExtra]	
	mov	cx,[grs.GRS_oRsCur]
	cmp	cx,[bx.EF_hBuffer]
	jne	UAltExit		;brif both don't refer to same txt tbl
	or	dx,dx
	jns	NotDel			;brif lines are not being deleted
	mov	cx,ax			;cx = lnTop
	sub	cx,dx			;cx = 1st line above deleted lines
	cmp	cx,[bx.EF_pdCur.pd_olntop]
	jbe	NotDel			;brif entire delete is below window top
	mov	dx,ax			;cx = lnTop
	sub	dx,[bx.EF_pdCur.pd_olntop]
					;dx = -#lines deleted below window top
NotDel:
	cmp	ax,[bx.EF_pdCur.pd_olntop]
	jae	UAltNoChg		;brif top line is unaffected by edit
	add	[bx.EF_pdCur.pd_olntop],dx
UAltNoChg:
	call	DrawDebugScr		;sledge hammer ok for uncommon state
UAltExit:
cEnd

;**************************************************************************
; void near ActivateHbuf
; Purpose:
;  Tell the context manager to make the module/procedure associated with
;  the list window identified by hbuf active.
;
; Algorithm:
;	If hbuf is not already active
;	   if hbuf is for scrap
;	      saved = current
;	   else if hbuf <> saved
;	      saved = undefined
;	   Activate hbuf
;	   if hbuf = saved
;	      current = saved
;	      saved = undefined
; Entry:
;  BX = hbuf - is the handle for a text table.
;       It is really an oRs (see context.h) for the text table .
;
; Exit:
;  The text table associated with hbuf is activated.
;
;**************************************************************************
cProc	ActivateHbuf,<NEAR>
cBegin
	DbAssertRel bx,ne,UNDEFINED,UI,<ActivateHbuf(UNDEFINED)>
	mov	[grs.GRS_fDirect],FALSE
	cmp	bx,[grs.GRS_oRsCur]
	je	AHB_End 		;brif hbuf is already active
					;This optimization is important,
					;because UiRsActivate calls UiFlushCache
					;which zeros lnGetNext, which is used
					;to speed up cbGetLine.

	;Now we do a speed optimization for CUT and COPY so cbGetLineBuf
	;can be fast even though we are swapping a user's and scrap's text
	;tables on a per-line basis.
	
	cmp	bx,[hbufOfScrap]
	jne	NotScrap1		;brif not activating the scrap
	mov	ax,[lnGetNext]		;save cached variables used to
	mov	[saveLnGetNext],ax	; make cbGetLineBuf fast
	mov	ax,[otxGetNext]
	mov	[saveOtxGetNext],ax
	mov	ax,[grs.GRS_oRsCur]
	mov	[saveRsCur],ax
	jmp	SHORT NotScrap2

NotScrap1:
	cmp	bx,[saveRsCur]
	je	NotScrap2		;brif activating rs other than scrap
	mov	[saveRsCur],UNDEFINED	; or saveRsCur - end of Cut/Copy/Paste
NotScrap2:
	cCall	UiRsActivate,<bx>
	mov	ax,[grs.GRS_oRsCur]
	cmp	ax,[saveRsCur]
	jne	NotScrap3		;brif not activating rs which was active
					; before scrap was last activated.
	mov	ax,[saveLnGetNext]	;restore cached variables that make
	mov	[lnGetNext],ax		; cbGetLineBuf fast
	mov	ax,[saveOtxGetNext]
	mov	[otxGetNext],ax
	mov	[saveRsCur],UNDEFINED
NotScrap3:
AHB_End:
cEnd

;**************************************************************************
; ModifyingHbuf
; Purpose:
;	Same as ActivateHbuf but also does TxtModified
;
; Entry:
;	BX = hbuf - is the handle for a list window (an oRs).
;
; Exit:
;	The text table associated with hbuf is activated and descanned.
;
;**************************************************************************
ModifyAndGrab PROC NEAR
	cmp	bx,[hbufOfCmd]
	je	ModifyingHbuf		;brif edit is in Command Window
					; user should be able to type
					; CLEAR even if he's low on memory
	push	bx
	call	UiGrabSpace		;don't let user enter such a long
					; program that he can't even execute
					; a CLEAR statement.
	pop	bx
ModifyAndGrab ENDP
	;fall into ModifyingHbuf
ModifyingHbuf PROC NEAR
	call	ActivateHbuf		;activate oRs [bx]
	cCall	TxtModified		;remember to save this file
MhExit:
	ret
ModifyingHbuf ENDP

;**************************************************************************
;UnGrab
;Purpose:
;	Release space allocated by ModifyAndGrab
;Entry:
;	ax = hbuf (space not released if hbufOfCmd)
;
;**************************************************************************
UnGrab	PROC NEAR
	cmp	ax,[hbufOfCmd]
	je	NotGrabbed		;brif edit is in Command Window
	call	UiReleaseSpace
NotGrabbed:
	ret
UnGrab	ENDP

; Added with [51]
;***
;fDocumentBuf - Is current text table a document buffer
;
;Purpose:
;	Deturmines if the currently activated text table should be
;	manipulated as a document buffer.  This should be done only
;	if we are started with the /EDITOR switch and this is not
;	a PCODE text table.
;
;	NOTE: we can not assert that all items that we are editing with
;	/EDITOR are document tables, as we will initialize with a
;	pCode table.
;
;Entry:
;	None.
;
;Exit:
;	psw.Z set if not a document
;
;Uses:
;	None.
;****
cProc	fDocumentBuf,<NEAR>
cBegin

	test	[cmdSwitches],CMD_SW_ED ;Started with /editor?
	jz	NotDocument		;no, can't be a large buffer
	test	[mrsCur.MRS_flags2],FM2_NoPcode ; Is it a document?
NotDocument:
cEnd

; Added with [51]
;****
;fEditorActive : test wether we were started with /editor
;
;Purpose:
;	Exports the checking for the /EDITOR switch to the components
;	of the product that do not have access to cmdSwitches.
;
;Entry:
;	None.
;
;Exit:
;	psw.z set if not started with /EDITOR  (jnz EditorActive)
;****
cProc	fEditorActive,<FAR, PUBLIC>
cBegin
	test	[cmdSwitches],CMD_SW_ED ;Started with /editor
cEnd


;****
;fQhelpActive : test wether we were started with /QHELP
;
;Purpose:
;	Exports the checking for the /QHELP switch to the components
;	of the product that do not have access to cmdSwitches.
;
;Entry:
;	None.
;
;Exit:
;	psw.z set if not started with /QHELP  (jnz QhelpActive)
;****
cProc	fQhelpActive,<FAR, PUBLIC>
cBegin
	test	[cmdSwitches],CMD_SW_QHELP ;Started with /QHELP
cEnd


;**************************************************************************
; DeleteLinesBuf - Delete a range of lines from the buffer
; Purpose:
;  Called by  TextWin's editor  when it needs to delete a
;  range of source lines.
;  cln lines are deleted from buffer hbuf starting at line ln.
;
; Entry:
;  hbuf  - buffer to delete lines from.
;  ln    - line number to delete.
;  cln   - Number of lines to delete.
;
; Exit:
;
;**************************************************************************
cProc	DeleteLinesBuf,<PUBLIC,FAR>,<si>
	parmW	hbuf
	parmW	ln
	parmW	cln
cBegin
	mov	bx,[hbuf]
	call	ModifyingHbuf

	call	fDocumentBuf		; Is this a large document buffer?
	jz	DLB_NotDocument 	; brif not, let txtmgr handle it
	push	[mrsCur.MRS_pDocumentBuf] 
	push	ln			
	push	cln			
	call	S_DeleteLinesBuf	; Delete line from document buffer
	jmp	SHORT DLB_Exit		

DLB_NotDocument:
;*** Don't need to do this because TxtChange calls UiFlushCache.
;***	mov	[lnGetNext],0		; clear cache

; TxtChange(OtxOfLn(ln),OtxOfLn(ln+cln),fNoInsert)

	mov	si,[ln]
	cCall	OtxOfLn,<si>
	push	ax			; 1st parm for TxtChange (otxStart)

	add	si,[cln]
	cCall	OtxOfLn,<si>
	push	ax			; 2nd parm for TxtChange (otxEnd)

	push	sp			; 3rd parm for TxtChange (fNoInsert)

	call	TxtChange		; just delete, don't insert anything

	mov	ax,[ln]			; pass line# above edit in ax
	mov	dx,[cln]
	neg	dx			; pass -#lines deleted in dx
	call	UpdAltListWnd

DLB_Exit:
cEnd

;**************************************************************************
; ReplaceLineBuf(hbuf, ln, cbNewSrc, pbNewSrc)
; Purpose:
;  Replace the line ln in the buffer hbuf with the text pbNewSrc.
;
; Entry:
;  hbuf - the buffer containing the line to be replaced.
;  ln   - the line to replace.
;  cbNewSrc - the length of the new line.
;  pbNewSrc - the text of the new line.
;
; Exit:
;  uierr is set non-zero if any error occurred.
;  returns zero if we changed hBufs (ie - line was a SUB or FUNCTION
;	definition). This tells the editmgr to stop any futher edits
;	to the entry hBuf (keeps us from inserting a BOL for a CR at
;	a random location in the text table.
;
;**************************************************************************
cProc	ReplaceLineBuf,<PUBLIC,FAR>,<si,di>
	parmW	hbuf
	parmW	ln
	parmW	cbNewSrc
	parmDP	pbNewSrc
	LocalW	cbTextOld
cBegin
DbAssertRel [pbNewSrc],e,[ps.PS_bdpSrc.BDP_pb],UI,<ReplaceLineBuf: bad pbNewSrc>
	mov	si,[ln]

	mov	bx,[hbuf]
	call	ModifyAndGrab

	call	fDocumentBuf		; Is this a large doc buffer?
	jz	RLB_NotDocument 	; brif not, let txtmgr handle it
	push	[mrsCur.MRS_pDocumentBuf] 
	push	ln			
	push	cbNewSrc		
	PUSHI	ax,<dataOffset ps.PS_bdpSrc.BDP_pb> ; Ptr to ptr to buffer
	call	S_ReplaceLineBuf	; Replace line in document buffer
	jmp	SHORT RLB_UnGrab	

RLB_NotDocument:
	mov	cx,[cbNewSrc]
	cCall	KludgePs

;*** Don't need to do this because TxtChange calls UiFlushCache.
;***	mov	[lnGetNext],0		; clear cache

	cCall	OtxOfLn,<si>		; Get otx of begining of line
	xchg	di,ax			; mov di,ax

	inc	si
	cCall	OtxOfLn,<si>		; Get otx of next line
	xchg	si,ax			; mov si,ax

	mov	ax,[txdCur.TXD_bdlText_cbLogical]
	mov	[cbTextOld],ax

; If there is currently an error and it is on the same line as we
; are about to change, clear the error under the assumption it's about
; to be fixed (if it isn't fixed then a new error is generated).
;
	cmp	di,[txtErr.TXER_otx]
	jne	RLB1
	cmp	[uierr],ER_OM
	je	RLB1			;don't clear of uierr=ER_OM
	mov	[uierr],0
RLB1:

;
; Now make the change.
;
	sub	ax,ax			;clear fNoInsert flag
	cCall	TxtChange,<di,si,ax>
	or	ax,ax
	je	RLB2

;
; There was an error
;
	mov	[uierr],ax
	jmp	SHORT RLB_End

RLB2:
; There was no error this time.
;
	cmp	[uierr],ax		; ax is zero
	je	RLB_End
;
; There was an error before this call to ReplaceLineBuf.
; Make sure that the otx reflects the changes this call has made.
;
	cmp	di,[txtErr.TXER_otx]
	ja	RLB_End 		; brif edit passed error loc

	mov	ax,[txdCur.TXD_bdlText_cbLogical]
	sub	ax,[cbTextOld]
	add	[txtErr.TXER_otx],ax

RLB_End:
	mov	ax,[ln]			; pass line# in ax
	sub	dx,dx			; pass line count in dx
	call	UpdAltListWnd
	cCall	UnKludgePs
RLB_UnGrab:
	mov	ax,[hbuf]
	call	UnGrab			;free space reserved by ModifyAndGrab
	sub	ax,ax			; Assume we changed hBufs
	mov	bx,[hBuf]		
	cmp	bx,[grs.GRS_oRsCur]	;see if hBuf on entry = hBuf on Exit
	jne	RLB_Exit		;return FALSE if not
	dec	ax			;return TRUE (same hBuf)
RLB_Exit:
cEnd

;**************************************************************************
; InsertLineBuf(hbuf, ln, cbNewSrc, pbNewSrc)
; Purpose:
;  Inserts the line specified by pbNewSrc and cbNewSrc into the buffer
;  specified by hbuf before the line ln.
;
; Entry:
;  hbuf     - buffer to insert line into
;  ln       - line to insert before
;  cbNewSrc - length of new line
;  pbNewSrc - text to insert
;
; Exit:
;  if the line was inserted, returns non-zero
;  else sets [uierr] and returns FALSE
;
;**************************************************************************
cProc	InsertLineBuf,<PUBLIC,FAR>
	parmW	hbuf
	parmW	ln
	parmW	cbNewSrc
	parmDP	pbNewSrc
cBegin
DbAssertRel [pbNewSrc],e,[ps.PS_bdpSrc.BDP_pb],UI,<InsertLineBuf: bad pbNewSrc>
	mov	bx,[hbuf]
	call	ModifyAndGrab

	call	fDocumentBuf		; is this a large document buffer
	jz	ILB_NotDocument 	; brif not, let txtmgr handle it
	push	[mrsCur.MRS_pDocumentBuf] 
	push	ln			
	push	cbNewSrc		
	PUSHI	ax,<dataOffset ps.PS_bdpSrc.BDP_pb> ; Ptr to ptr to buffer
	PUSHI	ax,0			; FALSE -> check # lines
	call	S_InsertLineBuf 	; Insert line in doc buffer
	push	ax			; save result for ILB_UnGrab
	jmp	SHORT ILB_UnGrab	

ILB_NotDocument:
	mov	cx,[cbNewSrc]
	cCall	KludgePs

	;Speed optimization so we don't call OtxOfLn for scrap.
	;We only insert lines at the end of the scrap.  This makes
	;Cut/Copy MUCH faster.
	
	mov	ax,[hbuf]
	cmp	ax,[hbufOfScrap]
	jne	NotScrap4
	mov	ax,[txdCur.TXD_bdlText_cbLogical]
	sub	ax,CB_EMPTY_TEXT
	jmp	SHORT GotScrap

NotScrap4:
	cCall	OtxOfLn,<ln>		;ax = text offset to line
GotScrap:
	sub	bx,bx			;clear fNoInsert flag
	cCall	TxtChange,<ax,ax,bx>
	or	ax,ax
	je	ILB_End			;brif no error

	mov	[uierr],ax

	mov	ax,-1
ILB_End:
	inc	ax			; return 0 if fail, 1 if Ok

	push	ax			; save return value

	;The next few lines treat a special case bug.
	;If the editor is extending beyond the end of the current window,
	;calling UpdAltListWnd will cause DrawDebugScr to cause the
	;edit mgr to Draw the debug screen, which will cause its partial
	;line to be dumped to ReplaceLineBuf.
	
	cmp	[cbNewSrc],0
	jne	NotExtend
	mov	ax,[txdCur.TXD_cLines]
	dec	ax
	cmp	ax,[ln]			; pass line# in ax
	je	ItsExtend
NotExtend:
	mov	ax,[ln]			; pass line# in ax
	mov	dx,1			; pass line count in dx
	call	UpdAltListWnd
ItsExtend:

	cCall	UnKludgePs

ILB_UnGrab:
	mov	ax,[hbuf]
	call	UnGrab			;free space reserved by ModifyAndGrab
	pop	ax			;restore return value
ILB_Exit:
	or	ax,ax			;set condition codes for caller
cEnd

;**************************************************************************
; fReadOnlyBuf(hbuf)
; Purpose:
;  Tells the EditMgr whether a buffer {is, is not} read only.
;  A buffer is read only if it is code and we are viewing include file lines.
;
; Entry
;  hbuf - The buffer
;
; Exit:
;  if hbuf is read only, Returns TRUE and sets uierr to:
;     MSG_InclOff if current line didn't come from $INCLUDE file
;      (causes ReportError to ask user if he wants View/IncludeLines turned off)
;     MSG_EditIncl if current line came from $INCLUDE file
;      (causes ReportError to ask user if he wants to edit $INCLUDE file)
;
;**************************************************************************
cProc	fReadOnlyBuf,<PUBLIC,FAR>
	parmW	hbuf
cBegin
	mov	bx,[hbuf]
	cmp	bx,hbufHelp		; Check for Help buffer.
	jne	@F
	mov	ax,sp			; If so, is help window, return TRUE
	jmp	short ExitFReadOnlyBuf	

@@:
	call	ActivateHbuf
	xor	ax,ax			;prepare to return FALSE
ExitFReadOnlyBuf:
cEnd


;**************************************************************************
; LinesInBuf(hbuf)
; Purpose:
;  Return number of lines in a given edit buffer
;
; Entry
;  hbuf - The buffer
;
; Exit:
;  return the number of lines in the buffer.
;
;**************************************************************************
cProc	LinesInBuf,<PUBLIC,FAR>
	parmW	hbuf
cBegin

	mov	bx,[hbuf]
	cmp	bx,hbufHelp			; test for help buffer
	jne	@F
	PUSHI	ax,WM_HELPFILESIZE		; message to send
	push	ax				; garbage parameter
	cCall	SendHelpMsg			; AX = # lines
	jmp	short LIB_End			

@@:
; Return 1 is hbuf is UNDEFINED (for single line edit fields).

	mov	ax,1
	inc	bx
	jz	LIB_End
	dec	bx

; else return the number of lines in the buffer.

	call	ActivateHbuf

	mov	ax,[txdCur.TXD_cLines]

	call	fDocumentBuf		; Is this a document buffer?
	jz	LIB_END 		; brif not, AX = # lines
	push	[mrsCur.MRS_pDocumentBuf] 
	call	S_LinesInBuf		; get # lines in document buffer

LIB_End:
cEnd


;**************************************************************************
; ListAxSiDi
; Entry:
;	ax = otx to next opcode to be executed by interpreter, or
;	     FFFF if next opcode is not in this text table.
;	si = otx to start of line to be listed.
;	di = ptr to buffer descriptor for destination.
; Exit:
;	ax = number of bytes listed (as returned by ListLine)
;	dx = column offset that corresponds to entry's ax
;
;**************************************************************************
ListAxSiDi PROC NEAR
	mov	[otxLsCursor],ax
	cCall	ListLine,<si,di>	; cbLine = ListLine(otx, pbd)
	ret
ListAxSiDi ENDP

;**************************************************************************
; ushort cbGetLineBuf(hbuf, ln, cbMax, szDst)
; Purpose:
;  Called by TextWin's editor, even when the current buffer has been
;  modified and the line needs to be refreshed.  This routine gets
;  the specified ASCII line of text even it is the current line (i.e. UNDO).
;
; Entry:
;  hbuf     - buffer handle.
;  ln       - line to copy
;  cbMax    - Max number of character to copy to buffer.
;  szDst    - where to put the zero terminated line
;  grs.otxCONT = text offset to next instruction to be executed
;
; Exit:
;  if grs.otxCONT points into line being listed:
;     colStmtStart = column of start of next statement
;     colStmtEnd = column of end of next statement
;  else
;     colStmtStart = colStmtEnd = UNDEFINED
;  return number of characters put in buffer (excluding terminating zero)
;  If out-of-memory, sets [uierr] to ER_OM and returns 0
;
;**************************************************************************
cProc	cbGetLineBuf,<PUBLIC,FAR>,<si,di>
	parmW	hbuf
	parmW	ln
	parmW	cbMax
	parmDP	szDst
cBegin
	;Caller can only call us to list to 1 of 2 buffers:
	; ps.bdpSrc or bdEMScratch, see which it is
	; The reason twin passes an absolute pointer is because twin is used
	; by other products that have static buffers.
	
	mov	di,DATAOFFSET ps.PS_bdpSrc
	mov	ax,[szDst]
	cmp	ax,[di.BD_pb]
	je	GotBdPtr		; brif ps.bdpSrc is our buffer
	mov	di,DATAOFFSET bdEMScratch
	DbAssertRel ax,e,[di.BD_pb],UI,<cbGetLineBuf called with bad pointer>

;di = ptr to output buffer descriptor
GotBdPtr:
	mov	bx,[hbuf]
	cmp	bx,hbufHelp		; Check for help buffer
	jne	@F			; if not, skip ahead

	mov	ax,WM_HELPLINE		; message to send
	mov	bx,OFFSET DGROUP:wndHelp ; window to send to
	cCall	SendMessage,<bx,ax,[ln],[szDst],[cbMax]>
	inc	[fWndHelp]		; Set flag for GetLineAttrs
	jmp	GlbExit 		

@@:
	mov	[fWndHelp],0		; make sure flag is reset
	call	ActivateHbuf

	call	fDocumentBuf		; Is this a large document buffer?
	jz	GLB_NotDocument		; brif not, let txtmgr handle it
	push	[mrsCur.MRS_pDocumentBuf] 
	push	ln			
	push	cbMax			
	push	szDst			
	call	S_cbGetLineBuf		; Get line from document buffer
	jmp	SHORT GlbExit		

GLB_NotDocument:
; [otxGetNext] is a cached otx for line [lnGetNext].
; See if we can use it.
	mov	si,[otxGetNext]
	mov	ax,[ln]
	mov	cx,[lnGetNext]
	inc	ax			;cache the otx for [ln]+1
	mov	[lnGetNext],ax
	dec	ax

	jcxz	RefreshCache		;brif cached otx is invalid
	cmp	ax,cx
	je	GotOtx

; Cached otx was no good, we have to search for the otx.
;
RefreshCache:
	cCall	OtxOfLn,<ax>
	xchg	si,ax				; mov si,ax

;Save cached otx for next call
GotOtx:
	mov	[otxLnLast],si

; ListLine checks to see if otxLsCursor is in the current line, and if so
; it returns dx=the equivalent column for the opcode at that otx.
; If the current text table is the `active text table' (i.e. the text table
; containing the next statement to be executed), then otxLsCursor is setup
; appropriately.  grs.oRsContTxtTbl gets set whenever grs.oRsCONT gets set.
; The only time it is different then grs.oRsCONT is when grs.oRsCONT is
; for a DEF FN, in which case, this gets set to the oRs for the module
; that contains the DEF FN.
;
	mov	ax,UNDEFINED		;assume line doesn't contain next stmt
					; to be executed by interpreter
	mov	[colStmtStart],ax
	mov	[colStmtEnd],ax
	xchg	dx,ax			;dx = UNDEFINED
	mov	ax,[grs.GRS_oRsContTxtTbl]
	cmp	ax,[grs.GRS_oRsCur]
	jne	ListTheLine		;brif this isn't the oRs with next
					; stmt to exec
	mov	ax,[grs.GRS_otxCONT]
	inc	ax			;test for UNDEFINED
	jz	ListTheLine		;brif grs.GRS_otxCONT == UNDEFINED
	xchg	dx,ax			;dx = otxCONT
	dec	dx			;undo above inc

	;Don't be tempted to enable this...  Keep the comment around
	; as a reminder, because it is very tempting...
	; This causes bug where if you edit the line with
	; the current instruction, afterward, it looks like the
	; previous line contains the next instruction.
	; Maybe fix this another way, or always keep a NOP after
	; opStSub, opStFunction, opStDefFn, opStStop
	
	;;;;Set dx to otxCONT - 1, so if STOP and BreakPoint after DEF FN,
	;;;; SUB, or FUNCTION will highlight the STOPPED stmt.
	
	;;;;je	ListTheLine		;brif grs.GRS_otxCONT == 0
	;;;;dec	dx

;dx = new otxLsCursor, si = otx to list, di = bdDestination
ListTheLine:
	xchg	ax,dx			; ax = new otxLsCursor
	call	ListAxSiDi		; cbLine = ListLine(otx, pbd)
	inc	ax			; test for UNDEFINED
	je	GlbOmErr		; return 0 if out-of-memory
	dec	ax			; restore ax = cbLine
	push	ax			; save cbLine (return value)
	mov	ax,[otxListNext]	; cache this value for next time
	mov	[otxGetNext],ax
	inc	dx			; test for UNDEFINED
	je	NotOnLine		; brif line doesn't contain next stmt

	;Since we know this line contains next stmt to be executed,
	;call ListLine twice more to find column offset for start and
	;end of stmt, LineAttr can highlight the statement.
	
	push	[otxLsCursor]
	call	OtxBosOfOtx		; ax = otx for next stmt's bos
	call	ListAxSiDi		; cbLine = ListLine(otx, pbd)
					;  since this line was just listed,
					;  we are assured not out-of-memory
	mov	[colStmtStart],dx
	inc	dx
	je	NotOnLine


	push	[otxLsCursor]		; push otx arg.
	call	OtxBosNext		; ax = otx for next stmt's eos
	call	ListAxSiDi		; cbLine = ListLine(otx, pbd)
					;  since this line was just listed,
					;  we are assured not out-of-memory
	mov	[colStmtEnd],dx
	inc	dx
	jne	NotOnLine		; brif not UNDEFINED
	dec	dx			; dx = UNDEFINED
	mov	[colStmtStart],dx	; if colStmtEnd is UNDEFINED,
					; so is colStmtStart
NotOnLine:
	pop	ax			; restore ax = cbLine (return value)
GlbExit:
cEnd

GlbOmErr:
	call	SetUiErrOm		; report error in msg loop
	jmp	SHORT GlbExit		; return ax=0


;**************************************************************************
; LineAttr(attrDefault)
; Purpose:
;  Returns an array discribing the screen attributes for the last line
;  fetched by cbGetLineBuf.
;
; Entry:
;  attrDefault is the screen attribute to use for non-standout text.
;  colStmtStart and colStmtEnd are as set by last call to cbGetLineBuf.
;
; Exit:
;  returns pointer to array of LineAttr's.
;  Each LineAttr consists of a count (cb) and an attribute (attr)
;  attr is the attribute to be used for the next cb characters in the line.
;  The array is terminated with an attr of 0xffff
;  cb may be zero.
;  If cb is 0xffff then attr is used for the rest of the line.
;
;**************************************************************************
cProc	GetLineAttrs,<PUBLIC,FAR>,<si,di>
	parmW	attrDefault
cBegin
	cmp	[fWndHelp],0		; Is being called for help window
	je	@F
	mov	[fWndHelp],0		; Clear fWndHelp
	mov	ax,WM_HELPATTR		; message to send
	cCall	SendHelpMsg,<ax,ax>	; Send message to help system
	jmp	short AttrEnd		

@@:
	mov	si,[attrDefault]
	mov	di,dataOFFSET rgLineAttr

	cCall	fCodeWnd
	jz	UseDefaultAttrs		;brif DOCUMENT text table

	cmp	[fLsIncluded],0
	je	NotIncluded
	mov	si,isaIncludeFileHilite 
NotIncluded:

	cCall	fBpSet,<otxLnLast>
	or	ax,ax
	je	NoBpSet
	mov	si,isaBreakpoint
NoBpSet:
	mov	ax,[colStmtStart]
	mov	dx,[colStmtEnd]
	inc	ax			;test for UNDEFINED
	je	UseDefaultAttrs
	inc	dx			;test for UNDEFINED
	je	UseDefaultAttrs
	dec	ax			;ax = [colStmtStart]
					;dx = [colStmtEnd] + 1
	

; Ahh, this line has the current statement on it.
; We must setup so that it gets highlighted properly
; ax = [colStmtStart], dx = [colStmtEnd]
;
	mov	[di.LA_cb],ax
	mov	[di.LA_attr],si
	sub	dx,ax			;dx = [colStmtEnd]+1-[colStmtStart]
	mov	ax,isaCurBreakpoint
	cmp	si,isaBreakpoint
	je	GotCurBp		;brif current stmt has breakpoint too
	mov	ax,isaCurStmt
GotCurBp:
	mov	[di + (size LINEATTR) + LA_cb],dx
	mov	[di + (size LINEATTR) + LA_attr],ax
	mov	ax,UNDEFINED
	mov	[di + (2*(size LINEATTR)) + LA_cb],ax
	mov	[di + (2*(size LINEATTR)) + LA_attr],si	
	mov	[di + (3*(size LINEATTR)) + LA_attr],ax
	jmp	short GLA_End

UseDefaultAttrs:
	mov	ax,UNDEFINED
	mov	[di + LA_cb],ax
	mov	[di + LA_attr],si
	mov	[di + (size LINEATTR) + LA_attr],ax
GLA_End:
	xchg	ax,di			;return ax = &rgLineAttr
AttrEnd:
cEnd


;**************************************************************************
; StartBigEdit
; Purpose:
;  Called by the Edit Mgr at the start of some operation which results
;  multiple calls to InsertLineBuf/ReplaceLineBuf/DeleteLinesBuf.
;  Examples include multi-line-paste/cut/copy, line-split, line-join.
;
; Entry:
;
; Exit:
;**************************************************************************
cProc	StartBigEdit,<PUBLIC,FAR>
cBegin
	cCall	TxtStartBigEdit
cEnd


;**************************************************************************
; EndBigEdit
; Purpose:
;  Called by the Edit Mgr at the end of some operation which results
;  multiple calls to InsertLineBuf/ReplaceLineBuf/DeleteLinesBuf.
;  Since during a BIG EDIT, all lines are emitted within opReParse
;  operands, and not really parsed to pcode until TxtEndBigEdit,
;  syntax errors may be discovered during TxtEndBigEdit().
;
; Exit:
;  if error encountered, uierr is set to standard error code
;
;**************************************************************************
cProc	EndBigEdit,<PUBLIC,FAR>
cBegin
	cCall	TxtEndBigEdit		;ax = non-zero if serious error
	or	ax,ax
	je	EndBigEdit_End
	mov	[uierr],ax
EndBigEdit_End:
cEnd

;**************************************************************************
; InsertBufInBuf()
; Purpose:
;  Insert the contents of 1 buffer (usually the scrap) into another buffer
;
; Entry:
;  hbufDst - buffer to insert other buffer into.
;  lnDst   - line before which the buffer is to be inserted.
;  hbufSrc - the buffer the be inserted.
;
; Exit:
;  returns zero if out-of-memory, non-zero if success
;
;**************************************************************************
cProc	InsertBufInBuf,<PUBLIC,FAR>,<si,di>
	parmW	hbufDst
	parmW	lnDst
	parmW	hbufSrc
cBegin

	call	StartBigEdit		;so we don't stop inserting just
					; because of a syntax error
	mov	bx,[hbufDst]
	call	ModifyAndGrab

	call	fDocumentBuf		; Is this a large document buffer
	jz	IBIB_NotDocument	; brif not, let txtmgr handle it
	push	[mrsCur.MRS_pDocumentBuf] 
	push	lnDst			

	mov	bx,hbufSrc		; bx = oPrs
	and	bh,7Fh			; mask off bit saying it is PRS.
	RS_BASE add,bx			
	push	[bx.MRS_pDocumentBuf]	
	call	S_InsertBufInBuf	
	jmp	SHORT IBIB_TestRetVal	

IBIB_NotDocument:
	push	[lnDst]
	call	oTxOfLn 		;get oTxInsert for destination buf
	push	ax			;pass oTxInsert
	push	[hBufSrc]		;pass src hBuf
	call	TxtPaste		;insert src buffer at insertion point
IBIB_TestRetVal:
	or	ax,ax			;Out of memory
	jne	IBIB_NotOm		;brif not out of memory
IBIB_OM:
	call	SetUiErrOm		;set out of memory error
IBIB_NotOm:
	call	EndBigEdit		;destination text table is active
	sub	ax,ax			;prepare to return 0 (error)
	cmp	[uierr],ax
	jne	IBIB_Done		;brif got an error
	dec	ax			;return non-zero (success)
IBIB_Done:
	push	ax
	mov	ax,[hbufDst]
	call	UnGrab			;free space reserved by ModifyAndGrab
	pop	ax
cEnd

;**************************************************************************
; ushort near hbufScrap()
; Purpose:
;  Return the handle for the Scrap buffer, allocating the buffer if necessary.
;
; Exit:
;  If out-of-memory, returns NULL
;
;**************************************************************************
cProc	hbufScrap,<PUBLIC,FAR>
	localV	sdName,<size sd>
cBegin
	mov	ax,[hbufOfScrap]
	cmp	ax,UNDEFINED
	jne	hbufScrap_End

; Make a text table (the name is unimportant, but cbName must be non-zero -
; otherwise it is the UNTITLED module), so use the 1 byte string starting
; at address 1 as the name of the scrap.
	lea	bx,sdName
	mov	[bx.SD_pb],DATAOFFSET hbufOfScrap
					;pb -> FF (impossible mrs name)
	mov	[bx.SD_cb],1
	push	bx			;pass &sdName
	PUSHI	ax,RS_scrap		;rsType
	cCall	RsMake			;ax = oRs of scrap
	mov	[hbufOfScrap],ax
	mov	[rsNew],UNDEFINED	;don't tell WnReset to display 
					; scrap in a list window

	DbAssertRel ax,ne,0,UI,<hbufScrap oRs==0>
hbufScrap_End:
cEnd

;**************************************************************************
; UiDelAll
; Purpose:
;	Delete all text from a specified text table
; Entry:
;	bx = hbuf
;
;**************************************************************************
cProc	UiDelAll,<NEAR>
cBegin
	call	ActivateHbuf		;activate text table bx
	call	TxtDelAll		;delete all text in the text
					; table except endprog and eot

	call	fDocumentBuf		; is this a large document
	jz	DelAllExit		; brif not, all done
	push	[mrsCur.MRS_pDocumentBuf] 
	call	FreeBuf 		; Release buffer
	call	NewBuf			; get a new one
	mov	[mrsCur.MRS_pDocumentBuf],ax ; and use that one instead
	DbAssertRel ax,ne,0,UI,<UiDelAll:NewBuf failed>

DelAllExit:
cEnd

;**************************************************************************
;FreeCmdHistory
;Purpose:
;	This is called when we're getting real tight on memory
;	and something needs to be done to free up enough to do
;	the most primitive operations
;Exit:
;	Caller's grs.oRsCur and txtErr are preserved
;
;**************************************************************************
cProc	FreeCmdHistory,<PUBLIC,NEAR>
cBegin
	mov	bx,[hbufOfCmd]
	inc	bx			;if hbufOfCmd is UNDEFINED, exit
	je	EndFreeCmdHistory
	dec	bx

	push	[grs.GRS_oRsCur]	;pass oRsCur to UiRsActivate below
	push	[txtErr.TXER_errCode]
	push	[txtErr.TXER_otx]
	push	[txtErr.TXER_oRs]
	push	WORD PTR [txtErr.TXER_fDirect]

	call	UiDelAll
	PUSHI	ax,<DATAOFFSET txdCur.TXD_bdlText>
	call	BdlTrim			;If we don't trim the buffer,
					; the space isn't made available
					; to other callers until TxtDeactivate
	pop	ax
	mov	[txtErr.TXER_fDirect],al
	pop	[txtErr.TXER_oRs]
	pop	[txtErr.TXER_otx]
	pop	[txtErr.TXER_errCode]
	call	UiRsActivate		;parm pushed on entry
EndFreeCmdHistory:
cEnd

;**************************************************************************
; void near FreeScrap()
; Purpose:
;  Release the contents of the 'scrap' buffer.
;
;**************************************************************************
cProc	FreeScrap,<PUBLIC,FAR>
cBegin
	mov	bx,[hbufOfScrap]
	inc	bx			;test for UNDEFINED
	jz	FreeScrap_End		;brif no scrap is allocated
	dec	bx			;restore bx=hbufOfScrap
	call	UiDelAll		;Delete all the lines in hbufOfScrap
FreeScrap_End:
cEnd

;**************************************************************************
; CutAll(hbufSrc)
; Purpose:
;	Cut the entire active text table to the scrap.
; Entry:
;	hbufSrc = hbuf (i.e. oRs) of source text table.
; Exit:
;  returns zero if out-of-memory, non-zero if success
;
;**************************************************************************
cProc	CutAll,<PUBLIC,NEAR>,<si,di>
	parmW	hbufSrc
	localW	lnDst
cBegin
	call	FreeScrap
	DbAssertRel [hbufOfScrap],ne,UNDEFINED,UI,<CutAll: no hbufOfScrap>

	call	StartBigEdit		;so we don't stop inserting just
					; because of a syntax error

; Cycle through all the lines in the source buffer, inserting each line in
; the Scrap buffer.
	sub	di,di
	mov	[lnDst],di		;init lnDst to 0
CA_NextLine:
	cCall	LinesInBuf,<hbufSrc>
	cmp	ax,di
	jna	CA_Done 		;brif done with loop

	;Use the line buffer of the source buffer as a scratch buffer.
	push	[hbufSrc]		;pass hbuf
	push	di			;pass line to get
	push	[ps.PS_bdpSrc.BDP_cbLogical] ;pass cbMax
	push	[ps.PS_bdpSrc.BDP_pb]	;pass pbDst
	call	cbGetLineBuf		;ax = #bytes fetched, uierr may = ER_OM
	inc	di			;bump line count

	push	[hbufOfScrap]		;pass Scrap as destination buffer
	push	[lnDst]
	push	ax			;pass cb
	push	[ps.PS_bdpSrc.BDP_pb]	;pass pbSrc
	call	InsertLineBuf
	je	CA_Done 		;brif line not inserted (out of memory)
	inc	[lnDst]
	jmp	short CA_NextLine

CA_Done:
	mov	bx,[hbufOfScrap]	;activate Scrap text table
	call	ActivateHbuf		; for EndBigEdit
	call	EndBigEdit
	sub	ax,ax			;prepare to return 0 (error)
	cmp	[uierr],ax
	jne	CA_Exit 		;brif got an error

; Now delete all source from text table

	mov	bx,[hbufSrc]
	call	UiDelAll		;delete all text in text table
CA_Exit:
cEnd

;**************************************************************************
; PasteAll
; Purpose:
;	Copy the entire scrap to the active text table.
; Entry:
;	grs.oRsCur identifies source text table.
;
;**************************************************************************
cProc	PasteAll,<PUBLIC,NEAR>
cBegin
	push	[grs.GRS_oRsCur]	;pass hbufSrc
	PUSHI	ax,0			;lnInsert = 0
	push	[hbufOfScrap]		;pass hbufDst
	call	InsertBufInBuf
cEnd



;*********************************************************************
; void NEAR MoveCursorPwndCur(ln, col)
; Purpose:
;  Position cursor to a particular line/column within the active window.
;
; Entry:
;  pwndAct points to active window's structure
;  ln  - line to position cursor to.
;  col - column to position cursor to.
;
; Exit:
;
;*********************************************************************
cProc	MoveCursorPwndCur,<PUBLIC,NEAR>
	parmW	ln
	parmW	col
cBegin
	DbAssertRel [pwndAct],ne,0,UI,<MoveCursorPwndCur: pwndAct=0>

	cCall	MoveCursorPwnd,<pwndAct,ln,col>
cEnd


;*********************************************************************
; void NEAR MoveCursorPwnd(pwnd, ln, col)
; Purpose:
;  Position cursor to a particular line/column within the window
;  specified
;
; Entry:
;  pwnd - points to window's structure
;  ln  - line to position cursor to.
;  col - column to position cursor to.
;
; Exit:
;
;*********************************************************************
cProc	MoveCursorPwnd,<PUBLIC,NEAR>
	parmW	pwnd
	parmW	ln
	parmW	col
cBegin
	DbAssertRel [ln],ne,0ffffH,UI,<MoveCursorPwnd: ln=ffff>
	DbAssertRel [col],ne,0ffffH,UI,<MoveCursorPwnd: col=ffff>
	DbAssertRel [pwnd],ne,0,UI,<MoveCursorPwnd: pwnd=0>

	push	[pwnd]
	PUSHI	ax,EM_SELCHARS		; message
	push	[ln]			; wParam - line.
	mov	ax,[col]
	push	ax			; lParam - start and end column
	push	ax
	call	SendMessage
cEnd


;*********************************************************************
; MoveTxdCursor
; Purpose:
;	Position cursor where it was last time text was visible.
; Entry:
;	pUwinAct points to active window's structure
;	pUwinAct->lnCursor = line to position window at
;
;*********************************************************************
cProc	MoveTxdCursor,<PUBLIC,NEAR>
cBegin
	DbAssertRel [pwndAct],ne,0,UI,<MoveTxdCursor: pwndAct=0>
	call	UiRsActivateWnd 	;activate active window's register set
	mov	ax,[txdCur.TXD_lnCursor]
	inc	ax			;test for UNDEFINED
	je	MtxdFirst		;brif 1st time this txd has been shown
					; line = 0
	dec	ax			;restore ax = last line cursor was on
MtxdFirst:
	mov	[txdCur.TXD_lnCursor],ax ;if it was UNDEFINED, set it to 0
					; now, so we don't think its the first
					; time we've seen it on subsequent calls
	push	ax			;pass line
	PUSHI	ax,0			;pass column = 0
	call	MoveCursorPwndCur	;move pwndCur's cursor
cEnd



;SetUiErrCond added with revision [47]
;*********************************************************************
; SetUiErr, SetUiErrCond
; Purpose:
;	Set uierr, and txterr properly.
;	SetUiErrCond conditionally sets uierr and txterr if:
;	    1. error code is non-zero
;	    2. uierr is not already set.
;
; Entry:
;	errCode is the error code
; Exit:
;	Sets uierr and txterr
;	callers assume that only AX is used.
;	AX = error code
;
;*********************************************************************
cProc	SetUiErrCond,<PUBLIC,NEAR>	; Same parms as SetUiErr
	parmW	errCode
cBegin
	mov	ax,[errCode]		; to return error in AX
	or	ax,ax			; got an error?
	jz	NoError			; brif not -- just
	cmp	uierr,0			; already got another error?
	je	SetUiErr_Start		; brif not -- go ahead & set uierr
NoError:
cEnd

cProc	SetUiErr,<PUBLIC,NEAR>
	parmW	errCode
cBegin
SetUiErr_Start:				; entry point for SetUiErrCond
	mov	[txtErr.TXER_oRs],UNDEFINED
	mov	ax,[errCode]
	mov	[uierr],ax
cEnd

cProc	SetUiErrOm,<PUBLIC,NEAR>
cBegin
	PUSHI	ax,ER_OM
	call	SetUiErr
cEnd

;*********************************************************************
; SetUiErrFar
;	Added with revision [26].
; Purpose:
;	Set uierr, and txterr properly.
; Entry:
;	AX is the error code
; Exit:
;	Sets uierr and txterr
;	callers assume that only AX is used.
;
;*********************************************************************

cProc	SetUiErrFar,<PUBLIC,FAR>
cBegin
	cCall	SetUiErr,<ax>
cEnd

;*********************************************************************
; void near ReportError()
; Purpose:
;  Display an error dialog box and, if appropriate, position the cursor
;  where the error was encountered.
;
; Entry:
;  uierr contains an offset into the standard BASIC message table.
;     If uierr=ER_GoDirect, this function just returns.
;     If high bit is set, the ASCII error message is contained in the
;     parser's global structure ps.bdErr.
;     If txtErr.oRs is UNDEFINED
;	 the cursor will not be positioned
;     Else
;        if txtErr.fDirect is TRUE
;           The cursor is put on the last line entered in the command window
;	    txtErr.oSrc = column where cursor is to be positioned (0..n)
;	 else
;	    A list window with register set txtErr.oRs is made active
;	    The cursor is put on the line indicated by txtErr.otx
;	    if txtErr.oSrc = UNDEFINED,
;	       cursor is placed at start of statement indicated by txtErr.otx
;	    else
;	       txtErr.oSrc = column where cursor is to be positioned (0..n)
;     If b$fCompErr is non-zero, error was in compiled code
;	 b$ErrLin = line # of last runtime error (ERL)
;	 b$ErrMod = far ptr to 0-terminated module name
;	 b$ErrAdr = far ptr where runtime call was made
;     Else
;	 error was in interpreted pcode, a simple dialog is displayed
;
;     If uierr == MSG_MrsNotFound
;        an OK/Cancel dialog box will be put up.  If the user selects
;	 OK, the current mrs will be unloaded.
;
;*********************************************************************
cProc	ReportError,<PUBLIC,NEAR>,<si>
	localW	pwndOldFocus
	localW	colSelect
	localW	lnSelect
	localW	cbSelect
	localW	fSelect
cBegin
ReWhileErr:
	sub	si,si
	mov	[pwndOldFocus],si
	mov	[fSelect],0ffffH	;initialize to UNDEFINED
	xchg	si,[uierr]		;si=uierr, uierr=0
	cmp	si,ER_OM
	jne	NotOmErr
	sub	bx,bx
	mov	bl,[b$ErrInfo]		;bx = extended error code
	shl	bx,1			;bx = 2*extended error code
	mov	si,cs:twExtOmErr[bx]	; si = extended error msg

	;If user wants to enter a direct mode stmt (like SYSTEM), make sure
	; there is room in the command window's buffer to hold the command.
	; If we didn't do this, it could be an infinite out-of-memory loop.
	
	call	FreeCmdHistory
NotOmErr:
	cCall	FlushMsgs		;Don't let any pending keys
					;foul us up.
	cmp	si,MSG_GoDirect
	jne	NotGoDirect
	jmp	ReEnd			;brif user pressed CANCEL
					; button in some Dialog box
NotGoDirect:
	cmp	si,MSG_HelpOOM		; Memory problems in help?
	jne	NotHelpOOM		; no, continue checking
	cCall	DisplayHelpOOM		; handled in shared code
	jmp	ReEnd			; exit
NotHelpOOM:				

	mov	ax,[txtErr.TXER_oRs]
	cmp	[hbufOfScrap],ax	;see if error during cut/paste
					; (like out-of-memory)
	je	ReNoCursor		;can't position to scrap
	cmp	[hbufOfCmd],ax
	je	ReCmdWndErr		;brif error in command window
					; since no syntax checking
					; in cmd window, probably
					; out-of-memory
	inc	ax			;test for UNDEFINED
	je	ReNoCursor		;brif can't position cursor

	cmp	[txtErr.TXER_fDirect],FALSE
	je	ReListCursor		;brif error wasn't in cmd wnd

ReCmdWndErr:
	;Position cursor at offending point in command window
	mov	ax,[txtErr.TXER_oSrc]	; if txtErr.TXER_oSrc=UNDEFINED
	inc	ax			;  then column = 0
	je	SkipDec1
	dec	ax			; otherwise, restore its value
SkipDec1:
	cCall	MoveCursorPwndCur,<lnCmdLast, ax> 
	jmp	SHORT ReNoCursor

ReListCursor:
	;Position cursor at offending point in list window
	mov	ax,txtErr.TXER_otx	;if txtErr.TXER_otx=UNDEFINED
	mov	[fSelect],ax		;set Select flag
	inc	ax			;then otx=0
	jz	short SkipDec
	dec	ax
SkipDec:
	cCall	ShowTok,<txtErr.TXER_oRs,ax,txtErr.TXER_oSrc>

;Since activation of a dialog box kills an edit window's input focus,
;which causes it to turn off the current selection, we have to play
;some tricks to cause the offending token to be highlighted while the
;dialog box is up.  First we find out what line, column and word size the
;cursor is currently on.  Then call FlushFocus() to kill the input focus.
;Then select the text.
;
	cmp	[fSelect],0ffffH	;See if we have selection
	je	short ReNoCursor	;if not, don't highlight
	inc	[fAdjustMsgBox] 	;set flag for moving error box
	call	GetEditColumn		;ax = edit column
	mov	[colSelect],ax
	call	GetEditLine		;ax = edit line
	mov	[lnSelect],ax
	PUSHI	ax,<DATAOFFSET bufStdMsg>
	PUSHI	ax,41d			;40 + 0-byte terminator
	PUSHI	ax,GEW_NODOTMASK	; do not include . in search
	call	GetEditWordMask 	; ax = #chars in current word
	mov	[cbSelect],ax
	cCall	FlushFocus

	push	[lnSelect]
	push	[colSelect]
	push	[cbSelect]
	call	SelectTextPwndCur	;select offending token

; Display a message box containing the error
; if high bit of si is set, the message is in ps.PS_bdErr
; else si is the error number.
;
ReNoCursor:
	cmp	[b$fCompErr],0
	je	NotCompCodeErr
	jmp	CompCodeErr		;brif err was in compiled code

NotCompCodeErr:
	mov	dx,dataOFFSET ps.PS_bdErr
	or	si,si
	jns	ReStdMsg		;brif caller didn't build msg
	cmp	[ps.PS_bdErr.BD_cbLogical],76d
	mov	si,ER_SN		;if msg too long to fit on
	ja	ReStdMsg		; one line, Syntax error
	mov	iHelpId,9999
	PUSHI	ax,MB_OK
	push	dx			;pass <dataOFFSET ps.PS_bdErr>
	call	MsgBoxBd		
J1_ReEnd:
	jmp	SHORT ReEnd		

ReStdMsg:
	mov	ax,MB_OK
	push	ax			;pass dialog box type
					; to MsgBoxStd, MsgBoxStd2
					; and MsgBoxStdBd


NotMsg2:
	push	si			;pass iMsg to MsgBoxStd
	test	HelpFlags,HLP_RTERR	; did this error come from RT?
	jz	NotRtError		; no, call MsgBoxStd
	call	MsgBoxStdRt		; don't muck with iHelpId
	jmp	SHORT ReEnd		; we are done with error
NotRtError:				
	call	MsgBoxStd
	jmp	SHORT ReEnd

;runtime error was in compiled code
CompCodeErr:
	mov	[uierr],si		;set uierr properly
	call	MsgBoxCompErr
	mov	[b$fCompErr],0
	cmp	[uierr],si		;see if uierr is the same
	jne	ReEnd			;if not, then we have new error
	mov	[uierr],0		;otherwise, reset uierr
ReEnd:

	;Turn off highlighted text
	cmp	[fSelect],0ffffH
	je	short ReExit1
	cCall	MoveCursorPwndCur,<lnSelect, colSelect>
	
;See if another error has occurred while reporting this error
;For example, we ask user if he wants to edit an include file,
;user responds YES, and we load include file which causes error.
;
ReExit1:
	cmp	[uierr],0
	je	ReExit
	jmp	ReWhileErr

ReExit:
	sub	ax,ax
	mov	[b$ErrInfo],al			;reset extended error code
	mov	[ps.PS_bdErr.BD_cbLogical],ax	;release ASCII msg buffer
	mov	[fAdjustMsgBox],FALSE
	and	HelpFlags,NOT HLP_RTERR 	; clear the flag
cEnd


;*********************************************************************
; void near ShowStmt(oRs, otx, col)
; Purpose:
;  Makes a statement visible, activating list window if necessary.
;
; Entry:
;   oRs  - Text table containing the line to show
;   otx  - Offset in text table of line to display
;   col  - Column to position cursor on.  If UNDEFINED,
;	   otx is used to compute column for start of stmt.
;
; Exit:
;   alters contents of ps.bdpSrc
;
;*********************************************************************
cProc	ShowStmt,<PUBLIC,NEAR>
	parmW	oRs
	parmW	otx
	parmW	col
cBegin
	push	[oRs]
	cCall	UiRsActivate

	push	[oRs]		;pass to ShowTok
	push	[otx]		;pass to OtxBosOfOtx
	call	OtxBosOfOtx	;ax = otx for beginning of stmt
	push	ax		;pass otx to ShowTok
	push	[col]		;pass col to ShowTok
	call	ShowTok
cEnd

cProc	ShowTok,<PUBLIC,NEAR>,<si>
	parmW	oRs
	parmW	otx
	parmW	col
	localW	line
	localW	oldCol
cBegin
	mov	si, [oRs]

	;If oRs is for a DECLARE or DEF FN prs, which has no text
	;table, use the module's test table instead
	
	cCall	UiRsActivate,<si>	;grs.oRsCur = si
	test	[txdCur.TXD_flags],FTX_mrs
	je	NotMrs			;brif cur txt tbl is for procedure
	mov	si,[grs.GRS_oMrsCur]	;use module's oRs, so we don't
					; activate oRs of DEF FN or DECLARE
	cCall	UiRsActivate,<si>	;grs.oRsCur = si
NotMrs:
	cCall	WndAssignList1		 ;make grs.oRsCur visible in list window

; Which line is the statement on?

	cCall	LnOfOtx,<otx>

	cmp	[fLnNotIncl],0
	jne	SS_NotIncludedLine

; Line was in an include file.
; Turn on viewing of include files, and recalulate the line.
;
	PUSHI	ax,TRUE			; push TRUE
	call	CmdViewInclude

	cCall	UiRsActivate,<si>	; CmdViewInclude activates
					; other text tables.
	cCall	LnOfOtx,<otx>		; ax = line

;Call cbGetLineBuf to set colStmtStart and colStmtEnd to mark the
;columns for the start and end of statement that surround grs.otxCONT
;
SS_NotIncludedLine:
	mov	[line],ax
	cCall	cbGetLineBuf,<si,ax,[ps.PS_bdpSrc.BDP_cbLogical],[ps.PS_bdpSrc.BDP_pb]>
	mov	dx,[col]
	cmp	dx,UNDEFINED
	jne	SS_SetCursor		; brif caller know's column

	;We need to map otx to column, by listing the pcode.
	mov	ax,[otx]
	mov	[otxLsCursor],ax	; tell ListLine to find column
					;  offset for stmt
	cCall	OtxOfLn,<[line]>	; ax = otx for start of line
	push	ax			; pass otx to ListLine
	PUSHI	ax,<DATAOFFSET ps.PS_bdpSrc>
	cCall	ListLine		; ax = cbLine
					; dx = column for otxLsCursor
	inc	ax			; test for UNDEFINED (out of memory)
	jne	NotOmErr1		; brif not out-of-memory
					; ax = 0 (just list a blank line)
	call	SetUiErrOm		; report error in msg loop
					; dx is preserved
NotOmErr1:
	inc	dx			; test for UNDEFINED
	je	SS_SetCursor		; if UNDEFINED, column=0
	dec	dx			; restore dx=column equivalent to [otx]

;If showing current statement, force entire statement to be visible if possible
;by first positioning to end-of-stmt, then to start-of-stmt
;
SS_SetCursor:
	mov	[oldCol],dx		; save the column equivalent to [otx]
	cmp	dx,[colStmtStart]	; if we are at the start of a statement
	jne	SkipAddCursor		; then ensure entire statement visible
	mov	dx,[colStmtEnd]
SkipAddCursor:
	cCall	MoveCursorPwndCur,<[line],dx>
	cCall	MoveCursorPwndCur,<[line],[oldCol]> ; move back to old column
	call	DoDrawDebugScr		; update debug screen if a
	or	al,al			;  new register set has been
					;  made active.
	jne	SS_Exit			; brif debug screen was redrawn

	;If only change has been current line in active window, at least
	; draw that window.  We could have just called DrawDebugScr before
	; DoDrawDebugScr and eliminated this code, but this is faster for
	; animation.
	
	cCall	DrawWindow,<[pwndAct]>
SS_Exit:
cEnd


;**************************************************************************
; DoCmd(szCmd)
; Purpose:
;  Setup to execute a direct mode command.
;
; Entry:
;  szCmd points to a 0-byte terminated ASCII command to be executed.
;  if szCmd == NULL, command has already been copied to ps.bdpSrc.
;
; Exit:
;  If command contains no parser/scanner errors,
;     fGotCmd == TRUE
;     grs.bdlDirect contains pcode to be executed
;  else
;     uierr = error to be reported by GetCmd's loop
;
;**************************************************************************
cProc	DoCmd,<PUBLIC,NEAR>
	parmDP	szCmd
cBegin
	mov	ax,[grs.GRS_oMrsMain]
	inc	ax			;test for UNDEFINED
	jne	DoCmdGotMain		;brif no main module
	PUSHI	ax,MSG_NoMainProg
	call	SetUiErr
	jmp	SHORT DoCmd_Exit

DoCmdGotMain:
	;so edit mgr doesn't think it already has current line cached.
	cCall	EditMgrFlush1

	mov	cx,[szCmd]
	jcxz	DoCmd_EndOk
	cCall	SetPsBufSz,<cx>
DoCmd_EndOk:
	mov	[fDoCmd],sp		; sp is TRUE
	mov	[fGotCmd],sp
DoCmd_Exit:
cEnd

;**************************************************************************
; boolean NEAR CmdEnter()
; Purpose:
;  Called by the main message pump to filter Carriage Return events
;  out of the event stream when the command window is active.  This
;  allows CR to have a different meaning in the command window than it
;  does in list windows.  In a list window, it means split the line.
;  In the command window, it means execute this entire line.
;
; Exit:
;  If command window is active,
;     Causes command to be executed
;     If command contains no parser/scanner errors,
;        fGotCmd == TRUE
;        grs.bdlDirect contains pcode to be executed
;     else
;        uierr = error to be reported by GetCmd's loop
;     returns TRUE
;  else
;     returns FALSE
;
;**************************************************************************
cProc	CmdEnter,<PUBLIC,NEAR>,<si,di>
cBegin
	mov	bx,offset DGROUP:wndCmd	; bx -> command window's UWIN
	cmp	bx,[pwndAct]
	je	CE1			;brif command window is active

; Ignore if command window is not active.

	sub	ax,ax			;tell caller it wasn't in Cmd Window
	jmp	CE_End

; Copy the line that ENTER was pressed on, and setup to execute it.
;
CE1:
	mov	cl,[bx.arcClipping.ayBottomArc]
	sub	cl,[bx.arcClipping.ayTopArc]; See if window has zero lines
	jnz	CmdEnterOk		
	jmp	CE_ExitTrue		; return true
CmdEnterOk:

	mov	bx,[bx.pefExtra]	
	mov	di,[bx.EF_ipCur_oln]	; Keep lnCmd in di

	;flush dirty line in active window.  Also makes sure edit mgr
	; doesn't think it already has current line cached
	call	EditMgrFlush1

	cCall	cbGetLineBuf,<[hbufOfCmd],di,[ps.PS_bdpSrc.BDP_cbLogical],[ps.PS_bdpSrc.BDP_pb]>
	sub	ax,ax
	cCall	DoCmd,<ax>

	mov	si,[txdCur.TXD_cLines]
	dec	si			; si = number of last line (0..n)
	js	CE_BottomLine		; brif cmd window has 0 lines
	cmp	di,si
	je	CE_BottomLine		; brif editing bottom line
	mov	si,di			; si = command line
	inc	si			; si = line after command line
	jmp	SHORT CE5		;      (place to move cursor to)

; ENTER was pressed on the last line of the COMMAND window, so add a blank
; line to the end for the next command to be entered into.
;
CE_BottomLine:
	sub	ax,ax
	inc	si			; bump # lines in window
	cCall	InsertLineBuf,<[hbufOfCmd],si,ax,[ps.PS_bdpSrc.BDP_pb]>
	je	CE_ExitTrue		; brif line not inserted (out of memory)

; If there are more than ten lines in the command window then
; get rid of the first.
;
	mov	di,offset DGROUP:wndCmd ; di points to cmd wnd from now on
	mov	ax,si			; ax = #lines in window
	sub	ax,10d
	jbe	CE4			; brif not more than 10

	push	ax			; pass oldest line to be deleted
	cCall	OtxOfLn			; ax = text offset to top line to delete
	sub	bx,bx
	cCall	TxtChange,<bx,ax,sp>	; delete top line of command window
	mov	bx,[di.pefExtra]	
	dec	[bx.EF_pdCur_olnTop]
	dec	si			; decrement current line

; If there are more lines in the buffer than in the window, make sure that
; when the cursor is put on the last line (at CE5:), that that line is
; at the bottom of the window (so that the most possible history is displayed).
;
CE4:
	sub	ch,ch
	mov	cl,[di.arcClipping.ayBottomArc]
	sub	cl,[di.arcClipping.ayTopArc]
	cmp	cx,si
	ja	CE5

	sub	ax,ax
	cCall	MoveCursorPwndCur,<si,ax>

	mov	ax,si
	sub	ch,ch
	mov	cl,[di.arcClipping.ayBottomArc]
	sub	cl,[di.arcClipping.ayTopArc]
	sub	ax,cx
	inc	ax
	sub	bx,bx
	cCall	MoveCursorPwndCur,<ax,bx>

; Put the cursor on the last line of the buffer (the blank line we inserted).
CE5:
	sub	ax,ax
	cCall	MoveCursorPwndCur,<si,ax>
	or	si,si			;if the line is zero,
	jz	CE6			;old line has disappeared
	dec	si
CE6:
	mov	[lnCmdLast],si		;save for error reporting
CE_ExitTrue:
	mov	ax,sp			;mov ax,TRUE

;ax = TRUE if Enter key was handled, FALSE if ignored (cmd window not active)
CE_End:
cEnd


;**************************************************************************
; fCodeWnd()
; Purpose:
;  returns TRUE if the active window contains pcode.
;
; Entry:
;
; Exit:
;  returns TRUE (nonzero in al/ax) if the active window contains code.
;  condition codes set based on value in ax
;
;**************************************************************************
cProc	fCodeWnd,<PUBLIC,NEAR>
cBegin
	mov	al,[mrsCur.MRS_flags2]
	mov	dx,FM2_NoPcode
	and	ax,dx			;isolate FM2_NoPcode bit
	xor	ax,dx			;ax = non-zero iff FM2_NoPcode 0
cEnd


;**************************************************************************
; GetSelText
; Purpose:
;  Copies the selected text in the current window to the specified buffer.
;
; Entry:
;  pb       - Near pointer to where text is to go.
;  cbMax    - max number of chars to copy
;
; Exit:
;  returns the number of chars copied.
;  The string is copied to pb, and is null terminated.
;
;**************************************************************************
cProc	GetSelText,<PUBLIC,NEAR>
	parmW	pb
	parmW	cbMax
cBegin
	cCall	GetEditText,<[pwndAct],[pb],[cbMax]>
cEnd


;***************************************************************************
; SetBookMark
; Purpose:
;  Sets to the specified bookmark (0 to 3)
;
; Entry:
;  cMark    - integer in range 0 to 3 specifying bookmark
;
; Exit:
;  Sets the specified bookmark to the current register set, otx, and column
;
;***************************************************************************

cProc	SetBookMark,<PUBLIC,NEAR>,<si>
	parmW	cMark
cBegin
DbAssertRel	cMark,b,MAXBOOKMARK,UI,<SetBookMark:cMark out of range>

	mov	si,dataOFFSET BookMarks
	mov	ax,size BookMark
	mov	cx,[cMark]
BookMarkValid:
	mul	cl
	add	si,ax
	cCall	GetEditLine
	cmp	pwndAct,OFFSET DGROUP:wndHelp	; displaying in help window
DJMP	jne	SetBookMarkNormal		; no, continue as normal

	
	;Since pwndAct = &wndHelp, the help window must be open.  Thus
	;we must be displaying a topic, hense the buffers must be allocated.
	
DbAssertTst	HelpFlags,nz,HLP_GOTBUF,UI,<SetBookMark:HLP_GOTBUF is FALSE>

	push	ax				; save edit line
	cCall	RetrieveHelpHistory		; pop last item
DbAssertRel	cx,ne,0,UI,<SetBookMark:Help Open with no help history>
	cCall	RecordHelpHistory		; put it back
	xchg	ax,cx				; CX = low word of item
						; DX = high word of item
	pop	ax				; AX = line #

	jmp	short SaveBookMarkVal
SetBookMarkNormal:
	mov	dx,NOT_HELPTOPIC		; flag as not a help topic
	mov	cx,[grs.GRS_oRsCur]		; Get oRs
SaveBookMarkVal:
	mov	[si].BM_Nc,dx			; save Nc
	mov	[si].BM_oRs,cx			; save oRs
	mov	[si].BM_oln,ax
	cCall	GetEditColumn
	mov	[si].BM_col,ax
SetBookMark_Exit:
cEnd

;***************************************************************************
; GotoBookMark
; Purpose:
;  Moves to the specified bookmark (0 to 3)
;
; Entry:
;  cMark    - integer in range 0 to 3 specifying bookmark
;
; Exit:
;  moves cursor to the specified bookmark
;
;***************************************************************************

cProc	GotoBookMark,<PUBLIC,NEAR>,<si,di>
	parmW	cMark
cBegin
DbAssertRel	cMark,b,MAXBOOKMARK,UI,<GotoBookMark:cMark out of range>

	mov	si,dataOFFSET BookMarks
	mov	ax,size BookMark
	mov	cx,[cMark]
	mul	cl
	add	si,ax
	cmp	[si].BM_oRs,UNDEFINED	; is this bookmark defined?
	jne	CheckHelpBookmark	; yes, go process it
Bleep_n_Exit:
	cCall	CowMoo			; inform user of problem
DJMP	jmp	short Nomark		; and exit
CheckHelpBookmark:			
	mov	dx,[si].BM_Nc		; get high word of help id
	cmp	dx,NOT_HELPTOPIC	; reference a help topic?
	je	GotoBookMarkNormal	; no, process as normally

	; we do not try to start the help system, as it is impossible
	; to have a help bookmark unless the help system is running.
	; Whenever the help system gets shut down, we are suspose to
	; clear all bookmarks into help related code.

DbAssertTst	HelpFlags,nz,HLP_GOTBUF,UI,<GotoBookMark:Help Bookmark exists when help system not started>

	mov	ax,[si].BM_oRs		; set DX:AX to context number
	mov	di,[si].BM_oLn		; DI = line # (engine) or -1 (varhlp)
	xor	bx,bx			; BX = 0
	;di = line # (engine) or 0  (varhelp)
	;bx = 0      (engine) or -1 (varhelp)

	PUSHI	cx,<OFFSET DGROUP:wndHelp> ; window to send message to
	PUSHI	cx,WM_HELPDISP		; message to send
	push	bx			; varhelp/engine help flag
	push	dx			; (long)context number
	push	ax			
	cCall	SendMessage		; redisplay the topic
	cmp	al,HELP_HANDLED 	; was it a handled error?
DJMP	je	NoMark			; yes, exit quietly
	or	al,al			; did we succeed?
DJMP	jne	Bleep_n_Exit		; no, inform user and exit


	PUSHI	ax,<OFFSET DGROUP:WndHelp> ; window to activate
	cCall	WndActivate		; goto help window

	mov	bx,di			; BX = line number
	jmp	short GotHelpBookMark	; move cursor

GotoBookMarkNormal:
	mov	ax,[si].BM_oRs
	cCall	UiRsActivate,<ax>
	cmp	[mRsCur.MRS_ogNam],OGNAM_IMMEDIATE ; is it immediate wnd?
	jne	PutInListWnd			   ; no, process as normal
	PUSHI	ax,<OFFSET DGROUP:WndCmd>	   ; window to activate
	cCall	WndActivate			   ; goto immediate window
	jmp	short GetBookMarkLine		   ; go move cursor
PutInListWnd:
	cCall	WndAssignList1

GetBookMarkLine:				   
	mov	bx,[si].BM_oln
GotHelpBookMark:
	mov	cx,[si].BM_col

;This is just MoveCursorPwndCur with a PostMsg instead of a SendMsg
	DbAssertRel [pwndAct],ne,0,UI,<GotoBookMark: pwndAct=0>
	DbAssertRel bx,ne,0ffffH,UI,<GotoBookMark: ln=ffff>
	DbAssertRel cx,ne,0ffffH,UI,<GotoBookMark: col=ffff>

	PUSHI	ax,[pwndAct]		; pwnd
	PUSHI	ax,EM_SELCHARS		; message
	push	bx			; wParam - line.
	push	cx			; lParam - start and end column
	push	cx

;We must post the message as opposed to sending it, because since the
;EditMgr can't be called recursively, it doesn't work properly.
	call	PostMessage
NoMark:
cEnd


;Added with [20]
;***
;ReAssignBookMark - change the oRs of bookmarks
;
;Purpose:
;	Changes the oRs of all bookmarks that match oRsOld to oRsNew.
;	This routine can be used to invalidate any bookmarks with a given
;	oRs by specifying UNDEFINED for oRsNew.
;
;Entry:
;	oRsOld	: oRs of bookmarks to be matched
;	oRsNew	: replacement value for oRs
;
;Exit:
;	None.
;
;Uses:
;	Per C Convention
;
;****

cProc	ReAssignBookMark,<PUBLIC,NEAR>
parmW	oRsOld
parmW	oRsNew
cBegin
	mov	bx,OFFSET DGROUP:BookMarks
	mov	cx,MAXBOOKMARK
	mov	ax,oRsOld		; put in AX for comparisons
	mov	dx,oRsNew		; put in DX for move
DiscardBookMarks:
	cmp	[bx].BM_oRs,ax		; does this bookmark have the oRs?
	jne	NextBookMark		; no, try the next one
	cmp	[bx].BM_Nc,NOT_HELPTOPIC; is it help engine help (not real ors)
	je	ChangeBookMark		; no, go reassign it
ChangeBookMark: 			
	mov	[bx].BM_oRs,dx		; reassign the bookmark
NextBookMark:
	add	bx,size BookMark
	loop	DiscardBookMarks
cEnd



;Added with [22]
;***
;DiscardHelpBookMarks - discard all bookmarks dealing with help
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per C Convention
;
;****

cProc	DiscardHelpBookMarks,<PUBLIC,NEAR>
cBegin
	mov	bx,OFFSET DGROUP:BookMarks
	mov	cx,MAXBOOKMARK
DiscardHelpBM:
	cmp	[bx].BM_Nc,NOT_HELPTOPIC	; is it help topic ?
	je	DiscardNext			; no, skip it
	mov	[bx].BM_oRs,UNDEFINED		; indicate no longer in use
DiscardNext:
	add	bx,size BookMark		; point to next bookmark
	loop	DiscardHelpBM			; check next one
cEnd


;***
;CowMoo: Beep the speaker
;
;Purpose:
;	Beeps the speaker by doing DoSound(0).
;
;Entry:
;	None.
;
;Exit:
;	None
;
;Preserves:
;	AX,BX,DX
;Uses:
;	CX,ES
;
;****

cProc	CowMoo,<PUBLIC,NEAR>,<AX,BX,DX>
cBegin
	xor	ax,ax			; do a regular beep, not a click
	cCall	DoSound,<ax>		; beep the speaker
cEnd

sEnd	UI

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uifile.c ===
/***
*uifile.c - Support File menu items.
*
*       Copyright <C> 1985-1988 Microsoft Corporation
*
*Purpose:
*       Support code for file menu items.
*
*******************************************************************************/

/* First, include version definition header */
#include <version.h>

/* Next, include COW's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>
#include <uiext.h>
#include <uinhelp.h>

#include <bios.h>                            // [QH1]

/* And the dialog information */
#include <cw/dlg.h>
#include "uifile.hs"
#include "uifile.sdm"

/* Next, include QBI's headers */
#ifndef CONTEXT_H
#include <context.h>
#endif

#ifndef HEAP_H
#include <heap.h>
#endif

#ifndef NAMES_H                                 /* [2]  */
#include <names.h>                             /* [2]  */
#endif                                          /* [2]  */

#ifndef PARSER_H
#include <parser.h>
#endif

#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef RTINTERP_H
#include <rtinterp.h>
#endif

#ifndef RTPS_H
#include <rtps.h>
#endif

#ifndef TXTMGR_H
#include <txtmgr.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

#ifndef UTIL_H
#include <util.h>
#endif

extern word NEAR RetryError (WORD);             //[22]
void FAR MakeRelativeFileSpec(char *, char *);
void NEAR LoadMerge(void);
BOOL near DoSaveFile(void);
STATICF(boolean) AskNotSavedInc(void);
WORD DoDlgLoadFile (void far *, WORD, WORD);
WORD DoDlgSaveFile (void far *, WORD, WORD);
extern BOOL NEAR ValidateFile (void);                   //[25]
extern BOOL NEAR ChangeDir (char *, WORD, char *);      //[25]
extern BOOL FAR fogNamUntitled(WORD);           //[49]

boolean far ClrModifiedInc(void);               //[24]
boolean far ClrModified(void);                  //[24][30]
void near ClrAllModified(bool);                 //[30]
boolean far SetAnyMrsMain(void);                //[31]

char *GetPrintDest (void);                               // [QH1]
DWORD FAR EditSubProc (PWND pwnd, WORD message,          // [QH1]
                       WORD wParam, DWORD lParam);       // [QH1]



WORD FAR WriteFileErr(WORD, char *, WORD );
BOOL IsDeviceReady (WORD iPort);

/* set by LoadFile() whenever a DATA statement is moved from a procedure
 * to module level
 */
extern bool fDataMoved;

bool fExiting = 0;              //[40] true if we are exitting QB.
char szPathSeparator[] = "\\";
char szNull[] = "";
char szUntitled[] = "Untitled"; //[49]
extern char szWildDefault[];    //[25] "*.bas" (defined in FILENAME.ASM)

extern ushort iHelpId;
bool fDirChanged = 0;           //[39] TRUE if b$Buf1 contains current
                                //[39] directory during a dialog.

bd bdFileLoad;
bd bdFileSave;
WORD oRsFileSave;
boolean fIsProgram = TRUE;      //[44] TRUE if program, FALSE if document
sd sdUntitled;                  //[45]


//
// [QH1] Start
//
extern bool fOptionsChanged;           // Has the printer setup been changed?
unsigned    iPrintPort;                // Printer port (LPT1, LPT2, COM1, etc)
bool        fPrintToFile;              // TRUE:Use file, FALSE:Use printer
char        szPrintDest[MAX_PATH];     // Print file
char       *aszDevices[] =             // Indexed via iPrintPort
{
    "LPT1",
    "LPT2",
    "LPT3",
    "COM1",
    "COM2"
};

extern char  szPrintSetup[];           // Declared in uirsrcc.c
extern char *szDialogTitle;            // Declared in uictl.c
extern WORD  cbDialogTitle;            // Declared in uictl.c

PLFN_WNDPROC pfnOldWndProc;            // Holds old edit-control proc

// Setting pwndPrintEdit != NULL enables special VK_TAB behavior in CW lib.
PWND pwndPrintEdit = NULL;

#define TAB  9
//
// [QH1] End
//



/* Terminology:
 * FileSpec = fully specified filename including optional drive, path, ext
 * FileName = directory relative filename, i.e. 8 letter base + extension
 * Path = drive and directory
 * Path + FileName = FileSpec
 * FILNAML - used in this file is imported from the runtime.
 *           it is the maximum legal file name. (see rtps.h)
 */


/***
*char *(FAR FileSpec (szFileSpec))
*Purpose:
*       Find the file name part of szFileSpec, and normalizes it.
*
*Entry:
*       szFileSpec      The File Spec to find file name of.
*
*Exit:
*       Return a pointer to the file name in szFileSpec.
*
*Exceptions:
*       None.
*******************************************************************************/

char *(FAR FileSpec (szFileSpec))
char *szFileSpec;
{
    char szFileName[FILNAML];

    strcpy (szFileName, szFileSpec);
    NormFileNameFar (szFileName, CbSzUi (szFileName), szFileSpec, szNull);
    return (b$PN_NAME);
}

/***
*void far MakeRelativeFileSpec (szFile, szWorkingDir)
*Purpose:
*       The given file spec in szFile is converted from a fully qualified
*       spec to a spec relative to the current directory.
*
*Entry:
*       szFile          The file spec.
*       szWorkingDir    The current working drive and directory.
*
*Exit:
*       Return relative path name in szFile.
*
*Exceptions:
*       None.
*******************************************************************************/
void FAR MakeRelativeFileSpec( szFile, szWorkingDir)
REG1 char *szFile;
char *szWorkingDir;
{
    REG2 WORD cb;
    char chSave;
    WORD result;
    register char *p;

    cb = CbSzUi (szWorkingDir);

    chSave = szFile[cb];
    szFile[cb] = 0;
    result = strcmp (szFile, szWorkingDir);
    szFile[cb] = chSave;
    if (result == 0) {
        /* szFile is a decendant of the working directory */
        if (cb == 3) {
            /* name is "<drive>:\".  Don't include '\' in count */
            cb = 2;
        }
        strcpy (szFile, szFile + cb + 1);
    }
    else {
        /* See if it is in a sibling */
        p = szWorkingDir + cb - 1;
        while (*p != '\\')
            p--;
        if (p > &szWorkingDir[3]) {
            *p = 0;
            cb = CbSzUi (szWorkingDir);
            chSave = szFile[cb];
            szFile[cb] = 0;
            result = strcmp (szFile, szWorkingDir);
            szFile[cb] = chSave;
            *p = '\\';

            if (result == 0) {
                strcpy (szFile, "..\\");
                strcat (szFile, szFile + cb + 1);
            }
        }
    }
}

/***
*BOOL FAR FDlgLoadFile (dlm, tmc, wNew, wOld, wParam)
*Purpose:
*       Dialog procedure for dlgFileLoad and dlgFileOpen.
*       Set the file listbox columns number on initialization, and
*       validates the filename.
*
*Entry:
*       dlm             dialog message type.
*       tmc             Ignored.
*       wNew            Ignored.
*       wOld            Ignored.
*       wParam          Ignored.
*
*Exit:
*       Return TRUE.
*
*Exceptions:
*       None.
*******************************************************************************/
BOOL FAR
FDlgLoadFile (dlm, tmc, wNew, wOld, wParam)
WORD dlm;
TMC tmc;
WORD wNew, wOld, wParam;
{
    Unreferenced (wNew);
    Unreferenced (wOld);
    Unreferenced (wParam);

    if (dlm == dlmInit) {
        SetTmcListWidth (tmcListFiles, 3);      // [10]
    } else {
        if ((dlm == dlmClick && tmc == tmcOK) ||
            (dlm == dlmDblClk && tmc == tmcListFiles)) {
            return (ValidateFile());
        }
    }
    return (TRUE);
}

/***
*BOOL FAR FDlgSaveCreateFile (dlm, tmc, wNew, wOld, wParam)
*Purpose:
*       Added with revision [25].
*
*       Dialog procedure for dlgFileSave and dlgFileCreate.
*       Validates the filename.
*
*Entry:
*       dlm             dialog message type.
*       tmc             Ignored.
*       wNew            Ignored.
*       wOld            Ignored.
*       wParam          Ignored.
*
*Exit:
*       Return TRUE.
*
*Exceptions:
*       None.
*******************************************************************************/
BOOL FAR
FDlgSaveCreateFile (dlm, tmc, wNew, wOld, wParam)
WORD dlm;
TMC tmc;
WORD wNew, wOld, wParam;
{
    Unreferenced (wNew);
    Unreferenced (wOld);
    Unreferenced (wParam);

    if (dlm == dlmClick && tmc == tmcOK) {
        return (ValidateFile());
    }

    return (TRUE);
}


/***
*WORD DoDlgLoadFile (pDlg, cbDlg, cabi)
*Purpose:
*       Do a file loading dialog until we get back a valid file name.
*
*       The path is put into bdFileLoad.
*
*Entry:
*       pDlg            File loading dialog.
*       cbDlg           Size of the dialog.
*       cabi            Cab index to initialize cab structure.
*
*Exit:
*       Returns file type returned for loaded file if dialog returns tmcOk,
*       or returns isNothing if tmcCancel, and leaves path in bdFileLoad.
*
*Exceptions:
*       None.
*******************************************************************************/
WORD DoDlgLoadFile (pDlg, cbDlg, cabi)
void far *pDlg;
WORD cbDlg, cabi;
{
    HCABFileOpen hcabFile;              //[22]
    sd  sdBuf2;                         //[25]
    WORD gr = FALSE;

    DbAssert (uierr == FALSE);                  //[22]
    hcabFile = (HCABFileOpen) HcabAlloc (cabi); //[22]
    if (uierr)  // If HcabAlloc failed, return cancelled
        return (isNothing);

    DbChkHoldBuf1();                    //[19] b$Buf1 used for life of routine
    DbChkHoldBuf2();                    //[19] b$Buf2 used for life of routine

    GetCurDriveDir (&b$Buf1);           //[19] save current dir in b$Buf1
    fDirChanged++;                      //[39] b$Buf1 contains directory

    if (bdFileLoad.pb != NULL)          //[25] if there was previous file loaded
        ChangeDir (bdFileLoad.pb, bdFileLoad.cbLogical, szNull);
                                        //[25] attempt to set current directory
                                        //[25] to that of last file loaded.
                                        //[25] Ignore errors.

    SzToCab (hcabFile, (cmdSwitches & CMD_SW_ED) ? "*.TXT" : szWildDefault, Iag (CABFileOpen, szFileName));     //[42]

    // [23] if SzToCab memory allocation failed, free cab and exit.
    if (uierr) {
        goto EndLoadFile;
    }

    HookInt24();        //[22] reset int 24 state so errors can be checked
    if (!(gr = (TmcDoDlgFar (pDlg, cbDlg, hcabFile) != tmcCancel)))
        goto EndLoadFile;

    DbAssert (b$fInt24Err == UNDEFINED);        //[25] no unhandled int24 errors

//[25] Realloc bdFileLoad to length of new pathname (in b$Buf2) and copy
//[25] b$Buf2 into it.
    sdBuf2.pb = &b$Buf2;                        //[25]
    sdBuf2.cb = CbSzUi(&b$Buf2);                //[25]
    if (!BdChgContents(&bdFileLoad,&sdBuf2)) {  //[25]
        SetUiErrOm ();                          //[25]
        goto EndLoadFile;                       //[25]
    }                                           //[25]

EndLoadFile:
    SetCurDir2 (&b$Buf1);               //[19] restore current directory
    fDirChanged--;                      //[39] b$Buf1 doesn't contain directory

    DbChkFreeBuf1();                    //[19] done with b$Buf1
    DbChkFreeBuf2();                    //[19] done with b$Buf2

    FreeCab (hcabFile);
    return gr;
}

/***
*WORD DoDlgSaveFile (pDlg, cbDlg, cabi)
*Purpose:
*       Do a file save dialog until we get back a valid file name.
*
*       The path is put into bdFileSave.
*
*Entry:
*       pDlg            File saving dialog.
*       cbDlg           Size of the dialog.
*       cabi            Cab index to initialize cab structure.
*
*Exit:
*       Returns file type returned for saved file if dialog returns tmcOk,
*       or returns isNothing if tmcCancel, and leaves path in bdFileSave.
*
*Exceptions:
*       None.
*******************************************************************************/
WORD DoDlgSaveFile (pDlg, cbDlg, cabi)
void far *pDlg;
WORD cbDlg, cabi;
{
    HCABFileSave hcabFileSave;
    WORD oRsFound;
    WORD id;
    char *pName;                        //[25]
    WORD gr;

    DbAssert (uierr == FALSE);                          //[22]
    hcabFileSave = (HCABFileSave) HcabAlloc (cabi);     //[22]
    if (uierr)  // If HcabAlloc failed, return cancelled
        return FALSE;

    DbChkHoldBuf1();                    //[19] b$Buf1 used for life of routine
    DbChkHoldBuf2();                    //[19] b$Buf2 used for life of routine

    GetCurDriveDir (&b$Buf1);           //[19] save current dir in b$Buf1
    fDirChanged++;                      //[39] b$Buf1 contains directory

    while (TRUE) {                      //[25]

        gr = FALSE;                     //[37] assume error

        if (ChangeDir (bdFileSave.pb, bdFileSave.cbLogical, szNull)) //[25]
                                        //[25] attempt to set current dir to
                                        //[25] that of last file file saved.
            pName = bdFileSave.pb;      //[25] if error, use full pathname
        else
            pName = b$PN_NAME;          //[25] if successful, use only name
                                        //[25] portion
        strcpy (&b$Buf2, pName);        //[35] ensure static before SzToCab
        SzToCab (hcabFileSave, &b$Buf2, Iag (CABFileSave, szFileName)); //[35]
        // [23] if SzToCab memory allocation failed, free cab and exit.
        if (uierr)                      //[37]
            break;                      // return isNothing

        (*hcabFileSave)->u.sab = sabSaveAll;    /* [8] */

        HookInt24();    //[22] reset int 24 state so errors can be checked
        if (TmcDoDlgFar (pDlg, cbDlg, hcabFileSave) == tmcCancel)
            break;                              // return isNothing

        DbAssert (b$fInt24Err == UNDEFINED);    //[25] no unhandled int24 errors

        if (!BdRealloc(&bdFileSave, CbSzUi(&b$Buf2)+1)) { //[51] Grow bd if needed
            SetUiErrOm ();                      //[51] OM if no space
            break;
        }

        strcpy (bdFileSave.pb, &b$Buf2);        //[25] copy pathname into bd
        bdFileSave.cbLogical--;                 //[51] Don't include 0 term.

        if (!(oRsFound = OgNamOfPsd((sd *)&bdFileSave))) { //[27]
            SetUiErrOm ();                      //[27] out of memory
            break;                              //[27] return isNothing
        }                                       //[27]

        gr = TRUE;
        oRsFound = MrsFind(oRsFound);           //[27]
        DbAssert (oRsFound != 0);  /* out-of-memory not possible */
        if (oRsFound != oRsFileSave) {
            /* user renamed mrs during dialog - remember to make sure
             * file doesn't already exist on disk */
            mrsCur.flags2 |= FM2_NewFile;
        }
        if ((oRsFound != UNDEFINED) &&
            (oRsFound != oRsFileSave)) {
            /* tried to save module with name of another already loaded
             * module - we can't 2 mrs's in memory with same name */
            MsgBoxStd( MB_OK, MSG_ModuleExists );
            continue;           // prompt for filename again
        }
        if (mrsCur.flags2 & FM2_NewFile) {
            mrsCur.flags2 &= ~FM2_NewFile;
            if (FileExists(bdFileSave.pb)) {
                /* file already exists */
                id = MsgBoxStd (MB_YESNOCANCEL, MSG_Overwrite);
                /* File already exists.  Over write? */
                if (id == IDNO)
                    continue;   /* prompt for FileName again */
                UiRsActivate (oRsFileSave);
                /* MsgBoxStd could have altered grs.oRsCur */
                if (id == IDCANCEL) {
                    gr = FALSE;
                    mrsCur.flags2 |= FM2_NewFile;
                }
            }
        }
        break;
    }   // while (TRUE)

    SetCurDir2 (&b$Buf1);               //[19] restore current directory
    fDirChanged--;                      //[39] b$Buf1 doesn't contain directory

    DbChkFreeBuf1();                    //[19] done with b$Buf1
    DbChkFreeBuf2();                    //[19] done with b$Buf2

    FreeCab (hcabFileSave);
    return gr;
}

/***
*void near CmdFileNew ()
*Purpose:
*       Perform File Menu, New Program command.  Eliminates all current
*       code, and initializes new program.
*
*Entry:
*       None.
*
*Exit:
*       None.
*
*Exceptions:
*       None.
*******************************************************************************/
VOID NEAR CmdFileNew ()
{
    // [26] If NewStmt succeeds, it calls MrsDiscard which calls WndReAssign
    // [26] to change all visible window's oRs's
    uierr = CallRtTrap (NewStmt);
    if (!uierr && (cmdSwitches & CMD_SW_ED)) {  //[45][47]
        sdUntitled.pb = szUntitled;             //[49]
        sdUntitled.cb = CbSzUi(szUntitled);     //[49]
        RsMake (&sdUntitled, RS_document);      //[45]
    }                                           //[45]
    fIsProgram = !(mrsCur.flags2 & FM2_NoPcode);
    DrawDebugScr ();
}

boolean far ClrModified() {
    mrsCur.flags2 &= ~FM2_Modified;
    return(TRUE);
}

boolean far ClrModifiedInc() {
    if (mrsCur.flags2 & FM2_Include) {
        mrsCur.flags2 &= ~FM2_Modified;
    }
    return(TRUE);
}

void near ClrAllModified(bool fAll) {
    ForEach(FE_PcodeMrs+FE_CallMrs+FE_TextMrs+FE_SaveRs+FE_FarCall,
            fAll ? ClrModified : ClrModifiedInc);
}

/***
*void near DoLoadFile (otx, pbdFileName)
*Purpose:
*       Load a file, handling INT24 errors.
*
*Entry:
*       otx             = LF_NewProg if pcode-module is to be added after
*                         doing a NewStmt.
*                       = LF_NewModule if pcode-module is to be added.
*                       = LF_NewDoc if a document-module is to be added.
*                       = otherwise otx is the text offset of a file to be
*                         merged into the current text table.
*
*Exit:
*       uierr is set to standard error code if any error occurs.
*
*Exceptions:
*       None.
*******************************************************************************/
void near DoLoadFile (otx, pbdFileName)
WORD otx;
bd * pbdFileName;
{
    WORD oRsSave;
    struct ef *pef;
    PWND pwnd;
    short result;                                       //[24]

    pwnd = (pwndAct == &wndCmd || pwndAct == &wndHelp) ? pwndTop : pwndAct;
    pef = (struct ef *) pwnd->pefExtra;                 // [36]
    oRsSave = pef->hBuffer;

    if (otx == LF_NewProg) {                            //[24]
        result = NotSavedIncSav();                      //[24]
        if (result > 0)                                 //[24]
            return;                                     //[24]
        else if (result < 0)                            //[24]
            ClrAllModified(FALSE);                      //[24][30]
        TxtReInclude();                                 //[24]
    }                                                   //[24]

LoadRetry:
    if (LoadFile ((sd *) pbdFileName, otx) != 0) {
        DoDrawDebugScr ();
        if ((result = RetryError(txtErr.errCode)) == IDRETRY)   //[38] if
                                                //[38] retryable error,
                                                //[38] put up retry/cancel box
            goto LoadRetry;                     //[38] user said to retry

        if (result != IDCANCEL)                 //[38] if CANCEL not hit, put
            uierr = txtErr.errCode;             //[38] up a message box later
        /* If the buffer is still around, reactivate it and make it visible */
        if ((otx != LF_NewProg) && (otx != LF_NewDoc)) {        //[49]
            UiRsActivate (oRsSave);
            WndAssign ();
        }
    }
}

/***
*void NEAR LoadMerge ()
*Purpose:
*       Display the dialog for FILE/OPEN, FILE/MERGE, or FILE/LOAD.
*
*Entry:
*       otx             = LF_NewProg if pcode-module is to be added after
*                         doing a NewStmt.
*                       = LF_NewModule if pcode-module is to be added.
*                       = LF_NewDoc if a document-module is to be added.
*                       = otherwise otx is the text offset of a file to be
*                         merged into the current text table.
*
*Exit:
*       None.
*
*Exceptions:
*       None.
*******************************************************************************/
void NEAR LoadMerge ()
{
    /* Don't let user load such a long program that he can't even execute a
     * CLEAR statement.
     */
    UiGrabSpace();

    /* DoDlgLoadFile will set bdFileLoad */
    if (DoDlgLoadFile (&dlgFileOpen, sizeof (dlgFileOpen),      //[43][47]
                       cabiCABFileOpen)) {                      //[43][47]
        fDataMoved = FALSE;
        DoLoadFile ((cmdSwitches & CMD_SW_ED) ? LF_NewDoc : LF_NewProg, &bdFileLoad);   //[47]
        /* causes rsNew to get set, which causes WnReset to display
         * new register set in a list window */
        if (fDataMoved && uierr == 0)
            MsgBoxStd (MB_OK, MSG_DataMoved);
    }

    UiReleaseSpace ();   /* free temp space reserved by UiGrabSpace */

}

VOID NEAR CmdFileOpen ()
{
    LoadMerge ();
    fIsProgram = !(mrsCur.flags2 & FM2_NoPcode);        //[44]
    DrawDebugScr ();    // [41]
}

/***
*BOOL near DoSaveFile ()
*Purpose:
*       Actually save a module to disk.
*
*Entry:
*       mrsCur identifies the module to be saved.
*       mrsCur.ogNam identifies the filename to save it as.
*
*Exit:
*       returns FALSE if file saved successfully
*       uierr = error code if any.
*
*Exceptions:
*       None.
*******************************************************************************/
BOOL near DoSaveFile ()
{
    WORD errCode;
    WORD result;                                //[38]

    UiGrabSpace ();
    /* SaveFile() can generate synthetic DECLAREs that could steal
     * memory from our ability to execute a SYSTEM, CLEAR, or SETMEM stmt.
     */

    if (mrsCur.flags2 & (FM2_NoPcode | FM2_Include)) {
        /* DOCUMENT and $INCLUDE files should only be saved in ASCII format */
        mrsCur.flags2 |= FM2_AsciiLoaded;
    }
SaveRetry:
    if ((errCode = SaveFile()) != 0) {
        if ((result = RetryError(errCode)) == IDRETRY)  //[38] if retryable err
                                                //[38] put up retry/cancel box
            goto SaveRetry;   /* user wants to retry */

        if (result != IDCANCEL)                 //[38] if CANCEL not hit, put
            SetUiErr (errCode);                 //[38] up a message box later
        rsNew = grs.oMrsCur;    /* show offending mrs in list window */
    }
    UiReleaseSpace ();
    return (errCode);
}

/***
*STATICF(boolean) AskNotSavedInc ()
*Purpose:
*       Ask user if he wants to save modifed include files before saving
*       the current file.  This is so synthetic DECLAREs won't be generated
*       if they were already entered into a modifed $INCLUDE file.
*
*Entry:
*       None.
*
*Exit:
*       If NO, or if all files were saved OK, uierr = 0, returns TRUE.
*       If CANCEL, uierr = MSG_GoDirect, returns FALSE.
*       If I/O error, uierr = error code, returns FALSE.
*
*Exceptions:
*       None.
*******************************************************************************/
STATICF(boolean)
AskNotSavedInc ()
{
    short result;

    /* don't prompt if user is currently saving an INCLUDE file,
     * they never get synthetic DECLAREs anyway
     */
    if ((mrsCur.flags2 & FM2_Include) == 0) {
        /* prompt user with "Save modified $INCLUDE files first?" */
        if ((result = NotSavedIncSav ()) > 0) {
            /* some error occurred, or user pressed CANCEL - abort
             * uierr already set */
            return FALSE;
        }
        if (result == 0) {
            /* One or more files needed to be saved.
             * No error occurred saving INCLUDE files.
             * Re-parse all $INCLUDE lines to pick up changes
             * Ignore errors while re-parsing $INCLUDE lines, like file-not-found
             * We're just trying to prevent redundant synthetic declares
             */
            TxtReInclude ();
        } /* else user didn't need to, or chose not to save include files */
    }
    return TRUE;
}

/***
*boolean NEAR CmdFileSaveAs ()
*Purpose:
*       Prompt the user for a filename, then save current module.
*
*Entry:
*       mrsCur identifies the module to be saved.
*       mrsCur.ogName identifies the filename to save it as.
*
*Exit:
*       Returns TRUE if user didn't press CANCEL in Save dialog box, and
*       there was no I/O error.  If I/O error, uierr = error code.
*
*Exceptions:
*       None.
*******************************************************************************/
boolean NEAR CmdFileSaveAs ()
{
    WORD gr;

    oRsFileSave = grs.oMrsCur;  /* save oRs of module being saved */

    /* Ask user if he wants to save modified include files first.
     * This is so synthetic DECLAREs won't be generated if they
     * were already entered into a modified $INCLUDE file.
     * If CANCEL, MSG_GoDirect; if user said NO, FFFF;
     * if I/O error, error code; if files saved ok, ax=0
     */
    if (!AskNotSavedInc ())
        return FALSE;

    UiGrabSpace ();
    if (!BdAlloc (&bdFileSave, FILNAML, IT_NO_OWNERS)) {
        SetUiErrOm ();
        goto CmdFileSaveAsEnd;
    }

    if (!fogNamUntitled(mrsCur.ogNam)) {                                 //[49]
        bdFileSave.cbLogical = CopyOgNamPb(bdFileSave.pb, mrsCur.ogNam); //[25]
        DbAssert (bdFileSave.cbLogical < FILNAML);
    } else
        *(bdFileSave.pb) = 0;   //[25] ensure first byte is a NULL, so ChangeDir
                                //[25] will exit without doing anything drastic

    if (gr = DoDlgSaveFile (&dlgFileSave, sizeof (dlgFileSave), cabiCABFileSave)) {
        /* activate active module's register set */
        /* DialogBox() activates other oRs's */
        UiRsActivate (oRsFileSave);

        /* User didn't press CANCEL button */
        /* Assume ASCII save is desired */
        mrsCur.flags2 |= FM2_AsciiLoaded;
        if ((mrsCur.ogNam = OgNamOfPsd ((sd *) &bdFileSave)) == 0)  /* [2] */
             SetUiErrOm ();
        else {
            DrawDebugScr ();
            DbAssert (oRsFileSave == grs.oRsCur);
            gr = !DoSaveFile ();
        }
    }

    BdFree (&bdFileSave);
    /* caller's depend on this */
    DbAssert (!gr || oRsFileSave == grs.oRsCur);

CmdFileSaveAsEnd:
    UiReleaseSpace ();
    return (uierr == 0 && gr);
}

/***
*boolean NEAR CmdFileSave ()
*Purpose:
*       Save current file.
*
*Entry:
*       mrsCur identifies module to be saved.
*       mrsCur.ogName identifies file name to save it as.
*
*Exit:
*       Returns TRUE if user didn't press CANCEL in Save dialog box, and
*       there was no I/O error.  If I/O error, uierr = error code.
*
*Exceptions:
*       None.
*******************************************************************************/
boolean NEAR CmdFileSave ()
   {
   /* Ask user if he wants to save modified include files first.
    * This is so synthetic DECLAREs won't be generated if they
    * were already entered into a modified $INCLUDE file.
    * If CANCEL, MSG_GoDirect; if user said NO, FFFF;
    * if I/O error, error code; if files saved ok, ax=0
    */
   if (!AskNotSavedInc ())
      return FALSE;

   if (fogNamUntitled(mrsCur.ogNam)) { /* [49] */
      /* Prompt user for name of <Untitled> module. */
      return (CmdFileSaveAs ());
   }
   return (!DoSaveFile() && uierr == 0);
}

/***
*boolean NEAR CmdFileSaveAll (fInclude)
*Purpose:
*       Save all modified files.
*
*Entry:
*       fInclude        If true, only INCLUDE mrs's are saved.
*
*Exit:
*       Returns TRUE if user didn't press CANCEL in Save dialog box, and
*       there was no I/O error.  If I/O error, uierr = error code.
*
*Exceptions:
*       None.
*******************************************************************************/
boolean NEAR CmdFileSaveAll(fInclude)
boolean fInclude;
{
   BYTE pass;

  /* This function alters ps.bdpSrc, which edit mgr also
   * uses to keep its current line in.  EditMgrFlush1 tells edit
   * mgr to forget that ps.bdpSrc contains the current cached line.
   * This is done in DoMenu() for CmdFileSave[As], but since this
   * function is called from places other than DoMenu(), we need to
   * do it here. */
   EditMgrFlush1 ();

   /* First save all modified INCLUDE files, so synthetic DECLARE
    * statements won't be generated when other modules which include
    * the include files are saved.
    */
   for (pass = 0; ++pass < 3; ) {
      UiRsActivate (UNDEFINED);
      while (uierr == 0 && NextMrsFile_All () != UNDEFINED) {   //[39]
         if (mrsCur.flags2 & FM2_Modified) {
            /* during pass 1, just save $INCLUDE files */
            if (pass == 2 || (mrsCur.flags2 & FM2_Include)) {
               if (fogNamUntitled(mrsCur.ogNam)) {      //[49]
                  /* Make Untitled mrs visible in active window so user
                   * see's which mrs he's being prompted for.
                   */
                  WndAssignList ();
                  DoDrawDebugScr ();
               }
               if (!CmdFileSave ())
                  return FALSE;
            }
         }
      } /* while */
      if (fInclude)
         break;   /* caller just wanted to save INCLUDE files */
      if ((uierr = TxtReInclude ()) != 0)
         return FALSE;   /* errors occurred re-parsing $INCLUDE lines */
   }
   return TRUE;
}

/***
*VOID NEAR CmdFilePrint ()
*Purpose:
*       Display the print dialog box and print the requested portion of text.
*
*Entry:
*       None.
*
*Exit:
*       Trashes ldEMScratch buffer.
*
*Exceptions:
*       None.
*******************************************************************************/
VOID NEAR CmdFilePrint ()
{
    REG1                printScope;
    REG2                cLnCur;
    WORD                fhPrinter, cbRead, rgLns[2], singleLn = 0;
    TMC                 tmc;
    struct ef          *pef = (struct ef *) pwndAct->pefExtra;  // [36]
    WORD                FilePrintDefault;                       //[17]


//
// [QH1] Start
//
    if (cmdSwitches & CMD_SW_QHELP)
    {
        HCABFilePrintQH       hcabFilePrintQH;

        DbAssert (uierr == FALSE);
        hcabFilePrintQH = (HCABFilePrintQH) HcabAlloc (cabiCABFilePrintQH);
        /* [4] If HcabAlloc failed, return */
        if (uierr)
            return;

        if (fPrintToFile)
            (*hcabFilePrintQH)->oFilePrintQHDest = isFilePrintQHFile;
        else
            (*hcabFilePrintQH)->oFilePrintQHDest = isFilePrintQHPrinter;
        SzToCab (hcabFilePrintQH, szPrintDest, Iag(CABFilePrintQH,szPrintFile));

        tmc = TmcDoDlgFar (&dlgFilePrintQH, sizeof (dlgFilePrintQH), hcabFilePrintQH);

        if (tmc == tmcOK)
        {
            fOptionsChanged = TRUE;
            fPrintToFile = (bool)
                ((*hcabFilePrintQH)->oFilePrintQHDest == isFilePrintQHFile);
            if (fPrintToFile)
                SzFromCab (hcabFilePrintQH, szPrintDest, MAX_PATH-1,
                           Iag(CABFilePrintQH,szPrintFile));
        }
        FreeCab (hcabFilePrintQH);
        printScope = isFilePrintCurrentWindow;
    }
//
// [QH1] End
//
    else
    {
        HCABFilePrint       hcabFilePrint;

        if (pef->fSelection)                                        //[16]
            FilePrintDefault = isFilePrintSelectedText;             //[16]
        else if (pwndAct == &wndHelp || cmdSwitches & CMD_SW_ED)    //[50]
            FilePrintDefault = isFilePrintCurrentWindow;            //[50]
        else                                                        //[16]
            FilePrintDefault = isFilePrintCurrentModule;            //[16]

        DbAssert (uierr == FALSE);                                  //[22]
        hcabFilePrint = (HCABFilePrint) HcabAlloc (cabiCABFilePrint);
        /* [4] If HcabAlloc failed, return */
        if (uierr)
            return;

        (*hcabFilePrint)->oFilePrintWhat = FilePrintDefault;
        /* [5] Do Easy dialog if Easy Menu option is TRUE */

        if (pwndAct == &wndHelp)                               //[15]
            (*hcabFilePrint)->u.sab = sabPrintHelp;                 //[15]
        else                                                        //[15]
            (*hcabFilePrint)->u.sab = (cmdSwitches & CMD_SW_ED) ?           //[47]
                                       sabPrintQedit : sabPrintQbas;        //[42][47]
        tmc = TmcDoDlgFar (&dlgFilePrint, sizeof (dlgFilePrint), hcabFilePrint);
        printScope = (*hcabFilePrint)->oFilePrintWhat;
        FreeCab (hcabFilePrint);
    }


    rgLns[0] = 0;

    /* activate the proper rs and modify scope variables if necessary if cancel
     * was requested the case will exit the procedure via goto */
    UiRsActivateWnd ();

    /* If printer not available, exit */
    if (uierr || tmc == tmcCancel) goto justExit;

    switch (printScope) {
        case isFilePrintCurrentModule:
            UiRsActivate (grs.oMrsCur);
            break;
        case isFilePrintSelectedText :
            singleLn = GetSelText (ldEMScratch.prgch, ldEMScratch.cbMax);
            /* if there is no text selected exit routine */
            if (!SendMessage (pwndAct, EM_GETLINESEL, (WORD) rgLns, 0L) &&
                !singleLn)
                goto justExit;
            break;
    }

    /***
     *  - print scope globals should be set up as follows:
     *      begLn, endLn    line range, 0 and ??? unless a multiple line
     *                      selection is being printed.
     *                      begLn is rgLns [ 0 ], endLn is rgLns [ 1 ]
     *      singleLn        != 0 => single line selection, == 0 => not sls
     ***/

    /* set up the alphabetical procedure listing */
    if (UiAlphaORsBuild () == 0) {
        SetUiErrOm();
        goto justExit;
    }

    /* open up the printer for write access, and abort if we get an error */

    if ((fhPrinter = CreateFile (GetPrintDest())) == UNDEFINED)     // [QH1]
    {                                                               // [QH1]
        if (cmdSwitches & CMD_SW_QHELP)                             // [QH1]
        {                                                           // [QH1]
            if (fPrintToFile)                                       // [QH1]
                SetUiErr (ER_IOE);                                  // [QH1]
            else                                                    // [QH1]
                SetUiErr (ER_DF);                                   // [QH1]
        }                                                           // [QH1]
        else                                                        // [QH1]
            SetUiErr(ER_IOE);
        goto justExit;
    }

    // If printing to printer, check that it's connected ok.        // [QH1]
    if (cmdSwitches & CMD_SW_QHELP)                                 // [QH1]
    {                                                               // [QH1]
        if ((!fPrintToFile) && (!IsDeviceReady(iPrintPort)))        // [QH1]
        {                                                           // [QH1]
            SetUiErr (ER_DF);                                       // [QH1]
            goto justExit;                                          // [QH1]
        }                                                           // [QH1]
    }                                                               // [QH1]

    if (!fPrintToFile)                                         // [QH1]
        StatusLineMsg(-MSG_Prt1);   /* "Waiting for printer" */

    /* loop through each line in each prs in each mrs in print scope */
    do {
        do {
            DbAssert (grs.oRsCur != UNDEFINED);
            /* set up endLin if printScope isn't selected text so that cbGetLine
             * gets valid line offsets */
            if (printScope != isFilePrintSelectedText) {
                rgLns[1] = (pwndAct == &wndHelp) ?              //[50]
                             (WORD)SendHelpMsg(WM_HELPFILESIZE,0) ://[50]
                             LinesInBuf(grs.oRsCur);            //[50]
                if (rgLns[1]) rgLns[1]--;                       //[50] make 0 relative
            }
            for (cLnCur = rgLns[0]; cLnCur <= rgLns[1]; cLnCur++) {
                /* grab line from prs */
                if (singleLn)
                    cbRead = GetSelText (ldEMScratch.prgch, ldEMScratch.cbMax);
                else
                if (pwndAct == &wndHelp)                //[16]
                     cbRead = (ushort) SendMessage(pwndAct,WM_HELPLINE,cLnCur,  //[34]
                              MAKELONG(ldEMScratch.cbMax,ldEMScratch.prgch));   //[34]
                else                                    //[16]
                    cbRead = cbGetLineBuf (grs.oRsCur, cLnCur,
                                           ldEMScratch.cbMax, ldEMScratch.prgch);
                /* print line, if an error occurs set uierr to i/o error */
                if ((uierr = WriteFileErr (fhPrinter, ldEMScratch.prgch, cbRead))
                    == 0)
                   uierr = WriteFileErr (fhPrinter, "\015\012", 2);
                if (uierr != 0) {
                    SetUiErr (uierr);
                    if ((cmdSwitches & CMD_SW_QHELP) && !fPrintToFile) // [QH1]
                        SetUiErr (ER_DF);                              // [QH1]
                    goto closeAndExit;
                }

                StatusLineMsg (-MSG_Prt2);      /* "Printing" */

                fPollKeyboard = TRUE;
                PollKeyboard ();                // [33]
                if (fAbort)                     // [33]
                    goto closeAndExit;
            }
            WriteFileErr (fhPrinter, "\015\012", 2);
        }
        while (printScope != isFilePrintSelectedText &&
               printScope != isFilePrintCurrentWindow &&        //[50]
               NextAlphaPrs () != 0) ;
    }
    while (FALSE) ;

    if ((cmdSwitches & CMD_SW_QHELP) && !fPrintToFile)               // [QH1]
    {   //                                                           // [QH1]
        // Tell printer to flush/print the page                      // [QH1]
        //                                                           // [QH1]
        WriteFileErr (fhPrinter, "\014", 1);                         // [QH1]
    }                                                                // [QH1]

closeAndExit:
    CloseFileNear (fhPrinter);          //[32]
justExit:
    DoStatusMsg(pwndAct);   //[9] restore normal status line message
    return;
}                   /* end of CmdFilePrint */



// [QH1]
/****************************************************************************
*  IsDeviceReady() - Does the port have a printer hooked to it?
*
*  Entry
*     iPort - DEV_LPT1, DEV_LPT2, DEV_LPT3, DEV_COM1, DEV_COM2
*  Entry
*     TRUE if port is usable, FALSE if not.
*  NOTES
*     (Info taken from MSD 2.00a)
****************************************************************************/
BOOL IsDeviceReady (WORD iPort)
{
    WORD status;
    BOOL bReady = TRUE;

//
// BUGBUG a-emoryh 10/31/92 - May want to implement COM-port checking too
//

    if (iPort >= DEV_LPT1 && iPort <= DEV_LPT3)
    {
        iPort -= DEV_LPT1;
        status = _bios_printer (_PRINTER_STATUS, iPort, 0);

        bReady &= (status & 0x06) ? FALSE : TRUE;        // Port detected?
        bReady &= (status & 0x10) ? TRUE  : FALSE;       // Online?
        bReady &= (status & 0x20) ? FALSE : TRUE;        // Paper out?
        bReady &= (status & 0x08) ? FALSE : TRUE;        // IO error?
    }
    else       // If COM Port
    {
       bReady = TRUE;
    }
    return (bReady);
}



// [QH1]
/*****************************************************************************
*BOOL FAR FDlgFilePrintQH (dlm, tmc, wNew, wOld, wParam)
*Purpose:
*       Dialog procedure for FilePrintQHelp dialog
*
*Entry:
*Exit:
*       Return TRUE.
*****************************************************************************/
BOOL FAR FDlgFilePrintQH (WORD dlm, TMC tmc, WORD wNew, WORD wOld, WORD wParam)
{
    Unreferenced (wNew);
    Unreferenced (wOld);
    Unreferenced (wParam);

    switch (dlm)
    {
        case dlmInit:
            // Subclass the edit control, so we can trap up/down arrow keys
            // Yah, i know it's not a listbox, but this guy works anyway.
            pwndPrintEdit = PwndOfListbox(tmcFilePrintQHEdit);
            pfnOldWndProc = pwndPrintEdit->pfnWndProc;
            SetWindowProc (pwndPrintEdit, (PLFN_WNDPROC)EditSubProc);

            // Display current printer port selection
            SetTmcText (tmcFilePrintQHPort, aszDevices[iPrintPort]);
            break;

        case dlmTerm:
            // Make sure this guy gets set to NULL before exiting the dialog!
            pwndPrintEdit = NULL;
            break;

        case dlmClick:
            if (tmc == tmcPrintSetup)
            {   //
                // Display the PrinterSetup sub-dialog, which lets user select
                // printer port.
                //
                HCABPrintSetup  hcabPrintSetup;
                char *pszOldTitle;
                WORD  cbOldTitle;

                DbAssert (uierr == FALSE);
                hcabPrintSetup = (HCABPrintSetup) HcabAlloc (cabiCABPrintSetup);
                /* If HcabAlloc failed, return */
                if (uierr)
                    return TRUE;

                // Save previous dialog title
                pszOldTitle = szDialogTitle;
                cbOldTitle  = cbDialogTitle;

                // Set the new title
                szDialogTitle = szPrintSetup;               // Globals used by
                cbDialogTitle = 0;                          //   TmcDoDlgFar().

                (*hcabPrintSetup)->oPrintSetupPort = iPrintPort;

                tmc = TmcDoDlgFar(&dlgPrintSetup, sizeof(dlgPrintSetup),
                                  hcabPrintSetup);
                if (tmc == tmcOK)
                {
                    iPrintPort = (*hcabPrintSetup)->oPrintSetupPort;
                    // Change displayed port name in FilePrint dialog.
                    SetTmcText (tmcFilePrintQHPort, aszDevices[iPrintPort]);
                    fOptionsChanged = TRUE;
                }

                // Restore previous dialog title
                szDialogTitle = pszOldTitle;
                cbDialogTitle = cbOldTitle;

                FreeCab (hcabPrintSetup);
                break;
            }
            break;

        case dlmSetFocus:
            switch (tmc)
            {
                case tmcQHFile:
                    //
                    // Enable filename edit-control, and set focus to it
                    //
                    if (!FEnabledTmc(tmcFileName))
                    {
                        EnableTmc (tmcFilePrintQHEdit, TRUE);
                        EnableTmc (tmcFileName,        TRUE);
                    }
                    SetFocusTmc(tmcFilePrintQHEdit);
                    break;

                case tmcQHPrinter:
                    //
                    // Disable file edit-control, since printer was selected
                    //
                    if (FEnabledTmc(tmcFileName))
                    {
                        EnableTmc (tmcFilePrintQHEdit, FALSE);
                        EnableTmc (tmcFileName,        FALSE);
                    }
                    break;
            }
            break;
    }

    return (TRUE);
}



// [QH1]
/*****************************************************************************
*  EditSubProc() -
*     Subclasses the edit-control in QH FilePrint dialog, allowing the arrow
*     keys to move user to the other radio-buttons (since this edit-control is
*     bound to one of the radio buttons).
*  Entry:
*  Exit:
*****************************************************************************/
DWORD FAR EditSubProc (PWND pwnd, WORD message, WORD wParam, DWORD lParam)
{
    switch (message)
    {
        case WM_CHAR:
            switch (wParam)
            {
                case VK_UP:
                case VK_DOWN:
                    // Set focus to printer radio-button, and select it
                    SetFocusTmc (tmcQHPrinter);
                    SetTmcVal (tmcFilePrintQHDest, isFilePrintQHPrinter);
                    break;

                case VK_TAB:
                case TAB:
                    // SDM default tab behavior wasn't working for this edit,
                    // so we handle the tab ourselves.  Note that we have a
                    // special hack in DLGCORE.C to give us tab messages here.
                    if (HIWORD(lParam) & KK_SHIFT)
                        SetFocusTmc (tmcHelp);
                    else
                        SetFocusTmc (tmcOK);
                    return (0l);
            }
    }
    return ((*pfnOldWndProc)(pwnd,message,wParam,lParam));
}



/***
*bool far SetMrsMain
*Purpose:
*       Called by ForEachMrs.
*       Sets grs.oMrsMain to grs.oMrsCur and returns FALSE to stop ForEachMrs
*
*       New for revision [31]
*
*Entry:
*       grs.oMrsCur
*
*Exit:
*       grs.oMrsMain == grs.oMrsCur
*       return FALSE
*
*******************************************************************************/
boolean far SetAnyMrsMain() {
     grs.oMrsMain = grs.oMrsCur;
     return(FALSE);
}

/***
*VOID NEAR CmdFileExt ()
*Purpose:
*       Exit from program.
*
*Entry:
*       None.
*
*Exit:
*       Cmd buffer has "system" command to exit from program.
*
*Exceptions:
*       None.
*******************************************************************************/
VOID NEAR CmdFileExit()
{
   int result;                          //[30]

   result = NotSaved();                 //[30]
   if (result > 0)                      //[30]
      return;                           //[30]
   if (result < 0)                      //[30]
      ClrAllModified(TRUE);             //[30]

   //[31] We need a main module to execute the SYSTEM command.
   //     At this point we will absolutely not be comming back,
   //     so it does not matter which module is main.
   //     Make the main module oMrsCur so we don't get a `No main module'
   //     dialog.
   ForEachMrs(SetAnyMrsMain);           //[31]
   DoCmd("system");
   fExiting = TRUE;                     //[40]
}



// [QH1]
/***  GetPrintDest() -- Retrieves current destination for printing
 *
 *  User has a choice of printing to LPT1, LPT2, LPT3, COM1, COM2, or a file.
 *
 *  Entry
 *      None
 *
 *  Exit
 *      Returns ptr to name of print dest - ("LPT1", "COM2", "C:\FOO.TXT", etc)
 *      This ptr is READ-ONLY!!
 */
char *GetPrintDest (void)
{
    char *pszDest;

    if (cmdSwitches & CMD_SW_QHELP)
    {
        if (fPrintToFile)
            pszDest = szPrintDest;
        else
            pszDest = aszDevices[iPrintPort];
    }
    else
    {   //
        // If not in QHelp mode, revert to old LPT1 print-dest
        //
        pszDest = aszDevices[DEV_LPT1];
    }
    return (pszDest);
}






=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uihelp.c ===
/***
*uihelp.c - Help routines.
*
*       Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*       Help management routines.
*
*******************************************************************************/

#include <version.h>
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>
#include <cw/help.h>
#include <uiext.h>

/* And the dialog information */
#include <cw/dlg.h>

#include "uihelp.hs"
#include "uihelp.sdm"

#ifndef PARSER_H
#include <parser.h>
#endif

#ifndef HEAP_H
#include <heap.h>
#endif

#ifndef UIHELP_H
#endif

#ifndef PRSTAB_H
#include <prstab.h>
#endif

#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

#ifndef RTPS_H                          /* [8] */
#include <rtps.h>                       /* [8] */
#endif                                  /* [8] */

#ifndef UINHELP_H                       /* [13] */
#include <uinhelp.h>                    /* [13] */
#endif                                  /* [13] */

ushort  iHelpId;
BYTE    fHelpAlloc;
BYTE    fNoScroll;                      //[41]
bdl     bdlHelp = {0, UNDEFINED, 0, 0};

uchar   NEAR toupper(uchar);            //internationalized case conv,
ushort  FAR HelpGetLine (ushort, ushort, char FAR *, char FAR *);

VOID    NEAR DisplayHlpDlgBdl (VOID);           /* [10] */
VOID    NEAR ResizeHelpDialog (short);          /* [10] */
VOID    NEAR DisplayHelpOOM (VOID);
VOID    NEAR CmdHelpAbout(VOID);

extern BYTE fNoHighlight;
char   *szDialogHelpContext;            //[27] current dialog box help szContext
extern char *szDialogTitle;             //[27]
extern WORD cbDialogTitle;              //[27]
extern BYTE HelpFlags;                  //[47]
extern BYTE HelpFlags2;                 //[47]
extern bool fHelpVisible;                       //[26]
extern WND  WndHelp;                            //[26]
extern WORD iFileSize;                  //[46]
extern BYTE fDirChanged;                //[50] TRUE if b$Buf1 contains the
                                        //[50] directory before dialog started

// a-emoryh - Dos6 QHelp
extern BOOL  fQhelpStarting;     // Hack flag for /QHELP; used to prevent edit
                                 // from being draw before Help comes up.


VOID    FAR PASCAL Help(WORD, WORD, VOID *, WORD);
extern char *(near SzGetIth(char *, ushort));
extern ushort FAR IRWofPbCb(char *, ushort);



/* massively rewritten with [13] */
/**************************************************************************
* VOID FAR PASCAL Help(WORD hem, WORD hid, VOID *pv, WORD kk)
* Purpose:
*  Help system entry point for COW.   COW will call this routine
*  whenever F1 (or SHIFT F1 or CTRL F1 or ...) is pressed unless it
*  is in an edit window (in which case we call it ourselved).
*
* Entry:
*  iHelpId : message number of message displayed if MENUITEM or MESSAGEBOX
*
*  hem     : main help item, either hemUserMin, hemMbox, hemMenuItem,
*            hemMenu or hemDialog.
*  hid     : help identifier for a dialog if hem = hemDialog
*  pv      : pointer to menu structur if hem = hemMenu
*  kk      : shift state
*
**************************************************************************/

VOID FAR PASCAL Help(hem, hid, pv, kk)
WORD    hem;
WORD    hid;
VOID    *pv;
register WORD   kk;
{
register char    *sz;                   //[48]
    ushort  iRetVal;
// a-emoryh
    BOOL    fCmdLineTopicFound;

    /* if we are in help system, or help system will not start, then return */

    if (HelpFlags & HLP_INHELP) //[30] make sure we aren't called recursively
        return;                                                                 /* Disallow recursive calls */

    fHelpAlloc++;               //[49] prevent allocs from shutting down help

    if (StartHelp())            /* if we can't start up, then exit */
        goto HelpDisplayed;

    switch (hem) {
        case hemAllWindow:

        //[29] parse F1 & various shift states
        //[29]   F1             = Keyword help
        //[29]   Shift+F1       = Default help
        //[29]   Ctrl+F1        = Help Next (next sequential help topic)
        //[29]   Shift+Ctrl+F1  = Help Prev (previous sequential help topic)
        //[29]   Alt+F1         = Help Back (last help displayed)
        //[29]                    NOTE: ALT is handled as an accelerator key

            if ((kk & KK_CONTROL) && (kk & KK_SHIFT))   //[29]
                CmdHelpPrev();                  //[29] previous sequential topic
            else                                //[29]
            if (kk & KK_CONTROL)                //[29]
                CmdHelpNext();                  //[29] next sequential topic
            else                                //[29]
            if (kk & KK_SHIFT) {                //[25] SHIFT-F1 for default help
                if (cmdSwitches & CMD_SW_QHELP)
                {
// a-emoryh - In Dos6 QHelp topics can be specified from commandline.
                    fCmdLineTopicFound = TRUE;
                    if (fQhelpStarting && (szCmdLineTopic[0] != 0))
                    {
                       if ((iRetVal = DisplayHlpWndSz(szCmdLineTopic)) == 0)
                       {
                          goto DisplayCmdLineTopic;
                       }
                       else
                       {
                          // Topic not found, so honk and goto normal contents
                          hid = helpQHContentsId;
                          fCmdLineTopicFound = FALSE;
                       }
                    }
                    else
                       hid = helpQHContentsId;
                }

                else if (cmdSwitches & CMD_SW_ED)  //[53]
                    hid = helpEditorHelp;       //[56]
                else                            //[53]
                    hid = helpOnHelpId;         //[25] default help
                goto DisplayHelphid;            //[25] display it in help window
            }                                   //[25]
            else {                              //[23] F1 for keyword help

// a-emoryh Fixed so F1 key always brings up HelpOnHelp (in QHelp mode)
//              if ((cmdSwitches & CMD_SW_QHELP) && pwndAct != &wndHelp) {

                if ((cmdSwitches & CMD_SW_QHELP) && pwndAct == &wndHelp) {
                    hid = helpHowToUseId;
                    goto DisplayHelphid;
                }                               //[53]
                if ((cmdSwitches & CMD_SW_ED) && pwndAct != &wndHelp) { //[55]
                    hid = helpSurvivalId;       //[53]
                    goto DisplayHelphid;        //[53]
                }                               //[53]

                //[30] if we are in the help window, then have F1 check
                //[30] for hot links as well as context sensitive help

                if (pwndAct != &wndHelp ||      //[31]
                        SelectHotLink(GetEditColumn(),GetEditLine(),FALSE))
                KeywordHelp();                  //[23]
            }
            goto HelpDisplayed;                 //[57]

        case hemWindowHid:      /* help menu items */
DisplayHelphid:                                 //[25] display help given hid
            iRetVal = DisplayHlpWndSz(CreateContext(hid));      //[40]

DisplayCmdLineTopic:                   // a-emoryh
            DbAssert (iRetVal != HELP_NF);                      //[42]

            //[26] we must set the focus into the help window here
            //[26] if displaying Survival, Index, or Table of Contents help
            if (iRetVal == HELP_OK && hid >= helpEditorHelp  //[56]
                                   && hid <= helpOnHelpId)   //[42]
                if (fHelpVisible)               //[26]
                    WndActivate(&WndHelp);      //[26]

// a-emoryh - If couldn't find topic requested on command-line, then put up
//    error dialog.
            if (fQhelpStarting && !fCmdLineTopicFound)
               MsgBoxStd (MB_OK, MSG_MatchNotFound);

            goto HelpDisplayed;                 //[26]

        case hemMenu:
            sz = "m.x";
            sz[2] = ((PMENU)pv)->pchTitle[((PMENU)pv)->ichHilite];
            break;

        case hemDialog:
            if (hid != hidDlgNull) {
                iHelpId = hid;                  //[24] Use HelpID from dlg box
            } /* otherwise use context number set up before Dialog was called */

        case hemMenuItem:
        case hemMbox:
            sz = CreateContext(iHelpId);        //[25]
            break;

        default:
            DbAssert(FALSE);
            break;
    }

    /* at this point, any help messages will go into a dialog box */

    if (fDirChanged) {                  //[50] if drive/dir modified from normal
        //[50] The only time this flag is set is for the duration of
        //[50] DoDlgLoadFile and DoDlgSaveFile.  b$Buf1 contains the current
        //[50] drive/directory before the dialog, which we must restore here
        //[50] before we attempt to do any Help file I/O.
        //[50] b$Buf2 is the return value from ValidateFile() (called by the
        //[50] Load/Save dialog procs), and is available for our use here.
        GetCurDriveDir(&b$Buf2);        //[50]   save current one in b$Buf2
        SetCurDir2(&b$Buf1);            //[50]   reset to original (in b$Buf1)
    }
    DbAssert(sz[0] != 0);               //[51] string must not be 0 length
    if (GetHelpMsgSz(sz,&bdlHelp) == HELP_OK) {                 //[42]

        szDialogHelpContext = sz;       //[27] save dialog box help *szContext
                                        //[27] for use as a title
        CloseCurHelpFile();             //[48] don't keep help file open during
                                        //[48] user input.  Probably not
                                        //[48] required here -- just being safe
        DisplayHlpDlgBdl();             // display the dialog box help
    }
    if (fDirChanged)                    //[50] if directory restored
        SetCurDir2(&b$Buf2);            //[50]   reset to current

HelpDisplayed:
    CloseCurHelpFile();                 //[48] don't keep help file open
    if (uierr == MSG_HelpOOM)
        DisplayHelpOOM();

    fHelpAlloc--;                       //[49] restore flag
}


#define cbMaxHlp 62             //[21] max text size = 60, plus some slop

/**************************************************************************
* VOID NEAR WListProcHelpText()
* Purpose:
*    Handles the scrollable help list box within the help dialog box.
*
*    Gets successive lines of help text.
*
* Exit:
*    Size of next line of help text for this context, or 0 if no more.
*
**************************************************************************/
WORD FAR WListProcHelpText (tmm, sz, isz, tmc, wParam, bArg)
WORD tmm;
char *sz;
WORD isz, tmc, wParam, bArg;
{

    Unreferenced (tmc);
    Unreferenced (wParam);
    Unreferenced (bArg);

    switch (tmm) {
        case tmmCount:          /* return desired size of listbox */
            return ((WORD)-1);          /* unknown size */

        case tmmText:
        case tmmEditText:
            // We are assured that the help system is running because
            // all allocations from the begining of the DisplayHlpDlgBdl
            // to the end are protected by a fHelpAlloc flag.

            DbAssert(HelpFlags & HLP_GOTBUF);  //[37]
            /* Call help engine to get text.  Returns 0 when all done. */
            return (HelpGetLine(isz+1, cbMaxHlp, sz,(char far *)MAKELONG(0,&(bdlHelp.seg))));
    }
}

/*
        These constants are pseudo-HACKS to allow dynamic resizing of help
        dialog boxes.  They are offsets into the dlgHelpText structure in
        UIHELP.SDM (created by DE.EXE from UIHELP.DES).  If UIHELP.DES changes
        radically, these constants MAY have to be changed.  Simple changes
        (like re-sizing the boxes) should not have an effect.   Adding boxes
        or buttons might cause rgsdmtm[2] to be something other than the
        OK button.
*/

#define DIALOGBOXPOS       dlgHelpText.dlgHeader.crcDlg.y
#define DIALOGBOXSIZE      dlgHelpText.dlgHeader.crcDlg.dy
#define DIALOGLISTBOXSIZE  (((uchar FAR *)&(dlgHelpText.rgsdmtm[0].l))[3])
#define DIALOGOKBUTTONPOS  (((uchar FAR *)&(dlgHelpText.rgsdmtm[2].l))[1])
#define LISTBOXBORDER      (int) 2      //[17] top line & scroll bar of list box

#define MAX_HELP_TITLE  56      //[27] biggest title allowed (including NULL)

/**************************************************************************
* VOID NEAR DisplayHlpDlgBdl ()
*
*   Added with revision [10].
*
* Purpose:
*   Brings up a scrollable help dialog box of minimum size.  The
*   help text is found in bdlHelp.
*
* Entry:
*       None.
*
**************************************************************************/
VOID NEAR DisplayHlpDlgBdl ()
{
    HCABHelpText hcabHelpText;
    char        *szDialogTitleSav;              //[27]
    WORD        cbDialogTitleSav;               //[27]
    char        TitleBuf[MAX_HELP_TITLE+1];     //[27]
    ushort      OldUiErr = uierr;               //[38]
register ushort OldFileSize;                    //[46]
register  int   ShrinkSize;                     //[46]
    PWND        pwndFocus;                      //[52]


    //[33] We must make sure that there is not already a recursion flag
    //[33] set, otherwise we will not be able to safely clear it at the
    //[33] end of this routine

    DbAssert(fHelpAlloc != 0);                  //[49] protect the Allocs

    uierr = 0;
    hcabHelpText = (HCABHelpText) HcabAlloc (cabiCABHelpText);
    if (uierr) {         /* Catch HcabAlloc failure */
        DisplayHelpOOM();
        goto DisplayHelpExit;                   //[37]
    }

    fNoHighlight++;                     /* don't highlight selected items */

    DbAssert(!(HelpFlags & HLP_INHELP));        //[58]
    HelpFlags |= HLP_INHELP;                    //[58] Add recursion lock

    OldFileSize = iFileSize;                    //[46]
    iFileSize = 0;                              //[46] must zero before
                                                //[46] GetHelpContextLen
    ShrinkSize = (int) DIALOGLISTBOXSIZE        /* current # lines in box */
                - (int) GetHelpContextLen(&bdlHelp) //[46] minus # for text
                - LISTBOXBORDER;                /* minus # needed for border */

    if (ShrinkSize < 0)                         //[41]
        ShrinkSize = 0;                         //[41] dialog box won't shrink
    else                                        //[46] less than full-size box
        if (iFileSize)                          //[46] ":l" NOT specified
            fNoScroll++;                        //[46] dialog box can't scroll
    iFileSize = OldFileSize;            //[46] restore original value
    ResizeHelpDialog (ShrinkSize);      /* trim initial box by ShrinkSize */

    szDialogTitleSav = szDialogTitle;   //[27] save old dialog box title info
    cbDialogTitleSav = cbDialogTitle;   //[27]

    GetHelpTitleStr(&bdlHelp,MAX_HELP_TITLE);   //[27] get title into bufStdMsg
    strcpy (TitleBuf, bufStdMsg);       //[27] can't keep title in bufStdMsg

    szDialogTitle = TitleBuf;           //[27] new dialog box title
    cbDialogTitle = 0;                  //[27] don't truncate title

    TmcDoDlgFar (&dlgHelpText, sizeof (dlgHelpText), hcabHelpText);

    szDialogTitle = szDialogTitleSav;   //[27] restore old dialog box title
    cbDialogTitle = cbDialogTitleSav;

    fNoHighlight--;                     /* highlighting OK again */
    pwndFocus = GetFocus();             //[52]
    if (pwndFocus != pwndAct)           //[52] If focus is a dialog window
        DrawWindow (pwndFocus);         //[52]  redraw, so listbox sel is right
    fNoScroll = 0;                      //[41] always want scroll bars
    ResizeHelpDialog(-ShrinkSize);      /* reset initial box size */

    FreeCab (hcabHelpText);

DisplayHelpExit:

    BdlFree(&bdlHelp);                  /*[58] delete the help text */

    uierr = OldUiErr;                   //[38] restore any error values

    HelpFlags &= ~HLP_INHELP;           //[35] remove recursion lock

}

/**************************************************************************
* VOID NEAR ResizeHelpDialog ()
*
*   Added with revision [10].
*
* Purpose:
*   Adjusts the initial scrollable help dialog box by a given amount.
*   Used to get the dialog box down to minimum size.
*
* Input:
*   ShrinkSize = # lines to trim dialog box by (negative if growing)
*
**************************************************************************/
VOID NEAR ResizeHelpDialog(ShrinkSize)
short   ShrinkSize;
{
    DIALOGBOXSIZE -= (BYTE) ShrinkSize;         /* shrink dialog box */
    DIALOGOKBUTTONPOS -= (BYTE) ShrinkSize;     /* move OK button up */
    DIALOGLISTBOXSIZE -= (BYTE) ShrinkSize;     /* shrink list box */
    DIALOGBOXPOS += (BYTE) (ShrinkSize/2);      /* re-center dialog box */
}

/**************************************************************************
* VOID NEAR CmdHelpAbout ()
*
*   Added with revision [54].
*
* Purpose:
*   Implements the Help.About... menu item.  This routine will pull up
*   a message box giving some very basic information about the program.
*
* Input:
*   None.
*
**************************************************************************/
VOID NEAR CmdHelpAbout()
{
    char szFirstLine[CB_bufStdMsg];
    char szSecondLine[CB_bufStdMsg];
    char szThirdLine[CB_bufStdMsg];

    if (cmdSwitches & CMD_SW_QHELP)
        ListStdMsg(MSG_HelpAboutQHelp);
    else if (cmdSwitches & CMD_SW_ED)
        ListStdMsg(MSG_HelpAboutEditor);
    else
        ListStdMsg(MSG_HelpAboutInterp);
    strcpy(szFirstLine, bufStdMsg);
    ListStdMsg(MSG_HelpAbout2);
    strcpy(szSecondLine, bufStdMsg);
    ListStdMsg(MSG_HelpAbout3);
    strcpy(szThirdLine, bufStdMsg);

    // We use the HLP_INHELP recursion flag to prevent anyone from
    // trying to get help on this message box.

    DbAssert(!(HelpFlags & HLP_INHELP));
    HelpFlags |= HLP_INHELP;

    UIMessageBox(szFirstLine, szSecondLine, szThirdLine, MB_OK | MB_NOHELP);

    HelpFlags &= ~HLP_INHELP;

}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uiinfhlp.asm ===
TITLE   uiinfhlp.asm - interface routines for new help engine.
;***
;uiinflp.asm
;
;       Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;       Interface routines for the new help system.
;
;
;*******************************************************************************

        .xlist
        include version.inc
        .list
        UIINFHLP_ASM = ON


        include cw/version.inc
        include cw/windows.inc
        include cw/edityp.inc

        IncludeOnce architec
        Include     help.inc
        IncludeOnce qbimsgs
        IncludeOnce ui
        IncludeOnce uiint
        IncludeOnce uimenu
        IncludeOnce uinhelp

assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

        subttl  DATA segment definitions.
        page

sBegin  DATA
        externB HelpFlags
        globalB fMessageBox,0,1         ; are we in a message box?
        externW efHelp                  ; Editmgr structure for Help Wnd.
        externW oCurTopic               ; offset to the current topic
        globalW iStaticHelpTopic,0,1    ; High word of NC during searches
        externB b$Buf1                  ; FILNAML-sized buffer
        externB b$Buf2
        externW iFileSize               ; Size of current help topic
        externW iCurRequestLine
        externW rgLineAttr              ; static attribute buffer
        externB fHelpAlloc

        HtSpot  EQU     b$Buf2          ; Static HotSpot structure

sEnd    DATA

        externFP GetEditMgrState
        externFP EditFilterWndProc
        externFP HelpSzContext
        externFP HelpHlNext
        externFP HelpNcPrev
        externFP HelpGetLineAttr
        externFP HelpGetLine
        externFP HelpNcNext


sBegin  UI
assumes CS,UI
        externNP toupper
        externNP GotoBookMark
        externNP SetBookMark
        externNP GetInitialPos
        externNP GetNextNc
        externNP SzSrchExcl
        externNP AppendBuf
        externNP CalcNc
        externNP MoveCursorPwnd
        externNP SizeHelpContext


;***
;DisplayHlpGeneric - Display either VarHelp or EngineHelp on screen
;
;Purpose:
;       Will deturmine the type of help specified and display it in
;       the help window.  It is expected to call this routine after
;       calling RetrieveHelpHistory, as its output parameters identically
;       match our input parameters.
;
;Entry:
;       DX:AX   - Help Topic (NC or Var Help ID)
;       CL      - Flags (EI_VARHELP only)
;                       0 => Engine help
;                      ~0 => Variable help
;
;Exit:
;       AL = 0    all ok
;       AL <> 0   failure (returns Error Code)
;****

cProc   DisplayHlpGeneric,<NEAR>
cBegin
        cCall   DisplayHlpWndNc         ; display the new topic

        ;AL = 0 if succeeded, error code otherwise

DisplayHlpGeneric_Exit:
cEnd


;***
;NextHotLink - Go to next hot link
;
;Purpose:
;       This routine will move the cursor to the next hot link in the
;       current topic.  Will wrap around the proper end of the help topic
;       to check for hot links if needed.
;
;Entry:
;       cLead : parameter to pass to HelpHlNext
;
;Exit:
;       None.
;
;****

cProc   NextHotLink,<NEAR>,<SI,DI>
parmW   cLead
cBegin
        ; This routine is only called when the help window is open
        ; and valid, thus we can assert HLP_GOTBUF and oCurTopic.

        DbAssertTst HelpFlags,ne,HLP_GOTBUF,UI,<NextHotLink:Buffers not initialized>


        DbChk   HoldBuf2                ; lock down the HotSpot

        ;Get current line#/column number

        mov     ax,EfHelp.EF_ipCur_ob   ; get the current column
        inc     ax                      ; make it 1 relative
        mov     HtSpot.colHS,ax         ; save it for HelpHlNext


        mov     ax,EfHelp.EF_ipCur_oln  ; current line #
        inc     ax                      ; make it 1 relative
        mov     HtSpot.lineHS,ax        ; save line number for help engine
        xor     di,di                   ; first time through

DbAssertRel     oCurTopic,ne,0,UI,<NextHotLink:oCurTopic invalid>

        mov     si,oCurTopic            ; get ptr to current topic
HotSpotRetry:
        lea     bx,[si].bdlHelpText.BDL_seg ; BX = handle of text seg
        xor     ax,ax                   ; ax = offset of text
        mov     cx,OFFSET DGROUP:HtSpot ; cx = offset of HotSPot
        push    HtSpot.lineHS           ; save row and column of hot spot
        push    HtSpot.colHS
        cCall   HelpHlNext,<cLead,BX,AX,DS,CX>
        pop     bx                      ; restore row and column of old hot spot
        pop     cx
        or      ax,ax                   ; did we get a hot linK?
        je      NextHotLink_Retry       ; no, go complain
        mov     ax,di                   ; save old loop counter
        inc     di                      ; one more time through loop
        or      ax,ax                   ; first time through?
        jne     MoveCursorToHotLink     ; no, it is a real hot link
        cmp     cx,HtSpot.lineHS        ; on the same row?
        jne     MoveCursorToHotLink     ; no, must be a real hot link
        cmp     bx,HtSpot.colHS         ; old column in current hot spot?
        jl      MoveCursorToHotLink     ; no, must be a real hot link
        mov     ax,HtSpot.ecolHS        ; AX = ending column of hot spot
        cmp     bx,ax                   ; old column in current hot spot
        ja      MoveCursorToHotLink     ; no, must be a real hot link
        inc     ax                      ; try again after the hot spot
        mov     HtSpot.colHS,ax         ; set position
        jmp     HotSpotRetry            ; and try again

NextHotLink_Beep:
        cCall   CowMoo                  ; beep the speaker
        jmp     short NextHotLink_Exit  ; and leave.

NextHotLink_Retry:
        cmp     di,1                    ; Have we already wrapped around?
        ja      NextHotLink_Beep        ; yes, nothing to find
        mov     di,2                    ; set wrapped flag
        mov     ax,1                    ; assume wrapping backwards
        mov     HtSpot.lineHS,ax        ; set line + col position
        mov     HtSpot.colHS,ax
        test    cLead,8000H             ; forward (+) or backwards (-)?
        jz      HotSpotRetry            ; we assumed right
        mov     ax,iFileSize            ; get last line number
        mov     HtSpot.lineHS,ax
        mov     HtSpot.colHS,-1         ; column position FFFF
        jmp     HotSpotRetry


MoveCursorToHotLink:
        ;Move the cursor to the position specified in the HotSpot structure
        mov     ax,HtSpot.lineHS        ; get the context relative row
        dec     ax                      ; make it 0 relative
        mov     cx,OFFSET DGROUP:wndHelp
        mov     bx,HtSpot.colHS         ; get the context relative column
        dec     bx                      ; make it 0 relative
        cCall   MoveCursorPwnd,<cx,ax,bx> ; move cursor to hotspot

NextHotLink_Exit:

        DbChk   FreeBuf2                ; release the HotSpot
cEnd


;***
;HelpBack - Backup one level of help (if possible)
;
;Purpose:
;       Implements ALT-F1.  The user asked us to go to the help topic
;       that was previously shown.
;
;
;       NOTE: SLIME: this routine uses iStaticHelpTopic for a temporary
;                    Dgroup storage location.  This should cause no problems,
;                    as HelpBack and searching are mutually exclusive.
;
;Entry:
;       None
;
;Exit:
;       None
;
;Uses:
;       Per Convention
;
;****
cProc   HelpBack,<PUBLIC, NEAR>,<SI,DI>
cBegin

;There are two cases to handle:
;       1) If the cursor is not at the start of a topic, move to start of topic
;          (note: the start of the topic is 0,0 and (if visible on the screen)
;          the first hot link.
;       2) If the cursor is at the start of a topic, move to previous topic
;
;General Algorithm when EI_VARHELP is turned on
;       Get Last topic from help history (should be displayed topic)
;       save topic
;       if (cursor not at start-of-topic)
;           Display Saved Topic  (will force cursor to start of topic)
;       else
;           while (New topic not displayed OK)
;               if (Topic Exists)
;                   Get Last topic from help history (topic to be displayed)
;                   Try to Display Topic
;               else
;                   Display Saved Topic

;
; We do not call HelpStart, as there is no reason to start the help system
; if it is not already started.  No Help => No Help Back => exit with error
;

        test    HelpFlags,HLP_GOTBUF    ; are we initialized?
        jne     Initialized             ; yes, see if we can get history
HelpBack_Err:
        cCall   CowMoo                  ; beep the speaker
DJMP    jmp     short HelpBack_Exit     ; and return

Initialized:
        cCall   RetrieveHelpHistory     ; get the currently displayed item
        jcxz    HelpBack_Err            ; no current topic? exit
                                        ; (possible if no help ask for yet)
        mov     si,dx                   ; set SI:DI = context info.
        mov     di,ax



        ;Test for cursor at begining of topic

        xor     ax,ax                   ; 0 to compare against
        cmp     fHelpVisible,al         ; help window visible?
        je      CurrentTopic            ; no, goto current topic

        cmp     EfHelp.EF_ipCur_ob,ax   ; at column 0?
        jne     CheckHotLink            ; no, goto initial position
        cmp     EfHelp.EF_ipCur_oln,ax  ; on first line?
        je      PreviousTopic           ; yes, goto previous topic

CheckHotLink:
        cCall   GetInitialPos           ; (DX,AX) is initial cursor position
        cmp     EfHelp.EF_ipCur_ob,ax   ; in the right column?
        jne     CurrentTopic            ; no, redisplay current topic
        cmp     EfHelp.EF_ipCur_oln,dx  ; in the right row?
        jne     CurrentTopic            ; no, redisplay current topic

PreviousTopic:
        cCall   RetrieveHelpHistory     ; get the item to goto
        jcxz    CurrentTopicBeep        ; none, beep and exit (CX = 0)

        cCall   DisplayHlpWndNc         ; display the topic
        cmp     al,HELP_HANDLED         ; did we get an error?
        je      CurrentTopic            ; yes, try to clean up and exit
        or      al,al                   ; did we succeed?
        jne     PreviousTopic           ; no, try topic before it

        jmp     short HelpBack_Exit     ; we succeeded, exit


CurrentTopicBeep:
        cCall   CowMoo                  ; tell user of error
CurrentTopic:
        mov     dx,si
        mov     ax,di
        cCall   DisplayHlpWndNc         ; display the topic

        ;any error at this point must have been caused by OOM or Missing varhelp

        or      al,al                   ; could we redisplay?
        je      HelpBack_Exit           ; yes, we are done
        cCall   GiveHelpOOM             ; display OOM message

HelpBack_Exit:
        DbAssertRel     curHelpFile,e,0,UI,<HelpBack: help file open>

cEnd

;***
;CmdHelpPrev - Goto Previous Help Topic
;
;Purpose:
;       The user has requested that we goto the previous help topic. Beeps
;       if this is not possible or the help window is not open.
;
;Entry:
;       None.
;
;Exit:
;       None.
;
;Uses:
;       Per C Convention
;
;****

cProc   CmdHelpPrev,<PUBLIC,NEAR>
cBegin
        cmp     fHelpVisible,0                  ; help window visible?
DJMP    je      CmdHelpBeep                     ; no, beep and exit

DbAssertTst     HelpFlags,ne,HLP_GOTBUF,UI,<CmdHelpPrev:Help window open but not HLP_GOTBUF>
        and     HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM) ;  clear flags
        mov     bx,oCurTopic                    ; get ptr to current topic
        push    Word Ptr [bx].ContextNum+2      ; parameter to HelpNcPrev
        push    Word Ptr [bx].ContextNum
        cCall   HelpNcPrev                      ; get next NC
        mov     cx,ax                           ; is it 0? (non available)
        or      cx,dx
        jne     CmdHelpDisplay                  ; no, try to display it
        test    HelpFlags,HLP_FAILFNF OR HLP_FAILOOM ; already displayed msg
        jz      CmdHelpBeep                     ; no, topic not found=>beep
cEnd

;***
;CmdHelpNext - Goto Next Help Topic
;
;Purpose:
;       The user has requested that we goto the next help topic. Beeps
;       if this is not possible or the help window is not open.
;
;Entry:
;       None.
;
;Exit:
;       None.
;
;Uses:
;       Per C Convention
;
;****

cProc   CmdHelpNext,<PUBLIC,NEAR>
cBegin

        cmp     fHelpVisible,0                  ; help window visible?
        je      CmdHelpBeep                     ; no, beep and exit

DbAssertTst     HelpFlags,ne,HLP_GOTBUF,UI,<CmdHelpNext:Help window open but not HLP_GOTBUF>
        mov     bx,oCurTopic
        mov     dx,Word Ptr [bx].ContextNum + 2 ; DX:AX = old context num
        mov     ax,Word Ptr [bx].ContextNum
        cCall   GetNextNc                       ; Set DX:AX
        jz      CmdHelpError                    ; check for errors
CmdHelpDisplay:                                 ; Called from CmdHelpPrev
        cCall   DisplayHlpWndNc
        or      al,al                           ; did we succeed?
        je      CmdHelpNext_Exit                ; yes, return.
CmdHelpError:
        cmp     al,HELP_HANDLED                 ; Will someone else handle?
        je      CmdHelpNext_Exit                ; yes, just exit
DbAssertRelB    al,e,HELP_NF,UI,<CmdHelpNext:Illegal error>

CmdHelpBeep:                                    ; NOTE: shared label
        cCall   CowMoo                          ; beep the speaker
CmdHelpNext_Exit:
cEnd

;Routine added with [1]
;***
;NormalizeTopic - Convert a context number to a standard form
;
;Purpose:
;       The current implementation of the help engine allows a piece of text
;       to have multiple context strings, thus multiple context numbers.
;       While searching, we use the context number to specify when we have
;       wrapped around the file and reached the starting point.  Thus, we
;       have to Normalize the topic number so it is the same one that will
;       be returned from HelpNcPrev or HelpNcNext.
;
;Entry:
;       AX : topic ID
;
;Exit:
;       if (CX != 0)
;          DX:AX : topic number
;       else
;          error (will have been signaled)
;
;Uses:
;       Per C Convention
;****

cProc   NormalizeTopic,<NEAR>
cBegin
        push    ax                      ; preserve Topic ID
        mov     dx,iStaticHelpTopic     ; DX:SI = context number
        ccall   HelpNcNext,<iStaticHelpTopic,AX> ; get previous one
        pop     bx                      ; BX = topic ID
        mov     cx,ax                   ; did we succeed?
        or      cx,dx
        jz      PrevNext                ; no, try to get one after the topic ID
        cCall   HelpNcPrev,<DX,AX>      ; yes, do a Prev to get normalized NC
        jmp     short CheckReturn       ; and return it
PrevNext:
        cCall   HelpNcPrev,<iStaticHelpTopic,bx> ; get NC before topic ID
        mov     cx,ax                   ; did this succeed?
        or      cx,dx
        jz      NormalizeExit_Err       ; no, exit with error
        cCall   HelpNcNext,<DX,AX>      ; get topic after that one

CheckReturn:
        mov     cx,ax                   ; set error condition
        or      cx,dx

NormalizeExit_Err:
cEnd


;***
;ChngHelpCurTopic - Cleans up after a help search
;
;Purpose:
;       The three routine set (GetHelpCurTopic, GetHelpNextTopic,
;       ChngHelpCurTopic) are used for a search or scan of the help file.
;
;       This routine will take a topic ID that was used to terminate
;       the search and prepare things for continued operation of the
;       help system.  This routine should only be called if we are
;       exiting from a search in a topic other than the original
;       topic, and want to change that topic to be the new current topic.
;
;Entry:
;       CX = previous topic
;
;Exit:
;       None.
;****
cProc   ChngHelpCurTopic,<NEAR>
cBegin

DbAssertTst     HelpFlags,e,HLP_VARHELP,UI,<ChngHelpCurTopic:Called when HLP_VARHELP>
        mov     ax,cx                   ; Set DX:AX to NC of topic
        mov     dx,iStaticHelpTopic
        or      dx,dx                   ; check to see if it is valid
        je      ChngHelp_Exit           ; no, just exit (we will close help wnd)

        inc     cx                      ; Topic ID = UNDEFINED ?
        je      ChngHelp_Exit           ; brif - identifier is invalid.

DbAssertTst     HelpFlags,ne,HLP_GOTBUF,UI,<ChngHelpCurTopic:iStaticHelpTopic non 0 without HLP_GOTBUF>

        cCall   RecordHelpHistory       ; record topic in help history list
ChngHelp_Exit:
        cCall   DrawDebugScr            ; make sure screen is redrawn so
                                        ; we get proper help title.
cEnd

;***
;GetHelpNextTopic - Prepares the next topic for looking
;
;Purpose:
;       The three routine set (GetHelpCurTopic, GetHelpNextTopic,
;       ChngHelpCurTopic) are used for a search or scan of the help file.
;
;       This routine will take a Topic ID and return the next physical
;       Topic ID.  If the presented Topic ID was the last one in a section,
;       this routine will wrap around to the begining of the section.
;
;
;Entry:
;       CX = previous topic
;
;Exit:
;       AX = new Topic Identifier if engine help
;            0                    if var help (will work as topic id)
;            UNDEFINED            if error
;****

cProc   GetHelpNextTopic,<NEAR>,<DI>
cBegin
        DbChk   HoldBuf1                ; use BUF1 as a temporary buffer

        test    HelpFlags,HLP_COMPRESS  ; help shutting down
DJMP    jnz     NextTopic_Exit          ; yes, exit


        mov     dx,iStaticHelpTopic     ; get static high word of NC
        or      dx,dx                   ; is it 0 (help system shut down)
DJMP    je      NextTopic_Fail          ; yes, return error

DbAssertTst     HelpFlags,ne,HLP_GOTBUF,UI,<GetHelpNextTopic:iStaticHelpTopic non 0 without HLP_GOTBUF>

        mov     ax,cx                   ; DX:AX = old topic number
        cCall   GetNextNc               ; DX:AX = next context number
DJMP    jnz     GotNextTopic            ; we were successful

        cmp     al,HELP_HANDLED         ; error message already displayed?
DJMP    je      NextTopic_Fail          ; yes, return error code

DbAssertRelB    al,e,HELP_NF,UI,<GetHelpNextTopic:illegal error from GetNextNc>



        ;Goto the first topic of this section of the file.  We are guarenteed
        ;that the topic h.pg1 (MSG_FirstContextStr) exists at the begining of
        ;each section of the help system.  Thus, we pick off the file name
        ;part of any context string of the section and goto filename!h.pg1


        mov     bx,oCurTopic                    ; get ptr to a legal buffer
        mov     di,OFFSET DGROUP:B$Buf1         ; store results in B$Buf1
        push    ds                              ; far ptr to buffer
        push    di
        push    Word Ptr [bx].ContextNum+2      ; context number
        push    Word Ptr [bx].ContextNum
        cCall   HelpSzContext                   ; get current filename
        or      ax,ax                           ; was the call successful?
        je      NextTopic_Fail                  ; no, exit with error

        cCall   szSrchExcl,<DI>                 ; AX = pos of '!' or 0
DbAssertRel     ax,ne,0,UI,<szComposeContext:Illegal string from HelpSzContext>

        mov     bx,MSG_FirstContextStr          ; message to append
        cCall   AppendBuf,<AX,BX>               ; stick it on
        xchg    ax,bx
        mov     Byte Ptr [bx],0                 ; and 0 terminate it.

        ;Get the context number + context for this name
        ;param for CalcNc pushed above

        cCall   CalcNc,<DI>             ; convert to context number
        jcxz    NextTopic_DbFail        ; brif we couldn't locate it

        cCall   NormalizeTopic          ; normalize topic number
        jcxz    NextTopic_Fail          ; brif it can't be normalized

GotNextTopic:
        mov     di,ax                   ; save value to be returned
        cCall   BufferNc                ; BX = ptr to buffered context
        or      al,al                   ; error in buffering?
        jne     NextTopic_Fail          ; yes, return with error code
        lea     ax,[bx].bdlHelpText     ; get ptr to BDL
        cCall   SizeHelpContext,<ax>    ; AX = # lines in this topic
                                        ; sets iFileSize
        xchg    ax,di                   ; restore return value
        jmp     short NextTopic_Exit    ; and return

NextTopic_DbFail:
        DbAssertRelB al,ne,HELP_NF,UI,<GethelpNextTopic:h.pg1 missing from file>


        ;If we get a fatal error, we have to close the help window.  There
        ;is no guarentee that we can redisplay the original topic, and to
        ;display some random topic would be poor.  Thus, make sure the
        ;bit to close the help window in DoDrawDebugScr is set.

NextTopic_Fail:
        or      HelpFlags,HLP_COMPRESS  ; close help window at earliest time
        mov     ax,UNDEFINED            ; assume we will get an error
NextTopic_Exit:
        DbChk   FreeBuf1                ; release buffer
cEnd

;***
;GetHelpCurTopic - Start search and returns the current topic id
;
;Purpose:
;       The three routine set (GetHelpCurTopic, GetHelpNextTopic,
;       ChngHelpCurTopic) are used for a search or scan of the help file.
;
;       This routine will prepare for a linear scan of the help file
;       and will return the Topic Id for the currently displayed help
;       topic.
;
;       A Topic ID is a word that references a help topic.  It is the
;       lower word of a NC, so it is valid only as long as we do not
;       shut down the help system.
;
;Entry:
;       None.
;
;Exit:
;       AX = cur Topic Identifier if engine help
;            0                    if var help (will work as topic id)
;            UNDEFINED            if error
;****

cProc   GetHelpCurTopic,<NEAR>
cBegin
        test    HelpFlags,HLP_GOTBUF    ; are we initialized?
        mov     ax,UNDEFINED            ; assume not
        je      CurTopic_Exit           ; brif not - give error and ret.


DbAssertRel     oCurTopic,ne,0,UI,<GetHelpCurTopic:oCurTopic invalid>
        mov     bx,oCurTopic            ; get a pointer to the current topic
        mov     ax,Word Ptr [bx].ContextNum ; get topic specific part of NC
        mov     dx,Word Ptr [bx].ContextNum+2
        mov     iStaticHelpTopic,dx     ; save static part of NC
        cCall   NormalizeTopic          ; Normalize the topic number
        inc     cx                      ; JCXNZ
        loop    CurTopic_Exit           ; brif success
        mov     ax,-1                   ; set failure flag
CurTopic_Exit:

cEnd

;Added with [4]
;***
;RestoreHelpTopic - Return help system to state before a search
;
;Purpose:
;       The search code needs the original help topic restored to the screen.
;       We get the topic from the help history list and redisplay it.
;
;       Note: we can not use DisplayHlpWndNc, as it will change the position
;       of the cursor and resize the window.
;
;
;Entry:
;       None.
;
;Exit:
;       None.
;
;****

DbPub   RestoreHelpTopic
cProc   RestoreHelpTopic,<NEAR>
cBegin
        test    HelpFlags,HLP_VARHELP   ; are we in variable help?
        jnz     exit                    ; yes, exit. nothing to restore
        cCall   RetrieveHelpHistory     ; get the last history item
DbAssertRel     cx,ne,0,UI,<RestoreHelpTopic:History list empty>
        push    ax                      ; save context number
        push    dx
        cCall   BufferNc                ; load context into memory, al=err code
        pop     dx                      ; restore context number
        pop     cx
        or      al,al                   ; any errors?
        jne     RestoreTopic_Fail       ; yes, handle them
        push    bx                      ; save ptr to help context
        xchg    ax,cx                   ; DX:AX = context number
        cCall   RecordHelpHistory       ; save this in the history list
        pop     bx                      ; return ptr to help context
        lea     ax,[bx].bdlHelpText     ; Get ptr to BDL of this help topic
        cCall   SizeHelpContext,<ax>    ; calculate size, set iFileSize
        jmp     short exit              ; get out of here

RestoreTopic_Fail:
        DbAssertRelB    al,e,HELP_HANDLED,UI,<RestoreHelpTopic:Unable to regenerate initial topic>
        or      HelpFlags,HLP_COMPRESS  ; no error should have happened, we
                                        ; have no idea what state we are in,
                                        ; so close help window
exit:
cEnd

;***
;GetHelpTitle - Returns the title for the currently displayed help item
;
;Purpose:
;       Calculates the title that should go on the help window and
;       returns it in bufStdMsg.
;
;Entry:
;       CX = max title length allowed
;
;Exit:
;       AX = number of characters in title
;       bufStdMsg = contains title.
;
;Uses:
;       Per Convention
;****

DbPub   GetHelpTitle
cProc   GetHelpTitle,<NEAR>,<SI>
cBegin
        mov     si,cx                   ; SI = cbMaxTitle
        mov     ax,MSG_HelpTitleQH      ; first part of title ("MS-DOS Help: ")
        test    cmdSwitches,CMD_SW_QHELP ; /QHELP viewer?
        jnz     ght1                    ;   YES, got title

        mov     ax,MSG_HelpTitle        ; Yes normal help window title

ght1:
        cCall   ListStdMsg,<AX>         ; put in bufStdMsg

        mov     bl,HelpFlags                    ; get a copy of the flags
        and     bl,HLP_GOTBUF or HLP_COMPRESS   ; mask out all but these
        cmp     bl,HLP_GOTBUF                   ; brif NOT HLP_GOTBUF or
        jne     GetHelpTitle_Exit               ;  HLP_COMPRESS

; HLP_INHELP will only be set if we are about to do something that can
; put up a dialog/message box.  If this routine is called with it set,
; then we are trying to redraw the screen after the box has been removed.
; This can be dangerious, as we may not be in a state where we can
; generate a help title.  So return with what we have.

        test    HelpFlags,HLP_INHELP    ; are we called recursively?
        jz      NotRecursiveGHT         ; no, try to get a title
        cmp     fMessageBox,0           ; are we in a dialog box?
        jnz     GetHelpTitle_Exit       ; yes, exit with what we have.

NotRecursiveGHT:


HelpTitleNotVarHelp:
        mov     bx,oCurTopic
        or      bx,bx                   ; current topic invalid?
        je      GethelpTitle_Exit       ; yes, return with what we have
        lea     ax,[bx].bdlHelpText     ; get ptr to the BDL

        cCall   GetHelpTitleStr,<ax,si> ; AX = total length of title


GetHelpTitle_Exit:
        DbAssertRel ax,be,si,UI,<GetHelpTitle: title too big>
cEnd

;***
;GetHelpLine - Get a line of help text
;
;Purpose:
;       This routine is called by the edit manager to display a line
;       of text on the screen.  This routine must take care of all
;       the cases associated with ressyncing the virtual line mechanism,
;       as well as detecting when a ressync would be needed.
;
;       Since this routine is called from COW, the line numbers are 0 relative.
;       The help system is 1 relative (because of the HelpEngine) so we
;       do the conversions on the fly.
;
;Entry:
;       CX = iLineNum - virtual line number of line to retrieve
;       DX = szBufPtr - pointer to buffer in which to store line
;       AX = cbMaxSize - maximum size of buffer
;
;Exit:
;       AX = # bytes in line
;
;****

cProc   GetHelpLine,<NEAR>,<SI,DI>
cBegin
        mov     si,ax                           ; save entry params
        mov     di,dx
        mov     al,HelpFlags                    ; get a copy of the flags
        and     al,HLP_GOTBUF or HLP_COMPRESS   ; mask out all but these
        cmp     al,HLP_GOTBUF                   ; brif HLP_GOTBUF and
        je      CheckHelpOwner                  ;  NOT HLP_COMPRESS

GetLineError:
        xor     ax,ax                           ; number of characters
GetLine_NoAttr:

        ; signal GetHelpLineAttr that it can't lookup attributes

        mov     iCurRequestLine,UNDEFINED
        jmp     short GetHelpLine_Exit          ; and return

CheckHelpOwner:

        inc     cx                              ; make 1 relative



GotHelpLine:

        mov     bx, oCurTopic                   ; get current topic pointer
        or      bx,bx                           ; is it 0?
        je      GetLineError                    ; yes, no current topic set

        mov     iCurRequestLine,cx              ; set line # offset for attribs

        lea     bx,[bx].bdlHelpText.BDL_Seg          ; BX = handle text seg
        xor     ax,ax                                ; AX = text offset
        cCall   HelpGetLine,<CX,SI,DS,DI,BX,AX>      ; put text into buff.
        or      ax,ax                                ; did we get the line?
        je      GetLineError                         ; no, signal error

        ;AX = number of characters in buffer = return value

GetHelpLine_Exit:
cEnd


;***
;GetHelpLineAttr - return attributes for previously fetched line
;
;Purpose:
;       This routine will return the line attributes for the
;       line that was retrieved with the last call to GetHelpLine.
;
;       Note: No call that could change the state of the help system
;             should be called between GetHelpLine and this routine.
;
;Entry:
;       none.
;
;Exit:
;       AX = near ptr to string containing attributes
;
;Uses:
;       Per Convention
;
;****
cProc   GetHelpLineAttr,<NEAR>
cBegin
        .errnz (-1) - (UNDEFINED)

        mov     ax,iCurRequestLine              ; did GetHelpLine return bogus
        inc     ax                              ; line (== -1 = UNDEFINED)?
        jne     Get_Attr                        ; no, line is buffered

DefaultAttrs:
        mov     bx,OFFSET DGROUP:rgLineAttr     ; pointer to static buffer
        push    bx                              ; save for return ptr
        mov     ax,UNDEFINED
        mov     [bx + LA_cb],ax
        mov     [bx + LA_attr],isaSyntaxHelp
        mov     [bx + (size LINEATTR) + LA_attr],ax

DJMP    jmp     short GetAttr_End

Get_Attr:

; we assume that nothing in the help system will change from the call to
; HelpGetLine.  Thus, we do not have to check that help is up and running,
; as HelpGetLine will zero iCurRequestLine if there are ANY problems.
; Also, CompressHelp will zero iCurRequestLine.

DbAssertTst     HelpFlags,ne,HLP_GOTBUF,UI,<GetHelpLineAttr: HLP_GOTBUF not set>
DbAssertRel     oCurTopic,ne,0,UI,<GetHelpLineAttr:Invalid oCurTopic>

        mov     bx,oCurTopic
        lea     bx,[bx].bdlHelpText.BDL_seg     ; get handle of topic seg

; a-emoryh Added more space for Dos6 online help index strings
        mov     ax,CB_bufStdMsg + 6 + 16 + 70   ; maximum size of buffer

        mov     cx,OFFSET DGROUP:bufStdMsg      ; buffer to store results in
        push    cx                              ; save for mapping start
        xor     dx,dx                           ; offset into topic segment
        cCall   HelpGetLineAttr,<iCurRequestLine,AX,DS,CX,BX,DX>
        pop     bx                              ; pointer to buffer
        or      ax,ax                           ; did we succeed?
        jz      DefaultAttrs                    ; no, use default attrs

        ;Map attributes from HELP format to COW format

        push    bx              ; save ptr to buffer for return

AttrList:
        mov     ax,[bx].LA_attr ; get first attribute
        inc     ax              ; is it -1 (end of list)
        je      GetAttr_End     ; yes, we are done
        dec     ax              ; restore attribute
        DbAssertTst ax,e,<NOT (A_BOLD OR A_UNDERLINE OR A_ITALICS)>,UI,<GetHelpLineAttr: Illegal attributes set>
        mov     cx,isaBold      ; assume bold attribute
        test    ax,A_BOLD       ; does it have any bold in it?
        jne     GotAttr         ; yes, update and loop
        mov     cx,isaUnderline ; assume underline attribute
        test    ax,A_UNDERLINE  ; does it have any underline in it?
        jne     GotAttr         ; yes, update and loop
        mov     cx,isaItalic    ; assume italics attribute
        test    ax,A_ITALICS    ; does it have any italics in it?
        jne     GotAttr         ; yes, update and loop
        mov     cx,isaSyntaxHelp; it must be default

GotAttr:
        mov     [bx].LA_attr,cx ; update attribute
        add     bx,Size LINEATTR; point to next attribute/size pair
        jmp     short AttrList  ; go modify this one.

GetAttr_End:
        pop     ax              ; retrieve pointer to begining of buffer

cEnd

;***
;GetHelpFileSize - Returns the number of lines in the help file
;
;Purpose:
;       This routine is used to set the scroll bar, and to establish
;       the maximum line number in the file.  Since we currently use
;       a virtual file, we will return a virtual size.
;
;Entry:
;       None.
;
;Exit:
;       AX = size of file in lines
;
;Uses:
;       AX
;
;****
DbPub   GetHelpFileSize
cProc   GetHelpFileSize,<NEAR>
cBegin

; HLP_INHELP will only be set if we are about to do something that can
; put up a dialog/message box.  If this routine is called with it set,
; then we are trying to redraw the screen after the box has been removed.
; This can be dangerious, as we may not be in a state where we can
; access a help topic.  Thus we will tell the edit manager that we
; have 0 lines, so it will not call us to redraw the screen.

        mov     ax,iFileSize            ; get size of variable help
        test    HelpFlags,HLP_INHELP    ; are we recursively entering help?
        jz      ExitGHFS                ; no, return with what we got
        cmp     fMessageBox,0           ; are we in a message box?
        jz      ExitGHFS                ; no, return with what we got
        cCall   DrawDebugScr            ; make sure we are redrawn later
        xor     ax,ax                   ; return 0 lines
ExitGHFS:
cEnd



;***
;HelpWndProc - Window Proc for the help window
;
;Purpose:
;       This routine interprets all messages that are going to the help
;       window.  Those of interest is processes and returns a value.
;       Otherwize, it will pass the message on to EditFilterWndProc.
;
;       This routine implements the receiving end of the messaging system.
;       It must be able to be called recursively.
;
;Entry:
;       pwnd    - Ptr to window that is to receive the message
;       msg     - message
;       wParam  - Word parameter to message
;       lParamHi-\ Long word parameter to message, broken up for ease of use.
;       lParamLo-/
;
;Exit:
;       DX:AX - return value
;
;****

labelW  MessageTable                    ; list of addresses for our messages
        dw      UIOFFSET HelpBack
        dw      UIOFFSET CmdHelpNext
        dw      UIOFFSET DisplayHlpGeneric
        dw      UIOFFSET GetHelpCurTopic
        dw      UIOFFSET GetHelpNextTopic
        dw      UIOFFSET ChngHelpCurTopic
        dw      UIOFFSET RestoreHelpTopic
        dw      UIOFFSET GetHelpTitle
        dw      UIOFFSET GetHelpLine
        dw      UIOFFSET GetHelpLineAttr
        dw      UIOFFSET GetHelpFileSize

        .errnz  (($ - MessageTable) / 2) - NUM_HELPMSG

cProc   HelpWndProc,<PUBLIC,FAR>,<SI>
parmW   pwnd
parmW   msg
parmW   wParam
parmW   lParamHi
parmW   lParamLo
cBegin
        inc     fHelpAlloc              ; set recursion flag


        mov     cx,wParam               ; cache in a register for speed
        mov     ax,msg                  ; cache in a register for speed

        mov     bx,ax
        sub     bx,WM_FIRSTHELPMSG      ; is it one of our special msgs?
        cmp     bx,NUM_HELPMSG
        jae     NotInTable              ; no, it is not in table
        shl     bx,1                    ; make into a word index
        mov     dx,lParamHi             ; Make lParam accessable
        mov     ax,lParamLo
        call    CS:MessageTable[bx]     ; and go do the code
        jmp     WndProcExit_2           ; return with code from the call

NotInTable:
        cmp     ax,WM_LBUTTONDBLCLK
        jne     CheckSETFOCUS

DbAssertRel     pwnd,e,<OFFSET DGROUP:wndHelp>,UI,<HelpWndProc:mouse message not for Help window>
        mov     bx,lParamLo
        mov     al,bh                   ; al = screen relative row number
        cbw                             ; ax = screen relative row number
        add     ax,EfHelp.EF_pdCur_olnTop ; ax = file relative row number
        xor     bh,bh                   ; bx = screen relative column number
        add     bx,EfHelp.EF_pdCur_obleft ; bx = file relative column number
        push    BX                      ; push first parameter
SelectHotLinkTrue:
        push    ax

; a-emoryh - Don't beep in QHelp mode when can't find hotlink
;            Do we really want to not beep, though?
        mov     ax, 1                   ; assume do beep
        test    cmdSwitches,CMD_SW_QHELP ; /QHELP viewer?
        jz      hwpDoBeep
        xor     ax, ax                  ; Qhelp mode, so clear beep flag
hwpDoBeep:
        push    ax

;; Old line
;        push    sp

        cCall   SelectHotLink           ; select hot link, allow BEEP
        jmp     WndProcExit

CheckSETFOCUS:
        cmp     ax,WM_SETFOCUS
        jne     CheckSETBOOKMARK
        PUSHI   ax,<OFFSET DGROUP:wndHelp> ; borrow the SETFOCUS call to
        cCall   DoStatusMsg             ; update the status line message
        jmp     Short DefaultCase       ; Pass call onto the edit mgr.

CheckSETBOOKMARK:
        cmp     ax,WM_SETBOOKMARK
        jne     CheckGOTOBOOKMARK
        sub     cx,'0'                  ; CX = wParam - '0'
        cCall   SetBookMark,<CX>
        jmp     short WndProcExit

CheckGOTOBOOKMARK:
        cmp     ax,WM_GOTOBOOKMARK
        jne     CheckCHAR
        sub     cx,'0'                  ; CX = wParam - '0'
        cCall   GotoBookMark,<CX>
        jmp     short WndProcExit

CheckCHAR:
        cmp     ax,WM_CHAR
        jne     DefaultCase
        cmp     cx,09h                  ; is the character a TAB
        jne     NotTab                  ; no, go check for ENTER
        xor     ax,ax                   ; assume not shifted
        test    lParamHi,KK_SHIFT       ; is a shift key pressed?
        jz      GotoHotLink             ; no, use a value of 0
        dec     ax                      ; use -1
GotoHotLink:
        cCall   NextHotLink,<AX>
        jmp     short WndProcExit

NotTab:
        cmp     cx,0dh                  ; is the character an ENTER?
        jne     NotEnter                ; no, go test for another char
        cCall   GetEditColumn           ; AX = file relative column number
        push    ax
        cCall   GetEditLine             ; AX = file relative line number
        jmp     SelectHotLinkTrue       ; select hot link (AX = line)

NotEnter:                               ; check for legal characters
        cmp     cx,7fh                  ; is it a backspace?
        je      DefaultCase             ; yes,  let EditMgr have it
        or      ch,ch                   ; is it a virtual key
        jne     DefaultCase             ; yes, EditMgr will handle it
        cmp     cx,' '                  ; is it a control character
        jb      DefaultCase             ; yes, let EditMgr have it
        cCall   GetEditMgrState         ; Ctrl+Q or Ctrl+K active?
        or      ax,ax                   ; (non-zero if so)
        jnz     DefaultCase             ; yes, EditMgr will handle this
        cCall   toupper,<wParam>        ; convert parameter to uppercase
        cmp     ax,wParam               ; was it already upper?
        jne     GotoHotLink             ; no, goto hotlink
        neg     ax                      ; yes, tell hotlink to look backwards
        jmp     GotoHotLink             ; goto hotlink.

DefaultCase:
        cCall   EditFilterWndProc,<pwnd,msg,wParam,lParamHi,lParamLo>
        jmp     short WndProcExit_2
WndProcExit:
        xor     ax,ax                   ; return 0L
        cwd
WndProcExit_2:
        dec     fHelpAlloc              ; release allocation lock
        cCall   CloseCurHelpFile        ; close the current help file
cEnd

sEnd    UI
        end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uidebug.asm ===
TITLE	uidebug.asm - User interface to debugger.
;*** 
;uidebug.asm
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	Debugging support.
;
;
;*******************************************************************************

	.xlist
	include		version.inc
	UIDEBUG_ASM = ON

	;Include twin interface headers
	include 	cw/version.inc
	include 	cw/windows.inc
	include 	cw/edityp.inc

	;Next, include QBI's headers
	includeOnce	architec
	includeOnce	context
	includeOnce	executor
	includeOnce	heap
	includeOnce	lister
	includeOnce	opmin
	includeOnce	opstmt
	includeOnce	parser
	includeOnce	qbimsgs
	includeOnce	scanner
	includeOnce	txtmgr
	includeOnce	ui
	includeOnce	uiint
	includeOnce	util
	includeOnce	uimenu			
	.list

;---------------------------------------------------------------------------
;
; The following demonstrates how the user interface code interacts with
; the executor code to handle watchpoints and watch expressions.
; We start the discussion in UserInterface with the following program loaded:
;   A=1
;   A=2
; The pcode for this program is:
;   opBol
;   opLit1
;   opIdSt(A)
;   opBol
;   opLit2
;   opIdSt(A)
;   opEndProg
; 
; - User presses single step key, causing UserInterface to exit
; - opBol executes, sees DEBUG_TRACE bit set in debugFlags, enters UserInterface
; - User selects Watchpoint... menu, CmdWatchAdd(WT_Watch) prompts the user
;   for an expression, parses it to pcode, and inserts it at the end of the
;   text table.
; - User selects Watch... menu, CmdWatchAdd(WT_WatchPoint) prompts the user
;   for an expression, parses it to pcode, and inserts it at the end of the
;   text table.
; - We now have with a WATCHPOINT of "A=1" and a WATCH EXPRESSION of "A" and
;   the pcode looks like:
;   opBol
;   opLit1
;   opIdSt(A)
;   opBol
;   opLit2
;   opIdSt(A)
;   opEndProg
;   opIdLd(A)
;   opLit1
;   opEQ
;   opWatchStop
;   opIdLd(A)
;   opWatchExp
;   opEot
; 
; - User presses single step key.  When UserInterface exits, it sees active
;   Watch expressions, and sets DEBUG_WATCH in debugFlags.
; - opLit1 and opIdSt(A) execute
; - opBol executes, sees bits set in debugFlags, enters UserInterface
; - UserInterface immediately dispatches to DebugWatch.  DebugWatch sees
;   iWatch (static counter variable) is UNDEFINED (meaning we weren't executing
;   Watch pcode), saves current pc in otxWatchSave, sets the
;   current pc to the 1st watch expression's pcode, sets iWatch to 0,
;   returns to UserInterface with flags telling it to dispatch.
; - opIdLd(A), opLit1, and opEQ execute.
; - opWatchStop executes, sees a TRUE (non-zero) argument on the stack, sets
;   DEBUG_BREAK in debugFlags.  opWatchStop then falls into opBol which sees
;   debugFlags non-zero and enters UserInterface.
; - UserInterface immediately dispatches to DebugWatch.  DebugWatch sees
;   iWatch is 0, bumps it to 1, sets the current pc to the 2nd watch
;   expression's pcode, returns to UserInterface with flags telling it to dispatch.
; - opIdLd(A) executes.
; - opWatch executes, saves value at [pWatchVal], opWatch then falls into
;   opBol which sees debugFlags non-zero and enters UserInterface.
; - UserInterface immediately dispatches to DebugWatch.  DebugWatch sees
;   iWatch is 1, restores the current pc to otxWatchSave,
;   returns to UserInterface.
; - UserInterface then sees DEBUG_BREAK is set, and would have stopped program
;   execution even if we weren't tracing.  UserInterface then interacts with
;   the user until the user gives another command.
; - User presses single step key.  When UserInterface exits, it sees active
;   Watch expressions, and sets DEBUG_WATCH in debugFlags.
; - opLit2 and opIdSt(A) execute
; - opEndProg executes, causing us to once again enter UserInterface
;
;---------------------------------------------------------------------------


assumes	DS,DATA
assumes	ES,NOTHING
assumes	SS,DATA

	EXTRN	B$BEEP:FAR
	EXTRN	B$IFOUT:FAR
	EXTRN	B$Pause:FAR

sBegin	DATA

	EXTRN	b$ErrNum:word		;error code for last runtime error
	EXTRN	b$CurFrame:word	;current frame ptr (for PTRACE)
	EXTRN	b$MainFrame:word	;base frame ptr

	EXTRN	fRecord:byte		;set TRUE is /RCD switch seen
	EXTRN	fPlayBack:word		;TRUE if we're playing back.
					; an event playback file.
	EXTRN	axMac:byte

	externB HelpFlags		;	uiint.inc/h

;Points to space allocated by CallsMenuInit, released by CallsMenuTerm
;
pbCallsRelease DW 0

;iWatch is used by several functions involved in drawing the content
; of the watch window.  It indicates which line in the window is currently
; being drawn (0 to n)
;
DbPub	iWatch
iWatch	DW	UNDEFINED

; iInstWatch is used to keep track of where an Instant Watch entry is
; in the tWatch table.  The value of iInstWatch is only significant if
; the value of cInstWatch is non-zero.
DbPub	iInstWatch			
iInstWatch DW	0			

;fRefreshWatch is set TRUE whenever a WATCH entry is added or removed.
;It causes us to refresh the WATCH window.
;
PUBLIC	fRefreshWatch
fRefreshWatch	DB	0

;pWatchVal points to valtyp/value structure to be filled in by Watch executors
PUBLIC		pWatchVal
pWatchVal	DW	0

;1 entry per watch expression - number of bytes in expression's title
tCbWatchTitle	DB (WATCH_MAX+1) DUP (?) ; "+1" is for Instant Watch

otxWatchSave	DW 0	;copy of grs.otxCur while WATCH pcode executes
errnumSave	DW 0	; copy of b$errnum while WATCH pcode executes
bpWatchSave	DW 0	;copy of bp for start of current WATCH expression
fDirectSave	DB 0	;copy of grs.fDirect while WATCH pcode executes

;Trace modes
;
TRACE_OFF	EQU 0
TRACE_HISTORY	EQU 1	;Debug/History menu item is ON
TRACE_ANIMATE	EQU 2	;Debug/Trace menu item is ON
TRACE_STEP	EQU 3	;F8 was pressed last time in UserInterface
TRACE_PSTEP	EQU 4	;F10 was pressed last time in UserInterface
TRACE_WATCHSTEP	EQU 5	;Used by watch to force watch code to execute.

traceMode	DB TRACE_OFF

pStepFrame	DW 0
nonStickyBpRs	DW 0
nonStickyBpLn	DW UNDEFINED

CHIST	EQU 20	;we will remember last 20 statements executed
CBHIST	EQU 4	;number of bytes in 1 history entry
bdHist	DB size BD DUP (0)

oHistNext	DW 0
oHistShow	DW 0
histFlags	DB 0
	FH_Full		equ	01H
	FH_NotEmpty	equ	02H

szRun	DB	"RUN",0

sEnd	DATA

sBegin	CODE

;Table of opcodes(1) which descanner inserts where it finds return
; addresses on the stack:
;
tOpNoList LABEL WORD
	opTabStart	NOLIST
	opTabEntry	NOLIST,opNoList1
	opTabEntry	NOLIST,opEot
sEnd	CODE

sBegin	UI
assumes	cs,UI


;**************************************************************************
; DoRunOrCont(ax:fFromStart)
; Purpose:
;	Setup so program will continue execution.
;	If can't continue then start at begining.
;
; Entry:
;	ax = fFromStart - if TRUE start program from the beginning.
; Exit:
;	fGotCmd is set TRUE (which terminates GetCmd)
;
;**************************************************************************
DoCont	PROC NEAR
	sub	ax,ax
DoCont	ENDP
	;fall into DoRunOrCont
cProc	DoRunOrCont,<NEAR>
cBegin
	or	ax,ax
	jne	FromStart
	call	fCanContUI
	jne	NotFromStart		;brif can continue

; FNextStmtDoesIO uses grs.otxCONT to determine if the next statement to
; execute will do output.  ContContext is called just before FNextStmtDoesIO.
; if grs.otxCONT is UNDEFINED, ContContext will
; set grs.otxCONT to the begining of the main module.
;
FromStart:
	call	CantCont		;sets [grs.GRS_otxCONT] to UNDEFINED
	PUSHI	ax,<dataOFFSET szRUN>
	call	DoCmd
NotFromStart:
	mov	[fGotCmd],sp
cEnd

;**************************************************************************
; SetTronTroff
; Purpose:
;	Set [traceMode] and set DEBUG_TRACE bit in [debugFlags] if not TRACE_OFF
;	Called by TRON and TROFF opcode executors after they set [fTraceOn]
; Entry:
;	[fTraceOn] = non-zero if TRON is active
;	[fHistOn] = non-zero if HISTORY is active
;
;**************************************************************************
PUBLIC	SetTronTroff
SetTronTroff PROC FAR
	.errnz	TRACE_ANIMATE - 2
	mov	ax,TRACE_ANIMATE
	cmp	[fTraceOn],ah
	jne	NoTrace			;brif TRON (Trace ON) is not active
	dec	ax			;al = TRACE_HISTORY
	.errnz TRACE_HISTORY - 1
	cmp	[fHistOn],ah
	jne	NoTrace			;brif History ON is not active
	dec	ax			;al = TRACE_OFF
	.errnz TRACE_OFF
NoTrace:
	call	SetTraceMode
	ret				;can't fall into SetTraceMode, far->near
SetTronTroff ENDP

;**************************************************************************
; SetTraceMode
; Purpose:
;	Set [traceMode] and set DEBUG_TRACE bit in [debugFlags] if not TRACE_OFF
; Entry:
;	al = new trace mode (TRACE_STEP etc.)
;
;**************************************************************************
SetTraceMode PROC NEAR
	mov	[traceMode],al
	or	al,al
	je	GotTroff
	.errnz TRACE_OFF
	or	[debugFlags],DEBUG_TRACE
GotTroff:
	ret
SetTraceMode ENDP

;**************************************************************************
; CmdGo(fFromStart)
; Purpose:
;	Continue or start program execution taking into account trace state.
;	This procedure is called in response to the menu items `Run/Run' and
;	`Run/Continue'
;
; Entry:
;	fTraceOn - non-zero if TRON is active
;	fFromStart - TRUE if we want to RUN else we want to CONT.
;
;**************************************************************************
cProc	CmdGo,<PUBLIC,NEAR>
	parmW	fFromStart
cBegin
	call	SetTronTroff		;setup based on [fTraceOn]
	mov	ax,[fFromStart]
	call	DoRunOrCont		;execute a RUN or CONT command
cEnd

;**************************************************************************
; CmdSetNextStmt()
; Purpose:
;	Reset instruction pointer to statement at cursor.
;
;**************************************************************************
cProc	CmdSetNextStmt,<PUBLIC,NEAR>,<si,di>
cBegin
	call	TxtDescan		;descan to SS_PARSE
	call	GetEditLine		;ax = current edit line (from EditMgr)
	push	ax
	call	OtxOfLn 		;ax = text offset to start of line
	xchg	ax, bx			; bx = otx of pcode to skip.
	call	TxtSkipOpFar		;ax = otx beyond the opBol[xx] opcode
					;We always enter direct mode after
					;execution of the opBol
	xchg	si,ax			;si = otx
	mov	di,[grs.GRS_oRsCur]	;di = oRs of current text table
	test	[txdCur.TXD_flags],FTX_mrs
	je	NotInDefFn		;brif we're in a sub/function window
	push	si			;pass otx
	call	OPrsOfOtx		;ax = otx of DEF FN
	inc	ax			;test for UNDEFINED
	je	NotInDefFn		;brif we're in main-level code
	dec	ax			;ax = oPrs for DEF FN
	or	ah,80h			;ax = oRs of DEF FN
	xchg	di,ax			;di = oRs of DEF FN
NotInDefFn:
	call	NeedContContext		;grs.oRsCur=grs.oRsCONT or grs.oMrsMain
					;if no main module, uierr is set
	je	NxtStmtExit		;brif no main module
	cmp	di,[grs.GRS_oRsCur]
	je	BranchOk		;brif branching within text table
BadBranch:
	PUSHI	ax,MSG_BadNextStmt	;"Cannot cross module/procedure boundary"
	call	SetUiErr
	jmp	SHORT NxtStmtExit

BranchOk:
	mov	[grs.GRS_otxCONT],si
	call	DrawDebugScr		;so new current stmt will be hilighted
NxtStmtExit:
cEnd

;**************************************************************************
; CmdRestart()
; Purpose:
;	Restart program. Like a Step but always starts at begining of program.
;
;**************************************************************************
cProc	CmdRestart,<PUBLIC,NEAR>
cBegin
	mov	al,TRACE_STEP
	call	SetTraceMode
	mov	ax,sp			;ax = TRUE (non-zero)
	call	DoRunOrCont
cEnd

;**************************************************************************
; PStepReset
; Purpose:
;	Called whenever executor resets stack pointer.  This guarentees
;	that DebugTrace will stop the next time it is called (even for F10).
;
;**************************************************************************
cProc	PStepReset,<PUBLIC,FAR>
cBegin
	mov	[pStepFrame],0
cEnd

;**************************************************************************
; CmdStep(fPStep)
; Purpose:
;	Setup to execute the next program statement.
;	This routine is called in response to the Step and PStep
;	accelerator keys.
;
; Entry:
;	fPStep - if TRUE count procedure calls as one statement (F10).
;
; Exit:
;	PStepFrame, debugFlags, traceMode, fGotCmd are all updated
;
;**************************************************************************
cProc	CmdStep,<PUBLIC,NEAR>
	parmW	fPStep
cBegin
	call	ContContext		;activate program counter's context
	call	SkipStop		;skip past opBreakPoint or opStStop

	mov	ax,[grs.GRS_otxCONT]
	inc	ax			;test for UNDEFINED
	je	UseBp			;if Can't continue, stop at next entry
	mov	ax,[b$CurFrame] 	;get current frame
	mov	cx,[pGosubLast] 	;get gosub stack value
	jcxz	UseBp			;zero, use current frame as frame

	cmp	cx,ax			
	ja	UseBp			; brif no gosubs for this frame

	xchg	ax,cx			;else use top of stack
UseBp:
	mov	[pStepFrame],ax 	;and move it in

	mov	al,TRACE_STEP
	cmp	[fPStep],FALSE
	je	CsNotPStep		;brif F8 was pressed (step into proc)
	.errnz TRACE_STEP - 3
	.errnz TRACE_PSTEP - 4
	inc	ax			;al = TRACE_PSTEP (F10=step around proc)
CsNotPStep:
	call	SetTraceMode
	call	DoCont			;continue program execution
cEnd

;**************************************************************************
; CmdToggleBp()
; Purpose:
;	Toggles the breakpoint setting of the current line.
;	Note: will only be called if the current window contains code.
;
; Exit:
;	If an edit window is active a breakpoint is set/reset at the
;	current line.
;	ax active edit line (UNDEFINED if none)
;
;**************************************************************************
cProc	CmdToggleBp,<PUBLIC,NEAR>
cBegin
	call	UiGrabSpace
	call	GetEditLine		;ax = current edit line (from EditMgr)
	push	ax			;save for return value
	inc	ax			;test for UNDEFINED
	je	CsNoEditLine
	dec	ax
	push	ax			;pass to ToggleBp
	call	ToggleBp
	mov	[uierr],ax		;store possible error code
	call	DrawDebugScr		;Refresh any lines containing
					;this breakpoint
CsNoEditLine:
	call	UiReleaseSpace
	pop	ax			;ax = edit line
cEnd

;**************************************************************************
; CmdGoUntilHere()
; Purpose:
;  Sets a non-sticky breakpoint at the current line and runs until it
;  gets there. When the breakpoint is reached it will automatically be cleared.
;  Note: will only be called if the current window contains code.
;
;**************************************************************************
cProc	CmdGoUntilHere,<PUBLIC,NEAR>
cBegin
	call	UiRsActivateWnd 	;activate active window's context
	test	[mrsCur.MRS_flags2],FM2_Include OR FM2_NoPcode
	jne	CgExit			;brif not a pcode window
	call	GetEditLine		;get line number
	cCall	OtxOfLn,<ax>		;get otx
	cCall	fBpSet,<ax>		;see if bp is set
	or	ax,ax			
	jnz	CgGo			;do nothing if bp already set
	call	CmdToggleBp		;set break point on current line
	inc	ax			;test for UNDEFINED
	je	CgExit			;brif no active edit line
	dec	ax			;restore ax = line number
	mov	[nonStickyBpLn],ax	;remember to reset break point
	mov	ax,[grs.GRS_oRsCur]
	mov	[nonStickyBpRs],ax
CgGo:
	call	ContContext		;activate program counter's context
	call	SkipStop		;skip past the opBreakPoint
	xor	ax,ax
	cCall	CmdGo,<ax>		;continue program execution
CgExit:
cEnd

;**************************************************************************
; ClrNonStickyBp()
; Purpose:
;	Called on entry to GetCmd()
;	Clears any breakpoint set by CmdGoUntilHere().
; Exit:
;	Context may be switched to another text table.
;
;**************************************************************************
cProc	ClrNonStickyBp,<PUBLIC,NEAR>
cBegin
	mov	ax,[nonStickyBpLn]
	inc	ax			;test for UNDEFINED
	je	ClrNoBp
	dec	ax
	push	ax			;pass to ToggleBp
	push	[nonStickyBpRs]		;pass to UiRsActivate
	call	UiRsActivate
	call	ToggleBp
	mov	[nonStickyBpLn],UNDEFINED
	call	DrawDebugScr		;Refresh any lines containing
					;this breakpoint
ClrNoBp:
cEnd


;**************************************************************************
; DebugError()
; Purpose:
;  Setup to report a runtime error.
;
; Exit:
;  uierr and txtErr structure are setup so error will be reported in GetCmd.
;  Returns mask which tells UserInterface to stop for commands.
;
;**************************************************************************
PUBLIC	DebugError
DebugError PROC NEAR
	mov	ax,[b$ErrNum]
	cmp	ax,MSG_GoDirect
	je	DeExit			;Ignore MSG_GoDirect - it is used
					; when user presses CANCEL button
					; in some dialog.  Easy way to
					; back all the way out of the dialog.
	or	HelpFlags,HLP_RTERR	; this error came from execution

	;Setup so GetCmd() will call ReportError()
	mov	dx,ER_UE		;dx = max standard runtimer error code
	cmp	ax,dx			;see if error was generated by user
					; via ERROR(x) statement
	jbe	StdRtErr		;brif std runtime error code
	xchg	ax,dx			;ax = "Unprintable error"
StdRtErr:
	mov	[uierr],ax		;error will be reported by GetCmd
					; calling ReportError()
	mov	al,[grs.GRS_fDirect]
	mov	[txtErr.TXER_fDirect],al
	mov	ax,[grs.GRS_oRsCur]
	mov	[txtErr.TXER_oRs],ax
	mov	ax,[grs.GRS_otxCur]
	mov	[txtErr.TXER_otx],ax
	mov	[txtErr.TXER_oSrc],0
DeExit:
	mov	ax,FDM_GetCmd
	jmp	SHORT TrOffExit
DebugError ENDP

;**************************************************************************
; DebugStop()
; Purpose:
;  Setup to report stop statement.
;
; Exit:
;  returns mask which tells UserInterface to show the current statement
;    and stop for commands.
;
;**************************************************************************
PUBLIC	DebugStop
DebugStop PROC NEAR
	mov	ax,FDM_GetCmd OR FDM_ShowStmt
	jmp	SHORT TrOffExit
DebugStop ENDP

;**************************************************************************
; DebugEnd()
; Purpose:
;  Called when the program reaches end-of-pcode or END statement
;
; Exit:
;  returns mask which tells UserInterface to stop for commands.
;
;**************************************************************************
PUBLIC	DebugEnd
DebugEnd PROC NEAR
	cmp	[fDebugScr],FALSE
	jne	ShowDeb			;brif debug screen is visible
	cmp	[fRecord],FALSE
	jne	ShowDeb			;brif recording a playback file
	; brif not reading a playback file.  Since RUNTIME consumes the
	; keystroke in B$Pause, this would hang the playback file up.
	cmp	[fPlayBack],FALSE
	jne	ShowDeb

	; The user has just finished running a program up to an END stmt.
	; The output screen is still visible.  Display the prompt:
	; 'Press any key to return to editor'
	; on the bottom line of the output window and wait for the
	; user to press a key.
	
	call	B$Pause
ShowDeb:
	cmp	[grs.GRS_fDirect],FALSE
	jne	DeDirMode		;brif end-of-direct mode execution
	call	EnsShowDebugScr		;init debug screen, make it visible
	call	DrawDebugScr		;turn off old current stmt highlight
DeDirMode:
	mov	ax,FDM_GetCmd
TrOffExit:
	mov	[traceMode],TRACE_OFF
	ret
DebugEnd ENDP

;**************************************************************************
; DebugTrace()
; Purpose:
;   This is invoked when we enter UserInterface with DEBUG_TRACE set in
;   debugFlags.
;   Setup to show current statement and depending on the trace mode stop
;   for commands.
;
; Entry:
;   traceMode = TRACE_HISTORY if we are to do nothing more than record
;		   the pcode address of the instruction for History Playback
;	        TRACE_ANIMATE if we are to show stmt and exit direct mode,
;               TRACE_STEP if we are stopping for each statement (F8),
;               TRACE_PSTEP if we are stepping around procedure calls (F10).
;
; Exit:
;   The current statement's location is recorded in the history buffer.
;   Returns mask to tell UserInterface to show the current statement
;   and/or tell it to stop and interact with the user.
;
;**************************************************************************
cProc	DebugTrace,<PUBLIC,NEAR>,<di>
cBegin
	call	FExecutable		;see if next stmt to be executed
					; contains any executable code
	jne	ItsExecutable		;brif stmt is executable
	sub	di,di			;tell UserInterface to take no action
J1_TrSetTraceFlag:
	jmp	SHORT TrSetTraceFlag

ItsExecutable:

;set debugFlags, traceMode, fGotCmd, and al (return value) as follows:
;switch (traceMode)
;  case TRACE_OFF:
;	fGotCmd remains 0
;       return al = 0
;  case TRACE_HISTORY:
;	fGotCmd remains 0
;       return al = 0
;  case TRACE_ANIMATE:
;	if alternateListWindow is showing new oRs, activate it
;	if fCantCont, directModeCmd = RUN
;	fGotCmd = TRUE
;       return al = FDM_ShowStmt
;  case TRACE_PSTEP:
;	if ([pGosubLast] != 0 && ([pGosubLast] < [pStepFrame])) ||
;	   ([pGosubLast] == 0 && ([b$CurFrame] < [pStepFrame]))
;	   fGotCmd = TRUE
;          return al = 0
;	else
;	   fall into case TRACE_STEP
;  case TRACE_WATCHSTEP:
;  case TRACE_STEP:
;	fGotCmd remains 0
;	traceMode = TRACE_OFF
;	return al = FDM_GetCmd OR (case WATCHSTEP ? 0 :FDM_ShowStmt)
;end switch
;if traceMode != TRACE_OFF
;   debugFlags != DEBUG_TRACE
;
	sub	di,di			;tell UserInterface to take no action
	sub	cx,cx
	mov	cl,[traceMode]		;cx = traceMode
	dec	cx
	.errnz	TRACE_OFF
	js	SHORT TrSetTraceFlag	;brif traceMode == TRACE_OFF
	.errnz	TRACE_HISTORY - 1
	je	TrSetTraceFlag		;brif traceMode == TRACE_HISTORY
	loop	TrNotAnim		;brif traceMode != TRACE_ANIMATE
	.errnz	TRACE_ANIMATE - 2
	sub	ax,ax
	push	ax
	call	CmdGo
TrShow:
	or	di,FDM_ShowStmt
	jmp	SHORT TrSetTraceFlag

TrNotAnim:
	loop	TrNotStep		;brif traceMode != TRACE_STEP
	.errnz	TRACE_STEP - 3
	.errnz	TRACE_WATCHSTEP - 5
TrStep:
	mov	di,FDM_ShowStmt		
TrWatchStep:				
	or	di,FDM_GetCmd		
	mov	[traceMode],TRACE_OFF
	jmp	SHORT TrSetTraceFlag	

	.errnz	TRACE_PSTEP - 4
;traceMode == TRACE_PSTEP
TrNotStep:
	loop	TrWatchStep		
	mov	ax,[b$CurFrame] 	;get current frame
	mov	cx,[pGosubLast] 	;get gosub stack value
	jcxz	TrUseBp			;zero, use current frame as frame
	
	cmp	cx,ax			
	ja	TrUseBp 		; brif no gosubs for this frame

	xchg	ax,cx			;else use top of stack
TrUseBp:
	cmp	[pStepFrame],ax 	;compare, and if pstepframe
	jbe	TrStep			;watermark is below or equal, step

TrSkip:
	call	DoCont			;continue program execution
;di = FDM_xxx actionMask return value
TrSetTraceFlag:
	cmp	[traceMode],TRACE_OFF
	je	TrExit			;leave trace flag 0 if not tracing
	or	[debugFlags],DEBUG_TRACE
TrExit:
	xchg	ax,di			;ax = return value
cEnd	;DebugTrace





;**************************************************************************
; HistReset()
; Purpose:
;   This is called when we Scan/Descan a program to flush the history
;   buffer.
;
;**************************************************************************
cProc	HistReset,<PUBLIC,FAR>
cBegin
cEnd






;**************************************************************************
; CmdWatchDelAll()
; Purpose:
;	Called when 'View/Watch Delete' menu is selected.
;	Delete all active WATCH expressions
;
;**************************************************************************
cProc	CmdWatchDelAll,<PUBLIC,FAR>
cBegin
WDelLoop:
	call	WatchInfoUI		;make sure cWatch is up-to-date
	mov	bx,[cWatch]
	dec	bx
	js	WDelExit		;brif no watch expressions left
	cCall	WatchDel,<bx>		;delete watch expression [bx]
	jmp	SHORT WDelLoop

WDelExit:
cEnd

;**************************************************************************
; WatchDeleted
; Purpose:
;	Called by Text Mgr whenever a Watch expression is deleted.
;	It releases 1 line from the Watch Window in the Debug Screen
;	and remembers to redraw the debug screen.
;
;**************************************************************************
cProc	WatchDeleted,<PUBLIC,FAR>
cBegin
	call	WatchRelease		;release any existing WATCH values
	call	DrawDebugScr		; remember to redraw screen
cEnd

;**************************************************************************
; WatchInfoUI
; Purpose:
;	Given an index for a watch expression, load registers with info
;	about that watch expression.
; Entry:
;	iWatch = watch index (0 to n)
; Exit:
;	ax = oRs for text table containing expression
;	bx = pointer to 1 byte valTyp, 8 byte value structure
;	cx = otx to start of expression
;	[cWatch] = number of watch expressions in all loaded modules
;	grs.fDirect is set to FALSE
;
;**************************************************************************
PUBLIC	WatchInfoUI
WatchInfoUI PROC NEAR
	mov	bx,[iWatch]
WatchInfoUI ENDP
WatchInfoBx PROC NEAR
	call	WatchInfo
	ret
WatchInfoBx ENDP

;**************************************************************************
; WatchName
; Purpose:
;	Fill bufStdMsg with the title of a watch expression.
;	The text table containing the watch expression is also activated.
; Entry:
;	ax = oRs for watch pcode
;	cx = otx for watch pcode
; Exit:
;	entry's register set is activated
;	bufStdMsg = '<context> <expression>: '
;	bx = &bufStdMsg, ax = #bytes in message
;
;**************************************************************************
cProc	WatchName,<PUBLIC,NEAR>,<si>
	localV	bdBuf,<size BD>
cBegin
	dec	cx
	dec	cx			;back up to opEndProg or prev opWatch
					; ListLine treats these like opBol
	mov	si,cx			;si = otx for expression

	push	ax			;preserve ax
	push	ax			;pass oRs to UiRsActivate
	call	UiRsActivate
	pop	ax			;ax = oRs

	push	ax			;pass oRs to GetRsName
	mov	al,RSN_fIndent
	push	ax			;pass GetRsName flags
	mov	al,20d
	push	ax			;cbMax = 20
	call	GetRsName		;fill bufStdMsg with name
					;ax = cbName
	mov	bx,dataOFFSET bufStdMsg ;bx points to buffer being filled
	add	bx,ax			;ax points beyond end of context's name
	mov	BYTE PTR [bx],' '
	inc	bx			;bx points to dst for expression's name
	mov	dx,CB_bufStdMsg - 3	;dx = max chars in context + expression
	DbAssertRel CB_bufStdMsg,ae,40d,UI,<WatchName: msg buffer too small>
	sub	dx,ax			;dx = max chars left for expression
	mov	[bdBuf.BD_cbLogical],dx ;pass cbMax to ListLine
	mov	[bdBuf.BD_pb],bx	;pass ptr to buffer to ListLine
	push	bx			;save ptr to expression's name
	lea	bx,bdBuf
	push	si			;pass otx to ListLine
	push	bx
	call	ListLine		;ax = #bytes listed
	pop	bx			;bx points to szExpression
	add	bx,ax			;bx points to 0-byte terminator
	mov	ax,dataOFFSET bufStdMsg + 40d
	cmp	bx,ax
	jb	LengthOk		;brif length of context+name < 40
	xchg	bx,ax			;truncate length of name to 40
					; 20 for context, 20 for expression
LengthOk:
	mov	WORD PTR [bx]," :"	;store ": " at end of expression
	inc	bx
	inc	bx			;return ax = new cbMsg
	mov	BYTE PTR [bx],0		;store 0-byte terminator
	mov	ax,dataOFFSET bufStdMsg ;ax points to start of name
	xchg	ax,bx			;bx points to start of name (ret value)
					;ax points to end of name
	sub	ax,bx			;ax = length of name (return value)
cEnd

;**************************************************************************
; WatchNameId(idWatch)
; Purpose:
;	Fill bufStdMsg with the title of a watch expression.
;	The text table containing the watch expression is also activated.
; Entry:
;	idWatch = id of watch expression (0..WATCH_MAX)
; Exit:
;	entry's register set is activated
;	bufStdMsg = '<context> <expression>: '
;
;**************************************************************************
cProc	WatchNameId,<PUBLIC,NEAR>
	parmW	id
cBegin
	mov	bx,[id]
	call	WatchInfoBx		;ax = oRs, cx = otx for id
					;bx = ptr to valTyp, value
	call	WatchName		;fill bufStdMsg with title (id)
					;bx = pbMsg, ax = cbMsg
cEnd

;**************************************************************************
; WatchPrint
; Purpose:
;	Display some information in the Watch window
;
; Entry:
;	[iWatch] = 0 to n and identifies an entry in the watch window
;	bx = pbMsg
;	ax = cbMsg
;	cx = ALERT flag (0 for normal, non-zero for WatchBreak value)
;	dx = the type of information as follows:
;	     0:  expression's title
;	     1:  expression's value
;
;**************************************************************************
cProc	WatchPrint,<PUBLIC,NEAR>,<si,di>
	localV	rrc,<size _ARC>
cBegin

	;preserve window's current attribute, set it to Watch Window's attr
	xchg	si,bx			;si = pbMsg
	mov	di,isaWatchWindow	; [17] di = current isa
	jcxz	NotAlert
	mov	di,isaWatchpointHilite	
NotAlert:
	mov	bx,dataOFFSET tCbWatchTitle
	add	bx,[iWatch]		;bx points to cbTitle field
	or	dx,dx
	je	Type0			;brif not printing Watch Value
	mov	dl,[bx]			;dx = 1 column beyond title
	jmp	SHORT DisplayIt

Type0:
	mov	[bx],al			;tCbWatchTitle[iWatch] = cbMsg

;ax = byte count
;dx = 1st column to write
;si = ptr to string to write
;
DisplayIt:
	mov	cx,80d
	mov	bx,ax
	add	bx,dx
	sub	bx,cx
	jbe	Fits
	sub	ax,bx
	jb	WpExit			;if new starting column is negative
Fits:
	PUSHI	cx,<dataOFFSET wndDebug>
	push	dx			;pass rx
	push	[iWatch]		;pass ry
	push	si			;pass ptr to string
	push	ax			;pass cch (byte count)
	push	di			;pass isa
	call	TextOut

WpExit:
cEnd



;**************************************************************************
; WatchValue
; Purpose:
;	Called by DebugWatch and DrawWatch to list
;	an expression's value into a buffer in ASCII format.
;
;	[23] Modified to not call WatchPrint (just list to buffer).
;
; Entry:
;	bx points to 1 byte valTyp, 8 byte value structure
;	[iWatch] = watch id (0..n)
; Exit:
;	bx - points to value in display (ASCII) format
;	ax - cb - length of string pointed to by bx.
;	cx - fAlert - TRUE if watch is a watchpoint.
;
;**************************************************************************
DbPub	WatchValue			
cProc	WatchValue,<NEAR>
cBegin
	mov	al,[bx]			;al = value type
	inc	bx			;bx points to value
	xor	ah,ah			;ax = 0 if no value
	or	al,al
	je	NoValue
	js	WatchErr		;brif value = standard error code
	cmp	al,12h
	je	WValPoint		;brif got watch point
	cmp	al,24h
	je	WValStr			;brif got string
	push	ds
	pop	es			;es = DGROUP (for B$IFOUT)
	;inputs to B$IFOUT are bx->number, al = type, es=ds
	call	B$IFOUT 		;bx = adr of ascii string
					;ax = byte count
	jmp	SHORT WValNoAlert

WValStr:
	mov	ax,[bx.SD_cb]		;ax = byte count for WatchValue
	mov	bx,[bx.SD_pb]		;bx = ptr to WatchValue
;bx = pbMsg, ax = cbMsg
WValNoAlert:
	sub	cx,cx			;normal, not Alert attribute
	jmp	SHORT WValPrint

WatchErr:
	sub	cx,cx			;cx = FALSE (no alert)
	mov	ax,[bx]			;ax = MSG_xxx (standard error code)
	jmp	SHORT PrintStdMsg

WValPoint:
	sub	cx,cx			;cx = FALSE (no alert)
	mov	ax,MSG_FALSE
	cmp	WORD PTR [bx],0		;test boolean's value
	je	PrintStdMsg		;brif boolean expression is TRUE
	.errnz	MSG_TRUE - MSG_FALSE - 1
	inc	ax			;ax = MSG_TRUE
	dec	cx			;cx = TRUE (alert)
PrintStdMsg:
	push	cx			;preserve alert flag
	push	ax			;pass msg id to ListStdMsg
	call	ListStdMsg		;ax = byte count of msg
	pop	cx			;restore alert flag
	mov	bx,dataOFFSET bufStdMsg	;bx points to start of msg

;bx = pbMsg, ax = cbMsg
;cx = ALERT flag (0 for normal, non-zero for WatchBreak value)
WValPrint:
NoValue:
cEnd

;**************************************************************************
; DrawWatch()
; Purpose:
;	Called to draw Watch Window whenever the debug screen is being drawn.
;
;**************************************************************************
cProc	DrawWatch,<PUBLIC,NEAR>
cBegin
	mov	ax,[cWatch]		;ax = # watch active expressions
;if      FV_INSTWAT 		     
;	     sub     ax,[cInstWatch]	     ; Leave out any instant watch.
;endif   ;FV_INSTWAT		     
	mov	[iWatch],ax		;start with bottom WATCH line
DwLoop:
	mov	ax,[iWatch]
	dec	ax
	mov	[iWatch],ax
	js	DwExit			;brif end of watch expressions
					;i.e. if iWatch == UNDEFINED

	call	WatchInfoUI		;ax = oRs, cx = otx for iWatch
					;[bx] = ptr to valTyp, value
	push	bx			;save ptr to watch value
	call	WatchName		;fill bufStdMsg with title (iWatch)
					;bx = pbMsg, ax = cbMsg
	sub	dx,dx			;watchInfo = TITLE
	sub	cx,cx			;not ALERT
	call	WatchPrint		;display Watch title
	pop	bx			;bx = ptr to watch value
	call	WatchValue		;display Watch value on screen
					;bx = pbMsg, ax = cbMsg, cx = fAlert
	mov	dx,1			;print value, not title
	call	WatchPrint		
	jmp	SHORT DwLoop

DwExit:
cEnd

;**************************************************************************
; DebugWatch()
; Purpose:
;	This is called when we enter direct mode while any watch expressions
;	are active.  It updates the display by executing the watch opcodes.
; Note:
;	Currently, the only watch expressions which get updated are those
;	from the current context (i.e. if a SUB is active, only expressions
;	entered while the SUBs list window was active are updated).
;	If you are tempted to allow all watch expressions to be updated
;	no matter which oRs is active, be warned:  The scanner must
;	prevent function and DEF FN references in WATCH pcode, the
;	most recent BP for the sub must be loaded into BP temporarily
;	(so the most recent incarnation of the SUBs variables can be
;	accessed), error and event trapping would have to be disabled.
; Entry:
;	[iWatch] = UNDEFINED if UserInterface was entered after executing
;		   user pcode.
;	[iWatch] = 0..n if UserInterface was entered after executing
;		   watch expression [iWatch]
; Exit:
;	if next pcode to execute is Watch pcode
;	   iWatch is set to 0..n, indicating which Watch pcode is being executed
;	   grs.otxCur is set pointing to the watch pcode to execute
;	   grs.fDirect is set FALSE.
;	   grs.GRS_flags.FG_WatchActive is set
;	   returns TRUE (non-zero)
;	if next pcode to execute is user pcode
;	   iWatch is set to UNDEFINED
;	   grs.otxCur, grs.fDirect, grs.oRsCur are restored from the
;	      static values which were saved by DebugWatch when the last
;	      user pcode finished executing
;	   grs.GRS_flags.FG_WatchActive is clear
;	   returns FALSE
;	Condition codes are set based on value in ax
;
;**************************************************************************
;Note:
;	The code is organized so that the most common path makes no branches
;	so it is as fast as possible.
;

;NOTE:	This isn't the main entry --- DebugWatch is below.  This is here
;	for optimal short-jump space.
;	dl = [debugFlags]
UserPcode:
	;If we execute Watch pcode after each direct mode statement, we could
	;never execute RUN or SYSTEM if one of the Watchpoints was TRUE.
	;So, we just execute it at the end (opEot) of the direct mode stmt.
	
	test	dl,DEBUG_ERROR OR DEBUG_STOP
	jne	J1_DWatchFalse		;brif runtime error in user-pcode
	mov	ax,[grs.GRS_otxCur]	;capture cur execution state in ax,bl
	mov	bl,[grs.GRS_fDirect]
	or	bl,bl
	je	SaveState1		;brif not executing Direct Mode stmts
	test	[grs.GRS_flags],FG_allSsExecute
	je	J1_DWatchFalse		;can't execute WATCH pcode if some
					; text table isn't scanned to SS_EXECUTE
	inc	ax			;test for UNDEFINED
	je	SaveState		;brif just executed an dir mode opEot
J1_DWatchFalse:
	jmp	DWatchFalse		;brif user stmt had an error

SaveState:
	;preserve state of user's pcode before we begin executing WATCH pcode
	dec	ax			;restore ax = grs.otxCur
SaveState1:
	mov	[bpWatchSave],bp
	mov	[otxWatchSave],ax
	mov	ax,[b$errnum]		
	mov	[errnumSave],ax 	
	mov	[fDirectSave],bl
	sub	ax,ax			;initial iWatch is 0
	jmp	SHORT ExWatchPcode


cProc	DebugWatch,<PUBLIC,FAR>
cBegin
NextWatch:
	mov	dl,[debugFlags]
	or	dl,dl
	.errnz	DEBUG_CANT_CONT - 80h
	js	J1_DWatchFalse		;don't try to watch if can't continue
					; otherwise it screws up error reporting
	mov	ax,[iWatch]
	inc	ax			;test for UNDEFINED
	je	UserPcode		;brif just executed user pcode
;ax = index for next WATCH pcode to execute
ExWatchPcode:
	cmp	bp,[bpWatchSave]
	jb	WatchInUserFunc		;brif Watch expression is evaluating
					; a user-pcode function.  Don't execute
					; watch expressions recursively.
	test	[debugFlags],DEBUG_ERROR
	je	NoWatchErr		;brif no error in previous watch-pcode
	push	ax			;save iWatch for next watch expression
	and	[debugFlags],NOT DEBUG_ERROR
	call	WatchInfoUI		;bx = ptr to valTyp, value
					; for watch expression with error
	push	bx			;save ptr to watch entry
	push	bx			;pass parm = ptr to watch entry
	call	ZeroWatchVal		;release string descriptor if any
	pop	bx			;bx = ptr to watch entry
	mov	BYTE PTR [bx],0FFh	;valtyp = std error code
	sub	ax,ax
	xchg	ax,[b$ErrNum]
	mov	[bx+1],ax		;save error code
	pop	ax			;restore ax = iWatch for next expression
;ax = index for next WATCH pcode to execute
NoWatchErr:
	cmp	ax,[cWatch]
	jae	EndWatch		;brif last watch exp has been executed
	mov	[iWatch],ax
	xchg	bx,ax			;bx = iWatch
	call	WatchInfo		;ax = oRs for text table for iWatch
					;cx = otx to start of watch pcode
					;bx = ptr to valTyp, value
					;grs.fDirect = FALSE
	cmp	ax,[grs.GRS_oRsCur]
	jne	DOutOfScope		;brif exp isn't from current context
	mov	[pWatchVal],bx		;tell executor where to store value
	mov	[grs.GRS_otxCur],cx
	mov	[grs.GRS_fDirect],0	
	or	[grs.GRS_flags],FG_WatchActive
	DbAssertTst [grs.GRS_flags],ne,FG_allSsExecute,UI,<DebugWatch err1>
DWatchTrue:
	mov	ax,sp			;return TRUE - tells caller we're
					; about to execute watch-pcode
	or	ax,ax			;set condition codes for caller
DWatchExit:
cEnd

;bx points to entry in watch table for current watch expression
DOutOfScope:
	DbHalt	UI,<DOutOfScope: Watch code not enabled for LQB>	
	or	[debugFlags],DEBUG_ERROR
	jmp	NextWatch		;go get next watch expression

;Watch expression is evaluating a user supplied function
;If runtime error occurs within a watch expression, it is untrappable
; and reported.
;Otherwise, just return and continue executing the function.
;This causes TRACE to be disabled during WATCH pcode.
;
WatchInUserFunc:
	test	[debugFlags],DEBUG_ERROR OR DEBUG_STOP
	je	DWatchTrue		;brif watch expression had no error
	or	[debugFlags],DEBUG_CANT_CONT
					;don't allow user to continue after
					; error in Watch function
	jmp	SHORT DWatchFalse	;let error/breakpoint/stop within
					;user-function be reported.

EndWatch:
	cmp	[fDebugScr],FALSE
	je	NoDebugScr		;brif debug screen not visible
DebDrawLoop:
	call	WatchInfoUI		;bx = ptr to valTyp, value
	call	WatchValue		;display Watch value on screen
	mov	dx,1			;print value, not title
	call	WatchPrint		
	dec	[iWatch]
	jns	DebDrawLoop

;Restore state of user-pcode that was interrupted to execute watch-pcode
NoDebugScr:
	mov	al,[fDirectSave]
	mov	[grs.GRS_fDirect],al
	mov	ax,[errnumSave] 	;restore value of b$errnum from
	mov	[b$errnum],ax		;  before WATCH pcode execution
	mov	ax,[otxWatchSave]
	mov	[grs.GRS_otxCur],ax
	DbAssertRel bp,e,[bpWatchSave],UI,<DebugWatch: invalid bp>
DWatchFalse:
	and	[grs.GRS_flags],NOT FG_WatchActive
	mov	ax,UNDEFINED
	mov	[iWatch],ax
	inc	ax			;return FALSE - tells caller we're
	jmp	SHORT DWatchExit	;about to execute user-pcode
					;Condition codes are also set for caller


sEnd	UI

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uifileio.asm ===
page    ,132

        TITLE UIFILEIO - low level file io routines.
;***
;UIFILEIO - low level file io routines.
;
;       Copyright <C> 1988, Microsoft Corporation
;
;Purpose:
;
;
;*******************************************************************************

        .xlist
        include version.inc

        UIFILEIO_ASM = ON

        .list

        include cw/version.inc
        include cw/windows.inc
        include cw/edityp.inc

        includeonce     architec
        includeonce     rtps
        includeonce     uiint
        includeonce     heap

assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

    ; Following declarations/definitions added while converting c - Asm.


        externFP BdAlloc
        externFP SetTabs
        externFP SetIsaColor
        externFP GetIsaColor
        externFP GetTabs
        externNP ColorResolution

        externFP FindAndOpenFile

        subttl  DATA segment definitions.

sBegin DATA

;NOTE: ORDERING OF bdLibPath, bdExePath, bdInclPath, bdHelpPath
;      IN UIPATHS.ASM MUST REMAIN CONSTANT.

        externW bdLibPath
        externW fOptionsChanged
        externW fScrollBars
        externB fSyntaxCheck
        externB fDebugScr

        externB fRightMouseHelp

        externB b$Buf1
        externW __aenvseg


; some constants for ReadQbIni and WriteQbIni

QBSIGNATURE     equ    4251h        ; Signature for 2.0, 3.0, 4.5

QB45VERSION     equ    0450h

QB40SIGNATURE   equ    4215h
QB40VERSION     equ    0390h
QB20VERSION     equ    0200h

QHELP11VERSION  equ    0460h                    ; [QH1]


AtrData struc

    bkClr   dw      ?
    fgClr   dw      ?
    fHLgt   dw      ?
    fBlnk   dw      ?

AtrData ends

    ;*************************************************************
    ; WARNING ! WARNING ! WARNING ! WARNING ! WARNING ! WARNING !

    ; B$ULLoad in RTMLOAD.ASM also reads qb.ini but doesn't have
    ; access to this structure definition. If this structure changes
    ; B$ULLoad must also be changed.

    ; WARNING ! WARNING ! WARNING ! WARNING ! WARNING ! WARNING !
    ;*************************************************************

;; [QH1]
;;  a-emoryh:
;;  Well, i looked, but i didn't find any code to change over in rtmload.asm.
;;  My guess is that user-library stuff was removed from Dos5 QBasic, to keep
;;  it lower-end than the stand-alone Basic products.  Hope that's true!
;;
OPTIONS struc

    signature   dw  ?
    version     dw  ?
    normT       db  SIZE ATRDATA DUP(?)
    curLn       db  SIZE ATRDATA DUP(?)
    bpLn        db  SIZE ATRDATA DUP(?)
    tabStopsOpt dw  ?
    fScroBars   dw  ?
    fSyntCheck  dw  ?

    fEZM        db  ?
    RightM      db  ?

    iPrint      dw  ?                           ; [QH1]
    fFile       dw  ?                           ; [QH1]
    szPrint     db  MAX_PATH DUP(?)             ; [QH1]

OPTIONS ends

staticW fh,0
globalB qbIniFName,<"qbasic.ini",0>
        cbqbIniFName = $ - qbIniFName

sEnd    DATA

        page

sBegin  UI
assumes CS,UI

        externNP CheckSwitchDiskettes

        subttl  Low level MSDOS File I/O calls.
        page

; NOTE: can't assert that b$fInt24Err is NZ in all these routines, since
;       a few are called from TXTLOAD/TXTSAVE, and int24 errors are supposed
;       to be hooked there.

; Exit:
;       If error, ax = UNDEFINED
;       otherwise, ax = return code
;
cProc   DoInt21,<NEAR>
cBegin
        int     21h
        jnc     IntOk           ;brif no error
        mov     ax,-1           ;Return error condition.
IntOk:
cEnd

;***
; OpenFile(szFile), CreateFile(szFile)
; Purpose:
;       Open specified file using supplied string.
;       Opens file for Read-Only access.
;       Use CreateFile to open for write-access.
; Entry:
;       pointer to Zero terminated string.
; Exit:
;       AX == file fhandle.
;       AX == -1 for error condition, carry set
;
;****
labelNP <PUBLIC,OpenFile>
        mov     ax,3d00h                ; open for read access
        SKIP2_PSW                       ; eat the next MOV

labelNP <PUBLIC,CreateFile>
        mov     ah,3ch                  ; create

cProc   OpenCreateFile,<NEAR>
        ParmW   szFile
cBegin
        mov     bx,[szFile]             ; bx = *file name
        cCall   <FAR ptr OpenCheckDrive>,<ds:[bx]> ; make sure we don't
                                        ; have to switch diskettes
                                        ; PRESERVES ALL REGISTERS
        mov     dx,bx                   ; dx = * to fn
        xor     cx,cx                   ; for CreateFile
        call    DoInt21
cEnd



;***
;OpenCheckDrive(drive)
;
;Purpose:
;       Called before opening a file or getting the current directory,
;       to check if the logical drive might have to be switched.
;
;       Re-written with revision [6].
;
;Entry:
;       drive = possible "drive_letter" + ":"
;
;Exit:
;       None
;
;Uses:
;       None.  Callers depend on ALL REGISTERS being preserved
;****

cProc   OpenCheckDrive,<FAR,PUBLIC>,<ax,bx,cx,dx,es>
parmW   drive
cBegin
        cmp     fDebugScr,0             ; capable of displaying a msg?
        jz      NoNewDrive              ; brif not -- let DOS do it

        mov     ax,[drive]              ; bx = possible "drive_letter" + ":"
        cmp     ah,':'                  ; drive specified?
        jne     NoNewDrive              ; brif not
        DbAssertRelB    al,ne,0,UI,<OpenCheckDrive: Null filename>
        cCall   CheckSwitchDiskettes,<ax> ; if we are switching logical disk
                                        ; drives, do it, and display a msgbox
NoNewDrive:
cEnd

        page

;***
;  CloseFileNear(fhandle)       [3]
;
;  Near routine to close file specified by "fhandle"
;
;  Inputs:      integer specifying fhandle to be closed.
;
;  Outputs:     AX == -1 for error conditio, carry set
;
;****

cProc CloseFileNear,<PUBLIC,NEAR>
        ParmW   fhandle
cBegin
        mov     bx, [fhandle]
        mov     ah, 3eh
        call    DoInt21
cEnd


        page

;***
;  WriteFile(fhandle, offBuf, cb)
;
;  Write cb bytes to file fhandle.
;
;  Inputs:
;       fhandle - file handle to write to.
;       offBuf  - address of buffer.
;       cb      - length of buffer.
;
;  Outputs:     AX == -1 for error conditions, carry set
;
;****

cProc WriteFile,<PUBLIC,NEAR>,<SI,DI,DS>
        ParmW   fhandle
        ParmW   offBuf
        ParmW   cb

cBegin
        mov     bx, [fhandle]
        mov     cx, [cb]
        mov     dx, [offBuf]
        mov     ah, 40H
        call    DoInt21
cEnd

        page

;***
;  ReadFile(fhandle, offBuf, cb)
;
;  Read file fhandle of cb bytes into the segment:offset buffer area.
;
;  Inputs:      unsigned integer file fhandle.
;               unsigned integer offset address.
;               unsigned integer count of bytes to read.
;
;  Outputs:     AX == -1 for error conditions, carry set
;
;****

cProc ReadFile,<PUBLIC,NEAR>
        ParmW   fhandle
        ParmW   offBuf
        ParmW   cb

cBegin
        mov     bx, [fhandle]
        mov     cx, [cb]
        mov     dx, [offBuf]
        mov     ah, 3fh
        call    DoInt21
cEnd

        page


;***
; FileExists(szFile)
; Purpose:
;       Determine whether or not a given filename exists.
; Entry:
;       szFile = pointer to Zero terminated string.
; Exit:
;       AX == TRUE if file found, false if not.
;
;****
cProc   FileExists,<PUBLIC,FAR>
        ParmW   szFile
cBegin
        push    [szFile]
        call    OpenFile                ;ax = file handle
        inc     ax
        je      NotOpened               ;return FALSE if file not opened
        dec     ax                      ;restore ax = file handle
        cCall   CloseFileNear,<ax>
        mov     ax,sp                   ;return TRUE
NotOpened:
cEnd

;***
; DelFile(szFile)
; Purpose:
;       Delete a file
; Entry:
;       szFile = pointer to Zero terminated string.
; Exit:
;       ax = -1 if error
;
;****
cProc   DelFile,<PUBLIC,FAR>
        ParmW   szFile
cBegin
        mov     dx, [szFile]
        mov     ah, 41h
        call    DoInt21
cEnd


;***
; ReadQbIni () - Read QB.INI file into the system
;
; Purpose:
;       Called at startup to read in the qb.ini file off the path and
;       set up defaults as appropriate.
;
; Entry:
;       None.
;
; Exit:
;       Sets up fOptionsChanged, fEZMenus, fRightMouseHelp, fSyntaxCheck
;       variables to default setup. Also sets colors using SetIsaColor.
;
; Uses:
;       Per Convention
;
;************************************************************************


cProc   ReadQbIni,<PUBLIC,NEAR>,<SI,DI>
cBegin

DbAssertRel b$fInt24Err,ne,0,UI,<ReadQbIni: Int 24 errors not ignored>

        mov     iPrintPort, DEV_LPT1    ; Set up print-dest defaults   ; [QH1]
        mov     fPrintToFile, 0                                        ; [QH1]
        mov     szPrintDest, 0                                         ; [QH1]


        mov     ax,SIZE OPTIONS         ; Allocate space on the frame
        sub     sp,ax                   ; for local structure.
        mov     fOptionsChanged,FALSE
        push    ax                      ; AX = SIZE OPTIONS

        mov     di,DATAOFFSET bdLibPath ; Allocate runtime heap entries
        mov     si,UIOFFSET DoAllocs    ; for all 4 Paths in environment
        Call    FourTimes               ; Lib, Exe, Incl, Help

        mov     di,DATAOFFSET bdLibPath ;[9] Set cbLogical to 1 for all 4
        mov     si,UIOFFSET DoTrims     ; path bd's (Lib, Exe, Incl, Help)
        Call    FourTimes

        cmp     uierr,FALSE             ; if heap allocation failed then exit
        jne     jmp_OpenFailed          ; from ReadQbIni. This is Out_of_Memory
                                        ; error. User interface will check
                                        ; for this and exit gracefully.

                                        ; initialise for unchanged Ini file
        xor     bx,bx                   ; BX = FALSE for Read Only Mode.
        call    OpenQBIni               ; Open the QB.INI file for reading
        jnz     OpenOK                  ; AX = File Handle for QB.INI
jmp_OpenFailed:
        jmp     short OpenFailed

OpenOK:
        DbHeapMoveOff           ; can't have heap movement below, since BD's
                                ; could be trimed back to their cbLogical's,
                                ; causing us to read QB.INI paths over the
                                ; top of memory we don't own.
        pop     bx                      ; BX = Size of Options, Bytes to be read
        mov     si,sp                   ; set up si to Frame for Ini Options
        push    bx                      ; Save Size of Options for later usage
        cCall   ReadFile,<ax,si,bx>
        cmp     ax,UNDEFINED            ; AX = -1 if error in reading.
        jz      ReadDone                ; brif error -- close file & return

        mov     ax,[si].signature
        cmp     ax,QB40SIGNATURE        ; if it is qb40 change its signature
        jnz     notqb40                 ; to qbsignature
        mov     ax,QBSIGNATURE
        dec     fOptionsChanged         ; fOptionsChanged set to TRUE
notqb40:
        cmp     ax,QBSIGNATURE          ; check for qb signature
        jnz     ReadDone                ; if not qb4 then look for qb2

        mov     ax,[si].version         ; AX=VERSION

; [QH1]
        cmp     ax, QHELP11VERSION      ; If QHELP version, start reading
        je      qb4version
        mov     fOptionsChanged, TRUE   ; Else upgrade it to QHELP11VERSION


        cmp     ax,QB40VERSION          ; check for qb 40 or 45 versions
        je      qb4version
        cmp     ax,QB45VERSION
        je     qb4version

        cmp     ax,QB20VERSION          ; Check for qb20 version. If
        jnz     ReadDone                ; yes then OptionsChanged True.
        jmp     SHORT ReadDone


qb4version:
        push    si                      ; Save SI = pointer to Option
                                        ; Frame on stack, because it is
                                        ; modified by Chk3Windows/SetSColor

        mov     di,UIOFFSET SetSColor   ; Set up default colors for
        call    Chk3Windows             ; Normal Text, Break Points,
                                        ; and Current Statement by calling
                                        ; SetSColor in Chk3Windows.
        call    ColorResolution         ; Resolve color dependencies.

        pop     si                      ; Restore SI=ptr to Option Frame
        mov     di,si                   ; di = *options(for later)
        lea     si,[si.tabStopsOpt]     ; SI = *tabstopsOpt
        lodsw                           ; Get default TabStops
        cCall   SetTabs,<ax>            ; Set Tabs
        lodsw                           ; Get default ScrollBars
        mov     fScrollBars,ax          ; Set ScrollBars
        lodsw                           ; Get default SyntaxCheck Status
        mov     fSyntaxCheck,al         ; Set SyntaxCheck Status

        cmp     [di].version,QB45VERSION ; DI = Options
        jl      ReadDone

        lodsb                           ; Get fEZM
        lodsb                           ; Get RightMouseHelp Status


;; [QH1] - Read print-dest info, if ini-file was QHELP version
        cmp     [di].version, QHELP11VERSION
        je      ReadPrintInfo
ReadPaths:

        mov     ax,UIOFFSET readfileabc ; Read four Paths
        call    rd_wrt_path


ReadDone:
        cCall   CloseFileNear,<fh>      ; Close the opened file
        DbHeapMoveOn                    ; heap movement OK now

OpenFailed:
        pop     ax                      ; AX = SIZE OPTIONS
        add     sp,ax                   ; Release allocated frame space
cEnd

;;
;; [QH1] Start
;;
;; Read print-dest info
;;      SI now points to Options.iPrint
;;      DI points to beginning of Options
;;
ReadPrintInfo:
        lodsw                           ; Load printer port
        cmp     ax, cDEVICES            ; Make sure field is valid
        jge     SkipDevField            ; Bogus value!!, so keep default
        mov     iPrintPort, ax

        lodsw                           ; Read PrinterOrFile flag
        mov     fPrintToFile, ax

SkipDevField:
        ; Load szPrintDest
        push    di
        mov     ax, ds                  ; Give ES the DATA seg (I hope!)
        mov     es, ax
        lea     di, szPrintDest

        mov     cx, MAX_PATH
        rep     movsb
        dec     di
        mov     BYTE PTR [di], 0        ; Make it asciiz, if not already
        pop     di

        ; Now SI should point to first field following Option.szPrint[]
        jmp     short ReadPaths
;;
;; [QH1] End
;;


;***
; rd_wrt_path() - performs read/write of all 4 path names
;
; Purpose:
;       This is written to save code. ReadQbIni reads and WriteQbIni
;       writes the information.
;
; Entry:
;       AX should have address of read/write-fileabc to be invoked by
;       by rd_wrt_cb2.
;
; Exit:
;       None.
;
; Uses:
;       Both SI,DI are destroyed.
;***********************************************************************

cProc   rd_wrt_path,<NEAR>
cBegin
        mov     di,DATAOFFSET bdLibPath ; Write BD structure for all the
        mov     si,UIOFFSET rd_wrt_cb2  ; four paths
        jmp     SHORT Fourtimes         ; Call rd_wrt_cb2 4 times and return
cEnd    <nogen>


;***
; rd_wrt_cb2() - reads/writes size of paths, then reads/writes the path into
;             heap entry for it.
; Purpose:
;       It has been written to save on code. This reading/writing
;       is done for all the four paths. It is used in conjunction
;       with procedure FourTimes.
;
; Entry:
;       DI should point to bd structure for current path.
;       fh has file handle for qb.ini
;       AX has offset of readfileabc/writefileabc - routine to be called
;       bdLibPath, bdExePath, bdInclPath, bdHelpPath must be contiguous
;       and in correct order.
;
; Exit:
;       DI is updated to next bd structure
;
; Uses:
;       DI is destroyed.
;
;***************************************************************************

cProc   rd_wrt_cb2,<NEAR>
cBegin
        lea     bx,[di].bd_cbLogical    ; reads a word having size of
        mov     cx,02                   ; bd structure into bd_cbLogical
        push    ax                      ; save address read/write-fileabc
        call    ax                      ; call read/write-fileabc
        pop     ax                      ; restore address read/write-fileabc
        mov     bx,[di].bd_pb           ; reads the bd structure from
        mov     cx,[di].bd_cbLogical    ; file.
        push    ax                      ; save address read/write-fileabc
        call    ax                      ; Call read/write-fileabc
        pop     ax                      ; restore address read/write-fileabc
        add     di,SIZE bd              ; Updates DI to point to next bd.
cEnd

;***
; readfileabc() - makes the call to read file.
;
; Purpose:
;       Written to save code by pushing 3 parms, and calling ReadFile.
;
; Entry:
;       fh has the file handle to read from.
;       cx has the number of bytes to read
;       bx has the address of buffer to read into.
;
; Exit:
;       None.
;
; Uses:
;       Per Convention
;
;**************************************************************************

cProc   readfileabc,<NEAR>
cBegin
        cCall   ReadFile,<fh,bx,cx>
cEnd

;***
; writefileabc() - Makes the WriteFile call.
;
; Purpose:
;       Written to save code by pushing 3 params, and calling WriteFile
;
; Entry:
;       fh has the file handle.
;       bx has the address of buffer
;       cx has the count of bytes to be written into file.
;
; Exit:
;       None.
;
; Uses:
;       Per Convention
;
;**************************************************************************

cProc   writefileabc,<NEAR>
cBegin
        cCall   WriteFile,<fh,bx,cx>
cEnd



;***
; FourTimes() - Makes call to the given procedure four times.
;
; Purpose:
;       Read and Write QBINI procedures make all file operations
;       for four paths Exe, Lib, Help and Inc.
;
; Entry:
;       SI has the OFFSET of procedure to be called four times.
;
; Exit:
;       None.
;
; Uses:
;       Per Convention
;
;*********************************************************************

cProc   FourTimes,<NEAR>
cBegin
        mov     cx,4            ; Sets up a count of 4
FT_next:
        push    cx              ; loop until zero to make four call on given
        call    si              ; procedure. Since the given procedure could
        pop     cx              ; destroy count (CX) save it.
        loop    FT_next
cEnd



;***
; DoAllocs - allocates runtime heap entry
;
; Purpose:
;       Allocate an interpreter specific heap entry from runtime
;       and set respective flags. If Out_of_Memory then SetUiErrOm.
;
;       DoAllocs works in conjunction with Fourtimes. It is done to
;       save on code for param initialization and passing. It assumes
;       ORDER of bdLibPath,bdExePath,bdInclPath,bdHelpPath and adds
;       size of Bd structure to get to next. Saves code!
;
; Entry:
;       DI has address of a bd structure of a env path
;
; Exit:
;       bd_pb of bd structure points to heap entry.
;       bd_cbPhysical of bd structure is set to cbSize.
;       DI is incremented to next bd structure.
;       AX is set TRUE is heap entry was allocated else FALSE.
;
;****************************************************************

cProc  DoAllocs,<NEAR>
cBegin
        mov     ax,MAX_SEARCH_PATH      ; Number of bytes wanted on heap
        mov     bx,IT_NO_OWNERS         ; Type of interp table
        cCall   BdAlloc,<di,ax,bx>      ; Allocate the heap entry
        or      ax,ax                   ; NZ if allocation successful
        jnz     DoAllocsOK              ; if heap alloc failed
        cCall   SetUiErrOm              ; out of memory error. (sets uierr)
                                        ; OK to fall into DoTrims, since it
                                        ; will be done anyway later.

labelNP <DoTrims>                       ; ROUTINE to trim size of BD's
        mov     [di].bd_cbLogical,1     ; set initial size = 1 so we have
                                        ; a null path string.

DoAllocsOK:
        add     di,SIZE bd              ; increment DI to point to next
                                        ; bd structur i.e. next path.
cEnd



;***
; OpenQBIni() - Opens the QB.INI file
;
; Purpose:
;       Opens the QB.INI file for reading/writing the system
;       default parameters.
; Entry:
;       BX = TRUE for WriteOnly mode
;            FALSE for ReadOnly mode
; Exit:
;       fh has the file handle
;       NZ  if open successful
;       ZF  if open unsuccessful
; Uses:
;       Per Convention
;
;*********************************************************************

cProc   OpenQBIni,<NEAR>,<DI,SI>
cBegin
        push    bx                      ; save file open mode
        mov     ah,30h                  ; get version number
        int     21h                     ; AX = dos version number
        pop     bx                      ; restore file open mode
        cmp     al,3                    ; are we DOS 3.x or above?
        jb      UsePATH                 ; brif not, no path present

        mov     es,__aenvseg            ; ES:0 is location of env.
        xor     di,di                   ; ES:DI is location of env
        mov     cx,8000h                ; scan to end of env table
        xor     ax,ax                   ; for a 0
LocateFname:
        repne   scasb                   ;
        scasb                           ; skip null, see if double 0
        jne     LocateFname             ; brif not double 0, keep looking
        scasw                           ; skip following 1

ASSUMES DS,NOTHING
        mov     si, di                  ; ES:SI = ptr to QBASIC path & name
        mov     di, DATAOFFSET b$buf1   ; DS:DI = ptr to INI path & name
        push    es                      ;
        pop     ds                      ; DS:SI = ptr to QBASIC path & name
        push    ss                      ;
        pop     es                      ; ES:DI = ptr to INI path & name
        mov     cx,di                   ; DS:CX = ptr to last seen path char
                                        ; in name as it is copied over

CopyName:
        lodsb                           ; grab a byte
        stosb                           ; and store it
        cmp     al,'\'                  ; is it a slash
        je      PathChar                ;  go remember it
        cmp     al,'/'                  ; or this slash
        jne     TestTerminator          ;  go remember it
PathChar:
        mov     cx,di                   ; set last path character found
TestTerminator:
        or      al,al                   ; 0 terminator?
        jnz     CopyName                ; brif not, more characters to do

HavePath:
        push    ss                      ;
        pop     ds                      ; restore DS = DGROUP = ES

ASSUMES DS,DGROUP

        cmp     cx, DATAOFFSET b$buf1   ; did we have any path?
        je      UsePATH                 ; brif not, use $PATH:

        mov     di, cx                  ; ES:DI = ptr to end of INI path
        mov     si, DATAOFFSET qbIniFName; DS:SI = ptr to new file name
        mov     cx, cbqbIniFName        ; CX = # characters
        rep     movsb                   ; and copy it over

        ; all set up, lets go open the INI file

        mov     ax,3d00h                ; Open existing file, read only
        or      bx,bx                   ; BX = 0 (FALSE = Read Only)
        jz      ReadOnly                ; brif assumption true
        mov     ah,3ch                  ; Create file, write access
ReadOnly:
        push    bx                      ; save open flag (open could fail)
        PUSHI   cx,<DATAOFFSET b$buf1>  ;
        call    OpenCreateFile          ; open file for mode AX
        pop     bx                      ; restore open flag
        mov     cl,1                    ;
        inc     cl                      ; Clear ZF, don't touch Carry
        jnc     FileOpened              ; brif success

UsePATH:
        mov     ax,DATAOFFSET qbIniFName ; AX = "QB.INI"
        mov     cx,EXEFILE              ; return value for success/failure
        cCall   FindAndOpenFile,<ax,bx,cx>
        or      ax,ax                   ; NZ ==> success

FileOpened:
        mov     fh,ax                   ; save the file handle value.

cEnd

;***
;Chk3Windows() - It makes GetSColor/SetSColor to 3 Isa's.
;
;Purpose:
;       To set up / save color defaults for various things on QB
;       Get / Set is performed during write/read. This helps save
;       code by setting up parameter and calling Get/Set as set
;       in DI.
;Entry:
;       SI points to the OPTIONS frame on stack
;       DI points to procedure for GetSColor/SetSColor
;Exit:
;       SI points to ATTRDATA of BreakPoint.
;Uses:
;       Per Convention
;
;*********************************************************************

cProc   Chk3Windows,<NEAR>          ; Added with revision
cBegin
        lea     si,[si].normT       ; SI to point to ATTRDATA for Normal Text
        mov     ax,isaEditWindow    ; Isa - Edit Window
        call    di                  ; Call GetSColor/SetSColor
        lea     si,[si].(curLn-normT); SI to point to ATTRDATA for Cur Stmt
        mov     ax,isaCurStmt       ; Isa - Cur Stmt
        call    di                  ; Call GetSColor/SetSColor
        lea     si,[si].(bpLn-curLn); SI to point to ATTRDATA for Brk Point
        mov     ax,isaBreakpoint    ; Isa - Break Point
        jmp     di                  ; Call GetSColor/SetSColor and return
cEnd    <nogen>

;***
; SetSColor() - Set System Color Defaults
;
; Purpose:
;       Default colors for Hight Light, Back Ground, Fore Ground etc
;       set for Edit Window, Break Point etc.
;
;       Based on SetSysColor Macro
;
; Entry:
;       ax has the Isa identifier like Edit Window, etc.
;       SI points to ATTRDATA of window in Options Frame on stack.
; Exit:
;       None.
; Uses:
;       Per Convention
;
;************************************************************************

cProc   SetSColor,<NEAR>
cBegin
        push    ax              ; SetIsaColor Parm #1

        mov     ax,[si].fHlgt   ; Set up the High Light + Foreground
        or      ax,ax           ; Parameter
        jz      NoBrForeground
        mov     ax,8
NoBrForeground:
        add     ax,[si].fgClr
        push    ax              ; SetIsaColor Parm #2

        mov     ax,[si].fBlnk   ; Set up the Blink + Background parameter
        or      ax,ax
        jz      NoBrBackground
        mov     ax,8
NoBrBackground:
        add     ax,[si].bkClr
        push    ax              ; SetIsaColor Parm #3

        cCall   SetIsaColor     ; Set up the colors.
cEnd

;***
; GetSColor() - Gets current system colors
; Purpose:
;       Current colors for EditWindow, BreakPoint, Current Statement
;       etc are obtained and later written into QB.INI file. This
;       ensures that next time the user would get same set up as at
;       the end of last session with QB.
;       Based on GETSYSCOLOR in file "uioptns.c".
; Entry:
;       ax has the Isa identifier like Edit Window, Break Point.
;       SI points to ATTRDATA structure correspoinding Isa in Options
;       frame on stack.
; Exit:
;       None.
; Uses:
;       Per Convention
;
;**********************************************************************

cProc   GetSColor,<NEAR>
cBegin
        push    ax              ; GetIsaColor parm #1

        lea     ax,[si].fgClr   ; Set up the address of Foreground Color
        push    ax              ; GetIsaColor parm #2

        lea     ax,[si].bkClr   ; Set up the address of Background Color
        push    ax              ; GetIsaColor parm #3

        cCall   GetIsaColor     ; Read the current colors into frame.

        xor     ax,ax           ; Decode Background and Blink based on
        test    [si].bkClr,8    ; formula in SetSColor and setup.
        jz      dontsetbit
        inc     ax
dontsetbit:
        mov     [si].fBlnk,ax   ; store blink bit (0, 1)

        xor     ax,ax
        test    [si].fgClr,8    ; Decode Foreground and High Light based
        jz      donotsetbit     ; on formula in SetSColor and setup.
        inc     ax
donotsetbit:
        mov     [si].fHlgt,ax   ; store highlight bit (0, 1)

        and     [si].bkClr,0fff7h   ; Strip off Blink bit
        and     [si].fgClr,0fff7h   ; Strip off Hightlight bit
cEnd


;***
; WriteQbIni() - Writes QB.INI File.
;
; Purpose:
;       Called at exit to write the qb.ini file if current default
;       options of QB are changed.
;
; Entry:
;       Uses a lot of system's common status variables.
;
; Exit:
;       None.
;
; Uses:
;       Per Convention (After explicitly saving SI,DI)
;
;**********************************************************************

cProc   WriteQBIni,<PUBLIC,NEAR>,<SI,DI>
cBegin

        cCall   HookInt24               ; ignore int 24 errors for the
                                        ; duration of this routine

        cmp     fOptionsChanged,FALSE   ; were options changed?
        je      OptNotChanged           ; brif not -- just exit

        mov     bx,TRUE                 ; Open QB.INI file for write only mode
        call    OpenQBIni
        jnz     FileFound               ; brif file found -- don't create one.


        mov     ax,DATAOFFSET qbIniFName; AX = "QB.INI"
        cCall   CreateFile,<AX>         ; create file, AX = file handle
        mov     fh,ax                   ; fh = file handle
FileFound:
        cmp     ax,UNDEFINED            ; If file creation successful proceed
        jz      NoHandle                ; else set fOptionsChanged to FALSE
                                        ;   and exit gracefully.

        mov     ax,SIZE OPTIONS
        sub     sp,ax                   ;Set up frame for OPTION structure
        mov     di,sp                   ; DI points to OPTIONS frame.
        push    ax                      ;save SIZE OPTIONS

        mov     [di].signature,QBSIGNATURE  ; Set up QBSIGNATURE and
                                            ; VERSION on frame.

        mov     [di].version, QHELP11VERSION                    ; [QH1]

        push    ds  ; Set ES = DS for following STOS instructions.
        pop     es

        push    di                      ; save *options
        lea     di,[di.tabStopsOpt]
        cCall   GetTabs                 ; AX = current tab setting
        stosw                           ; and set in Option Frame
        mov     ax,fScrollBars          ; AX = ScrollBars
        stosw                           ; and set in Option Frame
        mov     al,fSyntaxCheck         ; AX = SyntaxCheck
        cbw                             ; convert to word
        stosw                           ; and set in Option Frame

        mov     al,1                    ; store TRUE
        stosb
        mov     al,fRightMouseHelp      ; store RightMouseHelp
        stosb
        pop     si                      ; si = *options

        mov     di,UIOFFSET GetSColor   ; Get color settings.
        push    si
        call    Chk3Windows             ; for each isa, perform GetSColor
        pop     si

        call    SavePrintInfo                           ; [QH1]

        pop     ax      ;AX = SIZE OPTIONS
        push    ax      ;FH = File Handle
                                        ; Write OPTION structure with current
        cCall   WriteFile,<fh,si,ax>    ; settings into QB.INI file.


        mov     ax,UIOFFSET writefileabc ; for each bd, call writefileabc
        call    rd_wrt_path


        cCall   CloseFileNear,<fh>      ; Close the file.
        pop     ax                      ; AX = SIZE OPTIONS
        add     sp,ax                   ; Release frame from stack.

NoHandle:
        mov     fOptionsChanged,FALSE   ; Now current settings conform to
                                        ; the ones in QB.INI
OptNotChanged:

        cCall   UnHookInt24             ; have runtime handle int 24 errors

cEnd


;;
;; [QH1] Start
;;
;; Save print-dest info
;;      SI points to beginning of Options
;;
SavePrintInfo:
        cld
        mov     ax, iPrintPort          ; Save printer port
        mov     [si].iPrint, ax

        mov     ax, fPrintToFile        ; Save PrinterOrFile flag
        mov     [si].fFile, ax

        mov     cx, MAX_PATH            ; Save print-filename, if any
        lea     di, [si].szPrint
        mov     ax, ds
        mov     es, ax
        push    si
        lea     si, szPrintDest
        rep     movsb
        pop     si

        ret
;;
;; [QH1] End
;;


sEnd    UI
        end




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uimain.asm ===
TITLE	uimain.asm - BASIC's top level interface to user interface.
;***
;uimain.asm
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	Main user interface, and support routines.
;
;
;*******************************************************************************

	include	version.inc

	UIMAIN_ASM = ON

	;Next, include COW's interface headers
	include cw/version.inc
	include cw/windows.inc
	include cw/edityp.inc

	;Next, include QBI's headers
	includeOnce	architec
	includeOnce	context
	includeOnce	executor
	includeOnce	heap
	includeOnce	parser
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	txtmgr
	includeOnce	ui
	includeOnce	uiint
	includeOnce	uimenu	

assumes	ds,DATA
assumes	ss,DATA
assumes	es,NOTHING

	; external procedures used by uictl	
						
	externFP EnableMenuItem 		
	externFP CheckMenuItem			
	externNP fCanContUI			
	externNP GetEditLine			
	externFP SetBlinkBit
IFNDEF ROMBASIC
        externFP FCheckTandy1000
ENDIF

	;Runtime supplied functions used by this module:
	
	EXTRN	B$UnhookKbd:FAR
	EXTRN	B$hookKbd:FAR


sBegin	DATA

	externW fIsProgram 		
	externB fPasteOK		
	externB fSyntaxCheck		
	externW cWatch			
	externB fInsertMode		;EditMgr insert state.

	EXTRN	b$fCompErr:word	;non-zero if error was in compiled code
	EXTRN	fRefreshWatch:byte	;non-zero if WATCH window needs to
					; be refreshed

	externW	szDialogTitle		; * current dialog box title, or
					; 0 if no title.
;fUiActive is TRUE when user-interface keyboard and mouse interrupt
;handlers are active.
PUBLIC  fUiActive
fUiActive	dw	0
fUIInit 	db	0		; non-zero if UI Initialized.

;When we can CONTinue, and we execute a direct mode stmt that causes a ret
; adr to the direct mode buffer to be pushed on the stack (call/gosub/func),
; and then enter direct mode to save the otx of the called routine, we save the
; old grs.otxCont in otxContProg, so that after the direct mode call finishes,
; we can still CONTinue the stopped program.
;This variable gets set to UNDEFINED if we do any EDITs (because otxContProg
; isn't updated as pcode is moved by the text mgr and static-scanner).
;It is also set to UNDEFINED if we execute another direct mode stmt
; while there is a return address to the direct mode buffer on the stack,
; because we choose not to remember an arbitrary number of these, and
; it would be difficult for the user to keep track of them anyway.
;TxtDirect guarentees that if user enters a direct mode statement
; while there is a return address to the direct-mode-buffer on the
; stack (FG_RetDir), that CantCont will occur.
;
otxContProg	DW UNDEFINED

cGrab	db	0		;number of active callers of UiGrabSpace
sEnd	DATA

sBegin	UI
assumes cs,UI


;**************************************************************************
; UiInit
; Purpose:
;	In QB, the RUNTIME gets control first (since in stand-alone EXEs
;	there is no user-interface).  This is called after the runtime
;	has initialized.  It initializes the user interface.
; Entry:
;	cmdSwitches has flags set to indicate command-line switch settings
; Exit:
;	the file QB.INI is read
;	If command line didn't contain /RUN <filename>, the debug screen
;	   is shown.
;	AX nonzero if Out of Memory
;	
;**************************************************************************
cProc	UiInit,<PUBLIC,FAR>
cBegin
; Set colors at beginning so first screen writes are the same color.
	call	ReadQbIni
	call	B$UnhookKbd
IFNDEF ROMBASIC
        call    FCheckTandy1000         ;check for/install TANDY 1000 KBD
ENDIF
	call	CwInit
	call	B$HookKbd
	test	[cmdSwitches],CMD_SW_RUN ;/RUN filename given on command line?
	jnz	NoDebugScr		;  brif so, no debug screen
	call	EnsShowDebugScr
NoDebugScr:
	call	GrabSpace		;make sure we can successfully
	or	ax,ax			;  GrabSpace (ax = 0 if failed)
	not	ax			;0 -> -1 if failed, preserves flags
	jz	UiInitExit		;brif failure, exit with ax<>0
	call	ReleaseSpace		;release what we grabbed
	xor	ax,ax			;exit with ax = 0 for success
UiInitExit:				
	inc	fUIInit 		;indicate UiInit complete
cEnd

;**************************************************************************
; UiTerm
; Purpose:
;    Called just before we are about to leave the QB for good.
;    Calls COW and KKIF to tell it to terminate.
;
;    Also called before a SHELL is performed.  The runtime calls
;    this routine prior to SHELL, or at termination.  After a SHELL,
;    The runtime calls UiReInit so COW can re-initialize.
; Entry:
; Exit:
;	
;**************************************************************************
cProc	UiTerm,<PUBLIC,FAR>
cBegin
	cmp	fUIInit,0	; were we ever initialized?
	jz	UTExit		; brif not, exit now

	cCall	WriteQbIni	; write the qb.ini file
	cCall	CwTerm		
	mov	al, 1			
	cCall	SetBlinkBit,<ax>
UTExit:
cEnd

;**************************************************************************
; UiReInit
; Purpose:
;	In QB, the RUNTIME needs to reinitialize the user interface
;	at certain points (primarily after SHELL).  This entry point
;	allows the user interface to reestablish any state (such as
;	hooking interrupts) that is necessary.
; Entry:
;	none.
; Exit:
;	none.
;	
;**************************************************************************
cProc	UiReInit,<PUBLIC,FAR>
cBegin
cEnd

;**************************************************************************
; UiPause
; Purpose:
;    Added with [24].
;    Called before a SHELL is performed.  The runtime calls
;    this routine prior to SHELL, or at termination.  After a SHELL,
;    The runtime calls UiReInit so COW can re-initialize.
; Entry:
; Exit:
;	
;**************************************************************************
cProc	UiPause,<PUBLIC,FAR>
cBegin
cEnd

;**************************************************************************
; UserInterface()
; Purpose:
;  UserInterface() is the primary interface the user-interface
;  provides to the rest of BASIC.
;  It is called by the beginning-of-statement/line
;  executor when it sees bosMask & BOS_DEBUG non-zero,
;  by opEot and opStEnd (end-of-program), opBreakPoint, and opStStop.
;
;  For example, if tracing was active for the program:
;    CLS : PRINT
;    STOP
;  UserInterface would be invoked between the opcodes seperated by '^':
;    opBol ^ opStCls opBos ^ opBreakPoint ^ opStPrint opBol ^ opStStop ^ opEot ^
;
; Entry:
;  grs.oRsCur, otxCur identify the next statement to be executed.
;  If grs.otxCur == UNDEFINED, it means we've just executed an ExEot,
;     and thus cannot continue.  Otherwise, it points just beyond the
;     ExBos opcode which caused UserInterface to be called.
;  If the parser's input buffer (ps.bdpSrc) contains any text, that
;     text is executed as if the user entered it as a direct mode stmt.
;     This allows executors like RUN <filename> to load the file, then
;     re-invoke UserInterface after stuffing the command "RUN" in the
;     parser's input buffer.  This allows there to be only 1 control path
;     to scan all loaded text tables.
;
;  The actions performed by UserInterface() are determined by which
;  bits are set in debugFlags as follows:
;
;  DEBUG_EXEC_CMD - set by some executor like RUN <file>/CHAIN <file>,
;     which has loaded pcode, and now wants the pcode to be scanned
;     and a direct mode statement executed (like RUN or CONT).  The
;     executor for the direct mode stmt has been loaded into grs.bdlDirect.
;
;  DEBUG_ERROR - set when a runtime error occurs and
;     is not trapped.  The runtime error code restores SI to
;     the beginning of statement, sets this flag, then re-
;     executes the statement, which invokes the debugger.
;     The error code is passed in the same static variable
;     examined by the ERR intrinsic function.  Causes
;     DebugError() to be invoked.
;
;  DEBUG_STOP - set when a STOP statement is executed,
;     when Ctrl-BREAK is pressed and not trapped, or
;     when a breakpoint is executed.
;     Causes DebugStop() to be invoked.
;
;  DEBUG_WATCHPOINT - set when a Stop-Watch-Expression evaluates to TRUE
;     Causes DebugStop() to be invoked.
;
;  DEBUG_END - set by the executors for opEot and
;     opStEnd to indicate end-of-program.  Causes DebugEnd()
;     to be invoked.
;
;  DEBUG_TRACE - set while tracing statement execution
;     either because of TRON, single-step, or procedure-
;     step.  Causes DebugTrace() to be invoked.
;
;  DEBUG_WATCH - set when any Watch Expressions are
;     active in the program.  Causes DebugWatch() to be invoked.
;
;  DEBUG_CANT_CONT - Causes UserInterface() to set grs.otxCONT to
;     UNDEFINED the next time it is called.
;     This is used by executors, which cannot call CantCont
;     because UserInterface sets grs.otxCONT every time
;     we enter UserInterface, thus undoing their change.
;     Since it sets otxCONT rather than calling CantCont(),
;     stack tracing and variable printing are still possible
;     from direct mode, just not continuing.
;
; Exit:
;	grs.fDirect, grs.oRsCur, grs.otxCur indicate where pcode
;	   execution is to commence
;
;**************************************************************************
cProc	UserInterface,<PUBLIC,FAR>
cBegin
	DbAssertRelB [cGrab],e,0,UI,<UserInterface: cGrab non-zero>
	test	[debugFlags],DEBUG_WATCH
	je	NoWatch			;brif no WATCH expressions visible
	call	DebugWatch		;get next watch expression, or
					; normal program pcode
	jne	J1_TestRestore		;brif the next pcode to be executed
					; is WATCH pcode, DebugWatch has
					; set grs up so it's ready to go
	cmp	[fDebugScr],FALSE
	jne	NoWatch			;brif debug screen is visible
					; need to print values in watch window
	test	[debugFlags],NOT DEBUG_WATCH
	jne	NoWatch			;brif WATCH isn't only thing to do
					;speeds up WATCHPOINTs significantly
J1_TestRestore:
	jmp	SHORT TestRestore
	;If we didn't care about Watch functions that write to the screen
	; we could branch to ExecStmt and be faster, but since most watchpoints
	; are handled by the executor calling DebugWatch directly, the only
	; watch points we are slowing down are when the debug screen is active.

NoWatch:
	cmp	[grs.GRS_fDirect],FALSE
	je	NotInDirect		;brif not executing direct mode stmts

	;Following test prevents tracing statements in direct mode.
	test	[debugFlags],NOT (DEBUG_TRACE OR DEBUG_WATCH)
	je	GotNextStmt		;brif nothing other than TRACE/WATCH

	;We've returned to direct mode, potentially after having debugged
	;a GOSUB/SUB/FUNCTION/DEF FN.  If we don't set otxCur to
	;otxContProg, we'd show the RETURN or END DEF/SUB/FUNCTION
	;stmt as the next stmt to be executed, instead of the statement
	;that was active before the direct mode statement executed.
	
	mov	ax,[otxContProg]
	mov	[grs.GRS_otxCur],ax	;will be stored in grs.otxCONT

NotInDirect:
	;we were not executing in direct mode, setup for CONT executor.
	;If grs.otxCur == UNDEFINED (as set by opEot), we cannot continue
	
	cmp	[debugFlags],0
	je	GotNextStmt		;brif nothing to do.  This is true
					;for the 1st non-direct-mode-buffer
					;pcode we execute.  Once we branch
					;out of the direct mode buffer,
					;there's no need to call UserInterface
					;between statements.
	mov	ax,[grs.GRS_oRsCur]
	mov	[grs.GRS_oRsCONT],ax
	test	[txdCur.TXD_flags],FTX_mrs
	je	NotInDefFn		;brif definately not within a DEF FN
	mov	ax,[grs.GRS_oMrsCur]
NotInDefFn:
	mov	[grs.GRS_oRsContTxtTbl],ax

	mov	ax,[grs.GRS_otxCur]
	mov	[grs.GRS_otxCONT],ax
GetNextStmt:
	;Call NextStmt() to determine what stmt should be executed next.
	;NextStmt() may interact with user, letting user edit program etc.
	
	call	NextStmt

	;If user added or removed a WATCH expression, we need to refresh
	;the values in the Watch window.
	
	cmp	[fRefreshWatch],FALSE
	je	GotNextStmt
	mov	[fRefreshWatch],FALSE
	call	DebugWatch
	je	GetNextStmt		;brif can't execute WATCH pcode
					; for any reason
GotNextStmt:
	cmp	[cWatch],0
	je	TestRestore		;brif no WATCH expressions are active
	or	[debugFlags],DEBUG_WATCH; tell Executor to call UserInterface
					; after executing next statement

;The reason we enter direct mode for each statement, regardless of
;the state of debugFlags, is so we can toggle to the output screen
;for direct mode lines like:
;    FOR I=1 TO 10: PRINT A(I): NEXT I
;but leave the debug screen active for direct mode lines like:
;    FOR I=1 TO 10: A(I) = 1: NEXT I
;
;Make the output screen visible IF:
; we're tracing or watching variables AND next stmt does screen I/O OR
; we're NOT tracing or watching variables AND next stmt is in program
;   (as opposed to direct mode statement buffer)
;
TestRestore:
	cmp	[fDebugScr],FALSE
	je	ExecStmt		;brif output screen already visible
					;If this test is removed, callers
					;who set DebugFlags.DEBUG_EXEC_CMD
					;need to put an ExEot in bdlDirect
					;for FNextStmtDoesIO
	test	[debugFlags],DEBUG_WATCH OR DEBUG_TRACE
	jne	TestForIO		;brif we're watching or tracing
	cmp	[grs.GRS_fDirect],FALSE
	je	ShowUserScr		;brif not executing direct mode stmts
TestForIO:
	call	FNextStmtDoesIO
	or	ax,ax
	je	ExecStmt		;brif next stmt causes no screen I/O
ShowUserScr:
	call	EnsShowOutSaveRs	;show output screen, don't alter
					; grs.oRsCur

ExecStmt:


;***** Begin revision [17]
	
	;Clear FBOSSTOP in bosFlags now, because we have just had the
	;chance to responde to it so if it is still set it is because
	;we stopped for some other reason.  There for, the FBOSSTOP
	;has already been serviced.
	
	and	[bosFlags], NOT FBOSSTOP
;***** End revision [17]

	;If we are debugging or we are executing a direct mode statement,
	;make sure we re-enter user interface for each opBos.
	
	mov	al,[debugFlags]
	or	al,[grs.GRS_fDirect]
	je	DontReEnter
	or	[bosFlags],FBOSDEBUG	;tell executor to call UserInterface
					; at the next beginning of stmt
DontReEnter:
	;ContReinitStat needs to be called every time we exit the
	;user interface if any editing/loading took place.  It ensures
	;there is no unused space within BDs and no free space between
	;near-heap entries.  If there was any, a string allocation could fail
	;even though there is free space, because arrays of string descriptors
	;can only be moved at statement level, because the runtime
	;could have several pointers to them, i.e. x$=a$(1)+a$(2)
	
	call	ContReinitStat

;Return to the executor to execute pcode indicated by:
;grs.fDirect, grs.oRs, grs.otx.
;If the Quit menu item is selected, or the SYSTEM command is entered
;UserInterface returns to let the executor execute ExStSystem.
;Returning from this function causes the pcode-executor to begin.
;

cEnd	;UserInterface

;**************************************************************************
; EnterUserInterface()
; Purpose:
;  Enable all user interface interrupt handlers.
;
;**************************************************************************
cProc	EnterUserInterface,<PUBLIC,NEAR>
cBegin
	cmp	[fUiActive],0
	jne	EntDmExit		;brif already in user interface
	mov	[fUiActive],sp
KbLoadOk:
	cCall	DrawDebugScr		
	cCall	B$UnhookKbd		;tell runtime to disable its handler
	cCall	HookInt24		;enable interrupt-24 interrupt handler
	cCall	CwHook
	call	FlushMsgs		;flush any type-ahead keystrokes or
					; mouse clicks
EntDmExit:
	;Set the BIOS INSERT flag to match what we will be using in
	;this invocation of the UI.  This will keep us in ssync with
	;what speach software thinks our insert state is.

	xor	bx, bx
	mov	es, bx
	cli				; don't allow interrupts (might
					; change BIOS flags on us)
	mov	al, es:[417h]		; get BIOS shift state flags
	and	al, 7fh			; assume insert mode off
	cmp	fInsertMode, bl 	; is CW in an insert mode
        je      @F                      ; brif not, assumption good
	or	al, 80h			; set BIOS insert mode on
@@:
	mov	es:[417h], al		; update BIOS flags
	sti				; reenable interrupts

cEnd	;EnterUserInterface

;**************************************************************************
; ExitUserInterface()
; Purpose:
;  Unhooks all user interface interrupt handlers.
;
;**************************************************************************
cProc	ExitUserInterface,<PUBLIC,NEAR>
cBegin
	call	FlushMsgs		;flush any type-ahead keystrokes or
					; mouse clicks
DbAssertRel [fUiActive],ne,0,UI,<ExitUserInterface: not in user interface>
	mov	[fUiActive],0
	cCall	CwUnHook
	cCall	UnHookInt24
	cCall	B$hookKbd		;tell runtime to enable its handler
cEnd	;ExitUserInterface

;**************************************************************************
; DebugExecCmd
; Purpose:
;	Invoked when we enter NextStmt with DEBUG_EXEC_CMD bit set in
;	debugFlags
; Exit:
;	Returns actionFlag bit which will cause the work to get done.
;
;**************************************************************************
DebugExecCmd PROC NEAR
	mov	[grs.GRS_otxCONT],UNDEFINED
					;RUN <filename> needs otxCont UNDEFINED
					; so scanner can grow variable tables.
	mov	al,FDM_ExecCmd
	ret
DebugExecCmd ENDP

;**************************************************************************
; NextStmt
; Purpose:
;  Called by UserInterface() to determine the next opcode to be executed
;  It is only called when UserInterface has something significant to do.
;
; Entry:
;  same as for UserInterface()
;	
;**************************************************************************
.errnz	DEBUG_ERROR	- 01h
.errnz	DEBUG_EXEC_CMD	- 02h
.errnz	DEBUG_STOP	- 04h
.errnz	DEBUG_END	- 08h
.errnz	DEBUG_WATCHPOINT - 10h
.errnz	DEBUG_TRACE	- 20h
DebugDispTbl LABEL WORD
	DW	UIOFFSET DebugError
	DW	UIOFFSET DebugExecCmd
	DW	UIOFFSET DebugStop
	DW	UIOFFSET DebugEnd
	DW	UIOFFSET DebugStop
	DW	UIOFFSET DebugTrace
DebugDispTblEnd LABEL WORD

DbPub	NextStmt
cProc	NextStmt,<NEAR>
	localB	actionFlags
	localB	debugFlagsTmp
cBegin
	DbAssertRelB [cGrab],e,0,UI,<NextStmt: cGrab non-zero>
	;remember if the debug screen was visible when we entered NextStmt()
	mov	al,[debugFlags]
	mov	[debugFlagsTmp],al
	test	al,DEBUG_ERROR
	jne	GotRtErr

	;Set b$fCompErr 0 so any errors generated from within the user
	; interface don't look like they were generated in QuickLibrary.
	
	mov	[b$fCompErr],0
GotRtErr:

	;reset any variables that assume we're in same context we were
	;in last time they were set.
	
	call	UiFlushCache
	sub	ax,ax
	mov	[actionFlags],al
	mov	[debugFlags],al
	mov	[fDoCmd],ax

;  Dispatch to function based on debugFlagsTmp.  Function
;  returns ushort mask with 0 or more of FDM_xxx bits set
;  indicating what action is to be performed.
;  Function also sets various bits in debugFlagsTmp to cause
;  UserInterface to be entered after the next statement is executed.
;
;  NOTE: The order these flags are tested is IMPORTANT
;
	mov	al,[debugFlagsTmp]
	and	al,DEBUG_EXEC_CMD+DEBUG_ERROR+DEBUG_STOP+DEBUG_END+DEBUG_WATCHPOINT+DEBUG_TRACE
	je	DispRet			;brif nothing interesting
	mov	bx,UIOFFSET DebugDispTbl-2
DispLoop:
	inc	bx			;advance to next exception handler
	inc	bx
DbAssertRel bx,b,<UIOFFSET DebugDispTblEnd>,UI,<uimain.asm: Bad debugFlags>
	shr	al,1
	jnc	DispLoop
	call	cs:[bx]			;dispatch to routine based on debugFlags
					;al = bit mask of actions to carry out
DispRet:
 	mov	[actionFlags],al
 	test	al,FDM_ShowStmt
	je	TestGetCmd		;brif cursor not to be positioned
	call	EnsShowDebugScr		;make debug screen visible
	call	DoDrawDebugScr		;actually draw debug screen, can't
					; wait for next call in GetCmd() in the
					; case where user just executed a TRON
					; stmt, we don't call GetCmd at all
	call	ContContext		;activate "program counter's" context
	je	TestGetCmd		;brif can't continue & no main program

	;otx may point to beginning of next statement, get it back to current
	;map UNDEFINED,0,1,2,3,... to 0,0,0,1,2,3,...
	
	mov	ax,[grs.GRS_otxCONT]
	inc	ax			;test for UNDEFINED
	je	DoShowStmt		;if can't CONT, cur stmt is 0 of main
	dec	ax			;restore ax = otxCONT
	je	DoShowStmt		;map 0 to 0
	dec	ax			;map 1,2,... to 0,1,...
DoShowStmt:
	push	[grs.GRS_oRsCur]
	push	ax			;pass otxCur
	PUSHI	ax,UNDEFINED		;determine column from otx
	call	ShowStmt

TestGetCmd:
	;See if executor told user interface to not allow continuing.
	;This is done when it wants to show where execution stopped
	;(i.e. for error reporting) so it leaves grs.otxCur not UNDEFINED
	;on entry to UserInterface.  It is important that we not call CantCont
	;before calling ShowStmt, or else ShowStmt has nothing to show.
	
	test	[debugFlagsTmp],DEBUG_CANT_CONT
	je	CantContNotSet
	call	CantCont
	mov	[actionFlags],FDM_GetCmd
CantContNotSet:
	test	[actionFlags],FDM_GetCmd
	je	TestDoCmd

;Init debug screen if necessary, make it visible.  This is necessary
;because DEBUG_END causes FDM_GetCmd to be set, but not FDM_ShowStmt.
;Continue calling GetCmd() until we get a command which we can execute
;without errors.  GetCmd() interacts with user until user enters a
;direct-mode command (which may take the form of a menu selection, or
;accelerator key like SingleStep).
;This can cause context switches to different module and
;procedure text tables.  It also invokes the text
;manager (which invokes the parser) to alter program text.
;
GetCmdLoop:
	;Turn off CMD_SW_RUN switch in case user specified /RUN <filename>
	;in qb command line, and then got a runtime error.  This will
	;cause the SYSTEM statement to return to user interface rather than
	;terminating qb.
	
	and	[cmdSwitches],NOT CMD_SW_RUN

	call	EnsShowDebugScr
	call	EnterUserInterface	;enable userInterface interrupt handlers
	mov	[otxContProg],UNDEFINED	;since this call to GetCmd can cause
					; editing, and otxContProg isn't updated
					; for pcode movement, we can't depend
					; on it after this call.
	call	GetCmd
	call	WatchInfoUI		;update cWatch if necessary
WatchWnOk:
	call	ExitUserInterface	;restore runtime's interrupt handlers

;Make sure TxtDirect and SystemScan are unable to tie up so much
;variable table space that we are unable to execute very simple
;direct mode statements.  This block of memory will be freed
;by UiReleaseSpace below.  Be very careful when changing control
;flow below this point that all UiGrabSpace calls are balanced by
;UiReleaseSpace calls.
TestDoCmd:
	call	UiGrabSpace		; UiGrabSpace can take a lot of time...
					; slows down tracing, and WATCH (when
					; debug screen is visible)
	cmp	[fDoCmd],0		; fDoCmd can only be set as a result
					;  of calling GetCmd().  It is not
					;  set as a if user wants to TRACE
	je	NoDirect		; brif all scanned and ready to execute
					;  (speed optimization for WATCH/TRACE)
	mov	[fDoCmd],0
	call	ContContext		;activate "program counter's" context
					; for TxtDirect
	call	TxtDirect		;Now parse & scan direct mode statement
	mov	ax,[grs.GRS_otxCONT]
	mov	[otxContProg],ax
	jmp	SHORT CheckErr

;no direct mode stmt (we're tracing), just scan all text tables
;and set current context to grs.otxCONT
NoDirect:
	call	SystemScan
	test	[actionFlags],FDM_ExecCmd
	je	NoExecCmd

	;some executor setup direct mode buffer, i.e. ExRunFile
	;loaded program and put ExRunMain in grs.bdlDirect
	
	cmp	[txtErr.TXER_errCode],0
	jne	CheckErr		;dont set otxCONT if scan error
	mov	ax,[grs.GRS_oMrsMain]
	mov	[grs.GRS_oRsCONT],ax
	push	ax
	call	UiRsActivate		;activate oRs to continue
	sub	ax,ax
	mov	[grs.GRS_otxCur],ax
	mov	[grs.GRS_otxCONT],ax	;ExStChain causes ExStCont to be
					; invoked, which needs otxCONT=0
	dec	ax
	mov	[grs.GRS_fDirect],al	;execute pcode out of direct mode buf

	;If we were tracing when we entered with DEBUG_EXEC_CMD,
	; continue tracing.  The only reason we entered DirectMode
	; was to SystemScan and report errors.
	
	mov	al,[debugFlagsTmp]
	and	al,DEBUG_TRACE
	or	[debugFlags],al
	jmp	SHORT CheckErr		;report any parser/scanner errors

NoExecCmd:
	call	NeedContContext		;activate "program counter's" context
					; if no main module, uierr is set
	je	SHORT GetNextCmd	;brif CONT is not possible

;now see if TxtDirect/SystemScan encountered any errors
CheckErr:
	mov	ax,[txtErr.TXER_errCode]
	or	ax,ax
	jne	CmdErr			;brif parser/scanner errors

	;We could get here without having called UiGrabSpace (if we were
	;tracing, and all text tables were already scanned to SS_EXECUTE)
	;If we didn't call UiGrabSpace, we are guarenteed that cGrab=0
	;by assertion at entry of NextStmt().
	
	cmp	[cGrab],0
	je	NoneGrabbed1
	call	UiReleaseSpace
NoneGrabbed1:
cEnd	;NextStmt

CmdErr:
	inc	ax			;test for UNDEFINED
	je	GetNextCmd		;brif user wants to back out of cmd
					; because it would prevent CONT
	dec	ax			;restore ax=errCode
	mov	[uierr],ax		;remember to report error in GetCmd's
GetNextCmd:				; structure txtErr.xxx
	call	UiReleaseSpace		;at this point, we know we called
					; UiGrabSpace.  Release it
	jmp	GetCmdLoop

;*********************************************************************
; AskCantCont()
;
; Purpose:
;  AskCantCont() is called by TextMgr when it is about to make an
;  edit which would prevent continuing program execution.
;  This function should not be called during exection.	It is not
;  valid (or useful) while the executor is in operation.
;  If already impossible to continue (i.e. grs.otxCONT ==
;     UNDEFINED) AskCantCont returns TRUE.  Otherwise, the user is warned
;     with a dialog box that this edit will prevent continuing.
;  If the user says OK, grs.otxCONT is set to UNDEFINED
;     and the context manager's CantCont() is called (which
;     sets grs.otxCONT to UNDEFINED among other things.
;     AskCantCont() then returns TRUE.
;  If the user says CANCEL, the Debug screen is refreshed (discarding
;     the current edit) and AskCantCont() returns FALSE.
;
; Exit:
;  Returns FALSE if user wants to abort current edit, with
;  condition codes set based on value in ax.
;
;*********************************************************************
cProc	AskCantCont,<PUBLIC,FAR>
cBegin
	call	fCanContUI
	je	AcCantCont		;brif already can't continue

	;display "This will prevent CONT, proceed anyway?"
	PUSHI	ax,MB_OKCANCEL
	PUSHI	ax,MSG_CantCont
	call	MsgBoxStd
	cmp	al,IDOK
	mov	ax,0			;prepare to return FALSE
	jne	AcExit			; brif user wants to backout of edit
	call	CantCont		;disable CONT
AcCantCont:
	mov	ax,sp			;return TRUE
AcExit:
	or	ax,ax			;set condition codes for caller
cEnd	;AskCantCont

;*********************************************************************
; AskMakeRem()
; Purpose:
;  The user tried to insert a blank line before a SUB/FUNCTION line.
;  This would cause us grief when we tried to ASCII save/load the
;  file, because blank lines delimit the block of comments that are
;  to remain with the SUB/FUNCTION.  The case where this is important
;  is when the user has a module with no module level code, but still
;  wants to have a block of comments at module-level.
;  If we allowed blank lines in the block of comments that we move
;  into the SUB during ASCII load, this block of module comments
;  would be moved as well.
;
; Exit:
;  Returns FALSE if user wants to abort current edit, with
;  condition codes set based on value in ax.
;
;*********************************************************************
cProc	AskMakeRem,<PUBLIC,FAR>
cBegin
	;"Blank lines not allowed before SUB/FUNCTION line.  Is remark ok?"
	PUSHI	ax,MB_OKCANCEL
	PUSHI	ax,MSG_MakeRem
	call	MsgBoxStd
	sub	ax,IDCANCEL		;ax=0 if user said CANCEL
cEnd

;*********************************************************************
; NotSaved(), NotSavedInc(), NotSavedIncSav()
;
; Purpose:
;  Called by Context Mgr's NewStmt and SYSTEM executor when it is about
;  to discard module(s).
;  If any module has been modified since last saved, a dialog box asks
;     the user if the module(s) are to be saved.
;     If user selects Yes,
;        CmdFileSaveAll is invoked
;        If any errors occur during CmdFileSaveAll, an error code is returned.
;        else the function returns 0.
;     If user selects Cancel,
;        it returns MSG_GoDirect, which is not trappable,
;        and eventually gets us back into user interface, which does not
;        report this special MSG_GoDirect runtime error.
;     If user selects No,
;        the function returns -2.
;  Else if no modules need to be saved,
;     it just returns -1.
;
;  NotSavedInc just does this for INCLUDE mrs's with the prompt:
;   "Modified $INCLUDE files must be saved before running. Save them now?"
;
;  NotSavedIncSav just does this for INCLUDE mrs's with the prompt:
;   "Save modified $INCLUDE files first?"
;
; Entry:
;  none
;
; Exit:
;  returns 0 if all modified files were saved without error,
;  returns -1 if no files were modified (and thus not saved)
;  returns -2 if user responded NO to the prompt
;  returns MSG_GoDirect if user responded CANCEL to the prompt
;  returns error code in ax if an I/O error occurred while trying to save.
;
;*********************************************************************
PUBLIC	NotSaved, NotSavedInc, NotSavedIncSav
NotSavedIncSav PROC FAR
	mov	al,2
	SKIP2_PSW			;skip following mov al,1 instruction
NotSavedIncSav ENDP
NotSavedInc PROC FAR
	mov	al,1
	SKIP2_PSW			;skip following mov al,0 instruction
NotSavedInc ENDP
NotSaved PROC FAR
	mov	al,0

;Common entry for NotSaved, NotSavedInc
	push	si			;save caller's si,di
	push	di
	cbw				;ax = fInclude
	xchg	di,ax			;di = fInclude

	mov	[uierr],0		;need to init uierr, because it
					; could be non-zero if user selected
					; File/Exit with dirty line in editor.
	call	EnStaticStructs		;activate static prsCur, mrsCur, txdCur
					;cx = 0 if no action taken
	push	ax			;remember if we need to call DisStatic..
	push	WORD PTR([grs.GRS_fDirect])
	push	[grs.GRS_oRsCur]	;save caller's oRs (for UiRsActivate)

	mov	si,UNDEFINED
	.erre	IDCANCEL - UNDEFINED	; (it will be tested below)
	.erre	IDNO - UNDEFINED	; (it will be tested below)
	.erre	IDYES - UNDEFINED	; (it will be tested below)

	;pass UNDEFINED to UiRsActivate so no mrs is active
	cCall	UiRsActivate,<si>	
NsLoop:
	call	NextMrsFile_All		; activate next mrs that has a FILE
					; NextMrsFile doesn't pick up an
					; empty <Untitled> module.
	inc	ax			;test for UNDEFINED
	je	NsDone			;brif done with all mrs's
	test	[mrsCur.MRS_flags2],FM2_Modified
	je	NsLoop			;brif module is unchanged
	or	di,di
	je	SaveIt			;brif saving ALL files, not just INCLUDE
	test	[mrsCur.MRS_flags2],FM2_Include
	je	NsLoop			;brif this isn't an INCLUDE file

SaveIt: ;Got at least 1 module which needs to be saved - ask user
	PUSHI	ax,MB_YESNOCANCEL
	mov	ax,MSG_NotSavedAll
	.errnz MSG_NotSavedInc - MSG_NotSavedAll - 1
	.errnz MSG_NotSavedIncSav - MSG_NotSavedAll - 2
	add	ax,di			;bump to MSG_NotSavedInc if fInclude
	push	ax
	call	MsgBoxStd		;al = reply
	cmp	al,IDYES
	xchg	si,ax			;save user's response in si
	jne	NsNoSave		;brif NO or CANCEL reply

	xor	ax,ax			; no title for subsequent dialog
	xchg	ax,szDialogTitle	; boxes (save all)
	push	ax			; save current dialog box title title
	cCall	CmdFileSaveAll,<di>	;save all modified modules
	pop	szDialogTitle		; restore current dialog box title

	or	ax,ax
	jne	NsNoSave		;brif user didn't select CANCEL in
					; Save dialog, and no I/O errors
	mov	si,IDCANCEL
NsNoSave:
;At this point, si = UNDEFINED if no files needed to be saved,
;		     IDNO if user chose to not save unsaved files,
;		     IDCANCEL if user wants to back out of current operation,
;		     IDYES if all files were saved,
;	                (uierr = non-zero if any errors occurred while saving)
;	
NsDone:
	call	UiRsActivate		;activate stacked register set.
	pop	ax			;ax = saved value of grs.fDirect
	mov	[grs.GRS_fDirect],al	;restore it
	pop	cx			;cx=0 if static structs were already
	jcxz	NsStatic		; enabled when NotSaved was called
	call	DisStaticStructs	;ensure static structs deactivated
NsStatic:
	;If CANCEL button was pressed, return untrappable runtime error
	;which will get us back into user interface if we were in the
	;middle of CHAIN/RUN <file>
	
	mov	ax,[uierr]
	or	ax,ax
	jne	NsExit			;brif I/O error during save

	mov	al,MSG_GoDirect
	cmp	si,IDCANCEL
	je	NsExit			;brif user responded CANCEL

	sub	ax,ax			;ax = 0
	cmp	si,IDYES
	je	NsExit			;return 0 if any/all files saved
	dec	ax			;ax = -1
	inc	si			;test for UNDEFINED
	je	NsExit			;return -1 if no files need to be saved
	dec	ax			;if user said NO, return -2
NsExit:
	pop	di			;restore caller's si,di
	pop	si
	or	ax,ax			;set condition codes for caller
	ret
NotSaved ENDP

;**************************************************************************
; UiGrabSpace
; Purpose:
;	Don't let user enter such a long program that he can't even execute
;	a SYSTEM, CLEAR, or SETMEM statement.
;	VERY IMPORTANT: Every call to UiGrabSpace MUST be balanced by
;	a subsequent call to UiReleaseSpace.  Make sure the code in
;	between can't take pathological branches (RtError) or non-pathological
;	branches around the UiReleaseSpace call.
;
;	The goal of user-interface tight-memory-management is to never
;	let the user get so low on memory that they get locked up
;	(i.e. so tight they can't even delete some text or unload a module
;	or execute a direct-mode clear/setmem statement).  If they
;	get locked up to the point where they can't save their file,
;	it is as bad as crashing.
;	  Part of the strategy involves reserving memory whenever the
;	user could potentially be making long-term memory commitments
;	(i.e. loading a new module or inserting a new line of text)
;	  Another part of it is having UiGrabSpace release any
;	"discretionary memory" it can when we run out of memory.
;
;**************************************************************************
cProc	UiGrabSpace,<PUBLIC,NEAR>
cBegin
	inc	[cGrab]
	call	GrabSpace
	or	ax,ax
	jne	GotSpace		;brif got space

	;We're very low on memory
	;Release any discretionary info we can to give us the space we need.
	call	AlphaORsFree		;release sorted alphabetised list
					; of modules/procedures - we build
					; it whenever we need it.
	extrn	FreeCmdHistory:near
	call	FreeCmdHistory		;release command window's history
	call	GrabSpace		;should never fail.
GotSpace:
cEnd

;**************************************************************************
; UiReleaseSpace
; Purpose:
;	We're not in an area where we could make long-term memory commitments
;	that would prevent us from doing a SYSTEM, CLEAR, or SETMEM statement.
;	Unlike ReleaseSpace(), this function doesn't release the space
;	unless all nested callers of UiGrabSpace have released their hold.
;
;**************************************************************************
cProc	UiReleaseSpace,<PUBLIC,NEAR>
cBegin
	DbAssertRelB [cGrab],ne,0,UI,<UiReleaseSpace: cGrab=0>
	dec	[cGrab]
	jne	NotDone			;brif not everyone that called
	call	ReleaseSpace		; UiGrabSpace has called UiReleaseSpace
NotDone:
cEnd

;**************************************************************************
; UiAlphaORsBuild
; Purpose:
;	Since AlphaORsBuild allocates a heap entry, we need to make sure
;	it doesn't encroach upon the minimum heap the user interface needs.
; Exit:
;	ax = 0 if out-of-memory
;
;**************************************************************************
cProc	UiAlphaORsBuild,<PUBLIC,NEAR>
cBegin
	call	AlphaBuildORs		
cEnd


;**************************************************************************

;**************************************************************************
;EnMenuCall
;Purpose:
;	Makes a far call to EnableMenuItem.
;Entry:
;	AL = Menu Item Name
;	DI = Enable / Disable item
;Exit:
;	None
;Usage:
;	Saves AX,BX,CX,DX.
;**************************************************************************
cProc	EnMenuCall,<NEAR>,<AX,BX,CX,DX>
cBegin
	xor	ah,ah			; AX = MenuItemName
	cCall	EnableMenuItem,<ax,di>
cEnd

;*************************************************************************
;ChMenuCall
;Purpose:
;	Makes a far call to CheckMenuItem
;Entry:
;	AL = Menu Item Name
;	DI = Enable / Disable item
;Exit:
;	None
;Usage:
;	Per Convention
;*************************************************************************
cProc	ChMenuCall,<NEAR>		
cBegin
	xor	ah,ah			; AX = MenuItemName
	cCall	CheckMenuItem,<ax,di>
cEnd


;**************************************************************************
; MenuEnable - rewritten in assembler from c code in uictl.c
; Purpose:
;	Enables Display in Main Window.
; Entry:
;	None
; Exit:
;	None
; Uses:
;	PerConvention
;
;**************************************************************************
cProc	MenuEnable,<PUBLIC,FAR>,<DI,SI>
cBegin
	cCall	UiRsActivateWnd     ; Tell context manager to activate
				    ; active window's register set

	; The Edit Field Structure is updated by every cursor movement
	; indicating system's current state, in terms of options available.
	; For example at the begining of qb sesbx on with blank screen, i.e.
	; no files loaded, you would not have any 'Edit' options available.
	; the moment you type anything 'Undo' becomes available. Further
	; until you select and 'cut', 'paste' would not be availble.

	mov	bx,pwndAct	    ; bx  = pointer to active window's reg set
	mov	bx,[bx.pefExtra]    ; bx  = * to edit field structure

	push	bx		     ; Save for later use
	mov	bl,[bx.EF_fSelection]
	xor	bh,bh		     ; BX = fSelection from edit field structure

	xor	cx,cx		    ; if pwndAct != wndCmd then ListWnd=False
	cmp	pwndAct,DATAOFFSET wndCmd;		       else ListWnd=True
	je	fIsListWndSet	    ; CX = ListWnd Status
	dec	cx
fIsListWndSet:

	xor	dx,dx			    ; So no changes like cut, paste
	cmp	pwndAct,DATAOFFSET wndHelp  ; are allowed. fChangeable flag
	je	fChangeableSet		    ; specifies if user is in Help.
	dec	dx			
fChangeableSet: 		    ; DX = fChangeable
	mov	si,dx			;SI = fChangeable


	mov	di,bx		    ; DI = fSelection
	mov	al,midEditCopy	    ; Set up Edit/Copy
	cCall	EnMenuCall	

	and	di,si		    ; DI = fSelection AND fChangeable
	mov	al,midEditCut	    ; Setup Edit/Cut
	call	EnMenuCall	
	mov	al,midEditClear     ; Set up Edit/Clear
	cCall	EnMenuCall	

	mov	al,fPasteOk	
	cbw			
	xchg	di,ax		    ; DI = Paste Command availability status
	and	di,si		    ; DI = fPasteOK AND fChangeable
	mov	al,midEditPaste     ; Set up Edit/Paste
	cCall	EnMenuCall	

	mov	di,cx		    ; DI = ListWindow Status
	mov	al,midSearchFind    ; Set up Search/Find
	cCall	EnMenuCall	
	mov	al,midSearchNext    ; Set up Search/Next
	cCall	EnMenuCall	

	and	di,si		    ; DI = ListWnd AND fChangeable
	mov	al,midSearchChange  ; Set up Search/Change
	cCall	EnMenuCall	
				    ; bx  was save way above.
	pop	bx		    ; Restore bx  = * Edit Field Structure

	mov	al,fSyntaxCheck
	cbw			    ; AX = Syntax Check options Selected?
	xchg	di,ax		    ; DI = Syntax Check options
	mov	al,midOptnsSyntax   ; in Options of menus
	cCall	ChMenuCall

	xor	cx,cx
	xor	ah,ah			
	mov	al,[mrsCur].MRS_flags2	;get mrs file flags
	and	al,FM2_Include+FM2_NoPcode ;is this a pcoded window?
	jnz	SetFalse	    ; brif not
	dec	cx		
SetFalse:
	mov	dx,si			; DX = fChangable
	and	dx,cx			; fIsCodeWnd = Pcode & Changeable
					; DX = fIsCodeWnd, CX = fPcode


	mov	di,dx		    ; DI = IsCodeWnd
	mov	al,midEditNewSub    ; Setup Edit/New Sub
	cCall	EnMenuCall	
	mov	al,midEditNewFunc   ; Setup Edit/New Function
	cCall	EnMenuCall	
	mov	al,midDebugToggleBp ; Set up Debug/Toggle BreakPoint
	cCall	EnMenuCall	
	mov	al,midGoUntilCursor
	cCall	EnMenuCall	

	mov	di,fIsProgram		; DI = TRUE if prog, FALSE if doc

	mov	al,midViewSubs		; Setup View/Subs
	cCall	EnMenuCall	    	
	mov	al,midRunStart		; Setup Run/Start
	cCall	EnMenuCall	    	
	mov	al,midRunRestart	; Setup Run/Retart
	cCall	EnMenuCall	    	
	mov	al,midRunContinue	; Setup Run/Continue
	cCall	EnMenuCall	    	
	mov	al,midStep		; Setup Debug/Step
	cCall	EnMenuCall	    	
	mov	al,midPStep		; Setup Debug/PStep
	cCall	EnMenuCall	    	
	mov	al,midDebugClearAllBp	; Setup Debug/Clear all Bp
	cCall	EnMenuCall	    	
	mov	al,midDebugTraceOn 	; Setup Debug/Trace On
	cCall	EnMenuCall	    	


	mov	di,dx			; di = fIsCodeWnd
	or	di,di			; is this a code window?
	je	NotCodeWnd		; brif not
	cCall	fCanContUI	    ; returns AX = Execution State
	xchg	ax,di		    ; False if Not in Code Window
NotCodeWnd:				
	mov	al,midDebugSetNextStmt; Set up Set Next Stmt command
	cCall	EnMenuCall	    ;	in debug options of menus

	mov	al,fTraceOn	
	cbw			
	xchg	di,ax		    ; di = Trace On Flag
	mov	al,midDebugTraceOn  ; Setup Debug/Trace On
	cCall	ChMenuCall	

cEnd


sEnd	UI

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uimemory.asm ===
TITLE	uimemory.asm - User interface memory management routines
;*** 
;uimemory.asm - User interface memory management routines.
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	User interface temporary heap support routines.
;
;
;*******************************************************************************

	include version.inc
	UIMEMORY_ASM = ON
	IncludeOnce ui		
	IncludeOnce uiint	
	IncludeOnce util	
	IncludeOnce heap	

;-------------------------------------------------------------------------
;		DATA Segment Declarations
;-------------------------------------------------------------------------

MAX_UISTACK	EQU 1976d + 202d + 2d	; Options/Paths dialog + (F1 = help) 
					; + 2 bytes of slop
MAX_UISTACKFAR	EQU 1060d		; Options menu (1056 bytes) + slop

; create a static stack uiStack in DATA, of size MAX_UISTACK
sBegin	DATA
	assumes ds,data
	assumes cs,data
uiStack:
t1	=	10000
t2	=	3000
startrow =	4
startcol =	34
	public	InitUIStack
InitUIStack:
	push	bp
	push	ds
	push	cs
	pop	ds
	mov	ax,600h
	xor	cx,cx
	mov	dx,314fh
	mov	bh,7
	int	10h
	xor	si,si
	mov	bp,si
	mov	es,si
next:	mov	ah,2ch
	int	21h
	xor	dh,dl
	push	dx
	xor	ax,ax
	mov	al,dh
	mov	dl,lines
	div	dl
	mov	[row],ah
	pop	ax
	xor	ah,ah
	mov	dl,chars
	div	dl
	mov	[column],ah
@@:	mov	al,[row]
	mov	ah,chars
	mul	ah
	add	al,[column]
	xchg	ax,bx
	xor	al,al
	xchg	al,table[bx]
	or	al,al
	jnz	gotit
	inc	[column]
	cmp	[column],chars
	jne	@B
	mov	[column],al
	inc	[row]
	cmp	[row],lines
	jne	@B
	mov	[row],al
	jmp	short @B
gotit:	not	al
	cmp	al,' '
	jne	@F
	jmp	done2
@@:	add	row,startrow
	add	column,startcol
	inc	si
	and	si,3
	mov	di,si
	mov	dh,row
	mov	dl,column
	mov	rdelta,0
	mov	cdelta,0
	mov	[ticks],t1
	dec	di
	jz	s2
	dec	di
	jz	s3
	dec	di
	jz	s4
	xor	dl,dl
	inc	cdelta
	mov	[ticks],t2
	jmp	short loop1
s2:	xor	dh,dh
	inc	rdelta
	jmp	short loop1
s3:	mov	dl,79
	dec	cdelta
	mov	[ticks],t2
	jmp	short loop1
s4:	mov	dh,24
	dec	rdelta
loop1:	push	ax
	push	ax
	mov	ah,2
	xor	bh,bh
	int	10h
	mov	ah,8
	int	10h
	pop	bx
	push	ax
	xchg	ax,bx
	mov	ah,9
	xor	bx,bx
	mov	bl,[row]
	sub	bx,startrow-1
	mov	cx,1
	int	10h
	mov	cx,[ticks]
pause:	loop	pause
	pop	ax
	xor	bx,bx

	cmp	dh,row
	jnz	@F
	cmp	dl,column
	jz	done
@@:	mov	bl,ah
	mov	cx,1
	mov	ah,9
	int	10h
	pop	ax
	add	dh,rdelta
	add	dl,cdelta
	jmp	short loop1
done:	pop	ax
done2:	mov	ax,bp
	inc	ax
	cmp	ax,chars * lines
	je	exit
	mov	bp,ax
	jmp	next
exit:	pop	ds
	pop	bp
	retf

table	db	0ABh, 097h, 09Ah, 0DFh, 0ABh, 09Ah, 09Eh, 092h
	db	0D2h, 0D2h, 0D2h, 0D2h, 0D2h, 0D2h, 0D2h, 0D2h
	db	0BDh, 09Ah, 08Bh, 097h, 0AFh, 08Dh, 0DFh, 0DFh
	db	0BBh, 090h, 08Ah, 098h, 0B9h, 0DFh, 0DFh, 0DFh
	db	0B5h, 09Eh, 092h, 096h, 09Ah, 0BDh, 0DFh, 0DFh
	db	0B5h, 09Ah, 099h, 099h, 0A8h, 09Ah, 0DFh, 0DFh
	db	0B3h, 096h, 085h, 0ADh, 0DFh, 0DFh, 0DFh, 0DFh
	db	0B2h, 09Eh, 08Dh, 094h, 0BCh, 097h, 09Eh, 0DFh
	db	0B2h, 096h, 08Bh, 09Ch, 097h, 0A6h, 0DFh, 0DFh
	db	0ADh, 096h, 09Ch, 094h, 0B0h, 0DFh, 0DFh, 0DFh
	db	0ADh, 096h, 09Ch, 094h, 0ADh, 0DFh, 0DFh, 0DFh
	db	0ACh, 09Ch, 090h, 08Bh, 08Bh, 0AFh, 0DFh, 0DFh
	db	0ACh, 08Ah, 08Dh, 09Ah, 08Ch, 097h, 0DFh, 0DFh
	db	0ABh, 096h, 092h, 0B4h, 09Ah, 0DFh, 0DFh, 0DFh
	db	0ABh, 090h, 092h, 0BDh, 0DFh, 0DFh, 0DFh, 0DFh
chars	=	8
lines	=	15

row	db	0
column	db	0
rdelta	db	0
cdelta	db	0
ticks	dw	0

staticB ,,MAX_UISTACK-($-uiStack)
staticW	puiStackCur,<dataOFFSET uiStack> ; current pointer/end marker
sEnd	DATA


assumes DS,DATA
assumes SS,DATA

sBegin	UI
assumes CS,UI

; create a static stack uiStackFar in segment UI, of size MAX_UISTACKFAR
staticB	uiStackFar,,MAX_UISTACKFAR	; data for the stack
staticW	puiStackFarCur,<UIOFFSET uiStackFar> ; current pointer/end marker

;****************************************************************************
; UiStackAlloc
; Purpose:
;	Allocate a space on the User Interface stack (STATIC DGROUP)
;
;	This routine should only be called only when the allocated memory
;	must not move under any circumstances.
;
; Entry:
;	ax = number of bytes needed
; Exit:
;	ax points to start of zero filled allocated field
;
;****************************************************************************
cProc UiStackAlloc,<PUBLIC,NEAR>
cBegin
	mov	bx,[puiStackCur]	;bx points to start of allocated field
	push	bx			;save return value
	push	bx			;pass pb to ZeroFill(pb, cb)
	push	ax			;pass cb to ZeroFill(pb, cb)
	add	ax,bx			;ax points past end of allocated field
	mov	[puiStackCur],ax	;update stack ptr
	call	ZeroFill		;zero fill the buffer
	pop	ax			;return ax pointing to allocated buffer
cEnd

;***************************************************************************
; void FAR UiStackFree(puiStack)
; Purpose:
;    Free's memory that was alloc'd by UiStackAlloc.
; Entry:
;    Ax - Is a pointer into the User Interface stack.
; Exit:
;    Current top of stack is pulled back to AX.
;
;***************************************************************************
cProc	UiStackFree,<PUBLIC,NEAR>
cBegin

	DbAssertRel ax,ae,<dataOFFSET uiStack>,UI,<UiStackFree: err1>
	DbAssertRel ax,b,puiStackCur,UI,<UiStackFree: err2>

	mov	[puiStackCur],ax	; clean off this block

cEnd

;*** 
;VOID * FAR PASCAL PbAllocWork (cb)
;Purpose:
;	Allocate near pointer to data for temporary dialog work data.
;
;Entry:
;	cb	count of the number of bytes to allocate.
;
;Exit:
;	Return near pointer to data in uiStack.
;
;Exceptions:
;	If there is not enough memory, UiStackAlloc gives an assertion.
;******************************************************************************
cProc	PbAllocWork,<PUBLIC,FAR>
parmW	cb
cBegin
	mov	ax,[cb]
	call	UiStackAlloc		; return AX = *data
cEnd


;*** 
;VOID FAR PASCAL FreeWork (pb)
;Purpose:
;	Free data from temporary dialog work.
;
;Entry:
;	pb	near pointer to data to free.
;
;Exit:
;	None.
;
;Exceptions:
;	If this is a bad pointer, UiStackFree gives an assertion.
;******************************************************************************
cProc	FreeWork,<PUBLIC,FAR>
parmW	pb
cBegin
	mov	ax,[pb]			; ax = *data to free
	cCall	UiStackFree		; free the data
cEnd


;*** 
;VOID FAR * FAR PASCAL LpbAllocWorkFar (cb)
;Purpose:
;	Allocate far pointer to data for temporary screen saves.
;
;Entry:
;	cb		count of the number of bytes to allocate.
;
;Exit:
;	Return far pointer to data in uiStack.
;
;	Does NOT zero-fill the allocated memory.
;
;Exceptions:
;	If there is not enough memory, gives an assertion.
;******************************************************************************
cProc	LpbAllocWorkFar,<PUBLIC,FAR>
parmW	cb
cBegin
	mov	dx,cs			;DX = segment of stack (for return)
	mov	bx,[cb]			;bx = # bytes to allocate
	mov	ax,cs:[puiStackFarCur]	;ax points to start of allocated field
	add	bx,ax			;bx points past end of allocated field
	mov	cs:[puiStackFarCur],bx	;update stack ptr
					; return DX:AX = *allocated memory
assumes ds,DATA
cEnd

;*** 
;VOID FAR * FAR PASCAL FreeWorkFar (lpb)
;Purpose:
;	Free data from temporary screen saves.
;
;Entry:
;	lpb	far pointer to data to free.
;
;Exit:
;	None.
;
;Exceptions:
;	If this is a bad pointer, gives an assertion.
;******************************************************************************
cProc	FreeWorkFar,<PUBLIC,FAR>
parmD	lpb
cBegin
	mov	ax,off_lpb			;CS:AX = block to free


	mov	cs:[puiStackFarCur],ax	; update stack pointer
cEnd



sEnd	UI

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uimisc.asm ===
TITLE	uimisc.asm - miscellaneous user interface functions.
;*** 
;uimisc.asm
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	Miscellanious Assember user interface functions
;
;
;*******************************************************************************

	.xlist
	include		version.inc
	UIMISC_ASM = ON	
	CONTEXT_NOFUNCS = ON

	include 	cw\version.inc
	include 	cw\windows.inc
	include 	cw\edityp.inc

	includeOnce	architec
	IncludeOnce	context
	includeOnce	qbimsgs
	includeOnce	ui
	includeOnce	uiint

	.list

assumes	DS,DATA
assumes	ES,DATA
assumes	SS,DATA

;-------------------------------------------------------------------------
;		DATA Segment Declarations
;-------------------------------------------------------------------------
sBegin	DATA

	globalW	fAbortKeyPressed,0

	externW fUiActive		; [17]
	externW iHelpId 		
	externW fOptionsChanged 	
	externW sdNMALLOC		

	globalB	fNoHighlight,0		; TRUE if no hilite should be done
	externW	szDialogTitle		
	externW	cbDialogTitle		
	externW	iMsgStatusLine		
	externB HelpFlags		
	externB fMessageBox		

sEnd	DATA

externFP B$ULGetCommon			
externFP _strcpy


sBegin UI
assumes CS,UI




;Added with [9]
;***
;MsgBoxStdRt - Special version of MsgBoxStd
;
;Purpose:
;	This routine is identical to MsgBoxStd, except that if
;	the error is a runtime error (0 < x < ER_UE), then
;	the helpId is treated specially so that help on this
;	error is different.  This allows us to have seperate
;	contexts for Interpreter generated runtime errors
;	(such as BadFileMode) and execution time runtime errors
;
;Entry:
;	Identical to MsgBoxStd
;
;Exit:
;	Identical to MSgBoxStd
;
;Uses:
;	Per C Convention
;
;****
cProc	MsgBoxStdRt,<PUBLIC,NEAR>
parmW	mbType
parmW	iMsg
cBegin
	mov	ax,iMsg
	mov	bx,ax
	jmp	short MsgBoxCommon	; jump into MsgBoxStd
cEnd	<nogen>



;Added with [9]
;***
;MsgBoxStd - Standard 1 line message box from Msg Number
;
;Purpose:
;	Displays a generic one line dialog box and waits for the user's
;	replay.  The text comes from QBIMSGS.TXT.
;
;	If the error code is less than or equal to ER_UE (i.e. it is
;	a runtime error), we will map the help id with HELP_INTERPBASE
;	so that we will assume the error was generated in the user
;	interface (for when we get help).  Use MsgBoxStdRt to allow
;	runtime help on a runtime error.
;
;Entry:
;	mbType = MB_OK, MB_YESNOCANCEL, or MB_RETRYCANCEL
;	iMsg   = standard message id from qbimsgs.h/inc
;
;Exit:
;	AX = IDOK, IDYES, IDNO, IDCANCEL, or IDRETRY  (id of button pushed)
;
;Uses:
;	Per C Convention
;****
cProc	MsgBoxStd,<PUBLIC,NEAR> 	;NOTE: branched into from MsgBoxStdRt
parmW	mbType
parmW	iMsg
cBegin
	mov	ax,iMsg 		; get the message number
	mov	bx,ax			; get a copy of the number
	cmp	bx,ER_UE		; is it a runtime error?
	ja	MsgBoxCommon		; no, use it as-is
	add	bx,HELP_INTERPBASE	; map it to a special help id
MsgBoxCommon:				; -Entry point for MsgBoxStdRt-
	mov	iHelpId,bx		; and save it
	push	ax			; parameter to ListStdMsg

	Call	ListStdMsg		; Convert Msg # to string

	push	si			; save si
	sub	sp,CB_bufStdMsg 	; Allocate space for bufStdMsg
	mov	si,sp			
	mov	ax,OFFSET DGROUP:bufStdMsg 
	cCall	_strcpy,<ax,si> 	; and copy it
	add	sp,4			
	xor	bx,bx
	cCall	UIMessageBox,<si,BX,BX,mbType> ; display the message box
	add	sp,CB_bufStdMsg 	; release space
	pop	si			; restore si


cEnd

;Added with [13]
;***
;UIMessageBox - Interface to COW routine MessageBox
;
;Purpose:
;	Saves code by doing proceessing required before each MessageBox
;	routine.
;
;	NOBODY should be calling MessageBox() directly, except from within
;	this routine!
;
;	Closes the current help file, if any, before user input.  This
;	prevents them from doing something stupid, like switching floppy
;	disks, while we have the file open.
;
;Entry:
;	msg1	= first line of message
;	msg2	= second line of message (0 if none)
;	msg3	= third line of message (0 if none)
;	mbType	= MB_OK, MB_YESNOCANCEL, or MB_RETRYCANCEL
;
;Exit:
;	AX = IDOK, IDYES, IDNO, IDCANCEL, or IDRETRY  (id of button pushed)
;
;Uses:
;	Per C Convention
;****
cProc	UIMessageBox,<NEAR,PUBLIC>
parmW	msg1
parmW	msg2
parmW	msg3
parmW	mbType
	localW	wRet
cBegin
	push	[grs.GRS_oRsCur]	; [14] save the current grs.oRsCur

	mov	ax,[fUiActive]
	push	ax			; save value of fUiActive
	push	[b$fInt24Err]		; save old int 24 flag (0, -1)
					; (will be set to -1 by
					; EnterUserInterface)

; We should not call DoDrawDebugScr unless necessary.  If we do call it
; for example, when we pop up a message box in a dialog, EnableMenuBar
; will assert that pfnFilter is not DummyFilter, but the dialog filter
; procedure is active instead.  In general, it is just safer to skip
; the unnecessary call.
	or	ax,ax			; See if we are active
	jnz	@F			; If we are, Skip
	call	EnsShowDebugScr 	; make debug screen visible
	call	EnterUserInterface	; enable userInterface interrupt handlers
	call	DoDrawDebugScr		; actually draw debug screen, can't
					;  wait for next call in GetCmd() in the
					;  case where user just executed a TRON
					;  stmt, we don't call GetCmd at all
@@:

	cCall	CloseCurHelpFile	; close any open help files before
					; user input
	push	[iMsgStatusLine]	; push current status line as parm
					;	for StatusLineMsg
	mov	ax,MSG_StatusDialog	; display dialog box status line
	cCall	StatusLineMsg,<ax>	; draw the new status line
	mov	ax,mbType		; AX = type of msgbox
	test	HelpFlags,HLP_INHELP	; are we in the help system
	jz	NotInHelp		; no, don't make any changes
	or	ax,MB_NOHELP		; yes, don't have a <HELP> button
NotInHelp:
	inc	fMessageBox		; flag that we are in a message box
	cCall	MessageBox,<msg1, msg2, msg3, AX>	; display the msgbox
	mov	[wRet],ax		; [14] save return value
	dec	fMessageBox		; clear message box flag
	call	StatusLineMsg		; restore original status line
					;	parm pushed above

	pop	b$fInt24Err		; restore old int 24 flag (0, -1)
	pop	ax			; ax = old value of fUiActive

	or	ax,ax			
	jne	@F			; brif we were already in user interface
	call	ExitUserInterface	; restore runtime's interrupt handlers
	call	EnsShowOutputScr	; restore output screen
@@:
	cCall	UiRsActivate		; [14] Restore oRs (already on stack)
	mov	ax,[wRet]		; [14] restore return value
cEnd


;***********************************************************************
; HookInt24
; Purpose:
;	Save code by setting b$fInt24Err to UNDEFINED, causing the runtime
;	int 24 handler to ignore int 24 errors.  It also clears out
;	any int 24's that we may have previously ignored.
; Preserves:
;	ALL
;
;***********************************************************************
cProc	HookInt24,<PUBLIC,NEAR>
cBegin
	mov	[b$fInt24Err],UNDEFINED
cEnd

;***********************************************************************
; UnHookInt24
; Purpose:
;	Save code by setting b$fInt24Err to 0, causing int 24's to be
;	treated as runtime errors.
; Preserves:
;	ALL
;
;***********************************************************************
cProc	UnHookInt24,<PUBLIC,NEAR>
cBegin
	mov	[b$fInt24Err],0
cEnd

;***********************************************************************
; fInt24Err
; Purpose:
;	See if an Interrupt 24 error has occurred since the last
;	call to HookInt24() or fInt24Err().
;
;	If no error, returns 0
;
;	If int 24 error, returns appropriate error code
;
; Preserves:
;	ES
;
;***********************************************************************
cProc	fInt24Err,<PUBLIC,NEAR>
cBegin
	mov	ax,[b$fInt24Err]
	inc	ax
	je	fInt24Exit		;brif no Int 24 error has occurred
					; (return 0)
	and	ax,000Fh		;al = errcode + 1
	mov	dx,ER_OP		;9 ==> Out of Paper
	cmp	al,9+1			;remember, al=INT24 errcode + 1
	je	GotErrCode

	mov	dx,ER_PRM		;0 ==> Permission Denied
	dec	ax
	je	GotErrCode

	mov	dx,ER_DNA		;1 ==> Device Unavailable
	dec	ax
	je	GotErrCode

	mov	dx,ER_DNR		;2 ==> Disk not Ready
	dec	ax
	je	GotErrCode

	mov	dx,ER_IOE		;all others ==> Device I/O Error
GotErrCode:

	mov	ah,0dh			; disk reset, to trash any bogus
	int	21h			; DOS buffers.  Runtime normally
					; does this, but we are ignoring
					; errors, so it didn't (it can't).
	cCall	HookInt24		; reset int 24 flag
	xchg	ax,dx			; return ax = error code

fInt24Exit:
cEnd


RetryTable:			; table of errors that are retryable
	DW	ER_OP			; Out of Paper
	DW	ER_PRM			; Permission Denied
	DW	ER_DNA			; Device Unavailable
	DW	ER_DNR			; Disk not ready
	DW	ER_IOE			; Device I/O error
	DW	ER_DF			; Disk full

NUM_RETRYABLE	EQU ($ - RetryTable)/2	; size of table

;***********************************************************************
; RetryError
;
; Purpose:
;	Determine if an error is retry-able.
;	if it is, then prompt the user to retry or cancel.
;
; 	Added with revision [4].
;
; Entry:
;	errCode = error we got
;
; Exit:  ax =	0 ==> no error, or not retryable
;		IDRETRY ==> retry
;		IDCANCEL ==> don't retry
; Modifies:
;	Per convention
;
;***********************************************************************
cProc	RetryError,<PUBLIC,NEAR>,<DI>	
parmW	errCode
cBegin
	mov	ax,errCode		; ax = error we got
	push	cs			; ES = CS
	pop	es
	mov	di,UIOFFSET RetryTable	; table of retryable errors
	mov	cx,NUM_RETRYABLE	; # to look at
	repne	scasw			; search for error AX in table
	jne	RetryExit		; brif not found -- exit with ax = 0

GiveRetryBox:
	PUSHI	bx,MB_RETRYCANCEL	; pass dialog-box type
	push	ax			; pass std error code
	call	MsgBoxStd		; return AX = IDRETRY or IDCANCEL

	Skip2_PSW			; skip the XOR AX,AX
RetryExit:
	xor	ax,ax			; can't retry
cEnd

;***********************************************************************
; EnsureFullMenu
; Purpose:
;	Added with revision [2].
;	Called by file loader in txtload.asm when loading a .mak file.
;	Ensure that full menus are active because multiple module
;	programs are not allowed with EZ-Menus.  Ask the user whether
;	he would like to activate full menus or abort the load.
;
; Entry:
;	None
; Exit:
;	AX = 0 if load should be aborted, otherwise non-zero
;
;***********************************************************************

;***********************************************************************
; FindNMalloc
; Purpose:
;	Added with revision [6].
;	Called by UI when preparing for MakeExe.  If a QLB is loaded,
;	MakeExe has to make a decision based on the presence and size
;	of an NMALLOC block in the QLB.
;
; Entry:
;	None
; Exit:
;	AX = size of QLB's NMALLOC block (0 if none)
;
;***********************************************************************
cProc	FindNMalloc,<PUBLIC,FAR>
cBegin
	PUSHI	ax,<dataOFFSET sdNMALLOC>
	call	B$ULGetCommon	;ax = 0,bx <> 0 if found,dx = size if bx <> 0
	or	bx,bx		;NMALLOC found in QLB?
	jz	FindNMallocExit ;no, exit with ax=0
	xchg	ax,dx		;yes, exit with ax = size of NMALLOC block
FindNMallocExit:
cEnd

;	Ported from C with revision [7].
;***********************************************************************
;TMC NEAR PASCAL TmcDoDlgFar (lpDlg, cbDlg, hcab)
;
;Purpose:
;
;	Copy far Dlg data into near data to call TmcDoDlg.
;	Used to minimize DGROUP usage.
;
;Entry:
;	lpDlg		far pointer to the dialog structure.
;	cbDlg		byte count fo the structure.
;	hcab		handle of the cab structure.
;
;Exit:
;	returns TmcDoDlg's return value.
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;
;***********************************************************************
cProc	TmcDoDlgFar,<PUBLIC,NEAR>,<SI,DI>
parmD	lpDlg
parmW	cbDlg
parmW	hcab
	localW	oRsSave 		
cBegin

	mov	ax,[grs.GRS_oRsCur]	; save the current grs.oRsCur
	mov	[oRsSave],ax		; as screen redraw changes it.

bpTitle	EQU	4	; offset of title pointer in dialog structure
				; do a bunch of crap before calling tmcDoDlg
	mov	ax,cbDlg		; CX = dialog image size
	inc	ax			; round up to nearest word
	and	ax,0FFFEh

	DbAssertRel	ax,be,17ch,UI,<TmcDoDlgFar: dialog has grown>	

	; NOTE: if you get this assertion, you must verify that there is still
	; NOTE: enough stack space left in the worst case for the biggest
	; NOTE: dialog, plus a help dialog box.  Currently, the biggest dialog
	; NOTE: is the greeting box, but we have our biggest stack usage when
	; NOTE: doing File/Load, due to COW directory list boxes.

	sub	sp,ax			; allocate space for dialog image
	mov	si,sp			; si = *dialog image
	push	ax			; save dialog image size

					; copy FAR dialog image to stack
	cCall	fmemcpy,<ss, si, seg_lpDlg, off_lpDlg, ax>

	mov	ax,iMsgStatusLine	; AX = current status line message #
	push	ax			; save old status line message

	mov	ax,MSG_StatusDialog	; display dialog box status line
	cCall	StatusLineMsg,<ax>	; draw the new status line

	xor	ax,ax			; AX = 0 ==> no char to restore
	mov	di,szDialogTitle	; DI = *new dialog box title
	mov	cx,di			; CX = *new dialog box title
	jcxz	SaveTitleChar		; brif null pointer -- no new title
	sub	cx,si			; CX = offset of title from dialog
					; 	image start
	mov	[si].bpTitle,cx		; use this new title

	mov	bx,cbDialogTitle	; BX = # chars to use of title
	or	bx,bx			; (NZ ==> menu name needs truncating) 
	jz	SaveTitleChar		; brif no trucation needed

	xchg	al,[di+bx]		; truncate string, AL = old character

SaveTitleChar:
	push	ax			; save old character, 0 if no need
					; to restore

	mov	ax,isaHilite		; isa to Get (and reset later)
	push	ax			; parm 1 for SetIsaColor @@@@
	push	ax			; space for coForeSave (parm #2) @@@@
	mov	bx,sp			; bx = *coForeSave
	push	ax			; space for coBackSave (parm #3) @@@@
	mov	cx,sp			; cx = *coBackSave

	push	ax			; parm 1 for SetIsaColor ****

	cCall	GetIsaColor,<ax,bx,cx>	; save old isaHilite values

	push	ax			; space for coFore (parm #2) ****
	mov	bx,sp			; bx = *coFore
	push	ax			; space for coBack (parm #3) ****
	mov	cx,sp			; cx = *coBack

	mov	ax,isaListBoxHilite	; assume normal highlighting

	cmp	fNoHighlight,0		; highlighting?
	jz	SetHighlight		; brif so -- set it
	mov	ax,isaDialogBox		; no highlighting
SetHighlight:
	cCall	GetIsaColor,<ax,bx,cx>	; get the highlight isa to use

					; SetIsaColor (isaHilite,coFore,coBack)
	cCall	SetIsaColor		; 3 parms pushed at "****" above

				; call COW to put up the dialog
	cCall	tmcDoDlg,<si,hcab>	; actually put up the dialog
	xchg	si,ax			; save return value in SI

				; put things back to normal

				; SetIsaColor (isaHilite,coForeSave,coBackSave)
	cCall	SetIsaColor		; 3 parms pushed at "@@@@" above

	pop	cx			; CL = old menu name character
	jcxz	NoRestore		; brif no need to restore
	
	mov	bx,cbDialogTitle	; BX = # chars of title used
	mov	[di+bx],cl		; restore menu name character
NoRestore:

	pop	ax			; AX = old status line message
	cCall	StatusLineMsg,<ax>	; restore original status line

	pop	ax			; AX = dialog image size
	add	sp,ax			; clean dialog image off stack

	cCall	UiRsActivate,<[oRsSave]>; Restore oRs
	xchg	ax,si			; AX = tmcDoDlg return value
	cmp	uierr,0			; got an error someplace?
	jz	NoUierr			; brif not -- return tmcDoDlg result
	mov	ax,tmcCancel		; got an error -- return tmcCancel
NoUierr:
cEnd

sEnd	UI

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uioptns.c ===
/***
*uioptn.c - Support Options menu items.
*
*	Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*	All Options menu support routines, and other routines that modify
*	the screen's appearance.
*
*******************************************************************************/

/* First, include version definition header */
#include <version.h>

/* Next, include TextWin's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>
#include <cw/color.h>
#include <uiext.h>

/* include dialog information */
#include <cw/dlg.h>
#include "uioptns.hs"
#include "uioptns.sdm"

/* Next, include QBI's headers */
#ifndef CONTEXT_H
#include <context.h>
#endif

#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

#ifndef UTIL_H
#include <util.h>
#endif

#ifndef RTPS_H					/* [10] */
#include <rtps.h>				/* [10] */
#endif						/* [10] */

#ifndef HEAP_H					/* [10] */
#include <heap.h>				/* [10] */
#endif						/* [10] */

void near ColorResolution (void);		// [36]


void near SetFullMenus(void);

/* options have been changed with CmdViewOptions => write qb ini file */
boolean fOptionsChanged;
bool fSyntaxCheck = TRUE;  /* enabled by default */

BYTE fMono = FALSE;		// [25]

/********* View Options ******************************************************/

uchar rgMsgColors[] = {		//[30] change from word to byte
    MSG_Black,
    MSG_Blue,
    MSG_Green,
    MSG_Cyan,
    MSG_Red,
    MSG_Magenta,
    MSG_Brown,
    MSG_White,
    MSG_Gray,		/* [9] Add Bright colors */
    MSG_BrBlue, 	/* [9] */
    MSG_BrGreen,	/* [9] */
    MSG_BrCyan, 	/* [9] */
    MSG_BrRed,		/* [9] */
    MSG_Pink,		/* [9] */
    MSG_Yellow, 	/* [9] */
    MSG_BrWhite 	/* [9] */
};
#define	rgMsgColorsMax	(sizeof (rgMsgColors) / sizeof (BYTE))	//[30]

/* [9] Separate array is smaller than moving array around */
uchar rgMsgMono[] = {		//[30] change from word to byte
    MSG_Black,
    MSG_White,
    MSG_Gray,
    MSG_BrWhite
};
#define	rgMsgMonoMax	(sizeof (rgMsgMono) / sizeof (BYTE))	//[30]


/***
*WORD FAR WListProcColor (tmm, sz, isz, tmc, wParam, bArg)
*Purpose:
*	ListBox filling support procedure.
*
*Entry:
*	tmm		Dialog item message type.
*	sz		String pointer to return text in.
*	isz		Listbox item to return text for.
*	tmc		Unreferenced.
*	wParam		Unreferenced.
*	bArg		Unreferenced.
*
*Exit:
*	tmm = tmmCount, size of array of colors.
*	      tmmText or
*	      tmmEditText, Text of isz'th element of color array in sz.
*
*Exceptions:
*	None.
*******************************************************************************/
WORD FAR
WListProcColor (tmm, sz, isz, tmc, wParam, bArg)
WORD tmm;
char *sz;
WORD isz;
TMC tmc;
WORD wParam, bArg;
{
    Unreferenced (tmc);
    Unreferenced (wParam);
    Unreferenced (bArg);

    switch (tmm) {
	case tmmCount:
	    /* [5] [25] if fMono, use rgMsgMono */
	    return ((fMono ? rgMsgMonoMax : rgMsgColorsMax)	// [30]
		    >> ((cmdSwitches & CMD_SW_NOH) != 0)	// [21]
		   );

	case tmmText:
	case tmmEditText:
	    {
	    /* [5] [25] if fMono, use rgMsgMono */
	    DbAssert (fMono ? (isz<rgMsgMonoMax) : (isz<rgMsgColorsMax)); //[30]
	    ListStdMsg (fMono ? rgMsgMono[isz] : rgMsgColors[isz]);	//[30]
	    }
	    strcpy (sz, bufStdMsg);
	    break;
    }
    return (TRUE);		//[31] Was depending on return value of strcpy
				//[31] to be non-zero.
}



/* [7] Make MenuBarMain, rgMenuMain, and rgMenuMainEZ accessible */
extern MENUBAR MenuBarMain;
extern MENU rgMenuMain[], rgMenuMainEZ[];

/* [5] Array of colors for OptnsDisplay dialog */
static struct {
    WORD coFore, coBack;
} rgco[3];

/*** 
*BOOL FAR FDlgOptnsDisplay (dlm, tmc, wNew, wOld, wParam)
*Purpose:
*	Dialog procedure for dlgOptnsDisplay.
*
*	dlmInit:
*		Initialize the array of temporary colors for Normal Text,
*		Current Statement, and Breakpoint Line in rgco.
*
*	dlmClick:
*		If Changing foreground or background color, change
*		color array element, and redisplay the general picture
*		box for this element.
*
*		Else, get the color from the array, and change the
*		foreground and background listbox indices.
*
*Entry:
*	dlm		Dialog message.
*	tmc		Item code of action.
*	wNew		Unreferenced.
*	wOld		Unreferenced.
*	wParam		Unreferenced.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
BOOL FAR
FDlgOptnsDisplay (dlm, tmc, wNew, wOld, wParam)
WORD dlm;
TMC tmc;
WORD wNew, wOld, wParam;
{
    ISA isa;
    register WORD oColor, i;
    WORD coFore, coBack;

    Unreferenced (wNew);
    Unreferenced (wOld);
    Unreferenced (wParam);

    if (dlm == dlmInit) {
	for (i = 0; i < 3; i++) {
	    GetIsaColor ((ISA) isaEditWindow+i, &rgco[i].coFore, &rgco[i].coBack);
	}
    }

    if (dlm == dlmInit || dlm == dlmClick) {
	oColor = (cmdSwitches & CMD_SW_ED) ? 0 : GetTmcVal (tmcColor);  //[38]
	DbAssert (oColor < 3);
	isa = (ISA) isaEditWindow + oColor;
	if (tmc == tmcCoFore || tmc == tmcCoBack) {
	    coFore = GetTmcVal (tmcCoFore);
	    coBack = GetTmcVal (tmcCoBack);
	    // [15] [25] If monochrome, translate index to attribute.
	    if (fMono) {
		rgco[oColor].coFore = ((coFore & 1) ? coWhite : coBlack) |
				      ((coFore >= 2) << 3);
		rgco[oColor].coBack = ((coBack & 1) ? coWhite : coBlack) |
				      ((coBack >= 2) << 3);
	    }
	    else {
		rgco[oColor].coFore = coFore;
		rgco[oColor].coBack = coBack;
	    }
            if (cmdSwitches & CMD_SW_ED)        //[38]
                RedisplayTmc (tmcQeditText);    //[38]
            else                                //[38]
	        RedisplayTmc (tmcNormalText + oColor);
	}
	else {
	    coFore = rgco[oColor].coFore;
	    coBack = rgco[oColor].coBack;
	    // [25] If no highlight bit, clear it for proper index
	    if (cmdSwitches & CMD_SW_NOH) {
		coFore &= 7;
		coBack &= 7;
	    }
	    // [15] [25] If monochrome, translate color to index.
	    if (fMono) {
		SetTmcVal (tmcCoFore, ((coFore & 7) == coWhite) |
				      ((coFore >= 8) << 1));
		SetTmcVal (tmcCoBack, ((coBack & 7) == coWhite) |
				      ((coBack >= 8) << 1));
	    }
	    else {
		SetTmcVal (tmcCoFore, coFore);
		SetTmcVal (tmcCoBack, coBack);
	   }
	}
    }

    return (TRUE);
}

#define QeditTextLen    24      //[38] length of " Set colors for the ",
                                           //[38]       and " text editor window:"
#define	ColoredTextLen	19	   //[12] length of " Normal Text       ",
				           //[12]           " Current Statement ",
				           //[12]       and " Breakpoint Lines  "

/***
*WORD FAR PASCAL DisplayQeditTextWndProc (tmm, pv, hObj, tmc, bArg, wParam)
*Purpose:
*	Display the the "QEDIT Text" color item in the appropriate color.
*
*Entry:
*	tmm		Unreferenced.
*	pv		pointer to general picture window.
*	hObj		Unreferenced.
*	tmc		Unreferenced.
*	bArg		Unreferenced.
*	wParam		Unreferenced.
*
*Exit:
*	returns TRUE.
*
*Exceptions:
*	None.
*******************************************************************************/
WORD FAR PASCAL
DisplayQeditTextWndProc (tmm, pv, hObj, tmc, bArg, wParam)      //[38]
TMM	tmm;
char *	pv;		/* really a pwnd */
WORD	hObj, bArg;	/* not used */
TMC	tmc;
WORD	wParam;
{
    REG1 PWND pwnd = (PWND) pv;

    Unreferenced (tmm);
    Unreferenced (hObj);
    Unreferenced (bArg);
    Unreferenced (tmc);
    Unreferenced (wParam);

    SetIsaColor (isaUserMax-1, rgco[0].coFore, rgco[0].coBack);
    ListStdMsg (MSG_QeditText1);
    TextOut (pwnd, 0, 0, bufStdMsg, QeditTextLen, isaUserMax-1);
    ListStdMsg (MSG_QeditText2);
    TextOut (pwnd, 0, 1, bufStdMsg, QeditTextLen, isaUserMax-1);

    return (TRUE);
}

/***
*WORD FAR PASCAL DisplayNormalTextWndProc (tmm, pv, hObj, tmc, bArg, wParam)
*Purpose:
*	Display the the "Normal Text" color item in the appropriate color.
*
*Entry:
*	tmm		Unreferenced.
*	pv		pointer to general picture window.
*	hObj		Unreferenced.
*	tmc		Unreferenced.
*	bArg		Unreferenced.
*	wParam		Unreferenced.
*
*Exit:
*	returns TRUE.
*
*Exceptions:
*	None.
*******************************************************************************/
WORD FAR PASCAL
DisplayNormalTextWndProc (tmm, pv, hObj, tmc, bArg, wParam)
TMM	tmm;
char *	pv;		/* really a pwnd */
WORD	hObj, bArg;	/* not used */
TMC	tmc;
WORD	wParam;
{
    REG1 PWND pwnd = (PWND) pv;

    Unreferenced (tmm);
    Unreferenced (hObj);
    Unreferenced (bArg);
    Unreferenced (tmc);
    Unreferenced (wParam);

    ListStdMsg (MSG_NormalText);
    SetIsaColor (isaUserMax-1, rgco[0].coFore, rgco[0].coBack);
    TextOut (pwnd, 0, 0, bufStdMsg, ColoredTextLen, isaUserMax-1);	//[12]

    return (TRUE);
}


/***
*WORD FAR PASCAL DisplayCurStmtWndProc (tmm, pv, hObj, tmc, bArg, wParam)
*Purpose:
*	Display the the "Current Statement" color item in the appropriate color.
*
*Entry:
*	tmm		Unreferenced.
*	pv		pointer to general picture window.
*	hObj		Unreferenced.
*	tmc		Unreferenced.
*	bArg		Unreferenced.
*	wParam		Unreferenced.
*
*Exit:
*	returns TRUE.
*
*Exceptions:
*	None.
*******************************************************************************/
WORD FAR PASCAL
DisplayCurStmtTextWndProc (tmm, pv, hObj, tmc, bArg, wParam)
TMM	tmm;
char *	pv;		/* really a pwnd */
WORD	hObj, bArg;	/* not used */
TMC	tmc;
WORD	wParam;
{
    REG1 PWND pwnd = (PWND) pv;

    Unreferenced (tmm);
    Unreferenced (hObj);
    Unreferenced (bArg);
    Unreferenced (tmc);
    Unreferenced (wParam);

    ListStdMsg (MSG_CurStmt);
    SetIsaColor (isaUserMax-1, rgco[1].coFore, rgco[1].coBack);
    TextOut (pwnd, 0, 0, bufStdMsg, ColoredTextLen, isaUserMax-1);	//[12]

    return (TRUE);
}

/*** 
*WORD FAR PASCAL DisplayBreakpointTextWndProc (tmm, pv, hObj, tmc, bArg, wParam)
*Purpose:
*	Display the the "Breakpoint Lines" color item in the appropriate color.
*
*Entry:
*	tmm		Unreferenced.
*	pv		pointer to general picture window.
*	hObj		Unreferenced.
*	tmc		Unreferenced.
*	bArg		Unreferenced.
*	wParam		Unreferenced.
*
*Exit:
*	returns TRUE.
*
*Exceptions:
*	None.
*******************************************************************************/
WORD FAR PASCAL
DisplayBreakpointTextWndProc (tmm, pv, hObj, tmc, bArg, wParam)
TMM	tmm;
char *	pv;		/* really a pwnd */
WORD	hObj, bArg;	/* not used */
TMC	tmc;
WORD	wParam;
{
    REG1 PWND pwnd = (PWND) pv;

    Unreferenced (tmm);
    Unreferenced (hObj);
    Unreferenced (bArg);
    Unreferenced (tmc);
    Unreferenced (wParam);

    ListStdMsg (MSG_Breakpoint);
    SetIsaColor (isaUserMax-1, rgco[2].coFore, rgco[2].coBack);
    TextOut (pwnd, 0, 0, bufStdMsg, ColoredTextLen, isaUserMax-1);	//[12]

    return (TRUE);
}

/*** 
*VOID NEAR CmdOptnsDisplay ()
*Purpose:
*	Called when OPTIONS/DISPLAY menu item is selected.
*
*Entry:
*	None.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
VOID NEAR CmdOptnsDisplay ()
{
    ushort tabs;
    WORD i;
    HCABOptnsDisplay hcabOptnsDisplay;

    tabs = 0;
    DbAssert (uierr == 0);		//[24]
    hcabOptnsDisplay = (HCABOptnsDisplay) HcabAlloc (cabiCABOptnsDisplay);
    /* [5] Catch HcabAlloc errors */
    if (uierr)
	return;

    (*hcabOptnsDisplay)->oColor = 0;
    (*hcabOptnsDisplay)->oCoFore = (*hcabOptnsDisplay)->oCoBack = 0;

    itoa (GetTabs (), bufStdMsg, 10);
    SzToCab (hcabOptnsDisplay, bufStdMsg, Iag (CABOptnsDisplay, szTabStops));
    // [26] if SzToCab memory allocation failed, free cab and exit.
    if (uierr)
	goto EndCmdOptnsDisplay;
    (*hcabOptnsDisplay)->fScrollBars = fScrollBars;	/* [4] */
    (*hcabOptnsDisplay)->u.sab = (cmdSwitches & CMD_SW_ED) ? sabOptnsQedit : sabOptnsQbas;      //[38]

    if (TmcDoDlgFar (&dlgOptnsDisplay, sizeof (dlgOptnsDisplay), hcabOptnsDisplay) == tmcOk) {
	fOptionsChanged = TRUE;
	for (i = 0; i < 3; i++) {
	    SetIsaColor ((ISA) isaEditWindow+i, rgco[i].coFore, rgco[i].coBack);
	}
	ColorResolution ();			// [36]

	fScrollBars = (*hcabOptnsDisplay)->fScrollBars;
	// [21] Either RemoveScrollBars() or AddScrollBars() will have no effect
	// [21] (depending on the setting of fScrollBars).
	RemoveScrollBars ();
	AddScrollBars ();
      
	/* SetTabs only if greater than zero */
	SzFromCab (hcabOptnsDisplay, bufStdMsg, CB_bufStdMsg,
		   Iag (CABOptnsDisplay, szTabStops));
	/* [22] if user specified -1 convert to -2 so erroneous
	   [22] Can't Set Tabs dialog is not displayed.         */
	if ((tabs = atoi (bufStdMsg)) == -1)	//[22]
	     tabs--;				//[22]
	if (tabs != GetTabs()) {
	    /* user wants to change tab stop setting.
	     * Don't let them if any loaded files had tabs in them.
	     * Otherwise, the user won't get what was expected.  If the
	     * reload the file after changing TABs, everything is fine.
	     * QB doesn't keep TABs in its pcode.
	     */
	    UiRsActivate(UNDEFINED);
	    while (NextMrsFile() != UNDEFINED) {
		if (mrsCur.flags2 & FM2_EntabSource)
		    tabs = UNDEFINED;
	    }
	}
	DrawDebugScr();
    }

    if (tabs == UNDEFINED)
	MsgBoxStd (MB_OK, MSG_CantSetTabs);
    else if (tabs <= 99 && tabs > 0)
	SetTabs (tabs);
EndCmdOptnsDisplay:	// [26]
    FreeCab (hcabOptnsDisplay);
}

/*** 
*VOID NEAR CmdOptnsPaths ()
*Purpose:
*	Called when OPTIONS/PATHS menu item is selected.
*
*Entry:
*	None.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
VOID NEAR CmdOptnsPaths ()
{
    extern bd bdLibPath, bdExePath, bdInclPath, bdHelpPath;
    extern char b$buf1; 		//[32]

    if (!BdRealloc (&bdHelpPath, MAX_SEARCH_PATH )) {
	SetUiErrOm ();
	goto CmdOptnsPathsEnd;
    } 

    DbChkHoldBuf1();
    strcpy (&b$buf1, bdHelpPath.pb);
    if (PromptForString (cmdSwitches & CMD_SW_ED ? MSG_SearchPathEdit : MSG_SearchPathInterp, //[39]
			 (char far *) &b$buf1,			//[39]
			 MAX_SEARCH_PATH) != tmcCancel) {	//[39]
	fOptionsChanged = TRUE;
        strcpy (bdHelpPath.pb, &b$buf1);
        bdHelpPath.cbLogical = (CbSzUi(&b$buf1)) + 1;
    }
    DbChkFreeBuf1();

CmdOptnsPathsEnd:
    return;


}



bool fRightMouseHelp = TRUE;	// [14] default to right mouse help


/*** 
*void near ColorResolution ()
*Purpose:
*	Resolve all color dependencies.
*
*Entry:
*	Global isa's have been just set to their proper values.
*
*Exit:
*	Sets isaCurBreakpoint based on isaCurStmt and isaBreakpoint, and
*	isaIncludeFileHilite based on isaIncludeFileHilite, and isaEditWindow.
*
*Exceptions:
*	None.
*******************************************************************************/
void near ColorResolution ()		// [36]
{
    WORD coFore, coBack, dummy;
    /* for those statements that are both Current & Breakpoint, use:
     *	   the Current statement forground,
     *	   the Breakpoint statement background
     */
    GetIsaColor (isaCurStmt, &coFore, &dummy);
    GetIsaColor (isaBreakpoint, &dummy, &coBack);
    SetIsaColor (isaCurBreakpoint, coFore, coBack);

    /* for those statements that are Highlighted Include file lines, use:
     *	   the Include File Line foreground,
     *	   the Edit Window background
     */
    GetIsaColor (isaIncludeFileHilite, &coFore, &dummy);
    GetIsaColor (isaEditWindow, &dummy, &coBack);
    SetIsaColor (isaIncludeFileHilite, coFore, coBack);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uimsgbox.c ===
/*** 
*uimsgbox.c - Simple Dialog Box management functions
*
*	Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*	Currently just an interface to CW for message boxes, dlgPrompt, and
*	compiler and quick-lib error handling.
*
*******************************************************************************/

/* First, include version definition header */
#include <version.h>

/* Next, include COW's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>
#include <uiext.h>
#include <uinhelp.h>			//[7]

/* include dialog information */
#include <cw/dlg.h>
#include "uimsgbox.hs"
#include "uimsgbox.sdm"

/* Next, include QBI's headers */
#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

ushort NEAR MsgBoxStd2(ushort, ushort, ushort);
void NEAR strspcat (char *, int);
void NEAR MsgBoxCompErr(void);
ushort NEAR MsgBoxPsz(ushort, char *);	//[11]


/* Values setup by runtime for MsgBoxCompErr */
extern ushort b_ErrLin;    /* line # of last runtime error (ERL) */
extern ushort b_fCompErr;  /* Compiler error, set to value of uierr */
extern char far *b_ErrMod; /* far ptr to 0-terminated module name */
extern long b_ErrAdr;      /* far ptr where runtime call was made */

/* BASIC runtime functions */
extern void far B_ASSN(char far *, ushort, char far *, ushort);

void (near pascal *pMsgBoxHook)() = NULL;
char far *fpPFSText;

char szNull;		  //[23] A static NULL string
extern ushort iHelpId;
extern ushort HelpFlags;				//[14]
extern VOID FAR Help(WORD, WORD, VOID *, WORD);		//[7]


/****************************************************************************
* ushort MsgBoxStd2(mbType, iMsg1, iMsg2)
* Purpose:
*  Display a 2 line generic dialog box and wait for user's reply.
*
* Entry:
*  mbType = MB_OK, MB_YESNOCANCEL, or MB_RETRYCANCEL
*  iMsg1 and iMsg2 are standard BASIC message ids (ER_xxx or MSG_xxx)
*     from qbimsgs.h
*
* Exit:
*  returns IDOK, IDYES, IDNO, IDCANCEL, or IDRETRY,
*     depending upon which button was pushed by the user.
*
****************************************************************************/
ushort NEAR MsgBoxStd2(mbType, iMsg1, iMsg2)
ushort mbType;
ushort iMsg1;
ushort iMsg2;
{
    char Msg1[CB_bufStdMsg], Msg2[CB_bufStdMsg];	// [20]

    ListStdMsg (iMsg1);
    strcpy (Msg1, bufStdMsg);
    ListStdMsg (iMsg2);
    strcpy (Msg2, bufStdMsg);		// [19]

    return (UIMessageBox (Msg1, Msg2, NULL, mbType));

} /* MsgBoxStd2 */

/****************************************************************************
* ushort MsgBoxBd(mbType, bdMsg)
* Purpose:
*  Display a generic dialog box and wait for user's reply.
*
* Entry:
*  mbType = MB_OK, MB_YESNOCANCEL, or MB_RETRYCANCEL
*  bdMsg points to a bd (buffer descriptor) for the ASCII message to be
*     displayed.  For example MsgBoxBd(MB_OK, (bd *)&ps.bdErr);
*
* Exit:
*  returns IDOK, IDYES, IDNO, IDCANCEL, or IDRETRY,
*     depending upon which button was pushed by the user.
*
****************************************************************************/
ushort NEAR MsgBoxBd(mbType, bdMsg)
ushort mbType;
bd *bdMsg;
{
    //[9] null terminate the message in bdMsg

    if (BdAppend(bdMsg, &szNull, 1) == 0) {	//[23] try to grow the BD
	MsgBoxStd(MB_OK,ER_OM); 		//[20] ran out of memory, give
						//[20] OM error instead of bdMsg
	return (IDCANCEL);			//[20] return CANCEL to be safe
    }

    return MsgBoxPsz(mbType, bdMsg->pb);	//[11]
}


/****************************************************************************
* ushort MsgBoxPsz(mbType, PszMsg)
* Purpose:
*  Display a generic dialog box and wait for user's reply.
*  Added with revision [11].
*
* Entry:
*  mbType = MB_OK, MB_YESNOCANCEL, or MB_RETRYCANCEL
*  pszMsg points to a string to be displayed.
*
* Exit:
*  returns IDOK, IDYES, IDNO, IDCANCEL, or IDRETRY,
*     depending upon which button was pushed by the user.
*
****************************************************************************/
ushort NEAR MsgBoxPsz(mbType, pszMsg)
ushort mbType;
char *pszMsg;
{
    char Msg[CB_bufStdMsg];			//[21]

    strcpy (Msg, pszMsg);			//[21]
    return (UIMessageBox (Msg, NULL, NULL, mbType));
}

/****************************************************************************
* ushort MsgBoxStdBd(mbType, iMsg, bdMsg)
* Purpose:
*  Display a generic dialog box, with a variable message on 2nd line
*  and wait for user's reply.
*
* Entry:
*  mbType = MB_OK, MB_YESNOCANCEL, or MB_RETRYCANCEL
*  iMsg is a standard BASIC message id (ER_xxx or MSG_xxx) from qbimsgs.h
*  bdMsg points to a bd (buffer descriptor) for the ASCII message to be
*     displayed on 2nd line.
*
* Exit:
*  Caller's grs.oRsCur is preserved.
*  returns IDOK, IDYES, IDNO, IDCANCEL, or IDRETRY,
*     depending upon which button was pushed by the user.
*
****************************************************************************/
ushort NEAR MsgBoxStdBd(mbType, iMsg, bdMsg)
ushort mbType;
ushort iMsg;
bd *bdMsg;
{
    char Msg[CB_bufStdMsg];	//[20]

    iHelpId = iMsg;		//[12] as ListStdMsg may change it if it

    ListStdMsg (iMsg);
    strcpy (Msg, bufStdMsg);	//[19]

    //[9] null terminate the message in bdMsg

    if (BdAppend(bdMsg, &szNull, 1) == 0) {	//[23]
	MsgBoxStd(MB_OK,ER_OM); 		//[20] give OM error instead
	return (IDCANCEL);			//[20] return CANCEL to be safe
    }

    return (UIMessageBox (Msg, bdMsg->pb, NULL, mbType));
} /* MsgBoxStdBd */

/****************************************************************************
* TMC PromptForString(iMsg, fpBuffer, cchMac)
* Purpose:
*   Displays a message box with one message, one edit field, and OK button,
*   and a CANCEL button.
*
* Entry:
*  iMsg - Message to display as prompt
*  fpBuffer - Initial string, and where the result is placed.
*  cchMac - Max length of string to store in fpBuffer.
*
* Exit:
*  returns tmcOK, or tmcCANCEL
*     depending upon which button was pushed by the user.
*  if OK button is pushed
*     Copies the string entered in the edit field to fpBuffer.
*
****************************************************************************/
TMC NEAR PromptForString (iMsg, fpBuffer, cchMac)
ushort iMsg;
char far *fpBuffer;
ushort cchMac;
{
    TMC tmc = tmcCancel;	// [13]
    HCABPrompt hcabPrompt;
    char buffer[128];		//[11] max size of cow edit field

    DbAssert (fDebugScr != 0);

    DbAssert (uierr == 0);	//[11]
    hcabPrompt = (HCABPrompt) HcabAlloc(cabiCABPrompt);
    /* [2] Catch HcabAlloc error */
    if (uierr) {
	return (tmcCancel);	//[26] return error
    }

    iHelpId = iMsg;

    ListStdMsg (iMsg);
    SzToCab (hcabPrompt, bufStdMsg, Iag (CABPrompt, szPromptHeader));
    fstrcpy2 ((char far *) buffer, fpBuffer);			// [6]
    SzToCab (hcabPrompt, buffer, Iag (CABPrompt, szPrompt));	// [6]
    // [13] if SzToCab memory allocation failed, free cab and exit.
    if (uierr)
	goto EndPromptForString;

    if ((tmc = TmcDoDlgFar (&dlgPrompt, sizeof (dlgPrompt), hcabPrompt)) == tmcOK) {
	SzFromCab (hcabPrompt, buffer, cchMac, Iag (CABPrompt, szPrompt));
	fstrcpy2 (fpBuffer, (char far *) buffer);
    }


EndPromptForString:		// [13]
    FreeCab (hcabPrompt);	/* [4] */
    return (tmc);
}

/****************************************************************************
* void MsgBoxCompErr
* Purpose:
*  Display a Compiled Code Runtime Error dialog box
*          +------------------------------------+
*          |      <Runtime error message>       |
*          | In Quick library module: xxxxxxxx  |
*          | At offset: xxxx     ERL: xxxxx     |
*          +------------------------------------+
*  and wait for user's reply.
*
* Entry:
*  uierr = error code (ER_xxx or MSG_xxx from qbimsgs.h)
*  b_ErrLin = line # of last runtime error (ERL)
*  b_ErrMod = far ptr to 0-terminated module name
*  b_ErrAdr = far ptr where runtime call was made
*
****************************************************************************/
#define COMP_ERR_WIDTH 50
#define CB_MOD_NAME 8

void NEAR strspcat (sz, n)
register char *sz;
register int n;
{
    while (*sz++) ;
    --sz;			//[22] back up one char to point at null
    while (n--) *sz++ = ' ';
    *sz = '\0';
}


void NEAR MsgBoxCompErr()
{
    DbAssert(FALSE);		//[24] shouldn't ever get here
} /* MsgBoxCompErr */


/*** 
*VOID NEAR DoDlgGreetingBox ()
*Purpose:
*	Do the Greeting Box dialog.
*
*	If the dialog returns tmcSurvival, display the survival guide in the
*	help window.
*
*Entry:
*	None.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
VOID NEAR DoDlgGreetingBox ()
{
    HCABGreetingBox hcab;

    DbAssert (uierr == 0);	//[11]
    hcab = (HCABGreetingBox) HcabAlloc (cabiCABGreetingBox);
    if (uierr)
	return;

    (*hcab)->u.sab = (cmdSwitches & CMD_SW_ED) ? sabGreetingQedit : sabGreetingQbas;    //[25]
    if (TmcDoDlgFar (&dlgGreetingBox, sizeof (dlgGreetingBox), hcab) != tmcCancel)
	Help (hemWindowHid,helpSurvivalId,0,0);	//[10] display survival help

    FreeCab (hcab);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uinhelp.asm ===
TITLE	uinhelp.asm - utilities for new help engine.
;***
;uinhelp.asm
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	Utilities for the new help system.
;
;
;*******************************************************************************

	.xlist
	include	version.inc
	.list
	UINHELP_ASM = ON


	include cw/version.inc
	include cw/windows.inc
	include cw/edityp.inc

	IncludeOnce architec
	IncludeOnce heap
	Include     help.inc
	IncludeOnce parser
	IncludeOnce prstab
	IncludeOnce rtps
	IncludeOnce qbimsgs
	IncludeOnce ui
	IncludeOnce uiint
	IncludeOnce uimenu		
	IncludeOnce uinhelp		

assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

	subttl	DATA segment definitions.
	page

sBegin	DATA
	externW	iMsgStatusLine		; current status line message
	externW iHelpId 		

; GetHelpMessage and MapLineToContext return codes

	globalB fHelpAlloc,0		; Non-zero if help system is doing
					; a far heap allocation
	BdlTemp	BDL	<>		; temporary BDL owner
	externB	bdlHelp			; BDL for keyword help (def in UIHELP.C)
	externW	szDialogHelpContext	; *sz context of current dialog help


	externB b$Buf1			; FILNAML-sized buffer
	externB b$Buf2			; 16-byte buffer
	HtSpot	EQU	b$Buf2		; Static HotSpot structure

	globalB HelpFlags,0,1		;status of the help system
	globalB HelpFlags2,0,1		;more help system state


;BUFFERING:
;
;   The Help system uses a circular buffer of buffers to hold the
;   text of help messages (called contexts) so that scrolling up
;   and down in a file does not have to be continuously hitting the
;   disk.  The buffers are organized as follows:
;
;	HelpBuffer  : Slot 1 : Slot 2 : Slot 3 : ... : Slot MAX_HELPBUFS :
;
;   Each active slot in the Static HelpBuffer is of type HelpBufType.  The
;   entries in HelpBuffer are organized as a circular list so that they
;   may grow on either end without moving the existing entries.  Each
;   active entry in HelpBuffer represents one context that is currently
;   stored in memory.
;

	staticW oFirstBuf,,1		;Offset of first logical buffer
	staticW oLastBuf,,1		;Offset of last logical buffer
	staticB numBuf,0,1		;number of active buffers in HelpBuffer
	staticB fNoDelBufs,0,1		; are we allowed to delete the
					; buffers during a ShrinkHelp?


	MAX_HELPBUFS	= 9		; Number of entries in HelpBuffer
	BUFSIZE 	= SIZE HelpBufType;The size of the entries in HelpBuffer

	BUFFERSIZE	= MAX_HELPBUFS * BUFSIZE ; Size of HelpBuffer
	staticB	HelpBuffer,0,BUFFERSIZE
	BUFFEREND	EQU (OFFSET DGROUP:HelpBuffer) + (BUFFERSIZE)

	DbPub	HelpBuffer

	globalW iCurRequestLine,UNDEFINED,1 ; line # to get attributes for,
					; or UNDEFINED if no attributes
					; available
	globalW oCurTopic,0,1		; offset to the current topic
					; (0 if no current topic)

	globalW iFileSize,0,1		; Size of current help topic
	externW iStaticHelpTopic	; High word of NC during searches

	externW WndHelp 		; Help Window structure
	externW efHelp			; Editmgr structure for Help Wnd.

;QUEUE MANAGEMENT
;
;  In order to support help history (Ctrl-F1), we keep a LIFO queue
;  of the last 20 items that we requested help on.  The items are stored
;  as a circular list, with a pointer to the next item to be filled in
;  and a count of the number of items that exist.
;
;
;  This list (of type HelpHistEntry) is contained in a BDL, with the first
;  few bytes of the BDL containg a header (type HelpHistHeader) of useful
;  information
;

	BdlHelpHist BDL <>		; BDL for help backup (^F1) list

	ncInitial DD 0			

	HelpHistEntry STRUC
	    HH_HiWord	DW ?
	    HH_LoWord	DW ?
	HelpHistEntry ENDS

	HelpHistHeader STRUC		
	    HH_Used	DW ?		; number of history items in use
	    HH_First	DW ?		; offset into seg of next free item
	HelpHistHeader ENDS		

	NUM_HISTORY	= 20		; number of items that can be saved
	HELPHIST_BEGIN = Size HelpHistHeader  ; offset of first item in segment
	HELPHIST_END   = HELPHIST_BEGIN + NUM_HISTORY * SIZE HelpHistEntry
					; end of the last item

;MAGIC EDIT MANAGER Variables
;
;   The following magic locations in the edit manager are used:
;
;	EfHelp.EF_ipCur_ob     = Current column in help window
;	EfHelp.EF_ipCur_oln    = Current line in help window
;	EfHelp.EF_pdCur_olnTop = Top line of help window
;	EfHelp.EF_pdCur_obleft = Leftmost column of help window
;
;	WndHelp.arcClipping.ayBottomArc, WndHelp.arcClipping.ayTopArc
;		specify the top and bottom of the window.  I believe
;		that they are in screen coordinates.
;
;	One thing to note:  The Edit Manager uses 0 relative coordinates
;	while the helpengine (and variable help) use 1 relative coordinates.
;	Thus, you have to be careful in converting from one to another.
;
;	There are only 2 places that a line or column number is stored:
;	  - Bookmarks (0 relative, as the HelpEngine is not involved)
;	  - iCurRequestLine (1 relative, because it is a HelpEngine line#)
;


;HELP System ENTRY/EXIT conditions
;
;  Anytime that code for the help system is executing, we must have the
;  following conditions met:
;
;	1.)  As close as possible to the point where we could display a
;	     dialog box or message box receiveing ANY input from the user
;	     we must have HLP_INHELP set to prevent recursively entering the
;	     help system.  Currently, this occurs in 2 places:
;		- Displaying "Help File Not Found"
;		- Displaying "INsufficient memory for help system"
;
;	2.)  The help system must be active to the level that is needed to
;	     implement the desired functionality.  There are three levels:
;
;	     a.) Help Engine shut down - No functionality at all possible.
;
;	     b.) Help Engine Active, no current topic.
;		  HLP_GOTBUF is true, but oCurTopic = 0.
;
;	     c.) Help Engine Active, Current topic available.
;
;
;	     The following assumptions and conditions are used in checking
;	     entry conditions:
;
;	     - If the help window is open, we must be at level C.
;	     - If the help window is closed, we may be at A or B.
;	     - If we get a message from the help window, it must be open (C).
;	     - If StartHelp returns 0, you are in either B or C.
;
;	3.)  Any allocation could end up causing CompressHelp to be called.
;	     Thus, there has to be flag set ANYTIME we are in the help system
;	     so that CompressHelp will not yank the help system out from
;	     underneeth itself.  Currenly, there are only 2 entry points
;	     for help:
;		- Help()
;		- HelpWndProc()


sEnd	DATA

	externFP B$IFOUT		; Convert number to string
	externFP HelpOpen		; Misc Help engine routines
	externFP HelpNc
	externFP HelpNcCb
	externFP HelpLook
	externFP HelpDecomp
	externFP HelpXRef
	externFP HelpGetLine
	externFP HelpHlNext
	externFP HelpNcNext
	externFP HelpSzContext
	externFP HelpClose		
	externFP HelpShrink		
	externFP _atoi			; CONSIDE: use runtime call for this
	externFP fEditorActive		
	externFP fQhelpActive



sBegin	UI
assumes CS,UI

	staticB szHelpFileEdit,<"EDIT.HLP",0>	; main help file name
	staticB szHelpFileQhelp,<"HELP.HLP",0>	; qhelp help file name
	staticB szHelpFileInterp,<"QBASIC.HLP",0> ; second help file name

	externNP MoveCursorPwndCur	; Move cursor of current window
	externNP MoveCursorPwnd 	; Move cursor of specified window
	externNP WndHelpOpen		; Open help window to a given size
	externNP WndHelpClose		; Close the help window
	externNP SetHelpKeyword		; put keyword into help syntax menu

	externNP HelpBack		

	subttl	Main Help EntryPoints
	page


;***
;KeywordHelp : Display help for a keyword
;
;Purpose:
;	This routine implements SHIFT-F1.  If the cursor is on a keyword
;	in a window, then display help for this keyword in the help window
;	(opening it if needed). If there is no text selected, or it is
;	not a keyword, then return a non-zero value to indicate that F1
;	should be done.
;
;Entry:
;	None.
;
;Exit:
;	None
;
;Uses:
;	AX,BX,CX,DX
;
;****

cProc	KeywordHelp,<NEAR,PUBLIC>,<SI>	
cBegin
	cCall	StartHelp		; make sure we have the help system
	or	ax,ax			; did we succeed?
	jne	KeywordHelpExit 	; no, just return

	cCall	KeywordHelpLookup	; AX = length of current keyword
					; (text placed in bufStdMsg)
	or	ax,ax			; is there a current keyword?
	jne	CurKeyword		; brif so
Moo:
	cCall	CowMoo			; -- beep speaker & return
	jmp	short KeywordHelpExit	
CurKeyword:

	DbChk	HoldBuf1		; grab B$Buf1

	mov	ax,offset dgroup:bufStdMsg ; where the topic was placed
	mov	bx,offset dgroup:B$Buf1 ; new home for the topic string
	push	bx			; param to DisplayHlpWndSz

	cCall	fstrcpy2,<DS,bx,DS,ax>	


	cCall	DisplayHlpWndSz 	; try to display the help

	DbChk	FreeBuf1		; release the buffer

	or	al,al			; Did we succeed with engine hlp
	je	KeywordHelpExit_Ok	; yes, exit.

	test	al,HELP_HANDLED 	; have we displayed anything to
					; the user?
	jnz	KeywordHelpExit 	; yes, just exit
	jmp	short Moo		; otherwise tell user about it

KeywordHelpExit_Ok:
	mov	[uierr],0		; clear any leftover errors
KeywordHelpExit:
cEnd

;***
;KeywordHelpLookup : Find help for a keyword
;
;Purpose:
;	Added with revision [5].
;
;	Looks up the keyword, enables/disables the HelpSyntax menu item, and
;	puts the keyword into the HelpSyntax menu item.
;
;Entry:
;	None.
;
;Exit:
;	AX : =0 if no keyword was found
;	    length of keyword (NZ) if keyword was found
;Uses:
;	AX,BX,CX,DX
;
;****

cProc	KeywordHelpLookup,<NEAR,PUBLIC>
cBegin

	mov	ax,offset dgroup:bufStdMsg
	mov	bx,10			; maximum length of word  (10 is magic)
	mov	cx,GEW_HELPMASK 	; do not include . or ! in search
	cCall	GetEditWordMask,<ax,bx,cx> ; AX = length of word retrieved
	push	ax			; save for return value

	; enable/disable help syntax menu item based on AX (0 ==> disable)
	or	ax,ax			; if NZ, set low bit for stupid-ass
	jz	disableit		; COW C function
	mov	al,1
disableit:
	mov	bx,midHelpSyntax
	cCall	EnableMenuItem,<bx,ax>

	; copy current topic name into help syntax menu buffer
	mov	ax,offset dgroup:bufStdMsg
	cCall	SetHelpKeyword,<ax>

	pop	ax			; return AX = length of keyword
cEnd



;***
;SelectHotLink - Go to the hot link that is specified in the window coords
;
;Purpose:
;	Look in the help file given by the line number and column
;	number.  If there is a hot link at this position, go to the item
;	that it links to.  Otherwise, just returns.
;
;Entry:
;	(rx,ry) - virtual line coordinates of the location of a
;		  supposive hot spot.
;	beep	- TRUE if we are suspose to beep when we don't find anything
;
;Exit:
;	AX = 0 (FALSE) if a hot link was selected
;
;Uses:
;	Per Convention
;****

cProc	SelectHotLink,<PUBLIC,NEAR>,<SI,DI>
parmW	rx
parmW	ry
parmB	GiveBeep
cBegin

	;Since we got a keyboard message from the help window, it must be
	;open, therefor we must be initialized.

	DbAssertTst HelpFlags,ne,HLP_GOTBUF,UI,<SelectHotLink:Buffers Not Initialized>


	DbChk	HoldBuf2		; lock down the HotSpot
	DbChk	HoldBuf1		; for composed hotlink names

	mov	bx,oCurTopic		; get ptr to topic
	lea	bx,[bx].bdlHelpText.BDL_seg ; BX = handle to data seg
	mov	cx,rx
	inc	cx			; make column 1 relative
	mov	HtSpot.colHS,cx 	
	mov	cx,ry			; get line number
	inc	cx			; make it 1 relative
	mov	HtSpot.lineHS,cx	; and stick in HotSpot structure
	mov	ax,OFFSET DGROUP:HtSpot
	xor	cx,cx
	and	HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM) ; clear errors
	cCall	HelpXRef,<BX,CX,DS,AX>	;Get context string for topic
	or	ax,ax			; did we get a topic
	jnz	GotSelection		; yes, go display it
	test	HelpFlags,HLP_FAILFNF OR HLP_FAILOOM ; is error handled?
	jnz	NoBeep			; yes, do not beep
SelectHotLink_Beep:
	cmp	GiveBeep,0		; should we give a beep?
	je	NoBeep			; no, just exit with error code
	cCall	CowMoo			; beep cow's speaker
NoBeep:
	mov	ax,sp			; return with non-zero value
	DbChk	FreeBuf2		; release the HotSpot
	DbChk	FreeBuf1		;  and our other buffer
	jmp	short NoSelection	; and exit

GotSelection:
	;Copy context string into free part of Buf2 and display it in a help
	;window. The source string is in HtSpot.pXrefHS and is 0 terminated
	;We can not use the source directly, as it points into a BDL, and
	;we are not guarenteing a locked heap.

	push	ds				; set ES = DS = DGROUP
	pop	es				
	mov	di,offset dgroup:b$buf1 	; ES:DI = destination
	push	di				; parm for DislplayHlpWnd
	lds	si,DWord Ptr HtSpot.pXrefHS	; DS:SI = source

CopyLoop:
	lodsb					; copy the byte
	stosb					
	or	al,al				; is it the 0 termiantor
	jne	CopyLoop			; no, do next byte
	lodsw					; Copy next word
	stosw					; incase it was local

	push	es				; restore DGROUP
	pop	ds				

	DbChk	FreeBuf2			; release the HotSpot

	; Check to see if the context is !B.  If it is, then we should
	; execute a HelpBack command instead of displaying the context

	cmp	WORD PTR b$Buf1,'B!'		; is it !B?
	jne	NotHelpBack			; no, go display it
	cmp	BYTE PTR b$Buf1+2,0		; is it 0 terminated?
	jne	NotHelpBack			; no, go display it
DbAssertRel	pwndAct,e,<OFFSET DGROUP:wndHelp>,UI,<SelectHotLink:Not in help window>
	pop	ax				; restore stack (param to
						;  DisplayHlpwndSz not used)
	xor	ax,ax				; move to (0,0) so we will
	cCall	MoveCursorPwndCur,<ax,ax>	; goto previous topic
	DbChk	FreeBuf1			; incase HelpBack wants it
	call	HelpBack			; do the help back
	jmp	short ExitSuccess		; and exit

NotHelpBack:
	cCall	DisplayHlpWndSz 		; display text
DbAssertRelB	al,ne,HELP_NF,UI,<SelectHotLink:Returned hot link not found>
						;ignore any errors
	DbChk	FreeBuf1			; release context string

ExitSuccess:
	xor	ax,ax				; return value of success
						; this way we will not put
						; up an error box, then
						; do something useful.
NoSelection:

cEnd



;Rewrote with [5]
;***
;FillContextNext - Fill the next buffer with the desired context information
;
;Purpose:
;	Read a help context into the help buffer given the position that
;	is previous to it.  The information needed for the new context
;	is obtained from the context given.  This routine will read in
;	as many contexts as desired.
;
;	Note: this routine does not return any errors, as its caller
;	does not check the error code (this is used to fill the buffer
;	with topics after the current topic, so if we could not read
;	in a topic for any reason, then we will just leave the buffer
;	partially empty).
;
;Entry:
;	BX = current buffer
;	DI = number of context to read
;
;Exit:
;	oLastBuf = Last valid buffer
;	numBuf updated
;
;****

cProc	FillContextNext,<NEAR>,<DI>
cBegin

DbAssertRelB	fNoDelBufs,ne,0,UI,<FillContextNext:Caller did not set fNoDelBufs>


cEnd


;Added with [5]
;***
;GetHelpMsgNcFill - get a help message from a context number, fill in fields
;
;Purpose:
;	Calls GetHelpMsgNc, and fills in all the fields of the buffer except
;	for the first line number of the context.
;
;Entry:
;	DX:AX = context number to be filled in
;	BX = ptr to context
;Exit:
;	if (AL = 0)
;	    BX = ptr to context
;	    all fields of context are filled in
;	else
;	    AL = HELP_HANDLED.
;
;****
cProc	GetHelpMsgNcFill,<NEAR>
cBegin
	push	bx				; We need to preserve BX
	mov	Word Ptr [bx].ContextNum,ax	; save Context Num in Buffer
	mov	Word Ptr [bx].ContextNum+2,dx
	lea	cx,[bx].bdlHelpText		; point to BLD
	cCall	GetHelpMsgNc,<dx,ax,cx> 	; get message
						; (AL = return code)
	pop	bx				; BX = *Buffer

Fill_Exit:
cEnd

;***
;GetHelpMsgSz - get a help message from a context string
;GetHelpMsgNc - get a help message from a context number
;
;Purpose:
;	This routine calls the help engine to obtain the help text
;	associated with a context string.  The text is returned in a BDL.
;	No buffering of the help context is performed.
;
;	NOTE: Does not require oFirstBuf or oLastBuf to be set.
;
;Entry:
;	szContext : pointer to context string
;	BdlText : pointer to bdl owner structure.
;
;Exit:
;	AL = HELP_OK (0) if success.
;	AL = HELP_HANDLED, HELP_NF
;
;Uses:
;	Per convention
;
;Exceptions:
;	
;****
cProc	GetHelpMsgSz,<NEAR,PUBLIC>
parmW	szContext
parmW	BdlText
cBegin
DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<GetHelpMsgSz:HLP_GOTBUF false>
	mov	ax,szContext		; AX = context string
	cCall	CalcNc,<AX>		; DX:AX = nc for context string
	jcxz	GetHelpMsgSzExit	; return with error code (AL) if error

	cCall	GetHelpMsgNc,<DX,AX,BdlText> ; get message
GetHelpMsgSzExit:
cEnd

DbPub	GetHelpMsgNc
cProc	GetHelpMsgNc,<NEAR>,<SI,DI>
parmW	ncHigh
parmW	ncLow
parmW	BdlText
cBegin
DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<GetHelpMsgNc:HLP_GOTBUF false>
DbAssertRelB	fHelpAlloc,ne,0,UI,<GetHelpMsgNc:fHelpAlloc not set>

	mov	di,ncHigh		;set DI:SI to context string
	mov	si,ncLow

	and	HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM) ; clear flags

	cCall	HelpNcCb,<DI,SI>	; AX = #bytes for decompressed topic

	xchg	ax,cx					; save size in CX
	test	HelpFlags,HLP_FAILFNF OR HLP_FAILOOM	; did we fail it?
	mov	al,HELP_HANDLED 			; assume so
	jnz	GetHelpMsgNcExit_Near			; exit if error

	mov	bx,offset DGROUP:BdlTemp
	cCall	BdlAlloc,<BX,CX>	; alloc bdl for compressed data
	or	ax,ax			; OOM error?
	jz	GetHelpMsgOOM		; yes, go handle it

	lea	bx,[BdlTemp.BDL_seg]	; BX = handle to data segment
	xor	ax,ax			; offset 0
	cCall	HelpLook,<DI,SI,BX,AX>	; AX = # bytes uncompressed
	xchg	cx,ax			; CX = # bytes uncompressed
	jcxz	FreeExitError		; brif error -- release bdl & exit

	inc	fNoDelBufs		; don't delete buffers

	mov	bx,BdlText		; bx = *BDL owner
	cCall	BdlAlloc,<BX, CX>	; alloc BDL for uncompressed data
	or	ax,ax			; ZF ==> error
	jnz	DecompressHelp		; no error, go decompress help topic
	cCall	GiveHelpOOM		; generate OOM error
	dec	fNoDelBufs		; restore buffer flag
	jmp	short FreeExitError	; free Bdl and exit

GetHelpMsgOOM:
	cCall	GiveHelpOOM		; signal an OOM error
	mov	al,HELP_HANDLED 	
GetHelpMsgNcExit_Near:			
	jmp	Short GetHelpMsgNcExit	; brif so -- give error and exit

DecompressHelp:
DbAssertTst	HelpFlags,z,HLP_NOSHRINK,UI,<GetHelpMsgNc:NOSHRINK set>
	or	HelpFlags,HLP_NOSHRINK	; don't shrink during HelpDecomp
					; otherwise it will fail.
	mov	bx,BdlText		; bx = *BDL owner (could have moved)
	xor	ax,ax			; offset 0
	lea	dx,[BX].BDL_seg 	; DX = handle of destination seg
	lea	bx,[BdlTemp.BDL_seg]	; BX = handle of source segment
	cCall	HelpDecomp,<BX,AX,DX,AX,DI,SI>
					; decompress help text
	dec	fNoDelBufs		; reset buffer delete flag
	and	HelpFlags,NOT HLP_NOSHRINK ; reenable shrinking.

	or	ax,ax			; did we get an error?
	jz	FreeExit		; no, free temp BDL and exit
	mov	ax,BdlText		; get pointer to bdl
	cCall	BdlFree,<AX>		; and deallocate it

	test	HelpFlags,HLP_FAILOOM or HLP_FAILFNF ; have we reported?
	jnz	FreeExitError		; yes, get return code
	cCall	GiveHelpOOM		; report the error.

FreeExitError:
	mov	al,HELP_HANDLED 	; prepare to return error

FreeExit:
	push	ax			; save return code
	mov	ax,OFFSET DGROUP:BdlTemp
	cCall	BdlFree,<AX>		; release compressed data

	pop	ax			; AX = return code (NZ ==> success)

GetHelpMsgNcExit:

cEnd


	subttl	Display Text in the Help Window

;Rewrote with [5]
;***
;DisplayHlpWndSz - Display help in a window given a context string
;DisplayHlpWndNc - Display help in a window given a context number
;
;Purpose:
;	Displays a context in the help window given either a context
;	string (DisplayHlpWndSz) or a context number (DisplayHlpWndNc).
;	This routine will open the help window if it is not already
;	opened.
;
;Entry:
;	szContext : pointer to a context string  (DisplayHlpWndSz)
;			   or
;	DX:AX	  : context number		 (DisplayHlpWndNc)
;
;Exit:
;	AL = error code (HELP_OK, HELP_HANDLED, HELP_NF)
;
;Uses:
;	Per Convention
;
;****

cProc	DisplayHlpWndSz,<PUBLIC,NEAR>
parmW	szContext
cBegin

DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<DisplayHlpWndSz:HLP_GOTBUF false>

	mov	ax,szContext		;AX = context string
	cCall	CalcNc,<AX>		; DX:AX = nc for context string
	jcxz	HlpWndSzExit		; there was an error, exit
	cCall	DisplayHlpWndNc 	;display help for this context number

HlpWndSzExit:				;AL = return code
cEnd


cProc	DisplayHlpWndNc,<PUBLIC,NEAR>
cBegin

DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<DisplayHlpWndNc:HLP_GOTBUF false>

	cCall	BufferNc		; BX = ptr to new context
	or	al,al			; was there an error?
	jne	DisplayFailure		; yes, exit with error code

	push	bx			; save buffer pointer
	mov	dx,Word Ptr [bx].ContextNum+2  ; Get context number into
	mov	ax,Word Ptr [bx].ContextNum    ;  DX:AX
	cCall	RecordHelpHistory	; record context number for Ctrl-F1
	pop	bx			; restore buffer pointer

	lea	ax,[bx].bdlHelpText	
	push	ax			; save for call to GetHelpContextLen
	cCall	SizeHelpContext,<ax>	; get # lines in the help topic
					; sets iFileSize
	cCall	GetHelpContextLen	; AX = get suggested size of wnd
	cCall	OpenHelpWindow		; go open the window (to size AX)
	cCall	DrawDebugScr		; force help title to be redrawn

	xor	ax,ax			; return 0 for no-errors

DisplayFailure:
	cCall	CloseCurHelpFile	; shut down current help file, if
					; any opened. (preserves AX, DX)
cEnd




;***
;BufferNc - Given a context number, properly buffer in context
;
;Purpose:
;	This routine will refill the help buffer so that Nc is
;	present.  If Nc did not exist, the buffer is flushed and
;	refilled.
;
;Entry:
;	DX:AX	: Context number to be buffered
;
;Exit:
;	if (successful)
;		AL = HELP_OK  (=0)
;		BX = new buffer ptr
;		numBuf updated
;		oCurTopic = BX
;	else
;		AL = HELP_HANDLED
;
;****
cProc	BufferNc,<PUBLIC,NEAR>,<DI>
cBegin

	;See if the context number is already buffered

	xor	cx,cx
	mov	cl,numBuf		; scan numBuf contexts
	jcxz	DelNoBufs		; special case this...LOOP can't
	mov	bx,oFirstBuf		; Start at first context
CheckNext:
	cmp	ax,Word Ptr [bx].ContextNum ; check low word first
	jne	TryToLoop		; comparison failed, goto next one
	cmp	dx,Word Ptr [bx].ContextNum+2 ; check high word
	jne	TryToLoop		; comparison failed, goto next one
	jmp	FoundMatch		; we have the context already buffered
TryToLoop:
	add	bx,BUFSIZE		; move to next logical buffer
	cmp	bx,BUFFEREND		; did we go off the end?
	jb	Wrap5			; no, continue
	sub	bx,BUFFERSIZE		; adjust back to begining
Wrap5:
	loop	CheckNext		; try the next context

NotBuffered:

	
	; # buffers to free = # needed - # free
	;		    = MAX_HELPBUFS / 2 - (MAX_HELPBUFS - numBufs)
	;		    = numBufs - (MAX_HELPBUFS / 2)
	
	mov	cl,numBuf		; Calculate # buffers to delete
	sub	cl,MAX_HELPBUFS /2	
	ja	DelSomeBufs		; brif a positive number
	xor	cl,cl			; delete 0 buffers (makes
DelSomeBufs:				; oCurTopic == oLastTopic)
	xor	ch,ch			; CBW for CX
	push	ax			; save the context number
	push	dx
	call	FlushBuffer		; delete CX current contexts
	pop	dx			; restores context number
	pop	ax

DelNoBufs:
DbAssertRelB	numBuf,be,MAX_HELPBUFS,UI,<BufferNc: No buffers free after deleting some>

	mov	bx,oLastBuf		; Ptr to last buffer used
	cmp	numBuf,0		; stupid special case?
	jne	UseoLastBuf		; no, index off of oLastBuf
	mov	oFirstBuf,bx		; oFirstBuf = oLastBuf
	jmp	short NoWrap6		
UseoLastBuf:
	add	bx,BUFSIZE		; point to the next one
	cmp	bx,BUFFEREND		; did we go off the end?
	jb	NoWrap6 		
	sub	bx,BUFFERSIZE		
NoWrap6:
	cCall	GetHelpMsgNcFill	; get the help topic
	or	al,al			; any errors?
	jne	BufferNc_Exit		; yes, exit with error code

	inc	numBuf			; indicate one more buf in use

	;Fill the rest of the buffer with contexts after this one

	inc	fNoDelBufs		; do not delete buffers to get these
	mov	ax,MAX_HELPBUFS
	sub	al,numBuf		; AX = number of buffers free
	push	bx			; save it for exit
	xchg	di,ax			; set DI = number of free buffers

	mov	oLastBuf,bx		;set oLastBuf = last legal buffer

FillAnotherNext:
	mov	dx,Word Ptr [bx].ContextNum+2 ; DX:AX = current NC
	mov	ax,Word Ptr [bx].ContextNum
	push	bx
	cCall	GetNextNc		
	pop	bx
	je	FillContextDone 	; no more contexts

	add	bx,BUFSIZE		;Point BX at next buffer
	cmp	bx,BUFFEREND		; did we go off end of buffer?
	jb	NoWrap3 		;no, continue
	sub	bx,BUFFERSIZE		;wrap around to begining
NoWrap3:
	cCall	GetHelpMsgNcFill	;get message DX:AX into *(BX)
	or	al,al			; did an error occur
	jne	FillContextDone 	; yes, stop filling in buffers

	mov	oLastBuf,bx		; set oLastBuf = last legal buffer
	inc	numBuf			;record that a buffer is now in uses
	dec	di			;one more context use
	jne	FillAnotherNext 	;get another one if allowed
FillContextDone:

	;Ignore any errors, we have at least one buffer
	mov	uierr,0 		; clear any errors
	pop	bx			; pointer to buffer with our context

	dec	fNoDelBufs		; reset buffer delete pointer

FoundMatch:
	xor	ax,ax			; ax = 0 (no errors)
	mov	oCurTopic,bx		; update current buffer ptr.

BufferNc_Exit:
cEnd

;Rewrote with [45]
;***
;OpenHelpWindow - Open the help window and ready it to print text
;
;Purpose:
;	This routine will not only open the help window to the correct
;	size, but will adjust the size of the window to account
;	for the existance/non existance of the scroll bar.
;
;Entry:
;     ax = Size of window
;
;Exit:
;     None.
;****

DbPub OpenHelpWindow
cProc OpenHelpWindow,<NEAR>
cBegin
	cmp	pwndAct,OFFSET DGROUP:WndHelp ; in help window?
	je	InHelpWindow		; no, do not resize

	inc	ax			; add a line for scroll bar
InHelpWindow:
	cCall	WndHelpOpen,<AX>	; AX = actual size of window

	; We must always move the cursor to (0,0), otherwise the edit
	; manager may not realize that this is a new topic and would not
	; position it so that the first line is visible.

	xor	bx,bx			; cursor position is 0,0
	mov	ax,OFFSET DGROUP:wndHelp; window to receive the message
	push	ax			; save for second call
	cCall	MoveCursorPwnd,<AX,BX,BX> ; goto 0,0 in window

	cCall	GetInitialPos		; get initial position on screen

	cCall	MoveCursorPwnd,<DX,AX>	; goto hot link spot
cEnd

;***
;GetInitialPos - Calculate the initial cursor position in the help window
;
;Purpose:
;	Returns the initial cursor position in the help window.  This is
;	the (0 relative) coordinates of the first hot link (if it exists
;	and is visible), or (0,0).
;
;Entry:
;	None
;
;Exit:
;	(DX,AX) - initial Row/Column of the screen (0,0) or first hot spot
;
;Uses:
;	Per C Convention.
;****
cProc	GetInitialPos,<PUBLIC,NEAR>
cBegin
	DbChk	HoldBuf2		; lock down the hotspot

	test	HelpFlags,HLP_VARHELP	; are we in var help?
	jnz	Use00			; yes, there are no hotlinks

	mov	ax,1			; current row/column position
	mov	HtSpot.ColHS,ax 	
	mov	HtSpot.lineHS,ax	

DbAssertRel	oCurTopic,ne,0,UI,<GetInitialPos:oCurTopic invalid>
	mov	bx,oCurTopic
	lea	bx,[bx].bdlHelpText.BDL_seg
	mov	cx,OFFSET DGROUP:HtSpot
	dec	ax			; ax = 0
	cCall	HelpHlNext,<AX,BX,AX,DS,CX>
	or	ax,ax			; did we get a hot link?
	je	Use00			; no, use (0,0) as position
	mov	ax,HtSpot.ColHS 	; get position of hotlink
	mov	dx,HtSpot.lineHS	
	dec	dx			; make position 0 relative
	dec	ax
	
	; Make sure the hot link is visible.
	
	mov	cl,WndHelp.arcClipping.ayBottomArc
	sub	cl,WndHelp.arcClipping.ayTopArc ; CX = size of help window

	cmp	cl,dl			; within visible range?
	jae	GetInitialPos_Exit	; no, ignore the hotlink
Use00:
	xor	dx,dx
	xor	ax,ax

GetInitialPos_Exit:
	DbChk	FreeBuf2		; release HotSpot
cEnd

	subttl	Edit Manager Support Routines
	page



;Extracted and modified with revision [29].
;***
;GetHelpTitleStr - Returns the title for a given help topic
;
;Purpose:
;	Calculates the title, and returns it in bufStdMsg.
;	All titles are prefixed by "HELP: ".
;
;	Uses the ":n" information if the help file, if it exists.
;	Otherwise, returns the current context string.
;
;Entry:
;	pHelpBdl = *bdl containing decompressed help topic.
;	cbMaxSize = max title length allowed
;
;	If window help, curNc is the help context #
;	If dialog box help, szDialogHelpContext points to the current szContext
;
;Exit:
;	AX = number of characters in title
;	bufStdMsg = contains title.
;
;Uses:
;	Per Convention
;
;****
cProc	GetHelpTitleStr,<NEAR,PUBLIC>,<SI,DI>
parmW	pHelpBdl
parmW	cbMaxSize
cBegin

DbAssertTst	HelpFlags,nz,HLP_GOTBUF,UI,<GetHelpTitleStr:HLP_GOTBUF false>

	inc	fNoDelBufs		; do not delete buffers, we have
					; a generic ptr to a buffer

	; Setting fNoDelBufs is probably not needed as currently
	; pHelpBdl points to either oCurTopic or to a static
	; Bdl used by dialog help.	However, I doubt that we do any
	; allocs in this code, and I can not guarentee that pHelpBdl
	; is safe.


	mov	ax,MSG_HelpTitleQH	; first part of title ("MS-DOS Help: ")
	test	cmdSwitches,CMD_SW_QHELP ; /QHELP viewer?
	jnz	ghts1			;   YES, got title

	mov	ax,MSG_HelpTitle	; first part of title ("HELP: ")
ghts1:
	cCall	ListStdMsg,<AX> 	; put in bufStdMsg

	push	ax			; save length of static portion
	add	ax,OFFSET DGROUP:bufStdMsg ; ds:di = useful buffer
	xchg	di,ax
	mov	al,'n'			; look for ":nTITLE"
	cCall	GetHelpControlInfo,<pHelpBdl,cbMaxSize,ax> ; SI = *embedded title, if any
	or	si,si			; title found?
	jnz	AppendTitle		; brif so

	mov	si,szDialogHelpContext	; use current context string as title
					; for dialog box help
	cmp	pHelpBdl,offset DGROUP:bdlHelp	; title for dialog box help?
	je	AppendTitle		; brif so -- append string to title

	mov	bx,oCurTopic		; ptr to current topic data
	or	bx,bx			; is it valid?
	je	GetHelpTitleStr_Fail	; no, use MSG_HelpTitle for now

	push	ds			;push far address to load szContext
	push	di
	push	Word Ptr [bx].ContextNum+2 ; push context number
	push	Word Ptr [bx].ContextNum
	cCall	HelpSzContext		;Get text
	or	ax,ax			; did we succeed?
	je	GetHelpTitleStr_Fail	; no, exit with error

	;Strip off the filename at the begining of the context

	cCall	szSrchExcl,<di> 	; search for '!' in *di
	DbAssertRel ax,ne,0,UI,<GetHelpTitleStr: Illegal string from HelpSzContext>
	inc	ax			; point to chr beyond '!'
	xchg	si,ax			;di = *buffer, si = *szContext

AppendTitle:				; append title to bufStdMsg
					; DS:SI= *title
					; DS:DI= where to put it

	pop	bx			; BX = length of static portion
	push	ds			; ES = DS for string ops
	pop	es			

AnotherChar:				
	lodsb				; append szTitle to "HELP:" in
	stosb				; bufStdMsg
	inc	bx			; seen another char
	or	al,al			; more chars to do?
	jnz	AnotherChar		; brif so
	dec	bx			; don't  include NULL in count

	cmp	bx,cbMaxSize		; is it larger than we want to return
	jbe	GetHelpTitleStr_Exit	; no, exit
	mov	bx,cbMaxSize-1		; return maximum size (without NULL)
	mov	byte ptr [bufstdMsg+bx+1],al ; truncate the string

GetHelpTitleStr_Exit:			
	xchg	ax,bx			; return count in AX

	SKIP1_PSW			; skip the pop ax
GetHelpTitleStr_Fail:			
	pop	ax			; get length in case of error
	dec	fNoDelBufs		; reenable buffer deletes.
	DbAssertRel ax,be,cbMaxSize,UI,<GetHelpTitleStr: title too big>
cEnd

;Added with revision [29].
;***
;GetHelpContextLen - Returns the length to use for a given help topic
;
;Purpose:
;	Returns the suggested # lines to use to display a topic.
;	Uses ":lLENGTH" if it exists. Otherwise, returns the total # lines
;	in the topic.
;
;Entry:
;	pHelpBdl = *bdl containing decompressed help topic.
;
;Exit:
;	AX = number of lines to use
;
;Uses:
;	Per Convention
;
;****
cProc	GetHelpContextLen,<NEAR,PUBLIC>,<SI,DI>
parmW	pHelpBdl
cBegin
	inc	fNoDelBufs		; do not delete buffers, we have
					; a generic ptr to a buffer

	; Setting fNoDelBufs is probably not needed as currently
	; pHelpBdl points to either oCurTopic or to a static
	; Bdl used by dialog help.	However, I doubt that we do any
	; allocs in this code, and I can not guarentee that pHelpBdl
	; is safe.

	mov	di,OFFSET DGROUP:bufStdMsg ; ds:di = useful buffer
	mov	cx,6			; max len we care about
	mov	al,'l'			; look for ":l<LENGTH>"
	cCall	GetHelpControlInfo,<pHelpBdl,cx,ax> ; SI = *embedded len,
	or	si,si			; length found?
	jz	GetTotalLines		; brif not -- get the line count

	push	si			; arg on stack
	call	_atoi			; AX = result
	pop	bx			; clean stack (C calling conventions)
	jmp	SHORT GetHelpContextLen_Exit

GetTotalLines:
	cCall	SizeHelpContext,<pHelpBdl> ;AX = # lines in context
					; sets iFileSize

GetHelpContextLen_Exit:
	dec	fNoDelBufs		 ; reenable buffer deletes.
cEnd


;Extracted and modified with revision [29].
;***
;GetHelpControlInfo
;
;Purpose:
;	Returns the control information in a given help context, if any.
;
;Entry:
;	pHelpBdl = * bdl containing decompressed help topic
;	cbMaxSize = biggest line to get.
;	cChar = control char to look for (usually 'n' or 'l').
;
;	DS:DI = * place to put result
;
;Exit:
;	DS:SI = * embedded help control info
;
;Uses:
;	Per convention, plus SI
;****

cProc	GetHelpControlInfo,<NEAR>
parmW	pHelpBdl		; * bdl of current help context
parmW	cbMaxSize		; biggest string allowed
parmW	cChar			; control char to search for (l or n)
cBegin

DbAssertRelB	fNoDelBufs,ne,0,UI,<GetHelpControlInfo:fNoDelBufs not set>

	; This routine does not have to worry about error handling for
	; HelpGetLine.	If there is any error in trying to get the
	; proper line, we will just assume that there were no more
	; lines.

	mov	bx,pHelpBdl	; BX = *bdl of current help topic

	GETSEG	es,[bx].BDL_seg,bx,SIZE	; ES = context data segment
	mov	ax,-1			; AX = undefined for blasting help
	mov	es:[lnCurTH],ax 	; reset current line counter
					; so engine doesn't get confused
	xchg	es:[linCharTH],al	; don't ignore any lines
	push	ax			; save line rejection char

	xor	si,si			; start at line 0

AnotherLine:
	inc	si			; advance to next line
	lea	bx,[bx].BDL_seg 	; BX = handle of data segment
	xor	ax,ax			; AX = context data offset (0)
	cCall	HelpGetLine,<si,cbMaxSize,ds,di,bx,ax>
	mov	bx,pHelpBdl		; BX = *bdl of current help topic
	or	ax,ax			; any more lines?
	jz	NoEmbeddedInfo		; brif not
	mov	ax,[di]			; AX = first 2 chars
	cmp	al,':'			; ":" command?
	jne	NoEmbeddedInfo		; brif not -- they must come first
	cmp	ah,byte ptr (cChar)	; the one we are searching for?
	jne	AnotherLine		; brif not -- get another line

	mov	si,di			; DS:SI = *szTitle
	inc	si			; skip the ":"
	inc	si			; skip the control char
	SKIP2_PSW			; skip the XOR SI,SI
NoEmbeddedInfo:
	xor	si,si			; no szTitle found
	pop	ax			; restore old line rejection char
	GETSEG	es,[bx].BDL_seg,bx,SIZE ; ES = context data segment
	xchg	es:[linCharTH],al	; restore old line rejection char
DbAssertRel	AX,E,-1,UI,<GetHelpControlInfo: AX should be -1>
	mov	es:[lnCurTH],ax 	; reset current line counter
					; so engine doesn't get confused

cEnd

;***
;SizeHelpContext
;
;Purpose:
;	Added with revision [2].
;
;	Returns total # of lines of help text for a given context, for use
;	in dialog box re-sizing, and scroll bar updating.
;
;
;Entry:
;	bdlText	= * BDL containing a decompressed help context.
;
;Exit:
;	AX = iFileSize = # lines of help text present in this context.
;
;Uses:
;	Per Convention
;
;****

cProc	SizeHelpContext,<PUBLIC,NEAR>,<SI,DI>
ParmW	bdlText
cBegin
	mov	di,bdlText			; DI = *context BDL
	xor	si,si				; SI = count of # lines

Again:
	inc	si				
	mov	cx,offset DGROUP:bufStdMsg	; CX = &dummy sz
	mov	dx,CB_bufStdMsg			; DX = cbMax
	xor	ax,ax				; AX = context data offset (0)
	lea	bx,[di].BDL_seg 		; BX = handle of data seg
	cCall	HelpGetLine,<SI,DX,DS,CX,BX,AX>	
	or	ax,ax				; success?
	jnz	Again				; brif so -- try again

	xchg	ax,si				; AX = # lines + 1
	dec	ax				; return AX = # lines
	mov	iFileSize,ax			; save # lines
cEnd


;***
;CmdHelpClose - Close the help window (from ESC)
;
;Purpose:
;	Close the help window.	Attached to the ESC accelerator.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per C Convention
;
;****

cProc	CmdHelpClose,<PUBLIC,NEAR>
cBegin
	mov	oCurTopic,0		; indicate no valid help
	cCall	WndHelpClose		; close the window
cEnd


	subttl	Miscellanious Help Routines
	page

;***
;GetNextNc	- Advance a NC to the next topic
;
;Purpose:
;	Get the next physical context number given a context num.
;	Will not wrap from one file to another.
;
;Entry:
;	DX:AX = current context number
;
;Exit:
;	if ZF set (zero)
;	   No next topic
;	   CX = 0
;	   AL = error code	(HELP_HANDLED, HELP_NF)
;	else
;	   DX:AX is context number
;	   CX != 0
;
;Uses:
;	Per C Convention
;
;****

cProc	GetNextNc,<PUBLIC,NEAR>
cBegin
	and	HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM); clear errors
	push	dx				; value to compare against
	push	dx				; push current context number
	push	ax
	cCall	HelpNcNext			; get next Context Num
	pop	bx
	cmp	bx,dx				; is it in a different file?
	jne	GetNextNc_Err			; yes, give error
	mov	cx,ax				; check if no more contexts
	or	cx,dx				; NZ & CX != 0 if no error
	jnz	GetNextNC_exit			; exit if success
GetNextNc_Err:
	mov	al,HELP_HANDLED 		; assume handled error
	test	HelpFlags,HLP_FAILFNF OR HLP_FAILOOM ; was it?
	jnz	GetNextNc_Err2			; yes, use this code
	mov	al,HELP_NF			; context not found
GetNextNc_Err2:
	xor	cx,cx				; set CX = 0, ZF
GetNextNc_exit:
cEnd


;***
;CreateContext - convert a number into a context string
;char *(NEAR CreateContext(iContextNumber ))
;
;Purpose:
;	This routine takes a number and an initial character and
;	creates a context string out of it. The context string will
;	be of the form	"-1234" were '-' is the character and "1234"
;	is an ASCII representation of the number.  The string is
;	returned in a static buffer.
;
;	The number must be 0 < iContextNumber < 32768
;
;Entry:
;	iContextNumber : integer which will be remaining digits
;
;Exit:
;	AX = pSz : near pointer to string with results
;
;Uses:
;	AX, BX, CX, DX.
;
;****

cProc	CreateContext,<NEAR,PUBLIC>
	parmW	HelpId			
cBegin
	mov	al,VT_I2		;Format an integer
	lea	bx,HelpId		; BX = ptr to number to format

	DbAssertRel [bx],g,0,UI,<CreateContext: Bad Help ID>

	call	B$IFOUT 		;BX = address of 0 terminated string

	mov	BYTE PTR [bx],PREFIX_MESSAGE ; Replace space with character
					; that belongs in first postion
	xchg	ax,bx			;return *sz in AX
cEnd

;***
;ShrinkHelp - Compress Help system memory usage
;
;Purpose:
;	Reduce the amount of memory that the help system uses without
;	impeeding the functionallity of the help system.
;
;	WARNING!!!
;	    Any time that this routine may be called (i.e. any time an alloc
;	    is done), you must either set fNoDelBufs or guarentee that
;	    numBuf = 0, or guarentee that oCurTopic, oFirstBuf and oLastBuf
;	    are correct.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per C Convention.
;
;****
cProc	ShrinkHelp,<PUBLIC,FAR>
cBegin

	DbHeapMoveOff			; FH callback can't cause movement

	test	HelpFlags,HLP_NOSHRINK	; are we allowed to call HelpShrink?
	jnz	NoHelpShrink		; no, check for deleting buffers
	cCall	HelpShrink		; Tell help engine to shrink down
NoHelpShrink:


	cmp	fNoDelBufs,0		; Can we delete help buffers also?
	jnz	ShrinkHelp_Exit 	; no, just return

	xor	cx,cx
	mov	cl,numBuf		; cx = # buffers in use
	jcxz	ShrinkHelp_Exit 	; exit if there are none
	cmp	oCurTopic,0		; do we have a current topic?
	jz	NoCurrentTopic		; no, do not keep it in memory
	dec	cx			; do not delete the current topic
NoCurrentTopic:
	cCall	FlushBuffer		; delete CX buffers
ShrinkHelp_Exit:


	DbHeapMoveOn			; remove our lock on the heap
cEnd

;***
;CompressHelp - Close down the help system
;
;Purpose:
;	This routine is called before we execute any user code so that
;	the help system can release all the memory that it does not need.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	AX,BX,CX,DX
;
;Preserves:
;	ES
;****

cProc	CompressHelp,<PUBLIC,FAR>,<ES>	
cBegin
	DbHeapMoveOff			; we are called from FHAlloc
					; not allowed to move heaps

	test	HelpFlags,HLP_GOTBUF	; Help system started?
	jz	NoFreeHelpBuffer	; brif not -- nothing to do

	cmp	fHelpAlloc,0		; doing a help alloc?
	jnz	NoFreeHelpBuffer	; yes, do not shut down help system

	xor	ax,ax			; Nc of 0 => close all files
	cCall	HelpClose,<AX,AX>	; Shut down the help engine

	; we will ignore any file errors on the close


	cCall	DiscardHelpBookMarks	; free bookmark ptrs into help


NoHelpBuffer:
	xor	ax,ax			; get a convenient 0
	mov	iStaticHelpTopic,ax	; clear current search topic
	mov	oCurTopic,ax		; clear current topic ptr.
	mov	iCurRequestLine,ax	; clear GetHelpLine succeeded flag

	; zero the initial context number
	mov	WORD PTR ncInitial,ax	
	mov	WORD PTR ncInitial+2,ax

	or	HelpFlags,HLP_COMPRESS	; flag help has been compressed
	cCall	DrawDebugScr		; make sure screen is redrawn.

DbAssertRel	BdlHelpHist.BDL_Seg,ne,UNDEFINED,UI,<CompressHelp:HLP_GOTBUF is true, but no HistoryBuf Allocated>
	PUSHI	ax,<OFFSET DGROUP:BdlHelpHist>	; Free up the history buf
	cCall	BdlFree 		
	mov	cl,numBuf		; number of buffers to deallocate
	xor	ch,ch			
	cCall	FlushBuffer		; Delete all the help buffers
	and	HelpFlags,NOT HLP_GOTBUF ; indicate buffer unallocated

NoFreeHelpBuffer:
	DbHeapMoveOn			; remove our heap lock
cEnd



; ReWrote with [39]
;***
;GiveHelpOOM - Queue a message to give OOM for Help
;
;Purpose:
;	Indicate to the error handling code that an OOM error has occured
;	in the help system.  This routine may be called as many times as
;	desired before DisplayHelpOOM is called, and the error will only
;	be reported once.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	By Convention
;
;****

cProc	GiveHelpOOM,<PUBLIC,NEAR>
cBegin
	or	HelpFlags,HLP_FAILOOM	; indicate We failed due to OOM
	mov	ax,MSG_HelpOOM		
	cCall	SetUiErr,<AX>		
cEnd

;Added with [39]
;***
;DisplayHelpOOM - Display an OOM error
;
;Purpose:
;	Displays an OOM error messages box for help, closes the help window,
;	and resets static variables.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;****

cProc	DisplayHelpOOM,<PUBLIC,NEAR>
cBegin

DbAssertTst	HelpFlags,e,HLP_INHELP,UI,<DisplayHelpOOM: Recursion lock already set>
	or	HelpFlags,HLP_INHELP	; set the recursion lock

	
	;We must save the HelpId in case the user does something like:
	;   Error 1	      -> displays a dialog box
	;   F1		      -> gets help, runs out of memory
	;   we call MsgBoxStd -> blows away iHelpId
	;   OK to message     -> back to original dialog box
	;   F1		      -> trys help again, iHelpId is invalid
	
	push	iHelpId

	PUSHI	ax,MB_OK		; Box has OK button
	PUSHI	ax,MSG_HelpOOM		; message to be displayed
	call	MsgBoxStd		; put up a dialog box
	and	HelpFlags, NOT HLP_INHELP ;remove recursion lock
	push	Word Ptr fHelpAlloc	; save the help alloc flag
	mov	fHelpAlloc,0		; zero it so CompressHelp will
	call	CompressHelp		; get help system out of the way
	mov	uierr,0 		; clear out the error condition
	pop	ax			; get fHelpAlloc back
	mov	fHelpAlloc,al		; and restore it.
	pop	iHelpId 		; restore HelpId
cEnd


;Rewritten with [38]
;***
;FlushBuffer - Deallocates buffers from HelpBuffer
;
;Purpose:
;	This routine will deallocate all buffers from (but not including)
;	the current topic to the end of the buffer.  If this is not enough,
;	it will start deleting buffers from the begining, until the specified
;	number has been reached.
;
;	If there is no current topic, we will just delete buffers from the
;	begining until we have freed enough.
;
;Entry:
;	CX = minimum # buffers to deallocate
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;****

cProc	FlushBuffer,<NEAR>,<SI,DI>
cBegin

	DbHeapMoveOff

DbAssertRelB	cl,be,MAX_HELPBUFS,UI,<FlushBuffer: Deallocating more buffers than exist>

	mov	di,cx			; DI = # buffers to delete
	cmp	oCurTopic,0		; is oCurTopic invalid?
	je	DelBegin		; yes, just delete from the begining
	mov	si,oLastBuf		; get pointer to last buffer
DelEnd_Next:

	cmp	si,oCurTopic		; have we reached the current topic?
	je	DelBegin		; yes, start deleting from begining

	lea	ax,[si].bdlHelpText	; ax = ptr to BDL in first buffer
	cCall	BdlFree,<ax>		; get rid of it

	dec	numBuf			; indicate it is no longer in use
	sub	si,BUFSIZE		; point at the last buffer
	cmp	si,OFFSET DGROUP:HelpBuffer ;did we go off the end?
	jae	NoWrap5 		; no
	add	si,BUFFERSIZE		; wrap around
NoWrap5:
	mov	oLastBuf,si		; update oLastBuf
	dec	di			; one more buffer deleted
	jmp	short DelEnd_Next	; go try again

DelBegin:
	or	di,di			; is it 0 or negative
	jle	EndFlushBuffer		; yes, exit
	mov	si,oFirstBuf		; get pointer to first buffer
DelBegin_Next:
	lea	ax,[si].bdlHelpText	; ax = ptr to BDL in first buffer
	cCall	BdlFree,<ax>		; get rid of it

	dec	numBuf			; indicate it is no longer in use

	add	si,BUFSIZE		; Point SI at next buffer
	cmp	si,BUFFEREND		; did we go off end of buffer?
	jb	NoWrap1 		; no, continue
	sub	si,BUFFERSIZE		; wrap around to begining
NoWrap1:
	dec	di			; one less to do
	jnz	DelBegin_Next		; loop again
	mov	oFirstBuf,si		; restore ptr to first buffer

EndFlushBuffer:
	DbHeapMoveOn			; reeanble heap movement

cEnd


;Reorganized with [43]
;***
;StartHelp : make sure the help system is initialized (or reinitialized)
;
;Purpose:
;	This routine is called before any references to the help buffers
;	or the help engine are made.  It makes sure the help engine is
;	activated, the help file exists, and the buffers for the virtual
;	line system are initialized.
;
;Entry:
;	None.
;
;Exit:
;	AX = 0	if all OK
;	AX = HELP_HANDLED if an error occured (will be handled).
;
;Uses:
;	Per Convention
;
;****

cProc	StartHelp,<PUBLIC,NEAR>
cBegin
DbAssertRelB	fHelpAlloc,ne,0,UI,<StartHelp:fHelpAlloc not set>

	test	HelpFlags,HLP_GOTBUF	; do we have the buffers?
DJMP	jnz	StartHelp_Success	; yes, exit with return code

	
	;Try to start help engine
	
StartHelpEngine:

DbAssertRel	BdlHelpHist.BDL_Seg,e,UNDEFINED,UI,<StartHelp:History Buffer Valid without HLP_GOTBUF>
	PUSHI	ax,<OFFSET DGROUP:BdlHelpHist>
	PUSHI	ax,HELPHIST_END 	; # bytes to allocate
	cCall	BdlAlloc		; allocate the memory
	or	ax,ax			; did we get the memory?
	jnz	InitHistBuff		; yes, go initialize it
	cCall	GiveHelpOOM		; queue an OOM error

	mov	ax,sp			; return a non-zer value
	jmp	short StartHelp_Exit

InitHistBuff:
	GETSEG	es,BdlHelpHist.BDL_Seg,bx,SIZE	; get segment
	xor	bx,bx
	mov	ES:[bx].HH_Used,bx	; initialize # elements in use
	mov	WORD PTR ES:[bx].HH_First,HELPHIST_BEGIN ; initialize ptr
	
	;Initialize HelpBuffer
	
	push	di			; Save register
	push	ds			; Set ES=DS=DGROUP
	pop	es
	mov	ax,UNDEFINED		; value to initialize buffers with
	mov	cx,BUFFERSIZE/2 	; number of words in buffer
	mov	di,OFFSET DGROUP:HelpBuffer   ; start of buffer
	mov	oFirstBuf,DI		; initialize buffer pointers
	mov	oLastBuf,DI
	rep	stosw			; initialize buffer
	mov	numBuf,CL		; initialize num in use (=0)

	pop	di			; Restore register
	or	HelpFlags,HLP_GOTBUF

StartHelp_Success:
	xor	ax,ax			; return code of success

StartHelp_Exit:
cEnd


;Rewritten with revision [57]
;***
;CalcNc - Calculate a Context Number from a Context string
;
;Purpose:
;	Go though our list of help files, calling HelpNc with the
;	initial context number for each one.  If a help file is not
;	opened, then try to open it before calling HelpNc.
;
;	If the context number is not found and there have been any
;	dialog boxes displayed (or OOM), then return HELP_HANDLED.
;	Otherwise return HELP_NF.
;
;Entry:
;	npsz - Near pointer to context string
;
;Exit:
;	if (CX <> 0)
;	    DX:AX = Context Number
;	else
;	    AL = Error Code (HELP_NF, HELP_HANDLED)
;
;Uses:
;	Per Convention
;
;****

cProc	CalcNc,<PUBLIC,NEAR>,<SI,DI>
parmW	npsz
localB	retVal				; value to return on error
cBegin
	mov	retVal,HELP_NF		; default error code is HELP_NF

	mov	cx,offset szHelpFileQhelp; cs:cx = ptr to file name
	call	fQhelpActive		; are we in the help viewer
	jnz	InQhelp 		; brif so, have proper file name
	mov	cx,offset szHelpFileEdit; cs:cx = ptr to file name
	call	fEditorActive		; are we in the editor
	jnz	InQhelp 		; brif so, have proper file name
	mov	cx,offset szHelpFileInterp ; use help file for interpreter
InQhelp:

	mov	dx,WORD PTR ncInitial	; dx = high word of ncInitial
	mov	ax,WORD PTR ncInitial+2 ; ax = low word of ncInitial

	mov	bx,npsz 		; get a ptr to the string
	cmp	Byte Ptr [bx],0 	; is it a local context?
	jne	NotLocalContext 	; no, check if we have to open file
DbAssertRel	oCurTopic,ne,0,UI,<CalcNc:oCurTopic invaid>
	mov	bx,oCurTopic		; get ptr to current topic
	mov	ax,Word Ptr [bx].ContextNum ; use current NC as the initial NC
	mov	dx,Word Ptr [bx].ContextNum+2

NotLocalContext:
	mov	bx,ax			; do we have a context #?
	or	bx,dx
	jnz	GotHelpFile		; brif so -- try the lookup

	cCall	HelpOpen,<cs,cx>	; try to open the file.
					; DX:AX = ncInitial, or 0:x if failure
	or	dx,dx			; was there an error?
	jnz	SaveInitialNc		; no
	cmp	ax,HELPERR_MAX		; check the low word
	jae	SaveInitialNc		; no error, continue processing

	.erre	HELPERR_MAX LT 256	; make sure all errors fit in a byte
	.errnz	HELPERR_FNF - 1 	; these two errors should be first
	.errnz	HELPERR_READ - 2

;HELPERR_READ => error already given
;HELPERR_FNF  => error already given
; error 7     => error already given
;HELPERR_LIMIT => assert that this doesn't happen (25 help files)
;HELPERR_BADAPPEND => give ER_BFM
;HELPERR_NOTHELP => give ER_BFM
;HELPERR_BADVERS => give ER_BFM
;others        => whatever is convenient

	mov	retVal,HELP_HANDLED	; set a new return value
DbAssertRel	ax,ne,HELPERR_LIMIT,UI,<CalcNC:HELPERR_LIMIT from HelpEngine>
	cmp	ax,HELPERR_READ 	; have we already informed user?
DJMP	jbe	CalcNcExit_Err		; yes, exit in error
	cmp	ax,7			; another error we told user about?
DJMP	je	CalcNcExit_Err		; yes, exit

DbAssertTst	HelpFlags,z,HLP_INHELP,UI,<HelpStart:Recursion lock set>
	or	HelpFlags,HLP_INHELP	; set recursion lock
	PUSHI	ax,MB_OK		; only an OK button
	PUSHI	ax,ER_BFM		; It must be a bad help file
	cCall	MsgBoxStd		; display error
	and	HelpFlags,NOT HLP_INHELP ; clear recursion lock
	jmp	CalcNCExit_Err		; and exit

SaveInitialNc:
	mov	WORD PTR ncInitial+2,ax	; save NC
	mov	WORD PTR ncInitial,dx	

GotHelpFile:
	and	HelpFlags,NOT (HLP_FAILOOM OR HLP_FAILFNF) ; clear flags

	cCall	HelpNc,<ds,npsz,dx,ax>	; DX:AX = nc for this context str

	test	HelpFlags,HLP_FAILOOM OR HLP_FAILFNF ; a handled error?
	jz	CheckForSuccess 	; no, check to see if we succeeded
	mov	retVal,HELP_HANDLED	; update return code otherwise

CheckForSuccess:
	mov	cx,dx
	or	cx,ax			; cx != 0 iff we got the topic
	jnz	CalcNcExit		; brif ok -- we got the NC

CalcNcExit_Err:
	xor	cx,cx			; set cx in case of error
	mov	al,retVal		; return error code
CalcNcExit:				;DX:AX = context #, or 0
cEnd


; Constants used by DoStatusButton().  All added with revision [10].

; NOTE: These messages must remain in sync with QBIMSGS.TXT so that the
; NOTE: status line buttons work properly.
; NOTE:
; NOTE: How to change the text of a message:
; NOTE:
; NOTE:	1. Make sure that the new message will not overflow the status
; NOTE:	   line.  If it will, text changes are required, or a button
; NOTE:	   must be removed.
; NOTE:	2. Make the change to the text in QBIMSGS.TXT
; NOTE:	3. Make the change to the text in UINHELP.ASM
; NOTE:	4. Adjust the button position #'s in UINHELP.ASM
; NOTE:
; NOTE: How to add/remove a button:
; NOTE:
; NOTE:	1. Perform the steps required to change the status line text
; NOTE:	2. Inc/Dec the # of buttons constant in the appropriate
; NOTE:	   StatusXXXTable list.
; NOTE:	3. Add/Remove the Button_XXX constant corresponding to the
; NOTE:	   desired key from the appropriate StatusXXXTable list.
; NOTE:


				; <Shift+F1=Help> <Possible other fields>
			;         ^              ^
All_ob1_F1	EQU 1	;---------+              |
All_ob2_F1	EQU 16	;------------------------+

;Editing
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F6=Window> <F2=Subs> <F5=Run> <F8=Step>
;		     	  ^          ^^        ^^       ^^        ^
Edit_ob1_F6	EQU 17	;-+          ||        ||       ||        |
Edit_ob2_F6	EQU 28	;------------+|        ||       ||        |
Edit_ob1_F2	EQU 29	;-------------+        ||       ||        |
Edit_ob2_F2	EQU 38	;----------------------+|       ||        |
Edit_ob1_F5	EQU 39	;-----------------------+       ||        |
Edit_ob2_F5	EQU 47	;-------------------------------+|        |
Edit_ob1_F8	EQU 48	;--------------------------------+        |
Edit_ob2_F8	EQU 57	;-----------------------------------------+

;Program running (debugging):
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F5=Continue> <F9=Toggle Bkpt> <F8=Step>
;	     	          ^            ^^               ^^        ^
Running_ob1_F5	EQU 17	;-+            ||               ||        |
Running_ob2_F5	EQU 30	;--------------+|               ||        |
Running_ob1_F9	EQU 31	;---------------+               ||        |
Running_ob2_F9	EQU 47	;-------------------------------+|        |
Running_ob1_F8	EQU 48	;--------------------------------+        |
Running_ob2_F8	EQU 57	;-----------------------------------------+

;Immediate window active:
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F6=Window> <Enter=Execute Line>
;                         ^          ^^                   ^
Immed_ob1_F6	EQU 17	;-+          ||                   |
Immed_ob2_F6	EQU 28	;------------+|                   |
Immed_ob1_ENTER	EQU 29	;-------------+                   |
Immed_ob2_ENTER	EQU 49	;---------------------------------+

;Help window active:
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>
;	 	          ^          ^^           ^^             ^^            ^
Help_ob1_F6	EQU 17	;-+          ||           ||             ||            |
Help_ob2_F6	EQU 28	;------------+|           ||             ||            |
Help_ob1_ESC	EQU 29	;-------------+           ||             ||            |
Help_ob2_ESC	EQU 41	;-------------------------+|             ||            |
Help_ob1_CTRLF1	EQU 42	;--------------------------+             ||            |
Help_ob2_CTRLF1	EQU 56	;----------------------------------------+|            |
Help_ob1_ALTF1	EQU 57	;-----------------------------------------+            |
Help_ob2_ALTF1	EQU 70	;------------------------------------------------------+

; Editing in QEDIT
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;	  MS-DOS Editor	 <F1=Help> Press ALT to activate menus
;			 ^	 ^
;			 |	 |
QEdit_ob1_F1	EQU 16	 ;	 |
QEdit_ob2_F1	EQU 25	 ;-------+


; Help window active: QEDIT
;        00000000001111111111222222222233333333334444444444555555555566666
;        01234567890123456789012345678901234567890123456789012345678901234
;         <F1=Help> <F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>
;	  ^	  ^ ^          ^^           ^^             ^^            ^           ^
QHelp_ob1_F1    EQU 01  ;      ||           ||             ||            |
QHelp_ob2_F1    EQU 09  ;      ||           ||             ||            |
QHelp_ob1_F6	EQU 11  ;      ||           ||             ||            |
QHelp_ob2_F6	EQU 22  ;------ |           ||             ||            |
QHelp_ob1_ESC	EQU 23  ;-------+           ||             ||            |
QHelp_ob2_ESC	EQU 35  ;-------------------+|             ||            |
QHelp_ob1_CTLF1 EQU 36  ;--------------------+             ||            |
QHelp_ob2_CTLF1 EQU 50  ;----------------------------------+|            |
QHelp_ob1_ALTF1	EQU 51  ;-----------------------------------+            |
QHelp_ob2_ALTF1	EQU 64  ;------------------------------------------------+


; QHELP help viewer start-up status: MSG_StatusQHStart
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;	  MS-DOS Help Viewer  <F1=Help> Press ALT to activate menus
;			      ^       ^
;			      |       |
QHStart_ob1_F1	  EQU 21      ;       |
QHStart_ob2_F1	  EQU 29      ;-------+


; QHELP help window active: MSG_StatusQHHelp
;	 00000000001111111111222222222233333333334444444444555555555566666666667
;	 01234567890123456789012345678901234567890123456789012345678901234567890
;         <Alt+C=Contents> <Alt+N=Next> <Alt+B=Back>
;         ^               ^^           ^^           ^
QHHelp_ob1_CONTS EQU 01 ; ||           ||           |
QHHelp_ob2_CONTS EQU 17 ;-+|           ||           |
QHHelp_ob1_NEXT  EQU 18 ;--+           ||           |
QHHelp_ob2_NEXT  EQU 30 ;--------------+|           |
QHHelp_ob1_BACK  EQU 31 ;---------------+           |
QHHelp_ob2_BACK  EQU 43 ;---------------------------+


labelNP	<StatusTable>
	DW	UIOFFSET StatusEditTable
	DW	UIOFFSET StatusRunningTable
	DW	UIOFFSET StatusImmedTable
	DW	UIOFFSET StatusHelpTable
        DW      UIOFFSET StatusQeditTable
        DW      UIOFFSET StatusQhelpTable
	DW	UIOFFSET StatusQHStartTable
	DW	UIOFFSET StatusQHhelpTable

StatusButton STRUC
SB_Command	db	?
SB_obStart	db	?
SB_obEnd	db	?
StatusButton ends

LabelNP	<StatusEditTable>
	DB	5		; # of buttons in Edit status message
	StatusButton	<midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton	<midNextWindow, Edit_ob1_F6, Edit_ob2_F6>
	StatusButton	<midViewSubs, Edit_ob1_F2, Edit_ob2_F2>
	StatusButton	<midRunContinue, Edit_ob1_F5, Edit_ob2_F5>
	StatusButton	<midStep, Edit_ob1_F8, Edit_ob2_F8>

LabelNP	<StatusRunningTable>
	DB	4		; # of buttons in Running status message
	StatusButton	<midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton	<midRunContinue, Running_ob1_F5, Running_ob2_F5>
	StatusButton	<midDebugToggleBp, Running_ob1_F9, Running_ob2_F9>
	StatusButton	<midStep, Running_ob1_F8, Running_ob2_F8>

LabelNP	<StatusImmedTable>
	DB	3		; # of buttons in Immediate status message
	StatusButton	<midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton	<midNextWindow, Immed_ob1_F6 , Immed_ob2_F6>
	StatusButton	<midEnter, Immed_ob1_ENTER, Immed_ob2_ENTER>

LabelNP	<StatusHelpTable>
	DB	5		; # of buttons in Help status message
	StatusButton	<midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton	<midNextWindow, Help_ob1_F6, Help_ob2_F6>
	StatusButton	<midHelpClose, Help_ob1_ESC, Help_ob2_ESC>
	StatusButton	<midHelpNext, Help_ob1_CTRLF1, Help_ob2_CTRLF1>
	StatusButton	<midHelpBack, Help_ob1_ALTF1, Help_ob2_ALTF1>

LabelNP	<StatusQeditTable>
	DB	1		; # of buttons in Edit status message
	StatusButton	<midHelpSyntax, Qedit_ob1_F1, Qedit_ob2_F1>

LabelNP	<StatusQhelpTable>
	DB	5		; # of buttons in Help status message
	StatusButton	<midHelpSyntax, QHelp_ob1_F1, QHelp_ob2_F1>
	StatusButton	<midNextWindow, QHelp_ob1_F6, QHelp_ob2_F6>
	StatusButton	<midHelpClose, QHelp_ob1_ESC, QHelp_ob2_ESC>
	StatusButton	<midHelpNext, QHelp_ob1_CTLF1, QHelp_ob2_CTLF1>
	StatusButton	<midHelpBack, QHelp_ob1_ALTF1, QHelp_ob2_ALTF1>

LabelNP <StatusQHStartTable>
	DB	1		; # of buttons in QHELP start status message
	StatusButton	<midHelpHowToUse, QHStart_ob1_F1, QHStart_ob2_F1>

LabelNP <StatusQHhelpTable>
        DB      3               ; # of buttons in QHELP Help status message
        StatusButton    <midHelpHelp,    QHHelp_ob1_CONTS, QHHelp_ob2_CONTS>
        StatusButton    <midHelpNext,    QHHelp_ob1_NEXT , QHHelp_ob2_NEXT >
        StatusButton    <midHelpBack,    QHHelp_ob1_BACK , QHHelp_ob2_BACK >


;***
;HStatusButton
;	Given a mouse position in the status line window, return
;	a handle to the status button at that position.
;
;Purpose:
;	Heavy modification in revision [52]
;
;Entry:
;	posX = 0-relative mouse position
;Exit:
;	AX - handle to the status button or NULL if no button.
;	     The handle is actually a pointer into the code segment.
;Uses:
;	Per Convention
;****

cProc	HStatusButton,<PUBLIC,NEAR>,<SI>
	ParmW	posX
cBegin
	xor	si,si			;Default return value: NULL

	mov	bx,iMsgStatusLine	; bx = current line displayed
	sub	bx,MSG_StatusEdit	; bx = 0, 1, 2, 3, or invalid
	cmp	bx,(MSG_StatusQHhelp - MSG_StatusEdit) ; out of range?
	ja	ButtonExit		; brif so -- just exit

	shl	bx,1			; word index
	mov	si,word ptr cs:[bx].StatusTable

	mov	bx,[posX]		; bx = 0-relative position
	lods	byte ptr cs:[si]	; AL = number of entries for this line
	cbw				
	xchg	cx,ax			; CX = number of entries
ButtonLoop:
	inc	si			;Ignore the SB_Command
	lods	word ptr cs:[si]	;AH = obEnd, AL = obStart
	cmp	bl, al
	jb	ButtonNotFound
	cmp	bl, ah
	jb	ButtonFound
	loop	ButtonLoop
ButtonNotFound:
	mov	si,SIZE StatusButton	;return NULL
ButtonFound:
	sub	si,SIZE StatusButton	;point back to begining of structure.
ButtonExit:
	mov	ax, si
cEnd

;***
;ObStatusButton - Returns the position of a Status Line Button
;
;Purpose:
;	Return the position of the specified Status Button.
;
;	new for revision [52]
;
;Entry:
;	hButton - handle to button (near pointer in CS)
;
;Exit:
;	AX - Offset in characters from the beginning of the status line.
;
;Preserves:
;
;****
cProc ObStatusButton,<NEAR,PUBLIC>
	parmW	hButton
cBegin
	mov	bx, [hButton]
	xor	ax,ax
	mov	al, cs:[bx.SB_obStart]
cEnd

;***
;CbStatusButton - Returns the number of characters in a Status Line Button
;
;Purpose:
;	Return the number of characters in the specified Status Button.
;
;	new for revision [52]
;
;Entry:
;	hButton - handle to button (near pointer in CS)
;
;Exit:
;	AX - Size of button.
;
;Preserves:
;
;****
cProc CbStatusButton,<NEAR,PUBLIC>
	parmW hButton
cBegin
	mov	bx, [hButton]
	mov	al, cs:[bx.SB_obEnd]
	sub	al, cs:[bx.SB_obStart]
	xor	ah,ah
cEnd

;***
;DoStatusButton - Posts the key message associated with a Status Line Button
;
;Purpose:
;	Post the WM_CHAR message for the specified Status Button.
;
;	new for revision [52]
;
;Entry:
;	hButton - handle to button (near pointer in CS)
;
;Exit:
;	None.
;
;Preserves:
;
;****
cProc DoStatusButton,<NEAR,PUBLIC>
	parmW	hButton
cBegin
	mov	bx, [hButton]
	xor	dx,dx				
	mov	dl,cs:[bx.SB_Command]		
	pushi	ax, <DATAOffset wndMain>	
	pushi	ax, WM_COMMAND			
	push	dx				
	xor	ax,ax
	push	ax
	push	ax
	call	PostMessage
cEnd

cEnd

;***
;RecordHelpHistory - Add entry to history list
;
;Purpose:
;	Record an entry into the help history list.  If the list is already
;	full, the last item gets bumped.
;
;Entry:
;	DX:AX	: item to be stored
;	BL	: flags to store with it	(EI_VARHELP Only)
;
;Exit:
;	None.
;
;Preserves:
;	AX,DX
;
;****

cProc	RecordHelpHistory,<NEAR,PUBLIC>,<DS>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<RecordHelpHistory:BdlHelpBack not initialized>

	GETSEG	ds,BdlHelpHist.BDL_Seg,bx,SIZE	; get segment of data

	;NOTE: DS != DGROUP at this point

	ASSUMES DS,NOTHING

	xor	bx,bx			; look at location 0
	cmp	WORD PTR [bx].HH_Used,NUM_HISTORY ; all slots being uses?
	je	RecordOverwrite 	; yes, just overwrite last item
	inc	WORD PTR [bx].HH_Used	; one more item being used
RecordOverwrite:
	mov	cx,[bx].HH_First	; DX is location to stick item
	push	cx
	add	cx,SIZE HelpHistEntry	; point CX at next entry
	cmp	cx,HELPHIST_END 	; at end of table?
	jb	NoTableWrap		; no
	mov	cx,HELPHIST_BEGIN	; point to begining of table
NoTableWrap:
	mov	[bx].HH_First,cx	; save new initial location
	pop	bx			; restore previous starting loc
	mov	[bx].HH_HiWord,dx	; save Hi word
	mov	[bx].HH_LoWord,ax	; save lo word
	ASSUMES DS,DGROUP
cEnd

;***
;RetrieveHelpHistory - Get the last recorded item in help history list
;
;Purpose:
;	Retrieve the last item from the help history list.  Returns with CX=0
;	if no items are left.
;
;Entry:
;	None.
;
;Exit:
;	if CX <> 0
;	    DX:AX   : item stored
;	    BL	    : flags stored with it (IF EI_VARHELP)
;	else
;	    No items recorded
;
;****
cProc	RetrieveHelpHistory,<NEAR,PUBLIC>,<DS>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<RetrieveHelpHistory:BldHelBack not initialized>

	GETSEG	ds,BdlHelpHist.BDL_Seg,bx,SIZE	; get segment of data
	
	;NOTE: DS != DGROUP at this point
	
	ASSUMES DS,NOTHING

	xor	bx,bx			; look at location 0
	mov	cx,[bx].HH_Used 	; CX = number of slots in use
	jcxz	RetrieveExit		; no items, return with error
	
	;NOTE: CX <> 0 is preserved for rest of routine
	
	dec	WORD PTR [bx].HH_Used	; indicate one less
	mov	ax,[bx].HH_First	; AX = offset into table
	sub	ax,SIZE HelpHistEntry	; point to previous entry
	cmp	ax,HELPHIST_BEGIN	; before first entry?
	jge	NoRetrieveWrap		; no, continue
	mov	ax,HELPHIST_END - SIZE HelpHistEntry ; set to last item
NoRetrieveWrap:
	mov	[bx].HH_First,ax	; save new pointer
	xchg	bx,ax			; bx = ptr to entry to retrieve
	mov	dx,[bx].HH_HiWord	; retrieve values and exit
	mov	ax,[bx].HH_LoWord
RetrieveExit:
	ASSUMES DS,DGROUP
cEnd

;***
;HelpHistoryLength - return number of items in the help history list
;
;Entry:
;	None
;
;Exit:
;	CX = number of items
;
;Uses:
;	CX,ES
;
;Preserves:
;	AX,BX,DX
;***

cProc	HelpHistoryLength,<NEAR>,<BX>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<HelpHistoryLength:BldHelBack not initialized>

	GETSEG	es,BdlHelpHist.BDL_Seg,bx,SIZE	; get segment of data
	mov	cx,ES:[0].HH_Used	; CX = number of slots in use
cEnd



; added with [24], rewritten with [25]
;***
;DiscardHistoryoRs - Discard all Help + Bookmark information for an oRs
;
;Purpose:
;	Discards any stored information about a given oRs in the help system.
;	If the current help being displayed is dependent on this oRs, then we
;	will do a Help Back until something is found.  If nothing is found,
;	close the help window.
;
;Entry:
;	oRs - oRs to be discarded
;
;Exit:
;	None
;
;Uses:
;	Per C Conventions
;***

cProc	DiscardHistoryoRs,<PUBLIC,FAR>,<SI,DI>
parmW	oRs
cBegin
	mov	ax,UNDEFINED		; indicates bookmark not valid
	cCall	ReAssignBookMark,<oRs,AX> ; delete all matching bookmarks



DiscardHistory_Exit:
cEnd


;***
;szSrchExcl - search for '!' in a 0 terminated string
;
;Purpose:
;	This routine scans a 0 terminated string to find an '!' in
;	it.
;
;Entry:
;	npsz	- Near Ptr to string to search
;
;Exit:
;	if character not found
;	    AX = 0
;	else
;	    AX = ptr to first occurance of the character
;
;Uses:
;	Per C convention
;****

cProc	szSrchExcl,<PUBLIC,NEAR>,<SI>
parmW	npsz
cBegin
	mov	si,npsz 		; start of string to scan
NextChr:
	lodsb
	cmp	al,'!'			; is it the character of interest?
	je	FoundChr		; yes, return its position
	or	al,al			; is it the 0 terminator?
	jne	NextChr 		; no, try the next character.
	cbw				; AX = 0
	xchg	ax,si			; SI = 0  (return value)
FoundChr:
	xchg	ax,si			; AX = Ptr to str OR 0
cEnd


;***
;SendHelpMsg - Stub routine to send a message to the help window
;
;Purpose:
;	Code saving method of sending a message (with wParm only) to
;	the help window.
;
;Entry:
;	msg - message to send
;	wParam - one parameter to be passed
;
;Exit:
;	Return value from Window Proc
;
;
;****

cProc	SendHelpMsg,<PUBLIC,NEAR>
parmW	msg
parmW	wParam
cBegin
	mov	ax,OFFSET DGROUP:wndHelp
	cCall	SendMessage,<AX, msg, wParam, ax,ax>
cEnd


sEnd	UI
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uipaths.asm ===
TITLE UiPaths.asm - Configurable path-searching functions

COMMENT	\

--------- --- ---- -- ---------- ----
COPYRIGHT (C) 1988 BY MICROSOFT, INC.
--------- --- ---- -- ---------- ----

\
;============================================================================
; Module: UiPaths.asm - Configurable path-searching functions
; System: Quick BASIC Interpreter
;============================================================================

	.xlist
	include		version.inc
	UIPATHS_ASM = ON

	include cw/version.inc
	include cw/windows.inc
	include cw/edityp.inc
	include cw/dlg.inc		

	includeOnce	architec	
	includeOnce	heap
	includeOnce	rtps
	includeOnce	qbimsgs
	includeOnce	ui
	includeOnce	uiint		
	.list

assumes	DS,DATA
assumes	SS,DATA
assumes	ES,NOTHING


;
; external declarations for runtime routines used by FindFile
;
	EXTRN	B$FindFileOnPaths:FAR


	externFP NormFileNameFar		

	externFP HelpAlloc			

;-------------------------------------------------------------------------
;		DATA Segment Declarations
;-------------------------------------------------------------------------
sBegin	DATA


	externB bufLib				; literal "LIB"
	EXTRN	CB_bufLib:ABS			; length of "LIB"
	externB bufPath 			; literal "PATH"
	EXTRN	CB_bufPath:ABS			; length of "PATH

	bufInclude  db	"INCLUDE"
	CB_bufInclude	=   $ - bufInclude

	labelW	tSearchPathBds			; table of bd's
	globalB bdLibPath,0,<SIZE bd>		; bd for lib path
	globalB bdExePath,0,<SIZE bd>		; bd for exe path
	globalB bdInclPath,0,<SIZE bd>		; bd for include path
	globalB bdHelpPath,0,<SIZE bd>		; bd for help path


	externW iHelpId 			
	externB HelpFlags			
	externB b$Buf1				; buffer for saving dir
	externB b$Buf2				; buffer for dialog box fns
	externW b$PN_NAME			; *to name.ext in pathname
						; file type radio buttons
	staticB	szDot,<".",0>			
	externB	b$BAS_EXT			; ".BAS"
	externB	szWildDefault			; "*.BAS"
	globalB fFileCreate,0			; NZ if doing File/Create

sEnd	DATA


sBegin	UI					
assumes CS,UI					

	externNP SetCurDir2			
	externNP GetCurDrive2			
	externNP GetCurDriveDir			
	externNP SetCurDrive2			
	externNP RetryError			


	externNP AppendBuf			;[14]

labelW	tDefEnvVars			; table of default env vars (FAR)
	dw	DATAOFFSET bufLib		; pointer to "LIB"
	dw	CB_bufLib			; length of "LIB"
	dw	0				;	    placeholder
	dw	DATAOFFSET bufPath		; pointer to "PATH"
	dw	CB_bufPath			; length of "PATH"
	dw	0				;	    placeholder
	dw	DATAOFFSET bufInclude		; pointer to "INCLUDE"
	dw	CB_bufInclude			; length of "INCLUDE"
	dw	0				;	    placeholder
	dw	DATAOFFSET bufPath		; pointer to "PATH"
	dw	CB_bufPath			; length of "PATH"

; The following file types are used to index the preceding table, so they
; better have the right values.

.errnz	bdLibPath  - tSearchPathBds - LIBFILE	
.errnz	bdExePath  - tSearchPathBds - EXEFILE	
.errnz	bdInclPath - tSearchPathBds - INCFILE	
.errnz	bdHelpPath - tSearchPathBds - HELPFILE	

;****
;FindAndOpenFile (pszFile, fWrite, fFileType)
;
;Purpose:
;	Searches the current directory, the appropriate user-specified
;	search path, and the appropriate environment variable for the
;	file pszFile and opens the file based on fWrite.
;
;Input:
;	pszFile   - near pointer to null-terminated file name to open
;	fWrite	  - write only mode flag:
;			T => open file in write only mode
;			F => open file in read only mode
;	fFileType - type of file being searched for (determines search path)
;			LIBFILE  => search user-specified library path
;			EXEFILE  => search user-specified exe-file path
;			INCFILE  => search user-specified include path
;			HELPFILE => search user-specified help path
;Output:
;	if successful
;	   AX == file handle
;	else
;	   AX == 0
;
;****
cProc	FindAndOpenFile,<PUBLIC,FAR>,<DS>
	ParmW	pszFile
	ParmW	fWrite
	ParmW	fFileType
cBegin
DbAssertRel b$fInt24Err,ne,0,UI,<FindAndOpenFile: int 24 errors not ignored>
	cCall	<far ptr FindFile>,<pszFile,fFileType>
	or	ax,ax			; found file?
	jz	FindOpenExit		; no, return with AX = 0

	mov	ds,dx
	xchg	ax,dx			; ds:dx = ptr to pathname to open
	xor	ax,ax			; get a zero
	cmp	ax,[fWrite]		; set CY if fWrite is TRUE
	rcl	ax,1			; set AX = 1 if fWrite is TRUE

; Now AX = 0 if fWrite is FALSE or 1 if fWrite is TRUE.  That means
; AL = the mode which we need for the int 21h for the OPEN.

	mov	ah,3dh			; fn # for open file
	int	21h			; open the file
	jnc	FindOpenExit		; return with handle in AX if success

DbAssertRel	ax,ne,2,UI,<FindAndOpenFile: OPEN got File Not Found error>
DbAssertRel	ax,ne,3,UI,<FindAndOpenFile: OPEN got Path Not Found error>
DbAssertRel	ax,ne,12,UI,<FindAndOpenFile: OPEN got Invalid Access error>

	xor	ax,ax			; open failed, return zero
FindOpenExit:
cEnd

;****
;FindFile (pszFile, fFileType)
;
;Purpose:
;	Searches the current directory, the appropriate user-specified
;	search path, and the appropriate environment variable for the
;	file pszFile and returns a pointer to a fully-qualified pathfile
;	name where the file was found.
;
;Input:
;	pszFile   - near pointer to null-terminated file name to open
;	fFileType - type of file being searched for (determines search path)
;			LIBFILE  => search user-specified library path
;			EXEFILE  => search user-specified exe-file path
;			INCFILE  => search user-specified include path
;			HELPFILE => search user-specified help path
;Output:
;	if successful
;	   DX:AX == pointer to pathfile name where file was found
;	else
;	   AX == 0
;
;****
cProc	FindFile,<PUBLIC,FAR>		
	ParmW	pszFile
	ParmW	fFileType
cBegin

	mov	bx,[fFileType]
	cCall	B$FindFileOnPaths,<ds,pszFile,[bx].tSearchPathBds.BD_pb,ds,cs:[bx].tDefEnvVars,cs:[bx+2].tDefEnvVars>	

; B$FindFileOnPaths returns exactly what we want to return here so no
; furthur processing is necessary.

cEnd


;****
;OpenFileOnPath (pszFile, fWrite) -- Help engine callback.
;
;Purpose:
;
;	Searches the current directory, the appropriate user-specified
;	search path, and the appropriate environment variable for the
;	file pszFile and opens the file based on fWrite.  If pszFile
;	already contains a path (ie: a "\") no searching is done; the
;	specified path/file name is used without modification.
;
;	NOTE: CAN cause heap movement when doing the alloc for the virtual
;	file handle.  This SHOULD NOT be a problem, since the help engine
;	doesn't hold any "locks" when it does the call to OpenFileOnPath.
;
;	See HENGINE.ASM for a discussion of virtual file handles.
;
;Input:
;	pszFile   far pointer to null-terminated file name to open
;		      Filename may have environment variable prepended
;		      to it in the form: $ENVVAR:filename
;	fWrite	  write only mode flag:
;		      T => open file in write only mode
;		      F => open file in read only mode
;Output:
;	if successful
;	   AX == file handle
;	else
;	   AX == 0
;
;****

cProc	OpenFileOnPath,<PUBLIC,FAR>,<SI,DI>
	ParmD	pszFile
	ParmW	fWrite
cBegin

	push	iHelpId			; msg boxes could trash this

DbAssertRel	fWrite,e,0,UI,<OpenFileOnPath: fWrite != 0>	
DbAssertTst	HelpFlags,z,HLP_INHELP,UI,<OpenFileOnPath: recursion lock set>
	or	HelpFlags,HLP_INHELP	; set recursion lock

RetryOpen:
	les	si,[pszFile]		; es:di points to input string

; Parse the input filename to isolate environment variable if present
; and set up pointers for searching.
; Note: we can't test for the presence of ENVVAR just by testing for the
;	first char being '$' because that is a legal first char for a
;	filename.

	lods	byte ptr es:[si]	; get 1st character
	mov	bx,si			; save this pointer
	cmp	al,'$'			; first char == '$' ?
	je	EnvVarCheck		; yes, check for possible env var
NoEnvVar:
; No $ENVVAR: was specified in filename, set up defaults.
; (Defaults are user-specified HELP path and environment variable PATH.

	push	es
	push	[off_pszFile]		; push far ptr to filename
	push	es			; push second copy for possible
	push	[off_pszFile]		; display in the MessageBox

OpenNoEnvVar:
	mov	dx,[bdHelpPath].BD_pb	; dx = ptr to user-specified HELP path
	push	ds
	pop	es
	mov	bx,DATAOFFSET bufPath	; es:bx = ptr to constant "PATH"
	mov	cx,CB_bufPath		; cx = length of constant "PATH"
DJMP	jmp	SHORT CallFind		; finish up

EnvVarCheck:
	xor	cx,cx			; init counter
EnvVarLoop:
	lods	byte ptr es:[si]	; get next character
	or	al,al			; end of string?
	jz	NoEnvVar		; yes, then there's no env var present
	inc	cx			; count this char
	cmp	al,':'			; found end of env var?
	jne	EnvVarLoop		; no, try next character
	dec	cx			; don't count last ':' as part of name

DbAssertRel	cx,nz,0,UI,<OpenFileOnPath: null environment variable specified>

; If we fall through to here, $ENVVAR: was found.
;	es:bx points to environment variable name part of string
;	cx = length of environment variable name
;	es:si points to filename part of input string

	push	es
	push	si			; push far ptr to filename part
	push	es			; save second copy for error msg
	push	si			
	push	cx			; save env var length

; Determine which user-specified search path we will be using.	If the
; ENVVAR we just found is INCLUDE, then we'll use bdInclPath.  Otherwise
; we'll use bdHelpPath.

	cmp	cx,CB_bufInclude
	jne	HaveBdPtr		; can't match if not the same length
	mov	di,bx			; es:di points to ENVVAR
	mov	si,DATAOFFSET bufInclude ; ds:si points to constant "INCLUDE"
	mov	dx,[bdInclPath].BD_pb	; assume INCLUDE
	repz	cmpsb			; compare the strings
	jz	HaveBdPtr		; they matched. use INCLUDE
	mov	dx,[bdHelpPath].BD_pb	; use HELP

HaveBdPtr:
	pop	cx			; restore env var length

; First parm to B$FindFileOnPaths is the far ptr to filename we pushed above.

CallFind:
	cCall	B$FindFileOnPaths,<dx,es,bx,cx>
	or	ax,ax			; found the file?
	jnz	OpenFileFound		; brif so

OpenFileNotFound:			
	pop	si			; ES:SI = base file name pointer
	pop	es			
	;put up a message, and re-try the open if the user wants
	cCall	NoHelpFile,<ES,SI>
	cmp	ax,IDCANCEL		; cancel?
	jne	RetryOpen		; brif not -- try again
	or	HelpFlags,HLP_FAILFNF	; set failure flag
	xor	ax,ax			; set error flag
	jmp	SHORT OpenFileExit2	; exit

OpenFileFound:			; DX:AX = fully-qualified file name
	mov	si,dx			; SI:DI = * fully-qualified filename
	xchg	di,ax			

	push	di			; save register
	mov	es,si			; ES:DI = * string
	xor	ax, ax			
	mov	cx, 0ffffH		
	repne scasb			
	neg	cx			; cx = 2 greater than length
	pop	di			
	dec	cx			; cx = 1 greater than length
					; (room for name and NULL)
	cCall	HelpAlloc,<cx>		; allocate CX bytes, AX = handle
	or	ax,ax			; error? (failure flag will be set)
	je	OpenFileExit		; brif so -- exit with ax = 0
				; AX is now a "virtual file handle"

	push	ax			; save virtual file handle
	xchg	bx,ax			; bx = memory handle
	xor	ax,ax			; [bx]:ax = filename address
	cCall	fstrcpy2,<[bx],ax,si,di> ; copy filename to buffer
	pop	ax			; AX = virtual file handle

OpenFileExit:				; exit with AX = file handle
	pop	bx			; discard file name pointer
	pop	bx			
OpenFileExit2:				
	and	HelpFlags,NOT HLP_INHELP ; clear recursion lock
	pop	iHelpId			; restore (possibly) trashed help id

cEnd

;Split out of OpenFileOnPath with [14]
;***
;NoHelpFile - Inform user that a help file does not exit
;
;Purpose:
;
;Entry:
;	fpszFilename - far pointer to zero terminated file name
;
;Exit:
;	AX = IDCANCEL or IDRETRY
;
;Uses:
;	Per C Convention
;****

cProc	NoHelpFile,<NEAR,PUBLIC>,<SI,DI>	
parmD	fpszFilename
localV	npszLine2,80			; Order is important!
localV	npszLine1,80			
cBegin
	lea	ax,npszLine1		; pointer to first line
	push	ax			; buffer to append to
	PUSHI	ax,MSG_NoHelp		; Message number to append
	cCall	AppendBuf		; put message in npszLine1
	xchg	di,ax			; DI = ptr to next free byte in buffer

	; copy LONG string to stack (uses both stack buffers)
	cCall	fstrcpy2,<ds, di, seg_fpszFilename, off_fpszFilename>	

	push	uierr			; save old uierr
	mov	uierr,0			; clear it so we can check later
					; (FileSpec can set it)

	cCall	FileSpec,<di>		; AX = * name portion (upper-cased)

	xchg	si,ax			; SI = *name portion of parsed name

	cmp	uierr,0			; got error? (like Disk Not Ready)
	pop	uierr			; restore old uierr
	jz	UseParsedName		; brif not -- use parsed name

		; restore original name trashed by FileSpec that failed
	cCall	fstrcpy2,<ds, di, seg_fpszFilename, off_fpszFilename>	
	mov	si,di			; just use incoming name

UseParsedName:				

	push	ds			; ES = DGROUP
	pop	es			

CopyLoop:			; copy name portion to first part of buffer
	lodsb				; get a byte
	stosb				; save it
	cmp	al,0			; 0 terminator?
	jnz	CopyLoop		; no, go for next byte
	dec	di			; back up over null

	push	di			; buffer to append to
	PUSHI	ax,MSG_NoHelp1		; Message number to append
	cCall	AppendBuf		; put message onto end of npszLine1
	xchg	ax,si			; si = ptr to end of buffer
	mov	Byte Ptr [si],0 	; zero terminate buffer

	lea	di,npszLine2		; get pointer to second line
	push	di			; buffer to append to
	mov	ax,MSG_NoQHelp2 	; Assume QHELP help file
	test	[cmdSwitches],CMD_SW_QHELP ; /QHELP help file?
	jnz	nhf10			;  YES, go get it
	mov	ax,MSG_NoHelp2		;  NO, EDIT/QBASIC help file

nhf10:
	push	ax
	cCall	AppendBuf		; put message into npszLine2
	xchg	ax,si			; si = ptr to end of buffer
	mov	Byte PTr [si],0 	; zero terminate buffer

	;; Do third line of text

	mov	ax,MSG_NoQHelp3 	; Assume QHELP help file
	test	[cmdSwitches],CMD_SW_QHELP ; /QHELP help file?
	jnz	nhf20			;  YES, go get it
	mov	ax,MSG_NoHelp3		;  NO, EDIT/QBASIC help file

nhf20:
	push	ax
	cCall	ListStdMsg		; fill it in

	mov	ax,OFFSET DGROUP:BufStdMsg ; get a ptr to the source
	sub	sp,CB_bufStdMsg 	; create buffer on stack
					; note: this can not be done
					; in the prolog, as we may not
					; have stack space for it and
					; the call to FileSpec
	mov	si,sp			; SI = ptr to temporary buffer
	cCall	fstrcpy2,<ds, si, ds, ax>; copy from BufStdMsg to our buffer
	lea	ax,npszLine1		; pointer to first line
	push	ax			; first parameter to MessageBox
	push	di			; ptr to second line of text
	push	si			; ptr to third line of text
	mov	ax, MB_OK	        ; Just OK button if QHELP mode
	test	[cmdSwitches],CMD_SW_QHELP ; /QHELP help file?
	jnz	nhf30			;  YES, go get it
	mov	ax, MB_RETRYCANCEL	; RETRY and a CANCEL button
nhf30:
        push    ax
					; (Help button won't be put on)
	cCall	UIMessageBox		; display the message box
	add	sp,CB_bufStdMsg 	; remove temporary buffer

	test	[cmdSwitches],CMD_SW_QHELP      ; return cancel if QHELP mode
	jz	nhf40			
        mov     ax, IDCANCEL
nhf40:
cEnd



	page

;****
;ValidateFile ()
;
;Purpose:
;
;	Added with revision [15].
;
;	Obtains and validates filenames from dialogs before COW gets its
;	fingers on the name.  Validates the file, and puts up an error
;	msgbox if it is incorrect.  Adds the appropriate extension.
;
;	By checking things now, we avoid problems of switching logical
;	drives, int 24 errors, etc.
;
;Input:
;	None
;
;Output:
;	AX =	TRUE if name is proper
;		FALSE if name isn't
;Uses:
;	Per convention
;
;****

cProc	ValidateFile,<PUBLIC,NEAR>,<SI,DI>
cBegin

TEMP_BUF_SIZE = (FILNAML+1) AND 0FFFEh	; max length of name, made even
isFileTypeModule = 0			; Constant only available in C for now

	push	iHelpId			; save dialog box help id (trashed
					; when we put up a message box)
TryAgain:				
	mov	ax,TEMP_BUF_SIZE	; ax = max length of name
	sub	sp,ax			; sp = *temp buffer
	mov	si,sp			; si = *temp buffer (on stack)
	mov	bx,tmcSzFileName	; bx = file name tmc
	cCall	GetTmcText,<bx, si, ax>	; get filename into temp buffer

	cCall	GetCurDrive2		; AL = current drive letter
	push	ax			; save for later
	cmp	byte ptr [si],0		; null filename?
	je	NotDirName		; brif so -- don't try to CD

	cCall	ChangeDir2		; try to change directory to the
					; entire pathname.
	mov	b$PN_NAME,OFFSET DGROUP:szWildDefault ; default to "*.bas"
	or	ax,ax			; success? (file is directory name)
	jz	ValidateDone		; brif so -- put up "*.bas"

NotDirName:				
	mov	di,OFFSET DGROUP:b$BAS_EXT ; di = * default extension to add

	cCall	CbSzUi,<si>		; ax = # chars in filename

	cCall	ChangeDir,<si,ax,di>	; parse pathname into b$Buf2, and
					; change current drive and directory
					; to that of the pathname

ValidateDone:				
	pop	bx			; bl = original drive letter
	add	sp,TEMP_BUF_SIZE	; trash temporay space now, before
					; we need more stack (msgbox, help)

	or	ax,ax			; any errors?
	jnz	GotError		; brif so -- display a message box

	mov	dx,b$PN_NAME		; dx = *new name portion
	mov	ax,ER_IFN		; prepare to give "bad file name"
	cmp	fFileCreate,0		; File/Create?
	jz	NoError			; brif not -- we're ok
	cmp	dx,OFFSET DGROUP:szWildDefault ; trying to create directory?
	jne	NoError			; brif not -- we're ok
GotError:				; AX = error code
					; BL = original drive letter
	xchg	si,ax			; SI = error code (save across call)
	cCall	SetCurDrive2,<bx>	; restore original drive

	cCall	RetryError,<si>		; give them a chance to retry
	cmp	ax,IDRETRY		; retryable error, and <RETRY> hit?
	je	TryAgain		; brif so -- try again
	cmp	ax,IDCANCEL		; retryable error, and <CANCEL>?
	je	ErrorExit		; brif so -- exit

	mov	bx,MB_OK		; just put up an OK box
	cCall	MsgBoxStd,<bx,si>	; display the message box
	
ErrorExit:				
	xor	ax,ax			; exit with AX = FALSE
	jmp	SHORT ValidateExit

NoError:				
	mov	ax,tmcSzFileName	; ax = filename tmc
	cCall	SetTmcText,<ax, dx>	;  write out name to COW, (converted
					; to upper case, truncated)
	mov	al,1			; exit with AX = TRUE

ValidateExit:				; AX = TRUE ==> success, FALSE ==> fail
	pop	iHelpId			; restore dialog box help id
DbAssertRel	uierr,e,0,UI,<ValidateFile: uierr not 0 on exit>	
cEnd

;****
;ChangeDir (pbPath, cbPath, szExt)
;
;Purpose:
;
;	Added with revision [15].
;
;	Validates a file spec, and changes the current drive and directory
;	to that of the give file.
;
;Input:
;	pbPath = pathname to validate (not necessarily null-terminated)
;	cbPath = size of pbPath
;	szExt   = extension to add if none present
;
;Output:
;	AX = error code, or 0 if no error
;	if no error:	b$Buf2 contains parsed file name
;			b$PN_NAME points to name portion of file name
;			current drive and directory set to that of pbPath
;Uses:
;	Per convention
;
;****
cProc	ChangeDir,<NEAR,PUBLIC>,<si,di>
	parmW	pbPath
	parmW	cbPath
	ParmW	szExt
cBegin

	mov	si,pbPath		; si = *pathname
	mov	ax,MSG_MustSpecifyName	; assume null filename
	cmp	byte ptr [si],0		; null filename?
	jz	ChangeDirExit		; brif so -- "must specify name" error

DbAssertRel	uierr,e,0,UI,<ChangeDir: uierr not 0 on entry>
	push	si			; parm #1, path
	push	cbPath			; parm #2, size of path
	mov	si,OFFSET DGROUP:b$Buf2	; si = *dest buffer (for later)
	push	si			; parm #3, dest buffer
	push	szExt			; parm #4, extension
	cCall	NormFileNameFar		; parse path into b$Buf2
					; AX = -1 ==> failure (uierr = error)
	inc	ax			; failure?
	mov	ax,0			; prepare to clear uierr
	xchg	ax,uierr		; clear uierr, ax = error code
	jz	ChangeDirExit		; brif failure

;NOTE: this section WILL work for KANJI after all!  The pathname validation code
; only accepts single-byte slashes, and sets b$PN_NAME to point after the last
; slash it sees.  So it is safe to back up over the backslash.
	mov	di,b$PN_NAME		; di = *first char of name
	push	di			; save for later
	cmp	di,(OFFSET DGROUP:b$Buf2) + 3	; is file in root directory?
	je	RootDir			; brif so - don't back up over '\'
	dec	di			; back up over the '\'

RootDir:
	push	[di]			; save char
	mov	byte ptr [di],0		; chop off name portion

	cCall	ChangeDir2		; try to change directory to the path
					; portion of the pathname in SI (b$Buf2)
					; AX = error code, or 0 if success

	pop	[di]			; restore '\' in name
	pop	di			; di = b$PN_NAME
	cmp	byte ptr [di],0		; no name portion? (directory name
					; ending with a '\')
	jnz	ChangeDirExit		; brif not -- b$PN_NAME is right

	mov	b$PN_NAME,OFFSET DGROUP:szWildDefault ; default to "*.bas"

ChangeDirExit:
cEnd

;****
;ChangeDir2 ()
;
;Purpose:
;
;	Added with revision [17].
;
;	Attempts to change the current drive and directory.
;
;Input:
;	si = *pathname to change directory to
;
;Output:
;	AX = error code, or 0 if no error
;	if no error, current drive and directory set.
;	NOTE: DRIVE MAY BE SET EVEN THOUGH ERROR OCCURRED SETTING DIRECTORY
;
;Uses:
;	Per convention
;
;****
cProc	ChangeDir2,<NEAR>
cBegin
	DbAssertRelB	[si],ne,0,UI,<ChangeDir2: Null filename>

	DbAssertRel	b$fInt24Err,ne,0,UI,<ValidateFile: Int 24 error hooked>
	cCall	HookInt24		; reset int 24 flag for later check

	cCall	SetCurDir2,<si>		; set the current drive & directory

	push	ax			; save SetCurDir2 error code
	cCall	fInt24Err		; check for int 24's first, ax = error
					; code, or 0 if none
	pop	bx			; bx = SetCurDir2 error code
	or	ax,ax			; int 24 error?
	jnz	ChangeDir2Exit		; brif so -- exit

	inc	bx			; BX = -1 ==> failure
	jnz	ChangeDir2Exit		; brif no error -- exit with ax = 0
	mov	ax,ER_PNF		; give "path not found" error
ChangeDir2Exit:
cEnd


;****
;ValidatePath (pbPath, cbPath, szExt)
;
;Purpose:
;
;	Added with revision [25].
;
;	Checks that a pathame is well-formed, then validates the path portion
;	of the name by CD'ing to it.  Restores original drive/dir when done.
;
;	Does NOT reject directory names.
;	Does NOT reject wild cards.
;
;Input:
;	pbPath = pathname to validate (not necessarily null-terminated)
;	cbPath = size of pbPath
;	szExt   = extension to add if none present
;
;Output:
;	uierr = error code, or 0 if no error
;	If no error, validated filename stored in b$Buf2
;
;Uses:
;	Per convention, plus b$Buf1 & b$Buf2
;
;****
cProc	ValidatePath,<NEAR,PUBLIC>
parmW	pbPath
parmW	cbPath
parmW	szExt
cBegin
	DbChk	HoldBuf1		; uses b$Buf1 and b$Buf2
	DbChk	HoldBuf2

	mov	ax,offset DGROUP:b$Buf1	; where to save current drive/dir
	push	ax			; save addr for later
	cCall	GetCurDriveDir,<ax>	; save current drive/dir in b$Buf1

	cCall	ChangeDir,<pbPath,cbPath,szExt>	; validate the file, and
					; (possibly) change directory.  Store
					; fully-qualified pathname in b$Buf2

	cCall	SetUiErrCond,<ax>	; set uierr = error code, if
					; error code non-zero and no
					; existing error

	pop	bx			; BX = &b$Buf1
	push	ax			; save error code
	cCall	SetCurDir2,<bx>		; restore current drive/dir from b$Buf1
	pop	ax			; return AX = error code, or 0 if OK

	DbChk	FreeBuf1		; done with b$Buf1 and b$Buf2
	DbChk	FreeBuf2

cEnd

sEnd	UI				

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uirs.asm ===
TITLE	uirs.asm - User Interface Register Set Management.
;*** 
;uirs.asm - User interface register set management.
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	This module attempts to localize the interface between the rest of
;	the user-interface and the contest manager.
;
;
;*******************************************************************************

	.xlist
	include		version.inc
	include 	..\uq\intl.inc       ;IPG - holds definition for CCHUNTITLED
	UIRS_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	names		
	includeOnce	qbimsgs
	includeOnce	txtmgr
	includeOnce	ui
	includeOnce	uiint
	.list

assumes	DS,DATA
assumes	ES,DATA
assumes	SS,DATA

sBegin	DATA
	externB szUntitled		
sEnd	DATA


sBegin	CP
assumes	cs,CP

; Added with [7]
;****
;fogNamUntitled - is this ogNam reference to an untitiled text table
;
;Purpose:
;	For QEDIT, there can be two untitled text tables: the untitled
;	text table (ogNam = OGNAM_UNNAMED) and the text table with the title
;	"UNTITLED".  Figure out if this ogNam references either of them.
;
;Entry:
;	ogNam - ogNam to check
;
;Exit:
;	TRUE - ogNam is UNTITLED or for the UNTITILED window
;
;Uses:
;	AX, BX, CX, DX
;****
cProc	fogNamUntitled,<FAR,PUBLIC>,<SI,DI>
parmw	ogNam
cBegin
	mov	ax,ogNam
	cmp	ax,OGNAM_UNNAMED	;is it the untitled text table?
	je	IsUntitled
	xor	cx,cx			;(assume special, set length)
	cmp	ax,OGNAM_PSEUDO_MAX	;is it a special one?
	jbe	IsTitled		;yes, it has a title
	push	ax
	call	FpNamOfOgNam		;es:bx = ptr to name, cx = count

IsTitled:
	xor	ax,ax			;prepare to return FALSE (not untitled)
	cmp	cx,CCHUNTITLED ;IPG			;is it 8 = len(UNTITLED)
	jne	fogExit 		;brif not, return FALSE
	mov	di,bx
	mov	si,dataOffset szUntitled
	repz	cmpsb			;is it untitled?
	jnz	fogExit 		;brif not, return FALSE

IsUntitled:
	mov	ax,sp			;return TRUE

fogExit:
cEnd

sEnd	CP

sBegin	UI
assumes	cs,UI

;**************************************************************************
;fCanContUI
;
;Purpose:
;       tests grs.otxCONT for UNDEFINED, i.e., sees if the user
;       can CONTINUE.
;Entry:
;       none.
;Exit:
;       ax = 0 and psw.Z is set if the user cannot continue
;
;*******************************************************************************
cProc	fCanContUI,<PUBLIC,NEAR,NODATA>
cBegin
	mov	ax,[grs.GRS_otxCONT]
	inc	ax			;ax = 0 if can't continue
cEnd

;**************************************************************************
; ushort GetRsName(oRs, flags, cbMax)
; Purpose:
;	Copy the ASCII Name of a given register set to the global buffer
;	'bufStdMsg'.  This may be a module name or procedure name.
;
; Entry:
;	ushort oRs = register set (as returned by RsMake)
;	uchar flags says to display name in the form:
;	  RSN_fFullName:   <module name>:<procedure name>
;		where procedure name is only included if
;		  grs.oPrsCur != UNDEFINED
;	  RSN_fIndent:     precede name with 2 spaces
;	uchar cbMax = maximum number of characters to display.  If name won't
;		fit, "..." is inserted in middle of procedure name.
;		Assumes cbMax > length of MSG_Untitled
;		Assumes cbMax > 14
;		Assumes cbMax < 256
;		If cbMax > CB_MSG_MAX (defined in qbimsgs.inc) then
;		   cbMax is forced to CB_MSG_MAX
;	mrsCur.ogNam describes module's name (assumed < 256 chars long)
;	prsCur.ogNam describes procedure's name (assumed < 256 chars long)
;
; Exit:
;	returns # bytes in name
;	bufStdMsg contains a 0-byte terminated name
;	preserves active register set on exit
;
; Algorithm:
;       if (oRs == UNDEFINED) {
;          strcpy( &bufStdMsg, "" )
;          return(2)
;          }
;	if (fFullName or grs.oPrsCur != UNDEFINED)
;	   if (((grs.oPrsCur == UNDEFINED) || fFullName) &&
;	       (mrsCur.ogNam == NULL))
;	         cbMax -= (EmitMsg('<Untitled>'))
;	   else
;	      cbMax -= Emit(pFilePart(sdMrsName.pb, cbMax))
;	   if (grs.oPrsCur != UNDEFINED)
;	      emit ':'
;	      cbMax -= 1
;	if (grs.oPrsCur != UNDEFINED)
;	   EmitName(&sdPrsName, cbMax)
;	
;**************************************************************************
cProc	GetRsName,<PUBLIC,NEAR,NODATA>,<si,di>
	parmW	oRs
	parmB	flags
	parmB	cbMax
	localD	sdName,4		
	localV	rsName,255D		
 cBegin	GetRsName
;       if (oRs == UNDEFINED) {
;          strcpy( &bufStdMsg, "" )
;          return(2)
;          }
	mov	di,dataOFFSET bufStdMsg	;di points to destination buffer
	mov	ax,[oRs]
	inc	ax			; Is oRs UNDEFINED?
	jne	oRsOk
	mov	byte ptr [di],0		;store 0-byte terminator
	jmp	GetRsNameEnd		;return ax = length = 0

oRsOk:
	; make a fake sd for use with ogNam of the Rs
	lea	si,rsName		
	mov	[SEG_sdName],si		; set up pointer part of fake sd

	dec	ax			;restore ax = oRs parm
	push	[grs.GRS_oRsCur]	;preserve current context
					; (will be restored on exit)
	push	ax
	call	UiRsActivate		;activate register set of interest
	push	ds
	pop	es			;es = DGROUP for stosb, movsb
	mov	dx,[grs.GRS_oPrsCur]
	and	dh,dl			;dh = FF only if oPrsCur == UNDEFINED
	mov	dl,[cbMax]		;dl = cbMax
	cmp	dl,CB_MSG_MAX
	jbe	CbMaxOk			;brif cbMax <= CB_MSG_MAX
	mov	dl,CB_MSG_MAX		;force cbMax within range
CbMaxOk:
	test	[flags],RSN_fIndent
	je	NoIndent1
	dec	dl			;cbMax -= 2
	dec	dl
NoIndent1:
	inc	dh			;dh = 0 if oPrsCur == UNDEFINED
	je	ListModName		;brif no active procedure
	test	[flags],RSN_fFullName
	je	ListProcName		;brif caller doesn't want mod name
ListModName:
	push	dx			; preserve DX
	push	[mrsCur.MRS_ogNam]	
	call	fogNamUntitled		
	pop	dx			; restore DX
	or	ax,ax			; is it an untitled module?
	mov	bx,MSG_Untitled		; assume so
	jne	SpecialOgNam		;brif module is untitled
	mov	bx,MSG_Immediate	
	mov	ax,[mrsCur.MRS_ogNam]	
	cmp	ax,OGNAM_IMMEDIATE	
	jne	NotSpecialOgNam		;brif module is Immediate window
SpecialOgNam:
	push	dx			;preserve dx
	push	bx			;pass MSG_xxx
	call	ListStdMsg		;copy "<Untitled>" to buffer,
					; ax = #bytes (international <> 8)
	pop	dx			;restore dx
	add	di,ax			;di points beyond "<Untitled>"
	inc	ax			;add 1 for following space if proc
	sub	dl,al			;cbMax = #bytes left in buffer
	jmp	SHORT TryProcName

NotSpecialOgNam:
	push	dx			; preserve across call
	cCall	CopyOgNamPb,<si,ax>	; copy name into fake sd on stack
	pop	dx			
	mov	[OFF_sdName],ax		; save cbName in cb part of fake sd
	xchg	ax,bx			; bx = length of module name
	cCall	pFilePart		; Get pointer to file part of file spec.
					; pointer in si; count in bx
					; all other regs preserved.
	sub	dl,bl			; cbMax -= length of module's name
	mov	cx,bx			; Get byte count of file spec.
	rep movsb			; copy filename to destination

;	if (grs.oPrsCur != UNDEFINED)
;	   if (anything emitted yet)
;	      emit ':'
;	   EmitName(&sdPrsName, cbMax)
;
; dh = 0 if no prs is active
; di points into bufStdMsg
; dl = max bytes left in output buffer
;
TryProcName:
	or	dh,dh
	je	ListZeroTerm		;brif no procedure is active
	mov	al,':'
	stosb				;emit ':' between module and proc name
	dec	dl			;cbMax -= 1
ListProcName:
	push	dx			; preserve across call
	lea	si,rsName		
	cCall	CopyOgNamPb,<si,prsCur.prs_ogNam> 
	pop	dx			
	lea	si,sdName		
	mov	[si.SD_cb],ax		
	call	EmitName		;EmitName(si, di, dl)

;di points beyond last byte of name
ListZeroTerm:
	test	[flags],RSN_fIndent
	je	NoIndent2		;brif no space to be inserted at front
	mov	si,di
	dec	si			;si points to last byte of name
	inc	di
	push	di			;save ptr beyond last byte
	mov	cx,di
	sub	cx,dataOFFSET bufStdMsg	;cx = byte count of name
	std
	rep movsb			;shift name right 2 bytes
	cld
	mov	ax,' '
	stosb				;put '  ' in front of name
	stosb
	pop	di			;di points to last byte of name
	inc	di			;di points beyond last byte of name
NoIndent2:
	pop	ax			;ax = caller's context
	inc	ax			;test for UNDEFINED
	je	NoRsWasActive
	dec	ax			;restore ax = oRs
	push	ax
	call	UiRsActivate		;re-activate saved register set
NoRsWasActive:
	mov	byte ptr [di],0		;store 0-byte terminator
	xchg	ax,di			;ax points beyond end of name
	sub	ax,dataOFFSET bufStdMsg	;ax = actual size (return value)
;ax = #bytes in name
GetRsNameEnd:
	DbAssertRelB	[cbMax],ae,al,UI,<GetRsName: name too long>	
	; If the pathname code doesn't truncate names/extensions,
	; GetRsName can return > cbMax chars, hosing DGROUP, etc.
cEnd	GetRsName

;**************************************************************************
; EmitName(si = psdSrc, di = pbDst, dl = cbMax)
; Purpose:
;	List as much of a name as possible, storing "..." in middle
;	if insufficient room.
;
; Entry:
;	si = psdSrc = pointer to source name's string descriptor
;	di = pbDst = pointer to destination buffer
;	dl = size of destination buffer (assumed > 15)
;
; Algorithm:
;  think of name as [cbLeft-cbSkip-cbRight]
;  if entire name won't fit in destination, [cbLeft...cbRight] is listed
;  cbLeft = cbMax / 2
;  cbRight = cbMax - cbLeft
;  cbSkip = cbName - cbLeft - cbRight = cbName - cbMax
;
; Exit:
;	di points beyond emitted name
;
; Alters:
;	al, bx, cx, si (ALL others are preserved)
;
;**************************************************************************
EmitName:
	mov	cx,[si.SD_cb]		;cx = length of name
					; we can assume ch == 0
	mov	si,[si.SD_pb]		;si points to 1st byte of name
	sub	al,al			;al = cbRight = 0 (assume name fits)
	cmp	cl,dl			;compare cbName with cbMax
	jbe	NameFits		;brif plenty of room for entire name
	sub	dl,3			;account for the `...'
	mov	bx,cx			;bx = bl = cbName
	mov	cl,dl			;cx = cl = cbMax
	shr	cl,1			;cx = cl = cbLeft = cbMax / 2
	mov	al,dl			;al = cbMax
	sub	al,cl			;al = cbRight = cbMax - cbLeft
	sub	bl,dl			;bx = bl = cbSkip = cbName - cbMax
NameFits:
	rep movsb			;copy left part of name
	mov	cl,al			;cx = cl = cbRight
	jcxz	EmitNameExit		;brif no right half to emit
	mov	al,'.'
	stosb				;emit '...'
	stosb
	stosb
	add	si,bx			;si points to right half of name
	rep movsb			;copy right part of name
EmitNameExit:
	ret

;**************************************************************************
; pFilePart(si = pointer to file spec, bx = byte count of file spec)
; Purpose:
;  Advance file spec pointer so that it points to the filename part.
;  Adjust byte count accordingly
;
;  KANJI variant added with [6]
;
; Entry:
;    SI - Pointer to file spec.
;    BX - Count of bytes in file spec.
;
; Exit:
;    SI - Pointer to file part of file spec.
;    BX - Count of bytes of file part in file spec.
;
; Alters: si, bx
;
;**************************************************************************

DbPub pFilePart
cProc pFilePart,<NEAR>,<AX,CX,DX,DI,ES>
cBegin

	push	ds
	pop	es

	mov	di,si
	mov	al,'\'
	mov	cx,bx
ScanForBackSlash:
	repne scasb
	jne	NoMoreBackSlash
	inc	si			; Point after the '\'
	mov	bx,cx			; Save away the count and the pointer
	mov	si,di
	jmp	SHORT ScanForBackSlash

NoMoreBackSlash:

	cmp	bx,2
	jbe	pFilePartEnd
	cmp	byte ptr [si+2],':'	; Is there a drive specification.
	jne	pFilePartEnd
	inc	si			; Throw away drive specification.
	inc	si
	dec	bx
	dec	bx
pFilePartEnd:
cEnd


;************************************************************************
; boolean ContContext()
; Purpose:
;	Make the current MRS and PRS the one where BASIC's program counter
;	is pointing.  If CONTinue is not possible, make main module active.
;
; Exit:
;	If unable to CONT and no main module
;	   returns FALSE
;	else
;	   returns TRUE after setting up grs.oRsCur, grs.otxCur
;
;************************************************************************
cProc	ContContext,<PUBLIC,NEAR>
cBegin
	mov	ax,[grs.GRS_otxCONT]
	mov	[grs.GRS_otxCur],ax
	inc	ax			;test for UNDEFINED
	mov	ax,[grs.GRS_oRsCONT]
	jne	CanCont

	;we can't continue, use 'main' module if there is one
	mov	ax,[grs.GRS_oMrsMain]
	inc	ax
	je	CcExit			;brif no main module
	mov	[grs.GRS_otxCur],0	;grs.otxCur = 0
	dec	ax
;ax = oRs containing next stmt to be executed
CanCont:
	cCall	UiRsActivate,<ax>
	mov	ax,sp			;return TRUE
CcExit:
	or	ax,ax			;set condition codes for caller
cEnd

;************************************************************************
; boolean NeedContContext()
; Purpose:
;	Make the current MRS and PRS the one where BASIC's program counter
;	is pointing.  If CONTinue is not possible, make main module active.
;
; Exit:
;	If unable to CONT and no main module
;	   [uierr] = MSG_NoMainProg
;	   txtErr.oRs = UNDEFINED (so cursor won't be positioned by ReportError)
;	   returns FALSE
;	else
;	   returns TRUE after setting up grs.oRsCur, grs.otxCur
;
;************************************************************************
cProc	NeedContContext,<PUBLIC,NEAR>
cBegin
	call	ContContext		;activate CONT program counter
	jne	CcNoErr			;brif can CONT
	PUSHI	ax,MSG_NoMainProg
	call	SetUiErr
	xor	ax,ax			; set ax and condition codes
CcNoErr:
cEnd

sEnd	CP

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uiscrn.c ===
/*** 
*uiscrn.c - screen management functions.
*
*	Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*	Miscellaneous procedures to interface QB with CW screen operations.
*
*******************************************************************************/

/* First, include version definition header */
#include <version.h>

/* Next, include TextWin's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>

/* Next, include QBI's headers */
#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

#ifndef HEAP_H
#include <heap.h>
#endif

void far EnsShowDebugScrFar(void);
void far ShowOutScr(void);
void far EnsMouseOff(void);
void far TossOutputScreen(void);
void near Cls (void);
void near SaveUserMouse(void);
void near RestoreUserMouse(void);

extern bool FAR PASCAL FInitMouse(void);	//[17]
extern void FAR PASCAL EndMouse(void);		//[17]

extern void FAR PASCAL SetBlinkBit(ushort);

bool fDebugScr = FALSE;             /* TRUE if debug screen is visible,
				       FALSE if Output Screen is visible */

extern WORD iModeCurrent;

bd bdVids = {0, NULL, 0};
bd bdVidsDebug = {0, NULL, 0};
bdl bdlVidData = {0, NOT_OWNER, 0, 0};
bdl bdlUserMouse = {0, NOT_OWNER, 0, 0};	//[17]

/*** 
*void near Cls ()
*Purpose:
*	Clear the output screen.  This is used if we couldn't restore the
*	output screen.
*
*Entry:
*	None.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
void near Cls ()
{
    RRC rrc;

    rrc.rxLeft = rrc.ryTop = 0;
    rrc.rxRight = axMac;
    rrc.ryBottom = ayMac;
    FillRrc (NULL, &rrc, ' ', isaBackground);
}


/*** 
*void near SaveUserMouse
*Purpose:
*	Saves the mouse state of the User's mouse
*
*	New for revision [17]
*
*Entry:
*
*Exit:
*
*Exceptions:
*	None.
*******************************************************************************/
void near SaveUserMouse()
{
    WORD cbMouse;

    BdlFree(&bdlUserMouse);

    cbMouse = CbSizeMouseState();
    if (cbMouse && BdlAlloc (&bdlUserMouse, cbMouse)) {
       SaveMouseState((void FAR *) MAKELONG (0, GETSEG (bdlUserMouse.seg)));
    }
}

/*** 
*void near RestoreUserMouse
*Purpose:
*	Restores the mouse state of the user's mouse
*
*	New for revision [17]
*
*Entry:
*
*Exit:
*
*Exceptions:
*	None.
*******************************************************************************/
void near RestoreUserMouse()
{
    if (bdlUserMouse.seg != NOT_OWNER) {
       RestoreMouseState((void FAR *) MAKELONG (0, GETSEG (bdlUserMouse.seg)));
       BdlFree(&bdlUserMouse);
    }
}

/*** 
*void near SaveUserScreen ()
*Purpose:
*	Save the contents of the output screen.
*
*	If we don't have enough room for the screen data, we still save the
*	mode information so we can at least change modes and clear the screen
*	properly.
*
*Entry:
*	bdVids		Is a bd to be used for the mode structure data.
*	bdlVidData	Is a bdl to be used for the screen contents.
*
*Exit:
*	bdVids and bdlVidData contain the information from the output
*	screen if there is room to store them.
*
*Exceptions:
*	None.
*******************************************************************************/
void near SaveUserScreen ()
{
    INST inst;
    WORD cbVids;

    if ((cbVids = CbSizeVids ()) == 0)
	return;						//[17]

    if (!BdAlloc (&bdVids, cbVids, IT_NO_OWNERS))
	return;						//[17]

    if (!FQueryInst (&inst, iModeCurrent))	/* [3] */
	DbAssert (FALSE);
    if (!FSaveVids ((VIDS *)bdVids.pb, &inst)) {	//[12]
	DbAssert (FALSE);
    }

    if (BdlAlloc (&bdlVidData, ((VIDS *)bdVids.pb)->cwVidData * sizeof (WORD)))	//[12]
	SaveVidData ((VIDS *)bdVids.pb, (WORD FAR *) MAKELONG (0, GETSEG (bdlVidData.seg)));	//[12]
    else
	// Must free, as FRestoreVids doesn't clear and leaves junk on screen.
	BdFree (&bdVids);

    if (bdVidsDebug.pb != NULL) 				// [6]
	if (!FRestoreVids ((VIDS *) bdVidsDebug.pb))		// [6]
	    DbAssert (FALSE);					// [6]
    
    SetBlinkBit(0);

}

/*** 
*void near RestoreUserScreen ()
*Purpose:
*	Restore the output screen from previously stored data in
*	SaveUserScreen.
*
*Entry:
*	bdVids		Global data pertaining to the mode and screen overhead.
*	bdVidData	Global data containing the screen contents.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
void near RestoreUserScreen ()
{
    INST inst;
    WORD cbVids;

    BdFree (&bdVidsDebug);					// [6]
    if ((cbVids = CbSizeVids ()) == 0)				// [6]
	goto FailRestore;					// [6]
    if (!BdAlloc (&bdVidsDebug, cbVids, IT_NO_OWNERS))		// [6]
	goto FailRestore;					// [6]
    if (!FQueryInst (&inst, iModeCurrent))			// [6]
	DbAssert (FALSE);					// [6]
    if (!FSaveVids ((VIDS *) bdVidsDebug.pb, &inst))		// [6]
	DbAssert (FALSE);					// [6]

    if (bdVids.pb == NULL) {					//[12]
FailRestore:							// [6]
	Cls ();
	return;
    }

    if (!FRestoreVids ((VIDS *) bdVids.pb)) {			//[12]
	DbAssert (FALSE);
    }
    // [5] May not have data, but restored mode if possible.
    else if (bdlVidData.seg != NOT_OWNER) {
	RestoreVidData ((VIDS *)bdVids.pb,			//[12]
			(WORD FAR *) MAKELONG (0, GETSEG (bdlVidData.seg)));
    }

    TossUserScreen();
}

void near TossUserScreen ()
{
    BdFree (&bdVids);
    BdlFree (&bdlVidData);
}

void far EnsShowDebugScrFar ()
{
    EnsShowDebugScr ();
    FEnableMouse(TRUE);			//[17]
}

/*** 
*void near EnsShowDebugScr ()
*Purpose:
*	If the debug screen is not already visible, save the user screen.
*
*Entry:
*	None.
*
*Exit:
*	None.
*
*Exceptions:
*	None.
*******************************************************************************/
void near EnsShowDebugScr ()
{
    if (!fDebugScr) {
	/* Output screen is currently visible */
	fDebugScr = TRUE;
      
	/* put screen in User Interface compatible (text) mode.
	 * User's screen may have been in high or low-res graphics mode.
	 * Don't save user's screen image if memory is so low that
	 * there's not enough to execute a SYSTEM, CLEAR, or SETMEM statement.
	 * This is ensured by calling UiGrabSpace first.
	 */
	UiGrabSpace();
	SaveUserMouse();	//[17]
	EndMouse();		//[17] This will turn off the user's mouse so
				//[17] it won't get saved by SaveUserScreen
	SaveUserScreen ();
	UiReleaseSpace();
	FInitMouse();		//[17]
	DrawDebugScr ();	//[16]
    }
}

/**************************************************************************
* void near EnsShowOutSaveRs()
* Purpose:
*  If the output screen is not already
*  visible, switch  to saved  output screen mode and copy
*  the buffer saved by EnsShowDebugScr() to video ram.
*  Unlike EnsShowOutputScr, this function DOES NOT flush the edit manager's
*  buffer, and thus, perserves the caller's register set.
*
**************************************************************************/
void near EnsShowOutSaveRs()
{
    if (fDebugScr) {
	fDebugScr = FALSE;
	/* Restore the user screen */
	RestoreUserScreen ();
	RestoreUserMouse();	//[17]
    }
}

/**************************************************************************
* ShowOutScr
* Purpose:
*  called by PRINT, CALL executors that want to force the user's screen
*  to be restored.
*
**************************************************************************/
void far ShowOutScr ()
{
    EnsShowOutSaveRs ();
}

/**************************************************************************
* EnsMouseOff
* Purpose:
*  Called by runtime initialization code just before a call to B$RUNINI
*  to turn the mouse off so it won't leave a ghost cursor when it clears
*  the screen.
*
**************************************************************************/
void far EnsMouseOff ()
{
    FEnableMouse(FALSE);	//[17]
}

/**************************************************************************
* TossOutScreen()
* Purpose:
*  The runtime has changed screen modes while the debug screen was active.
*  We need to change state to be consistent with the output screen being active.
*  Output screen and mouse will be resaved by the next call to EnsShowDebugScr.
*
**************************************************************************/
void far TossOutputScreen ()
{
    TossUserScreen ();	/* release memory used to save output scr */
    fDebugScr = FALSE;
}

/**************************************************************************
* void near EnsShowOutputScr()
* Purpose:
*  If the output screen is not already
*  visible, switch  to saved  output screen mode and copy
*  the buffer saved by EnsShowDebugScr() to video ram.
*  Unlike EnsShowOutSaveRs, this function flushes the edit manager's
*  buffer, and thus, may alter caller's register set.
*
**************************************************************************/
void near EnsShowOutputScr ()
{
    EditMgrFlush ();
    /* so dirty buffer can never be written to user's screen by edit mgr */
    EnsShowOutSaveRs ();
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uirsc.c ===
/*** 
*uirsc.c - Register Set routines.
*
*	Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*	User interface routines to handle register sets.
*
*******************************************************************************/

/* First, include version definition header */
#include <version.h>

/* Next, include COW's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>

/* Next, include QBI's headers */
#ifndef CONTEXT_H
#include <context.h>
#endif

#ifndef LISTER_H
#include <lister.h>
#endif

#ifndef NAMES_H					/* [1] */
#include <names.h>				/* [1] */
#endif						/* [1] */

#ifndef PARSER_H
#include <parser.h>
#endif

#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef TXTMGR_H
#include <txtmgr.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

#ifndef UTIL_H
#include <util.h>
#endif

/*----------------------------------------------------------------------*
 * register set management (i.e. interface with context manager)  *
 *----------------------------------------------------------------------*/

/**************************************************************************
* UiRsActivate(oRs)
* Purpose:
*  Tell the context manager to activate the specified register set.
*  If oRs == UNDEFINED, no register set is active on exit.
*
**************************************************************************/
void near UiRsActivate (oRs)
ushort oRs;
{
    DbAssert (oRs != hbufHelp); // [6] Shouldn't be activating help
    if (grs.oRsCur != oRs)	/* speed optimization */
	RsActivate (oRs);
    UiFlushCache ();
}

/**************************************************************************
* UiRsActivateWnd
* Purpose:
*  Tell the context manager to activate the active window's register set
*
**************************************************************************/
void near UiRsActivateWnd ()
{
    register struct ef *pef = (struct ef *) pwndAct->pefExtra;	// [7]

    DbAssert (pwndAct != NULL);
    if (pef->hBuffer != hbufHelp)	/* [5] */
	UiRsActivate (pef->hBuffer);
}

/**************************************************************************
* ushort near RsMake(psdName, rsType)
* Purpose:
*  Tell the context manager to create a text table (register set).
*  This may be a mrs (module register set) or prs (procedure register set).
*  If rsType == RS_sub or RS_function, the new procedure will be put in the
*     current module.  If the command window, or text file is active, the
*     procedure will be put in the MAIN module.  If there is no MAIN
*     module, uierr = MSG_NoMainProg on exit.
* Entry:
*  psdName points to sd for the name the context manager
*     is to associate with the register set.
*  rsType is the type of entry being created (RS_xxx)
* Exit:
*  if out-of-memory, duplicate module, or duplicate procedure error,
*     returns UNDEFINED and the global uierr indicates the error code.
*  the oRs is returned.
*
**************************************************************************/
ushort NEAR RsMake (psdName, rsType)
sd *psdName;
REG1 char rsType;
{
    REG2 ushort errCode;
    ushort result;
    ushort ogNam;			/* [1] */

    result = UNDEFINED;
    if (rsType == RS_cmdWnd)		/* [2] */
	ogNam = OGNAM_IMMEDIATE;	/* [2] */
    else if (rsType == RS_scrap)	/* [2] */
	ogNam = OGNAM_CLIPBOARD;	/* [2] */
    else {				/* [2] */
	ogNam = OgNamOfPsd(psdName);	/* [1] */
	if (!ogNam) {			/* [1] OM error returned by nammgr */
	    errCode = ER_OM;		/* [1] */
	    goto CheckErr;		/* [1] */
	}				/* [1] */
    }

    if ((rsType == RS_sub) || (rsType == RS_function)) {
	if (mrsCur.flags2 & FM2_NoPcode) {
	    // Current module is not pcode, just an ASCII file.
	    // It is either be the cmd window or document file.
	    if (grs.oMrsMain == UNDEFINED) {
		errCode = MSG_NoMainProg;  /* Error: No main program */
		goto CheckErr;
	    }
	    /* put new procedure in MAIN source file */
	    UiRsActivate(grs.oMrsMain);
	}
	if (rsType == RS_function) {
	    /* There may already be references to this function that look
	     * like variables.	Since PrsMake causes the pcode for
	     * the FUNCTION and END FUNCTION stmts to be inserted,
	     * this makes sure a variable table entry gets built
	     * for the function by the Rude Scanner.
	     */
	    ModuleRudeEditFar();
	}
	errCode = PrsMake (ogNam, (rsType == RS_sub) ?
				  (char) PT_SUB : (char) PT_FUNCTION); // [1]
    }
    else {
	/* make use of REG var 'errCode' to set flags */
	errCode = 0x100 * FM2_File;		/* assume it is a module */
	if ((rsType == RS_cmdWnd) || (rsType == RS_scrap))	/* [2] */
	    errCode = 0x100 * FM2_NoPcode;
	if (rsType == RS_document)
	    errCode = 0x100 * (FM2_File | FM2_NoPcode);
	if (rsType == RS_includeFile)
	    errCode= 0x100 * (FM2_File | FM2_Include);
	errCode = MrsMake (ogNam, errCode);	/* [1] */
    }

CheckErr:
    if (errCode != 0) {
	/* tell GetCmd to remember to report the error
	 * and not to position the cursor
	 */
	SetUiErr (errCode);
    }
    else
	result = grs.oRsCur;
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uisearch.c ===
/***
*uisearch.c - Search and Replace code.
*
*       Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*       Routines to support Search/Find, and Search/Change.
*
*******************************************************************************/

#include <version.h>

/* Next, include TextWin's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>

#include <uiext.h>
#include <uinhelp.h>            //[17]

/* include dialog information */
#include <cw/dlg.h>
#include "uisearch.hs"
#include "uisearch.sdm"

#ifndef CONTEXT_H
#include <context.h>
#endif

#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

#ifndef UTIL_H
#include <util.h>
#endif

#ifndef RTPS_H
#include <rtps.h>
#endif


/* Externals */
STATICF(boolean) StartSearch(void);         //[18]
STATICF(boolean) SearchNext(boolean);
STATICF(boolean) FEndOfSearch(void);
STATICF(boolean) SearchLine(void);
STATICF(ushort) obFind(char *, ushort, ushort, char *);
STATICF(ushort) obFindLabel(char *, ushort, ushort, char *);
STATICF(void) DoChange(void);
STATICF(void) MakeBdlFromBuf (bdl *, char *);  //[28]
STATICF(void) MakeBufFromBdl (char *, bdl *);  //[28]
STATICF(boolean) fSrchLastAlpha (ushort);
STATICF(ushort) SrchORsOfAlpha (ushort);
STATICF(TMC) DoDlgSearch (void far *, WORD, WORD, BOOL);
AY FAR PASCAL GetUILine (void); //[39]
void NEAR SelectTextPwndCur(ushort, ushort, ushort); //[39]

#define isInActiveWindow 0              //[39] taken from UISEARCH.DES
#define isInCurrentModule 1             //[39]

/* Static Data */
boolean fMatchCase = FALSE;
boolean fWholeWord = FALSE;
boolean fLabel;
ushort  oSearchInSave = isInCurrentModule;      //[36]

/*
  The following are used to determine when a search is complete.
  They are set by StartSearch and SearchNext, and are tested by FEndOfSearch.
  They are updated by SrchReAssign.
  No one else should touch them.
*/
ushort ioRsSrchStart;
ushort ioRsSrchCur;
bd bdSearchAlpha;
static ushort olnStart;
static ushort obStart;
static ushort olnCur;
static ushort obCur;
static boolean fWrapped;

/*
  scopeOfSearch controls the scope of the search.
  It is one of:
     isInActiveWindow, isInCurrentModule
*/
static ushort scopeOfSearch = isInCurrentModule;

/*
  bdlSaveFind is where the last search string is saved for later use
  (It is saved in the far heap to save DGROUP space).
*/
#define CBMAX_FIND      FILNAML         //[28]
#define CBMAX_CHANGE    FILNAML         //[28]
bdl bdlSaveFind = { 0, NOT_OWNER, 0, 0 };
bdl bdlSaveChange = { 0, NOT_OWNER, 0, 0 };     //[28]


/****
*STATICF(TMC) DoDlgSearch - Display dialog for standard searches
*
*Purpose:
*       This routine will display the dialog for any type of search and
*       also for search/change.  It will deturmine the proper defaults for
*       all the buttons from static variables.  After the dialog is displayed,
*       this routine will update the static variables to reflect what the
*       user actually selected.
*
*Entry:
*       pdlg    - Pointer to dialog structure
*       cbDlg   - size of dialog structure
*       cabi    - cab for dialog
*       fSearchChange - TRUE if this dialog is the Search/Change dialog
*
*       fMatchCase - static variable:default value of case matching
*       fWholeWord - static variable:default value of whole word searching
*       oSearchInSave - static variable:default value of search location
*                       if the window is not the help window.
*       fEZMenu    - static variable:use easy or full menus (!FK_KANJI only)
*       &b$Buf1    - default value to search for (may be empty).
*       &b$Buf2    - default value to change to (may be empty).
*
*Exit:
*       returns tmc value of dialog or FALSE for cancel or error.
*
*Uses:
*       Per C Convention.
*
*****/
STATICF(TMC) DoDlgSearch (pdlg, cbDlg, cabi, fSearchChange)
void far *pdlg;
WORD cbDlg, cabi;
BOOL fSearchChange;
{
    HCABSearchChange hcabSearch = (HCABSearchChange) HcabAlloc (cabi);
    TMC tmc = tmcCancel;        // [10]

    /* [2] Catch HcabAlloc errors */
    if (uierr)
        return (FALSE);

    (*hcabSearch)->fMatchCase = fMatchCase;
    (*hcabSearch)->fWholeWord = fWholeWord;

    SzToCab (hcabSearch, &b$Buf1, Iag (CABSearchChange, szFindWhat));   //[28][19]
    SzToCab (hcabSearch, fSearchChange ? &b$Buf2 : "",                  //[28]
             Iag (CABSearchChange, szChangeTo));
    // [10] if SzToCab memory allocation failed, free cab and exit.
    if (uierr)
        goto DoDlgSearchEnd;

DoSearchAgain:  /* [3] If the search string is empty, we should repeat */
    tmc = TmcDoDlgFar (pdlg, cbDlg, hcabSearch);

    if (tmc != tmcCancel) {
        scopeOfSearch = isInCurrentModule;              //[39]

        // Update default value for search scope if we are not in help window
        if (pwndAct != &wndHelp)                        //[36]
            oSearchInSave = scopeOfSearch;              //[36]

        fMatchCase = (*hcabSearch)->fMatchCase;
        fWholeWord = (*hcabSearch)->fWholeWord;
        SzFromCab (hcabSearch, &b$Buf1, CBMAX_FIND,                     //[28]
                   Iag (CABSearchChange, szFindWhat));
        if (!CbSzUi (&b$Buf1)) {                                        //[28]
            MsgBoxStd (MB_OK, MSG_NoSearchString);                      //[39]
            goto DoSearchAgain;         /* [3] */
        }

        if (fSearchChange) {
            SzFromCab (hcabSearch, &b$Buf2, CBMAX_CHANGE,               //[28]
                       Iag (CABSearchChange, szChangeTo));
        }
    }

DoDlgSearchEnd:         // [10]
    FreeCab (hcabSearch);                       /* [3] */
    return ((tmc == tmcCancel) ? FALSE : tmc);  /* [3] */
}


VOID near CmdSearchFind (fPrompt, fUseSelect, fLabelT)
boolean fPrompt;
boolean fUseSelect;
boolean fLabelT;
{
    TMC tmc;
    ushort cbSelection;
    boolean fGotSelect;
    boolean fNotFound;          //[21] was the item found?

    EditMgrFlush1 ();

    fLabel = fLabelT;

    if (fLabelT) {
        fWholeWord = TRUE;
        fMatchCase = FALSE;
        scopeOfSearch = isInCurrentModule;
    }

    DbChkHoldBuf1();            //[28]
    fGotSelect = ((cbSelection = GetSelText (&b$Buf1, CBMAX_FIND)) != 0);       //[28]
    if (!fGotSelect) {
        /* no text is selected, set default to what ever word cursor is on */
        cbSelection = GetEditWord (&b$Buf1, CBMAX_FIND);  //[28][7]
    }
    if (!((fUseSelect || bdlSaveFind.cbLogical == 0) && cbSelection)) {
        /* Don't use selected text, or word under cursor, as FIND pattern */
        MakeBufFromBdl (&b$Buf1, &bdlSaveFind);                 //[28]
    }
    if (fPrompt || b$Buf1 == '\0' || (fUseSelect && !fGotSelect) ||     //[35]
        (fLabelT && !fGotSelect)) {
        tmc = DoDlgSearch (&dlgSearchFind, sizeof (dlgSearchFind),
                           cabiCABSearchFind, FALSE);
    }
    else {
        tmc = tmcOk;
    }

    if (tmc == tmcOk) {

        MakeBdlFromBuf (&bdlSaveFind, &b$Buf1); //[28]

//
// a-emoryh - In Dos6 QHelp, search context strings first, then if not found,
//            search everything.
//
         if ((pwndAct == &wndHelp) && (cmdSwitches & CMD_SW_QHELP))
         {
            // Search context strings first.  Fast!!
            if (DisplayHlpWndSz(&b$Buf1) == 0)
               // Found string!  Exit now.
               goto CmdSearchFindEnd;
         }


         //
         // Didn't find string, so search everything now.  Slow!!
         //
         if (StartSearch() || uierr)             //[18] if any problems, exit
             goto CmdSearchFindEnd;

         fNotFound = !SearchNext (TRUE) && !uierr;               //[21]

                                                             //[21]
         // Reset the current help topic if it needs it.  This   //[21]
         // Must be done before the message box, as it will      //[21]
         // cause the screen to be redrawn with the wrong help   //[21]
         // help topic.                                          //[21]

         DbChkFreeBuf1();                                        //[28]
         if (pwndAct == &wndHelp) {                              //[21]
             if (fAbort)                                 //[21][27]
                 SendHelpMsg(WM_HELPRESTORETOPIC,0);             //[21]
             else if (ioRsSrchStart != ioRsSrchCur)//[7]         //[21]
                 SendHelpMsg(WM_HELPCHGTOPIC,ioRsSrchCur);       //[21]
         }                                                       //[21]

         if (fAbort)                               //[39]
             FlushMsgs();                          //[39] Get rid of ESCAPE
         else if (fNotFound) {                     //[21] don't put up dialog box
             MsgBoxStd (MB_OK, MSG_MatchNotFound); //[18] if error
         }
    }

   CmdSearchFindEnd:
    DbChkFreeBuf1();            //[28]
    CloseCurHelpFile();         //[15] close current help file if one opened.
    BdFree (&bdSearchAlpha);
}

/***
*fSrchLastAlpha - have we visited the last text table
*
*Purpose:
*       Indicates if i is the last text table of the sorted list of
*       text tables that we created.
*
*Entry:
*       i - index into bdSearchAlpha list (0 based)
*
*Exit:
*       TRUE - if i is at or beyond last text table
*       FALSE- otherwize
*
*****/
STATICF(boolean) fSrchLastAlpha (i)
ushort i;
{
    return (i >= (bdSearchAlpha.cbLogical >> 1));
}

/***
*SrchORsOfAlpha - get the ith entry from the sorted text table list.
*
*Purpose:
*       Returns the ith entry from the sorted text table list that
*       is assumed to already be created.  If fSrchLastAlpha(i) is
*       TRUE, then undefined results are returned.
*
*Entry:
*       i - index into bdSearchAlpha list (0 based)
*
*Exit:
*
*
*****/
STATICF(ushort) SrchORsOfAlpha (i)
ushort i;
{
    return (((ushort *) bdSearchAlpha.pb)[i]);
}

VOID near CmdSearchChange ()
{
    struct ef *pef = (struct ef *) pwndAct->pefExtra;   // [20]
    boolean fChange = FALSE;
    TMC tmc;
    CRC far *pcrc = &dlgConfirm.dlgHeader.crcDlg;
    HCABConfirm hcabConfirm;
    AY ay;

    fLabel = FALSE;                                             //[33]
    EditMgrFlush1 ();

    /* fReadOnlyBuf sets uierr if INCLUDEd lines are visible */
    DbAssert (pwndAct != NULL);
    if (fReadOnlyBuf(pef->hBuffer))
        return;

    DbChkHoldBuf1();                                            //[28]
    DbChkHoldBuf2();                                            //[28]
    if (!GetSelText(&b$Buf1, CBMAX_FIND))                       //[28]
        MakeBufFromBdl (&b$Buf1, &bdlSaveFind);                 //[28]
    MakeBufFromBdl (&b$Buf2, &bdlSaveChange);                   //[28]

    // [11] If Cancelled, exit.
    if (!(tmc = DoDlgSearch (&dlgSearchChange, sizeof (dlgSearchChange),
                             cabiCABSearchChange, TRUE)))
        goto CmdSearchChangeDone;
    MakeBdlFromBuf (&bdlSaveFind, &b$Buf1);                     //[28]
    MakeBdlFromBuf (&bdlSaveChange, &b$Buf2);                   //[28]

    if (tmc == tmcFindAndVerify) {
        if (StartSearch() || uierr) goto CmdSearchChangeDone;   //[18]
        if ( !SearchNext (TRUE) && !uierr) {
            if (fAbort)                                         //[39]
                FlushMsgs();                                    //[39]
            else                                                //[39]
                MsgBoxStd (MB_OK, MSG_MatchNotFound);
            goto CmdSearchChangeDone;
        }
        else {
            do {
                // [18] we must branch now if any errors, otherwise we
                // [18] will not dealloc the cab
                if (uierr)
                    goto CmdSearchChangeEnd;

                hcabConfirm = (HCABConfirm) HcabAlloc (cabiCABConfirm);
                /* [2] Catch HcabAlloc errors */
                if (uierr)
                    goto CmdSearchChangeEnd;

                ay = ayMac - (pcrc->dy + 1);
                pcrc->y = (GetUILine () < ay) ? ay : 2;

                DoDrawDebugScr();    // [8]
                tmc = TmcDoDlgFar (&dlgConfirm, sizeof (dlgConfirm), hcabConfirm);
                FreeCab (hcabConfirm);
                if (tmc == tmcCancel)
                    goto CmdSearchChangeEnd;
                if (tmc == tmcChange)
                    DoChange ();
                else if (tmc == tmcSkip)
                    obCur++;
                if (uierr) goto CmdSearchChangeEnd;
            } while (SearchNext (TRUE));

            if (fAbort)                 //[39]
                FlushMsgs();            //[39] get rid of ESCAPE, no msg box
            else if (!uierr)            //[18]
                MsgBoxStd (MB_OK, MSG_ChangeComplete);
        }
    }

    else if (tmc == tmcChangeAll) {
        if (StartSearch() || uierr) goto CmdSearchChangeDone;   //[18]
        SendMessage (pwndAct, WM_SETREDRAW, FALSE, 0L );        //[29]
        while (SearchNext (FALSE)) {
            fChange = TRUE;
            DoChange();
            if (uierr) break;
        }
        SendMessage (pwndAct, WM_SETREDRAW, TRUE, 0L);
        if (uierr) goto CmdSearchChangeEnd;
        if (fAbort)                                             //[39]
            FlushMsgs();                                        //[39]
        else                                                    //[39]
            MsgBoxStd (MB_OK, fChange ? MSG_ChangeComplete : MSG_MatchNotFound);
        if (!fChange) goto CmdSearchChangeDone;
    }

CmdSearchChangeEnd:
    if (obStart) {
        obStart--;
    }
    /* make initial oRs visible in active window */
    WndReset (SrchORsOfAlpha (ioRsSrchStart));
    MoveCursorPwndCur (olnStart, obStart);  /* restore initial cursor */

CmdSearchChangeDone:
    DbChkFreeBuf1();    //[28]
    DbChkFreeBuf2();    //[28]
    BdFree (&bdSearchAlpha);
}

STATICF(boolean) StartSearch ()
{
    struct ef *pef = (struct ef *) pwndAct->pefExtra;           // [20]
    ushort iLines;

    if (pwndAct == &wndHelp) {                                  //[7]
        ioRsSrchStart = ioRsSrchCur = (ushort) SendHelpMsg(WM_HELPCURTOPIC,0); //[17]
        if (ioRsSrchCur == UNDEFINED)           //[18]
            return (TRUE);                      //[18] indicate failure
        iLines = (ushort) SendHelpMsg(WM_HELPFILESIZE,0);       //[17]
    } else                                                      //[7]
    {
        if (!AlphaBuildORs ()) {
            SetUiErrOm ();
            return (TRUE);                      //[18] indicate failure
        }
        ioRsSrchStart = ioRsSrchCur = AlphaOfORsFar (pef->hBuffer);
        BdChgOwner (&bdAlphaRs, &bdSearchAlpha);
        iLines = LinesInBuf(SrchORsOfAlpha (ioRsSrchStart));    //[7]
    }
    olnCur = olnStart = GetEditLine();

    if (olnCur == iLines)                                       //[7]
        obCur = obStart = 0;
    else
        obCur = obStart = GetEditColumn () + 1;
    fWrapped = FALSE;

    if (!fMatchCase)
        lower (&b$Buf1);                        //[28]

    return (FALSE);                             //[18] return success
}

STATICF(boolean) FEndOfSearch ()
{
    fPollKeyboard = TRUE;
    PollKeyboard ();            // [16]
    return (fAbort ||           // [16][27]
            fWrapped && (ioRsSrchStart == ioRsSrchCur) &&
            (olnCur > olnStart || (olnStart == olnCur && obCur >= obStart)));
}

/***
*SrchReAssign - Reassign oRs during a search
*
*Purpose:
*       During a search and replace, we may end up changing oRss for text
*       tables (such as changing the names of a SUB or FUNCTION).  This
*       call back allows the search code to update its cached list of
*       oRss in this case.
*
*Entry:
*       oRsOld - value of oRs that is changing
*       oRsNew - new value for this register set.
*
*Exit:
*       None.
*****/
void near SrchReAssign(oRsOld, oRsNew)
ushort oRsOld, oRsNew;
{
    int i;

    for (i = 0; !fSrchLastAlpha (i); i++) {
        if (SrchORsOfAlpha (i) == oRsOld) {
            ((ushort *) bdSearchAlpha.pb)[i] = oRsNew;
        }
    }
}


STATICF(boolean) SearchNext(fSrchMsg)
boolean fSrchMsg;
{

    DbAssert ((scopeOfSearch == isInActiveWindow) ||
              (scopeOfSearch == isInCurrentModule));

    if (fSrchMsg) {
        StatusLineMsg (-MSG_Searching);
    }
    /* display intense 'Searching' msg on status line */
    while (TRUE) {
        if (FEndOfSearch())
            break;

        if (pwndAct == &wndHelp) {                              //[7]
            if (olnCur >= (ushort) SendHelpMsg(WM_HELPFILESIZE,0)) { //[17]
                fWrapped = TRUE;                                //[7]
                olnCur = 0;                                     //[7]
                if (scopeOfSearch != isInActiveWindow) {        //[7]
                    DbChkFreeBuf1();                            //[28]
                    ioRsSrchCur = (ushort) SendHelpMsg(WM_HELPNXTTOPIC,ioRsSrchCur); //[17]
                    //Check for errors                          //[7]
                    if (ioRsSrchCur == UNDEFINED)               //[7]
                        break;                                  //[7]
                                                                //[7]
                    DbChkHoldBuf1();                            //[28]

                    // Refresh the DGROUP copy of the search string,
                    // remapping it to lower case if needed.
                    MakeBufFromBdl (&b$Buf1, &bdlSaveFind);     //[28]
                    if (!fMatchCase)                            //[39]
                        lower (&b$Buf1);                        //[39]

                }                                               //[7]
            }                                                   //[7]
        } else                                                  //[7]
        if (olnCur >= LinesInBuf(SrchORsOfAlpha (ioRsSrchCur))) {
            fWrapped = TRUE;
            olnCur = 0;
            if (scopeOfSearch != isInActiveWindow) {
                if (fSrchLastAlpha (++ioRsSrchCur) ||
                    (SrchORsOfAlpha (ioRsSrchCur) & 0x8000) == 0) {
                while (SrchORsOfAlpha (--ioRsSrchCur) & 0x8000) ;
                UiRsActivate (SrchORsOfAlpha (ioRsSrchCur));
                }
            }
            if (FEndOfSearch ()) {
                break;
            }
        }

        if ((olnCur & 0xf) == 0)
            DrawTogglesLnCol (olnCur, obCur);
        if (SearchLine ())
            break;

        olnCur++;
        obCur = 0;
    } // end WHILE

    if (fSrchMsg) {
        DoStatusMsg (pwndAct);  //[5] restore normal status line message
    }
    /* tell DrawStatusLine it is ok to stop showing Searching msg */
    DrawToggles();

    /*
      Note: Call FEndOfSearch again 'cause even if we did find something,
            we could have gone too far.
    */
    return(!FEndOfSearch());
}

/****
* SearchLine - Scan a line for a particular string or label
*
*Entry:
*       ioRsSrchCur - oRs identifier of window/help topic to search
*       olnCur      - line in text table/help topic to search
*
*Exit:
*       TRUE - text was found
*       FALSE - text was not found
*
* NOTE: for a search of the help system, WM_HELPLINE will return 0 if
*       there is an error.  This routine ignores it, as there will be
*       no text found, and the next WM_HELPNEXTTOPIC will fail if
*       there is a real problem.
***********************************************************************/
STATICF(boolean) SearchLine ()
{
    ushort cb;
    ushort ob;

    if (pwndAct == &wndHelp)                    //[7]
        cb = (ushort) SendMessage(pwndAct, WM_HELPLINE, olnCur, MAKELONG(ldEMScratch.cbMax, ldEMScratch.prgch)); //[17]
    else                                        //[7]
        {
        cb = cbGetLineBuf (SrchORsOfAlpha (ioRsSrchCur), olnCur,
                           ldEMScratch.cbMax, ldEMScratch.prgch);
        }

    if (cb) {
        if (!fMatchCase)
            lower (ldEMScratch.prgch);

        if (fLabel)
            ob = obFindLabel (ldEMScratch.prgch, obCur, cb, &b$Buf1);   //[28]
        else
            ob = obFind (ldEMScratch.prgch, obCur, cb, &b$Buf1);        //[28]
        if (ob != UNDEFINED) {
            obCur = ob;

            /* make active text table visible in active list window */

            if (pwndAct != &wndHelp)            //[7]
                WndReset (SrchORsOfAlpha (ioRsSrchCur));
            if (!FEndOfSearch ()) {
                SelectTextPwndCur (olnCur, obCur, CbSzUi (&b$Buf1));    //[28]
            }
            return (TRUE);
        }
    }

    return (FALSE);
}

/**************************************************************************
*   obFind - check for matching string
*   Description:
*      This routine searchs the specified buffer for a match of the
*      specified pattern. It returns an offset from the start of the buffer
*      to the first character in the matched pattern. If the pattern is not
*      found it return the number of bytes originally specified as size of
*      the buffer.
*
*      pszPattern is assumed to be a non-null string.
*
*   Input:
*      pszTarget - pointer to start of buffer
*      ob - where to start search in pszTarget
*      cb - size of buffer
*      pszPattern - pointer to search pattern
*   Output:
*      return - offset from pszTarget to start of pattern
*               is cb if not found
**************************************************************************/
STATICF(ushort) obFind(pszTarget, ob, obMax, pszPattern)
char *pszTarget;
ushort ob;
ushort obMax;
char *pszPattern;
{
    register short cb;
    register char *psz;
    ushort cbPattern;
    char ch;

    ch = *pszPattern;
    psz = pszTarget + ob;
    cb = obMax - ob + 1;
    cbPattern = CbSzUi (pszPattern);
    while (cb > 0) {
        /* Look for match of first character in pattern */
        if (!(psz = memchr (psz, ch, cb)))
            /* starting character is not in buffer */
            return (UNDEFINED);

        /* compute remaining bytes */
        ob = psz - pszTarget;
        cb = obMax - ob + 1;

        /* if pattern can't fit into buffer return */
        if (cbPattern > cb)
            return(UNDEFINED);

        if (memcmp (psz, pszPattern, cbPattern) == 0)
            if (fWholeWord) {
                if (ob == 0 || !IsWordChar (*(psz-1)))
                    if (ob + cbPattern > obMax || !IsWordChar(*(psz+cbPattern)))
                        return (ob);
            }
            else
                return(ob);

        {                                               //[22]
            psz ++;                                     //[22]
            cb  --;                                     //[22]
        }                                               //[22]
    }
    return (UNDEFINED);
}

/**************************************************************************
*   obFindLabel - check for matching label
*
*   Description:
*      This routine searchs the specified buffer for a match of the
*      specified label. It returns an offset from the start of the buffer
*      to the first character in the matched label. If the label is not
*      found it returns -1
*
*      pszPattern is assumed to be a non-null string.
*
*   Input:
*      pszTarget - pointer to start of buffer
*      obStart   - where to start search in pszTarget
*      cbMax     - size of buffer
*      pszPattern - pointer to search pattern
*   Output:
*      return - offset from pszTarget to start of pattern
*               is cb if not found
**************************************************************************/
STATICF(ushort) obFindLabel (pszTarget, obStart, obMax, pszPattern)
register char *pszTarget;
ushort obStart;
ushort obMax;
char *pszPattern;
{
    register ushort ob;
    ushort cbPattern;
    register char *psz;

    cbPattern = CbSzUi( pszPattern );

    // Don't include ':' in the string to be searched for.  This allows
    // us to search for substrings of a label.

    if (pszPattern[cbPattern-1] == ':') {  //This is legal because : can not
        pszPattern[cbPattern-1] = 0;       //be part of a DBCS character
        cbPattern--;
    }

    ob = obFind(pszTarget, obStart, obMax, pszPattern);
    if (ob != UNDEFINED) {

        //We found the string.  Make sure that all characters on the
        //line up to the first ':' are legal characters for a label
        //If the line does not include a ':', then the 0 terminator
        //will cause the routine to exit, as it is not a legal Label
        //character.


        for (psz = pszTarget+ob; psz >= pszTarget; psz--)       //[26]
            if (!IsLabelChar(*psz))
                return(UNDEFINED);
        for (psz = pszTarget+ob+cbPattern; *psz != ':'; psz++)
            if (!IsLabelChar (*psz))
                return (UNDEFINED);
    }
    return (ob);

}

STATICF(void) DoChange ()
{
    ushort cbAdd, cbDel;

    cbAdd = CbSzUi (&b$Buf2);   //[28]
    cbDel = CbSzUi (&b$Buf1);   //[28]

    DbChkFreeBuf1();            //[28]
    DbChkFreeBuf2();            //[28]
    SendMessage (pwndAct, EM_REPLACESEL, (WORD) &b$Buf2, 0L );
    DbChkHoldBuf1();            //[28]
    DbChkHoldBuf2();            //[28]
    MakeBufFromBdl (&b$Buf1, &bdlSaveFind);     //[28]
    if (!fMatchCase)            //[28]
        lower (&b$Buf1);        //[28]
    MakeBufFromBdl (&b$Buf2, &bdlSaveChange);   //[28]
    if (ioRsSrchStart == ioRsSrchCur && olnCur == olnStart && obCur < obStart) {
        /*
           We have wrapped around to the line we started on, and we
           are adding/deleting characters before obStart. So, adjust
           obStart by the amount we add/delete.
        */
        if (obCur + cbDel > obStart) {
            /*
               we just deleted char at search-start position,
               so push obStart back to zero so we will terminate on the
               next iteration.
            */
            obStart = 0;
        }
        else
            obStart += cbAdd - cbDel;
        }
    obCur += cbAdd;
}

/**************************************************************************
* STATICF (void) MakeBdlFromBuf (pbdl, buf)
* Purpose:
*  Copies NEAR data in a buf to the FAR heap.
*
**************************************************************************/
STATICF (void) MakeBdlFromBuf (pbdl, buf)       //[28]
bdl *pbdl;
char *buf;
{
    ushort cb = CbSzUi (buf);

    if (pbdl->seg != NOT_OWNER)
        BdlFree (pbdl);

    if (cb && !BdlAlloc (pbdl, cb)) {
        cb = 0;                 //[30]
        SetUiErrOm ();
    }

    if (cb) {                   //[30]
        fmemcpy ((char far *) MAKELONG (0, GETSEG (pbdl->seg)),
                 (char far *) buf, cb);
    }
    else {
        pbdl->cbLogical = 0;    //[30]
    }
}

/**************************************************************************
* STATICF (void) MakeBufFromBdl( buf, pbdl )
* Purpose:
*  Copies FAR data in a bdl to NEAR data.
*
**************************************************************************/
STATICF (void) MakeBufFromBdl ( buf, pbdl )     //[28]
char *buf;
bdl *pbdl;
{
    ushort cb = pbdl->cbLogical;

    if (cb) {   //[29]
        DbAssert (pbdl->seg != NOT_OWNER);      //[29]
        fmemcpy ((char far *) buf,
                 (char far *) MAKELONG (0, GETSEG (pbdl->seg)), cb);
    }           //[29]
    buf[cb] = '\0';
}

AY FAR PASCAL
GetUILine ()
{
    struct ef *pef = (struct ef *) pwndAct->pefExtra;   // [20]

    return (((AY) (GetEditLine () - pef->pdCur.olntop)) +
            pwndAct->arcClipping.ayTop);
}


// Added back [39]
/*********************************************************************
* void NEAR SelectTextPwndCur(ln, col, cb)
* Purpose:
*  Selects a range of text on a single line in the current window.
*
*********************************************************************/

void NEAR SelectTextPwndCur(ln, col, cb)
ushort ln;
ushort col;
ushort cb;
{
    SendMessage (pwndAct, EM_SELCHARS, ln, MAKELONG(col, col+cb));
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uiutil.asm ===
TITLE	uiutil.asm - low level utilities for SHELL
;*** 
;uiutil.asm
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	Support routines needed by user-interface.
;
;
;*******************************************************************************

	.xlist
	include	version.inc
	.list

	include cw/version.inc	
	include cw/windows.inc	
	include cw/edityp.inc	

	IncludeOnce architec	
	IncludeOnce qbimsgs	
	IncludeOnce ui		


assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

	subttl	DATA segment definitions.
	page

externFP CbSz			

DOS_LOGICAL_DRIVE EQU	504H

sBegin	DATA
staticB	DisketteDrives,-1	; Number of Diskette Drives on machine
				; -1 ==> not yet determined
externW	__doserrno
externW	iHelpId			
externB fMousePresent
sEnd	DATA


sBegin	UI
assumes CS,UI

externNP MsgBoxPsz		

	subttl	Low level MSDOS File I/O calls.
	page

;***
;
;  GetCurDrive2()
;
;	Returns the current drive letter.
;
;  Inputs:	none
;
;  Outputs:	AL is the current drive letter
;
;  Uses:	AX, DX.
;
;****

cProc	GetCurDrive2,<NEAR,PUBLIC>
cBegin
	mov	ah, 19h
	int	21h
	add	al, 'A'
	xor	ah, ah
cEnd


;***
;
;  GetCurDriveDir(szPath)
;
;	Gets the current working directory and drive into the supplied buffer.
;	Re-written in assembler and moved here with revision [1].
;
;  Inputs:
;	szPath = pointer to buffer area.  (<=64 bytes long).
;
;  Outputs:
;	None.
;  Uses:
;	Per convention.
;
;****

cProc	GetCurDriveDir,<NEAR,PUBLIC>,<SI>
	parmW	szPath
cBegin
	cCall	GetCurDrive2		; al = current drive letter

	mov	si,szPath		;Get pointer to target area.
	mov	Byte Ptr [si],al	;store drive letter
	mov	Word Ptr [si+1],'\:'	; store ":\"
	add	si,3			;advance past "drive:\"


	;We do not have to worry about KANJI characters here, as
	;drive designators can only be single byte characters

	and	al, not 20H		; convert lower case to upper case.
	sub	al, 'A' - 1		; 0 -> Current drive, 1 -> A, 2 -> B,...
	mov	dl,al
	mov	ah, 47h
	int	21h

	mov	bx, 0			
	mov	[__doserrno],bx		
	xchg	ax,bx
	jnc	GetCurDriveDir_Exit

	mov	[__doserrno],bx
	dec	ax

GetCurDriveDir_Exit:

cEnd

	page

;***
;
;  SetCurDrive2()
;
;	Sets the current drive.
;
;  Inputs:	letter - is the drive letter.
;
;  Outputs:	none.
;
;  Uses:	AX, DX.
;
;****

cProc	SetCurDrive2,<NEAR,PUBLIC>
	parmB	letter
cBegin
	mov	dl, letter
	push	dx
	cCall	CheckSwitchDiskettes,<dx>
	pop	dx
	and	dl, not 20H			; convert lower case to upper
	sub	dl, 'A'				; A->0, B->1, etc
	mov	ah, 0eH
	int	21h
cEnd


;***
;
;  SetCurDir2(pArea)
;
;  Set's the current working directory from the supplied pointer buffer.
;
;  Inputs:	pointer to buffer area.  <= 64 bytes.
;
;  Outputs:	AX == 0  for normal completion.
;		AX == -1 for error during operation.
;
;  Uses:	AX, DX.
;
;****

cProc	SetCurDir2,<NEAR,PUBLIC>
	parmDP	pArea
cBegin
	xor	ax,ax
	mov	[__doserrno],ax

	mov	bx, pArea
	push	bx			; save for later
	mov	dx,[bx]			; dx = possible drive letter + colon
	cmp	dh, ':'			; drive specified?
	jne	NoDriveSpec		; brif not

	cCall	SetCurDrive2,<dx>	; set current drive

noDriveSpec:
	pop	dx			; dx = *directory name
	mov	ah, 3Bh			; set current directory
	int	21h

	mov	bx,0			; assume success
	xchg	ax,bx			; ax = return code
	jnc	SetCurDir_Exit		; brif success, with ax = 0

	mov	[__doserrno],bx
	dec	ax			; ax = -1 ==> failure

SetCurDir_Exit:
cEnd

	page



;***
;
; CheckSwitchDiskettes( drive )
;
; Inputs:	drive - is the drive letter we are about to access
;
; Outputs:	none
;
; Uses:	all
;
;****
cProc CheckSwitchDiskettes,<NEAR,PUBLIC>
	parmB	drive
cBegin
	mov	al,DisketteDrives		; al = # disk drives
	cmp	al,-1				; have we initialized it?
	jne	InitDone			; brif so


	int	11H				; BIOS Equipment List
	shl	ax, 1				
	shl	ax, 1				
	and	ah, 00000011B			
	inc	ah				
	mov	al,ah				
	mov	DisketteDrives, al		; save value for next time
						; so we don't have to do the
						; INT every time

InitDone:					; al = # disk drives
	cmp	al, 1				
	jne	EndCheckSwitchDiskettes

	mov	dl, drive
	and	dl, not 20H			; convert lower case to upper
	sub	dl, 'A'				; A->0, B->1, etc
	cmp	dl, 1
	ja	EndCheckSwitchDiskettes		; only drives A and B matter

	xor	ax, ax				
	mov	es, ax				
	mov	al, es:[DOS_LOGICAL_DRIVE]	; Get current logical drive
	cmp	dl, al
	je	EndCheckSwitchDiskettes

; Well now we know... We have to switch diskettes.
	push	es				; save segment 0 for later
	push	dx				; save drive number

	mov	ax,MSG_SwitchDisks	; "Insert diskette for drive A:"
	mov	iHelpid,ax			
	cCall	ListStdMsg,<ax>			; get message into bufStdMsg


	pop	ax				; restore AX = drive number
	push	ax				; save drive # again
	lea	bx,[bufStdMsg+26]		; BX = ptr to "A:"
	add	[bx],al				; change to 'B:' if necessary

	mov	ax,MB_OK			; display the message
	push	ax				
	mov	ax,OFFSET DGROUP:bufStdMsg	
	push	ax				
	call	MsgBoxPsz			

	; actually switch the diskettes
	pop	dx				; DX = drive number
	pop	es				; ES = 0
	mov	es:[DOS_LOGICAL_DRIVE], dl	; Tell DOS we switched the
						; diskettes

	mov	ah, 0dh				; reset the disk
	int	21h				

EndCheckSwitchDiskettes:
cEnd

	page

;***
;
;  FlushFile()
;
;  Flushes all DOS buffers for the file to disk.
;
;  Inputs:	fd - file descriptor for the file to flush.
;
;  Outputs:	
;
;  Uses:	AX, DX.
;
;****
cProc	FlushFile,<NEAR,PUBLIC>
	parmW	fd

cBegin
	mov	bx, [fd]
	mov	ah, 45H
	int	21H			; Duplicate the handle
	jc	FlushFileExit

	mov	bx, ax
	mov	ah, 3eH
	int	21H			; Close the dup'd handle to flush.

FlushFileExit:
cEnd


;***
;
;  fstrcpy2( fpDst, fpSrc )
;
;  Move null terminated string from Src to Dst
;
;  Inputs:
;		far pointer destination.
;		far pointer source.
;
;  Outputs:	none.
;
;  Uses:	AX, CX.
;
;****

cProc	fstrcpy2,<NEAR,PUBLIC>,<SI, DI, DS>
	ParmD	fpDst
	ParmD	fpSrc
cBegin
	les	di, fpDst
	lds	si, fpSrc
fstrcpy1:
	lodsb
	stosb
	cmp	al, 0
	jnz	fstrcpy1

cEnd

;***
;
;  CbSzUi(psz) 
;
;  Added with revision [4] to save bytes.
;
;  Return length of null-terminated string, not including the null
;  The length is returned in bytes (not characters).
;
;  Inputs:
;		psz = near pointer to string
;
;  Outputs:	AX = length in bytes.
;
;  Uses:	Per convention
;
;****
cProc	CbSzUI,<NEAR,PUBLIC>
cBegin
	pop	ax		; ax = return address

				; parm(s) are on the stack
	push	cs		; push return segment
	push	ax		; push return offset
	jmp	CbSz		; "CALL" CbSz,<parm(s)>
cEnd	<nogen>


;***
;
;  fmemcpy(fpDst, fpSrc, cb )
;
;  Move cb bytes (not characters) from Src to Dst
;
;  Inputs:
;		far pointer destination.
;		far pointer source.
;		unsigned integer for number of bytes to move.
;
;  Outputs:	none.
;
;  Uses:	AX, CX.
;
;****

cProc	fmemcpy,<NEAR,PUBLIC>,<SI, DI, DS>
	ParmD	fpDst
	ParmD	fpSrc
	ParmW cb

cBegin
	mov	cx, cb
	jcxz	fmemcpyEnd		;Early exit.

	les	di, fpDst
	lds	si, fpSrc
	repz	movsb

fmemcpyEnd:
cEnd

	subttl	Character mapping routines
	page

; These tables now conform to IBM code page 850

labelB	<Translation_Table>
	DB	081h, 09ah, 'U'
	DB	082h, 090h, 'E'
	DB	083h, 0b6h, 'A'
	DB	084h, 08eh, 'A'
	DB	085h, 0b7h, 'A'
	DB	086h, 08fh, 'A'
	DB	087h, 080h, 'C'
	DB	088h, 0d2h, 'E'
	DB	089h, 0d3h, 'E'
	DB	08ah, 0d4h, 'E'
	DB	08bh, 0d8h, 'I'
	DB	08ch, 0d7h, 'I'
	DB	08dh, 0deh, 'I'
	DB	091h, 092h, 'A'
	DB	093h, 0e2h, 'O'
	DB	094h, 099h, 'O'
	DB	095h, 0e3h, 'O'
	DB	096h, 0eah, 'U'
	DB	097h, 0ebh, 'U'
	DB	098h,  'Y', 'Y'
	DB	09bh, 09dh, 'O'
	DB	0a0h, 0b5h, 'A'
	DB	0a1h, 0d6h, 'I'
	DB	0a2h, 0e0h, 'O'
	DB	0a3h, 0e9h, 'U'
	DB	0a4h, 0a5h, 'N'
	DB	0a6h,  'A', 'A'
	DB	0a7h,  'O', 'O'
	DB	0c6h, 0c7h, 'A'
	DB	0e4h, 0e5h, 'O'
	DB	0e7h, 0e8h, 'P'
	DB	0ech, 0edh, 'Y'
	DB	0, 0, 0			; table end marker


;re-written in assembler, and moved here with revision [5].
;re-wrote table lookup with revision [7].
;*** 
;tolower, toupper, toupperNoAccent -- character conversion routines
;
;Purpose:
;
;	Convert a character to either lower or upper case
;	If char > 127, does an international mapping of the character
;	If toupperNoAccent, converts it to the upper case version of the
;	'Normal' character.
;
;Entry:
;	chr	= character to convert
;
;Exit:
;	AL	= converted char
;
;Uses:
;	Per convention
;
;*******************************************************************************
labelNP	<PUBLIC, toupperNoAccent>
	mov	dx,UIOFFSET ReturnNoAccent	; return a upper case char
	jmp	short toupper2			; without any accent

labelNP	<PUBLIC, toupper>
	mov	dx,UIOFFSET ReturnUpper		; return a upper case char
toupper2:
	mov	cx,'Aa'				; CX = map lower to upper
	jmp	short MapChar

labelNP	<PUBLIC, tolower>
	mov	dx,UIOFFSET ReturnLower		; return a lower case char
	mov	cx,'aA'				; CX = map upper to lower

cProc	MapChar,<NEAR>
parmB	chr		; char to convert
cBegin

	; BX = translation table, CL = old A-Z start, CH = new A-Z start
	mov	al,chr				; AL = char to convert
	or	al,al				; above 127?
	js	DoTableLookup			; brif so -- map the sucker

	push	ax				; save char
	sub	al,cl				; make zero-relative
	cmp	al,26				; out of range?
	pop	ax				; restore char
	jae	MapCharExit			; brif out of range - no change
	sub	al,cl				; make zero-relative again
	add	al,ch				; translate
	jmp	short MapCharExit		; done


DoTableLookup:
	mov	bx,UIOFFSET Translation_Table

TryNextEntry:
	mov	cx,cs:[bx]			; cl = lower case char
						; ch = upper case char
	jcxz	MapCharExit			; brif end of table reached
	inc	bx				; prepare to do next one
	inc	bx
	inc	bx
	cmp	al,cl				; lower case char match?	
	je	TableMatch			; brif so
	cmp	al,ch				; upper case char match?	
	jne	TryNextEntry			; brif not -- try again

TableMatch:
	jmp	dx				; return right result
ReturnNoAccent:
	mov	al,cs:[bx-1]			; return no-accent character 
	SKIP2_PSW				; exit
ReturnUpper:
	mov	al,ch				; return upper case character
	SKIP2_PSW				; exit
ReturnLower:
	mov	al,cl				; return lower case character

MapCharExit:
cEnd

;re-written in assembler, and moved here with revision [5].
;*** 
;lower -- convert a character string to lower case
;
;Purpose:
;
;Entry:
;	psz	= near pointer to string to convert
;
;Exit:
;	string converted to lower case
;
;Uses:
;	Per convention
;
;*******************************************************************************
cProc	lower,<NEAR,PUBLIC>,<SI>
parmW	psz		; string to convert
cBegin
	mov	si,psz				; si = * string to convert
NextChar:
	lodsb					; al = next char in string
	cCall	tolower,<ax>			; convert the char
	mov	[si-1],al			; store converted char 
	or	al,al				; all done?
	jne	NextChar			; brif not
cEnd



;***
;
; CbSizeMouseState
;
; Returns the number of bytes required to save the mouse state.
;
; Inputs:	none
;
; Outputs:	AX = number of bytes
;
; Uses:		AX, BX, CX, DX.
;
;****
cProc cbSizeMouseState,<FAR,PUBLIC>
cBegin
	xor	ax,ax
	cmp	[fMousePresent], al
	je	@F

	mov	ax, 21
	xor	bx,bx			; Won't be changed if not supported
	int	33H
	mov	ax, bx
@@:
cEnd

;***
;
; SaveMouseState
;
; Saves the mouse state in global memory
;
; Inputs:	pointer to buffer for mouse save data
;
; Outputs:	none
;
; Uses:		AX, BX, CX, DX.
;
;****
cProc SaveMouseState,<FAR,PUBLIC>
	parmD	pBuffer
cBegin
	les	dx, [pBuffer]
	mov	ax, 22
	int	33H
cEnd

;***
;
; RestoreMouseState
;
; Restores the mouse state saved by SaveMouse.
;
; Inputs:	pBuffer - pointer to buffer containing saved mouse state.
;
; Outputs:	none.
;
; Uses:		AX, BX, CX, DX.
;
;****

cProc RestoreMouseState,<FAR,PUBLIC>
	parmD	pBuffer
cBegin
	les	dx, [pBuffer]
	mov	ax, 23
	int	33H
cEnd

sEnd	UI
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbdut\strings\intl.inc ===
CCHUNTITLED             EQU 8 ; length of "Untitled" file name string
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uirsrcc.c ===
/***
*uirsrcc.c - Resources (isolated for internationalization).
*
*	Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*	Menu data structure definitions.
*
*******************************************************************************/

/* First, include version definition header */
#include <version.h>

/* Next, include TextWin's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>

/* Next, include QBI's headers */
#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

/*------------------------------ Menu Bar ------------------------------------*/

#define CBMAX_FILE 14
static char szFileNew[] 	= "New";		/* [21] */
static char szFileOpen[]	= "Open...";		/* [21] */
static char szFileSave[]	= "Save";		/* [27] */
static char szFileSaveAs[]	= "Save As..."; 	/* [3] */
static char szFilePrint[]	= "Print...";		/* [3] */
static char szFileExit[]	= "Exit";		/* [3] */

// a-emoryh:
// The title for the PrintSetup dialog (a sub-dialog of FilePrint).
// This seemed the best place to put it, seeing as all the other dialog titles
// are generated from the strings in this file.
//
char szPrintSetup[]         = "Printer Setup";


// NOTE: The last parameter to the menuitem and menuitemX calls is the
// NOTE: number of characters of the string to use for the dialog box
// NOTE: title.  If it doesn't have dialog box, or it doesn't have a title,
// NOTE: this should be 0.  Make sure the EZ and full menu versions match!

#define CBMAX_FILEQHELP   8	// Enough for Print... and Exit
MENUITEM rgMenuItemFileQhelp[] = {
    menuitemX (midFilePrint,	szFilePrint,	0, 5)
    menuitemSep
    menuitemX (midFileExitQH,	szFileExit,	1, 0)
};

MENUITEM rgMenuItemFile[] = {
    menuitemX (midFileNew,	szFileNew,	0, 0)
    menuitemX (midFileOpen,	szFileOpen,	0, 4)
    menuitemX (midFileSave,	szFileSave,	0, 4)		//[27]
    menuitemX (midFileSaveAs,	szFileSaveAs,	5, 7)
    menuitemSep
    menuitemX (midFilePrint,	szFilePrint,	0, 5)
    menuitemSep
    menuitemX (midFileExit,	szFileExit,	1, 0)
};

#define CBMAX_EDIT 20
static char szEditCut[] 	= "Cut\tShift+Del";		// [3] [19]
static char szEditCopy[]	= "Copy\tCtrl+Ins";		// [3] [19]
static char szEditPaste[]	= "Paste\tShift+Ins";		// [3] [19]
static char szEditClear[]       = "Clear\tDel";
static char szEditNewSub[]	= "New SUB..."; 		/* [3] */
static char szEditNewFunc[]	= "New FUNCTION...";		/* [3] */

MENUITEM rgMenuItemEditQedit[] = {
    menuitemX (midEditCut,	szEditCut,	2, 0)
    menuitemX (midEditCopy,	szEditCopy,	0, 0)
    menuitemX (midEditPaste,	szEditPaste,	0, 0)
    menuitemX (midEditClear,    szEditClear,    2, 0)
};

MENUITEM rgMenuItemEdit[] = {
    menuitemX (midEditCut,	szEditCut,	2, 0)
    menuitemX (midEditCopy,	szEditCopy,	0, 0)
    menuitemX (midEditPaste,	szEditPaste,	0, 0)
    menuitemX (midEditClear,    szEditClear,    2, 0)
    menuitemSep
    menuitemX (midEditNewSub,	szEditNewSub,	4, 7)
    menuitemX (midEditNewFunc,	szEditNewFunc,	4, 12)
};

#define CBMAX_VIEW 21
static char szViewSubs[]	= "SUBs...\tF2";		// [3] [19]
static char szViewSplit[]	= "Split";			/* [3] */
static char szViewOutScrn[]	= "Output Screen\tF4";		// [3] [19]

MENUITEM rgMenuItemView[] = {
    menuitemX (midViewSubs,	szViewSubs,	0, 4)
    menuitemX (midViewSplit,	szViewSplit,	1, 0)
    menuitemX (midViewOutScrn,	szViewOutScrn,	0, 0)
};

#define CBMAX_SEARCH 24
static char szSearchFind[]	= "Find...";			/* [3] */
static char szSearchNext[]	= "Repeat Last Find\tF3";	// [3] [19]
static char szSearchChange[]	= "Change...";			/* [3] */

MENUITEM rgMenuItemSearchQhelp[] = {
    menuitemX (midSearchFind,	szSearchFind,	0, 4)
    menuitemX (midSearchNext,	szSearchNext,	0, 16)
};

MENUITEM rgMenuItemSearch[] = {
    menuitemX (midSearchFind,	szSearchFind,	0, 4)
    menuitemX (midSearchNext,	szSearchNext,	0, 16)
    menuitemX (midSearchChange,	szSearchChange, 0, 6)
};

#define CBMAX_RUN 19
static char szRunStart[]	= "Start\tShift+F5";		// [3] [19]
static char szRunRestart[]	= "Restart";			/* [3] */
static char szRunContinue[]	= "Continue\tF5";		// [3] [19]

MENUITEM rgMenuItemRun[] = {
    menuitemX (midRunStart,	szRunStart,	0, 0)
    menuitemX (midRunRestart,	szRunRestart,	0, 0)
    menuitemX (midRunContinue,	szRunContinue,	0, 0)		//[23]
};

#define CBMAX_DEBUG 27
static char szDebugStep[]	 = "Step\tF8";			/* [21] */
static char szDebugPStep[]	 = "Procedure Step\tF10";	/* [21] */
static char szDebugTraceOn[]	 = "Trace On";			/* [3] */
static char szDebugToggleBp[]	 = "Toggle Breakpoint\tF9";	// [3] [19]
static char szDebugClearAllBp[]  = "Clear All Breakpoints";	/* [3] */
static char szDebugSetNextStmt[] = "Set Next Statement"; 	/* [3] */

// IF Instant watch EVER changes postion, then UICTL.C shift+rightmouse
// needs to change postion.

MENUITEM rgMenuItemDebug[] = {
    menuitemX (midStep,			szDebugStep, 		0, 0)
    menuitemX (midPStep,		szDebugPStep, 		0, 0)
    menuitemSep
    menuitemX (midDebugTraceOn,		szDebugTraceOn, 	0, 0)
    menuitemSep
    menuitemX (midDebugToggleBp, 	szDebugToggleBp,	7, 0)
    menuitemX (midDebugClearAllBp,	szDebugClearAllBp,	0, 0)
    menuitemX (midDebugSetNextStmt,	szDebugSetNextStmt,	4, 0)
};

#define CBMAX_OPTNS 15
static char szOptnsDisplay[]	= "Display...";
static char szOptnsPaths[]	= "Help Path...";		// [12]
static char szOptnsSyntax[]	= "Syntax Checking";		/* [3] */

MENUITEM rgMenuItemOptnsQedit[] = {
    menuitemX (midOptnsDisplay,	szOptnsDisplay,	0, 7)
    menuitemX (midOptnsPaths,	szOptnsPaths,	5, 9)		// [21]
};

MENUITEM rgMenuItemOptns[] = {
    menuitemX (midOptnsDisplay,	szOptnsDisplay,	0, 7)
    menuitemX (midOptnsPaths,	szOptnsPaths,	5, 9)		// [21]
    menuitemX (midOptnsSyntax,	szOptnsSyntax,	0, 0)
};


/*
   The current keyword is inserted in the MID_HELP_SYNTAX menu item.
*/
#define OB_HELP_SYNTAX 7	//offset into szHelpSyntax to insert the keyword
#define CB_HELP_SYNTAX 8	//# of chars of keyword that are shown
//[14]   The keyword is inserted here
//[14]			      vvvvvvvv
char szHelpSyntax[] = "Topic:                 F1";		//[14]

#define CBMAX_HELP 25
static char szHelpIndex[]	= "Index";			/* [7] */
static char szHelpTable[]	= "Contents";			/* [7] */
static char szHelpHelp[]	= "Using Help\tShift+F1";	//[26]
static char szHelpAbout[]	= "About...";			//[25]

MENUITEM rgMenuItemHelp[] = {
    menuitemX (midHelpIndex,	szHelpIndex,	0, 0 )		/* [5] */
    menuitemX (midHelpTable,	szHelpTable,	0, 0 )		/* [5] */
    menuitemX (midHelpSyntax,	szHelpSyntax,	0, 0 )
    menuitemX (midHelpHelp,	szHelpHelp,	6, 0 )		//[26]
    menuitemSep 						//[25]
    menuitemX (midHelpAbout,	szHelpAbout,	0, 0 )		//[25]
};

#define CBMAX_EDITHELP 15					//[25]
static char szHelpStarted[]	= "Getting Started";		//[25]
static char szHelpKeyboard[]	= "Keyboard";			//[25]

MENUITEM rgMenuItemEditHelp[] = {				//[25]
    menuitemX (midHelpStarted,	szHelpStarted,	0, 0 )		//[25]
    menuitemX (midHelpKeyboard,	szHelpKeyboard,	0, 0 )		//[25]
    menuitemSep 						//[25]
    menuitemX (midHelpAbout,	szHelpAbout,	0, 0 )		//[25]
};								//[25]

#define CBMAX_QHELPHELP 24
static char szHelpHowToUse[]	= "How to Use MS-DOS Help";

MENUITEM rgMenuItemQhelpHelp[] = {
    menuitemX (midHelpHowToUse, szHelpHowToUse, 0, 0 )
    menuitemSep
    menuitemX (midHelpAbout,	szHelpAbout,	0, 0 )
};


static char szFile[]		= "File";	/* [3] */
static char szEdit[]		= "Edit";	/* [3] */
static char szView[]		= "View";	/* [3] */
static char szSearch[]		= "Search";	/* [3] */
static char szRun[]		= "Run";	/* [3] */
static char szDebug[]		= "Debug";	/* [3] */
static char szOptns[]		= "Options";
static char szHelp[]		= "Help";	//[12]

MENU rgMenuQedit[] = {

    {
	midFile,					/* idMenu      */
	3,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	4,						/* cchTitle    */
	szFile, 					/* pchTitle    */
	sizeof (rgMenuItemFile) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_FILE,					/* cchItemMax  */
	rgMenuItemFile, 				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midEdit,					/* idMenu      */
	9,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	4,						/* cchTitle    */
	szEdit, 					/* pchTitle    */
	sizeof (rgMenuItemEditQedit) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_EDIT,					/* cchItemMax  */
	rgMenuItemEditQedit, 				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midSearch,					/* idMenu      */
	15,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	6,						/* cchTitle    */
	szSearch,					/* pchTitle    */
	sizeof (rgMenuItemSearch) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_SEARCH,					/* cchItemMax  */
	rgMenuItemSearch,				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midOptns,					/* idMenu      */
	23,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	7,						/* cchTitle    */
	szOptns,					/* pchTitle    */
	sizeof (rgMenuItemOptnsQedit) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_OPTNS,					/* cchItemMax  */
	rgMenuItemOptnsQedit,				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midHelp,					/* idMenu      [25] */
	74,						/* rxTitle     [25] */
	0,						/* ichHilite   [25] */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	4,						/* cchTitle    [25] */
	szHelp, 					/* pchTitle    [25] */
	sizeof (rgMenuItemEditHelp) / sizeof (MENUITEM),/* cItem       [25] */
	CBMAX_EDITHELP,					/* cchItemMax  [25] */
	rgMenuItemEditHelp,				/* rgMenuItem  [25] */
	0						/* wParamUser  [25] */
    },


};

MENU rgMenuQhelp[] = {

    {
	midFile,					/* idMenu      */
	3,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	4,						/* cchTitle    */
	szFile, 					/* pchTitle    */
	sizeof(rgMenuItemFileQhelp) / sizeof(MENUITEM), /* cItem       */
	CBMAX_FILEQHELP,				/* cchItemMax  */
	rgMenuItemFileQhelp,				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midSearch,					/* idMenu      */
	9,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	6,						/* cchTitle    */
	szSearch,					/* pchTitle    */
	sizeof(rgMenuItemSearchQhelp) / sizeof(MENUITEM), /* cItem	 */
	CBMAX_SEARCH,					/* cchItemMax  */
	rgMenuItemSearchQhelp,				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midHelp,					/* idMenu      [25] */
	74,						/* rxTitle     [25] */
	0,						/* ichHilite   [25] */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	4,						/* cchTitle    [25] */
	szHelp, 					/* pchTitle    [25] */
	sizeof (rgMenuItemQhelpHelp) / sizeof (MENUITEM),/* cItem	[25] */
	CBMAX_QHELPHELP,				/* cchItemMax  [25] */
	rgMenuItemQhelpHelp,				/* rgMenuItem  [25] */
	0						/* wParamUser  [25] */
    },


};

MENU rgMenuQbas[] = {

    {
	midFile,					/* idMenu      */
	3,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	4,						/* cchTitle    */
	szFile, 					/* pchTitle    */
	sizeof (rgMenuItemFile) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_FILE,					/* cchItemMax  */
	rgMenuItemFile, 				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midEdit,					/* idMenu      */
	9,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	4,						/* cchTitle    */
	szEdit, 					/* pchTitle    */
	sizeof (rgMenuItemEdit) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_EDIT,					/* cchItemMax  */
	rgMenuItemEdit, 				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midView,					/* idMenu      */
	15,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	4,						/* cchTitle    */
	szView, 					/* pchTitle    */
	sizeof (rgMenuItemView) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_VIEW,					/* cchItemMax  */
	rgMenuItemView, 				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midSearch,					/* idMenu      */
	21,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	6,						/* cchTitle    */
	szSearch,					/* pchTitle    */
	sizeof (rgMenuItemSearch) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_SEARCH,					/* cchItemMax  */
	rgMenuItemSearch,				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midRun, 					/* idMenu      */
	29,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	3,						/* cchTitle    */
	szRun,						/* pchTitle    */
	sizeof (rgMenuItemRun) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_RUN,					/* cchItemMax  */
	rgMenuItemRun,					/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midDebug,					/* idMenu      */
	34,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	5,						/* cchTitle    */
	szDebug,					/* pchTitle    */
	sizeof (rgMenuItemDebug) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_DEBUG,					/* cchItemMax  */
	rgMenuItemDebug,				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midOptns,					/* idMenu      */
	41,						/* rxTitle     */
	0,						/* ichHilite   */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	7,						/* cchTitle    */
	szOptns,					/* pchTitle    */
	sizeof (rgMenuItemOptns) / sizeof (MENUITEM),	/* cItem       */
	CBMAX_OPTNS,					/* cchItemMax  */
	rgMenuItemOptns,				/* rgMenuItem  */
	0						/* wParamUser  */
    },

    {
	midHelp,					/* idMenu      [12] */
	74,						/* rxTitle     [12] */
	0,						/* ichHilite   [12] */
	FALSE, TRUE, 0, 				/* fHandle, fEnabled, filler */
	4,						/* cchTitle    [12] */
	szHelp, 					/* pchTitle    [12] */
	sizeof (rgMenuItemHelp) / sizeof (MENUITEM),	/* cItem       [12] */
	CBMAX_HELP,					/* cchItemMax  [12] */
	rgMenuItemHelp, 				/* rgMenuItem  [12] */
	0						/* wParamUser  [12] */
    },

};

/*---------------------- Main Accelerator Keys ------------------------------*/

MPVKEYID rgmpvkeyidQedit[] = {
/* [2] Add ALT+ and ALT- */
    '+' | KK_ALT,		midWndGrow,		/* [2] */
    '=' | KK_ALT | KK_SHIFT,	midWndGrow,	//[17] main kbd '+' is shift '='
    '-' | KK_ALT,		midWndShrink,		/* [2] */
    '\x7f',			midEditClear2,		/* [2] */
    '\x7f' | KK_SHIFT,		midEditCut2,		/* [2] */
    VK_INSERT | KK_CONTROL,	midEditCopy,
    VK_INSERT | KK_SHIFT,	midEditPaste,
    '\x0c' | KK_CONTROL,	midSearchNext,		/* [2] Ctrl+L */
    VK_F1 | KK_ALT,		midHelpBack,		// [16]
    VK_F3,			midSearchNext,
    VK_F6,			midNextWindow,
    VK_F6 | KK_SHIFT,		midPreviousWindow,
    0,	  0
};

MPVKEYID rgmpvkeyidQhelp[] = {
/* Add ALT+ and ALT- */
    VK_F1 | KK_ALT,		midHelpBack,		// [16]
    VK_F3,			midSearchNext,
//
// LOCALIZATION -
//    Change this char in the following 3 lines if you need to change the
//            |         accelerator character.
//            |
//            v
//
    (VK_A+(  'C'  -'A')) | KK_ALT,   midHelpHelp,         // Contents
    (VK_A+(  'N'  -'A')) | KK_ALT,   midHelpNext,         // Next
    (VK_A+(  'B'  -'A')) | KK_ALT,   midHelpBack,         // Back
    0,	  0
};

MPVKEYID rgmpvkeyidQbas[] = {
/* [2] Add ALT+ and ALT- */
    '+' | KK_ALT,		midWndGrow,		/* [2] */
    '=' | KK_ALT | KK_SHIFT,	midWndGrow,	//[17] main kbd '+' is shift '='
    '-' | KK_ALT,		midWndShrink,		/* [2] */
//[21]    '\x08' | KK_ALT,		midEditUndo,		/* [2] */
    '\x7f',			midEditClear2,		/* [2] */
    '\x7f' | KK_SHIFT,		midEditCut2,		/* [2] */
    VK_INSERT | KK_CONTROL,	midEditCopy,
    VK_INSERT | KK_SHIFT,	midEditPaste,
    '\x0c' | KK_CONTROL,	midSearchNext,		/* [2] Ctrl+L */
//[21]    '\x1c' | KK_CONTROL,	midSearchSel,		/* [2] Ctrl+\ */
    VK_F1 | KK_ALT,		midHelpBack,		// [16]
    VK_F2,			midViewSubs,
    VK_F2 | KK_SHIFT,		midViewNextProc,
    VK_F2 | KK_CONTROL, 	midViewPrevProc,
    VK_F3,			midSearchNext,
    VK_F4,			midViewOutScrn,
    VK_F5,			midRunContinue,
    VK_F5 | KK_SHIFT,		midRunStart,
    VK_F5 | KK_CONTROL, 	midWndRestore,
    VK_F6,			midNextWindow,
    VK_F6 | KK_SHIFT,		midPreviousWindow,
    VK_F7,			midGoUntilCursor,
    VK_F8,			midStep,
//[21]    VK_F8 | KK_SHIFT,		midHistBack,
    VK_F9,			midDebugToggleBp,
    VK_F10,			midPStep,
//[21]    VK_F10 | KK_SHIFT,		midHistForward,
    VK_F10 | KK_CONTROL,	midWndMaximize,
    0,	  0
};

MENUBAR MenuBarQedit = {
    sizeof (rgMenuQedit) / sizeof (MENU),
    rgMenuQedit,	//[21]
    rgmpvkeyidQedit
};

MENUBAR MenuBarQhelp = {
    sizeof (rgMenuQhelp) / sizeof (MENU),
    rgMenuQhelp,
    rgmpvkeyidQhelp
};

MENUBAR MenuBarQbas = {
    sizeof (rgMenuQbas) / sizeof (MENU),
    rgMenuQbas,		//[21]
    rgmpvkeyidQbas
};


void NEAR SetHelpKeyword (szSrc)
char *szSrc;
{
    register ushort cb;
    register char ch;
    char *pchDst;

    cb = CB_HELP_SYNTAX;
    pchDst = szHelpSyntax + OB_HELP_SYNTAX;
    while(cb && (ch = *szSrc++)) {
	*pchDst++ = ch;
	cb--;
    }
    while (cb--) {
	*pchDst++ = ' ';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uistub.c ===
#include "version.h"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uiview.c ===
/*** 
*uiview.c - Support View menu items.
*
*	Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*	All View menu support routines, and C Debug menu support.
*
*******************************************************************************/

/* First, include version definition header */
#include <version.h>

/* Next, include TextWin's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>
#include <uiext.h>

/* include dialog information */
#include <cw/dlg.h>
#include "uiview.hs"
#include "uiview.sdm"

/* Next, include QBI's headers */
#ifndef CONTEXT_H
#include <context.h>
#endif

#ifndef NAMES_H				/* [1] */
#include <names.h>		       /* [1] */
#endif					/* [1] */

#ifndef PARSER_H
#include <parser.h>
#endif

#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef RTPS_H
#include <rtps.h>
#endif

#ifndef TXTMGR_H
#include <txtmgr.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

#ifndef UTIL_H
#include <util.h>
#endif

ushort oRsOfAlphaMrs(ushort);
void NEAR DrawViewListBox(PWND, ushort, ushort);
STATICF(bool) UnloadFile(ushort);		//[32]
STATICF(void) DescribeORs(void);
WORD NEAR DoViewSub (TMC);

bool NEAR FChInSet(char ch, char *szSet);	//[26]
bool NEAR FValidId(char *szName);		//[26]

bool fPcodeOnly;

extern ushort iHelpId;		//[11]


ushort oRsInitial; /* set by CmdViewSubs() for ViewSubsDialog() */
ushort oRsView;    /* set by ViewSubsDialog() for CmdViewSubs() */
ushort oRsDst;	   /* set by ViewSubsDialog() for CmdViewSubs() */
ushort oProcOrModule;

#define CB_LISTBOX_COL 20
#define CBMAX_EXPLEN 40 /* [10] max length of expression for instant watch */

/**********************************************************************
* oRsOfAlphaMrs(iAlpha)
* Purpose:
*	Just like oRsOfAlpha, but it skips prs entries.
*	Returns the oRs of the iAlpha'th alphabetically sorted mrs.
*
**********************************************************************/
ushort oRsOfAlphaMrs(iAlpha)
ushort iAlpha;
{
    ushort i;
    ushort oRs;

    i = 0;
    while (TRUE) {
	if (((oRs = oRsOfAlpha (i++)) & 0x8000) == 0) {
	    if (oRs == 0x7fff) {
		return (UNDEFINED);
	    }
	    UiRsActivate (oRs);
	    if (!fPcodeOnly || !(mrsCur.flags2 & (FM2_NoPcode | FM2_Include))) {
		if (iAlpha-- == 0) {
		    return (oRs);
		}
	    }
	}
    }
}

WORD FAR
WListProcModuleAndSub (tmm, sz, isz, tmc, wParam, bArg)
WORD tmm;
char *sz;
WORD isz;
TMC tmc;
WORD wParam, bArg;
{
    WORD cRs, oRs;

    Unreferenced (wParam);
    Unreferenced (bArg);

    switch (tmm) {
	case tmmCount:
	    oProcOrModule = 0;
	    return ((WORD) -1);
	case tmmText:
	case tmmEditText:

	    cRs = UiAlphaORsBuild();
	    if (!cRs) {
		SetUiErrOm ();
	    }

	    if (uierr) {		//[27] if any errors occured
		*sz = '\0';		//[27] return a null string if needed
		return (isz == 0);	//[27] no error for first time
	    }

	    if (isz >= cRs) {
		return (FALSE);
	    }

	    switch (tmc) {
		case tmcListModulesAndSubs: oRs = oRsOfAlpha (isz); break;
	    }

	    if (oRs == UNDEFINED) {
		return (FALSE);
	    }

	    UiRsActivate (oRs);
	    if (oRs == oRsInitial) {
		oProcOrModule = isz;
	    }
	    GetRsName (grs.oRsCur,
		       (grs.oRsCur & 0x8000) ? RSN_fIndent : 0,
		       CB_LISTBOX_COL);
	    strcpy (sz, bufStdMsg);
	    break;
    }
    return (TRUE);
}



/* -------------------------------- *
 *          View Subs               *
 * -------------------------------- */

STATICF(bool) UnloadFile (oRsDiscard)		//[32]
ushort oRsDiscard;
{
    ushort result;

    EditMgrFlush1 ();	// [22] [16] CmdFileSave used editmgr buffer
    UiRsActivate (oRsDiscard);
    DbAssert ((mrsCur.flags2 & FM2_File) != 0);

    /* Give user a chance to back out of action, descan module's text
     * table to SS_RUDE (need to at least descan to SS_PARSE before
     * calling MrsDiscard().
     */
    if (!AskRudeEditFar ())
	return(FALSE);	 /* [32] user pressed CANCEL button */
    DoDrawDebugScr ();
    /* calling AskRudeEditFar can cause the output screen to be shown
     * (because of RunInit()), in which case, we need to re-draw the
     * list windows now.
     */

    if (mrsCur.flags2 & FM2_Modified) {
	/* give user a chance to save modified file */
	oRsDiscard = grs.oRsCur;
	if ((result = MsgBoxStd (MB_YESNOCANCEL, MSG_NotSaved)) == IDYES) {
	    if (!CmdFileSave()) {
		/* I/O error, or user pressed CANCEL button */
		if (uierr != 0)
		    ReportError ();   /* user didn't press CANCEL */
		return(FALSE);		//[32]
	    }
	}
	if (result == tmcCancel)
	    return(FALSE);		//[32]
	UiRsActivate (oRsDiscard);  /* CmdFileSave could activate other mrs's */
    }
    MrsDiscard ();
    return(TRUE);			//[32]
}

/**************************************************************************
* DescribeORs()
* Purpose:
*  Display the type of file currently selected in the ViewSubs dialog.
*  This message is one of the following (in 50 columns or less):
*       00000000011111111112222222222333333333344444444445 
*       12345678901234567890123456789012345678901234567890
*       xxxxxxxx.xxx is the Main Module
*       xxxxxxxx.xxx is a Module
*       xxxxxxxx.xxx is an Include File
*       xxxxxxxx.xxx is a Document
*       xxxxxxxxxxxxxxxxxx is a Subprogram in yyyyyyyy.yyy 
*       xxxxxxxxxxxxxxxxxx is a Function in yyyyyyyy.yyy
*       00000000011111111112222222222333333333344444444445
*       12345678901234567890123456789012345678901234567890
*
* Entry:
*  grs.oRsCur identifies currently selected module.
*
**************************************************************************/
STATICF(void)
DescribeORs()
{
    ushort msgId;
    char szDesc[71];   //IPG- from 51, length of buffer needed to increase.
		       // since functions names were being truncated in view box
    *szDesc = '\0';
    GetRsName(grs.oRsCur, 0, (grs.oRsCur & 0x8000) ? 18 : 12);
    strcat (szDesc, bufStdMsg);
    ListStdMsg(MSG_Is);
    strcat (szDesc, bufStdMsg);
    if (grs.oRsCur & 0x8000) {
	/* it is an prs, not a mrs */
	msgId = (prsCur.procType == PT_FUNCTION) ?
	    MSG_Function : MSG_Sub;
    }
    else {
	/* it is an mrs, not a prs */
	msgId = (mrsCur.flags2 & FM2_Include) ?
		MSG_IncludeFile : (mrsCur.flags2 & FM2_NoPcode) ?
		MSG_Document : (grs.oMrsMain == grs.oRsCur) ?
		MSG_MainModule : MSG_Module;
    }
    ListStdMsg(msgId);
    strcat (szDesc, bufStdMsg);
    if (grs.oRsCur & 0x8000) {
	/* it is an prs, not a mrs */
	GetRsName(grs.oMrsCur, 0, 12);
	strcat (szDesc, bufStdMsg);
    }

    SetTmcText (tmcViewSubsDescription, szDesc);
}


BOOL FAR
FDlgViewSubs (dlm, tmc, wNew, wOld, wParam)
WORD dlm;
TMC tmc;
WORD wNew, wOld, wParam;
{
    Unreferenced (wNew);
    Unreferenced (wOld);
    Unreferenced (wParam);
    Unreferenced (tmc);

    if (uierr && dlm != dlmTerm)	//[36] Return FALSE if OM error, unless
	return (FALSE); 		//[36]	we are trying to terminate

    switch (dlm) {
	case dlmInit:
	    SetTmcVal (tmcListModulesAndSubs, oProcOrModule);
	    SetTmcListWidth (tmcListModulesAndSubs, 3);       //[12]
	case dlmClick:
	    if (uierr)			//[27] if there was an error, the call
		break;			//[27] to oRsOfAlpha would be bogus.
	    oRsView = oRsOfAlpha (GetTmcVal (tmcListModulesAndSubs));
	    UiRsActivate (oRsView);
	    DescribeORs ();
	    break;

	case dlmTerm:			//[27] we always want to
	    return (TRUE);		//[27] allow termination.
    }

    return (!uierr);
}


/*** 
*VOID NEAR CmdViewSubs ()
*Purpose:
*	Perform View/Subs command.
*
*Entry:
*	None.
*
*Exit:
*	mrsCur is changed to new oRs from View/Subs dialog.
*
*Exceptions:
*	None.
*******************************************************************************/
VOID NEAR CmdViewSubs()
{
    REG1 ushort oRsReg;
    sd sdName;
    HCABViewSubs hcabViewSubs;
    TMC tmc;
    ushort ogNam;

/*********************************************************************
 *    If there is selected text then we want to jump directly to
 *    that procedure. If there is no selected text, but the cursor
 *    is on the name of a procedure, then we want to bring up the
 *    list box with that procedure name selected.
 *********************************************************************/
    oRsReg = oRsInitial = UNDEFINED;

    if (GetSelText(&bufStdMsg[0], CB_IDNAM_MAX + 1) != 0) {
	/* user has selected an identifier, make it the default */
	oRsReg = 0;
    }
    else if (GetEditWord( bufStdMsg, CB_IDNAM_MAX + 1) != 0) {
	/* cursor is after an identifier */
	oRsReg = oRsInitial = 0;
    }

    if (oRsReg == 0) {
	sdName.pb = bufStdMsg;
	sdName.cb = CbSzUi(bufStdMsg);
	if (!(ogNam = OgNamOfPsd(&sdName))) {
	   /* couldn't find the ogNam don't preselect a prs */
	   oRsReg = UNDEFINED;
	}
	else {
	    oRsReg = PrsFind(ogNam) | 0x8000;		/* [1] */
	    UiRsActivate(oRsReg);
	    if (txdCur.flags & FTX_mrs) {
		/* selected name was for a prs with no text table, like a
		 * DEF FN or SUB which is only called but has not text table.
		 * Treat this the same as if nothing was selected.
		 */
		oRsReg = UNDEFINED;
	    }
	    if (oRsInitial != UNDEFINED) {
		oRsInitial = oRsReg;
		oRsReg = UNDEFINED;
	    }
	}
    }

    if ((oRsView = oRsReg) == UNDEFINED) {
	/* Selected text (if any) didn't match any known prs.
	 * Let user select prs from a list */

	DbAssert(uierr == 0)	//[29]

	hcabViewSubs = (HCABViewSubs) HcabAlloc (cabiCABViewSubs);
	/* [5] Catch HcabAlloc errors */
	if (uierr)
	    return;

	(*hcabViewSubs)->oModuleOrSub = 0;

	while (DoViewSub (tmc = TmcDoDlgFar (&dlgViewSubs, sizeof (dlgViewSubs), hcabViewSubs))) ;

	FreeCab (hcabViewSubs);

	/* user pressed CANCEL or got error (like out-of-memory) */
	if (tmc == tmcCancel || uierr != 0) {
	    return;
	}

	/* user didn't press CANCEL button */
	UiRsActivate (oRsView); 	//[30] if DIALOG_NOSAVE, oRs may be wrong
    }

    /* [5] Fix QB4.1 PTR #107, fix View/Subs Split functionality */
    /* else user wants to edit new oRs in current window */
    UiRsActivate(oRsView);
    /* open list window if only command window is open.
     * make sure active window is a list window.
     * show text table identified by grs.oRsCur in that list window.
     */
    WndAssignList();
}

WORD NEAR
DoViewSub (tmc)
TMC tmc;
{

    if (tmc != tmcDelete)	//[33]
	return (FALSE);

    if ((oRsView & 0x8000) == 0) {
	/* user selected a module */
    }
    else {
	/* deleting or moving a procedure */
	    /* deleting a procedure, make sure its not a mistake */
	    if (MsgBoxStd(MB_OKCANCEL, MSG_DelProc) != IDDEFAULT)
		return (TRUE);	 /* user pressed cancel */
    } /* deleting or moving a procedure */
    AlphaORsFree();
    oRsInitial = grs.oMrsCur;

    if (tmc == tmcDelete) {
	if ((oRsView & 0x8000) == 0) {
	    /* user selected a module */

	    UnloadFile(oRsView);
	}
	else {
	    /* user selected a procedure */

	    /* Give user a chance to back out of action */
	    if (AskCantCONT()) {
		UiRsActivate(oRsView);
		PrsDiscard();
	    }
	}
    }


    /* redraw list window behind dialog box to reflect change */
    DoDrawDebugScr();
    return (uierr == 0);
}


/*** 
*bool NEAR FChInSet(char ch, char *szSet)
*Purpose:
*	Returns TRUE if ch is in the set specified by szSet.
*
*	new for revision [26]
*
*Entry:
*	ch - The char to check for.
*	szSet - a string of characters to check ch against.
*	        if szSet[n] == '-' then
*		    check if ch is in the interval szSet[n+1]...szSet[n+2]
*
*Exit:
*	returns TRUE if ch is in the specified set.
*
*******************************************************************************/
bool NEAR FChInSet(ch, szSet)
REG2 char ch;
REG1 char *szSet;
{

    while (*szSet != 0) {
	if (*szSet == '-') {
	    if (ch >= szSet[1] && ch <= szSet[2])
	       return(TRUE);
	    szSet += 3;
	}
	else if (ch == *szSet++)
	   return(TRUE);
    }
    return(FALSE);
}

/*** 
*bool NEAR FValidId(char *szName)
*Purpose:
*	Checks if szName is a valid identifier.
*
*	new for revision [26]
*
*Entry:
*	szName - The name to check.
*
*Exit:
*	returns TRUE if szName is valid
*
*******************************************************************************/
bool NEAR FValidId(szName)
REG1 char *szName;
{
    REG2 char *szCharsCur;
    static char szCharsId[] = "-09.-AZ-az";

    /* First character must be alphabetic */
    szCharsCur = szCharsId + 4;
    do {
	if (!FChInSet(*szName++, szCharsCur))
	    return(FALSE);
	/* Subsequent characters can also be numberic or period */
	szCharsCur = szCharsId;
    } while (*szName);
   
    return(TRUE);
}

sd sdProcName;

VOID NEAR CmdNewProc (rsType)
char rsType;
{
    ushort lnCursor;
    ushort oRsProc;
    char szProcName[CB_IDNAM_MAX + 1];
    HCABNewProc hcabNewProc;
    ushort oType;	//[26]

    /* New Sub/Function is a Rude Edit */
    if (!AskRudeEditFar())
	return;   /* user wants to abort action */

    DbAssert(uierr == 0);	 //[29]

    hcabNewProc = (HCABNewProc) HcabAlloc (cabiCABNewProc);
    /* [5] Catch HcabAlloc errors */
    if (uierr)
	return;

    sdProcName.pb = szProcName;
    bufStdMsg[0] = 0;
    if (GetSelText (&bufStdMsg[0], CB_IDNAM_MAX + 1) == 0) {
	GetEditWord (bufStdMsg, CB_IDNAM_MAX + 1);
	/* fill bufStdMsg with id if cursor is after an identifier */
    }
    strcpy (szProcName, bufStdMsg );
    sdProcName.cb = CbSzUi (szProcName);
    SzToCab (hcabNewProc, szProcName, Iag (CABNewProc, szProcName));
    // [18] if SzToCab memory allocation failed, free cab and exit.
    if (uierr)
	goto CmdNewProcEnd;

Retry:
    if (TmcDoDlgFar (&dlgNewProc, sizeof (dlgNewProc), hcabNewProc) != tmcCancel) {
	SzFromCab (hcabNewProc, szProcName, CB_IDNAM_MAX + 1,	// [15]
		   Iag (CABNewProc, szProcName));
	if ((sdProcName.cb = CbSzUi (szProcName)) == 0) {
	    MsgBoxStd (MB_OK, MSG_MustSpecifyName);
	    goto Retry;
	}

	oType = OTypeOfTypeCharFar(szProcName[sdProcName.cb-1]);	//[26]
	if (oType)							//[26]
	    szProcName[--(sdProcName.cb)] = 0;				//[26]

	/* don't let user try to put param list in with name */
	if ((rsType != RS_function && oType != ET_IMP)  //[26]
		|| !FValidId(szProcName)) {		//[26]
	    MsgBoxStd (MB_OK, MSG_BadId);
	    goto Retry;
	}

	UiGrabSpace ();
	/* Don't allocate memory that could steal
	 * from our ability to execute a SYSTEM, CLEAR, or SETMEM stmt.
	 */
	if ((oRsProc = RsMake (&sdProcName, rsType)) != UNDEFINED) {
	    WndAssignList ();	/* make new proc visible in list window */
	    /* RsMake encountered no errors */
	    TxtPrsInit (oType); /* Insert module's DEFxxx state in proc */
	    /* Place cursor at end of SUB/FUNCTION line */
	    lnCursor = txdCur.cLines - 2;
	    MoveCursorPwndCur (lnCursor,
			       cbGetLineBuf (oRsProc,
					     lnCursor,
					     ps.bdpSrc.cbLogical,
					     ps.bdpSrc.pb));
	    DrawDebugScr ();
	}
	UiReleaseSpace ();
    }

CmdNewProcEnd:	// [18]
    FreeCab (hcabNewProc);
}

/*************************************************************************
* CmdViewInclude(fShow)
* Purpose:
*	Make $INCLUDE files in all list windows visible if fShow!=0,
*	or invisible if fShow==0.
*	Cursor is kept as close to current line as possible.
*
*************************************************************************/
VOID FAR CmdViewInclude(fShow)
REG1 bool fShow;
{

    if (fShow != fViewInclude) {
	DbAssert(FALSE);	//[35] shouldn't ever get here
    }
} /* CmdViewInclude */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uiword.asm ===
page	,132
	TITLE	uiword.asm - Low level code for delineating words
;*** 
;uiword.asm
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	Interface between CW and and QB for determining characters
;	delineating words.  Contains tables and code that define
;	character set allowed in generic words, and BASIC labels.
;
;
;*******************************************************************************


	.xlist
	include	version.inc
	.list

	UIWORD_ASM = ON

	IncludeOnce uiint


assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

	subttl	DATA segment definitions.
	page


sBegin UI
assumes CS,UI

	extrn	GetEditWord:near	

	; Verify that all the GEW constants have realistic values
	; These must match with the word at wordDot.

	.erre	GEW_DFLTMASK   EQ 5E03H
	.erre	GEW_DFLTMASK   EQ GEW_NODOTMASK OR 0002H
	.erre	GEW_DFLTMASK   EQ GEW_HELPMASK	OR 4002H
	.erre	GEW_VARMASK    EQ 0000H
	.erre	GEW_VARDOTMASK EQ GEW_VARMASK	OR 0002H


wordCharBitMask	dw	00000H	; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
				
				; N S S E E E A B B H L V F C S S
				; U O T T O N C E S T F T F R O I
				; L H X X T Q K L

		dw	00000H	; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
				
				; D D D D D S E C E S E F G R U S
				; L C C C C Y T A M U S S S S S P
				; E 1 2 3 4 N B N   B C

wordDot 	dw	05e03H	; 0 1 0 1 1 1 1 0 0 0 0 0 0 0 1 1
				;   ! " # $ % & ' ( ) * + , - . /

		dw	0ffC0H	; 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0
				; 0 1 2 3 4 5 6 7 8 9 : ; < = > ?

		dw	07fffH	; 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
				; @ A B C D E F G H I J K L M N O

		dw	0ffe0H	; 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0
				; P Q R S T U V W X Y Z [ \ ] ^ _

		dw	07fffH	; 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
				; ` a b c d e f g h i j k l m n o

		dw	0ffe0H	; 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0
				; p q r s t u v w x y z { | } ~ D
				;                               E
				;                               L

		dw	0ffffH	; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
				
				; Accented letters (IBM char set)

		dw	0ffe0H	; 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0
				
				; Accented letters (IBM char set)

		dw	0ff00H	; 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
				
				; Accented letters (IBM char set)

LabelBitMask	dw	00040H	; 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0
				
				; N S S E E E A B B H L V F C S S
				; U O T T O N C E S T F T F R O I
				; L H X X T Q K L

		dw	00000H	; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
				
				; D D D D D S E C E S E F G R U S
				; L C C C C Y T A M U S S S S S P
				; E 1 2 3 4 N B N   B C

		dw	08002H	; 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
				;   ! " # $ % & ' ( ) * + , - . /

		dw	0ffc0H	; 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0
				; 0 1 2 3 4 5 6 7 8 9 : ; < = > ?

		dw	07fffH	; 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
				; @ A B C D E F G H I J K L M N O

		dw	0ffe0H	; 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0
				; P Q R S T U V W X Y Z [ \ ] ^ _

		dw	07fffH	; 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
				; ` a b c d e f g h i j k l m n o

		dw	0ffe0H	; 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0
				; p q r s t u v w x y z { | } ~ D
				;                               E
				;                               L

		dw	0ffffH	; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
				
				; Accented letters (IBM char set)

		dw	0ffe0H	; 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0
				
				; Accented letters (IBM char set)

		dw	0ff00H	; 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
				
				; Accented letters (IBM char set)

	subttl	Low level CW interface for chars in defining words/labels
	page

;***
;IsInTable - checks specified table for presence of character
;Purpose:
;  Uses mod arithematic to check of a bit in a mask table
;  is on for a character. This is used to classify character
;Entry:
;  al - character
;  si - pointer to mask table
;Exit:
;  returns - 1 if in table
;	     0 if not
;Uses:
;  bx, cx
;***
cProc	IsInTable,<NEAR>
cBegin
	cmp	al, 0b0H
	jae	NotInTable

; See if bit # char is set in the array of bits WordCharBitMask
	push	ax
	and	ax, 00f0H
	mov	cl, 3
	shr	al, cl
	mov	bx, ax
	mov	bx, cs:[si+bx]		; table is FAR to save DGROUP
	pop	ax
	and	al, 0fH
	inc	al
	mov	cl, al
	xor	ax, ax
	stc
	rcr	ax, cl
	and	ax, bx
	jz	NotInTable

	mov	ax, 1
	jmp	short InTableDone

NotInTable:
	xor	ax, ax

InTableDone:
cEnd


;***
;IsWordChar, IsLabelChar - checks if character can be in a word or BASIC label
;Purpose:
;  Sets up word table and calls IsInTable to see if specified character
;  is a valid character in a word/BASIC label.
;Entry:
;  parmB char - character to test
;Exit:
;  returns - 1 if char can be part of a word
;	     0 if not
;Uses:
;  Per Convention
;*****************************************************************************
cProc	IsWordChar,<PUBLIC,FAR>,<SI>
	parmB	char
cBegin
	mov	si, UIOFFSET WordCharBitMask
	mov	al, char
	cCall	IsInTable
cEnd

cProc	IsLabelChar,<PUBLIC,NEAR>,<SI>
	parmB	char
cBegin
	mov	si, UIOFFSET LabelBitMask
	mov	al, char
	cCall	IsInTable
cEnd


;***
;GetEditWordMask - Calls GetEditWord, disallowing certain standard characters
;
;Purpose:
;	Added with revision [5].
;	Toggles the bits inthe table that are specified by the mask, then
;	calls GetEditWord.
;
;Entry:
;	pBuf - ptr to buffer to receive word	(same as GetEditWord)
;	cbMax - maximum size of buffer		(same as GetEditWord)
;	wMask  - GEW constant defining what values to mask out for this
;		GetEditWord search.
;
;Exit:
;	none
;
;Uses:
;	Per Convention
;*****************************************************************************
cProc	GetEditWordMask,<PUBLIC,NEAR>
parmW	pBuf
parmW	cbMax
parmW	wMask
cBegin
	mov	ax,wMask		; get the new set of legal chars
	mov	cs:[wordDot],ax		; disable characters in words
	cCall	GetEditWord,<pBuf,cbMax> ;get word under cursor
	or	cs:[wordDot],GEW_DFLTMASK ; re-enable proper chars in words
cEnd

sEnd	UI
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\uq\uiwind.c ===
/***
*uiwind.c
*
*  Copyright <C> 1985-1988, Microsoft Corporation
*
*Purpose:
*  Window Management Functions.
*
*******************************************************************************/

/* First, include version definition header */
#include <version.h>

/* Next, include COW's interface headers */
#include <cw/version.h>
#include <cw/windows.h>
#include <cw/edityp.h>
#include <uiext.h>
#include <uinhelp.h>

/* Next, include QBI's headers */
#ifndef CONTEXT_H
#include <context.h>
#endif

#ifndef PARSER_H
#include <parser.h>
#endif

#ifndef QBIMSGS_H
#include <qbimsgs.h>
#endif

#ifndef TXTMGR_H
#include <txtmgr.h>
#endif

#ifndef UI_H
#include <ui.h>
#endif

#ifndef UIINT_H
#include <uiint.h>
#endif

#ifndef UTIL_H
# include "util.h"
#endif

STATICF(PWND) PwndPrev(PWND);
STATICF(PWND) PwndStealAbove(PWND);
STATICF(PWND) PwndGiveAbove(PWND);
STATICF(PWND) PwndStealBelow(PWND);
STATICF(void) SetWndFields(PWND, ushort);
STATICF(void) WndRecalc(void);
STATICF(void) WndSetEnable(PWND);
PWND(NEAR WndAlloc(void));
void NEAR WndDebugOpen(AY);
void FAR WnReAssign(ushort, ushort, boolean);
void FAR WndReAssign(ushort, ushort, boolean);
void NEAR WndAssignList1(void);
void NEAR DoWndAssignList(boolean);
STATICF(void) DragCaption(PWND, AY);
void FAR DrawDebugScrFar(void);
void FAR DoDrawDebugScrFar(void);
void FAR ScreenRedraw(void);
void NEAR PutChSetup(AX, AY);
void NEAR PutCh(char);
void NEAR PutChCbPb(ushort, char *);
void FAR StatusMsgFar(short);

/* Forward declarations */
STATICF(void) DrawPwndOutline(PWND);
STATICF(void) WndFullScreen(PWND);
void NEAR WndNoFullScreen(void);

extern ushort NEAR HStatusButton(ushort);    //[47]
extern VOID NEAR DoStatusButton(ushort);     //[47]
extern ushort NEAR ObStatusButton(ushort);      //[47]
extern short NEAR CbStatusButton(ushort);    //[47]
ushort hStatusButtonCur = NULL;           //[47]

WORD FAR DebugWndProc (PWND, WORD, WORD, DWORD);
DWORD FAR HelpWndProc (PWND, WORD, WORD, DWORD);
uchar * NEAR AppendBuf(uchar *, WORD);
WORD FAR StatusWndProc (PWND, WORD, WORD, DWORD);
DWORD FAR EditFilterWndProc (PWND, WORD, WORD, DWORD);

#define DayPwnd(pw)  ((AY)((pw)->arcClipping.ayBottom-(pw)->arcClipping.ayTop))
#define DaxPwnd(pw)  ((AX)((pw)->arcClipping.axRight-(pw)->arcClipping.axLeft))
#define GrowPwnd(pw,day)   SetWindowSize(pw,DaxPwnd(pw),DayPwnd(pw)+day)
#define ShrinkPwnd(pw,day) SetWindowSize(pw,DaxPwnd(pw),DayPwnd(pw)-day)

/* TRUE if scroll bars are to be visible */
boolean fScrollBars = TRUE;
/* TRUE when HELP is visible and WATCH is dispabled */
bool fHelpVisible = FALSE;
bool fAdjustCursor = FALSE;      //[52]

static bool fSignonDisplayed = FALSE;  //[64] TRUE if signon has been displayed
extern BYTE HelpFlags;        //[45]

#define cWindowsMax  4

static bool fDaySaveHelpOk = FALSE; //[34]
static ushort daySaveHelpWnd1;      //[34]
static ushort daySaveHelpWnd2;      //[34]
static ushort daySaveHelpCmd;    //[34]
static PWND pwndActSaveHelp;     //[41]


               //[72] so don't ever put it up
short iMsgStatusLine = MSG_StatusEdit; //[72] start with Edit window message
ISA isaStatusLineVal = isaStatusLine;  //[72] start in normal intensity
ushort cbStatusMsg;     //[10] size of current status message

struct ef EfTop, EfAltList, EfCmd, EfHelp;

WND wnd1 =
    wndGeneric (idWndEdit, WS_CHILD | WS_EDIT, TRUE, 0, 1, 80, 22,   //[55]
                EditFilterWndProc, &wndMain, NULL, NULL)
                { 0, (WORD) &EfTop }                  //[60]
    endWndGeneric;

WND wnd2 =
    wndGeneric (idWndEdit, WS_CHILD | WS_EDIT, TRUE, 0, 0, 0, 0,  //[55]
      EditFilterWndProc, &wndMain, NULL, NULL)
    { 0, (WORD) &EfAltList }                 //[60]
    endWndGeneric;

PWND pwndFull = NULL;
   /* points to the entry in twin which is currently full screen,
      NULL if no window is currently full screen */

WND wndCmd =
    wndGeneric (idWndEdit, WS_CHILD | WS_EDIT, TRUE, 0, 0, 0, 0,  //[55]
      EditFilterWndProc, &wndMain, NULL, NULL)
    { 0, (WORD) &EfCmd }                  //[60]
    endWndGeneric;

WND wndDebug =
    wndGeneric (idWndDebug, WS_CHILD, TRUE, 0, 0, 0, 0,
      DebugWndProc, &wndMain, NULL, NULL)
    { 0, 0 }                        //[60]
    endWndGeneric;

WND wndHelp =
    wndGeneric (idWndHelp, WS_CHILD, TRUE, 0, 0, 0, 0,
      HelpWndProc, &wndMain, NULL, NULL)
    { 0, (WORD) &EfHelp }                 //[60]
    endWndGeneric;


WND wndStatus =
    wndGeneric (idWndStatus, WS_CHILD, TRUE, 0, 0, 0, 0,
      StatusWndProc, NULL, NULL, NULL)
    { 0, 0 }                        //[60]
    endWndGeneric;

PWND pwndBegin = &wnd1;
PWND pwndTop = &wnd1;
PWND pwndAct = &wnd1;

bool fWndSplit = FALSE;    //[41]

/* default size of command window */
#define dayCmdMin 2
#define dayCmdMax 10

static bool fDrawDebugScr = FALSE;

/*------------------------- Window Definitions -------------------------------*/

/* root window for Debug Screen, with defaults set for CGA card */
WND wndMain =
   wndGeneric (idWndMain, WS_TILED | WS_HSCROLL | WS_VSCROLL, TRUE,
          0, 0, 80, 25, MainWndProc, NULL, NULL, NULL)
   { 0, 0 }                   //[60]
   endWndGeneric;


extern WND wndScrollV, wndScrollH;

/*------------------------------------------------------------------
          Window Searching Functions
 *----------------------------------------------------------------*/

/*******************************************************************
* PWND PwndPrev (pwnd)
* Purpose:
*  Return pointer to window above this window.  If pwnd is top
*  window on screen, return NULL.
*
*******************************************************************/
STATICF(PWND)
PwndPrev (pwnd)
PWND pwnd;
{
    REG1 PWND pwndPrev;
    REG2 PWND pwndCur;

    pwndPrev = NULL;
    pwndCur = pwndBegin;
    while (pwndCur != pwnd) {
        DbAssert (pwndCur != NULL);
        pwndPrev = pwndCur;
        pwndCur = pwndCur->pwndSibling;
    }
    return (pwndPrev);
}

/*******************************************************************
* PWND PwndStealAbove (pwnd)
* Purpose:
*  Find window above a given one which has free space to give up
*
*******************************************************************/
STATICF(PWND)
PwndStealAbove (pwnd)
PWND pwnd;
{
    REG1 PWND pwndCur;
    REG2 PWND pwndPrev;

    pwndPrev = NULL;
    pwndCur = pwndBegin;
    while (pwndCur != pwnd) {
        DbAssert (pwndCur != NULL);
        if (pwndCur != &wndCmd && DayPwnd (pwndCur))
            pwndPrev = pwndCur;
        pwndCur = pwndCur->pwndSibling;
    }
    return (pwndPrev);
}

/*******************************************************************
* PWND PwndGiveAbove (pwnd)
* Purpose:
*  Find window above a given one which can grow
*
*******************************************************************/
STATICF(PWND)
PwndGiveAbove (pwnd)
PWND pwnd;
{
    REG1 PWND pwndCur;
    REG2 PWND pwndPrev;

    pwndPrev = NULL;
    pwndCur = pwndBegin;
    while (pwndCur != pwnd) {
        DbAssert (pwndCur != NULL);
        if (pwndCur != &wndCmd)
            pwndPrev = pwndCur;
        pwndCur = pwndCur->pwndSibling;
    }
    return (pwndPrev);
}

/*******************************************************************
* PWND PwndStealBelow (pwnd)
* Purpose:
*  Find window at or below a given one which has free space to give up
*
*******************************************************************/
STATICF(PWND)
PwndStealBelow (pwnd)
PWND pwnd;
{
    REG1 PWND pwndCur = pwnd;

    while (pwndCur != NULL && !DayPwnd (pwndCur)) {
        pwndCur = pwndCur->pwndSibling;
    }
    return (pwndCur);
}

/*******************************************************************
* void SetWndFields (pwnd)
* Purpose:
*  Initialize fields in a Pwnd structure. Called when a window
*  is allocated and/or opened.
*
* Entry:
*  wndMain structure describes debug screen
*
*******************************************************************/
STATICF(void)
SetWndFields (pwnd, oRs)
REG1 PWND pwnd;
ushort oRs;
{
    struct ef *pef = (struct ef *) pwnd->pefExtra; // [60]

    /* Set window relative fields */
    pef->pdCur.olntop =
       pef->pdCur.obleft =
       pef->ipCur.ob =
       pef->ipCur.oln =
       pef->ipAnchor.ob =
       pef->ipAnchor.oln = 0;

    pef->pwndScrollV = pef->pwndScrollH = (PWND) NULL;

    pef->hBuffer = oRs;
    pef->pdCur.oln = UNDEFINED;
    pef->fSelection = FALSE;
    pef->attrCur = (pwnd == &wndHelp) ? isaHelpWindow : isaEditWindow;  // [18]

    if ((cmdSwitches & CMD_SW_QHELP) && (pwnd == &wndHelp))
       pef->Style = ES_MULTILINE | ES_NOSELECT;                     // [QH1]
    else
       pef->Style = ES_MULTILINE;


    pef->pldCur = (ld *) &ps.ldDummy[0];
}

extern MENUBAR MenuBarQedit, MenuBarQhelp, MenuBarQbas;       //[74]

/*******************************************************************
* void WndInit ()
* Purpose:
*  Called once during initialization to init the window manager
*  and construct the borders of wndMain, wndScrollH, and wndScrollV.
*
* Entry:
*
*******************************************************************/
void near
WndInit ()
{
    ushort oRs = rsNew;

    /* init scrap for editor.  If we don't do it here, the editor
     * may call it during CopyLines(), at which time heap movement
     * is not allowed.
     */
    hbufScrap ();
    hbufOfCmd = RsMake (NULL, RS_cmdWnd);
    /* RsMake causes rsNew to get set. Reset it so WndReset won't be called
     * again for the Command window */
    rsNew = UNDEFINED;

    /* full screen less menu and status */
    SetWindowSize (&wndMain, axMac, ayMac-1);
    /* move to top, leave 1 row for menubar */
    MoveWindow (&wndMain, 0, 1);
    /* Make a root window */
    AddChild (NULL, &wndMain);

    SetWindowSize (&wndDebug, axMac, 0);
    MoveWindow (&wndDebug, 0, 1);
    AddChild (&wndMain, &wndDebug);

    SetWindowSize (&wndHelp, axMac-2, 0);
    MoveWindow (&wndHelp, 0, 1);
    AddChild (&wndMain, &wndHelp);
    SetWndFields (&wndHelp, hbufHelp); /* [7] */

    SetWindowSize (&wnd1, axMac-2, (ayMac - 3) -
                   ((cmdSwitches & CMD_SW_ED) ? 0 : (dayCmdMin + 1)));  //[74]
    MoveWindow (&wnd1, 1, 2);
    AddChild (&wndMain, &wnd1);
    SetWndFields (&wnd1, oRs);
    AddScrollBars ();      // [16]

    SetWindowSize (&wndStatus, axMac, 1);
    /* Size and Position status window */
    MoveWindow (&wndStatus, 0, ayMac-1);
    /* Another root window */
    AddChild (NULL, &wndStatus);

    // [74] No command window for QEDIT
    if (!(cmdSwitches & CMD_SW_ED)) {
        SetWindowSize (&wndCmd, axMac-2, dayCmdMin);
        MoveWindow (&wndCmd, 1, ayMac-(dayCmdMin+1));
        AddChild (&wndMain, &wndCmd);
        SetWndFields (&wndCmd, hbufOfCmd);
    }

    /* [74] initialize the menu bar */
    if (cmdSwitches & CMD_SW_QHELP)
        InitMenu (&wndMain, &MenuBarQhelp);
    else if (cmdSwitches & CMD_SW_ED)
        InitMenu (&wndMain, &MenuBarQedit);
    else
        InitMenu (&wndMain, &MenuBarQbas);
    FEnableMenuBar (FALSE);   // [27]
}

/***
*void RemoveScrollBars ()
*Purpose:
*  Removes the scroll bars from the active window.  It looks at
*  cScrollBarAdded to see if we are nested into AddScrollBars, and if
*  we are, does nothing.
*
*Entry:
*  None.
*
*Exit:
*  None.
*
*Exceptions:
*  None.
*******************************************************************************/
void NEAR RemoveScrollBars ()    // [16] cleaned up
{
    REG1 PWND pwndActReg = pwndAct;
    REG2 struct ef *pef = (struct ef *) pwndActReg->pefExtra;  // [60]

    /* If window has a horizontal scroll bar, resize the window */
    if (pef->pwndScrollH != NULL) {
        SetWindowSize (pwndAct, axMac-2, DayPwnd (pwndActReg) + 1);
        RemoveChild (&wndScrollH); // [26]
    }
    if (pef->pwndScrollV != NULL)   // [26]
        RemoveChild (&wndScrollV); // [26]

    pef->pwndScrollV = pef->pwndScrollH = NULL;
}

/***
*void AddScrollBars ()
*Purpose:
*  Adds the scroll bars to the active window if we have not done so
*  already.
*
*  This also makes sure that the cursor is within the window by calling
*  MoveCursorPwndCur with the current line and column.
*Entry:
*  None.
*
*Exit:
*  None.
*
*Exceptions:
*  None.
*******************************************************************************/
void NEAR AddScrollBars()     // [16] cleaned up
{
    REG1 PWND pwndActReg = pwndAct;
    REG2 struct ef *pef = (struct ef *) pwndActReg->pefExtra;  // [60]

    // [42] [43] Make sure cursor is within window
    fAdjustCursor++;       //[52] [68]

    /* [3] */
    if (!fScrollBars || pwndActReg == &wndCmd)  // [43]
        return;

    if (DayPwnd (pwndActReg) >= 2 && pwndActReg != &wndHelp) { //[75]
        SetWindowSize (pwndActReg, axMac-2, DayPwnd (pwndActReg) - 1);
        SetWindowSize (&wndScrollH, axMac-2, 1);
        MoveWindow (&wndScrollH, pwndActReg->arcClipping.axLeft,
                    pwndActReg->arcClipping.ayBottom);
        pef->pwndScrollH = &wndScrollH;
        // [26] Insert at front of list
        wndScrollH.pwndParent = &wndMain;
        wndScrollH.pwndSibling = wndMain.pwndChild;
        wndMain.pwndChild = &wndScrollH;
    }

    if (DayPwnd (pwndActReg) >= 3) {
        SetWindowSize (&wndScrollV, 1, DayPwnd (pwndActReg));
        MoveWindow (&wndScrollV, axMac-1, pwndActReg->arcClipping.ayTop);
        pef->pwndScrollV = &wndScrollV;
        // [26] Insert at front of list
        wndScrollV.pwndParent = &wndMain;
        wndScrollV.pwndSibling = wndMain.pwndChild;
        wndMain.pwndChild = &wndScrollV;
    }
}


STATICF(void)
WndRecalc()
{
    REG1 PWND pwnd;
    AY ayPrev = (DayPwnd (&wndDebug) == 0) ?
                 (AY) 2 : wndDebug.arcClipping.ayBottom + 1;

    RemoveScrollBars ();   // [16]
    for (pwnd = pwndBegin; pwnd != NULL; pwnd = pwnd->pwndSibling) {
        MoveWindow (pwnd, 1, ayPrev);
        ayPrev = pwnd->arcClipping.ayBottom + 1;
    }
    DbAssert (ayPrev == ayMac);
    AddScrollBars ();

    WndSetEnable(&wndHelp);      //[35]
    WndSetEnable(&wnd1);      //[35]
    WndSetEnable(&wnd2);      //[35]
    WndSetEnable(&wndCmd);    //[35]

    DrawDebugScr ();
    fDaySaveHelpOk = FALSE;      //[34]
}

/*******************************************************************
* void WndSetEnable (pwnd)
* Purpose:
*  Enables the specified window iff it has more than zero lines.
*
*  Renamed WndSetEnable from WndShow in revision [35]
*
*******************************************************************/
STATICF(void)
WndSetEnable (pwnd)
REG1 PWND pwnd;
{
    if (!DayPwnd (pwnd)) {
        /* window just has a title bar, no content is visible */
        if (pwnd->fEnabled) {
            /* window just became invisible */
            EnableWindow (pwnd, FALSE);
        }
    }

    /* window has some content visible */
    else if (!pwnd->fEnabled) {
        /* window just became visible */
        EnableWindow (pwnd, TRUE);
    }
}

/*******************************************************************
* void WndDeactivate ()
* Purpose:
*  If any window is currently active, make it inactive.
*  No changes are visible on the screen until DoDrawDebugScr is next called.
*
* Entry:
*  pwndAct points to active window
*
*******************************************************************/
void NEAR WndDeactivate ()
{
    UiRsActivateWnd (); /* load txdCur with active window's info */
    if (pwndAct != &wndHelp)        //[29]
        txdCur.lnCursor = GetEditLine ();   //[29]
    SetFocus (&wndMain);         //[43]
    RemoveScrollBars ();         // [16]
    DrawDebugScr ();
}

/*******************************************************************
* void WndActivate (pwnd)
* Purpose:
*  Make the specified window active (and deactivate the
*  currently active window (if any).
*  No changes are visible on the screen until DoDrawDebugScr is next called.
* Entry:
*  pwnd points to window to be made active.
*
*******************************************************************/
void NEAR WndActivate (pwndActNew)
REG1 PWND pwndActNew;
{
    DbAssert (pwndActNew != NULL);
    if (pwndAct != pwndActNew) {
        /* window isn't already active */
        WndDeactivate ();
        pwndAct = pwndActNew;

        if (txdCur.lnCursor == UNDEFINED
          || pwndActNew->style & UIWS_MOVECURSOR) { //[53]
            pwndActNew->style &= ~UIWS_MOVECURSOR;      //[53]
            MoveTxdCursor ();
        }

        UiRsActivateWnd ();     // [49]
        AddScrollBars ();    // [16]
        DoStatusMsg(pwndAct);      //[53]
        DrawDebugScr ();
    }
}

/*******************************************************************
* void WndDebugOpen (day, pwnd)
* Purpose:
*  Sets the Debug window size.   Used to allocate space for
*  Debug window.
* Entry:
*  day = number of lines in the Debug window
* Exit:
*
*******************************************************************/
void NEAR WndDebugOpen (day)
REG1 AY day;
{
    REG2 PWND pwnd;
    PWND pwndFullOld = NULL;

    pwndFullOld = pwndFull;
    WndNoFullScreen ();  /* disable full-screen for calculations */

    GrowPwnd (pwndBegin, DayPwnd (&wndDebug));
    SetWindowSize (&wndDebug, axMac, day);   /* [9] */
    while (day--) {
        pwnd = PwndStealBelow (pwndBegin);
        DbAssert(pwnd != NULL);
        DbAssert(DayPwnd (pwnd) != 0);

        ShrinkPwnd (pwnd, 1);
    }

    WndRecalc();
    WndFullScreen (pwndFullOld);
}


/*******************************************************************
* void WndHelpOpen (day, pwnd)
* Purpose:
*  Sets the Top window size.  Used to allocate space for
*  Watch and On-Line-Help windows.
* Entry:
*  day = number of lines in the Top window
* Exit:
*
*******************************************************************/
VOID NEAR WndHelpOpen (dayReq)         //[45]
REG1 WORD dayReq;
{
    REG2 PWND pwnd;
    PWND pwndCur;          //[28]
    AY dayWndGrow;            //[8]
    AY day = 0;            //[28]
    bool fDaySaveTmp;            //[34]

    if (dayReq != 0 && pwndFull == &wndHelp) //[41]
        return;           //[41]

    // If opening help window for /QHELP, make it as big as possible
    if ((dayReq != 0) && (cmdSwitches & CMD_SW_QHELP)) {
        dayReq = ayMac;
    }

    WndNoFullScreen ();          //[44]
    /***** Start of revision [34] *****/
    /*
     * If we are putting up fresh help save the sizes of the windows.
     *
     */
    if (!fHelpVisible && dayReq != 0) {
        fDaySaveHelpOk = TRUE;
        RemoveScrollBars();
        daySaveHelpWnd1 = DayPwnd(&wnd1);
        daySaveHelpWnd2 = DayPwnd(&wnd2);
        daySaveHelpCmd = DayPwnd(&wndCmd);
        pwndActSaveHelp = pwndAct;    //[41]
        /* Note: AddScollBars() will be done in WndRecalc below */
    }
    fDaySaveTmp = fDaySaveHelpOk;
    /***** End of revision [34] *****/

    pwnd = pwndTop;           //[41]
    dayWndGrow = DayPwnd(&wndHelp);    //[41]

    if (fHelpVisible) {          //[39]
        GrowPwnd (pwndTop, dayWndGrow+1);   //[8]
    }

    fHelpVisible = (bool) (dayReq != 0);  //[39] don't set until after
                  //[39] WndNoFullScreen();

    if (dayReq == 0) {
        pwndBegin = pwndBegin->pwndSibling;
        /***** Start of revision [34] *****/
        if (fDaySaveTmp) {
            RemoveScrollBars();
            SetWindowSize(&wnd1, axMac-2, (AY) daySaveHelpWnd1);
            SetWindowSize(&wnd2, axMac-2, (AY) daySaveHelpWnd2);
            SetWindowSize(&wndCmd, axMac-2, (AY) daySaveHelpCmd);
            /* Note: AddScollBars() will be done in WndRecalc below */
        }
        fDaySaveTmp = FALSE;
        /***** End of revision [34] *****/
    }
    else {
        dayReq++;
        while (dayReq--) {
            pwndCur = pwnd;        //[28]
            if ((pwnd = PwndStealBelow (pwndCur)) == NULL)  //[28]  //[34]
                break;            //[28]

            // DO Steal last line from active window!
            if (!(cmdSwitches & CMD_SW_QHELP)) {
                /***** Start of revision [34] *****/
                /*
                 * Don't steal the last line from the active window.
                 */
                if ((pwnd == pwndAct) && (DayPwnd(pwnd) <= 1)) {
                    pwnd = pwnd->pwndSibling;
                    if (pwnd == NULL)
                        break;
                    continue;
                }
            }
            /***** End of revision [34] *****/

            DbAssert(DayPwnd (pwnd) != 0);
            day++;

            ShrinkPwnd (pwnd, 1);
        }

        pwndBegin = &wndHelp;
        day --;           //[40]
    }

    DbAssert(day >= 0);          //[40]
    SetWindowSize (&wndHelp, axMac-2, day);  //[40]

    // Make /QHELP window full screen
    if (cmdSwitches & CMD_SW_QHELP)
        WndFullScreen(&wndHelp);
    else
        WndRecalc();          //[28]
    fDaySaveHelpOk = fDaySaveTmp;      //[34]
}

/*******************************************************************
* void WndHelpClose ()
* Purpose:                     1037
*  Restores the Debug window.
*
*******************************************************************/
void NEAR WndHelpClose ()
{
    PWND pwndFullSave = pwndFull;   //[32] save full window status

    WndNoFullScreen();        //[32] no full window
    if (pwndAct == &wndHelp) {      // [10] [16] Must be at beginning.
        DbAssert(pwndActSaveHelp != 0);     //[41]
        if (DayPwnd(pwndActSaveHelp) > 0)   //[41]
            WndActivate(pwndActSaveHelp);   //[41]
        else              //[41]
            WndActivate (pwndTop);    // [10]
    }
    if (fHelpVisible)
        WndHelpOpen (0);

    if (pwndFullSave && pwndFullSave != &wndHelp) {  //[32] restore full window
        WndFullScreen(pwndFullSave);          //[32] if it didn't close
        DrawDebugScr();
    }
}

/*******************************************************************
* void WndOpen (oRs)
* Purpose:
*  Create a new window in the debug screen.
*  Assumes the debug screen is already visible.
*  On exit, the newly created window is made active.
*  Factors which determine the window's size and location are:
*     - lines per screen (25 for CGA, 43 for EGA)
*     - whether menu bar and/or status line are enabled (visible)
*     - Current number of windows on screen
*
* Entry:
*  oRs identifies text table (register set) to be displayed in window
*
* Exit:
*  new window is linked into pwndTop's list and is made active,
*  ax points to new Pwnd structure.
*
*******************************************************************/
void NEAR WndOpen (oRs)
ushort oRs;
{
    REG1 PWND pwndNew;
    BYTE day;

    DbAssert (!fWndSplit && pwndTop != NULL);   //[41]

    /*
       [41] Make sure the window that is being split is big enough
    */
    WndActivate (pwndTop);        //[41]
    while (DayPwnd(pwndTop) < 3) {     //[41]
       WndGrow();          //[41]
    }                //[41]

    WndDeactivate ();
    /* Calculate day after WndDeactivate so scroll bars are not counted */
    day = DayPwnd(pwndTop);         //[41]
    pwndNew = (pwndTop == &wnd1) ? &wnd2 : &wnd1;

    SetWindowSize (pwndNew, axMac-2, day >> 1);
    SetWindowSize (pwndTop, axMac-2, (day - (day >> 1)) - 1);
    RemoveChild (&wndCmd);
    AddChild (&wndMain, pwndNew);
    AddChild (&wndMain, &wndCmd);
    SetWndFields (pwndNew, oRs);

    WndRecalc ();
    WndActivate (pwndNew);
    /* source line at top of window */
    // [16] Do this in WndOpen
    MoveCursorPwndCur (((struct ef *) pwndAct->pefExtra)->pdCur.olntop, 0);   // [60]
    WndActivate (pwndTop); // [16]
    fWndSplit = TRUE;
}

/*******************************************************************
* void WndClose ()
* Purpose:
*  This is called when the user asks to close a window.
*  All controls and edit fields in the window are released.
*  The window is removed from pwndTop list of visible windows.
*  All the closed window's lines are given to the window below.
*  If the closed window was active, the source window below
*  is made active.  If no source windows are left on the screen,
*  the command window is made active.
*
* Entry:
*  pwndAct - pointer to window to close
*
*******************************************************************/
void NEAR WndClose ()      // [16] clean up code.
{
    REG1 PWND pwndClose;
    REG2 PWND pwndGrow;

    DbAssert (pwndAct != &wndHelp); //[29]
    DbAssert (pwndAct != &wndCmd && pwndAct != NULL && fWndSplit);   //[41]
    if (pwndAct == &wnd2) {      //[41]
        pwndClose = &wnd1;      //[41]
        pwndGrow = &wnd2;    //[41]
    }             //[41]
    else {           //[41]
        pwndClose = &wnd2;      //[41]
        pwndGrow = &wnd1;    //[41]
    }             //[41]

    WndDeactivate ();

    /* actually give released space to other window */
    GrowPwnd (pwndGrow, DayPwnd (pwndClose) + 1);
    RemoveChild (pwndClose);

    pwndTop = pwndGrow;
    DbAssert (pwndTop != NULL); /* [24] */
    if (pwndBegin == pwndClose) // [16] Forgot to set pwndBegin.
        pwndBegin = pwndTop; // [16]
    WndRecalc();
    /* activate window which received the new space */
    WndActivate (pwndGrow);
    fWndSplit = FALSE;
}

/*******************************************************************
* void FAR WndReAssign (oRsOld, oRsNew, fRename)
* Purpose:
*  This function is called by the Text Manager when the user changes
*  the name of a procedure window by entering a SUB or FUNCTION statement
*  with an id name different from the window.
*  It is also called by MrsDiscard and PrsDiscard.
*  For each window, if the window is showing oRsOld, it is changed
*  to show oRsNew.
*  In addition, if rsNew == oRsOld, it is set to UNDEFINED (so WnReset
*  won't later try to show this now defunct register set.
*
* Entry:
*  oRsOld = register set which should no longer be displayed
*  oRsNew = register set to be shown in its place
*  fRename is TRUE if window is just being renamed (i.e. SUB FOO -> SUB FOO1)
*    if FALSE, cursor is moved to txdCur.lnCursor
*    (i.e. the place it was when oRsNew was last visible)
*
* Exit:
*  Existing grs.oRsCur is preserved
*
*******************************************************************/

void FAR WndReAssign (oRsOld, oRsNew, fRename)
ushort oRsOld;
ushort oRsNew;
boolean fRename;
{
    REG1 PWND pwndCur;
    ushort oRsSave;
    struct ef *pef;
    PWND   pwndFullOld;    //[66]

    oRsSave = grs.oRsCur;
    if (rsNew == oRsOld) {
        /* window is being removed before it ever got shown */
        rsNew = UNDEFINED;
    }

    pwndFullOld = pwndFull;   //[66]
    WndNoFullScreen();     //[66]

    for (pwndCur = pwndTop; pwndCur != NULL; pwndCur = pwndCur->pwndSibling) {
        pef = (struct ef *) pwndCur->pefExtra;    // [60]
        if (oRsOld == pef->hBuffer) {
            /* can't call EditMgrFlush1(), because it would end up calling
             * RsActivate for oRsOld, which no longer exists
             */
            pef->hBuffer = oRsNew;
            if (!fRename) {
                // [42] Cursor will be homed if txd.lnCursor is UNDEFINED (i.e.
                // [42] if oRsNew is for a new text table) the next time
                // [42] window is activated or DoDrawDebugScr is called.
                pwndCur->style |= UIWS_MOVECURSOR;
            }
            DrawDebugScr ();
        }
    }

    //[63] If we are renaming the pRs/oRs (fRename == TRUE) then we should
    //[63] update the bookmark list.  Otherwize, the bookmarks should be
    //[63] erased.

    ReAssignBookMark(oRsOld,(fRename ? oRsNew : UNDEFINED)); //[63]

    /* A Search/Change may be in progress.  The change may have caused
     * the oRs of a window to change.  If so, keep uisearch.c up to date.
     */
    SrchReAssign (oRsOld, oRsNew);

    WndFullScreen(pwndFullOld);  //[66]

}


void FAR WnReAssign (oRsOld, oRsNew, fRename)
ushort oRsOld, oRsNew;
boolean fRename;
{
    WndReAssign (oRsOld, oRsNew, fRename);
}

/**************************************************************************
* GetEditLine ()
* Purpose:
*  Returns the number of the current line (the line that has the cursor on it).
*
**************************************************************************/
ushort NEAR GetEditLine ()
{
    return (((struct ef *) pwndAct->pefExtra)->ipCur.oln);  //[43] [60]
}

/**************************************************************************
* GetEditColumn ()
* Purpose:
*  Returns the number of the current column (the column that has the
*  cursor on it).
*
**************************************************************************/
ushort NEAR GetEditColumn ()
{
    return (((struct ef *) pwndAct->pefExtra)->ipCur.ob);   //[43] [60]
}

/*******************************************************************
* void WndAssign ()
* Purpose:
*  Make active register set visible in active window.
* Entry:
*  grs.oRsCur identifies register set (text table) to show
*  pwndAct points to active window structure
* Exit:
*  grs.oRsCur will not change from caller's value (callers assume this)
*  Flag is set so debug screen will be refreshed next time
*  DoDrawDebugScr is called.
*
*******************************************************************/
void NEAR WndAssign ()
{
    ushort oRsNew;
    struct ef *pef = (struct ef *) pwndAct->pefExtra;    // [60]

    DbAssert (pwndAct != NULL);
    oRsNew = grs.oRsCur;

    /* rs isn't currently visible in active window OR
     * this is the first time we've shown this rs (TxtCurInit initializes
     * lnCursor to UNDEFINED.  This extra check is needed because register
     * sets are serially re-used as new file are unloaded and loaded.
     */
    if (oRsNew != pef->hBuffer || txdCur.lnCursor == UNDEFINED) {
        if (oRsNew != pef->hBuffer) {
            UiRsActivateWnd ();  /* activate pwndAct's register set */
            txdCur.lnCursor = GetEditLine ();
            /* so edit mgr doesn't think it already has current line cached */
            EditMgrFlush1 ();
            pef->hBuffer = oRsNew;
            UiRsActivate (oRsNew);
        }

        // position cursor where it was last time text was visible,
        // or at 0,0 if this txdCur.lnCursor == UNDEFINED
        MoveTxdCursor ();
        DrawDebugScr ();
    }

    DbAssert (oRsNew == grs.oRsCur);
}

/*******************************************************************
* void WndAssignList ()
* Purpose:
* Entry:
* Exit:
*
*******************************************************************/
void NEAR WndAssignList ()
{
    DoWndAssignList(FALSE);
}

/*******************************************************************
* void WndAssignList1 ()
* Purpose:
*
*******************************************************************/
void NEAR WndAssignList1 ()
{
    DoWndAssignList(TRUE);
}

/*******************************************************************
* void DoWndAssignList()
* Purpose:
*  Assigns grs.oRsCur to a list window.
*  If the active list window already is set to grs.oRsCur then this
*  is a no-op.
*  grs.oRsCur is assigned to:
*     wnd1 - If !fUseOtherWnd or !fWndSplit
*     wnd2 - Otherwise
*
*  Merge and rewrite of WndAssignList/WndAssignList1 in revision [54]
*
* Entry:
*  fUseOtherWnd - TRUE if other list window should be used if available.
* Exit:
*       grs.oRsCur is preserved.
*
*******************************************************************/
void NEAR DoWndAssignList(boolean fUseOtherWnd)
{
    REG1 ushort oRsNew;

    oRsNew = grs.oRsCur;

    if (pwndAct != &wnd1 && pwndAct != &wnd2) {
        WndNoFullScreen();
        WndActivate(pwndTop);
    }

    UiRsActivateWnd();
    if (grs.oRsCur == oRsNew)
        return;

    if (fWndSplit && fUseOtherWnd) {
        WndNoFullScreen();      //[62] must get out of full screen mode if we
                                //[62] are going to draw on the second window
        WndActivate((pwndAct == &wnd1) ? &wnd2 : &wnd1);
    }
    UiRsActivate (oRsNew);
    WndAssign();
}

/*******************************************************************
* void WndAssignNext (fPrev)
* Purpose:
*  Show next/previous procedure in current module in the active
*  list window.  If list window is not active, it is made active.
* Entry:
*  fPrev is TRUE if previous procedure is to be shown.
* Exit:
*  Flag is set so debug screen will be refreshed next time
*  DoDrawDebugScr is called.
*
*******************************************************************/
void NEAR WndAssignNext (fPrev)
boolean fPrev;
{
    REG1 ushort oRsPrev;
    ushort oRsCur;

    /* make sure a list window is active */
    DbAssert (pwndAct != NULL);
    if (UiAlphaORsBuild() == 0) {
        SetUiErrOm();
        return;
    }

    if (pwndAct == &wndCmd || pwndAct == &wndHelp) {  //[29]
        WndNoFullScreen ();           //[36]
        WndActivate (pwndTop);
    }
    UiRsActivateWnd ();    /* load mrsCur, prsCur with active window's info */
    oRsPrev = oRsCur = grs.oRsCur;
    NextAlphaPrs ();    /* activate next proc in current module */
    if (fPrev) {
        /* find prs that alphabetically precedes oRsCur */
        while (grs.oRsCur != oRsCur) {
            oRsPrev = grs.oRsCur;
            NextAlphaPrs (); /* activate next proc in current module */
        }
        UiRsActivate (oRsPrev);
    }

    /* make active proc visible in active window */
    WndAssign ();
}

/**************************************************************************
* WndSplit ()
* Purpose:
*  Split the active list window, or close the alternate list window.
*  On entry, we know that the active window is a list window.
*
**************************************************************************/
VOID NEAR WndSplit ()      // [16] Move functionality to WndOpen/Close
{
    WndNoFullScreen ();
    DbAssert (pwndTop != NULL);

    /* Command window is active.  Don't split it */

    if (pwndAct == &wndCmd || pwndAct == &wndHelp) {  //[29]
        WndActivate (pwndTop);
    }

    /* [37] only 1 list window is currently visible */
    if (!fWndSplit)
        WndOpen (grs.oRsCur);
    /* list window is already split - close inactive half */
    else
        WndClose ();
}

/*******************************************************************
* WnReset(oRs)
* Purpose:
*  We are either initializing, or the user has executed a NEW or LOAD
*  statement, which means windows we are displaying are no longer
*  valid.  This function makes the specified oRs visible in the
*  active list window (or any list window if no list window is active).
*
* Entry:
*  oRs identifies list window to show
*
*******************************************************************/
void FAR WnResetMove(oRs)
ushort oRs;
{
    WndReset (oRs);
    pwndAct->style |= UIWS_MOVECURSOR;    //[53]
}

/*******************************************************************
* WndReset (oRs)
* Purpose:
*  We are either initializing, or the user has executed a NEW or LOAD
*  statement, which means windows we are displaying are no longer
*  valid.  This function makes the specified oRs visible in the
*  active list window (or any list window if no list window is active).
*
* Entry:
*  oRs identifies list window to show
*
*******************************************************************/
void NEAR WndReset (oRs)
ushort oRs;
{
    DbAssert(oRs != UNDEFINED);
    UiRsActivate (oRs);
    WndAssignList ();
}

/*------------------------------------------------------------------
          Window Movement Functions
 *----------------------------------------------------------------*/

/*******************************************************************
* void WndFullScreen (pwndFullNew) - maximize or restore window
* Purpose:
*  Make window take up full screen, hiding all other windows on screen.
*  If pwndFullNew == NULL, restore all windows to their previous sizes.
*  Windows are toggled full screen by double clicking their caption bars,
*  or by clicking the maximize/restore icon.
*
*  Note: Since this routine is called from WndReAssign, neither this routine
*   nor anything that it calls can access any register sets.  Nor can
*   they call the text manager, as it is non-reentrant.
*
*
*Entry:
*  pwndFullNew: if non-NULL, window to maximize
*     if NULL, restore windows to original sizes
*
*Exit:
*  none
*
*******************************************************************/
STATICF(void)
WndFullScreen (pwndFullNew)
REG1 PWND pwndFullNew;
{
    REG2 PWND pwndCur;
    short i;
    static short cWindows = 0;
    static PWND rgPwndSave[cWindowsMax];
    static AY daySave;

    DbAssert (pwndFull == NULL || pwndFullNew == NULL);
    if (!((ushort) pwndFull | (ushort) pwndFullNew)) {
        return;
    }
    DbAssert (!(cmdSwitches & CMD_SW_ED))       //[74]

    RemoveScrollBars ();   // [16]

    if (pwndFullNew) {  /* maximize pwndFullNew */
        cWindows = 0;
        while ((pwndCur = wndDebug.pwndSibling) != NULL) {
            DbAssert (cWindows < cWindowsMax);
            rgPwndSave[cWindows++] = pwndCur;
            RemoveChild (pwndCur);
        }
        daySave = DayPwnd (pwndFullNew);
        AddChild (&wndMain, pwndFullNew);
        SetWindowSize (pwndFullNew, (axMac-2),
                       (ayMac-3) - DayPwnd (&wndDebug));
        pwndBegin = pwndTop = pwndFullNew;  /* [24] added pwndTop */
    }
    else { /* restore to original size */
        RemoveChild (pwndFull);
        for (i = 0; i < cWindows; i++) {
            AddChild (&wndMain, rgPwndSave[i]);
        }
        SetWindowSize (pwndFull, axMac-2, daySave);
        pwndBegin = fHelpVisible ? &wndHelp : wndHelp.pwndSibling;
        pwndTop = wndHelp.pwndSibling;
        DbAssert (pwndTop != NULL); /* [24] */
    }

    /* set pwndFull to NULL for minimize, pwndFullNew for maximize */
    pwndFull = pwndFullNew;

    WndRecalc(); // [31]
}

/*******************************************************************
* void WndNoFullScreen ()
* Purpose:
*  If the active window is in full-screen mode, restore it to its original
*  size and location.
*
*******************************************************************/
void NEAR WndNoFullScreen ()
{
    WndFullScreen (NULL);
}

/*******************************************************************
* ViewFull
* Purpose:
*  Called when F6 is pressed to toggle active window between normal
*  size and full-screen size.
*
*******************************************************************/
VOID NEAR ViewFull ()
{
    DbAssert (pwndAct != NULL);
    if (pwndFull == NULL)
        WndFullScreen (pwndAct);
    else
        WndNoFullScreen ();
}

/*******************************************************************
* void DragCaption(pwnd, ayNew)
*
* Purpose:
*  move the caption bar of a window, causing 1 window to grow, and
*  another to shrink.
*
* Entry:
*  pwnd = window whose title bar is to be moved
*  lnNew = new screen line for title bar
*
*******************************************************************/
STATICF(void)
DragCaption (pwnd, ayNew)
REG1 PWND pwnd;
AY ayNew;
{
    REG2 PWND pwndShrink;
    AY ayCur = pwnd->arcClipping.ayTop-1, ayTopCmd;
    PWND pwndPrev;

    RemoveScrollBars ();      // [16]

    /* Don't let command window grow larger than dayCmdMax lines */
    ayTopCmd = ayMac - dayCmdMax - 2;
    if (pwnd == &wndCmd && ayNew < ayTopCmd)
        ayNew = ayTopCmd;

    while (ayNew < ayCur) {
        /* title bar has been dragged up at least 1 line */
        /* find lowest window above pwnd that has any space to give up */
        if ((pwndShrink = PwndStealAbove (pwnd)) == NULL)
            break;   /* no space can be obtained */
        ShrinkPwnd (pwndShrink, 1);
        GrowPwnd (pwnd, 1);

        ayCur--;
    }

    while (ayNew > ayCur) {
        /* title bar has been dragged down at least 1 line */
        /* find lowest window above pwnd that can take space */
        if ((pwndPrev = PwndGiveAbove (pwnd)) == NULL)
            break;   /* no window above can take the space */

        /* we may need to move windows below this one down as well,
           set pwndShrink to highest window at or below current window
           which we can steal from */
        if ((pwndShrink = PwndStealBelow (pwnd)) == NULL)
            break;   /* this window and all windows below have no space to give */

        ShrinkPwnd (pwndShrink, 1);
        GrowPwnd (pwndPrev, 1);

        ayCur++;
    }

    WndRecalc ();
}

/*******************************************************************
* void ViewPrev()
* Purpose:
*  Called when Alt-Shift-Tab is pressed.  Makes previous window active.
*
*******************************************************************/
void NEAR ViewPrev ()
{
    REG1 PWND pwndCur;
    PWND pwndFullSave;

    WndDeactivate();       //[53]
    pwndFullSave = pwndFull;
    WndNoFullScreen ();

    pwndCur = pwndAct;     //[43]
    if ((pwndCur = PwndPrev (pwndCur)) == NULL) {
        /* top window is currently active, activate bottom window in screen */
        for (pwndCur = pwndAct;    //[53][54]Backout rev [53] change.
             pwndCur->pwndSibling != NULL;
             pwndCur = pwndCur->pwndSibling) ;
    }

    WndActivate (pwndCur);

    if (pwndFullSave != NULL) {
        WndFullScreen (pwndCur);
        DrawDebugScr ();
    }
}

/*******************************************************************
* void ViewNext()
* Purpose:
*  Called when VIEW/NEXT menu item is selected.  Makes next window
*  active.
*
*******************************************************************/
void NEAR ViewNext ()
{
    REG1 PWND pwndNext;
    PWND pwndFullSave;

    WndDeactivate();       //[53]
    pwndFullSave = pwndFull;
    WndNoFullScreen ();

    if ((pwndNext = pwndAct->pwndSibling) == NULL)
        pwndNext = pwndBegin;
    WndActivate (pwndNext);

    if (pwndFullSave != NULL) {
        WndFullScreen (pwndNext);
        DrawDebugScr ();
    }
} /* ViewNext */

/*******************************************************************
* void WndGrow ()
* Purpose:
*  Called when Ctrl+ is pressed to grow active window.
*  Moves active window's bottom line down 1 line if possible.
*  If no room at bottom, moves active window's top line up 1 line if possible.
*
*******************************************************************/
void NEAR WndGrow ()
{
    REG1 PWND pwnd;
    REG2 PWND pwndSteal;

    pwndSteal = PwndStealBelow (pwnd = pwndAct->pwndSibling);

    /* Only steal from command window as last resort */
    if (pwndSteal == &wndCmd && PwndStealAbove (pwndAct) != NULL) {
        pwndSteal = NULL;
    }

    /* there is a window below the active window - grow from bottom */
    if (pwndSteal != NULL) {
        DragCaption (pwnd, pwnd->arcClipping.ayTop);
    }
    /* there is no window below the active window - grow from top */
    else if (pwndAct != pwndBegin) {
        DragCaption (pwndAct, pwndAct->arcClipping.ayTop-2);
    }
}

/*******************************************************************
* void NEAR WndShrink ()
* Purpose:
*  Called when Ctrl- is pressed to shrink active window.
*  Moves active window's bottom line up 1 line if possible.
*  If no room at top, moves active window's top line down 1 line if possible.
*
*******************************************************************/
void NEAR WndShrink ()
{
    REG1 PWND pwndGive;

    WndNoFullScreen ();
    if (DayPwnd(pwndAct) > 0) {  //[43] [41]
        /* we have an active window */
        pwndGive = pwndAct->pwndSibling;

        /* Only give space to command window as last resort */
        if (pwndGive == &wndCmd && PwndGiveAbove (pwndAct) != NULL) {
            pwndGive = NULL;
        }

        /* there is a window below the active window */
        if (pwndGive != NULL) {
            DragCaption (pwndGive, pwndGive->arcClipping.ayTop-2);
        }
        else if (pwndAct != pwndBegin) {
            DragCaption (pwndAct, pwndAct->arcClipping.ayTop);
        }
    }
}


WORD FAR
StatusWndProc (pwnd, msg, wParam, lParam)
PWND pwnd;
WORD msg, wParam;
DWORD lParam;
{
    REG1 ushort hStatusButtonNew = NULL;     //[47]
    static ushort hStatusButtonStart = NULL;    //[47]
    ushort mouseX = (ushort) LOBYTE(LOWORD(lParam));  //[47]

    Unreferenced (pwnd);

    switch (msg) {
        case WM_PAINT:
            DrawStatusLine ();
            break;

        case WM_LBUTTONDBLCLK:  // [48]
        case WM_LBUTTONDOWN: // [10]
            /***** Begin revision [47] *****/
            hStatusButtonStart = HStatusButton(mouseX);
            if (hStatusButtonStart != NULL) {
                hStatusButtonNew = hStatusButtonStart;
                SetCapture(pwnd);
            }
            goto MouseCommon;

        case WM_MOUSEMOVE:
            if (hStatusButtonStart != NULL) {
                if ((wParam & MK_NONCLIENT) == 0) {
                    hStatusButtonNew = HStatusButton(mouseX);
                    if (hStatusButtonNew != hStatusButtonStart)
                        hStatusButtonNew = NULL;
                }
            }
            goto MouseCommon;

        case WM_LBUTTONUP:
            if (hStatusButtonStart != NULL) {
                ReleaseCapture();
                hStatusButtonStart = NULL;
            }
            if (hStatusButtonCur != NULL) {
                DoStatusButton(hStatusButtonCur);
            }
        MouseCommon:
            if (hStatusButtonNew != hStatusButtonCur) {
                hStatusButtonCur = hStatusButtonNew;
                DrawStatusLine();
            }
            /***** End revision [47] *****/
            break;

    } // switch (msg)

    return (0);
}

WORD FAR
DebugWndProc (pwnd, msg, wParam, lParam)
PWND pwnd;
WORD msg, wParam;
DWORD lParam;
{
    RRC rrc;

    Unreferenced (pwnd);
    Unreferenced (wParam);
    Unreferenced (lParam);

    if (msg == WM_PAINT) {
        GetClientRrc (&wndDebug, &rrc);
        FillRrc (&wndDebug, &rrc, ' ', isaWatchWindow);
        DrawWatch ();
    }
    return (0);
}


DWORD FAR
EditFilterWndProc (pwnd, msg, wParam, lParam)
PWND pwnd;
WORD msg, wParam;
DWORD lParam;
{
    switch (msg) {
        case WM_LBUTTONDOWN:
            WndActivate (pwnd);
            break;
    }

    return ((pwnd->fEnabled) ? EditWndProc (pwnd, msg, wParam, lParam) : 0L);
}


/*******************************************************************
* void NEAR DoStatusMsg ()
*
* Purpose:
*    Added with revision [10].
*
*    Called when to display the proper status line message.
*
*    if !FV_NEWHELP, there is only one status line message, so we
*    just do StatusLineMsg(0) to display the default.
*
* Entry:
*    pwnd = current window
*
* Exit:
*    None
*
*******************************************************************/
VOID NEAR DoStatusMsg (pwnd)
PWND pwnd;
{
    ushort StatusMsg;

    if (pwnd == &wndHelp)     // determine the proper message
        if (cmdSwitches & CMD_SW_QHELP)
            StatusMsg = MSG_StatusQHhelp;
        else if (cmdSwitches & CMD_SW_ED)   //[74]
            StatusMsg = MSG_StatusQHelp;        //[74]
        else                                    //[74]
            StatusMsg = MSG_StatusHelp;
    else if (pwnd == &wndCmd) {
        DbAssert(!(cmdSwitches & CMD_SW_ED));
        StatusMsg = MSG_StatusImmediate;
    }
    else if (fCanContUI()) {
        DbAssert(!(cmdSwitches & CMD_SW_ED));
        StatusMsg = MSG_StatusRunning;
    }
    else
        if (cmdSwitches & CMD_SW_QHELP)
            StatusMsg = MSG_StatusQHStart;
        else if (cmdSwitches & CMD_SW_ED)   //[74]
            StatusMsg = MSG_StatusQEdit;        //[74]
        else                                    //[74]
            StatusMsg = MSG_StatusEdit;

    StatusLineMsg (StatusMsg);      // display the right status line
}

/***
*DoCaption (msg, ax, ay) - Handle mouse messages for caption bar
*Purpose:
*  This function is called from MainWndProc when a mouse click or
*  movement is detected in the main window.
*
*  Depending on the message received the function may maximize or
*  minimize the window, or drag the caption bar.
*
*Entry:
*  WORD msg:   mouse message
*  AX ax:      x position of mouse
*  AY ay:      y position of mouse
*
*Exit:
*  none
*
*******************************************************************************/
void NEAR
DoCaption (msg, ax, ay)
WORD msg;
AX ax;
AY ay;
{
    PWND pwnd = NULL;
    /* [24] fMakeWinFullScreen should be FALSE until WM_LBUTTONDBLCLK
       or maximize icon is clicked */
    static bool fMakeWinFullScreen = FALSE;
    static PWND pwndTrack = NULL;

    DbAssert (pwndTop != NULL);
    // [26] Find caption message is in, leave NULL if not in caption

    for (pwnd = pwndBegin; pwnd != NULL; pwnd = pwnd->pwndSibling) {
        if (ay == pwnd->arcWindow.ayTop-1) {
            break;
        }
    }
    // [26] If we aren't in a caption or tracking, do nothing.
    if (pwnd == NULL && pwndTrack == NULL)
        return;

    switch (msg) {
        case WM_LBUTTONDBLCLK:
            /* make window full screen when button is released */
            fMakeWinFullScreen = TRUE;

        case WM_LBUTTONDOWN:
            if (!pwndTrack) {         // [61]
                SetCapture (&wndMain);
                pwndTrack = pwnd;
                WndActivate (pwnd);     // [26] Activate window
            }
            break;

        case WM_MOUSEMOVE:
            if (pwndTrack)
                DragCaption (pwndTrack, ay);
            break;

        case WM_LBUTTONUP:
            // [26] If in caption (pwnd != NULL) and the click is in
            // [26] the maximize location, or we had a double click, then
            // [26] [74] we must maximize (or minimize if already).
            if ((pwnd != NULL) && !(cmdSwitches & CMD_SW_ED) && (ax == 76 || fMakeWinFullScreen)) {
                if (pwndFull == NULL)
                    WndFullScreen (pwndTrack);
            else
                WndNoFullScreen ();
            DrawDebugScr ();
            }
            /* caption bar was dragged and released */
            else if (pwndTrack) {  // [58] May be second LBUTTONUP.
                DragCaption (pwndTrack, ay);
            }

            fMakeWinFullScreen = FALSE;
            ReleaseCapture ();
            pwndTrack = NULL;
            break;
    }
}


/*------------------------------------------------------------------
 *         Window Drawing Functions
 *----------------------------------------------------------------*/

/*******************************************************************
* void DrawDebugScr()
* Purpose:
*  Set flag so we remember to call DoDrawDebugScr before getting
*  the next event (key/mouse) from the user.
*  Tell's outer-loop to call DoDrawDebugScr().
*  eliminates redundant calls which make screen flicker needlessly.
*  caller of DrawDebugScr() need not worry if DebugScr is currently visible.
*
* DoDrawDebugScr returns non-zero if screen was updated.
*
*******************************************************************/
void NEAR DrawDebugScr ()
{
    fDrawDebugScr = TRUE;   /* remember to call DoDrawDebugScr */
}

bool NEAR DoDrawDebugScr ()
{
    bool result;
    ushort oRsSave;

    if (HelpFlags & HLP_COMPRESS) {       //[45]
        WndHelpClose ();           //[45]
        HelpFlags &= ~HLP_COMPRESS;         //[45]
    }                   //[45]

    if (!fDebugScr)
        return FALSE;

    oRsSave = grs.oRsCur;

    /* [3] We must resize this window here now, before we add scroll bars */
    /* [3] as window resizing will only work then */
    /* make cWatch (maybe 0) lines visible at top of screen */
    WatchInfoUI();   /* make sure cWatch is up to date */
    if (cWatch != DayPwnd (&wndDebug)) {
        WndDebugOpen ((AY) cWatch);
        DbAssert (cWatch == DayPwnd (&wndDebug));
    }

    if (rsNew != UNDEFINED) {
        /* We are either initializing, or the user has executed a NEW/LOAD
         * command, which means we need to show rsNew in a list window.
         */
        WndReset (rsNew);
        rsNew = UNDEFINED;
    }

    if (emFlags & EMF_IN_EDITMGR) {
        /* edit mgr is not reenterant.   If it is active, defer drawing
         * debug screen until edit mgr can respond to our requests.
         */
        return FALSE;
    }

    /* load mrsCur, prsCur with active window's info */
    UiRsActivateWnd ();
    if (
        (pwndAct != &wndHelp) &&         // [61]
        (txdCur.lnCursor == UNDEFINED || pwndAct->style & UIWS_MOVECURSOR)) {
        // [42] load mrsCur, prsCur with active window's info,
        // [42] position cursor where it was last time text was visible,
        // [42] or at 0,0 if txdCur.lnCursor == UNDEFINED
            pwndAct->style &= ~UIWS_MOVECURSOR;
            MoveTxdCursor ();
    }
    if (fAdjustCursor) {   //[52]
        fAdjustCursor = FALSE;
        MoveCursorPwndCur (GetEditLine (), GetEditColumn ());
    }


    if (result = fDrawDebugScr) {
        DrawWindow (NULL);
    }
    FEnableMenuBar (TRUE); // [27]

    fDrawDebugScr = FALSE;
    UiRsActivate (oRsSave);
    return (result);
}

/*******************************************************************
* void DrawDebugScrFar()
* Purpose:
*  Same as DrawDebugScr, above, but far rather than near.
*
*******************************************************************/
void FAR DrawDebugScrFar ()
{
    DrawDebugScr();
}

void FAR DoDrawDebugScrFar ()
{
    DoDrawDebugScr();
}

void FAR ScreenRedraw ()   // [56]
{
    extern BYTE emFlags;      // [70]

    if (emFlags && fWndSplit) {  // [70]
        DrawDebugScr ();     // [70]
    }             // [70]
    else {           // [70]
        fDrawDebugScr = FALSE;
        EditMgrFlush1 ();    // [65]
        DrawWindow (&wndMain);
        DrawWindow (&wndStatus);   // [67]
    }
}

static AY ayPutCh;
static AX axPutCh;
/*******************************************************************
* void PutChSetup(ax, ay)
* Purpose:
*  Cause the next call to PutCh() to output its char in the specified
*  column and line of the specified window.
*  This is just a code-size optimization for replacing lots of calls to
*     CharOut (&wndMain, rx, ry, ch, di)
*
*******************************************************************/
void NEAR PutChSetup(ax, ay)
AX ax;
AY ay;
{
    axPutCh = ax;
    ayPutCh = ay;
}

ISA isaOutline;

/*******************************************************************
* void PutCh (ch)
* Purpose:
*  Output the specified char to the window and location indicated by
*  the last call to PutChSetup.  Advance the current column afterward.
*  This is just a code-size optimization for replacing lots of calls to
*     CharOut (&wndMain, rx, ry, ch, di)
*
*******************************************************************/
void NEAR PutCh (ch)
char ch;
{
    CharOut (NULL, axPutCh++, ayPutCh, ch, isaOutline);
} /* PutCh */

/*******************************************************************
* void PutCbPb(cb, pb)
* Purpose:
*  Output the specified string to the window and location indicated by
*  the last call to PutChSetup.  Advance the current column afterward.
*
*******************************************************************/
void NEAR PutChCbPb (cch, pch)
WORD cch;
char *pch;
{
    TextOut (NULL, axPutCh, ayPutCh, pch, cch, isaOutline);
    axPutCh += (AX) cch;
} /* PutChCbPb */

/*******************************************************************
* void DrawPwndOutline(pwnd)
* Purpose:
*  Draw a particular window's caption (title) bar, left & right borders.
*
*******************************************************************/
STATICF(void) DrawPwndOutline(pwnd)
PWND pwnd;
{
    REG1 ushort cChLeft;
    ushort cChRight, cbName;
    AX ay, ayBottom;
    boolean fTopWnd = (pwnd == pwndBegin);
    struct ef *pef = (struct ef *) pwnd->pefExtra; // [60]

    if (pwnd == NULL)
        return;

    isaOutline = (ISA) pef->attrCur;      // [18]
    /* prepare to draw title line 1 line above top of window */
    PutChSetup (0, pwnd->arcClipping.ayTop - 1);

    /* copy name of register set to bufStdMsg */
    if (pef->hBuffer == hbufHelp)   /* [7] */
        cbName = (ushort)SendHelpMsg(WM_HELPTITLE,(ushort)(axMac - 12)); //[59]
    else
        cbName = GetRsName (pef->hBuffer, RSN_fFullName, axMac - 12);

    /* center the title */
    cChLeft = (axMac - cbName - 5);

    /* If odd number of extra bytes, extra goes to right of title bar */
    cChRight = (cChLeft + 1) >> 1;
    cChLeft = cChLeft >> 1;

    PutCh (fTopWnd ? chTopLeftCorner1 : chMiddleLeft1);
    while (cChLeft-- > 0)
        PutCh (chTopSide1);

    if (pwnd == pwndAct)
        /* highlight active window by showing its title in reverse video */
        isaOutline = SetInverseIsa (isaOutline);  // [18]

    PutCh(' ');
    PutChCbPb(cbName, bufStdMsg);   /* print window's title */
    PutCh(' ');

    if (pwnd == pwndAct)
        isaOutline = (ISA) pef->attrCur; // [18]

    cChLeft = cChRight - 2;
    if (pwnd == &wndCmd || (cmdSwitches & CMD_SW_ED)) { //[74]
        cChLeft += 4;
        while (--cChLeft > 0)
            PutCh(chTopSide1);
    }
    else {
        while (--cChLeft > 0)
            PutCh(chTopSide1);
        /* Draw MAXIMIZE/RESTORE Icon */
        PutCh(chMiddleRight1);
        isaOutline = SetInverseIsa (isaOutline);  // [18]

        PutCh ((pwnd == pwndFull) ?
               chUpDownArrow /* RESTORE Icon */ :
               chUpArrow /* MAXIMIZE Icon */);
        isaOutline = (ISA) pef->attrCur; // [18]
        PutCh(chMiddleLeft1);
        PutCh(chTopSide1);
    }

    PutCh (fTopWnd ? chTopRightCorner1 : chMiddleRight1);

    /* draw this window's vertical border (left & right )*/
    ayBottom = pwnd->arcClipping.ayBottom;
    if (pef->pwndScrollH)
        ayBottom++;
    for (ay = pwnd->arcClipping.ayTop; ay < ayBottom; ay++) {
        CharOut (NULL, 0, ay, chLeftSide1, isaOutline);
        if (!pef->pwndScrollV || ay == ayBottom-1)
            CharOut (NULL, axMac-1, ay, chRightSide1, isaOutline);
    }
}

/*******************************************************************
* void DrawCaptions() {
* Purpose:
*  Draw all window caption bars.  This gets called when wndMain
*  receives a WM_PAINT message.
*
*******************************************************************/
void NEAR DrawCaptions()
{
    REG1 PWND pwnd;

    if (pwndFull != NULL)
        DrawPwndOutline (pwndFull);
    else

        for (pwnd = pwndBegin; pwnd != NULL; pwnd = pwnd->pwndSibling)
            DrawPwndOutline (pwnd);
}

/**************************************************************************
* GetEditWord()
* Purpose:
*   Gets the word that the cursor in the current edit window.  NOTE: if
*   the current window is not active (i.e. it is 0 lines in size) then
*   EditFilterWndProc will return FALSE, but noone will have put the
*   zero terminator in the buffer.  We will do that here.
*
* Entry:
*  None.
*
* Exit:
*  return number of characters in the word.
*
**************************************************************************/
ushort NEAR GetEditWord(szWord, cbMax)
char *szWord;
ushort cbMax;
{
    *szWord = '\0';                 //[76]
    return  ((WORD) SendMessage (pwndAct, EM_GETWORD, cbMax,
                                 (DWORD) (char far *) szWord));
}

BOOL fCapLock = FALSE, fNumLock = FALSE;

#define  TOGGLES_START  62    /* extra room for "| " */

#define  BUF_LEN     (80-TOGGLES_START)
#define  BUF_COL     (BUF_LEN - 4)
#define  BUF_LINE (BUF_LEN - 10)
#define  BUF_NUMLOCK (BUF_LEN - 12)
#define  BUF_CAPSLOCK   (BUF_LEN - 13)
#define  BUF_WORDSTAR   (BUF_LEN - 16)
#define  BUF_VERTBAR (BUF_LEN - 18)

/**************************************************************************
* DrawTogglesLnCol
* Purpose:
*  Draw the "toggles" (caps lock, num lock, etc.) and current line
*  and column on the right-most portion of the status line if there is
*  enough room.  Re-written with revision [10].
* Entry:
*  ln = line # to display
*  col = column # to display
* Exit:
*  None
*
**************************************************************************/

void NEAR DrawTogglesLnCol (ln, col)
ushort ln;
ushort col;
{
    char buffer[BUF_LEN];
    char editState;
    register ushort i;
    register char *pch;

    if (fDebugScr &&       //[15] only if enough room
      ((cbStatusMsg <= TOGGLES_START)
      || iMsgStatusLine == MSG_StatusHelp
      )) {
        memset(buffer, ' ', BUF_LEN);

        buffer[BUF_VERTBAR] = 0xb3;      //[14] put in "|" separator
        /* set WordStar Ctrl+Q and Ctrl+K indicators */
        if ((editState = GetEditMgrState()) != 0) {
            buffer[BUF_WORDSTAR] = '^';
            buffer[BUF_WORDSTAR+1] = editState + 0x40;
        }

        /* Set Caps-Lock and Num-Lock indicators */
        if (fCapLock)
            buffer[BUF_CAPSLOCK] = 'C';
        if (fNumLock)
            buffer[BUF_NUMLOCK] = 'N';

        if (iMsgStatusLine == MSG_StatusHelp) {      //[20] write buffer NOW
            TextOut (&wndStatus, (RX) 72, (RY) 0, buffer, 7, //[20]
            DiMake (dmNormal, isaStatusLine));    //[20] normal color
            return;             //[20] and quit
        }                 //[20]
        /*
         * internally the line and column are zero based,
         * but we want to display them as one based, so bump them up.
         */
        ln++;
        col++;

        pch = &buffer[BUF_LINE+4];              /* stuff in line */
        i = 5;
        while (i--) {
            *pch-- = (char) ('0' + (ln % 10));
            ln /= 10;
        }

        buffer[BUF_COL-1] = ':';   /* separate with a colon */

        pch = &buffer[BUF_COL+2];  /* stuff in column */
        i = 3;
        while (i--) {
            *pch-- = (char) ('0' + (col % 10));
            col /= 10;
        }

// [21] Use isaStatusLock for lock status text
        TextOut (&wndStatus, (RX) TOGGLES_START, (RY) 0,
                 &buffer[0], BUF_LINE, isaStatusLock);
        TextOut (&wndStatus, (RX) TOGGLES_START + BUF_LINE, (RY) 0,
                 &buffer[BUF_LINE], BUF_LEN, isaStatusLine);
    }
}

/**************************************************************************
* DrawToggles
* Purpose:
*  Called by TWIN whenever the CAPS-LOCK or NUM-LOCK key is pressed.
*  Status line is updated to re-draw indicators.
*
**************************************************************************/
void COW DrawToggles ()
{
    DrawTogglesLnCol (GetEditLine (), GetEditColumn ());
}

/*******************************************************************
* void DrawStatusLine
* Purpose:
*  Update the status line at the bottom of the window, if the
*  status line is enabled.  Called by DoDrawDebugScr and EnsShowDebugScr.
*

 Main: <filename>     Context: Program not running              ^Q CN nnnnn:nnn

*  Column - length - content
*       0 -      1 - blank
*       1 -      6 - "Main: "
*       7 -     15 - <main module's name>
*      22 -      9 - "Context: "
*      31 -     32 - <active context's name> or "Program not running"
*      63 -      1 - blank
*
*      The following are drawn by DrawToggles
*      64 -      2 - ^Q or ^K for WordStar 2 letter sequences
*      66 -  1 - blank
*      67 -      2 - toggles (C and N for CapsLock and NumLock)
*      69 -  1 - blank
*
*      70 -  9 - line:column
*      79 -  1 - blank
*
* Exit:
*  grs.oRsCur is preserved
*
*******************************************************************/
void NEAR DrawStatusLine()
{
register char *pBuf;                // [10]
    char buffer[80];
    ushort oRsSave;


    if (fDebugScr) {
        oRsSave = grs.oRsCur;


        DbAssert (iMsgStatusLine != 0);

        pBuf = buffer;
        *pBuf++ = ' ';          // leave 1 space at start

        if (iMsgStatusLine >= MSG_HelpFileNew) {     //[12]
            if (iMsgStatusLine <= MSG_StatusDialog) {      //[12]
                // prefix message with "F1=Help   "    //[12]
                pBuf = AppendBuf(pBuf, MSG_StatusF1Help); //[12]
                if (iMsgStatusLine < MSG_StatusMenu)   //[14] menu item descr
                    *(pBuf-2) = 0xb3;       //[14] put in "|"
            } else if (iMsgStatusLine <= MSG_StatusHelp)   //[12]
            // prefix message with "<Shift+F1=Help> " //[19]
            pBuf = AppendBuf(pBuf, MSG_StatusShiftF1);   //[19]
        }                    //[12]

        pBuf = AppendBuf(pBuf, iMsgStatusLine);

        cbStatusMsg = pBuf-buffer;
        DbAssert (cbStatusMsg <= 80)     // verify msg not too long
        memset( pBuf, ' ', 80-cbStatusMsg );   // fill rest with spaces


        cbStatusMsg = (cbStatusMsg > TOGGLES_START) ? 80 : TOGGLES_START;

        TextOut (&wndStatus, (RX) 0, (RY) 0, buffer, cbStatusMsg,
                 DiMake (dmNormal, isaStatusLineVal));

        if (hStatusButtonCur != NULL) {
            RX obStart = (RX) ObStatusButton(hStatusButtonCur);

            TextOut(
                    &wndStatus,
                    obStart, (RY) 0,
                    buffer + obStart,
                    CbStatusButton(hStatusButtonCur),
                    DiMake(dmNormal, SetInverseIsa(isaStatusLineVal))
                   );

        }
        DrawToggles ();

        UiRsActivate(oRsSave);
    }
}

/**************************************************************************
* AppendBuf(buffer, iMsg)
* Purpose:
*  Append a message to a a buffer.  Added with revision [10] to save code.
*
* Entry:
*  iMsg = a standard message number (MSG_xxx) from qbimsgs.h
*
* Exit:
*  Returns number of bytes in the message
*
**************************************************************************/
uchar * NEAR AppendBuf(buffer, iMsg)
uchar *buffer;
WORD iMsg;
{
    WORD cbMsg;

    fmemcpy ((char far *)buffer, (char far *)bufStdMsg, (cbMsg = ListStdMsg (iMsg)));  //[51]
    return (buffer+cbMsg);
}

/**************************************************************************
* StatusLineMsg(iMsg)
* Purpose:
*  Display a message on the status line for a menu item on the status line.
*  The message will remain there until the next call to DrawToggles,
*  StatusLineMsg, or DrawStatusLine.
*
* Entry:
*  iMenu = a standard message number (MSG_xxx) from qbimsgs.h, or
*     -MSG_xxx if message is to be shown in intense video,
* Exit:
*  grs.oRsCur is preserved
*
**************************************************************************/
void NEAR StatusLineMsg(iMsg)
short iMsg;
{
    boolean fHighlight = TRUE;   //[73] default= hilited for LQB

    if (fSignonDisplayed) {   //[64] if not the first time

        if ((iMsgStatusLine = iMsg) < 0) {
            iMsgStatusLine = -iMsgStatusLine;
            fHighlight = !fHighlight;    //[14] switch isa's
        }
        isaStatusLineVal = (ISA) (fHighlight ? isaStatusAlert : isaStatusLine); //[14]
    } else        //[64] first call to StatusLineMsg should
        fSignonDisplayed++;  //[64] not change iMsgStatusLine, so Signon
            //[64] message stays visible

    hStatusButtonCur = 0;  //[47]
    DrawStatusLine();
}

void FAR StatusMsgFar(iMsg)
short iMsg;
{
    StatusLineMsg(iMsg);
}

/**************************************************************************
* UpdStatusLn(ln)
* Purpose:
*  Displays a number in the line number field of the status line
*  to indicate progress during ASCII Load, Search, Scan.
*  Since this can be called by scanner, when text tables are in
*  an indeterminate scan state, we don't want to do anything in this
*  function that could cause us to look at pcode (like LnOfOtx, OtxOfLn,
*  DoDrawDebugScr, ListLine, etc.)
*
* Entry:
*  fDebugScr - TRUE if debug screen is visible
*  ln - line numbers to display
*
**************************************************************************/
void FAR UpdStatusLn (ln)
ushort ln;
{
    if (fDebugScr)
        DrawTogglesLnCol (ln, 0);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbfrn\strings\intl.inc ===
CCHUNTITLED 		EQU 8  ; length of "Untitled" file name string
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbdut\strings\uinhelp.asm ===
TITLE   uinhelp.asm - utilities for new help engine.
;***
;uinhelp.asm
;
;       Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;       Utilities for the new help system.
;
;
;*******************************************************************************

	.xlist
	include version.inc
	.list
	UINHELP_ASM = ON


	include cw/version.inc
	include cw/windows.inc
	include cw/edityp.inc

	IncludeOnce architec
	IncludeOnce heap
	Include     help.inc
	IncludeOnce parser
	IncludeOnce prstab
	IncludeOnce rtps
	IncludeOnce qbimsgs
	IncludeOnce ui
	IncludeOnce uiint
	IncludeOnce uimenu              
	IncludeOnce uinhelp             

assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

	subttl  DATA segment definitions.
	page

sBegin  DATA
	externW iMsgStatusLine          ; current status line message
	externW iHelpId                 

; GetHelpMessage and MapLineToContext return codes

	globalB fHelpAlloc,0            ; Non-zero if help system is doing
					; a far heap allocation
	BdlTemp BDL     <>              ; temporary BDL owner
	externB bdlHelp                 ; BDL for keyword help (def in UIHELP.C)
	externW szDialogHelpContext     ; *sz context of current dialog help


	externB b$Buf1                  ; FILNAML-sized buffer
	externB b$Buf2                  ; 16-byte buffer
	HtSpot  EQU     b$Buf2          ; Static HotSpot structure

	globalB HelpFlags,0,1           ;status of the help system
	globalB HelpFlags2,0,1          ;more help system state


;BUFFERING:
;
;   The Help system uses a circular buffer of buffers to hold the
;   text of help messages (called contexts) so that scrolling up
;   and down in a file does not have to be continuously hitting the
;   disk.  The buffers are organized as follows:
;
;       HelpBuffer  : Slot 1 : Slot 2 : Slot 3 : ... : Slot MAX_HELPBUFS :
;
;   Each active slot in the Static HelpBuffer is of type HelpBufType.  The
;   entries in HelpBuffer are organized as a circular list so that they
;   may grow on either end without moving the existing entries.  Each
;   active entry in HelpBuffer represents one context that is currently
;   stored in memory.
;

	staticW oFirstBuf,,1            ;Offset of first logical buffer
	staticW oLastBuf,,1             ;Offset of last logical buffer
	staticB numBuf,0,1              ;number of active buffers in HelpBuffer
	staticB fNoDelBufs,0,1          ; are we allowed to delete the
					; buffers during a ShrinkHelp?


	MAX_HELPBUFS    = 9             ; Number of entries in HelpBuffer
	BUFSIZE         = SIZE HelpBufType;The size of the entries in HelpBuffer

	BUFFERSIZE      = MAX_HELPBUFS * BUFSIZE ; Size of HelpBuffer
	staticB HelpBuffer,0,BUFFERSIZE
	BUFFEREND       EQU (OFFSET DGROUP:HelpBuffer) + (BUFFERSIZE)

	DbPub   HelpBuffer

	globalW iCurRequestLine,UNDEFINED,1 ; line # to get attributes for,
					; or UNDEFINED if no attributes
					; available
	globalW oCurTopic,0,1           ; offset to the current topic
					; (0 if no current topic)

	globalW iFileSize,0,1           ; Size of current help topic
	externW iStaticHelpTopic        ; High word of NC during searches

	externW WndHelp                 ; Help Window structure
	externW efHelp                  ; Editmgr structure for Help Wnd.

;QUEUE MANAGEMENT
;
;  In order to support help history (Ctrl-F1), we keep a LIFO queue
;  of the last 20 items that we requested help on.  The items are stored
;  as a circular list, with a pointer to the next item to be filled in
;  and a count of the number of items that exist.
;
;
;  This list (of type HelpHistEntry) is contained in a BDL, with the first
;  few bytes of the BDL containg a header (type HelpHistHeader) of useful
;  information
;

	BdlHelpHist BDL <>              ; BDL for help backup (^F1) list

	ncInitial DD 0                  

	HelpHistEntry STRUC
	    HH_HiWord   DW ?
	    HH_LoWord   DW ?
	HelpHistEntry ENDS

	HelpHistHeader STRUC            
	    HH_Used     DW ?            ; number of history items in use
	    HH_First    DW ?            ; offset into seg of next free item
	HelpHistHeader ENDS             

	NUM_HISTORY     = 20            ; number of items that can be saved
	HELPHIST_BEGIN = Size HelpHistHeader  ; offset of first item in segment
	HELPHIST_END   = HELPHIST_BEGIN + NUM_HISTORY * SIZE HelpHistEntry
					; end of the last item

;MAGIC EDIT MANAGER Variables
;
;   The following magic locations in the edit manager are used:
;
;       EfHelp.EF_ipCur_ob     = Current column in help window
;       EfHelp.EF_ipCur_oln    = Current line in help window
;       EfHelp.EF_pdCur_olnTop = Top line of help window
;       EfHelp.EF_pdCur_obleft = Leftmost column of help window
;
;       WndHelp.arcClipping.ayBottomArc, WndHelp.arcClipping.ayTopArc
;               specify the top and bottom of the window.  I believe
;               that they are in screen coordinates.
;
;       One thing to note:  The Edit Manager uses 0 relative coordinates
;       while the helpengine (and variable help) use 1 relative coordinates.
;       Thus, you have to be careful in converting from one to another.
;
;       There are only 2 places that a line or column number is stored:
;         - Bookmarks (0 relative, as the HelpEngine is not involved)
;         - iCurRequestLine (1 relative, because it is a HelpEngine line#)
;


;HELP System ENTRY/EXIT conditions
;
;  Anytime that code for the help system is executing, we must have the
;  following conditions met:
;
;       1.)  As close as possible to the point where we could display a
;            dialog box or message box receiveing ANY input from the user
;            we must have HLP_INHELP set to prevent recursively entering the
;            help system.  Currently, this occurs in 2 places:
;               - Displaying "Help File Not Found"
;               - Displaying "INsufficient memory for help system"
;
;       2.)  The help system must be active to the level that is needed to
;            implement the desired functionality.  There are three levels:
;
;            a.) Help Engine shut down - No functionality at all possible.
;
;            b.) Help Engine Active, no current topic.
;                 HLP_GOTBUF is true, but oCurTopic = 0.
;
;            c.) Help Engine Active, Current topic available.
;
;
;            The following assumptions and conditions are used in checking
;            entry conditions:
;
;            - If the help window is open, we must be at level C.
;            - If the help window is closed, we may be at A or B.
;            - If we get a message from the help window, it must be open (C).
;            - If StartHelp returns 0, you are in either B or C.
;
;       3.)  Any allocation could end up causing CompressHelp to be called.
;            Thus, there has to be flag set ANYTIME we are in the help system
;            so that CompressHelp will not yank the help system out from
;            underneeth itself.  Currenly, there are only 2 entry points
;            for help:
;               - Help()
;               - HelpWndProc()


sEnd    DATA

	externFP B$IFOUT                ; Convert number to string
	externFP HelpOpen               ; Misc Help engine routines
	externFP HelpNc
	externFP HelpNcCb
	externFP HelpLook
	externFP HelpDecomp
	externFP HelpXRef
	externFP HelpGetLine
	externFP HelpHlNext
	externFP HelpNcNext
	externFP HelpSzContext
	externFP HelpClose              
	externFP HelpShrink             
	externFP _atoi                  ; CONSIDE: use runtime call for this
	externFP fEditorActive          
	externFP fQhelpActive



sBegin  UI
assumes CS,UI

	staticB szHelpFileEdit,<"EDIT.HLP",0>   ; main help file name
	staticB szHelpFileQhelp,<"HELP.HLP",0>  ; qhelp help file name
	staticB szHelpFileInterp,<"QBASIC.HLP",0> ; second help file name

	externNP MoveCursorPwndCur      ; Move cursor of current window
	externNP MoveCursorPwnd         ; Move cursor of specified window
	externNP WndHelpOpen            ; Open help window to a given size
	externNP WndHelpClose           ; Close the help window
	externNP SetHelpKeyword         ; put keyword into help syntax menu

	externNP HelpBack               

	subttl  Main Help EntryPoints
	page


;***
;KeywordHelp : Display help for a keyword
;
;Purpose:
;       This routine implements SHIFT-F1.  If the cursor is on a keyword
;       in a window, then display help for this keyword in the help window
;       (opening it if needed). If there is no text selected, or it is
;       not a keyword, then return a non-zero value to indicate that F1
;       should be done.
;
;Entry:
;       None.
;
;Exit:
;       None
;
;Uses:
;       AX,BX,CX,DX
;
;****

cProc   KeywordHelp,<NEAR,PUBLIC>,<SI>  
cBegin
	cCall   StartHelp               ; make sure we have the help system
	or      ax,ax                   ; did we succeed?
	jne     KeywordHelpExit         ; no, just return

	cCall   KeywordHelpLookup       ; AX = length of current keyword
					; (text placed in bufStdMsg)
	or      ax,ax                   ; is there a current keyword?
	jne     CurKeyword              ; brif so
Moo:
	cCall   CowMoo                  ; -- beep speaker & return
	jmp     short KeywordHelpExit   
CurKeyword:

	DbChk   HoldBuf1                ; grab B$Buf1

	mov     ax,offset dgroup:bufStdMsg ; where the topic was placed
	mov     bx,offset dgroup:B$Buf1 ; new home for the topic string
	push    bx                      ; param to DisplayHlpWndSz

	cCall   fstrcpy2,<DS,bx,DS,ax>  


	cCall   DisplayHlpWndSz         ; try to display the help

	DbChk   FreeBuf1                ; release the buffer

	or      al,al                   ; Did we succeed with engine hlp
	je      KeywordHelpExit_Ok      ; yes, exit.

	test    al,HELP_HANDLED         ; have we displayed anything to
					; the user?
	jnz     KeywordHelpExit         ; yes, just exit
	jmp     short Moo               ; otherwise tell user about it

KeywordHelpExit_Ok:
	mov     [uierr],0               ; clear any leftover errors
KeywordHelpExit:
cEnd

;***
;KeywordHelpLookup : Find help for a keyword
;
;Purpose:
;       Added with revision [5].
;
;       Looks up the keyword, enables/disables the HelpSyntax menu item, and
;       puts the keyword into the HelpSyntax menu item.
;
;Entry:
;       None.
;
;Exit:
;       AX : =0 if no keyword was found
;           length of keyword (NZ) if keyword was found
;Uses:
;       AX,BX,CX,DX
;
;****

cProc   KeywordHelpLookup,<NEAR,PUBLIC>
cBegin

	mov     ax,offset dgroup:bufStdMsg
	mov     bx,10                   ; maximum length of word  (10 is magic)
	mov     cx,GEW_HELPMASK         ; do not include . or ! in search
	cCall   GetEditWordMask,<ax,bx,cx> ; AX = length of word retrieved
	push    ax                      ; save for return value

	; enable/disable help syntax menu item based on AX (0 ==> disable)
	or      ax,ax                   ; if NZ, set low bit for stupid-ass
	jz      disableit               ; COW C function
	mov     al,1
disableit:
	mov     bx,midHelpSyntax
	cCall   EnableMenuItem,<bx,ax>

	; copy current topic name into help syntax menu buffer
	mov     ax,offset dgroup:bufStdMsg
	cCall   SetHelpKeyword,<ax>

	pop     ax                      ; return AX = length of keyword
cEnd



;***
;SelectHotLink - Go to the hot link that is specified in the window coords
;
;Purpose:
;       Look in the help file given by the line number and column
;       number.  If there is a hot link at this position, go to the item
;       that it links to.  Otherwise, just returns.
;
;Entry:
;       (rx,ry) - virtual line coordinates of the location of a
;                 supposive hot spot.
;       beep    - TRUE if we are suspose to beep when we don't find anything
;
;Exit:
;       AX = 0 (FALSE) if a hot link was selected
;
;Uses:
;       Per Convention
;****

cProc   SelectHotLink,<PUBLIC,NEAR>,<SI,DI>
parmW   rx
parmW   ry
parmB   GiveBeep
cBegin

	;Since we got a keyboard message from the help window, it must be
	;open, therefor we must be initialized.

	DbAssertTst HelpFlags,ne,HLP_GOTBUF,UI,<SelectHotLink:Buffers Not Initialized>


	DbChk   HoldBuf2                ; lock down the HotSpot
	DbChk   HoldBuf1                ; for composed hotlink names

	mov     bx,oCurTopic            ; get ptr to topic
	lea     bx,[bx].bdlHelpText.BDL_seg ; BX = handle to data seg
	mov     cx,rx
	inc     cx                      ; make column 1 relative
	mov     HtSpot.colHS,cx         
	mov     cx,ry                   ; get line number
	inc     cx                      ; make it 1 relative
	mov     HtSpot.lineHS,cx        ; and stick in HotSpot structure
	mov     ax,OFFSET DGROUP:HtSpot
	xor     cx,cx
	and     HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM) ; clear errors
	cCall   HelpXRef,<BX,CX,DS,AX>  ;Get context string for topic
	or      ax,ax                   ; did we get a topic
	jnz     GotSelection            ; yes, go display it
	test    HelpFlags,HLP_FAILFNF OR HLP_FAILOOM ; is error handled?
	jnz     NoBeep                  ; yes, do not beep
SelectHotLink_Beep:
	cmp     GiveBeep,0              ; should we give a beep?
	je      NoBeep                  ; no, just exit with error code
	cCall   CowMoo                  ; beep cow's speaker
NoBeep:
	mov     ax,sp                   ; return with non-zero value
	DbChk   FreeBuf2                ; release the HotSpot
	DbChk   FreeBuf1                ;  and our other buffer
	jmp     short NoSelection       ; and exit

GotSelection:
	;Copy context string into free part of Buf2 and display it in a help
	;window. The source string is in HtSpot.pXrefHS and is 0 terminated
	;We can not use the source directly, as it points into a BDL, and
	;we are not guarenteing a locked heap.

	push    ds                              ; set ES = DS = DGROUP
	pop     es                              
	mov     di,offset dgroup:b$buf1         ; ES:DI = destination
	push    di                              ; parm for DislplayHlpWnd
	lds     si,DWord Ptr HtSpot.pXrefHS     ; DS:SI = source

CopyLoop:
	lodsb                                   ; copy the byte
	stosb                                   
	or      al,al                           ; is it the 0 termiantor
	jne     CopyLoop                        ; no, do next byte
	lodsw                                   ; Copy next word
	stosw                                   ; incase it was local

	push    es                              ; restore DGROUP
	pop     ds                              

	DbChk   FreeBuf2                        ; release the HotSpot

	; Check to see if the context is !B.  If it is, then we should
	; execute a HelpBack command instead of displaying the context

	cmp     WORD PTR b$Buf1,'B!'            ; is it !B?
	jne     NotHelpBack                     ; no, go display it
	cmp     BYTE PTR b$Buf1+2,0             ; is it 0 terminated?
	jne     NotHelpBack                     ; no, go display it
DbAssertRel     pwndAct,e,<OFFSET DGROUP:wndHelp>,UI,<SelectHotLink:Not in help window>
	pop     ax                              ; restore stack (param to
						;  DisplayHlpwndSz not used)
	xor     ax,ax                           ; move to (0,0) so we will
	cCall   MoveCursorPwndCur,<ax,ax>       ; goto previous topic
	DbChk   FreeBuf1                        ; incase HelpBack wants it
	call    HelpBack                        ; do the help back
	jmp     short ExitSuccess               ; and exit

NotHelpBack:
	cCall   DisplayHlpWndSz                 ; display text
DbAssertRelB    al,ne,HELP_NF,UI,<SelectHotLink:Returned hot link not found>
						;ignore any errors
	DbChk   FreeBuf1                        ; release context string

ExitSuccess:
	xor     ax,ax                           ; return value of success
						; this way we will not put
						; up an error box, then
						; do something useful.
NoSelection:

cEnd



;Rewrote with [5]
;***
;FillContextNext - Fill the next buffer with the desired context information
;
;Purpose:
;       Read a help context into the help buffer given the position that
;       is previous to it.  The information needed for the new context
;       is obtained from the context given.  This routine will read in
;       as many contexts as desired.
;
;       Note: this routine does not return any errors, as its caller
;       does not check the error code (this is used to fill the buffer
;       with topics after the current topic, so if we could not read
;       in a topic for any reason, then we will just leave the buffer
;       partially empty).
;
;Entry:
;       BX = current buffer
;       DI = number of context to read
;
;Exit:
;       oLastBuf = Last valid buffer
;       numBuf updated
;
;****

cProc   FillContextNext,<NEAR>,<DI>
cBegin

DbAssertRelB    fNoDelBufs,ne,0,UI,<FillContextNext:Caller did not set fNoDelBufs>


cEnd


;Added with [5]
;***
;GetHelpMsgNcFill - get a help message from a context number, fill in fields
;
;Purpose:
;       Calls GetHelpMsgNc, and fills in all the fields of the buffer except
;       for the first line number of the context.
;
;Entry:
;       DX:AX = context number to be filled in
;       BX = ptr to context
;Exit:
;       if (AL = 0)
;           BX = ptr to context
;           all fields of context are filled in
;       else
;           AL = HELP_HANDLED.
;
;****
cProc   GetHelpMsgNcFill,<NEAR>
cBegin
	push    bx                              ; We need to preserve BX
	mov     Word Ptr [bx].ContextNum,ax     ; save Context Num in Buffer
	mov     Word Ptr [bx].ContextNum+2,dx
	lea     cx,[bx].bdlHelpText             ; point to BLD
	cCall   GetHelpMsgNc,<dx,ax,cx>         ; get message
						; (AL = return code)
	pop     bx                              ; BX = *Buffer

Fill_Exit:
cEnd

;***
;GetHelpMsgSz - get a help message from a context string
;GetHelpMsgNc - get a help message from a context number
;
;Purpose:
;       This routine calls the help engine to obtain the help text
;       associated with a context string.  The text is returned in a BDL.
;       No buffering of the help context is performed.
;
;       NOTE: Does not require oFirstBuf or oLastBuf to be set.
;
;Entry:
;       szContext : pointer to context string
;       BdlText : pointer to bdl owner structure.
;
;Exit:
;       AL = HELP_OK (0) if success.
;       AL = HELP_HANDLED, HELP_NF
;
;Uses:
;       Per convention
;
;Exceptions:
;       
;****
cProc   GetHelpMsgSz,<NEAR,PUBLIC>
parmW   szContext
parmW   BdlText
cBegin
DbAssertTst     HelpFlags,ne,HLP_GOTBUF,UI,<GetHelpMsgSz:HLP_GOTBUF false>
	mov     ax,szContext            ; AX = context string
	cCall   CalcNc,<AX>             ; DX:AX = nc for context string
	jcxz    GetHelpMsgSzExit        ; return with error code (AL) if error

	cCall   GetHelpMsgNc,<DX,AX,BdlText> ; get message
GetHelpMsgSzExit:
cEnd

DbPub   GetHelpMsgNc
cProc   GetHelpMsgNc,<NEAR>,<SI,DI>
parmW   ncHigh
parmW   ncLow
parmW   BdlText
cBegin
DbAssertTst     HelpFlags,ne,HLP_GOTBUF,UI,<GetHelpMsgNc:HLP_GOTBUF false>
DbAssertRelB    fHelpAlloc,ne,0,UI,<GetHelpMsgNc:fHelpAlloc not set>

	mov     di,ncHigh               ;set DI:SI to context string
	mov     si,ncLow

	and     HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM) ; clear flags

	cCall   HelpNcCb,<DI,SI>        ; AX = #bytes for decompressed topic

	xchg    ax,cx                                   ; save size in CX
	test    HelpFlags,HLP_FAILFNF OR HLP_FAILOOM    ; did we fail it?
	mov     al,HELP_HANDLED                         ; assume so
	jnz     GetHelpMsgNcExit_Near                   ; exit if error

	mov     bx,offset DGROUP:BdlTemp
	cCall   BdlAlloc,<BX,CX>        ; alloc bdl for compressed data
	or      ax,ax                   ; OOM error?
	jz      GetHelpMsgOOM           ; yes, go handle it

	lea     bx,[BdlTemp.BDL_seg]    ; BX = handle to data segment
	xor     ax,ax                   ; offset 0
	cCall   HelpLook,<DI,SI,BX,AX>  ; AX = # bytes uncompressed
	xchg    cx,ax                   ; CX = # bytes uncompressed
	jcxz    FreeExitError           ; brif error -- release bdl & exit

	inc     fNoDelBufs              ; don't delete buffers

	mov     bx,BdlText              ; bx = *BDL owner
	cCall   BdlAlloc,<BX, CX>       ; alloc BDL for uncompressed data
	or      ax,ax                   ; ZF ==> error
	jnz     DecompressHelp          ; no error, go decompress help topic
	cCall   GiveHelpOOM             ; generate OOM error
	dec     fNoDelBufs              ; restore buffer flag
	jmp     short FreeExitError     ; free Bdl and exit

GetHelpMsgOOM:
	cCall   GiveHelpOOM             ; signal an OOM error
	mov     al,HELP_HANDLED         
GetHelpMsgNcExit_Near:                  
	jmp     Short GetHelpMsgNcExit  ; brif so -- give error and exit

DecompressHelp:
DbAssertTst     HelpFlags,z,HLP_NOSHRINK,UI,<GetHelpMsgNc:NOSHRINK set>
	or      HelpFlags,HLP_NOSHRINK  ; don't shrink during HelpDecomp
					; otherwise it will fail.
	mov     bx,BdlText              ; bx = *BDL owner (could have moved)
	xor     ax,ax                   ; offset 0
	lea     dx,[BX].BDL_seg         ; DX = handle of destination seg
	lea     bx,[BdlTemp.BDL_seg]    ; BX = handle of source segment
	cCall   HelpDecomp,<BX,AX,DX,AX,DI,SI>
					; decompress help text
	dec     fNoDelBufs              ; reset buffer delete flag
	and     HelpFlags,NOT HLP_NOSHRINK ; reenable shrinking.

	or      ax,ax                   ; did we get an error?
	jz      FreeExit                ; no, free temp BDL and exit
	mov     ax,BdlText              ; get pointer to bdl
	cCall   BdlFree,<AX>            ; and deallocate it

	test    HelpFlags,HLP_FAILOOM or HLP_FAILFNF ; have we reported?
	jnz     FreeExitError           ; yes, get return code
	cCall   GiveHelpOOM             ; report the error.

FreeExitError:
	mov     al,HELP_HANDLED         ; prepare to return error

FreeExit:
	push    ax                      ; save return code
	mov     ax,OFFSET DGROUP:BdlTemp
	cCall   BdlFree,<AX>            ; release compressed data

	pop     ax                      ; AX = return code (NZ ==> success)

GetHelpMsgNcExit:

cEnd


	subttl  Display Text in the Help Window

;Rewrote with [5]
;***
;DisplayHlpWndSz - Display help in a window given a context string
;DisplayHlpWndNc - Display help in a window given a context number
;
;Purpose:
;       Displays a context in the help window given either a context
;       string (DisplayHlpWndSz) or a context number (DisplayHlpWndNc).
;       This routine will open the help window if it is not already
;       opened.
;
;Entry:
;       szContext : pointer to a context string  (DisplayHlpWndSz)
;                          or
;       DX:AX     : context number               (DisplayHlpWndNc)
;
;Exit:
;       AL = error code (HELP_OK, HELP_HANDLED, HELP_NF)
;
;Uses:
;       Per Convention
;
;****

cProc   DisplayHlpWndSz,<PUBLIC,NEAR>
parmW   szContext
cBegin

DbAssertTst     HelpFlags,ne,HLP_GOTBUF,UI,<DisplayHlpWndSz:HLP_GOTBUF false>

	mov     ax,szContext            ;AX = context string
	cCall   CalcNc,<AX>             ; DX:AX = nc for context string
	jcxz    HlpWndSzExit            ; there was an error, exit
	cCall   DisplayHlpWndNc         ;display help for this context number

HlpWndSzExit:                           ;AL = return code
cEnd


cProc   DisplayHlpWndNc,<PUBLIC,NEAR>
cBegin

DbAssertTst     HelpFlags,ne,HLP_GOTBUF,UI,<DisplayHlpWndNc:HLP_GOTBUF false>

	cCall   BufferNc                ; BX = ptr to new context
	or      al,al                   ; was there an error?
	jne     DisplayFailure          ; yes, exit with error code

	push    bx                      ; save buffer pointer
	mov     dx,Word Ptr [bx].ContextNum+2  ; Get context number into
	mov     ax,Word Ptr [bx].ContextNum    ;  DX:AX
	cCall   RecordHelpHistory       ; record context number for Ctrl-F1
	pop     bx                      ; restore buffer pointer

	lea     ax,[bx].bdlHelpText     
	push    ax                      ; save for call to GetHelpContextLen
	cCall   SizeHelpContext,<ax>    ; get # lines in the help topic
					; sets iFileSize
	cCall   GetHelpContextLen       ; AX = get suggested size of wnd
	cCall   OpenHelpWindow          ; go open the window (to size AX)
	cCall   DrawDebugScr            ; force help title to be redrawn

	xor     ax,ax                   ; return 0 for no-errors

DisplayFailure:
	cCall   CloseCurHelpFile        ; shut down current help file, if
					; any opened. (preserves AX, DX)
cEnd




;***
;BufferNc - Given a context number, properly buffer in context
;
;Purpose:
;       This routine will refill the help buffer so that Nc is
;       present.  If Nc did not exist, the buffer is flushed and
;       refilled.
;
;Entry:
;       DX:AX   : Context number to be buffered
;
;Exit:
;       if (successful)
;               AL = HELP_OK  (=0)
;               BX = new buffer ptr
;               numBuf updated
;               oCurTopic = BX
;       else
;               AL = HELP_HANDLED
;
;****
cProc   BufferNc,<PUBLIC,NEAR>,<DI>
cBegin

	;See if the context number is already buffered

	xor     cx,cx
	mov     cl,numBuf               ; scan numBuf contexts
	jcxz    DelNoBufs               ; special case this...LOOP can't
	mov     bx,oFirstBuf            ; Start at first context
CheckNext:
	cmp     ax,Word Ptr [bx].ContextNum ; check low word first
	jne     TryToLoop               ; comparison failed, goto next one
	cmp     dx,Word Ptr [bx].ContextNum+2 ; check high word
	jne     TryToLoop               ; comparison failed, goto next one
	jmp     FoundMatch              ; we have the context already buffered
TryToLoop:
	add     bx,BUFSIZE              ; move to next logical buffer
	cmp     bx,BUFFEREND            ; did we go off the end?
	jb      Wrap5                   ; no, continue
	sub     bx,BUFFERSIZE           ; adjust back to begining
Wrap5:
	loop    CheckNext               ; try the next context

NotBuffered:

	
	; # buffers to free = # needed - # free
	;                   = MAX_HELPBUFS / 2 - (MAX_HELPBUFS - numBufs)
	;                   = numBufs - (MAX_HELPBUFS / 2)
	
	mov     cl,numBuf               ; Calculate # buffers to delete
	sub     cl,MAX_HELPBUFS /2      
	ja      DelSomeBufs             ; brif a positive number
	xor     cl,cl                   ; delete 0 buffers (makes
DelSomeBufs:                            ; oCurTopic == oLastTopic)
	xor     ch,ch                   ; CBW for CX
	push    ax                      ; save the context number
	push    dx
	call    FlushBuffer             ; delete CX current contexts
	pop     dx                      ; restores context number
	pop     ax

DelNoBufs:
DbAssertRelB    numBuf,be,MAX_HELPBUFS,UI,<BufferNc: No buffers free after deleting some>

	mov     bx,oLastBuf             ; Ptr to last buffer used
	cmp     numBuf,0                ; stupid special case?
	jne     UseoLastBuf             ; no, index off of oLastBuf
	mov     oFirstBuf,bx            ; oFirstBuf = oLastBuf
	jmp     short NoWrap6           
UseoLastBuf:
	add     bx,BUFSIZE              ; point to the next one
	cmp     bx,BUFFEREND            ; did we go off the end?
	jb      NoWrap6                 
	sub     bx,BUFFERSIZE           
NoWrap6:
	cCall   GetHelpMsgNcFill        ; get the help topic
	or      al,al                   ; any errors?
	jne     BufferNc_Exit           ; yes, exit with error code

	inc     numBuf                  ; indicate one more buf in use

	;Fill the rest of the buffer with contexts after this one

	inc     fNoDelBufs              ; do not delete buffers to get these
	mov     ax,MAX_HELPBUFS
	sub     al,numBuf               ; AX = number of buffers free
	push    bx                      ; save it for exit
	xchg    di,ax                   ; set DI = number of free buffers

	mov     oLastBuf,bx             ;set oLastBuf = last legal buffer

FillAnotherNext:
	mov     dx,Word Ptr [bx].ContextNum+2 ; DX:AX = current NC
	mov     ax,Word Ptr [bx].ContextNum
	push    bx
	cCall   GetNextNc               
	pop     bx
	je      FillContextDone         ; no more contexts

	add     bx,BUFSIZE              ;Point BX at next buffer
	cmp     bx,BUFFEREND            ; did we go off end of buffer?
	jb      NoWrap3                 ;no, continue
	sub     bx,BUFFERSIZE           ;wrap around to begining
NoWrap3:
	cCall   GetHelpMsgNcFill        ;get message DX:AX into *(BX)
	or      al,al                   ; did an error occur
	jne     FillContextDone         ; yes, stop filling in buffers

	mov     oLastBuf,bx             ; set oLastBuf = last legal buffer
	inc     numBuf                  ;record that a buffer is now in uses
	dec     di                      ;one more context use
	jne     FillAnotherNext         ;get another one if allowed
FillContextDone:

	;Ignore any errors, we have at least one buffer
	mov     uierr,0                 ; clear any errors
	pop     bx                      ; pointer to buffer with our context

	dec     fNoDelBufs              ; reset buffer delete pointer

FoundMatch:
	xor     ax,ax                   ; ax = 0 (no errors)
	mov     oCurTopic,bx            ; update current buffer ptr.

BufferNc_Exit:
cEnd

;Rewrote with [45]
;***
;OpenHelpWindow - Open the help window and ready it to print text
;
;Purpose:
;       This routine will not only open the help window to the correct
;       size, but will adjust the size of the window to account
;       for the existance/non existance of the scroll bar.
;
;Entry:
;     ax = Size of window
;
;Exit:
;     None.
;****

DbPub OpenHelpWindow
cProc OpenHelpWindow,<NEAR>
cBegin
	cmp     pwndAct,OFFSET DGROUP:WndHelp ; in help window?
	je      InHelpWindow            ; no, do not resize

	inc     ax                      ; add a line for scroll bar
InHelpWindow:
	cCall   WndHelpOpen,<AX>        ; AX = actual size of window

	; We must always move the cursor to (0,0), otherwise the edit
	; manager may not realize that this is a new topic and would not
	; position it so that the first line is visible.

	xor     bx,bx                   ; cursor position is 0,0
	mov     ax,OFFSET DGROUP:wndHelp; window to receive the message
	push    ax                      ; save for second call
	cCall   MoveCursorPwnd,<AX,BX,BX> ; goto 0,0 in window

	cCall   GetInitialPos           ; get initial position on screen

	cCall   MoveCursorPwnd,<DX,AX>  ; goto hot link spot
cEnd

;***
;GetInitialPos - Calculate the initial cursor position in the help window
;
;Purpose:
;       Returns the initial cursor position in the help window.  This is
;       the (0 relative) coordinates of the first hot link (if it exists
;       and is visible), or (0,0).
;
;Entry:
;       None
;
;Exit:
;       (DX,AX) - initial Row/Column of the screen (0,0) or first hot spot
;
;Uses:
;       Per C Convention.
;****
cProc   GetInitialPos,<PUBLIC,NEAR>
cBegin
	DbChk   HoldBuf2                ; lock down the hotspot

	test    HelpFlags,HLP_VARHELP   ; are we in var help?
	jnz     Use00                   ; yes, there are no hotlinks

	mov     ax,1                    ; current row/column position
	mov     HtSpot.ColHS,ax         
	mov     HtSpot.lineHS,ax        

DbAssertRel     oCurTopic,ne,0,UI,<GetInitialPos:oCurTopic invalid>
	mov     bx,oCurTopic
	lea     bx,[bx].bdlHelpText.BDL_seg
	mov     cx,OFFSET DGROUP:HtSpot
	dec     ax                      ; ax = 0
	cCall   HelpHlNext,<AX,BX,AX,DS,CX>
	or      ax,ax                   ; did we get a hot link?
	je      Use00                   ; no, use (0,0) as position
	mov     ax,HtSpot.ColHS         ; get position of hotlink
	mov     dx,HtSpot.lineHS        
	dec     dx                      ; make position 0 relative
	dec     ax
	
	; Make sure the hot link is visible.
	
	mov     cl,WndHelp.arcClipping.ayBottomArc
	sub     cl,WndHelp.arcClipping.ayTopArc ; CX = size of help window

	cmp     cl,dl                   ; within visible range?
	jae     GetInitialPos_Exit      ; no, ignore the hotlink
Use00:
	xor     dx,dx
	xor     ax,ax

GetInitialPos_Exit:
	DbChk   FreeBuf2                ; release HotSpot
cEnd

	subttl  Edit Manager Support Routines
	page



;Extracted and modified with revision [29].
;***
;GetHelpTitleStr - Returns the title for a given help topic
;
;Purpose:
;       Calculates the title, and returns it in bufStdMsg.
;       All titles are prefixed by "HELP: ".
;
;       Uses the ":n" information if the help file, if it exists.
;       Otherwise, returns the current context string.
;
;Entry:
;       pHelpBdl = *bdl containing decompressed help topic.
;       cbMaxSize = max title length allowed
;
;       If window help, curNc is the help context #
;       If dialog box help, szDialogHelpContext points to the current szContext
;
;Exit:
;       AX = number of characters in title
;       bufStdMsg = contains title.
;
;Uses:
;       Per Convention
;
;****
cProc   GetHelpTitleStr,<NEAR,PUBLIC>,<SI,DI>
parmW   pHelpBdl
parmW   cbMaxSize
cBegin

DbAssertTst     HelpFlags,nz,HLP_GOTBUF,UI,<GetHelpTitleStr:HLP_GOTBUF false>

	inc     fNoDelBufs              ; do not delete buffers, we have
					; a generic ptr to a buffer

	; Setting fNoDelBufs is probably not needed as currently
	; pHelpBdl points to either oCurTopic or to a static
	; Bdl used by dialog help.      However, I doubt that we do any
	; allocs in this code, and I can not guarentee that pHelpBdl
	; is safe.


	mov     ax,MSG_HelpTitleQH      ; first part of title ("MS-DOS Help: ")
	test    cmdSwitches,CMD_SW_QHELP ; /QHELP viewer?
	jnz     ghts1                   ;   YES, got title

	mov     ax,MSG_HelpTitle        ; first part of title ("HELP: ")
ghts1:
	cCall   ListStdMsg,<AX>         ; put in bufStdMsg

	push    ax                      ; save length of static portion
	add     ax,OFFSET DGROUP:bufStdMsg ; ds:di = useful buffer
	xchg    di,ax
	mov     al,'n'                  ; look for ":nTITLE"
	cCall   GetHelpControlInfo,<pHelpBdl,cbMaxSize,ax> ; SI = *embedded title, if any
	or      si,si                   ; title found?
	jnz     AppendTitle             ; brif so

	mov     si,szDialogHelpContext  ; use current context string as title
					; for dialog box help
	cmp     pHelpBdl,offset DGROUP:bdlHelp  ; title for dialog box help?
	je      AppendTitle             ; brif so -- append string to title

	mov     bx,oCurTopic            ; ptr to current topic data
	or      bx,bx                   ; is it valid?
	je      GetHelpTitleStr_Fail    ; no, use MSG_HelpTitle for now

	push    ds                      ;push far address to load szContext
	push    di
	push    Word Ptr [bx].ContextNum+2 ; push context number
	push    Word Ptr [bx].ContextNum
	cCall   HelpSzContext           ;Get text
	or      ax,ax                   ; did we succeed?
	je      GetHelpTitleStr_Fail    ; no, exit with error

	;Strip off the filename at the begining of the context

	cCall   szSrchExcl,<di>         ; search for '!' in *di
	DbAssertRel ax,ne,0,UI,<GetHelpTitleStr: Illegal string from HelpSzContext>
	inc     ax                      ; point to chr beyond '!'
	xchg    si,ax                   ;di = *buffer, si = *szContext

AppendTitle:                            ; append title to bufStdMsg
					; DS:SI= *title
					; DS:DI= where to put it

	pop     bx                      ; BX = length of static portion
	push    ds                      ; ES = DS for string ops
	pop     es                      

AnotherChar:                            
	lodsb                           ; append szTitle to "HELP:" in
	stosb                           ; bufStdMsg
	inc     bx                      ; seen another char
	or      al,al                   ; more chars to do?
	jnz     AnotherChar             ; brif so
	dec     bx                      ; don't  include NULL in count

	cmp     bx,cbMaxSize            ; is it larger than we want to return
	jbe     GetHelpTitleStr_Exit    ; no, exit
	mov     bx,cbMaxSize-1          ; return maximum size (without NULL)
	mov     byte ptr [bufstdMsg+bx+1],al ; truncate the string

GetHelpTitleStr_Exit:                   
	xchg    ax,bx                   ; return count in AX

	SKIP1_PSW                       ; skip the pop ax
GetHelpTitleStr_Fail:                   
	pop     ax                      ; get length in case of error
	dec     fNoDelBufs              ; reenable buffer deletes.
	DbAssertRel ax,be,cbMaxSize,UI,<GetHelpTitleStr: title too big>
cEnd

;Added with revision [29].
;***
;GetHelpContextLen - Returns the length to use for a given help topic
;
;Purpose:
;       Returns the suggested # lines to use to display a topic.
;       Uses ":lLENGTH" if it exists. Otherwise, returns the total # lines
;       in the topic.
;
;Entry:
;       pHelpBdl = *bdl containing decompressed help topic.
;
;Exit:
;       AX = number of lines to use
;
;Uses:
;       Per Convention
;
;****
cProc   GetHelpContextLen,<NEAR,PUBLIC>,<SI,DI>
parmW   pHelpBdl
cBegin
	inc     fNoDelBufs              ; do not delete buffers, we have
					; a generic ptr to a buffer

	; Setting fNoDelBufs is probably not needed as currently
	; pHelpBdl points to either oCurTopic or to a static
	; Bdl used by dialog help.      However, I doubt that we do any
	; allocs in this code, and I can not guarentee that pHelpBdl
	; is safe.

	mov     di,OFFSET DGROUP:bufStdMsg ; ds:di = useful buffer
	mov     cx,6                    ; max len we care about
	mov     al,'l'                  ; look for ":l<LENGTH>"
	cCall   GetHelpControlInfo,<pHelpBdl,cx,ax> ; SI = *embedded len,
	or      si,si                   ; length found?
	jz      GetTotalLines           ; brif not -- get the line count

	push    si                      ; arg on stack
	call    _atoi                   ; AX = result
	pop     bx                      ; clean stack (C calling conventions)
	jmp     SHORT GetHelpContextLen_Exit

GetTotalLines:
	cCall   SizeHelpContext,<pHelpBdl> ;AX = # lines in context
					; sets iFileSize

GetHelpContextLen_Exit:
	dec     fNoDelBufs               ; reenable buffer deletes.
cEnd


;Extracted and modified with revision [29].
;***
;GetHelpControlInfo
;
;Purpose:
;       Returns the control information in a given help context, if any.
;
;Entry:
;       pHelpBdl = * bdl containing decompressed help topic
;       cbMaxSize = biggest line to get.
;       cChar = control char to look for (usually 'n' or 'l').
;
;       DS:DI = * place to put result
;
;Exit:
;       DS:SI = * embedded help control info
;
;Uses:
;       Per convention, plus SI
;****

cProc   GetHelpControlInfo,<NEAR>
parmW   pHelpBdl                ; * bdl of current help context
parmW   cbMaxSize               ; biggest string allowed
parmW   cChar                   ; control char to search for (l or n)
cBegin

DbAssertRelB    fNoDelBufs,ne,0,UI,<GetHelpControlInfo:fNoDelBufs not set>

	; This routine does not have to worry about error handling for
	; HelpGetLine.  If there is any error in trying to get the
	; proper line, we will just assume that there were no more
	; lines.

	mov     bx,pHelpBdl     ; BX = *bdl of current help topic

	GETSEG  es,[bx].BDL_seg,bx,SIZE ; ES = context data segment
	mov     ax,-1                   ; AX = undefined for blasting help
	mov     es:[lnCurTH],ax         ; reset current line counter
					; so engine doesn't get confused
	xchg    es:[linCharTH],al       ; don't ignore any lines
	push    ax                      ; save line rejection char

	xor     si,si                   ; start at line 0

AnotherLine:
	inc     si                      ; advance to next line
	lea     bx,[bx].BDL_seg         ; BX = handle of data segment
	xor     ax,ax                   ; AX = context data offset (0)
	cCall   HelpGetLine,<si,cbMaxSize,ds,di,bx,ax>
	mov     bx,pHelpBdl             ; BX = *bdl of current help topic
	or      ax,ax                   ; any more lines?
	jz      NoEmbeddedInfo          ; brif not
	mov     ax,[di]                 ; AX = first 2 chars
	cmp     al,':'                  ; ":" command?
	jne     NoEmbeddedInfo          ; brif not -- they must come first
	cmp     ah,byte ptr (cChar)     ; the one we are searching for?
	jne     AnotherLine             ; brif not -- get another line

	mov     si,di                   ; DS:SI = *szTitle
	inc     si                      ; skip the ":"
	inc     si                      ; skip the control char
	SKIP2_PSW                       ; skip the XOR SI,SI
NoEmbeddedInfo:
	xor     si,si                   ; no szTitle found
	pop     ax                      ; restore old line rejection char
	GETSEG  es,[bx].BDL_seg,bx,SIZE ; ES = context data segment
	xchg    es:[linCharTH],al       ; restore old line rejection char
DbAssertRel     AX,E,-1,UI,<GetHelpControlInfo: AX should be -1>
	mov     es:[lnCurTH],ax         ; reset current line counter
					; so engine doesn't get confused

cEnd

;***
;SizeHelpContext
;
;Purpose:
;       Added with revision [2].
;
;       Returns total # of lines of help text for a given context, for use
;       in dialog box re-sizing, and scroll bar updating.
;
;
;Entry:
;       bdlText = * BDL containing a decompressed help context.
;
;Exit:
;       AX = iFileSize = # lines of help text present in this context.
;
;Uses:
;       Per Convention
;
;****

cProc   SizeHelpContext,<PUBLIC,NEAR>,<SI,DI>
ParmW   bdlText
cBegin
	mov     di,bdlText                      ; DI = *context BDL
	xor     si,si                           ; SI = count of # lines

Again:
	inc     si                              
	mov     cx,offset DGROUP:bufStdMsg      ; CX = &dummy sz
	mov     dx,CB_bufStdMsg                 ; DX = cbMax
	xor     ax,ax                           ; AX = context data offset (0)
	lea     bx,[di].BDL_seg                 ; BX = handle of data seg
	cCall   HelpGetLine,<SI,DX,DS,CX,BX,AX> 
	or      ax,ax                           ; success?
	jnz     Again                           ; brif so -- try again

	xchg    ax,si                           ; AX = # lines + 1
	dec     ax                              ; return AX = # lines
	mov     iFileSize,ax                    ; save # lines
cEnd


;***
;CmdHelpClose - Close the help window (from ESC)
;
;Purpose:
;       Close the help window.  Attached to the ESC accelerator.
;
;Entry:
;       None.
;
;Exit:
;       None.
;
;Uses:
;       Per C Convention
;
;****

cProc   CmdHelpClose,<PUBLIC,NEAR>
cBegin
	mov     oCurTopic,0             ; indicate no valid help
	cCall   WndHelpClose            ; close the window
cEnd


	subttl  Miscellanious Help Routines
	page

;***
;GetNextNc      - Advance a NC to the next topic
;
;Purpose:
;       Get the next physical context number given a context num.
;       Will not wrap from one file to another.
;
;Entry:
;       DX:AX = current context number
;
;Exit:
;       if ZF set (zero)
;          No next topic
;          CX = 0
;          AL = error code      (HELP_HANDLED, HELP_NF)
;       else
;          DX:AX is context number
;          CX != 0
;
;Uses:
;       Per C Convention
;
;****

cProc   GetNextNc,<PUBLIC,NEAR>
cBegin
	and     HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM); clear errors
	push    dx                              ; value to compare against
	push    dx                              ; push current context number
	push    ax
	cCall   HelpNcNext                      ; get next Context Num
	pop     bx
	cmp     bx,dx                           ; is it in a different file?
	jne     GetNextNc_Err                   ; yes, give error
	mov     cx,ax                           ; check if no more contexts
	or      cx,dx                           ; NZ & CX != 0 if no error
	jnz     GetNextNC_exit                  ; exit if success
GetNextNc_Err:
	mov     al,HELP_HANDLED                 ; assume handled error
	test    HelpFlags,HLP_FAILFNF OR HLP_FAILOOM ; was it?
	jnz     GetNextNc_Err2                  ; yes, use this code
	mov     al,HELP_NF                      ; context not found
GetNextNc_Err2:
	xor     cx,cx                           ; set CX = 0, ZF
GetNextNc_exit:
cEnd


;***
;CreateContext - convert a number into a context string
;char *(NEAR CreateContext(iContextNumber ))
;
;Purpose:
;       This routine takes a number and an initial character and
;       creates a context string out of it. The context string will
;       be of the form  "-1234" were '-' is the character and "1234"
;       is an ASCII representation of the number.  The string is
;       returned in a static buffer.
;
;       The number must be 0 < iContextNumber < 32768
;
;Entry:
;       iContextNumber : integer which will be remaining digits
;
;Exit:
;       AX = pSz : near pointer to string with results
;
;Uses:
;       AX, BX, CX, DX.
;
;****

cProc   CreateContext,<NEAR,PUBLIC>
	parmW   HelpId                  
cBegin
	mov     al,VT_I2                ;Format an integer
	lea     bx,HelpId               ; BX = ptr to number to format

	DbAssertRel [bx],g,0,UI,<CreateContext: Bad Help ID>

	call    B$IFOUT                 ;BX = address of 0 terminated string

	mov     BYTE PTR [bx],PREFIX_MESSAGE ; Replace space with character
					; that belongs in first postion
	xchg    ax,bx                   ;return *sz in AX
cEnd

;***
;ShrinkHelp - Compress Help system memory usage
;
;Purpose:
;       Reduce the amount of memory that the help system uses without
;       impeeding the functionallity of the help system.
;
;       WARNING!!!
;           Any time that this routine may be called (i.e. any time an alloc
;           is done), you must either set fNoDelBufs or guarentee that
;           numBuf = 0, or guarentee that oCurTopic, oFirstBuf and oLastBuf
;           are correct.
;
;Entry:
;       None.
;
;Exit:
;       None.
;
;Uses:
;       Per C Convention.
;
;****
cProc   ShrinkHelp,<PUBLIC,FAR>
cBegin

	DbHeapMoveOff                   ; FH callback can't cause movement

	test    HelpFlags,HLP_NOSHRINK  ; are we allowed to call HelpShrink?
	jnz     NoHelpShrink            ; no, check for deleting buffers
	cCall   HelpShrink              ; Tell help engine to shrink down
NoHelpShrink:


	cmp     fNoDelBufs,0            ; Can we delete help buffers also?
	jnz     ShrinkHelp_Exit         ; no, just return

	xor     cx,cx
	mov     cl,numBuf               ; cx = # buffers in use
	jcxz    ShrinkHelp_Exit         ; exit if there are none
	cmp     oCurTopic,0             ; do we have a current topic?
	jz      NoCurrentTopic          ; no, do not keep it in memory
	dec     cx                      ; do not delete the current topic
NoCurrentTopic:
	cCall   FlushBuffer             ; delete CX buffers
ShrinkHelp_Exit:


	DbHeapMoveOn                    ; remove our lock on the heap
cEnd

;***
;CompressHelp - Close down the help system
;
;Purpose:
;       This routine is called before we execute any user code so that
;       the help system can release all the memory that it does not need.
;
;Entry:
;       None.
;
;Exit:
;       None.
;
;Uses:
;       AX,BX,CX,DX
;
;Preserves:
;       ES
;****

cProc   CompressHelp,<PUBLIC,FAR>,<ES>  
cBegin
	DbHeapMoveOff                   ; we are called from FHAlloc
					; not allowed to move heaps

	test    HelpFlags,HLP_GOTBUF    ; Help system started?
	jz      NoFreeHelpBuffer        ; brif not -- nothing to do

	cmp     fHelpAlloc,0            ; doing a help alloc?
	jnz     NoFreeHelpBuffer        ; yes, do not shut down help system

	xor     ax,ax                   ; Nc of 0 => close all files
	cCall   HelpClose,<AX,AX>       ; Shut down the help engine

	; we will ignore any file errors on the close


	cCall   DiscardHelpBookMarks    ; free bookmark ptrs into help


NoHelpBuffer:
	xor     ax,ax                   ; get a convenient 0
	mov     iStaticHelpTopic,ax     ; clear current search topic
	mov     oCurTopic,ax            ; clear current topic ptr.
	mov     iCurRequestLine,ax      ; clear GetHelpLine succeeded flag

	; zero the initial context number
	mov     WORD PTR ncInitial,ax   
	mov     WORD PTR ncInitial+2,ax

	or      HelpFlags,HLP_COMPRESS  ; flag help has been compressed
	cCall   DrawDebugScr            ; make sure screen is redrawn.

DbAssertRel     BdlHelpHist.BDL_Seg,ne,UNDEFINED,UI,<CompressHelp:HLP_GOTBUF is true, but no HistoryBuf Allocated>
	PUSHI   ax,<OFFSET DGROUP:BdlHelpHist>  ; Free up the history buf
	cCall   BdlFree                 
	mov     cl,numBuf               ; number of buffers to deallocate
	xor     ch,ch                   
	cCall   FlushBuffer             ; Delete all the help buffers
	and     HelpFlags,NOT HLP_GOTBUF ; indicate buffer unallocated

NoFreeHelpBuffer:
	DbHeapMoveOn                    ; remove our heap lock
cEnd



; ReWrote with [39]
;***
;GiveHelpOOM - Queue a message to give OOM for Help
;
;Purpose:
;       Indicate to the error handling code that an OOM error has occured
;       in the help system.  This routine may be called as many times as
;       desired before DisplayHelpOOM is called, and the error will only
;       be reported once.
;
;Entry:
;       None.
;
;Exit:
;       None.
;
;Uses:
;       By Convention
;
;****

cProc   GiveHelpOOM,<PUBLIC,NEAR>
cBegin
	or      HelpFlags,HLP_FAILOOM   ; indicate We failed due to OOM
	mov     ax,MSG_HelpOOM          
	cCall   SetUiErr,<AX>           
cEnd

;Added with [39]
;***
;DisplayHelpOOM - Display an OOM error
;
;Purpose:
;       Displays an OOM error messages box for help, closes the help window,
;       and resets static variables.
;
;Entry:
;       None.
;
;Exit:
;       None.
;
;****

cProc   DisplayHelpOOM,<PUBLIC,NEAR>
cBegin

DbAssertTst     HelpFlags,e,HLP_INHELP,UI,<DisplayHelpOOM: Recursion lock already set>
	or      HelpFlags,HLP_INHELP    ; set the recursion lock

	
	;We must save the HelpId in case the user does something like:
	;   Error 1           -> displays a dialog box
	;   F1                -> gets help, runs out of memory
	;   we call MsgBoxStd -> blows away iHelpId
	;   OK to message     -> back to original dialog box
	;   F1                -> trys help again, iHelpId is invalid
	
	push    iHelpId

	PUSHI   ax,MB_OK                ; Box has OK button
	PUSHI   ax,MSG_HelpOOM          ; message to be displayed
	call    MsgBoxStd               ; put up a dialog box
	and     HelpFlags, NOT HLP_INHELP ;remove recursion lock
	push    Word Ptr fHelpAlloc     ; save the help alloc flag
	mov     fHelpAlloc,0            ; zero it so CompressHelp will
	call    CompressHelp            ; get help system out of the way
	mov     uierr,0                 ; clear out the error condition
	pop     ax                      ; get fHelpAlloc back
	mov     fHelpAlloc,al           ; and restore it.
	pop     iHelpId                 ; restore HelpId
cEnd


;Rewritten with [38]
;***
;FlushBuffer - Deallocates buffers from HelpBuffer
;
;Purpose:
;       This routine will deallocate all buffers from (but not including)
;       the current topic to the end of the buffer.  If this is not enough,
;       it will start deleting buffers from the begining, until the specified
;       number has been reached.
;
;       If there is no current topic, we will just delete buffers from the
;       begining until we have freed enough.
;
;Entry:
;       CX = minimum # buffers to deallocate
;
;Exit:
;       None.
;
;Uses:
;       Per Convention
;****

cProc   FlushBuffer,<NEAR>,<SI,DI>
cBegin

	DbHeapMoveOff

DbAssertRelB    cl,be,MAX_HELPBUFS,UI,<FlushBuffer: Deallocating more buffers than exist>

	mov     di,cx                   ; DI = # buffers to delete
	cmp     oCurTopic,0             ; is oCurTopic invalid?
	je      DelBegin                ; yes, just delete from the begining
	mov     si,oLastBuf             ; get pointer to last buffer
DelEnd_Next:

	cmp     si,oCurTopic            ; have we reached the current topic?
	je      DelBegin                ; yes, start deleting from begining

	lea     ax,[si].bdlHelpText     ; ax = ptr to BDL in first buffer
	cCall   BdlFree,<ax>            ; get rid of it

	dec     numBuf                  ; indicate it is no longer in use
	sub     si,BUFSIZE              ; point at the last buffer
	cmp     si,OFFSET DGROUP:HelpBuffer ;did we go off the end?
	jae     NoWrap5                 ; no
	add     si,BUFFERSIZE           ; wrap around
NoWrap5:
	mov     oLastBuf,si             ; update oLastBuf
	dec     di                      ; one more buffer deleted
	jmp     short DelEnd_Next       ; go try again

DelBegin:
	or      di,di                   ; is it 0 or negative
	jle     EndFlushBuffer          ; yes, exit
	mov     si,oFirstBuf            ; get pointer to first buffer
DelBegin_Next:
	lea     ax,[si].bdlHelpText     ; ax = ptr to BDL in first buffer
	cCall   BdlFree,<ax>            ; get rid of it

	dec     numBuf                  ; indicate it is no longer in use

	add     si,BUFSIZE              ; Point SI at next buffer
	cmp     si,BUFFEREND            ; did we go off end of buffer?
	jb      NoWrap1                 ; no, continue
	sub     si,BUFFERSIZE           ; wrap around to begining
NoWrap1:
	dec     di                      ; one less to do
	jnz     DelBegin_Next           ; loop again
	mov     oFirstBuf,si            ; restore ptr to first buffer

EndFlushBuffer:
	DbHeapMoveOn                    ; reeanble heap movement

cEnd


;Reorganized with [43]
;***
;StartHelp : make sure the help system is initialized (or reinitialized)
;
;Purpose:
;       This routine is called before any references to the help buffers
;       or the help engine are made.  It makes sure the help engine is
;       activated, the help file exists, and the buffers for the virtual
;       line system are initialized.
;
;Entry:
;       None.
;
;Exit:
;       AX = 0  if all OK
;       AX = HELP_HANDLED if an error occured (will be handled).
;
;Uses:
;       Per Convention
;
;****

cProc   StartHelp,<PUBLIC,NEAR>
cBegin
DbAssertRelB    fHelpAlloc,ne,0,UI,<StartHelp:fHelpAlloc not set>

	test    HelpFlags,HLP_GOTBUF    ; do we have the buffers?
DJMP    jnz     StartHelp_Success       ; yes, exit with return code

	
	;Try to start help engine
	
StartHelpEngine:

DbAssertRel     BdlHelpHist.BDL_Seg,e,UNDEFINED,UI,<StartHelp:History Buffer Valid without HLP_GOTBUF>
	PUSHI   ax,<OFFSET DGROUP:BdlHelpHist>
	PUSHI   ax,HELPHIST_END         ; # bytes to allocate
	cCall   BdlAlloc                ; allocate the memory
	or      ax,ax                   ; did we get the memory?
	jnz     InitHistBuff            ; yes, go initialize it
	cCall   GiveHelpOOM             ; queue an OOM error

	mov     ax,sp                   ; return a non-zer value
	jmp     short StartHelp_Exit

InitHistBuff:
	GETSEG  es,BdlHelpHist.BDL_Seg,bx,SIZE  ; get segment
	xor     bx,bx
	mov     ES:[bx].HH_Used,bx      ; initialize # elements in use
	mov     WORD PTR ES:[bx].HH_First,HELPHIST_BEGIN ; initialize ptr
	
	;Initialize HelpBuffer
	
	push    di                      ; Save register
	push    ds                      ; Set ES=DS=DGROUP
	pop     es
	mov     ax,UNDEFINED            ; value to initialize buffers with
	mov     cx,BUFFERSIZE/2         ; number of words in buffer
	mov     di,OFFSET DGROUP:HelpBuffer   ; start of buffer
	mov     oFirstBuf,DI            ; initialize buffer pointers
	mov     oLastBuf,DI
	rep     stosw                   ; initialize buffer
	mov     numBuf,CL               ; initialize num in use (=0)

	pop     di                      ; Restore register
	or      HelpFlags,HLP_GOTBUF

StartHelp_Success:
	xor     ax,ax                   ; return code of success

StartHelp_Exit:
cEnd


;Rewritten with revision [57]
;***
;CalcNc - Calculate a Context Number from a Context string
;
;Purpose:
;       Go though our list of help files, calling HelpNc with the
;       initial context number for each one.  If a help file is not
;       opened, then try to open it before calling HelpNc.
;
;       If the context number is not found and there have been any
;       dialog boxes displayed (or OOM), then return HELP_HANDLED.
;       Otherwise return HELP_NF.
;
;Entry:
;       npsz - Near pointer to context string
;
;Exit:
;       if (CX <> 0)
;           DX:AX = Context Number
;       else
;           AL = Error Code (HELP_NF, HELP_HANDLED)
;
;Uses:
;       Per Convention
;
;****

cProc   CalcNc,<PUBLIC,NEAR>,<SI,DI>
parmW   npsz
localB  retVal                          ; value to return on error
cBegin
	mov     retVal,HELP_NF          ; default error code is HELP_NF

	mov     cx,offset szHelpFileQhelp; cs:cx = ptr to file name
	call    fQhelpActive            ; are we in the help viewer
	jnz     InQhelp                 ; brif so, have proper file name
	mov     cx,offset szHelpFileEdit; cs:cx = ptr to file name
	call    fEditorActive           ; are we in the editor
	jnz     InQhelp                 ; brif so, have proper file name
	mov     cx,offset szHelpFileInterp ; use help file for interpreter
InQhelp:

	mov     dx,WORD PTR ncInitial   ; dx = high word of ncInitial
	mov     ax,WORD PTR ncInitial+2 ; ax = low word of ncInitial

	mov     bx,npsz                 ; get a ptr to the string
	cmp     Byte Ptr [bx],0         ; is it a local context?
	jne     NotLocalContext         ; no, check if we have to open file
DbAssertRel     oCurTopic,ne,0,UI,<CalcNc:oCurTopic invaid>
	mov     bx,oCurTopic            ; get ptr to current topic
	mov     ax,Word Ptr [bx].ContextNum ; use current NC as the initial NC
	mov     dx,Word Ptr [bx].ContextNum+2

NotLocalContext:
	mov     bx,ax                   ; do we have a context #?
	or      bx,dx
	jnz     GotHelpFile             ; brif so -- try the lookup

	cCall   HelpOpen,<cs,cx>        ; try to open the file.
					; DX:AX = ncInitial, or 0:x if failure
	or      dx,dx                   ; was there an error?
	jnz     SaveInitialNc           ; no
	cmp     ax,HELPERR_MAX          ; check the low word
	jae     SaveInitialNc           ; no error, continue processing

	.erre   HELPERR_MAX LT 256      ; make sure all errors fit in a byte
	.errnz  HELPERR_FNF - 1         ; these two errors should be first
	.errnz  HELPERR_READ - 2

;HELPERR_READ => error already given
;HELPERR_FNF  => error already given
; error 7     => error already given
;HELPERR_LIMIT => assert that this doesn't happen (25 help files)
;HELPERR_BADAPPEND => give ER_BFM
;HELPERR_NOTHELP => give ER_BFM
;HELPERR_BADVERS => give ER_BFM
;others        => whatever is convenient

	mov     retVal,HELP_HANDLED     ; set a new return value
DbAssertRel     ax,ne,HELPERR_LIMIT,UI,<CalcNC:HELPERR_LIMIT from HelpEngine>
	cmp     ax,HELPERR_READ         ; have we already informed user?
DJMP    jbe     CalcNcExit_Err          ; yes, exit in error
	cmp     ax,7                    ; another error we told user about?
DJMP    je      CalcNcExit_Err          ; yes, exit

DbAssertTst     HelpFlags,z,HLP_INHELP,UI,<HelpStart:Recursion lock set>
	or      HelpFlags,HLP_INHELP    ; set recursion lock
	PUSHI   ax,MB_OK                ; only an OK button
	PUSHI   ax,ER_BFM               ; It must be a bad help file
	cCall   MsgBoxStd               ; display error
	and     HelpFlags,NOT HLP_INHELP ; clear recursion lock
	jmp     CalcNCExit_Err          ; and exit

SaveInitialNc:
	mov     WORD PTR ncInitial+2,ax ; save NC
	mov     WORD PTR ncInitial,dx   

GotHelpFile:
	and     HelpFlags,NOT (HLP_FAILOOM OR HLP_FAILFNF) ; clear flags

	cCall   HelpNc,<ds,npsz,dx,ax>  ; DX:AX = nc for this context str

	test    HelpFlags,HLP_FAILOOM OR HLP_FAILFNF ; a handled error?
	jz      CheckForSuccess         ; no, check to see if we succeeded
	mov     retVal,HELP_HANDLED     ; update return code otherwise

CheckForSuccess:
	mov     cx,dx
	or      cx,ax                   ; cx != 0 iff we got the topic
	jnz     CalcNcExit              ; brif ok -- we got the NC

CalcNcExit_Err:
	xor     cx,cx                   ; set cx in case of error
	mov     al,retVal               ; return error code
CalcNcExit:                             ;DX:AX = context #, or 0
cEnd


; Constants used by DoStatusButton().  All added with revision [10].

; NOTE: These messages must remain in sync with QBIMSGS.TXT so that the
; NOTE: status line buttons work properly.
; NOTE:
; NOTE: How to change the text of a message:
; NOTE: 
; NOTE: 1. Make sure that the new message will not overflow the status
; NOTE:    line.  If it will, text changes are required, or a button
; NOTE:    must be removed.
; NOTE: 2. Make the change to the text in QBIMSGS.TXT
; NOTE: 3. Make the change to the text in UINHELP.ASM
; NOTE: 4. Adjust the button position #'s in UINHELP.ASM
; NOTE:
; NOTE: How to add/remove a button:
; NOTE: 
; NOTE: 1. Perform the steps required to change the status line text
; NOTE: 2. Inc/Dec the # of buttons constant in the appropriate
; NOTE:    StatusXXXTable list.
; NOTE: 3. Add/Remove the Button_XXX constant corresponding to the
; NOTE:    desired key from the appropriate StatusXXXTable list.
; NOTE:


				; <Shift+F1=Help> <Possible other fields>
			;         ^              ^
All_ob1_F1      EQU 1       ;---------+                              |
All_ob2_F1      EQU 16 ;------------------------+

;Editing
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;                       <Shift+F1=Help> <F6=Window> <F2=Subs> <F5=Run> <F8=Step>
;                                                                ^                      ^^               ^^              ^^                    ^
Edit_ob1_F6 EQU 17           ;-+                       ||                    ||              ||       |
Edit_ob2_F6 EQU 28           ;------------+|                 ||              ||       |
Edit_ob1_F2 EQU 29           ;-------------+               ||              ||       |
Edit_ob2_F2 EQU 38           ;----------------------+|                       ||       |
Edit_ob1_F5 EQU 39           ;-----------------------+                       ||       |
Edit_ob2_F5 EQU 47           ;-------------------------------+|               |
;Edit_ob1_F8 EQU 48           --------------------------------+               |
;Edit_ob2_F8 EQU 57           -----------------------------------------+  nl te weinig ruimte 

;Program running (debugging):
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F5=Continue> <F9=Toggle Bkpt> <F8=Step>
;                         ^            ^^               ^^        ^
Running_ob1_F5 EQU 17       ;-+                             ||                                ||                    |
Running_ob2_F5 EQU 30       ;--------------+|                                 ||                    |
Running_ob1_F9 EQU 31       ;---------------+                                 ||                    |
Running_ob2_F9 EQU 47       ;-------------------------------+|                      |
Running_ob1_F8 EQU 48       ;--------------------------------+                      |
Running_ob2_F8 EQU 57       ;-----------------------------------------+

;Immediate window active:
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F6=Window> <Enter=Execute Line>
;                         ^          ^^                   ^
Immed_ob1_F6    EQU 17      ;-+                      ||                                              |
Immed_ob2_F6    EQU 28      ;------------+|                                          |
Immed_ob1_ENTER EQU 29      ;-------------+                                          |
Immed_ob2_ENTER EQU 49      ;---------------------------------+

;Help window active:
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>
;                         ^          ^^           ^^             ^^            ^
Help_ob1_F6 EQU 17  ;-+                      ||                       ||                              ||                             |
Help_ob2_F6 EQU 28  ;------------+|                   ||                              ||                             |
Help_ob1_ESC    EQU 29      ;-------------+                   ||                              ||                             |
Help_ob2_ESC    EQU 41      ;-------------------------+|                              ||                             |
Help_ob1_CTRLF1 EQU 42      ;--------------------------+                              ||                             |
Help_ob2_CTRLF1 EQU 56      ;----------------------------------------+|                              |
;Help_ob1_ALTF1 EQU 57       -----------------------------------------+                              |
;Help_ob2_ALTF1 EQU 70       ------------------------------------------------------+

;[67] Editing in QEDIT
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         MS-DOS Editor  <F1=Help> Press ALT to activate menus
;                        ^       ^
;                        |       |
QEdit_ob1_F1    EQU 16       ;  |           ;[73]
QEdit_ob2_F1    EQU 25       ;-------+                      ;[73]


;[67] Help window active: QEDIT
;        00000000001111111111222222222233333333334444444444555555555566666
;        01234567890123456789012345678901234567890123456789012345678901234
;         <F1=Help> <F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>
;         ^       ^ ^          ^^           ^^             ^^            ^           ^
QHelp_ob1_F1    EQU 01     ;                ||                       ||                              ||                             |
QHelp_ob2_F1    EQU 09     ;                ||                       ||                              ||                             |
QHelp_ob1_F6    EQU 11  ;           ||                       ||                              ||                             |
QHelp_ob2_F6    EQU 22  ;------ |                    ||                              ||                             |
QHelp_ob1_ESC   EQU 23  ;-------+                    ||                              ||                             |
QHelp_ob2_ESC   EQU 35  ;-------------------+|                               ||                             |
QHelp_ob1_CTLF1 EQU 36      ;--------------------+                            ||                             |
QHelp_ob2_CTLF1 EQU 50      ;----------------------------------+|                            |
;QHelp_ob1_ALTF1 EQU 51  -----------------------------------+                               |
;QHelp_ob2_ALTF1 EQU 64  ------------------------------------------------+


; QHELP help viewer start-up status: MSG_StatusQHStart
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         MS-DOS Help Viewer  <F1=Help> Press ALT to activate menus
;                             ^       ^
;                             |       |
QHStart_ob1_F1    EQU 21 ;       |
QHStart_ob2_F1    EQU 29      ;-------+


; QHELP help window active: MSG_StatusQHHelp
;        00000000001111111111222222222233333333334444444444555555555566666666667
;        01234567890123456789012345678901234567890123456789012345678901234567890
;         <Alt+C=Contents> <Alt+N=Next> <Alt+B=Back>
;         ^               ^^           ^^           ^
QHHelp_ob1_CONTS EQU 01 ; ||           ||           |
QHHelp_ob2_CONTS EQU 17 ;-+|           ||           |
QHHelp_ob1_NEXT  EQU 18 ;--+           ||           |
QHHelp_ob2_NEXT  EQU 30 ;--------------+|           |
QHHelp_ob1_BACK  EQU 31 ;---------------+           |
QHHelp_ob2_BACK  EQU 43 ;---------------------------+


labelNP <StatusTable>
	DW      UIOFFSET StatusEditTable
	DW      UIOFFSET StatusRunningTable
	DW      UIOFFSET StatusImmedTable
	DW      UIOFFSET StatusHelpTable
	DW      UIOFFSET StatusQeditTable       
	DW      UIOFFSET StatusQhelpTable       
	DW      UIOFFSET StatusQHStartTable
	DW      UIOFFSET StatusQHhelpTable

StatusButton STRUC
SB_Command      db      ?
SB_obStart      db      ?
SB_obEnd        db      ?
StatusButton ends

LabelNP <StatusEditTable>
	DB      4               ; # of buttons in Edit status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midNextWindow, Edit_ob1_F6, Edit_ob2_F6>
	StatusButton    <midViewSubs, Edit_ob1_F2, Edit_ob2_F2>
	StatusButton    <midRunContinue, Edit_ob1_F5, Edit_ob2_F5>
       ;StatusButton    <midStep, Edit_ob1_F8, Edit_ob2_F8>

LabelNP <StatusRunningTable>
	DB      4               ; # of buttons in Running status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midRunContinue, Running_ob1_F5, Running_ob2_F5>
	StatusButton    <midDebugToggleBp, Running_ob1_F9, Running_ob2_F9>
	StatusButton    <midStep, Running_ob1_F8, Running_ob2_F8>

LabelNP <StatusImmedTable>
	DB      3               ; # of buttons in Immediate status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midNextWindow, Immed_ob1_F6 , Immed_ob2_F6>
	StatusButton    <midEnter, Immed_ob1_ENTER, Immed_ob2_ENTER>

LabelNP <StatusHelpTable>
	DB      4               ; # of buttons in Help status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midNextWindow, Help_ob1_F6, Help_ob2_F6>
	StatusButton    <midHelpClose, Help_ob1_ESC, Help_ob2_ESC>
	StatusButton    <midHelpNext, Help_ob1_CTRLF1, Help_ob2_CTRLF1>
	;StatusButton    <midHelpBack, Help_ob1_ALTF1, Help_ob2_ALTF1>

LabelNP <StatusQeditTable>
	DB      1               ; # of buttons in Edit status message
	StatusButton    <midHelpSyntax, Qedit_ob1_F1, Qedit_ob2_F1>

LabelNP <StatusQhelpTable>
	DB      4               ; # of buttons in Help status message
	StatusButton    <midHelpSyntax, QHelp_ob1_F1, QHelp_ob2_F1>
	StatusButton    <midNextWindow, QHelp_ob1_F6, QHelp_ob2_F6>
	StatusButton    <midHelpClose, QHelp_ob1_ESC, QHelp_ob2_ESC>
	StatusButton    <midHelpNext, QHelp_ob1_CTLF1, QHelp_ob2_CTLF1>
	;StatusButton    <midHelpBack, QHelp_ob1_ALTF1, QHelp_ob2_ALTF1>

LabelNP <StatusQHStartTable>
	DB      1               ; # of buttons in QHELP start status message
	StatusButton    <midHelpHowToUse, QHStart_ob1_F1, QHStart_ob2_F1>

LabelNP <StatusQHhelpTable>
	DB      3               ; # of buttons in QHELP Help status message
	StatusButton    <midHelpHelp,    QHHelp_ob1_CONTS, QHHelp_ob2_CONTS>
	StatusButton    <midHelpNext,    QHHelp_ob1_NEXT , QHHelp_ob2_NEXT >
	StatusButton    <midHelpBack,    QHHelp_ob1_BACK , QHHelp_ob2_BACK >


;***
;HStatusButton
;       Given a mouse position in the status line window, return
;       a handle to the status button at that position.
;
;Purpose:
;       Heavy modification in revision [52]
;
;Entry:
;       posX = 0-relative mouse position
;Exit:
;       AX - handle to the status button or NULL if no button.
;            The handle is actually a pointer into the code segment.
;Uses:
;       Per Convention
;****

cProc   HStatusButton,<PUBLIC,NEAR>,<SI>
	ParmW   posX
cBegin
	xor     si,si                   ;Default return value: NULL

	mov     bx,iMsgStatusLine       ; bx = current line displayed
	sub     bx,MSG_StatusEdit       ; bx = 0, 1, 2, 3, or invalid
	cmp     bx,(MSG_StatusQHhelp - MSG_StatusEdit) ; out of range?
	ja      ButtonExit              ; brif so -- just exit

	shl     bx,1                    ; word index
	mov     si,word ptr cs:[bx].StatusTable

	mov     bx,[posX]               ; bx = 0-relative position
	lods    byte ptr cs:[si]        ; AL = number of entries for this line
	cbw                             
	xchg    cx,ax                   ; CX = number of entries
ButtonLoop:
	inc     si                      ;Ignore the SB_Command
	lods    word ptr cs:[si]        ;AH = obEnd, AL = obStart
	cmp     bl, al
	jb      ButtonNotFound
	cmp     bl, ah
	jb      ButtonFound
	loop    ButtonLoop
ButtonNotFound:
	mov     si,SIZE StatusButton    ;return NULL
ButtonFound:
	sub     si,SIZE StatusButton    ;point back to begining of structure.
ButtonExit:
	mov     ax, si
cEnd

;***
;ObStatusButton - Returns the position of a Status Line Button
;
;Purpose:
;       Return the position of the specified Status Button.
;
;       new for revision [52]
;
;Entry:
;       hButton - handle to button (near pointer in CS)
;
;Exit:
;       AX - Offset in characters from the beginning of the status line.
;
;Preserves:
;
;****
cProc ObStatusButton,<NEAR,PUBLIC>
	parmW   hButton
cBegin
	mov     bx, [hButton]
	xor     ax,ax
	mov     al, cs:[bx.SB_obStart]
cEnd

;***
;CbStatusButton - Returns the number of characters in a Status Line Button
;
;Purpose:
;       Return the number of characters in the specified Status Button.
;
;       new for revision [52]
;
;Entry:
;       hButton - handle to button (near pointer in CS)
;
;Exit:
;       AX - Size of button.
;
;Preserves:
;
;****
cProc CbStatusButton,<NEAR,PUBLIC>
	parmW hButton
cBegin
	mov     bx, [hButton]
	mov     al, cs:[bx.SB_obEnd]
	sub     al, cs:[bx.SB_obStart]
	xor     ah,ah
cEnd

;***
;DoStatusButton - Posts the key message associated with a Status Line Button
;
;Purpose:
;       Post the WM_CHAR message for the specified Status Button.
;
;       new for revision [52]
;
;Entry:
;       hButton - handle to button (near pointer in CS)
;
;Exit:
;       None.
;
;Preserves:
;
;****
cProc DoStatusButton,<NEAR,PUBLIC>
	parmW   hButton
cBegin
	mov     bx, [hButton]
	xor     dx,dx                           
	mov     dl,cs:[bx.SB_Command]           
	pushi   ax, <DATAOffset wndMain>        
	pushi   ax, WM_COMMAND                  
	push    dx                              
	xor     ax,ax
	push    ax
	push    ax
	call    PostMessage
cEnd

cEnd

;***
;RecordHelpHistory - Add entry to history list
;
;Purpose:
;       Record an entry into the help history list.  If the list is already
;       full, the last item gets bumped.
;
;Entry:
;       DX:AX   : item to be stored
;       BL      : flags to store with it        (EI_VARHELP Only)
;
;Exit:
;       None.
;
;Preserves:
;       AX,DX
;
;****

cProc   RecordHelpHistory,<NEAR,PUBLIC>,<DS>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<RecordHelpHistory:BdlHelpBack not initialized>

	GETSEG  ds,BdlHelpHist.BDL_Seg,bx,SIZE  ; get segment of data

	;NOTE: DS != DGROUP at this point

	ASSUMES DS,NOTHING

	xor     bx,bx                   ; look at location 0
	cmp     WORD PTR [bx].HH_Used,NUM_HISTORY ; all slots being uses?
	je      RecordOverwrite         ; yes, just overwrite last item
	inc     WORD PTR [bx].HH_Used   ; one more item being used
RecordOverwrite:
	mov     cx,[bx].HH_First        ; DX is location to stick item
	push    cx
	add     cx,SIZE HelpHistEntry   ; point CX at next entry
	cmp     cx,HELPHIST_END         ; at end of table?
	jb      NoTableWrap             ; no
	mov     cx,HELPHIST_BEGIN       ; point to begining of table
NoTableWrap:
	mov     [bx].HH_First,cx        ; save new initial location
	pop     bx                      ; restore previous starting loc
	mov     [bx].HH_HiWord,dx       ; save Hi word
	mov     [bx].HH_LoWord,ax       ; save lo word
	ASSUMES DS,DGROUP
cEnd

;***
;RetrieveHelpHistory - Get the last recorded item in help history list
;
;Purpose:
;       Retrieve the last item from the help history list.  Returns with CX=0
;       if no items are left.
;
;Entry:
;       None.
;
;Exit:
;       if CX <> 0
;           DX:AX   : item stored
;           BL      : flags stored with it (IF EI_VARHELP)
;       else
;           No items recorded
;
;****
cProc   RetrieveHelpHistory,<NEAR,PUBLIC>,<DS>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<RetrieveHelpHistory:BldHelBack not initialized>

	GETSEG  ds,BdlHelpHist.BDL_Seg,bx,SIZE  ; get segment of data
	
	;NOTE: DS != DGROUP at this point
	
	ASSUMES DS,NOTHING

	xor     bx,bx                   ; look at location 0
	mov     cx,[bx].HH_Used         ; CX = number of slots in use
	jcxz    RetrieveExit            ; no items, return with error
	
	;NOTE: CX <> 0 is preserved for rest of routine
	
	dec     WORD PTR [bx].HH_Used   ; indicate one less
	mov     ax,[bx].HH_First        ; AX = offset into table
	sub     ax,SIZE HelpHistEntry   ; point to previous entry
	cmp     ax,HELPHIST_BEGIN       ; before first entry?
	jge     NoRetrieveWrap          ; no, continue
	mov     ax,HELPHIST_END - SIZE HelpHistEntry ; set to last item
NoRetrieveWrap:
	mov     [bx].HH_First,ax        ; save new pointer
	xchg    bx,ax                   ; bx = ptr to entry to retrieve
	mov     dx,[bx].HH_HiWord       ; retrieve values and exit
	mov     ax,[bx].HH_LoWord
RetrieveExit:
	ASSUMES DS,DGROUP
cEnd

;***
;HelpHistoryLength - return number of items in the help history list
;
;Entry:
;       None
;
;Exit:
;       CX = number of items
;
;Uses:
;       CX,ES
;
;Preserves:
;       AX,BX,DX
;***

cProc   HelpHistoryLength,<NEAR>,<BX>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<HelpHistoryLength:BldHelBack not initialized>

	GETSEG  es,BdlHelpHist.BDL_Seg,bx,SIZE  ; get segment of data
	mov     cx,ES:[0].HH_Used       ; CX = number of slots in use
cEnd



; added with [24], rewritten with [25]
;***
;DiscardHistoryoRs - Discard all Help + Bookmark information for an oRs
;
;Purpose:
;       Discards any stored information about a given oRs in the help system.
;       If the current help being displayed is dependent on this oRs, then we
;       will do a Help Back until something is found.  If nothing is found,
;       close the help window.
;
;Entry:
;       oRs - oRs to be discarded
;
;Exit:
;       None
;
;Uses:
;       Per C Conventions
;***

cProc   DiscardHistoryoRs,<PUBLIC,FAR>,<SI,DI>
parmW   oRs
cBegin
	mov     ax,UNDEFINED            ; indicates bookmark not valid
	cCall   ReAssignBookMark,<oRs,AX> ; delete all matching bookmarks



DiscardHistory_Exit:
cEnd


;***
;szSrchExcl - search for '!' in a 0 terminated string
;
;Purpose:
;       This routine scans a 0 terminated string to find an '!' in
;       it.
;
;Entry:
;       npsz    - Near Ptr to string to search
;
;Exit:
;       if character not found
;           AX = 0
;       else
;           AX = ptr to first occurance of the character
;
;Uses:
;       Per C convention
;****

cProc   szSrchExcl,<PUBLIC,NEAR>,<SI>
parmW   npsz
cBegin
	mov     si,npsz                 ; start of string to scan
NextChr:
	lodsb
	cmp     al,'!'                  ; is it the character of interest?
	je      FoundChr                ; yes, return its position
	or      al,al                   ; is it the 0 terminator?
	jne     NextChr                 ; no, try the next character.
	cbw                             ; AX = 0
	xchg    ax,si                   ; SI = 0  (return value)
FoundChr:
	xchg    ax,si                   ; AX = Ptr to str OR 0
cEnd


;***
;SendHelpMsg - Stub routine to send a message to the help window
;
;Purpose:
;       Code saving method of sending a message (with wParm only) to
;       the help window.
;
;Entry:
;       msg - message to send
;       wParam - one parameter to be passed
;
;Exit:
;       Return value from Window Proc
;
;
;****

cProc   SendHelpMsg,<PUBLIC,NEAR>
parmW   msg
parmW   wParam
cBegin
	mov     ax,OFFSET DGROUP:wndHelp
	cCall   SendMessage,<AX, msg, wParam, ax,ax>
cEnd


sEnd    UI
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbfrn\strings\itl.h ===
/*
	COW : Character Oriented Windows

	itl.h   : Internationalization header

	This contains strings for use in QBASIC dialog boxes.

	You have a string in quotes, followed by its length +
	the total number of spaces to have on each side of
	the string.

	eg. "OK" is 2 long, the 4 means put 4/2=2 spaces on
	    each side of the word when it is being displayed.
	    make sure you leave the brackets around the numbers
	    ie, 2+4 is incorrect, (2+4) is correct.

	Some also have their hotkey following the key and the
	size, make sure that you leave the single qutoes (')
	around these characters.

	You may have to make some adjustments to the .des files
	when you have changed this file.

	eg, say you translate "OK" to "Okay", then the size
	might go to (4+4), or whatever you want.
	Then you would go to the .des files.
	lines with the following would have to be modified:

	OK_BUTTON AT (col, row, 6, 1) ACT...........
				^

	to

	OK_BUTTON AT (col, row, 8, 1) ACT...........
				^

*/


#define szOk            "OK"
#define cchOk           (2+2)
/* chAccelOk no accelerator */

#define szYes           "Oui"
#define cchYes          (3+2)
#define chAccelYes      'O'

#define szNo            "Non"
#define cchNo           (3+2)
#define chAccelNo       'N'

#define szCancel        "Annuler"
#define cchCancel       (7+2)
/* chAccelCancel no accelerator */

#define szRetry         "Reprise"
#define cchRetry        (7+2)
#define chAccelRetry    'R'

#define szAbort         "Abandon"
#define cchAbort        (7+2)
#define chAccelAbort    'A'

#ifdef HELP_BUTTON
#define szHelp          "Aide"
#define cchHelp         (4+2)
#define chAccelHelp     'A'
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbdut\strings\itl.h ===
/*
	COW : Character Oriented Windows

	itl.h   : Internationalization header

	This contains strings for use in QBASIC dialog boxes.

	You have a string in quotes, followed by its length +
	the total number of spaces to have on each side of
	the string.

	eg. "OK" is 2 long, the 4 means put 4/2=2 spaces on
	    each side of the word when it is being displayed.
	    make sure you leave the brackets around the numbers
	    ie, 2+4 is incorrect, (2+4) is correct.

	Some also have their hotkey following the key and the
	size, make sure that you leave the single qutoes (')
	around these characters.

	You may have to make some adjustments to the .des files
	when you have changed this file.

	eg, say you translate "OK" to "Okay", then the size
	might go to (4+4), or whatever you want.
	Then you would go to the .des files.
	lines with the following would have to be modified:

	OK_BUTTON AT (col, row, 6, 1) ACT...........
				^

	to

	OK_BUTTON AT (col, row, 8, 1) ACT...........
				^

*/


#define szOk            "OK"
#define cchOk           (2+4)
/* chAccelOk no accelerator */

#define szYes		"Ja"
#define cchYes		(2+2)
#define chAccelYes	'J'

#define szNo		"Nee"
#define cchNo		(3+4)
#define chAccelNo       'N'

#define szCancel	"Annuleren"
#define cchCancel	11
/* chAccelCancel no accelerator */

#define szRetry 	"Herhalen"
#define cchRetry	10
#define chAccelRetry	'H'

#define szAbort 	"Afbreken"
#define cchAbort	10
#define chAccelAbort    'A'

#ifdef HELP_BUTTON
#define szHelp          "Help"
#define cchHelp         (4+2)
#define chAccelHelp     'H'
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbitn\strings\intl.inc ===
CCHUNTITLED             EQU 8 ; length of "Untitled" file name string
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbger\strings\intl.inc ===
CCHUNTITLED		EQU 10 ; length of "Untitled" file name string
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbger\strings\itl.h ===
/*
	COW : Character Oriented Windows

	itl.h   : Internationalization header

	This contains strings for use in QBASIC dialog boxes.

	You have a string in quotes, followed by its length +
	the total number of spaces to have on each side of
	the string.

	eg. "OK" is 2 long, the 4 means put 4/2=2 spaces on
	    each side of the word when it is being displayed.
	    make sure you leave the brackets around the numbers
	    ie, 2+4 is incorrect, (2+4) is correct.

	Some also have their hotkey following the key and the
	size, make sure that you leave the single qutoes (')
	around these characters.

	You may have to make some adjustments to the .des files
	when you have changed this file.

	eg, say you translate "OK" to "Okay", then the size
	might go to (4+4), or whatever you want.
	Then you would go to the .des files.
	lines with the following would have to be modified:

	OK_BUTTON AT (col, row, 6, 1) ACT...........
				^

	to

	OK_BUTTON AT (col, row, 8, 1) ACT...........
				^

*/


#define szOk            "OK"
#define cchOk           (2+4)
/* chAccelOk no accelerator */

#define szYes           "Ja"
#define cchYes          (2+2)
#define chAccelYes      'J'

#define szNo            "Nein"
#define cchNo           (4+4)
#define chAccelNo       'N'

#define szCancel        "Abbrechen"
#define cchCancel       9
/* chAccelCancel no accelerator */

#define szRetry         "Wiederholen"
#define cchRetry        11
#define chAccelRetry    'W'

#define szAbort         "Abbrechen"
#define cchAbort        9
#define chAccelAbort    'A'

#ifdef HELP_BUTTON
#define szHelp          "Hilfe"
#define cchHelp         (5+2)
#define chAccelHelp     'H'
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbitn\strings\itl.h ===
/*
	COW : Character Oriented Windows

	itl.h   : Internationalization header

	This contains strings for use in QBASIC dialog boxes.

	You have a string in quotes, followed by its length +
	the total number of spaces to have on each side of
	the string.

	eg. "OK" is 2 long, the 4 means put 4/2=2 spaces on
		 each side of the word when it is being displayed.
		 make sure you leave the brackets around the numbers
		 ie, 2+4 is incorrect, (2+4) is correct.

	Some also have their hotkey following the key and the
	size, make sure that you leave the single qutoes (')
	around these characters.

	You may have to make some adjustments to the .des files
	when you have changed this file.

	eg, say you translate "OK" to "Okay", then the size
	might go to (4+4), or whatever you want.
	Then you would go to the .des files.
	lines with the following would have to be modified:

	OK_BUTTON AT (col, row, 6, 1) ACT...........
				^

	to

	OK_BUTTON AT (col, row, 8, 1) ACT...........
				^

*/


#define szOk            "OK"
#define cchOk           (2+0)
/* chAccelOk no accelerator */

#define szYes           "S"
#define cchYes          (2+0)
#define chAccelYes      'S'

#define szNo            "No"
#define cchNo           (2+0)
#define chAccelNo       'N'

#define szCancel        "Annulla"
#define cchCancel       7
/* chAccelCancel no accelerator */

#define szRetry         "Riprova"
#define cchRetry        7
#define chAccelRetry    'R'

#define szAbort         "Interrompi"
#define cchAbort        10
#define chAccelAbort    'I'

#ifdef HELP_BUTTON
#define szHelp          "Guida"
#define cchHelp         (5+0)
#define chAccelHelp     'G'
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbpor\strings\intl.inc ===
CCHUNTITLED		EQU 10 ; length of "Untitled" file name string
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbspa\strings\intl.inc ===
CCHUNTITLED		EQU 10 ; length of "Untitled" file name string
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbitn\strings\uinhelp.asm ===
TITLE	uinhelp.asm - utilities for new help engine.
;***
;uinhelp.asm
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	Utilities for the new help system.
;
;
;*******************************************************************************

	.xlist
	include	version.inc
	.list
	UINHELP_ASM = ON


	include cw/version.inc
	include cw/windows.inc
	include cw/edityp.inc

	IncludeOnce architec
	IncludeOnce heap
	Include     help.inc
	IncludeOnce parser
	IncludeOnce prstab
	IncludeOnce rtps
	IncludeOnce qbimsgs
	IncludeOnce ui
	IncludeOnce uiint
	IncludeOnce uimenu		
	IncludeOnce uinhelp		

assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

	subttl	DATA segment definitions.
	page

sBegin	DATA
	externW	iMsgStatusLine		; current status line message
	externW iHelpId 		

; GetHelpMessage and MapLineToContext return codes

	globalB fHelpAlloc,0		; Non-zero if help system is doing
					; a far heap allocation
	BdlTemp	BDL	<>		; temporary BDL owner
	externB	bdlHelp			; BDL for keyword help (def in UIHELP.C)
	externW	szDialogHelpContext	; *sz context of current dialog help


	externB b$Buf1			; FILNAML-sized buffer
	externB b$Buf2			; 16-byte buffer
	HtSpot	EQU	b$Buf2		; Static HotSpot structure

	globalB HelpFlags,0,1		;status of the help system
	globalB HelpFlags2,0,1		;more help system state


;BUFFERING:
;
;   The Help system uses a circular buffer of buffers to hold the
;   text of help messages (called contexts) so that scrolling up
;   and down in a file does not have to be continuously hitting the
;   disk.  The buffers are organized as follows:
;
;	HelpBuffer  : Slot 1 : Slot 2 : Slot 3 : ... : Slot MAX_HELPBUFS :
;
;   Each active slot in the Static HelpBuffer is of type HelpBufType.  The
;   entries in HelpBuffer are organized as a circular list so that they
;   may grow on either end without moving the existing entries.  Each
;   active entry in HelpBuffer represents one context that is currently
;   stored in memory.
;

	staticW oFirstBuf,,1		;Offset of first logical buffer
	staticW oLastBuf,,1		;Offset of last logical buffer
	staticB numBuf,0,1		;number of active buffers in HelpBuffer
	staticB fNoDelBufs,0,1		; are we allowed to delete the
					; buffers during a ShrinkHelp?


	MAX_HELPBUFS	= 9		; Number of entries in HelpBuffer
	BUFSIZE 	= SIZE HelpBufType;The size of the entries in HelpBuffer

	BUFFERSIZE	= MAX_HELPBUFS * BUFSIZE ; Size of HelpBuffer
	staticB	HelpBuffer,0,BUFFERSIZE
	BUFFEREND	EQU (OFFSET DGROUP:HelpBuffer) + (BUFFERSIZE)

	DbPub	HelpBuffer

	globalW iCurRequestLine,UNDEFINED,1 ; line # to get attributes for,
					; or UNDEFINED if no attributes
					; available
	globalW oCurTopic,0,1		; offset to the current topic
					; (0 if no current topic)

	globalW iFileSize,0,1		; Size of current help topic
	externW iStaticHelpTopic	; High word of NC during searches

	externW WndHelp 		; Help Window structure
	externW efHelp			; Editmgr structure for Help Wnd.

;QUEUE MANAGEMENT
;
;  In order to support help history (Ctrl-F1), we keep a LIFO queue
;  of the last 20 items that we requested help on.  The items are stored
;  as a circular list, with a pointer to the next item to be filled in
;  and a count of the number of items that exist.
;
;
;  This list (of type HelpHistEntry) is contained in a BDL, with the first
;  few bytes of the BDL containg a header (type HelpHistHeader) of useful
;  information
;

	BdlHelpHist BDL <>		; BDL for help backup (^F1) list

	ncInitial DD 0			

	HelpHistEntry STRUC
	    HH_HiWord	DW ?
	    HH_LoWord	DW ?
	HelpHistEntry ENDS

	HelpHistHeader STRUC		
	    HH_Used	DW ?		; number of history items in use
	    HH_First	DW ?		; offset into seg of next free item
	HelpHistHeader ENDS		

	NUM_HISTORY	= 20		; number of items that can be saved
	HELPHIST_BEGIN = Size HelpHistHeader  ; offset of first item in segment
	HELPHIST_END   = HELPHIST_BEGIN + NUM_HISTORY * SIZE HelpHistEntry
					; end of the last item

;MAGIC EDIT MANAGER Variables
;
;   The following magic locations in the edit manager are used:
;
;	EfHelp.EF_ipCur_ob     = Current column in help window
;	EfHelp.EF_ipCur_oln    = Current line in help window
;	EfHelp.EF_pdCur_olnTop = Top line of help window
;	EfHelp.EF_pdCur_obleft = Leftmost column of help window
;
;	WndHelp.arcClipping.ayBottomArc, WndHelp.arcClipping.ayTopArc
;		specify the top and bottom of the window.  I believe
;		that they are in screen coordinates.
;
;	One thing to note:  The Edit Manager uses 0 relative coordinates
;	while the helpengine (and variable help) use 1 relative coordinates.
;	Thus, you have to be careful in converting from one to another.
;
;	There are only 2 places that a line or column number is stored:
;	  - Bookmarks (0 relative, as the HelpEngine is not involved)
;	  - iCurRequestLine (1 relative, because it is a HelpEngine line#)
;


;HELP System ENTRY/EXIT conditions
;
;  Anytime that code for the help system is executing, we must have the
;  following conditions met:
;
;	1.)  As close as possible to the point where we could display a
;	     dialog box or message box receiveing ANY input from the user
;	     we must have HLP_INHELP set to prevent recursively entering the
;	     help system.  Currently, this occurs in 2 places:
;		- Displaying "Help File Not Found"
;		- Displaying "INsufficient memory for help system"
;
;	2.)  The help system must be active to the level that is needed to
;	     implement the desired functionality.  There are three levels:
;
;	     a.) Help Engine shut down - No functionality at all possible.
;
;	     b.) Help Engine Active, no current topic.
;		  HLP_GOTBUF is true, but oCurTopic = 0.
;
;	     c.) Help Engine Active, Current topic available.
;
;
;	     The following assumptions and conditions are used in checking
;	     entry conditions:
;
;	     - If the help window is open, we must be at level C.
;	     - If the help window is closed, we may be at A or B.
;	     - If we get a message from the help window, it must be open (C).
;	     - If StartHelp returns 0, you are in either B or C.
;
;	3.)  Any allocation could end up causing CompressHelp to be called.
;	     Thus, there has to be flag set ANYTIME we are in the help system
;	     so that CompressHelp will not yank the help system out from
;	     underneeth itself.  Currenly, there are only 2 entry points
;	     for help:
;		- Help()
;		- HelpWndProc()


sEnd	DATA

	externFP B$IFOUT		; Convert number to string
	externFP HelpOpen		; Misc Help engine routines
	externFP HelpNc
	externFP HelpNcCb
	externFP HelpLook
	externFP HelpDecomp
	externFP HelpXRef
	externFP HelpGetLine
	externFP HelpHlNext
	externFP HelpNcNext
	externFP HelpSzContext
	externFP HelpClose		
	externFP HelpShrink		
	externFP _atoi			; CONSIDE: use runtime call for this
	externFP fEditorActive		
	externFP fQhelpActive



sBegin	UI
assumes CS,UI

	staticB szHelpFileEdit,<"EDIT.HLP",0>	; main help file name
	staticB szHelpFileQhelp,<"HELP.HLP",0>	; qhelp help file name
	staticB szHelpFileInterp,<"QBASIC.HLP",0> ; second help file name

	externNP MoveCursorPwndCur	; Move cursor of current window
	externNP MoveCursorPwnd 	; Move cursor of specified window
	externNP WndHelpOpen		; Open help window to a given size
	externNP WndHelpClose		; Close the help window
	externNP SetHelpKeyword		; put keyword into help syntax menu

	externNP HelpBack		

	subttl	Main Help EntryPoints
	page


;***
;KeywordHelp : Display help for a keyword
;
;Purpose:
;	This routine implements SHIFT-F1.  If the cursor is on a keyword
;	in a window, then display help for this keyword in the help window
;	(opening it if needed). If there is no text selected, or it is
;	not a keyword, then return a non-zero value to indicate that F1
;	should be done.
;
;Entry:
;	None.
;
;Exit:
;	None
;
;Uses:
;	AX,BX,CX,DX
;
;****

cProc	KeywordHelp,<NEAR,PUBLIC>,<SI>	
cBegin
	cCall	StartHelp		; make sure we have the help system
	or	ax,ax			; did we succeed?
	jne	KeywordHelpExit 	; no, just return

	cCall	KeywordHelpLookup	; AX = length of current keyword
					; (text placed in bufStdMsg)
	or	ax,ax			; is there a current keyword?
	jne	CurKeyword		; brif so
Moo:
	cCall	CowMoo			; -- beep speaker & return
	jmp	short KeywordHelpExit	
CurKeyword:

	DbChk	HoldBuf1		; grab B$Buf1

	mov	ax,offset dgroup:bufStdMsg ; where the topic was placed
	mov	bx,offset dgroup:B$Buf1 ; new home for the topic string
	push	bx			; param to DisplayHlpWndSz

	cCall	fstrcpy2,<DS,bx,DS,ax>	


	cCall	DisplayHlpWndSz 	; try to display the help

	DbChk	FreeBuf1		; release the buffer

	or	al,al			; Did we succeed with engine hlp
	je	KeywordHelpExit_Ok	; yes, exit.

	test	al,HELP_HANDLED 	; have we displayed anything to
					; the user?
	jnz	KeywordHelpExit 	; yes, just exit
	jmp	short Moo		; otherwise tell user about it

KeywordHelpExit_Ok:
	mov	[uierr],0		; clear any leftover errors
KeywordHelpExit:
cEnd

;***
;KeywordHelpLookup : Find help for a keyword
;
;Purpose:
;	Added with revision [5].
;
;	Looks up the keyword, enables/disables the HelpSyntax menu item, and
;	puts the keyword into the HelpSyntax menu item.
;
;Entry:
;	None.
;
;Exit:
;	AX : =0 if no keyword was found
;	    length of keyword (NZ) if keyword was found
;Uses:
;	AX,BX,CX,DX
;
;****

cProc	KeywordHelpLookup,<NEAR,PUBLIC>
cBegin

	mov	ax,offset dgroup:bufStdMsg
	mov	bx,10			; maximum length of word  (10 is magic)
	mov	cx,GEW_HELPMASK 	; do not include . or ! in search
	cCall	GetEditWordMask,<ax,bx,cx> ; AX = length of word retrieved
	push	ax			; save for return value

	; enable/disable help syntax menu item based on AX (0 ==> disable)
	or	ax,ax			; if NZ, set low bit for stupid-ass
	jz	disableit		; COW C function
	mov	al,1
disableit:
	mov	bx,midHelpSyntax
	cCall	EnableMenuItem,<bx,ax>

	; copy current topic name into help syntax menu buffer
	mov	ax,offset dgroup:bufStdMsg
	cCall	SetHelpKeyword,<ax>

	pop	ax			; return AX = length of keyword
cEnd



;***
;SelectHotLink - Go to the hot link that is specified in the window coords
;
;Purpose:
;	Look in the help file given by the line number and column
;	number.  If there is a hot link at this position, go to the item
;	that it links to.  Otherwise, just returns.
;
;Entry:
;	(rx,ry) - virtual line coordinates of the location of a
;		  supposive hot spot.
;	beep	- TRUE if we are suspose to beep when we don't find anything
;
;Exit:
;	AX = 0 (FALSE) if a hot link was selected
;
;Uses:
;	Per Convention
;****

cProc	SelectHotLink,<PUBLIC,NEAR>,<SI,DI>
parmW	rx
parmW	ry
parmB	GiveBeep
cBegin

	;Since we got a keyboard message from the help window, it must be
	;open, therefor we must be initialized.

	DbAssertTst HelpFlags,ne,HLP_GOTBUF,UI,<SelectHotLink:Buffers Not Initialized>


	DbChk	HoldBuf2		; lock down the HotSpot
	DbChk	HoldBuf1		; for composed hotlink names

	mov	bx,oCurTopic		; get ptr to topic
	lea	bx,[bx].bdlHelpText.BDL_seg ; BX = handle to data seg
	mov	cx,rx
	inc	cx			; make column 1 relative
	mov	HtSpot.colHS,cx 	
	mov	cx,ry			; get line number
	inc	cx			; make it 1 relative
	mov	HtSpot.lineHS,cx	; and stick in HotSpot structure
	mov	ax,OFFSET DGROUP:HtSpot
	xor	cx,cx
	and	HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM) ; clear errors
	cCall	HelpXRef,<BX,CX,DS,AX>	;Get context string for topic
	or	ax,ax			; did we get a topic
	jnz	GotSelection		; yes, go display it
	test	HelpFlags,HLP_FAILFNF OR HLP_FAILOOM ; is error handled?
	jnz	NoBeep			; yes, do not beep
SelectHotLink_Beep:
	cmp	GiveBeep,0		; should we give a beep?
	je	NoBeep			; no, just exit with error code
	cCall	CowMoo			; beep cow's speaker
NoBeep:
	mov	ax,sp			; return with non-zero value
	DbChk	FreeBuf2		; release the HotSpot
	DbChk	FreeBuf1		;  and our other buffer
	jmp	short NoSelection	; and exit

GotSelection:
	;Copy context string into free part of Buf2 and display it in a help
	;window. The source string is in HtSpot.pXrefHS and is 0 terminated
	;We can not use the source directly, as it points into a BDL, and
	;we are not guarenteing a locked heap.

	push	ds				; set ES = DS = DGROUP
	pop	es				
	mov	di,offset dgroup:b$buf1 	; ES:DI = destination
	push	di				; parm for DislplayHlpWnd
	lds	si,DWord Ptr HtSpot.pXrefHS	; DS:SI = source

CopyLoop:
	lodsb					; copy the byte
	stosb					
	or	al,al				; is it the 0 termiantor
	jne	CopyLoop			; no, do next byte
	lodsw					; Copy next word
	stosw					; incase it was local

	push	es				; restore DGROUP
	pop	ds				

	DbChk	FreeBuf2			; release the HotSpot

	; Check to see if the context is !B.  If it is, then we should
	; execute a HelpBack command instead of displaying the context

	cmp	WORD PTR b$Buf1,'B!'		; is it !B?
	jne	NotHelpBack			; no, go display it
	cmp	BYTE PTR b$Buf1+2,0		; is it 0 terminated?
	jne	NotHelpBack			; no, go display it
DbAssertRel	pwndAct,e,<OFFSET DGROUP:wndHelp>,UI,<SelectHotLink:Not in help window>
	pop	ax				; restore stack (param to
						;  DisplayHlpwndSz not used)
	xor	ax,ax				; move to (0,0) so we will
	cCall	MoveCursorPwndCur,<ax,ax>	; goto previous topic
	DbChk	FreeBuf1			; incase HelpBack wants it
	call	HelpBack			; do the help back
	jmp	short ExitSuccess		; and exit

NotHelpBack:
	cCall	DisplayHlpWndSz 		; display text
DbAssertRelB	al,ne,HELP_NF,UI,<SelectHotLink:Returned hot link not found>
						;ignore any errors
	DbChk	FreeBuf1			; release context string

ExitSuccess:
	xor	ax,ax				; return value of success
						; this way we will not put
						; up an error box, then
						; do something useful.
NoSelection:

cEnd



;Rewrote with [5]
;***
;FillContextNext - Fill the next buffer with the desired context information
;
;Purpose:
;	Read a help context into the help buffer given the position that
;	is previous to it.  The information needed for the new context
;	is obtained from the context given.  This routine will read in
;	as many contexts as desired.
;
;	Note: this routine does not return any errors, as its caller
;	does not check the error code (this is used to fill the buffer
;	with topics after the current topic, so if we could not read
;	in a topic for any reason, then we will just leave the buffer
;	partially empty).
;
;Entry:
;	BX = current buffer
;	DI = number of context to read
;
;Exit:
;	oLastBuf = Last valid buffer
;	numBuf updated
;
;****

cProc	FillContextNext,<NEAR>,<DI>
cBegin

DbAssertRelB	fNoDelBufs,ne,0,UI,<FillContextNext:Caller did not set fNoDelBufs>


cEnd


;Added with [5]
;***
;GetHelpMsgNcFill - get a help message from a context number, fill in fields
;
;Purpose:
;	Calls GetHelpMsgNc, and fills in all the fields of the buffer except
;	for the first line number of the context.
;
;Entry:
;	DX:AX = context number to be filled in
;	BX = ptr to context
;Exit:
;	if (AL = 0)
;	    BX = ptr to context
;	    all fields of context are filled in
;	else
;	    AL = HELP_HANDLED.
;
;****
cProc	GetHelpMsgNcFill,<NEAR>
cBegin
	push	bx				; We need to preserve BX
	mov	Word Ptr [bx].ContextNum,ax	; save Context Num in Buffer
	mov	Word Ptr [bx].ContextNum+2,dx
	lea	cx,[bx].bdlHelpText		; point to BLD
	cCall	GetHelpMsgNc,<dx,ax,cx> 	; get message
						; (AL = return code)
	pop	bx				; BX = *Buffer

Fill_Exit:
cEnd

;***
;GetHelpMsgSz - get a help message from a context string
;GetHelpMsgNc - get a help message from a context number
;
;Purpose:
;	This routine calls the help engine to obtain the help text
;	associated with a context string.  The text is returned in a BDL.
;	No buffering of the help context is performed.
;
;	NOTE: Does not require oFirstBuf or oLastBuf to be set.
;
;Entry:
;	szContext : pointer to context string
;	BdlText : pointer to bdl owner structure.
;
;Exit:
;	AL = HELP_OK (0) if success.
;	AL = HELP_HANDLED, HELP_NF
;
;Uses:
;	Per convention
;
;Exceptions:
;	
;****
cProc	GetHelpMsgSz,<NEAR,PUBLIC>
parmW	szContext
parmW	BdlText
cBegin
DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<GetHelpMsgSz:HLP_GOTBUF false>
	mov	ax,szContext		; AX = context string
	cCall	CalcNc,<AX>		; DX:AX = nc for context string
	jcxz	GetHelpMsgSzExit	; return with error code (AL) if error

	cCall	GetHelpMsgNc,<DX,AX,BdlText> ; get message
GetHelpMsgSzExit:
cEnd

DbPub	GetHelpMsgNc
cProc	GetHelpMsgNc,<NEAR>,<SI,DI>
parmW	ncHigh
parmW	ncLow
parmW	BdlText
cBegin
DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<GetHelpMsgNc:HLP_GOTBUF false>
DbAssertRelB	fHelpAlloc,ne,0,UI,<GetHelpMsgNc:fHelpAlloc not set>

	mov	di,ncHigh		;set DI:SI to context string
	mov	si,ncLow

	and	HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM) ; clear flags

	cCall	HelpNcCb,<DI,SI>	; AX = #bytes for decompressed topic

	xchg	ax,cx					; save size in CX
	test	HelpFlags,HLP_FAILFNF OR HLP_FAILOOM	; did we fail it?
	mov	al,HELP_HANDLED 			; assume so
	jnz	GetHelpMsgNcExit_Near			; exit if error

	mov	bx,offset DGROUP:BdlTemp
	cCall	BdlAlloc,<BX,CX>	; alloc bdl for compressed data
	or	ax,ax			; OOM error?
	jz	GetHelpMsgOOM		; yes, go handle it

	lea	bx,[BdlTemp.BDL_seg]	; BX = handle to data segment
	xor	ax,ax			; offset 0
	cCall	HelpLook,<DI,SI,BX,AX>	; AX = # bytes uncompressed
	xchg	cx,ax			; CX = # bytes uncompressed
	jcxz	FreeExitError		; brif error -- release bdl & exit

	inc	fNoDelBufs		; don't delete buffers

	mov	bx,BdlText		; bx = *BDL owner
	cCall	BdlAlloc,<BX, CX>	; alloc BDL for uncompressed data
	or	ax,ax			; ZF ==> error
	jnz	DecompressHelp		; no error, go decompress help topic
	cCall	GiveHelpOOM		; generate OOM error
	dec	fNoDelBufs		; restore buffer flag
	jmp	short FreeExitError	; free Bdl and exit

GetHelpMsgOOM:
	cCall	GiveHelpOOM		; signal an OOM error
	mov	al,HELP_HANDLED 	
GetHelpMsgNcExit_Near:			
	jmp	Short GetHelpMsgNcExit	; brif so -- give error and exit

DecompressHelp:
DbAssertTst	HelpFlags,z,HLP_NOSHRINK,UI,<GetHelpMsgNc:NOSHRINK set>
	or	HelpFlags,HLP_NOSHRINK	; don't shrink during HelpDecomp
					; otherwise it will fail.
	mov	bx,BdlText		; bx = *BDL owner (could have moved)
	xor	ax,ax			; offset 0
	lea	dx,[BX].BDL_seg 	; DX = handle of destination seg
	lea	bx,[BdlTemp.BDL_seg]	; BX = handle of source segment
	cCall	HelpDecomp,<BX,AX,DX,AX,DI,SI>
					; decompress help text
	dec	fNoDelBufs		; reset buffer delete flag
	and	HelpFlags,NOT HLP_NOSHRINK ; reenable shrinking.

	or	ax,ax			; did we get an error?
	jz	FreeExit		; no, free temp BDL and exit
	mov	ax,BdlText		; get pointer to bdl
	cCall	BdlFree,<AX>		; and deallocate it

	test	HelpFlags,HLP_FAILOOM or HLP_FAILFNF ; have we reported?
	jnz	FreeExitError		; yes, get return code
	cCall	GiveHelpOOM		; report the error.

FreeExitError:
	mov	al,HELP_HANDLED 	; prepare to return error

FreeExit:
	push	ax			; save return code
	mov	ax,OFFSET DGROUP:BdlTemp
	cCall	BdlFree,<AX>		; release compressed data

	pop	ax			; AX = return code (NZ ==> success)

GetHelpMsgNcExit:

cEnd


	subttl	Display Text in the Help Window

;Rewrote with [5]
;***
;DisplayHlpWndSz - Display help in a window given a context string
;DisplayHlpWndNc - Display help in a window given a context number
;
;Purpose:
;	Displays a context in the help window given either a context
;	string (DisplayHlpWndSz) or a context number (DisplayHlpWndNc).
;	This routine will open the help window if it is not already
;	opened.
;
;Entry:
;	szContext : pointer to a context string  (DisplayHlpWndSz)
;			   or
;	DX:AX	  : context number		 (DisplayHlpWndNc)
;
;Exit:
;	AL = error code (HELP_OK, HELP_HANDLED, HELP_NF)
;
;Uses:
;	Per Convention
;
;****

cProc	DisplayHlpWndSz,<PUBLIC,NEAR>
parmW	szContext
cBegin

DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<DisplayHlpWndSz:HLP_GOTBUF false>

	mov	ax,szContext		;AX = context string
	cCall	CalcNc,<AX>		; DX:AX = nc for context string
	jcxz	HlpWndSzExit		; there was an error, exit
	cCall	DisplayHlpWndNc 	;display help for this context number

HlpWndSzExit:				;AL = return code
cEnd


cProc	DisplayHlpWndNc,<PUBLIC,NEAR>
cBegin

DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<DisplayHlpWndNc:HLP_GOTBUF false>

	cCall	BufferNc		; BX = ptr to new context
	or	al,al			; was there an error?
	jne	DisplayFailure		; yes, exit with error code

	push	bx			; save buffer pointer
	mov	dx,Word Ptr [bx].ContextNum+2  ; Get context number into
	mov	ax,Word Ptr [bx].ContextNum    ;  DX:AX
	cCall	RecordHelpHistory	; record context number for Ctrl-F1
	pop	bx			; restore buffer pointer

	lea	ax,[bx].bdlHelpText	
	push	ax			; save for call to GetHelpContextLen
	cCall	SizeHelpContext,<ax>	; get # lines in the help topic
					; sets iFileSize
	cCall	GetHelpContextLen	; AX = get suggested size of wnd
	cCall	OpenHelpWindow		; go open the window (to size AX)
	cCall	DrawDebugScr		; force help title to be redrawn

	xor	ax,ax			; return 0 for no-errors

DisplayFailure:
	cCall	CloseCurHelpFile	; shut down current help file, if
					; any opened. (preserves AX, DX)
cEnd




;***
;BufferNc - Given a context number, properly buffer in context
;
;Purpose:
;	This routine will refill the help buffer so that Nc is
;	present.  If Nc did not exist, the buffer is flushed and
;	refilled.
;
;Entry:
;	DX:AX	: Context number to be buffered
;
;Exit:
;	if (successful)
;		AL = HELP_OK  (=0)
;		BX = new buffer ptr
;		numBuf updated
;		oCurTopic = BX
;	else
;		AL = HELP_HANDLED
;
;****
cProc	BufferNc,<PUBLIC,NEAR>,<DI>
cBegin

	;See if the context number is already buffered

	xor	cx,cx
	mov	cl,numBuf		; scan numBuf contexts
	jcxz	DelNoBufs		; special case this...LOOP can't
	mov	bx,oFirstBuf		; Start at first context
CheckNext:
	cmp	ax,Word Ptr [bx].ContextNum ; check low word first
	jne	TryToLoop		; comparison failed, goto next one
	cmp	dx,Word Ptr [bx].ContextNum+2 ; check high word
	jne	TryToLoop		; comparison failed, goto next one
	jmp	FoundMatch		; we have the context already buffered
TryToLoop:
	add	bx,BUFSIZE		; move to next logical buffer
	cmp	bx,BUFFEREND		; did we go off the end?
	jb	Wrap5			; no, continue
	sub	bx,BUFFERSIZE		; adjust back to begining
Wrap5:
	loop	CheckNext		; try the next context

NotBuffered:

	
	; # buffers to free = # needed - # free
	;		    = MAX_HELPBUFS / 2 - (MAX_HELPBUFS - numBufs)
	;		    = numBufs - (MAX_HELPBUFS / 2)
	
	mov	cl,numBuf		; Calculate # buffers to delete
	sub	cl,MAX_HELPBUFS /2	
	ja	DelSomeBufs		; brif a positive number
	xor	cl,cl			; delete 0 buffers (makes
DelSomeBufs:				; oCurTopic == oLastTopic)
	xor	ch,ch			; CBW for CX
	push	ax			; save the context number
	push	dx
	call	FlushBuffer		; delete CX current contexts
	pop	dx			; restores context number
	pop	ax

DelNoBufs:
DbAssertRelB	numBuf,be,MAX_HELPBUFS,UI,<BufferNc: No buffers free after deleting some>

	mov	bx,oLastBuf		; Ptr to last buffer used
	cmp	numBuf,0		; stupid special case?
	jne	UseoLastBuf		; no, index off of oLastBuf
	mov	oFirstBuf,bx		; oFirstBuf = oLastBuf
	jmp	short NoWrap6		
UseoLastBuf:
	add	bx,BUFSIZE		; point to the next one
	cmp	bx,BUFFEREND		; did we go off the end?
	jb	NoWrap6 		
	sub	bx,BUFFERSIZE		
NoWrap6:
	cCall	GetHelpMsgNcFill	; get the help topic
	or	al,al			; any errors?
	jne	BufferNc_Exit		; yes, exit with error code

	inc	numBuf			; indicate one more buf in use

	;Fill the rest of the buffer with contexts after this one

	inc	fNoDelBufs		; do not delete buffers to get these
	mov	ax,MAX_HELPBUFS
	sub	al,numBuf		; AX = number of buffers free
	push	bx			; save it for exit
	xchg	di,ax			; set DI = number of free buffers

	mov	oLastBuf,bx		;set oLastBuf = last legal buffer

FillAnotherNext:
	mov	dx,Word Ptr [bx].ContextNum+2 ; DX:AX = current NC
	mov	ax,Word Ptr [bx].ContextNum
	push	bx
	cCall	GetNextNc		
	pop	bx
	je	FillContextDone 	; no more contexts

	add	bx,BUFSIZE		;Point BX at next buffer
	cmp	bx,BUFFEREND		; did we go off end of buffer?
	jb	NoWrap3 		;no, continue
	sub	bx,BUFFERSIZE		;wrap around to begining
NoWrap3:
	cCall	GetHelpMsgNcFill	;get message DX:AX into *(BX)
	or	al,al			; did an error occur
	jne	FillContextDone 	; yes, stop filling in buffers

	mov	oLastBuf,bx		; set oLastBuf = last legal buffer
	inc	numBuf			;record that a buffer is now in uses
	dec	di			;one more context use
	jne	FillAnotherNext 	;get another one if allowed
FillContextDone:

	;Ignore any errors, we have at least one buffer
	mov	uierr,0 		; clear any errors
	pop	bx			; pointer to buffer with our context

	dec	fNoDelBufs		; reset buffer delete pointer

FoundMatch:
	xor	ax,ax			; ax = 0 (no errors)
	mov	oCurTopic,bx		; update current buffer ptr.

BufferNc_Exit:
cEnd

;Rewrote with [45]
;***
;OpenHelpWindow - Open the help window and ready it to print text
;
;Purpose:
;	This routine will not only open the help window to the correct
;	size, but will adjust the size of the window to account
;	for the existance/non existance of the scroll bar.
;
;Entry:
;     ax = Size of window
;
;Exit:
;     None.
;****

DbPub OpenHelpWindow
cProc OpenHelpWindow,<NEAR>
cBegin
	cmp	pwndAct,OFFSET DGROUP:WndHelp ; in help window?
	je	InHelpWindow		; no, do not resize

	inc	ax			; add a line for scroll bar
InHelpWindow:
	cCall	WndHelpOpen,<AX>	; AX = actual size of window

	; We must always move the cursor to (0,0), otherwise the edit
	; manager may not realize that this is a new topic and would not
	; position it so that the first line is visible.

	xor	bx,bx			; cursor position is 0,0
	mov	ax,OFFSET DGROUP:wndHelp; window to receive the message
	push	ax			; save for second call
	cCall	MoveCursorPwnd,<AX,BX,BX> ; goto 0,0 in window

	cCall	GetInitialPos		; get initial position on screen

	cCall	MoveCursorPwnd,<DX,AX>	; goto hot link spot
cEnd

;***
;GetInitialPos - Calculate the initial cursor position in the help window
;
;Purpose:
;	Returns the initial cursor position in the help window.  This is
;	the (0 relative) coordinates of the first hot link (if it exists
;	and is visible), or (0,0).
;
;Entry:
;	None
;
;Exit:
;	(DX,AX) - initial Row/Column of the screen (0,0) or first hot spot
;
;Uses:
;	Per C Convention.
;****
cProc	GetInitialPos,<PUBLIC,NEAR>
cBegin
	DbChk	HoldBuf2		; lock down the hotspot

	test	HelpFlags,HLP_VARHELP	; are we in var help?
	jnz	Use00			; yes, there are no hotlinks

	mov	ax,1			; current row/column position
	mov	HtSpot.ColHS,ax 	
	mov	HtSpot.lineHS,ax	

DbAssertRel	oCurTopic,ne,0,UI,<GetInitialPos:oCurTopic invalid>
	mov	bx,oCurTopic
	lea	bx,[bx].bdlHelpText.BDL_seg
	mov	cx,OFFSET DGROUP:HtSpot
	dec	ax			; ax = 0
	cCall	HelpHlNext,<AX,BX,AX,DS,CX>
	or	ax,ax			; did we get a hot link?
	je	Use00			; no, use (0,0) as position
	mov	ax,HtSpot.ColHS 	; get position of hotlink
	mov	dx,HtSpot.lineHS	
	dec	dx			; make position 0 relative
	dec	ax
	
	; Make sure the hot link is visible.
	
	mov	cl,WndHelp.arcClipping.ayBottomArc
	sub	cl,WndHelp.arcClipping.ayTopArc ; CX = size of help window

	cmp	cl,dl			; within visible range?
	jae	GetInitialPos_Exit	; no, ignore the hotlink
Use00:
	xor	dx,dx
	xor	ax,ax

GetInitialPos_Exit:
	DbChk	FreeBuf2		; release HotSpot
cEnd

	subttl	Edit Manager Support Routines
	page



;Extracted and modified with revision [29].
;***
;GetHelpTitleStr - Returns the title for a given help topic
;
;Purpose:
;	Calculates the title, and returns it in bufStdMsg.
;	All titles are prefixed by "HELP: ".
;
;	Uses the ":n" information if the help file, if it exists.
;	Otherwise, returns the current context string.
;
;Entry:
;	pHelpBdl = *bdl containing decompressed help topic.
;	cbMaxSize = max title length allowed
;
;	If window help, curNc is the help context #
;	If dialog box help, szDialogHelpContext points to the current szContext
;
;Exit:
;	AX = number of characters in title
;	bufStdMsg = contains title.
;
;Uses:
;	Per Convention
;
;****
cProc	GetHelpTitleStr,<NEAR,PUBLIC>,<SI,DI>
parmW	pHelpBdl
parmW	cbMaxSize
cBegin

DbAssertTst	HelpFlags,nz,HLP_GOTBUF,UI,<GetHelpTitleStr:HLP_GOTBUF false>

	inc	fNoDelBufs		; do not delete buffers, we have
					; a generic ptr to a buffer

	; Setting fNoDelBufs is probably not needed as currently
	; pHelpBdl points to either oCurTopic or to a static
	; Bdl used by dialog help.	However, I doubt that we do any
	; allocs in this code, and I can not guarentee that pHelpBdl
	; is safe.


	mov	ax,MSG_HelpTitleQH	; first part of title ("MS-DOS Help: ")
	test	cmdSwitches,CMD_SW_QHELP ; /QHELP viewer?
	jnz	ghts1			;   YES, got title

	mov	ax,MSG_HelpTitle	; first part of title ("HELP: ")
ghts1:
	cCall	ListStdMsg,<AX> 	; put in bufStdMsg

	push	ax			; save length of static portion
	add	ax,OFFSET DGROUP:bufStdMsg ; ds:di = useful buffer
	xchg	di,ax
	mov	al,'n'			; look for ":nTITLE"
	cCall	GetHelpControlInfo,<pHelpBdl,cbMaxSize,ax> ; SI = *embedded title, if any
	or	si,si			; title found?
	jnz	AppendTitle		; brif so

	mov	si,szDialogHelpContext	; use current context string as title
					; for dialog box help
	cmp	pHelpBdl,offset DGROUP:bdlHelp	; title for dialog box help?
	je	AppendTitle		; brif so -- append string to title

	mov	bx,oCurTopic		; ptr to current topic data
	or	bx,bx			; is it valid?
	je	GetHelpTitleStr_Fail	; no, use MSG_HelpTitle for now

	push	ds			;push far address to load szContext
	push	di
	push	Word Ptr [bx].ContextNum+2 ; push context number
	push	Word Ptr [bx].ContextNum
	cCall	HelpSzContext		;Get text
	or	ax,ax			; did we succeed?
	je	GetHelpTitleStr_Fail	; no, exit with error

	;Strip off the filename at the begining of the context

	cCall	szSrchExcl,<di> 	; search for '!' in *di
	DbAssertRel ax,ne,0,UI,<GetHelpTitleStr: Illegal string from HelpSzContext>
	inc	ax			; point to chr beyond '!'
	xchg	si,ax			;di = *buffer, si = *szContext

AppendTitle:				; append title to bufStdMsg
					; DS:SI= *title
					; DS:DI= where to put it

	pop	bx			; BX = length of static portion
	push	ds			; ES = DS for string ops
	pop	es			

AnotherChar:				
	lodsb				; append szTitle to "HELP:" in
	stosb				; bufStdMsg
	inc	bx			; seen another char
	or	al,al			; more chars to do?
	jnz	AnotherChar		; brif so
	dec	bx			; don't  include NULL in count

	cmp	bx,cbMaxSize		; is it larger than we want to return
	jbe	GetHelpTitleStr_Exit	; no, exit
	mov	bx,cbMaxSize-1		; return maximum size (without NULL)
	mov	byte ptr [bufstdMsg+bx+1],al ; truncate the string

GetHelpTitleStr_Exit:			
	xchg	ax,bx			; return count in AX

	SKIP1_PSW			; skip the pop ax
GetHelpTitleStr_Fail:			
	pop	ax			; get length in case of error
	dec	fNoDelBufs		; reenable buffer deletes.
	DbAssertRel ax,be,cbMaxSize,UI,<GetHelpTitleStr: title too big>
cEnd

;Added with revision [29].
;***
;GetHelpContextLen - Returns the length to use for a given help topic
;
;Purpose:
;	Returns the suggested # lines to use to display a topic.
;	Uses ":lLENGTH" if it exists. Otherwise, returns the total # lines
;	in the topic.
;
;Entry:
;	pHelpBdl = *bdl containing decompressed help topic.
;
;Exit:
;	AX = number of lines to use
;
;Uses:
;	Per Convention
;
;****
cProc	GetHelpContextLen,<NEAR,PUBLIC>,<SI,DI>
parmW	pHelpBdl
cBegin
	inc	fNoDelBufs		; do not delete buffers, we have
					; a generic ptr to a buffer

	; Setting fNoDelBufs is probably not needed as currently
	; pHelpBdl points to either oCurTopic or to a static
	; Bdl used by dialog help.	However, I doubt that we do any
	; allocs in this code, and I can not guarentee that pHelpBdl
	; is safe.

	mov	di,OFFSET DGROUP:bufStdMsg ; ds:di = useful buffer
	mov	cx,6			; max len we care about
	mov	al,'l'			; look for ":l<LENGTH>"
	cCall	GetHelpControlInfo,<pHelpBdl,cx,ax> ; SI = *embedded len,
	or	si,si			; length found?
	jz	GetTotalLines		; brif not -- get the line count

	push	si			; arg on stack
	call	_atoi			; AX = result
	pop	bx			; clean stack (C calling conventions)
	jmp	SHORT GetHelpContextLen_Exit

GetTotalLines:
	cCall	SizeHelpContext,<pHelpBdl> ;AX = # lines in context
					; sets iFileSize

GetHelpContextLen_Exit:
	dec	fNoDelBufs		 ; reenable buffer deletes.
cEnd


;Extracted and modified with revision [29].
;***
;GetHelpControlInfo
;
;Purpose:
;	Returns the control information in a given help context, if any.
;
;Entry:
;	pHelpBdl = * bdl containing decompressed help topic
;	cbMaxSize = biggest line to get.
;	cChar = control char to look for (usually 'n' or 'l').
;
;	DS:DI = * place to put result
;
;Exit:
;	DS:SI = * embedded help control info
;
;Uses:
;	Per convention, plus SI
;****

cProc	GetHelpControlInfo,<NEAR>
parmW	pHelpBdl		; * bdl of current help context
parmW	cbMaxSize		; biggest string allowed
parmW	cChar			; control char to search for (l or n)
cBegin

DbAssertRelB	fNoDelBufs,ne,0,UI,<GetHelpControlInfo:fNoDelBufs not set>

	; This routine does not have to worry about error handling for
	; HelpGetLine.	If there is any error in trying to get the
	; proper line, we will just assume that there were no more
	; lines.

	mov	bx,pHelpBdl	; BX = *bdl of current help topic

	GETSEG	es,[bx].BDL_seg,bx,SIZE	; ES = context data segment
	mov	ax,-1			; AX = undefined for blasting help
	mov	es:[lnCurTH],ax 	; reset current line counter
					; so engine doesn't get confused
	xchg	es:[linCharTH],al	; don't ignore any lines
	push	ax			; save line rejection char

	xor	si,si			; start at line 0

AnotherLine:
	inc	si			; advance to next line
	lea	bx,[bx].BDL_seg 	; BX = handle of data segment
	xor	ax,ax			; AX = context data offset (0)
	cCall	HelpGetLine,<si,cbMaxSize,ds,di,bx,ax>
	mov	bx,pHelpBdl		; BX = *bdl of current help topic
	or	ax,ax			; any more lines?
	jz	NoEmbeddedInfo		; brif not
	mov	ax,[di]			; AX = first 2 chars
	cmp	al,':'			; ":" command?
	jne	NoEmbeddedInfo		; brif not -- they must come first
	cmp	ah,byte ptr (cChar)	; the one we are searching for?
	jne	AnotherLine		; brif not -- get another line

	mov	si,di			; DS:SI = *szTitle
	inc	si			; skip the ":"
	inc	si			; skip the control char
	SKIP2_PSW			; skip the XOR SI,SI
NoEmbeddedInfo:
	xor	si,si			; no szTitle found
	pop	ax			; restore old line rejection char
	GETSEG	es,[bx].BDL_seg,bx,SIZE ; ES = context data segment
	xchg	es:[linCharTH],al	; restore old line rejection char
DbAssertRel	AX,E,-1,UI,<GetHelpControlInfo: AX should be -1>
	mov	es:[lnCurTH],ax 	; reset current line counter
					; so engine doesn't get confused

cEnd

;***
;SizeHelpContext
;
;Purpose:
;	Added with revision [2].
;
;	Returns total # of lines of help text for a given context, for use
;	in dialog box re-sizing, and scroll bar updating.
;
;
;Entry:
;	bdlText	= * BDL containing a decompressed help context.
;
;Exit:
;	AX = iFileSize = # lines of help text present in this context.
;
;Uses:
;	Per Convention
;
;****

cProc	SizeHelpContext,<PUBLIC,NEAR>,<SI,DI>
ParmW	bdlText
cBegin
	mov	di,bdlText			; DI = *context BDL
	xor	si,si				; SI = count of # lines

Again:
	inc	si				
	mov	cx,offset DGROUP:bufStdMsg	; CX = &dummy sz
	mov	dx,CB_bufStdMsg			; DX = cbMax
	xor	ax,ax				; AX = context data offset (0)
	lea	bx,[di].BDL_seg 		; BX = handle of data seg
	cCall	HelpGetLine,<SI,DX,DS,CX,BX,AX>	
	or	ax,ax				; success?
	jnz	Again				; brif so -- try again

	xchg	ax,si				; AX = # lines + 1
	dec	ax				; return AX = # lines
	mov	iFileSize,ax			; save # lines
cEnd


;***
;CmdHelpClose - Close the help window (from ESC)
;
;Purpose:
;	Close the help window.	Attached to the ESC accelerator.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per C Convention
;
;****

cProc	CmdHelpClose,<PUBLIC,NEAR>
cBegin
	mov	oCurTopic,0		; indicate no valid help
	cCall	WndHelpClose		; close the window
cEnd


	subttl	Miscellanious Help Routines
	page

;***
;GetNextNc	- Advance a NC to the next topic
;
;Purpose:
;	Get the next physical context number given a context num.
;	Will not wrap from one file to another.
;
;Entry:
;	DX:AX = current context number
;
;Exit:
;	if ZF set (zero)
;	   No next topic
;	   CX = 0
;	   AL = error code	(HELP_HANDLED, HELP_NF)
;	else
;	   DX:AX is context number
;	   CX != 0
;
;Uses:
;	Per C Convention
;
;****

cProc	GetNextNc,<PUBLIC,NEAR>
cBegin
	and	HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM); clear errors
	push	dx				; value to compare against
	push	dx				; push current context number
	push	ax
	cCall	HelpNcNext			; get next Context Num
	pop	bx
	cmp	bx,dx				; is it in a different file?
	jne	GetNextNc_Err			; yes, give error
	mov	cx,ax				; check if no more contexts
	or	cx,dx				; NZ & CX != 0 if no error
	jnz	GetNextNC_exit			; exit if success
GetNextNc_Err:
	mov	al,HELP_HANDLED 		; assume handled error
	test	HelpFlags,HLP_FAILFNF OR HLP_FAILOOM ; was it?
	jnz	GetNextNc_Err2			; yes, use this code
	mov	al,HELP_NF			; context not found
GetNextNc_Err2:
	xor	cx,cx				; set CX = 0, ZF
GetNextNc_exit:
cEnd


;***
;CreateContext - convert a number into a context string
;char *(NEAR CreateContext(iContextNumber ))
;
;Purpose:
;	This routine takes a number and an initial character and
;	creates a context string out of it. The context string will
;	be of the form	"-1234" were '-' is the character and "1234"
;	is an ASCII representation of the number.  The string is
;	returned in a static buffer.
;
;	The number must be 0 < iContextNumber < 32768
;
;Entry:
;	iContextNumber : integer which will be remaining digits
;
;Exit:
;	AX = pSz : near pointer to string with results
;
;Uses:
;	AX, BX, CX, DX.
;
;****

cProc	CreateContext,<NEAR,PUBLIC>
	parmW	HelpId			
cBegin
	mov	al,VT_I2		;Format an integer
	lea	bx,HelpId		; BX = ptr to number to format

	DbAssertRel [bx],g,0,UI,<CreateContext: Bad Help ID>

	call	B$IFOUT 		;BX = address of 0 terminated string

	mov	BYTE PTR [bx],PREFIX_MESSAGE ; Replace space with character
					; that belongs in first postion
	xchg	ax,bx			;return *sz in AX
cEnd

;***
;ShrinkHelp - Compress Help system memory usage
;
;Purpose:
;	Reduce the amount of memory that the help system uses without
;	impeeding the functionallity of the help system.
;
;	WARNING!!!
;	    Any time that this routine may be called (i.e. any time an alloc
;	    is done), you must either set fNoDelBufs or guarentee that
;	    numBuf = 0, or guarentee that oCurTopic, oFirstBuf and oLastBuf
;	    are correct.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per C Convention.
;
;****
cProc	ShrinkHelp,<PUBLIC,FAR>
cBegin

	DbHeapMoveOff			; FH callback can't cause movement

	test	HelpFlags,HLP_NOSHRINK	; are we allowed to call HelpShrink?
	jnz	NoHelpShrink		; no, check for deleting buffers
	cCall	HelpShrink		; Tell help engine to shrink down
NoHelpShrink:


	cmp	fNoDelBufs,0		; Can we delete help buffers also?
	jnz	ShrinkHelp_Exit 	; no, just return

	xor	cx,cx
	mov	cl,numBuf		; cx = # buffers in use
	jcxz	ShrinkHelp_Exit 	; exit if there are none
	cmp	oCurTopic,0		; do we have a current topic?
	jz	NoCurrentTopic		; no, do not keep it in memory
	dec	cx			; do not delete the current topic
NoCurrentTopic:
	cCall	FlushBuffer		; delete CX buffers
ShrinkHelp_Exit:


	DbHeapMoveOn			; remove our lock on the heap
cEnd

;***
;CompressHelp - Close down the help system
;
;Purpose:
;	This routine is called before we execute any user code so that
;	the help system can release all the memory that it does not need.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	AX,BX,CX,DX
;
;Preserves:
;	ES
;****

cProc	CompressHelp,<PUBLIC,FAR>,<ES>	
cBegin
	DbHeapMoveOff			; we are called from FHAlloc
					; not allowed to move heaps

	test	HelpFlags,HLP_GOTBUF	; Help system started?
	jz	NoFreeHelpBuffer	; brif not -- nothing to do

	cmp	fHelpAlloc,0		; doing a help alloc?
	jnz	NoFreeHelpBuffer	; yes, do not shut down help system

	xor	ax,ax			; Nc of 0 => close all files
	cCall	HelpClose,<AX,AX>	; Shut down the help engine

	; we will ignore any file errors on the close


	cCall	DiscardHelpBookMarks	; free bookmark ptrs into help


NoHelpBuffer:
	xor	ax,ax			; get a convenient 0
	mov	iStaticHelpTopic,ax	; clear current search topic
	mov	oCurTopic,ax		; clear current topic ptr.
	mov	iCurRequestLine,ax	; clear GetHelpLine succeeded flag

	; zero the initial context number
	mov	WORD PTR ncInitial,ax	
	mov	WORD PTR ncInitial+2,ax

	or	HelpFlags,HLP_COMPRESS	; flag help has been compressed
	cCall	DrawDebugScr		; make sure screen is redrawn.

DbAssertRel	BdlHelpHist.BDL_Seg,ne,UNDEFINED,UI,<CompressHelp:HLP_GOTBUF is true, but no HistoryBuf Allocated>
	PUSHI	ax,<OFFSET DGROUP:BdlHelpHist>	; Free up the history buf
	cCall	BdlFree 		
	mov	cl,numBuf		; number of buffers to deallocate
	xor	ch,ch			
	cCall	FlushBuffer		; Delete all the help buffers
	and	HelpFlags,NOT HLP_GOTBUF ; indicate buffer unallocated

NoFreeHelpBuffer:
	DbHeapMoveOn			; remove our heap lock
cEnd



; ReWrote with [39]
;***
;GiveHelpOOM - Queue a message to give OOM for Help
;
;Purpose:
;	Indicate to the error handling code that an OOM error has occured
;	in the help system.  This routine may be called as many times as
;	desired before DisplayHelpOOM is called, and the error will only
;	be reported once.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	By Convention
;
;****

cProc	GiveHelpOOM,<PUBLIC,NEAR>
cBegin
	or	HelpFlags,HLP_FAILOOM	; indicate We failed due to OOM
	mov	ax,MSG_HelpOOM		
	cCall	SetUiErr,<AX>		
cEnd

;Added with [39]
;***
;DisplayHelpOOM - Display an OOM error
;
;Purpose:
;	Displays an OOM error messages box for help, closes the help window,
;	and resets static variables.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;****

cProc	DisplayHelpOOM,<PUBLIC,NEAR>
cBegin

DbAssertTst	HelpFlags,e,HLP_INHELP,UI,<DisplayHelpOOM: Recursion lock already set>
	or	HelpFlags,HLP_INHELP	; set the recursion lock

	
	;We must save the HelpId in case the user does something like:
	;   Error 1	      -> displays a dialog box
	;   F1		      -> gets help, runs out of memory
	;   we call MsgBoxStd -> blows away iHelpId
	;   OK to message     -> back to original dialog box
	;   F1		      -> trys help again, iHelpId is invalid
	
	push	iHelpId

	PUSHI	ax,MB_OK		; Box has OK button
	PUSHI	ax,MSG_HelpOOM		; message to be displayed
	call	MsgBoxStd		; put up a dialog box
	and	HelpFlags, NOT HLP_INHELP ;remove recursion lock
	push	Word Ptr fHelpAlloc	; save the help alloc flag
	mov	fHelpAlloc,0		; zero it so CompressHelp will
	call	CompressHelp		; get help system out of the way
	mov	uierr,0 		; clear out the error condition
	pop	ax			; get fHelpAlloc back
	mov	fHelpAlloc,al		; and restore it.
	pop	iHelpId 		; restore HelpId
cEnd


;Rewritten with [38]
;***
;FlushBuffer - Deallocates buffers from HelpBuffer
;
;Purpose:
;	This routine will deallocate all buffers from (but not including)
;	the current topic to the end of the buffer.  If this is not enough,
;	it will start deleting buffers from the begining, until the specified
;	number has been reached.
;
;	If there is no current topic, we will just delete buffers from the
;	begining until we have freed enough.
;
;Entry:
;	CX = minimum # buffers to deallocate
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;****

cProc	FlushBuffer,<NEAR>,<SI,DI>
cBegin

	DbHeapMoveOff

DbAssertRelB	cl,be,MAX_HELPBUFS,UI,<FlushBuffer: Deallocating more buffers than exist>

	mov	di,cx			; DI = # buffers to delete
	cmp	oCurTopic,0		; is oCurTopic invalid?
	je	DelBegin		; yes, just delete from the begining
	mov	si,oLastBuf		; get pointer to last buffer
DelEnd_Next:

	cmp	si,oCurTopic		; have we reached the current topic?
	je	DelBegin		; yes, start deleting from begining

	lea	ax,[si].bdlHelpText	; ax = ptr to BDL in first buffer
	cCall	BdlFree,<ax>		; get rid of it

	dec	numBuf			; indicate it is no longer in use
	sub	si,BUFSIZE		; point at the last buffer
	cmp	si,OFFSET DGROUP:HelpBuffer ;did we go off the end?
	jae	NoWrap5 		; no
	add	si,BUFFERSIZE		; wrap around
NoWrap5:
	mov	oLastBuf,si		; update oLastBuf
	dec	di			; one more buffer deleted
	jmp	short DelEnd_Next	; go try again

DelBegin:
	or	di,di			; is it 0 or negative
	jle	EndFlushBuffer		; yes, exit
	mov	si,oFirstBuf		; get pointer to first buffer
DelBegin_Next:
	lea	ax,[si].bdlHelpText	; ax = ptr to BDL in first buffer
	cCall	BdlFree,<ax>		; get rid of it

	dec	numBuf			; indicate it is no longer in use

	add	si,BUFSIZE		; Point SI at next buffer
	cmp	si,BUFFEREND		; did we go off end of buffer?
	jb	NoWrap1 		; no, continue
	sub	si,BUFFERSIZE		; wrap around to begining
NoWrap1:
	dec	di			; one less to do
	jnz	DelBegin_Next		; loop again
	mov	oFirstBuf,si		; restore ptr to first buffer

EndFlushBuffer:
	DbHeapMoveOn			; reeanble heap movement

cEnd


;Reorganized with [43]
;***
;StartHelp : make sure the help system is initialized (or reinitialized)
;
;Purpose:
;	This routine is called before any references to the help buffers
;	or the help engine are made.  It makes sure the help engine is
;	activated, the help file exists, and the buffers for the virtual
;	line system are initialized.
;
;Entry:
;	None.
;
;Exit:
;	AX = 0	if all OK
;	AX = HELP_HANDLED if an error occured (will be handled).
;
;Uses:
;	Per Convention
;
;****

cProc	StartHelp,<PUBLIC,NEAR>
cBegin
DbAssertRelB	fHelpAlloc,ne,0,UI,<StartHelp:fHelpAlloc not set>

	test	HelpFlags,HLP_GOTBUF	; do we have the buffers?
DJMP	jnz	StartHelp_Success	; yes, exit with return code

	
	;Try to start help engine
	
StartHelpEngine:

DbAssertRel	BdlHelpHist.BDL_Seg,e,UNDEFINED,UI,<StartHelp:History Buffer Valid without HLP_GOTBUF>
	PUSHI	ax,<OFFSET DGROUP:BdlHelpHist>
	PUSHI	ax,HELPHIST_END 	; # bytes to allocate
	cCall	BdlAlloc		; allocate the memory
	or	ax,ax			; did we get the memory?
	jnz	InitHistBuff		; yes, go initialize it
	cCall	GiveHelpOOM		; queue an OOM error

	mov	ax,sp			; return a non-zer value
	jmp	short StartHelp_Exit

InitHistBuff:
	GETSEG	es,BdlHelpHist.BDL_Seg,bx,SIZE	; get segment
	xor	bx,bx
	mov	ES:[bx].HH_Used,bx	; initialize # elements in use
	mov	WORD PTR ES:[bx].HH_First,HELPHIST_BEGIN ; initialize ptr
	
	;Initialize HelpBuffer
	
	push	di			; Save register
	push	ds			; Set ES=DS=DGROUP
	pop	es
	mov	ax,UNDEFINED		; value to initialize buffers with
	mov	cx,BUFFERSIZE/2 	; number of words in buffer
	mov	di,OFFSET DGROUP:HelpBuffer   ; start of buffer
	mov	oFirstBuf,DI		; initialize buffer pointers
	mov	oLastBuf,DI
	rep	stosw			; initialize buffer
	mov	numBuf,CL		; initialize num in use (=0)

	pop	di			; Restore register
	or	HelpFlags,HLP_GOTBUF

StartHelp_Success:
	xor	ax,ax			; return code of success

StartHelp_Exit:
cEnd


;Rewritten with revision [57]
;***
;CalcNc - Calculate a Context Number from a Context string
;
;Purpose:
;	Go though our list of help files, calling HelpNc with the
;	initial context number for each one.  If a help file is not
;	opened, then try to open it before calling HelpNc.
;
;	If the context number is not found and there have been any
;	dialog boxes displayed (or OOM), then return HELP_HANDLED.
;	Otherwise return HELP_NF.
;
;Entry:
;	npsz - Near pointer to context string
;
;Exit:
;	if (CX <> 0)
;	    DX:AX = Context Number
;	else
;	    AL = Error Code (HELP_NF, HELP_HANDLED)
;
;Uses:
;	Per Convention
;
;****

cProc	CalcNc,<PUBLIC,NEAR>,<SI,DI>
parmW	npsz
localB	retVal				; value to return on error
cBegin
	mov	retVal,HELP_NF		; default error code is HELP_NF

	mov	cx,offset szHelpFileQhelp; cs:cx = ptr to file name
	call	fQhelpActive		; are we in the help viewer
	jnz	InQhelp 		; brif so, have proper file name
	mov	cx,offset szHelpFileEdit; cs:cx = ptr to file name
	call	fEditorActive		; are we in the editor
	jnz	InQhelp 		; brif so, have proper file name
	mov	cx,offset szHelpFileInterp ; use help file for interpreter
InQhelp:

	mov	dx,WORD PTR ncInitial	; dx = high word of ncInitial
	mov	ax,WORD PTR ncInitial+2 ; ax = low word of ncInitial

	mov	bx,npsz 		; get a ptr to the string
	cmp	Byte Ptr [bx],0 	; is it a local context?
	jne	NotLocalContext 	; no, check if we have to open file
DbAssertRel	oCurTopic,ne,0,UI,<CalcNc:oCurTopic invaid>
	mov	bx,oCurTopic		; get ptr to current topic
	mov	ax,Word Ptr [bx].ContextNum ; use current NC as the initial NC
	mov	dx,Word Ptr [bx].ContextNum+2

NotLocalContext:
	mov	bx,ax			; do we have a context #?
	or	bx,dx
	jnz	GotHelpFile		; brif so -- try the lookup

	cCall	HelpOpen,<cs,cx>	; try to open the file.
					; DX:AX = ncInitial, or 0:x if failure
	or	dx,dx			; was there an error?
	jnz	SaveInitialNc		; no
	cmp	ax,HELPERR_MAX		; check the low word
	jae	SaveInitialNc		; no error, continue processing

	.erre	HELPERR_MAX LT 256	; make sure all errors fit in a byte
	.errnz	HELPERR_FNF - 1 	; these two errors should be first
	.errnz	HELPERR_READ - 2

;HELPERR_READ => error already given
;HELPERR_FNF  => error already given
; error 7     => error already given
;HELPERR_LIMIT => assert that this doesn't happen (25 help files)
;HELPERR_BADAPPEND => give ER_BFM
;HELPERR_NOTHELP => give ER_BFM
;HELPERR_BADVERS => give ER_BFM
;others        => whatever is convenient

	mov	retVal,HELP_HANDLED	; set a new return value
DbAssertRel	ax,ne,HELPERR_LIMIT,UI,<CalcNC:HELPERR_LIMIT from HelpEngine>
	cmp	ax,HELPERR_READ 	; have we already informed user?
DJMP	jbe	CalcNcExit_Err		; yes, exit in error
	cmp	ax,7			; another error we told user about?
DJMP	je	CalcNcExit_Err		; yes, exit

DbAssertTst	HelpFlags,z,HLP_INHELP,UI,<HelpStart:Recursion lock set>
	or	HelpFlags,HLP_INHELP	; set recursion lock
	PUSHI	ax,MB_OK		; only an OK button
	PUSHI	ax,ER_BFM		; It must be a bad help file
	cCall	MsgBoxStd		; display error
	and	HelpFlags,NOT HLP_INHELP ; clear recursion lock
	jmp	CalcNCExit_Err		; and exit

SaveInitialNc:
	mov	WORD PTR ncInitial+2,ax	; save NC
	mov	WORD PTR ncInitial,dx	

GotHelpFile:
	and	HelpFlags,NOT (HLP_FAILOOM OR HLP_FAILFNF) ; clear flags

	cCall	HelpNc,<ds,npsz,dx,ax>	; DX:AX = nc for this context str

	test	HelpFlags,HLP_FAILOOM OR HLP_FAILFNF ; a handled error?
	jz	CheckForSuccess 	; no, check to see if we succeeded
	mov	retVal,HELP_HANDLED	; update return code otherwise

CheckForSuccess:
	mov	cx,dx
	or	cx,ax			; cx != 0 iff we got the topic
	jnz	CalcNcExit		; brif ok -- we got the NC

CalcNcExit_Err:
	xor	cx,cx			; set cx in case of error
	mov	al,retVal		; return error code
CalcNcExit:				;DX:AX = context #, or 0
cEnd


; Constants used by DoStatusButton().  All added with revision [10].

; NOTE: These messages must remain in sync with QBIMSGS.TXT so that the
; NOTE: status line buttons work properly.
; NOTE:
; NOTE: How to change the text of a message:
; NOTE: 
; NOTE: 1. Make sure that the new message will not overflow the status
; NOTE:    line.  If it will, text changes are required, or a button
; NOTE:    must be removed.
; NOTE: 2. Make the change to the text in QBIMSGS.TXT
; NOTE: 3. Make the change to the text in UINHELP.ASM
; NOTE: 4. Adjust the button position #'s in UINHELP.ASM
; NOTE:
; NOTE: How to add/remove a button:
; NOTE: 
; NOTE: 1. Perform the steps required to change the status line text
; NOTE: 2. Inc/Dec the # of buttons constant in the appropriate
; NOTE:    StatusXXXTable list.
; NOTE: 3. Add/Remove the Button_XXX constant corresponding to the
; NOTE:    desired key from the appropriate StatusXXXTable list.
; NOTE:


                                ; <Shift+F1=Help> <Possible other fields>
                        ;         ^              ^
All_ob1_F1      EQU 1       ;---------+                              |
All_ob2_F1      EQU 16 ;------------------------+

;Editing
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;                       <Shift+F1=Help> <F6=Window> <F2=Subs> <F5=Run> <F8=Step>
;                                                                 ^                      ^^               ^^              ^^                    ^
Edit_ob1_F6 EQU 17          ;-+                       ||                    ||              ||       |
Edit_ob2_F6 EQU 28          ;------------+|                 ||              ||       |
Edit_ob1_F2 EQU 29          ;-------------+                 ||              ||       |
Edit_ob2_F2 EQU 38          ;----------------------+|                       ||       |
Edit_ob1_F5 EQU 39          ;-----------------------+                       ||       |
Edit_ob2_F5 EQU 47          ;-------------------------------+|               |
Edit_ob1_F8 EQU 48          ;--------------------------------+               |
Edit_ob2_F8 EQU 57          ;-----------------------------------------+

;Program running (debugging):
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F5=Continue> <F9=Toggle Bkpt> <F8=Step>
;                         ^            ^^               ^^        ^
Running_ob1_F5 EQU 17       ;-+                             ||                                ||                    |
Running_ob2_F5 EQU 30       ;--------------+|                                 ||                    |
Running_ob1_F9 EQU 31       ;---------------+                                 ||                    |
Running_ob2_F9 EQU 47       ;-------------------------------+|                      |
Running_ob1_F8 EQU 48       ;--------------------------------+                      |
Running_ob2_F8 EQU 57       ;-----------------------------------------+

;Immediate window active:
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F6=Window> <Enter=Execute Line>
;                         ^          ^^                   ^
Immed_ob1_F6    EQU 17      ;-+                      ||                                              |
Immed_ob2_F6    EQU 28      ;------------+|                                          |
Immed_ob1_ENTER EQU 29      ;-------------+                                          |
Immed_ob2_ENTER EQU 49      ;---------------------------------+

;Help window active:
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>
;                         ^          ^^           ^^             ^^            ^
Help_ob1_F6 EQU 17  ;-+                      ||                       ||                              ||                             |
Help_ob2_F6 EQU 28  ;------------+|                   ||                              ||                             |
Help_ob1_ESC    EQU 29      ;-------------+                   ||                              ||                             |
Help_ob2_ESC    EQU 41      ;-------------------------+|                              ||                             |
Help_ob1_CTRLF1 EQU 42      ;--------------------------+                              ||                             |
Help_ob2_CTRLF1 EQU 56      ;----------------------------------------+|                              |
Help_ob1_ALTF1 EQU 57       ;-----------------------------------------+                              |
Help_ob2_ALTF1 EQU 70       ;------------------------------------------------------+

;[67] Editing in QEDIT
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         MS-DOS Editor  <F1=Help> Press ALT to activate menus
;                        ^       ^
;                        |       |
QEdit_ob1_F1    EQU 16       ;  |           ;[73]
QEdit_ob2_F1    EQU 25       ;-------+                      ;[73]


;[67] Help window active: QEDIT
;        00000000001111111111222222222233333333334444444444555555555566666
;        01234567890123456789012345678901234567890123456789012345678901234
;         <F1=Help> <F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>
;         ^       ^ ^          ^^           ^^             ^^            ^           ^
QHelp_ob1_F1    EQU 01     ;                ||                       ||                              ||                             |
QHelp_ob2_F1    EQU 09     ;                ||                       ||                              ||                             |
QHelp_ob1_F6    EQU 11  ;           ||                       ||                              ||                             |
QHelp_ob2_F6    EQU 22  ;------ |                    ||                              ||                             |
QHelp_ob1_ESC   EQU 23  ;-------+                    ||                              ||                             |
QHelp_ob2_ESC   EQU 35  ;-------------------+|                               ||                             |
QHelp_ob1_CTLF1 EQU 36      ;--------------------+                            ||                             |
QHelp_ob2_CTLF1 EQU 50      ;----------------------------------+|                            |
QHelp_ob1_ALTF1 EQU 51  ;-----------------------------------+                               |
QHelp_ob2_ALTF1 EQU 64  ;------------------------------------------------+


; QHELP help viewer start-up status: MSG_StatusQHStart
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;	  MS-DOS Help Viewer  <F1=Help> Press ALT to activate menus
;			      ^       ^
;			      |       |
QHStart_ob1_F1    EQU 21 ;       |
QHStart_ob2_F1    EQU 29      ;-------+


; QHELP help window active: MSG_StatusQHHelp
;	 00000000001111111111222222222233333333334444444444555555555566666666667
;	 01234567890123456789012345678901234567890123456789012345678901234567890
;         <Alt+C=Contents> <Alt+N=Next> <Alt+B=Back>
;         ^               ^^           ^^           ^
QHHelp_ob1_CONTS EQU 01 ; ||           ||           |
QHHelp_ob2_CONTS EQU 17 ;-+|           ||           |
QHHelp_ob1_NEXT  EQU 18 ;--+           ||           |
QHHelp_ob2_NEXT  EQU 30 ;--------------+|           |
QHHelp_ob1_BACK  EQU 31 ;---------------+           |
QHHelp_ob2_BACK  EQU 43 ;---------------------------+


labelNP <StatusTable>
	DW      UIOFFSET StatusEditTable
	DW      UIOFFSET StatusRunningTable
	DW      UIOFFSET StatusImmedTable
	DW      UIOFFSET StatusHelpTable
	DW      UIOFFSET StatusQeditTable       
	DW      UIOFFSET StatusQhelpTable       
	DW	UIOFFSET StatusQHStartTable
	DW	UIOFFSET StatusQHhelpTable

StatusButton STRUC
SB_Command      db      ?
SB_obStart      db      ?
SB_obEnd        db      ?
StatusButton ends

LabelNP <StatusEditTable>
	DB      5               ; # of buttons in Edit status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midNextWindow, Edit_ob1_F6, Edit_ob2_F6>
	StatusButton    <midViewSubs, Edit_ob1_F2, Edit_ob2_F2>
	StatusButton    <midRunContinue, Edit_ob1_F5, Edit_ob2_F5>
	StatusButton    <midStep, Edit_ob1_F8, Edit_ob2_F8>

LabelNP <StatusRunningTable>
	DB      4               ; # of buttons in Running status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midRunContinue, Running_ob1_F5, Running_ob2_F5>
	StatusButton    <midDebugToggleBp, Running_ob1_F9, Running_ob2_F9>
	StatusButton    <midStep, Running_ob1_F8, Running_ob2_F8>

LabelNP <StatusImmedTable>
	DB      3               ; # of buttons in Immediate status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midNextWindow, Immed_ob1_F6 , Immed_ob2_F6>
	StatusButton    <midEnter, Immed_ob1_ENTER, Immed_ob2_ENTER>

LabelNP <StatusHelpTable>
	DB      5               ; # of buttons in Help status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midNextWindow, Help_ob1_F6, Help_ob2_F6>
	StatusButton    <midHelpClose, Help_ob1_ESC, Help_ob2_ESC>
	StatusButton    <midHelpNext, Help_ob1_CTRLF1, Help_ob2_CTRLF1>
	StatusButton    <midHelpBack, Help_ob1_ALTF1, Help_ob2_ALTF1>

LabelNP <StatusQeditTable>
	DB      1               ; # of buttons in Edit status message
	StatusButton    <midHelpSyntax, Qedit_ob1_F1, Qedit_ob2_F1>

LabelNP <StatusQhelpTable>
	DB      5               ; # of buttons in Help status message
	StatusButton    <midHelpSyntax, QHelp_ob1_F1, QHelp_ob2_F1>
	StatusButton    <midNextWindow, QHelp_ob1_F6, QHelp_ob2_F6>
	StatusButton    <midHelpClose, QHelp_ob1_ESC, QHelp_ob2_ESC>
	StatusButton    <midHelpNext, QHelp_ob1_CTLF1, QHelp_ob2_CTLF1>
        StatusButton    <midHelpBack, QHelp_ob1_ALTF1, QHelp_ob2_ALTF1>

LabelNP <StatusQHStartTable>
	DB	1		; # of buttons in QHELP start status message
	StatusButton	<midHelpHowToUse, QHStart_ob1_F1, QHStart_ob2_F1>

LabelNP <StatusQHhelpTable>
        DB      3               ; # of buttons in QHELP Help status message
        StatusButton    <midHelpHelp,    QHHelp_ob1_CONTS, QHHelp_ob2_CONTS>
        StatusButton    <midHelpNext,    QHHelp_ob1_NEXT , QHHelp_ob2_NEXT >
        StatusButton    <midHelpBack,    QHHelp_ob1_BACK , QHHelp_ob2_BACK >


;***
;HStatusButton
;       Given a mouse position in the status line window, return
;       a handle to the status button at that position.
;
;Purpose:
;       Heavy modification in revision [52]
;
;Entry:
;       posX = 0-relative mouse position
;Exit:
;       AX - handle to the status button or NULL if no button.
;            The handle is actually a pointer into the code segment.
;Uses:
;       Per Convention
;****

cProc   HStatusButton,<PUBLIC,NEAR>,<SI>
	ParmW   posX
cBegin
	xor     si,si                   ;Default return value: NULL

	mov     bx,iMsgStatusLine       ; bx = current line displayed
	sub     bx,MSG_StatusEdit       ; bx = 0, 1, 2, 3, or invalid
        cmp     bx,(MSG_StatusQHhelp - MSG_StatusEdit) ; out of range?
	ja      ButtonExit              ; brif so -- just exit

	shl     bx,1                    ; word index
	mov     si,word ptr cs:[bx].StatusTable

	mov     bx,[posX]               ; bx = 0-relative position
	lods    byte ptr cs:[si]        ; AL = number of entries for this line
	cbw                             
	xchg    cx,ax                   ; CX = number of entries
ButtonLoop:
	inc     si                      ;Ignore the SB_Command
	lods    word ptr cs:[si]        ;AH = obEnd, AL = obStart
	cmp     bl, al
	jb      ButtonNotFound
	cmp     bl, ah
	jb      ButtonFound
	loop    ButtonLoop
ButtonNotFound:
	mov     si,SIZE StatusButton    ;return NULL
ButtonFound:
	sub     si,SIZE StatusButton    ;point back to begining of structure.
ButtonExit:
	mov     ax, si
cEnd

;***
;ObStatusButton - Returns the position of a Status Line Button
;
;Purpose:
;       Return the position of the specified Status Button.
;
;       new for revision [52]
;
;Entry:
;       hButton - handle to button (near pointer in CS)
;
;Exit:
;       AX - Offset in characters from the beginning of the status line.
;
;Preserves:
;
;****
cProc ObStatusButton,<NEAR,PUBLIC>
	parmW   hButton
cBegin
	mov     bx, [hButton]
	xor     ax,ax
	mov     al, cs:[bx.SB_obStart]
cEnd

;***
;CbStatusButton - Returns the number of characters in a Status Line Button
;
;Purpose:
;       Return the number of characters in the specified Status Button.
;
;       new for revision [52]
;
;Entry:
;       hButton - handle to button (near pointer in CS)
;
;Exit:
;       AX - Size of button.
;
;Preserves:
;
;****
cProc CbStatusButton,<NEAR,PUBLIC>
	parmW hButton
cBegin
	mov     bx, [hButton]
	mov     al, cs:[bx.SB_obEnd]
	sub     al, cs:[bx.SB_obStart]
	xor     ah,ah
cEnd

;***
;DoStatusButton - Posts the key message associated with a Status Line Button
;
;Purpose:
;       Post the WM_CHAR message for the specified Status Button.
;
;       new for revision [52]
;
;Entry:
;       hButton - handle to button (near pointer in CS)
;
;Exit:
;       None.
;
;Preserves:
;
;****
cProc DoStatusButton,<NEAR,PUBLIC>
	parmW   hButton
cBegin
	mov     bx, [hButton]
	xor     dx,dx                           
	mov     dl,cs:[bx.SB_Command]           
	pushi   ax, <DATAOffset wndMain>        
	pushi   ax, WM_COMMAND                  
	push    dx                              
	xor     ax,ax
	push    ax
	push    ax
	call    PostMessage
cEnd

cEnd

;***
;RecordHelpHistory - Add entry to history list
;
;Purpose:
;       Record an entry into the help history list.  If the list is already
;       full, the last item gets bumped.
;
;Entry:
;       DX:AX   : item to be stored
;       BL      : flags to store with it        (EI_VARHELP Only)
;
;Exit:
;       None.
;
;Preserves:
;       AX,DX
;
;****

cProc   RecordHelpHistory,<NEAR,PUBLIC>,<DS>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<RecordHelpHistory:BdlHelpBack not initialized>

	GETSEG  ds,BdlHelpHist.BDL_Seg,bx,SIZE  ; get segment of data

	;NOTE: DS != DGROUP at this point

	ASSUMES DS,NOTHING

	xor     bx,bx                   ; look at location 0
	cmp     WORD PTR [bx].HH_Used,NUM_HISTORY ; all slots being uses?
	je      RecordOverwrite         ; yes, just overwrite last item
	inc     WORD PTR [bx].HH_Used   ; one more item being used
RecordOverwrite:
	mov     cx,[bx].HH_First        ; DX is location to stick item
	push    cx
	add     cx,SIZE HelpHistEntry   ; point CX at next entry
	cmp     cx,HELPHIST_END         ; at end of table?
	jb      NoTableWrap             ; no
	mov     cx,HELPHIST_BEGIN       ; point to begining of table
NoTableWrap:
	mov     [bx].HH_First,cx        ; save new initial location
	pop     bx                      ; restore previous starting loc
	mov     [bx].HH_HiWord,dx       ; save Hi word
	mov     [bx].HH_LoWord,ax       ; save lo word
	ASSUMES DS,DGROUP
cEnd

;***
;RetrieveHelpHistory - Get the last recorded item in help history list
;
;Purpose:
;       Retrieve the last item from the help history list.  Returns with CX=0
;       if no items are left.
;
;Entry:
;       None.
;
;Exit:
;       if CX <> 0
;           DX:AX   : item stored
;           BL      : flags stored with it (IF EI_VARHELP)
;       else
;           No items recorded
;
;****
cProc   RetrieveHelpHistory,<NEAR,PUBLIC>,<DS>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<RetrieveHelpHistory:BldHelBack not initialized>

	GETSEG  ds,BdlHelpHist.BDL_Seg,bx,SIZE  ; get segment of data
	
	;NOTE: DS != DGROUP at this point
	
	ASSUMES DS,NOTHING

	xor     bx,bx                   ; look at location 0
	mov     cx,[bx].HH_Used         ; CX = number of slots in use
	jcxz    RetrieveExit            ; no items, return with error
	
	;NOTE: CX <> 0 is preserved for rest of routine
	
	dec     WORD PTR [bx].HH_Used   ; indicate one less
	mov     ax,[bx].HH_First        ; AX = offset into table
	sub     ax,SIZE HelpHistEntry   ; point to previous entry
	cmp     ax,HELPHIST_BEGIN       ; before first entry?
	jge     NoRetrieveWrap          ; no, continue
	mov     ax,HELPHIST_END - SIZE HelpHistEntry ; set to last item
NoRetrieveWrap:
	mov     [bx].HH_First,ax        ; save new pointer
	xchg    bx,ax                   ; bx = ptr to entry to retrieve
	mov     dx,[bx].HH_HiWord       ; retrieve values and exit
	mov     ax,[bx].HH_LoWord
RetrieveExit:
	ASSUMES DS,DGROUP
cEnd

;***
;HelpHistoryLength - return number of items in the help history list
;
;Entry:
;       None
;
;Exit:
;       CX = number of items
;
;Uses:
;       CX,ES
;
;Preserves:
;       AX,BX,DX
;***

cProc   HelpHistoryLength,<NEAR>,<BX>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<HelpHistoryLength:BldHelBack not initialized>

	GETSEG  es,BdlHelpHist.BDL_Seg,bx,SIZE  ; get segment of data
	mov     cx,ES:[0].HH_Used       ; CX = number of slots in use
cEnd



; added with [24], rewritten with [25]
;***
;DiscardHistoryoRs - Discard all Help + Bookmark information for an oRs
;
;Purpose:
;       Discards any stored information about a given oRs in the help system.
;       If the current help being displayed is dependent on this oRs, then we
;       will do a Help Back until something is found.  If nothing is found,
;       close the help window.
;
;Entry:
;       oRs - oRs to be discarded
;
;Exit:
;       None
;
;Uses:
;       Per C Conventions
;***

cProc   DiscardHistoryoRs,<PUBLIC,FAR>,<SI,DI>
parmW   oRs
cBegin
	mov     ax,UNDEFINED            ; indicates bookmark not valid
	cCall   ReAssignBookMark,<oRs,AX> ; delete all matching bookmarks



DiscardHistory_Exit:
cEnd


;***
;szSrchExcl - search for '!' in a 0 terminated string
;
;Purpose:
;       This routine scans a 0 terminated string to find an '!' in
;       it.
;
;Entry:
;       npsz    - Near Ptr to string to search
;
;Exit:
;       if character not found
;           AX = 0
;       else
;           AX = ptr to first occurance of the character
;
;Uses:
;       Per C convention
;****

cProc   szSrchExcl,<PUBLIC,NEAR>,<SI>
parmW   npsz
cBegin
	mov     si,npsz                 ; start of string to scan
NextChr:
	lodsb
	cmp     al,'!'                  ; is it the character of interest?
	je      FoundChr                ; yes, return its position
	or      al,al                   ; is it the 0 terminator?
	jne     NextChr                 ; no, try the next character.
	cbw                             ; AX = 0
	xchg    ax,si                   ; SI = 0  (return value)
FoundChr:
	xchg    ax,si                   ; AX = Ptr to str OR 0
cEnd


;***
;SendHelpMsg - Stub routine to send a message to the help window
;
;Purpose:
;       Code saving method of sending a message (with wParm only) to
;       the help window.
;
;Entry:
;       msg - message to send
;       wParam - one parameter to be passed
;
;Exit:
;       Return value from Window Proc
;
;
;****

cProc   SendHelpMsg,<PUBLIC,NEAR>
parmW   msg
parmW   wParam
cBegin
	mov     ax,OFFSET DGROUP:wndHelp
	cCall   SendMessage,<AX, msg, wParam, ax,ax>
cEnd


sEnd    UI
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbswe\strings\intl.inc ===
CCHUNTITLED             EQU 8 ; length of "Untitled" file name string
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbusa\strings\intl.inc ===
CCHUNTITLED             EQU 8 ; length of "Untitled" file name string
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbusa\strings\itl.h ===
/*
	COW : Character Oriented Windows

	itl.h   : Internationalization header

	This contains strings for use in QBASIC dialog boxes.

	You have a string in quotes, followed by its length +
	the total number of spaces to have on each side of
	the string.

	eg. "OK" is 2 long, the 4 means put 4/2=2 spaces on
	    each side of the word when it is being displayed.
	    make sure you leave the brackets around the numbers
	    ie, 2+4 is incorrect, (2+4) is correct.

	Some also have their hotkey following the key and the
	size, make sure that you leave the single qutoes (')
	around these characters.

	You may have to make some adjustments to the .des files
	when you have changed this file.

	eg, say you translate "OK" to "Okay", then the size
	might go to (4+4), or whatever you want.
	Then you would go to the .des files.
	lines with the following would have to be modified:

	OK_BUTTON AT (col, row, 6, 1) ACT...........
				^

	to

	OK_BUTTON AT (col, row, 8, 1) ACT...........
				^

*/


#define szOk            "OK"
#define cchOk           (2+4)
/* chAccelOk no accelerator */

#define szYes           "Yes"
#define cchYes          (3+2)
#define chAccelYes      'Y'

#define szNo            "No"
#define cchNo           (2+4)
#define chAccelNo       'N'

#define szCancel        "Cancel"
#define cchCancel       6
/* chAccelCancel no accelerator */

#define szRetry         "Retry"
#define cchRetry        5
#define chAccelRetry    'R'

#define szAbort         "Abort"
#define cchAbort        5
#define chAccelAbort    'A'

#ifdef HELP_BUTTON
#define szHelp          "Help"
#define cchHelp         (4+2)
#define chAccelHelp     'H'
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbswe\strings\itl.h ===
/*
	COW : Character Oriented Windows

	itl.h   : Internationalization header

	This contains strings for use in QBASIC dialog boxes.

	You have a string in quotes, followed by its length +
	the total number of spaces to have on each side of
	the string.

	eg. "OK" is 2 long, the 4 means put 4/2=2 spaces on
	    each side of the word when it is being displayed.
	    make sure you leave the brackets around the numbers
	    ie, 2+4 is incorrect, (2+4) is correct.

	Some also have their hotkey following the key and the
	size, make sure that you leave the single qutoes (')
	around these characters.

	You may have to make some adjustments to the .des files
	when you have changed this file.

	eg, say you translate "OK" to "Okay", then the size
	might go to (4+4), or whatever you want.
	Then you would go to the .des files.
	lines with the following would have to be modified:

	OK_BUTTON AT (col, row, 6, 1) ACT...........
				^

	to

	OK_BUTTON AT (col, row, 8, 1) ACT...........
				^

*/

#define	szOk		"OK"
#define cchOk		(2+0)
/* chAccelOk no accelerator */

#define	szYes		"Ja"
#define cchYes		(2+0)
#define	chAccelYes	'J'

#define	szNo		"Nej"
#define cchNo		(3+0)
#define	chAccelNo	'N'

#define szCancel	"Avbryt"
#define cchCancel	6
/* chAccelCancel no accelerator */

#define	szRetry		"Nytt frsk"
#define	cchRetry	11
#define	chAccelRetry	'N'

#define	szAbort		"Avbryt"
#define cchAbort	6
#define	chAccelAbort	'A'

#ifdef HELP_BUTTON
#define szHelp		"Hjlp"
#define cchHelp 	(5+0)
#define chAccelHelp	'H'
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbpor\strings\itl.h ===
/*
	COW : Character Oriented Windows

	itl.h   : Internationalization header

	This contains strings for use in QBASIC dialog boxes.

	You have a string in quotes, followed by its length +
	the total number of spaces to have on each side of
	the string.

	eg. "OK" is 2 long, the 4 means put 4/2=2 spaces on
	    each side of the word when it is being displayed.
	    make sure you leave the brackets around the numbers
	    ie, 2+4 is incorrect, (2+4) is correct.

	Some also have their hotkey following the key and the
	size, make sure that you leave the single qutoes (')
	around these characters.

	You may have to make some adjustments to the .des files
	when you have changed this file.

	eg, say you translate "OK" to "Okay", then the size
	might go to (4+4), or whatever you want.
	Then you would go to the .des files.
	lines with the following would have to be modified:

	OK_BUTTON AT (col, row, 6, 1) ACT...........
				^

	to

	OK_BUTTON AT (col, row, 8, 1) ACT...........
				^

*/


#define szOk            "OK"
#define cchOk           (2+4)
/* chAccelOk no accelerator */

#define szYes           "OK"
#define cchYes          (2+2)
#define chAccelYes      'O'

#define szNo		"Nao"
#define cchNo		(3+2)
#define chAccelNo       'N'

#define szCancel	"Cancelar"
#define cchCancel	8
/* chAccelCancel no accelerator */

#define szRetry 	"Repetir"
#define cchRetry	7
#define chAccelRetry    'R'

#define szAbort 	"Anular"
#define cchAbort	6
#define chAccelAbort    'A'

#ifdef HELP_BUTTON
#define szHelp		"Socorro"
#define cchHelp 	(7+2)
#define chAccelHelp     'S'
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbspa\strings\itl.h ===
/*
	COW : Character Oriented Windows

	itl.h   : Internationalization header

	This contains strings for use in QBASIC dialog boxes.

	You have a string in quotes, followed by its length +
	the total number of spaces to have on each side of
	the string.

	eg. "OK" is 2 long, the 4 means put 4/2=2 spaces on
	    each side of the word when it is being displayed.
	    make sure you leave the brackets around the numbers
	    ie, 2+4 is incorrect, (2+4) is correct.

	Some also have their hotkey following the key and the
	size, make sure that you leave the single qutoes (')
	around these characters.

	You may have to make some adjustments to the .des files
	when you have changed this file.

	eg, say you translate "OK" to "Okay", then the size
	might go to (4+4), or whatever you want.
	Then you would go to the .des files.
	lines with the following would have to be modified:

	OK_BUTTON AT (col, row, 6, 1) ACT...........
				^

	to

	OK_BUTTON AT (col, row, 8, 1) ACT...........
				^

*/


#define szOk            "SI"
#define cchOk           (2+4)
/* chAccelOk no accelerator */

#define szYes           "S"
#define cchYes          (2+2)
#define chAccelYes      'S'

#define szNo            "No"
#define cchNo           (2+4)
#define chAccelNo       'N'

#define szCancel        "Cancelar"
#define cchCancel       (8+2)
/* chAccelCancel no accelerator */

#define szRetry         "Reintentar"
#define cchRetry        (10+2)
#define chAccelRetry    'R'

#define szAbort         "Anular"
#define cchAbort        (6+2)
#define chAccelAbort    'A'

#ifdef HELP_BUTTON
#define szHelp          "Ayuda"
#define cchHelp         (5+2)
#define chAccelHelp     'A'
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbswe\strings\uinhelp.asm ===
TITLE	uinhelp.asm - utilities for new help engine.
;***
;uinhelp.asm
;
;	Copyright <C> 1985-1988, Microsoft Corporation
;
;Purpose:
;	Utilities for the new help system.
;
;
;*******************************************************************************

	.xlist
	include	version.inc
	.list
	UINHELP_ASM = ON


	include cw/version.inc
	include cw/windows.inc
	include cw/edityp.inc

	IncludeOnce architec
	IncludeOnce heap
	Include     help.inc
	IncludeOnce parser
	IncludeOnce prstab
	IncludeOnce rtps
	IncludeOnce qbimsgs
	IncludeOnce ui
	IncludeOnce uiint
	IncludeOnce uimenu		
	IncludeOnce uinhelp		

assumes DS,DATA
assumes ES,DATA
assumes SS,DATA

	subttl	DATA segment definitions.
	page

sBegin	DATA
	externW	iMsgStatusLine		; current status line message
	externW iHelpId 		

; GetHelpMessage and MapLineToContext return codes

	globalB fHelpAlloc,0		; Non-zero if help system is doing
					; a far heap allocation
	BdlTemp	BDL	<>		; temporary BDL owner
	externB	bdlHelp			; BDL for keyword help (def in UIHELP.C)
	externW	szDialogHelpContext	; *sz context of current dialog help


	externB b$Buf1			; FILNAML-sized buffer
	externB b$Buf2			; 16-byte buffer
	HtSpot	EQU	b$Buf2		; Static HotSpot structure

	globalB HelpFlags,0,1		;status of the help system
	globalB HelpFlags2,0,1		;more help system state


;BUFFERING:
;
;   The Help system uses a circular buffer of buffers to hold the
;   text of help messages (called contexts) so that scrolling up
;   and down in a file does not have to be continuously hitting the
;   disk.  The buffers are organized as follows:
;
;	HelpBuffer  : Slot 1 : Slot 2 : Slot 3 : ... : Slot MAX_HELPBUFS :
;
;   Each active slot in the Static HelpBuffer is of type HelpBufType.  The
;   entries in HelpBuffer are organized as a circular list so that they
;   may grow on either end without moving the existing entries.  Each
;   active entry in HelpBuffer represents one context that is currently
;   stored in memory.
;

	staticW oFirstBuf,,1		;Offset of first logical buffer
	staticW oLastBuf,,1		;Offset of last logical buffer
	staticB numBuf,0,1		;number of active buffers in HelpBuffer
	staticB fNoDelBufs,0,1		; are we allowed to delete the
					; buffers during a ShrinkHelp?


	MAX_HELPBUFS	= 9		; Number of entries in HelpBuffer
	BUFSIZE 	= SIZE HelpBufType;The size of the entries in HelpBuffer

	BUFFERSIZE	= MAX_HELPBUFS * BUFSIZE ; Size of HelpBuffer
	staticB	HelpBuffer,0,BUFFERSIZE
	BUFFEREND	EQU (OFFSET DGROUP:HelpBuffer) + (BUFFERSIZE)

	DbPub	HelpBuffer

	globalW iCurRequestLine,UNDEFINED,1 ; line # to get attributes for,
					; or UNDEFINED if no attributes
					; available
	globalW oCurTopic,0,1		; offset to the current topic
					; (0 if no current topic)

	globalW iFileSize,0,1		; Size of current help topic
	externW iStaticHelpTopic	; High word of NC during searches

	externW WndHelp 		; Help Window structure
	externW efHelp			; Editmgr structure for Help Wnd.

;QUEUE MANAGEMENT
;
;  In order to support help history (Ctrl-F1), we keep a LIFO queue
;  of the last 20 items that we requested help on.  The items are stored
;  as a circular list, with a pointer to the next item to be filled in
;  and a count of the number of items that exist.
;
;
;  This list (of type HelpHistEntry) is contained in a BDL, with the first
;  few bytes of the BDL containg a header (type HelpHistHeader) of useful
;  information
;

	BdlHelpHist BDL <>		; BDL for help backup (^F1) list

	ncInitial DD 0			

	HelpHistEntry STRUC
	    HH_HiWord	DW ?
	    HH_LoWord	DW ?
	HelpHistEntry ENDS

	HelpHistHeader STRUC		
	    HH_Used	DW ?		; number of history items in use
	    HH_First	DW ?		; offset into seg of next free item
	HelpHistHeader ENDS		

	NUM_HISTORY	= 20		; number of items that can be saved
	HELPHIST_BEGIN = Size HelpHistHeader  ; offset of first item in segment
	HELPHIST_END   = HELPHIST_BEGIN + NUM_HISTORY * SIZE HelpHistEntry
					; end of the last item

;MAGIC EDIT MANAGER Variables
;
;   The following magic locations in the edit manager are used:
;
;	EfHelp.EF_ipCur_ob     = Current column in help window
;	EfHelp.EF_ipCur_oln    = Current line in help window
;	EfHelp.EF_pdCur_olnTop = Top line of help window
;	EfHelp.EF_pdCur_obleft = Leftmost column of help window
;
;	WndHelp.arcClipping.ayBottomArc, WndHelp.arcClipping.ayTopArc
;		specify the top and bottom of the window.  I believe
;		that they are in screen coordinates.
;
;	One thing to note:  The Edit Manager uses 0 relative coordinates
;	while the helpengine (and variable help) use 1 relative coordinates.
;	Thus, you have to be careful in converting from one to another.
;
;	There are only 2 places that a line or column number is stored:
;	  - Bookmarks (0 relative, as the HelpEngine is not involved)
;	  - iCurRequestLine (1 relative, because it is a HelpEngine line#)
;


;HELP System ENTRY/EXIT conditions
;
;  Anytime that code for the help system is executing, we must have the
;  following conditions met:
;
;	1.)  As close as possible to the point where we could display a
;	     dialog box or message box receiveing ANY input from the user
;	     we must have HLP_INHELP set to prevent recursively entering the
;	     help system.  Currently, this occurs in 2 places:
;		- Displaying "Help File Not Found"
;		- Displaying "INsufficient memory for help system"
;
;	2.)  The help system must be active to the level that is needed to
;	     implement the desired functionality.  There are three levels:
;
;	     a.) Help Engine shut down - No functionality at all possible.
;
;	     b.) Help Engine Active, no current topic.
;		  HLP_GOTBUF is true, but oCurTopic = 0.
;
;	     c.) Help Engine Active, Current topic available.
;
;
;	     The following assumptions and conditions are used in checking
;	     entry conditions:
;
;	     - If the help window is open, we must be at level C.
;	     - If the help window is closed, we may be at A or B.
;	     - If we get a message from the help window, it must be open (C).
;	     - If StartHelp returns 0, you are in either B or C.
;
;	3.)  Any allocation could end up causing CompressHelp to be called.
;	     Thus, there has to be flag set ANYTIME we are in the help system
;	     so that CompressHelp will not yank the help system out from
;	     underneeth itself.  Currenly, there are only 2 entry points
;	     for help:
;		- Help()
;		- HelpWndProc()


sEnd	DATA

	externFP B$IFOUT		; Convert number to string
	externFP HelpOpen		; Misc Help engine routines
	externFP HelpNc
	externFP HelpNcCb
	externFP HelpLook
	externFP HelpDecomp
	externFP HelpXRef
	externFP HelpGetLine
	externFP HelpHlNext
	externFP HelpNcNext
	externFP HelpSzContext
	externFP HelpClose		
	externFP HelpShrink		
	externFP _atoi			; CONSIDE: use runtime call for this
	externFP fEditorActive		
	externFP fQhelpActive



sBegin	UI
assumes CS,UI

	staticB szHelpFileEdit,<"EDIT.HLP",0>	; main help file name
	staticB szHelpFileQhelp,<"HELP.HLP",0>	; qhelp help file name
	staticB szHelpFileInterp,<"QBASIC.HLP",0> ; second help file name

	externNP MoveCursorPwndCur	; Move cursor of current window
	externNP MoveCursorPwnd 	; Move cursor of specified window
	externNP WndHelpOpen		; Open help window to a given size
	externNP WndHelpClose		; Close the help window
	externNP SetHelpKeyword		; put keyword into help syntax menu

	externNP HelpBack		

	subttl	Main Help EntryPoints
	page


;***
;KeywordHelp : Display help for a keyword
;
;Purpose:
;	This routine implements SHIFT-F1.  If the cursor is on a keyword
;	in a window, then display help for this keyword in the help window
;	(opening it if needed). If there is no text selected, or it is
;	not a keyword, then return a non-zero value to indicate that F1
;	should be done.
;
;Entry:
;	None.
;
;Exit:
;	None
;
;Uses:
;	AX,BX,CX,DX
;
;****

cProc	KeywordHelp,<NEAR,PUBLIC>,<SI>	
cBegin
	cCall	StartHelp		; make sure we have the help system
	or	ax,ax			; did we succeed?
	jne	KeywordHelpExit 	; no, just return

	cCall	KeywordHelpLookup	; AX = length of current keyword
					; (text placed in bufStdMsg)
	or	ax,ax			; is there a current keyword?
	jne	CurKeyword		; brif so
Moo:
	cCall	CowMoo			; -- beep speaker & return
	jmp	short KeywordHelpExit	
CurKeyword:

	DbChk	HoldBuf1		; grab B$Buf1

	mov	ax,offset dgroup:bufStdMsg ; where the topic was placed
	mov	bx,offset dgroup:B$Buf1 ; new home for the topic string
	push	bx			; param to DisplayHlpWndSz

	cCall	fstrcpy2,<DS,bx,DS,ax>	


	cCall	DisplayHlpWndSz 	; try to display the help

	DbChk	FreeBuf1		; release the buffer

	or	al,al			; Did we succeed with engine hlp
	je	KeywordHelpExit_Ok	; yes, exit.

	test	al,HELP_HANDLED 	; have we displayed anything to
					; the user?
	jnz	KeywordHelpExit 	; yes, just exit
	jmp	short Moo		; otherwise tell user about it

KeywordHelpExit_Ok:
	mov	[uierr],0		; clear any leftover errors
KeywordHelpExit:
cEnd

;***
;KeywordHelpLookup : Find help for a keyword
;
;Purpose:
;	Added with revision [5].
;
;	Looks up the keyword, enables/disables the HelpSyntax menu item, and
;	puts the keyword into the HelpSyntax menu item.
;
;Entry:
;	None.
;
;Exit:
;	AX : =0 if no keyword was found
;	    length of keyword (NZ) if keyword was found
;Uses:
;	AX,BX,CX,DX
;
;****

cProc	KeywordHelpLookup,<NEAR,PUBLIC>
cBegin

	mov	ax,offset dgroup:bufStdMsg
	mov	bx,10			; maximum length of word  (10 is magic)
	mov	cx,GEW_HELPMASK 	; do not include . or ! in search
	cCall	GetEditWordMask,<ax,bx,cx> ; AX = length of word retrieved
	push	ax			; save for return value

	; enable/disable help syntax menu item based on AX (0 ==> disable)
	or	ax,ax			; if NZ, set low bit for stupid-ass
	jz	disableit		; COW C function
	mov	al,1
disableit:
	mov	bx,midHelpSyntax
	cCall	EnableMenuItem,<bx,ax>

	; copy current topic name into help syntax menu buffer
	mov	ax,offset dgroup:bufStdMsg
	cCall	SetHelpKeyword,<ax>

	pop	ax			; return AX = length of keyword
cEnd



;***
;SelectHotLink - Go to the hot link that is specified in the window coords
;
;Purpose:
;	Look in the help file given by the line number and column
;	number.  If there is a hot link at this position, go to the item
;	that it links to.  Otherwise, just returns.
;
;Entry:
;	(rx,ry) - virtual line coordinates of the location of a
;		  supposive hot spot.
;	beep	- TRUE if we are suspose to beep when we don't find anything
;
;Exit:
;	AX = 0 (FALSE) if a hot link was selected
;
;Uses:
;	Per Convention
;****

cProc	SelectHotLink,<PUBLIC,NEAR>,<SI,DI>
parmW	rx
parmW	ry
parmB	GiveBeep
cBegin

	;Since we got a keyboard message from the help window, it must be
	;open, therefor we must be initialized.

	DbAssertTst HelpFlags,ne,HLP_GOTBUF,UI,<SelectHotLink:Buffers Not Initialized>


	DbChk	HoldBuf2		; lock down the HotSpot
	DbChk	HoldBuf1		; for composed hotlink names

	mov	bx,oCurTopic		; get ptr to topic
	lea	bx,[bx].bdlHelpText.BDL_seg ; BX = handle to data seg
	mov	cx,rx
	inc	cx			; make column 1 relative
	mov	HtSpot.colHS,cx 	
	mov	cx,ry			; get line number
	inc	cx			; make it 1 relative
	mov	HtSpot.lineHS,cx	; and stick in HotSpot structure
	mov	ax,OFFSET DGROUP:HtSpot
	xor	cx,cx
	and	HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM) ; clear errors
	cCall	HelpXRef,<BX,CX,DS,AX>	;Get context string for topic
	or	ax,ax			; did we get a topic
	jnz	GotSelection		; yes, go display it
	test	HelpFlags,HLP_FAILFNF OR HLP_FAILOOM ; is error handled?
	jnz	NoBeep			; yes, do not beep
SelectHotLink_Beep:
	cmp	GiveBeep,0		; should we give a beep?
	je	NoBeep			; no, just exit with error code
	cCall	CowMoo			; beep cow's speaker
NoBeep:
	mov	ax,sp			; return with non-zero value
	DbChk	FreeBuf2		; release the HotSpot
	DbChk	FreeBuf1		;  and our other buffer
	jmp	short NoSelection	; and exit

GotSelection:
	;Copy context string into free part of Buf2 and display it in a help
	;window. The source string is in HtSpot.pXrefHS and is 0 terminated
	;We can not use the source directly, as it points into a BDL, and
	;we are not guarenteing a locked heap.

	push	ds				; set ES = DS = DGROUP
	pop	es				
	mov	di,offset dgroup:b$buf1 	; ES:DI = destination
	push	di				; parm for DislplayHlpWnd
	lds	si,DWord Ptr HtSpot.pXrefHS	; DS:SI = source

CopyLoop:
	lodsb					; copy the byte
	stosb					
	or	al,al				; is it the 0 termiantor
	jne	CopyLoop			; no, do next byte
	lodsw					; Copy next word
	stosw					; incase it was local

	push	es				; restore DGROUP
	pop	ds				

	DbChk	FreeBuf2			; release the HotSpot

	; Check to see if the context is !B.  If it is, then we should
	; execute a HelpBack command instead of displaying the context

	cmp	WORD PTR b$Buf1,'B!'		; is it !B?
	jne	NotHelpBack			; no, go display it
	cmp	BYTE PTR b$Buf1+2,0		; is it 0 terminated?
	jne	NotHelpBack			; no, go display it
DbAssertRel	pwndAct,e,<OFFSET DGROUP:wndHelp>,UI,<SelectHotLink:Not in help window>
	pop	ax				; restore stack (param to
						;  DisplayHlpwndSz not used)
	xor	ax,ax				; move to (0,0) so we will
	cCall	MoveCursorPwndCur,<ax,ax>	; goto previous topic
	DbChk	FreeBuf1			; incase HelpBack wants it
	call	HelpBack			; do the help back
	jmp	short ExitSuccess		; and exit

NotHelpBack:
	cCall	DisplayHlpWndSz 		; display text
DbAssertRelB	al,ne,HELP_NF,UI,<SelectHotLink:Returned hot link not found>
						;ignore any errors
	DbChk	FreeBuf1			; release context string

ExitSuccess:
	xor	ax,ax				; return value of success
						; this way we will not put
						; up an error box, then
						; do something useful.
NoSelection:

cEnd



;Rewrote with [5]
;***
;FillContextNext - Fill the next buffer with the desired context information
;
;Purpose:
;	Read a help context into the help buffer given the position that
;	is previous to it.  The information needed for the new context
;	is obtained from the context given.  This routine will read in
;	as many contexts as desired.
;
;	Note: this routine does not return any errors, as its caller
;	does not check the error code (this is used to fill the buffer
;	with topics after the current topic, so if we could not read
;	in a topic for any reason, then we will just leave the buffer
;	partially empty).
;
;Entry:
;	BX = current buffer
;	DI = number of context to read
;
;Exit:
;	oLastBuf = Last valid buffer
;	numBuf updated
;
;****

cProc	FillContextNext,<NEAR>,<DI>
cBegin

DbAssertRelB	fNoDelBufs,ne,0,UI,<FillContextNext:Caller did not set fNoDelBufs>


cEnd


;Added with [5]
;***
;GetHelpMsgNcFill - get a help message from a context number, fill in fields
;
;Purpose:
;	Calls GetHelpMsgNc, and fills in all the fields of the buffer except
;	for the first line number of the context.
;
;Entry:
;	DX:AX = context number to be filled in
;	BX = ptr to context
;Exit:
;	if (AL = 0)
;	    BX = ptr to context
;	    all fields of context are filled in
;	else
;	    AL = HELP_HANDLED.
;
;****
cProc	GetHelpMsgNcFill,<NEAR>
cBegin
	push	bx				; We need to preserve BX
	mov	Word Ptr [bx].ContextNum,ax	; save Context Num in Buffer
	mov	Word Ptr [bx].ContextNum+2,dx
	lea	cx,[bx].bdlHelpText		; point to BLD
	cCall	GetHelpMsgNc,<dx,ax,cx> 	; get message
						; (AL = return code)
	pop	bx				; BX = *Buffer

Fill_Exit:
cEnd

;***
;GetHelpMsgSz - get a help message from a context string
;GetHelpMsgNc - get a help message from a context number
;
;Purpose:
;	This routine calls the help engine to obtain the help text
;	associated with a context string.  The text is returned in a BDL.
;	No buffering of the help context is performed.
;
;	NOTE: Does not require oFirstBuf or oLastBuf to be set.
;
;Entry:
;	szContext : pointer to context string
;	BdlText : pointer to bdl owner structure.
;
;Exit:
;	AL = HELP_OK (0) if success.
;	AL = HELP_HANDLED, HELP_NF
;
;Uses:
;	Per convention
;
;Exceptions:
;	
;****
cProc	GetHelpMsgSz,<NEAR,PUBLIC>
parmW	szContext
parmW	BdlText
cBegin
DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<GetHelpMsgSz:HLP_GOTBUF false>
	mov	ax,szContext		; AX = context string
	cCall	CalcNc,<AX>		; DX:AX = nc for context string
	jcxz	GetHelpMsgSzExit	; return with error code (AL) if error

	cCall	GetHelpMsgNc,<DX,AX,BdlText> ; get message
GetHelpMsgSzExit:
cEnd

DbPub	GetHelpMsgNc
cProc	GetHelpMsgNc,<NEAR>,<SI,DI>
parmW	ncHigh
parmW	ncLow
parmW	BdlText
cBegin
DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<GetHelpMsgNc:HLP_GOTBUF false>
DbAssertRelB	fHelpAlloc,ne,0,UI,<GetHelpMsgNc:fHelpAlloc not set>

	mov	di,ncHigh		;set DI:SI to context string
	mov	si,ncLow

	and	HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM) ; clear flags

	cCall	HelpNcCb,<DI,SI>	; AX = #bytes for decompressed topic

	xchg	ax,cx					; save size in CX
	test	HelpFlags,HLP_FAILFNF OR HLP_FAILOOM	; did we fail it?
	mov	al,HELP_HANDLED 			; assume so
	jnz	GetHelpMsgNcExit_Near			; exit if error

	mov	bx,offset DGROUP:BdlTemp
	cCall	BdlAlloc,<BX,CX>	; alloc bdl for compressed data
	or	ax,ax			; OOM error?
	jz	GetHelpMsgOOM		; yes, go handle it

	lea	bx,[BdlTemp.BDL_seg]	; BX = handle to data segment
	xor	ax,ax			; offset 0
	cCall	HelpLook,<DI,SI,BX,AX>	; AX = # bytes uncompressed
	xchg	cx,ax			; CX = # bytes uncompressed
	jcxz	FreeExitError		; brif error -- release bdl & exit

	inc	fNoDelBufs		; don't delete buffers

	mov	bx,BdlText		; bx = *BDL owner
	cCall	BdlAlloc,<BX, CX>	; alloc BDL for uncompressed data
	or	ax,ax			; ZF ==> error
	jnz	DecompressHelp		; no error, go decompress help topic
	cCall	GiveHelpOOM		; generate OOM error
	dec	fNoDelBufs		; restore buffer flag
	jmp	short FreeExitError	; free Bdl and exit

GetHelpMsgOOM:
	cCall	GiveHelpOOM		; signal an OOM error
	mov	al,HELP_HANDLED 	
GetHelpMsgNcExit_Near:			
	jmp	Short GetHelpMsgNcExit	; brif so -- give error and exit

DecompressHelp:
DbAssertTst	HelpFlags,z,HLP_NOSHRINK,UI,<GetHelpMsgNc:NOSHRINK set>
	or	HelpFlags,HLP_NOSHRINK	; don't shrink during HelpDecomp
					; otherwise it will fail.
	mov	bx,BdlText		; bx = *BDL owner (could have moved)
	xor	ax,ax			; offset 0
	lea	dx,[BX].BDL_seg 	; DX = handle of destination seg
	lea	bx,[BdlTemp.BDL_seg]	; BX = handle of source segment
	cCall	HelpDecomp,<BX,AX,DX,AX,DI,SI>
					; decompress help text
	dec	fNoDelBufs		; reset buffer delete flag
	and	HelpFlags,NOT HLP_NOSHRINK ; reenable shrinking.

	or	ax,ax			; did we get an error?
	jz	FreeExit		; no, free temp BDL and exit
	mov	ax,BdlText		; get pointer to bdl
	cCall	BdlFree,<AX>		; and deallocate it

	test	HelpFlags,HLP_FAILOOM or HLP_FAILFNF ; have we reported?
	jnz	FreeExitError		; yes, get return code
	cCall	GiveHelpOOM		; report the error.

FreeExitError:
	mov	al,HELP_HANDLED 	; prepare to return error

FreeExit:
	push	ax			; save return code
	mov	ax,OFFSET DGROUP:BdlTemp
	cCall	BdlFree,<AX>		; release compressed data

	pop	ax			; AX = return code (NZ ==> success)

GetHelpMsgNcExit:

cEnd


	subttl	Display Text in the Help Window

;Rewrote with [5]
;***
;DisplayHlpWndSz - Display help in a window given a context string
;DisplayHlpWndNc - Display help in a window given a context number
;
;Purpose:
;	Displays a context in the help window given either a context
;	string (DisplayHlpWndSz) or a context number (DisplayHlpWndNc).
;	This routine will open the help window if it is not already
;	opened.
;
;Entry:
;	szContext : pointer to a context string  (DisplayHlpWndSz)
;			   or
;	DX:AX	  : context number		 (DisplayHlpWndNc)
;
;Exit:
;	AL = error code (HELP_OK, HELP_HANDLED, HELP_NF)
;
;Uses:
;	Per Convention
;
;****

cProc	DisplayHlpWndSz,<PUBLIC,NEAR>
parmW	szContext
cBegin

DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<DisplayHlpWndSz:HLP_GOTBUF false>

	mov	ax,szContext		;AX = context string
	cCall	CalcNc,<AX>		; DX:AX = nc for context string
	jcxz	HlpWndSzExit		; there was an error, exit
	cCall	DisplayHlpWndNc 	;display help for this context number

HlpWndSzExit:				;AL = return code
cEnd


cProc	DisplayHlpWndNc,<PUBLIC,NEAR>
cBegin

DbAssertTst	HelpFlags,ne,HLP_GOTBUF,UI,<DisplayHlpWndNc:HLP_GOTBUF false>

	cCall	BufferNc		; BX = ptr to new context
	or	al,al			; was there an error?
	jne	DisplayFailure		; yes, exit with error code

	push	bx			; save buffer pointer
	mov	dx,Word Ptr [bx].ContextNum+2  ; Get context number into
	mov	ax,Word Ptr [bx].ContextNum    ;  DX:AX
	cCall	RecordHelpHistory	; record context number for Ctrl-F1
	pop	bx			; restore buffer pointer

	lea	ax,[bx].bdlHelpText	
	push	ax			; save for call to GetHelpContextLen
	cCall	SizeHelpContext,<ax>	; get # lines in the help topic
					; sets iFileSize
	cCall	GetHelpContextLen	; AX = get suggested size of wnd
	cCall	OpenHelpWindow		; go open the window (to size AX)
	cCall	DrawDebugScr		; force help title to be redrawn

	xor	ax,ax			; return 0 for no-errors

DisplayFailure:
	cCall	CloseCurHelpFile	; shut down current help file, if
					; any opened. (preserves AX, DX)
cEnd




;***
;BufferNc - Given a context number, properly buffer in context
;
;Purpose:
;	This routine will refill the help buffer so that Nc is
;	present.  If Nc did not exist, the buffer is flushed and
;	refilled.
;
;Entry:
;	DX:AX	: Context number to be buffered
;
;Exit:
;	if (successful)
;		AL = HELP_OK  (=0)
;		BX = new buffer ptr
;		numBuf updated
;		oCurTopic = BX
;	else
;		AL = HELP_HANDLED
;
;****
cProc	BufferNc,<PUBLIC,NEAR>,<DI>
cBegin

	;See if the context number is already buffered

	xor	cx,cx
	mov	cl,numBuf		; scan numBuf contexts
	jcxz	DelNoBufs		; special case this...LOOP can't
	mov	bx,oFirstBuf		; Start at first context
CheckNext:
	cmp	ax,Word Ptr [bx].ContextNum ; check low word first
	jne	TryToLoop		; comparison failed, goto next one
	cmp	dx,Word Ptr [bx].ContextNum+2 ; check high word
	jne	TryToLoop		; comparison failed, goto next one
	jmp	FoundMatch		; we have the context already buffered
TryToLoop:
	add	bx,BUFSIZE		; move to next logical buffer
	cmp	bx,BUFFEREND		; did we go off the end?
	jb	Wrap5			; no, continue
	sub	bx,BUFFERSIZE		; adjust back to begining
Wrap5:
	loop	CheckNext		; try the next context

NotBuffered:

	
	; # buffers to free = # needed - # free
	;		    = MAX_HELPBUFS / 2 - (MAX_HELPBUFS - numBufs)
	;		    = numBufs - (MAX_HELPBUFS / 2)
	
	mov	cl,numBuf		; Calculate # buffers to delete
	sub	cl,MAX_HELPBUFS /2	
	ja	DelSomeBufs		; brif a positive number
	xor	cl,cl			; delete 0 buffers (makes
DelSomeBufs:				; oCurTopic == oLastTopic)
	xor	ch,ch			; CBW for CX
	push	ax			; save the context number
	push	dx
	call	FlushBuffer		; delete CX current contexts
	pop	dx			; restores context number
	pop	ax

DelNoBufs:
DbAssertRelB	numBuf,be,MAX_HELPBUFS,UI,<BufferNc: No buffers free after deleting some>

	mov	bx,oLastBuf		; Ptr to last buffer used
	cmp	numBuf,0		; stupid special case?
	jne	UseoLastBuf		; no, index off of oLastBuf
	mov	oFirstBuf,bx		; oFirstBuf = oLastBuf
	jmp	short NoWrap6		
UseoLastBuf:
	add	bx,BUFSIZE		; point to the next one
	cmp	bx,BUFFEREND		; did we go off the end?
	jb	NoWrap6 		
	sub	bx,BUFFERSIZE		
NoWrap6:
	cCall	GetHelpMsgNcFill	; get the help topic
	or	al,al			; any errors?
	jne	BufferNc_Exit		; yes, exit with error code

	inc	numBuf			; indicate one more buf in use

	;Fill the rest of the buffer with contexts after this one

	inc	fNoDelBufs		; do not delete buffers to get these
	mov	ax,MAX_HELPBUFS
	sub	al,numBuf		; AX = number of buffers free
	push	bx			; save it for exit
	xchg	di,ax			; set DI = number of free buffers

	mov	oLastBuf,bx		;set oLastBuf = last legal buffer

FillAnotherNext:
	mov	dx,Word Ptr [bx].ContextNum+2 ; DX:AX = current NC
	mov	ax,Word Ptr [bx].ContextNum
	push	bx
	cCall	GetNextNc		
	pop	bx
	je	FillContextDone 	; no more contexts

	add	bx,BUFSIZE		;Point BX at next buffer
	cmp	bx,BUFFEREND		; did we go off end of buffer?
	jb	NoWrap3 		;no, continue
	sub	bx,BUFFERSIZE		;wrap around to begining
NoWrap3:
	cCall	GetHelpMsgNcFill	;get message DX:AX into *(BX)
	or	al,al			; did an error occur
	jne	FillContextDone 	; yes, stop filling in buffers

	mov	oLastBuf,bx		; set oLastBuf = last legal buffer
	inc	numBuf			;record that a buffer is now in uses
	dec	di			;one more context use
	jne	FillAnotherNext 	;get another one if allowed
FillContextDone:

	;Ignore any errors, we have at least one buffer
	mov	uierr,0 		; clear any errors
	pop	bx			; pointer to buffer with our context

	dec	fNoDelBufs		; reset buffer delete pointer

FoundMatch:
	xor	ax,ax			; ax = 0 (no errors)
	mov	oCurTopic,bx		; update current buffer ptr.

BufferNc_Exit:
cEnd

;Rewrote with [45]
;***
;OpenHelpWindow - Open the help window and ready it to print text
;
;Purpose:
;	This routine will not only open the help window to the correct
;	size, but will adjust the size of the window to account
;	for the existance/non existance of the scroll bar.
;
;Entry:
;     ax = Size of window
;
;Exit:
;     None.
;****

DbPub OpenHelpWindow
cProc OpenHelpWindow,<NEAR>
cBegin
	cmp	pwndAct,OFFSET DGROUP:WndHelp ; in help window?
	je	InHelpWindow		; no, do not resize

	inc	ax			; add a line for scroll bar
InHelpWindow:
	cCall	WndHelpOpen,<AX>	; AX = actual size of window

	; We must always move the cursor to (0,0), otherwise the edit
	; manager may not realize that this is a new topic and would not
	; position it so that the first line is visible.

	xor	bx,bx			; cursor position is 0,0
	mov	ax,OFFSET DGROUP:wndHelp; window to receive the message
	push	ax			; save for second call
	cCall	MoveCursorPwnd,<AX,BX,BX> ; goto 0,0 in window

	cCall	GetInitialPos		; get initial position on screen

	cCall	MoveCursorPwnd,<DX,AX>	; goto hot link spot
cEnd

;***
;GetInitialPos - Calculate the initial cursor position in the help window
;
;Purpose:
;	Returns the initial cursor position in the help window.  This is
;	the (0 relative) coordinates of the first hot link (if it exists
;	and is visible), or (0,0).
;
;Entry:
;	None
;
;Exit:
;	(DX,AX) - initial Row/Column of the screen (0,0) or first hot spot
;
;Uses:
;	Per C Convention.
;****
cProc	GetInitialPos,<PUBLIC,NEAR>
cBegin
	DbChk	HoldBuf2		; lock down the hotspot

	test	HelpFlags,HLP_VARHELP	; are we in var help?
	jnz	Use00			; yes, there are no hotlinks

	mov	ax,1			; current row/column position
	mov	HtSpot.ColHS,ax 	
	mov	HtSpot.lineHS,ax	

DbAssertRel	oCurTopic,ne,0,UI,<GetInitialPos:oCurTopic invalid>
	mov	bx,oCurTopic
	lea	bx,[bx].bdlHelpText.BDL_seg
	mov	cx,OFFSET DGROUP:HtSpot
	dec	ax			; ax = 0
	cCall	HelpHlNext,<AX,BX,AX,DS,CX>
	or	ax,ax			; did we get a hot link?
	je	Use00			; no, use (0,0) as position
	mov	ax,HtSpot.ColHS 	; get position of hotlink
	mov	dx,HtSpot.lineHS	
	dec	dx			; make position 0 relative
	dec	ax
	
	; Make sure the hot link is visible.
	
	mov	cl,WndHelp.arcClipping.ayBottomArc
	sub	cl,WndHelp.arcClipping.ayTopArc ; CX = size of help window

	cmp	cl,dl			; within visible range?
	jae	GetInitialPos_Exit	; no, ignore the hotlink
Use00:
	xor	dx,dx
	xor	ax,ax

GetInitialPos_Exit:
	DbChk	FreeBuf2		; release HotSpot
cEnd

	subttl	Edit Manager Support Routines
	page



;Extracted and modified with revision [29].
;***
;GetHelpTitleStr - Returns the title for a given help topic
;
;Purpose:
;	Calculates the title, and returns it in bufStdMsg.
;	All titles are prefixed by "HELP: ".
;
;	Uses the ":n" information if the help file, if it exists.
;	Otherwise, returns the current context string.
;
;Entry:
;	pHelpBdl = *bdl containing decompressed help topic.
;	cbMaxSize = max title length allowed
;
;	If window help, curNc is the help context #
;	If dialog box help, szDialogHelpContext points to the current szContext
;
;Exit:
;	AX = number of characters in title
;	bufStdMsg = contains title.
;
;Uses:
;	Per Convention
;
;****
cProc	GetHelpTitleStr,<NEAR,PUBLIC>,<SI,DI>
parmW	pHelpBdl
parmW	cbMaxSize
cBegin

DbAssertTst	HelpFlags,nz,HLP_GOTBUF,UI,<GetHelpTitleStr:HLP_GOTBUF false>

	inc	fNoDelBufs		; do not delete buffers, we have
					; a generic ptr to a buffer

	; Setting fNoDelBufs is probably not needed as currently
	; pHelpBdl points to either oCurTopic or to a static
	; Bdl used by dialog help.	However, I doubt that we do any
	; allocs in this code, and I can not guarentee that pHelpBdl
	; is safe.


	mov	ax,MSG_HelpTitleQH	; first part of title ("MS-DOS Help: ")
	test	cmdSwitches,CMD_SW_QHELP ; /QHELP viewer?
	jnz	ghts1			;   YES, got title

	mov	ax,MSG_HelpTitle	; first part of title ("HELP: ")
ghts1:
	cCall	ListStdMsg,<AX> 	; put in bufStdMsg

	push	ax			; save length of static portion
	add	ax,OFFSET DGROUP:bufStdMsg ; ds:di = useful buffer
	xchg	di,ax
	mov	al,'n'			; look for ":nTITLE"
	cCall	GetHelpControlInfo,<pHelpBdl,cbMaxSize,ax> ; SI = *embedded title, if any
	or	si,si			; title found?
	jnz	AppendTitle		; brif so

	mov	si,szDialogHelpContext	; use current context string as title
					; for dialog box help
	cmp	pHelpBdl,offset DGROUP:bdlHelp	; title for dialog box help?
	je	AppendTitle		; brif so -- append string to title

	mov	bx,oCurTopic		; ptr to current topic data
	or	bx,bx			; is it valid?
	je	GetHelpTitleStr_Fail	; no, use MSG_HelpTitle for now

	push	ds			;push far address to load szContext
	push	di
	push	Word Ptr [bx].ContextNum+2 ; push context number
	push	Word Ptr [bx].ContextNum
	cCall	HelpSzContext		;Get text
	or	ax,ax			; did we succeed?
	je	GetHelpTitleStr_Fail	; no, exit with error

	;Strip off the filename at the begining of the context

	cCall	szSrchExcl,<di> 	; search for '!' in *di
	DbAssertRel ax,ne,0,UI,<GetHelpTitleStr: Illegal string from HelpSzContext>
	inc	ax			; point to chr beyond '!'
	xchg	si,ax			;di = *buffer, si = *szContext

AppendTitle:				; append title to bufStdMsg
					; DS:SI= *title
					; DS:DI= where to put it

	pop	bx			; BX = length of static portion
	push	ds			; ES = DS for string ops
	pop	es			

AnotherChar:				
	lodsb				; append szTitle to "HELP:" in
	stosb				; bufStdMsg
	inc	bx			; seen another char
	or	al,al			; more chars to do?
	jnz	AnotherChar		; brif so
	dec	bx			; don't  include NULL in count

	cmp	bx,cbMaxSize		; is it larger than we want to return
	jbe	GetHelpTitleStr_Exit	; no, exit
	mov	bx,cbMaxSize-1		; return maximum size (without NULL)
	mov	byte ptr [bufstdMsg+bx+1],al ; truncate the string

GetHelpTitleStr_Exit:			
	xchg	ax,bx			; return count in AX

	SKIP1_PSW			; skip the pop ax
GetHelpTitleStr_Fail:			
	pop	ax			; get length in case of error
	dec	fNoDelBufs		; reenable buffer deletes.
	DbAssertRel ax,be,cbMaxSize,UI,<GetHelpTitleStr: title too big>
cEnd

;Added with revision [29].
;***
;GetHelpContextLen - Returns the length to use for a given help topic
;
;Purpose:
;	Returns the suggested # lines to use to display a topic.
;	Uses ":lLENGTH" if it exists. Otherwise, returns the total # lines
;	in the topic.
;
;Entry:
;	pHelpBdl = *bdl containing decompressed help topic.
;
;Exit:
;	AX = number of lines to use
;
;Uses:
;	Per Convention
;
;****
cProc	GetHelpContextLen,<NEAR,PUBLIC>,<SI,DI>
parmW	pHelpBdl
cBegin
	inc	fNoDelBufs		; do not delete buffers, we have
					; a generic ptr to a buffer

	; Setting fNoDelBufs is probably not needed as currently
	; pHelpBdl points to either oCurTopic or to a static
	; Bdl used by dialog help.	However, I doubt that we do any
	; allocs in this code, and I can not guarentee that pHelpBdl
	; is safe.

	mov	di,OFFSET DGROUP:bufStdMsg ; ds:di = useful buffer
	mov	cx,6			; max len we care about
	mov	al,'l'			; look for ":l<LENGTH>"
	cCall	GetHelpControlInfo,<pHelpBdl,cx,ax> ; SI = *embedded len,
	or	si,si			; length found?
	jz	GetTotalLines		; brif not -- get the line count

	push	si			; arg on stack
	call	_atoi			; AX = result
	pop	bx			; clean stack (C calling conventions)
	jmp	SHORT GetHelpContextLen_Exit

GetTotalLines:
	cCall	SizeHelpContext,<pHelpBdl> ;AX = # lines in context
					; sets iFileSize

GetHelpContextLen_Exit:
	dec	fNoDelBufs		 ; reenable buffer deletes.
cEnd


;Extracted and modified with revision [29].
;***
;GetHelpControlInfo
;
;Purpose:
;	Returns the control information in a given help context, if any.
;
;Entry:
;	pHelpBdl = * bdl containing decompressed help topic
;	cbMaxSize = biggest line to get.
;	cChar = control char to look for (usually 'n' or 'l').
;
;	DS:DI = * place to put result
;
;Exit:
;	DS:SI = * embedded help control info
;
;Uses:
;	Per convention, plus SI
;****

cProc	GetHelpControlInfo,<NEAR>
parmW	pHelpBdl		; * bdl of current help context
parmW	cbMaxSize		; biggest string allowed
parmW	cChar			; control char to search for (l or n)
cBegin

DbAssertRelB	fNoDelBufs,ne,0,UI,<GetHelpControlInfo:fNoDelBufs not set>

	; This routine does not have to worry about error handling for
	; HelpGetLine.	If there is any error in trying to get the
	; proper line, we will just assume that there were no more
	; lines.

	mov	bx,pHelpBdl	; BX = *bdl of current help topic

	GETSEG	es,[bx].BDL_seg,bx,SIZE	; ES = context data segment
	mov	ax,-1			; AX = undefined for blasting help
	mov	es:[lnCurTH],ax 	; reset current line counter
					; so engine doesn't get confused
	xchg	es:[linCharTH],al	; don't ignore any lines
	push	ax			; save line rejection char

	xor	si,si			; start at line 0

AnotherLine:
	inc	si			; advance to next line
	lea	bx,[bx].BDL_seg 	; BX = handle of data segment
	xor	ax,ax			; AX = context data offset (0)
	cCall	HelpGetLine,<si,cbMaxSize,ds,di,bx,ax>
	mov	bx,pHelpBdl		; BX = *bdl of current help topic
	or	ax,ax			; any more lines?
	jz	NoEmbeddedInfo		; brif not
	mov	ax,[di]			; AX = first 2 chars
	cmp	al,':'			; ":" command?
	jne	NoEmbeddedInfo		; brif not -- they must come first
	cmp	ah,byte ptr (cChar)	; the one we are searching for?
	jne	AnotherLine		; brif not -- get another line

	mov	si,di			; DS:SI = *szTitle
	inc	si			; skip the ":"
	inc	si			; skip the control char
	SKIP2_PSW			; skip the XOR SI,SI
NoEmbeddedInfo:
	xor	si,si			; no szTitle found
	pop	ax			; restore old line rejection char
	GETSEG	es,[bx].BDL_seg,bx,SIZE ; ES = context data segment
	xchg	es:[linCharTH],al	; restore old line rejection char
DbAssertRel	AX,E,-1,UI,<GetHelpControlInfo: AX should be -1>
	mov	es:[lnCurTH],ax 	; reset current line counter
					; so engine doesn't get confused

cEnd

;***
;SizeHelpContext
;
;Purpose:
;	Added with revision [2].
;
;	Returns total # of lines of help text for a given context, for use
;	in dialog box re-sizing, and scroll bar updating.
;
;
;Entry:
;	bdlText	= * BDL containing a decompressed help context.
;
;Exit:
;	AX = iFileSize = # lines of help text present in this context.
;
;Uses:
;	Per Convention
;
;****

cProc	SizeHelpContext,<PUBLIC,NEAR>,<SI,DI>
ParmW	bdlText
cBegin
	mov	di,bdlText			; DI = *context BDL
	xor	si,si				; SI = count of # lines

Again:
	inc	si				
	mov	cx,offset DGROUP:bufStdMsg	; CX = &dummy sz
	mov	dx,CB_bufStdMsg			; DX = cbMax
	xor	ax,ax				; AX = context data offset (0)
	lea	bx,[di].BDL_seg 		; BX = handle of data seg
	cCall	HelpGetLine,<SI,DX,DS,CX,BX,AX>	
	or	ax,ax				; success?
	jnz	Again				; brif so -- try again

	xchg	ax,si				; AX = # lines + 1
	dec	ax				; return AX = # lines
	mov	iFileSize,ax			; save # lines
cEnd


;***
;CmdHelpClose - Close the help window (from ESC)
;
;Purpose:
;	Close the help window.	Attached to the ESC accelerator.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per C Convention
;
;****

cProc	CmdHelpClose,<PUBLIC,NEAR>
cBegin
	mov	oCurTopic,0		; indicate no valid help
	cCall	WndHelpClose		; close the window
cEnd


	subttl	Miscellanious Help Routines
	page

;***
;GetNextNc	- Advance a NC to the next topic
;
;Purpose:
;	Get the next physical context number given a context num.
;	Will not wrap from one file to another.
;
;Entry:
;	DX:AX = current context number
;
;Exit:
;	if ZF set (zero)
;	   No next topic
;	   CX = 0
;	   AL = error code	(HELP_HANDLED, HELP_NF)
;	else
;	   DX:AX is context number
;	   CX != 0
;
;Uses:
;	Per C Convention
;
;****

cProc	GetNextNc,<PUBLIC,NEAR>
cBegin
	and	HelpFlags,NOT (HLP_FAILFNF OR HLP_FAILOOM); clear errors
	push	dx				; value to compare against
	push	dx				; push current context number
	push	ax
	cCall	HelpNcNext			; get next Context Num
	pop	bx
	cmp	bx,dx				; is it in a different file?
	jne	GetNextNc_Err			; yes, give error
	mov	cx,ax				; check if no more contexts
	or	cx,dx				; NZ & CX != 0 if no error
	jnz	GetNextNC_exit			; exit if success
GetNextNc_Err:
	mov	al,HELP_HANDLED 		; assume handled error
	test	HelpFlags,HLP_FAILFNF OR HLP_FAILOOM ; was it?
	jnz	GetNextNc_Err2			; yes, use this code
	mov	al,HELP_NF			; context not found
GetNextNc_Err2:
	xor	cx,cx				; set CX = 0, ZF
GetNextNc_exit:
cEnd


;***
;CreateContext - convert a number into a context string
;char *(NEAR CreateContext(iContextNumber ))
;
;Purpose:
;	This routine takes a number and an initial character and
;	creates a context string out of it. The context string will
;	be of the form	"-1234" were '-' is the character and "1234"
;	is an ASCII representation of the number.  The string is
;	returned in a static buffer.
;
;	The number must be 0 < iContextNumber < 32768
;
;Entry:
;	iContextNumber : integer which will be remaining digits
;
;Exit:
;	AX = pSz : near pointer to string with results
;
;Uses:
;	AX, BX, CX, DX.
;
;****

cProc	CreateContext,<NEAR,PUBLIC>
	parmW	HelpId			
cBegin
	mov	al,VT_I2		;Format an integer
	lea	bx,HelpId		; BX = ptr to number to format

	DbAssertRel [bx],g,0,UI,<CreateContext: Bad Help ID>

	call	B$IFOUT 		;BX = address of 0 terminated string

	mov	BYTE PTR [bx],PREFIX_MESSAGE ; Replace space with character
					; that belongs in first postion
	xchg	ax,bx			;return *sz in AX
cEnd

;***
;ShrinkHelp - Compress Help system memory usage
;
;Purpose:
;	Reduce the amount of memory that the help system uses without
;	impeeding the functionallity of the help system.
;
;	WARNING!!!
;	    Any time that this routine may be called (i.e. any time an alloc
;	    is done), you must either set fNoDelBufs or guarentee that
;	    numBuf = 0, or guarentee that oCurTopic, oFirstBuf and oLastBuf
;	    are correct.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per C Convention.
;
;****
cProc	ShrinkHelp,<PUBLIC,FAR>
cBegin

	DbHeapMoveOff			; FH callback can't cause movement

	test	HelpFlags,HLP_NOSHRINK	; are we allowed to call HelpShrink?
	jnz	NoHelpShrink		; no, check for deleting buffers
	cCall	HelpShrink		; Tell help engine to shrink down
NoHelpShrink:


	cmp	fNoDelBufs,0		; Can we delete help buffers also?
	jnz	ShrinkHelp_Exit 	; no, just return

	xor	cx,cx
	mov	cl,numBuf		; cx = # buffers in use
	jcxz	ShrinkHelp_Exit 	; exit if there are none
	cmp	oCurTopic,0		; do we have a current topic?
	jz	NoCurrentTopic		; no, do not keep it in memory
	dec	cx			; do not delete the current topic
NoCurrentTopic:
	cCall	FlushBuffer		; delete CX buffers
ShrinkHelp_Exit:


	DbHeapMoveOn			; remove our lock on the heap
cEnd

;***
;CompressHelp - Close down the help system
;
;Purpose:
;	This routine is called before we execute any user code so that
;	the help system can release all the memory that it does not need.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	AX,BX,CX,DX
;
;Preserves:
;	ES
;****

cProc	CompressHelp,<PUBLIC,FAR>,<ES>	
cBegin
	DbHeapMoveOff			; we are called from FHAlloc
					; not allowed to move heaps

	test	HelpFlags,HLP_GOTBUF	; Help system started?
	jz	NoFreeHelpBuffer	; brif not -- nothing to do

	cmp	fHelpAlloc,0		; doing a help alloc?
	jnz	NoFreeHelpBuffer	; yes, do not shut down help system

	xor	ax,ax			; Nc of 0 => close all files
	cCall	HelpClose,<AX,AX>	; Shut down the help engine

	; we will ignore any file errors on the close


	cCall	DiscardHelpBookMarks	; free bookmark ptrs into help


NoHelpBuffer:
	xor	ax,ax			; get a convenient 0
	mov	iStaticHelpTopic,ax	; clear current search topic
	mov	oCurTopic,ax		; clear current topic ptr.
	mov	iCurRequestLine,ax	; clear GetHelpLine succeeded flag

	; zero the initial context number
	mov	WORD PTR ncInitial,ax	
	mov	WORD PTR ncInitial+2,ax

	or	HelpFlags,HLP_COMPRESS	; flag help has been compressed
	cCall	DrawDebugScr		; make sure screen is redrawn.

DbAssertRel	BdlHelpHist.BDL_Seg,ne,UNDEFINED,UI,<CompressHelp:HLP_GOTBUF is true, but no HistoryBuf Allocated>
	PUSHI	ax,<OFFSET DGROUP:BdlHelpHist>	; Free up the history buf
	cCall	BdlFree 		
	mov	cl,numBuf		; number of buffers to deallocate
	xor	ch,ch			
	cCall	FlushBuffer		; Delete all the help buffers
	and	HelpFlags,NOT HLP_GOTBUF ; indicate buffer unallocated

NoFreeHelpBuffer:
	DbHeapMoveOn			; remove our heap lock
cEnd



; ReWrote with [39]
;***
;GiveHelpOOM - Queue a message to give OOM for Help
;
;Purpose:
;	Indicate to the error handling code that an OOM error has occured
;	in the help system.  This routine may be called as many times as
;	desired before DisplayHelpOOM is called, and the error will only
;	be reported once.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	By Convention
;
;****

cProc	GiveHelpOOM,<PUBLIC,NEAR>
cBegin
	or	HelpFlags,HLP_FAILOOM	; indicate We failed due to OOM
	mov	ax,MSG_HelpOOM		
	cCall	SetUiErr,<AX>		
cEnd

;Added with [39]
;***
;DisplayHelpOOM - Display an OOM error
;
;Purpose:
;	Displays an OOM error messages box for help, closes the help window,
;	and resets static variables.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;****

cProc	DisplayHelpOOM,<PUBLIC,NEAR>
cBegin

DbAssertTst	HelpFlags,e,HLP_INHELP,UI,<DisplayHelpOOM: Recursion lock already set>
	or	HelpFlags,HLP_INHELP	; set the recursion lock

	
	;We must save the HelpId in case the user does something like:
	;   Error 1	      -> displays a dialog box
	;   F1		      -> gets help, runs out of memory
	;   we call MsgBoxStd -> blows away iHelpId
	;   OK to message     -> back to original dialog box
	;   F1		      -> trys help again, iHelpId is invalid
	
	push	iHelpId

	PUSHI	ax,MB_OK		; Box has OK button
	PUSHI	ax,MSG_HelpOOM		; message to be displayed
	call	MsgBoxStd		; put up a dialog box
	and	HelpFlags, NOT HLP_INHELP ;remove recursion lock
	push	Word Ptr fHelpAlloc	; save the help alloc flag
	mov	fHelpAlloc,0		; zero it so CompressHelp will
	call	CompressHelp		; get help system out of the way
	mov	uierr,0 		; clear out the error condition
	pop	ax			; get fHelpAlloc back
	mov	fHelpAlloc,al		; and restore it.
	pop	iHelpId 		; restore HelpId
cEnd


;Rewritten with [38]
;***
;FlushBuffer - Deallocates buffers from HelpBuffer
;
;Purpose:
;	This routine will deallocate all buffers from (but not including)
;	the current topic to the end of the buffer.  If this is not enough,
;	it will start deleting buffers from the begining, until the specified
;	number has been reached.
;
;	If there is no current topic, we will just delete buffers from the
;	begining until we have freed enough.
;
;Entry:
;	CX = minimum # buffers to deallocate
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;****

cProc	FlushBuffer,<NEAR>,<SI,DI>
cBegin

	DbHeapMoveOff

DbAssertRelB	cl,be,MAX_HELPBUFS,UI,<FlushBuffer: Deallocating more buffers than exist>

	mov	di,cx			; DI = # buffers to delete
	cmp	oCurTopic,0		; is oCurTopic invalid?
	je	DelBegin		; yes, just delete from the begining
	mov	si,oLastBuf		; get pointer to last buffer
DelEnd_Next:

	cmp	si,oCurTopic		; have we reached the current topic?
	je	DelBegin		; yes, start deleting from begining

	lea	ax,[si].bdlHelpText	; ax = ptr to BDL in first buffer
	cCall	BdlFree,<ax>		; get rid of it

	dec	numBuf			; indicate it is no longer in use
	sub	si,BUFSIZE		; point at the last buffer
	cmp	si,OFFSET DGROUP:HelpBuffer ;did we go off the end?
	jae	NoWrap5 		; no
	add	si,BUFFERSIZE		; wrap around
NoWrap5:
	mov	oLastBuf,si		; update oLastBuf
	dec	di			; one more buffer deleted
	jmp	short DelEnd_Next	; go try again

DelBegin:
	or	di,di			; is it 0 or negative
	jle	EndFlushBuffer		; yes, exit
	mov	si,oFirstBuf		; get pointer to first buffer
DelBegin_Next:
	lea	ax,[si].bdlHelpText	; ax = ptr to BDL in first buffer
	cCall	BdlFree,<ax>		; get rid of it

	dec	numBuf			; indicate it is no longer in use

	add	si,BUFSIZE		; Point SI at next buffer
	cmp	si,BUFFEREND		; did we go off end of buffer?
	jb	NoWrap1 		; no, continue
	sub	si,BUFFERSIZE		; wrap around to begining
NoWrap1:
	dec	di			; one less to do
	jnz	DelBegin_Next		; loop again
	mov	oFirstBuf,si		; restore ptr to first buffer

EndFlushBuffer:
	DbHeapMoveOn			; reeanble heap movement

cEnd


;Reorganized with [43]
;***
;StartHelp : make sure the help system is initialized (or reinitialized)
;
;Purpose:
;	This routine is called before any references to the help buffers
;	or the help engine are made.  It makes sure the help engine is
;	activated, the help file exists, and the buffers for the virtual
;	line system are initialized.
;
;Entry:
;	None.
;
;Exit:
;	AX = 0	if all OK
;	AX = HELP_HANDLED if an error occured (will be handled).
;
;Uses:
;	Per Convention
;
;****

cProc	StartHelp,<PUBLIC,NEAR>
cBegin
DbAssertRelB	fHelpAlloc,ne,0,UI,<StartHelp:fHelpAlloc not set>

	test	HelpFlags,HLP_GOTBUF	; do we have the buffers?
DJMP	jnz	StartHelp_Success	; yes, exit with return code

	
	;Try to start help engine
	
StartHelpEngine:

DbAssertRel	BdlHelpHist.BDL_Seg,e,UNDEFINED,UI,<StartHelp:History Buffer Valid without HLP_GOTBUF>
	PUSHI	ax,<OFFSET DGROUP:BdlHelpHist>
	PUSHI	ax,HELPHIST_END 	; # bytes to allocate
	cCall	BdlAlloc		; allocate the memory
	or	ax,ax			; did we get the memory?
	jnz	InitHistBuff		; yes, go initialize it
	cCall	GiveHelpOOM		; queue an OOM error

	mov	ax,sp			; return a non-zer value
	jmp	short StartHelp_Exit

InitHistBuff:
	GETSEG	es,BdlHelpHist.BDL_Seg,bx,SIZE	; get segment
	xor	bx,bx
	mov	ES:[bx].HH_Used,bx	; initialize # elements in use
	mov	WORD PTR ES:[bx].HH_First,HELPHIST_BEGIN ; initialize ptr
	
	;Initialize HelpBuffer
	
	push	di			; Save register
	push	ds			; Set ES=DS=DGROUP
	pop	es
	mov	ax,UNDEFINED		; value to initialize buffers with
	mov	cx,BUFFERSIZE/2 	; number of words in buffer
	mov	di,OFFSET DGROUP:HelpBuffer   ; start of buffer
	mov	oFirstBuf,DI		; initialize buffer pointers
	mov	oLastBuf,DI
	rep	stosw			; initialize buffer
	mov	numBuf,CL		; initialize num in use (=0)

	pop	di			; Restore register
	or	HelpFlags,HLP_GOTBUF

StartHelp_Success:
	xor	ax,ax			; return code of success

StartHelp_Exit:
cEnd


;Rewritten with revision [57]
;***
;CalcNc - Calculate a Context Number from a Context string
;
;Purpose:
;	Go though our list of help files, calling HelpNc with the
;	initial context number for each one.  If a help file is not
;	opened, then try to open it before calling HelpNc.
;
;	If the context number is not found and there have been any
;	dialog boxes displayed (or OOM), then return HELP_HANDLED.
;	Otherwise return HELP_NF.
;
;Entry:
;	npsz - Near pointer to context string
;
;Exit:
;	if (CX <> 0)
;	    DX:AX = Context Number
;	else
;	    AL = Error Code (HELP_NF, HELP_HANDLED)
;
;Uses:
;	Per Convention
;
;****

cProc	CalcNc,<PUBLIC,NEAR>,<SI,DI>
parmW	npsz
localB	retVal				; value to return on error
cBegin
	mov	retVal,HELP_NF		; default error code is HELP_NF

	mov	cx,offset szHelpFileQhelp; cs:cx = ptr to file name
	call	fQhelpActive		; are we in the help viewer
	jnz	InQhelp 		; brif so, have proper file name
	mov	cx,offset szHelpFileEdit; cs:cx = ptr to file name
	call	fEditorActive		; are we in the editor
	jnz	InQhelp 		; brif so, have proper file name
	mov	cx,offset szHelpFileInterp ; use help file for interpreter
InQhelp:

	mov	dx,WORD PTR ncInitial	; dx = high word of ncInitial
	mov	ax,WORD PTR ncInitial+2 ; ax = low word of ncInitial

	mov	bx,npsz 		; get a ptr to the string
	cmp	Byte Ptr [bx],0 	; is it a local context?
	jne	NotLocalContext 	; no, check if we have to open file
DbAssertRel	oCurTopic,ne,0,UI,<CalcNc:oCurTopic invaid>
	mov	bx,oCurTopic		; get ptr to current topic
	mov	ax,Word Ptr [bx].ContextNum ; use current NC as the initial NC
	mov	dx,Word Ptr [bx].ContextNum+2

NotLocalContext:
	mov	bx,ax			; do we have a context #?
	or	bx,dx
	jnz	GotHelpFile		; brif so -- try the lookup

	cCall	HelpOpen,<cs,cx>	; try to open the file.
					; DX:AX = ncInitial, or 0:x if failure
	or	dx,dx			; was there an error?
	jnz	SaveInitialNc		; no
	cmp	ax,HELPERR_MAX		; check the low word
	jae	SaveInitialNc		; no error, continue processing

	.erre	HELPERR_MAX LT 256	; make sure all errors fit in a byte
	.errnz	HELPERR_FNF - 1 	; these two errors should be first
	.errnz	HELPERR_READ - 2

;HELPERR_READ => error already given
;HELPERR_FNF  => error already given
; error 7     => error already given
;HELPERR_LIMIT => assert that this doesn't happen (25 help files)
;HELPERR_BADAPPEND => give ER_BFM
;HELPERR_NOTHELP => give ER_BFM
;HELPERR_BADVERS => give ER_BFM
;others        => whatever is convenient

	mov	retVal,HELP_HANDLED	; set a new return value
DbAssertRel	ax,ne,HELPERR_LIMIT,UI,<CalcNC:HELPERR_LIMIT from HelpEngine>
	cmp	ax,HELPERR_READ 	; have we already informed user?
DJMP	jbe	CalcNcExit_Err		; yes, exit in error
	cmp	ax,7			; another error we told user about?
DJMP	je	CalcNcExit_Err		; yes, exit

DbAssertTst	HelpFlags,z,HLP_INHELP,UI,<HelpStart:Recursion lock set>
	or	HelpFlags,HLP_INHELP	; set recursion lock
	PUSHI	ax,MB_OK		; only an OK button
	PUSHI	ax,ER_BFM		; It must be a bad help file
	cCall	MsgBoxStd		; display error
	and	HelpFlags,NOT HLP_INHELP ; clear recursion lock
	jmp	CalcNCExit_Err		; and exit

SaveInitialNc:
	mov	WORD PTR ncInitial+2,ax	; save NC
	mov	WORD PTR ncInitial,dx	

GotHelpFile:
	and	HelpFlags,NOT (HLP_FAILOOM OR HLP_FAILFNF) ; clear flags

	cCall	HelpNc,<ds,npsz,dx,ax>	; DX:AX = nc for this context str

	test	HelpFlags,HLP_FAILOOM OR HLP_FAILFNF ; a handled error?
	jz	CheckForSuccess 	; no, check to see if we succeeded
	mov	retVal,HELP_HANDLED	; update return code otherwise

CheckForSuccess:
	mov	cx,dx
	or	cx,ax			; cx != 0 iff we got the topic
	jnz	CalcNcExit		; brif ok -- we got the NC

CalcNcExit_Err:
	xor	cx,cx			; set cx in case of error
	mov	al,retVal		; return error code
CalcNcExit:				;DX:AX = context #, or 0
cEnd


; Constants used by DoStatusButton().  All added with revision [10].

; NOTE: These messages must remain in sync with QBIMSGS.TXT so that the
; NOTE: status line buttons work properly.
; NOTE:
; NOTE: How to change the text of a message:
; NOTE: 
; NOTE: 1. Make sure that the new message will not overflow the status
; NOTE:    line.  If it will, text changes are required, or a button
; NOTE:    must be removed.
; NOTE: 2. Make the change to the text in QBIMSGS.TXT
; NOTE: 3. Make the change to the text in UINHELP.ASM
; NOTE: 4. Adjust the button position #'s in UINHELP.ASM
; NOTE:
; NOTE: How to add/remove a button:
; NOTE: 
; NOTE: 1. Perform the steps required to change the status line text
; NOTE: 2. Inc/Dec the # of buttons constant in the appropriate
; NOTE:    StatusXXXTable list.
; NOTE: 3. Add/Remove the Button_XXX constant corresponding to the
; NOTE:    desired key from the appropriate StatusXXXTable list.
; NOTE:


                                ; <Shift+F1=Help> <Possible other fields>
                        ;         ^              ^
All_ob1_F1      EQU 1       ;---------+                              |
All_ob2_F1      EQU 16 ;------------------------+

;Editing
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;                       <Shift+F1=Help> <F6=Window> <F2=Subs> <F5=Run> <F8=Step>
;                                                                 ^                      ^^               ^^              ^^                    ^
Edit_ob1_F6 EQU 17          ;-+                       ||                    ||              ||       |
Edit_ob2_F6 EQU 28          ;------------+|                 ||              ||       |
Edit_ob1_F2 EQU 29          ;-------------+                 ||              ||       |
Edit_ob2_F2 EQU 38          ;----------------------+|                       ||       |
Edit_ob1_F5 EQU 39          ;-----------------------+                       ||       |
Edit_ob2_F5 EQU 47          ;-------------------------------+|               |
Edit_ob1_F8 EQU 48          ;--------------------------------+               |
Edit_ob2_F8 EQU 57          ;-----------------------------------------+

;Program running (debugging):
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F5=Continue> <F9=Toggle Bkpt> <F8=Step>
;                         ^            ^^               ^^        ^
Running_ob1_F5 EQU 17       ;-+                             ||                                ||                    |
Running_ob2_F5 EQU 30       ;--------------+|                                 ||                    |
Running_ob1_F9 EQU 31       ;---------------+                                 ||                    |
Running_ob2_F9 EQU 47       ;-------------------------------+|                      |
Running_ob1_F8 EQU 48       ;--------------------------------+                      |
Running_ob2_F8 EQU 57       ;-----------------------------------------+

;Immediate window active:
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F6=Window> <Enter=Execute Line>
;                         ^          ^^                   ^
Immed_ob1_F6    EQU 17      ;-+                      ||                                              |
Immed_ob2_F6    EQU 28      ;------------+|                                          |
Immed_ob1_ENTER EQU 29      ;-------------+                                          |
Immed_ob2_ENTER EQU 49      ;---------------------------------+

;Help window active:
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         <Shift+F1=Help> <F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>
;                         ^          ^^           ^^             ^^            ^
Help_ob1_F6 EQU 17  ;-+                      ||                       ||                              ||                             |
Help_ob2_F6 EQU 28  ;------------+|                   ||                              ||                             |
Help_ob1_ESC    EQU 29      ;-------------+                   ||                              ||                             |
Help_ob2_ESC    EQU 41      ;-------------------------+|                              ||                             |
Help_ob1_CTRLF1 EQU 42      ;--------------------------+                              ||                             |
Help_ob2_CTRLF1 EQU 56      ;----------------------------------------+|                              |
Help_ob1_ALTF1 EQU 57       ;-----------------------------------------+                              |
Help_ob2_ALTF1 EQU 70       ;------------------------------------------------------+

;[67] Editing in QEDIT
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;         MS-DOS Editor  <F1=Help> Press ALT to activate menus
;                        ^       ^
;                        |       |
QEdit_ob1_F1    EQU 16       ;  |           ;[73]
QEdit_ob2_F1    EQU 25       ;-------+                      ;[73]


;[67] Help window active: QEDIT
;        00000000001111111111222222222233333333334444444444555555555566666
;        01234567890123456789012345678901234567890123456789012345678901234
;         <F1=Help> <F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>
;         ^       ^ ^          ^^           ^^             ^^            ^           ^
QHelp_ob1_F1    EQU 01     ;                ||                       ||                              ||                             |
QHelp_ob2_F1    EQU 09     ;                ||                       ||                              ||                             |
QHelp_ob1_F6    EQU 11  ;           ||                       ||                              ||                             |
QHelp_ob2_F6    EQU 22  ;------ |                    ||                              ||                             |
QHelp_ob1_ESC   EQU 23  ;-------+                    ||                              ||                             |
QHelp_ob2_ESC   EQU 35  ;-------------------+|                               ||                             |
QHelp_ob1_CTLF1 EQU 36      ;--------------------+                            ||                             |
QHelp_ob2_CTLF1 EQU 50      ;----------------------------------+|                            |
QHelp_ob1_ALTF1 EQU 51  ;-----------------------------------+                               |
QHelp_ob2_ALTF1 EQU 64  ;------------------------------------------------+


; QHELP help viewer start-up status: MSG_StatusQHStart
;        000000000011111111112222222222333333333344444444445555555555
;        012345678901234567890123456789012345678901234567890123456789
;	  MS-DOS Help Viewer  <F1=Help> Press ALT to activate menus
;			      ^       ^
;			      |       |
QHStart_ob1_F1    EQU 21 ;       |
QHStart_ob2_F1    EQU 29      ;-------+


; QHELP help window active: MSG_StatusQHHelp
;	 00000000001111111111222222222233333333334444444444555555555566666666667
;	 01234567890123456789012345678901234567890123456789012345678901234567890
;         <Alt+C=Contents> <Alt+N=Next> <Alt+B=Back>
;         ^               ^^           ^^           ^
QHHelp_ob1_CONTS EQU 01 ; ||           ||           |
QHHelp_ob2_CONTS EQU 17 ;-+|           ||           |
QHHelp_ob1_NEXT  EQU 18 ;--+           ||           |
QHHelp_ob2_NEXT  EQU 30 ;--------------+|           |
QHHelp_ob1_BACK  EQU 31 ;---------------+           |
QHHelp_ob2_BACK  EQU 43 ;---------------------------+


labelNP <StatusTable>
	DW      UIOFFSET StatusEditTable
	DW      UIOFFSET StatusRunningTable
	DW      UIOFFSET StatusImmedTable
	DW      UIOFFSET StatusHelpTable
	DW      UIOFFSET StatusQeditTable       
	DW      UIOFFSET StatusQhelpTable       
	DW	UIOFFSET StatusQHStartTable
	DW	UIOFFSET StatusQHhelpTable

StatusButton STRUC
SB_Command      db      ?
SB_obStart      db      ?
SB_obEnd        db      ?
StatusButton ends

LabelNP <StatusEditTable>
	DB      5               ; # of buttons in Edit status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midNextWindow, Edit_ob1_F6, Edit_ob2_F6>
	StatusButton    <midViewSubs, Edit_ob1_F2, Edit_ob2_F2>
	StatusButton    <midRunContinue, Edit_ob1_F5, Edit_ob2_F5>
	StatusButton    <midStep, Edit_ob1_F8, Edit_ob2_F8>

LabelNP <StatusRunningTable>
	DB      4               ; # of buttons in Running status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midRunContinue, Running_ob1_F5, Running_ob2_F5>
	StatusButton    <midDebugToggleBp, Running_ob1_F9, Running_ob2_F9>
	StatusButton    <midStep, Running_ob1_F8, Running_ob2_F8>

LabelNP <StatusImmedTable>
	DB      3               ; # of buttons in Immediate status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midNextWindow, Immed_ob1_F6 , Immed_ob2_F6>
	StatusButton    <midEnter, Immed_ob1_ENTER, Immed_ob2_ENTER>

LabelNP <StatusHelpTable>
	DB      5               ; # of buttons in Help status message
	StatusButton    <midHelpHelp, ALL_ob1_F1, ALL_ob2_F1>
	StatusButton    <midNextWindow, Help_ob1_F6, Help_ob2_F6>
	StatusButton    <midHelpClose, Help_ob1_ESC, Help_ob2_ESC>
	StatusButton    <midHelpNext, Help_ob1_CTRLF1, Help_ob2_CTRLF1>
	StatusButton    <midHelpBack, Help_ob1_ALTF1, Help_ob2_ALTF1>

LabelNP <StatusQeditTable>
	DB      1               ; # of buttons in Edit status message
	StatusButton    <midHelpSyntax, Qedit_ob1_F1, Qedit_ob2_F1>

LabelNP <StatusQhelpTable>
	DB      5               ; # of buttons in Help status message
	StatusButton    <midHelpSyntax, QHelp_ob1_F1, QHelp_ob2_F1>
	StatusButton    <midNextWindow, QHelp_ob1_F6, QHelp_ob2_F6>
	StatusButton    <midHelpClose, QHelp_ob1_ESC, QHelp_ob2_ESC>
	StatusButton    <midHelpNext, QHelp_ob1_CTLF1, QHelp_ob2_CTLF1>
        StatusButton    <midHelpBack, QHelp_ob1_ALTF1, QHelp_ob2_ALTF1>

LabelNP <StatusQHStartTable>
	DB	1		; # of buttons in QHELP start status message
	StatusButton	<midHelpHowToUse, QHStart_ob1_F1, QHStart_ob2_F1>

LabelNP <StatusQHhelpTable>
        DB      3               ; # of buttons in QHELP Help status message
        StatusButton    <midHelpHelp,    QHHelp_ob1_CONTS, QHHelp_ob2_CONTS>
        StatusButton    <midHelpNext,    QHHelp_ob1_NEXT , QHHelp_ob2_NEXT >
        StatusButton    <midHelpBack,    QHHelp_ob1_BACK , QHHelp_ob2_BACK >


;***
;HStatusButton
;       Given a mouse position in the status line window, return
;       a handle to the status button at that position.
;
;Purpose:
;       Heavy modification in revision [52]
;
;Entry:
;       posX = 0-relative mouse position
;Exit:
;       AX - handle to the status button or NULL if no button.
;            The handle is actually a pointer into the code segment.
;Uses:
;       Per Convention
;****

cProc   HStatusButton,<PUBLIC,NEAR>,<SI>
	ParmW   posX
cBegin
	xor     si,si                   ;Default return value: NULL

	mov     bx,iMsgStatusLine       ; bx = current line displayed
	sub     bx,MSG_StatusEdit       ; bx = 0, 1, 2, 3, or invalid
        cmp     bx,(MSG_StatusQHhelp - MSG_StatusEdit) ; out of range?
	ja      ButtonExit              ; brif so -- just exit

	shl     bx,1                    ; word index
	mov     si,word ptr cs:[bx].StatusTable

	mov     bx,[posX]               ; bx = 0-relative position
	lods    byte ptr cs:[si]        ; AL = number of entries for this line
	cbw                             
	xchg    cx,ax                   ; CX = number of entries
ButtonLoop:
	inc     si                      ;Ignore the SB_Command
	lods    word ptr cs:[si]        ;AH = obEnd, AL = obStart
	cmp     bl, al
	jb      ButtonNotFound
	cmp     bl, ah
	jb      ButtonFound
	loop    ButtonLoop
ButtonNotFound:
	mov     si,SIZE StatusButton    ;return NULL
ButtonFound:
	sub     si,SIZE StatusButton    ;point back to begining of structure.
ButtonExit:
	mov     ax, si
cEnd

;***
;ObStatusButton - Returns the position of a Status Line Button
;
;Purpose:
;       Return the position of the specified Status Button.
;
;       new for revision [52]
;
;Entry:
;       hButton - handle to button (near pointer in CS)
;
;Exit:
;       AX - Offset in characters from the beginning of the status line.
;
;Preserves:
;
;****
cProc ObStatusButton,<NEAR,PUBLIC>
	parmW   hButton
cBegin
	mov     bx, [hButton]
	xor     ax,ax
	mov     al, cs:[bx.SB_obStart]
cEnd

;***
;CbStatusButton - Returns the number of characters in a Status Line Button
;
;Purpose:
;       Return the number of characters in the specified Status Button.
;
;       new for revision [52]
;
;Entry:
;       hButton - handle to button (near pointer in CS)
;
;Exit:
;       AX - Size of button.
;
;Preserves:
;
;****
cProc CbStatusButton,<NEAR,PUBLIC>
	parmW hButton
cBegin
	mov     bx, [hButton]
	mov     al, cs:[bx.SB_obEnd]
	sub     al, cs:[bx.SB_obStart]
	xor     ah,ah
cEnd

;***
;DoStatusButton - Posts the key message associated with a Status Line Button
;
;Purpose:
;       Post the WM_CHAR message for the specified Status Button.
;
;       new for revision [52]
;
;Entry:
;       hButton - handle to button (near pointer in CS)
;
;Exit:
;       None.
;
;Preserves:
;
;****
cProc DoStatusButton,<NEAR,PUBLIC>
	parmW   hButton
cBegin
	mov     bx, [hButton]
	xor     dx,dx                           
	mov     dl,cs:[bx.SB_Command]           
	pushi   ax, <DATAOffset wndMain>        
	pushi   ax, WM_COMMAND                  
	push    dx                              
	xor     ax,ax
	push    ax
	push    ax
	call    PostMessage
cEnd

cEnd

;***
;RecordHelpHistory - Add entry to history list
;
;Purpose:
;       Record an entry into the help history list.  If the list is already
;       full, the last item gets bumped.
;
;Entry:
;       DX:AX   : item to be stored
;       BL      : flags to store with it        (EI_VARHELP Only)
;
;Exit:
;       None.
;
;Preserves:
;       AX,DX
;
;****

cProc   RecordHelpHistory,<NEAR,PUBLIC>,<DS>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<RecordHelpHistory:BdlHelpBack not initialized>

	GETSEG  ds,BdlHelpHist.BDL_Seg,bx,SIZE  ; get segment of data

	;NOTE: DS != DGROUP at this point

	ASSUMES DS,NOTHING

	xor     bx,bx                   ; look at location 0
	cmp     WORD PTR [bx].HH_Used,NUM_HISTORY ; all slots being uses?
	je      RecordOverwrite         ; yes, just overwrite last item
	inc     WORD PTR [bx].HH_Used   ; one more item being used
RecordOverwrite:
	mov     cx,[bx].HH_First        ; DX is location to stick item
	push    cx
	add     cx,SIZE HelpHistEntry   ; point CX at next entry
	cmp     cx,HELPHIST_END         ; at end of table?
	jb      NoTableWrap             ; no
	mov     cx,HELPHIST_BEGIN       ; point to begining of table
NoTableWrap:
	mov     [bx].HH_First,cx        ; save new initial location
	pop     bx                      ; restore previous starting loc
	mov     [bx].HH_HiWord,dx       ; save Hi word
	mov     [bx].HH_LoWord,ax       ; save lo word
	ASSUMES DS,DGROUP
cEnd

;***
;RetrieveHelpHistory - Get the last recorded item in help history list
;
;Purpose:
;       Retrieve the last item from the help history list.  Returns with CX=0
;       if no items are left.
;
;Entry:
;       None.
;
;Exit:
;       if CX <> 0
;           DX:AX   : item stored
;           BL      : flags stored with it (IF EI_VARHELP)
;       else
;           No items recorded
;
;****
cProc   RetrieveHelpHistory,<NEAR,PUBLIC>,<DS>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<RetrieveHelpHistory:BldHelBack not initialized>

	GETSEG  ds,BdlHelpHist.BDL_Seg,bx,SIZE  ; get segment of data
	
	;NOTE: DS != DGROUP at this point
	
	ASSUMES DS,NOTHING

	xor     bx,bx                   ; look at location 0
	mov     cx,[bx].HH_Used         ; CX = number of slots in use
	jcxz    RetrieveExit            ; no items, return with error
	
	;NOTE: CX <> 0 is preserved for rest of routine
	
	dec     WORD PTR [bx].HH_Used   ; indicate one less
	mov     ax,[bx].HH_First        ; AX = offset into table
	sub     ax,SIZE HelpHistEntry   ; point to previous entry
	cmp     ax,HELPHIST_BEGIN       ; before first entry?
	jge     NoRetrieveWrap          ; no, continue
	mov     ax,HELPHIST_END - SIZE HelpHistEntry ; set to last item
NoRetrieveWrap:
	mov     [bx].HH_First,ax        ; save new pointer
	xchg    bx,ax                   ; bx = ptr to entry to retrieve
	mov     dx,[bx].HH_HiWord       ; retrieve values and exit
	mov     ax,[bx].HH_LoWord
RetrieveExit:
	ASSUMES DS,DGROUP
cEnd

;***
;HelpHistoryLength - return number of items in the help history list
;
;Entry:
;       None
;
;Exit:
;       CX = number of items
;
;Uses:
;       CX,ES
;
;Preserves:
;       AX,BX,DX
;***

cProc   HelpHistoryLength,<NEAR>,<BX>
cBegin
	DbAssertRel BdlHelpHist.BDL_Seg,ne,NOT_OWNER,UI,<HelpHistoryLength:BldHelBack not initialized>

	GETSEG  es,BdlHelpHist.BDL_Seg,bx,SIZE  ; get segment of data
	mov     cx,ES:[0].HH_Used       ; CX = number of slots in use
cEnd



; added with [24], rewritten with [25]
;***
;DiscardHistoryoRs - Discard all Help + Bookmark information for an oRs
;
;Purpose:
;       Discards any stored information about a given oRs in the help system.
;       If the current help being displayed is dependent on this oRs, then we
;       will do a Help Back until something is found.  If nothing is found,
;       close the help window.
;
;Entry:
;       oRs - oRs to be discarded
;
;Exit:
;       None
;
;Uses:
;       Per C Conventions
;***

cProc   DiscardHistoryoRs,<PUBLIC,FAR>,<SI,DI>
parmW   oRs
cBegin
	mov     ax,UNDEFINED            ; indicates bookmark not valid
	cCall   ReAssignBookMark,<oRs,AX> ; delete all matching bookmarks



DiscardHistory_Exit:
cEnd


;***
;szSrchExcl - search for '!' in a 0 terminated string
;
;Purpose:
;       This routine scans a 0 terminated string to find an '!' in
;       it.
;
;Entry:
;       npsz    - Near Ptr to string to search
;
;Exit:
;       if character not found
;           AX = 0
;       else
;           AX = ptr to first occurance of the character
;
;Uses:
;       Per C convention
;****

cProc   szSrchExcl,<PUBLIC,NEAR>,<SI>
parmW   npsz
cBegin
	mov     si,npsz                 ; start of string to scan
NextChr:
	lodsb
	cmp     al,'!'                  ; is it the character of interest?
	je      FoundChr                ; yes, return its position
	or      al,al                   ; is it the 0 terminator?
	jne     NextChr                 ; no, try the next character.
	cbw                             ; AX = 0
	xchg    ax,si                   ; SI = 0  (return value)
FoundChr:
	xchg    ax,si                   ; AX = Ptr to str OR 0
cEnd


;***
;SendHelpMsg - Stub routine to send a message to the help window
;
;Purpose:
;       Code saving method of sending a message (with wParm only) to
;       the help window.
;
;Entry:
;       msg - message to send
;       wParam - one parameter to be passed
;
;Exit:
;       Return value from Window Proc
;
;
;****

cProc   SendHelpMsg,<PUBLIC,NEAR>
parmW   msg
parmW   wParam
cBegin
	mov     ax,OFFSET DGROUP:wndHelp
	cCall   SendMessage,<AX, msg, wParam, ax,ax>
cEnd


sEnd    UI
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\brkctl.inc ===
;***
;brkctl.inc - definitions and structure for brkctl
;
;	Copyright (c) 1987-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	The file contains brkctl command values and structure
;	definitions.
;
;*******************************************************************************

BR_ARGSEG= 1			; specified segment
BR_NEWSEG= 2			; new segment
BR_IMPSEG= 3			; last or new segment

MAXSEG_DOS =	20		; maximum brkctl segments for REAL mode
MAXSEG_OS2 =	256		; maximum brkctl segments for PROTECTED mode

segrec	struc			; defines brkctl segment offsets
	sz	dw      ?
	sg	dw      ?
segrec	ends

heaprec	struc			; defines heap descriptor offsets
	bottom	dw      ?
	roveroff dw      ?
	last	dw      ?
	top	dw      ?
	nextseg	dw      ?
heaprec	ends
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\cdata.inc ===
;***
;cdata.inc - 30-Jan-87 - C Run-time Shared Global Data
;***
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	The data items defined here  must  appear  first  in  the  DATA
;	segment  of  RT_DATA  because they must exactly match up between
;	the linked program and the separately linked run-time module.
;	This is also true of user libraries and the QB4 runtime.  This
;	file should be included in global.inc only.
;
;	All non-zero initialized data should be using the DEFDATA macro,
;	so that QLIB's will have a large uninitialized (or zero) data hole
;	that can be compressed.
;
;******************************************************************************

labelB	<PUBLIC,__anullsize>	;[6] label to "end" of _NULL for null pointer
				;[6] checking.  Any addr less than this is
				;[6] considered to be invalid.  Safe to put it
				;[6] at the beginning of our data, since we
				;[6] don't want to check null pointers.

; **********	Definitions copied from BRKCTL.INC	********************

MAXSEG_DOS = 20			; maximum brkctl segments for REAL mode
MAXSEG_OS2 = 256		;[6] maximum brkctl segments for PROTECTED mode

segrec		struc			; defines brkctl segment offsets
  sz		dw	?
  sg		dw	?
segrec		ends



; **********	Definitions copied from MSDOS.INC	********************

STACKSLOP	equ	256	; stack slop for interrupt overhead



; **********	Data taken from CHKSTK.ASM

DefData W,STKHQQ,<OFFSET DGROUP:_end+STACKSLOP> ;initial C stack low-water mark
;[2]  STKHQQ	dw	OFFSET DGROUP:_end+STACKSLOP ; initial value

DefData	D,__aaltstkovr,-1	;[3] alternate stack overflow
;[3] globalCP __aaltstkovr,-1	; alternate stack overflow


; **********	Data taken from CRT0MSG.ASM


; **********	Data taken from CRT0/5CRT0.ASM	****************************

;	these are used by DOS C memory management (not used in Windows)

globalW	__asizds,0 		; DS size (in bytes)
globalW	__atopsp,0 		; top of stack (heap bottom)
globalW __aexit_rtn,0		; NEAR pointer
;[2] globalW	__aexit_rtn,<OFFSET _TEXT:__exit> ; NEAR pointer
;[2] added

labelW	<PUBLIC,__abrktb> 	; segment table for brkctl
	dw	?
DefData W,,DGROUP
;	dw	DGROUP
	db	(MAXSEG_DOS-1) * (size segrec) dup (?)

labelW	<PUBLIC,__abrktbe>
DefData W,__abrkp,<OFFSET DGROUP:__abrktb>
;[2] globalW	_abrkp,<dataoffset _abrktb>


; **********	Data taken from CRT0DAT.ASM	****************************

;	special C environment string

labelB	<PUBLIC,__acfinfo>	;[2]


	cfile	db	';C_FILE_INFO'
	cfilex	db	0
	b$cfileln EQU cfilex-cfile


PUBLIC	b$cfileln		;[2]
	b$cfilex EQU cfilex	;[2]
PUBLIC	b$cfilex		;[2]


globalD	__aintdiv,0 		; divide error interrupt vector save

globalQ	__fac,0			; floating accumulator
globalW	_errno,0		; initial error code
globalW	__umaskval,0 		; initial umask value

;=============== following must be in this order

globalW	__pspadr,0 		; psp:0 (far * to PSP segment)
globalW	__psp,0			; psp:0 (paragraph #)

;=============== above must be in this order

;=============== following must be in this order

labelW	<PUBLIC,__osversion>
labelB	<PUBLIC,__dosvermajor>
globalB	__osmajor,0
labelB	<PUBLIC,__dosverminor>
globalB	__osminor,0

;=============== above must be in this order

globalB	__osmode,0 		; 0 = real mode

labelW	<PUBLIC,__oserr>
globalW	__doserrno,0 		; initial DOS error code

_NFILE_ = 20			; Maximum number of file handles

DefData W,__nfile,<_NFILE_>	; maximum number of file handles
;globalW	__nfile,_NFILE_ 	; maximum number of file handles

;	__osfile flag values for DOS file handles

FOPEN		equ	01H	; file handle open
FEOFLAG 	equ	02H	; end of file has been encountered
FCRLF		equ	04H	; CR-LF across read buffer (in text mode)
FPIPE		equ	08H	; file handle refers to a pipe
FRDONLY 	equ	10H	; file handle associated with read only file
FAPPEND 	equ	20H	; file handle opened O_APPEND
FDEV		equ	40H	; file handle refers to device
FTEXT		equ	80H	; file handle is in text mode


labelB	<PUBLIC,__osfile>
defdata	B,,<FOPEN+FTEXT>	; stdin
defdata	B,,<FOPEN+FTEXT>	; stdout
defdata	B,,<FOPEN+FTEXT>	; stderr
;[2]	db	3 dup (FOPEN+FTEXT)	; stdin, stdout, stderr
defdata	B,,FOPEN			; stdaux
defdata	B,,FOPEN			; stdprn
;[2]	db	2 dup (FOPEN)		; stdaux, stdprn
	db	_NFILE_-5 dup (0)	; the other 15 handles

globalW	___argc,0
globalDP ___argv,0
globalDP _environ,0 		; environment pointer

globalW __child,0		; flag used to handle signals from child process

labelD	<PUBLIC,__pgmptr> 	; pointer to program name
DefData W,,<OFFSET DGROUP:dos2nam>
DefData W,,DGROUP
labelB	dos2nam
DefData B,,'C'			; dummy argv[0] for DOS 2.X
DefData B,,0
;[2]  	dw	dataOFFSET dos2nam,DGROUP
;[2] dos2nam	db	'C',0		; dummy argv[0] for DOS 2.X

;*
;*	The following (_acmdln and _acmdseg) must be in this order!
;*

globalW __acmdln,0		;[1] Offset of command line string in env
globalW __acmdseg,0		;[1] command line pointer
globalW __aenvseg,0		;[1] Selector of Environment segment


;Overlay related data

globalB __ovlflag,0		;[4] Overlay flag (0 = no overlays)
globalB	__intno,0		;[4] Overlay interrupt value (e.g., 3F)
globalD __ovlvec,0		;[4] Address of original overlay handler
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\brk.asm ===
page	,132
	title	brk	- C system call for memory
;***
;brk.asm - DOS brk and sbrk memory allocation
;
;	Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines brk() and sbrk() memory allocation routines
;
;		NOTE:  this large model BRK.ASM must be present in the BASIC
;		libraries so that brk() will return with an error code.
;		BASIC supports both large and medium model C, and the medium
;		model BRK.ASM is not suitable for linking with BASIC programs.
;
;*******************************************************************************

include	version.inc
.xlist
include	cmacros.inc
include	msdos.inc
include	errno.inc 		; errno.h for assembler
.list
include	brkctl.inc


sBegin	data

	assumes	ds,data

externW	_abrktb			; brk limit table
externW	_atopsp			; top of stack
externW	_asizds			; top of DS
externW	errno			; error return code

sEnd


externP	brkctl


sBegin	code

	assumes	cs,code
	assumes	ds,data

page
;***
;char *sbrk(inc), brk(newval) - memory break functions
;
;Purpose:
;	resets the break value
;
;Entry:
;	int incr - number of bytes to allocate (may be negative)
;	char *newval - new top of memory (heap)
;
;Exit:
;	sbrk returns the old break value or -1 if fails
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


cProc	sbrk,<PUBLIC>,<>

	parmw	incr

cBegin
ife	sizeD
	mov	ax,[_abrktb].sz	; get old value
	mov	cx,incr		; get incr
	or	cx,cx
	js	sbrkdec		;   negative increment

	xor	bx,bx		; 0
	push	ds
	push	bx		; DS:0
	push	bx
	push	cx		; 0:cx
	errnz	BR_ARGSEG-1
	inc	bx
	push	bx
	call	brkctl		; brkctl(BR_ARGSEG,(long)cx,DS:0)
	jnc	sbrkok
	add	sp,10		;   pop arguments
	jmp	short brkOM

sbrkok:
	add	sp,10		;   pop arguments
	jmp	short sbrkexit	; return

sbrkdec:
	add	cx,ax		; cx = old + incr
	jnc	brkOM		;   overflow

	cmp	cx,[_atopsp]
	jb	brkOM		;   too small

	mov	[_abrktb].sz,cx	; save new value
	jmp	short sbrkexit

endif				;sizeD eq 0
brkOM:				; error if large data
	mov	[errno],ENOMEM	; no memory error
	mov	ax,-1
	cwd

sbrkexit:
cEnd


cProc	brk,<PUBLIC>,<>

	parmdp	newval

cBegin
if	sizeD
	jmp	brkOM		; error if large data
else
	mov	ax,word ptr (newval) ; get new value
	cmp	ax,[_atopsp]
	jb	brkOM		; out of memory
	cmp	ax,[_asizds]
	jae	brkOM
	mov	[_abrktb].sz,ax	; set new brk value
	xor	ax,ax
	jmp	short sbrkexit	; leave through sbrk
endif
cEnd	nogen

sEnd
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\brkctl.asm ===
page	,132
	title	brkctl - C system call for memory
;***
;brkctl.asm - DOS brkctl memory allocation
;
;	Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	DOS brkctl memory allocation
;
;*******************************************************************************

include	version.inc
.xlist
include	cmacros.inc
include	msdos.inc
.list
include	brkctl.inc


sBegin	data
assumes	ds,data

externW _psp			; PSP paragraph number
externW _abrktb
externW	_abrktbe
externW	_abrkp

extrn	b$nmalloc_end:word	;[1] offset of last word of nmalloc space

externW	_aseglo			;[1] defined in CDATA3.INC

sEnd	data

sBegin	code
assumes	ds,data
assumes	cs,code

page
;***
;brkctl(command,incr,saddr) - memory allocation routine
;
;Purpose:
;	Allocate memory from OS.  Based on Xenix brkctl routine.
;	This is the work-horse OS interface routine for the C runtime
;	memory allocation package.
;
;Entry:
;
;	command - brkctl command: BR_ARGSEG or BR_NEWSEG 
;		BR_NEWSEG:	allocate a new data segment
;		BR_ARGSEG:	expand or shrink existing segment
;	incr - increment: for BR_ARGSEG, increment specified seg
;			  for BR_NEWSEG, allocate new seg of size incr
;	saddr - segment: segment address of block to operate on
;
;	command		incr	seg	action
;	-------		----	---	------
;	BR_ARGSEG	0	NULL	report on last seg
;	BR_ARGSEG	other	other	increment specified seg
;	BR_NEWSEG	0	-	allocate new seg, size 0
;	BR_NEWSEG	other	-	allocate new seg, size incr
;					up empty segs
;
;	IMPORTANT note:  The above documentation is taken from the Xenix
;	sources.  It may not be completely accurate for the DOS version
;	of brkctl.  
;
;Exit:
;	DX:AX  	segment:offset address of affected memory block on success
;		-1 on error
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

cProc	brkctl,<PUBLIC>,<si,di,es>

	parmw	command
	parmd	incr
	parmd	saddr

cBegin
	cmp	word ptr (incr+2),0 ; ???  for now allow 0-FFFF
	jnz	reterr		;   die

	mov	di,dataoffset _abrktb ; di = start of segment table (DGROUP)
	mov	dx,word ptr (incr) ; dx = incr
	mov	ax,command	; ax = command
	errnz	BR_ARGSEG-1
	dec	ax
	jnz	tryNEW

doARG:
	call	argseg		; try specified segment
	jc	reterr
	jmp	short return	; done

tryNEW:
	mov	si,[_abrkp]	; si = current segment entry
	errnz	BR_NEWSEG-2
	dec	ax
	jz	doNEW

doIMP:
	cmp	si,di		; IMP with current segment = DGROUP
	je	doNEW		;   yes - allocate new segment
	mov	ax,[si].sg	; ax = last allocated segment
	mov	Seg_saddr,ax	; use for argseg attempt
	push	si		; save segment for possible NEW
	call	argseg		; try specified segment
	pop	si
	jnc	return		; successful

doNEW:
	add	si,size segrec
	cmp	si,dataoffset _abrktbe ; check for end of segtab
	jae	reterr

	or	dx,dx		; is it 0?
	jnz	okNEW		;   no

reterr:
	mov	ax,-1
	cwd			; dx:ax = -1
	jmp	short return

okNEW:
	mov	bx,dx		; compute # paragraphs
	add	bx,15
	rcr	bx,1
	mov	cl,3
	shr	bx,cl		; bx = # paragraphs
@@:
	callos	allocmem
	jc	reterr

	cmp	ax,_aseglo	;* Check to see if we ignore this segment
	jbe	@B		;* Yes -- get a new segment

	xchg	ax,dx		; dx:ax = seg:size
	mov	[si].sz,ax	; save new segment size
	mov	[si].sg,dx	; save new segment value
	mov	[_abrkp],si	; save new last segment pointer
	xor	ax,ax		; return seg:0

return:

cEnd

page
;***
;argseg - helper routine for changing size of requested segment
;
;Purpose:
;
;Entry:
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

argseg:
	mov	cx,Seg_saddr	; get segment to find
	mov	si,di		; si = start of segment table

segloop:
	cmp	[si].sg,cx
	je	segfound	;   found it
	add	si,size segrec	; skip to next
	cmp	si,dataoffset _abrktbe
	jne	segloop		; keep looping
	stc			; set 'C' for error
	jmp	short toobig	; bad entry

segfound:
	mov	bx,dx
	add	bx,[si].sz	; add in current size
	jc	toobig		;   carry - too big
	mov	dx,bx		; dx = current size
	mov	es,cx		; set up segment

	cmp	si,di		; check if DS
	jne	getmem		;   no

 	cmp	[b$nmalloc_end],bx ;[1] DS - do we need more memory?
 	jnb	setsize 	;[1] no
;[1] 	stc			;[1]
 	jmp	short toobig	;[1] need to grow near heap -- error

getmem:

	add	bx,15		; round up to paragraph (17 bits)
	rcr	bx,1
	shr	bx,1
	shr	bx,1
	shr	bx,1		; bx = # paragraphs (1-1000h)


	callos	setmem		; set memory block size
	jc	toobig		;   too big


setsize:
	xchg	ax,dx		; ax = newsize
	xchg	[si].sz,ax	; ax = base
	mov	dx,cx		; dx:ax = seg:base
				; carry clear
toobig:
	ret


sEnd	code

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\5crt0.asm ===
page	,132
	title	crt0 - OS/2 C start up routine
;***
;crt0.asm - OS/2 C start up routine
;
;	Copyright (c) 1986-1988, Microsoft Corporation, All Rights Reserved
;
;Purpose:
;	How startup works in a few words -
;
;	The startup and termination is performed by a few modules
;
;		crt0.asm	OS/2 specific init/term
;		crt0msg.asm	OS/2 error messages
;		crt0dat.asm	remainder of shared OS/2 init/term
;
;	*************  IMPORTANT  *****************************************
;
;	The "DOSSEG" directive in this module must not be removed or else
;	the user will have to link with the "/DOSSEG" linker switch in
;	order to get proper segment ordering.
;
;	See the C documentation for more information about the /DOSSEG switch.
;
;	All assembler modules must be assembled with the /Mx switch, i.e.
;
;		masm -Mx crt0,;
;
;*******************************************************************************

;*******************************;*
	DOSSEG			;* specifies DOS SEGment ordering *
;*******************************;*

;*******************************;*
;*******************************;*

?DF=	1			; this is special for c startup

.xlist
include	version.inc
include	cmacros.inc
include	msdos.inc
include	brkctl.inc
EI_QB = 0			;[1] constants so include file works
OM_DOS5 = NOT 0 		;[1]
include stack2.inc		;[1] STACK_SIZE constant

assumesdata	macro	seg	;;[1] Newer versions of CMACROS reject
assumes seg,DGROUP		;;[1]
endm				;;[1]

.list

	page
;===========================================================================
;
;	Segment definitions
;
;	The segment order is essentially the same as in XENIX.
;	This module is edited after assembly to contain a dosseg comment
;	record for the linker.
;
;===========================================================================

createSeg _TEXT, code,	word,	public, CODE,	<>
createSeg C_ETEXT,etext, word,	public, ENDCODE,<>

createSeg _DATA, data,	word,	public, DATA,	DGROUP
createSeg STACK, stack,	para,	stack,	STACK,	DGROUP

defGrp	DGROUP			; define DGROUP

codeOFFSET equ	offset _TEXT:
dataOFFSET equ	offset DGROUP:

page

public	__acrtused 		; trick to force in startup
	__acrtused = 9876h	; funny value not easily matched in SYMDEB

extrn	__acrtmsg:abs 		; trick to pull in startup messages


sBegin	stack
assumesdata	ds		;[1]
	db	STACK_SIZE dup (?) ;[1] default stack size
sEnd

page

extrn	B$amsg_exit:FAR 	;[1]
extrn	B$terminate:FAR 	;[1]
extrn	B$Init:FAR		;[1]

sBegin	data

extrn	_edata:byte 		; end of data (start of bss)
extrn	_end:byte 		; end of bss (start of stack)

externB _osfile
externB _osmajor		; Major and Minor versions of OS/2
externB _osmode 		; real/protected mode flag

				;[1]
extrn	b$nmalloc_start:word	;[1] start of BASIC near malloc buffer
externW	_acmdln 		;[1]
externW	_aenvseg 		;[1]
externW	_asizds 		;[1]
externW	_atopsp			;[1]
externW _aexit_rtn		;[1] NEAR pointer
externW	_abrktb 		;[1]
externB _acfinfo		;[1] special C environment string
extrn	b$cfilex:byte		;[1] end char of _acfinfo
extrn	b$cfileln:abs		;[1] length
	cfile	EQU _acfinfo	;[1]
	cfilex	EQU b$cfilex	;[1]
	cfileln EQU b$cfileln	;[1]

;[1] externW	_abrktbe	;[1]
;[1] externW	_abrkp		;[1]
				;[1]

sEnd

	page


externP	_cinit			; run-time initializers


externP	main			; C main program
externP	exit			; exit ( code )

extrn	__exit:far 		; _exit ( code) (cmacros name conflict)

	extrn	DOSGETVERSION:far
	extrn	DOSGETMACHINEMODE:far
	extrn	DOSREALLOCSEG:far	;[1]

sBegin	code
assumes	cs,code

page
;***
;_astart - start of all C programs
;
;Purpose:
;	Startup routine to initialize C run-time environment.
;
;Entry:
;	OS/2 Start-Up Conditions:
;
;	DS	= Automatic Data Segment
;	SS:SP	= Stack Segment and Initial Stack Pointer
;	ES	= 0000
;	AX	= Selector of Environment Segment
;	BX	= Offset of Command Line in Environment Segment
;	CX	= Size of Automatic Data Segment (CX=0 means 65536 bytes)
;	BP	= 0000
;
;Exit:
;	Exits to OS/2 via exit().
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

labelNP	<PUBLIC,_astart> 	; start address of all "C" programs
;
;

	cld			; set direction flag (up)
	mov	[_atopsp],sp	; Top of Stack Region
	mov	[_aenvseg],ax	;[1] Handle of Environment Segment
	mov	[_acmdln],bx	;[1] Offset of Command Line String
	mov	[_aexit_rtn],codeoffset _exit ;[1] call high-level exit()
	jcxz	Got64kDS	;[1] brif got 64k DS
	xor	cx,cx		;[1] if not get 64K
	push	cx		;[1] push requested size
	push	ds		;[1] doit to DS
	call	DOSREALLOCSEG	;[1] realloc for 64K
	xchg	ax,cx		;[1] return code in cx
	jcxz	Got64kDS	;[1] brif successful

	mov	[_aexit_rtn],codeoffset B$terminate ;[1] die quickly
	mov	ax,9		;[1] C error message (not enough space)
	jmp	short __amsg_exit ;[1] print message and die

Got64kDS:
	dec	cx
	mov	[_asizds],cx	; Size of Global Data Segment
;	[1] Initialize C near heap to BASIC near malloc buffer

	mov	ax,[b$nmalloc_start]	;[1] get top of nmalloc buffer
	mov	[_abrktb].sz,ax ;[1] set near brk end of heap marker
	mov	[_abrktb].sg,ds ;[1] DGROUP segment
	call	B$Init		;[1] Do necessary BASIC init prior to XI
				;[1] processing
;
;	get OS/2 version
;
	push	ax
	mov	ax,sp

	push	ss
	push	ax		; address for version
	call	DOSGETVERSION
	pop	ax
	xchg	ah,al		; swap bytes
	mov	word ptr [_osmajor],ax
;
; Get real/protected mode flag
;
	mov	ax,dataOFFSET _osmode
	push	ds
	push	ax
	call	DOSGETMACHINEMODE

;****
;*	C_FILE_INFO must be processed before _cinit() is called
;*	because _cinit() checks handles 0-2 for device/pipe.
;****

;	fix up files inherited from child using _C_FILE_INFO

	call	inherit

;	do necessary initialization BEFORE command line processing!

	call	_cinit		; shared by OS/2 and Windows

;	process command line and environment


	call	main		; main ( argc , argv , envp )

; use whatever is in ax after returning here from the main program

	push	ax
	call	exit		; exit (AX)
				;   _exit will call terminators

page
;***
;_amsg_exit, _cintDIV - Fast exit fatal errors
;
;Purpose:
;	Exit the program with error code of 255 and appropriate error
;	message.  cintDIV is used for integer divide by zero, amsg_exit
;	is for other run time errors.
;
;Entry:
;	AX	= error message number (amsg_exit only).
;
;Exit:
;	calls exit() [cintDIV] or indirect through _aexit_rtn [amsg_exit].
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

labelNP	<PUBLIC,_cintDIV>

	assumes ds,nothing
assumesdata	ss		;[1]

;	_NMSG_WRITE will reestablish ds = DGROUP

	mov	ax,3		; Integer divide by zero interrupt
	mov	[_aexit_rtn],codeoffset _exit ; call high-level exit()
				; to cause file buffer flushing

labelNP <PUBLIC,_amsg_exit>


	JMP	B$amsg_exit	;[1] print error message and terminate


page
;***
;inherit - process C_FILE_INFO variable from the environment
;
;Purpose:
;	locates and interprets the "C_FILE_INFO" environment variable.
;	The value of this variable is written into the "_osfile" array.
;	This routine recognizes both DOS and OS/2 formats:
;
;	DOS:	";C_FILE_INFO" + count byte "N" + "N" data bytes + "\0"
;
;		where each data byte is written directly into _osfile
;		except that 0xFF represents 0
;
;	OS/2:	"_C_FILE_INFO=<AA><BB><CC><DD>" + "\0"
;
;		In this case the variable is a null-terminated string
;		(a well-formed environment variable) where each pair
;		of successive letters form one byte in _osfile.
;		The letters are in the range "A" through "P", representing
;		0 through 15.  The first letter of each pair is the more
;		significant 4 bits of the result.
;
;Entry:
;
;Exit:
;
;Uses:
;	AX, BX, CX, DX, SI, DI, ES
;
;Exceptions:
;
;*******************************************************************************

inherit proc	near
	mov	bx,cfileln
	cmp	[_osmode],0
	jne	not_fapi
;
;	Set up real-mode version of ;C_FILE_INFO
;
	mov	[cfile],';'	; change _C_FILE_INFO= to ;C_FILE_INFO
	mov	[cfilex],0
	dec	bx		; length is one less
not_fapi:
	xor	di,di
	mov	es,[_aenvseg]	; ES:DI points to environment strings
	mov	cx,07FFFh	; environment max = 32K
	cmp	byte ptr es:[di],0
	jne	cfilp
	inc	di		; first environment string is null
cfilp:
	cmp	byte ptr es:[di],0 ; check for end of environment
	je	nocfi		;   yes - not found
	mov	si,dataOFFSET cfile
	mov	dx,cx		; DX has count of bytes left in environment
	mov	cx,bx		; BX=cfileln
	repe	cmpsb		; compare for '_C_FILE_INFO='/';C_FILE_INFO'
	mov	cx,dx		; environment max = 32K
	je	gotcfi		;   yes - now do something with it
	xor	ax,ax
	repne	scasb		; search for end of current string
	je	cfilp		; keep searching
;
	jmp	short nocfi	;   no 00 !!! - assume end of env.
;
;	found _C_FILE_INFO, so transfer handle info into _osfile
;
gotcfi:
	push	es
	push	ds

	pop	es		; es = DGROUP
	mov	si,di		; si = startup of _osfile info
	pop	ds		; ds = env. segment
assumesdata	es		;[1]
	assumes	ds,nothing

	mov	di,dataOFFSET _osfile ; di = _osfile block

	cmp	bx,cfileln
	jne	real_cfi
;
; Prot-mode _C_FILE_INFO:
;	Read in pairs of characters, expected to be ['A'..'P'].
;	Each pair represents one byte in the _osfile array.
;	A null is the normal terminator for the string.
;
	mov	cl,4

osfile_lp:
	lodsb			; get next byte (more significant 4 bits)
	sub	al,'A'
	jb	nocfi		; string should terminate with a null
	shl	al,cl
	xchg	dx,ax		; save in DL

	lodsb			; get next byte (less significant 4 bits)
	sub	al,'A'
	jb	nocfi
	or	al,dl		; this assumes that AL is in range
	stosb
	jmp	short osfile_lp
;
; Real-mode C_FILE_INFO
;
real_cfi:
	lodsb			; must be less than 20
	cbw
	xchg	cx,ax		; cx = number of entries

osflp:
	lodsb			; get next byte
	inc	al
	jz	saveit		; was FF - save as 00
	dec	ax		; restore al
saveit:
	stosb
	loop	osflp		; transfer next character

;------

nocfi:
	push	ss
	pop	ds		; ds = DGROUP
assumesdata	ds		;[1]

	ret
inherit endp

sEnd
	end	_astart		; start address
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\cdata2.inc ===
;***
;cdata2.inc - 07-Sep-88 - More C Run-time Shared Global Data
;***
;***
;
;	Copyright <C> 1988, Microsoft Corporation
;
;Purpose:
;	This file contains special C startup debugger screen swap data items.
;	They are of class COMMON, and therefore can't be in GLOBAL.INC with
;	the rest of the C data items.  They are not included into QB.EXE, but
;	are present in every QLB.  They are present in both the user program
;	and the RTM (for custom RTM capability), and are in each /O exe.
;
;******************************************************************************

sBegin	dbdata
				; Debugger Screen swap setup segment
?PLM = 0				;[2]
globalW	 __aDBswpflg,0			;[1] Flag == __aDBswpyes if should
					;[1] attempt swapping
globalW  __aDBswpchk,___aDBretaddr	;[1] By default points to a model
					;[1] dependent ret
globalW  __aDBrterr,___aDBretaddr	;[1] 
globalW  __aDBexit,___aDBretaddr	;[1]  (Report we are exiting)
globalD  __aDBcallbk,0			;[1] Call back address to debugger
__aDBdoswp	=	0d6d6h
public	 __aDBdoswp
?PLM = 1				;[2]

sEnd	dbdata
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\cdata3.inc ===
;***
;cdata.inc - 30-Jan-87 - C Run-time Shared Global Data
;***
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This file contains all C data that has been added to the stubbed-out
;	sources since C 5.10 shipped.
;
;******************************************************************************


globalW	__aseglo,0		; was defined in BRKCTL.ASM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\chksum.asm ===
page	,132
	title	chksum - _nullcheck routine for C
;***
;chksum.asm - _nullcheck routine for C
;
;	Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This routine is used to check for assignment through a null pointer.
;	Memory at DGROUP:0 is checked for destructive assignments.  This
;	routine is not particularly effective in compact and large models.
;	A stub may be provoded for this routine without affecting the
;	behavior of a correctly written C program.
;
;*******************************************************************************

?DF=		1			; this is special for c startup
include version.inc
.xlist
include cmacros.inc
.list

createSeg	_TEXT,	code,	word,	public, CODE,	<>


sBegin	code
assumes cs,code


page
;***
;_nullcheck - check-sum of start of DGROUP segment to detect null-ptr-assignmt.
;
;Purpose:
;	_nullcheck cumulatively xor's all the bytes from ds:0 through 1 past end
;	of copyright string, finally xor'ing an arbitrary non-zero constant.
;	This is used to check if a null pointer has been written to.
;
;	This version can be called as many times as the user wants.
;	The function returns zero if the checksum is OK.
;
;	Note that this checksum only detects (DS:0) null pointer assignments
;	but not (0:0) null pointer assignments.
;
;Entry:
;	Assumes DS points to the beginning of DGROUP.
;
;Exit:
;	Returns : AX = 0 if no error; AX = 1 if error.
;
;Uses:
;	BX,CX,DX,ES are destroyed.
;
;Exceptions:
;	If _nullcheck check-sum fails, an error message is written
;	to standard error, and the routine returns an error code (AX = 1).
;
;*******************************************************************************

cProc	_nullcheck,<PUBLIC>,<>
cBegin	nogen				; no arguments - so no frame



	XOR	AX,AX			;[1] checksum always OK for BASIC




	ret

cEnd	nogen


sEnd	code

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\chkstk.asm ===
page	,132
	title	chkstk - C stack checking routine
;***
;chkstk.asm - C stack checking routine
;
;	Copyright (c) 1985-1988 Microsoft Corporation, All Rights Reserved
;
;Purpose:
;	Provides support for automatic stack checking in C procedures
;	when stack checking is enabled.
;
;*******************************************************************************

.xlist
include	version.inc
include	cmacros.inc
include	msdos.inc
.list

sBegin	data
	assumes	ds,data

extrn	STKHQQ:word		;[4]
externCP _aaltstkovr		;[4] alternate stack overflow

sEnd	data


sBegin	code
assumes	ds,data
assumes	cs,code

externNP _amsg_exit 		; write error and die

page
;***
;_chkstk - check stack upon procedure entry
;
;Purpose:
;	Provide stack checking on procedure entry.
;
;Entry:
;	AX	= size of local frame
;
;Exit:
;	SP	= new stackframe if successful
;
;Uses:
;	BX, CX, DX
;
;Exceptions:
;	Gives out of memory error and aborts if there is not enough
;	stack space for the routine.
;*******************************************************************************

labelP	<PUBLIC,_chkstk>

	pop	cx		; get return offset
	pop	dx		; get return segment

	mov	bx,sp
	sub	bx,ax		; new position
	jc	OMerr		; error - out of memory
	cmp	bx,[STKHQQ]	; SP - AX : STKHQQ (for heap/stack)
	jb	OMerr		;   error - out of memory

	mov	sp,bx		; set new stack pointer

	push	dx		; push segment
	push	cx		; push offset
chkproc	proc	far
	ret			; far return to dx:cx
chkproc	endp

OMerr:
	mov	ax,word ptr [_aaltstkovr]
	inc	ax
	jnz	altstkovr


	xor	ax,ax
	jmp	_amsg_exit	; give stack overflow and die

altstkovr:
	push	dx		; user segment
	push	cx		; user offset
	jmp	[_aaltstkovr]	; Pascal/FORTRAN stack overflow

sEnd	code

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\crt0fp.asm ===
page	,132
	title	crt0fp - floating point not loaded trap
;***
;crt0fp.asm - floating point not loaded trap
;
;	Copyright (c) 1986-1988, Microsoft Corporation, All Rights Reserved
;
;Purpose:
;	To trap certain cases where certain necessary floating-point
;	software is not loaded.  Two specific cases are when 87.LIB
;	is linked in but no coprocessor is present, and when floating
;	point i/o conversions are done, but no floating-point variables
;	or expressions are used in the program.
;
;*******************************************************************************

?DF=	1			; this is special for c startup
include	version.inc
.xlist
include	cmacros.inc
.list

createSeg _TEXT, code,	word,	public, CODE,	<>


sBegin	code
assumes	cs,code

externNP _amsg_exit

page
;***
;_fptrap - trap for missing floating-point software
;
;Purpose:
;	Catches these cases of incomplete f.p. software linked into a program.
;
;	(1) 87.LIB chosen, but no coprocessor present;
;	    (i.e., emulator not linked)
;
;	(2) "%e", "%f", and "%g" i/o conversion formats specified, but
;	    not all conversion software has been linked in, because the
;	    program did not use any floating-point variables or expressions.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	AX.
;
;Exceptions:
;	Transfers control to _amsg_exit which ...
; 	- Writes error message to standard error:  "floating point not loaded";
;	- Terminates the program by calling _exit().
;*******************************************************************************

labelNP <PUBLIC,_fptrap>


	mov	ax,2		; issue floating point not loaded
	jmp	_amsg_exit	;   and die

sEnd	code

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\cmiscdat.asm ===
page	,132
	title	cmiscdat - miscellaneous C run-time data
;***
;cmiscdat.asm - miscellaneous C run-time data
;
;	Copyright (c) 1987-1988, Microsoft Corporation, All Rights Reserved
;
;Purpose:
;	Includes floating point conversion table (for C float output),
;	a data structure used by signal/exec to tell if a SIGINT handler 
;	has been installed, and the public variables _asizeC and _asizeD
;	for conveying memory-model information to the memory-model-independent
;	GRAPHICS.LIB.
;
;	When floating point i/o conversions are done, but no floating-point
;	variables or expressions are used in the C program, we use the
;	_cfltcvt_tab[] to map these cases to the _fptrap entry point,
;	which prints "floating point not loaded" and dies.
;
;	This table is initialized to five copies of _fptrap by default.
;	If floating-point is linked in (_fltused), these table entries
;	are reset (see input.c, output.c, fltused.asm, and fltuseda.asm).
;
;*******************************************************************************


include	version.inc
.xlist
include	cmacros.inc
.list

externNP _fptrap			;[2] not needed for QC version

sBegin	data

	assumes	ds,data
	assumes	cs,code

;
;	... table of (model-dependent) code pointers ...
;
;	Five entries, all point to _fptrap by default,
;	but are changed to point to the appropriate
;	routine if the _fltused initializer (_cfltcvt_init)
;	is linked in.
;
;	this table is used or modified in the following
;	source files:
;
;		\clib\stdio\input.c
;		\clib\stdio\output.c
;		\math\c\fltused.asm
;		\math\c\fltuseda.asm
;
;	if the _fltused modules are linked in, then the
;	_cfltcvt_init initializer sets the 5 entries of
;	_cfltcvt_tab to:
;
;		_cfltcvt
;		_cropzeros
;		_fassign
;		_forcdecpt
;		_positive
;


labelCP	<PUBLIC, _cfltcvt_tab>
	DD	5 dup (_fptrap)

;
;	miscellaneous data (used by signal and exec*)
;
;	(just by the DOS 3 versions, though)
;

globalW	_sigintseg,0 		;SIGINT default signal routine (segment)
globalW	_sigintoff,0 		;SIGINT default signal routine (offset)

;
;	memory model information for use in GRAPHICS.LIB
;	
;	_asizeC is zero    for Small   & Compact models, 
;	           nonzero for Medium  & Large   models;
;	_asizeD is zero    for Small   & Medium  models, 
;	           nonzero for Compact & Large   models.
;
;

globalB _asizeC,sizeC
globalB _asizeD,sizeD


sEnd	data

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\crt0.asm ===
page	,132
	title	crt0 - C start up routine
;***
;crt0.asm - C start up routine
;
;	Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	How startup works in a few words -
;
;	The startup and termination is performed by a few modules
;
;		crt0.asm	DOS 2.x/3.x specific init/term
;		crt0msg.asm	DOS 2.x/3.x error messages
;		(winstart.asm)	Windows specific init/term (not included)
;
;		crt0dat.asm	remainder of shared DOS 3.x init/term
;
;	*************  IMPORTANT  *****************************************
;
;	The "DOSSEG" directive in this module must not be removed or else
;	the user will have to link with the "/DOSSEG" linker switch in
;	order to get proper segment ordering.
;
;	See the C documentation for more information about the /DOSSEG switch.
;
;	All assembler modules must be assembled with the /Mx switch, i.e.
;
;		masm -Mx crt0,;
;
;*******************************************************************************

;*******************************;*
	DOSSEG			;* specifies DOS SEGment ordering *
;*******************************;*

?DF=	1			; this is special for c startup

.xlist
include	version.inc
include	cmacros.inc
include	msdos.inc
include brkctl.inc

EI_QB = -1			;[12] interpreter version
EI_EB = 0			;[12] not EB
OM_DOS5 = 0			;[12] not an OS/2 version
include stack2.inc		;[12] STACK_SIZE constant

.list

CondEnd MACRO	entrypoint	;[12] generate END _astart
	END	entrypoint	;[12]
	ENDM			;[12]

assumesdata	macro	seg	;;[12] Newer versions of CMACROS reject
assumes seg,DGROUP		;;[12]
endm				;;[12]



	page
;===========================================================================
;
;	Segment definitions
;
;	The segment order is essentially the same as in XENIX.
;	This module is edited after assembly to contain a dosseg comment
;	record for the linker.
;
;===========================================================================

createSeg _TEXT, code,	word,	public, CODE,	<>
createSeg C_ETEXT,etext, word,	public, ENDCODE,<>

createSeg _DATA, data,	word,	public, DATA,	DGROUP
createSeg STACK, stack,	para,	stack,	STACK,	DGROUP

defGrp	DGROUP			; define DGROUP

codeOFFSET equ	offset _TEXT:
dataOFFSET equ	offset DGROUP:

page

public	__acrtused 		; trick to force in startup
	__acrtused = 9876h	; funny value not easily matched in SYMDEB

extrn	__acrtmsg:abs 		; trick to pull in startup messages


sBegin	stack
assumesdata	ds		;[12]
	db	STACK_SIZE dup (?) ;[12] default stack size
sEnd

page

externP	main			; C main program

externP	exit			; exit ( code )

extrn	__exit:far 		; _exit ( code) (cmacros name conflict)

extrn	__amsg_exit:FAR 	;[12]
extrn	B$terminate:FAR 	;[12]
extrn	B$Init:FAR		;[12]



sBegin	data

extrn	_edata:byte 		; end of data (start of bss)
extrn	_end:byte 		; end of bss (start of stack)

externW	_psp			; psp:0 (paragraph #)


;	these are used by DOS C memory management (not used in Windows)


externW _asizds 		;[12] moved these to CDATA.INC
externW _atopsp 		;[12]
externW _aexit_rtn		;[12]
externW _abrktb 		;[12]
externW _abrktbe		;[12]
externW _abrkp			;[12]

extrn	b$nmalloc_start:word	;[12] start of BASIC near malloc buffer
externW _aenvseg		;[12]
externW _acmdseg		;[12]
externW _acmdln 		;[12]


sEnd

	page


externP	_cinit			; run-time initializers


sBegin	code
assumes	cs,code

assumes	ds,nothing

page
;***
;_astart - start of all C programs
;
;Purpose:
;	Startup routine to initialize C run-time environment
;
;Entry:
;
;Exit:
;	Exits to DOS via exit().
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

labelNP	<PUBLIC,_astart> 	; start address of all "C" programs


;	check MS-DOS version for 2.0 or later

	callos	VERSION		; AX must be preserved until later
	cmp	al,2		; check for version 2 or later
	jae	setup		;   yes - continue with setup
	int	20h		; DOS 1.0 exit program

setup:

	mov	di,DGROUP
	mov	si,ds:[DOS_MAXPARA] ; get max. paragraph

	sub	si,di		; si = # para in data area
	cmp	si,1000h	; if more than 64K
	jb	setSP

	mov	si,1000H	; use full 64K (-16)

setSP:

	cli			; turn off interrupts
	mov	ss,di		; SS = DGROUP
 	add	sp,dataoffset _end-2 ; 2 for _asizds limit
	sti			; turn interrupts back on
	jnc	SPok

	assumes ss,DGROUP	;[12] assume it points somewhere
StackOverflow:			;[12]
	xor	ax,ax		;[12] stack overflow error message (0)
	mov	SS:[_aexit_rtn],codeoffset B$terminate ;[12] jmp to INT 21, fn 4C
	jmp	short jmp_amsg_exit ;[12] print message and exit

SPok:
assumesdata	ss		;[12]

	and	sp,not 1	; make even (if not)
	mov	[_atopsp],sp	; save top of stack


	mov	ax,si		; si = # paragraphs
	mov	cl,4
	shl	ax,cl
	dec	ax
	mov	[_asizds],ax	; save DS size - 1 (in bytes)


;	release extra space to DOS

	add	si,di		; si = DGROUP + # para in DGROUP
	mov	ds:[DOS_MAXPARA],si ; fix psp:2
	mov	bx,es		; bx = PSP base
	sub	bx,si		; bx = - # para used
	neg	bx
	callos	setmem		; set memory block size
	mov	[_psp],ds	; save psp:0

	MOV	AX,DS:[2CH]		;[12] AX = Handle of Environ Segment
	MOV	SS:[_aenvseg],AX	;[12]
	mov	SS:[_acmdseg],DS	;[12] Handle of Command Line Segment
	mov	SS:[_acmdln],081H	;[12] Offset of Command Line String

;	zero data areas (_BSS and c_common)

	push	ss
	pop	es
assumesdata	es		;[12]

	cld			; set direction flag (up)
	mov	di,dataOFFSET _edata ; beginning of bss area
	mov	cx,dataOFFSET _end ; end of bss area
	sub	cx,di
	xor	ax,ax
	rep	stosb		; zero bss

;	C segmentation conventions set up here	(DS=SS and CLD)

	push	ss		; set up initial DS=ES=SS, CLD
	pop	ds
assumesdata	ds		;[12]

;[12]	 Initialize C near heap to BASIC near malloc buffer

	mov [_aexit_rtn],codeoffset _exit ;[12] call high-level exit()
	mov	ax,[b$nmalloc_start]	;[12] get top of nmalloc buffer
	mov	_abrktb.sz,ax		;[12] set near brk end of heap marker
	call	B$Init		;[12]Do necessary BASIC init Prior to XI
				;[12] processing.


;	do necessary initialization BEFORE command line processing!

	call	_cinit		; shared by DOS and Windows

	push	ss
	pop	ds		; ds = DGROUP

	push	ss		;[12]
	pop	es		;[12]set es=ds
assumesdata	ds		;[12]


;	call main and exit

	xor	bp,bp		; mark top stack frame for SYMDEB


	call	main		; main ( argc , argv , envp )

; use whatever is in ax after returning here from the main program

	push	ax
	call	exit		; exit (AX)
				;   _exit will call terminators

page

;***
;_amsg_exit, _cintDIV - Fast exit fatal errors
;
;Purpose:
;	Exit the program with error code of 255 and appropriate error
;	message.  cintDIV is used for integer divide by zero, amsg_exit
;	is for other run time errors.
;
;Entry:
;	AX	= error message number (amsg_exit only).
;
;Exit:
;	calls exit() [cintDIV] or indirect through _aexit_rtn [amg_exit].
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

labelNP	<PUBLIC,_cintDIV>

	assumes ds,nothing
	assumesdata	ss		;[12]

;	_cintDIV establishes ds = DGROUP


	mov	ax,3		; Integer divide by zero interrupt
	mov	[_aexit_rtn],codeoffset _exit ; call high-level exit()
				; to cause file buffer flushing

jmp_amsg_exit:			;[12]
	jmp	__amsg_exit	;[12] branch to __amsg_exit in BASIC code


sEnd

	CondEnd _astart 		;[12] start address if NOT FO_RTM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\crt0stub.asm ===
TITLE	crt0stub - stub replacement for crt0*.* (QLib only)
;***
; crt0stub - stub replacement for crt0*.* (QLib only)
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Quick Libs need the C startup for linking, but never execute it.
;	This stub contains the appropriate PUBLICs so that the link will
;	work, but contains no code.
;
;	Note:	Before this module can be linked into BQLB40 successfully
;		it must be run through DOSSEG for C segment ordering.
;
;*******************************************************************************

	DOSSEG				;[5]

	extrn	B$IEND:FAR		;[3]

_TEXT	segment byte public 'CODE'

public	__acrtused			; trick to force in startup
	__acrtused = 9876h

assume	cs:_TEXT
	public	_exit			;[3]
	public	__exit			;[3]
__astart:

__cinit:
__ctermsub:
_exit:
__exit:
	jmp	B$IEND			;[3] vector to B$IEND to stop execution

__cexit	proc far			;[6]
	public	__cexit			;[6]
	ret				;[6]
__cexit endp				;[6]

_TEXT	ends

	end	__astart 		; start address
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\crt0dat.asm ===
page	,132
	title	crt0dat - DOS and Windows shared startup and termination
;***
;crt0dat.asm - DOS and Windows shared startup and termination
;
;	Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	Shared startup and termination.
;
;*******************************************************************************

_NFILE_	=	20		; Maximum number of file handles

?DF	=	1		;; tell cmacros.inc we want to define our own segments

include	version.inc
.xlist

assumesdata	macro	seg	;;[12] Newer versions of CMACROS reject
assumes seg,DGROUP		;;[12]
endm				;;[12]


include	cmacros.inc
include	msdos.inc
.list


createSeg _TEXT, code,	word,	public, CODE,	<>
createSeg CDATA, cdata,	word,	common, DATA,	DGROUP
createSeg _DATA, data,	word,	public, DATA,	DGROUP

createSeg DBDATA, dbdata, word,	common, DATA,	DGROUP

createSeg XIFB,	xifbseg, word,	public, DATA,	DGROUP
createSeg XIF,	xifseg,	word,	public, DATA,	DGROUP ; far init's
createSeg XIFE,	xifeseg, word,	public, DATA,	DGROUP

createSeg XIB,	xibseg, word,	public, DATA,	DGROUP
createSeg XI,	xiseg,	word,	public, DATA,	DGROUP ; init's
createSeg XIE,	xieseg, word,	public, DATA,	DGROUP

createSeg XOB,	xobseg, word,	public, BSS,	DGROUP
createSeg XO,	xoseg,	word,	public, BSS,	DGROUP ; onexit table
createSeg XOE,	xoeseg, word,	public, BSS,	DGROUP

createSeg XPB,	xpbseg, word,	public, DATA,	DGROUP
createSeg XP,	xpseg,	word,	public, DATA,	DGROUP ; preterm's
createSeg XPE,	xpeseg, word,	public, DATA,	DGROUP

createSeg XCB,	xcbseg, word,	public, DATA,	DGROUP
createSeg XC,	xcseg,	word,	public, DATA,	DGROUP ; term's
createSeg XCE,	xceseg, word,	public, DATA,	DGROUP

createSeg XCFB,	xcfbseg, word,	public, DATA,	DGROUP
createSeg XCF,	xcfseg,	word,	public, DATA,	DGROUP ; far term's
createSeg XCFE,	xcfeseg, word,	public, DATA,	DGROUP

defGrp	DGROUP			; define DGROUP

codeOFFSET equ	offset _TEXT:
dataOFFSET equ	offset DGROUP:

page
sBegin	xifbseg
xifbegin label	byte
sEnd	xifbseg

sBegin	xifeseg
xifend	label	byte
sEnd	xifeseg

sBegin	xibseg
xibegin	label	byte
sEnd	xibseg

sBegin	xieseg
xiend	label	byte
sEnd	xieseg

sBegin	xobseg
xontab	label	byte		; start of onexit table
sEnd	xobseg

sBegin	xoeseg
xonend	label	byte
sEnd	xoeseg

sBegin	xpbseg
xpbegin	label	byte		; end of onexit table
sEnd	xpbseg

sBegin	xpeseg
xpend	label	byte
sEnd	xpeseg

sBegin	xcbseg
xcbegin	label	byte
sEnd	xcbseg

sBegin	xceseg
xcend	label	byte
sEnd	xceseg

sBegin	xcfbseg
xcfbegin label	byte
sEnd	xifbseg

sBegin	xcfeseg
xcfend	label	byte
sEnd	xcfeseg



sBegin	cdata			; floating point setup segment
assumesdata	ds		;[12]assumesdata     ds

	dw	0		; force segment to be at least 0's
labelD	<PUBLIC,_fpinit> 	; public for signal
fpmath	dd	1 dup (?)	; linking trick for fp
fpdata	dd	1 dup (?)
fpsignal dd	1 dup (?)	; fp signal message

 
sEnd




sBegin	data
assumesdata	ds		;[12]

	
externD	_aintdiv 		; divide error interrupt vector save
externW	_psp			; psp:0 (paragraph #)
externW	_osversion
externW	_nfile			; maximum number of file handles
externB	_osfile
externB _acfinfo
extrn	b$cfilex:byte
extrn	b$cfileln:abs		; length
	cfile	EQU _acfinfo	; _acinfo structure items
	cfilex	EQU b$cfilex
	cfileln	EQU b$cfileln

externB _ovlflag		; Overlay flag (0 = no overlays)
externB	_intno			; Overlay interrupt value (e.g., 3F)
externD _ovlvec			; Address of original overlay handler


staticB StartupFlags,0		;[12] flag for special initialization
	FloatInit	= 01h	;[12] or termination
	cinitsub	= 02h	;[12]
	cterm		= 04h	;[12]

sEnd	data

page
externNP _fptrap
externP	_cintDIV
externP	_nullcheck


sBegin	code
assumes	cs,code

global	proc	far

page
;***
;_cinit - C initialization
;
;Purpose:
;	This routine performs the shared DOS and Windows initialization.
;	The following order of initialization must be preserved -
;
;	1.	Integer divide interrupt vector setup
;	2.	Floating point initialization
;	3.	Copy ;C_FILE_INFO into _osfile
;	4.	Check for devices for file handles 0 - 4
;	5.	General C initializer routines
;
;Entry:
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

cProc	_cinit,<PUBLIC>,<>

cBegin	nogen			; no local frame to set up
assumesdata	ds		;[12]
assumesdata	ss		;[12]

;	Store DOS major/minor version number
;	This is done in crt0dat.asm rather than in crt0.asm for Windows' sake.
;

	callos	VERSION
	mov	[_osversion],ax

init_step1:			;[12] entry point for B$cinitsub

;	*** Increase File Handle Count ***
;
;	(1) This code only works on DOS Version 3.3 and later.  
;	(2) This code is intentially commented out; the user must enable
;	this code to access more than 20 files.
;
;	mov	ah,67h		; system call number
;	mov	bx,_NFILE_	; number of file handles to allow
;	callos			; issue the system call
;	;check for error here, if desired (if carry set, AX equals error code)
;	
;	*** End Increase File Handle Count ***


;	1.	Integer divide interrupt vector setup

	mov	ax,DOS_getvector shl 8 + 0
	callos			; save divide error interrupt
	mov	word ptr [_aintdiv],bx
	mov	word ptr [_aintdiv+2],es

	push	cs
	pop	ds
	assumes	ds,nothing
	mov	ax,DOS_setvector shl 8 + 0
	mov	dx,codeOFFSET _cintDIV
	callos			; set divide error interrupt
	push	ss
	pop	ds
	assumesdata	ds	;[12]




;	2.	Floating point initialization

	mov	cx,word ptr [fpmath+2]
	jcxz	nofloat_i

	mov	es,[_psp]	; psp segment
	mov	si,es:[DOS_ENVP] ; environment segment
	lds	ax,[fpdata]	; get task data area
	assumes	ds,nothing
	mov	dx,ds		;   into dx:ax
	xor	bx,bx		; (si) = environment segment
	call	[fpmath]	; fpmath(0) - init
	jnc	fpok

	push	ss		; restore ds from ss
	pop	ds
	jmp	_fptrap		; issue "Floating point not loaded"
				; error and abort

fpok:
	lds	ax,[fpsignal]	; get signal address
	assumes	ds,nothing
	mov	dx,ds
	mov	bx,3
	call	[fpmath]	; fpmath(3) - set signal address
	push	ss
	pop	ds
	assumesdata	ds	;[12]

nofloat_i:

	test	[StartupFlags],FloatInit+cinitsub ;[12] special initialization?
	jz	not_special	;[12] brif not -- continue
	mov	[StartupFlags],0 ;[12] clear flags
	ret			;[12] return to caller
not_special:			;[12]

;	3.	Copy ;C_FILE_INFO into _osfile

;	fix up files inherited from child using ;C_FILE_INFO

	mov	es,[_psp]	; es = PSP
	mov	cx,word ptr es:[DOS_envp] ; es = user's environment
	jcxz	nocfi		;   no environment !!!
	mov	es,cx
	xor	di,di		; start at 0

cfilp:
	cmp	byte ptr es:[di],0 ; check for end of environment
	je	nocfi		;   yes - not found
	mov	cx,cfileln
	mov	si,dataOFFSET cfile
	repe	cmpsb		; compare for ';C_FILE_INFO'
	je	gotcfi		;   yes - now do something with it
	mov	cx,07FFFh	; environment max = 32K
	xor	ax,ax
	repne	scasb		; search for end of current string
	jne	nocfi		;   no 00 !!! - assume end of env.
	jmp	cfilp		; keep searching

;	found ;C_FILE_INFO and transfer info into _osfile

gotcfi:
	push	es
	push	ds
	pop	es		; es = DGROUP
	pop	ds		; ds = env. segment
	assumes	ds,nothing
	assumesdata	es	;[12]
	mov	si,di		; si = startup of _osfile info
	mov	di,dataOFFSET _osfile ; di = _osfile block

	lodsb			; must be less than 20
	cbw
	xchg	cx,ax		; cx = number of entries

osflp:
	lodsb			; get next byte
	inc	al
	jz	saveit		; was FF - save as 00
	dec	ax		; restore al
saveit:
	stosb
	loop	osflp		; transfer next character

	push	ss
	pop	ds		; ds = DGROUP
	assumesdata	ds	;[12]
nocfi:


;	4.	Check for devices for file handles 0 - 4
;
;		Clear the FDEV bit (which might be inherited from C_FILE_INFO)
;		and then call DOS to see if it really is a device or not
;
	mov	bx,4

devloop:
	and	_osfile[bx],not FDEV ; clear FDEV bit on principal

	mov	ax,DOS_ioctl shl 8 + 0 ; issue ioctl(0) to get dev info
	callos
	jc	notdev

	test	dl,80h		; is it a device ?
	jz	notdev		;   no
	or	_osfile[bx],FDEV ;   yes - set FDEV bit

notdev:
	dec	bx
	jns	devloop

;	5.	General C initializer routines

	mov	si,dataOFFSET xifbegin
	mov	di,dataOFFSET xifend

	call	initterm	; call the far initializers


	mov	si,dataOFFSET xibegin
	mov	di,dataOFFSET xiend
	call	initterm	; call the initializers


___aDBretaddr:					; label to appropriate "RET"

	ret
cEnd	nogen

?PLM = 1			;[12]

assumes ds,DGROUP		;[12]
assumes ss,DGROUP		;[12]

;[12] BASIC needs to be able to perform init steps 1-2 as a subroutine
labelFP <PUBLIC,B$cinitsub>	;[12]
	mov	[StartupFlags],cinitsub ;[12] set flag to return after step 2
	jmp	init_step1	;[12] jump to start of init step 1



?PLM = 0			;[14]

;[14] Routine to perform termination steps 1-7 as a subroutine
public	__cexit			;[14]
__cexit:			;[14]
	push	si		;[14] save user's registers
	push	di		;[14]
	mov	[StartupFlags],cterm	;[12] set flag to return after last step
	jmp	SHORT exit_step1	;[12] jump to start of exit step 1

page
;***
;exit(status), _exit(status) - C termination
;
;Purpose:
;	The termination sequence is more complicated due to the multiple
;	entry points - exit(code) and _exit(code).  The _exit() routine
;	is a quick exit routine that does not do certain C exit functions
;	like stdio buffer flushing and onexit processing.
;
;	exit (status):
;
;	1.	call runtime preterminators
;
;	_exit (status):
;
;	2.	perform C terminators
;	3.	perform _nullcheck() for null pointer assignment
;	4.	close all open files
;	5.	terminate floating point
;	6.	reset divide by zero interrupt vector
;	7.	restore int 3F handler
;	8.	terminate with return code to DOS
;
;Entry:
;	int status - exit status
;
;Exit:
;	returns to DOS.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

public	_exit
_exit:
cProc	dummy1,<>,<>

parmw	status

cBegin
assumesdata	ds		;[12]
assumesdata	ss		;[12]

;	1.	call runtime preterminators
;		- onexit processing
;		- flushall
;		- rmtmp

exit_step1:				;[12] entry point for _cexit

	mov	si,dataOFFSET xontab ; beginning of onexit table
	mov	di,dataOFFSET xonend ; end of onexit table
	call	initterm

	mov	si,dataOFFSET xpbegin ; beginning of pre-terminators
	mov	di,dataOFFSET xpend ; end of pre-terminators
	call	initterm


	jmp	short exiting	; jump into _exit

cend	nogen


public	__exit
__exit:
cProc	dummy2,<>,<>

parmw	status

cBegin
assumesdata	ds			;[12]
assumesdata	ss			;[12]

exiting:

;	2.	perform C terminators

	mov	si,dataOFFSET xcbegin
	mov	di,dataOFFSET xcend
	call	initterm	; call the terminators


	mov	si,dataOFFSET xcfbegin
	mov	di,dataOFFSET xcfend

	call	initterm	; call the far terminators


;	3.	perform _nullcheck() for null pointer assignment

	call	_nullcheck	; check data in NULL data segment at DS:0
	or	ax,ax		; zero if no null ptr assignment detected
	jz	startclose
	cmp	status,0	; zero if no other error has occurred
	jnz	startclose
	mov	status,255	; nonzero status to indicate an
				; null-pointer-assignment error
startclose:

;	4.	close all files (except pre-opened handles 0-4)


;	5.	terminate floating point
;	6.	reset divide by zero interrupt vector
;	7.	restore int 3F handler


	call	far ptr _ctermsub ;[12] fast cleanup

	test	[StartupFlags],cterm ;[12] return instead of dying?
	jz	dying		;[12] brif not -- terminate
	mov	[StartupFlags],0 ;[12] clear flag
	pop	di		;[14] restore user's registers
	pop	si		;[14]
	ret			;[12] return to caller
dying:				;[12]

;	8.	return to the DOS

	mov	ax,status	; get return value
	PUBLIC	B$terminate	;[12]
B$terminate	label	FAR	;[12]
	callos	terminate	; exit with al = return code

cEnd	nogen

global	endp


page
;***
;_ctermsub - more C termination code
;
;Purpose:
;	This routine
;		(1) performs floating-point termination
;		(2) resets the divide by zero interrupt vector
;		(3) restore int 3F handler
;
;Entry:
;
;Exit:
;
;Uses:
;	AX,BX,CX,DX.
;
;Exceptions:
;
;*******************************************************************************

cProc	_ctermsub,<PUBLIC,FAR>		;[12]
cBegin					;[12]

;	5.	terminate floating point

	mov	cx,word ptr [fpmath+2] ; test for floating point
	jcxz	nofloat_t	;   no

	mov	bx,2		;   yes - cleanup
	call	[fpmath]

nofloat_t:



;	6.	reset divide by zero interrupt vector

	push	ds
	lds	dx,[_aintdiv]	; ds:dx = restore vector
	mov	ax,DOS_setvector shl 8 + 0
	callos			; set divide error interrupt
	pop	ds


;	7.	restore overlay interrupt vector

	cmp	byte ptr [_ovlflag],0	; Overlays in use ??
	jz	done_ovlvec		; if 0, don't restore overlay vector
	push	ds			; save ds
	mov	al,byte ptr [_intno]	; overlay interrupt number
	lds	dx,dword ptr [_ovlvec]	; original ovl interrupt vector
	callos	setvector		; restore the overlay vector
	pop	ds			; restore ds
done_ovlvec:

	cEnd				;[12]


page
;***
;initterm - do a set of initializers or terminators
;
;Purpose:
;	The initializors and terminators may be written in C
;	so we are assuming C conventions (DS=SS, CLD, SI and DI preserved)
;	We go through them in reverse order for onexit.
;
;Entry:
;	SI	= start of procedure list
;	DI	= end of procedure list
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

initterm:
	cmp	si,di		; are we done?
	jae	itdone		;   yes - no more

	sub	di,4
	mov	ax,[di]
	or	ax,[di+2]
	jz	initterm	; skip null procedures
	call	dword ptr [di]
	jmp	initterm	; keep looping

itdone:
	ret

page



sEnd

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\doexec.asm ===
page	,132
	title	doexec	-- (xenix) exec a child process
;***
;doexec.asm - execute a child process
;
;	Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines _doexec() - execute a child process (overlay existing process)
;	This is complicated and involves some knowledge of DOS
;	arena headers.
;
;*******************************************************************************

?DF	=	1	; tell cmacros.inc we want to define our own segments

.xlist
include	version.inc
include	cmacros.inc
include	msdos.inc
.list

assumesdata	macro	seg	;;[1] Newer versions of CMACROS reject
assumes	seg,DGROUP		;;[1]
endm				;;[1]

createSeg _TEXT, code,	word,	public, CODE,	<>
createSeg _DATA, data,	word,	public, DATA,	DGROUP
createSeg EXEC,	eseg,	word,	common, DATA,	DGROUP

defGrp	DGROUP			; define DGROUP

codeOFFSET equ	offset _TEXT:
dataOFFSET equ	offset DGROUP:



l	macro	nam		;;[1] Conditionally make label public
nam:				;;[1]
	endm			;;[1]


arena	struc			; first 5 bytes of the arena header
	sig	db	0		; 'M' or 'Z' for last block
	own	dw	0		; PSP value of owner process or 0 if free
	asiz	dw	0		; size of block (not including header)
arena	ends

extrn	b$EX_MSG_BEG:FAR	;[1]
extrn	b$EX_MSG_END:FAR	;[1]

sBegin	data
assumesdata	ds		;[1]

externW	_psp			; psp segment
externB	_osmajor 		; dos major version number
externW	_sigintseg 		; SIGINT default signal handler (segment)
externW	_sigintoff 		; SIGINT default signal handler (offset)

globalW	_p_overlay,2 		; OLD_P_OVERLAY value

staticW	freepsp,0 		; arena of last free segment contiguous with PSP



staticW emsg,<2+ OFFSET b$EX_MSG_BEG> ;[1] +2 to skip first msg number
staticW emsgseg,<SEG b$EX_MSG_BEG>    ;[1]
staticW	emsgln,<OFFSET b$EX_MSG_END>;[1] must subtract emsg from it

staticD	target,0 		; for long jump to 'exec code'

sEnd


FCB1	=	5ch		; offset in psp
FCB2	=	6ch

DOS2CMD= 280h			; size of DOS 2.0 non-resident COMMAND.COM


externP execve

sBegin	eseg

	dd	execve		; force in execve() if called from spawnve

sEnd

sBegin	code
assumes	cs,code
assumesdata	ds		;[1]


page
;***
;_doexec - execute a child process (overlay existing)
;
;Purpose:
;
;Entry:
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

cProc	_doexec,<PUBLIC>,<si,di>

	parmw	flag
	parmdp	nam
	parmw	nlength
	parmdp	command
	parmdp	envblock
	parmw	elength
	parmw	siz
	parmw	initss
	parmw	initsp
	parmw	initcs
	parmw	initip
	parmw	fsiz

cBegin

;	exec overlays the current process using its PSP and all memory
;	above it.

	push	ds		; save DGROUP

;	check for trashed arena before we go on - will assume OK from here on
;	DGROUP is on the top of the stack

	assumes	ds,nothing
l	checkmem
	pop	ds		; restore DGROUP
	assumesdata	ds	;[1]

	mov	bx,-1		; request max memory
	callos	allocmem	; will always fail
	cmp	al,E_arena
	je	ov0		;   arena is trashed

;	find out how much contiguous memory there is that is either free
;	or belongs to the current process

	mov	bx,[_psp]
	mov	dx,bx		; dx = current owner
	dec	bx		; bx = current arena header
	xor	cx,cx		; last free block in contiguous area

	push	ds		; save DGROUP
l	maxloop
	assumes	ds,nothing
	mov	ds,bx		; ds = current arena
	mov	ax,ds:[own]
	cmp	ax,dx		; do we own it?
	je	maxadd		;   yes - count it
	or	ax,ax		; is it free?
	jne	maxend		;   no - end of contiguous memory

	mov	cx,bx		; last free block of memory

l	maxadd
	inc	bx
	add	bx,ds:[asiz]
	jc	checkmem	;   carry - assuming arena is trashed
	mov	al,ds:[sig]	; get arena signature
	cmp	al,'M'		; are we at end of memory?
	je	maxloop		;   no - have good next block
	cmp	al,'Z'		;
	jne	checkmem	;   unknown sig byte - assuming arena is trashed

;	bx = top of contiguous area for current process
;	cx = last free segment contiguous with PSP

l	maxend
	sub	bx,dx		; bx = size
	pop	ds		; restore DS
	assumesdata	ds	;[1]
	mov	[freepsp],cx	; save last free segment contiguous with PSP

	cmp	[_osmajor],2	; see if 2.x or above
	ja	nohole		;   3.x or above, don't need hole for loader

	sub	bx,DOS2CMD+1	; leave 280h paras (10K) for the system's loader
	jnc	nohole		;   enough space

;-----	memory overflow or error before user memory is released

l	ov
	mov	ax,E_nomem	; not enough memory
l	ov0

	mov	AH,4CH		;[1]get code to terminate
	INT	21H		;[1]immediate termination

;-----

l	nohole

; see how big the exec code will be. it must sit in hi mem. it consists of
; code between a: and z: below (or b: and y: for .coms), the filename, (in the
; case of .exe files) a para of data (initial register values), and some room
; (160 bytes) for a local stack


STKSIZ=	160
exesz=	z-a
exeln=	exesz	+ STKSIZ	; .exe loader size + stack
comsz	=	y-b
comln=	comsz	+ STKSIZ	; .com loader size + stack

	push	bx		; save max length possible


	sub	[emsgln],offset b$EX_MSG_BEG ;[1] compute message length
	mov	ax,[emsgln]	;[1] need emsgln in calculations
	

	add	ax,BYTE PTR exeln	;[2] assume .exe
	cmp	flag,0
	je	join0		;   was .exe
___tmp=	comln-exeln
	add	ax,BYTE PTR ___tmp	;[2] was .com
l	join0

	mov	cl,4
	add	ax,nlength	; plus filename
	add	ax,0fh		; exec code rounded up to next para
	shr	ax,cl		; (ax) = paras for exec code

	mov	dx,elength	; new env length (in bytes)
	add	dx,0fh		; env rounded up to next para
	shr	dx,cl		; (dx) = paras for new env

	pop	bx		; restore the maximum length to bx

;	ax = exec code + data size
;	dx = environment size
;	bx = PSP contiguous size

	sub	bx,dx		; reduce PSP by environment segment
	jbe	ov

	sub	bx,2		; reduce by 2 (arena header + DOS 4.0 slop)
	jc	ov

;	bx = PSP contiguous size

	mov	cx,siz		; cx = assumed .exe size

	cmp	flag,0		; .exe or .com?
	je	join1		;   was .exe

	mov	cx,fsiz		; size of .com child in paras
	inc	cx		; plus para for stack
	jz	ov

l	join1
	add	cx,10h		; child must have a PSP
	jc	ov

;	ax = exec code + data size
;	cx = minimum size of child
;	bx = PSP contiguous size

	cmp	bx,cx		; enough for child?
	jb	ov		;   no

	push	ax		; save exec code size
	push	dx		; save env size

;	allocate and link all free memory in the system
;	assume the arena is good here and all errors are not enough memory

	xor	cx,cx		; cx = free link

l	allocloop
	mov	bx,1		; allocate 1 paragraph block
	callos	allocmem
	jc	allocall	;   all linked up

	mov	es,ax		; es = segment to allocate
	mov	bx,-1		; bx = maximum request
l	allocretry
	callos	setmem		; grow segment
	jc	allocretry	;  force it to be allocated

	mov	es:[0],cx	; save last free block
	mov	cx,es		; cx = current free link
	mov	dx,bx		; dx = size of last block
	jmp	allocloop	; keep allocating

l	allocall
	mov	bx,dx

;	es = cx = free segment linked list
;	bx = size of last free block

	cmp	[_osmajor],2	; check for DOS 2.0
	jne	allocenv	;   no - just try allocing environment

	sub	bx,DOS2CMD+1	; size to cut back
	jnc	shrinkdos2

;-----	release all "free" blocks because of error

l	freefree 		; free all linked up "free" memory
	jcxz	allfree
	mov	es,cx
	mov	cx,es:[0]	; next free block
	callos	freemem
	jnc	freefree	; keep freeing linked blocks

l	allfree			; if freemem error, just give up
	jmp	ov		; fail with no memory error

;-----

l	shrinkdos2
	callos	setmem
	jc	freefree	; any error at this point is no memory

;	es = cx = free segment linked list
;	bx = size of last free block

l	allocenv
	pop	dx		; dx = environment size
	push	dx
	inc	dx
	inc	dx		; dx = envsize + 2 (for arena header + DOS 4.0)
	sub	bx,dx
	jnc	haveenv		; have space in this block for environment

;	no space for environment in this block - try end of PSP contiguous area

	mov	ax,[freepsp]	; ax = last free segment in PSP-contiguous area
	or	ax,ax
	jz	tryotherfree	;   none here - try other free blocks

	inc	ax		; convert arena address to segment address
	mov	es,ax
	mov	bx,-1
	callos	setmem		; find size of segment
	cmp	al,E_nomem
	jne	freefree	;   must be something like arena trashed
	sub	bx,dx		; enough room?
	jnc	haveenv		;   yes - do actual environment allocation
				; else go try somewhere else

;	try other free blocks if above attempts fail

l	tryotherfree
	jcxz	allfree
	mov	ax,cx
;
;	dx = environment size in paragraphs + 2 (for arena hdr + DOS 4.0 slop)
;	cx = pointer to beginning of "free" list (segment address)
;	ax = pointer into "free" list (segment address)
;

l	tryotherloop
	dec	ax		;[1] AX = header address (temporarily)
	mov	es,ax		;    header of current free block
	mov	bx,es:[asiz]	;    size of current free block (in header)
	inc	ax		;[1] convert header addr back into seg addr
	mov	es,ax		;[1] AX = ES = segment address
	sub	bx,dx		; will environment fit?
	jnc	haveenv		;   yes - do actual environment allocation
	mov	ax,es:[0]	; else go on to next free block
	or	ax,ax		; end of list?
	jz	freefree	;   yes - not enough memory; clean up and fail
	jmp	short tryotherloop ; keep trying

;	es = segment to shrink for environment
;	bx = size to which to shrink chosen "free" segment

l	haveenv
	callos	setmem
	jc	freefree	; any error at this point is no memory

	pop	bx
	callos	allocmem	; allocate environment segment
	jc	freefree	; any error at this point is no memory

;	ax = environment segment

	mov	es,[_psp]
	mov	bx,es
	mov	es:[DOS_envp],ax ; new env segment
	mov	es,ax
	xor	di,di		; es:di points to new env

if	sizeD
	push	ds		; save DGROUP
	lds	si,envblock
else
	mov	si,envblock
endif
	mov	cx,elength
	rep	movsb		; move env to new segment
if	sizeD
	pop	ds		; restore DGROUP
endif

	mov	dx,es		; dx = environment segment

;	bx = PSP
;	dx = environment segment

	push	dx		; save needed registers
	push	bx

	cmp	_sigintseg,0	; has ^C been hooked ?
	je	letsgo		; no, do the exec

	push	ds
	mov	dx,_sigintoff	; load system default address
	mov	ds,_sigintseg	; load system default segment
	mov	ax,DOS_setvector shl 8 + 23H ; reset ^C vector (INT 23H)
	callos
	pop	ds		; restore registers
l	letsgo


;
;	IMPORTANT NOTE:
;
;	DOS 3.30 and later allow the user to increase the size of the
;	file handle table.  If the file handle count > 20, then a far
;	segment is allocated to store the table.  This segment must be
;	freed up before the child program is exec-ed.  This code relies
;	on the fact that DOS will free up that far segment if the handle
;	count is set back to 20.  If DOS ever changes, this code will fail.
;
	mov	ax,word ptr [_osmajor]
	xchg	ah,al		; AH = _osmajor, AL = _osminor
	cmp	ax,(3 shl 8) + 30
	jb	pre_DOS330	; _osmajor:_osminor < 3:30?

	mov	bx,20		; IF >= DOS 3.30 THEN
	mov	ah,67h		; Set Handle Count on principle
	callos			; set number of handles to default value
pre_DOS330:

	pop	bx
	pop	dx

;	WARNING - any errors past this point - must go to execpanic

;	now free all blocks of memory belonging to this process
;	except the PSP and new environment block

;	bx = PSP
;	dx = environment segment

l	freemore
	push	bx		; save PSP
	mov	ah,52h		; magic DOS call
	int	21h
	mov	ax,es:[bx-2]	; ax = first arena segment!!!
	pop	bx		; restore PSP

;	ax = current segment to check

l	findused
	mov	es,ax
	inc	ax
	cmp	ax,bx		; is it PSP?
	je	atend		;   yes - skip
	cmp	ax,dx		; is it environment?
	je	atend		;   yes - skip

	cmp	es:[own],bx	; do we own it?
	jne	atend		;   no -skip

	mov	es,ax		; es = must be one past arena header
	callos	freemem		; free up the segment
	jmp	freemore	;   and start over - even if error

l	atend
	add	ax,es:[asiz]	; add in segment size
	jc	freemore	;   error - changed arena - retry
	cmp	es:[sig],'Z'	; last segment?
	jne	findused	;   no - check next segment

;	increase size of PSP to maximum amount available
;
;	bx = PSP

	mov	es,bx		; es= PSP
	mov	bx,-1
	callos	setmem
	callos	setmem		; allocates on second try
	jnc	bigPSP

l	execpanic		; error in exec after memory freed
	mov	dx,word ptr [emsg]	;[1] DS:DX = "Not enough memory"
	mov	ax,word ptr [emsgseg]	;[1]
	mov	ds,ax		;[1]
	callos	message
	mov	ax,DOS_terminate shl 8 + 255
	callos			; error code = 255

l	bigPSP
	mov	ax,es
	add	ax,bx		; bx = size of PSP block
	mov	es:[DOS_maxpara],ax ; set new memory limit in PSP

;	ax = top of PSP segment
;	((sp)) = (exec code size)

	pop	cx		; cx = exec code size
	sub	bx,cx		; reduce PSP size
	jc	execpanic
	sub	ax,cx
	mov	word ptr [target+2],ax ; set up final jump address

;	move the exec code and its data up to hi mem
;
;	ax = exec code segment

	mov	es,ax		; es = exec code segment
	push	es		; save exec code segment

	push	ds		; save DGROUP

	push	cs
	pop	ds		; ds points into code segment
	xor	di,di
	mov	cx,BYTE PTR exesz ;[1] assume exe file
	mov	si,codeOFFSET a
	cmp	flag,0		; .exe or .com?
	je	exe4		;   .exe
	mov	cx,BYTE PTR comsz ;[1]
	mov	si,codeOFFSET b

l	exe4
	rep	movsb		; move code to exec code segment

	pop	ds		; restore DGROUP

	push	ds		;[1] save DGROUP
	mov	cx,[emsgln]	;[1] count of bytes to move
	mov	si,word ptr [emsg]	;[1] DS:SI = start of 3 error messages
	mov	ax,word ptr [emsgseg]	;[1]
	mov	ds,ax		;[1]
	rep	movsb		;[1] move 3 error messages
	pop	ds		;[1] restore DGROUP

	mov	bx,di		; (bx) = offset of data/name (save)
	cmp	flag,0		; .exe or .com?
	jne	com5		;   .com

; for .exe save initial register values

	mov	ax,initss
	stosw
	mov	ax,initsp
	stosw
	mov	ax,initcs
	stosw
	mov	ax,initip
	stosw
l	com5

if	sizeD
	push	ds		; save DGROUP
	lds	si,nam
else
	mov	si,nam
endif

	mov	cx,nlength
	rep	movsb		; move name

if	sizeD
	pop	ds		; restore DGROUP
endif

; exec code and its data are in hi mem. set the dma and fix the psp (the
; command line at offset 80h, and the fcbs)

	mov	es,[_psp]	; psp seg

; set the dma to psp:80h

	push	ds		; save DGROUP
	push	es
	pop	ds		; psp segment
	mov	dx,80h		; default dma=psp:80h
	callos	setdma
	pop	ds		; restore DGROUP

; set up the command line

	mov	di,DOS_cmdline

if	sizeD
	push	ds		; save DGROUP
	lds	si,command
else
	mov	si,command
endif
	mov	cl,[si]		; length of command
	inc	cx		; (ch) = 0 from last rep movsb (name)
	inc	cx		; count byte & terminating <cr>
	rep	movsb		; move the command line into psp:80h

; set up the fcbs

	mov	dx,bx		; (dx) = data/name offset

	mov	di,FCB1		; fcb at offset 5ch
	xchg	ax,cx		; null byte to store
				; (cx) = 0 from last rep movsb (command line)
	mov	cx,20h		; length of 2 fcbs
	rep	stosb		; zero the fcbs
	mov	di,FCB1		; fcb at offset 5ch

if	sizeD
	lds	si,command
else
	mov	si,command
endif
	inc	si		; si points to arg1 (or space before it)
	mov	ax,DOS_fcbparse shl 8 + 1
	callos			; parse filename
	cmp	al,0ffh		; see if invalid drive letter
	je	bad1
	xor	al,al
l	bad1
	mov	bl,al		; first drive letter
	mov	di,FCB2		; second fcb in psp
	mov	ax,DOS_fcbparse shl 8 + 1
	callos			; parse filename
	cmp	al,0ffh		; see if invalid drive letter
	je	bad2
	xor	al,al
l	bad2
	mov	bh,al		; bx = drive letter flags

if	sizeD
	pop	ds		; restore DGROUP
endif

; setup stack in exec code segment

	pop	cx		; exec code segment
	mov	si,dx		; data/name offset in exec code
	add	si,STKSIZ	; push it up to produce a stack
	cmp	flag,0		; .exe or .com? (last frame reference)
	mov	bp,bx		; initial ax
	cli			; disable interrupts until stack set up
	mov	ss,cx
	mov	sp,si
	sti			; temporary stack set up

	jne	join6		;   was .com

	push	dx		; save data offset to init. register values
	add	dx,8		; name offset in hi mem

l	join6

	mov	ax,es		; (ax) = paras from 0:0 to psp:0
	add	ax,10h		; (ax) = paras from 0:0 to parameter block
	mov	bx,100h		; psp:100h is parameter block for load/exec
	mov	es:[bx],ax	; word segment address to load at
	mov	es:[bx+2],ax	; word relocation factor to be applied
	push	ax		; save relocation factor
	mov	ax,DOS_exec shl 8 + 3

;	(ax) = dos code for load/exec (4b03h)
;	(dx) = name offset in exec segment
;	(es:bx) = psp:100 (parameter block)
;	(ds) = DGROUP seg
;	(bp) = initial ax
;
;	di and si are free

	jmp	dword ptr [target] ; and away we go!

;-----------------------------------------------------------------------------

NOMEM	equ	5
BADFORM	equ	6
BADENV	equ	7

execom	macro	lab,fil
l	lab
	push	cs
	pop	ds		; DS = exec code segment

	callos			; overlay parent with child
	jnc	allok&lab

	mov	bx,BADFORM - NOMEM
	cmp	al,E_ifunc	; invalid format
	je	die&lab

	mov	bl,BADENV - NOMEM
	cmp	al,E_badenv	; bad environment
	je	die&lab

	mov	bl,BADFORM - NOMEM
	cmp	al,E_badfmt	; bad format
	je	die&lab

	xor	bx,bx		; NOMEM - NOMEM

l	die&lab
	push	cs
	pop	es		; es = exec code segment

	xor	ax,ax
	mov	cx,-1
	mov	di,BYTE PTR fil&sz	;[2]
	or	bx,bx
	jz	outmsg&lab
	jmp	short nmsg&lab


;	Warning if you change this section above you must
;	leave the following bytes for DOS 2.0 to walk all
;	over without walking on data DOS walks on DS:2E to
;	DS:31  extra slop just incase!

	org	lab + 32h
l	nmsg&lab
	repne	scasb
	inc	di		; skip past message number
	inc	di
	dec	bx
	jnz	nmsg&lab

l	outmsg&lab
	mov	dx,di
	callos	message
	mov	ax,DOS_terminate shl 8 + 255
	callos			; terminate (255)

l	allok&lab
	endm


;-----------------------------------------------------------------------------
;
;	.exe  exec code

	execom	a,exe		; expand for .exe file

	pop	di		; relocation factor
	pop	si		; data offset of initial register values

	lodsw			; initss
	add	ax,di		; relocation factor (paras) from 0:0
	xchg	dx,ax
	lodsw			; initsp
	cli
	mov	ss,dx		; reloc'd ss
	mov	sp,ax
	sti

	lodsw			; initcs
	add	di,ax
	lodsw
	push	di		; save INIT CS
	push	ax		; save INIT IP

	push	es
	pop	ds		; es = ds = PSP
	mov	ax,bp		; ax = valid drive letter flags

xglobal	proc	far
	ret			; force far return to dos int 21h handler
xglobal	endp

z:

;-----------------------------------------------------------------------------
;
;	.com  exec code

	execom	b,com		; expand for .com file

	pop	di		; burn relocation factor (not used)
	mov	bx,cs		; get exec code segment
	mov	ax,es		; get PSP segment
	sub	bx,ax		; bx = size of program area (in paragraphs)

	mov	cl,4
	test	bx,0f000h	; will we lost precision when we shift?
	jz	doit
	mov	bx,1000h	;   yes, set ss:sp = psp:0000
doit:
	shl	bx,cl		; make byte offset from psp:0
	dec	bx
	dec	bx
	cli			; disable interrupts until stack's ok
	mov	ss,ax
	mov	sp,bx		; reserved para offset (stack grows down)
	sti			; enable interrupts; stack's ok now
	mov	word ptr ss:[bx],0 ; put 0000 on top of stack for return

	push	es
	mov	ax,100h
	push	ax		; INIT CS:IP = PSP:100h
	push	es
	pop	ds		; DS = ES = CS = PSP
	mov	ax,bp		; ax = valid drive letter flags

cglobal	proc	far
	ret			; force far return
cglobal	endp

y:

cEnd	nogen


sEnd
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\fmsghdr.asm ===
page	,132
	title	fmsghdr       - far message handler and finder
;***
;fmsghdr.asm - far message handler and finder
;
;	Copyright (c) 1986-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	Far message handler and finder.
;
;*******************************************************************************


?DF=	1			; this is special for c startup
include	version.inc
?PLM=	1			; pascal calling conventions
.xlist
include	cmacros.inc
include	msdos.inc
.list

createSeg _TEXT, code,	word,	public, CODE,	<>

createSeg _DATA, data,	word,	public, DATA,	DGROUP

createSeg FAR_HDR,fhdr, byte,	public, FAR_MSG,FMGROUP
createSeg FAR_MSG,fmsg, byte,	public, FAR_MSG,FMGROUP
createSeg FAR_PAD,fpad, byte,	common, FAR_MSG,FMGROUP
createSeg FAR_EPAD,fepad, byte,	common, FAR_MSG,FMGROUP

defGrp	DGROUP			; define DGROUP
defGrp	FMGROUP			; define FMGROUP

codeOFFSET equ	offset _TEXT:
fmsgOFFSET equ	offset FMGROUP:

assumesdata	macro	seg	;;[1] Newer versions of CMACROS reject
assumes	seg,DGROUP		;;[1]
endm				;;[1]

sBegin	fhdr
assumesdata	ds		;[1]

	db	'<<FMSG>>'
stfmsg	label	byte

sEnd

SBegin	fpad
assumesdata	ds		;[1]

	dw	-1		; message padding marker

sEnd

sBegin	fepad
assumesdata	ds		;[1]

	db	-1

sEnd


sBegin	code
assumes	cs,code
assumesdata	ds		;[1]

page
;***
;__FMSG_TEXT(messagenumber) - find message for given message number
;
;Purpose:
;	This routine returns a far pointer to the message associated with
;	messagenumber.	If the message does not exist, then a 0:0 is returned.
;
;Entry:
;	==PASCAL CALLING CONVENTIONS==
;	messagenumber	= WORD number of desired message
;
;Exit:
;	DX:AX	= pointer to message text or 0:0 if message doesn't exist
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

cProc	__FMSG_TEXT,<PUBLIC>,<ds,si,di,es>  ;[1] pascal calling - added ES

parmW	msgt

cBegin
	mov	ax,FMGROUP
	mov	ds,ax		; ds = FMGROUP (force it always)
	push	ds
	pop	es
	mov	dx,msgt		; dx = message number
	mov	si,fmsgOFFSET stfmsg ; start of far messages

tloop:
	lodsw			; ax = current message number
	cmp	ax,dx
	je	found		;   found it - return address
	inc	ax
	xchg	ax,si
	jz	found		;   at end and not found - return 0
	xchg	di,ax
	xor	ax,ax
	mov	cx,-1
	repne	scasb		; skip until 00
	mov	si,di
	jmp	tloop		; try next entry

found:
	xchg	ax,si
	cwd			; zero out dx in case NULL
	or	ax,ax
	jz	notfound
	mov	dx,ds		; remember segment selector
notfound:
cEnd

sEnd

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\errno.inc ===
;***
;errno.inc - defines standard C error codes
;
;	Copyright (c) 1987-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file contains definitions for the standard C error codes
;	used by XENIX (many of these have little significance for
;	MS-DOS).
;
;*******************************************************************************


err	MACRO	num,name,text
name	equ	num
	ENDM


err	1,	EPERM,          <Not owner>
err	2,	ENOENT,         <No such file or directory>
err	3,	ESRCH,          <No such process>
err	4,	EINTR,          <Interrupted system call>
err	5,	EIO,            <I/O error>
err	6,	ENXIO,          <No such device or address>
err	7,	E2BIG,          <Arg list too long>
err	8,	ENOEXEC,        <Exec format error>
err	9,	EBADF,          <Bad file number>
err	10,	ECHILD,         <No child processes>
err	11,	EAGAIN,         <No more processes>
err	12,	ENOMEM,         <Not enough space>
err	13,	EACCES,         <Permission denied>
err	14,	EFAULT,         <Bad address>
err	15,	ENOTBLK,        <Block device required>
err	16,	EBUSY,          <Mount device busy>
err	17,	EEXIST,         <File exists>
err	18,	EXDEV,          <Cross-device link>
err	19,	ENODEV,         <No such device>
err	20,	ENOTDIR,        <Not a directory>
err	21,	EISDIR,         <Is a directory>
err	22,	EINVAL,         <Invalid argument>
err	23,	ENFILE,         <File table overflow>
err	24,	EMFILE,         <Too many open files>
err	25,	ENOTTY,         <Not a typewriter>
err	26,	ETXTBSY,        <Text file busy>
err	27,	EFBIG,          <File too large>
err	28,	ENOSPC,         <No space left on device>
err	29,	ESPIPE,         <Illegal seek>
err	30,	EROFS,          <Read-only file system>
err	31,	EMLINK,         <Too many links>
err	32,	EPIPE,          <Broken pipe>
err	33,	EDOM,           <Math argument>
err	34,	ERANGE,         <Result too large>
err	35,	EUCLEAN,        <file system needs cleaning>
err	36,	EDEADLOCK,      <would deadlock>

;       end of errno.inc
;-----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\execve.asm ===
title	execve	-- stub to disable C execs and spawns

;--------------------------------------------------------------------------
;
;	Microsoft C Compiler Runtime for MS-DOS
;
;	(C)Copyright Microsoft Corporation, 1985, 1985, 1986
;
;--------------------------------------------------------------------------
;
;	Purpose
;
;	This routine is used to disable all forms of C execs and spawns
;	for BASIC.  BASIC will trap the attempt and issue an advanced
;	feature error.	All forms of the C exec function filter through
;	_execve.  All forms of spawn, and system() filter into _spawnve.
;
;----------------------------------------------------------------------------

?DF=		1			; this is special for c startup
include version.inc
.xlist
include cmacros.inc
.list

createSeg	_TEXT,	code,	byte,	public, CODE,	<>

?PLM = 1
externP B$ERR_AFE			;BASIC advance feature error
sBegin	code
assumes cs,code

;	_spawnve, _execve
;
;	The BASIC runtime cannot coexist peacefully with the
;	C exec, spawn, and system functions.  All of these
;	functions filter their way into either _spawnve or
;	_execve.  We will trap the attempt and issue an
;	ADVANCED feature error to the BASIC program.

labelP	<PUBLIC,_spawnve>
cProc	_execve,<PUBLIC,FORCEFRAME>,<>
cBegin
	PUSH	SS		;[2] set DS = SS = DGROUP
	POP	DS		;[2]
	JMP	B$ERR_AFE	; let BASIC print the error message
cEnd	nogen

sEnd	code
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\freect.asm ===
page	,132
	title	freect - C runtime heap allocation _freect and _memavl
;***
;freect.asm - C runtime heap allocation _freect and _memavl
;
;	Copyright (c) 1987-1988, Microsoft Corporation, All Rights Reserved
;
;Purpose:
;	_freect and _memavl routines are useful for determining how
;	much memory within the default data segment is still free for
;	dynamic allocation (by malloc in small/medium memory models,
;	and by _nmalloc in all memory models).
;
;*******************************************************************************

include	version.inc
.xlist
include	cmacros.inc
include	brkctl.inc
.list

sBegin	data
assumes	ds,data

externW	_asegds
extrn b$nmalloc_end:word	;[1] end of BASIC near malloc buffer
externW	_abrktb

sEnd	data

externP	_nmalloc


sBegin	code
assumes	ds,data
assumes	cs,code

;
; freect() assumes that DGroup_Left() does not trash CX
;	In real mode (DOS 3), uses actual size of DGROUP
;	If executing in Protected Mode, assume DGROUP can be grown to 65535
;


cProc	DGroup_Left,<NEAR>,<>

cBegin
 	mov	ax,[b$nmalloc_end] ;[1] size of Near malloc buffer...
 	dec	ax		;[1] ...-1
not_prot_mode:
	sub	ax,3		; overhead - can only use 65534 bytes
				; allocating an entry takes 2 bytes
				; plus 1 to make AX=DGROUP-overhead
	mov	dx,[_abrktb].sz	; end of heap memory
	mov	bx,[_asegds]
	cmp	word ptr [bx+2],0fffeH ; check for heap not really set-up
	jnz	have_heap
	sub	ax,3		; more overhead: dummy heap entries
have_heap:
	cmp	ax,dx
	ja	have_room
	mov	dx,ax		; no room left
have_room:
	sub	ax,dx		; number of bytes than can be allocated
cEnd

page
;***
;unsigned _memmax() - find size of largest free block in near heap
;
;Purpose:
;	returns the size in bytes of the maximal free block left in
;	the default data segment (in the near heap)
;
;Entry:
;	None.
;
;Exit:
;	returns AX = WORD size in bytes of largest free block in DGROUP
;
;Uses:
;	BX, CX, DX.
;
;Exceptions:
;
;*******************************************************************************

cProc	_memmax,<PUBLIC>,<si>

cBegin
	call	_initheap	; make sure heap is init'd
	or	ax,ax		; did _initheap succeed ??
	jz	x_exit		; nope - return 0

	call	DGroup_Left	; Number of free bytes left in DGROUP
	mov	cx,ax		; after the end of the current heap
	mov	bx,ax		; Save in BX for later

	mov	si,[_asegds].bottom ; si = start of near heap
	jmp	short x_first	; into the middle of things

x_notfree:
	cmp	ax,-2		; check for end of heap
	je	x_endheap
	add	si,ax		; advance to next heap entry

x_first:
	lodsw			; ax = length
	test	al,1
	jz	x_notfree	;   in use - go to next one
;
;	Add up a series of 1 or more contiguous free blocks as if
;	they were coalesced.  Coalescing is only done when needed.
;
	mov	dx,-2		; bias by -2 for first header

x_isfree:
	dec	ax		; ax = length of free block
	inc	dx
	inc	dx		; add in size of freeable header
	add	dx,ax		; add in free block
	add	si,ax		; si = next entry
	lodsw
	test	al,1		; is next free?
	jnz	x_isfree	;   yes - total it up

	cmp	ax,-2
	jne	x_notend
	add	dx,bx		; add in space left in DS after heap
	add	dx,2		; don't need a new header
x_notend:
	cmp	cx,dx		; add in "would-be coalesced" block
	ja	x_notfree	; made up of adjacent free entries
	mov	cx,dx
	jmp	x_notfree	; CX keeps track of largest

x_endheap:
	mov	ax,cx		; return largest number of free
				; bytes in one contiguous piece
x_exit:

cEnd

page
;***
;unsigned _memavl() - gives byte count of remaining space in near heap
;
;Purpose:
;	The _memval function returns the approximate size, in bytes, of
;	the memory available for dynamic memory allocation within the
;	default data segment.  This function can be used with calloc,
;	malloc, or realloc in small/medium memory models, and with
;	_nmalloc in all memory models.
;
;	This is the DOS version of _memavl, and it calls DGroup_Left.
;
;Entry:
;	None.
;
;Exit:
;	returns AX = WORD size in bytes of available 'near heap' memory
;
;Uses:
;	CX, DX.
;
;Exceptions:
;
;*******************************************************************************

cProc	_memavl,<PUBLIC>,<si>

cBegin
	call	_initheap	; make sure heap is init'd
	or	ax,ax		; did _initheap succeed ??
	jz	_exit		; nope - return 0

	call	DGroup_Left	; Number of free bytes left in DGROUP
	mov	cx,ax		; after the end of the current heap

	mov	si,[_asegds].bottom ; si = start of near heap
	jmp	short _first	; into the middle of things

_notfree:
	cmp	ax,-2		; check for end of heap
	je	_endheap
	add	si,ax		; advance to next heap entry

_first:
	lodsw			; ax = length
	test	al,1
	jz	_notfree	;   in use - go to next one
;
;	Add up a series of 1 or more contiguous free blocks as if
;	they were coalesced.  Coalescing is only done when needed.
;
	mov	dx,-2		; bias by -2 for first header

_isfree:
	dec	ax		; ax = length of free block
	inc	dx
	inc	dx		; add in size of freeable header
	add	dx,ax		; add in free block
	add	si,ax		; si = next entry
	lodsw
	test	al,1		; is next free?
	jnz	_isfree		;   yes - total it up

	add	cx,dx		; add in "would-be coalesced" block
	jmp	_notfree	; made up of adjacent free entries

_endheap:
	mov	ax,cx		; return number of free bytes

_exit:

cEnd

page
;***
;unsigned _freect(size) - count of blocks of given size that can be _nmalloc()'d
;
;Purpose:
;	To give an indication of how much free space is available
;	within the default data segment for dynamic memory allocation
;	(malloc/_nmalloc), in terms of the number of blocks of the
;	given size that can be _nmalloc()'d before running out of space.
;
;Entry:
;	blksiz = WORD size of block to be used as a measuring rod
;		 of available memory
;
;Exit:
;	returns AX = WORD number of blocks of size 'blksiz' that could
;	             be _nmalloc()'d
;
;Uses:
;	BX, CX, DX.
;
;Exceptions:
;
;*******************************************************************************

cProc	_freect,<PUBLIC>,<si>

	parmW	blksiz		; block size

cBegin
	call	_initheap	; make sure heap is init'd
	or	ax,ax		; did _initheap succeed ??
	jz	freectxit	; nope - return 0

	mov	si,[_asegds].bottom ; si = start of near heap
	mov	bx,blksiz
	add	bx,3
	and	bl,not 1	; round up even (blksiz+2)
	xor	cx,cx		; # free entries
	jmp	short first	; into the middle of things

notfree:
	cmp	ax,-2		; check for end of heap
	je	endheap
	add	si,ax

first:
	lodsw			; ax = length
	test	al,1
	jz	notfree		;   in use - go to next one

	mov	dx,-2		; bias by -2

isfree:
	dec	ax		; ax = length of free block
	inc	dx
	inc	dx		; add in size of freeable header
	add	dx,ax		; add in free block
	add	si,ax		; si = next entry
	lodsw
	test	al,1		; is next free?
	jnz	isfree		;   yes - total it up

	push	ax
	xchg	ax,dx
	xor	dx,dx
	div	bx
	add	cx,ax		; cx += freeblock / (blksiz+2)
	pop	ax
	jmp	notfree

endheap:
	push	bx		; DGroup_Left may trash BX
	call	DGroup_Left	; must preserve CX
	pop	bx
	xor	dx,dx
	div	bx
	add	ax,cx		; ax = cx + DGROUPfree / (blksiz+2)

freectxit:
cEnd

page
;***
;_initheap - Initializes the heap, if necessary.
;
;Purpose:
;	_initheap tests to see if the heap is initialized.  If not,
;	it issues a malloc which causes the heap to be initialized.
;	_initheap then frees the memory it aquired (since it is not
;	really needed).
;
;	We must check to see if _nmalloc returns NULL.
;
;Entry:
;	None.
;
;Exit:
;	AX =  0 = failure, heap no room to initialize heap
;	     !0 = success, heap initialized
;
;Uses:
;	AX, BX
;
;Exceptions:
;	None.
;
;*******************************************************************************

cProc	_initheap,<NEAR>,<>

cBegin
	mov	ax,1		;ax = 1 = success flag
	mov	bx,dataoffset[_asegds] ;heap data base
	cmp	word ptr[bx],0	;is it init'd ??
	jne	_initdone	;leave if heap init'd

	;mov	ax,1		;allocate a 1-byte area
	push	ax		;onto the stack
	call	_nmalloc	;initialize the heap
	pop	bx		;[1] clean stack after call for people who's
				;[1] CMACROS doesn't put a MOV SP,BP at the end
	or	ax,ax		;did _nmalloc() succeed ??
	jz	_initdone	;if failure, exit with AX=0
	mov	bx,ax		;get mem addr in index reg
	or	byte ptr[bx-2],1 ;free the memory

_initdone:			;return with ax

cEnd

sEnd	code

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\fpreset.asm ===
title	fpreset  - floating point package reset routine

;---------------------------------------------------------------------------
;
;	Copyright (C) Microsoft Corp. 1985
;
;---------------------------------------------------------------------------

include version.inc
.xlist
include cmacros.inc
;[1] include os2supp.inc
.list


createSeg CDATA, cdata,	word,	common, DATA,	DGROUP

sBegin	cdata
externD _fpinit
sEnd	cdata

dgroup	group	cdata

assumes ds,dgroup

sBegin	code
assumes cs,code

;***	_fpreset - reset floating point math and control word

cproc	_fpreset,<PUBLIC>,<>

cBegin
;ifdll - don't _loadds - DS not used>
	mov	cx,word ptr [_fpinit+2] ;Get segment of math vector
	jcxz	nofloat 		;No floating point present
	mov	bx,1
	call	[_fpinit]		; reset chip
	mov	bx,4
	mov	ax,1332h		; ignored by altmath/decmath
	call	[_fpinit]		; set initial control word
nofloat:
cEnd

sEnd

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\msdos.inc ===
;***
;msdos.inc - MS-DOS definitions for C runtime
;
;	Copyright (c) 1987-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file contains the MS-DOS definitions (DOS function request
;	numbers, flags, etc) used by the C runtime.
;
;*******************************************************************************


;_NFILE equ	20		; maximum # files per process

STACKSLOP equ	256		; stack slop for DOS interrupt overhead

;	__osfile flag values for DOS file handles

FOPEN	equ	01H		; file handle open
FEOFLAG	equ	02H		; end of file has been encountered
FCRLF	equ	04H		; CR-LF across read buffer (in text mode)
FPIPE	equ	08H		; file handle refers to a pipe
FRDONLY	equ	10H		; file handle associated with read only file
FAPPEND	equ	20H		; file handle opened O_APPEND
FDEV	equ	40H		; file handle refers to device
FTEXT	equ	80H		; file handle is in text mode


callos	MACRO	func
ifnb	<func>
	mov	ah,DOS_&func
endif
	int	DOS
	ENDM


DOS	equ	21H		; MS-DOS interrupt

DOS_exit equ	00000H		; exit offset		(PSP:0000)
DOS_maxpara equ	00002H		; maximum paragraph	(PSP:0002)
DOS_envp equ	0002cH		; environment address	(PSP:002c)
DOS_cmdline equ	00080H		; command line offset	(PSP:0080)

DOS_kill	equ	00H		; terminate
DOS_echoread	equ	01H		; read keyboard and echo
DOS_display	equ	02H		; display character
DOS_auxinput	equ	03H		; auxiliary input
DOS_auxoutput	equ	04H		; auxiliary output
DOS_print	equ	05H		; print character
DOS_conio	equ	06H		; direct console i/o
DOS_coninput	equ	07H		; direct console input
DOS_readkbd	equ	08H		; read keyboard
DOS_message	equ	09H		; display string
DOS_bufkbdin	equ	0aH		; buffered keyboard input
DOS_kbdstatus	equ	0bH		; check keyboard status
DOS_flshread	equ	0cH		; flush buffer and read keyboard
DOS_diskreset	equ	0dH		; disk reset
DOS_selectdisk	equ	0eH		; select default disk
DOS_fcbopen	equ	0fH		; open file with fcb
DOS_fcbclose	equ	10H		; close file with fcb
DOS_fcbfirst	equ	11H		; search for first entry with fcb
DOS_fcbnext	equ	12H		; search for next entry with fcb
DOS_fcbdelete	equ	13H		; delete file with fcb
DOS_fcbsread	equ	14H		; sequential read with fcb
DOS_fcbswrite	equ	15H		; sequential write with fcb
DOS_fcbcreate	equ	16H		; create file with fcb
DOS_fcbrename	equ	17H		; rename file with fcb
DOS_currentd	equ	19H		; current default disk
DOS_setDMA	equ	1aH		; set DMA
DOS_fcbrread	equ	21H		; random read with fcb
DOS_fcbrwrite	equ	22H		; random write with fcb
DOS_fcbsize	equ	23H		; file size with fcb
DOS_fcbsetrec	equ	24H		; set relative record with fcb
DOS_setvector	equ	25H		; set interrupt vector
DOS_fcbbread	equ	27H		; random block read with fcb
DOS_fcbbwrite	equ	28H		; random block write with fcb
DOS_fcbparse	equ	29H		; parse file name with fcb
DOS_getdate	equ	2aH		; get date
DOS_setdate	equ	2bH		; set date
DOS_gettime	equ	2cH		; get time
DOS_settime	equ	2dH		; set time
DOS_verify	equ	2eH		; set/reset verify flag
DOS_getDMA	equ	2fH		; get DMA
DOS_version	equ	30H		; get version number
DOS_keep	equ	31H		; keep process
DOS_cntlc	equ	33H		; Cntl-C check
DOS_getvector	equ	35H		; get interrupt vector
DOS_getdskspc	equ	36H		; get disk free space
DOS_country	equ	38H		; get country dependent info
DOS_mkdir	equ	39H		; make subdirectory
DOS_rmdir	equ	3aH		; remove subdirectory
DOS_chdir	equ	3bH		; change subdirectory
DOS_create	equ	3cH		; create pathname
DOS_open	equ	3dH		; open pathname
DOS_close	equ	3eH		; close file handle
DOS_read	equ	3fH		; read from file handle
DOS_write	equ	40H		; write from file handle
DOS_delete	equ	41H		; delete pathname
DOS_lseek	equ	42H		; move file pointer
DOS_filemode	equ	43H		; get/set attributes of pathname
DOS_ioctl	equ	44H		; ioctl for devices
DOS_dup		equ	45H		; duplicate file handle
DOS_forcedup	equ	46H		; force duplicate file handle
DOS_curdir	equ	47H		; get current directory
DOS_allocmem	equ	48H		; allocate memory block
DOS_freemem	equ	49H		; free memory block
DOS_setmem	equ	4aH		; set size of memory block
DOS_exec	equ	4bH		; load and execute program
DOS_terminate	equ	4cH		; terminate process with errorcode
DOS_wait	equ	4dH		; get child process return code
DOS_findfirst	equ	4eH		; find first file match
DOS_findnext	equ	4fH		; find next file match
DOS_getverify	equ	54H		; return current verify flag
DOS_rename	equ	56H		; rename pathname
DOS_filedate	equ	57H		; get/set file handle date/time
DOS_createnew	equ	5BH		; create new file
DOS_locking	equ	5CH		; file record locking/unlocking
DOS_sleep	equ	89H		; delay process execution


;	DOS error codes

doserr	MACRO	num,name,text
name	equ	num
	ENDM

doserr	1,	E_ifunc,	<invalid function code>
doserr	2,	E_nofile,	<file not found>
doserr	3,	E_nopath,	<path not found>
doserr	4,	E_toomany,	<too many open files>
doserr	5,	E_access,	<access denied>
doserr	6,	E_ihandle,	<invalid handle>
doserr	7,	E_arena,	<arena trashed>
doserr	8,	E_nomem,	<not enough memory>
doserr	9,	E_iblock,	<invalid block>
doserr	10,	E_badenv,	<bad environment>
doserr	11,	E_badfmt,	<bad format>
doserr	12,	E_iaccess,	<invalid access code>
doserr	13,	E_idata,	<invalid data>
doserr	14,	E_unknown,	<??? unknown error ???>
doserr	15,	E_idrive,	<invalid drive>
doserr	16,	E_curdir,	<current directory>
doserr	17,	E_difdev,	<not same device>
doserr	18,	E_nomore,	<no more files>
doserr	19,	E_maxerr2,	<unknown error - Version 2.0>

; the following errors can occur only in DOS 3.0

doserr	32,	E_sharerr,	<sharing violation>
doserr	33,	E_lockerr,	<locking violation>
doserr	34,	E_maxerr3,	<unknown error - Version 3.0>


;	DOS file attributes

A_ro	equ	01H		; read-only file
A_h	equ	02H		; hidden
A_s	equ	04H		; system
A_v	equ	08H		; volume ID
A_d	equ	10H		; directory
A_a	equ	20H		; archive

A_mod	equ	A_ro+A_h+A_s+A_a ; modifiable attributes

;	OS/2 file creation bits

F_CREATFLAG equ 10h
F_OPENFLAG  equ 01h
F_TRUNCFLAG equ 02H

;	OS/2 device mask

IS_DEV	equ 1
IS_PIPE equ 2

;	end of msdos.inc
;-----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\onexit.asm ===
page	,132
	title	onexit - saves function pointer for pretermination execution
;***
;onexit.asm - save function for execution on exit
;
;	Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines onexit(), atexit() - save function for execution at exit
;
;*******************************************************************************

?DF	=	1		; tell cmacros.inc we want to define our own segments

include	version.inc
.xlist
include	cmacros.inc
.list

assumesdata	macro	seg	;;[1] Newer versions of CMACROS reject
assumes	seg,DGROUP		;;[1]
endm				;;[1]

createSeg _TEXT, code,	word,	public, CODE,	<>
createSeg _DATA, data,	word,	public, DATA,	DGROUP

createSeg XOB,	xobseg, word,	public, BSS,	DGROUP
createSeg XO,	xoseg,	word,	public, BSS,	DGROUP ; onexit table
createSeg XOE,	xoeseg, word,	public, BSS,	DGROUP

defGrp	DGROUP			; define DGROUP

codeOFFSET equ	offset _TEXT:
dataOFFSET equ	offset DGROUP:

    CPsize= 4


sBegin	xoseg
assumesdata	ds		;[1]

ontable	db	32*CPsize dup (?) ; in BSS because it is not initialized
onend	label	byte

sEnd


sBegin	data
assumesdata	ds		;[1]

staticW	onptr,<dataOFFSET ontable>

sEnd


sBegin	code
assumes	cs,code
assumesdata	ds		;[1]

page
;***
;onexit(func), atexit(func) - add function to be executed upon exit
;
;Purpose:
;	The onexit/atexit functions are passed a pointer to a function
;	to be called when the program terminate normally.  Successive
;	calls create a register of functions that are executed last in,
;	first out.
;
;Entry:
;	void (*func)() - pointer to function to be executed upon exit
;
;Exit:
;	onexit:
;		Success - return pointer to user's function.
;		Error - return NULL pointer.
;	atexit: (MSC 5.0 Only)
;		Success - return 0.
;		Error - return non-zero value.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

cProc	atexit,<PUBLIC>,<> 	; atexit entry point

	parmCP	fname

cBegin
	mov	ax,-1		; error return is non-zero
	jmp	SHORT common	; join common code
cEnd	nogen

cProc	onexit,<PUBLIC>,<> 	; onexit entry point

	parmCP	fname

cBegin
	xor	ax,ax		; error return is 0 (NULL pointer)
common:

				; common code
	mov	cx,ax		; save error value as entry code
	cwd			; dx:ax = error return value
	mov	bx,[onptr]	; get current onexit table pointer
	cmp	bx,dataOFFSET onend ; is the table full?
	je	retax		;   yes - return 0

	add	[onptr],CPsize	; point to next table entry
	mov	dx,word ptr (fname+2) ; get terminator segment
	mov	[bx+2],dx	; save terminator segment
	mov	ax,word ptr (fname) ; get terminator offset
	mov	[bx],ax		; save terminator offset

	or	cx,cx		; atexit or onexit ??
	jz	retax		; onexit -- return func addr
	xor	ax,ax		; atexit -- return 0

retax:				; return



cEnd

page

?PLM = 1			;[1] B_OnExit uses PASCAL calling conventions

;***
;B_OnExit - register a user lib termination routine
;far pascal B$OnExit(fpRoutine)
; far *fpRoutine;
;
;Purpose:
;	Register a routine to be called by the runtime when BASIC
;	terminates, or is restarted.  This allows foreign languages
;	a hook for necessary clean up.
;Entry:
;	fpRoutine - far pointer to termination routine
;Exit:
;		DX:AX = 0 if no space left in table (32 entries max).
;Uses:
;	Per Convention.
;Exceptions:
;	None.
;******************************************************************************

cProc	B_OnExit,<PUBLIC,FAR>	;[1] moved here from USRENTRY.ASM
parmD	fpRoutine
cBegin
	cCall	_onexit,<fpRoutine> ;call C onexit() function to do the work
	ADD	SP,4		;clean parms off of the stack
cEnd

?PLM = 0			;[1] return to C calling conventions


sEnd
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\cursor.asm ===
;	TITLE	CURSOR - page and cursor control for MSHERC
;***
;CURSOR
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	Page and cursor control for MSHERC.
;
;Revision History:
;
;******************************************************************************

	include	hgcdefs.inc

code     segment para public 'code'
         assume  cs:code,ds:code

Public	SetActivePage
Public	SetCursor
Public	ReadCursor
Public	GSetCursorType

Extrn	DMC_Save:byte
Extrn	ConfigMode:byte			;[1] FULL or HALF mode

;-------------------------------------------------------------------------------
; 5  SELECTACTIVEPAGE
;	 AL => Page Number
;-------------------------------------------------------------------------------
SetActivePage	proc	near
	mov	ah,DMC_Save		;get saved DMC_Port value
	and	ah,not GraphicsPage1	;clear page bit
	xor	cx,cx			;Assume Graphics Page 0
	and	al,1			;page 0 or 1?
	jz	SetGSeg 		;go if page 0
	dec	al			;[1] set al = 0 in case not FULL mode
	cmp	[ConfigMode],FULL	;[1] make sure FULL mode
	jne	SetGSeg			;[1] brif not, use page 0
	inc	al			;[1] reset al = 1 for page 1
	mov	cx,GraphBufferSize	;no, use page 1
	or	ah,GraphicsPage1	;set page 1
SetGSeg:
	mov	DMC_Save,ah		;Save in Mode Record
	mov	byte ptr es:BIOSPAGE,al ;set page number BIOS variable
	mov	word ptr es:BIOSSTART,cx;set buffer offset BIOS variable

	push	ax
	mov	dx,DMC_Port		;Use the Display Mode Control Port
	mov	al,ah			;output new DMC_Port value
	out	dx,al			;Set DMC Port and turn on screen
	pop	ax

	xor	ah,ah			;set proper cursor loc for this page
	shl	ax,1
	mov	di,ax
	mov	bx,es:BIOSCURS[di]
	ret
SetActivePage	endp

;-------------------------------------------------------------------------------
; 2  SET CURSOR POSITION
;	 BH => Page Number
;	 DH,DL => Row, Column, (0,0) is upper left
;-------------------------------------------------------------------------------
SetCursor	proc	near
	xor	ax,ax
	mov	al,bh
	and	ax,1
	shl	ax,1
	mov	di,ax
	mov	es:BIOSCURS[di],dx
	Ret	;Finished Set Cursor Procedure
SetCursor	endp

;-------------------------------------------------------------------------------
; 3  READ CURSOR POSITION
;	 BH => Page Number
;	 DH,DL <= Row, Column, (0,0) is upper left
;	 CX <= BIOS Cursor Type (N/A for graphics mode)
;-------------------------------------------------------------------------------
ReadCursor	proc	near
;------Put the current cursor position on stack------
	xor	ax,ax
	mov	al,bh
	shl	ax,1
	mov	di,ax
	mov	dx,es:BIOSCURS[di]	;Fetch Cursor Position
	mov	FunData.FunDX,dx	;Save in Stack Parameter Area
	mov	cx,es:BIOSCURSMODE	;Fetch Cursor Start/Stop Scans
	mov	FunData.FunCX,cx	;Save in Stack Parameter Area
	Ret	;Finished Read Cursor Procedure
ReadCursor	endp

;-------------------------------------------------------------------------------
; 1  SET CURSOR TYPE
;	 CX => Cursor type (saved, but no action taken)
;-------------------------------------------------------------------------------
GSetCursorType	proc	near
	mov	word ptr es:BIOSCURSMODE,cx
	Ret	;Finished Set Cursor Type Procedure
GSetCursorType	endp

code     ends
	 end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\crt\version.inc ===
;***
;version.inc - defines current memory model
;
;	Copyright (c) 1987-1988, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file defines the current memory model being used.
;
;*******************************************************************************

?PLM=	0
?WIN=	0

	mem_l	equ	1	;[1] large model
	memL	equ	1	; large model
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\fmakeres.asm ===
;	TITLE	FMAKERES - Command entry point for MSHERC.
;***
;FMAKERES
;
;	Copyright <C> 1987 - 1990, Microsoft Corporation
;
;Purpose:
;	Assumes control upon entry of MSHERC.COM to initialize the driver
;	and install the INT 10 hook.  Then terminate and stay resident.
;
;******************************************************************************

	include	hgcdefs.inc

code            segment para public 'code'
                assume  cs:code,ds:code

Public   Save_Old_Int10h

Extrn   Start_Of_New_Routine:word	;offset of start of HGC INT 10H
Extrn   Old_Int10h_Routine:dword	;old INT 10H address
Extrn	GetHGCStatus:near
Extrn	ConfigMode:byte			;[1] FULL or HALF

Save_Old_Int10h:

	; Parse the command line first, so that we can display
	; help if it is needed.

	cld				;[2] make sure scanning forward
	mov	si,81h			;[2] start at begining of Cmd Line
GetNextByte:				;[2]
	lodsb				;[2] Grab a character
	cmp	al,' '			;[2] is it a space?
	je	GetNextByte		;[2] brif so, this is valid seperator
	cmp	al,9			;[2] is it a tab?
	je	GetNextByte		;[2] brif so, also a valid seperator
	cmp	al,0dh			;[2] cmd line terminator?
	je	Parsed			;[2] brif so, done parsing
	cmp	al,'/'			;[2] is this a switch char?
	jne	GiveHelp		;[2] brif not, give help
	lodsb				;[2] get switch character
	and	al,0DFh 		;[2] convert to upper case
	mov	[ConfigMode],HALF	;[2] assume it is /H
	cmp	al,'H'			;[2] is it /H
	je	SwitchEnd		;[2] brif so, parsed successful

GiveHelp:
	mov	dx, offset HelpMsg	;[2] point to the help message
	jmp	short DontLoadIt	;[2] go print it and exit


	; Skip to the end of the current switch.  We could also
	; make sure that it is /HALF or some subset of it, but
	; that would be inconsistent with previous versions and
	; would probably take more code.

SwitchEnd:				;[2]
	lodsb				;[2] get next character
	cmp	al,0dh			;[2] end of cmd line?
	je	Parsed			;[2] brif so, end of switch
	cmp	al,' '			;[2] seperator character?
	je	GetNextByte		;[2] brif so, end of switch
	cmp	al,9			;[2] seperator character
	je	GetNextByte		;[2] brif so, end of switch
	jmp	short SwitchEnd 	;[2] keep looking for end of switch

Parsed:					;[2]

;first confirm that our INT 10h has not already been loaded
	mov	dl,-1			;DL will not change if no driver
	mov	ah,InquireFuncNo	;test for Hercules INT10 driver
	int	10H
	cmp	dl,-1			;DL returns -1 if no driver
	mov	dx,offset already	;Fetch offset of string
	jne	DontLoadIt		;there is driver, don't load it
	call	GetHGCStatus		;status request
	cmp	dl,-1			;DL returns -1 if no HGC card
	jne	LoadIt			;there is an HGC, go load it
	mov	dx,offset noHGC 	;Fetch offset of string

;announce that int 10h has already been installed
DontLoadIt:
	mov	ah,9			;print string DOS function
	int	21H
	xor	ax,ax			;terminate
	int	20H
	
;------- save the original interrupt routine
LoadIt:
	 push	es
         xor    ax,ax
         mov    es,ax
         mov    bx, es:[INT10HVECTOR_OFFSET]
         mov    word ptr Old_Int10h_Routine,bx
         mov    bx, es:[INT10HVECTOR_SEGMENT]
         mov    word ptr Old_Int10h_Routine[2],bx

;------- point to this interrupt routine

         cli
         mov    word ptr es:[INT10HVECTOR_OFFSET],offset Start_Of_New_Routine
         mov    es:[INT10HVECTOR_SEGMENT],cs
	 sti
	 pop	es

;------ Write the HGC INT 10H Message------
	mov	ah,9
	mov	dx,offset sign_on	;Fetch offset of string
	int	21H			;Write the string

;------- make this routine resident

         mov     dx, offset Save_Old_Int10h
         mov     cl,4
         shr     dx,cl
         inc     dx
         mov     ax,3100h
         int     21h

sign_on db	'Hercules Resident Video Support Routines. Version 1.12'
	db	0DH,0AH,'$'
already db	'Hercules Video Support Routines are already installed.'
	db	0DH,0AH,'$'
noHGC	db	'Hercules Video Card not present.',0DH,0AH
	db	'Hercules Video Support Routines not installed.'
	db	0DH,0AH,'$'
HelpMsg db	'Install MSHERC.COM before running programs with graphics requiring', 0DH, 0AH
	db	'the Hercules graphics card.', 0DH, 0AH, 0DH, 0AH
	db	'MSHERC [/HALF]', 0DH, 0AH
	db	'  /HALF Required when a color adapter is also installed.', 0DH, 0AH, '$'
code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\fcommon.asm ===
;	TITLE	FCOMMON - Common utility routines for MSHERC
;***
;FCOMMON
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	Common utility routines for MSHERC.
;
;******************************************************************************

	include	hgcdefs.inc

code            segment para public 'code'
                assume  cs:code,ds:code

Public	Pause			;Execute a Pause...
Public	MapGraphXYToVideoOffset	;Map graphics coordinates to video offset

Extrn	YTable:word		;Y Offset Table area

;------Pause procedure - uses vsync pulse for timer--------
;Input:	cx = delay count
;
Pause	proc	near
	mov	dx,DS_Port
vson:
	in	al,dx
	or	al,al
	js	vsoff
	jmp	vson
vsoff:
	in	al,dx
	or	al,al
	jns	vsync
	jmp	vsoff
vsync:
	loop	vson
	ret
Pause	endp

;=================================================================
;			MapGraphXYToVideoOffset
;
;	Converts x,y coordinates to graphics buffer offset and
;	bit mask.
;
;	Input:	cx = x coordinate
;		dx = y coordinate
;
;	Output:	cx = graphics buffer offset
;		dx = bit mask
;
;=================================================================
MapGraphXYToVideoOffset	proc	near
	push	si

;fetch the y offset from the table
	mov	si,dx
	shl	si,1
	mov	dx,YTable[si]

;calculate x offset
	push	cx

	shr	cx,1
	shr	cx,1
	shr	cx,1	;x/8
	add	cx,dx	;cx = offset into graphics buffer

;calculate bit mask: 7 - (X MOD 8)
	pop	dx	;Retrieve X coordinate
	and	dx,7	;X MOD 8
	neg	dx	;- (X MOD 8)
	add	dx,7	;7 - (X MOD 8) = bit position

;finished
	pop	si
	Ret
MapGraphXYToVideoOffset	endp

code     ends
         end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\fvars.asm ===
;	TITLE	FVARS - Global data for MSHERC.
;***
;FVARS
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	Global data for MSHERC.
;
;******************************************************************************

	include	hgcdefs.inc

code            segment para public 'code'
                assume  cs:code,ds:code

Extrn	GetVideoState:near
Extrn	SetGraphicsMode:near
Extrn	Null_Function:near
Extrn	SetCursor:near
Extrn	ReadCursor:near
Extrn	SetActivePage:near
Extrn	WriteDot:near
Extrn	ReadDot:near
Extrn	WriteTTY:near
Extrn	GSetCursorType:near,GScrollUp:near,GScrollDown:near
Extrn	GReadAttrChar:near,WriteGrChar:near,GWriteChar:near

Public	Old_Int10h_Routine
Public	GrFuncTable
Public	DMC_Save,HardGraphVals
Public	DeltaCols,DeltaRows
Public	YTable,UnHookFlag
Public	Bit0
Public	LEdge,REdge,BitPos,DstEdgeMasks
Public	ZERO
Public	CharHeight
Public	CharBuff
Public	ScrollLines
Public	ConfigMode		;[1]

;---------INT 10H - Functions Dispatch Table----------

GrFuncTable	dw	offset SetGraphicsMode
		dw	offset GSetCursorType
		dw	offset SetCursor
		dw	offset ReadCursor
		dw	offset Null_Function
		dw	offset SetActivePage
		dw	offset GScrollUp
		dw	offset GScrollDown
		dw	offset GReadAttrChar
		dw	offset WriteGrChar
		dw	offset GWriteChar
		dw	offset Null_Function
		dw	offset WriteDot
		dw	offset ReadDot
		dw	offset WriteTTY
		dw	offset GetVideoState

Old_Int10h_Routine       dd    ?	;Segment:Offset of previous INT 10H
UnHookFlag		db	1	;Set to disable HGC Video Routines
					;Clear to enable HGC Video Routines
ConfigMode		db	FULL	;[1] default to FULL mode (3)

ZERO		dw	0

DMC_Save	db	?	;temp variable for the DMC_Port value

;-------6845 register values for HGC graphics mode-----
HardGraphVals	db	35H,2DH,2EH,7,5BH,2,57H,57H,2,3,0,0,0,0

;-------Temporary variables for the Scrolling Procedures------
DeltaCols	dw	?	;Number of columns in scroll window
DeltaRows	dw	?	;Number of rows in scroll window
ScrollLines	dw	?	;number of scan lines to scroll

;------Table of bit position masks------
Bit0	db	00000001b
Bit1	db	00000010b
Bit2	db	00000100b
Bit3	db	00001000b
Bit4	db	00010000b
Bit5	db	00100000b
Bit6	db	01000000b
Bit7	db	10000000b

;------Table of Left Edge Masks--------
LEdge	db	11111110b
	db	11111100b
	db	11111000b
	db	11110000b
	db	11100000b
	db	11000000b
	db	10000000b
	db	00000000b

;------Table of Right Edge Masks
REdge	db	00000000b
	db	00000001b
	db	00000011b
	db	00000111b
	db	00001111b
	db	00011111b
	db	00111111b
	db	01111111b

;------Table y coordinate offsets for use in graphics mode calculations-----
YTable	label	word
	?ROW = 0	;row number
	REPT	350	;loop for each row (scan line)
	;compute regen buffer offset for this row
	DW	2000H * (?ROW MOD 4) + (?ROW / 4) * 90
	?ROW = ?ROW + 1 ;next row
	ENDM

;------- Graphics Mode Variables ----------
DstEdgeMasks	dw	?	;Dest Left(LSB) and Right(MSB) Edge Masks
BitPos		db	?	;Bit Position in Graphics Byte
CharHeight	db	14
CharBuff	db	14 dup (?)  ;hold buffer for reading graphics character
code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\fstart.asm ===
;	TITLE	FSTART - Entrypoint for INT 10 processing for MSHERC
;***
;FSTART - Entrypoint for INT 10 processing for MSHERC
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;
;	  Hercules Graphics Mode support in Language products
;	  ---------------------------------------------------
;
;Characteristics:
;
;    - Requires Hercules Graphics Card.  The Graphics Card Plus also works,
;      as should the Hercules InColor Card and 100% clones of these.
;
;    - Requires a monochrome monitor.
;
;    - Hercules text mode is SCREEN 0 (BIOS 7) and behaves exactly like
;      the IBM MDPA (mono adapter).
;
;    - Hercules graphics mode is SCREEN 3.  BIOS mode used by the driver
;      is 8.
;
;    - Requires the MSHERC driver to be loaded.  The RUNTIME will report
;      an "illegal function call" if entering SCREEN 3 is attempted when
;      the driver is not loaded.
;
;    - 80x25 text dimensions with a 9x14 character box
;      (bottom 2 scan lines of 25th row are not visible)
;
;    - 720x348 pixel resolution, monochrome.
;
;    - Two pages.  Note:  only one page allowed if second adapter installed.
;
;    - No palette support.
;
;    - All other characteristics identical to CGA SCREEN 2.
;
;    - Mouse support requires user to follow special instructions regarding
;      the Hercules card in the "Microsoft Mouse Programmer's Reference Guide."
;
;    - SHELL'ed programs may not properly recognize the arbitrary BIOS screen
;      mode (8) chosen.  (There is no standard BIOS number for Hercules
;      graphics mode.)
;
;
;MSHERC Driver specification:
;
;-------------------------------------------------------------------------------
; 0  SET MODE
;	 AL => mode #8, bit 7, when set, prevents regen buffer clear.
;    Pass on all but request for Hercules graphics mode.
;    Trap ALL functions (except EGAINT10) while in graphics mode.
;    This function should be ignored if BIOS equipment variable not
;    set for B/W.
;-------------------------------------------------------------------------------
; 1  SET CURSOR TYPE
;	 CX => Cursor type (saved, but no action taken)
;-------------------------------------------------------------------------------
; 2  SET CURSOR POSITION
;	 BH => Page Number
;	 DH,DL => Row, Column, (0,0) is upper left
;-------------------------------------------------------------------------------
; 3  READ CURSOR POSITION
;	 BH => Page Number
;	 DH,DL <= Row, Column, (0,0) is upper left
;	 CX <= BIOS Cursor Type (N/A for graphics mode)
;-------------------------------------------------------------------------------
; 4  READ LIGHT PEN POSITION
;    Ignored.
;-------------------------------------------------------------------------------
; 5  SELECTACTIVEPAGE
;	 AL => Page Number
;-------------------------------------------------------------------------------
; 6  SCROLL ACTIVE PAGE UP
;	 AL => # lines (0 means blank window)
;	 CH,CL => Row, Column of upper left corner
;	 DH,DL => Row, Column of lower right corner
;	 BH => attribute for blanking lines
;-------------------------------------------------------------------------------
; 7  SCROLL ACTIVE PAGE DOWN
;	 AL => # lines (0 means blank window)
;	 CH,CL => Row, Column of upper left corner
;	 DH,DL => Row, Column of lower right corner
;	 BH => attribute for blanking lines
;-------------------------------------------------------------------------------
; 8  READ ATTRIBUTE/CHARACTER AT CURRENT CURSOR POSITION
;	 BH => Display Page
;	 AL <= Character
;-------------------------------------------------------------------------------
; 9  WRITE ATTRIBUTE/CHARACTER AT CURRENT CURSOR POSITION
;	 BH => Display Page
;	 CX => Count of chars to write
;	 AL => Character
;	 BL => Color, bit 7 causes use of XOR operation for write
;-------------------------------------------------------------------------------
; A  WRITE CHARACTER ONLY AT CURRENT CURSOR POSITION
;	 BH => Display Page
;	 CX => Count of chars to write
;	 AL => Character
;-------------------------------------------------------------------------------
; B  SET COLOR PALETTE
;    Ignored.
;-------------------------------------------------------------------------------
; C  WRITE DOT
;	 BH => Display Page
;	 DX => Row
;	 CX => Column
;	 AL => Color, bit 7 causes use of XOR operation for write
;-------------------------------------------------------------------------------
; D  READ DOT
;	 BH => Display Page
;	 DX => Row
;	 CX => Column
;	 AL <= Color
;-------------------------------------------------------------------------------
; E  WRITE TELETYPE TO ACTIVE PAGE
;	 AL => Character
;	 BL => Color
;-------------------------------------------------------------------------------
; F  CURRENT VIDEO STATE
;	 AL <= Current Mode (8)
;	 AH <= # Character Columns
;	 BH <= Active Display Page (currently always 0)
;-------------------------------------------------------------------------------
; EF INQUIRE HGC MSHERC DRIVER
;	 DL => -1
;	 DL <= -1 if driver not loaded
;	     otherwise
;	 DL <= HGC card type:
;		 0: HGC102   Graphics Card
;		 1: HGC112   Graphics Card Plus
;		 2: HGC122   InColor Card
;	 DH <= max. number of graphics pages:
;		 0 if HALF mode
;		 1 if FULL mode
;-------------------------------------------------------------------------------
;ALL OTHERS
;    Ignored.
;-------------------------------------------------------------------------------
;******************************************************************************

	include	hgcdefs.inc

code     segment para public 'code'
         assume  cs:code,ds:code

Extrn	Save_Old_Int10h:near		;TSR loader routine
Extrn	GrFuncTable:word		;jump table ptr for INT 10H functions
Extrn	Old_Int10h_Routine:dword	;Segment:Offset of previous INT 10H
Extrn	UnHookFlag:byte
Extrn	ReturnHGCStatus:near
Extrn	SetGraphicsMode:near
Extrn	ZERO:word

Public	Start_Of_New_Routine
Public	Null_Function

         org    100h

main     proc   far
         jmp    Save_Old_Int10h

Start_Of_New_Routine label word        ;this is the start of the routine

;------- Push registers onto the stack------
	push	bp
	push	es
	push	ds
	push	di
	push	si
	push	dx
	push	cx
	push	bx
	push	ax

;------- set the pointer to point to the parameters on the stack ------
	mov	bp,sp
	push	[bp+16h]		;[2] save flag (interrupt status)
	push	cs			;ds = ours
	pop	ds
	mov	es,ZERO 		;es = BIOS variable segment
	cld

;------- Check for an Inquiry Function Call-------
	cmp	ah,InquireFuncNo	;Is this a driver Inquiry?
	je	DoInquiry		;go if so

;------- Check for a SetMode Function Call-------
	or	ah,ah			;Is this a SetMode Call (0)?
	jz	DoSetMode		;Yes, do it

;------- Check the state of the UnHook Flag-----
LookAtHookFlag:
	cmp	UnHookFlag,0		;Use our routines?
	jnz	Goto_Original_Routine	;No, use IBM BIOS

;------- Look for a supported INT 10H request code ------
	cmp	ah,LowerFuncMax 	;Is the Function in the lower range?
	ja	CheckEGAINT10		;No, look for EGAINT10

Use_This_Routine:			;This jump code handles lookalikes
	mov	di,word ptr FunData.FunAX[1]	;di = offset into address table
	and	di,0FFH
	shl	di,1
	popf				;[2] restore interrupt status

;------- jump to the requested function and then return to calling program
	call	GrFuncTable[di] 	;goto the function handler

Restore_Registers:
	pop	ax
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	ds
	pop	es
	pop	bp
	iret

CheckEGAINT10:
	cmp	ah,0F0H 		;EGAINT10 function?
	jnb	Goto_Original_Routine	;[2]
	pop	ax			;[2] pop flags
	jmp	short Restore_Registers ;[2] Return to calling program

DoInquiry:
	popf				;[2] restore interrupt status
	call	ReturnHGCStatus 	;status request
	jmp	short Restore_Registers ;Return to calling program

;------- Is the request for a Hercules Mode? ------
DoSetMode:
	cmp	al,HGCGrMode		;request for graphics mode wo/clear?
	je	Use_This_Routine	;go if so, set graphics mode
	cmp	al,HGCGrMode+80H	;request for graphics mode w/clear?
	je	Use_This_Routine	;go if so, set graphics mode
	mov	UnHookFlag,1		;Set the unhook flag

Goto_Original_Routine:
	pop	ax			;[2] pop flags
	pop	ax
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	ds
	pop	es
	pop	bp
	jmp	cs:Old_Int10h_Routine	;goto bios routines

Null_Function	proc near
	ret
Null_Function	endp

main     endp
code     ends
         end main
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\gscroll.asm ===
;	TITLE	GSCROLL - Scrolling routines for MSHERC.
;***
;GSCROLL
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	Scroll Up and Down routines for MSHERC.
;
;******************************************************************************

	include	hgcdefs.inc

code            segment para public 'code'
                assume  cs:code,ds:code

Public	GScrollUp
Public	GScrollDown

Extrn	ZERO:word
Extrn	DeltaCols:word		;Number of columns in scroll window
Extrn	DeltaRows:word		;Number of rows in scroll window
Extrn	LEdge:byte,REdge:byte	;Tables containing left and right edge masks
Extrn	MapGraphXYToVideoOffset:near
Extrn	DstEdgeMasks:word
Extrn	CharHeight:byte
Extrn	ScrollLines:word

;-------------------------------------------------------------------------------
; 6  SCROLL ACTIVE PAGE UP
;	 AL => # lines (0 means blank window)
;	 CH,CL => Row, Column of upper left corner
;	 DH,DL => Row, Column of lower right corner
;	 BH => attribute for blanking lines
;-------------------------------------------------------------------------------
GScrollUp	proc	near

	mov	bl,bh
	push	bx			;save blanking attribute

;------Calculate Scroll Area Parameters-------
	sub	dh,ch			;Calculate the delta row count
	inc	dh
	sub	dh,al			;Adjust # of Rows to scroll
	mov	byte ptr DeltaRows,dh	;Save row count
	xor	ah,ah			;Clear ah
	mul	CharHeight		;Calculate # scans to scroll
	mov	ScrollLines,ax
	sub	dl,cl			;Calculate the delta column count
	inc	dl
	xor	dh,dh			;dx = DeltaColumns
	mov	byte ptr DeltaRows[1],dh ;Clear msb of delta rows

	mov	ax,14			;Fetch current font char height
	mov	bx,ax			;Save height value
	mul	byte ptr DeltaRows	;Char Height*Rows = DeltaY
	mov	DeltaRows,ax		;Save window height

	mov	ax,bx			;Retrieve char height
	mul	ch			;Char height*start row = start y
	push	ax			;Save starting y coordinate

;-----Char width is 9, continue calculating scroll parameters-----
	mov	ax,dx			;Save delta cols
	shl	dx,1			;cols*2
	shl	dx,1			;cols*4
	shl	dx,1			;cols*8
	add	dx,ax			;cols*9 = delta x
	mov	DeltaCols,dx		;Save delta x

;-----Calculate starting x,y graphics coordinates-------
	xor	ch,ch			;Clear ch
	mov	ax,cx			;Save starting col
	shl	cx,1			;Start col*2
	shl	cx,1			;Start col*4
	shl	cx,1			;Start col*8
	add	cx,ax			;Start col*9 = starting x coordinate
	mov	ax,cx			;Save starting x coordinate
	pop	dx			;Fetch starting y coordinate
	mov	bx,dx			;Save starting y coordinate

;------Calculate Display Buffer Offset for beginning of scroll----
	Call	MapGraphXYToVideoOffset	;Result: cx = offset dl = bit mask
	mov	di,cx			;di = dest ptr to screen

	mov	dx,bx			;Retrieve starting y coordinate
	add	dx,ScrollLines		;start y + # scans to scroll
					; = y source for scroll
	mov	cx,ax			;Retrieve starting x coordinate
	Call	MapGraphXYToVideoOffset	;Result: cx = offset, dl = bit mask
	mov	si,cx			;si = src ptr to screen
	push	ax			;Save start x

;------Calculate left and right edge masks for scroll------
	xor	bh,bh			;Clear bh
	mov	bl,dl			;bx = bit mask
	mov	cl,LEdge[bx]		;Fetch the left edge mask
	add	ax,DeltaCols		;starting x + deltax
	dec	ax			;- 1 = right edge x coordinate
	mov	dx,ax			;Save right edge x coordinate
	and	ax,7			;X MOD 8
	neg	ax			;- (X MOD 8)
	add	ax,7			;7 - (X MOD 8)
	mov	bx,ax			;bx = index to bit mask
	mov	ch,REdge[bx]		;Fetch the right edge mask
	mov	DstEdgeMasks,cx 	;Save the scrolling dest edge masks

;------Calculate # bytes in inner loop count------
	shr	dx,1
	shr	dx,1
	shr	dx,1			;byte containing right edge x
	pop	ax			;fetch start x
	shr	ax,1
	shr	ax,1
	shr	ax,1			;byte containing start x
	sub	dx,ax
	inc	dx
	or	cl,cl
	jz	NoLeftEdge
	dec	dx
NoLeftEdge:
	or	ch,ch
	jz	NoRightEdge
	dec	dx
NoRightEdge:
	mov	DeltaCols,dx	;Save inner loop cnt
	
;------Finish setting up for Scroll------
	mov	bx,DstEdgeMasks ;Fetch the left and right edge masks
	mov	cx,Scr1_Buf_Seg
	test	byte ptr es:BIOSPAGE,1
	jnz	SUpPg
	mov	cx,Scr0_Buf_Seg
SupPg:
	mov	es,cx		;es = Display Buffer Segment
	mov	ds,cx		;ds = Display Buffer Segment

	assume	ds:nothing

;------Check to see if the entire window is to be blanked-----
	xor	cx,cx		;Clear cx
	add	cx,ScrollLines	;Scroll Count+cx to set flags
	jnz	SGoUp		;Start normal scroll up

;--------Blank the window-----------
	mov	cx,cs:DeltaRows ;Fetch # of rows to blank
	jmp	BlankUp1	;Blank the window

;------Execute the Scroll---------
SGoUp:
	mov	cx,cs:DeltaRows ;Fetch # of Rows to copy
GoUp:
	push	cx		;Save row count
	push	si		;Save src
	push	di		;Save dst

;------Handle the left edge-----
	or	bl,bl		;Is there a left edge to handle?
	jz	GoUpInner	;No, scroll the inner loop

	mov	ah,es:[di]	;Fetch the destination, and load the latches
	and	ah,bl		;Mask out the portion to be modified

	lodsb			;Load the latches with source data
	not	bl		;Create the source edge mask
	and	al,bl		;Mask out the unwanted source data
	not	bl		;Restore the destination edge mask
	or	al,ah		;Combine the source and destination
	stosb			;Save the desired result

;-----Scroll up the inner portion-----
GoUpInner:
	mov	cx,cs:DeltaCols ;Fetch inner loop count
rep	movsb			;Copy one row

;-----Handle the right edge-----
	or	bh,bh		;Is there a right edge to handle?
	jz	AdvUpPtrs	;No, Update the screen pointers

	mov	ah,es:[di]	;Fetch the destination, and load the latches
	and	ah,bh		;Mask out the portion to be modified

	lodsb			;Load the latches with source data
	not	bh		;Create the source edge mask
	and	al,bh		;Mask out the unwanted source data
	not	bh		;Restore the destination edge mask
	or	al,ah		;Combine the source and destination
	stosb			;Save the desired result

;------Update the Screen Pointers-----
AdvUpPtrs:
	pop	di
	pop	si
	add	si,GrNextScan		;Point to next source row
	jns	PntNxtUpDst		;Update dest ptr
	sub	si,NextScanAdjust	;Adjust Src Ptr to screen

PntNxtUpDst:
	add	di,GrNextScan		;Point to next dest row
	jns	DstPtrOnScr		;Dest Ptr updated
	sub	di,NextScanAdjust	;Adjust Dst Ptr to screen

DstPtrOnScr:
	pop	cx		;Retrieve row count
	loop	GoUp		;Copy next row

	mov	cx,ScrollLines	;# of rows to blank
BlankUp1:
	pop	si		;Blanking Character
BlankUp:
	push	cx				;Save row count
	push	di

;------Handle the left edge-----
	or	bl,bl		;Is there a left edge to handle?
	jz	BlkUpInner	;No, blank the inner loop

	mov	ah,es:[di]	;Fetch the destination, and load the latches
	and	ah,bl		;Mask out the portion to be modified

	mov	dx,si		;dl = blanking value
	not	bl		;Convert to Src Edge Mask
	and	dl,bl		;Mask out unwanted portion of blanking byte
	not	bl		;Convert back to Dst Edge Mask

	or	ah,dl		;Combine the source and destination
	xchg	ah,al
	stosb			;Save the desired result

;-----Blank the inner portion-----
BlkUpInner:
	mov	cx,cs:DeltaCols ;Fetch column count
	mov	ax,si		;Fetch blanking value
rep	stosb			;Blank one row

;-----Handle the right edge-----
	or	bh,bh		;Is there a right edge to handle?
	jz	AdvBlkUpPtr	;No, Update the screen pointers

	mov	ah,es:[di]	;Fetch the destination, and load the latches
	and	ah,bh		;Mask out the portion to be modified

	mov	dx,si		;dl = blanking value
	not	bh		;Create the source edge mask
	and	dl,bh		;Mask out the unwanted source data
	not	bh		;Restore the destination edge mask

	or	ah,dl		;Combine the source and destination
	xchg	ah,al
	stosb			;Save the desired result

;------Update the Screen Pointers-----
AdvBlkUpPtr:
	pop	di
	add	di,GrNextScan		;Point to next dest row
	jns	BDstPtrOnScr		;Dest Ptr updated
	sub	di,NextScanAdjust	;Adjust Dst Ptr to screen

BDstPtrOnScr:
	pop	cx		;Retrieve row count
	loop	BlankUp		;Copy next row

	push	cs		;restore DS & ES
	pop	ds

	assume	ds:code

	mov	es,ZERO
	Ret	;Finished Scroll Up
GScrollUp	endp

;-------------------------------------------------------------------------------
; 7  SCROLL ACTIVE PAGE DOWN
;	 AL => # lines (0 means blank window)
;	 CH,CL => Row, Column of upper left corner
;	 DH,DL => Row, Column of lower right corner
;	 BH => attribute for blanking lines
;-------------------------------------------------------------------------------
GScrollDown	proc	near

	mov	bl,bh
	push	bx			;save blanking attribute

;------Calculate Scroll Area Parameters-------
	sub	dh,ch			;Calculate the delta row count
	inc	dh
	add	ch,dh			;Adjust start row to window bottom
	dec	ch
	sub	dh,al			;Adjust # of Rows to scroll
	mov	byte ptr DeltaRows,dh	;Save row count
	xor	ah,ah			;Clear ah
	mul	CharHeight		;Calculate # scans to scroll
	mov	ScrollLines,ax
	sub	dl,cl			;Calculate the delta column count
	inc	dl
	xor	dh,dh			;dx = DeltaColumns
	mov	byte ptr DeltaRows[1],dh ;Clear msb of delta rows

	mov	ax,14			;Fetch current font char height
	mov	bx,ax			;Save height value
	mul	byte ptr DeltaRows	;Char Height*Rows = DeltaY
	mov	DeltaRows,ax		;Save window height

	mov	ax,bx			;Retrieve char height
	mul	ch			;Char height*start row = start y
	add	ax,13			;(start is at bottom of last text row)
	push	ax			;Save starting y coordinate

;-----Char width is 9, continue calculating scroll parameters-----
	mov	ax,dx			;Save delta cols
	shl	dx,1			;cols*2
	shl	dx,1			;cols*4
	shl	dx,1			;cols*8
	add	dx,ax			;cols*9 = delta x
	mov	DeltaCols,dx		;Save delta x

;-----Calculate starting x,y graphics coordinates-------
	xor	ch,ch			;Clear ch
	mov	ax,cx			;Save starting col
	shl	cx,1			;Start col*2
	shl	cx,1			;Start col*4
	shl	cx,1			;Start col*8
	add	cx,ax			;Start col*9 = starting x coordinate
	mov	ax,cx			;Save starting x coordinate
	pop	dx			;Fetch starting y coordinate
	mov	bx,dx			;Save starting y coordinate

;------Calculate Display Buffer Offset for beginning of scroll----
	Call	MapGraphXYToVideoOffset	;Result: cx = offset dl = bit mask
	mov	di,cx			;di = dest ptr to screen

	mov	dx,bx			;Retrieve starting y coordinate
	sub	dx,ScrollLines		;start y - # scans to scroll
	       				;= y source for scroll
	mov	cx,ax			;Retrieve starting x coordinate
	Call	MapGraphXYToVideoOffset	;Result: cx = offset, dl = bit mask
	mov	si,cx			;si = src ptr to screen
	push	ax			;Save start x

;------Calculate left and right edge masks for scroll------
	xor	bh,bh			;Clear bh
	mov	bl,dl			;bx = bit mask
	mov	cl,LEdge[bx]		;Fetch the left edge mask
	add	ax,DeltaCols		;starting x + deltax
	dec	ax			;- 1 = right edge x coordinate
	mov	dx,ax			;Save right edge x coordinate
	and	ax,7			;X MOD 8
	neg	ax			;- (X MOD 8)
	add	ax,7			;7 - (X MOD 8)
	mov	bx,ax			;bx = index to bit mask
	mov	ch,REdge[bx]		;Fetch the right edge mask
	mov	DstEdgeMasks,cx 	;Save the scrolling dest edge masks

;------Calculate # bytes in inner loop count------
	shr	dx,1
	shr	dx,1
	shr	dx,1			;byte containing right edge x
	pop	ax
	shr	ax,1
	shr	ax,1
	shr	ax,1			;byte containing start x

	sub	dx,ax
	inc	dx
	or	cl,cl
	jz	NoLeftEdgeD
	dec	dx
NoLeftEdgeD:
	or	ch,ch
	jz	NoRightEdgeD
	dec	dx
NoRightEdgeD:
	mov	DeltaCols,dx	;Save inner loop cnt
	
;------Finish setting up for Scroll------
	mov	bx,DstEdgeMasks ;Fetch the left and right edge masks
	mov	cx,Scr1_Buf_Seg
	test	byte ptr es:BIOSPAGE,1
	jnz	SDnPg
	mov	cx,Scr0_Buf_Seg
SDnPg:
	mov	es,cx		;es = Display Buffer Segment
	mov	ds,cx		;ds = Display Buffer Segment

	assume	ds:nothing

;------Check to see if the entire window is to be blanked-----
	xor	cx,cx		;Clear cx
	add	cx,ScrollLines	;Scroll Cnt + cx to set flags
	jnz	SGoDown

;--------Blank the window-----------
	mov	cx,cs:DeltaRows ;Fetch # of rows to blank
	jmp	BlankDown1	;Blank the window


;------Execute the Scroll---------
SGoDown:
	mov	cx,cs:DeltaRows ;Fetch # of Rows to copy
GoDown:
	push	cx		;Save row count
	push	si		;Save src
	push	di		;Save dst

;------Handle the left edge-----
	or	bl,bl		;Is there a left edge to handle?
	jz	GoDownInner	;No, scroll the inner loop

	mov	ah,es:[di]	;Fetch the destination, and load the latches
	and	ah,bl		;Mask out the portion to be modified

	lodsb			;Load the latches with source data
	not	bl		;Create the source edge mask
	and	al,bl		;Mask out the unwanted source data
	not	bl		;Restore the destination edge mask
	or	al,ah		;Combine the source and destination
	stosb			;Save the desired result

;-----Scroll down the inner portion-----
GoDownInner:
	mov	cx,cs:DeltaCols ;Fetch inner loop count
rep	movsb			;Copy one row

;-----Handle the right edge-----
	or	bh,bh		;Is there a right edge to handle?
	jz	AdvDwnPtrs	;No, Update the screen pointers

	mov	ah,es:[di]	;Fetch the destination, and load the latches
	and	ah,bh		;Mask out the portion to be modified

	lodsb			;Load the latches with source data
	not	bh		;Create the source edge mask
	and	al,bh		;Mask out the unwanted source data
	not	bh		;Restore the destination edge mask
	or	al,ah		;Combine the source and destination
	stosb			;Save the desired result

;------Update the Screen Pointers-----
AdvDwnPtrs:
	pop	di
	sub	di,GrNextScan
	jns	PntNxtDwnDst		;Update Src ptr
	add	di,NextScanAdjust	;Adjust Dst Ptr to screen

PntNxtDwnDst:
	pop	si
	sub	si,GrNextScan		;Point to next src row
	jns	DstDPtrOnScr		;Src Ptr updated
	add	si,NextScanAdjust	;Adjust Src Ptr to screen

DstDPtrOnScr:
	pop	cx		;Retrieve row count
	loop	GoDown		;Copy next row

	mov	cx,ScrollLines	;# of rows to blank
BlankDown1:
	pop	si		;Blanking Character
BlankDown:
	push	cx				;Save row count
	push	di

;------Handle the left edge-----
	or	bl,bl		;Is there a left edge to handle?
	jz	BlkDwnInner	;No, blank the inner loop

	mov	ah,es:[di]	;Fetch the destination, and load the latches
	and	ah,bl		;Mask out the portion to be modified

	mov	dx,si		;dl = blanking value
	not	bl		;Convert to Src Edge Mask
	and	dl,bl		;Mask out unwanted portion of blanking byte
	not	bl		;Convert back to Dst Edge Mask

	or	ah,dl		;Combine the source and destination
	xchg	ah,al
	stosb			;Save the desired result

;-----Blank the inner portion-----
BlkDwnInner:
	mov	cx,cs:DeltaCols ;Fetch column count
	mov	ax,si		;Fetch blanking value
rep	stosb			;Blank one row

;-----Handle the right edge-----
	or	bh,bh		;Is there a right edge to handle?
	jz	AdvBlkDwnPtr	;No, Update the screen pointers

	mov	ah,es:[di]	;Fetch the destination, and load the latches
	and	ah,bh		;Mask out the portion to be modified

	mov	dx,si		;dl = blanking value
	not	bh		;Create the source edge mask
	and	dl,bh		;Mask out the unwanted source data
	not	bh		;Restore the destination edge mask

	or	ah,dl		;Combine the source and destination
	xchg	ah,al
	stosb			;Save the desired result

;------Update the Screen Pointers-----
AdvBlkDwnPtr:
	pop	di
	sub	di,GrNextScan		;Point to next dest row
	jns	BDstDwnPtrOnScr		;Dest Ptr updated
	add	di,NextScanAdjust	;Adjust Dst Ptr to screen

BDstDwnPtrOnScr:
	pop	cx		;Retrieve row count
	loop	BlankDown	;Copy next row

	push	cs		;restore DS & ES
	pop	ds

	assume	ds:code

	mov	es,ZERO
	Ret	;Finished Scroll Down
GScrollDown	endp

code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\gwrite.asm ===
;	TITLE	GWRITE - Character writing for MSHERC.
;***
;GWRITE
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	Paint characters onto the screen for text writes in graphics mode.
;
;******************************************************************************

	include	hgcdefs.inc

code	segment	para	public	'code'

Public	WriteGrChar

Extrn	ZERO:word
Extrn	MapGraphXYToVideoOffset:near ;Graph x,y coord conversion to video off
Extrn	DeltaCols:word
Extrn	BitPos:byte
Extrn	LEdge:byte,REdge:byte,DstEdgeMasks:word
Extrn	HFont:byte
Extrn	CharHeight:byte

assume	cs:code,ds:code

;-------------------------------------------------------------------------------
; 9  WRITE ATTRIBUTE/CHARACTER AT CURRENT CURSOR POSITION
;	 BH => Display Page
;	 CX => Count of chars to write
;	 AL => Character
;	 BL => Color, bit 7 causes use of XOR operation for write
;-------------------------------------------------------------------------------
WriteGrChar	proc	near
;-----If char count is 0, then terminate procedure-----
	or	cx,cx		;Null char count?
	jnz	GoGWrChar	;No, write chars
	jmp	NoGWrChar	;Yes, exit procedure

GoGWrChar:
	mov	ah,bl		;AH = attribute, AL = character
	push	ax		;save 'em

	mov	dx,Scr0_Buf_Seg		;Assume graphics page 0
	test	bh,1			;Are we on page 1?
	jz	SetVidPtr		;No, pnt to page 0
	mov	dx,Scr1_Buf_Seg		;Yes, pnt to page 1
SetVidPtr:

;------ Calculate the graphic y coordinate ------
	mov	bl,bh		;bx = page number
	xor	bh,bh
	shl	bx,1
	mov	bx,es:BIOSCURS[bx]		;Fetch start coords.
	mov	al,bh				;ax = row coordinate
	xor	ah,ah
	mul	CharHeight			;Calculate y coordinate
	push	ax				;Save y coordinate

	mov	es,dx			;Point es to Video Buffer Segment

;------ Character width is 9 bits, finish calculating write parameters----
	xor	bh,bh		;bx = column coordinate
	mov	ax,bx
	shl	bx,1		;cols*2
	shl	bx,1		;cols*4
	shl	bx,1		;cols*8
	add	bx,ax		;cols*9 = start x coordinate

	mov	dx,cx		;dx = char count
	shl	cx,1		;cnt*2
	shl	cx,1		;cnt*4
	shl	cx,1		;cnt*8
	add	dx,cx		;dx = cnt*9 = width in bits
	mov	cx,dx		;cx = width in bits
	add	cx,bx		;width + start x - 1 = stop x
	dec	cx		;cx = stop x

	mov	ax,bx		;ax = start x
	shr	ax,1		;ax = start x
	shr	ax,1
	shr	ax,1
	mov	dx,cx		;dx = stop x
	shr	dx,1		;dx = stop byte
	shr	dx,1
	shr	dx,1
	sub	dx,ax		;dx = number of bytes effected
	inc	dx		;	(both whole and partial)
	mov	DeltaCols,dx	;save it

;------ Calculate the right edge mask for the background loop----
	xchg	bx,cx		;bx = stop x, cx = start x
	and	bx,7		;bx = x mod 8
	neg	bx		;bx = - x mod 8
	add	bx,7		;bx = 7 - x mod 8 = bit position
	mov	al,REdge[bx]	;Fetch the right edge mask
	mov	byte ptr DstEdgeMasks[1],al	;Save the right edge mask

;------ Calculate the video buffer offset ------
	pop	dx			;Retrieve the y coordinate
	Call	MapGraphXYToVideoOffset	;Calculate buffer offset
	mov	di,cx  			;Pnt di to video offset
	mov	bx,dx			;bx = bit position
	mov	BitPos,bl		;save the start bit position
	mov	al,LEdge[bx]		;Fetch the left edge mask
	mov	byte ptr DstEdgeMasks,al ;Save the edge mask

;------- Set up for the character/attribute write------
	mov	bx,DstEdgeMasks 	;bx = left and right edge masks
	or	bl,bl
	jz	NoLeftEdge
	dec	DeltaCols		;adjust for whole byte count
NoLeftEdge:
	or	bh,bh
	jz	NoRightEdge
	dec	DeltaCols		;adjust for whole byte count
NoRightEdge:
	pop	ax			;refresh char/attr
	push	ax

;------ Clear out the char fill area with the background AND loop ------
	xor	ch,ch
	mov	cl,14			;Fetch font char height
	push	cx			;Save the # scan rows for fore loop

	push	di			;Save 1st scan beg ptr
	test	ah,80H			;test attr for XOR request
	jnz	DoXor9
	xor	al,al			;Use 0 as background
BackLp:
	push	cx			;Save scan row count
	mov	cx,DeltaCols		;Fetch the whole byte count
	mov	dx,di			;Save screen ptr

	or	bl,bl			;Is there a left edge to handle?
	jz	BackMid 		;No, do whole bytes

	and	es:[di],bl		;AND the left edge
	inc	di
BackMid:
    rep stosb				;Clear whole bytes

	or	bh,bh			;Is there a right edge to handle?
	jz	BackNext		;No, do another line
	and	es:[di],bh		;AND the right edge
BackNext:
	mov	di,dx			;Fetch beginning of row ptr
	add	di,GrNextScan		;Inc to next scan
	jns	FetchRCnt		;Go to check for more rows
	sub	di,NextScanAdjust	;Pnt di back on screen
FetchRCnt:
	pop	cx			;Fetch scan row count
	loop	BackLp			;If more, clear next scan

DoXor9:

;----- Now OR in the foreground portion of the character -----
	mov	dx,DstEdgeMasks 	;bx = left and right edge masks
	or	dl,dl
	jz	NoLeftOr
	inc	DeltaCols		;adjust for whole + first byte count
NoLeftOr:
	or	dh,dh
	jz	NoRightOr
	not	dh
NoRightOr:

	pop	di			;Retrieve beg. screen ptr
	pop	cx			;Retrieve scan row count
	mov	bl,BitPos		;Fetch the starting bit position
	inc	bl			;plus 1 for shift count
	pop	ax			;al = character code
	xor	dl,dl			;DL=0 means not block graphic char
	cmp	al,179			;such chars are in range (179-223)
	jbe	NotBlock		;go if not
	cmp	al,223
	ja	NotBlock		;go if not
	inc	dl			;DL=1 means it is block graphic char
NotBlock:
	mul	cl			;scan cnt*char code=char offset
	mov	si,offset HFont 	;Fetch the graphics font ptr
	add	si,ax			;Point to specified character

ForeLp:
	push	cx			;Save the scan row count
	lodsb				;Fetch the current font char byte
	or	al,al			;save time for empty scan lines
	jz	NullByte
	mov	ah,dl			;AH=1 for block graphic chars
	and	ah,al			;copy rightmost bit, if so
	ror	ah,1			;move to where it will rotate in right
	mov	cl,bl
	rol	ax,cl			;Rotate the char byte into position
	push	di			;Save beg. of scan row ptr
	mov	cx,DeltaCols		;Fetch whole byte count
ForeInLp:
	xor	es:[di],ah		;Or in high byte of fore char
	mov	bh,al
	shr	ax,1			;Rotate char to next bit position
	or	ah,bh
	inc	di			;Point to next byte
	loop	ForeInLp		;If more chars, continue
	and	ah,dh
	xor	es:[di],ah		;Or in high byte of fore char

	pop	di			;Retrieve beg of scan ptr
NullByte:
	add	di,GrNextScan		;Pnt to next scan line
	jns	GetRCnt			;Ptr on screen, no extra adjust
	sub	di,NextScanAdjust	;Pnt di back on screen
GetRCnt:
	pop	cx			;Fetch remaining row count
	loop	ForeLp			;Continue if more rows

	push	cs			;restore ES & DS
	pop	ds
	mov	es,ZERO
NoGWrChar:
	Ret	;Finished Write A Character/Attribute
WriteGrChar	endp

code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\rwchar.asm ===
;	TITLE	RWCHAR - Character read/write for MSHERC.
;***
;RWCHAR
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	Single character read and write.
;
;******************************************************************************

	include	hgcdefs.inc

code            segment para public 'code'
                assume  cs:code,ds:code

Public	GReadAttrChar
Public	GWriteChar

Extrn	WriteGrChar:near
Extrn	MapGraphXYToVideoOffset:near
Extrn	CharBuff:byte
Extrn	HFont:byte
Extrn	ZERO:word
Extrn	CharHeight:byte

;-------------------------------------------------------------------------------
; A  WRITE CHARACTER ONLY AT CURRENT CURSOR POSITION
;	 BH => Display Page
;	 CX => Count of chars to write
;	 AL => Character
;-------------------------------------------------------------------------------
GWriteChar	proc	near
	mov	bh,1		;use attribute 1??
;-----Write the Graphics Character to the screen-----
	jmp	WriteGrChar
GWriteChar	endp

;-------------------------------------------------------------------------------
; 8  READ ATTRIBUTE/CHARACTER AT CURRENT CURSOR POSITION
;	 BH => Display Page
;	 AL <= Character
;-------------------------------------------------------------------------------
GReadAttrChar	proc	near
;------ Calculate the graphic y coordinate ------
	mov	bl,bh				;bx = page number
	xor	bh,bh
	mov	cx,Scr1_Buf_Seg 		;assume page 1
	or	bl,bl
	jnz	RdPg1				;go if was page 1
	mov	cx,Scr0_Buf_Seg 		;use page 0
	push	cx				;save page # segment for later
RdPg1:
	shl	bx,1
	mov	bx,es:BIOSCURS[bx]		;Fetch start coords.
	mov	al,bh				;ax = row coordinate
	xor	ah,ah
	mul	CharHeight			;Calculate y coordinate
	push	ax				;Save y coordinate

;------ Character width is 9 bits ----
	xor	bh,bh		;bx = column coordinate
	mov	cx,bx
	shl	bx,1		;cols*2
	shl	bx,1		;cols*4
	shl	bx,1		;cols*8
	add	cx,bx		;cols*9 = start x coordinate

;------ Calculate the video buffer offset ------
	pop	dx			;Retrieve the y coordinate
	Call	MapGraphXYToVideoOffset	;Calculate buffer offset
	mov	di,cx			;Pnt di to video offset
	mov	bl,dl			;bl = bit position
	neg	bl			;bl = - x mod 8
	add	bl,7			;bl = 7 - x mod 8 = bit position

	pop	es			;set ES for specified page
	xor	cx,cx
	mov	cl,14			;cx = char height
	mov	si,offset CharBuff	;place to store graphics char
	mov	dx,1			;DH=accumulate non-0 9th bits
					;DL=accumulate equal 9th bits
RdCharLp:
	mov	ah,es:[di]		;get first byte of char
	mov	al,es:[di+1]		;  and second
	xchg	cx,bx
	sal	ax,cl			;left justify both bytes in word
	xchg	cx,bx
	mov	[si],ah 		;save first byte for comparison
	inc	si

	rol	al,1			;move 9th bit to least sig bit
	or	dh,al			;non-0 9th bits
	xor	al,ah			;AL=0 where AL==AH
	not	al			;AL=1 where AL==AH
	and	dl,al			;DL stays 1 if 9th bit == 8th bit

	add	di,GrNextScan		;Inc to next scan
	jns	ScanOk			;Go to check for more rows
	sub	di,NextScanAdjust	;Pnt di back on screen
ScanOk:
	loop	RdCharLp		;read entire character

	push	dx			;save 9th bit info
;	setup for font table compare
	xor	cx,cx
	mov	cl,14				;(cx) = font size
	mov	dx,cx				;(dx) = font size copy
	push	ds
	pop	es
	mov	di,offset HFont 		;(es:di) = @font table
	add	di,cx				;skip <NULL> in font table
	mov	ax,1				;(ax) = ascii of current char

;	find match loop
MatchLp:
	push	di				;save current position
	mov	si,offset CharBuff		;(ds:si) = data buffer
   repe cmpsb					;cmp buffer with current char
	pop	di
	jz	Found				;if match, exit loop
	inc	ax				;if not, advance ascii count
	mov	cx,dx				;restore font size
	add	di,cx				;advance to next font entry
	cmp	ax,0ffh 			;at end of font table?
	jbe	MatchLp 			; if not, loop
	xor	ax,ax				;if no match, ascii=0
Found:
	pop	dx				;recover 9th bit info
	cmp	al,179			;such chars are in range (179-223)
	jbe	NotBlock		;go if not
	cmp	al,223
	ja	NotBlock		;go if not
	or	dl,dl			;DL=1 if all 9th bits == 8th bits
	jnz	RdDun			;go if so, OK block character
RdBad:
	xor	ax,ax			;invalid block character
	jmp	short RdDun
NotBlock:
	and	dh,1			;any non-zero 9th bits
	jnz	RdBad			;go if so, not good for normal char
RdDun:
	mov	FunData.FunAX,AX
	mov	es,ZERO
	Ret	;Finished Read A Character/Attribute
GReadAttrChar	endp

code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\stanfnt.asm ===
;	TITLE	STANFNT - 9x14 character font for MSHERC.
;***
;STANFNT
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	The 9x14 character is produced from this 8x14 font.  For
;	line-drawing characters, the 9th column is a replication of
;	the 8th.  Otherwise, the 9th column is blank.
;
;******************************************************************************

code	segment	para	public	'code'
assume	cs:code,ds:code

Public	HFont

HFont	db	00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,7EH,81H,0A5H,81H,81H,0BDH,99H,81H,7EH,00H,00H,00H
	db	00H,00H,7EH,0FFH,0DBH,0FFH,0FFH,0C3H,0E7H,0FFH,7EH,00H,00H,00H
	db	00H,00H,00H,36H,7FH,7FH,7FH,7FH,3EH,1CH,08H,00H,00H,00H
	db	00H,00H,00H,08H,1CH,3EH,7FH,3EH,1CH,08H,00H,00H,00H,00H
	db	00H,18H,3CH,3CH,0E7H,0E7H,0E7H,3CH,18H,18H,3CH,00H,00H,00H
	db	00H,00H,18H,3CH,7EH,0FFH,0FFH,7EH,18H,18H,3CH,00H,00H,00H
	db	00H,00H,00H,00H,00H,18H,3CH,3CH,18H,00H,00H,00H,00H,00H
	db	0FFH,0FFH,0FFH,0FFH,0FFH,0E7H,0C3H,81H,0E7H,0FFH,0FFH,0FFH,0FFH,0FFH
	db	00H,00H,00H,00H,3CH,66H,42H,42H,66H,3CH,00H,00H,00H,00H
	db	0FFH,0FFH,0FFH,0FFH,0C3H,99H,0BDH,0BDH,99H,0C3H,0FFH,0FFH,0FFH,0FFH
	db	00H,00H,0FH,07H,0DH,19H,3CH,66H,66H,66H,3CH,00H,00H,00H
	db	00H,00H,3CH,66H,66H,66H,3CH,18H,7EH,18H,18H,00H,00H,00H
	db	00H,00H,3FH,33H,3FH,30H,30H,30H,70H,0F0H,0E0H,00H,00H,00H
	db	00H,00H,7FH,63H,7FH,63H,63H,63H,67H,0E7H,0E6H,60H,00H,00H
	db	00H,00H,18H,18H,0DBH,3CH,0E7H,3CH,0DBH,18H,18H,00H,00H,00H
	db	00H,00H,40H,60H,70H,7CH,7FH,7CH,70H,60H,40H,00H,00H,00H
	db	00H,00H,01H,03H,07H,1FH,7FH,1FH,07H,03H,01H,00H,00H,00H
	db	00H,00H,18H,3CH,7EH,18H,18H,18H,7EH,3CH,18H,00H,00H,00H
	db	00H,00H,33H,33H,33H,33H,33H,33H,00H,33H,33H,00H,00H,00H
	db	00H,00H,7FH,0DBH,0DBH,0DBH,7BH,1BH,1BH,1BH,1BH,00H,00H,00H
	db	00H,3EH,63H,30H,1CH,36H,63H,63H,36H,1CH,06H,63H,3EH,00H
	db	00H,00H,00H,00H,00H,00H,00H,00H,7FH,7FH,7FH,00H,00H,00H
	db	00H,00H,18H,3CH,7EH,18H,18H,18H,7EH,3CH,18H,00H,00H,00H
	db	00H,18H,3CH,7EH,18H,18H,18H,18H,18H,18H,00H,00H,00H,00H
	db	00H,00H,18H,18H,18H,18H,18H,18H,7EH,3CH,18H,00H,00H,00H
	db	00H,00H,00H,00H,0CH,06H,0FFH,06H,0CH,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,18H,30H,7FH,30H,18H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,60H,60H,60H,7FH,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,24H,66H,0FFH,66H,24H,00H,00H,00H,00H,00H
	db	00H,00H,00H,08H,1CH,1CH,3EH,3EH,7FH,7FH,00H,00H,00H,00H
	db	00H,00H,00H,7FH,7FH,3EH,3EH,1CH,1CH,08H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,18H,3CH,3CH,3CH,18H,18H,00H,18H,18H,00H,00H,00H
	db	00H,63H,63H,63H,22H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,36H,36H,7FH,36H,36H,36H,7FH,36H,36H,00H,00H,00H
	db	0CH,0CH,3EH,63H,61H,60H,3EH,03H,43H,63H,3EH,0CH,0CH,00H
	db	00H,00H,00H,00H,61H,63H,06H,0CH,18H,33H,63H,00H,00H,00H
	db	00H,00H,1CH,36H,36H,1CH,3BH,6EH,66H,66H,3BH,00H,00H,00H
	db	00H,30H,30H,30H,60H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,0CH,18H,30H,30H,30H,30H,30H,18H,0CH,00H,00H,00H
	db	00H,00H,18H,0CH,06H,06H,06H,06H,06H,0CH,18H,00H,00H,00H
	db	00H,00H,00H,00H,66H,3CH,0FFH,3CH,66H,00H,00H,00H,00H,00H
	db	00H,00H,00H,18H,18H,18H,0FFH,18H,18H,18H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,00H,00H,18H,18H,18H,30H,00H,00H
	db	00H,00H,00H,00H,00H,00H,00H,0FFH,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,00H,00H,00H,18H,18H,00H,00H,00H
	db	00H,00H,01H,03H,06H,0CH,18H,30H,60H,0C0H,80H,00H,00H,00H
	db	00H,00H,3EH,63H,67H,6FH,7BH,73H,63H,63H,3EH,00H,00H,00H
	db	00H,00H,0CH,1CH,3CH,0CH,0CH,0CH,0CH,0CH,3FH,00H,00H,00H
	db	00H,00H,3EH,63H,03H,06H,0CH,18H,30H,63H,7FH,00H,00H,00H
	db	00H,00H,3EH,63H,03H,03H,1EH,03H,03H,63H,3EH,00H,00H,00H
	db	00H,00H,06H,0EH,1EH,36H,66H,7FH,06H,06H,0FH,00H,00H,00H
	db	00H,00H,7FH,60H,60H,60H,7EH,03H,03H,63H,3EH,00H,00H,00H
	db	00H,00H,1CH,30H,60H,60H,7EH,63H,63H,63H,3EH,00H,00H,00H
	db	00H,00H,7FH,63H,03H,06H,0CH,18H,18H,18H,18H,00H,00H,00H
	db	00H,00H,3EH,63H,63H,63H,3EH,63H,63H,63H,3EH,00H,00H,00H
	db	00H,00H,3EH,63H,63H,63H,3FH,03H,03H,06H,3CH,00H,00H,00H
	db	00H,00H,00H,18H,18H,00H,00H,18H,18H,00H,00H,00H,00H,00H
	db	00H,00H,00H,18H,18H,00H,00H,00H,18H,18H,30H,00H,00H,00H
	db	00H,00H,06H,0CH,18H,30H,60H,30H,18H,0CH,06H,00H,00H,00H
	db	00H,00H,00H,00H,00H,7EH,00H,00H,7EH,00H,00H,00H,00H,00H
	db	00H,00H,60H,30H,18H,0CH,06H,0CH,18H,30H,60H,00H,00H,00H
	db	00H,00H,3EH,63H,63H,06H,0CH,0CH,00H,0CH,0CH,00H,00H,00H
	db	00H,00H,3EH,63H,63H,6FH,6FH,6FH,6EH,60H,3EH,00H,00H,00H
	db	00H,00H,08H,1CH,36H,63H,63H,7FH,63H,63H,63H,00H,00H,00H
	db	00H,00H,7EH,33H,33H,33H,3EH,33H,33H,33H,7EH,00H,00H,00H
	db	00H,00H,1EH,33H,61H,60H,60H,60H,61H,33H,1EH,00H,00H,00H
	db	00H,00H,7CH,36H,33H,33H,33H,33H,33H,36H,7CH,00H,00H,00H
	db	00H,00H,7FH,33H,31H,34H,3CH,34H,31H,33H,7FH,00H,00H,00H
	db	00H,00H,7FH,33H,31H,34H,3CH,34H,30H,30H,78H,00H,00H,00H
	db	00H,00H,1EH,33H,61H,60H,60H,6FH,63H,33H,1DH,00H,00H,00H
	db	00H,00H,63H,63H,63H,63H,7FH,63H,63H,63H,63H,00H,00H,00H
	db	00H,00H,3CH,18H,18H,18H,18H,18H,18H,18H,3CH,00H,00H,00H
	db	00H,00H,0FH,06H,06H,06H,06H,06H,66H,66H,3CH,00H,00H,00H
	db	00H,00H,73H,33H,36H,36H,3CH,36H,36H,33H,73H,00H,00H,00H
	db	00H,00H,78H,30H,30H,30H,30H,30H,31H,33H,7FH,00H,00H,00H
	db	00H,00H,0C3H,0E7H,0FFH,0DBH,0C3H,0C3H,0C3H,0C3H,0C3H,00H,00H,00H
	db	00H,00H,63H,73H,7BH,7FH,6FH,67H,63H,63H,63H,00H,00H,00H
	db	00H,00H,1CH,36H,63H,63H,63H,63H,63H,36H,1CH,00H,00H,00H
	db	00H,00H,7EH,33H,33H,33H,3EH,30H,30H,30H,78H,00H,00H,00H
	db	00H,00H,3EH,63H,63H,63H,63H,6BH,6FH,3EH,06H,07H,00H,00H
	db	00H,00H,7EH,33H,33H,33H,3EH,36H,33H,33H,7BH,00H,00H,00H
	db	00H,00H,3EH,63H,63H,30H,1CH,06H,63H,63H,3EH,00H,00H,00H
	db	00H,00H,0FFH,0DBH,99H,18H,18H,18H,18H,18H,3CH,00H,00H,00H
	db	00H,00H,63H,63H,63H,63H,63H,63H,63H,63H,3EH,00H,00H,00H
	db	00H,00H,0C3H,0C3H,0C3H,0C3H,0C3H,0C3H,66H,3CH,18H,00H,00H,00H
	db	00H,00H,0C3H,0C3H,0C3H,0C3H,0C3H,0DBH,0FFH,66H,66H,00H,00H,00H
	db	00H,00H,0C3H,0C3H,66H,3CH,18H,3CH,66H,0C3H,0C3H,00H,00H,00H
	db	00H,00H,0C3H,0C3H,0C3H,66H,3CH,18H,18H,18H,3CH,00H,00H,00H
	db	00H,00H,0FFH,0C3H,86H,0CH,18H,30H,61H,0C3H,0FFH,00H,00H,00H
	db	00H,00H,3CH,30H,30H,30H,30H,30H,30H,30H,3CH,00H,00H,00H
	db	00H,00H,40H,60H,70H,38H,1CH,0EH,07H,03H,01H,00H,00H,00H
	db	00H,00H,3CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,3CH,00H,00H,00H
	db	08H,1CH,36H,63H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,0FFH,00H,00H
	db	18H,18H,0CH,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,3CH,06H,3EH,66H,66H,3BH,00H,00H,00H
	db	00H,00H,70H,30H,30H,3CH,36H,33H,33H,33H,6EH,00H,00H,00H
	db	00H,00H,00H,00H,00H,3EH,63H,60H,60H,63H,3EH,00H,00H,00H
	db	00H,00H,0EH,06H,06H,1EH,36H,66H,66H,66H,3BH,00H,00H,00H
	db	00H,00H,00H,00H,00H,3EH,63H,7FH,60H,63H,3EH,00H,00H,00H
	db	00H,00H,1CH,36H,32H,30H,7CH,30H,30H,30H,78H,00H,00H,00H
	db	00H,00H,00H,00H,00H,3BH,66H,66H,66H,3EH,06H,66H,3CH,00H
	db	00H,00H,70H,30H,30H,36H,3BH,33H,33H,33H,73H,00H,00H,00H
	db	00H,00H,0CH,0CH,00H,1CH,0CH,0CH,0CH,0CH,1EH,00H,00H,00H
	db	00H,00H,06H,06H,00H,0EH,06H,06H,06H,66H,66H,3CH,00H,00H
	db	00H,00H,70H,30H,30H,33H,36H,3CH,36H,33H,73H,00H,00H,00H
	db	00H,00H,1CH,0CH,0CH,0CH,0CH,0CH,0CH,0CH,1EH,00H,00H,00H
	db	00H,00H,00H,00H,00H,0E6H,0DBH,0DBH,0DBH,0DBH,0DBH,00H,00H,00H
	db	00H,00H,00H,00H,00H,6EH,33H,33H,33H,33H,33H,00H,00H,00H
	db	00H,00H,00H,00H,00H,3EH,63H,63H,63H,63H,3EH,00H,00H,00H
	db	00H,00H,00H,00H,00H,6EH,33H,33H,33H,3EH,30H,30H,78H,00H
	db	00H,00H,00H,00H,00H,3BH,66H,66H,66H,3EH,06H,06H,0FH,00H
	db	00H,00H,00H,00H,00H,6EH,33H,33H,30H,30H,78H,00H,00H,00H
	db	00H,00H,00H,00H,00H,3EH,63H,38H,0EH,63H,3EH,00H,00H,00H
	db	00H,00H,08H,18H,18H,7EH,18H,18H,18H,1BH,0EH,00H,00H,00H
	db	00H,00H,00H,00H,00H,66H,66H,66H,66H,66H,3BH,00H,00H,00H
	db	00H,00H,00H,00H,00H,0C3H,0C3H,0C3H,66H,3CH,18H,00H,00H,00H
	db	00H,00H,00H,00H,00H,0C3H,0C3H,0DBH,0DBH,7EH,66H,00H,00H,00H
	db	00H,00H,00H,00H,00H,63H,36H,1CH,1CH,36H,63H,00H,00H,00H
	db	00H,00H,00H,00H,00H,63H,63H,63H,63H,3FH,03H,06H,3CH,00H
	db	00H,00H,00H,00H,00H,7FH,66H,0CH,18H,33H,7FH,00H,00H,00H
	db	00H,00H,0EH,18H,18H,18H,70H,18H,18H,18H,0EH,00H,00H,00H
	db	00H,00H,18H,18H,18H,18H,00H,18H,18H,18H,18H,00H,00H,00H
	db	00H,00H,70H,18H,18H,18H,1CH,18H,18H,18H,70H,00H,00H,00H
	db	00H,00H,3BH,6EH,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,08H,1CH,36H,63H,63H,63H,7FH,00H,00H
	db	00H,00H,1EH,33H,61H,60H,60H,61H,63H,3EH,06H,03H,3EH,00H
	db	00H,00H,66H,66H,00H,66H,66H,66H,66H,66H,3BH,00H,00H,00H
	db	00H,06H,0CH,18H,00H,3EH,63H,7FH,60H,63H,3EH,00H,00H,00H
	db	00H,08H,1CH,36H,00H,3CH,06H,3EH,66H,66H,3BH,00H,00H,00H
	db	00H,00H,66H,66H,00H,3CH,06H,3EH,66H,66H,3BH,00H,00H,00H
	db	00H,30H,18H,0CH,00H,3CH,06H,3EH,66H,66H,3BH,00H,00H,00H
	db	00H,1CH,36H,1CH,00H,3CH,06H,3EH,66H,66H,3BH,00H,00H,00H
	db	00H,00H,00H,00H,00H,3CH,66H,60H,66H,3CH,06H,3CH,00H,00H
	db	00H,08H,1CH,36H,00H,3EH,63H,7FH,60H,63H,3EH,00H,00H,00H
	db	00H,00H,66H,66H,00H,3EH,63H,7FH,60H,63H,3EH,00H,00H,00H
	db	00H,30H,18H,0CH,00H,3EH,63H,7FH,60H,63H,3EH,00H,00H,00H
	db	00H,00H,36H,36H,00H,1CH,0CH,0CH,0CH,0CH,1EH,00H,00H,00H
	db	00H,18H,3CH,66H,00H,38H,18H,18H,18H,18H,3CH,00H,00H,00H
	db	00H,60H,30H,18H,00H,38H,18H,18H,18H,18H,3CH,00H,00H,00H
	db	00H,63H,63H,08H,1CH,36H,63H,63H,7FH,63H,63H,00H,00H,00H
	db	1CH,36H,1CH,00H,1CH,36H,63H,63H,7FH,63H,63H,00H,00H,00H
	db	0CH,18H,30H,00H,7FH,33H,30H,3EH,30H,33H,7FH,00H,00H,00H
	db	00H,00H,00H,00H,00H,6EH,3BH,1BH,7EH,0D8H,0DCH,77H,00H,00H
	db	00H,00H,1FH,36H,66H,66H,7FH,66H,66H,66H,67H,00H,00H,00H
	db	00H,08H,1CH,36H,00H,3EH,63H,63H,63H,63H,3EH,00H,00H,00H
	db	00H,00H,63H,63H,00H,3EH,63H,63H,63H,63H,3EH,00H,00H,00H
	db	00H,30H,18H,0CH,00H,3EH,63H,63H,63H,63H,3EH,00H,00H,00H
	db	00H,18H,3CH,66H,00H,66H,66H,66H,66H,66H,3BH,00H,00H,00H
	db	00H,30H,18H,0CH,00H,66H,66H,66H,66H,66H,3BH,00H,00H,00H
	db	00H,00H,63H,63H,00H,63H,63H,63H,63H,3FH,03H,06H,3CH,00H
	db	00H,63H,63H,1CH,36H,63H,63H,63H,63H,36H,1CH,00H,00H,00H
	db	00H,63H,63H,00H,63H,63H,63H,63H,63H,63H,3EH,00H,00H,00H
	db	00H,18H,18H,7EH,0C3H,0C0H,0C0H,0C3H,7EH,18H,18H,00H,00H,00H
	db	00H,1CH,36H,30H,30H,78H,30H,30H,30H,73H,7EH,00H,00H,00H
	db	00H,00H,0C3H,66H,3CH,18H,0FFH,18H,0FFH,18H,18H,00H,00H,00H
	db	00H,0FCH,66H,66H,7CH,62H,66H,6FH,66H,66H,0F3H,00H,00H,00H
	db	00H,0EH,1BH,18H,18H,18H,7EH,18H,18H,18H,18H,0D8H,70H,00H
	db	00H,0CH,18H,30H,00H,3CH,06H,3EH,66H,66H,3BH,00H,00H,00H
	db	00H,0CH,18H,30H,00H,38H,18H,18H,18H,18H,3CH,00H,00H,00H
	db	00H,0CH,18H,30H,00H,3EH,63H,63H,63H,63H,3EH,00H,00H,00H
	db	00H,0CH,18H,30H,00H,66H,66H,66H,66H,66H,3BH,00H,00H,00H
	db	00H,00H,3BH,6EH,00H,6EH,33H,33H,3BH,33H,33H,33H,00H,00H
	db	3BH,6EH,00H,63H,73H,7BH,7FH,6FH,67H,63H,63H,00H,00H,00H
	db	00H,3CH,6CH,6CH,3EH,00H,7EH,00H,00H,00H,00H,00H,00H,00H
	db	00H,38H,6CH,6CH,38H,00H,7CH,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,18H,18H,00H,18H,18H,33H,33H,1EH,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,7FH,60H,60H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,7FH,03H,03H,00H,00H,00H,00H,00H
	db	00H,60H,0E0H,63H,66H,6CH,18H,30H,6EH,0C3H,06H,0CH,1FH,00H
	db	00H,60H,0E0H,63H,66H,6CH,18H,30H,67H,0CFH,1FH,03H,03H,00H
	db	00H,00H,18H,18H,00H,18H,18H,3CH,3CH,3CH,18H,00H,00H,00H
	db	00H,00H,00H,00H,1BH,36H,6CH,36H,1BH,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,6CH,36H,1BH,36H,6CH,00H,00H,00H,00H,00H
	db	11H,44H,11H,44H,11H,44H,11H,44H,11H,44H,11H,44H,11H,44H
	db	55H,0AAH,55H,0AAH,55H,0AAH,55H,0AAH,55H,0AAH,55H,0AAH,55H,0AAH
	db	0DDH,77H,0DDH,77H,0DDH,77H,0DDH,77H,0DDH,77H,0DDH,77H,0DDH,77H
	db	18H,18H,18H,18H,18H,18H,18H,18H,18H,18H,18H,18H,18H,18H
	db	18H,18H,18H,18H,18H,18H,18H,0F8H,18H,18H,18H,18H,18H,18H
	db	18H,18H,18H,18H,18H,0F8H,18H,0F8H,18H,18H,18H,18H,18H,18H
	db	36H,36H,36H,36H,36H,36H,36H,0F6H,36H,36H,36H,36H,36H,36H
	db	00H,00H,00H,00H,00H,00H,0FEH,36H,36H,36H,36H,36H,36H,36H
	db	00H,00H,00H,00H,00H,0F8H,18H,0F8H,18H,18H,18H,18H,18H,18H
	db	36H,36H,36H,36H,36H,0F6H,06H,0F6H,36H,36H,36H,36H,36H,36H
	db	36H,36H,36H,36H,36H,36H,36H,36H,36H,36H,36H,36H,36H,36H
	db	00H,00H,00H,00H,00H,0FEH,06H,0F6H,36H,36H,36H,36H,36H,36H
	db	36H,36H,36H,36H,36H,0F6H,06H,0FEH,00H,00H,00H,00H,00H,00H
	db	36H,36H,36H,36H,36H,36H,36H,0FEH,00H,00H,00H,00H,00H,00H
	db	18H,18H,18H,18H,18H,0F8H,18H,0F8H,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,00H,0F8H,18H,18H,18H,18H,18H,18H
	db	18H,18H,18H,18H,18H,18H,18H,1FH,00H,00H,00H,00H,00H,00H
	db	18H,18H,18H,18H,18H,18H,18H,0FFH,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,00H,0FFH,18H,18H,18H,18H,18H,18H
	db	18H,18H,18H,18H,18H,18H,18H,1FH,18H,18H,18H,18H,18H,18H
	db	00H,00H,00H,00H,00H,00H,00H,0FFH,00H,00H,00H,00H,00H,00H
	db	18H,18H,18H,18H,18H,18H,18H,0FFH,18H,18H,18H,18H,18H,18H
	db	18H,18H,18H,18H,18H,1FH,18H,1FH,18H,18H,18H,18H,18H,18H
	db	36H,36H,36H,36H,36H,36H,36H,37H,36H,36H,36H,36H,36H,36H
	db	36H,36H,36H,36H,36H,37H,30H,3FH,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,3FH,30H,37H,36H,36H,36H,36H,36H,36H
	db	36H,36H,36H,36H,36H,0F7H,00H,0FFH,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,0FFH,00H,0F7H,36H,36H,36H,36H,36H,36H
	db	36H,36H,36H,36H,36H,37H,30H,37H,36H,36H,36H,36H,36H,36H
	db	00H,00H,00H,00H,00H,0FFH,00H,0FFH,00H,00H,00H,00H,00H,00H
	db	36H,36H,36H,36H,36H,0F7H,00H,0F7H,36H,36H,36H,36H,36H,36H
	db	18H,18H,18H,18H,18H,0FFH,00H,0FFH,00H,00H,00H,00H,00H,00H
	db	36H,36H,36H,36H,36H,36H,36H,0FFH,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,0FFH,00H,0FFH,18H,18H,18H,18H,18H,18H
	db	00H,00H,00H,00H,00H,00H,00H,0FFH,36H,36H,36H,36H,36H,36H
	db	36H,36H,36H,36H,36H,36H,36H,3FH,00H,00H,00H,00H,00H,00H
	db	18H,18H,18H,18H,18H,1FH,18H,1FH,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,1FH,18H,1FH,18H,18H,18H,18H,18H,18H
	db	00H,00H,00H,00H,00H,00H,00H,3FH,36H,36H,36H,36H,36H,36H
	db	36H,36H,36H,36H,36H,36H,36H,0FFH,36H,36H,36H,36H,36H,36H
	db	18H,18H,18H,18H,18H,0FFH,18H,0FFH,18H,18H,18H,18H,18H,18H
	db	18H,18H,18H,18H,18H,18H,18H,0F8H,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,00H,1FH,18H,18H,18H,18H,18H,18H
	db	0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH
	db	00H,00H,00H,00H,00H,00H,00H,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH
	db	0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H
	db	0FH,0FH,0FH,0FH,0FH,0FH,0FH,0FH,0FH,0FH,0FH,0FH,0FH,0FH
	db	0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,3BH,6EH,6CH,6CH,6EH,3BH,00H,00H,00H
	db	00H,00H,00H,00H,3EH,63H,7EH,63H,63H,7EH,60H,60H,20H,00H
	db	00H,00H,7FH,63H,63H,60H,60H,60H,60H,60H,60H,00H,00H,00H
	db	00H,00H,00H,00H,7FH,36H,36H,36H,36H,36H,36H,00H,00H,00H
	db	00H,00H,7FH,63H,30H,18H,0CH,18H,30H,63H,7FH,00H,00H,00H
	db	00H,00H,00H,00H,00H,3EH,6CH,6CH,6CH,6CH,38H,00H,00H,00H
	db	00H,00H,00H,00H,33H,33H,33H,33H,3EH,30H,30H,60H,00H,00H
	db	00H,00H,00H,00H,3BH,6EH,0CH,0CH,0CH,0CH,0CH,00H,00H,00H
	db	00H,00H,7EH,18H,3CH,66H,66H,66H,3CH,18H,7EH,00H,00H,00H
	db	00H,00H,1CH,36H,63H,63H,7FH,63H,63H,36H,1CH,00H,00H,00H
	db	00H,00H,1CH,36H,63H,63H,63H,36H,1CH,36H,36H,77H,00H,00H
	db	00H,00H,1EH,30H,18H,0CH,3EH,66H,66H,66H,3CH,00H,00H,00H
	db	00H,00H,00H,00H,00H,7EH,0DBH,0DBH,7EH,00H,00H,00H,00H,00H
	db	00H,00H,03H,06H,7EH,0DBH,0DBH,0F3H,7EH,60H,0C0H,00H,00H,00H
	db	00H,00H,1CH,30H,60H,60H,7CH,60H,60H,30H,1CH,00H,00H,00H
	db	00H,00H,00H,00H,3EH,63H,63H,63H,63H,63H,63H,63H,00H,00H
	db	00H,00H,00H,00H,7FH,00H,7FH,7FH,00H,7FH,00H,00H,00H,00H
	db	00H,00H,18H,18H,18H,0FFH,18H,18H,18H,00H,0FFH,00H,00H,00H
	db	00H,00H,30H,18H,0CH,06H,0CH,18H,30H,00H,0FFH,00H,00H,00H
	db	00H,00H,0CH,18H,30H,60H,30H,18H,0CH,00H,0FFH,00H,00H,00H
	db	00H,00H,0EH,1BH,1BH,18H,18H,18H,18H,18H,18H,18H,18H,18H
	db	18H,18H,18H,18H,18H,18H,18H,18H,0D8H,0D8H,70H,00H,00H,00H
	db	00H,00H,18H,18H,00H,00H,0FFH,00H,00H,18H,18H,00H,00H,00H
	db	00H,00H,00H,00H,3BH,6EH,00H,3BH,6EH,00H,00H,00H,00H,00H
	db	00H,38H,6CH,6CH,38H,00H,00H,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,18H,18H,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,00H,30H,00H,00H,00H,00H,00H,00H
	db	00H,0FH,0CH,0CH,0CH,0CH,0CH,0ECH,6CH,3CH,1CH,00H,00H,00H
	db	00H,0D8H,6CH,6CH,6CH,6CH,6CH,00H,00H,00H,00H,00H,00H,00H
	db	00H,70H,0D8H,30H,60H,0C8H,0F8H,00H,00H,00H,00H,00H,00H,00H
	db	00H,00H,00H,00H,3CH,3CH,3CH,3CH,3CH,3CH,00H,00H,00H,00H
	db	00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H,00H

code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\rwdot.asm ===
;	TITLE	RWDOT - Read and write dot for MSHERC.
;***
;RWDOT
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	Read and write individual pixels.
;
;******************************************************************************

	include	hgcdefs.inc

code            segment para public 'code'
                assume  cs:code,ds:code

Public	ReadDot		;Read the Graphics Mode Pixel Value
Public	WriteDot	;Write the Graphics Mode Pixel

Extrn	MapGraphXYToVideoOffset:near ;Map Graphics coords to a video offset
Extrn	Bit0:byte		;Bit Mask Table

;-------------------------------------------------------------------------------
; C  WRITE DOT
;	 BH => Display Page
;	 DX => Row
;	 CX => Column
;	 AL => Color, bit 7 causes use of XOR operation for write
;-------------------------------------------------------------------------------
WriteDot	proc	near
	mov	di,Scr0_Buf_Seg 		;Assume Graphics Page 0
	test	bh,1				;Graphics Page 1 on?
	jz	SetBufSeg			;No, point es to page 0
	mov	di,Scr1_Buf_Seg 		;Yes, point es to page 1
SetBufSeg:
	mov	es,di				;Point es to graphics segment

;------ Calculate the video buffer offset -----
	Call	MapGraphXYToVideoOffset		;Result in cx and dx
	mov	di,cx				;di = ptr to video offset
	mov	bx,dx				;Save bit position in bx
	mov	bl,Bit0[bx]			;Fetch bit mask

	or	al,al			;Clear the pixel?
	jnz	SetPix			;No, set the pixel

	not	bl			;Invert the bit mask
	and	es:[di],bl		;Clear the pixel
	jmp	FiniWriteDot		;Exit procedure

SetPix:
	test	al,80H			;use XOR?
	jz	UseOr			;go if not
	xor	es:[di],bl		;XOR the pixel
	jmp	FiniWriteDot		;Exit procedure
UseOr:
	or	es:[di],bl		;Set the pixel

FiniWriteDot:
	Ret	;Finished the Write Dot Procedure
WriteDot	endp

;-------------------------------------------------------------------------------
; D  READ DOT
;	 BH => Display Page
;	 DX => Row
;	 CX => Column
;	 AL <= Color
;-------------------------------------------------------------------------------
ReadDot	proc	near
	mov	di,Scr0_Buf_Seg 		;Assume Graphics Page 0
	test	bh,1				;Graphics Page 1 on?
	jz	RSetBufSeg			;No, point es to page 0
	mov	di,Scr1_Buf_Seg 		;Yes, point es to page 1
RSetBufSeg:
	mov	es,di				;Point es to graphics segment

;------ Calculate the video buffer offset -----
	Call	MapGraphXYToVideoOffset		;Result in cx and dx
	mov	di,cx				;di = ptr to video offset
	mov	bx,dx				;Save bit position in bx
	mov	bl,Bit0[bx]			;Fetch bit mask
	mov	al,es:[di]	;Read the video byte
	and	al,bl		;Isolate the desired pixel
	neg	al		;set carry iff non-0
	sbb	al,al		;AL = (AL==0) ? 0 : -1
	neg	al		;AL = (AL==0) ? 0 :  1
	mov	byte ptr FunData.FunAX,al	;Save pixel color
	Ret	;Finished Pixel Color Read Procedure
ReadDot	endp

code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\setmode.asm ===
;	TITLE	SETMODE - Mode oriented routines for MSHERC.
;***
;SETMODE
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	Set graphics mode, get video state and check hardware card
;	status.
;
;******************************************************************************

	include	hgcdefs.inc

code     segment para public 'code'
         assume  cs:code,ds:code

Public	GetVideoState
Public	SetGraphicsMode
Public	ReturnHGCStatus
Public	GetHGCStatus

Extrn	ConfigMode:byte		;[1] either FULL or HALF mode
Extrn	UnHookFlag:byte
Extrn	DMC_Save:byte		;temp variable for the DMC_Port value
Extrn	HardGraphVals:byte	;Start of Graphics Mode Hardware Reg data
Extrn	Pause:near		;Procedure that counts vsync pulses, and
				;in effect executes a pause...

;-------------------------------------------------------------------------------
; F  CURRENT VIDEO STATE
;	 AL <= Current Mode (8)
;	 AH <= # Character Columns
;	 BH <= Active Display Page (currently always 0)
;-------------------------------------------------------------------------------
GetVideoState	proc near
	mov	ah,es:BIOSCOLS
	mov	al,HGCGrMode
	mov	FunData.FunAX,ax
	mov	al,es:BIOSPAGE
	mov	byte ptr FunData.FunBX[1],al
	ret
GetVideoState	endp

;-------------------------------------------------------------------------------
; 0  SET MODE
;	 AL => mode #8, bit 7, when set, prevents regen buffer clear.
;    Pass on all but request for Hercules graphics mode.
;    Trap ALL functions (except EGAINT10) while in graphics mode.
;    This function should be ignored if BIOS equipment variable not
;    set for B/W.
;-------------------------------------------------------------------------------
SetGraphicsMode proc near
	mov	ah,es:BIOSEQUIP
	and	ah,00110000B		;is B/W mode
	cmp	ah,00110000B
	je	StrtGMode		;go if OK
	ret				;no action if not B/W (mono)
StrtGMode:
	mov	DMC_Save,GraphicsOn+GraphicsPage0+ScreenOff

	push	ax			;save bit 7 (regen clear flag)
	xor	ax,ax
	mov	byte ptr es:BIOSMODE,8		    ;set bios mode number
	mov	word ptr es:BIOSCOLS,80 	    ;set # text columns
	mov	byte ptr es:BIOSPAGE,al 	    ;default page 0
	mov	word ptr es:BIOSCURS,ax 	    ;clear page 0 cursor
	cmp	[ConfigMode],FULL		    ;[1] make sure FULL mode
	jne	SkipPage1		            ;[1] brif not
	mov	word ptr es:BIOSCURS+2,ax	    ;clear page 1 cursor
SkipPage1:					    ;[1]
	mov	word ptr es:BIOSSTART,ax	    ;set buffer start
	mov	word ptr es:BIOSLEN,GraphBufferSize ;    and length
	mov	UnHookFlag,al			    ;Clear the unhook flag

FinGraphicsEntry:

;------Program the 6845 for Graphics Mode-------
	mov	si,offset HardGraphVals	;6845 Graphics values
	mov	cx,CRTValsCnt		;# of data values to program
	mov	ah,Register0		;Start with 6845 register 0

	cli				;Disable interrupts
	mov	dx,DMC_Port		;Use Display Mode Control Port
	mov	al,DMC_Save		;Fetch the DMC value
	out	dx,al			;Disable video
	Call	ProgramRegisters	;Program the 6845 registers
	mov	dx,Config_Port		;Use the configuration port
	mov	al,[ConfigMode] 	;[1] Fetch the config. value
	out	dx,al			;Set Configuration Port

;--------Wait for screen to settle-------
	mov	cx,delay
	Call	Pause

;-------Clear the screen------
	pop	ax			;restore bit 7 (regen clear flag)
	test	al,80H			;bit 7 set to preserve regen buffer?
	jnz	DontClear
	mov	ax,Scr0_Buf_Seg		;Assume Page 0
	push	es
	mov	es,ax			;Pnt es to graphics page
	xor	di,di			;Point di to beg. of buffer offset
	xor	ax,ax
	mov	cx,GraphBufferSize	;Size of both graphics pages in words
	cmp	[ConfigMode],FULL	;[1] make sure in FULL mode
	je	clearit			;[1] brif so
	shr	cx,1			;[1] only clear one page if HALF mode
clearit:				;[1]
rep	stosw				;Store blanking value in graphics buf
	pop	es

DontClear:
;------Set the font character height and width --------
	mov	dx,DMC_Port		;Use the Display Mode Control Port
	mov	al,DMC_Save		;Fetch the video-off value
	or	al,ScreenOn		;Set the video-on bit
	mov	DMC_Save,al		;Save it
	out	dx,al			;Set DMC Port and turn on screen
        ret	;Finished Graphics Mode Set
SetGraphicsMode endp

ReturnHGCStatus proc near
;-------Adjust pointers--------
	call	GetHGCStatus
	mov	word ptr FunData.FunDX,dx   ;[1] Return to user
	ret
ReturnHGCStatus endp

GetHGCStatus	proc near
	mov	dx,DS_Port
	in	al,dx
	and	al,IDMask
	cmp	al,HGC222ID	;Is this a 222?
	jnz	Chk112		;No, check for a 112
	mov	dl,2				;Return to user
	jmp	FiniStatReq			;Finished
Chk112:
	cmp	al,HGC112ID	;Is this a 112?
	jnz	Chk102		;No, check for a 102
	mov	dl,1				;Return to user
	jmp	FiniStatReq			;Finished
Chk102:
	MOV	DX,3BAH        	; Bit 7 at port 3BA changes pretty often
	MOV	CX,0FFFFH      	; on a Hercules so check it to see if
	IN	AL,DX	       	; it flips.
	MOV	BL,AL
tst102:
	IN	AL,DX			; Current value of Port 3BA
	XOR	AL,BL			; XOR to see if it changes
	TEST	AL,80H			; Did it?
	JNZ	got102			; Yes, we must have a Hercules
	LOOP	tst102	 		; No, try again
	mov	dx,-1			;[2] Indicate non-Hercules
	JMP	SHORT FiniRetDef	;[2] If we didn't get it, give up
got102:
	xor	dl,dl				;Indicate 102

FiniStatReq:
	mov	dh,[ConfigMode]		;[1] return FULL = 1 or HALF = 0
	shr	dh,1			;[1]
FiniRetDef:				;[2]
	ret	;Finished HGC Status Request
GetHGCStatus	endp

;-----------------------------------------------------------------------------;
;				ProgramRegisters
;
;	Loads a consecutive set of registers with the values from the
;	specified table via the Index/Data Ports.
;
;               Entry:  ds:si = offset of data table
;			ah = 1st register number
;			cx = # registers to load
;
;		Uses:	ax,cx,dx,si
;
;	**Notes: This routine is practical for programming 3 or more data
;		values
;
;-----------------------------------------------------------------------------;
ProgramRegisters	proc	near
	cli				;Disable interrupts
ProgRegs:
	mov	dx,IndexReg		;Use Index Register
	mov	al,ah			;Get Desired Register Number
	out	dx,al			;Point to Register
	inc	dx			;Use Data Port
	lodsb				;Fetch data value from table
	out	dx,al			;Output data value
	inc	ah			;Increment to next register number
	loop	ProgRegs		;Loop to output next data value
	sti				;Enable interrupts

         ret				;Finished
ProgramRegisters	endp

code     ends
         end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\baslibma.inc ===
;***
; BASLIBMA.INC - 26-Aug-86 - General Utility Macro Definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; General purpose runtime macros.
;
;******************************************************************************
;
;	Undefined switch initialization
;
NDEF	MACRO	switch
.xcref
ifndef	switch
switch= 0
endif
.cref
	endm

NDEFV	MACRO	switch,vl
.xcref
ifndef	switch
switch= vl
endif
.cref
	endm
;******************************************************************************
;
;	Conditional text output
;
OUTIF	MACRO	vl,txt
ndef	vl
if	vl
	%out	txt
endif
	endm

OUTELSE MACRO	vl,txt
ndef	vl
ife	vl
	%out	txt
endif
	endm

;******************************************************************************
;
;	Special Table Generation Macros 	(formerly TABMAC.INC)
;
ENTORG	MACRO	First_entry
	.XCREF
___ZZZ= First_entry
	.CREF
	ENDM

ENT	MACRO	Lab,Incr
Lab=	___ZZZ
	.XCREF
___ZZZ= ___ZZZ+Incr
	.CREF
	ENDM

ENTI	MACRO	Incr
	.XCREF
___ZZZ= ___ZZZ+Incr
	.CREF
	ENDM

;******************************************************************************
;
; Skip execution of the next "n" bytes. Eats them up in a one byte register
; compare instruction. Needless to say, flags are lost.
;

SKIP	MACRO	LEN

IF	LEN EQ 1		;;Is length 1?
	DB	03CH		;;CMP AL,...
ENDIF				;;IF LENGTH EQ 1

IF	LEN EQ 2		;;Is length 2?
	DB	03DH		;;CMP AX,...
ENDIF				;;IF LENGTH EQ 2

IF	LEN GT 2
	.ERR	SKIP MACRO: ILLEGAL SKIP LENGTH: LEN ;;Cause an error
	%OUT	SKIP MACRO: ILLEGAL SKIP LENGTH: LEN ;;Cause an error
ENDIF				;;IF LENGTH GT 2
	ENDM

;***
;PUSHI macro - push immediate data word
;
;Entry:
;	reg - register to use as intermediate in the case we're not
;		building for a 286 environment
;	wData - a word of data to be pushed
;Exit:
;	none.
;Modifies:
;	Will alter the given register if not HP_286.
;**************************************************************************
PUSHI 	MACRO	reg,wData
;if	286 instructions are enabled, use a real immediate push
;	PUSH	wData
;else
	MOV	reg,wData
	PUSH	reg
;endif
	endm
	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\herc\tty.asm ===
;	TITLE	TTY - TTY output routine for MSHERC.
;***
;TTY
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	TTY output routine for MSHERC.
;
;******************************************************************************

	include	hgcdefs.inc

code            segment para public 'code'
                assume  cs:code,ds:code

Extrn	GScrollUp:near
Extrn	WriteGrChar:near
Extrn	SetCursor:near
Extrn	Old_Int10h_Routine:dword	;Segment:Offset of previous INT 10H

Public	WriteTTY

;-------------------------------------------------------------------------------
; E  WRITE TELETYPE TO ACTIVE PAGE
;	 AL => Character
;	 BL => Color
;-------------------------------------------------------------------------------
WriteTTY	proc	near

	mov	cl,bl			;save attr

;------Fetch the current cursor position-------
	xor	bx,bx
	mov	bl,es:BIOSPAGE
	shl	bx,1
	mov	dx,es:BIOSCURS[bx]

;----- Check for special characters -------
	cmp	al,Bell 		;Is char a bell?
	jz	ExecBell		;Yes, execute a Bell

	cmp	al,BackSpace		;Is char a backspace?
	jz	ExecBackSpace		;Yes, execute a BackSpace

	cmp	al,LineFeed		;Is char a line feed?
	jz	ExecLineFeed		;Yes, execute a LineFeed

	cmp	al,CarriageReturn	;Is char a carriage return?
	jz	ExecCarriageReturn	;Yes, execute a carriage return

;-----Not a special character so write it to screen-----
	mov	bl,cl			;use attr
	mov	cx,1			;Char Cnt = 1
	mov	bh,es:BIOSPAGE		;use active page
	Call	WriteGrChar		;Write char at current cursor pos

;------Fetch the current cursor position-------
	xor	bx,bx
	mov	bl,es:BIOSPAGE
	shl	bx,1
	mov	dx,es:BIOSCURS[bx]

;----- Advance and Check Cursor Position-------
	inc	dl			;Increment the cursor column position
	cmp	dl,80			;End of Row?
	jge	GotoNextLine		;Yes, go to next row

;----- Update the cursor and exit-------
SetCursorAndExit:
	mov	bh,es:BIOSPAGE
	Call	SetCursor		;set the cursor to new position
	jmp	FiniTTY 		;exit

;----- Routines for special cases------
ExecBell:
	mov	ah,14			;Write TTY request for orig INT 10
	pushf				;so original INT 10 can IRET
	Call	Old_Int10h_Routine	;let it BEEP for us
	jmp	FiniTTY			;Finished

ExecBackSpace:
	cmp	dl,0			;Beginning of line?
	jz	FiniTTY 		;Yes, do nothing
	dec	dl			;No, set cursor to
	jmp	SetCursorAndExit	;previous column, then exit

ExecCarriageReturn:
	xor	dl,dl		       ;Set cursor at first column in line
	jmp	SetCursorAndExit    ;and then exit

ExecLineFeed:
	mov	cx,25			;Fetch # of rows on screen
	dec	cl
	cmp	dh,cl			;Is cursor on the last line?
	jz	ScrollTheScreen 	;Yes, then scroll screen
	inc	dh			;No, set cursor to next line
	jmp	SetCursorAndExit	;and exit

;----- Set column to 0. Are we at the end of the screen?-----
GotoNextLine:
	xor	dl,dl			;Set cursor to first column on line
	mov	cx,25			;Fetch screen width
	dec	cl
	cmp	dh,cl			;Is this the last row?
	jge	ScrollTheScreen 	;Yes, scroll the screen
	inc	dh			;No, set cursor to next line
	jmp	SetCursorAndExit	;and exit routine

;----- Cursor is on last row of screen. Set cursor position then scroll-----
ScrollTheScreen:
	mov	bh,es:BIOSPAGE
	Call	SetCursor

;----- Set up parameters then scroll screen-------
	mov	ax,1		;# of lines to scroll
	xor	cx,cx		;Upper Left corner of scroll
	xor	bh,bh		;blanking attribute??
	mov	dx,79+24 shl 8	;lower right corner
	Call	GScrollUp	;Scroll up window

FiniTTY:
	Ret	;Finished Text TTY Routine
WriteTTY	endp

code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\ascii.inc ===
;***
;ascii.inc - 20-Mar-86 - ASCII Character Definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

ASCBEL=	07h			;Bell
ASCBS=	08h			;Backspace
ASCHT=	09h			;Tab
ASCLF=	0Ah			;Line feed
ASCCR=	0Dh			;Carriage return
ASCSP=	20h			;Space
ASCQO=	22h			;Quote

newline= asccr

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\array.inc ===
;***
; array.inc - 12-Nov-86 - far memory and array descriptors
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; Contains the definition of the array and far heap descriptors.
; 
; NOTE: If you modify this file, notify the QBI group, as they include it too.
;
;Array descriptor fields:
;
; AD_oAdjusted: This field contains the constant portion of the array indexing
;   expression, which takes into account the cumulative affect of all the lower
;   bounds for the array dimensions. Given:
;
;	DIM ARY(l1 to u1, l2 to u2, l3 to u3)
;		  \  /	    \  /      \  /
;		   \/	     \/        \/
;		   c1	     c2        c3	(count of elements)
;
;   The address of any array element can be calculated as:
;
;	(((k - l3) * c2 + j - l2) * c1 + i - l1) * elementsize + offset
;
;   This can be rearranged to isolate the items dealing with the lower bounds:
;
;	(((k * c2 + j) * c1) + i) * elementsize
;	    - (l3 * c2 * c1 + l2 * c1 + l1) * elementsize
;	    + offset
;
;   The second and third lines of this equation are known at DIM time, and are
;   placed into the AD_oAdjusted field. To access an array element then, the
;   calculation required is:
;
;	(((k * c2 + j) * c1) + i) * elementsize + AD_oAdjusted
;
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME and
;	NOTE: the interpreter projects.  Any changes made to one should
;	NOTE: be carried over (COPIED) to the other!!!
;
;******************************************************************************

ARRAY_INC = -1	;needed by QBI sources which also include this file.

AHD	STRUC			;[6]Array header - in front of data in far space
AHD	ENDS			;[6]

;		FHD Structure - Far heap descriptor

FHD		STRUC
FHD_oData	DW	?	;[1]Offset of data start
FHD_hData	DW	?	;[1]Segment of data start
FHD_pNext	DW	?	;DGROUP offset of next FHD
FHD_cPara	DW	?	;Para count of entry (bytes for non-LNA)
FHD		ENDS

;		DM Structure - Array dimension information

DM		STRUC
DM_cElements	DW	?	;Element count for this dimension
DM_iLbound	DW	?	;Lower bound for this dimension
DM		ENDS

;		AD Structure - Array descriptor

AD		STRUC
AD_fhd		DB	SIZE FHD DUP(?) ;FHD for this AD

AD_cDims	DB	?	;Dimension count
AD_fFeatures	DB	?	;Feature flags

AD_oAdjusted	DW	?	;[3] Adjusted offset
AD_cbElement	DW	?	;Byte count per element

AD_tDM		DB	?	;First byte of first DM structure
AD		ENDS

;		AD_fFeatures flag definitions

FADF_NEAR	EQU	0	;[1]near allocation
FADF_FAR	EQU	1	;[1]far allocation
FADF_HUGE	EQU	2	;[1]huge allocation
FADF_ALCMSK	EQU	3	;[1]allocation mask
FADF_STATIC	EQU	40h	;[1]Array is a $STATIC array
FADF_SD 	EQU	80h	;[1]Array is a string array
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\addr.inc ===
;***
;addr.inc   -  26-May-86  -  Module Header Definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;	****************************************************************
;	****							    ****
;	****	WARNING!	WARNING!	WARNING!	    ****
;	****							    ****
;	**** PLEASE READ REVISION HISTORY # 4 BEFORE MAKING CHANGES ****
;	****							    ****
;	****************************************************************
;
;Purpose:
;
;******************************************************************************

;-------------------------------------------------------------------------

;	Module Information Block

;	This structure occurs at the beginning of each compiled source
;	module.  This information describes offsets and segment numbers
;	for the runtime memory map.  Some of the fields have special
;	meanings for the initial module loaded since the offsets and
;	segment bases refer to the start of the particular named segment.
;	This allows the overall size of a segment to be determined.
;	For example, the difference between the contents of the OF_FT
;	and OF_DAT fields of the first module gives the overall size
;	of the static variables in all the compiled modules.


	.RADIX	10
;	Code segment offsets

modnam_len= 8			;module name length

MODULE_CODE STRUC

SG_CMP	DW	?		;Signature word - 'bl' or 'bm'

OF_MOD	DB	"        "	;Offset for Module Name
OF_STA	DW	?		;Offset for Statement address table
OF_DS	DW	?		;Offset for BC_DS + 2
OF_DAT	DW	?		;Offset for BC_DATA
OF_FT	DW	?		;Offset for BC_FT
BS_ICN	DW	?		;Base	for BC_ICN
BS_INC	DW	?		;Base	for INIT
BS_DSG	DW	?		;[CONST] Base	for DATA (runtime DATA)
OF_COM	DW	?		;Offset for COMMON
SZ_COM	DW	?		;Size	for COMMON
OF_UCONST DW	?		;Offset for CONST (user CONST)
OF_UDATA DW	?		;Offset for DATA  (user DATA)
OF_CN	DW	?		;Offset for BC_CN
SZ_FRAME DW	?		;Size	for frame
off_alloc DW	?		;Offset  heap allocation routine for ISAM
seg_alloc DW	?		;Segment heap allocation routine
off_dealoc DW	?		;Offset  heap deallocation routine for ISAM
seg_dealoc DW	?		;Segment heap deallocation routine
C_VALUE DW	?		;Value	of  /C:n switch, -1 if not given
U_FLAG	DW	?		;Switches specified at compile time
MODULE_CODE ENDS
O_ENT	=	U_FLAG + 2


RELSIZ= O_ENT+15		;size of module header structure



;	Module header signature constants

; The following are the signature values for the different runtime
; configurations.  The are two be found in the first two bytes of
; the module header (the SG_CMP field).  Notice that the constants
; are defined as byte swapped values, so that the values may be
; handled as word entities.

BM_BRUN =	"mb"		;[3]"br" - QB runtime module OMF
BR_BCOM =	"lb"		;[1]"bl" - QB "calls" module OMF

;	Data segment offsets

MODULE_DATA STRUC

OFD_RESTORE	DB	?	;Restore flag for module
		DB	?	;unused
OFD_DATA	DW	?	;Data statement pointer
OFD_ONERROR	DW	?	;ON ERROR trap address

MODULE_DATA ENDS

;----U_FLAG bit defintitions---------------------------
	u_sw_d	=      1h	;/d switch
	u_sw_i	=      4h	;[4] /fpi switch
	u_sw_a	=      8h	;[4] /fpa switch
	u_sw_x	=     20h	;/x switch
	u_sw_e	=     40h	;/e switch
	u_sw_r	=    100h	;/r switch
	u_sw_v	=    400h	;/v switch
	u_sw_w	=    800h	;/w switch
	u_sw_o	=   1000h	;/o switch
	u_sw_t	=   2000h	;/t switch

;----end of U_FLAG bit defintitions--------------------

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\comdcb.inc ===
;***
;comdcb.inc - 13-Aug-86 - communications device control block structure
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Provides the control block used between the communications
;	high- and low-level code.
;
;******************************************************************************

;	RS232 Device Control Block Definition:


COMDCB	STRUC

CD_DEVID	DB	?	;RS232 Channel ID (0..n)
CD_BYTSZ	DB	?	;bits per byte (4..8)
CD_PARIT	DB	?	;parity (0..4)= (none, odd, even, mark, space)
CD_STOPB	DB	?	;(0..2)= (1, 1.5, 2) stop bits
CD_BAUDR	DW	?	;baud rate
CD_OPNTO	DW	?	;[2]device open timeout
CD_RLSTO	DW	?	;RLSD (rec. line signal detect) timeout
CD_CTSTO	DW	?	;CTS (clear to send) timeout
CD_DSRTO	DW	?	;DSR (data set ready) timeout
				;timeout values are in milliseconds (0=infinite)
CD_CMWID	DB	?	;device width (columns per line)
CD_CMPOS	DB	?	;current column of device (must follow _CMWID)
CD_CMEVT	DW	?	;counter for event flag processing
				;set to 0 at COM open, decremented for
				;each character read from queue.  If
				;less than number of characters in queue
				;then event is signaled (if enabled)
CD_CMFDB	DW	?	;points to FDB for file (0=not opened)
CD_RXSEG	DW	?	;[2]seg of COMx receive buffer in far memory
CD_RXSIZ	DW	?	;[2]size in bytes of the COMx receive buffer
CD_TXSEG	DW	?	;[2]seg of COMx transmit buffer in far memory
CD_TXSIZ	DW	?	;[2]size in bytes of the COMx transmit buffer
CD_CMFLG	DB	?	;Boolean attributes mask for this device

COMDCB	ENDS


;	Values for bits in COMx DCB flag byte CD_CMFLG.

CF_CMBIN	EQU	01H	;(0/1)=ASC/BIN (BIN|ASC specified in filespec)
CF_CMRTS	EQU	02H	;if set, suppress Request-To-Send (RS option)
CF_CMPEN	EQU	04H	;if set, receive parity enabled
CF_CMOPN	EQU	08H	;[2]if set, open timeout specified
CF_CMCOD	EQU	10H	;if set, user specified BIN or ASC
CF_CMCTS	EQU	20H	;if set, CTS parm not defaulted (in ParseOpt)
CF_CMCTZ	EQU	20H	;[3]if set, Ctl-Z seen in ASC (after ParseOpt)
CF_CMCLF	EQU	40H	;if set, send line feed after CR
CF_CMCRF	EQU	80H	;if set, last char sent was carriage return

;	IF COM filename contains:      ASC     BIN     both    neither
;	Then CF_CMBIN, CF_CMCOD is:    0,1     1,1   bad name    1,0

	.LIST			;[1]
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\comioctl.inc ===
;***
;comioctl.inc - 12-Oct-86 - DOS5 com device driver IOCTL definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Provides value, structure, and bit definitions for the DOS5 com
;	IOCTL and hardware.
;
;******************************************************************************

ComCategory	EQU	1		;IOCTL category for COMx device driver

;	Line characteristics

;--------------------------------------------------------------------------
IOComSetBaud	EQU	41H		;set baud rate
IOComGetBaud	EQU	61H		;get baud rate

SetBaudStruc	STRUC
IOParmBaudRate	DW	?		;baud rate (bits per second)
SetBaudStruc	ENDS
;--------------------------------------------------------------------------
IOComSetLinCtl	EQU	42H		;set line control
IOComGetLinCtl	EQU	62H		;get line control

LinCtlStruc	STRUC
IOParmDatLen	DB	?		;length of data in bits (5-8)
IOParmParity	DB	?		;parity (0-4)=(no,odd,even,mark,space)
IOParmStopBt	DB	?		;stop bits (0-2)=(1,1.5,2)
IOParmBreak	DB	?		;(get only) Tx break: 0=off; 1=on
LinCtlStruc	ENDS
;--------------------------------------------------------------------------
IOComTxStatus	EQU	65H		;return transmit data status

TxStatusStruc	STRUC
IOParmTxStat	DB	?		;bits of transmit data status (*)
TxStatusStruc	ENDS

;(*)	Bits in transmit data status byte.

	IOTxWriteReq	EQU	01H	;WRITE request packet queued
	IOTxDataInQueue	EQU	02H	;data in driver transmit queue
	IOTxCharActive	EQU	04H	;transmitter currently active
	IOTxCharWaiting	EQU	08H	;waiting for "immediate transmit"
	IOTxXonWaiting	EQU	10H	;waiting to transmit XON
	IOTxXoffWaiting	EQU	20H	;waiting to transmit XOFF
;--------------------------------------------------------------------------
IOComSetModCtl	EQU	46H		;set modem control register

SetModCtlStruc	STRUC
IOParmModCtlSet	DB	?		;bits to set in modem control reg
IOParmModCtlClr	DB	?		;bits to clear in modem control reg
SetModCtlStruc	ENDS
;--------------------------------------------------------------------------
IOComGetModCtl	EQU	66H		;get modem control register

GetModCtlStruc	STRUC
IOParmModCtl	DB	?		;value of modem control register (*)
GetModCtlStruc	ENDS

;(*)	Modem control register bit definitions.

	IOModCtlDTR	EQU	01H	;DTR active low
	IOModCtlRTS	EQU	02H	;RTS active low
;--------------------------------------------------------------------------
IOComGetLinStat	EQU	65H		;get line status register

GetLinStatStruc	STRUC
IOParmLinStat	DB	?		;value of line status register (*)
GetLinStatStruc	ENDS

;(*)	Line status register bit definitions.

	IOLinStatRxRdy	EQU	01H	;Rx data register full
	IOLinStatChrOR	EQU	02H	;Rx data register character overrun
	IOLinStatParErr	EQU	04H	;Rx data register parity error
	IOLinStatBitOR	EQU	08H	;Rx data register bit overrun (framing)
	IOLinStatBreak	EQU	10H	;Rx data register break detected
	IOLinStatTxHold	EQU	20H	;Tx holding register empty
	IOLinStatTxEmpt	EQU	40H	;Tx shift and holding registers empty
;--------------------------------------------------------------------------
IOComGetModStat	EQU	67H		;get modem status register

GetModStatStruc	STRUC
IOParmModStat	DB	?		;value of modem status register (*)
GetModStatStruc	ENDS

;(*)	Modem status register bit definitions.

	IOModStatCTS	EQU	10H	;current CTS (clear to send)
	IOModStatDSR	EQU	20H	;current DSR (data set ready)
	IOModStatRI	EQU	40H	;current RI (ring indicator)
	IOModStatDCD	EQU	80H	;current DCD (data carrier detect)
;--------------------------------------------------------------------------

;	Manual XON/XOFF processing

;--------------------------------------------------------------------------
IOComTxImmed	EQU	44H		;transmit immediate

TxImmedStruc	STRUC
IOParmChrTxImm	DB	?		;char to be transmitted immediately
TxImmedStruc	ENDS
;--------------------------------------------------------------------------
IOComSimXOFF	EQU	47H		;simulate XOFF received (stop Tx)
;--------------------------------------------------------------------------
IOComSimXON	EQU	48H		;simulate XON received (start Tx)
;--------------------------------------------------------------------------

;	Break processing and port error.

;--------------------------------------------------------------------------
IOComBreakOn	EQU	4BH		;set break condition on
IOComBreakOff	EQU	45H		;set break condition off
IOComGetPrtErr	EQU	6DH		;get com port error

PrtErrStruc	STRUC
IOParmPrtErr	DW	?		;ommunications port error word (*)
PrtErrStruc	ENDS

;(*)	Communications port error word bit definitions.

	IOErrRxQueOflo	EQU	0001H	;receive queue overflow
	IOErrRxHardOflo	EQU	0002H	;receive hardware overflow
	IOErrRxParity	EQU	0004H	;receive character parity error
	IOErrRxBitOR	EQU	0008H	;receive character bit overrun error
;--------------------------------------------------------------------------

;	Device driver queue management

;--------------------------------------------------------------------------
IOComGetInQChr	EQU	68H		;get number of char in input queue
IOComGetOutQChr	EQU	69H		;get number of char in output queue

QueChrStruc	STRUC
IOParmCharQue	DW	?		;number of characters in the queue
IOParmSizeQue	DW	?		;size of queue
QueChrStruc	ENDS
;--------------------------------------------------------------------------

;	Polled events

;--------------------------------------------------------------------------
IOComSetEvtMask	EQU	52H		;set com event mask
IOComGetEvtMask	EQU	72H		;get com event mask

EventStruc	STRUC
IOParmEvent	DW	?		;communications event word (*)
EventStruc	ENDS

;(*)	Communication event word bit definitions.

	IOEvtRxAnyChr	EQU	0001H	;any character received
	IOEvtTxLastChr	EQU	0004H	;last character transmitted
	IOEvtDeltaCTS	EQU	0008H	;delta in CTS state
	IOEvtDeltaDSR	EQU	0010H	;delta in DSR state
	IOEvtDeltaDCD	EQU	0020H	;delta in DCD state
	IOEvtBreak	EQU	0040H	;break condition detected
	IOEvtLineStat	EQU	0080H	;line status error (parity,overrun)
	IOEvtDeltaRI	EQU	0100H	;delta in RI state
;--------------------------------------------------------------------------
IOComGetPrtStat	EQU	6BH		;get com port status

PrtStatStruc	STRUC
IOParmPrtStat	DB	?		;communications port status (*)
PrtStatStruc	ENDS

;(*)	Communications port status bit definitions.

	IOPrtCTSTxWait	EQU	01H	;transmit waiting for CTS to be on
	IOPrtDSRTxWait	EQU	02H	;transmit waiting for DSR to be on
	IOPrtDCDTxWait	EQU	04H	;transmit waiting for DCD to be on
	IOPrtXOFRxWait	EQU	08H	;transmit waiting since XOFF received
	IOPrtXOFTxWait	EQU	10H	;transmit waiting since XOFF transmit
	IOPrtBrkTxWait	EQU	20H	;transmit waiting since BREAK transmit
	IOPrtDSRRxWait	EQU	40H	;receive waiting for DSR to be on
;--------------------------------------------------------------------------

;	Device data control block (DCB) management

;--------------------------------------------------------------------------
IOComSetDevDCB	EQU	53H		;set DCB parameters
IOComGetDevDCB	EQU	73H		;get DCB parameters

DevDCBStruc	STRUC
IOParmWriteTime	DW	?		;write timeout in hundredths of sec
IOParmReadTime	DW	?		;read timeout in hundrerths of sec
IOParmFlags1	DB	?		;first byte of flags (*)
IOParmFlags2	DB	?		;second byte of flags (**)
IOParmFlags3	DB	?		;third byte of flags (***)
IOParmErrRepChr	DB	?		;error replacement character
IOParmBrkRepChr	DB	?		;break replacement character
IOParmXONChar	DB	?		;XON character value
IOParmXOFFChar	DB	?		;XOFF character value
DevDCBStruc	ENDS

;(*)	First flag byte bit definitions.

	IOFlag1DTRMask	EQU	03H	;DTR control mode mask
	  IOFlag1DTRDis	EQU	00H	;DTR disable
	  IOFlag1DTREnb	EQU	01H	;DTR enable
	  IOFlag1RxDTR	EQU	02H	;DTR input handshaking
	IOFlag1TxCTS	EQU	08H	;CTS output handshaking
	IOFlag1TxDSR	EQU	10H	;DSR output handshaking
	IOFlag1TxDCD	EQU	20H	;DCD output handshaking
	IOFlag1RxDSR	EQU	40H	;DSR input handshaking

;(**)	Second flag byte bit definitions.

	IOFlag2XONOut	EQU	01H	;output XON/XOFF active
	IOFlag2XONIn	EQU	02H	;input XON/XOFF active
	IOFlag2ErrChar	EQU	04H	;error replacement char active
	IOFlag2NulStrp	EQU	08H	;null char stripping active
	IOFlag2BrkChar	EQU	10H	;break replacement char active
	IOFlag2RTSMask	EQU	0C0H	;RTS control mode mask
	  IOFlag2RTSDis	EQU	000H	;RTS disable
	  IOFlag2RTSEnb	EQU	040H	;RTS enable
	  IOFlag2RxRTS	EQU	080H	;RTS input handshaking
	  IOFlag2RTSTog	EQU	0C0H	;RTS toggling on transmit

;(***)	Third flag byte bit definitions.

	IOFlag3TxInf	EQU	01H	;enable write infinite timeout
	IOFlag3RxTOMask	EQU	06H	;read timeout processing mask
	  IOFlag3RxNorm	EQU	02H	;normal read timeout
	  IOFlag3RxWait	EQU	04H	;wait read timeout
	  IOFlag3RxNone	EQU	06H	;no-wait read timeout
;--------------------------------------------------------------------------

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to HHLs
(C)Copyright Microsoft Corp. 1984, 1985, 1986
$
if1
ASMpass=1
else
ASMpass=2
endif
outif MACRO name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
else
name=name
endif
if name
name=1
ifnb <onmsg>
if1
%out ! onmsg
endif
endif
else
ifnb <offmsg>
if1
%out ! offmsg
endif
endif
endif
endm
??error macro msg
E r r o r ----- msg
endm
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
if1
%out cMacros Version 2.07 - 9/19/86
%out Copyright (C) Microsoft Corp. 1984, 1985, 1986. All rights reserved.
endif
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS= 1
outif memS,0,<Small Model>
else
??error <Must have only 1 memory model selected>
endif
endif
sizeC= memM + memL + memH
sizeD= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows Support>
outif ?PLM,1,<PLM calling convention>
ifndef ?NODATA
?NODATA1=0
else
?NODATA1=1
if1
%out ! NODATA module
endif
endif
ifndef ?CHKSTK
?CHKSTK1=0
else
?CHKSTK1=1
ifdef ?CHKSTKPROC
if1
%out ! Private stack checking enabled
endif
else
if1
%out ! Stack checking enabled
endif
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
if1
%out ! DOS5 module
endif
endif
ifdef ?PROFILE
if1
%out ! Native Profiling Enabled
endif
endif
.XCREF
.XCREF ?N,?AX,?AH,?AL,?BX,?BH
.XCREF ?BL,?CX,?CH,?CL,?DX,?DH
.XCREF ?DL,?SI,?DI,?ES,?DS,?BP
.XCREF ?SP,?SS,?CS
.XCREF ?RSL,?CPD,?argl,?argc,?BA
.XCREF ?ACB,???,?PO
.XCREF ?PAS,?PC
.XCREF Uconcat,mPush,mPop
.XCREF ?RI,?pp,?pp1,?al1
.XCREF ?aD,?AP,?Atal,?dd,?dd1
.XCREF ?pg,?pg1,?aloc,?cs1,?cs2
.XCREF ?DF,?TF,?FF,?PLM,?WIN,?IA,?PU,?ADJ
.XCREF ?UF,?RP,?NX,?ND,?NODATA1,?CHKSTK1,?DOS5
.XCREF ?WFP
?RSL = 0
?CPD = 0
?ArgL = 0
?ArgC = 0
?BA = 0
?ACB = 0
??? = 0
?PO = 0
?PAS = 0
?PC = 0
?IA = 0
?PU = 0
?ADJ = 0
?RP = 0
?UF = 0
?ND = 0
?NX = 0
?WFP = 0
?FF = 0
?N = 0000000000000000B
?AX = 0000000000000011B
?AH = 0000000000000001B
?AL = 0000000000000010B
?BX = 0000000000001100B
?BH = 0000000000000100B
?BL = 0000000000001000B
?CX = 0000000000110000B
?CH = 0000000000010000B
?CL = 0000000000100000B
?DX = 0000000011000000B
?DH = 0000000001000000B
?DL = 0000000010000000B
?SI = 0000000100000000B
?DI = 0000001000000000B
?ES = 0000010000000000B
?DS = 0000100000000000B
?BP = 0001000000000000B
?SP = 0010000000000000B
?SS = 0100000000000000B
?CS = 1000000000000000B
.CREF
uconcat macro a,b,c,d,e,f
a&b c&d e&f
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if r AND ?&&x
push x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if r AND ?&&x
pop x
endif
endm
endm
save macro r
?RSL=0
?RI ?RSL,<r>
endm
?RI macro n,r
irp x,<r>
ifdef ?&&x
n=n OR ?&&x
endif
endm
endm
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<DWORD>,0,4
?pp <Off_&&x>,<WORD>,2,2
?pp <Seg_&&x>,<WORD>,2,2
endm
else
irp x,<n>
?pp <Seg_&&x>,<WORD>,2,2
?pp <Off_&&x>,<WORD>,2,2
?pp <&&x>,<DWORD>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<QWORD>,8,8
endm
parmT macro n
?pp <n>,<TBYTE>,10,10
endm
if sizeC
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sizeD
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?CPD
.xcref
irp x,<n>
.xcref ?T&&x
?T&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?PO+?adj)
?PO=?PO+l
else
?PO=?PO+l
?pp1 x,<t>,%?PO,%?adj
endif
endm
.cref
else
??error <Parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b
ife ?PLM
n equ t ptr [bp+b]
else
n equ t ptr [bp+a+?PO-o]
endif
endm
ifndef ?NOPARMR
.XCREF
.XCREF ?pr
.CREF
parmR macro n,r,r2
?pr n,r,r2,%?RP,%(?IA+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR SEG_&n,r
parmR OFF_&n,r2
n equ dword ptr [bp-o-2]
.xcref ?T&n
?T&n=4
else
.xcref ?RP&i
?RP&i=0
ifdef ?&r
?RP&i=?&r
endif
if ??? OR (?CPD EQ 0) OR (?RP&i EQ 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ word ptr [bp-o]
?T&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x EQ ?&r
n equ byte ptr [bp-o]
?T&n=1
exitm
endif
endm
?IA=?IA+2
?RP=?RP+1
endif
.cref
endm
endif
localB macro n
?aLoc <n>,<BYTE ptr>,1,1,0
endm
localW macro n
?aLoc <n>,<WORD PTR>,2,2,1
endm
localD macro n
irp x,<n>
?aLoc <Seg_&&x>,<WORD PTR>,2,2,1
?aLoc <Off_&&x>,<WORD PTR>,2,2,1
?aLoc <&&x>,<DWORD PTR>,0,4,1
endm
endm
localQ macro n
?aLoc <n>,<QWORD PTR>,8,8,1
endm
localT macro n
?aLoc <n>,<TBYTE PTR>,10,10,1
endm
if sizeC
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sizeD
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aLoc <n>,,%(a),0,1
endm
?aLoc macro n,t,l,s,a
if ?CPD
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) AND 0FFFEH)
endif
?aL1 x,<t>,%(???+?IA)
.xcref ?T&&x
?T&&x=s
endm
.cref
else
??error <Locals "&n" declared outside procedure def>
endif
endm
?aL1 macro n,t,o
n equ t [bp-o]
endm
ifndef ?NOGLOBAL
globalB macro n,i,s
?aD <n>,1
?dd n,1,<BYTE>,<DB>,<i>,<s>
endm
globalW macro n,i,s
?aD <n>,2
?dd n,1,<WORD>,<DW>,<i>,<s>
endm
globalD macro n,i,s
?aD <n>,4
?dd n,1,<DWORD>,<DD>,<i>,<s>
endm
globalQ macro n,i,s
?aD <n>,8
?dd n,1,<QWORD>,<DQ>,<i>,<s>
endm
globalT macro n,i,s
?aD <n>,10
?dd n,1,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
globalCP macro n,i,s
globalD n,<i>,<s>
endm
else
globalCP macro n,i,s
globalW n,<i>,<s>
endm
endif
if sizeD
globalDP macro n,i,s
globalD n,<i>,<s>
endm
else
globalDP macro n,i,s
globalW n,<i>,<s>
endm
endif
endif
ifndef ?NOSTATIC
staticB macro n,i,s
?aD <n>,1
?dd n,0,<BYTE>,<DB>,<i>,<s>
endm
staticW macro n,i,s
?aD <n>,2
?dd n,0,<WORD>,<DW>,<i>,<s>
endm
staticD macro n,i,s
?aD <n>,4
?dd n,0,<DWORD>,<DD>,<i>,<s>
endm
staticQ macro n,i,s
?aD <n>,8
?dd n,0,<QWORD>,<DQ>,<i>,<s>
endm
staticT macro n,i,s
?aD <n>,10
?dd n,0,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sizeD
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s
ife ?PLM
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
PUBLIC n
endif
ifb <s>
n d i
else
ifb <i>
n d s DUP (?)
else
n d s DUP (i)
endif
endif
endm
ifndef ?NOEXTERN
.XCREF
.XCREF ?ex1
.CREF
externB macro n
?ex1 <n>,1,<BYTE>
endm
externW macro n
?ex1 <n>,2,<WORD>
endm
externD macro n
?ex1 <n>,4,<DWORD>
endm
externQ macro n
?ex1 <n>,8,<QWORD>
endm
externT macro n
?ex1 <n>,10,<TBYTE>
endm
externNP macro n
?ex1 <n>,2,<NEAR>
endm
externFP macro n
?ex1 <n>,4,<FAR>
endm
if sizeC
externP macro n
?ex1 <n>,4,<FAR>
endm
else
externP macro n
?ex1 <n>,2,<NEAR>
endm
endif
if sizeC
externCP macro n
?ex1 <n>,4,<DWORD>
endm
else
externCP macro n
?ex1 <n>,2,<WORD>
endm
endif
if sizeD
externDP macro n
?ex1 <n>,4,<DWORD>
endm
else
externDP macro n
?ex1 <n>,2,<WORD>
endm
endif
?ex1 macro n,s,d
irp x,<n>
.xcref
.xcref ?T&&x
.cref
?T&&x=s
ife ?PLM
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
endm
endm
endif
ifndef ?NOLABEL
.XCREF
?lblpu = 0
.XCREF ?lb1,?lblpu
.CREF
labelB macro n
?lb1 <n>,1,<BYTE>
endm
labelW macro n
?lb1 <n>,2,<WORD>
endm
labelD macro n
?lb1 <n>,4,<DWORD>
endm
labelQ macro n
?lb1 <n>,8,<QWORD>
endm
labelT macro n
?lb1 <n>,10,<TBYTE>
endm
labelNP macro n
?lb1 <n>,2,<NEAR>
endm
labelFP macro n
?lb1 <n>,4,<FAR>
endm
if sizeC
labelP macro n
?lb1 <n>,4,<FAR>
endm
else
labelP macro n
?lb1 <n>,2,<NEAR>
endm
endif
if sizeC
labelCP macro n
?lb1 <n>,4,<DWORD>
endm
else
labelCP macro n
?lb1 <n>,2,<WORD>
endm
endif
if sizeD
labelDP macro n
?lb1 <n>,4,<DWORD>
endm
else
labelDP macro n
?lb1 <n>,2,<WORD>
endm
endif
?lb1 macro n,s,d
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?T&&x
.cref
?T&&x=s
ife ?PLM
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
defB macro n
?aD <n>,1
endm
defW macro n
?aD <n>,2
endm
defD macro n
?aD <n>,4
endm
defQ macro n
?aD <n>,8
endm
defT macro n
?aD <n>,10
endm
if sizeC
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sizeD
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?aD macro n,s
irp x,<n>
.xcref
.xcref ?T&&x
.cref
?T&&x=s
endm
endm
ifndef ?NOPTR
regPtr macro n,S,O
farPtr n,S,O
endm
farptr macro n,S,O
.xcref
.xcref ?T&n
.cref
n &macro
push S
push O
&endm
?T&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?Atal <x>,%?argc
endm
endm
?Atal macro n,i
.xcref
.xcref ?ALI&i
.cref
?ALI&i &macro
?AP n
&endm
endm
?AP macro n
?argl=?argl+2
ifdef ?T&n
ife ?T&n-1
push word ptr (n)
exitm
endif
ife ?T&n-2
push n
exitm
endif
ife ?T&n-4
push word ptr (n)+2
push word ptr (n)
?argl=?argl+2
exitm
endif
ife ?T&n-8
push word ptr (n)+6
push word ptr (n)+4
push word ptr (n)+2
push word ptr (n)
?argl=?argl+6
exitm
endif
if ?T&n AND 80h
n
?argl=?argl+2
exitm
endif
ife ?T&n
push word ptr (n)
exitm
endif
endif
push n
endm
ccall macro n,a,sleaze
ifnb <a>
Arg <a>
endif
mpush %?RSL
?argl=0
ife ?PLM
?ACB=?argc
else
?ACB=1
endif
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
ife ?PLM
?ACB=?ACB-1
else
?ACB=?ACB+1
endif
endm
ife ?PLM
ifb <sleaze>
call _&n
else
call n
endif
if ?argl
add sp,?argl
endif
else
call n
endif
mpop %?RSL
?RSL=0
?argc= 0
?argl= 0
endm
cProc macro n,c,a
if ?CPD
?UTPE
endif
?CPD=1
???=0
?argc=0
?BA=0
?PO=0
?PU=0
?IA=0
?adj=4
?RP=0
?UF=0
?WFP=0
?FF=0
?PAS=0
ifnb <a>
?RI ?PAS,<a>
endif
?PC=sizeC
?ND=?NODATA1
?NX=0
irp x,<c>
ifidn <x>,<FAR>
?PC=1
endif
ifidn <x>,<NEAR>
?PC=0
endif
ifidn <x>,<PUBLIC>
?PU=1
endif
ifidn <x>,<SMALL>
?UF=1
endif
ifidn <x>,<DATA>
?ND=0
endif
ifidn <x>,<NODATA>
?ND=1
endif
ifidn <x>,<ATOMIC>
?NX=1
endif
ifidn <x>,<FORCEFRAME>
?FF=1
endif
endm
if (?NX eq 1) AND (?ND eq 0)
?NX = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?PC
if ?WIN
?WFP=1
ife ?NX
?IA=2
?PAS = ?PAS AND (NOT ?ds)
endif
endif
?adj=?adj+2
endif
?PAS = ?PAS AND (NOT (?sp+?cs+?ss))
if ?UF
?PAS = ?PAS AND (NOT (?bp+?si+?di))
endif
ife ?PLM
?pg <_&n>,%?PU,%?PC,%?PAS,%?WFP,<n>
else
?pg <n>,%?PU,%?PC,%?PAS,%?WFP,<n>
endif
endm
?pg macro n,p,c,a,w,nu
.xcref
if ?UF
if ?RP
??error <parmR encountered in &n - user frame ignored>
?UF=0
endif
if ?ND
??error <NODATA encountered in &n - user frame ignored>
?UF=0
endif
endif
cBegin &macro g
.xcref
?pg1 <n>,c,a,%?PO,w,%?UF,%?ND,%?RP
?CPD=0
?argc=0
?BA=1
???=(???+1) AND 0FFFEH
if p
PUBLIC n
endif
ife ?PLM
ife c
nu label near
else
nu label far
endif
endif
ife c
n proc NEAR
else
n proc FAR
endif
ifidn <g>,<nogen>
if ???+?PO+a+?RP
%out <cBegin - possible invalid use of nogen>
endif
else
if ?UF
?MF c,%???,%?PO
mPush a
else
if w
ife ?ND
mov ax,ds
nop
endif
ife ?NX
ife ?DOS5
inc bp
endif
push bp
mov bp,sp
push ds
else
if ?FF+???+?PO+?RP
push bp
mov bp,sp
endif
endif
ife ?ND
mov ds,ax
endif
else
if ?FF+???+?PO+?RP
push bp
mov bp,sp
endif
endif
if ?RP
?UF=0
rept ?RP
uconcat mpush,,?RP,%?UF
?UF=?UF+1
endm
endif
if ???
if ?CHKSTK1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
mov ax,???
ife ?PLM
call _chkstk
else
call chkstk
endif
endif
else
sub sp,???
endif
endif
mPush a
endif
ifdef ?PROFILE
if c
call StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
?UTPE &macro
??error <Unterminated Procedure Definition: "&n">
&endm
endm
?pg1 macro n,c,a,o,w,f,d,r
.xcref
cEnd &macro g
.xcref
?BA=0
ifidn <g>,<nogen>
if o+a+r
%out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mPop a
if f
db 0C3h
else
if w
ife ?NX
if (?TF eq 0) OR (???+?RP)
lea sp,-2[bp]
endif
pop ds
pop bp
ife ?DOS5
dec bp
endif
else
if (?TF eq 0) OR (???+?RP)
mov sp,bp
endif
if ???+?PO+?RP
pop bp
endif
endif
else
if ?FF+???+?PO+?RP
if (?TF eq 0) OR (???+?RP)
mov sp,bp
endif
pop bp
endif
endif
ife ?PLM
ret
else
ret o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addSeg grp,n
else
ln&OFFSET equ OFFSET n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addSeg macro grp,seg
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
grp&_add &macro s
grp&_in <seg>,s
&endm
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defGrp macro grp,ln
addSeg grp
ifnb <ln>
?cs3 <ln>,<grp>
ln&OFFSET equ OFFSET grp:
ln&BASE equ grp
endif
endm
?cs1 macro ln,n
ln&_sBegin &macro
?MF &&macro c,l,p
if c
extrn n&_FARFRAME:near
call n&_FARFRAME
else
extrn n&_NEARFRAME:near
call n&_NEARFRAME
endif
db l shr 1
db p shr 1
&&endm
?cs2 <ln>,<n>
n segment
?segname equ <&n>
&endm
endm
?cs2 macro ln,n
sEnd &macro
n ends
purge ?MF
&endm
endm
?cs3 macro ln,n
ln&_assumes &macro s
assume s:&n
&endm
endm
sBegin macro ln
ln&_sBegin
endm
ife ?DF
createSeg _TEXT,code,word,public,CODE
ife ?NODATA1
createSeg _DATA,data,word,public,DATA,DGROUP
defGrp DGROUP,DATA
endif
if ?CHKSTK1
ifndef ?CHKSTKPROC
externP <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *ERRNZ* x1 = x2
endm
errn$ macro l,x
errnz <OFFSET $ - OFFSET l x>
ENDM
ifdef ?PROFILE
externFP <StartNMeas, StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\const.inc ===
;***
; const.inc - 13-Jul-87
;***
	.XLIST
;***
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	
; This include file contains constants for use with global flags.
;
;******************************************************************************


;	Equates for use with b$IOFLAG.

RED_INP		= 01H		; redirected input
RED_OUT		= 02H		; redirected output
LPR_ECHO	= 04H		; echo screen output to the line printer
F_KDSP		= 08H		; displaying function keys
IN_INPUT	= 10H		; output editing to screen and not to
				; 	printer or redirected stdout.
F_EDIT		= 20H		; in edit mode (in INPUT statement)
SCN_INIT	= 40H		; screen initialized -- screen IO done.
SCN_SCROLL	= 80H		; need to scroll the screen upon first
				; screen operation because we entered
				; on the last line of the screen.


;	Equates for use with b$CtrlFlags.

;[2]NoSTACKINIT = 01H		; disable B$STACKINIT
ULInited	= 02H		; User Library initialization done
TraceOn		= 04H		; Trace is on
DSwitch		= 08H		; /D specified
NoInitBcVars	= 10H		; Set if BC_VARS are already initialized
Detached	= 20H		;[7] Set if running as a DETACHed process


;	Equates for use with b$DebugFlags.  Added with [1].

BUF1_HELD	= 01H		; b$Buf1 is in use
BUF2_HELD	= 02H		; b$Buf2 is in use
BUF3_HELD	= 04H		; b$Buf3 is in use



;	Equates for use with b$DblFlags.  Added with [3]
;
; K_Interim_On must be 01H for INTERIM character support to work.  Many of
; the flags that were merged into this variable were local to a single
; file and could probably be overlaped if needed.
;

K_Interim_On	= 01H		;Are Interim characters currently on?  (0 = no)
K_Interim_Sup	= 02H		;Are we supporting Interim characters  (0 = no)
K_AddBlank	= 08H		;Do we replace last KANJI chr with ' ' (0 = no)
K_IgnBlank	= 10H		;Do we ignore blanks in our scan?      (0 = no)
K_Print 	= 20H		;Did we print the first half of a KANJI(0 = no)
K_FullMap	= 40H		;[5]Need to restore B$FIN scan pointer?(0 = no)

;	Equates for use with b$OGFlags.  Added with [6].

OGLine		= 0001H 	;Optional Line-drawing routine supported
OGBox		= 0002H 	;Optional Box-drawing routine supported
OGPutGet	= 0004H 	;Optional Put/Get routine supported
OGCircle	= 0008H 	;Optional Circle-drawing routine supported
OGCircleClip	= 0010H 	;Clipping and arbitrary aspect ratios supported
				;  in optional circle routine (not valid
				;  without OGCircle)
OGPaint 	= 0020H 	;Optional Painting routine supported
OGPaintClip	= 0040H 	;Viewport clipping supported in optional paint
				;  routine (not valid without OGPaint)
OGPaintTile	= 0080H 	;Tiling supported in optional paint routine
				;  (not valid without OGPaint)

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\dc.inc ===
;***
;dc.inc - 20-Mar-86 - dc macro definition
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

;       Data definition macros                  (formerly DATMAC.INC)

DC	MACRO	txt
	.xcref
__Pchr	=	0
	IRPC	chr,<txt>
IF	__Pchr
	DB	&__Pchr
	ENDIF
__Pchr	=	"&chr"
	ENDM
	DB	__Pchr+128
	.cref
	ENDM

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\devdef.inc ===
;***
; DEVDEF.INC - 08-Aug-86 - Device Independent I/O Definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

GENDEV	MACRO	dev,num
if	num
	nmdev=0
	REPT	num
	nmdev=nmdev+1
	DEVMAC	dev&%nmdev
	ENDM
endif
	ENDM

DEVNAM	MACRO
	DEVMAC	KYBD
	DEVMAC	SCRN
	DEVMAC	CONS

	GENDEV	COM,NUM_RS232
	GENDEV	LPT,NUM_LPT
	DEVMAC	PIPE
	ENDM


___DEV= -1

DEVMAC	MACRO	ARG
DN_&ARG= ___DEV
.xcref
___DEV= ___DEV-1
.cref
	ENDM

	DEVNAM


LAST_DEVICE_OFFSET= -2*___DEV	;All devices have lower offsets
	PAGE

DSPNAM	MACRO
	DSPMAC	EOF		;;EOF function
	DSPMAC	LOC		;;LOC function
	DSPMAC	LOF		;;LOF function
	DSPMAC	CLOSE		;;CLOSE statement
	DSPMAC	WIDTH		;;WIDTH statement
	DSPMAC	RANDIO		;;GET/PUT statements
	DSPMAC	OPEN		;;OPEN statement
	DSPMAC	BAKC		;;Backup character
	DSPMAC	SINP		;;Serial input
	DSPMAC	SOUT		;;Serial output
	DSPMAC	GPOS		;;Get current position
	DSPMAC	GWID		;;Get current width
	DSPMAC	DWID		;[8] Set device width
	DSPMAC	BLKIN		;;BLOCK INPUT
	DSPMAC	BLKOUT		;;BLOCK OUTPUT
	ENDM


;	Device Function Dispatch Table Offsets


DSPMAC	MACRO	func
ENT	DV_&func,2
	ENDM


ENTORG	0
	DSPNAM
ENT	DV_TABLEN,0

	PAGE

;	File Mode Definitions

	MD_RNDCH	EQU	10H	;[5]Random character device - PIPE.

;[b$ACCESS] - file ACCESS definitions

	ACCESS_NONE	EQU	0h	;[1]
	ACCESS_DEFAULT	EQU	0h	;[1]

;[b$LOCKTYPE] - file LOCK definitions	;[3]

	LOCK_COMPATIBLE EQU	00h	;[1]
	LOCK_DEFAULT	EQU	00h	;[1]

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\compvect.inc ===
;***
;compvect.inc - 03-Sep-86  -  Component vector dispatch table structures
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;	There are several dispatch tables that the runtime uses during
;	initialization and termination.  These tables contain addresses
;	of routines that need to be called during initialization or
;	termination.  The tables are initialized to contain ptrs to
;	B$NearRet which only contains a return.  The
;	tables get updated whenever crt0 (the c startup) indirectly
;	calls a runtime routine with its address in the XI segment.
;	The initialization routine that crt0 calls will update the
;	appropriate dispatch tables.  crt0 will call all routines
;	with addresses in the XI segment before _main gets called.
;	This allows us to build up the dispatch tables for _main,
;	and lets us call each initialization routine in an ordered
;	fashion.
;
;
;******************************************************************************

;
;	One time initialization dispatch vector table structure
;
INIT_VECTORS	STRUC
	NM_IVECS	DW	(SIZE INIT_VECTORS)/2-1 ;[21]Number of vectors
	RT_IVEC 	DW	B$NearRet	;ptr to Basic Core routine
	NH_IVEC 	DW	B$NearRet	;ptr to near heap routine
	FH_IVEC 	DW	B$NearRet	;ptr to far heap routine
	CN_IVEC 	DW	B$NearRet	;ptr to console I/O routine
	OS_IVEC 	DW	B$NearRet	;ptr to OS specific routine
	SN_IVEC 	DW	B$NearRet	;[12]ptr to sound routine
	DB_IVEC 	DW	B$NearRet	;ptr to debug routine
INIT_VECTORS	ENDS

;
;	One time termination dispatch vector table structure
;
TERM_VECTORS	STRUC
	NM_TVECS	DW	(SIZE TERM_VECTORS)/2-1 ;[21]Number of vectors
	SN_TVEC 	DW	B$NearRet	;[2]ptr to sound and music routine
	CN_TVEC 	DW	B$NearRet	;ptr to console I/O routine
	RT_TVEC 	DW	B$NearRet	;[15] Terminate Interrupt vects

TERM_VECTORS	ENDS

;
;	"RUN" time initialization dispatch vector table structure.
;
RUN_VECTORS	STRUC
	NM_RVECS	DW	(SIZE RUN_VECTORS)/2-1 ;[21]Number of vectors
	NH_RVEC 	DW	B$NearRet	;ptr to near heap routine
	FH_RVEC 	DW	B$NearRet	;ptr to far heap routine
	RT_RVEC 	DW	B$NearRet	;[14]ptr to Basic Core routine
	CN_RVEC 	DW	B$NearRet	;ptr to console I/O routine
	SN_RVEC 	DW	B$NearRet	;ptr to sound and music routine
	MT_RVEC 	DW	B$NearRet	;ptr to math routine
	GR_RVEC 	DW	B$NearRet	;ptr to graphics routine
	DV_RVEC 	DW	B$NearRet	;ptr to device io routine
	EV_RVEC 	DW	B$NearRet	;ptr to event routine
	DK_RVEC 	DW	B$NearRet	;[18]ptr to disk I/O routine
RUN_VECTORS	ENDS

;
;	"END" time termination dispatch vector table structure.
;
END_VECTORS	STRUC
	NM_EVECS	DW	(SIZE END_VECTORS)/2-1 ;[21]Number of vectors
	DK_EVEC 	DW	B$NearRet	;[18]ptr to disk io routine
END_VECTORS	ENDS

;
;	CLEAR statement "termination" dispatch vector table structure.
;
;	For the clear statement, "termination" are those activities which must
;	be cleaned up prior to the actual reallocation of memory, and the
;	movement of the stack pointer that occurs during the CLEAR statement.
;
CLRT_VECTORS	STRUC				;[1]
	NM_CLTVECS	DW	(SIZE CLRT_VECTORS)/2-1 ;[21] Number of vectors
	SN_CLTVEC	DW	B$NearRet	;[1]ptr to music routine
	DK_CLTVEC	DW	B$NearRet	;[18]ptr to disk io routine
	FH_CLTVEC	DW	B$NearRet	;[16] ptr to far heap routine
	NH_CLTVEC	DW	B$NearRet	;[16] ptr to Near Heap routine
CLRT_VECTORS	ENDS				;[1]

;
;	CLEAR statement initialization dispatch vector table structure.
;
;	For the CLEAR statement, "initialization" are those activities which
;	must occur to reinitialize the system after the stack has been moved,
;	and after memory has been reallocated.
;
CLR_VECTORS	STRUC
	NM_CVECS	DW	(SIZE CLR_VECTORS)/2-1 ;[21] Number of vectors
	RT_CVEC 	DW	B$NearRet	;ptr to Basic Core routine
	GR_CVEC 	DW	B$NearRet	;[4] ptr to graphics routine
	EV_CVEC 	DW	B$NearRet	;[10]ptr to event routine
CLR_VECTORS	ENDS

;
;	SHELL "initialization" dispatch vector table structure.
;
SHLI_VECTORS	STRUC
	NM_SIVECS	DW	(SIZE SHLI_VECTORS)/2-1 ;[21]Number of vectors
	DK_SIVEC	DW	B$NearRet	;[18]ptr to disk I/O routine
	CN_SIVEC	DW	B$NearRet	;ptr to console I/O routine
	FH_SIVEC	DW	B$NearRet	;ptr to far heap routine
	SN_SIVEC	DW	B$NearRet	;[8][3]ptr to sound routine
SHLI_VECTORS	ENDS

;
;	SHELL "termination" dispatch vector table structure.
;
SHLT_VECTORS	STRUC
	NM_STVECS	DW	(SIZE SHLT_VECTORS)/2-1 ;[21]Number of vectors
	SN_STVEC	DW	B$NearRet	;ptr to sound and music routine
	FH_STVEC	DW	B$NearRet	;ptr to far heap routine
	CN_STVEC	DW	B$NearRet	;ptr to console I/O routine
	DK_STVEC	DW	B$NearRet	;[18]ptr to device I/O routine
SHLT_VECTORS	ENDS

;
;	ERROR reset dispatch vector table structure
;
ERROR_VECTORS	STRUC				;[13]
	NM_ERVECS	DW	(SIZE ERROR_VECTORS)/2-1 ;[21]Number of vectors
	DK_ERVEC	DW	B$NearRet	;[18] disk IO
	XH_ERVEC	DW	B$NearRet	;[22] near heap or far heap,
						;..depending on version built
	GR_ERVEC	DW	B$NearRet	;[13] graphics
ERROR_VECTORS	ENDS				;[13]

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\error2.inc ===
;      SCCSID = @(#)error2.inc	8.11 87/03/23
;BREAK <CP/DOS error codes>

ERROR_INVALID_PROCID            EQU     303     ; invalid process id
ERROR_INVALID_PDELTA            EQU     304     ; invalid priority delta
ERROR_NOT_DESCENDANT            EQU     305     ; not descendant
ERROR_NOT_SESSION_MANAGER       EQU     306     ; requestor not session manager
ERROR_INVALID_PCLASS            EQU     307     ; invalid p class
ERROR_INVALID_SCOPE             EQU     308     ; invalid scope
ERROR_INVALID_THREADID          EQU     309     ; invalid thread id
ERROR_DOSSUB_SHRINK             EQU     310     ; can't shrink - MspSet
ERROR_DOSSUB_NOMEM              EQU     311     ; no memory - MspAlloc
ERROR_DOSSUB_OVERLAP            EQU     312     ; overlap - MspFree
ERROR_DOSSUB_BADSIZE            EQU     313     ; bad size parameter - MspAlloc or MspFree
ERROR_DOSSUB_BADFLAG            EQU     314     ; bad flag parameter - MspSet
ERROR_DOSSUB_BADSELECTOR        EQU     315     ; invalid MspSegment Selector
ERROR_MR_MSG_TOO_LONG           EQU     316     ; message too long for buffer
ERROR_MR_MID_NOT_FOUND          EQU     317     ; message id number not found
ERROR_MR_UN_ACC_MSGF            EQU     318     ; unable to access message file
ERROR_MR_INV_MSGF_FORMAT        EQU     319     ; invalid message file format
ERROR_MR_INV_IVCOUNT            EQU     320     ; invalid insertion variable count
ERROR_MR_UN_PERFORM             EQU     321     ; unable to perform function
ERROR_TS_WAKEUP                 EQU     322     ; unable to wake up
ERROR_TS_SEMHANDLE              EQU     323     ; user passed invalid system semaphore
ERROR_TS_NOTIMER                EQU     324     ; no times available
ERROR_TS_HANDLE                 EQU     326     ; invalid timer handle
ERROR_TS_DATETIME               EQU     327     ; date or time invalid
ERROR_SYS_INTERNAL              EQU     328     ; internal system error
ERROR_QUE_CURRENT_NAME          EQU     329     ; current name does not exist
ERROR_QUE_PROC_NOT_OWNED        EQU     330     ; current process does not own queue
ERROR_QUE_PROC_OWNED            EQU     331     ; current process owns queue
ERROR_QUE_DUPLICATE             EQU     332     ; duplicate name
ERROR_QUE_ELEMENT_NOT_EXIST     EQU     333     ; element does not exist
ERROR_QUE_NO_MEMORY             EQU     334     ; inadequate memory
ERROR_QUE_INVALID_NAME          EQU     335     ; invalid name
ERROR_QUE_INVALID_PRIORITY      EQU     336     ; invalid priority parameter
ERROR_QUE_INVALID_HANDLE        EQU     337     ; invalid queue handle
ERROR_QUE_LINK_NOT_FOUND        EQU     338     ; link not found
ERROR_QUE_MEMORY_ERROR          EQU     339     ; memory error
ERROR_QUE_PREV_AT_END           EQU     340     ; previous element was at end of queue
ERROR_QUE_PROC_NO_ACCESS        EQU     341     ; process does not have access to queues
ERROR_QUE_EMPTY                 EQU     342     ; queue is empty
ERROR_QUE_NAME_NOT_EXIST        EQU     343     ; queue name does not exist
ERROR_QUE_NOT_INITIALIZED       EQU     344     ; queues not initialized
ERROR_QUE_UNABLE_TO_ACCESS      EQU     345     ; unable to access queues
ERROR_QUE_UNABLE_TO_ADD         EQU     346     ; unable to add new queue
ERROR_QUE_UNABLE_TO_INIT        EQU     347     ; unable to initialize queues
ERROR_VIO_INVALID_MASK          EQU     349     ; invalid replacement mask
ERROR_VIO_PTR                   EQU     350     ; invalid pointer to parameter
ERROR_VIO_APTR                  EQU     351     ; invalid pointer to attribute
ERROR_VIO_RPTR                  EQU     352     ; invalid pointer to row
ERROR_VIO_CPTR                  EQU     353     ; invalid pointer to column
ERROR_VIO_LPTR                  EQU     354     ; invalid pointer to length
ERROR_VIO_MODE                  EQU     355     ; unsupported screen mode
ERROR_VIO_WIDTH                 EQU     356     ; invalid cursor width value
ERROR_VIO_ATTR                  EQU     357     ; invalid cursor attribute value
ERROR_VIO_ROW                   EQU     358     ; invalid row value
ERROR_VIO_COL                   EQU     359     ; invalid column value
ERROR_VIO_TOPROW                EQU     360     ; invalid toprow value
ERROR_VIO_BOTROW                EQU     361     ; invalid botrow value
ERROR_VIO_RIGHTCOL              EQU     362     ; invalid right column value
ERROR_VIO_LEFTCOL               EQU     363     ; invalid left column value
ERROR_SCS_CALL                  EQU     364     ; call issued by other than sm
ERROR_SCS_VALUE                 EQU     365     ; value is not for save or restore
ERROR_VIO_WAIT_FLAG             EQU     366     ; invalid wait flag setting
ERROR_VIO_UNLOCK                EQU     367     ; screen not previously locked
ERROR_SGS_NOT_SESSION_MGR       EQU     368     ; caller not session manager
ERROR_SMG_INVALID_SGID          EQU     369     ; invalid screen group id
ERROR_SMG_INVALID_SESSION_ID    EQU     369     ; invalid session id
ERROR_SMG_NOSG                  EQU     370     ; all screen groups in use
ERROR_SMG_NO_SESSIONS           EQU     370     ; no sessions available
ERROR_SMG_GRP_NOT_FOUND         EQU     371     ; screen group not found
ERROR_SMG_SESSION_NOT_FOUND     EQU     371     ; session not found
ERROR_SMG_SET_TITLE             EQU     372     ; title set by shell or parent cant be changed
ERROR_KBD_PARAMETER             EQU     373     ; invalid parameter to kbd
ERROR_KBD_NO_DEVICE             EQU     374     ; out of system handles
ERROR_KBD_INVALID_IOWAIT        EQU     375     ; invalid i/o wait specified
ERROR_KBD_INVALID_LENGTH        EQU     376     ; invalid length for keyboard
ERROR_KBD_INVALID_ECHO_MASK     EQU     377     ; invalid echo mode mask
ERROR_KBD_INVALID_INPUT_MASK    EQU     378     ; invalid input mode mask
ERROR_MON_INVALID_PARMS         EQU     379     ; invalid parameters to dos mon
ERROR_MON_INVALID_DEVNAME       EQU     380     ; invalid device name string
ERROR_MON_INVALID_HANDLE        EQU     381     ; invalid device handle
ERROR_MON_BUFFER_TOO_SMALL      EQU     382     ; buffer too small
ERROR_MON_BUFFER_EMPTY          EQU     383     ; buffer is empty
ERROR_MON_DATA_TOO_LARGE        EQU     384     ; data record too large
ERROR_MOUSE_NO_DEVICE           EQU     385     ; no mouse device attached
ERROR_MOUSE_INV_HANDLE          EQU     386     ; mouse device closed (invalid device handle)
ERROR_MOUSE_INV_PARMS           EQU     387     ; parameters invalid or out of range
ERROR_MOUSE_CANT_RESET          EQU     388     ; function assigned and cannot be reset
ERROR_MOUSE_DISPLAY_PARMS       EQU     389     ; parameters invalid for display mode
ERROR_MOUSE_INV_MODULE          EQU     390     ; module not found
ERROR_MOUSE_INV_ENTRY_PT        EQU     391     ; entry point not valid
ERROR_MOUSE_INV_MASK            EQU     392     ; function mask invalid
NO_ERROR_MOUSE_NO_DATA          EQU     393     ; no mouse data
NO_ERROR_MOUSE_PTR_DRAWN        EQU     394     ; pointer drawn
ERROR_INVALID_FREQUENCY         EQU     395     ; invalid frequency for beep
ERROR_NLS_NO_COUNTRY_FILE       EQU     396     ; can't find country.sys
ERROR_NLS_OPEN_FAILED           EQU     397     ; can't open country.sys
ERROR_NLS_NO_CTRY_CODE          EQU     398     ; country code not found
ERROR_NO_COUNTRY_OR_CODEPAGE    EQU     398     ; country code not found
ERROR_NLS_TABLE_TRUNCATED       EQU     399     ; table truncated, buffer too small
ERROR_NLS_BAD_TYPE              EQU     400     ; selector type does not exist
ERROR_NLS_TYPE_NOT_FOUND        EQU     401     ; selector type not in file
ERROR_VIO_SMG_ONLY              EQU     402     ; valid from session manager only
ERROR_VIO_INVALID_ASCIIZ        EQU     403     ; invalid asciiz length
ERROR_VIO_DEREGISTER            EQU     404     ; vio deregister disallowed
ERROR_VIO_NO_POPUP              EQU     405     ; popup not allocated
ERROR_VIO_EXISTING_POPUP        EQU     406     ; popup on screen (no wait)
ERROR_KBD_SMG_ONLY              EQU     407     ; valid from session manager only
ERROR_KBD_INVALID_ASCIIZ        EQU     408     ; invalid asciiz length
ERROR_KBD_INVALID_MASK          EQU     409     ; invalid replacement mask
ERROR_KBD_REGISTER              EQU     410     ; kbdregister disallowed
ERROR_KBD_DEREGISTER            EQU     411     ; kbdderegister disalloed
ERROR_MOUSE_SMG_ONLY            EQU     412     ; valid from session manager only
ERROR_MOUSE_INVALID_ASCIIZ      EQU     413     ; invalid asciiz length
ERROR_MOUSE_INVALID_MASK        EQU     414     ; invalid replacement mask
ERROR_MOUSE_REGISTER            EQU     415     ; mouse register disallowed
ERROR_MOUSE_DEREGISTER          EQU     416     ; mouse deregister disallowed
ERROR_SMG_BAD_ACTION            EQU     417     ; invalid action specified
ERROR_SMG_INVALID_CALL          EQU     418     ; init called more than once
ERROR_SCS_SG_NOTFOUND           EQU     419     ; new screen group #
ERROR_SCS_NOT_SHELL             EQU     420     ; caller is not shell
ERROR_VIO_INVALID_PARMS         EQU     421     ; invalid parms passed in
ERROR_VIO_FUNCTION_OWNED        EQU     422     ; save/restore already owned
ERROR_VIO_RETURN                EQU     423     ; non-destruct return (undo)
ERROR_SCS_INVALID_FUNCTION      EQU     424     ; not valid request for caller
ERROR_SCS_NOT_SESSION_MGR       EQU     425     ; caller not session manager
ERROR_VIO_REGISTER              EQU     426     ; VIO register disallowed
ERROR_VIO_NO_MODE_THREAD        EQU     427     ; No mode restore thread in SG
ERROR_VIO_NO_SAVE_RESTORE_THD   EQU     428     ; No save/rest thread in SG
ERROR_VIO_IN_BG                 EQU     429     ; Physical selector requested in background
ERROR_VIO_ILLEGAL_DURING_POPUP  EQU     430     ; Function not allowed during popup
ERROR_SMG_NOT_BASESHELL         EQU     431     ; caller is not the base shell
ERROR_SMG_BAD_STATUSREQ         EQU     432     ; invalid status requested
ERROR_QUE_INVALID_WAIT          EQU     433     ; nowait parameter out of bounds
ERROR_VIO_LOCK                  EQU     434     ; error returned from scrlock
ERROR_MOUSE_INVALID_IOWAIT      EQU     435     ; invalid parameters for IO wait
ERROR_VIO_INVALID_HANDLE        EQU     436     ; invalid vio handle
ERROR_VIO_ILLEGAL_DURING_LOCK   EQU     437     ; Function not allowed during screen lock
ERROR_VIO_INVALID_LENGTH        EQU     438     ; invalid vio length
ERROR_KBD_INVALID_HANDLE        EQU     439     ; invalid kbd handle
ERROR_KBD_NO_MORE_HANDLE        EQU     440     ; ran out of handles
ERROR_KBD_CANNOT_CREATE_KCB     EQU     441     ; unable to create kcb
ERROR_KBD_CODEPAGE_LOAD_INCOMPL EQU     442     ; unsuccessful codepage load
ERROR_KBD_INVALID_CODEPAGE_ID   EQU     443     ; invalid codepage id
ERROR_KBD_NO_CODEPAGE_SUPPORT   EQU     444     ; no codepage support
ERROR_KBD_FOCUS_REQUIRED        EQU     445     ; keyboard focus required
ERROR_KBD_FOCUS_ALREADY_ACTIVE  EQU     446     ; keyboard focus exists
ERROR_KBD_KEYBOARD_BUSY         EQU     447     ; keyboard busy
ERROR_KBD_INVALID_CODEPAGE      EQU     448     ; invalid codepage
ERROR_KBD_UNABLE_TO_FOCUS       EQU     449     ; focus attempt failed
ERROR_SMG_SESSION_NON_SELECT    EQU     450     ; session is not selectable
ERROR_SMG_SESSION_NOT_FOREGRND  EQU     451     ; parent/child session not foreground
ERROR_SMG_SESSION_NOT_PARENT    EQU     452     ; not parent of requested child
ERROR_SMG_INVALID_START_MODE    EQU     453     ; invalid session start mode
ERROR_SMG_INVALID_RELATED_OPT   EQU     454     ; invalid session start related option
ERROR_SMG_INVALID_BOND_OPTION   EQU     455     ; invalid session bond option
ERROR_SMG_INVALID_SELECT_OPT    EQU     456     ; invalid session select option
ERROR_SMG_START_IN_BACKGROUND   EQU     457     ; session started in background
ERROR_SMG_INVALID_STOP_OPTION   EQU     458     ; invalid session stop option
ERROR_SMG_BAD_RESERVE           EQU     459     ; reserved parameters not zero
ERROR_SMG_PROCESS_NOT_PARENT    EQU     460     ; session parent process already exists
ERROR_SMG_INVALID_DATA_LENGTH   EQU     461     ; invalid data length
ERROR_SMG_NOT_BOUND             EQU     462     ; parent not bound
ERROR_SMG_RETRY_SUB_ALLOC       EQU     463     ; retry request block allocation
ERROR_KBD_DETACHED              EQU     464     ; this call disallawed for detached pid
ERROR_VIO_DETACHED              EQU     465     ; this call disallawed for detached pid
ERROR_MOU_DETACHED              EQU     466     ; this call disallawed for detached pid
ERROR_VIO_FONT                  EQU     467     ; no font available to support mode
ERROR_VIO_USER_FONT             EQU     468     ; user font active
ERROR_VIO_BAD_CP                EQU     469     ; invalid code page specified
ERROR_VIO_NO_CP                 EQU     470     ; system displays don't support code page
ERROR_VIO_NA_CP                 EQU     471     ; current displays doesn't support code page
ERROR_INVALID_CODE_PAGE         EQU     472     ; invalid code page
ERROR_CPLIST_TOO_SMALL          EQU     473     ; code page list is too small
ERROR_CP_NOT_MOVED              EQU     474     ; code page not moved
ERROR_MODE_SWITCH_INIT          EQU     475     ; mode switch init error
ERROR_CODE_PAGE_NOT_FOUND       EQU     476     ; code page not found
ERROR_UNEXPECTED_SLOT_RETURNED  EQU     477     ; internal error
ERROR_SMG_INVALID_TRACE_OPTION  EQU     478     ; invalid start session trace indicator
ERROR_VIO_INTERNAL_RESOURCE     EQU     479     ; vio internal resource error
ERROR_VIO_SHELL_INIT            EQU     480     ; vio shell init error
ERROR_SMG_NO_HARD_ERRORS        EQU     481     ; no session manager hard errors

;
; intercomponent error codes (from 8000H or 32768)
;
ERROR_SWAPPER_NOT_ACTIVE        EQU     32768   ; swapper is not active
ERROR_INVALID_SWAPID            EQU     32769   ; invalid swap identifier
ERROR_IOERR_SWAP_FILE           EQU     32770   ; i/o error on swap file
ERROR_SWAP_TABLE_FULL           EQU     32771   ; swap control table is full
ERROR_SWAP_FILE_FULL            EQU     32772   ; swap file is full
ERROR_CANT_INIT_SWAPPER         EQU     32773   ; cannot initialize swapper
ERROR_SWAPPER_ALREADY_INIT      EQU     32774   ; swapper already initialized
ERROR_PMM_INSUFFICIENT_MEMORY   EQU     32775   ; insufficient memory
ERROR_PMM_INVALID_FLAGS         EQU     32776   ; invalid flags for phys. mem.
ERROR_PMM_INVALID_ADDRESS       EQU     32777   ; invalid address of phys. mem.
ERROR_PMM_LOCK_FAILED           EQU     32778   ; lock of storage failed
ERROR_PMM_UNLOCK_FAILED         EQU     32779   ; unlock of storage failed
ERROR_PMM_MOVE_INCOMPLETE       EQU     32780   ; move not completed
ERROR_UCOM_DRIVE_RENAMED        EQU     32781   ; drive name was renamed
ERROR_UCOM_FILENAME_TRUNCATED   EQU     32782   ; file name was truncated
ERROR_UCOM_BUFFER_LENGTH        EQU     32783   ; bad buffer length
ERROR_MON_CHAIN_HANDLE          EQU     32784   ; invalid chain handle - mon dh
ERROR_MON_NOT_REGISTERED        EQU     32785   ; monitor not registered
ERROR_SMG_ALREADY_TOP           EQU     32786   ; specified screen group is top
ERROR_PMM_ARENA_MODIFIED        EQU     32787   ; arena modified - phys mem
ERROR_SMG_PRINTER_OPEN          EQU     32788   ; printer open error on prtsc
ERROR_PMM_SET_FLAGS_FAILED      EQU     32789   ; update to arena header flags failed
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\error.inc ===
;	CP-DOS error codes
;
;	SCCSID = @(#)error.inc	1.5 87/12/16
;
; WARNING. If modifying this file may have to modify files
; src\h\error.h
; src\doscall1\dosio.asm
; src\cmd\bind\api\d_eclass.asm
;
; CP-DOS calls all return error codes through AX.  If an error occurred then
; the carry bit will be set and the error code is in AX.  If no error occurred
; then the carry bit is reset and AX contains returned info.
;
; Since the set of error codes is being extended as we extend the operating
; system, we have provided a means for applications to ask the system for a
; recommended course of action when they receive an error.
;
; The GetExtendedError system call returns a universal error, an error
; location and a recommended course of action.	The universal error code is
; a symptom of the error REGARDLESS of the context in which GetExtendedError
; is issued.

;
; These are the 2.0 error codes
;
NO_ERROR			EQU	0
ERROR_INVALID_FUNCTION		EQU	1
ERROR_FILE_NOT_FOUND		EQU	2
ERROR_PATH_NOT_FOUND		EQU	3
ERROR_TOO_MANY_OPEN_FILES	EQU	4
ERROR_ACCESS_DENIED		EQU	5
ERROR_INVALID_HANDLE		EQU	6
ERROR_ARENA_TRASHED		EQU	7
ERROR_NOT_ENOUGH_MEMORY 	EQU	8
ERROR_INVALID_BLOCK		EQU	9
ERROR_BAD_ENVIRONMENT		EQU	10
ERROR_BAD_FORMAT		EQU	11
ERROR_INVALID_ACCESS		EQU	12
ERROR_INVALID_DATA		EQU	13
;**** reserved			EQU	14	; *****
ERROR_INVALID_DRIVE		EQU	15
ERROR_CURRENT_DIRECTORY 	EQU	16
ERROR_NOT_SAME_DEVICE		EQU	17
ERROR_NO_MORE_FILES		EQU	18
;
; These are the universal int 24 mappings for the old INT 24 set of errors
;
ERROR_WRITE_PROTECT		EQU	19
ERROR_BAD_UNIT			EQU	20
ERROR_NOT_READY 		EQU	21
ERROR_BAD_COMMAND		EQU	22
ERROR_CRC			EQU	23
ERROR_BAD_LENGTH		EQU	24
ERROR_SEEK			EQU	25
ERROR_NOT_DOS_DISK		EQU	26
ERROR_SECTOR_NOT_FOUND		EQU	27
ERROR_OUT_OF_PAPER		EQU	28
ERROR_WRITE_FAULT		EQU	29
ERROR_READ_FAULT		EQU	30
ERROR_GEN_FAILURE		EQU	31
;
; These are the new 3.0 error codes reported through INT 24
;
ERROR_SHARING_VIOLATION 	EQU	32
ERROR_LOCK_VIOLATION		EQU	33
ERROR_WRONG_DISK		EQU	34
ERROR_FCB_UNAVAILABLE		EQU	35
ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
;
; New OEM network-related errors are 50-79
;
ERROR_NOT_SUPPORTED		EQU	50
ERROR_NETWORK_ACCESS_DENIED	EQU	65
;
; End of INT 24 reportable errors
;
ERROR_FILE_EXISTS		EQU	80
ERROR_DUP_FCB			EQU	81	; *****
ERROR_CANNOT_MAKE		EQU	82
ERROR_FAIL_I24			EQU	83
;
; New 3.0 network related error codes
;
ERROR_OUT_OF_STRUCTURES 	EQU	84
ERROR_ALREADY_ASSIGNED		EQU	85
ERROR_INVALID_PASSWORD		EQU	86
ERROR_INVALID_PARAMETER 	EQU	87
ERROR_NET_WRITE_FAULT		EQU	88
;
; New error codes for 4.0
;
ERROR_NO_PROC_SLOTS		EQU	89	; no process slots available
ERROR_NOT_FROZEN		EQU	90
ERR_TSTOVFL			EQU	91	; timer service table overflow
ERR_TSTDUP			EQU	92	; timer service table duplicate
ERROR_NO_ITEMS			EQU	93	; There were no items to operate upon
ERROR_INTERRUPT 		EQU	95	; interrupted system call

ERROR_TOO_MANY_SEMAPHORES	EQU	100	; user/sys open sem limit hit
ERROR_EXCL_SEM_ALREADY_OWNED	EQU	101	; exclusive sem already owned
ERROR_SEM_IS_SET		EQU	102	; SemClose found sem set
ERROR_TOO_MANY_SEM_REQUESTS	EQU	103	; too many exclusive sem reqs
ERROR_INVALID_AT_INTERRUPT_TIME EQU	104	; operation invalid at int time
ERROR_SEM_OWNER_DIED		EQU	105	; waitsem found owner died
ERROR_SEM_USER_LIMIT		EQU	106	; too many procs have this sem
ERROR_DISK_CHANGE		EQU	107	; insert disk b into drive a
ERROR_DRIVE_LOCKED		EQU	108	; drive locked by another process
ERROR_BROKEN_PIPE		EQU	109	; write on pipe with no reader
;
; New error codes for 5.0
;
ERROR_OPEN_FAILED		EQU	110	; open/created failed due to
						; explicit fail command
ERROR_BUFFER_OVERFLOW		EQU	111	; buffer passed to system call
						; is too small to hold return
						; data.
ERROR_DISK_FULL 		EQU	112	; not enough space on the disk
						; (DOSNEWSIZE/w_NewSize)
ERROR_NO_MORE_SEARCH_HANDLES	EQU	113	; can't allocate another search
						; structure and handle.
						; (DOSFINDFIRST/w_FindFirst)
ERROR_INVALID_TARGET_HANDLE	EQU	114	; Target handle in DOSDUPHANDLE
						; is invalid
ERROR_PROTECTION_VIOLATION	EQU	115	; Bad user virtual address
ERROR_VIOKBD_REQUEST		EQU	116
ERROR_INVALID_CATEGORY		EQU	117	; Category for DEVIOCTL in not
						; defined
ERROR_INVALID_VERIFY_SWITCH	EQU	118	; invalid value passed for
						; verify flag
ERROR_BAD_DRIVER_LEVEL		EQU	119	; DosDevIOCTL looks for a level
						; four driver.	If the driver
						; is not level four we return
						; this code
ERROR_CALL_NOT_IMPLEMENTED	EQU	120	; returned from stub api calls.
						; This call will disappear when
						; all the api's are implemented.
ERROR_SEM_TIMEOUT		EQU	121	; Time out happened from the
						; semaphore api functions.
ERROR_INSUFFICIENT_BUFFER	EQU	122	; Some call require the
					; application to pass in a buffer
					; filled with data.  This error is
					; returned if the data buffer is too
					; small.  For example: DosSetFileInfo
					; requires 4 bytes of data.  If a
					; two byte buffer is passed in then
					; this error is returned.
					; error_buffer_overflow is used when
					; the output buffer in not big enough.
ERROR_INVALID_NAME		EQU	123	; illegal character or malformed
						; file system name
ERROR_INVALID_LEVEL		EQU	124	; unimplemented level for info
						; retrieval or setting
ERROR_NO_VOLUME_LABEL		EQU	125	; no volume label found with
						; DosQFSInfo command
ERROR_MOD_NOT_FOUND		EQU	126	; w_getprocaddr,w_getmodhandle
ERROR_PROC_NOT_FOUND		EQU	127	; w_getprocaddr

ERROR_WAIT_NO_CHILDREN		EQU	128	; CWait finds to children

ERROR_CHILD_NOT_COMPLETE	EQU	129	; CWait children not dead yet

;This is a temporary fix for the 4-19-86 build this should be changed when
; we get the file from MS
ERROR_DIRECT_ACCESS_HANDLE	EQU	130	; handle operation is invalid
						; for direct disk access
						; handles
ERROR_NEGATIVE_SEEK		EQU	131	; application tried to seek
						; to negative offset
ERROR_SEEK_ON_DEVICE		EQU	132	; application tried to seek
						; on device or pipe
;
; The following are errors generated by the join and subst workers
;

ERROR_IS_JOIN_TARGET		EQU	133
ERROR_IS_JOINED 		EQU	134
ERROR_IS_SUBSTED		EQU	135
ERROR_NOT_JOINED		EQU	136
ERROR_NOT_SUBSTED		EQU	137
ERROR_JOIN_TO_JOIN		EQU	138
ERROR_SUBST_TO_SUBST		EQU	139
ERROR_JOIN_TO_SUBST		EQU	140
ERROR_SUBST_TO_JOIN		EQU	141
ERROR_BUSY_DRIVE		EQU	142
ERROR_SAME_DRIVE		EQU	143
ERROR_DIR_NOT_ROOT		EQU	144
ERROR_DIR_NOT_EMPTY		EQU	145
ERROR_IS_SUBST_PATH		EQU	146
ERROR_IS_JOIN_PATH		EQU	147
ERROR_PATH_BUSY 		EQU	148
ERROR_IS_SUBST_TARGET		EQU	149
ERROR_SYSTEM_TRACE		EQU	150	; system trace error

ERROR_INVALID_EVENT_COUNT	equ	151	; DosMuxSemWait errors
ERROR_TOO_MANY_MUXWAITERS	equ	152	;
ERROR_INVALID_LIST_FORMAT	equ	153	;
ERROR_LABEL_TOO_LONG		equ	154	; volume label is too big
ERROR_TOO_MANY_TCBS		equ	155	; can't create another tcb
						; in this PTDA
ERROR_SIGNAL_REFUSED		equ	156	; Signal refused
ERROR_DISCARDED 		equ	157	; segment is discarded
ERROR_NOT_LOCKED		equ	158	; segment was not locked
ERROR_BAD_THREADID_ADDR 	equ	159	; bad thread id address
ERROR_BAD_ARGUMENTS		equ	160	; bad environment pointer

						; passed to exec
ERROR_BAD_PATHNAME		equ	161	; bad pathname passed to exec
ERROR_SIGNAL_PENDING		equ	162	; signal already pending
ERROR_UNCERTAIN_MEDIA		equ	163	; ERROR_I24 mapping
ERROR_MAX_THRDS_REACHED 	equ	164	; No more proc slots
ERROR_MONITORS_NOT_SUPPORTED	equ	165	; ERROR_I24 mapping

;	following error code added for DOSGETRESOURCE [loader related]

ERROR_INVALID_SEGMENT_NUMBER	EQU	180

;	following error codes are used by FreeDynLink [loader]

ERROR_INVALID_CALLGATE		EQU	181
ERROR_INVALID_ORDINAL		EQU	182
ERROR_ALREADY_EXISTS		EQU	183
ERROR_NO_CHILD_PROCESS		EQU	184	; No child process to wait for
ERROR_INVALID_FLAG_NUMBER	EQU	186	; Invalid flag number
ERROR_SEM_NOT_FOUND		EQU	187	; Semaphore does not exist

;	following error codes have added  to make the loader error
;	messages distinct

ERROR_INVALID_STARTING_CODESEG		EQU	188
ERROR_INVALID_STACKSEG			EQU	189
ERROR_INVALID_MODULETYPE		EQU	190
ERROR_INVALID_EXE_SIGNATURE		EQU	191
ERROR_EXE_MARKED_INVALID		EQU	192
ERROR_BAD_EXE_FORMAT			EQU	193
ERROR_ITERATED_DATA_EXCEEDS_64k 	EQU	194
ERROR_INVALID_MINALLOCSIZE		EQU	195
ERROR_DYNLINK_FROM_INVALID_RING 	EQU	196
ERROR_IOPL_NOT_ENABLED			EQU	197
ERROR_INVALID_SEGDPL			EQU	198
ERROR_AUTODATASEG_EXCEEDS_64k		EQU	199
ERROR_RING2SEG_MUST_BE_MOVABLE		EQU	200
ERROR_RELOC_CHAIN_XEEDS_SEGLIM		EQU	201
ERROR_INFLOOP_IN_RELOC_CHAIN		EQU	202

ERROR_ENVVAR_NOT_FOUND			EQU	203
ERROR_NOT_CURRENT_CTRY			EQU	204
ERROR_NO_SIGNAL_SENT			EQU	205
ERROR_FILENAME_EXCED_RANGE		EQU	206	; if filename > 8.3
ERROR_RING2_STACK_IN_USE		EQU	207	; for FAPI
ERROR_META_EXPANSION_TOO_LONG		EQU	208	; if "*a" > 8.3
ERROR_INVALID_SIGNAL_NUMBER		EQU	209
ERROR_THREAD_1_INACTIVE 		EQU	210
ERROR_INFO_NOT_AVAIL			EQU	211 ;@@ PTM 5550
ERROR_LOCKED				EQU	212
ERROR_BAD_DYNALINK			EQU	213 ;@@ PTM 5760
ERROR_TOO_MANY_MODULES			EQU	214
ERROR_NESTING_NOT_ALLOWED		EQU	215

ERROR_CANNOT_SHRINK			EQU	216	;attempt made to shrink
							;ring 2 stack
ERROR_ZOMBIE_PROCESS			EQU	217
ERROR_STACK_IN_HIGH_MEMORY		EQU	218
ERROR_NO_CHILDREN			EQU	228
ERROR_INVALID_SCREEN_GROUP		EQU	229
;
; Error codes 230 - 249 are reserved for MS Networks
;

;	REMINDER: don't forget to update error.h

;
;	All user-defined error codes from device drivers are mapped into the
;	range 0xFF00 - 0xFFFF
;

ERROR_USER_DEFINED_BASE 	EQU	0FF00h



;	Device driver error codes

ERROR_I24_WRITE_PROTECT 		EQU	0
ERROR_I24_BAD_UNIT			EQU	1
ERROR_I24_NOT_READY			EQU	2
ERROR_I24_BAD_COMMAND			EQU	3
ERROR_I24_CRC				EQU	4
ERROR_I24_BAD_LENGTH			EQU	5
ERROR_I24_SEEK				EQU	6
ERROR_I24_NOT_DOS_DISK			EQU	7
ERROR_I24_SECTOR_NOT_FOUND		EQU	8
ERROR_I24_OUT_OF_PAPER			EQU	9
ERROR_I24_WRITE_FAULT			EQU	0Ah
ERROR_I24_READ_FAULT			EQU	0Bh
ERROR_I24_GEN_FAILURE			EQU	0Ch
ERROR_I24_DISK_CHANGE			EQU	0Dh
ERROR_I24_WRONG_DISK			EQU	0Fh
ERROR_I24_UNCERTAIN_MEDIA		EQU	10h
ERROR_I24_CHAR_CALL_INTERRUPTED 	EQU	11h
ERROR_I24_NO_MONITOR_SUPPORT		EQU	12h
ERROR_I24_INVALID_PARAMETER		EQU	13h

; THE FOLLOWING ARE MASKS FOR THE allowed action for hard error Daemon service

ALLOWED_FAIL			EQU	1h
ALLOWED_ABORT			EQU	2h
ALLOWED_RETRY			EQU	4h
ALLOWED_IGNORE			EQU	8h
ALLOWED_DETACHED		EQU	8000h

;NOTE: ABORT is ALWAYS allowed

I24_OPERATION			EQU	1h	;Z if READ,NZ if Write
I24_AREA			EQU	6h	; 00 if DOS
						; 01 if FAT
						; 10 if root DIR
						; 11 if DATA
I24_CLASS			EQU	80h	;Z if DISK, NZ if FAT or char

;	GetExtendedError CLASSes ACTIONs LOCUSs

; Values for error CLASS

ERRCLASS_OUTRES 	EQU	1	; Out of Resource
ERRCLASS_TEMPSIT	EQU	2	; Temporary Situation
ERRCLASS_AUTH		EQU	3	; Permission problem
ERRCLASS_INTRN		EQU	4	; Internal System Error
ERRCLASS_HRDFAIL	EQU	5	; Hardware Failure
ERRCLASS_SYSFAIL	EQU	6	; System Failure
ERRCLASS_APPERR 	EQU	7	; Application Error
ERRCLASS_NOTFND 	EQU	8	; Not Found
ERRCLASS_BADFMT 	EQU	9	; Bad Format
ERRCLASS_LOCKED 	EQU	10	; Locked
ERRCLASS_MEDIA		EQU	11	; Media Failure
ERRCLASS_ALREADY	EQU	12	; Collision with Existing Item
ERRCLASS_UNK		EQU	13	; Unknown/other
ERRCLASS_CANT		EQU	14	; Can't perform requested operation
ERRCLASS_TIME		EQU	15	; Timeout

; Values for error ACTION

ERRACT_RETRY		EQU	1	; Retry
ERRACT_DLYRET		EQU	2	; Delay Retry, retry after pause
ERRACT_USER		EQU	3	; Ask user to regive info
ERRACT_ABORT		EQU	4	; abort with clean up
ERRACT_PANIC		EQU	5	; abort immediately
ERRACT_IGNORE		EQU	6	; ignore
ERRACT_INTRET		EQU	7	; Retry after User Intervention

; Values for error LOCUS

ERRLOC_UNK		EQU	1	; No appropriate value
ERRLOC_DISK		EQU	2	; Random Access Mass Storage
ERRLOC_NET		EQU	3	; Network
ERRLOC_SERDEV		EQU	4	; Serial Device
ERRLOC_MEM		EQU	5	; Memory

; Abnormal termination codes

TC_NORMAL		EQU	0
TC_HARDERR		EQU	1
TC_GP_TRAP		EQU	2
TC_SIGNAL		EQU	3
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\exehdr.inc ===
;***
;exehdr.inc - 02-Sep-86 - EXE file header structure
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Defines structure for DOS 3 EXE file header.
;
;******************************************************************************

;	Structure for EXE file header area.

ExeHeader	STRUC

EHSignature	DW	?	;always 5A4DH for EXE files
EHcbLastPage	DW	?	;length of last page in bytes
EHcPages	DW	?	;number of pages (including last partial)
EHcRelocItems	DW	?	;number of relocations items
EHcpHeader	DW	?	;paragraph size of header and reloc table
EHcpMinExtra	DW	?	;minimum paragraphs needed after load image
EHcpMaxExtra	DW	?	;maximum paragraphs needed after load image
EHInitialSS	DW	?	;initial SS segment displacement
EHInitialSP	DW	?	;initial SP offset
EHChecksum	DW	?	;file checksum - negative sum of all words
EHInitialIP	DW	?	;initial IP offset
EHInitialCS	DW	?	;initial SS segment displacement
EHbpRelocStart	DW	?	;byte pointer to relocation items
EHcOverlay	DW	?	;overlay number (0 for resident)

ExeHeader	ENDS

ExeSignature	EQU	5A4DH		;legal signature for EXE files


;
; User Library header block description.
;
;  The first three pointers refer to a series of items containing information
;  concerning the symbols.  This is the TYPE code, symbol name string pointer,
;  and Long Pointer to the CODE/DATA/SEGMENT area.
;

UserLib_Hdr struc

Far_Jmp 	db 5 dup (?)	;[2]Skip the 5 byte far jump to __aulstart
QL_version	db	?	;[2]QLink version number
Magic_Word	dw	?	;[2]Magic word 'ul' for consistency checks.
Code_List	dw	?	;Near Offset to start of CODE symbols.
Data_List	dw	?	;Near Offset to start of DGROUP symbols.
Segment_List	dw	?	;Near Offset to start of SEGMENT symbols.
Code_Start	dw	?	;Segment Pointer to start of CODE in file.
Data_Start	dw	?	;Segment Pointer to start of DGROUP in file.
Sym_Start	dw	?	;Segment Pointer to start of SYMBOLS in file.
Sym_Size	dw	?	;Constant size of Symbol segment.
FData_Start	dw	?	;[2]Segment Pointer to start of FAR_DATA segments.
FData_Size	dd	?	;[2]Constant size of FAR_DATA segments.
FBss_Start	dw	?	;[2]Segment Pointer to start of FAR_BSS segments.
FBss_Size	dd	?	;[2]Constant size of FAR_BSS segments.

UserLib_Hdr ends

ULSignature	EQU	'lu'	;[2]legal magic word for user libraries
FARJMP		EQU	0EAH	;[2]opcode for Far jump at start of header

;
;  This is the description of the User Library symbol definitions.
;

UserLib_Sym struc

User_Type	dw	?	;Special code.
User_pzName	dw	?	;Offset to the zero terminated name string.
User_pName	dd	?	;Long Pointer to actual location.

UserLib_Sym ends

;
;  The following define the ordinals for the User_Type field
;

User_Type_Null		=	0	;terminates a list
User_Type_Code		=	1	;code item
User_Type_Data		=	2	;data item
User_Type_Segment	=	3	;segment item
User_Type_Common	=	4	;common segment
User_Type_Abs		=	5	;ABSolute symbol may be in with
					;DATA or SEGMENT symbols
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\global.inc ===
;***
;global.inc - 23-Jun-87 - Run-time Global Data Areas
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	 The data items defined here  must  appear  first  in  the  DATA
;	 segment  of  RT_DATA  because they must exactly match up between
;	 the linked program and the separately linked run-time module.
;
;******************************************************************************
;
; The following data is included in two places. In the runtime module it is
; uninitialized, while the version in the runtime module lib is initialized.
; During RTM all data is copied to user data space except for the data in this
; file. This allows the RTM, compiler, and c runtime to share a limited set of
; data.
;
DefData MACRO	t,nam,val
IFDEF	NO_INITDATA		;;[29]
	global&t nam,?		;; define global data space (uninitialized)
ELSE				;;[29] IFDEF FO_NOINIT
	global&t nam,<val>	;; define global data (initialized)
ENDIF				;;[29] IFDEF FO_NOINIT
;[29] WARNING:  this macro does NOT work right for more than one item on a line!
	ENDM

;[29] An EVEN directive causes problems in this file, since EVEN assembles a
;[29] 90H into the data (NOP opcode).  Don't want initialized data in some
;[29] cases (QB user libs), so we have the EVENMAC macro that generates
;[29] a DB ? instead of a NOP in order to word-align the data.
EVENMAC	MACRO
IF	(($ - DataStart) AND 1)	;;[29] if odd address
	DB	?		;;[29]    make it even
ENDIF				;;[29]
ENDM
;******************************************************************************
;
; Data from here to the start of saved common areas below is local and unique
; to each RTM user program. When a CHAIN occurs, this data is reloaded from the
; copy contained in the chained-to program.
;
;******************************************************************************
	INCLUDE array.inc	;[26]
	INCLUDE rtps.inc	;[28]constants shared with QBI
DataStart label byte		;[29]
	INCLUDE cdata.inc	;[15]include shared C startup data.


	DefData W,b$pend,<OFFSET DGROUP:_end>	      ;[3]End of static data
	DefData W,b$pendchk,<OFFSET DGROUP:_end+STACK_CHECK> ;[3]stack boundary
labelW	<PUBLIC,__bpBC_SAB>			;[32]
	DefData W,b$pBC_SAB,<OFFSET DGROUP:BC_SAB>   ;[3]Ucode start adresses
	DefData W,b$nmalloc_start,<OFFSET DGROUP:NMALLOC>;[12]
	DefData W,b$nmalloc_end,<OFFSET DGROUP:ENMALLOC> ;[12]

	DefData D,b$pULtoRTFar,B$ULtoRTFar ;[10]ptr to UL to RT far call helper
	DefData D,b$pULtoRTNear,B$ULtoRTNear ;[10]ptr to UL to RT near call helper




;******************************************************************************
;
; Data from here to b$CommonLast (which points at the end of the common in the
; user program), preserved across a DOS 3 CHAIN.
;
;******************************************************************************

	EVENMAC 	;[29] EVEN operation that doesn't generate a NOP
	labelW	<PUBLIC,b$RTMOverlayStart> ;[7]start of overlay for CHAIN

	globalB b$Chaining,0	;[6] flag for CHAIN processing
	globalW b$chaindata_len,? ;[6]length of RTM static data

;******************************************************************************
;
; Data from here to b$CommonLast (which points at the end of the common in the
; user program), preserved across a DOS 5 CHAIN.
;
;******************************************************************************

;	Program level

	globalW b$seg,?		;DEF SEG segment value

;	Floating point accumulator
labelB	<PUBLIC,$DAC>
labelB	<PUBLIC,$AC>
	globalB B$DAC,?,4	;double precision accumulator
	globalB B$AC,?,4	;single precision accumulator


labelW	<PUBLIC,b_ULSymSeg>		;Interpreter Reachable Symbol
	globalW b$ULSymSeg,0		;User Library symbol table segment
	globalW b$ULDataLength,0	;length of UL static data
	globalW b$ULDataStart,0	;[10]offset of UL static data in DGROUP
	globalB b$FHDULNearData,0,<SIZE FHD> ;FHD for UL near-data image
	globalB b$FHDULFarData,0,<SIZE FHD>  ;FHD for UL far-data image



	globalB b$CtrlFlags,0		; Misc. control flags
					; (bits defined in CONST.INC)
	globalW b$userflags,0		;compile time flags
	globalW b$mainframe,0		;Main level program BP
	globalW b$curframe,0		;Current program level BP
	globalW b$curlevel,0		;current program level

	globalD b$EVTRETV,0		;Event Trapping Return Dispatch
	labelW	<PUBLIC, b$?TYP>	; word label for b$TTYP and b$VTYP
	labelB <PUBLIC,B$VALTYP>	;
	globalB b$VTYP,0		; value type for print items
	globalB b$TTYP,0		; current type of print item

	globalB	b$LPTFDB,0,FDB_SIZE	; LPRINT file data block

;******************************************************************************
;
; The following data between the STARTZERO and STOPZERO labels gets zeroed on
; initialization, CHAIN, RUN, and CLEAR
;
;******************************************************************************
	EVENMAC		;[29] EVEN operation that doesn't generate a NOP
labelB	STARTZERO			;[10]

	globalW b$PUDS,,2		;[10]Print Using Descriptor

labelD	<PUBLIC,b_erradr>		;Intepreter reachable symbol
	globalD b$erradr,0		;[10]Error offset
labelD	<PUBLIC,b_errmod>		;Intepreter reachable symbol
	globalD b$errmod,0		;[10]pointer to error module name
labelW	<PUBLIC,b_errnum>		;Intepreter reachable symbol
	globalW b$errnum,0		;[10]Error number
labelW	<PUBLIC,b_errlin>		;Intepreter reachable symbol
	globalW b$errlin,0		;[10]Error line
	globalB b$inonerr,0		;[10]flag indicating an ON ERROR GOTO is
					;[10]is currently active.
	globalW b$PTRFIL,,1		;[10]Current File Pointer
	staticW unused,,1		;[46]keeping byte count the same
	globalW b$cCSubs,0		;[10]Count of active subs for compiler in interp
	globalW b$cNonQBIFrames,0	;[21]Count of non QBI frames on stack.
					;[21](that we know about)
labelB	STOPZERO			;[10]

	INCLUDE cdata3.inc		;[47] More shared C startup data.

;******************************************************************************
;
; The following label must be the last data item in this file.
;
;******************************************************************************

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\fdb.inc ===
;***
; fdb.inc - 31-Jul-87
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This include file contains the definition of the BASIC File Data Block.
;
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME and
;	NOTE: the interpreter projects.  Any changes made to one should
;	NOTE: be carried over (COPIED) to the other!!!
;
;******************************************************************************

FDB_INC = -1			;remember that this file has been included


FILE_DATA_BLOCK	STRUC

FD_MODE    	DB	0	;file mode of open
FD_HANDLE   	DW	0	;file handle
FD_DEVICE  	DB	0	;device number (0 for disks)
FD_WIDTH   	DB	0	;file width
FD_FLAGS   	DB	0	;miscellaneous bit flags (defined below)

; Storage for the the following fields, as well as for a buffer, is only
; present for disk files, PIPE:, COMn:, and XENIX LPRINT.

FD_VRECL   	DW	0	;record length/buffer size
FD_FSIZ_LO   	DW	0	;low word of file size (char dev only)
FD_FSIZ_HI   	DW	0	;high word of file size (char dev only)
FD_LOGREC  	DW	0	;current logical record number
FD_HIGHLR  	DW	0	;to be used for 32-bit record numbers
FD_BUFCNT	DW	0	;# of read/unwritten bytes in seq buffer
				;  (offset of next char in buffer)
FD_OUTPS  	DB	0	;output position for tab expansion
FD_BUFFER   	DB	1 DUP(0) ;buffer for random and sequential access.
				;complete pathname for disk files is stored
				;after the buffer.
FILE_DATA_BLOCK ENDS

;	FDB-related constants

FDB_SIZE    =	FD_VRECL	;[1] size of basic FDB, without buffer(s) or
				;[1] extra fields.
FD_INBUFCNT  =	FD_LOGREC	;# of bytes in the sequential input buffer

;[2]
;[2]FileDB used for transparent reference to FDB structure
;[2]
FileDB	EQU	[SI]		;[2]

;***
;FDB_PTR - macro to create an FDB pointer in registers
;
;Purpose:
;	Rewritten with [3].
;	This macro allows us to create a either a WORD or DWORD pointer
;	for FDB's depending on the FV_FARFDB switch.
;Entry:
;	seg  -	seg register to receive FDB segment address
;	reg  -	index register to receive actual FDB offset from handle/ptr
;		in srce; if not present, register is not loaded
;	srce -	source of handle/ptr for FDB;
;		if not present, register is not loaded
;
;	NOTE:  The equate for FileDB above assumes ES:SI for seg:reg!
;
;Exit:
;	seg:reg or reg contains the physical FDB pointer.
;Preserves:
;	All.
;
;**************************************************************************
FDB_PTR MACRO	seg,reg,srce
ifnb	<reg>
	.errb <srce>			;reg specified without srce
  ifdifi <reg>,<srce>
	mov	reg,srce		;;load reg from ptr/handle in srce
  endif
else
	.errnb <srce>			;;srce specified without reg
endif
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\files.inc ===
;***
; files.inc - 26-Aug-86
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; This include file specifies Macros and Equates used in common system library
; routines used by Xenix and DOS (C-Merge).
;
;******************************************************************************

	INCLUDE FDB.INC 	;[17]
;
;	These equates set up common definitions for things like stdin,
;	stdout, stderr, and error return values from library functions.
;
STDIN	=	0
STDOUT	=	1
STDERR	=	2
LIBERR	=	-1
;
;	MSDOS Operating System Function Codes
;
;	Note that these are also the names of the Xenix functions.  The
;	CALLOS macro for Xenix generates a 'call <name>', using the name.
;
C_TERM	=	0
C_LPTO	=	5		;output to line printer (PRN) device
C_DCIO	=	6
C_DCIN  =	7		;[20] wait for keyboard input
C_PRINT =	09
C_RDLIN =	10
C_FBRK  =	12		;[20] flush keyboard buffer, read keyboard
C_REST	=	13
C_SDRV	=	14
C_FOPEN =	15
C_FCLOS =	16
C_SEAR	=	17
C_DELE	=	19
C_SEQR	=	20
C_SEQW	=	21
C_MAKE	=	22
C_RENA	=	23
C_GDRV	=	25
C_BUFF	=	26
C_RNDR	=	33
C_RNDW	=	34
C_SETIV =	37
C_BLKR	=	39
C_BLKW	=	40
C_PARS	=	41
;
;	DOS 2.0 additions
;
C_VERSN =	48		;Get version number
C_CTRLC =	51		;Set control-c trapping
C_GETIV =	53		;Set interrupt vector
C_FREES =	54		;Get disk  free space
C_CHROP =	55		;Get character operators (switch char.)
C_MKDIR =	57		;Make directory
C_RMDIR =	58		;Remove directory
C_CHDIR =	59		;Change default directory
C_CREAT =	60		;Create file
C_OPEN	=	61		;Open file
C_CLOSE =	62		;Close file
C_READ	=	63		;Read file
C_WRITE =	64		;Write file
C_UNLINK =	65		;Remove file from directory
C_LSEEK =	66		;Seek to location
C_CHMOD =	67		;Change mode
C_IOCTL =	68		;i/o control
C_XDUP	=	69		;duplicate handle
C_XDUP2 =	70		;force duplicate handle
C_CURDIR =	71		;Current directory
C_ALLOC =	72		;allocate memory block
C_DEALLOC =	73		;deallocate memory block
C_SETBLK =	74		;set memory block
C_EXEC	=	75		;Execute program
C_EXIT	=	76		;exit program - return to calling
C_WAIT	=	77		;wait on something
C_FINDF =	78		;find first
C_FINDN =	79		;find next
C_RENAME =	86		;Rename source to dest.
C_LOCKING =	92		;Lock/Unlock system call
;
;	MS-DOS 2.0 error codes
;	Carry bit set on return from system call means the value in
;	AX indicates the following:
;
ERRIVF	=	1		;INVALID FUNCTION
ERRFNF	=	2		;FILE NOT FOUND
ERRPNF	=	3		;PATH NOT FOUND
ERRTMF	=	4		;TOO MANY OPEN FILES
ERRACD	=	5		;ACCESS DENIED
ERRIVH	=	6		;INVALID HANDLE
ERRART	=	7		;ARENA TRASHED
ERROEM	=	8		;NOT ENOUGH MEMORY
ERRIVB	=	9		;INVALID BLOCK
ERRBEN	=	10		;BAD ENVIRONMENT
ERRBFM	=	11		;BAD FORMAT
ERRIVA	=	12		;INVALID ACCESS
ERRIDT	=	13		;INVALID DATA
ERRIVD	=	15		;INVALID DRIVE
ERRCDR	=	16		;CURRENT DIRECTORY
ERRNSD	=	17		;NOT SAME DEVICE
ERRNMF	=	18		;NO MORE FILES
;
;	OS/2 additions
;
ERRSHR =	32		;[2] sharing error
ERRLCK =	33		;[2] locking error
ERROPF =	110		;[2] open/create failed due to explicit fail
MODE_HIGH_BYTE =60H		;[2] This is used in the high byte of the mode
				;[2] word for DOS 5.0 opens. It sets the File
				;[2] Write Through bit and the Fail bit.
;
;	MSDOS File attributes
;
ATTR_READONLY = 01H
ATTR_HIDDEN =	02H
ATTR_SYSTEM =	04H
ATTR_VOLUME =	08H
ATTR_SUBDIR =	10H
ATTR_ARCHIVE =	20H
;
;	Operating System dependent field sizes
;
EOFCHR	=	'Z' AND 1FH

	SUBTTL	CALLOS macro
	PAGE
;******************************************************************************
;
; CALLOS macro
;

CALLOS	MACRO	what,error,arg1,arg2,arg3,arg4
ifnb	<arg1>
ifdif	<arg1>,<bx>
	mov	bx,arg1
endif
endif
ifnb	<arg2>
ifdif	<arg2>,<cx>
	mov	cx,arg2
endif
endif
ifnb	<arg3>
ifdif	<arg3>,<dx>
	mov	dx,arg3
endif
endif
ifnb	<arg4>
ifdif	<arg4>,<ax>
	mov	ax,arg4
endif
endif
ifnb	<what>
ifdif	<what>,<ah>
	mov	ah,c_&what
endif
endif
	int	33
ifnb	<error>
	jb	error
endif
	ENDM
;

	SUBTTL	BASIC FDB
	PAGE

;******************************************************************************
;
;	Equates related to File Data Block usage
;

REC_LENGTH  =	128		;default FDB buffer size for random files
SEQ_BUF_LEN =	512		;default FDB buffer size for seq files

;	Equates for COMn:
FD_BAKC     =	FD_FSIZ_LO	;Holds backup char if FD_FLAGS & FL_BKC

;	Equates for PIPE:

FD_PIPEOUT  =	FD_HANDLE	;output pipe file handle
FD_PIPEIN   =	FD_FSIZ_LO	;input pipe file handle
FD_PID	    =	FD_FSIZ_HI	;process id for spawned pipe process
FD_CBIN     =	FD_HIGHLR	;count of bytes in input queue
FD_INOFF    =	FD_LOGREC	;[21] input position (cur pos=FD_CBIN-FD_INOFF)
FD_INBUF    =	FD_BUFFER + 1	;[22] beginning of pipe input buffer

;	FDB-related constants

;[19] FDB_SIZE    =	FD_VRECL ;size of basic FDB, without buffer(s) or
				;  extra fields.
FDB_EXTRA   =	FD_BUFFER - FD_VRECL ;additional space needed for extra fields

;
;	FD_FLAGS flags
;
FL_CONINP   =	01h		;[14] File is CONsole INPUT.
				;[14] DO NOT MOVE FL_CONINP FROM THE FIRST BIT.
FL_CONOUT   =	02h		;File is CONsole OUT.  This flag is needed
				;because DOS 2.0 handles DOS 2.0 (raw) writes
				;to CON out incorrectly.  DOS always reports
				;n-1 bytes written for a write of n bytes
				;[11] DO NOT MOVE FL_CONOUT FROM THE SECOND BIT.
FL_NEOF     =	04h		;[11] Not(eof reached on file) - used by com
FL_FIELD    =	08H		;[7] FIELD statement has been encountered
FL_BKC	    =	10H		;[11] FD_BAKC holds backup character (COMn:)
FL_LPT_OPN  =	10H		;[11] LPRINT FDB has been opened
				;[11] NOTE:  OK for these to share the same bit.
FL_BIN	    =	20H		;[14] File encoding [0..1]=[ASCII..BINARY]
FL_TRUNC    =	40H		;[19] Trunctate output file upon first write.
FL_CHAR     =	80h		;File is connected to character device
				;Note that this is the same bit as that
				;returned by the ioctl call for char/blk
				;[11] DO NOT MOVE FL_CHAR FROM THE EIGHTH BIT.

;	Equates for use with flag returned by B$GET_PATHNAME

FN_WILD     =	01H		;[11] wild card present in filename
FN_HAS_EXT  =	02H		;[11] file name has extention
FN_IS_DIR  =	04H		;[24] file name has ends with '\'


;	Equates for use with random I/O code (GET/PUT).

PutFlg	    =	01h		;[23] PUT call
RelFlg      =	02h		;[23] Record number specified
RecFlg      =	04h		;[23] Record variable specified
VarStrLen   =	08h		;[23] processing length of var len string
VarStrData   =	10h		;[23] processing data portion of var len string

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\graph.h ===
/***
*graph.h - declare constants, functions, and macros for graphics library
*
*   Copyright (c) 1987, 1988, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file declares the graphics library functions and
*   the manifest constants that are used with them.
*
***************************************************************************/

/* user-visible declarations for Quick-C Graphics Library */

#ifndef _GRAPH_T_DEFINED
/* structure for _getvideoconfig() as visible to user */
struct videoconfig {
	short numxpixels;	/* number of pixels on X axis */
	short numypixels;	/* number of pixels on Y axis */
	short numtextcols;	/* number of text columns available */
	short numtextrows;	/* number of text rows available */
	short numcolors;	/* number of actual colors */
	short bitsperpixel;	/* number of bits per pixel */
	short numvideopages;	/* number of available video pages */
	short mode;		/* current video mode */
	short adapter;		/* active display adapter */
	short monitor;		/* active display monitor */
	short memory;		/* adapter video memory in K bytes */
};

/* return value of _setvieworg(), etc. */
struct xycoord {
	short xcoord;
	short ycoord;
};

/* structure for text position */
struct rccoord {
	short row;
	short col;
};


#define _GRAPH_T_DEFINED
#endif

#ifndef NO_EXT_KEYS /* extensions enabled */
	#define _CDECL	cdecl
	#define _FAR	far
#else /* extensions not enabled */
    #ifdef M_I86LM /* large model */
	#define _CDECL
	#define _FAR
    #else
	#error -Za requires -AL when using graph.h
    #endif /* M_I86LM */
#endif /* NO_EXT_KEYS */


/* SETUP AND CONFIGURATION */

short _FAR _CDECL _setvideomode(short);
short _FAR _CDECL _setvideomoderows(short,short); /* return rows; 0 if error */

/* arguments to _setvideomode() */
#define _DEFAULTMODE	-1	/* restore screen to original mode */
#define _TEXTBW40	0	/* 40-column text, 16 grey */
#define _TEXTC40	1	/* 40-column text, 16/8 color */
#define _TEXTBW80	2	/* 80-column text, 16 grey */
#define _TEXTC80	3	/* 80-column text, 16/8 color */
#define _MRES4COLOR	4	/* 320 x 200, 4 color */
#define _MRESNOCOLOR	5	/* 320 x 200, 4 grey */
#define _HRESBW		6	/* 640 x 200, BW */
#define _TEXTMONO	7	/* 80-column text, BW */
#define _HERCMONO	8	/* 720 x 348, BW for HGC */
#define _MRES16COLOR	13	/* 320 x 200, 16 color */
#define _HRES16COLOR	14	/* 640 x 200, 16 color */
#define _ERESNOCOLOR	15	/* 640 x 350, BW */
#define _ERESCOLOR	16	/* 640 x 350, 4 or 16 color */
#define _VRES2COLOR	17	/* 640 x 480, BW */
#define _VRES16COLOR	18	/* 640 x 480, 16 color */
#define _MRES256COLOR	19	/* 320 x 200, 256 color */
#define _ORESCOLOR	64	/* 640 x 400, 1 of 16 colors (Olivetti) */

short _FAR _CDECL _setactivepage(short);
short _FAR _CDECL _setvisualpage(short);
short _FAR _CDECL _getactivepage(void);
short _FAR _CDECL _getvisualpage(void);

/* videoconfig adapter values */
/* these manifest constants can be used to determine the type of the active  */
/* adapter, using either simple comparisons or the bitwise-AND operator (&)  */
#define _MDPA		0x0001	/* Monochrome Display Adapter	      (MDPA) */
#define _CGA		0x0002	/* Color Graphics Adapter	      (CGA)  */
#define _EGA		0x0004	/* Enhanced Graphics Adapter	      (EGA)  */
#define _VGA		0x0008	/* Video Graphics Array		      (VGA)  */
#define _MCGA		0x0010	/* MultiColor Graphics Array	      (MCGA) */
#define _HGC		0x0020	/* Hercules Graphics Card	      (HGC)  */
#define _OCGA		0x0042	/* Olivetti Color Graphics Adapter    (OCGA) */
#define _OEGA		0x0044	/* Olivetti Enhanced Graphics Adapter (OEGA) */
#define _OVGA		0x0048	/* Olivetti Video Graphics Array      (OVGA) */

/* videoconfig monitor values */
/* these manifest constants can be used to determine the type of monitor in */
/* use, using either simple comparisons or the bitwise-AND operator (&) */
#define _MONO		0x0001	/* Monochrome */
#define _COLOR		0x0002	/* Color (or Enhanced emulating color) */
#define _ENHCOLOR	0x0004	/* Enhanced Color */
#define _ANALOGMONO	0x0008	/* Analog Monochrome only */
#define _ANALOGCOLOR	0x0010	/* Analog Color only */
#define _ANALOG		0x0018	/* Analog Monochrome and Color modes */

struct videoconfig _FAR * _FAR _CDECL _getvideoconfig(struct videoconfig _FAR *);



/* COORDINATE SYSTEMS */

struct xycoord _FAR _CDECL _setvieworg(short, short);
struct xycoord _FAR _CDECL _setlogorg(short, short); /* obsolescent */

struct xycoord _FAR _CDECL _getviewcoord(short, short);
struct xycoord _FAR _CDECL _getlogcoord(short, short); /* obsolescent */

struct xycoord _FAR _CDECL _getphyscoord(short, short);

void _FAR _CDECL _setcliprgn(short, short, short, short);
void _FAR _CDECL _setviewport(short, short, short, short);


/* OUTPUT ROUTINES */

/* control parameters for Rectangle, Ellipse and Pie */
#define _GBORDER	2	/* draw outline only */
#define _GFILLINTERIOR	3	/* fill using current fill mask */

#define _GCLEARSCREEN	0
#define _GVIEWPORT	1
#define _GWINDOW	2

void _FAR _CDECL _clearscreen(short);

struct xycoord _FAR _CDECL _moveto(short, short);
struct xycoord _FAR _CDECL _getcurrentposition(void);

short _FAR _CDECL _lineto(short, short);
short _FAR _CDECL _rectangle(short, short, short, short, short);
short _FAR _CDECL _ellipse(short, short, short, short, short);
short _FAR _CDECL _arc(short, short, short, short, short, short, short, short);
short _FAR _CDECL _pie(short, short, short, short, short, short, short, short, short);

short _FAR _CDECL _setpixel(short, short);
short _FAR _CDECL _getpixel(short, short);
short _FAR _CDECL _floodfill(short, short, short);


/* PEN COLOR, LINE STYLE, FILL PATTERN */

short _FAR _CDECL _setcolor(short);
short _FAR _CDECL _getcolor(void);

void _FAR _CDECL _setlinestyle(unsigned short);
unsigned short _FAR _CDECL _getlinestyle(void);

void _FAR _CDECL _setfillmask(unsigned char _FAR *);
unsigned char _FAR * _FAR _CDECL _getfillmask(unsigned char _FAR *);

/* COLOR SELECTION */

long _FAR _CDECL _setbkcolor(long);
long _FAR _CDECL _getbkcolor(void);

long _FAR _CDECL _remappalette(short, long);
short _FAR _CDECL _remapallpalette(long _FAR *);
short _FAR _CDECL _selectpalette(short);


/* TEXT */
#define _GCURSOROFF	0
#define _GCURSORON	1

#define _GWRAPOFF	0
#define _GWRAPON	1

short _FAR _CDECL _settextrows(short); /* returns # rows set; 0 if error */
void _FAR _CDECL _settextwindow(short, short, short, short);
void _FAR _CDECL _outtext(unsigned char _FAR *);
short _FAR _CDECL _wrapon(short);

short _FAR _CDECL _displaycursor(short);
short _FAR _CDECL _settextcursor(short);
short _FAR _CDECL _gettextcursor(void);

struct rccoord _FAR _CDECL _settextposition(short, short);
struct rccoord _FAR _CDECL _gettextposition(void);

short _FAR _CDECL _settextcolor(short);
short _FAR _CDECL _gettextcolor(void);


/* SCREEN IMAGES */

void _FAR _CDECL _getimage(short, short, short, short, char _FAR *);
void _FAR _CDECL _putimage(short, short, char _FAR *, short);
long _FAR _CDECL _imagesize(short, short, short, short);

/* "action verbs" for _putimage() */
#define _GPSET		3
#define _GPRESET	2
#define _GAND		1
#define _GOR		0
#define _GXOR		4

/* universal color values: */
#define _BLACK		0x000000L
#define _BLUE		0x2a0000L
#define _GREEN		0x002a00L
#define _CYAN		0x2a2a00L
#define _RED		0x00002aL
#define _MAGENTA	0x2a002aL
#define _BROWN		0x00152aL
#define _WHITE		0x2a2a2aL
#define _GRAY		0x151515L
#define _LIGHTBLUE	0x3F1515L
#define _LIGHTGREEN	0x153f15L
#define _LIGHTCYAN	0x3f3f15L
#define _LIGHTRED	0x15153fL
#define _LIGHTMAGENTA	0x3f153fL
#define _LIGHTYELLOW	0x153f3fL
#define _BRIGHTWHITE	0x3f3f3fL

/* mono mode F color values: */
#define _MODEFOFF	0L
#define _MODEFOFFTOON	1L
#define _MODEFOFFTOHI	2L
#define _MODEFONTOOFF	3L
#define _MODEFON	4L
#define _MODEFONTOHI	5L
#define _MODEFHITOOFF	6L
#define _MODEFHITOON	7L
#define _MODEFHI	8L

/* mono mode 7 color values: */
#define _MODE7OFF	0L
#define _MODE7ON	1L
#define _MODE7HI	2L


/* WINDOW COORDINATE SYSTEM */

/* structure for window coordinate pair */
struct _wxycoord {
	double wx;	/* window x coordinate */
	double wy;	/* window y coordinate */
	};


/* define real coordinate window - returns non-zero if successful */
short _FAR _CDECL _setwindow(short,double,double,double,double);

/* convert from view to window coordinates */
struct _wxycoord _FAR _CDECL _getwindowcoord(short,short);
struct _wxycoord _FAR _CDECL _getwindowcoord_xy(struct xycoord);

/* convert from window to view coordinates */
struct xycoord _FAR _CDECL _getviewcoord_w(double,double);
struct xycoord _FAR _CDECL _getviewcoord_wxy(struct _wxycoord _FAR *);

/*	return the window coordinates of the current graphics output
	position as an _wxycoord structure. no error return. */
struct _wxycoord _FAR _CDECL _getcurrentposition_w(void);


/* window coordinate entry points for graphics output routines */

#define _arc_wxy(pwxy1, pwxy2, pwxy3, pwxy4) \
	_arc_xy(_getviewcoord_wxy(pwxy1), _getviewcoord_wxy(pwxy2), \
		_getviewcoord_wxy(pwxy3), _getviewcoord_wxy(pwxy4))

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _arc_xy(struct xycoord,struct xycoord,struct xycoord,struct xycoord);


#define _ellipse_w(control, wx1, wy1, wx2, wy2) _ellipse_xy(control, \
		_getviewcoord_w(wx1,wy1), _getviewcoord_w(wx2,wy2))

#define _ellipse_wxy(control, pwxy1, pwxy2) _ellipse_xy(control, \
	_getviewcoord_wxy(pwxy1), _getviewcoord_wxy(pwxy2))

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _ellipse_xy(short,struct xycoord,struct xycoord);


#define _floodfill_w(wx, wy, boundary) \
	_floodfill_xy(_getviewcoord_w(wx,wy), boundary)

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _floodfill_xy(struct xycoord, short);


#define _getpixel_w(wx, wy) \
	_getpixel_xy(_getviewcoord_w(wx,wy))

/*	returns pixel value at given point; -1 if unsuccessful. */
short _FAR _CDECL _getpixel_xy(struct xycoord);


#define _lineto_w(wx, wy) \
	_lineto_xy(_getviewcoord_w(wx,wy))

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _lineto_xy(struct xycoord);


#define _moveto_w(wx, wy) \
	_getwindowcoord_xy(_moveto_xy(_getviewcoord_w(wx,wy)))

/*	returns the view coordinates of the previous output
	position as an _xycoord structure. no error return */
struct xycoord _FAR _CDECL _moveto_xy(struct xycoord);


#define _pie_wxy(control, pwxy1, pwxy2, pwxy3, pwxy4) _pie_xy(control, \
		_getviewcoord_wxy(pwxy1), _getviewcoord_wxy(pwxy2), \
		_getviewcoord_wxy(pwxy3), _getviewcoord_wxy(pwxy4))

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _pie_xy(short,struct xycoord,struct xycoord,struct xycoord,struct xycoord);


#define _rectangle_w(control, wx1, wy1, wx2, wy2) _rectangle_xy(control, \
		_getviewcoord_w(wx1,wy1), _getviewcoord_w(wx2,wy2))

#define _rectangle_wxy(control, pwxy1, pwxy2) _rectangle_xy(control, \
		_getviewcoord_wxy(pwxy1), _getviewcoord_wxy(pwxy2))

/*	returns nonzero if successful; otherwise 0	*/
short _FAR _CDECL _rectangle_xy(short,struct xycoord,struct xycoord);


#define _setpixel_w(wx, wy) \
	_setpixel_xy(_getviewcoord_w(wx,wy))

/*	returns previous color; -1 if unsuccessful */
short _FAR _CDECL _setpixel_xy(struct xycoord);


/* window coordinate image routines */
#define _getimage_w( wx1, wy1, wx2, wy2, buffer) \
		_getimage_xy( _getviewcoord_w(wx1,wy1), \
		_getviewcoord_w(wx2,wy2), buffer)

#define _getimage_wxy( pwxy1, pwxy2, buffer) \
		_getimage_xy( _getviewcoord_wxy(pwxy1), \
		_getviewcoord_wxy(pwxy2), buffer)

/*	no return value */
void _FAR _CDECL _getimage_xy(struct xycoord,struct xycoord, char _FAR *);


#define _imagesize_w( wx1, wy1, wx2, wy2) _imagesize_xy( \
		_getviewcoord_w(wx1,wy1), _getviewcoord_w(wx2,wy2))

#define _imagesize_wxy( pwxy1, pwxy2) _imagesize_xy( \
		_getviewcoord_wxy(pwxy1), _getviewcoord_wxy(pwxy2))

/*	returns the image's storage size in bytes */
long _FAR _CDECL _imagesize_xy(struct xycoord,struct xycoord);


#define _putimage_w(wx, wy, image, action) \
	_putimage_xy(_getviewcoord_w(wx,wy), image, action)

/*	no return value */
void _FAR _CDECL _putimage_xy(struct xycoord,char _FAR *,short);


/* FONTS */

struct _fontinfo {
	int	type;		/* b0 set = vector,clear = bit map	*/
	int	ascent;		/* pix dist from top to baseline	*/
	int	pixwidth;	/* character width in pixels, 0=prop	*/
	int	pixheight;	/* character height in pixels		*/
	int	avgwidth;	/* average character width in pixels	*/
	char	filename[66];	/* file name including path		*/
	char	facename[32];	/* font name				*/
};
short	_FAR _CDECL	_registerfonts( unsigned char _FAR *);
void	_FAR _CDECL	_unregisterfonts( void );
short	_FAR _CDECL	_setfont( unsigned char _FAR * );
short	_FAR _CDECL	_getfontinfo( struct _fontinfo _FAR * );
void	_FAR _CDECL	_outgtext( unsigned char _FAR * );
short	_FAR _CDECL	_getgtextextent( unsigned char _FAR * );
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\event.inc ===
;***
; event.inc - 20-Mar-86 - functions to oem trapping routines
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

	enable_trap = 254
	disable_trap= 255

;music
	set_note_cnt= 2

;timer
	set_interval= 1

;keys
	define_key =   1
	start_key = 252
	stop_key = 253

	Printer_Echo= -3	;define parameters for special keys
	Pause_Key =  -2
	Ctl_Break =  -1

;[3]start of stuff moved from switch.inc

NUM_TRAPDEV = 0 		;Number of trappable devices

NUM_JOYST =	0		;Default number of joystick triggers
NUM_JOYST =	4		;Number of joystick triggers
JOYST_IND =   NUM_TRAPDEV	;Dispatch table index for joystick
NUM_TRAPDEV = NUM_TRAPDEV + 1	;[5] Number of trappable devices
;[5] HACK -- for OS/2, would be better not to waste the slots marked with
;[5] HACK -- [5], but it would either require separate assembly, or
;[5] HACK -- changing the polling order.

NUM_LITEPEN =	0		;Default number of lightpens supported
NUM_LITEPEN =	1		;Number of lightpens supported
LITEPEN_IND = NUM_TRAPDEV	;Dispatch table index for litepen
NUM_TRAPDEV = NUM_TRAPDEV + 1	;[5] Number of trappable devices

NUM_MOUSE =	 0		;Default number of MOUSE events supported

NUM_UEVENT =	0		;Default number of user defined events

RS232_IND =   NUM_TRAPDEV	;Dispatch table index for rs232
NUM_TRAPDEV = NUM_TRAPDEV + 1	;Number of trappable devices

NUM_SIGNAL =	 0		;Default number of SIGNALs supported

NUM_SOUND =	0		;Default number of PLAY events
NUM_SOUND =	1		;Number of PLAY events
SOUND_IND =   NUM_TRAPDEV	;Dispatch table index for sound

;[5]HACK: this works since SOUND and SIGNAL are mutually exclusive
NUM_TRAPDEV = NUM_TRAPDEV + 1	;[5] Number of trappable devices

NUM_TIMER =	0		;Default number of TIMER events
NUM_TIMER =	1		;Number of timer events
TIMER_IND =   NUM_TRAPDEV	;Dispatch table index for timer
NUM_TRAPDEV = NUM_TRAPDEV + 1	;number of trappable devices

NUM_UKEYS =	11		;Number of user-defined keys for trapping
NUM_GAP =	4		;number of gap in between the last user
				; defined key and F11
NUM_TKEYS =	0		;Default number of trappable keys
NUM_TKEYS =	NUM_FKEYS + 4 + NUM_UKEYS + NUM_GAP
				;there is a gap between the last user
				; defined key and F11
				;Number of trappable keys
				;Function + Direction + User-defined
TKEYS_IND =   NUM_TRAPDEV	;Dispatch table index for key trapping
NUM_TRAPDEV = NUM_TRAPDEV + 1	;number of trappable devices

NUM_TRAPS =	NUM_TKEYS + NUM_RS232 + NUM_LITEPEN + NUM_SIGNAL
NUM_TRAPS =	NUM_TRAPS + NUM_JOYST + NUM_TIMER + NUM_SOUND
NUM_TRAPS =	NUM_TRAPS + NUM_MOUSE + NUM_UEVENT
				;Total number of trappable conditions
;[3]end of stuff moved from switch.inc

;[1]	Equates for use with b$EventFlags.

InSLEEP		= 01H		; SLEEP statement is waiting for an event
SLEEPtmr	= 02H		; SLEEP timeout timer is enabled
PAUSEF		= 04H		; ^S, ^Q flag
CNTLC		= 08H		; CTRL-BREAK encountered 
TimerInst	= 10H		; Timer interrupt installed
KybdInst	= 20H		;[6] keyboard interrupt installed

;[1] Event Action Verbs: ON, OFF and STOP

$ON=	0			;Event ON
$OFF=	1			;Event OFF
$STOP=	2			;Event STOP

;[1] Trap Table Event Action Masks.

TRP_ON= 1			;Event Trap ON.
TRP_ST= 2			;Event Trap STOP.
TRP_RQ= 4			;Event Trap Request.
TRP_OS= TRP_ON+TRP_ST		;Event Trap ON or STOPed
TRP_CN= 80H			;Context bit (0=comp handler !0 = interp)
TRP_MSK = 7FH			;Mask out Context bit

;[1] Offsets into b$TRPTBL for Event Traps.

;[4] The IFDEF's are so that files that only refer to the first few
;[4] ones don't need to have separate DOS3-OS/2 versions, but we will
;[4] detect it if any of the OS-dependent ones are referenced.

COMOFF= 0

KEYOFF= COMOFF+NUM_RS232

TIMOFF= KEYOFF+NUM_TKEYS

MOUOFF= TIMOFF+NUM_TIMER

UEVOFF= MOUOFF+NUM_MOUSE

PENOFF= UEVOFF+NUM_UEVENT

PLAOFF= PENOFF+NUM_LITEPEN

STGOFF= PLAOFF+NUM_SOUND

SIGOFF= STGOFF+NUM_JOYST

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\idmac.inc ===
;***
; IDMAC.INC - 1-Apr-87 - Internal Debugging Macros
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	To provide a simple, consistent interface to internal debugging
;	code via macros; these macros allow minimal muddying of source
;	code, yet provide the ability to make runtime assertion checks,
;	and give useful status information on failure.
;
;******************************************************************************


DbHalt MACRO	seg,message
	ENDM
DbAssertRel MACRO	parm1,arel,parm2,seg,message
	ENDM
DbAssertRelB MACRO	parm1,arel,parm2,seg,message
	ENDM
DbAssertFlags MACRO	arel,seg,message
	ENDM
DbAssertTst MACRO	parm1,arel,parm2,seg,message
	ENDM
DbChk	MACRO	name,parms
	ENDM
DbPub	MACRO	ep
	ENDM
DJMP	MACRO	op,parm1,parm2
	op	parm1 parm2
ENDM


.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\egaint10.inc ===
;***
; EGAINT10 - Source for EGAINT10 driver
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This driver for the EGAINT10 interface allows the EGA registers
;	to be read as well as written.	It is loaded only if a valid
;	EGA.SYS or MOUSE.SYS driver containing the interface is not
;	detected during initialization.
;
;******************************************************************************
;
;	SCCSID = @(#)egaint10.inc	5.6 87/06/23

;-----------------------------------------------------------------------------;
;   brian conte                                                 12/24/84      ;
;   egaint10.inc                                                v1.40         ;
;   steve shaiman (mod to RevertDefault for glitch in           11/11/85      ;
;                  in graphics controller misc. register)       v1.50         ;
;   steve shaiman (mod to ChangeRegs to clear the direction      2/14/86      ;
;                  flag instead of assuming it's cleared)       v1.51         ;
;   steve shaiman (made Int10Vector, ChangeRegs, Int10Routine    2/21/86      ;
;                  public as needed by erice)                   v1.52         ;
;   steve shaiman (mod to RevertDefault for glitch in            6/09/86      ;
;                  in sequencer clocking mode register)         v1.53         ;
;   steve shaiman (added GetDefault as function f8)             10/30/86      ;
;                 (added SimWriteReg & SimWriteSet for use      v1.60         ;
;                  by routines that intercept standard Int 10                 ;
;                  calls and want to modify the shadow regs                   ;
;		   but not the actual hardware regs)			      ;
;		  (added int 10h bios support for functions		      ;
;		   5 [set display page], b [set CGA palette		      ;
;		   registers] & 10 [set EGA palette registers]		      ;
;	      jtp (fixed bug in SetEgaPalette to split 17-byte	 4/01/87      ;
;		   update into two updates)				      ;
;	      jtp (incorporated various bug fixes, primarily to 	      ;
;		   SetCgaPalette and SetEgaPalette Int hooks)	 4/12/87      ;
;	      jtp (optimized Int10Routine to minimize time		      ;
;		   spent on ignored functions, and optimized		      ;
;		   the rep-movsw's in the egaint10 functions)    4/12/87      ;
;	      jtp (added kludge to RevertDefault to update		      ;
;		   Bios data areas too, for Word /C operation)	 5/24/87      ;
;                                                                             ;
;   egaint10 is an interface to the ega card which allows all of the w/o      ;
;   registers to be read from as well as written to.  this is a requirement   ;
;   in order to use interrupt-driven graphics (such as cursor update code).   ;
;   interrupt-driven graphics can be implemented on the ega if both the       ;
;   synchronous app and the interrupt code use the egaint10 interface         ;
;   to the ega registers.  the microsoft mouse driver (version 3.0 and        ;
;   greater) uses the egaint10 interface to the ega card.                     ;
;                                                                             ;
;   this file contains the code that intercepts the int 10's and keeps        ;
;   shadow maps of all ega registers so that these registers can be           ;
;   read as well as written.  note that the primary consideration was         ;
;   speed, some of the calls need to be made in tight graphics loops.  for    ;
;   this reason, the interface may seem arbitrary and the code may seem       ;
;   unnecessarily "tricky" at time.  i've tried to document all such          ;
;   instances.  also keep in mind that there is no error checking of          ;
;   parameters.  illegal parameters may cause unpredictable results,          ;
;   including possibly a system crash.                                        ;
;                                                                             ;
;   this code may be used in a standalone driver, or may be incorporated      ;
;   into an app or another driver if desired.  here are the requirements      ;
;   for using this code:                                                      ;
;                                                                             ;
;               include the file inside your code segment.                    ;
;                                                                             ;
;               put the current screen mode in ah, and bits 7:4 of the        ;
;               crtc io address ("b" for "3b4", "d" for "3d4) into bits 7:4   ;
;               of al, set ds to zero, and then call "ChangeRegs".            ;
;                                                                             ;
;               get the current int 10 vector and save it in "Int10Vector".   ;
;                                                                             ;
;               set the int 10 vector to point to cs:Int10Routine.            ;
;                                                                             ;
;               after this, regular int 10 and extended int 10 calls may      ;
;               be executed as desired.                                       ;
;                                                                             ;
;   the code that does this in the ega.sys standalone driver follows:         ;
;                                                                             ;
;               xor     ax,ax                                                 ;
;               mov     ds,ax                                                 ;
;               mov     ah,ds:[449h]                                          ;
;               mov     al,byte ptr ds:[463h]                                 ;
;               and     al,11110000b                                          ;
;               call    ChangeRegs                                            ;
;               mov     ax,cs                                                 ;
;               mov     ds,ax                                                 ;
;               assume  ds:Code                                               ;
;               mov     ax,3510h                                              ;
;               int     21h                                                   ;
;               mov     word ptr [Int10Vector],bx                             ;
;               mov     word ptr [Int10Vector+2],es                           ;
;               mov     ax,2510h                                              ;
;               mov     dx,offset Int10Routine                                ;
;               int     21h                                                   ;
;                                                                             ;
;   eventually ega.sys will intercept all bios calls and update its tables.   ;
;   right now it only intercepts calls to set the mode (ah=0).                ;
;                                                                             ;
;   ega.sys is reentrant.  this means that it is legal for an interrupt       ;
;   routine to call ega.sys while the synchronous program is in the middle of ;
;   one of its calls to ega.sys.  [currently, this is only true if the        ;
;   interrupt routine only saves and restores registers (ie makes no permanent;
;   changes) but this could be changed to accomodate interrupt routines that  ;
;   make permanent changes (eg an interrupt routine that changed the palette  ;
;   on a vertical retrace).]                                                  ;
;                                                                             ;
;   a special note about the attribute chip registers:  the flip-flop which   ;
;   determines whether 3c0 is the address or data register must be set to     ;
;   "address" before making extended int 10 calls.  it will always be left    ;
;   in the "address" state on return.  interrupt code must be sure to set     ;
;   the flip flop to "address" before using attribute registers, and to       ;
;   return it to "address" on return.  any code which sets the flip flop      ;
;   to "data" and then depends on it being set that way must disable          ;
;   interrupts for the length of time between setting it to "data" and the    ;
;   last time it is assumed to be "data".                                     ;
;                                                                             ;
;   this code knows nothing about the sequencer memory mode register.  this   ;
;   is because the sequencer will produce a 20 ns glitch on the cas lines     ;
;   when this register is accessed, which seems to have a chance of glitching ;
;   vram even though write enable is never asserted.  therefore, reading to   ;
;   or writing to this register using these routines is an error.             ;
;                                                                             ;
;   this code does not restore the contents of the graphics controller        ;
;   miscellaneous register as part of the RevertDefault (function F6).        ;
;   this is because it appears to cause a glitch on the cas lines in a        ;
;   similar to the sequencer memory mode register.  the rest of the code      ;
;   does not give this register any special treatment, and it is the          ;
;   responsibility of the programmer to be careful.  this problem is          ;
;   particularly insideous because it will only show up on EGA cards with     ;
;   the add on memory cards that have INMOS RAM chips.  Beware!!!             ;
;                                                                             ;
;   this code has no provisions for reading the input status registers        ;
;   on the ega.  any code that wants to read either of the input status       ;
;   registers should do so directly.                                          ;
;                                                                             ;
;   extended int 10 call interface spec:                                      ;
;                                                                             ;
;   Read One Register                                                         ;
;                                                                             ;
;       in:     ah      0f0h                                                  ;
;               dx:     port number                                           ;
;                       0h: crtc chip      (3x4h)                             ;
;                       8h: sequencer chip (3c4h)                             ;
;                      10h: graphics chips (3ceh)                             ;
;                      18h: attribute chip (3c0h)                             ;
;                      20h: misc out reg   (3c2h)                             ;
;                      28h: feature reg    (3xah)                             ;
;                      30h: gr 1 pos reg   (3cch)                             ;
;                      38h: gr 2 pos reg   (3cah)                             ;
;               bx:     ptr for ptr/data ports (first 4 above)  (bh=0, bl=ptr);
;                       ignored for single registers (last 4 above)           ;
;                                                                             ;
;       return: ax      restored                                              ;
;               bl      data                                                  ;
;               bh      restored                                              ;
;               dx      restored                                              ;
;               all others restored                                           ;
;                                                                             ;
;                                                                             ;
;   Write One Register                                                        ;
;                                                                             ;
;       in:     ah      0f1h                                                  ;
;               dx      port number                                           ;
;                       0h: crtc chip      (3x4h)                             ;
;                       8h: sequencer chip (3c4h)                             ;
;                      10h: graphics chips (3ceh)                             ;
;                      18h: attribute chip (3c0h)                             ;
;                      20h: misc out reg   (3c2h)                             ;
;                      28h: feature reg    (3xah)                             ;
;                      30h: gr 1 pos reg   (3cch)                             ;
;                      38h: gr 2 pos reg   (3cah)                             ;
;               bl      pointer value for ptr/data ports (first 4 above)      ;
;                       data for single registers (last 4 above)              ;
;               bh      data for ptr/data ports                               ;
;                       ignored for single registers                          ;
;                                                                             ;
;       return: ax      restored                                              ;
;               bl      restored                                              ;
;               bh      trashed                                               ;
;               dx      trashed                                               ;
;               all others restored                                           ;
;                                                                             ;
;                                                                             ;
;   Read Register Range                                                       ;
;                                                                             ;
;       in:     ah      0f2h                                                  ;
;               dx      port number                                           ;
;                       0h: crtc chip      (3x4h)                             ;
;                       8h: sequencer chip (3c4h)                             ;
;                      10h: graphics chips (3ceh)                             ;
;                      18h: attribute chip (3c0h)                             ;
;               es:bx   table of values                                       ;
;               ch      starting pointer value                                ;
;               cl      number of regs (must be > 1)                          ;
;                                                                             ;
;       return: ax      restored                                              ;
;               bx      restored                                              ;
;               cx      trashed                                               ;
;               dx      restored                                              ;
;               es      restored                                              ;
;               all others restored                                           ;
;                                                                             ;
;                                                                             ;
;   Write Register Range                                                      ;
;                                                                             ;
;       in:     ah      0f3h                                                  ;
;               dx      port number                                           ;
;                       0h: crtc chip      (3x4h)                             ;
;                       8h: sequencer chip (3c4h)                             ;
;                      10h: graphics chips (3ceh)                             ;
;                      18h: attribute chip (3c0h)                             ;
;               es:bx   table of values                                       ;
;               ch      starting pointer value                                ;
;               cl      number of regs (must be > 1)                          ;
;                                                                             ;
;       return: ax      restored                                              ;
;               bx      trashed                                               ;
;               dx      trashed                                               ;
;               es      restored                                              ;
;               all others restored                                           ;
;                                                                             ;
;                                                                             ;
;   Read Register Set                                                         ;
;                                                                             ;
;       in:     ah      0f4h                                                  ;
;               es:bx   table of values, where each entry consists of         ;
;                               port number     (word)                        ;
;                               pointer value   (byte) (should be 0 for       ;
;                                                       single registers)     ;
;                               data            (byte)                        ;
;               cx      number of regs (must be > 1)                          ;
;                                                                             ;
;       return: ax      restored                                              ;
;               bx      restored                                              ;
;               cx      trashed                                               ;
;               es      restored                                              ;
;               all others restored                                           ;
;                                                                             ;
;                                                                             ;
;   Write Register Set                                                        ;
;                                                                             ;
;       in:     ah      0f5h                                                  ;
;               es:bx   table of values, where each entry consists of         ;
;                               port number     (word)                        ;
;                               pointer value   (byte) (should be 0 for       ;
;                                                       single registers)     ;
;                               data            (byte)                        ;
;               cx      number of regs (must be > 1)                          ;
;                                                                             ;
;       return: ax      restored                                              ;
;               bx      restored                                              ;
;               cx      trashed                                               ;
;               es      restored                                              ;
;               all others restored                                           ;
;                                                                             ;
;   Revert To Default Registers                                               ;
;                                                                             ;
;       in:     ah      0f6h                                                  ;
;                                                                             ;
;       return: all registers restored                                        ;
;                                                                             ;
;                                                                             ;
;   Define Default Register Table                                             ;
;                                                                             ;
;       in:     ah      0f7h                                                  ;
;               dx      port number                                           ;
;                       0h: crtc chip      (3x4h)                             ;
;                       8h: sequencer chip (3c4h)                             ;
;                      10h: graphics chips (3ceh)                             ;
;                      18h: attribute chip (3c0h)                             ;
;                      20h: misc out reg   (3c2h)                             ;
;                      28h: feature reg    (3xah)                             ;
;                      30h: gr 1 pos reg   (3cch)                             ;
;                      38h: gr 2 pos reg   (3cah)                             ;
;               es:bx  points to table of default values (all must be present);
;                                                                             ;
;       return: ax      restored                                              ;
;               bx      trashed                                               ;
;               dx      trashed                                               ;
;               es      restored                                              ;
;               all others restored                                           ;
;                                                                             ;
;                                                                             ;
;   Get Default Register Table                                                ;
;                                                                             ;
;       in:     ah      0f8h                                                  ;
;               dx      port number                                           ;
;                       0h: crtc chip      (3x4h)                             ;
;                       8h: sequencer chip (3c4h)                             ;
;                      10h: graphics chips (3ceh)                             ;
;                      18h: attribute chip (3c0h)                             ;
;                      20h: misc out reg   (3c2h)                             ;
;                      28h: feature reg    (3xah)                             ;
;                      30h: gr 1 pos reg   (3cch)                             ;
;                      38h: gr 2 pos reg   (3cah)                             ;
;               es:bx  points to table receiving default values               ;
;                      (table must have room for full set of values)          ;
;                                                                             ;
;       return: ax      restored                                              ;
;               bx      trashed                                               ;
;               dx      trashed                                               ;
;               es      restored                                              ;
;               all others restored                                           ;
;                                                                             ;
;                                                                             ;
;   Inquire Driver                                                            ;
;      in:     ah      0fah                                                   ;
;              bx      0                                                      ;
;                                                                             ;
;      return: ax      restored                                               ;
;              es:bx   nonzero (reserved)                                     ;
;                                                                             ;
;                                                                             ;
;  note: calls 0f9h, and 0fbh - 0fdh are reserved. 0feh & 0ffh are used by    ;
;        environments such as Windows, TopView, and Mondrian                  ;
;                                                                             ;
;-----------------------------------------------------------------------------;

;[1]not for BASIC RUNTIME!!
;[1]		.286c	;can use 286 instructions in os/2 driver

                public  Int10Vector

                public  ChangeRegs
                public  Int10Routine


MyCallTable     label   word
                dw      offset ReadReg          ;call f0
                dw      offset WriteReg         ;call f1
                dw      offset ReadRange        ;call f2
                dw      offset WriteRange       ;call f3
                dw      offset ReadSet          ;call f4
                dw      offset WriteSet         ;call f5
                dw      offset RevertDefault    ;call f6
                dw      offset DefineDefault    ;call f7
                dw      offset GetDefault       ;call f8
                dw      offset CallInt10        ;call f9
                dw      offset InquireDriver    ;call fa
                dw      offset CallInt10        ;call fb
                dw      offset CallInt10        ;call fc
                dw      offset CallInt10        ;call fd
                dw      offset CallInt10        ;call fe
                dw      offset CallInt10        ;call ff

MaxBIOSCall     equ     13h                     ;max rom bios call

BIOSCallTable   label   word                    ;eventually none will be ignored
                dw      offset SetMode          ;set display mode
                dw      offset Ignore
                dw      offset Ignore
                dw      offset Ignore
                dw      offset Ignore
		dw	offset Ignore		;set page now ignored  4/12/87
                dw      offset Ignore
                dw      offset Ignore
                dw      offset Ignore
                dw      offset Ignore
                dw      offset Ignore
                dw      offset SetCgaPalette    ;set CGA palette registers
                dw      offset Ignore
                dw      offset Ignore
                dw      offset Ignore
                dw      offset Ignore
                dw      offset SetEgaPalette    ;set EGA palette registers
                dw      offset Ignore
                dw      offset Ignore
                dw      offset Ignore

SetRec          struc                           ;used in read/write set calls
    SRPortNum   dw      ?
    SRPtr       db      ?
    SRData      db      ?                       ;must be last!
SetRec          ends

PortRec         struc
    PRPortAddr  dw      ?                       ;io port address (can change)
    PRCurrTable dw      ?                       ;current shadow map table
    PRDefTable  dw      ?                       ;default shadow map table
    PRNumRegs   db      ?                       ;number of data regs
    PRModFlag   db      ?                       ;modified since last "rev def"
PortRec         ends

MasmBug         macro   pa,ct,dt,nr,mf          ;masm 3.0 doesn't allow >1
                dw      pa                      ; ... relocatable in a record
                dw      ct
                dw      dt
                db      nr
                db      mf
                endm

NumPtrData      equ     4

PortTable       label   word                    ;code dependent on order
                MasmBug 3d4h,<offset CRTCRegs    >,<offset DefCRTCRegs    >,19h,0
                MasmBug 3c4h,<offset SeqRegs     >,<offset DefSeqRegs     >,4h,0
                MasmBug 3ceh,<offset GraphicsRegs>,<offset DefGraphicsRegs>,9h,0
                MasmBug 3c0h,<offset AttrRegs    >,<offset DefAttrRegs    >,14h,0
                MasmBug 3c2h,<offset MiscOutReg  >,<offset DefMiscOutReg  >,1,0
                MasmBug 3dah,<offset FeatureReg  >,<offset DefFeatureReg  >,1,0
                MasmBug 3cch,<offset Gr1PosReg   >,<offset DefGr1PosReg   >,1,0
                MasmBug 3cah,<offset Gr2PosReg   >,<offset DefGr2PosReg   >,1,0
PortTableEnd    label   byte

SequencerAddr   equ     03c4h
SequencerClMReg equ     1

GraphicsAddr    equ     03ceh                   ;graphics controller port address
GraphicsMiscReg equ     6                       ;miscellaneous reg offset in gc

StartShadowMaps label   byte
SeqRegs         db      5h dup(?)               ;these are the shadow map tables
MiscOutReg      db      ?                       ;order must be same as bios
CRTCRegs        db      19h dup(?)
AttrRegs        db      14h dup(?)
GraphicsRegs    db      9h dup(?)
SizeShadowMaps  equ     $-StartShadowMaps
DefSeqRegs      db      5h dup(?)               ;these are default sm tables
DefMiscOutReg   db      ?                       ;order must be same as bios
DefCRTCRegs     db      19h dup(?)
DefAttrRegs     db      14h dup(?)
DefGraphicsRegs db      9h dup(?)

Gr1PosReg       db      ?                       ;these aren't included in bios
Gr2PosReg       db      ?
FeatureReg      db      0                       ;never changed
DefGr1PosReg    db      ?
DefGr2PosReg    db      ?
DefFeatureReg   db      0                       ;never changed

SingleRegMod    db      0                       ;>0 if a single reg modified

SaveAX          dw      ?                       ;temp variables
SaveSI          dw      ?

Int10Vector     dd      ?                       ;old int 10 vector

EgaStateVars    label   byte                    ;this is reserved for the future
  Version       db      1,60
  CopyrightMsg  dw      offset Copyright
  CheckSum      dw      0
  CheckSumStart dw      offset SetMode
  InBIOS        db      0
Copyright       db      "*** This is Copyright (c) 1984,85,86  Microsoft ***"


; BIOS data segment offsets of display data

BiosCrtMode     equ     49h             ;40:49 = CRT mode
BiosCrtCols     equ     4ah             ;40:4a = CRT character columns/line
BiosCrtLen      equ     4ch             ;40:4c = regen buffer length
BiosCursorPosn  equ     50h             ;40:50 = start of cursor position array
BiosActivePage  equ     62h             ;40:62 = active display page #
BiosCrtPalette  equ     66h             ;40:66 = CRT palette byte



SetMode 	proc	near			;this is called when a bios
		push	ds			; set mode call is made.
		xor	ax,ax			;it must predict which mode
		mov	ds,ax			; table the bios will use, so
		mov	ax,ds:[410h]		; the bios decision logic is
		and	al,30h			; duplicated here.
                test    byte ptr ds:[487h],2
                jz      SMNoMonochrome
                cmp     al,30h
                jnz     SMNoChange
                mov     ah,byte ptr cs:[SaveAX]
                mov     al,0b0h                 ;io addr = 3bx
                and     ah,7fh
                cmp     ah,0fh
                jz      SMChangeRegs
                mov     ah,07h
                jmp     short SMChangeRegs      ;ah has mode
SMNoMonochrome: cmp     al,30h
                jz      SMNoChange
                mov     ah,byte ptr cs:[SaveAX]
                mov     al,0d0h                 ;io addr = 3dx
                and     ah,7fh
SMChangeRegs:   call    ChangeRegs
SMNoChange:     pop     ds
Ignore:         ret
SetMode         endp


MakeBase	proc	near			;extracted from ChangeRegs 4/12/87
		assume	ds:nothing		;ds must be = 0
		les	si,ds:[4a8h]
		les	si,es:[si]
		test	byte ptr ds:[487h],60h
		jz	mb0			;these labels correspond to
		add	si,440h 		;... bios offsets.
		cmp	ah,0fh
		je	mbx
		add	si,40h
		cmp	ah,10h
		je	mbx
		sub	si,480h
mb0:		cmp	ah,3
		ja	mb2
		mov	al,0fh
		and	al,ds:[488h]
		cmp	al,03h
		je	mb1
		cmp	al,09h
		jne	mb2
mb1:		add	si,4c0h
mb2:		xor	al,al
		shr	ax,1
		shr	ax,1
		add	si,ax
mbx:		ret				;es:si points to correct table
MakeBase	endp


ChangeRegs      proc    near                    ;inp: ah=mode,al=io addr,ds=0
                push    es                      ;sets up shadow map tables
                push    cx
                push    di
                pushf                           ; save direction flag
                cld                             ; clear direction flag
                and     byte ptr cs:PortTable[0].PRPortAddr,0fh
                or      byte ptr cs:PortTable[0].PRPortAddr,al
                and     byte ptr cs:PortTable[5 * size PortRec].PRPortAddr,0fh
                or      byte ptr cs:PortTable[5 * size PortRec].PRPortAddr,al
		call	MakeBase
		mov	ax,es			;es:si points to correct table
                mov     ds,ax
                assume  ds:nothing
                mov     ax,cs
                mov     es,ax                   ;ds is source, es dest
                add     si,5
                mov     di,offset StartShadowMaps
                mov     al,3
                stosb
                mov     cx,SizeShadowMaps-1
                shr     cx,1
                push    cx
                if      (SizeShadowMaps-1) and 1
                movsb
                endif
                rep     movsw
                sub     si,(SizeShadowMaps-1)
                stosb
                pop     cx
                if      (SizeShadowMaps-1) and 1
                movsb
                endif
                rep     movsw
                mov     ax,cs
                mov     ds,ax
                assume  ds:Code
                mov     [Gr1PosReg],cl
                mov     [DefGr1PosReg],cl
                inc     cl
                mov     [Gr2PosReg],cl
                mov     [DefGr2PosReg],cl
                xor     di,di
                mov     cx,NumPtrData
CRClearModFlag: mov     byte ptr PortTable[di].PRModFlag,0
                add     di,size PortRec
                loop    CRClearModFlag
                mov     [SingleRegMod],0
                popf
                pop     di
                pop     cx
                pop     es
                ret
ChangeRegs      endp


;   Since both hardware regs this routine is trying to shadow are readable,
;   and since BVS has taken responsibility for this anyway, this routine
;   is unnecessary.   It has perhaps not even been tested, since it
;   expects AL to have page # on entry, when in fact it must use SaveAX.  4/12/87
;
;SetDisplayPage proc	near
;		push	ax		     ;save registers that may get
;		push	bx		     ; destroyed
;		push	cx
;		push	dx
;		push	di
;
;		cbw			     ;ax <- display page #
;		mov	bx,ax		     ;bx <- display page #
;		push	ds		     ;save ds
;		mov	cx,40h		     ;set ds pointing to the BIOS
;		mov	ds,cx		     ; data segment
;		mov	cl,ds:[BiosActivePage]	;cl <- BIOS active display page
;		mov	dh,ds:[BiosCrtMode]	;dh <- BIOS display mode
;		mov	dl,ds:[BiosCrtCols]	;dl <- BIOS chars/line
;		mov	di,offset BiosCursorPosn[bx] ;di <- cursor position
;		mov	bx,ds:[BiosCrtLen]	;bx <- BIOS regen buffer length
;		pop	ds		     ;restore ds
;
;		cmp	al,cl		     ;check if page # hasn't changed
;		je	SDispPageEnd	     ;branch if new page == old page
;		mov	cx,ax		     ;cx <- display page #
;		xor	si,si		     ;si will end up with regen buffer
;					     ; address for selected page
;		jcxz	SetDispPage2	     ;branch if page 0 selected
;SetDispPage1:	add	si,bx		     ;add page offset to page start
;		loop	SetDispPage1	     ;sum pages until done
;SetDispPage2:	mov	bx,si		     ;bh <- msb of CRTC start address
;		cmp	dh,7		     ;modes <= 7 use word addresses
;		ja	SetDispPage3	     ;branch if display mode > 7
;		sar	bx,1		     ;use starting word address
;SetDispPage3:	mov	12[CRTCRegs],bh      ;save Start Address High Reg value
;		mov	13[CRTCRegs],bl      ;save Start Address Low Reg value
;		mov	bx,di		     ;bh <- curs row / bl <- curs col
;		mov	cl,dl		     ;cl <- characters/line
;		mov	dx,si		     ;dx <- page starting byte offset
;		sar	dx,1		     ;dx <- page starting cursor posn
;		mov	al,bh		     ;al <- cursor position row
;		mul	cl		     ;ax <- cursor row address/2
;		xor	bh,bh		     ;bh <- cursor column #
;		add	ax,bx		     ;ax <- page cursor position
;		add	ax,dx		     ;ax <- cursor position
;		mov	14[CRTCRegs],ah      ;save Cursor Loc High Reg value
;		mov	15[CRTCRegs],al      ;save Cursor Loc Low Reg value
;		mov	byte ptr PortTable[0].PRModFlag,1 ;set CRTC dirty flag
;
;SDispPageEnd:	pop	di
;		pop	dx
;		pop	cx
;		pop	bx
;		pop	ax
;		ret
;SetDisplayPage endp


SetCgaPalette   proc    near
                push    ax                   ;save registers that may get
                push    bx                   ; destroyed
                push    cx
                push    dx

                push    ds                   ;save ds
                mov     cx,40h               ;set ds pointing to the BIOS
                mov     ds,cx                ; data segment
                mov     cl,ds:[BiosCrtPalette]  ;cl <- BIOS CRT palette byte
                mov     ch,ds:[BiosCrtMode]     ;ch <- BIOS CRT mode
                pop     ds                   ;restore ds

                or      bh,bh                ;background or palette colors ?
                jnz     SCgaPalette          ;branch if set CGA palette colors

		and	cl,11100000b	     ;cl gets an updated
		and	bl,00011111b	     ; version of the BIOS palette byte
		or	cl,bl		     ; now, with new background color

                mov     bh,bl                ;convert the color number
                shl     bl,1                 ; in bl into an intensity
                and     bl,10h               ; in bit 4 and color in
                and     bh,7                 ; bits 2-0 and leave the
                or      bh,bl                ; results in bh

                cmp     ch,3                 ;check for character modes
                jbe     SCgaCharPal          ;branch if in a character mode

		mov	dx,18h		     ;dx <- attribute controller port #
                push    bx                   ;save color in bh
                xor     bl,bl                ;set attr cntrlr palette color 0
                call    SimWriteReg          ; (background) to value in bh
                pop     bx                   ;restore color to bh
SCgaCharPal:    mov     dx,18h               ;dx <- attribute controller port #
                mov     bl,11h               ;set attribute controller
                call    SimWriteReg          ; overscan color to value in bh
;		jmp	short SCgaPaletteEnd
		mov	bl,cl		     ;ega function w/bh=0 sets both
		and	bl,00100000b	     ; border and background color,
;[1]		rol	bl,3		     ; so we drop into background logic
		rol	bl,1		     ;[1]
		rol	bl,1		     ;[1]
		rol	bl,1		     ;[1]

SCgaPalette:    cmp     ch,3                 ;check for character modes
                jbe     SCgaPaletteEnd       ;branch if character mode (no
                                             ; palettes for character modes)
                and     cl,10h               ;cl <- intensity bit from palette
                                             ; which is actually derived from
                                             ; the background color by the BIOS
                and     bl,1                 ;only allow palettes 0 and 1
                or      bl,cl                ;or intensity into palette
                or      bl,2                 ;color 1 is green (2) or cyan (3)
                mov     bh,bl                ;bh <- color and intensity
                mov     bl,1                 ;set attribute controller palette
                                             ; register 1 to value in bh
		mov	dx,18h		     ;dx <- attribute controller port #
		push	bx		     ;save bx
                call    SimWriteReg          ;write it!
                pop     bx                   ;restore bx
                inc     bh                   ;color 2 is red (4) or magenta (5)
                inc     bh
                inc     bl                   ;set attribute controller palette
                                             ; register 2 to value in bh
                mov     dx,18h               ;dx <- attribute controller port #
		push	bx		     ;save bx
                call    SimWriteReg          ;write it!!
                pop     bx                   ;restore bx
                inc     bh                   ;color 3 is brown (6) or white (7)
                inc     bh
                inc     bl                   ;set attribute controller palette
                                             ; register 3 to value in bh
                mov     dx,18h               ;dx <- attribute controller port #
                call    SimWriteReg          ;write it!!!

SCgaPaletteEnd: pop     dx
                pop     cx
                pop     bx
                pop     ax
                ret
SetCgaPalette   endp


SetEgaPalette   proc    near
                push    ax                   ;save registers that may get
                push    bx                   ; destroyed
                push    cx
                push    dx

                mov     dx,18h               ;dx <- attribute controller port #
                mov     al,byte ptr [SaveAX] ;al <- subfunction
                or      al,al                ;0 = set individual palette reg
                jnz     NotS1EgaPalReg       ;branch if not set 1 register

S1EgaPalReg:    call    SimWriteReg          ;write 1 Attribute Controller Reg
                jmp     short SEgaPaletteEnd

NotS1EgaPalReg: dec     al                   ;1 = set overscan register
                jnz     NotSetOverscan       ;branch if not overscan register
                mov     bl,11h               ;bl <- overscan register number
                jmp     short S1EgaPalReg    ;write it!!!

NotSetOverscan: dec     al                   ;2 = set palette & overscan regs
                jnz     ToggleBlink          ;branch if not set all
                pop     bx                   ;bx <- table offset (was in dx)
                push    bx                   ;put dx value back onto stack
                mov     cx,16                ;16 registers to write first
                call    SimWriteRange        ;write them!!!
		pop	bx
		push	bx			;get pointer to data again
		mov	bh,es:[bx+16]		;get the overscan byte now
		mov	bl,11h			;ptr to overscan reg
		call	SimWriteReg		;write separated overscan now!
                jmp     short SEgaPaletteEnd

ToggleBlink:    dec     al                   ;3 = toggle blink bit
                jnz     SEgaPaletteEnd       ;branch if not toggle blink bit

;   In order to parallel EGA Bios logic (strange though it sometimes is),
;   this code must fetch the default attr mode reg value from the tables in
;   EGA ROM and modify THAT, rather than the CURRENT setting of the mode reg.
;   If the bh parm is not legal, then that default value is stored instead,
;   which may well be different from the current setting of the mode reg.  4/12/87

		push	ds
		push	es
		cbw			     ;we know al already 0
		mov	ds,ax		     ;MakeBase requires ds = 0
		mov	ah,ds:[449h]	     ;also requires video bios mode #
		call	MakeBase
		mov	bh,es:[si+51]	     ;get default attr mode value
		pop	es
		pop	ds

		or	bl,bl		     ;what's our purpose in life?
		jz	resetbit	     ;0 means shut off bit
		dec	bl
		or	bl,bl
		jnz	storebit	     ;still not 0? give'em a default
		or	bh,00001000b
		jmp	short storebit
resetbit:	and	bh,11110111b

;		mov	bx,16		     ;read attr controller mode reg
;		call	ReadReg 	     ;bl <- attr controller mode reg
;		pop	cx		     ;cx <- toggle bit
;		shl	cl,1		     ;move toggle bit from
;		shl	cl,1		     ; bit 0 to bit 3
;		shl	cl,1
;		or	cl,bl		     ;cl <- new value for mode reg
;		mov	bh,cl		     ;bh <- new value for mode reg

storebit:	mov	bl,16		     ;write attr controller mode reg
		mov	dx,18h		     ;dx <- attribute controller port #
		jmp	short S1EgaPalReg    ;write attr controller mode reg

SEgaPaletteEnd: pop     dx
                pop     cx
                pop     bx
                pop     ax
                ret
SetEgaPalette   endp


Int10Routine    proc    far
		cmp	ah,0f0h 		;Fast EGA R.I. call?
		jb	NotMine 		;no
MyCall:         push    ds                      ;CallInt10 depends on this!
                push    si
                push    ax
                mov     al,ah
                and     ax,000fh
                shl     ax,1
                mov     si,ax
                mov     ax,cs
                mov     ds,ax
                call    [si].MyCallTable
                pop     ax
                pop     si
                pop     ds
                iret

NotMine:	cmp	ah,0Bh			;SetCgaPalette call?
		je	Mine2			;we hook that one
		test	ah,0Fh			;test for AH=00 or 10
		jz	Mine1			;we hook both of those calls
		jmp	cs:[Int10Vector]	;we don't hook any other AH=0X

Mine1:		cmp	ah,MaxBIOSCall		;but we don't hook AH=20,30,etc
                ja      DoInt10
Mine2:		push	ds
                mov     cs:[SaveSI],si
                mov     si,cs
                mov     ds,si
                mov     [SaveAX],ax
                mov     al,ah
                xor     ah,ah
                shl     ax,1
                mov     si,ax
                call    BIOSCallTable[si]
                mov     ax,[SaveAX]
                mov     si,[SaveSI]
                pop     ds
DoInt10:        jmp     cs:[Int10Vector]
Int10Routine    endp


SimWriteReg     proc    near
                mov     ax,bx
                mov     si,dx
                cmp     dx,NumPtrData * size PortRec
                mov     dx,PortTable[si].PRPortAddr
                mov     byte ptr PortTable[si].PRModFlag,1
                mov     si,PortTable[si].PRCurrTable
                jge     SWRegNoPtr
                xor     bh,bh
                mov     [si+bx],ah
                ret
SWRegNoPtr:     mov     [si],al
                mov     [SingleRegMod],1
                ret
SimWriteReg     endp


SimWriteRange   proc    near
                cld
                push    di
                push    es
                mov     si,bx
                mov     di,dx
                mov     byte ptr PortTable[di].PRModFlag,1
                mov     di,PortTable[di].PRCurrTable
                mov     ax,es
                mov     bx,ds
                mov     es,bx
                mov     ds,ax
                xor     ax,ax
                xchg    al,ch
                add     di,ax
                shr     cx,1
                rep     movsw
		rcl	cx,1
		rep	movsb
                mov     ds,bx
                pop     es
                pop     di
                ret
SimWriteRange   endp


ReadReg         proc    near
                mov     si,dx
                mov     si,PortTable[si].PRCurrTable
                cmp     dx,NumPtrData * size PortRec
                jge     RRegNoPtr
                mov     bl,[si+bx]
                ret
RRegNoPtr:      mov     bl,[si]
                ret
ReadReg         endp


WriteReg        proc    near                    ;3c0h assumed to be ok state
                mov     ax,bx
                mov     si,dx
                cmp     dx,NumPtrData * size PortRec
                mov     dx,PortTable[si].PRPortAddr
                mov     byte ptr PortTable[si].PRModFlag,1
                mov     si,PortTable[si].PRCurrTable
                jge     WRegNoPtr
                xor     bh,bh
                mov     [si+bx],ah
                out     dx,ax
                ret
WRegNoPtr:      mov     [si],al
                mov     [SingleRegMod],1
                out     dx,al
                ret
WriteReg        endp


ReadRange       proc    near            ;should only be called for ptr/data regs
                sti
                cld                     ;cl must be > 1
                push    di
                mov     di,bx
                mov     si,dx
                mov     si,PortTable[si].PRCurrTable
                xor     ax,ax
                xchg    al,ch
                add     si,ax
		shr	cx,1
		rep	movsw
		rcl	cx,1
		rep	movsb
                pop     di
                ret
ReadRange       endp


WriteRange      proc    near
                sti
                cld
                push    di
                push    es
                mov     si,bx
                mov     di,dx
                mov     byte ptr PortTable[di].PRModFlag,1
                mov     dx,PortTable[di].PRPortAddr
                mov     di,PortTable[di].PRCurrTable
                mov     ax,es
                mov     bx,ds
                mov     es,bx
                mov     ds,ax
                xor     ax,ax
                xchg    al,ch
                add     di,ax
                push    cx
                shr     cx,1
		rep	movsw
		rcl	cx,1
		rep	movsb
                mov     ds,bx
                pop     cx
                sub     di,cx
WRangeNextReg:  mov     ah,[di]
                out     dx,ax           ;al initially contains starting reg
                inc     di
                inc     al
                loop    WRangeNextReg
                pop     es
                pop     di
                ret
WriteRange      endp


ReadSet         proc    near
                sti
                cld
                push    di
                mov     di,bx
RSetNextEntry:  mov     si,es:[di].SRPortNum
                mov     si,PortTable[si].PRCurrTable
                mov     al,es:[di].SRPtr
                cbw
                add     si,ax
                add     di,offset SRData
                movsb
                loop    RSetNextEntry
                pop     di
                ret
ReadSet         endp


WriteSet        proc    near
                sti
                cld
                push    di
                push    dx
                mov     di,bx
WSetNextEntry:  mov     si,es:[di].SRPortNum
                mov     byte ptr PortTable[si].PRModFlag,1
                mov     dx,PortTable[si].PRPortAddr
                mov     si,PortTable[si].PRCurrTable
                mov     al,es:[di].SRPtr
                cbw
                add     si,ax
                mov     ah,es:[di].SRData
                mov     [si],ah
                out     dx,ax
                add     di,size SetRec
                loop    WSetNextEntry
                pop     dx
                pop     di
                ret
WriteSet        endp


RevertDefault   proc    near
                sti
                cld
                push    di
                push    es
                push    dx
                push    cx
                push    bx
                mov     ax,ds
                mov     es,ax
                mov     bx,offset PortTable
                xor     cx,cx
RDefNextPtrData:cmp     byte ptr [bx].PRModFlag,ch
                je      RDefNotModified
                mov     byte ptr [bx].PRModFlag,ch
                mov     cl,byte ptr [bx].PRNumRegs
                mov     di,[bx].PRCurrTable
                mov     si,[bx].PRDefTable
                mov     dx,cx
                shr     cx,1
		rep	movsw
		rcl	cx,1
		rep	movsb
                mov     cx,dx
		sub	si,cx
                mov     dx,[bx].PRPortAddr

		cmp	dx,3C0h 		;attribute controller?
		jne	RDef1			;no
		sub	ax,ax			;yes, so update bios areas
		mov	es,ax			;they don't need es anymore
		mov	al,[si+16]		;fetch new mode ctrl
		and	al,00001000b		;isolate blink bit
		and	byte ptr es:[0465h],11011111b
;[1]		shl	al,2
		shl	al,1
		shl	al,1
		or	es:[0465h],al		;store new blink bit
		les	di,es:[04A8h]		;get save area address
		les	di,es:[di+4]		;get 2nd dword ptr there
		mov	ax,es
		or	ax,di			;anything there?
		jz	RDef1			;no
		mov	ax,cx			;save count
		mov	cx,16/2 		;copy 16 palette registers
		rep	movsw			;done!
		inc	si			;skip to the overscan value
		movsb				;copied!
		sub	si,18			;rewind src pointer
		mov	cx,ax			;restore count

RDef1:		mov	al,ch
RDefNextOut:    mov     ah,[si]
                cmp     dx,SequencerAddr                ; SAS 06/09/86
                jne     RDefNextOut1                    ; SAS 06/09/86
                cmp     al,SequencerClMReg              ; SAS 06/09/86
                je      DontRDefOut                     ; SAS 06/09/86
RDefNextOut1:   cmp     dx,GraphicsAddr
                jne     RDefOut
                cmp     al,GraphicsMiscReg
                je      DontRDefOut
RDefOut:        out     dx,ax
DontRDefOut:    inc     si
                inc     al
                loop    RDefNextOut

RDefNotModified:add     bx,size PortRec
                cmp     bx,offset PortTable + (NumPtrData * size PortRec)
		jae	RDef2
		jmp	RDefNextPtrData
RDef2:		cmp	[SingleRegMod],ch
                je      RDEFSinglesOK
                mov     [SingleRegMod],ch
                mov     dx,[bx+size PortRec].PRPortAddr
                mov     al,[DefFeatureReg]
                mov     [FeatureReg],al
                out     dx,al
                mov     dx,3c2h
                mov     al,[DefMiscOutReg]
                mov     [MiscOutReg],al
                out     dx,al
                mov     dx,3cch
                mov     al,[DefGR1PosReg]
                mov     [GR1PosReg],al
                out     dx,al
                mov     dx,3cah
                mov     al,[DefGR2PosReg]
                mov     [GR2PosReg],al
                out     dx,al

RDefSinglesOK:  mov     dx,3c0h
                mov     al,20h
                out     dx,al
                mov     dx,PortTable[5 * size PortRec].PRPortAddr
                in      al,dx
                pop     bx
                pop     cx
                pop     dx
                pop     es
                pop     di
                ret
RevertDefault   endp


DefineDefault   proc    near
                sti
                cld
                push    di
                push    cx
                mov     si,bx
                mov     di,dx
                xor     ch,ch
                mov     cl,byte ptr PortTable[di].PRNumRegs
                mov     byte ptr PortTable[di].PRModFlag,cl
                mov     [SingleRegMod],cl
                mov     di,PortTable[di].PRDefTable
                mov     ax,es
                mov     bx,ds
                mov     es,bx
                mov     ds,ax
                shr     cx,1
		rep	movsw
		rcl	cx,1
		rep	movsb
		mov	es,ax
                mov     ds,bx
                pop     cx
                pop     di
                ret
DefineDefault   endp


GetDefault      proc    near
                sti
                cld
                push    si
                push    di
                push    cx
                mov     di,bx
                mov     si,dx
                xor     ch,ch
                mov     cl,byte ptr PortTable[si].PRNumRegs
                mov     si,PortTable[si].PRDefTable
                shr     cx,1
		rep	movsw
		rcl	cx,1
		rep	movsb
		pop	cx
                pop     di
                pop     si
                ret
GetDefault      endp


InquireDriver   proc    near
                mov     ax,ds
                mov     es,ax
                mov     bx,offset EgaStateVars
		ret
InquireDriver   endp


CallInt10	proc	near			;very dependent on stack!
                push    bp
                mov     bp,sp
                mov     ax,[bp].8
                mov     ds,ax
                mov     si,[bp].6
                mov     ax,[bp].4
                pop     bp
                pushf
                call    cs:[Int10Vector]
                push    bp
                mov     bp,sp
                mov     [bp].4,ax
                mov     [bp].6,si
                mov     ax,ds
                mov     [bp].8,ax
                pop     bp
                ret
CallInt10       endp
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\intasg.inc ===
;***
;intasg.inc - 02/20/86 - software interrupt assignment
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

;	Software Interrupt Vector Numbers for run-time module


	W0__NM= 3Fh		;base interrupt number

	W1__NM= 0F8h
	W2__NM= W1__NM+1
	W3__NM= W1__NM+2


	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\hgcdefs.inc ===
;***
;HGCDEFS - Global definitions for MSHERC.
;***
	.XLIST
;***
;
;	Copyright <C> 1987, 1988, Microsoft Corporation
;
;Purpose:
;	Global definitions for MSHERC.
;
;******************************************************************************

;--------------------------------------------------------------------;
;			Equates
;--------------------------------------------------------------------;
LowerFuncMax	equ	0FH	;Max func # for implemented IBM lookalikes
InquireFuncNo	equ	0EFH		;Inquire Driver Function Number
HGCGrMode	equ	8		;BIOS mode number for HGC graphics

INT10HVECTOR_OFFSET	EQU	10h*4	;INT 10H Code Offset
INT10HVECTOR_SEGMENT	EQU	10h*4+2	;INT 10H Code Segment

;------Registers------
IndexReg		equ    	03B4H	;6845 CRT Controller Index Register
DataReg			equ	03B5H	;6845 CRT Controller Data Register
DMC_Port		equ	03B8H	;Display Mode Control Port
DS_Port			equ	03BAH	;Display Status Port
Config_Port		equ	03BFH	;Configuration Port
Register0		equ	0	;6845 Register 0

Scr0_Buf_Seg		equ	0B000H	;Display Buffer Segment
Scr1_Buf_Seg		equ	0B800H	;Graphics Page 1 Segment

;-----Configuration Port Values--------
DIAG		equ	0		;Graphics Mode and Page1 Disabled
HALF		equ	1		;Graphics Mode enabled,Page1 disabled
FULL		equ	3		;Graphics Mode and Page1 enabled

;------ Hercules ID Code Values ------
IDMask		equ	01110000b	;Mask for HGC ID Code bits
HGC112ID	equ	00010000b	;HGC GB112 ID Code
HGC222ID	equ	01010000b	;HGC GB222 ID Code

;------Display Mode Control Port Values--------
GraphicsOn	equ	00000010b	;Selects Graphics Mode
TextOn		equ	00000000b	;Selects Text Mode
ScreenOn	equ	00001000b	;Activates video
ScreenOff	equ	00000000b	;Disables video
BlinkOn		equ	00100000b	;Enable the Text Blink Attribute
BlinkOff	equ	00000000b	;Disable the Text Blink Attribute
GraphicsPage0	equ	00000000b	;Graphics Display Segment = 0B000H
GraphicsPage1	equ	10000000b	;Graphics Display Segment = 0B800H
GraphBufferSize	equ	8000h		;Graphics Buffer size = 32k bytes

Delay			equ	20	;Number of vsyncs to pause for a
					;mode change
CRTValsCnt		equ	14	;# bytes of 6845 Register Data

BIOSMODE	EQU	449H	;BIOS screen mode number
BIOSCURS	EQU	450H	;BIOS Offset of current cursor position
BIOSCOLS	EQU	44AH	;BIOS Offset of current screen columns
BIOSPAGE	EQU	462H	;BIOS Offset of current page number
BIOSSTART	EQU	44EH	;BIOS Offset of current page buffer start
BIOSLEN 	EQU	44CH	;BIOS page length
BIOSEQUIP	EQU	410H	;BIOS equipment information
BIOSCURSMODE	EQU	460H	;BIOS cursor type

;-------Parameter Offsets In Stack-------
FunData		equ	[bp]

RegStrc	struc		;Structure for saved registers

	FunAX		dw	?
	FunBX		dw	?
	FunCX		dw	?
	FunDX		dw	?

RegStrc	ends

;----- Graphics Mode Constants -------
GrNextScan	equ	2000H		;Point to next scan in graphics mode
NextScanAdjust	equ	8000H-90	;Adjusts next scan ptr when off-screen

;------ Write TTY equates ------
Bell		equ	7
BackSpace	equ	8
CarriageReturn	equ	0DH
LineFeed	equ	0AH
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\inchdr.inc ===
;***
;<filename> - <last modification date> - <short description>
;***
	IFNDEF	LI_EXPAND
	.XLIST
	ENDIF
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;Revision History:
;
;   []  20-Mar-86  LN: Clean up for Bascom 3 and Common Runtime Projects
;
;******************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\intmac.inc ===
;***
;intmac.inc - 20-Mar-86
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

;       8086 Interrupt Handling Macros
;       MS-DOS 1.0 does not have INT 21 to GET a vector
;       hence SAVINT just moves interrupts around.

	SVINT	MACRO   savloc,intloc,reg
	IFB	<reg>
	SVINT	savloc,intloc,AX
	ELSE
	MOV	reg,intloc
	MOV	savloc,reg
	MOV	reg,intloc+2
	MOV	savloc+2,reg
	ENDIF
	ENDM

	savint	macro savloc,intvec 
	MOV	AX,3500H+INTVEC/4 ;;AH=get int - AL=interrupt number
	int	21h
	mov	word ptr savloc,bx ;;savloc = offset
	mov	word ptr savloc+2,es ;;savloc+2 = segment
	endm

;	The following macros use the MS-DOS INT 21 call to change
;	interrupt vectors.

setvec	macro	interrupt,offset_adr ;;set interrupt vector function call
	mov	dx,offset offset_adr
	MOV	AX,2500H+INTERRUPT ;;AH=set int call - AL=interrupt
	int	21h
	endm

rstvec	macro	interrupt,save_adr ;;restore interrupt from saved
	lds	dx,dword ptr save_adr
	MOV	AX,2500H+INTERRUPT ;;AH=set int call - AL=interrupt
	int	21h
	endm

XFRINT	MACRO	TOINT,FROMINT	;;move FROMINT to TOINT
	PUSH	ES		;;save register...
	MOV	AX,3500H+FROMINT ;;want to get FROMINT
	INT	21H		;;vector now in ES:BX
	MOV	AX,ES		;;keep segment around
	POP	ES		;;restore register...
	MOV	DX,BX		;;move offset for put
	PUSH	DS		;;save register...
	MOV	DS,AX		;;segment for put
	MOV	AX,2500H+TOINT	;;want to put TOINT
	INT	21H		;;vector now in DS:DX
	POP	DS		;;restore register
	ENDM

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\grmac.inc ===
;***
; GRMAC - ModeData macros
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This macro set is used to create the "ModeData" tables.
;
;	The "master" ModeData table is called "b$ModeData" and resides in
;	DGROUP in LLCGRP.  Each mode-dependent module constructs a separate
;	table for each different mode in the Code Segment using these
;	macros. A mode-dependent ModeData table is then copied to the
;	master table when establishing a new screen mode.
;
;	All the tables are created using this macro set to insure
;	consistency in their structure and to provide a central point (the
;	macros) for modifying that structure.
;
;	The mModeData macro should be followed by individual data item
;	macros (in any order) and terminated using the mEnd macro.
;	The general format and list of data items is as follows:
;
;	mModeData	<table name>
;	mScreenMode	<screen mode>
;	mBiosMode	<BIOS mode>
;	mBurst		<burst>
;	mScrWidth	<text screen width>
;	mScrHeight	<text screen height>
;	mHorzRes	<horizontal pixel resolution>
;	mVertRes	<vertical pixel resolution>
;	mVideoBase	<base address of video segment>
;	mMaxAttr	<maximum attribute value>
;	mMaxColor	<maximum color value (for palette assignment)>
;	mPageSize	<page size (a "rough" size in K)>
;	mCurrPSize	<page size in paragraphs for 1 plane>
;	mMaxPage	<maximum page number>
;	mNullColor	<null character color attribute>
;	mForeColor	<foreground color attribute>
;	mBackColor	<background color attribute>
;	mEgaWrMd	<value for EGA write mode register (odd/even control)>
;	mInitPalette	<pointer to initial palette>
;	mInitVgaPal	<pointer to initial VGA palette>
;	mAlphaDim	<function vector to change screen text dimensions>
;	mSetMode	<function vector to set screen mode>
;	mSetPages	<function vector to change active/visual pages>
;	mPalReset	<function vector to reset palette>
;	mPalPut 	<function vector to set single palette entry>
;	mPalTrans	<function vector to translate attribute/color pair>
;	mPalSet 	<function vector to set entire palette>
;	mSetColor	<function vector to process COLOR statment>
;
;	--- following data items required for GRAPHICS modes only ---
;
;	mForeMapped	<forecolor mapped to hardware value>
;	mBitsPerPixel	<bits per pixel (per plane)>
;	mPlanes 	<number of graphics planes>
;	mMapXYC 	<function vector to map X,Y to mask & offset>
;	mLeftC		<function vector to move graphics cursor left>
;	mChkUpC 	<function vector to move graphics cursor up w/check>
;	mUpC		<function vector to move graphics cursor up>
;	mChkDownC	<function vector to move graphics cursor down w/check>
;	mDownC		<function vector to move graphics cursor down>
;	mSetAttr	<function vector to set current color attribute>
;	mReadC		<function vector to read pixel value>
;	mSetC		<function vector to set pixel value>
;	mSetPixC	<function vector to set pixel multiple times>
;	mSetPixFirstC	<function vector to prologue SetPixC>
;	mSetPixLastC	<function vector to epilogue SetPixC>
;	mLineX		<function vector to draw X-major lines>
;	mLineY		<function vector to draw Y-major lines>
;	mLineV		<function vector to draw vertical lines>
;	mPutAction	<function vector to establish PUT action verb>
;	mNReadL 	<function vector to read a line of pixels>
;	mNWriteL	<function vector to write a line of pixels>
;	mNSetC		<function vector to set a line of pixels>
;	mPaintBound	<function vector to set PAINT boundaries for a line>
;	mSetTile	<function vector to set PAINT tile>
;	mScanL		<function vector to scan left during PAINT>
;	mScanR		<function vector to scan right during PAINT>
;
;	--- mEnd required for ALL modes ---
;
;	mEnd		<graphics length>,<text length>,<define PUBLICS>
;
;******************************************************************************

;*** 
; mModeData (macro)
;
;Purpose:
;	When invoked, mModeData creates a macro called ?mModeData.  This
;	macro generates the label name for the table.  All ?m macros
;	and data values are for internal use by the macro set only.
;	?mModeData purges itself after use (by mEnd).
;
;Arguments:
;	<table name>
;
;******************************************************************************

mModeData macro n
	?mModeData  macro
	    if	?mDEF
		labelW	<PUBLIC,n>
	    else
		labelW	n
	    endif
		purge	?mModeData	;avoid residue from one table to next
		endm
	endm

;*** 
; mEnd (macro)
;
;Purpose:
;
;	This macro actually builds the table.  The data items supplied by the
;	individual macros are placed appropriately in the table. Additional
;	items calculated from the supplied values are also computed and built
;	into the table. The "define" macro (below) is used to check and build
;	each numeric table item. Macros created by invocation of the vector
;	data item macros are used to build the pointers and function vectors.
;
;	Specifying a symbol for the <graphics length> parameter generates a
;	graphics mode table and sets the value of the symbol to the length of
;	the graphics table.
;
;	Specifying a symbol for the <text length> parameter generates a text
;	mode table and sets the value of the symbol to the length of the text
;	table.
;
;	Specifying a symbol for both generates a graphics table, but sets
;	each symbol as above.
;
;	Specifying TRUE for the <define PUBLICS> (third) parameter generates
;	PUBLIC names (prefixed with "b$") for each data item. This also
;	creates the GraphVectStart LABEL and GraphVectCnt ABSOLUTE used by
;	B$InitModeData to reset the graphics function vectors for text
;	modes.	This should be used only to define the "master" table.
;
;TABLE MAINTENANCE:
;	To add new entries in the table, add an entry to the MACRO CREATION
;	section.  Then insert a line in "mEnd" using "define" for numeric
;	items, or invoking the "?mXX" macro for vector items.
;
;Arguments:
;	<graphics length>
;	<text length>
;	<define PUBLICS>
;******************************************************************************

mEnd	macro	glen,tlen,def
    ifb     <def>
	?mDEF		=	0		;no PUBLICS
    else
	?mDEF		=	def		;define PUBLICS
    endif
	?mBurst 	= (?mBurst NE 0) AND 1	;strip Burst to one bit
    ifb     <tlen>
	?mLEN		=	12		;packet len for graphics modes
	?mType		=	10B		;DOS5 graphics flag on
    else
	?mLEN		=	8		;packet len for text modes
	?mType		=	0		;DOS5 graphics flag off
    endif
    if	(?mBiosMode NE 7) AND (?mBiosMode NE 0FH) ;if not a mono mode, set
	?mType		=	?mType + 1	;DOS5 color adapter flag
    endif
    ifnb    <glen>
;
;compute those graphics values which are derivable from the others
;
	?mPixelsPerByte = 8 / ?mBitsPerPixel
	?mBytesPerRow	= ?mHorzRes / ?mPixelsPerByte
	?mMaskLeft	= LOW (0FFH SHL (8-?mBitsPerPixel))
	?mMaskRight	= 0FFH SHR (8-?mBitsPerPixel)
	;
	;DivShift is the shift count used to divide by PixelsPerByte
	;
    if	?mPixelsPerByte EQ 8
	?mDivShift	= 3
    else
    if	?mPixelsPerByte EQ 4
	?mDivShift	= 2
    else
    if	?mPixelsPerByte EQ 1
	?mDivShift	= 0
    else
	.ERR
	%OUT BitsPerPixel: invalid value
    endif
    endif
    endif
	;
	;ModMask is the mask used to MOD by PixelsPerByte
	;
	?mModMask	= ?mPixelsPerByte - 1
	;
	;Aspect is 256*4*(VertRes/HorzRes)/3
	;AspectInv is the inverse of Aspect
	;   The "*256" produces a "fixed-point" decimal value.
	;   The rest of the funniness is to round the value and to
	;   avoid overflow of 16-bit computations during assembly.
	;
	; These are the correct values:
	;
	;  mode(s)	b$Aspect	b$AspectInv
	;  -------	--------	-----------
	;  1,4,7,13	   213		    307
	;    2,8	   107	            614
	;     3		   165		    397
	;    9,10	   187		    351
	;   11,12	   256		    256
	;
	; Note:  Since these formula are not exact, be sure that the correct
	; values are obtained for any new screen modes that are added.
	;
	AspTmp = (?mVertRes MOD ?mHorzRes * 64+?mHorzRes/8)/(?mHorzRes/4) ;;[4]
	?mAspect	= ((?mVertRes/?mHorzRes*256+AspTmp)*8+3)/6	;;[4]
	AspTmpInv = (?mHorzRes MOD ?mVertRes * 128)/(?mVertRes/2)	;;[4]
	?mAspectInv	= ?mHorzRes/?mVertRes*192+(AspTmpInv*3+2)/4	;;[4]
    endif

	?mStart = $

	?mModeData

	define	B,ScreenMode		;current BASIC screen mode
    if	    ?mDEF
	labelW	<PUBLIC,b$ModeBurst>	;BiosMode and Burst in one word
    endif
	define	B,BiosMode		;current BIOS screen mode
	define	B,Burst 		;color burst

;****************************************************************************
;START OF DOS5 VIOSETMODE request packet (keep in this format!!!!)
;****************************************************************************

	define	B,ScrWidth		;otherwise we only need to
	define	B,ScrHeight		;  use bytes
	define	W,HorzRes		;horizontal resolution
	define	W,VertRes		;vertical resolution

;****************************************************************************
;END OF DOS5 VIOSETMODE request packet
;****************************************************************************

	;text mode-dependent data
	define	W,VideoBase		;video segment base
	define	B,MaxAttr		;maximum attribute
	define	B,MaxColor		;maximum color
	define	B,PageSize		;page size in K
	define	W,CurrPSize		;page size in paragraphs (1 plane)
	define	B,MaxPage		;maximum page number
;b$NullColor:
;In text modes, low nibble = b$ForeColor and high nibble = b$BackColor
;In graphics modes, either b$ForeColor or b$BackColor, depending on the mode
	define	B,NullColor		;null character attribute
    if	    ?mDEF
	labelW	<PUBLIC,b$FBColors>	;fore and back colors in one word
    endif
	define	B,ForeColor		;foreground color
	define	B,BackColor		;background color
	define	B,EgaWrMd		;EGA write mode 2 register value,
					;   bit 4=odd/even
	?mInitPalette			;initial (reset) palette
	;text mode-dependent function hooks
	?mAlphaDim
	?mSetMode
	?mSetPages
	?mPalReset
	?mPalPut
	?mPalTrans
	?mPalSet
	?mSetColor
    ifnb    <tlen>
	tlen	 =   $ - ?mStart	;length of text mode tables
    endif
    ifnb    <glen>
	;graphic mode-dependent data
	define	B,ForeMapped		;fore color mapped to external value
					;  for text ops in graphics modes
	define	B,BitsPerPixel		;bits per pixel
	define	B,Planes		;number of graphic planes
	define	W,BytesPerRow		;number of bytes per row
	define	B,MaskLeft		;mask with leftmost bit set
	define	B,MaskRight		;mask with rightmost bit set
	define	W,PixelsPerByte 	;pixels per byte
	define	B,DivShift		;shift count for x DIV b$PixelsPerByte
	define	W,ModMask		;mask for x MOD b$PixelsPerByte
	define	W,Aspect		;aspect ratio * 256
	define	W,AspectInv		;inverse aspect ratio * 256
	;graphic mode-dependent function hooks
    if	    ?mDEF
	labelW	GraphVectStart		;start of graphics vectors
    endif
	?mMapXYC
	?mLeftC
	?mChkUpC
	?mUpC
	?mChkDownC
	?mDownC
	?mSetAttr
	?mReadC
	?mSetC
	?mSetPixC
	?mSetPixFirstC
	?mSetPixLastC
	?mLineX
	?mLineY
	?mLineV
	?mPutAction
	?mNReadL
	?mNWriteL
	?mNSetC
	?mPaintBound
	?mSetTile
	?mScanL
	?mScanR
    endif
    ifnb    <glen>
	glen	 =   $ - ?mStart	;length of graphics mode tables
    endif
    if	    ?mDEF
	GraphVectCnt = ($-GraphVectStart)/2 ;count of graphics vectors
    endif
	endm

;*** 
; define (internal macro)
;
;Purpose:
;	Build a numeric data item into the table, given a name and type.
;
;	If ?mDEF is set TRUE by "mEnd", "define" generate a public label
;	for the item.
;
;	Afterwards, the symbol is set to a known invalid value.  (Symbols
;	cannot be purged.)  This value is tested for to prevent subsequent
;	tables from inheriting values from a previous table by omitting
;	an entry.
;
;	NOTE:  Be sure, when modifying the table structure in "mEnd" that
;	       a symbol's value is used in any computations before use
;	       with "define", since it invalidates the value.
;
;Arguments:
;	<data storage type (B or W)>
;	<numeric item name>
;
;******************************************************************************

define	macro	t,n
    if	?mDEF
	label&t <PUBLIC,b$&n>
    endif
	D&t	?m&n
    if	?m&n EQ 7FFFH
	.ERR
	%OUT &n: invalid (residual) value
    endif
	?m&n	= 07FFFH	;set value to "invalid" to trap residue
	endm

;*** 
; mmd (internal macro) "make macro data"
;
;Purpose:
;	This macro is used internally to generate each of the macros
;	for use in recording the values of numeric data items.
;	"mmd ScreenMode", for example generates a macro named "mScreenMode".
;	When "mScreenMode" is later invoked with a value as an argument, the
;	symbol "?mScreenMode" will be set to that value for later use by
;	the "mEnd" macro.
;
;Arguments:
;	<numeric item name>
;
;******************************************************************************

mmd	macro	n
	mmdi	m&n,?m&n
	endm

;*** 
; mmdi (internal macro) "make macro data item"
;
;Purpose:
;	Used by macro mmd to create a macro (e.g. mScreenMode) which will
;	set a symbol (e.g. ?mScreenMode) to the value of its argument.
;
;Arguments:
;	<macro name>
;	<value symbol>
;******************************************************************************

mmdi	macro	n1,n2
	n1	macro	v
		n2	= v
		endm
	endm

;*** 
; mmwv (internal macro) "make macro word vector"
;
;Purpose:
;	This macro is used internally to generate each of the macros
;	for use in recording the values of word vector data items.
;	"mmwv AlphaDim", for example generates a macro named "mAlphaDim".
;	When "mAlphaDim" is later invoked with a label as an argument, a
;	new macro "?mAlphaDim" will be created.  "mEnd" invokes the
;	"?mAlphaDim" macro to build the "DW <label>" item.
;
;	This method is used as the only mechanism to "store" label
;	names for later use.  (The label name is essentially "stored"
;	in the final macro.)  With MASM (4.0), EQU's cannot be purged
;	or reassigned, and "="'s appear not to be able to handle
;	assignments involving external labels.
;
;Arguments:
;	<label item name>
;
;******************************************************************************

mmwv	macro	n
	mmv	m&n,?m&n,b$&n,W
	endm

;*** 
; mmdv (internal macro)
;
;Purpose:
;	This macro is used internally to generate each of the macros
;	The method is identical to "mmwv" except that a double-word
;	vector is ultimately generated.
;
;Arguments:
;	<label item name>
;
;******************************************************************************

mmdv	macro	n
	mmv	m&n,?m&n,b$&n,D
	endm

;*** 
; mmv (internal macro)
;
;Purpose:
;	Used by macros "mmwv" and "mmdv" to create a macro (e.g. mAlphaDim)
;	which will create a macro (e.g. ?mAlphaDim) to build the appropriate
;	short or double word pointer table entry.
;
;	The final macro (e.g. ?mAlphaDim) purges itself after use (by mEnd)
;	so that a subsequent table definition omitting a value will not
;	pick up residual data from a previous table construction.
;
;Arguments:
;	<first macro name (mXX)>
;	<second macro name (?mXX)>
;	<public name for item (b$XX)>
;	<data storage type (W or D)>
;******************************************************************************

mmv	macro	n1,n2,n3,t
	n1	macro	v
		n2	macro
		    if	?mDEF
			label&t <PUBLIC,n3>
		    endif
			D&t	v
			purge	n2	;avoid residue from one table to next
			endm
		endm
	endm
;
; MACRO CREATION:
; --------------
; Now create all the macros for all the data items (using the macros
; described above).  These macros, all named "mXX" where XX is the
; name argument, are then used to specify values for the table items.
;
mmdv	InitPalette
mmdv	InitVgaPal		;[1]
mmwv	AlphaDim
mmwv	SetMode
mmwv	SetPages
mmwv	PalReset
mmwv	PalPut
mmwv	PalTrans
mmwv	PalSet
mmwv	SetColor
mmwv	MapXYC
mmwv	LeftC
mmwv	ChkUpC
mmwv	UpC
mmwv	ChkDownC
mmwv	DownC
mmwv	SetAttr
mmwv	ReadC
mmwv	SetC
mmwv	SetPixC
mmwv	SetPixFirstC
mmwv	SetPixLastC
mmwv	LineX
mmwv	LineY
mmwv	LineV
mmwv	PutAction
mmwv	NReadL
mmwv	NWriteL
mmwv	NSetC
mmwv	PaintBound
mmwv	SetTile
mmwv	ScanL
mmwv	ScanR
mmd	ScreenMode
mmd	BiosMode
mmd	Burst
mmd	ScrWidth
mmd	ScrHeight
mmd	HorzRes
mmd	VertRes
mmd	VideoBase
mmd	MaxAttr
mmd	MaxColor
mmd	PageSize
mmd	CurrPSize
mmd	MaxPage
mmd	NullColor
mmd	ForeColor
mmd	BackColor
mmd	EgaWrMd
mmd	ForeMapped
mmd	BitsPerPixel
mmd	Planes

purge	mmd, mmwv, mmdv, mmv, mmdi  ;no longer needed
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\ibmunv.inc ===
;***
;ibmunv.inc - 20-Mar-86
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

;******************************************************************************

;	Chess ROS I/O Macro Definitions for the IBM PC

;******************************************************************************

;	VECTOR INTERRUPT EQUATES

;******************************************************************************

	I_SCNIO=10H 		;VIDEO_IO
	I_CASIO=15H 		;CASSETTE_IO
	I_KYBIO=16H 		;KEYBOARD_IO
	I_PTRIO=17H 		;PRINTER_IO
	I_DOSIO=21H 		;MSDOS_IO

;******************************************************************************

;	ROS MONITOR INTERRUPT CALL MACRO DEFINITIONS

;******************************************************************************

; The ROSMAC macro is used to define other macros. These new macros can then
; be used to access the IBM ROM bios level services. Refer to the IBM TechRef
; Manual for additional information.

ROSMAC	MACRO	NAM,REG
NAM	MACRO	FUNC
IFNB	<REG>
	PUSH	BP
	PUSH	SI
	PUSH	DI
ENDIF				;IFNB <REG>
IFNB	<FUNC>
	MOV	AH,FUNC
ENDIF				;IFNB <FUNC>
	INT	I_&NAM
IFNB	<REG>
	POP	DI
	POP	SI
	POP	BP
ENDIF				;IFNB <REG>
	ENDM			;&NAM	MACRO
	ENDM			;ROSMAC	MACRO

; The SCNIOS macro is used to save a bit of code. Invoking this macro
; causes a call to the B$SCNIO routine rather than invoking the SCNIO
; macro directly. This saves 3 PUSHes and 3 POPs for all screen
; related activity.

SCNIOS	MACRO	FUNC		;;VIDEO_IO
IFNB	<FUNC>
	MOV	AH,FUNC
ENDIF
	CALL	B$SCNIO
	ENDM

KYBIO	macro	func		;;[1]
	PUSH	BP		;;[1]
	PUSH	SI		;;[1]
	PUSH	DI		;;[1]
ifnb	<func>			;;[1]
	MOV	AH,FUNC		;;[1]
  ifndef	b$RcoFlg	;;[1]
	extrn	b$RcoFlg:byte	;;[1]
  endif				;;[1] ifndef
	OR	AH,b$RcoFlg	;;[1] b$RcoFlg is either 0 or 10H in DOS3
endif				;;[1] ifnb <func>
	INT	I_KYBIO		;;[1]
	POP	DI		;;[1]
	POP	SI		;;[1]
	POP	BP		;;[1]
ENDM				;;[1] KYBIO

	ROSMAC	SCNIO,R		;;VIDEO_IO
	ROSMAC	CASIO		;;CASSETTE_IO
	ROSMAC	PTRIO,R		;;PRINTER_IO
	ROSMAC	DOSIO		;;MSDOS_IO

;******************************************************************************

;	BIOS Video Support Functions (use with SCNIO macro):

;******************************************************************************

	vSetMode EQU	0		;set screen mode
	vSetCursorType EQU	1	;set cursor type
	vSetCursorPos EQU	2	;set cursor position
	vReadCursorPos EQU	3	;read cursor position
	vReadLightPen EQU	4	;read light pen position
	vSelActivePage EQU	5	;select active display page
	vScrollPageUp EQU	6	;scroll active page up
	vScrollPageDown EQU	7	;scroll active page down
	vReadChar EQU	8		;read character and attribute
	vWriteChar EQU	9h	;write character and attribute
	vWriteCharOnly EQU	0ah	;write character only
	vSetPalette EQU	0bh	;set color palette
	vWritePixel EQU	0ch	;write pixel to screen
	vReadPixel EQU	0dh	;read pixel from screen
	vWriteTTY EQU	0eh	;write tty to active page
	vGetVideoState EQU	0fh	;gets current video state
	vSetEgaPalette EQU	010h	;set palette registers
	vCharGen EQU	011h	;character generator routine
	vAltSelect EQU	012h	;alternate select - get ega info
	vWriteString EQU	013h	;write string to screen
	vGetVgaInfo EQU 01bh	;[5]get vga information

;******************************************************************************

;	BIOS Cassette Support Functions (use with CASIO macro):

;******************************************************************************

	cMotorOn EQU	0		;turn cassette motor on
	cMotorOff EQU	1		;turn cassette motor off
	cReadCassette EQU	2	;read block from cassette device
	cWriteCassette EQU	3	;write block to cassette device

;******************************************************************************

;	BIOS Keyboard Support Functions (use with KYBIO macro):

;******************************************************************************

	kReadKeyboard EQU	0	;read character from keyboard
	kPollKeyboard EQU	1	;poll keyboard for presence of character
	kReadShiftKeys EQU	2	;get status of shift keys

;******************************************************************************

;	BIOS Printer Support Functions (use with PTRIO macro):

;******************************************************************************

	lptPrintChar EQU	0	;print character on printer
	lptInitPrinter EQU	1	;initialize printer device
	lptReadStatus EQU	2	;read status of printer device

;******************************************************************************

;	BIOS RS232C COM Port Support Functions:

;******************************************************************************

	comInitPort EQU	0	;initialize COM port
	comSendByte EQU	1	;send byte to COM port
	comRecByte EQU	2	;receive byte from COM port
	comGetStatus EQU	3	;get COM port status info

;******************************************************************************

;	Interrupts / Interrupt Vectors / I/O Ports / Misc Constants

;	The following Offsets are for Cells assuming DS:0

;******************************************************************************

;	Timer Constants:

	TIMINT	= 8H		;timer interrupt
	CLKINT	= 20h		;X'20' Clock Interrupt Vector
	CLKVEC	= 3C0h		;X'3C0' (ROM) Clock Interrupt vector
	ROMCLK	= 240		;ROM Clock Interrupt number
	TIMADR	= 70H		;X'70' Timer Int Vector
	TICSAV	= 512H		;X'512-515' Clock Int Vec save area
	TMRCTL	= 1CH		;timer control interrupt
	TIMER0	= 40h		;X'40' Timer 0 Port Address
	TIMER2	= 42h		;X'42' Timer 2 Port Address
	TMRCMD	= 43h		;X'43' Timer Control Port

;	8259 constants:

	INTA0	= 20h		;X'20' 8259 Interrupt Control Port
	INTA1	= 21H		;8259 Interrupt Mask Register Port
	EOI	= 20h		;X'20' 8259 End-of-Interrupt ACK
	MSKREG	= 21H		;8259 interrupt mask register

;	Joystick Event Constants:

	GAMECD	= 201H		;Game Card I/O address
	TRIG_A1	= 10H		;Trigger 'A1' Mask, Active Low
	TRIG_A2	= 20H		;Trigger 'A2' Mask, Active Low
	TRIG_B1	= 40H		;Trigger 'B1' Mask, Active Low
	TRIG_B2	= 80H		;Trigger 'B2' Mask, Active Low

;	Music / Sound constants:

	SPEAKER	= 61h		;X'61' Speaker Latch Port Address.
	SpkrOn	= 3		;Speaker On Mask
	SpkrEn	= 10h		;Speaker Enable/Disable Mask
	SQUARE	= 0B6h		;X'B6' Timer 2, Square Wave (Mode 3).
	SND_MAX	= 32		;Max number of Notes Que can hold
	TIADDR	= 0C0H		;X'C0' TI sound chip address

;	Keyboard Constants:

	KBDINT	= 24H		;X'24' Keyboard Interrupt Vector
	KBDVEC	= 3BCH		;X'3BC' (ROS) KBD Int Vector
	KYBINT	= 9H		;keyboard interrupt
	ROMKBD	= 239D		;ROM KBD INT vectors saved at 239*4
	KBDFLG	= 417H		;keyboard special status flag
	KBDATA	= 60H		;keyboard data

;	Screen related constants:

	PALSIZ	= 16		;palette size
	CHREXT	= 7Ch		;X'7C' Extended Character Set pointer.
	CRT_LEN = 44Ch		;[12] crt page length
	CRT_START= 44eh		;crt start address
	ACTIVE_PAGE = 462H	;[4] Active page# is stored here by BIOS
	BIOS_CursorPos = 450H	;[9]start of BIOS cursor position table
	CGA_STATUS = 3DAH	;[9]CGA card status port
	VERT_SYNC = 8		;[9] 1 on status port means vertical sync
	HORZ_SYNC = 1		;[9] 1 on status port means horizontal sync
	MEMRIO	= 23Ch		;Port for MS Jr Booster Card signature byte
	CR	= 13D		;ASCII carriage return
	LF	= 10D		;ASCII  line feed
	BiosEquip= 410h		;bios equipment register


;[7]	This macro is used to choose between word OUTs and byte OUTs when
;[7]	writing to the EGA card.  The routine B$OutWord does the equivalent
;[7]	of a word out 1 byte at a time because of rumoured problems with
;[7]	word OUTs.  Currently, the AT&T 6300 is the only machine known to
;[7]	have problems with word OUTs.  If it is decided that the speed gained
;[7]	by using word OUTs is more important than supporting the AT&T thing,
;[7]	change this macro and remove B$OutWord from LLCGRP.

OutWord MACRO
	CALL	B$OutWord	; or this line can read "OUT DX,AX"
;	OUT	DX,AX		; or this line can read "CALL B$OutWord"
	ENDM



;	EGA (Enhanced Graphics Adapter) constants:


	OFFSCN=6D60H 		;first even off-screen location
				;we need an off-screen location in
				; video memory for writing a tiling
				; pattern

;	Accessing screen memory through the EGA card is handled by reading
;	or writing either directly from/to memory or through a set of latch
;	registers which represent each of the four color memory planes which
;	are supported.  This access is controlled by sending information in
;	the form of binary numbers or bit patterns to the data port associated
;	with the graphics registers. The graphics register selected to receive
;	the data is specified as an offset index, this offset being written to
;	an address port associated with a particular data port.

;	The following definitions and routines are a convenient means for
;	coding these staged interactions with the hardware.

;	Addresses of, or offsets to, registers used :

;	SEQUENCER -----------------------------------------------------

	SEQADD=3C4H 		;sequencer address register(takes index)
	SEQDAT=3C5H 		;sequencer data port (receives data for
				; register indexed above)
	MMREG=2			;offset to map mask register
				;/ ENABLES PLANES 0-3
				;/ FOR 32-BIT WRITE
	MMDREG=4 		;memory mode register

;	GRAPHICS --------------------------------------------------------

	GRPADD=3CEH 		;graphics address register
	GRPDAT=3CFH 		;graphics data port
	SRSREG=0 		;set/reset register
				;/ IF WRITE MODE 0, BINARY
				;/ VALUE OF COLOR TO WRITE
	ENBREG=1 		;enable set/reset register
				;/ BITS 0-3 ENABLE PLANES
				;/ FOR WRITING FROM SETRES
				;/ IF 0, WRITE IS FROM
				;/ PROCESSOR DATA
	CLCREG=2 		;color compare register
				;/ BITS 0-3 ARE COLOR VALUE
				;/ TO BE COMPARED
	DTRREG=3 		;data rotate register
				;/ BITS 0-2 = POSITIONS TO
				;/ ROTATE FOR WRITE
				;/ BITS 3-4 = LOGICAL OPS
				;/ WITH LATCHED DATA
	RMPREG=4 		;read map select register
				;/ BINARY REP OF PLANE FOR
				;/ READ
	RWMREG=5 		;read/write mode register
				;/ WRITES : BITS 1 0
				;/ 00 = DATA WRITE FROM
				;/ PROCESSOR OR SET-RESET
				;/ 01 = LATCH WRITE
				;/ 10 = BYTE <-- COLOR
				;/ READS : BIT 3
				;/ 0 = READ FROM PLANE
				;/ SPECIFIED BY READMP
				;/ 1 = COMPARE PIXEL COLOR
				;/ WITH COLOR COMPARE
				;/ ODD/EVEN : BIT 4
				;/ 1 = ODD/EVEN ADDRESS MODE
	CDCREG=7 		;color don't care register
				;/ BITS 0 - 3 REPRESENT 4
				;/ PLANES; 0 SPECIFIES IGNORE
				;/ PLANE WHEN DOING COLOR
				;/ COMPARE READ
	BMKREG=8 		; bit mask register
				;/ BITS 0 - 7 WHEN SET TO
				;/ 0 PROTECT BIT FROM WRITE

;	ATTRIBUTE -----------------------------------------------------

	ATTADD=3C0H 		;attribute address register - used also for data
				;via alternating OUTs


;[8] Constants and macros used by EGAINT10 interface.

EGAINT	MACRO	FUNC		;[8]run EGA outs through egaint10 interface
IFNB	<FUNC>
	MOV	AH,FUNC
ENDIF
	INT	10H
	ENDM

EGAINT10CLI MACRO		;[8]disable interrupts if HG_EGAINT10
	ENDM

EGAINT10STI MACRO		;[8]enable interrupts if HG_EGAINT10
	ENDM


;	COM port constants:

	IRQ3	= 11d*4		;COM2 interrupt level - Int loc for COM card @ 2xxh
	IRQ4	= 12d*4		;COM1 interrupt level - Int loc for COM card @ 3xxh

	RS232B	= 400H		; X'400' RS232 Card(s) I/O addr Save area.

	RDAIE	= 1		; Read Data Available   Interrupt Enable
	TBEIE	= 2		; Transmit Buffer Empty Interrupt Enable
	MSRIE	= 8		; Modem Status          Interrupt Enable

	CTS	= 10H		;Clear To Send
	DSR	= 20H		;Data Set Ready
	RLSD	= 80H		;Received Line Signal Detect (CD)

	XMIT_BUF_SIZE = 80H	;[6] length of output buffer

	PAGE

;******************************************************************************

;	enable and disable

;******************************************************************************

	ENABLE	EQU	STI
	DISABLE	EQU	CLI

;******************************************************************************

; The PAUSE macro is required because a number of Intel's early 286 processors
; had defects. The PAUSE macro is required whenever there is a number of
; IN and OUT instructions in close proximity to each other.
; This macro insures that an instruction fetch occurs between IN and/or OUT
; instructions on the IBM PC AT machine.

; Note:	OEMs should be able to disregard this macro by removing the JMP
;	instruction.

;******************************************************************************

PAUSE	MACRO			;macro to insure that an instruction
	JMP	$+2		;fetch occurs between IN and/or OUT
	ENDM			;instructions on the IBM PC AT machine

;***************************************************************************
;
;       8086 Interrupt Handling Macros
;       MS-DOS 1.0 does not have INT 21 to GET a vector
;       hence SAVINT just moves interrupts around.
;
;***************************************************************************

	SVINT	MACRO   savloc,intloc,reg
	IFB	<reg>
	SVINT	savloc,intloc,AX
	ELSE
	MOV	reg,intloc
	MOV	savloc,reg
	MOV	reg,intloc+2
	MOV	savloc+2,reg
	ENDIF
	ENDM

;****************************************************************************
;
;	The following macros use the MS-DOS INT 21 call to change
;	interrupt vectors.
;
;****************************************************************************

savint	macro	savloc,intvec 
	MOV	AX,3500H+INTVEC/4 ;;[2]AH=get int - AL=interrupt number
	int	21h
	mov	word ptr savloc,bx ;;savloc = offset
	mov	word ptr savloc+2,es ;;savloc+2 = segment
	endm

setvec	macro	interrupt,offset_adr ;;set interrupt vector function call
	mov	dx,offset offset_adr
	MOV	AX,2500H+INTERRUPT ;;[2]AH=set int call - AL=interrupt
	int	21h
	endm

rstvec	macro	interrupt,save_adr ;;restore interrupt from saved
	lds	dx,dword ptr save_adr
	MOV	AX,2500H+INTERRUPT ;;[2]AH=set int call - AL=interrupt
	int	21h
	endm

XFRINT	MACRO	TOINT,FROMINT	;;move FROMINT to TOINT
	PUSH	ES		;;save register...
	MOV	AX,3500H+FROMINT ;;want to get FROMINT
	INT	21H		;;vector now in ES:BX
	MOV	AX,ES		;;keep segment around
	POP	ES		;;restore register...
	MOV	DX,BX		;;move offset for put
	PUSH	DS		;;save register...
	MOV	DS,AX		;;segment for put
	MOV	AX,2500H+TOINT	;;want to put TOINT
	INT	21H		;;vector now in DS:DX
	POP	DS		;;restore register
	ENDM

;******************************************************************************

;	Queue Structures for music and communications

;******************************************************************************

; This queue structure is used by the MUSIC queues and
; the COM buffer queues (both input and output). The
; field QUNOTE is not used by the COM buffer queues
; but will be present as a dummy field so that the same
; queue manipulation routines may be used.

;******************************************************************************

QUE_CTRL_BLOCK STRUC

	QUNOTE	DW ?		; Number of notes in Bkgnd queue
	QUETOP	DW ?		; Top of Queue Location
	QUEBOT	DW ?		; Bot of Queue Location
	QUELEN	DW ?		; Length of Queue
	QUENUM	DW ?		; Number of bytes in Que
	QUEGET	DW ?		; Queue get pntr
	QUEPUT	DW ?		; Queue put pntr

QUE_CTRL_BLOCK ENDS

QUSIZE	=	SIZE QUE_CTRL_BLOCK

QLENTH	=	32*6		;room for 32 notes (exactly)

QUE_CTRL_LEN =	QUSIZE		;Length of Queue Control Block

	SPCSIZ=	QLENTH+16*3	;non-IBMPCJr queue size
				;one full size; two 16-byte
				;for SYNC's; NOISE queue
	HALSIZ=	QLENTH*3+QLENTH/2 ;PC Jr queue size; Three full
				;size queues; half size
				;queue for noise

;******************************************************************************
;	EQUates for $DONOTE input value in AL
;	The value of these equates is quite important as $DONOTE depends on
;	them.
;	Function codes to be passed to B$DONOTE
;******************************************************************************

	QUERST=0D		;[3] Queue an internote pause (rest)
	QUENOT=1D		;[3] Queue a note
	TSTVOC=2D		;[3] Test if voice is active
	QUESYN=3D		;[3] Queue synchronization mark
	SETESH=4D		;[3] Queue an envelope shape request
	SETEPR=5D		;[3] Queue an envelope period request
	MKNOIS=6D		;[3] Support NOISE statement
	SNDONF=252D		;[3] SOUND ON/OFF
	BEPONF=253D		;[3] BEEP  ON/OFF
	STRSND=254D		;Start sound
	STPSND=255D		;Stop sound and flush the queues

	DFLVOL=-1		;[3] Default Volume (-1)

;******************************************************************************
	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\llgrp.inc ===
;***
; llgrp.inc - 01-May-87 - lowlevel graphics definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
; Contains the definition of symbols used in lowlevel graphics modules.
; 
;******************************************************************************

; Graphics adapter types (values used in b$Adapter)

MDPA	=	00000001B	;Monochrome Display/Printer Adapter
CGA	=	00000010B	;Color Graphics Adapter
EGA	=	00000100B	;Enhanced Graphics Adapter
VGA	=	00001000B	;Video Graphics Array
MCGA	=	00010000B	;MultiColor Graphics Array
HGC	=	00100000B	;Hercules Graphics Card 		[1]
OGA	=	01000000B	;Olivetti Graphics Adapter		[4]

; Monitor types (values used in b$Monitor)

Monochrome  =  00000001B	;Monochrome monitor
StdColor    =  00000010B	;Standard Color monitor
				; (or Enhanced Color in compatibility mode)
EnhColor    =  00000100B	;Enhanced Color monitor
AnalogMono  =  00001000B	;Analog monitor supporting monochrome modes
AnalogColor =  00010000B	;Analog monitor supporting color modes

; Note: The definition of AnalogMono and AnalogColor is somewhat unusual:
;	IBM's Analog monitors are called Analog Color (which shows 256k colors)
;	and Analog Monochrome (which shows 64 shades of gray).	This is NOT
;	the definition being used here.  That distinction is unnecessary for
;	our purposes because both types support what the bios considers "color"
;	modes and "monochrome" modes.  The definition we use is based on what
;	bios modes are available in the current environment.  This is defined
;	by what secondary video cards (if any) are present in the machine.
;	If a CGA is present, then the VGA driving the Analog monitor is
;	limited by the bios to monochrome modes (7 & F).  This is "AnalogMono".
;	Similarly, if there is an MDPA present, the VGA is limited by the bios
;	to using color modes (all modes except 7 & F).	This is "AnalogColor".
;	If the VGA is the only video card in the system, then both the
;	AnalogMono bit and the AnalogColor bit of b$Monitor will be set,
;	indicating that all bios modes (color and monochrome) are available.

; Constants used b$VGAmodes to test which BIOS modes are supported.

VGAmode0h	= 00000001B	; supports BIOS mode 0h
VGAmode1h	= 00000010B	; supports BIOS mode 1h
VGAmode2h	= 00000100B	; supports BIOS mode 2h
VGAmode3h	= 00001000B	; supports BIOS mode 3h
VGAmode4h	= 00010000B	; supports BIOS mode 4h
VGAmode5h	= 00100000B	; supports BIOS mode 5h
VGAmode6h	= 01000000B	; supports BIOS mode 6h
VGAmode7h	= 10000000B	; supports BIOS mode 7h
VGAmodeDh	= 20h		; supports BIOS mode Dh
VGAmodeEh	= 40h		; supports BIOS mode Eh
VGAmodeFh	= 80h	  	; supports BIOS mode Fh
VGAmode10h	= 00000001B	; supports BIOS mode 10h
VGAmode11h	= 00000010B	; supports BIOS mode 11h
VGAmode12h	= 00000100B	; supports BIOS mode 12h
VGAmode13h	= 00001000B	; supports BIOS mode 13h

HALF		= 1		;[4] Hercules HALF mode value
	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\mathmac.inc ===
;***
; mathmac.inc - 20-Mar-86 - Helper macroes for elementary functions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************


S_MOV	MACRO	op1,op2
	MOV	SI,offset DGROUP:&op2
	MOV	DI,offset DGROUP:&op1
	MOVSW
	MOVSW
	ENDM

S_PUSH	MACRO	op1
	PUSH	[op1]
	PUSH	[op1+2]
	ENDM

S_POP	MACRO	op1
	POP	[op1+2]
	POP	[op1]
	ENDM

D_MOV	MACRO	op1,op2
	MOV	SI,offset DGROUP:&op2
	MOV	DI,offset DGROUP:&op1
	MOVSW
	MOVSW
	MOVSW
	MOVSW
	ENDM

D_PUSH	MACRO	op1
	PUSH	[op1]
	PUSH	[op1+2]
	PUSH	[op1+4]
	PUSH	[op1+6]
	ENDM

D_POP	MACRO	op1
	POP	[op1+6]
	POP	[op1+4]
	POP	[op1+2]
	POP	[op1]
	ENDM

OPER	MACRO	ty,op
&ty&_&op MACRO	op1,op2
	MOV	SI,offset DGROUP:&op1
	MOV	DI,offset DGROUP:&op2
	CALL	$&ty&&op
	&ENDM
	ENDM

OPER	S,ADD
OPER	S,SUB
OPER	S,MUL
OPER	S,DIV
OPER	S,CMP

OPER	D,ADD
OPER	D,SUB
OPER	D,MUL
OPER	D,DIV
OPER	D,CMP

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\lmem.inc ===
;***
;lmem.inc - LMEM constants and entry points
;***
	.XLIST
;***
;
;	Copyright <C> 1988, Microsoft Corporation
;
;Purpose:
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME
;	NOTE: and the interpreter projects.  Any changes made to one should
;	NOTE: be carried over to the other!!!
;	NOTE: There are some minor differences between the two versions for
;	NOTE: this file, so DO NOT just copy it!!!
;
;******************************************************************************

	include	sb.inc

fcmpNoCompact		equ	0
fcmpCompact		equ	1
fcmpCompactHandles	equ	2
merrAllocMoveable	equ	1
merrAllocFixed		equ	2
merrReallocMoveable	equ	3
merrAllocBlock		equ	4

;Special Zeros
pvZero		equ	12H	;a pointer to 0 length block, 1st word is 0
ppvZero		equ	14H	;a pointer to pvZero

;Entry points
extrn	CreateHeap:far		;(SB)
extrn	CbCompactHeap:far	;(SB, WORD)
extrn	PpvAllocCb:far		;(SB, WORD)
extrn	FReallocPpv:far		;(SB, VOID **, WORD)
extrn	FreePpv:far		;(SB, VOID **)
extrn	FreeDataPpv:far 	;(SB, VOID **)
extrn	CbSizePpv:far		;(SB, VOID **)
extrn	FResizePpv:far		;[1]realloc w/o data copy
extrn	PpvWalkHeap:far		;(SB, VOID **)

extrn	HFirstAllocBlock:far	;(SB, WORD)
extrn	FreeHandleBlock:far	;(SB, VOID **)
extrn	FreeHandleBlockCh:far	;(SB, WORD, VOID **)


comment	| Unused entry points are kept below, in case they're needed later

extrn	PvAllocFixedCb:far	;(SB, WORD)
extrn	CbSizeFixedPv:far	;(SB, VOID *)
extrn	LockHeap:far		;(SB)
extrn	UnlockHeap:far		;(SB)

extrn	FCreateWindowsHeap:far	;(SB, WORD)
extrn	SwapHandles:far		;(SB, VOID **, VOID **)

;Debug entry points
extrn	CheckHeap:far		;(SB)
extrn	ShakeHeapSb:far		;(SB)
extrn	GetHeapInfo:far		;(SB, CKL FAR *)
extrn	FCheckHandle:far	;(SB, VOID **)
extrn	PvWalkFixedHeap:far	;(SB, VOID *)
	|
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\oscalls.inc ===
;***
;oscall.inc - 20-May-86  -  Dos 3/5 macros and definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This include file contains structures and definitions for
;	the Operating system interface.
;
;******************************************************************************

	SUBTTL	"Operating system data structures and definitions"

;******************************************************************************
;* Disk and Device I/O data structures
;******************************************************************************

VOLUME_OR_SUBDIR	EQU	18H	;DOSQFILEMODE mask for subdir or vol label

SearchInfo	STRUC			;information used in DosFindFirst etc.
	CreatDate	DW	?	;date file was created
	CreatTime	DW	?	;time file was created
	AcessDate	DW	?	;date of last file access
	AccessTime	DW	?	;time of last access
	WriteDate	DW	?	;date of last write to file
	WriteTime	DW	?	;time of last write
	EOFPtr		DD	?	;end of file pointer
	EOAPtr		DD	?	;end of allocated space pointer
	fBlock		DW	?	;blocking flag
	FileAttribute	DW	?	;file attribute (hidden, archive, etc)
	cbFileName	DB	?	;length of file name
	szFileName	DB	128 DUP(?)	;file name
SearchInfo	ENDS


FsInfo	STRUC				;file system information
	FsID		DD	?	;file system ID
	cSecUnit	DD	?	;Number of sectors per allocation unit
	cUnits		DD	?	;Number of allocation units
	cUnitsAvail	DD	?	;Number of available allocation units
	cBytesSec	DW	?	;Number of bytes per sector
FsInfo	ENDS

;******************************************************************************
;* Miscellaneous data structures
;******************************************************************************

TimeDate	STRUC
	Hour		DB	?	;current hour
	Minute		DB	?	;current minute
	Second		DB	?	;current second
	Hundredth	DB	?	;current hundredth of a second
	Day		DB	?	;current day
	Month		DB	?	;current month
	Year		DW	?	;current year
	TimeZone	DW	?	;Time zone minutes from GMT
	WeekDay 	DB	?	;current day of the week
TimeDate	ENDS

;******************************************************************************
;* Keyboard data structures
;******************************************************************************

CharData	STRUC
	AsciiCode	DB	?	;ASCII character code
	ScanCode	DB	?	;Character Scan code
	Status		DW	?	;0=no chars avail
					;1=char is available (interim flag off)
					;2=means Interim char available
					;3=final char avail (interim flag on)
	fShift		DW	?	;state of shift keys
	TimeStamp	DB 4 DUP(?)	;hr min sec sec/100
CharData	ENDS


KbdStatus	STRUC
	KLength 	DW	5	;high byte reserved by DOS
					;low byte = length of KbdStatus struct
	ModeMask	DW	?	;input mode bit fields
					;High byte = 0 (reserved)
					;low byte bits
					; 7 - 0 reserved
					; 6 - 1 = modifying CR character
					; 5 - 1 = modifying interim char flags
					; 4 - 1 = modifying shift state
					; 3 - 1 = COOKED input mode
					; 2 - 1 = RAW input mode
					; 1 - 1 = ECHO off
					; 0 - 1 = ECHO on
	CRChar		DW	?	;high byte = 0, low byte = ASCII char
					;being defined as new Carriage return
					;character
	InterimFlag	DW	?	;high byte = 0, low byte bit fields
					; 7 - 1 = Interim char flag = ON
					; 6 - 0 reserved
					; 5 - 1 = on-the-spot conversion
					; 4/0 - 0 reserved
	ShiftState	DW	?	;high byte = 0, low byte bit fields
					; 7 - 1 = Insert ON
					; 6 - 1 = CapsLock ON
					; 5 - 1 = NumLock ON
					; 4 - 1 = ScrollLock ON
					; 3 - 1 = Alt key down
					; 2 - 1 = Ctrl key down
					; 1 - 1 = Left Shift key down
					; 0 - 1 = Right Shift key down
KbdStatus	ENDS

;******************************************************************************
;* Screen I/O data structures
;******************************************************************************

ScreenModeData	STRUC
	SLength DW	12D	;Length of ModeData including Length (in bytes)
	Mode	DB	?	;type: bit 0 = color adapter
				;	   1 = graphics mode
				;	   2 = color burst disable
	Color	DB	?	;colors: 0=mono, 1=2, 2=4, 4=16
	ColNum	DW	?	;number of columns
	RowNum	DW	?	;number of Rows
	HorRes	DW	?	;Horizontal pixel resolution
	VerRes	DW	?	;Vertical pixel resolution
ScreenModeData	ENDS

CursorData	STRUC
	StartLine	DW	?	;Starting Scan line for cursor
	EndLine 	DW	?	;Ending Scan line for cursor
	CWidth		DW	?	;0=1Column, !0=pixel width
	Attribute	DW	?	;-1=Hidden, else normal(text) or
					;color attribute(graphics)
CursorData	ENDS


CharCell	STRUC
	Char	DB	?	;character
	Attrib	DB	?	;color Attribute of Char
CharCell	ENDS

;******************************************************************************
;* Program EXEC and environment constants and structures
;******************************************************************************

	SYNC_EXEC	EQU	0	;[1]synchronous execution
	ASYNC_EXEC	EQU	1	;[1]asynchronous execution, throw away
					;[1]exit code
	ASYNC_EXEC_CODE EQU	2	;[1]asynchronous execution, remember
					;[1]exit code

	NO_SYS_TRACE	EQU	0	;[1]EXEC without system debugging
	SYS_TRACE	EQU	1	;[1]EXEC with system debugging

;******************************************************************************
;* OFFSETS of items in the GDT and LDT info segments
;******************************************************************************

;GDT TIME offsets

GDT_ELAPSED_SEC EQU	0	;[2]seconds from 1-1-1970
GDT_MILLISEC	EQU	4	;[2]milliseconds
GDT_HOUR	EQU	8	;[2]current HOUR
GDT_MINUTE	EQU	9	;[2]current MINUTE
GDT_SECOND	EQU	0AH	;[2]current SECOND
GDT_HUNDRED	EQU	0BH	;[2]current HUNDREDTH of a second
GDT_TIMEZONE	EQU	0CH	;[2]minutes from GMT
GDT_TIMER	EQU	0EH	;[2]timer interval (.0001)

;GDT DATE offsets

GDT_DAY 	EQU	10H	;[2]current DAY
GDT_MONTH	EQU	11H	;[2]current MONTH
GDT_YEAR	EQU	12H	;[2]current YEAR
GDT_WEEKDAY	EQU	14H	;[2]current WEEKDAY

;GDT Version offsets

GDT_MINOR_VER	EQU	15H	;[2]OS minor version number
GDT_MAJOR_VER	EQU	16H	;[2]OS major version number
GDT_REVISION	EQU	17H	;[2]OS revision letter

;GDT system status offsets

GDT_SCREENGROUP EQU	18H	;[2]current screen group
GDT_MAX_SCREEN	EQU	19H	;[2]maximum number of screen groups
GDT_HUGE_SHIFT	EQU	1AH	;[2]HUGE segment shift count
GDT_PROTECTONLY EQU	1BH	;[2]protect mode only flag

;GDT scheduler parameter offsets

GDT_DYNAMIC	EQU	1CH	;[2]dynamic variation flag
GDT_MAX_WAIT	EQU	1DH	;[2]maximum wait period
GDT_MIN_SLICE	EQU	1EH	;[2]minimum time slice
GDT_MAX_SLICE	EQU	20H	;[2]maximum time slice

;LDT offsets

LDT_PID 	EQU	0	;[2]process ID
LDT_PARENT_PID	EQU	2	;[2]parent process ID
LDT_PRIORITY	EQU	4	;[2]priority of current thread
LDT_THREAD_ID	EQU	6	;[2]thread ID
LDT_SCREENGROUP EQU	8	;[2]process screen group
LDT_SUBSCREEN	EQU	0AH	;[2]sub screen group
LDT_FOREGROUND	EQU	0CH	;[2]process in foreground flag

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\omega.inc ===
sbMth = 		12		
sbEbMin = 		14
sbFile = 		sbEbMin
sbString = 	sbEbMin+1
sbRs = 		sbEbMin+2
sbGVar = 		sbEbMin+3
sbGNam = 		sbEbMin+4
sbDirect = 	sbEbMin+5
sbQRun = 		24	    
sbMin = 		sbQRun+8    
sbMacInit = 	256			
cchModuleNameMax = 	63	
pgtypDbHeader =  			1
pgtypFree =  				2
pgtypDirectory =  			3
pgtypLeaf =  				4
pgtypDfHeader =  			5
pgtypData =  				6
pgtypTractAllocation =  	7
pgtypSegmentFreeMap =  	8
pgtypRcl =  				9
pgtypSort =  				10
pgtypSortInt =  			12
pgtypSortMerge =  			13
pgtypRd =  				14
pgtypRandom = 				15
pgtypSeqio =  				16
pgtypLog = 				17
pgtypPlex = 				18
pgtypMax = 				19
pgtypHeap =  				20
pgtypHeapMin = 			pgtypHeap
pgtypForm = 				21
pgtypMenu = 				22
pgtypHeapMax = 			pgtypMenu+1
pgtypEBPcode = 			23
pgtypEBRsTable = 			24
pgtypEBNameTable = 		25
pgtypEBVarTable = 			26
pgtypEBArrays = 			27
pgtypEBScratch = 			28
pgtypEBGeneric = 			29
wPgtypMask =  127
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\nhutil.inc ===
;***
; NHUTIL.INC - 15-May-86 - Near Heap structures and definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Near heap structures and definitions.
;
;******************************************************************************

;	Heap Entry Header format:

LHTYPE	EQU	 0		;local heap block type
LHFNUM	EQU	-1		;local heap file number (for FILE block)
LHLEN	EQU	-3		;local heap block length (including header)
LHBAKP	EQU	-5		;local heap backpointer (pointer to owner)
LHPOFF	EQU	-7		;local heap sd offset (for FILE blocks only)
LHPLEN	EQU	-9		;local heap sd length (for FILE blocks only)

LH_STD_HDR_LEN EQU	 6	;local heap standard header size
LH_FDB_HDR_LEN EQU	10	;local heap fdb header size (includes 4 bytes
				;	of sd for fielded strings)


;	Heap entry type-byte constants (LHTYPE, above):

	LH_FREE 	EQU	01h	;free entry
	LH_ARRAY	EQU	02h	;dynamic string array in entry
	LH_END		EQU	04h	;last block in heap
	LH_FILE 	EQU	08h	;FDB (field buffer) in entry
	;the type byte is split into two nibbles; the low nibble contains only
	;  the above general-purpose type constants. The high nibble is
	;  reserved for the interpreter. If the high bit (bit 7) is set,
	;  the entry is an interpreter entry. If any of bits 4, 5, or 6 are set
	;  then we must call back to the interpreter for it to adjust 
	;  backpointers to any owners in the entry.
	LH_IM_ENTRY	EQU	080h	;mask to see if interp. entry
	LH_I_NO_OWNERS	EQU	080h	;entry contains no owners
	LH_I_IN_USE_1	EQU	090h	;used by interpreter
	LH_I_IN_USE_2	EQU	0A0h	;used by interpreter
	LH_I_IN_USE_3	EQU	0B0h	;used by interpreter
	LH_I_IN_USE_4	EQU	0C0h	;used by interpreter
	LH_I_IN_USE_5	EQU	0E0h	;used by interpreter
	LH_I_IN_USE_6	EQU	0F0h	;used by interpreter
	LH_IM_CALL_BACK EQU	070h	;mask of three bits; if any of
					;  these three bits set, must call back
					;  to interpreter to update

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\pointers.inc ===
;***
;pointers.inc - 30-Dec-87 - pointer reference macros
;***
	.XLIST
;***
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	To provide a set of macros for pointer reference whether they are
;	NEAR (1-word) or FAR (2-word).	FAR pointers may also have an SB
;	index instead of a true physical segment.
;
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME and
;	NOTE: the interpreter projects.  Any changes made to one should
;	NOTE: be carried over (COPIED) to the other!!!
;
;******************************************************************************

POINTERS_INC = -1   ;needed by QBI sources which also include this file.

;FV_SBPTR determines the type of 2-word pointers used in manipulating
;Far Heap and some Near Heap accesses.	When OFF, these pointers contain
;an actual physical segment.  When ON, they contain an SB (Segment Base)
;which is an index to a table containing the actual physical segment.
;The following MACRO's attempt to hide these differences.

;[2]FV_SBSWAP is ON if an SB can be swapped out of active memory.  (Swapped
;[2]to disk or out of active EMM.)

;***
;GETSB_SEG - macro to get an SB's physical segment
;
;Purpose:
;	Added with [2].
;	This macro allows us to access the physical segment of an SB.
;Entry:
;	dest -	register in which the SB physical segment is to be placed
;	srce -	the SB index
;	temp -	a temporary register is required and should be used only when:
;		    SPEED, NOLOAD, (NOT FIXED) temp must be index reg
;		    SPEED, LOAD,   (NOT FIXED) temp must be index reg != dest
;		    SPEED, LOAD,   FIXED
;		    SIZE,  NOLOAD, FIXED
;		    SIZE,  LOAD,   FIXED
;	opt  -	any combination of the following options:
;		    SIZE to optimize macro code for size
;		    SPEED to optimize macro code for speed (default)
;		    LOAD tests for and reloads non-resident blocks
;		    NOLOAD no test or reload (default)
;		    FIXED if 'srce' is a fixed SB constant
;			(FIXED is also implied if srce is a constant)
;		    NOFLUSH to prohibit the flushing of all EMM blocks in
;			non-release versions
;		    FLUSH to cause EMM flushing (default)
;
;Exit:
;	register 'dest' contains the SB physical segment of 'srce'.
;Notes:
;	ES and DS are always preserved (when != dest) for SPEED and NOLOAD.
;	ES and DS are preserved (when != dest) for SIZE or LOAD if:
;	    -- it is psCur, or
;	    -- it is locked, or
;	    -- it is not-EMM and (non-swappable OR non-discardable)
;	When a desired option is important it should be specified rather
;	    than defaulted so that the defaults may be changed.
;Examples:
;	GETSB_SEG   es,[grs.GRS_sbVar],,<SIZE,LOAD>
;	GETSB_SEG   ds,bx,bx,<SPEED,NOLOAD>
;
;**************************************************************************
GETSB_SEG   MACRO   dest,srce,temp,opt
	LOCAL	NoReload
	?sz = 0 			;;default SPEED (not SIZE)
	?ld = 0 			;;default NOLOAD (not LOAD)
	?fx = 0 			;;default not FIXED
	?fl = 1 			;;[8]default FLUSH

	irp x,<opt>
	  ifidni <x>,<SIZE>		;;if SIZE,
	    ?sz=1			;;  set size flag
	  elseifidni <x>,<SPEED>	;;if SPEED,
	    ?sz=0			;;  clr size flag
	  elseifidni <x>,<LOAD> 	;;if LOAD,
	    ?ld=1			;;  set load flag
	  elseifidni <x>,<NOLOAD>	;;if NOLOAD
	    ?ld=0			;;  clr load flag
	  elseifidni <x>,<FIXED>	;;if FIXED
	    ?fx=1			;;  set fixed flag
	  elseifidni <x>,<FLUSH>	;;[8]if FLUSH
	    ?fl=1			;;  [8]set flush flag
	  elseifidni <x>,<NOFLUSH>	;;[8]if NOFLUSH
	    ?fl=0			;;  [8]clr flush flag
	  else
	    if1
	      %out invalid GETSB_SEG option: &x
	    endif
	    .err ;invalid GETSB_SEG option
	  endif
	endm

	?sz = 0 			;;  always SPEED
	?ld = 0 			;;  and NOLOAD
	?fl = 0 			;;[10]and NOFLUSH

	?fl = 0 			;;[10]NOFLUSH in RELEASE versions

if (.type srce) and 04H 		;;if srce is a constant
	?fx = 1 			;;  must be a FIXED SB
endif

if ?sz AND ?fx AND NOT ?ld		;;SIZE & FIXED & !LOAD is actually
	?sz = 0 			;;  smaller as !SIZE
endif

if ?sz					;;SIZE
  if ?fx				;;  FIXED
	mov	temp,srce		;;    can't push constant
	push	temp
  else					;;  not FIXED
	push	srce			;;    sb arg to call on stack
  endif

  if ?fl				;;[10]if EMM flushing desired
      % extrn	Flush_&&?segname:near	;;  [9]then do it
      % call	Flush_&&?segname	;;  [9]
  endif 				;;[9]
      % extrn	DerefSb_&&?segname:near ;;    [10]
      % call	DerefSb_&&?segname	;;    [10]top of stack = phys seg
	pop	dest			;;    [10]dest = phys seg
else					;;SPEED version
  if ?fx				;;  FIXED

    if ?fl				;;[10]if EMM flushing desired
      % extrn	Flush_&&?segname:near	;;  [9]then do it
      % call	Flush_&&?segname	;;  [9]
    endif				;;[9]

	mov	dest,mpsbps[srce*2]	;;    fetch seg direct from sb table
  else					;;  not FIXED
    ifdifi  <temp>,<srce>		;;    if temp != srce
	mov	temp,srce		;;	temp = srce  (SB)
    endif

    if ?fl				;;[10]if EMM flushing desired
      % extrn	Flush_&&?segname:near	;;  [9]then do it
      % call	Flush_&&?segname	;;  [9]
    endif				;;[9]

	shl	temp,1			;;    shift to make it a table index
	mov	dest,mpsbps[temp]	;;    fetch seg from sb table
  endif
  if ?ld				;;  LOAD
    ifidni  <dest>,<ds> 		;;    [8]if dest == ds
	?over	EQU <BYTE PTR SS>	;;    [8]  force SS override to DGROUP
    else				;;    [8]else
	?over	EQU <BYTE PTR DGROUP>	;;    [8]  insure DGROUP
    endif				;;    [8]
    if ?fx				;;    [4]
	test	?over:mpsbps[srce*2],1	;;    [8]test for resident segment
    else				;;    [4]
	test	?over:mpsbps[temp],1	;;    [8]test for resident segment
      ifidni <dest>,<temp>		;;    [10]temp must be != dest here
	if1				;;    [10]
	  %out temp == dest not allowed here;;[10]
	endif				;;    [10]
	.err ;temp == dest not allowed here   [10]
      endif				;;    [10]
    endif				;;    [4]
	jnz	NoReload		;;    [4]skip reload if resident
    if ?fx
	mov	temp,srce		;;    [10]
    else				;;    [10]
	shr	temp,1			;;    [10]restore SB index
    endif
	push	temp			;;    [4]
      % extrn	DerefSb_&&?segname:near ;;    [10]
      % call	DerefSb_&&?segname	;;    [10]top of stack = phys seg
	pop	dest			;;    [10]dest = phys seg

NoReload:				;;    [6]
  endif   ;;LOAD
endif	;;SIZE/SPEED
	ENDM


DGROUPSEG   EQU <SS>	;DGROUP is in SS


;***
;GETSEG - macro to access the physical segment of a far heap descriptor.
;
;Purpose:
;	Rewritten with [2].
;	This macro allows us to access the segment of a far heap descriptor
;	in different ways, depending on our far heap code support scheme.
;Entry:
;	see GETSB_SEG.
;Exit:
;	register 'dest' contains the physical segment address.
;
;**************************************************************************
GETSEG	MACRO	dest,srce,temp,opt

	mov	dest,srce		;;fetch seg address directly
	ENDM

;***
;GETPTR - macro for FAR/HUGE pointer reference
;
;Purpose:
;	Rewritten with [2].
;
;	This macro allows us to use a pointer whether it be FAR (with actual
;	physical segment) or HUGE (with an SB segment).
;	HUGE pointers are used when FV_SBPTR is on.
;
;	The result will always be a FAR pointer (with actual physical segment)
;	in a register pair.
;
;Entry:
;	alias - the name to use for subsequent pointer reference.
;	seg   - register to receive the physical segment.
;		seg must be a segment register to use alias.
;	reg   - register to receive the address offset of the pointer.
;		reg must be an index register to use alias.
;	srce  - source of the pointer.  Must be defined with parmDP or localDP.
;	temp  - the temporary register to use for dereferencing the SB.
;		If not provided, reg will be used (see GETSEG).
;	opt   - see GETSB_SEG.
;Exit:
;	seg:[reg] - contains the physical pointer
;	alias	  - is a name (equated to seg:[reg]) to use when referencing
;		    the pointer, so long as seg and reg remain undisturbed.
;**************************************************************************
GETPTR	MACRO alias,seg,reg,srce,temp,opt
ifnb	<alias>
alias	equ	seg:[reg]		;;  set up alias
endif
  ifidni <seg>,<es>
	les	reg,srce		;;  optimize segreg ES load wo/SB
  elseifidni <seg>,<ds>
	lds	reg,srce		;;  optimize segreg DS load wo/SB
  else
	mov	seg,SEG_&srce		;;  load seg (not a segreg)
	mov	reg,OFF_&srce		;;  and get offset
  endif
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\qcg.inc ===
;***
;QCG - QuickC Graphics Library Definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	QuickC Graphics Library definitions.
;
;******************************************************************************

PAINTQSIZE	= 2176	;min required for "H" pattern flood-fill
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\messages.inc ===
;***
; MESSAGE.INC - 20-Jul-87 - Runtime Message Definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Message text, number and symbol information. If the macro RTEDEF has
;	already been defined, we just use it, else we use a macro which just
;	defines the symbolic labels that the error numbers relate to.
;
;******************************************************************************
	PAGE
;******************************************************************************
;
; Message Isolation and Internationalization.
;
; All text messages in the BASIC runtime are defined in this file. A kit is
; provided to allow an OEM customer to alter the text of the messages. This
; kit consists of:
;
;	messages.inc	- This file. Defines all text.
;	*.asm		- Assembly files which include this file to generate
;			  actual message text.
;	newmsg.bat	- A batch file which assembles the *.asm files, and
;			  replaces them in their appropriate libraries.
;	chmsg.exe	- A message extraction / insertion utility to alter the
;			  messages in the runtime module .EXE files without
;			  relinking.
;
; To change message text:
;
;	1) Edit this file to change the text of the messages as required. The
;	   text is always the last argument to the RTEDEF or RLEDEF macros.
;	   Commented out text is present for documentation purposes only, and
;	   editting it will have no effect.
;
;	   There is no length limit on messages altered in this file.
;
;	   Messages may not contain null characters.
;
;	2) Run newmsg.bat, with this file, the *.asm files, and the product
;	   libraries in the current directory.
;
;	3) Run chmsg on the runtime module:
;
;		chmsg brun30c.exe >brun30c.txt
;
;	4) Edit brun30c.txt to alter the messages as desired.
;
;	5) Run chmsg on the runtime module again:
;
;		chmsg brun30c.exe brun30c.txt
;
;	   Note: no redirection this time. This will install the new messages.
;	   There is a limit, as reported by chmsg, as to the available space
;	   for altered messages.
;
;	6) repeat steps 3 through 6 on brun30p.exe.
;
;******************************************************************************
	PAGE
;******************************************************************************
;
; RTEDEF macro
;
; Used to define Run Time Error and other text messages, and symbolic constants
; associated with them. If RTEDEF has not already been defined by the time this
; file is INCLUDEd, the default RTEDEF just equates the symbol to the numeric
; value. In this way, just INCLUDEing this file, without any further thought,
; gives you the set of symbolic message constants.
;
; Files which actually want to define the text associated with the messages
; will define RTEDEF, prior to including this file, to perform whatever they
; need with the information available.
;
IFNDEF	RTEDEF			;if no RTEDEF macro already defined

RTEDEF	MACRO	TYPE,SYMBOL,NUM,MSG

IFNB	<SYMBOL>		;;If there is a symbol to be defined
SYMBOL	EQU	NUM		;;Define message symbol
ENDIF

	ENDM			;;RTEDEF MACRO

ENDIF				;IFNDEF RTEDEF

;******************************************************************************
;
; RCEDEF macro
;
; This is a special case of the RCEDEF macro used to define the strings used by
; the DOS 3 runtime loader. (RCE -> Runtime C Error). By default the macro
; does what RTEDEF does. In the files needed, the macro is defined as required
; to define symbolic constants and/or text.
;
IFNDEF	RCEDEF			; if RCEDEF macro not already defined

RCEDEF	MACRO	TYPE,SYMBOL,NUM,MSG
	RTEDEF	TYPE, SYMBOL, NUM, <MSG>
	ENDM			;;RCEDEF MACRO

ENDIF	;IFNDEF	RCEDEF

;******************************************************************************
;
; RLEDEF macro
;
; This is a special case of the RTEDEF macro used to define the strings used by
; the DOS 3 runtime loader. (RLE -> Runtime Loader Error). By default the macro
; does nothing. In the files needed, the macro is defined as required to define
; symbolic constants and/or text.
;
IFNDEF	RLEDEF			;[12]if RLEDEF macro not already defined

RLEDEF	MACRO	LABEL,TEXT	;[12]if not defined, just null
	ENDM	;;RLEDEF MACRO  ;[12]

ENDIF	;IFNDEF	RLEDEF		;[12]

;******************************************************************************
;
; RXEDEF macro [32]
;
; This is a special case of the RTEDEF macro used to define the strings used by
; the DOEXEC procedure.  (RXE -> Runtime eXec Error). By default the macro does
; nothing.  In the files needed, the macro is defined as required to define
; labels and text.
;
IFNDEF	RXEDEF			;[32] if RXEDEF macro not already defined

RXEDEF	MACRO	LABEL,NUM,TEXT	;[32] if not defined, just null
	ENDM	;;RXEDEF MACRO	;[32]

ENDIF	;IFNDEF	RXEDEF		;[32]


;******************************************************************************
;
; Define useful characters
;
ASCCR	=	0DH		;Carriage return

;******************************************************************************
;
;	Messages.
;	Messages are numbered as follows:
;
;	0000H - 00FFH:	BE_???? - Standard "Basic" Errors 0 through 255
;	0100H - 7FFFH:	Unused
;	8000H - FFFFH:	Internal messages.
;			8000 - 8FFFH:	MS_??? - Non-error messages
;			9000 - 9FFFH:	FE_??? - Fatal "crash and burn" errors.
;				9000-93FF:	Line number & Module valid
;				9400-96FF:	Module valid
;				9700-97FF:	QB interp initialization errors
;				9800-9BFF:	Nothing valid
;
;******************************************************************************
;
;	BE: Basic Errors
;	These are all the basic errors that can be generated at run time.
;
;******************************************************************************
	RTEDEF	SN,  BE_SYNTAX,    2,"Syntax error"
	RTEDEF	RG,  BE_RETURN,    3,"RETURN without GOSUB"
	RTEDEF	OD,  BE_NODATA,    4,"Out of DATA"
	RTEDEF	FC,  BE_ILLFUN,    5,"Illegal function call"
	RTEDEF	OV,  BE_OVERFLOW,  6,"Overflow"
	RTEDEF	OM,  BE_MEMORY,    7,"Out of memory"
	RTEDEF	BS,  BE_SUBSCRIP,  9,"Subscript out of range"
	RTEDEF	<DD>,BE_REDIM,	  10,"Duplicate definition"	;[23] <DD> avoids assembly confusion
	RTEDEF	DV0, BE_DIVIDE0,  11,"Division by zero"
	RTEDEF	TM,  BE_TYPE,	  13,"Type mismatch"
	RTEDEF	OS,  BE_STRINGSP, 14,"Out of string space"
	RTEDEF	ST,  BE_STRINGFO, 16,"String formula too complex"
	RTEDEF	NR,  BE_NORESUME, 19,"No RESUME"
	RTEDEF	RE,  BE_RESUME,   20,"RESUME without error"
	RTEDEF	DTO, BE_DEVTIME,  24,"Device timeout"
	RTEDEF	DVF, BE_DEVFAULT, 25,"Device fault"
	RTEDEF	OTP, BE_NOPAPER,  27,"Out of paper"
	RTEDEF	,,		  39,"CASE ELSE expected"	;[9]
	RTEDEF	RVR, BE_RECVARREQ,40,"Variable required"	;[30]
	RTEDEF	FOV, BE_FIELD,	  50,"FIELD overflow"
	RTEDEF	INT, BE_INTERNAL, 51,"Internal error"
	RTEDEF	IFN, BE_FILENUM,  52,"Bad file name or number"	;[23]
	RTEDEF	FNF, BE_NOFILE,   53,"File not found"
	RTEDEF	BFM, BE_FILEMODE, 54,"Bad file mode"
	RTEDEF	FAO, BE_FILEOPEN, 55,"File already open"
	RTEDEF	FSA, BE_FLDACTIVE,56,"FIELD statement active"	;[9]
	RTEDEF	IOE, BE_DEVICEIO, 57,"Device I/O error"
	RTEDEF	FAE, BE_EXISTS,   58,"File already exists"
	RTEDEF	BRL, BE_BADRECLEN,59,"Bad record length"	;[9]
	RTEDEF	DFL, BE_DISKFULL, 61,"Disk full"
	RTEDEF	RPE, BE_PASTEND,  62,"Input past end of file"	;[23]
	RTEDEF	BRN, BE_BADREC,   63,"Bad record number"
	RTEDEF	BFN, BE_BADNAME,  64,"Bad file name"
	RTEDEF	TMF, BE_TOOMANY,  67,"Too many files"
	RTEDEF	DNA, BE_NODEVICE, 68,"Device unavailable"
	RTEDEF	CBO, BE_COMMBUFF, 69,"Communication-buffer overflow" ;[23]
	RTEDEF	FWP, BE_HANDSOFF, 70,"Permission denied"	;[23]
	RTEDEF	DNR, BE_NOTREADY, 71,"Disk not ready"
	RTEDEF	DME, BE_MEDIA,	  72,"Disk-media error"		;[23]
	RTEDEF	AFE, BE_ADVANCED, 73,"Advanced feature unavailable" ;[23]
	RTEDEF	RAD, BE_RENAME,   74,"Rename across disks"
	RTEDEF	ACD, BE_ACCESS,   75,"Path/File access error"	;[24]
	RTEDEF	PNF, BE_NOTFOUND, 76,"Path not found"

	RTEDEF	UPE, BE_UNPRINT, 255,"Unprintable error"

;******************************************************************************
;
;	MS: Internal Messages of various sorts
;	These are just text messages, not necessarily related to errors.
;
;******************************************************************************
	RTEDEF	,MS_BASE,	8000H		;[14]Base of messages
	RTEDEF	,MS_REDO,	8000H,"Redo from start"		;[23]
	RTEDEF	,MS_BYTESFREE,	8001H,<"Bytes free",ASCCR>
	RTEDEF	,MS_ULPROMPT,	8002H		;"Cannot find file (" ;[22]
	RTEDEF	,MS_ULPROMPTEND 8003H		;"). Input path: " ;[24]
	RTEDEF	,MS_ULERR,	8004H		;"Error in loading file ( " ;[22]
	RTEDEF	,MS_ULERREND,	8005H		;") - " ;[22]
	RTEDEF	,MS_SEED,	8006H,<"Random-number seed (-32768 to 32767)">	     ;[24]
	RTEDEF	,MS_HITTORETURN,8007H,"Hit any key to return to system" ;[20]
	RTEDEF	,MS_QBEND,	8007H		;[14]End of interp messages

	RTEDEF	,MS_IN, 	8008H," in "
	RTEDEF	,MS_OF, 	8009H," of "
	RTEDEF	,MS_LINE,	800AH,"line "
	RTEDEF	,MS_MODULE,	800BH,"module "
	RTEDEF	,MS_ATADDR,	800CH," at address "
	RTEDEF	,MS_BREAK,	800DH,"*Break*"

;******************************************************************************
;
;	FE: Fatal Errors of various sorts
;
;******************************************************************************
;
;	Errors when line numbers and module names should be valid
;
;**** WARNING: If you change order, add or delete messages, make sure
;**** WARNING: that you notify the interpreter of these changes.


	RTEDEF	,FE_BASE,	9000H
	RTEDEF	SSC,FE_CORRUPT, 9000H,"String space corrupt"	;[23]
	RTEDEF	,FE_ULDISK,	9001H		;"Disk I/O error"
	RTEDEF	,FE_ULINVALID,	9002H		;"Invalid format"
	RTEDEF	,FE_ULSEGORDER, 9003H		;"Segment ordering problem"
	RTEDEF	,FE_ULFILE,	9004H		;"Cannot find file"
	RTEDEF	,FE_QBEND	9004H		;[14]End of QB FE "all valid" messages

	RTEDEF	EXE,FE_EXE,	9005H,"Error in EXE file"	;[10]
	RTEDEF	,FE_STOP,	9006H,"STOP"
	RTEDEF	OSS,FE_NOSTACK, 9007H,"Out of stack space"    ;[31]
;
;	Errors when module name should be valid
;
	RTEDEF	,FE_NOLINEBASE, 9400H
	RTEDEF	NOL,FE_NOLINES, 9400H,"No line number in "	;[23]
;
;	QB interpreter Initialization errors after Runtime init has
;	succeeded.
;
	RTEDEF	,FE_QBINITBASE, 9700H	;[19]
;
;	Errors when NOTHING is valid
;
	RTEDEF	,FE_NOTHINGBASE,  9800H
	RTEDEF	DOS,FE_DOSERR,	  9800H,"Requires DOS 2.10 or later"	;[49]
	RTEDEF	LLI,FE_LLINITERR, 9801H,"Error during run-time initialization"	;[42]
	RTEDEF	,FE_MEMORY,	  9802H,"Out of memory" 	;[21]
	RTEDEF	MEM,FE_DOSMEMERR, 9803H,"DOS memory-arena error"
	RTEDEF	FHC,FE_FHCONSIST, 9804H,"Far heap corrupt"	;[23]
;
;[17]	User library loader messages
;
	RTEDEF	,FE_ULMEMALLOC,   9806H 	;"Memory allocation error"
	RTEDEF	,FE_QBNOTHINGEND, 9806H 	;[21]End of QB error messages

;[29]
; Messages that are generated by the interpeter, processed through the runtime
; error handler, and passed on to the intepreter. (9900H)
;
	RTEDEF	,FE_GODIRECT,	  9900H 	;[29]


;[32] C message number have been given a high byte of 9Ah.  All these moved
;[32] here with revision [32].

	RCEDEF	,FE_STARTUPBASE,9A00H		; C startup messages
	RCEDEF	,,9A00H,<'R6000',13,10,'- stack overflow',13,10>
	RCEDEF	,,9A02H,<'R6002',13,10,'- floating point not loaded',13,10>
	RCEDEF	,,9A03H,<'R6003',13,10,'- integer divide by 0',13,10>

	; Messages copied and used by DOEXEC (these 3 must be contiguous)
	RXEDEF EX_MSG_BEG,,
	RXEDEF ,9A05H,<13,10,'run-time error R6005',13,10,'- not enough memory on exec',13,10,'$'>
	RXEDEF ,9A06H,<13,10,'run-time error R6006',13,10,'- bad format on exec',13,10,'$'>
	RXEDEF ,9A07H,<13,10,'run-time error R6007',13,10,'- bad environment on exec',13,10,'$'>
	RXEDEF EX_MSG_END,,

;[33] The following messages are required for mixed-language processing and
;[33] internationalization.
	RCEDEF	,,9A08H,<'R6008',13,10,'- not enough space for arguments',13,10>
	RCEDEF	,,9A09H,<'R6009',13,10,'- not enough space for environment',13,10>
	RCEDEF	,,9A0CH,<'R6012',13,10,'- illegal near pointer use',13,10>
	RCEDEF	,,9A0DH,<'R6013',13,10,'- illegal far pointer use',13,10>
	RCEDEF	,,9A0EH,<'R6014',13,10,'- control-BREAK encountered',13,10>
	RCEDEF	,,9A0FH,<'R6015',13,10,'- unexpected interrupt',13,10>
	RCEDEF	,FE_STARTUPEND,9AFFH,<13,10,'run-time error '>	;[34]

;[34] Die "really quick" errors.  These have a high byte of '9B'.
	RTEDEF	,FE_CHNMEMERR,9B00H,<13,10,'Out of memory during CHAIN',13,10>
	RTEDEF	,FE_CHNFILERR,9B01H,<13,10,'Error in CHAIN file format',13,10>

;
;[12]	Runtime module loader error messages.
;
	RLEDEF	HeaderErrStr,<"Error in loading RTM: $"> ;[37]
	RLEDEF	MemAllocErrStr,<"Memory allocation error","$">	;[23]
	RLEDEF	CannotFindStr,<"Cannot find file in PATH","$">	;[23]
	RLEDEF	DiskIOErrStr,<"Disk I/O error","$">		;[23]
	RLEDEF	InvalidStr,<"Invalid format","$">		;[23]
	RLEDEF	OutOfMemStr,<"Out of memory","$">		;[23]
	RLEDEF	ArenaBadStr,<"DOS memory-arena error","$">	;[23]
	RLEDEF	BadUsrRtmStr,<"Incompatible run-time module","$"> ;[48]
	RLEDEF	TrailerErrStr,<".",13,10,"$">
	RLEDEF	PathPromptStr,<"Input run-time module path: ","$">	;[42]

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\qstruc.inc ===
;***
; qstruc.inc - 20-Mar-86
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

;*******************************************************
;This queue structure is used by the MUSIC queues and
;the COM buffer queues (both input and output). The
;field QUNOTE is not used by the COM buffer queues
;but will be present as a dummy field so that the same
;queue manipulation routines may be used.


QUE_CTRL_BLOCK STRUC

QUNOTE	DW	1 DUP(?)
QUETOP	DW	1 DUP(?)
QUEBOT	DW	1 DUP(?)
QUELEN	DW	1 DUP(?)
QUENUM	DW	1 DUP(?)
QUEGET	DW	1 DUP(?)
QUEPUT	DW	1 DUP(?)

QUE_CTRL_BLOCK ENDS

QUSIZE	=	SIZE QUE_CTRL_BLOCK

QLENTH	=	32*6		;room for 32 notes

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\queues.inc ===
;***
;queues.inc - 20-Mar-86
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;*      queues.inc - contains all the needed definitions to use queues as
;*                   defined in GWQUE.ASM
;*      should be included in the 'CODE' segment for the externals to
;*      be in the right place
;
;******************************************************************************

	EXTRN	B$INITQ:NEAR
	EXTRN	B$GETQ:NEAR
	EXTRN	B$PUTQ:NEAR
	EXTRN	B$NUMQ:NEAR
	EXTRN	B$LFTQ:NEAR

QUEUE	STRUC

QUEPUT	DW	1 DUP(?)	;queue put pntr
QUEGET	DW	1 DUP(?)	;queue get pntr
QUEBOT	DW	1 DUP(?)	;bot of queue location
QUETOP	DW	1 DUP(?)	;top of queue location
QUELEN	DW	1 DUP(?)	;length of queue = max q-able bytes + 1
QUENUM	DW	1 DUP(?)	;number of bytes in que

QUEUE	ENDS

QUE_HEADER_SIZE = SIZE QUEUE

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\rmacros.inc ===
;***
; RMACROS.INC - June 3, 1986 - Common Runtime Common Macros
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; Contains macros and other definitions which are used prior to including
; other include files to control their definitions.
;
;Notes:
; This include file may create symbols which are referenced by other include
; files. All of these symbols begin with _?rt_.
;
;******************************************************************************

;***
;
;	useSeg
;	declares that a module uses a particular segment. This then
;	turns on the segment declaration for the segment in SEG.INC,
;	which is included after this file.
;
;***
useSeg	MACRO	sg
	IRP	s,<sg>		;;For each segment specified
_?rt_seg_&&s	EQU	TRUE	;;Tell SEG.INC to define it
	.XCREF	_?rt_seg_&&s	;;Keep the symbol table dump clean
	ENDM			;;IRP s
	ENDM			;;useSeg MACRO

;***
;
;	pubmac
;	used in place of the PUBLIC psuedo op, it defines the item PUBLIC,
;	and also defines a unique symbol to indicate that the item is defined
;	here.
;
;	This is a kludge to get the runtime interface mapper up and running.
;	The intent is to remove this kludge eventually.
;
;***
pub_dummy MACRO list		;;Used because PUBMAC could get a list
	IRP	p,<list>	;;For each name in list
	IFIDN	<p>,<>		;;If we're done
	EXITM			;;Exit the macro
	ENDIF
	PUBLIC	p		;;Else perform original function
p&&_DEFINED_HERE = 1		;; and set the defined flag
	ENDM
	ENDM

pubmac	MACRO	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
	pub_dummy <a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z>
	ENDM

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\rtmmac.inc ===
;***
; RTMMAC.INC - 20-Mar-86 - Macros for Generating Entry Numbers
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

WORG	MACRO	num
IF1
VecTable&num LABEL WORD
	INDEX	= 0		;;[1]
	PBYTE   = W1__NM - 1 + num
ENDIF	;;IF1
	ENDM

WLAST	MACRO	num
IF1			;;[1]
VecIndex&num = INDEX	;;[1]define ending index of each table
ENDIF	;;IF1		;;[1]
	ENDM

;	Display software interrupt postbyte.

PRINTE	MACRO	msg,pb,n
	ENDM

;	Create entry in table and define as external.

WORDDW	MACRO	pre,nam
	EXTRN	pre&nam:NEAR
	DW	pre&nam
IF1
	INDEX=INDEX+1		;;[1]
	PRINTE	pre&nam,%PBYTE,%INDEX
ENDIF	;;IF1
	ENDM

;	First table defines item if conditional true.

W1	MACRO	nam,cond
IFNB	<cond>
IF	cond
	WORDDW	<B$>,nam
ENDIF	;;IF <cond>
ELSE	;;IFNB <cond>
	WORDDW	<B$>,nam
ENDIF	;;IFB <cond>
	ENDM

;	Second table defines item if conditional true.

W2	MACRO	nam,cond
IFNB	<cond>
IF	cond
	WORDDW	<B$>,nam
ENDIF	;;IF <cond>
ELSE	;;IFNB <cond>
	WORDDW	<B$>,nam
ENDIF	;;IFB <cond>
	ENDM

;	Third table defines items depending on the list parameter:
;		If blank, num items defined suffixed by A, B, C, ...
;		If nonblank, items defined through list

W3	MACRO	nam,num,list
IFNB	<list>

IRP	item,<list>	;;if list is nonempty,...
	WORDDW	<B$>,item	;;...make an entry for each list item
ENDM

ELSE	;;IFNB <list>

IF	num GE 1
	WORDDW	<B$>,nam&A
ENDIF
IF	num GE 2
	WORDDW	<B$>,nam&B
ENDIF
IF	num GE 3
	WORDDW	<B$>,nam&C
ENDIF
IF	num GE 4
	WORDDW	<B$>,nam&D
ENDIF
IF	num GE 5
	WORDDW	<B$>,nam&E
ENDIF
IF	num GE 6
	WORDDW	<B$>,nam&F
ENDIF
IF	num GE 7
	WORDDW	<B$>,nam&G
ENDIF
IF	num GE 8
	WORDDW	<B$>,nam&H
ENDIF

ENDIF	;;IFB <list>

IF	num GT 8
	ERROR	W3 entry index too large
ENDIf
	ENDM

;	Fourth table defines items through the list.

W4	MACRO	nam,num,list

IRP	item,<list>
	WORDDW	<__>,item	;;make an entry for each list item
ENDM
ENDM

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\rtmint.inc ===
;***
;rtmint.inc - 09/03/87 - runtime module communications interrupts
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; This file is defines the runtime module communications interrupts. Any entry
; exists in this file for each runtime entry point that can be called by
; compiled code.
;
; This file is used in two places. It is included in rtmint.asm to create a
; module which compiled programs FAR CALL into to get dispatched to the runtime
; module. It is also included in rtm86.asm (or an interpeter equivalent) to
; dispatch to the intended routines.
;
; The reason this file exists is so that the interrupt number assignments are
; more or less version independent (at the expense of a big maintenence
; hassle.) Also, there are very few conditionals because the generic and full
; versions of the runtime module should be interchangable (same full set of
; interrupts).
;
;[9] The file number parameter was added to add granularity to non /o programs.
;[9] Entry points are grouped together with those that are likely to be
;[9] used along with each other.
;[9] This grouping is approximate and may be changed at any time.
;[9]
;[9] The following system is now being used:
;[9]	File 1:	Those functions required for a minimal "END" program
;[9]	File 2:	B$SRUN.  This is the only function that uses __doexec,
;[9]		which must be kept in the RTM LIBRARY.  __doexec is only
;[9]		linked in if a program contains a RUN statement.
;[9]	File 3:	"Common" entry points
;[9]	File 4:	"Non-common" floating point entry points
;[9]	File 5:	"graphics" entry points
;[9]	File 6:	everything else (includes unused C startup entries)
;[9]
;
;Summary of fields:
;
;	RTMENT	entryname,file,entryseg,startlabel,callflag,switches
;
;	    entryname - Name of routine
;	    file      - which file (RTMINT<file>.ASM) has the definition
;	    entryseg  - segment of <entryname> if not ???
;	    startlabel- Alternate name for routine
;	    callflag  - Blank: Function will ONLY be CALLed FAR.
;			'0'    Function can be JMP'ed to.  Will return.
;			'1'    Function can be JMP'ed to.  Will not return.
;	    switches  - set of MASM switches.  If defined and FALSE, there
;			will be no support for this routine, though the
;			postbyte will still be allocated.
;
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME and
;	NOTE: the interpreter projects.  Any changes made to one should
;	NOTE: be carried over (COPIED) to the other!!!
;
;******************************************************************************
;
; Entry points referenced by intepreter executors. (Must all be single post-
; bytes).
;


	RTMENT	B$ASSN,3
	RTMENT	B$BEEP,6
	RTMENT	B$BLOD,6
	RTMENT	B$BSAV,6
	RTMENT	B$CASP,5
	RTMENT	B$CDIR,6
	RTMENT	B$CHAN,3
	RTMENT	B$CHOU,3
	RTMENT	B$CIRC,5
	RTMENT	B$CLOS,3
	RTMENT	B$COLR,5
	RTMENT	B$CSCN,5
	RTMENT	B$CSRL,6
	RTMENT	B$CSTO,5
	RTMENT	B$CSTT,5
	RTMENT	B$DDIM,3
	RTMENT	B$DRAW,5
	RTMENT	B$DSEG,6
	RTMENT	B$DSG0,6
	RTMENT	B$DSKI,3
	RTMENT	B$DVI4,3
	RTMENT	B$DWID,6
	RTMENT	B$ENRD,3	;[12]
	RTMENT	B$ENSD,3	;[12]
	RTMENT	B$EPE0,6
	RTMENT	B$EPE1,6
	RTMENT	B$EPE2,6
	RTMENT	B$ERAS,6
	RTMENT	B$ERDS,6
	RTMENT	B$ERDV,6
	RTMENT	B$ESG0,6
	RTMENT	B$ESG1,6
	RTMENT	B$ESG2,6
	RTMENT	B$ETC0,6
	RTMENT	B$ETC1,6
	RTMENT	B$ETC2,6
	RTMENT	B$ETK0,6
	RTMENT	B$ETK1,6
	RTMENT	B$ETK2,6
	RTMENT	B$ETL0,6
	RTMENT	B$ETL1,6
	RTMENT	B$ETL2,6
	RTMENT	B$ETS0,6
	RTMENT	B$ETS1,6
	RTMENT	B$ETS2,6
	RTMENT	B$ETT0,6
	RTMENT	B$ETT1,6
	RTMENT	B$ETT2,6
	RTMENT	B$FASC,6
	RTMENT	B$FATR,6
	RTMENT	B$FCHR,3
	RTMENT	B$FCMD,3
	RTMENT	B$FCVD,3
	RTMENT	B$FCVI,3
	RTMENT	B$FCVL,3
	RTMENT	B$FCVS,3
	RTMENT	B$FDAT,3
	RTMENT	B$FEOF,3
	RTMENT	B$FEVI,6
	RTMENT	B$FEVS,6
	RTMENT	B$FHEX,6
	RTMENT	B$FICT,6
	RTMENT	B$FIEL,6
	RTMENT	B$FILS,6
	RTMENT	B$FINP,3
	RTMENT	B$FLDP,3
	RTMENT	B$FLEN,3
	RTMENT	B$FLOC,6
	RTMENT	B$FLOF,6
	RTMENT	B$FMDF,3
	RTMENT	B$FMID,3
	RTMENT	B$FMKD,3
	RTMENT	B$FMKI,3
	RTMENT	B$FMKL,3
	RTMENT	B$FMKS,3
	RTMENT	B$FMSF,3
	RTMENT	B$FOCT,6
	RTMENT	B$FPEN,6
	RTMENT	B$FPLY,3
	RTMENT	B$FPOS,6
	RTMENT	B$FREF,3
	RTMENT	B$FRI2,3
	RTMENT	B$FRSD,3
	RTMENT	B$FSCN,3
	RTMENT	B$FSEK,6	;[3]
	RTMENT	B$FSHL,6
	RTMENT	B$FSPC,3
	RTMENT	B$FSTG,3
	RTMENT	B$FTAB,3
	RTMENT	B$FTIM,3
	RTMENT	B$FVAL,3
	RTMENT	B$FWID,3
	RTMENT	B$GET1,6
	RTMENT	B$GET2,6
	RTMENT	B$GET3,6
	RTMENT	B$GET4,6
	RTMENT	B$GGET,5
	RTMENT	B$GPUT,5
	RTMENT	B$INKY,3
	RTMENT	B$INPP,3
	RTMENT	B$INS2,3
	RTMENT	B$INS3,3
	RTMENT	B$KFUN,3
	RTMENT	B$KILL,6
	RTMENT	B$KMAP,3
	RTMENT	B$LBND,3
	RTMENT	B$LCAS,3
	RTMENT	B$LDFS,3
	RTMENT	B$LEFT,3
	RTMENT	B$LINE,5
	RTMENT	B$LNIN,3
	RTMENT	B$LOCK,6
	RTMENT	B$LOCT,3
	RTMENT	B$LPOS,3
	RTMENT	B$LPRT,3
	RTMENT	B$LSET,3
	RTMENT	B$LTRM,3
	RTMENT	B$LWID,3
	RTMENT	B$MCVD,3
	RTMENT	B$MCVS,3
	RTMENT	B$MDIR,6
	RTMENT	B$MUI4,3
	RTMENT	B$N1I2,5
	RTMENT	B$N1R4,5
	RTMENT	B$N2I2,5
	RTMENT	B$N2R4,5
	RTMENT	B$NAME,6
	RTMENT	B$ONCA,6
	RTMENT	B$ONKA,6
	RTMENT	B$ONLA,6
	RTMENT	B$ONPA,6
	RTMENT	B$ONSA,6
	RTMENT	B$ONSG,6
	RTMENT	B$ONTA,6
	RTMENT	B$OOPN,3
	RTMENT	B$OPEN,3
	RTMENT	B$PAIN,5
	RTMENT	B$PAL0,5
	RTMENT	B$PAL2,5
	RTMENT	B$PALU,5
	RTMENT	B$PCI2,3
	RTMENT	B$PCI4,3
	RTMENT	B$PCPY,5
	RTMENT	B$PCR4,3
	RTMENT	B$PCR8,3
	RTMENT	B$PCSD,3
	RTMENT	B$PEEK,6
	RTMENT	B$PEI2,3
	RTMENT	B$PEI4,3
	RTMENT	B$PEOS,3
	RTMENT	B$PER4,3
	RTMENT	B$PER8,3
	RTMENT	B$PESD,3
	RTMENT	B$PINP,6	;[36] INP and OUT are only needed for the
	RTMENT	B$POUT,6	;[36] Interpreters
	RTMENT	B$PMAP,5
	RTMENT	B$PNI2,5
	RTMENT	B$PNR4,5
	RTMENT	B$PNT1,5
	RTMENT	B$PNTC,5
	RTMENT	B$POKE,6
	RTMENT	B$PRST,5
	RTMENT	B$PSET,5
	RTMENT	B$PSI2,3
	RTMENT	B$PSI4,3
	RTMENT	B$PSR4,3
	RTMENT	B$PSR8,3
	RTMENT	B$PSSD,3
	RTMENT	B$PSTC,5
	RTMENT	B$PUT1,6
	RTMENT	B$PUT2,6
	RTMENT	B$PUT3,6
	RTMENT	B$PUT4,6
	RTMENT	B$RDI2,3
	RTMENT	B$RDI4,3
	RTMENT	B$RDIM,6
	RTMENT	B$RDIR,6
	RTMENT	B$RDR4,3
	RTMENT	B$RDR8,3
	RTMENT	B$RDSD,3
	RTMENT	B$REST,3
	RTMENT	B$RGHT,3
	RTMENT	B$RMI4,3
	RTMENT	B$RND0,6
	RTMENT	B$RND1,6
	RTMENT	B$RNZ0,6
	RTMENT	B$RNZP,6
	RTMENT	B$RSET,3
	RTMENT	B$RTRM,3
	RTMENT	B$S1I2,5
	RTMENT	B$S1R4,5
	RTMENT	B$S2I2,5
	RTMENT	B$S2R4,5
	RTMENT	B$SADD,3
	RTMENT	B$SASS,3
	RTMENT	B$SCAT,3
	RTMENT	B$SCLS,3
	RTMENT	B$SCPY,3
	RTMENT	B$SDAT,3
	RTMENT	B$SENV,6
	RTMENT	B$SERR,6
	RTMENT	B$SETM,6
	RTMENT	B$SICT,6
	RTMENT	B$SMID,3
	RTMENT	B$SOND,3
	RTMENT	B$SPAC,3
	RTMENT	B$SPLY,3
	RTMENT	B$SSEK,6	;[3]
	RTMENT	B$SSHL,6
	RTMENT	B$STDL,3 	;[2]
	RTMENT	B$STI2,3
	RTMENT	B$STI4,3
	RTMENT	B$STIK,6
	RTMENT	B$STIM,6
	RTMENT	B$STR4,3
	RTMENT	B$STR8,3
	RTMENT	B$STRI,3
	RTMENT	B$STRS,3
	RTMENT	B$SWP2,3
	RTMENT	B$SWP4,3
	RTMENT	B$SWP8,3
	RTMENT	B$SWPN,3
	RTMENT	B$TIMR,3
	RTMENT	B$UBND,3
	RTMENT	B$UCAS,3
	RTMENT	B$USNG,3
	RTMENT	B$VARP,3
	RTMENT	B$VEW0,5
	RTMENT	B$VIEW,5
	RTMENT	B$VWPT,5
	RTMENT	B$WAIT,3	;[36] WAIT is only needed by the Interpreter
	RTMENT	B$WIDT,3
	RTMENT	B$WIN0,5
	RTMENT	B$WIND,5
	RTMENT	B$WRIT,3
;
; Entry points not referenced by interpreter executors. (May be multiple post-
; bytes). These MAY be referenced by the interpeter, but not in a manner that
; requires a single post-byte.
;
	RTMENT	B$?EVT,3
	RTMENT	B$CEND,1
	RTMENT	B$CENP,1
	RTMENT	B$CPI4,3
	RTMENT	B$ENFA,3
	RTMENT	B$ENRA,3
	RTMENT	B$ENSA,3 	;[4]
	RTMENT	B$EVCK,3
	RTMENT	B$EXFA,3
	RTMENT	B$EXSA,3
	RTMENT	B$FBIN,3
	RTMENT	B$FERL,3
	RTMENT	B$FERR,3
	RTMENT	B$GOSA,3
	RTMENT	B$HARY,3
	RTMENT	B$LINA,3
	RTMENT	B$OEGA,3
	RTMENT	B$OGSA,3
	RTMENT	B$OGTA,3
	RTMENT	B$RELA,6
	RTMENT	B$RES0,6
	RTMENT	B$RESA,6
	RTMENT	B$RESN,6
	RTMENT	B$RETA,3
	RTMENT	B$RSTA,3
	RTMENT	B$RSTB,3
	RTMENT	B$RUNL,6 	;[5]
	RTMENT	B$SCHN,3
	RTMENT	B$SCLR,3
	RTMENT	B$SCMP,3
	RTMENT	B$SCPF,3 	;[7]
	RTMENT	B$SRUN,2	;[30] MUST have its own file
	RTMENT	B$STOP,3
	RTMENT	B$SWSD,3 	;[52]
	RTMENT	B$CMI4,3	;[35]
	RTMENT	B$TROF,6
	RTMENT	B$TRON,6
	RTMENT	B$Undef1,6,,,,FALSE ;[37]These four entrypoints were used in QB4
	RTMENT	B$Undef2,6,,,,FALSE ;[37]but are no longer used (they were for
	RTMENT	B$Undef3,6,,,,FALSE ;[37]ISAM support).  They may be used for any
	RTMENT	B$Undef4,6,,,,FALSE ;[37]Product, but the slots must exist.


;
; The following entries must be grouped together. They are all in segment _TEXT
;
	RTMENT	B$ATN4,4,_TEXT,_TEXT_START	;[1]
	RTMENT	B$ATN8,4,_TEXT
	RTMENT	B$COS4,4,_TEXT
	RTMENT	B$COS8,4,_TEXT
	RTMENT	B$EXP4,4,_TEXT
	RTMENT	B$EXP8,4,_TEXT
	RTMENT	B$FCMP,3,_TEXT		;[15] floating point compare
	RTMENT	B$FIL2,4,_TEXT
	RTMENT	B$FILD,4,_TEXT
	RTMENT	B$FIS2,4,_TEXT
	RTMENT	B$FIST,4,_TEXT
	RTMENT	B$FIX4,4,_TEXT
	RTMENT	B$FIX8,4,_TEXT
	RTMENT	B$FUST,4,_TEXT
	RTMENT	B$INT4,4,_TEXT
	RTMENT	B$INT8,4,_TEXT
	RTMENT	B$LOG4,4,_TEXT
	RTMENT	B$LOG8,4,_TEXT
	RTMENT	B$POW4,4,_TEXT
	RTMENT	B$POW8,4,_TEXT
	RTMENT	B$SGN4,4,_TEXT
	RTMENT	B$SGN8,4,_TEXT
	RTMENT	B$SIN4,4,_TEXT
	RTMENT	B$SIN8,4,_TEXT
	RTMENT	B$TAN4,4,_TEXT
	RTMENT	B$TAN8,4,_TEXT

	;[14] Definition of 5th parameter:
	;[14]	Blank:	function will ONLY be CALLed FAR.
	;[14]	'0'	Function can be JMP'ed to directly/indirectly.  Macro
	;[14]		will generate a far call to the INT 3F, followed by a
	;[14]		RETF.
	;[14]	'1'	Function can be JMP'ed to directly/indirectly.  Macro
	;[14]		will generate a far call to the INT 3F, but will not
	;[14]		follow it with a RETF, since routine does not return.


					;[10] C startup functions in the RTM
					;[10] and in QB.EXE
	RTMENT	__fpreset,1,_TEXT	;[17]math pack reset
	RTMENT	__chkstk,1,_TEXT	; publics in CHKSTK
	RTMENT	__nullcheck,1,_TEXT	; publics in CHKSUM
	RTMENT	__fptrap,1,_TEXT,,1	;[14] publics in CRT0FP
	RTMENT	__FMSG_TEXT,1,_TEXT,,0	;[14] publics in FMSGHDR
	RTMENT	__amsg_exit,1,_TEXT,,1	;[14] publics in CRT0
	RTMENT	__cintDIV,1,_TEXT,,1	;[14]


;[27]
;[27] NEW functions added after QB4 shipped.  Moved here with revision [27]
;[27] to ensure that the QB shipped with BASCOM 6 remains compatable with the
;[27] QB4.00 already shipped.
;[27]
;[37] They can not be moved into RTM_UNDEFINED slots, as that would break
;[37] break backward compatibility with QB4.00B.
;[37]
	RTMENT	B$EUE0,6,,_TEXT_END	;[27] label to mark end of _TEXT entries
	RTMENT	B$EUE1,6		;[27]
	RTMENT	B$EUE2,6		;[27]
	RTMENT	B$ONUE,6		;[27]
	RTMENT	B$SLEP,6		;[27]
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\rtps.h ===
/* File: rtps.h - Runtime constants                                     */
/* NOTE: When making changes to this file, be sure to make equivalent   */
/*       changes to file rtps.inc                                       */
/* [2] - 07/16-90 timke    Define BINSAV_ constants for QB45C.		*/
/* [1] - 10/31/88 Markcha  Changed BINSAV_ and QLB_ constants for QBJ	*/

#undef RTPS_H
#define RTPS_H ON       /* remember that this file has been included */

/* [LINE] INPUT prompt flags */
#define FINP_QSupress 1
			/* set if "prompt" was followed by a comma,
			   not a semicolon, indicating "? " is not to be
			   output after prompt. */
#define FINP_CrLf 2
			/* set if INPUT was followed by optional ";",
			   meaning CrLf is not to be output when user
			   presses return. */
#define FINP_Prompt 4	/* set if the optional SDPrompt argument is included. */

/* File LOCK & UNLOCK Constants */
#define LOCK_UNLOCK 1		/* set if operation is UNLOCK, not LOCK */
#define LOCK_1stToLast 2	/* set if only part of file */
#define LOCK_RtMask 3		/* bits which get passed to runtime */
#define LOCK_Def1stArg 4	/* set if 1st arg defaulted */
#define LOCK_DefLastArg 8	/* set if last arg defaulted */

/* File Open mode, access, locking flags */
#define MD_SQI 1		/* for INPUT */
#define MD_SQO 2		/* for OUTPUT */
#define MD_RND 4		/* [for RANDOM] */
#define MD_APP 8		/* for APPEND */
#define MD_BIN 16		/* for BINARY */
#define MD_DEFAULT MD_RND	/* [for RANDOM] */
#define ACCESS_READ 1		/* READ */
#define ACCESS_WRITE 2		/* WRITE */
#define ACCESS_BOTH 3		/* READ WRITE */
#define LOCK_READ 0x30		/* LOCK READ */
#define LOCK_WRITE 0x20		/* LOCK WRITE */
#define LOCK_BOTH 0x10		/* LOCK READ WRITE */
#define LOCK_SHARED 0x40	/* LOCK SHARED */

/* DOS does not allow you to do a CD (change directory) to a path > 64,
 * but once you are in a directory whose path is 64 bytes long, DOS
 * will let you open a 64 byte relative path, making the maximum length
 * of a filename accessible by DOS = 128.  Since the runtime just has 1
 * static copy of a filename buffer, they decided to let running programs
 * access files whose full path > 64 (even though you can't get into the
 * lowest directory from DOS.
 *   The user interface chooses to limit the path to 64 for the directory,
 * and 12 for the filename (and 1 for a 0-byte terminator).  This is for
 * two reasons:
 *   - The directory that source files are saved in should be accessible by
 *     all programs (including command.com).  
 *   - There are several layers of functions in the user interface code that
 *     each need a copy of a filename.  The increased stack demands of going
 *     to 128 are prohibitive.
 */
#define FILNAML 128+1		/* max. filename length for runtime */
#define FILNAML64 64+12+1	/* max. filename length for user interface */

/* Runtime Value Types */
#define VT_I2 0x02		/* short integer */
#define VT_I4 0x14		/* long integer */
#define VT_R4 0x04		/* 32 bit real */
#define VT_R8 0x08		/* 64 bit real */
#define VT_SD 0x03		/* string */

/* Runtime bits for b$CtrlFlags */
#define NoSTACKINIT 0x01h   /* Doesn't call B$STACKINIT when set during
			      B$RUNINI or B$CHNINI calls. */

/* Extended Out of Memory error codes for b$errinfo. */
#define OMErr_OM   0x00h    /* generic OM error                               */
#define OMErr_NH   0x01h    /* out of near heap space ( DS > 64k )            */
#define OMErr_FH   0x02h    /* out of far heap space ( out of system memory )	*/
#define OMErr_STK  0x03h    /* out of stack space                            	*/
#define OMErr_Proc 0x04h    /* out of Procedure text table space ( > 64k )    */
#define OMErr_Mod  0x05h    /* out of Module text table space ( > 64k )       */
#define OMErr_Inc  0x06h    /* out of Include file text table space ( > 64k ) */
#define OMErr_Doc  0x07h    /* out of Document file text table space ( > 64k )	*/


/* File type constants for user-option path searching			*/
#define LIBFILE    0x00     /* search user-specified LIB path		*/
#define EXEFILE    0x06     /* search user-specified EXE path		*/
#define INCFILE    0x0c     /* search user-specified INCLUDE path	*/
#define HELPFILE   0x12     /* search user-specified HELP path		*/



/* QBI version & format revision constants (used by U.L. & Binary SAVE/LOAD)  */
/* if BINSAV_CBSPECHDR is changed, check MAX_SPECHDRSIZE in BinSav.ASM	      */

#define BINSAV_CBSPECHDR     0x0010
#if EI_EB
#define BINSAV_BASICVersion  0x0002	/* BASIC version number for EB */
#define BINSAV_REVISION_BYTE 0x01	/* binary save format revision byte */
#endif					//[1]

#if FL_JAPAN				//[2]
#define BINSAV_BASICVersion  0x0003	/*[1] BASIC version number for QBJ */
#define BINSAV_REVISION_BYTE 0x00	/*[1] binary save format revision byte */
#define QLB_BASICVersion     0x0003	/*[1] BASIC version QLB's compat. with */
#define QLB_REVISION_BYTE    0x00	/*[1] QuickLib format revision byte */
#endif

#if FL_TAIWAN				//[2]
#define BINSAV_BASICVersion  0x0004	/* BASIC version number for QBC */
#define BINSAV_REVISION_BYTE 0x00	/* binary save format revision byte */
#define QLB_BASICVersion     0x0004	/* BASIC version QLB's compat. with */
#define QLB_REVISION_BYTE    0x00	/* QuickLib format revision byte */
#endif

#ifndef BINSAV_BASICVersion		//[2] default version (American QB)
#define BINSAV_BASICVersion  0x0001	/* BASIC version number for QB */
#define BINSAV_REVISION_BYTE 0x00	/* binary save format revision byte */
#define	QLB_BASICVersion     0x0000	/* BASIC version QLB's compat. with */
#define	QLB_REVISION_BYTE    0x13	/* QuickLib format revision byte */
#endif					//[1]

/* Minimum space for NMALLOC buffer. */

#define NMALLOC_MIN	     0x0006	/* Minimum NMALLOC space needed */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\rtment.inc ===
;***
;rtment.inc - 11/23/87
;***
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	The RTMENT macro is redefined in many places, but
;	RTMINT{1|2|3|4|5|6}.ASM all need it defined to the same
;	value.	To make maintenance of this macro easier it is
;	defined here for those 6 modules.
;
;************************************************************************

	maxpb equ 255		; maximum post-byte value for QB case (255
				;   signals double post-byte)

RTMENT	MACRO	entryname,file,entryseg,startlabel,callflag

IFNDEF	UL&entryname
IF	file EQ FILENUM
	PUBLIC	entryname
entryname PROC	    FAR

IFNB	<&startlabel>		;; for duplicate labels
	PUBLIC	startlabel	;; to save some bytes
startlabel	LABEL FAR	;;
ENDIF				;;

IFNB	<&callflag>		;; generate a far call here for interrupt
				;; handler to backpatch
	CALL	FAR PTR t_&entryname	;;handler to backpatch
IF	callflag EQ 0		;; if return instruction specified
	RET			;; follow it with a FAR return
ENDIF				;;
t_&entryname	LABEL FAR	;;
ENDIF				;;

	INT	3FH		;;Transfer to the runtime module

	IF	entrypb NE 0	;;if there is to be a two-byte post byte
	DB	0FFH		;;the put in flag value
	ENDIF
	DB	entrynum	;;and the post byte value (0 through f9)

entryname ENDP
ENDIF				;;IF file EQ FILENUM
ENDIF				;;IFNDEF UL&entryname

entrynum	=	entrynum + 1
	IF	entrynum GE maxpb
entrynum	=	0
	IF	entrypb NE 0	;;if too many entries
	.err	Too Many runtime entries
	ENDIF
entrypb 	=	1
	ENDIF

	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\sb.inc ===
;***
;sb.inc - SB usage definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1988, Microsoft Corporation
;
;Purpose:
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME
;	NOTE: and the interpreter projects.  Any changes made to one should
;	NOTE: be carried over to the other!!!
;	NOTE: There are some minor differences between the two versions for
;	NOTE: this file, so DO NOT just copy it!!!
;
;******************************************************************************
SB_INC	=	-1

;HMEM_ constants used by SBMGR allocation routines

HMEM_FIXED	EQU	0000H
HMEM_MOVEABLE	EQU	0002H
HMEM_NOCOMPACT	EQU	0010H
HMEM_ZEROINIT	EQU	0040H
HMEM_DISCARDABLE EQU	0F00H
HMEM_EMM	EQU	0004H	;[2]


ifndef	FHSBMgr
sBegin	_DATA
	extrn	mpsbps:word
	extrn	_sbmax:abs	;total number of SB's
sEnd	_DATA
endif	;ifndef FHSBMgr


;For QB5, we need to have constants that map to the appropriate place
;in the table of FHD's
SbDgroup=	  2
SbString=	 97
SbFile	=	100
SbRs	=	103
SbGVar	=	106
SbGNam	=	109
SbDirect=	112
SbModString=	115
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\rtps.inc ===
;***
; rtps.inc - 04-Aug-87
;***
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This include file contains runtime constants needed by both the
;	runtime and QBI.  This file, along with fdb.inc, array.inc, and
;	messages.inc is part of a runtime "release" to QBI.
;
; WARNING: WARNING: WARNING: WARNING: WARNING: WARNING: WARNING: WARNING:
; WARNING:
; WARNING:  When making changes to this file, be sure to make equivalent
; WARNING:  changes to file rtps.h
; WARNING:
; WARNING: WARNING: WARNING: WARNING: WARNING: WARNING: WARNING: WARNING:
;
;******************************************************************************

RTPS_INC = -1			;remember that this file has been included

;==============================================================================
;
;QBI version & format revision constants (used by U.L. code & Binary SAVE/LOAD)
;   The version word is now a family id, it indicates what "family" the saving
;   product belongs to.  The revision byte indicates the revision of the
;   product within its family.




BINSAV_BASICVersion	EQU	0001h	;[15] BASIC version number for QB 4.5
BINSAV_REVISION_BYTE	EQU	00h	;[15] format revision byte
QLB_BASICVersion	EQU	0000h	;[16] BASIC version no. for QB 4.x QLB's
QLB_REVISION_BYTE	EQU	13h	;[16] QuickLib format revision byte

;Log of when BINSAV_REVISION_BYTE was changed:
;Date		Changed To	Reason
;------------------------------------------------------------------------
;23-Feb-87	    01		First change. Unknown number of older
;				binary-saved files in existence.
;27-Feb-87          02		No longer putting BLOCK_MOD at start of each
;				module, since we only save one module per file.
;16-Mar-87          03		Code to support compiling directly from 
;				our Binary SAVE format needs module name table
;				to be saved before the module text table.
;10-Jun-87          04		Changed for todays internal QB release. Must
;				be changed whenever peropcod.txt is changed.
;10-Jun-87 (PM)     05		Changed for todays internal QB release. Must
;				be changed whenever peropcod.txt is changed.
;17-Jun-87	    06		Changed for Beta Release because of peropcode
;				changes (DMC).
;30-Jun-87          07		Changed based on actual change to binsav format
;				(now saving both mrs flag bytes)
;15-Jul-87	    08		Peropcod changes. (DMC)
;21-Jul-87	    09		Peropcod changes and second beta. (DMC)
;03-Aug-87	    0a		Peropcod changes. (DMC)
;04-Aug-87	    0b		Peropcod changes. (DMC)
;10-Aug-87	    0c		VarMgr changes. (DMC)
;26-Aug-87	    0d		QLB dgroup compression changes. (DMC)
;31-Aug-87	    0e		C startup changes. (DMC)
;09-Sep-87	    0f		rtmint changes. (DMC)
;14-Sep-87	    10		rtmint changes. (DMC)
;15-Sep-87	    11		First final (?) beta REL.19 (DMC)
;15-Sep-87	    12		First final (?) beta REL.20 (DMC)
;??-???-87	    13		Release version REL.35 (???)
;11-Nov-87	    14		First Beta for BC6.  Want to be backwards
;				compatable to release version of QB4.
;16-Nov-87	    13		We're stuck at 13 for QB4 release compatibility!
;25-May-88	    14 (EB)	Changed for EB only, to make binary
;				incompatabilities easier to detect (BLR)
;08-Jun-88	    15 (EB)	Changed for EB only, due to changes in nam,
;				var, rs, and pcode tables to leave 2nd word
;				of each far heap buffer unused (used by Omega)
;15-Jun-88	    16 (EB)	Changed for EB only, due to additional pcode
;				changes to leave 2nd word free.
;24-Jun-88	    17 (EB)	Changed for EB only, removed data_otxfirst
;30-Jun-88	    18		Changed many AVtRfs to AIdLds in pcode
;05-Jul-88	    19		Removed obsolete pcodes
;07-Jul-88	    1a		Changed coercion pcode
;11-Jul-88	    00		Rewound due to change in binary format.  BASIC
;				version number is now a family number.	0 = QB
;				(v4.0 a,b), 1 = QB (v4.5 and later), 2 = EB.
;05-Aug-88	    01 (EB)	SQL pcode change
;==============================================================================


; [LINE] INPUT prompt flags
FINP_QSupress	EQU 1	;set if "prompt" was followed by a comma,
			;not a semicolon, indicating "? " is not to be
			;output after prompt.
FINP_CrLf	EQU 2	;set if INPUT was followed by optional ";",
			;meaning CrLf is not to be output when user
			;presses return.
FINP_Prompt	EQU 4	;set if the optional SDPrompt argument is included.


; Communications constants
cbComBuf	EQU 512 ;[1] default COM buffer size

; File LOCK & UNLOCK Constants
LOCK_UNLOCK		EQU 0001h	;set if operation is UNLOCK, not LOCK
LOCK_1stToLast		EQU 0002h	;set if only part of file locked
LOCK_RtMask		EQU 0003h	;bits which are meaningful to runtime
LOCK_Def1stArg		EQU 4000h	;set if 1st arg defaulted - used by list
LOCK_DefLastArg		EQU 8000h	;set if last arg defaulted- used by exec

;File Open mode, access, locking flags
MD_SQI			EQU 1	; for INPUT
MD_SQO			EQU 2	; for OUTPUT
MD_RND			EQU 4	; [for RANDOM]
MD_APP			EQU 8	; for APPEND
MD_BIN			EQU 20H	; for BINARY
MD_DEFAULT		EQU MD_RND
ACCESS_READ		EQU 1	; READ
ACCESS_WRITE		EQU 2	; WRITE
ACCESS_BOTH		EQU 3	; READ WRITE
LOCK_READ		EQU 30H	; LOCK READ
LOCK_WRITE		EQU 20H	; LOCK WRITE
LOCK_BOTH		EQU 10H	; LOCK READ WRITE
LOCK_SHARED		EQU 40H	; LOCK SHARED

;----------------------------------------------------------------------
;DOS does not allow you to do a CD (change directory) to a path > 64,
;but once you are in a directory whose path is 64 bytes long, DOS
;will let you open a 64 byte relative path, making the maximum length
;of a filename accessible by DOS = 128.  Since the runtime just has 1
;static copy of a filename buffer, they decided to let running programs
;access files whose full path > 64 (even though you can't get into the
;lowest directory from DOS.
;  The user interface chooses to limit the path to 64 for the directory,
;and 12 for the filename (and 1 for a 0-byte terminator).  This is for
;two reasons:
;  - The directory that source files are saved in should be accessible by
;    all programs (including command.com).  
;  - There are several layers of functions in the user interface code that
;    each need a copy of a filename.  The increased stack demands of going
;    to 128 are prohibitive.
;
FILNAML = 128d+1	;max. filename length for runtime
FILNAML64 = 64d+12d+1	;max. filename length for user interface

;Runtime Value Types
VT_I2 EQU 02h		;short integer
VT_I4 EQU 14h		;long integer
VT_R4 EQU 04h		;32 bit real
VT_R8 EQU 08h		;64 bit real
VT_SD EQU 03h		;string

;Runtime bits for b$CtrlFlags
NoSTACKINIT EQU 01h	;Doesn't call B$STACKINIT when set during B$RUNINI
			; or B$CHNINI calls.

;Extended Out of Memory error codes for b$errinfo.
OMErr_OM   EQU 00h	;generic OM error
OMErr_NH   EQU 01h	;out of near heap space ( DS > 64k )
OMErr_FH   EQU 02h	;out or far heap space	( out of system memory )
OMErr_STK  EQU 03h	;out of stack space
OMErr_Proc EQU 04h	;out of Procedure text table space ( > 64k )
OMErr_Mod  EQU 05h	;out of Module text table space ( > 64k )
OMErr_Inc  EQU 06h	;out of Include file text table space ( > 64k )
OMErr_Doc  EQU 07h	;out of Document file text table space ( > 64k )

;[8]File type constants for user-option path searching
LIBFILE    EQU 0	;[8]
EXEFILE    EQU 6	;[8]
INCFILE    EQU 12	;[8]
HELPFILE   EQU 18	;[8]

; Minimum space for NMALLOC buffer.  Moved here from const.inc with rev [17].
;
; This is the minimum space which must be allocated in the NMALLOC segment
; for any attempted near malloc() call to fail gracefully.  Enough space
; must be allocated for a "C" heap header.
;

NMALLOC_MIN	= 06H		;Minimum NMALLOC space needed.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\stack2.inc ===
;***
; STACK.INC - 18-Feb-88 - Stack size definitions
;***
	.XLIST
;***
;
; Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Stack constants
;
;	WARNING:  This file is shared between the runtime and interpreter.
;	WARNING:  The runtime is the official "owner", and all changes should
;	WARNING:  be made there first, and then propogated to the interpreter.
;
;
;******************************************************************************

STACK2_INC = -1			;[3] remember file has been included




FAT_COW 	= 300h		;[6] Extra slop just in case
STACK_SIZE	= 0800h	+ FAT_COW  ;[3] Default stack size (MUST BE EVEN)
STACK_MIN	= 0320h + FAT_COW  ;[3] Minimum stack size


STACK_CHECK	= STACK_MIN-20h+1h ;[3] Stack check marker offset (MUST BE ODD)
				;[3] This constant is used by runtime to ensure
				;[3]  we never make long-term stack commitments
				;[3]  (i.e. GOSUB, CALL, FUNCTION invocations)
				;[3]  that would result in less than this many
				;[3]  free bytes between SP and b$pend.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\switch.inc ===
;***
; SWITCH.INC - 01-Oct-87 - BASCOM compiler and runtime common switch file
;***
	.XLIST
;***
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

FALSE	      = 0
TRUE	      = NOT FALSE
UNDEFINED     = 0FFFFH		;an undefined value

memM	      = 1		;[14] medium model is internal default

NUM_CASS      = 0		;Number of cassettes supported
NUM_FKEYS     = 12		;Number of function keys (softkeys)
NUM_LINES     = 25		;Number of lines on screen
NUM_LPT       = 3		;Number of line printers supported
NUM_RS232     = 2		;Number of RS232 com ports supported
NUM_SCRLTYPE  = 1		;Number of scroll type
NUM_VOICES    = 1		;Number of voices for SOUND
NUM_VSTACK    = 24		;Number of entries for each voice in SOUND
ID_SSEQDS     = TRUE		;SS is assumed equal to DS

;	The specified <version>.<release><update> number is used
;	to guarantee compatibility among the compiler, runtime
;	library, and runtime module.

NumVer= 6
NumRel= 0
NumUpd= 0

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\string.inc ===
;string.inc - far string constants and definitions


bd	STRUC
BD_cbLogical	dw	?	;logical size of content part of heap entry
BD_pb		dw	?	;points to 1st byte of heap entry
BD_cbPhysical	dw	?	;actual size of heap entry, including padding
bd	ENDS

parmSD	macro	ParmName
;;parm is near pointer to SD structure
parmW	ParmName
	endm

GetpSD	macro	reg,ParmName
;;set reg = pSD, depending on whether parm is SD or pSD
	mov	reg,ParmName	;;reg = parm (parm is pointer to SD)
	endm

ArgLast	equ	[bp+6]		;Location of last argument

NumTemps = 20			;number of string temps
LenTemp = 6			;descriptor length is six bytes
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\smchain.inc ===
;***
; smchain.inc - 26-Aug-86
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; This include file contains definitions for shared memory versions of
; the CHAIN statement.
;
;******************************************************************************


;============================================================================
;	Shared Memory header offsets
;
;	The shared memory header basically looks like a list of
;	string descriptors, with a descriptor for each major component
;	of shared memory.  These components include the runtime
;	state variables which are contained in the segment BR_DATA,
;	variables in the blank COMMON segment, string space, and
;	local heap (containing dynamic string arrays and fdb's).
;	Finally, a Far heap descriptor is included which points to
;	the first item in the far heap descriptor list.

SM_HEADER STRUC
	SM_RTD_LEN DW	?		;length of runtime data segment
	SM_RTD_PTR DW	?		;pointer to runtime data data
	SM_COM_LEN DW	?		;length of COMMON segment
	SM_COM_PTR DW	?		;ptr to COMMON data
	SM_SS_LEN DW	?		;length of string space data
	SM_SS_PTR DW	?		;ptr to string space data
	SM_LH_LEN DW	?		;length of local heap data
	SM_LH_PTR DW	?		;ptr to local heap data
	SM_FH_PTR DW SIZE FHD DUP(?)	;Far heap descriptor (start of FHD list)
SM_HEADER ENDS

SM_HEADER_LEN EQU	SIZE SM_HEADER	;length of shared memory header
;============================================================================

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\seg.inc ===
;***
; SEG.INC (& cMacros.inc) - 18-Jun-1986 - Common Runtime Segment Definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; Contains the cMacros segment definitions used throughout the common runtime.
; Also includes cMacros.inc
;
;******************************************************************************
?WIN	=	0		;[18]No, not windows
?PLM	=	1		;[18]Default to PLM conventions
?DF	=	1		;[18]We'll define our own seg's
?TF	=	1		;[18]Don't need MOV SP,BP at cEnd
?NODATA =	1		;[31]no DS-setup prologue for Windows
				;[31]	harmless when ?WIN == 0, but required
				;[31]	so cMacros won't object to ATOMIC attr
	include cMacros.inc
;******************************************************************************
;
; Component segment usages.
; If a component segment name has been turned on, we now turn on the
; individual segments required/used by that component.
;
;******************************************************************************
IFDEF	_?rt_seg_RT		;Runtime Core Component
	useSeg	<RT_TEXT,_DATA>
ENDIF
IFDEF	_?rt_seg_NH		;Near Heap manager
	useSeg	SS_TEXT
ENDIF
IFDEF	_?rt_seg_FH		;Far heap manager
	useSeg	FH_TEXT
ENDIF
IFDEF	_?rt_seg_ST		;String functions
	useSeg	ST_TEXT
ENDIF
IFDEF	_?rt_seg_GR		;Graphics
	useSeg	GR_TEXT
ENDIF
IFDEF	_?rt_seg_MT		;Floating Point math
	useSeg	MT_TEXT
ENDIF
IFDEF	_?rt_seg_ER		;Error handling / processing
	useSeg	ER_TEXT
ENDIF
IFDEF	_?rt_seg_EV		;Event Handling
	useSeg	EV_TEXT
ENDIF
IFDEF	_?rt_seg_SN		;Sound and Music
	useSeg	SN_TEXT
ENDIF
IFDEF	_?rt_seg_DV		;Device I/O support
	useSeg	DV_TEXT
ENDIF
IFDEF	_?rt_seg_CN		;Console I/O support
	useSeg	CN_TEXT
ENDIF
IFDEF	_?rt_seg_DK		;Disk I/O support
	useSeg	DK_TEXT
ENDIF
IFDEF	_?rt_seg_OI		;COM/Printer I/O support
	useSeg	OI_TEXT
ENDIF
IFDEF	_?rt_seg_OS		;Operating system functions/features
	useSeg	OS_TEXT
ENDIF
IFDEF	_?rt_seg_DB		;Debug code (user level)
	useSeg	DB_TEXT
ENDIF
IFDEF	_?rt_seg_ID		;Internal debugging support
	useSeg	ID_TEXT
ENDIF
;******************************************************************************
;
; _?rt_cSeg	n,ln,a,co,cl,grp
;
; where:
;	n	= physical (external) name of segment
;	ln	= logical (internal) name of segment
;	a	= alignment (optional)
;	co	= combine type (optional)
;	cl	= class (optional)
;	grp	= group (optional)
;
; Mimics cMacros createSeg macro, except that it conditionally defines the
; desired segment only if "_?rt_seg_" symbol is defined to turn on that
; segment.
;
;******************************************************************************
_?rt_cSeg	macro	n,ln,a,co,cl,grp
IFDEF	_?rt_seg_&ln
	createSeg	n,ln,a,co,cl,grp
ENDIF
	endm
	.XCREF	_?rt_cSeg	;Don't list or cross reference it
;******************************************************************************
;
; _?rt_cdSeg
; Same as _?rt_cSeg, except that it also takes care of conditionally setting
; a flag that is later used to conditionally define DGROUP
;
;******************************************************************************
_?rt_cdSeg	macro	n,ln,a,co,cl,grp
IFDEF	_?rt_seg_&ln
	createSeg	n,ln,a,co,cl,grp
_?rt_dataseg	EQU	TRUE
ENDIF
	endm
	.XCREF	_?rt_cdSeg	;Don't list or cross reference it
;******************************************************************************
;
; Code segments
;
;******************************************************************************
CODESEGS MACRO		;[7]
	_?rt_cSeg	LOADRTM,LOADRTM,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,RT_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,NH_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,FH_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,ST_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,GR_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,MT_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,ER_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,EV_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,SN_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,DV_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,CN_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,DK_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,OI_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,OS_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,DB_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	CODE,ID_TEXT,WORD,PUBLIC,CODE
	_?rt_cSeg	_TEXT,_TEXT,PARA,PUBLIC,CODE			;[10]

	_?rt_cSeg	CODE,INIT_CODE,WORD,PUBLIC,CODE
	_?rt_cSeg	FAR_DATA,FAR_DATA,PARA,PUBLIC,FAR_DATA		;[14]
	_?rt_cSeg	FAR_BSS,FAR_BSS,PARA,PUBLIC,FAR_BSS		;[14]

	ENDM		;[7]
;******************************************************************************
;
; Data segments
;
;******************************************************************************
DATASEGS MACRO		;[7]
	_?rt_cdSeg	NULL,	NULL,	PARA,	PUBLIC, BEGDATA,DGROUP ;[13]
	_?rt_cdSeg	BR_DATA,BR_DATA,WORD,	PUBLIC, DATA,	DGROUP ;[6]
	_?rt_cdSeg	CONST,	CONST,	WORD,	PUBLIC, DATA,	DGROUP ;[6]
	_?rt_cdSeg	_BSS,	_BSS,	WORD,	PUBLIC, DATA,	DGROUP ;[6]
	_?rt_cdSeg	_DATA,	_DATA,	WORD,	PUBLIC, DATA,	DGROUP ;[6]
	_?rt_cdSeg	CDATA,	CDATA,	WORD,	PUBLIC, DATA,	DGROUP
	_?rt_cdSeg	XIFB,	XIFB,	WORD,	PUBLIC, DATA,	DGROUP ;[22]
	_?rt_cdSeg	XIF,	XIF,	WORD,	PUBLIC, DATA,	DGROUP ;[22]
	_?rt_cdSeg	XIFE,	XIFE,	WORD,	PUBLIC, DATA,	DGROUP ;[22]
	_?rt_cdSeg	XIB,	XIB,	WORD,	PUBLIC, DATA,	DGROUP
	_?rt_cdSeg	XI,	XI,	WORD,	PUBLIC, DATA,	DGROUP
	_?rt_cdSeg	XIE,	XIE,	WORD,	PUBLIC, DATA,	DGROUP
	_?rt_cdSeg	XPB,	XPB,	WORD,	PUBLIC, DATA,	DGROUP ;[22]
	_?rt_cdSeg	XP,	XP,	WORD,	PUBLIC, DATA,	DGROUP ;[22]
	_?rt_cdSeg	XPE,	XPE,	WORD,	PUBLIC, DATA,	DGROUP ;[22]
	_?rt_cdSeg	XCB,	XCB,	WORD,	PUBLIC, DATA,	DGROUP ;[9]
	_?rt_cdSeg	XC,	XC,	WORD,	PUBLIC, DATA,	DGROUP ;[9]
	_?rt_cdSeg	XCE,	XCE,	WORD,	PUBLIC, DATA,	DGROUP ;[9]
	_?rt_cdSeg	XCFB,	XCFB,	WORD,	PUBLIC, DATA,	DGROUP ;[22]
	_?rt_cdSeg	XCF,	XCF,	WORD,	PUBLIC, DATA,	DGROUP ;[22]
	_?rt_cdSeg	XCFE,	XCFE,	WORD,	PUBLIC, DATA,	DGROUP ;[22]
	_?rt_cdSeg	DBDATA,	DBDATA,	WORD,	COMMON, DATA,	DGROUP	;[39]
	_?rt_cdSeg	_CALLTAB,_CALLTAB,WORD,	PUBLIC, CALLTAB,DGROUP ;[30]
	_?rt_cdSeg	HDR,	HDR,	BYTE,	PUBLIC, MSG,	DGROUP ;[30]
	_?rt_cdSeg	MSG,	MSG,	BYTE,	PUBLIC, MSG,	DGROUP ;[30]
	_?rt_cdSeg	PAD,	PAD,	BYTE,	COMMON, MSG,	DGROUP ;[30]
	_?rt_cdSeg	EPAD,	EPAD,	BYTE,	COMMON, MSG,	DGROUP ;[30]
	_?rt_cdSeg	BC_DATA,BC_DATA,WORD,	PUBLIC, BC_DATA,DGROUP ;[25]
	_?rt_cdSeg	BC_FT,	BC_FT,	WORD,	PUBLIC, BC_SEGS,DGROUP
	_?rt_cdSeg	BC_CN,	BC_CN,	WORD,	PUBLIC, BC_SEGS,DGROUP
	_?rt_cdSeg	BC_DS,	BC_DS,	WORD,	PUBLIC, BC_SEGS,DGROUP
	_?rt_cdSeg	BC_SAB, BC_SAB, WORD,	PUBLIC, BC_SEGS,DGROUP
	_?rt_cdSeg	BC_SA,	BC_SA,	WORD,	PUBLIC, BC_SEGS,DGROUP
	_?rt_cdSeg	BC_SAE, BC_SAE, WORD,	PUBLIC, BC_SEGS,DGROUP ;[26]
	_?rt_cdSeg	XOB,	XOB,	WORD,	PUBLIC, BSS,	DGROUP ;[8]
	_?rt_cdSeg	XO,	XO,	WORD,	PUBLIC, BSS,	DGROUP ;[8]
	_?rt_cdSeg	XOE,	XOE,	WORD,	PUBLIC, BSS,	DGROUP ;[8]
	_?rt_cdSeg	BR_SKYS,BR_SKYS,PARA,	PUBLIC, BLANK,	DGROUP ;[20]
	_?rt_cdSeg	COMMON, COMMON, WORD,	COMMON, BLANK,	DGROUP
	_?rt_cdSeg	NMALLOC,NMALLOC,WORD,	COMMON, BC_VARS,DGROUP ;[15]
	_?rt_cdSeg	ENMALLOC,ENMALLOC,WORD, COMMON, BC_VARS,DGROUP ;[15]
	_?rt_cdSeg	STACK,	STACK,	PARA,	STACK,	STACK,	DGROUP ;[8]
IFDEF	_?rt_dataseg
	defGrp	DGROUP
ENDIF
	ENDM		;[7]
;******************************************************************************
;
; Order code vs. data based on whether or not we are dos 3 rtm
;
;******************************************************************************


IFNDEF SEGS_DEFINED		;[7]
	CODESEGS		;[7] code comes first everywhere else
	DATASEGS		;[7]
ENDIF				;[7] IFNDEF SEGS_DEFINED

;******************************************************************************
;
; Segment assumptions. We always assume DS=SS, and they both point at
; DGROUP. CS must be assumed by individual modules.
;
;******************************************************************************
IFDEF	_?rt_dataseg
assumes DS,DGROUP
assumes ES,NOTHING		;[37]
assumes SS,DGROUP
ENDIF

	PURGE	_?rt_cSeg	;Macros no longer needed
	PURGE	_?rt_cdSeg	;[7]
	PURGE	useSeg		;[7]
	PURGE	defGrp		;[7]
	PURGE	DATASEGS	;[7]
	PURGE	CODESEGS	;[7]

;******************************************************************************
;
;	The INITIALIZER macro puts the address of the passed routine
;	into the XI segment.  Each module that gets linked that has
;	an INITIALIZER macro invokation will also put its address
;	in the XI segment.  This has the effect of building up a
;	table of initialization routines that need called.  Crt0
;	will call all of these routines before it calls _main.
;
;******************************************************************************
INITIALIZER	MACRO	pINI
sBegin	XIB			;;[23] XIB and XIE must bracket XI, or
sEnd	XIB			;;[23] initializers will NOT get called!
				;;[23] this code makes sure that USESEG's
				;;[23] are present for XIB and XIE.
sBegin	XI
	DD	&pINI
sEnd	XI
sBegin	XIE			;;[23]
sEnd	XIE			;;[23]
	ENDM

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\ulib.inc ===
;***
;ulib.inc - 03-Sep-87
;***
	.XLIST

;
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Defines structures for data items shared between resident
;	runtime and userlibrary runtime.
;
;******************************************************************************

;-----------------------------------------------------------------------------
;	To minimize the number of global data items defined in
;	user library specific runtime and used in the resident
;	core runtime, they are defined in the following structure.
;	The user lib runtime will declare b$ULVars to be
;	of this structure type.  The resident runtime then only
;	needs to know the location of b$ULVars to reference
;	shared data items defined in the user lib.
;-----------------------------------------------------------------------------
IFNDEF	FirstInclude		;used so UlibVars is only defined once
	FirstInclude = TRUE	;if this file is included multiple times
ENDIF				;IFNDEF FirstInclude

IF	FirstInclude
UlibVars STRUC
	RTtoULFarProc	DD ?	;UL specific FAR entry point mapper
	RTtoULNearProc	DD ?	;UL specific NEAR entry point mapper
	FrameSetup	DD ?	;ptr to B$FrameSetup in UL runtime
	ULVersion	DW ?	;[10] Version used to create UL
	ULRevision	DB ?	;[10] Revision used to create UL
UlibVars ENDS
ENDIF				;IF FirstInclude

	PAGE
;-----------------------------------------------------------------------------
;	Entry points in user library runtime that compiled code
;	may call through runtime module interrupt service routine
;-----------------------------------------------------------------------------

IFNDEF	ULEntry 	;IF not defined then just NULL
ULEntry MACRO	name
	ENDM		;;ULEntry Macro
ENDIF			;IFNDEF ULEntry

	ULEntry B$RELA
	ULEntry B$RESA
	ULEntry B$OGSA
	ULEntry B$RETA
	ULEntry B$OGTA
	ULEntry B$GOSA
	ULEntry B$FERL
	ULEntry B$RESN
	ULEntry B$RES0
	ULEntry B$FERR
	ULEntry B$STOP
	ULEntry B$OEGA

	ULEntry B$ENRA 	;[8]
	ULEntry B$ENSA
	ULEntry B$ENRD	;[14]
	ULEntry B$ENSD	;[14]
	ULEntry B$EXSA

	ULEntry B$ENFA
	ULEntry B$EXFA

	PAGE
;-----------------------------------------------------------------------------
;	Entry points in user library runtime that resident
;	runtime calls NEAR.  These entry points pass parameters
;	through REGISTERS ONLY.  If this changes, the code in
;	ULtoRT.asm and RTtoUL.asm must also change.
;-----------------------------------------------------------------------------

IFNDEF	ULRTNearOrg	;IF not defined then just NULL
ULRTNearOrg MACRO
	ENDM		;;ULRTNearOrg
ENDIF			;IFNDEF ULRTNearOrg

	ULRTNearOrg

IFNDEF	ULRTNear	;IF not defined then just NULL
ULRTNear MACRO	name
	ENDM		;;ULRTNear Macro
ENDIF			;IFNDEF ULRTNear

	ULRTNear B$GETMODCODE

	PAGE
;-----------------------------------------------------------------------------
;	Entry points in user library runtime that resident
;	runtime calls FAR. These entry points pass parameters
;	on the STACK and may use all temp registers.  If any
;	routines are added which pass parameters through
;	registers, the associated code in ULtoRT and RTtoUL
;	must be examined.
;------------------------------------------------------------------------------

IFNDEF	ULRTFarOrg	;IF not defined then just NULL
ULRTFarOrg MACRO
	ENDM		;;ULRTFarOrg
ENDIF			;IFNDEF ULRTFarOrg

	ULRTFarOrg

IFNDEF	ULRTFar 	;IF not defined then just NULL
ULRTFar MACRO	name, nParms
	ENDM		;;ULRTFar Macro
ENDIF			;IFNDEF ULRTFar

;These procedures have no parameters

	ULRTFar B$ULInit,0
	ULRTFar B$ULTerm ,0
	ULRTFar B$ULDataRelease,0
	ULRTFar B$ULAllocDataImage,0	;[13]

;These procedures have 1 parameter

	ULRTFar B$CONERR,1
	ULRTFar B$ULGetProc,1
	ULRTFar B$ULGetData,1
	ULRTFar B$ULGetSeg,1
	ULRTFar B$ULGetCommon,1	;[2]

	PAGE
;-----------------------------------------------------------------------------
;	Entry points in resident runtime that user library
;	runtime calls NEAR.  These entry points pass parameters
;	through REGISTERS ONLY.  If this changes, the code in
;	ULtoRT.asm and RTtoUL.asm must also change.
;------------------------------------------------------------------------------

IFNDEF	RTNearOrg	;IF not defined then just NULL
RTNearOrg MACRO
	ENDM		;;RTNearOrg
ENDIF			;IFNDEF RTNearOrg

	RTNearOrg

IFNDEF	RTNear		;IF not defined then just NULL
RTNear	MACRO	name
	ENDM		;;RTNear Macro
ENDIF			;IFNDEF RTNear

	RTNear	B$BREAK_CHK
	RTNear	B$FOUTBX
	RTNear	B$LHLOCFDB		;[7]
	RTNear	B$RES_SETUP
	RTNear	B$TYPUI
	RTNear	B$LHFDBLOC		;[7]
	RTNear	B$$WCLF
	RTNear	B$$RCH
	RTNear	B$$TCR
	RTNear	B$$WCH
	RTNear	B$STALCTMP
	RTNear	B$TTY_SOUT
	RTNear	B$STDALC		;[15]
	RTNear	B$STDALCTMP
	RTNear	B$STDALCALLTMP		;[2]
	RTNear	B$PUTNUM
	RTNear	__BRUNERR
	RTNear	B$RUNERR
	RTNear	B$FHHighAlloc
	RTNear	B$FHHighDealloc
	RTNear	B$IFHAlloc		;[13]
	RTNear	B$FHDealloc		;[13]


	PAGE
;-----------------------------------------------------------------------------
;	Entry points in resident runtime that user library
;	runtime calls FAR. These entry points pass parameters
;	on the STACK and may use all temp registers.  If any
;	routines are added which pass parameters through
;	registers, the associated code in ULtoRT and RTtoUL
;	must be examined.
;------------------------------------------------------------------------------

IFNDEF	RTFarOrg	;IF not defined then just NULL
RTFarOrg MACRO
	ENDM		;;RTFarOrg
ENDIF			;IFNDEF RTFarOrg

	RTFarOrg

IFNDEF	RTFar		;IF not defined then just NULL
RTFar	MACRO	name
	ENDM		;;RTFar Macro
ENDIF			;IFNDEF RTFar

	RTFar	B$ULReload
	RTFar	B$IStop
	RTFar	B$END
	RTFar	B$GetNmalloc		;[16]
	RTFar	B$IEND			;[16]

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\stack.inc ===
;***
; STACK.INC - 3-Sep-87 - Frame definitions
;***
	.XLIST
;***
;
; Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************


RUN_RESERVE= 14h		;Paragraphs for EXE loader

;******************************************************************************
;
;Frame Contents
;==============
;
; The basic frame is set up on entry to the main program, by B$ENSA/B$ENRA SUB
; and FUNCTION entry routines, and on an event GOSUB. SZ_FRAME is the size in
; bytes of the standard basic frame.
;
;		+------+------+------+------+------+------+------+------+
;		|							|
;	+4/+8	+	Return address Segment				+
;		|							|
;		+------+------+------+------+------+------+------+------+
;		|							|
;	+2/+6	+	Return address offset				+
;		|							|
;IF EVENT GOSUB +------+------+------+------+------+------+------+------+
;		|							|
;	+4	+	Context flag					+
;		|							|
;		+------+------+------+------+------+------+------+------+
;		|							|
;	+2	+	Trap table index				+
;		|							|
;END EVENT GOSUB+------+------+------+------+------+------+------+------+
;	BP  --> |							|
;		+	Previous BP					+
;		|							|
;		+------+------+------+------+------+------+------+------+
;	-2  --> |							|
;		+	Previous BASIC frame pointer			|
;		|							|
;		+------+------+------+------+------+------+------+------+
;	-4  --> |							|
;		+	Saved SI					+
;		|							|
;		+------+------+------+------+------+------+------+------+
;	-6  --> |							|
;		+	Saved DI					+
;		|							|
;		+------+------+------+------+------+------+------+------+
;	-8  --> |							|
;		+	Count of local bytes on stack			|
;		|							|
;    		+------+------+------+------+------+------+------+------+
;       -10->   |							|
;		+	User program current GOSUB count		|
;		|							|
;		+------+------+------+------+------+------+------+------+
;		|							|
;
;
; Event frame info
;
FR_EVRETSEG	EQU	8	;[5] Return address segment for EVENT returns
FR_EVRETOFF	EQU	6	;[5] Return address offset for EVENT returns
;
; Return address to routine which FAR CALLed a BASIC SUB or FUNCTION. Placed by
; CALL instruction.
;
FR_RETSEG	EQU	4	;[3] return address segment
FR_RETOFF	EQU	2	;[3] return address offset
;
; BP on entry into BASIC SUB or FUNCTION for standard BP chain. PUSHed by
; Compiled code when the switches are not specified, by B$ENSA/B$ENRA in other
; cases.
;
FR_BP		EQU	0	;[10] Previous BP
;
; Previous BASIC frame. The value of [b$curframe] is saved here by B$ENSA /
; B$ENRA such that B$EXSA can restore it on exit. Should always be the first
; thing pushed after BP, for futre optimizations.
;
FR_BFRAME	EQU	-2	;[10] Previous BASIC frame
;
; Saved SI & DI. Preserved for C compatability. Saved by B$ENSA / B$ENRA /
; B$ENSD / B$ENRD restored by B$EXSA.
;
FR_SI		EQU	-4	;[10] SI for C compat, also QBI text pointer
FR_DI		EQU	-6	;[10] DI for C compat
;
; Count of local bytes of storage allocated on stack by compiler generated
; code. Placed by B$ENSA/B$ENRA. Used at error time to recover state prior to
; any ON ERROR.
;
FR_CLOCALS	EQU	-8	;[10] count of locals on stack
;
;
; Gosub count used only in /D/E/X compiled programs. Used to ensure that
; RETURNs to not exceed GOSUBs. Zeroed by B$ENSA / B$ENRA, otherwise maintained
; by GOSUB / RETURN and multi-line DEF code. Also used at error time to recover
; state prior to ON ERROR.
;
; Must be last on the frame to optimize recursive zero-fill.
;
FR_GOSUB	EQU	-10	;[10] GOSUB count
;
; Size in bytes of the items "pushed" onto the stack after BP.
;
FR_SIZE 	EQU	10	;[3] Frame size (without word temps)

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\inc\xenix.inc ===
;***
;xenix.inc - 20-Mar-86 - Operating System Equates and Macros
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************

XENERR=	-1			;Xenix error flag (in ax after system call)
XENEOF=	0			;Xenix end-of-file (in ax after system call)
MEMREQ	EQU	0FFF0H		;Initial memory request

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\abs.asm ===
TITLE	ABSOLUTE - helper for assembly routines
;***
; ABSOLUTE - Helper for calling BASIC interpreter assembly routines
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; Just used to clear information from the stack to various registers and
; memory locations.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	useSeg	_BSS
	useSeg	ER_TEXT 	
	useSeg	RT_TEXT

	INCLUDE seg.inc

sBegin	_BSS

	externW b$seg		;def seg segment


sEnd	_BSS


sBegin	RT_TEXT
assumes CS,RT_TEXT



;***
; ABSOLUTE - Call absolute address
;
;Purpose:
;	Routine which can be directly called from the basic level which
;	in turn calls an absolute address.
;
;	Under DOS, we push the address of the function on the stack
;	and RET to it.	This gives a protection violation under OS/2
;	Protect mode, so we set up a variable to hold the address
;	and do a JSR indirect to the address.  On return, we have
;	to release the Segment descriptor that we created.
;
;Entry:
;	The actual number of parameters is variable, and depends on the
;	routine that ABSOLUTE will in turn call. The LAST parameter pushed
;	MUST be the DSoffset of an integer variable containing the offset
;	of the routine to be called. The current DEF SEG is used as the
;	segment for the call.
;Exit:
;	IF OM_DOS3
;	   Whatever the called routine elects. We do NOT return to basic
;	   code from here.
;	IF OM_DOS5
;	   Whatever the called routine elects. We do not save any of
;	   the registers around the call. After the call we trash AX,CX
;	   so we would need to modify this to make a Function ABSOLUTE.
;
;Uses:
;      This routine follows convention, but does no saving or checking of
;      the code actually called.
;
;Notes:
; The called routine receives control with all parameters passed to ABSOLUTE,
; except the offset integer, on the stack in Pascal convention. The return
; address present is back to the BASIC level code which CALLed ABSOLUTE.
;
; Stack on call to ABSOLUTE:
;
;
;		\ 	Variable number of parameters		\
;		|	   to routine to be CALLed		|
;		+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;		|	Near pointer to I2 var containing	|
;		|	the offset of the routine to CALL	|
;		+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;		|CS						|
;		+    Far return address to caller of ABSOLUTE	+
;	[SP] -> |IP						|
;		+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;
; Stack on transfer to called routine:
;
;		\ 	Variable number of parameters		\
;		|	   to routine to be CALLed		|
;		+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;		|CS						|
;		+    Far return address to caller of ABSOLUTE	+
;	[SP] -> |IP						|
;		+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;
;
;
; Under OS/2 Protect mode things get complicated.  We have to return to
; this routine in order to deallocate the Segment Descriptor that we
; have created.  However, to insure that error handling works, we must
; have a BP Stack Frame on the stack for this procedure.  In order to
; do this, we have to move all the parameters to the absolute function
; down three words on the stack so that we can stuff our CS:IP BP values.
;
; To get the size of the parameters, we assume that there has been nothing
; pushed on the stack since the last BASIC frame.  We calculate the size
; of the basic frame, then move everything from that point to the end of
; the parameters down so that we can insert our stack frame.
;
;
;******************************************************************************
cProc	ABSOLUTE,<FAR,PUBLIC>
cBegin



	POP	AX		;return offset
	POP	DX		;return segment
	POP	BX		;get pointer to routine address
	PUSH	DX		;restore return address
	PUSH	AX
	PUSH	[b$seg]	; stack DEF SEG segment
	PUSH	[BX]		; stack routine offset

cEnd



sEnd	RT_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\circle.asm ===
TITLE	CIRCLE - iAPX 88/86 CIRCLE STATEMENT SUPPORT
;***
; CIRCLE - iAPX 88/86 CIRCLE STATEMENT SUPPORT
;
;	Copyright <C> 1986 - 1988, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - CIRCLE Statement:
;
;      CIRCLE (x,y),r [,color [,start,end [,aspect]]]
;	 |	|
;	 |	|
;	 |    Coord routines B$CSTT B$CSTO B$CASP B$CIRC
;	 |						 |
;	 +-----------------------------------------------+
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions
	INCLUDE const.inc	;constant definitions

	USESEG	CONST		
	USESEG	_DATA		
	USESEG	_BSS		
	USESEG	GR_TEXT 	

	INCLUDE seg.inc 	; Segment definitions
	INCLUDE idmac.inc	

sBegin	_BSS			
;
;****************************************************************************
; External low-level function vectors
;****************************************************************************
;
	externW b$MapXYC	
	externW b$SetPixFirstC	
	externW b$SetPixC	
	externW b$SetPixLastC	

	externW B$A_END		;defined in GWDATA.ASM
	externW B$A_START	;defined in GWDATA.ASM
	externW b$ASPECTR	;defined in GWDATA.ASM
	externW B$CSTCNT 	;defined in GWDATA.ASM
	externW B$CENCNT 	;defined in GWDATA.ASM
	externW B$CRCSUM 	;defined in GWDATA.ASM
	externB B$CPLOTF 	;defined in GWDATA.ASM
	externB B$CLINEF 	;defined in GWDATA.ASM
	externW B$CNPNTS 	;defined in GWDATA.ASM
	externW B$CPCNT		;defined in GWDATA.ASM
	externW B$CPCNT8 	;defined in GWDATA.ASM
	externB B$COPTFL 	;defined in GWDATA.ASM
	externW B$GX_OLD 	;defined in GWDATA.ASM
	externW B$GXPOS		;defined in GWDATA.ASM
	externW B$GRPACX 	;defined in GWDATA.ASM
	externW B$GRPACY 	;defined in GWDATA.ASM

	externQ B$LXDIF		; defined in GRFPINIT.ASM
	externB B$WNDWSW 	;defined in GWDATA.ASM


	externW B$VXMIN		;defined in GWDATA.ASM
	externW B$VYMIN		;defined in GWDATA.ASM
	externW B$VXMAX		;defined in GWDATA.ASM
	externW B$VYMAX		;defined in GWDATA.ASM
	externW B$CXOFF		;defined in GWDATA.ASM
	externW B$CYOFF		;defined in GWDATA.ASM

sEnd	_BSS			

sBegin	_DATA			

	externB B$CLIPF

sEnd	_DATA			

sBegin	CONST			

	externD b$FP_1 	; s.p. constant   1.0
	externD b$FP_256	; s.p. constant 256.0

	.8087			
FP_4OPI 	DD	1.273239545 ; 4/PI
FP_3PIO2	DD	4.71238898  ; 3*PI/2
FP_2PI		DD	6.283185306 ; 2*PI
FP_SQR2O2	DD	0.707106781 ; SQR(2)/2

sEnd	CONST			

	externFP B$fcomp	
	externFP B$fcompz	
	externFP B$fcompp	
	externFP B$FIX8		
	externFP B$COS4 	
	externFP B$SIN4 	

assumes CS,GR_TEXT		
sBegin	GR_TEXT 		


	externNP B$CLRATR


	externNP B$GetAspect	

	externNP B$INVIEW
	externNP B$CLINE2

	externNP B$ERR_FC
	externNP B$fmlds	
	externNP B$fmldw	
	externNP B$ftolrnd	
	externNP B$COORD1	
	externNP B$SCINIT	; Performs screen initialization
	externNP B$ERR_OV	;overflow error


	SUBTTL	B$CSTT - process optional start angle for CIRCLE statement
	PAGE
;***
;B$CSTT - process optional start angle for CIRCLE statement
;Purpose:
;	Process optional start angle for CIRCLE by saving it for later
;	in B$A_START.  Set bit 2 in flag variable B$COPTFL to
;	1 to indicate that a start angle was specified.
;Entry:
;	sAngle	= S.P. start angle in radians
;Exit:
;	B$A_START contains start angle
;Uses:
;	Per Convention
;****
cProc	B$CSTT,<PUBLIC,FAR>	
parmD	sAngle			
cBegin				
	PUSH	DI		;protect registers
	MOV	AL,4		;note start angle spec flag
	MOV	DI,OFFSET DGROUP:B$A_START ;POINT DI AT B$A_START
	JMP	SHORT CIR_SAVE	;save start angle and return
cEnd	<nogen> 		

	PAGE
	SUBTTL	B$CSTO -  process optional end angle for CIRCLE statement
;***
;B$CSTO -  process optional end angle for CIRCLE statement
;Purpose:
;	Process optional end angle for CIRCLE by saving it for later
;	in B$A_END.  Set bit 1 in flag variable B$COPTFL to
;	1 to indicate that an end angle was specified.
;Entry:
;	sAngle = S.P. end angle in radians
;Exit:
;	B$A_START contains end angle
;Uses:
;	Per Convention
;****
cProc	B$CSTO,<PUBLIC,FAR>	
parmD	sAngle			
cBegin				
	PUSH	DI
	MOV	AL,2		;note end angle spec flag
	MOV	DI,OFFSET DGROUP:B$A_END ;POINT DI AT B$A_END

CIR_SAVE:
	PUSH	ES		
	PUSH	DS		
	POP	ES		;Set ES = DS
	OR	B$COPTFL,AL	;set appropriate flag
	PUSH	SI
	LEA	SI,sAngle	;INIT SOURCE REGISTER
	CLD			;CLEAR DIRECTION FLAG
	MOVSW
	MOVSW			;save specified parameter
	POP	SI
	POP	ES		
	POP	DI
cEnd				


	SUBTTL	B$CASP - process optional aspect ratio for CIRCLE statement
	PAGE
;***
;B$CASP - process optional aspect ratio for CIRCLE statement
;
;Purpose:
; Process optional aspect ratio for CIRCLE.  Bit 3 in B$COPTFL is set to 1 to
; indicate non-default aspect ratio. Compare aspect ratio to 1. If greater than
; one,then set bit 0 in B$COPTFL to 1 to indicate that x axis must be scaled
; instead of y axis, and invert the aspect ratio (an aspect ratio greater than
; 1 is repre- sented as 256/n but is inverted to n/256 after setting flag bit
; in B$COPTFL). Multiply aspect ratio by 256 (i.e.,store numerator n only of
; aspect ratio (n/256)) and save as integer in b$ASPECTR.
;
;Entry:
;	aRatio = S.P. aspect ratio
;Exit:
;	None
;Uses:
;	Per convention
;****
cProc	B$CASP,<PUBLIC,FAR>,ES	
parmD	aRatio			
cBegin				

	OR	B$COPTFL,8	;FLAG NON-DEFAULT ASPECT RATIO


	FLD	aRatio		; ST0 = aspect ratio
	FLD	b$FP_1		; ST0 = 1.0, ST1 = aspect ratio
	CALL	B$fcomp 	; compare
	JNC	CIRC11		; brif aspect ratio already < 1.0
	OR	B$COPTFL,1	; Set scaling x flag
	FDIVR	b$FP_1		; ratio = 1.0/ratio
				; MAKE NUMBER FRACTION OF 256
CIRC11: 			
	FMUL	b$FP_256	; ratio = 256.0 * ratio


	CALL	B$ftolrnd	;round, pop off numeric stack, result in DX:AX
;
; This odd slice of code monkeys with negative aspect ratios so that we get the
; same results as produced by our interpreters (IBM and GW) when the specified
; aspect ratio is negative(!). At this point, BX contains an integer value (256
; * aspect ratio). Any value which has a low byte of zero and a non-zero high
; byte is mapped to 256 (aspect ratio of 1); otherwise the high byte is forced
; to zero.
;
	OR	AL,AL		;is low byte zero?
	JNZ	ZSTOASP 	;low byte is nonzero
				;so zero out high byte and store
	OR	AH,AH		;is high byte also zero?
	JZ	ZSTOASP 	;zero out high byte and store
	MOV	AH,1		;force aspect ratio to 1
	JMP	SHORT STOASP	;store the aspect ratio
ZSTOASP:
	XOR	AH,AH		;zero out high byte of aspect
STOASP:
	MOV	b$ASPECTR,AX	 ;SAVE ASPECT RATIO
cEnd				

	SUBTTL	B$CIRC - process the CIRCLE statement
	PAGE
;***
;B$CIRC, $CI0	   process the CIRCLE statement
;
;Purpose:
;	Draw the circle at the specified center coordinates with the
;	specified radius and of the specified color.  Arcs may be
;	drawn by specifying the start and end angles; segments may
;	be drawn by specifying these angles as negative.  The circle
;	may be scaled by specifying the aspect ratio.
;
;  flag bytes:
;
;  B$CLINEF:		   circle line to center flag
;	  lo bit (bit 0) set means draw line to ctr from start angle
;	  bit 1 set means line to ctr from start angle already drawn (bug fix)
;	  hi bit (bit 7) set means draw line to ctr from end angle
;	  bit 6 set means line to ctr from end angle already drawn (bug fix)
;
;  B$COPTFL:		   circle option flag
;	  bit 0 set means scale x axis by aspect ratio
;	  bit 0 clear means scale y axis by aspect ratio
;	  bit 1 set means end angle specified
;	  bit 2 set means start angle specified
;	  bit 3 set means aspect specified
;	  bits 4-7 unused
;
;  B$CPLOTF:  indicates which points to plot if start and end angles specified
;
;
;Entry:
;	Radius	= radius (spexp)
;	Color	= color specification
;
;Exit:
;	graphics accumulators set at center
;Uses:
;	Per convention
;****
CRCERR:
	JMP	B$ERR_FC	;ALLOW ONLY POSITIVE NOS

CRCOV:				
	JMP	B$ERR_OV	;jump to overflow error

cProc	B$CIRC,<PUBLIC,FAR>,<ES,DI,SI> 
parmD	Radius			
parmW	Color			
cBegin				

	CALL	B$SCINIT	; init screen if not already done
	cCall	B$COORD1	;Convert points
	LEA	BX,Radius	; Get ptr to radius
	MOV	AX,Color	; Get specified Color

;	Give error if color parm < -1.	We should be giving an error
;	for any negative color value, but -1 is what is passed if the
;	user defaulted the color parm.

	CMP	AX,-1		; is color < -1 ?
	JL	CRCERR		; yes, give IFC

	CALL	OLD_CIR 	; Perform circle function
	MOV	B$COPTFL,AL	; Reset options.
cEnd				



OLD_CIR:			
	MOV	CX,BX
	PUSH	AX		;SAVE COLOR ATTRIBUTE

	MOV	AH,[BX+3]	;get sign byte
	OR	AH,AH		;IS RADIUS POSITIVE?
	JS	CRCERR		;NO: issue error message
	FLD	DWORD PTR [BX]	; ST0 = value ref'd by bx

	CMP	B$WNDWSW,0	
	JZ	CIRCL1		; Scale only if Window active
	FMUL	[B$LXDIF]	
CIRCL1:
	CALL	B$ftolrnd	;round & pop ST0, convert to integer in DX:AX
	OR	DX,DX		; test if over 64K
	JNZ	CRCOV		; if so, then overflow error
	OR	AX,AX		; test if over 32K
	JS	CRCOV		; if so, then overflow error
	MOV	B$GX_OLD,AX	;SAVE RADIUS

	FILD	B$GX_OLD 	; load onto numeric stack (ST0)


	FMUL	FP_SQR2O2	; [ST0] = radius * SQR(2)/2 = # Pt.s to plot

	CALL	B$ftolrnd	;convert to integer in AX (pop from num. stack)
	MOV	B$CNPNTS,AX	;B$CNPNTS=RADIUS*SQR(2)/2=# PTS TO PLOT

	TEST	B$COPTFL,8	;Is aspect ratio defaulted?
	JNZ	NDFASP		;NO: don't get default aspect ratio

	CALL	B$GetAspect	;Yes: get default aspect ratio
;GetAspect returns BX=256*aspect ratio and DX=256/aspect ratio
	OR	BH,BH		;Is aspect ratio > 1?
	JZ	SAVASP		;NO: scale y and save BX in b$ASPECTR
	OR	B$COPTFL,1	;Set scaling x flag
	XCHG	BX,DX		;Scaling x, using 1/aspect ratio
SAVASP: 			;Save aspect ratio
	MOV	b$ASPECTR,BX	;b$ASPECTR:=BX
NDFASP: 			;Non default aspect ratio
	MOV	CX,B$GRPACX	;Get coords saved by $CI0
	MOV	DX,B$GRPACY
	POP	AX		;RESTORE COLOR ATTRIBUTE
	CALL	B$CLRATR 	;SET COLOR ATTRIBUTE OF CIRCLE
	PUSH	B$GX_OLD 	;B$GX_OLD CONTAINS RADIUS
	POP	B$GXPOS		;B$GXPOS:=RADIUS
	XOR	BX,BX		;BX:=0 (DEFAULT START ANGLE)
	MOV	B$CLINEF,BL	;CLEAR B$CLINEF

;If optional circle generation is supported (OGCircle = 1) but the
;routine does not support clipping (OGCircleClip = 0), then software
;circle generation must be used when the aspect ratio is specified or
;when clipping is required.

	MOV	B$CLIPF,BL	;Assume clipping not required
				;B$ClipCheck always called now
	CALL	B$ClipCheck	;check if clipping will occur
;B$CLIPF = FF means clipping required
;B$CLIPF = 0 means clipping not required


	XOR	AX,AX		;CLEAR FLOATING COUNT
	XOR	CX,CX		;CLEAR FLOATING COUNT
	XOR	DX,DX		;CLEAR INTEGER COUNT
ANGLES: TEST	B$COPTFL,4	;START ANGLE SPECIFIED?
	JZ	NOSTRT		;NO: USE DEFAULT COUNTS

	FLD	DWORD PTR B$A_START 

	MOV	CL,1		;LO BIT SET FOR LINE TO CNTR
	CALL	ANGLE_CALC	;GO DO ANGLE CALCULATIONS - result in AX
	XCHG	AX,DX		;put start result in DX


NOSTRT:


	TEST	B$COPTFL,2	;END ANGLE SPECIFIED?
	JZ	NOEND		;NO: USE DEFAULT COUNT

	PUSH	DX		;SAVE INTEGER COUNT
	MOV	DX,-1		;DEFAULT END COUNT = INFINITY
OGCircle2:			

	FLD	DWORD PTR B$A_END 

	JMP	SHORT ENDFND	;Use user specified end angle
NOEND:				;Provide end angle default
	mov	ax,-1		;integer end count = infinity
	mov	bl,0		;polarity is always counterclockwise
	JMP	SHORT cstplt	;go plot the circle
ENDFND:
	MOV	CL,128		;SET HI BIT IN B$CLINEF FOR LINE TO CNTR
	CALL	ANGLE_CALC	;GO DO ANGLE CALCULATIONS - result in AX



	;AX = integer end count
	POP	DX		;Restore integer start count
	CMP	AX,DX
	MOV	BL,0
	JAE	CSTPLT		;PLOT POINTS BETWEEN STRT & END if end >= start

	MOV	BL,B$CLINEF	;fetch center line flag byte
	OR	BL,BL		;was either flag set ?
	JZ	CIRREV		;no, just reverse polarity
	XOR	BL,129		;yes, were they both set ?
	JZ	CIRREV		;yes, just reverse polarity
	MOV	B$CLINEF,BL	;no, reverse center line flags also
CIRREV:
	MOV	BL,-1		;PLOT POINTS ABOVE & BELOW
	XCHG	DX,AX		;SWAP START AND END SO START .LT. END
CSTPLT:
	MOV	B$CPLOTF,BL	;SET UP PLOT POLARITY FLAG
	MOV	B$CSTCNT,DX	;STORE START COUNT
	MOV	B$CENCNT,AX	;AND END COUNT
	CMP	AX,DX		;Does START .EQ. END?
	JNE	CIRCPL		;No: GO PLOT CIRCLE
	MOV	AL,B$CLINEF	;Yes: check for special case
	TEST	AL,129		;   if either center line flag set then
	JZ	CIRCPL		;(BOTH FLAGS ALREADY SET)
	OR	AL,129		;set the BOTH flags so order of checks
	MOV	B$CLINEF,AL	;in CPLOT4 won't miss a center line needed
CIRCPL: 			;PLOT THE CIRCLE
	JMP	B$DrawCircle	;NOW DRAW THE CIRCLE


;***
;B$ClipCheck
;
;Purpose:
;	Detect if the circle must be clipped.
;
;Entry:
;	([B$VXMIN],[B$VYMIN]) = left upper window boundary
;	([B$VXMAX],[B$VYMAX]) = right lower window boundary
;	[b$ASPECTR] = integer aspect ratio
;	[B$COPTFL] = circle option flag
;	  bit 0 set means scale x axis by aspect ratio
;	  bit 0 clear means scale y axis by aspect ratio
;	[B$GRPACX] = center X
;	[B$GRPACY] = center Y
;	[B$GXPOS] = radius
;
;Exit:
;      [B$CLIPF] = FF indicates clipping will be required.
;
;Modifies:
;	none
;****

cProc	B$ClipCheck,<NEAR>,<AX,CX,DX>	
cBegin
	mov	dx,B$GXPOS	;move radius to dx for cplscx
	call	cplscx
	MOV	AX,B$GRPACX	;Get the X center
	ADD	AX,CX		;Radius
	SUB	AX,B$VXMAX	;Test for off to the right
	NEG	AX
	JS	CLPCLP		;Clipping required
	MOV	AX,B$GRPACX
	SUB	AX,CX		;Radius
	SUB	AX,B$VXMIN	;Test for off to the left
	JS	CLPCLP		;Clipping required
	MOV	AX,B$GRPACY	;Now check for the Y direction
	ADD	ax,dx		
	SUB	AX,B$VYMAX	;Test for off the bottom
	NEG	AX
	JS	CLPCLP		;Clipping required
	MOV	AX,B$GRPACY
	sub	ax,dx		
	SUB	AX,B$VYMIN	;Test for off the top

CLPCLP:
	RCL	AX,1		;Rotate sign bit to PSW.C
	SBB	AL,AL		;Map PSW.C to 0 or FF
	MOV	B$CLIPF,AL	;Store the new flag
cEnd


;*** 
; ANGLE_CALC
;
;Purpose:
;
;Entry:
; [ST0] = angle
; [CL]	= LO or HI bit set for line to cntr
;
;Exit:
; [AX]	= result of calculation
;
;Uses:
;
;Preserves: (optional)
;
;Exceptions:
;
;******************************************************************************
;
; Note:  This routine may exit by jumping to CGETXY
;

DbPub ANGLE_CALC
cProc ANGLE_CALC,<NEAR>
cBegin

;
; check sign of angle - make positive if not
;
	PUSH	CX		
	CALL	B$fcompz	; see if zero
	POP	CX		; restore input
	JZ	CHKCONT 	; brif angle = 0.0
	JC	CHKCONT 	; brif angle > 0.0

	MOV	BX,OFFSET DGROUP:B$CLINEF ; SET BIT IN [C] IN B$CLINEF
	OR	[BX],CL 	
	FCHS			; change sign of angle to positive
CHKCONT:			

	FLD	FP_2PI		; [ST0] = 2*PI
	CALL	B$fcomp	; Ensure angle within range
	JC	AngleBad	; Jump if > 2*PI


	FLD	ST(0)		; duplicate input angle on numeric stack
	FMUL	FP_4OPI 	; [ST0] = 4/PI * input angle
	CALL	B$FIX8		; MUST be truncated towards zero
	CALL	B$ftolrnd	; AX = trunc(octant(angle))  (0-7)
	INC	AX		; convert to 1-8
	SHR	AL,1		; AL = octant/2
	RCR	AL,1		; set up flags
	PUSHF			; PSW.V: 1=+,0=-; PSW.C: 1=COS,0=SIN
	RCL	AL,1		; restore octant/2, then multiply by 2:
	SHL	AL,1		; 0,2,2,4,4,6,6,8 = octant base index
	MUL	WORD PTR [B$CNPNTS] ; AX = (2 * INT((OCT+1)/2)) * CNPNTS
	POPF			; get flags: PSW.C: 1=COS, 0=SIN
	PUSH	AX		; save scaled count base
	PUSHF			; save PSW.V
	JC	UseCOS		; brif PSW.C = 1, use COSINE
	CALL	B$SIN4		; [ST0] = SIN(input angle)
	JMP	SHORT FixSign	; skip the COS stuff
UseCOS:				
	CALL	B$COS4		; [ST0] = COS(input angle)
FixSign:			
	FABS			; [ST0]=ABS(f(angle)), where f = SIN or COS
	POPF			; retrieve PSW.V
	JO	SignOK		; brif PSW.V set, otherwise simulate SUB
	FCHS			; NEGATE [ST0]
SignOK:				
	FIMUL	WORD PTR [B$GXPOS] ; [ST0] = Radius * ABS(f(angle)
	MOV	BX,SP		; [BX] points to scaled count base
	FIADD	WORD PTR [BX]	; Add octant base value for point count
	CALL	B$ftolrnd	; put integer equivalent in AX
	POP	BX		; remove count base from stack


cEnd				

AngleBad:
	JMP	B$ERR_FC	;angle too big




;
cProc	CPLSCX,<NEAR>		
cBegin				
	mov	cx,dx		;save unscaled value
	mov	ax,[b$ASPECTR]	;get 256*aspect ratio
	mul	dx		;dx:ax = dx * aspect *256
	add	ax,128D 	
	ADC	DH,DL		;(DH was 0 after mul)
	mov	dl,ah		;result is in dx
tstxchg:
	TEST	B$COPTFL,1	;SEE WHETHER ASPECT WAS .GT. 1
	JZ	CPLRET		;DON'T SWAP IF ZERO
	XCHG	cx,DX		;Greater, use 1/Aspect
CPLRET:
cEnd				

;***
;
;	CIRCLE ALGORITHM
;
;   [SI] = X = RADIUS
;   [DI] = Y = 0
;   SUM  = 1 - RADIUS
;   LOOP
;	plot 8 reflections of the point around the circle's center
;	IF Y >= X THEN
;	    EXIT LOOP
;	IF SUM > 0
;	    SUM = SUM - 2*X + 2
;	    X = X - 1
;	SUM = SUM + 2*Y + 3
;	Y = Y + 1
;
; 26-Jan-87 Major revision for speed
;
;****

cProc	B$DrawCircle,<NEAR>,<DI,SI,ES>   
cBegin
	CALL	[b$SetPixFirstC] ;low-level circle initialization
	XOR	DI,DI		;INIT Y = 0
	MOV	SI,B$GXPOS	;X = RADIUS
	MOV	AX,1		;SUM = 1-RADIUS
	SUB	AX,SI		
	MOV	B$CRCSUM,AX	
CIRCLP: 			
	PUSH	DI		;save X,Y
	PUSH	SI		
	CALL	CPLOT8		;reflect the point 8 ways
	POP	SI		;restore X,Y
	POP	DI		
	CMP	DI,SI		;finished when Y >= X
	JAE	CRCLPX		;go if done
	MOV	AX,B$CRCSUM	
	OR	AX,AX		;check sum for whether to move X too
	JS	CNODEX		;go, no X change this time, only Y
	SUB	AX,SI		;SUM = SUM - 2*X + 2
	SUB	AX,SI		
	ADD	AX,2		
	DEC	SI		;X = X - 1
CNODEX: 			;always move Y
	ADD	AX,DI		;SUM = SUM + 2*Y + 3
	ADD	AX,DI		
	ADD	AX,3		
	INC	DI		;Y = Y + 1
	MOV	B$CRCSUM,AX	;update sum
	JMP	SHORT CIRCLP	;loop

CRCLPX: 			;circle finished
	CALL	[b$SetPixLastC] ;low-level circle termination
cEnd				

TestClip:			;check point for clipping
	CALL	B$INVIEW 	;See if point outside of viewport
	JNC	CPLFIN		;go if pt not visible (carry reset)
	JMP	SHORT NoClip	;go if pt visible (carry set)

;
; REFLECT THE POINTS AROUND CENTER
; [SI] = X OFFSET FROM CENTER, [DI] = Y OFFSET FROM CENTER
;
cProc	CPLOT8,<NEAR>		
cBegin				
	MOV	B$CPCNT,DI	;octant point count is Y
	MOV	B$CPCNT8,0	;circle point count is 0

	MOV	AX,b$ASPECTR	;BX = round(Y * (aspect*256) / 256)
	MOV	CX,AX		
	MUL	DI		
	ADD	AX,128D 	
	ADC	DH,DL		;(DH was 0 after mul)
	MOV	DL,AH		
	MOV	BX,DX		

	MOV	AX,CX		;DX = round(X * (aspect*256) / 256)
	MUL	SI		
	ADD	AX,128D 	
	ADC	DH,DL		;(DH was 0 after mul)
	MOV	DL,AH		

	TEST	B$COPTFL,1	;which axis is being scaled?
	JNZ	NoSwap		;go if scaling X
	XCHG	BX,DI		;swap scaled/unscaled values
	XCHG	DX,SI		
NoSwap: 			
	MOV	B$CXOFF,BX	; B$CXOFF = scaled(unscaled) Y
				; DI     = unscaled(scaled) Y
	MOV	B$CYOFF,SI	; B$CYOFF = unscaled(scaled) X
	MOV	SI,DX		; SI     = scaled(unscaled) X

	NEG	DI		;negate Y to start
	CALL	CPLOT4		;plot (X,-SY) (-Y,-SX) (-X,SY) (Y,-SX)

	MOV	AX,B$CNPNTS	;odd octant counts start at end of octant
	MOV	B$CPCNT8,AX	
	SUB	AX,B$CPCNT	;later calculate point count in odd octant
	MOV	B$CPCNT,AX	;  as PNTCNT = PNTS/OCT - PNTCNT
	NEG	B$CXOFF		;negate B$CXOFF and Y to start
	NEG	DI		
cEnd	<nogen> 		

	; fall through to plot (Y,-SX) (-X,-SY) (-Y,SX) (X,SY)

;

cProc	CPLOT4,<NEAR>		
cBegin				
	MOV	AX,4		;plotting four points
CPLOT:
	PUSH	AX		;save count
	MOV	CX,SI		;get X,Y from saved values
	MOV	DX,DI		
	ADD	CX,B$GRPACX	;actual points are offset from
	ADD	DX,B$GRPACY	;  the circle's center
	test	B$COPTFL,6	;start or end angles specified?
	JNZ	TestAng 	;go if so
CPLTIT:
	CMP	B$CLIPF,0	;is clipping required?
	JNZ	TestClip	;go if so to check point
NoClip: 			;point gets plotted here
	CALL	[b$MapXYC]	;convert X,Y to address and mask
	CALL	[b$SetPixC]	;plot it
CPLFIN:
	POP	AX		;restore count
	DEC	AX		;finished?
	JZ	CIRRET		;go if so
	XCHG	SI,B$CXOFF	;swap values for next octant
	NEG	SI		
	XCHG	DI,B$CYOFF	
	NEG	DI		
	JMP	SHORT CPLOT	;loop for four octants/points
CIRRET:
cEnd				

TestAng:			;check point against start/end angles
	MOV	BX,B$CPCNT8	;current octant point count
	MOV	AX,B$CNPNTS	;update for next octant/point
	SAL	AX,1		
	ADD	AX,BX		
	MOV	B$CPCNT8,AX	
	ADD	BX,B$CPCNT	;BX = current point's count
	CMP	BX,B$CSTCNT	;at start point?
	JZ	CLINSC		;go if so
	JB	CNBTWN		;if less then point is not between
	CMP	BX,B$CENCNT	;at end point?
	JZ	CLINEC		;go if so
	JB	CBTWEN		;if less then point is between
CNBTWN:
	CMP	B$CPLOTF,0	;SEE WHETHER TO PLOT OR NOT
	JNZ	CPLTIT		;NEED TO PLOT NOT-BETWEEN POINTS
	JMP	SHORT CPLFIN	;DON'T PLOT - FIX UP STACK & RETURN
CLINEC:
	MOV	al,B$CLINEF	;get ptr to center line flag byte
	test	al,128
	JZ	CPLTIT		;NO LINE REQUIRED - JUST PLOT POINT
	test	al,64
	jnz	CPLFIN		;Don't draw line or point on arc.
	or	[B$CLINEF],64	;don't plot the line twice
	jmp	short CLINE	;plot the line from end angle to ctr

CLINSC:
	MOV	al,B$CLINEF	;get ptr to center line flag byte
	test	al,1
	JZ	CPLTIT		;NO LINE REQUIRED - JUST PLOT POINT
	test	al,2
	jnz	CPLFIN		;Don't draw line or point on arc.
	or	[B$CLINEF],2	;don't plot the line twice
CLINE:
	PUSH	SI		;save X,Y
	PUSH	DI		
	CALL	B$CLINE2 	;DRAW LINE FROM [CX],[DX] TO CENTER
	CALL	[b$SetPixFirstC] ;re-initialize for circle (EGA)
	POP	DI		;restore X,Y
	POP	SI		
GOCPLFIN:			
	JMP	SHORT CPLFIN

CBTWEN:
	CMP	B$CPLOTF,0	;SEE WHETHER PLOTTING BETWEENS OR NOT
	JNZ	GOCPLFIN	;relative jump out of range
	JMP	CPLTIT		;IF Z, THEN DOING BETWEENS


sEnd	GR_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\bload.asm ===
TITLE	BLOAD - BLOAD and BSAVE Library Support
;***
; BLOAD - BLOAD and BSAVE Library Support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;******************************************************************************
	INCLUDE rmacros.inc	; Runtime Macro Defintions
	INCLUDE switch.inc

;	code segments

	useSeg	DK_TEXT
	useSeg	DV_TEXT
	useSeg	NH_TEXT
	useSeg	ER_TEXT
	useSeg	RT_TEXT		

;	data segments

	useSeg	_DATA
	useSeg	_BSS

	INCLUDE	seg.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE baslibma.inc
	INCLUDE rtps.inc	; constants shared with QBI


	SUBTTL	local constant definitions

	BFileType=	0FDH	;253d if the file type
	TTY=		0	;tty is default

	SUBTTL	data externals

sBegin	_DATA
	externW	b$seg		;for DEF SEG
sEnd	_DATA

sBegin	_BSS
	externB	b$Buf3		
	externW	b$PTRFIL
	externB	b$ACCESS
	externB	b$LOCKTYPE
sEnd	_BSS

	SUBTTL	code externals
	page
sBegin	DV_TEXT
	externFP	B$CLOS
	externNP	B$OPENIT
	externNP	B$BIN
	externNP	B$BOT
	externNP	B$DOS3CHECK	
sEnd	DV_TEXT

sBegin	NH_TEXT
	externNP	B$LHFDBLOC	
sEnd	NH_TEXT

sBegin	RT_TEXT				
sEnd	RT_TEXT				

sBegin	ER_TEXT
	externNP	B$ERR_BFM	;bad file mode
	externNP	B$ERR_DFL	;Disk full
sEnd	ER_TEXT

	assumes	CS,DK_TEXT
sBegin	DK_TEXT
	SUBTTL	BSAVE interface -- B$BSAV
	Page

;***
;B$BSAV -- binary save
;void B$BSAV(sd *pFn, U2 offset, U2 cByte)
;
;Purpose:
;	BSAVE the memory image from the area defined by the last DEF SEG
;	value and user supplied Offset and Length.
;Entry:
;	Parameters are in stack.
;	sd	*pFileName
;	U2	Offs -- user supplied offset
;	U2	Len -- user supplied length
;Exit:
;	none
;Uses:
;	none
;Exceptions:
;	disk full -- can't write on the disk
;*******************************************************************************

cProc	B$BSAV,<PUBLIC,FAR>
	ParmW	pFileName	;*sd of filename
	ParmW	Offs		;U2 user specified offset
	ParmW	Len		;U2 user specified length
cBegin


;	Construct header block of seven bytes for start of BSAVE file.

	MOV	BYTE PTR b$Buf3,bFileType ;get file type in first hdr byte
	MOV	DX,[b$seg]	;get segment of memory to be saved
	MOV	WORD PTR b$Buf3+1,DX ;put into second and third bytes
	MOV	AX,Offs		;get offset of memory to be saved
	MOV	WORD PTR b$Buf3+3,AX ;put into fourth and fifth bytes
	MOV	CX,Len		;get length of memory to be saved
	MOV	WORD PTR b$Buf3+5,CX ;put into sixth and seventh bytes

;	Use registers set up to determine if access is illegal.


;	The BSAVE can proceed.  Now open the file for output.

	MOV	AX,MD_SQO	;BSave is output
	MOV	DX,pFileName	;DX = *sd of filename
	MOV	[b$ACCESS],ACCESS_WRITE ;write access for save
	MOV	[b$LOCKTYPE],LOCK_BOTH	;deny read/write
	cCall	OpenFile0	;open file 0, need AX & DX, on return
				; [b$PTRFIL]=*FDB

;	Output the seven-byte header in b$Buf3.

	MOV	DX,DS		;segment of b$Buf3 is DGROUP
	MOV	BX,OFFSET DGROUP:b$Buf3 ;get offset of b$Buf3
	MOV	CX,7		;size is the seven bytes
	cCall	B$BOT		;output the header to the file
	JC	ERCDFL		;if disk full, then file is closed

;	Output the memory to the file.

	MOV	DX,WORD PTR b$Buf3+1 ;get the segment of the BSAVE
	MOV	BX,WORD PTR b$Buf3+3 ;get the offset of the BSAVE
	MOV	CX,WORD PTR b$Buf3+5 ;get the length of the BSAVE
	cCall	B$BOT		;block output, need [b$PTRFIL]=*FDB
				; [DX|BX]=[segment|offset], [CX]=len 
	JC	ERCDFL		;if disk full, then file is closed
	cCall	CloseFile0	;close file 0


cEnd				;clear stack and exit to caller

ERCDFL:	JMP	B$ERR_DFL	;disk full

	SUBTTL	BLOAD interface -- B$BLOD
	page
;***
;B$BLOD -- binary load interface
;void B$BLOD(sd *pFn, U2 offset, I2 UsrFlag)
;
;Purpose:
;	File is loaded into the same Segment:Offset either from which it
;	was saved, if UsrFlag=0, or from the last DEF SEG value and user
;	supplied Offset.
;Entry:
;	Parameters are in stack.
;	sd	*pFileName
;	U2	Offs
;	I2	UsrFlag
;Exit:
;	none
;Uses:
;	none
;Exceptions:
;	Bad file mode -- file isn't a BLOAD file
;	input pass end -- can't read from the file
;*******************************************************************************

cProc	B$BLOD,<PUBLIC,FAR>
	ParmW	pFileName	;*sd of filename
	ParmW	Offs		;U2 user specified offset
	ParmW	UsrFlag		;I2 flag, 0 if user didn't specify offset
cBegin


	MOV	AX,MD_SQI	;BLoad is input
	MOV	DX,pFileName	;DX=*sd of file name
	MOV	[b$ACCESS],ACCESS_READ		;access read for load
	MOV	[b$LOCKTYPE],LOCK_WRITE	;deny write for load
	cCall	OpenFile0	;open file 0, need AX & DX, on return
				; [b$PTRFIL]=*FDB

;	Input the seven-byte header into b$Buf3.

	MOV	DX,DS		;segment of b$Buf3 is DGROUP
	MOV	BX,OFFSET DGROUP:b$Buf3 ;get offset of b$Buf3
	MOV	CX,7		;size is seven bytes
	cCall	B$BIN		;input the header to the file
	JC	ERCBFM		; brif not a BSAVE file -- Bad File Mode

;	Determine the far pointer of the memory to BLOAD.

	MOV	DX,WORD PTR b$Buf3+1 ;get the segment of the BSAVE
	MOV	BX,WORD PTR b$Buf3+3 ;get the offset of the BSAVE
	MOV	AX,WORD PTR b$Buf3+5 ;get the length of the BSAVE

	MOV	CX,UsrFlag	;get user flag
	JCXZ	LoadFile	;Brif yes, go load file

	MOV	BX,Offs		;get user specified offset
	MOV	DX,[b$seg]	;user's DEF SEG in DX

LoadFile:
	XCHG	AX,CX		;[CX] = Length

	cCall	B$BIN		;do block in, need [b$PTRFIL]=*FDB,
				; [DX|BX]=[segment|offset], [CX]=len

ERCBFM:				
	cCall	CloseFile0	;close file 0 (flag preserved)
	JNC	BLOAD_EXIT	; Brif no error
	JMP	B$ERR_BFM	; "Bad File Mode"
BLOAD_EXIT:			


cEnd


	SUBTTL	BLOAD/BSAVE supporting routines
	page
;***
;OpenFile0
;
;Purpose:
;	Open the given filename as the BASIC internal file (file 0).
;	This routine checks the file name (append '.BAS' to the file name,
;	if it doesn't have the extension), and then open it as the file 0.
;	If open succeed, get the addr. of the FDB and give the error
;	if the file is a special character device.
;Entry:
;	AX		= file mode
;	DX		= *sd of file name
;	[b$ACCESS]	= access right
;	[b$LOCKTYPE]	= deny right
;Exit:
;	[b$PTRFIL]	= *FDB of file 0
;Uses:
;	none
;Exceptions:
;	illegal function call -- if file name is a special char. device
;*******************************************************************************

cProc	OpenFile0,<NEAR>,<SI>

cBegin

	cCall	B$DOS3CHECK	;Are we running under DOS 2.1?
	JNC	IsDos3		;No, skip special code.
	MOV	[B$LockType],0	;Locking must be disabled for DOS 2.1
				; to prevent a DOS error when trying to open
IsDos3: 			; the file.

	MOV	BX,-1		;file #, indicate this is an internal file
	MOV	CX,1		;record length=1


	cCall	B$OPENIT	;open the file with AX=file mode, BX=file#
				; CX=VrecL, DX=*sd of file name, if file
				; name doesn't have extention, B$OPENIT
				; will append ".BAS" to it for file 0
	XOR	BX,BX		;get file 0's
	cCall	B$LHFDBLOC	;SI=*FDB
	MOV	[b$PTRFIL],SI	;for file dispatch routines (B$$RCH,...)
cEnd				;pop si and exit

	page
;***
;CloseFile0 -- close file 0
;
;Purpose:
;	This routine use existing interface routine to close file 0.
;Entry:
;	none
;Exit:
;	[b$PTRFIL] is reset
;Uses:
;	none
;Preserves:
;	flags
;Exceptions:
;
;*******************************************************************************

cProc	CloseFile0,<NEAR>

cBegin
	PUSHF			;save flags
	XOR	AX,AX		;file 0
	PUSH	AX		;I2 channel in stack
	INC	AX		;one parameter
	PUSH	AX		;cParams in stack
	cCall	B$CLOS		;close file 0
	MOV	[b$PTRFIL],TTY	;clear b$PTRFIL
	POPF			;get back flag
cEnd				;exit to caller

sEnd	DK_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\clear.asm ===
TITLE	CLEAR - CLEAR for BASCOM-86
;***
; CLEAR - CLEAR for BASCOM-86
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - CLEAR Statement
;
;      CLEAR [,[n][,m]]
;	     |
;	   B$SCLR
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	useSeg	RT_TEXT 	
	useSeg	_BSS		
	useSeg	_DATA		

	INCLUDE seg.inc 	
	INCLUDE stack2.inc	
	INCLUDE idmac.inc	
	INCLUDE const.inc	

sBegin	_BSS			

externW b$clrt_disp		; CLEAR "termination" dispatch table
externW b$clr_disp		; CLEAR statement dispatch table
externB b$inonerr		; flag indicating on-error in progress
externW b$mainframe		; main level frame
externW b$NH_first		
externW b$NH_last		
externW b$pend 			; End of user data
externW __atopsp		; top word allocated to STACK.
externW b$curlevel		;current program level
externB b$CtrlFlags		;BASIC generic flags
externB b$Clearing		; flag to indicate processing CLEAR stmt

staticW saveSI,,1		; preserved SI

sEnd	_BSS			

sBegin	RT_TEXT

externFP B$COMP_DISP		; Dispatch table utility
externNP B$ERR_OM_NH		
externNP B$ERR_OSS		
externNP B$ERR_FC		

externNP B$NHMOVALL		; juggle all heap space

assumes CS,RT_TEXT		
	SUBTTL	B$StackReset - Stack reset support for QBI
	PAGE
;*** 
; B$StackReset - Reset Stack to initial location (EI_QB only)
; void pascal B$StackReset(void)
;
;Purpose:
; Special entry point for QBI to set stack back to initial location
; before a RUN/RESTART.  Blasts stack back to main level, without
; doing all the other CLEAR related garbage.  This is necessary to
; ensure that .qlb XI initializers which nmalloc won't lose their
; allocated memory.
; Added with revision [18]
;
;Entry:
; none
;
;Exit:
; none
;
;Uses:
; per convention
;
;******************************************************************************

cProc	B$StackReset,<FAR,PUBLIC>
parmW	stack
parmW	fStack
cBegin
	MOV	AX,STACK_SIZE	;default size
.erre	STACK_SIZE AND 0FF00H
	OR	b$CtrlFlags,NoInitBcVars ;We have already inited BcVars,
	JMP	SHORT CLR_RUN
cEnd	<nogen>

	SUBTTL	B$RUNL - RUN Linenumber support for compiled code
	PAGE
;*** 
; B$RUNL - RUN Linenumber support for compiled code
; void pascal B$RUNL (U2 stack, U2 fStack)
;
;Purpose:
; Special entry point for compiler RUN [linenumber]. Performs all functions
; of B$SCLR(0), and blasts stack back to the main level.
; Interface added revision [13]
;
;Entry:
; none
;
;Exit:
; none
;
;Uses:
; per convention
;
;******************************************************************************
cProc	B$RUNL,<FAR,PUBLIC>
parmW	stack
parmW	fStack
cBegin
	MOV	AX,STACK_SIZE	;default size
	JMP	SHORT CLR_RUN
cEnd	<nogen> 		

ERCOSS:
DbAssertTst [b$CtrlFlags],Z,NoInitBcVars,RT_TEXT,<Unexpected OSS error in B$SCLR> 
	JMP	B$ERR_OSS	; memory allocation error

ERCFC:
DbAssertTst [b$CtrlFlags],Z,NoInitBcVars,RT_TEXT,<Unexpected IFC error in B$SCLR> 
	JMP	B$ERR_FC	; function error

;*** 
; B$SCLR - CLEAR statement
; void pascal B$SCLR (U2 stack, U2 fStack)
;
;Purpose:
; Clear variables and file system.  Closes all files, clears all variables
; (including COMMON and LNA), resets stack and optionally changes its size,
; initializes the string and local heaps, flushes the play queues and sets
; music to foreground, and sets $SEG to DGROUP.
;
; The compiler should ensure that CLEAR does not appear inside multiline
; functions. The runtime needs to ensure that CLEAR only occurs in the main
; program. This is done by testing whether the initial frame pointer is active.
;
; Interface added revision [9]
;
;Entry:
; stack = user requested stack size delta
; fStack = Flag indicating stack parameter is valid. If false, default is
;	   assumed.
;
;Exit:
; none
;
;Uses:
; per convention
;
;******************************************************************************
cProc	B$SCLR,<FAR,PUBLIC>	
parmW	stack			
parmW	fStack			
cBegin				
	MOV	AX,STACK_SIZE	; default size (in case fStack false)
	MOV	CX,fStack	
	JCXZ	CLEARIT 	; jump if default to be used
	MOV	AX,stack	; else get specified size
	ADD	AX,STACK_MIN	; Add base stack size
	JB	ERCOSS		; if too big, then error
;
;	Test if in main module, if not, then CLEAR is illegal.
;
CLEARIT:
	MOV	BX,[BP] 	; Get current user frame
	TEST	[b$inonerr],0ffH ; in an on error handler?
	JZ	CLEAR_10	; then BX is correct
	MOV	BX,[BX] 	; else BX is one removed
CLEAR_10:			
	CMP	BX,[b$mainframe] ;test if in main module
	JNE	ERCFC		;if not, then error
;
;	Compute new stack pointer by adding stack size to end of user
;	variables-2 (-2 so that there is no possiblity of segment wrap-around)
;	This calculation is the same as that in the C startup.
;
CLR_RUN:			; Entry point for RUN from above
	SUB	AX,2		; subtract 2 for __asizds limit
				; (won't cause carry)
	ADD	AX,b$pend	; add end of variables
	JC	ERCOSS		; if carry, then out of memory
	AND	AL,0FEh		; make even if not already

;
;	Execute clear-time termination routines for various runtime components
;

	INC	b$Clearing	; indicate processing CLEAR statement
	MOV	saveSI,si	;preserve SI
	PUSH	AX		; Save Me!
	MOV	SI,OFFSET DGROUP:b$clrt_disp	; get dispatch table addr
	CALL	FAR PTR B$COMP_DISP		; do table dispatches
	POP	AX		; [AX] = new atopsp
;
;	Initialize the new stack including the frame.
;
	SUB	AX,[__atopsp]	; [AX] = delta, Carry = moving down

	PUSHF			; save flags for later
	CMP	AX,8		; >= 8 bytes?
	JGE	AdjustStack	; brif so -- adjust stack
	CMP	AX,-8		; <= -8 bytes?
	JLE	AdjustStack	; brif so -- adjust stack
				; Don't move heaps since the algorithm
				; presently used by B$NHMOV will hose
				; things if the adjustment is -8 < x < 8
	POPF			; discard flags
	XOR	AX,AX		; pretend no adjustment specified
				; (clears carry so heaps won't be moved)
	PUSHF			; save the flags (reset SP & return)

AdjustStack:			
	POPF			; restore flags
	JBE	CLEARIT_DOWN	; brif no change or moving down
	CALL	B$NHMOVALL	; Move heaps up BY AX BEFORE setting stack
	JC	ERCOM		; Jump if no memory

CLEARIT_DOWN:			
	POP	DX		; Discard previous frame pointer
	POP	BX		; [BX] = return address offset
	POP	DX		; [DX] = return address segment

	ADD	[__atopsp],AX	; adjust top of stack pointer BY AX
	MOV	SP,[__atopsp]	; set the new stack
	PUSH	DX		; replace return address
	PUSH	BX		
	JNC	CLEARIT_UP	; Jump if moving up

	CALL	B$NHMOVALL	; Move heaps down BY AX AFTER setting stack
	JC	ERCOM		; Jump if no memory


CLEARIT_UP:			

;
;	Execute clear-time re-initialization routines for runtime components
;
	MOV	SI,OFFSET DGROUP:b$clr_disp	; get dispatch table addr
	CALL	FAR PTR B$COMP_DISP		; do table dispatches
	MOV	SI,saveSI	;recover SI

	AND	[b$CtrlFlags],NOT NoInitBcVars ;reset static flag
	MOV	b$Clearing,0	; indicate done processing CLEAR statement
	RET			;return to interp
cEnd	nogen			

ERCOM:
	AND	[b$CtrlFlags],NOT NoInitBcVars ;reset static flag
	JMP	B$ERR_OM_NH	; memory allocation error


sEnd	RT_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\cninit.asm ===
TITLE	CNINIT.ASM - Console I/O Initialization/Termination module
;***
;CNINIT.ASM - Console I/O initialization/termination module
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains screen and keyboard initialization and termination
;	support for the BASIC 3.0 runtime.  This module will only be present
;	in a user's program when a program contains I/O statements.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;
;	Code Segments
;
	USESEG	<INIT_CODE>	;Initialization
	USESEG	<CN_TEXT>	;Console I/O
	USESEG	<RT_TEXT>	;Runtime core
	USESEG	<ST_TEXT>	;String
	USESEG	<DV_TEXT>	

;
;	Data Segments
;
	USESEG	<_BSS>		;runtime data (uninitialized)
	USESEG	<_DATA> 	;runtime data (initialized)
	USESEG	<XIB>		; initializer segment
	USESEG	<XI>		;initializer segment
	USESEG	<XIE>		; initializer segment

	INCLUDE seg.inc
	INCLUDE compvect.inc	;component vectors
	INCLUDE messages.inc	;messages and associated numbers
	INCLUDE files.inc
	INCLUDE dc.inc
	INCLUDE idmac.inc	
	INCLUDE const.inc	

	INITIALIZER	B$xCNINI	;put B$xCNINI in initializer list.

	SUBTTL	Runtime code externals
	PAGE
sBegin	DV_TEXT 			
	externNP	B$NearRet	;for disp vectors in compvect.inc
sEnd	DV_TEXT 			

sBegin	RT_TEXT 		
	externNP	B$PUTNUM	;print message from message number
sEnd	RT_TEXT 		

sBegin	ST_TEXT
sEnd	ST_TEXT

sBegin	CN_TEXT

	externNP	B$CLREOL		; clear to end of line
	externNP	B$LastLine	; clear last line
	externNP	B$KEYDSP	; display function keys if on
	externNP	B$KYBINI	
	externNP	B$TTYIN		
	externNP	B$SCNLOC	; update b$CURSOR & displ user csr
	externNP	B$GETCSRDATA	; get active page cursor position
	externNP	B$OFFCSR	; display user cursor
	externNP	B$RESETSCN	; reset screen to entry-time state
	externNP	B$GWTERM	; OEM's routine

sEnd	CN_TEXT
	SUBTTL	Runtime data definitions for BASIC Console I/O
	PAGE
sBegin	_DATA

;
;	External data
;
	externW b$ini_disp	;One time initialization dispatch table
	externW b$term_disp	;One time termination dispatch table
	externW b$run_disp	;RUN time initialization dispatch table
	externW b$shli_disp	;SHELL time initialization dispatch table
	externW b$shlt_disp	;SHELL time termination dispatch table
	externW b$errnum	;error number - non-zero after error
	externB b$Chaining	;non-zero if we are CHAINing.
	externB	b$IOFLAG	; Misc. IO flags.  Defined in GWINI.ASM
	externW	b$CURSOR	; (1,1)-relative screen cursor
	externW	b$CurPages	; current active page and visual page
	externB	b$ActPage	; current active page

sEnd	_DATA

sBegin	_BSS

;
;	Local data
;
	staticB ctlcsave,?	;Intial Control C processing state.

sEnd	_BSS

	SUBTTL	Runtime Console I/O Initialization
	PAGE
assumes CS,INIT_CODE
sBegin	INIT_CODE

;***
;B$xCNINI - Console I/O initializer
;PLM B$xCNINI()
;
;Purpose:
;	Initializer for Console I/O component.	This routine is called
;	by the Crt0 startup before _main is called.  It will update the
;	indirect dispatch tables for the console I/O routines.	This
;	insures that the only time that Console I/O is accessed is when
;	this module is linked into the user program.
;
;Entry:
;	None.
;
;Exit:
;	b$ini_disp.CN_IVEC	- contains pointer to B$CNINI
;	b$term_disp.CN_TVEC	- contains pointer to B$CNTERM
;	b$run_disp.CN_RVEC	- contains pointer to B$CNRUNINI
;	b$shli_disp.CN_SIVEC	- contains pointer to B$CNKBDSET
;	b$shlt_disp.CN_STVEC	- contains pointer to B$CNKBDRESET
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xCNINI,<FAR>
cBegin
;
;	update "ONE" time initialization dispatch address to B$CNINI
;
	MOV	WORD PTR [b$ini_disp].CN_IVEC,CN_TEXTOFFSET B$CNINI 
;
;	update "ONE" time termination dispatch address to B$CNTERM
;
	MOV	WORD PTR [b$term_disp].CN_TVEC,CN_TEXTOFFSET B$CNTERM
;
;	update "RUN" time initialization dispatch address to B$CNRUNINI
;
	MOV	WORD PTR [b$run_disp].CN_RVEC,CN_TEXTOFFSET B$CNRUNINI
;
;	update SHELL "initialization" dispatch address to B$CNKBDSET
;
	MOV	WORD PTR [b$shli_disp].CN_SIVEC,CN_TEXTOFFSET B$CNKBDSET
;
;	update SHELL "termination" dispatch address to B$CNKBDRESET
;
	MOV	WORD PTR [b$shlt_disp].CN_STVEC,CN_TEXTOFFSET B$CNKBDRESET
cEnd
sEnd	INIT_CODE	

	PAGE		
assumes CS,CN_TEXT	
sBegin	CN_TEXT 	

;***
;B$CNINI	- One time initialization for Console I/O
;void pascal B$CNINI()
;
;Purpose:
; BC3
; ---
;	Initializes screen and keyboard for standard character
;	I/O.  B$CNINI does the following:
;		Determines if input and/or output is redirected, and sets
;			the appropriate bits in b$IOFLAG.
;		Saves high level screen dimensions
;		Save initial screen variables (low level)
;	  DOS 3 specific:
;		Save CTL-C state
;		Set ignore CTL-C
;		Save/Set keyboard interupt vector (low level)
;	  DOS 5 specific:
;		Set ignore ctl-c signal
;		Key board key trapping (??)
;
; QB3
; ---
;	Same as above. (WHO/HOW does CTL-C get handled for QB3??)
;
;Entry:
;	None.
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;****
cProc	B$CNINI,<PUBLIC,NEAR>		
cBegin


;	Get the DOS information for file handles 0 and 1, and set the
;	appropriate bit of b$IOFLAG if I/O is redirected.

	MOV	BX,STDOUT		; start with stdout
	MOV	CL,RED_OUT		; test for redirected output

REDIR_LOOP:				; loop will only go through twice
;	CL = bit mask RED_INP (when BX = stdin) or RED_OUT (when BX = stdout)

	MOV	AX,C_IOCTL SHL 8 + 0	; prepare to issue IOCTL(0)
	CALLOS				; get device info
	TEST	DL,FL_CHAR		; is handle a file?
	JZ	REDIR_IO		; brif so -- redirected

					; DX = device information
	TEST	DL,FL_CONINP OR FL_CONOUT ; console device?
	JNZ	NO_REDIR_IO		; brif so -- not redirected
REDIR_IO:				
	OR	b$IOFLAG,CL		; set appropriate redir flag
NO_REDIR_IO:				

	MOV	CL,RED_INP		; prepare to check stdin
	DEC	BX			;  for redirected input
	JZ	REDIR_LOOP		; brif stdin not processed yet


	CALL	B$CNKBDSET		;initialize the keyboard

CNINIExit:				

cEnd
	PAGE

;***
;B$CNRUNINI - RUN time console i/o initialization.
;void pascal B$CNRUNINI()
;
;Purpose:
; BC3 - void pascal B$CNRUNINI()
; ---
;	B$CNRUNINI does the following:
;		Set initial cursor variables (low level)
;		Set initial Window boundaries (high and low level)
;		Clear screen and home cursors.
;		Redisplay function keys if ON.
;
; QB3 - void pascal B$CNRUNINI()
; ---
;	Same as above. (How about Function Keys???)
;
;Entry:
;	None.
;
;Exit:
;	??
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$CNRUNINI,<NEAR>	
cBegin
cEnd


	PAGE


;***
;B$CNKBDSET - Keyboard Initialization
;void pascal B$CNKBDSET()
;
;Purpose:
;	This routine is responsible for initializing the keyboard.
;	It gets called during system initializaition, RUN, CHAIN,
;	and SHELL.
; BC3
; ---
;	Initializes keyboard for standard character I/O.
;	  DOS 3 specific:
;		Save CTL-C state
;		Set ignore CTL-C
;		Save/Set keyboard interupt vector (low level)
;	  DOS 5 specific:
;		Set ignore ctl-c signal
;		Put Keyboard in Binary mode [25]
;		Key board key trapping (??)
;
; QB3
; ---
;	Same as above. (WHO/HOW does CTL-C get handled for QB3??)
;
;Entry:
;	None.
;
;Exit:
;	ctlcsave - contains current control c processing state.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;
;****
cProc	B$CNKBDSET,<NEAR>	
cBegin
	XOR	AL,AL		;Get control c function code
	CALLOS	CTRLC		;Read control c processing state.
	MOV	ctlcsave,DL	;save initial control c state.
	XOR	DL,DL		;turn off control C processing
	MOV	AL,1		;Set control c function code
	CALLOS	CTRLC		;turn off control c processing.
cEnd

	SUBTTL	Runtime Console I/O termination routines
	PAGE
;***
;B$CNKBDRESET - Keyboard Termination
;void pascal B$CNKBDRESET()
;
;Purpose:
;	This routine is responsible for resetting the keyboard.
;	It gets called during system termination, RUN, CHAIN,
;	and SHELL.
; BC3
; ---
;	resets keyboard for standard character I/O.
;		reset CTL-C state
;		reset keyboard interupt vector (low level)
;
;Entry:
;	ctlcsave - contains control c processing state upon entry.
;
;Exit:
;	None.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;
;****
cProc	B$CNKBDRESET,<NEAR>	
cBegin
	MOV	DL,ctlcsave	;get initial control c state.
	MOV	AL,1		;Set control c function code
	CALLOS	CTRLC		;reset control c processing.
cEnd

sEnd	CN_TEXT
	PAGE

assumes CS,CN_TEXT
sBegin	CN_TEXT
;***
;B$CNTERM	- One time initialization for Console I/O
;void pascal B$CNTERM()
;
;Purpose:
; BC3
; ---
;	Initializes screen and keyboard for standard character
;	I/O.  B$CNTERM does the following:
;		Saves high level screen dimensions
;		Save initial screen variables (low level)
;	  DOS 3 specific:
;		Save CTL-C state
;		Set ignore CTL-C
;		Save/Set keyboard interupt vector (low level)
;	  DOS 5 specific:
;		Set ignore ctl-c signal
;		Key board key trapping (??)
;
; QB3
; ---
;	Same as above. (WHO/HOW does CTL-C get handled for QB3??)
;
;Entry:
;	None.
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;****
cProc	B$CNTERM,<NEAR> 	
cBegin
	CMP	b$errnum,0	;Has an error occurred?
	JZ	NOPAUSE 	;brif not.
	CALL	FAR PTR B$Pause ;Yes: display message and wait for char.
NOPAUSE:
	CMP	b$Chaining,0	;Are we in the process of chaining?
	JNZ	Chaining	;brif so.
	TEST	b$IOFLAG,SCN_INIT ; have we done any output yet?
	JZ	NoReset		; brif not -- don't reset screen
	CALL	B$RESETSCN	; reset screen to entry time state
NoReset:

	CALL	B$GWTERM	; OEM termination

Chaining:			
	cCall	B$CNKBDRESET	;RESET the keyboard
cEnd

;***
;B$Pause - wait until user hits a key to return.
;
;Purpose:
;	This module is needed on machines that clear the screen when resetting
;	screen mode. The error message would just flash on the screen before
;	being erased in B$CNTERM (which calls OEM's B$GWTERM routine).
;	Also used when QBI compile dialog spawns processes which have
;	errors.  The Hit any key message will be displayed before returning
;	to the user interface, which will redisplay the editting window.
;
;Entry:
;	None.
;
;Exit:
;	None.
;
;Uses:
;	Per convention.
;
;Exceptions:
;	None.
;****
cProc	B$Pause,<PUBLIC,FAR>	
cBegin

	TEST	b$IOFLAG,RED_INP+RED_OUT ; input or output redirected?
	JNZ	PauseExit	; brif so -- do nothing

	MOV	DX,b$CURSOR	; DX = logical cursor for this page
	PUSH	DX		; save it for later
	MOV	AX,b$CurPages	; AX = [visual|active] pages
	PUSH	AX		; save old page values
	CMP	AH,AL		; were active and visual pages the same?
	JE	SamePages	; brif so -- don't read cursor position,
				; since it may be wrong.
	MOV	b$ActPage,AH	; active page = visual page
	CALL	B$GETCSRDATA	; DX = cursor position for this page
SamePages:			
	PUSH	DX		; save cursor for visual page
	CALL	B$LastLine	; DX = b$CURSOR = first column of last line
	CALL	B$CLREOL	; erase last line (cursor left at start)
	MOV	AX,MS_HITTORETURN ;"Hit any key to return to system"
	cCall	B$PUTNUM	;print the message


	CALL	B$KYBINI 	; Erase any typeahead
	CALL	B$TTYIN		; Wait for any key

	CALL	B$LastLine	; DX = b$CURSOR = first column of last line
	CALL	B$CLREOL	; erase last line (cursor left at start)

	POP	DX		; DX = original cursor for visual page
	CALL	B$OFFCSR	; display off cursor at original location
				; on visual page (forces relocation)
	POP	AX		; restore active page to old value
	MOV	b$ActPage,AL	

	POP	DX		; DX = old logical cursor for active page
	CMP	AH,AL		; were active and visual pages the same?

	JNE	NoDisp		; brif not -- don't display function keys
	CALL	B$KEYDSP	; display function keys in active page if
				; on (clears last line and restores cursor)
NoDisp:				
	
	CALL	B$SCNLOC	; update b$CURSOR and display user cursor

PauseExit:			
cEnd
sEnd	CN_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\directry.asm ===
TITLE	DIRECTRY - GW BASIC 2.0 DIRECTORY HANDLING ROUTINES
;***
; DIRECTRY - GW BASIC 2.0 Directory handling routines
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - CHDIR Statement:
;
;      CHDIR pathname
;	 |
;      B$CDIR
;
;
; - MKDIR Statement:
;
;      MKDIR pathname
;	 |
;      B$MDIR
;
;
; - RMDIR Statement:
;
;      RMDIR pathname
;	 |
;      B$RDIR
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

;
;	Code Segments
;
	USESEG	<DK_TEXT>	;Disk I/O component
	USESEG	<NH_TEXT>	; For string deallocation

;
;	Data Segments
;
	USESEG	<_DATA> 	;Pre-initialized data

	INCLUDE seg.inc 	;segment definitions
	INCLUDE files.inc	;get callos macro, fn defs.
	INCLUDE baslibma.inc	
	INCLUDE string.inc	



sBegin	NH_TEXT			
	externNP B$STDALCTMP	; Deallocate temp string
	externNP B$STPUTZ	; Null-terminate string
sEnd	NH_TEXT			


assumes CS,DK_TEXT
sBegin	DK_TEXT

	externNP B$ERR_PNF
	externNP B$ERR_ACD


PAGE
;***
; B$MDIR - make a new directory entry (via DOS call)
; pascal far B$MDIR(psdDirectory)
;
; Input:
;	psdDirectory == a pointer to an sd containing the input string
; Output:
;	NONE
; Modifies:
;	per convention
; Exceptions:
;	May call B$ERR_PNF or B$ERR_ACD
;****
cProc	B$MDIR,<PUBLIC,FAR>
cBegin	<nogen>
	MOV	AH,C_MKDIR	; DOS function code for make-directory
	SKIP	2		; Proceed with processing	
cEnd	<nogen>			; End of B$MDIR

	PAGE
;***
; B$RDIR - remove a directory entry (via DOS call)
; pascal far B$RDIR(psdDirectory)
;
; Input:
;	psdDirectory == a pointer to an sd containing the input string
;
; Output:
;	NONE
; Modifies:
;	per convention
; Exceptions:
;	May call B$ERR_PNF or B$ERR_ACD
;****

cProc	B$RDIR,<PUBLIC,FAR>
cBegin	<nogen>
	MOV	AH,C_RMDIR	; DOS function code for remove-directory
	SKIP	2		; Proceed with processing
cEnd	<nogen>			; End of B$RDIR

	PAGE

;***
; B$CDIR - change current working directory (via a DOS call)
; pascal far B$CDIR(psdDirectory)
;
; Input:
;	psdDirectory == a pointer to an sd containing the input string
; Output:
;	NONE
; Modifies:
;	per convention
; Exceptions:
;	May call B$ERR_PNF or B$ERR_ACD
;****
cProc	B$CDIR,<PUBLIC,FAR>
cBegin	<nogen>
	MOV	AH,C_CHDIR	; AH = DOS function code for change-dir
cEnd	<nogen>			; End of B$CDIR & fall through

	PAGE

;***
;DIRECTORY - Common routine for all the three routines
;Pascal far DIRECTORY(psdDIRECTORY)   /* AH or AX is also input */
;
;ENTRY:
;	psdDIRECTORY = pointer to an sd containing the input string
;	AH = DOS function code for the directory function (DOS 2)
;	AL = Entry index into the dispatch-table for directory function (DOS 5)
;
;EXIT:
;	NONE
;
;Modifies:
;	per convention
;
;Exceptions:
;	May call B$ERR_PNF or B$ERR_ACD
;
;****

cProc	DIRECTORY,<FAR>,<SI,DI> 	
ParmSD	sdDIRECTORY			
cBegin					

	MOV	BX,sdDIRECTORY		; Get the sd of string
	CALL	B$STPUTZ		; null-terminate the string
					; AH preserved from entry
	MOV	DX,[BX+2]		; DS:DX = pathname string address
	CALLOS				; Do the requested function
	JC	DIR_ERROR		; Brif error
	cCALL	B$STDALCTMP		; deallocate temporary string

cEnd					; End of DIRECTORY

DIR_ERROR:				; DOS returned an error
					; Analyze it
	CMP	AL,ERRACD		; Is it Access-Denied?
	JE	ACCESS_DENIED		; Brif so
	JMP	B$ERR_PNF		; default to Path-not-found error
ACCESS_DENIED:				
	JMP	B$ERR_ACD		; Access-Denied error


sEnd	DK_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\dkopen.asm ===
TITLE	DKOPEN - DISK OPEN routines
;***
; DKOPEN - Disk open and other utility routines
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
;	The routines in this module are used while opening files
;	in all modes (disk and device files).
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; general runtime macros

	UseSeg	_BSS
	UseSeg	RT_TEXT
	UseSeg	ER_TEXT
	UseSeg	NH_TEXT 	
	UseSeg	DV_TEXT 	
	UseSeg	_DATA		

	INCLUDE seg.inc 	; Segment definitions

	INCLUDE baslibma.inc
	INCLUDE files.inc
	INCLUDE devdef.inc
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE nhutil.inc	
	INCLUDE string.inc	
	INCLUDE idmac.inc	

	.xall
	.radix	10

;************************************************************************
;
sBegin	_BSS

externB b$FILMOD		
externB b$PATHNAM		
externW b$Buf2			
PATH_LEN EQU b$Buf2		

globalW b$CLOS_HANDLE,0		; file handle for B$TEST_CLOSE to close
globalW b$CLOS_FDB,0		; FDB for B$TEST_CLOSE to close the file
				; and deallocate the FDB.

externB b$LOCKTYPE
externB b$ACCESS

sEnd	_BSS
;
;************************************************************************


;************************************************************************
;
sBegin	ER_TEXT
externNP	B$ERR_AFE	
externNP	B$ERR_BFM	
externNP	B$ERR_FNF
externNP	B$ERR_ACD
externNP	B$ERR_TMF
externNP	B$ERR_IOE
externNP	B$ERR_FAO
externNP	B$ERR_PNF	

sEnd	ER_TEXT
;
;************************************************************************

;************************************************************************
;
sBegin	NH_TEXT 			
	externNP	B$LHALC_CPCT	; compact LH and allocate entry
	externNP	B$LHDALC	; deallocate FDB
	externNP	B$STDALCTMP	
sEnd	NH_TEXT 			

sBegin	DV_TEXT 			
	externNP	B$DOS3CHECK	
	externNP	B$OPENIT	
sEnd	DV_TEXT 			

sBegin	RT_TEXT

externNP	B$GETEXTERR	; Get extended error, if available
externNP	B$CLOSE
externNP	B$LHNXTFIL	
externNP	B$FILESIZE
externNP	B$SeekFromStart 
externNP	B$DISK_SINP	
externNP	B$OpenErr	
;
;************************************************************************

assumes cs,RT_TEXT

	SUBTTL	disk OPEN
	page

;***
;  B$DISKOPEN - DISK device-dependent OPEN routine.
;
;Purpose:
;	This routine does the actual opening of the files.
;	It tries to open the file in the mode specified and
;	if that fails it will then try to reopen the file
;	in some of the other modes. (The reopen does not
;	happen if the first try was for READ_ONLY).
;	It also checks to see if it opened a character
;	device and if so sets the appropriate fields in the
;	FDB to reflect this. If the open is in the append mode
;	it seeks to the end of the file and backs up over the
;	first CTRL Z.
;
;Entry:
;
;	AX = output from B$GET_PATHNAME
;	BX = file number
;	CX = record size
;	DX = file name string descriptor (ignored)
;
;Exit:
;	File opened and FDB filled in OR
;	appropriate error message given.
;
;Uses:
;	AX, BX, CX, DX
;
;****


cProc	B$DISKOPEN,<NEAR,PUBLIC>,<ES,DI>
cBegin

	PUSH	DS		; ES = DS
	POP	ES

;	First, allocate FDB with extra space for all disk files and
;	space for the field buffer for random files.

	INC	CX		; LEN specified?
	LOOP	LEN_SPEC	; brif so -- use specified record length
	MOV	CX,REC_LENGTH	; CX = default random record length
	TEST	b$FILMOD,MD_RND ; random mode?
	JNZ	LEN_SPEC	; brif so -- use random default
	MOV	CX,SEQ_BUF_LEN	; use default sequential buffer length
LEN_SPEC:			
	TEST	b$FILMOD,MD_BIN ; BINARY mode?
	JZ	NOT_BIN		; brif not -- keep specified buffer size
	MOV	CX,1		; buffer size = 1
NOT_BIN:			
	PUSH	CX		; save buffer size
	PUSH	BX		; save file number
	PUSH	AX		; save output from B$GET_PATHNAME
	MOV	DI,OFFSET DGROUP:b$PATHNAM ; DI = pathname address for
				; B$CHKFOPEN
	XOR	SI,SI		; clear SI for B$AnalyzeErr, so it doesn't
				; try to access a non-existing FDB.

;	If the file is not random or sequential input, check if
;	the file has been already opened in BASCOM.  If CF = 1, then
;	give FILE ALREADY OPEN error.

	TEST	b$FILMOD,MD_RND+MD_SQI+MD_BIN ; random or binary or seqin?
	JNZ	DOPEN_NOCHK	;if so, then jump
	cCALL	B$CHKFOPEN	; check if already open -- give
				;  "file already open" error if so
DOPEN_NOCHK:

;	Determine the initial file access for the open.  The accesses
;	attempted are based on the file mode and ACCESS clause type:

;	[b$FILMOD] = MD_SQI (sequential input)
;	    [b$ACCESS] = ACCESS_NONE	read
;	    [b$ACCESS] = ACCESS_READ	read

;	[b$FILMOD] = MD_SQO (sequential output)
;	    [b$ACCESS] = ACCESS_NONE	write
;	    [b$ACCESS] = ACCESS_WRITE	write

;	[b$FILMOD] = MD_RND OR MD_BIN (random or binary)	[13]
;	    [b$ACCESS] = ACCESS_NONE	read/write, write, read
;	    [b$ACCESS] = ACCESS_READ	read
;	    [b$ACCESS] = ACCESS_WRITE	write
;	    [b$ACCESS] = ACCESS_READ_WRITE	read/write

;	[b$FILMOD] = MD_APP (append)
;	    [b$ACCESS] = ACCESS_NONE	read/write, write
;	    [b$ACCESS] = ACCESS_WRITE	write

	XOR	BX,BX		;assume 0 for OPEN read
	CMP	[b$ACCESS],ACCESS_READ ;test if ACCESS READ
	JE	DOPEN_OPEN	;if so, jump to open file
	CMP	b$FILMOD,MD_SQI ; test if input sequential
	JE	DOPEN_OPEN	;if so, jump to open file
	INC	BX		;assume 1 for OPEN write
	CMP	[b$ACCESS],ACCESS_WRITE ;test if ACCESS WRITE
	JE	DOPEN_OPEN	;if so, jump to open file
	CMP	b$FILMOD,MD_SQO ; test if output sequential
	JE	DOPEN_OPEN	;if so, jump to open file
	INC	BX		;otherwise, read/write file
				;  The file is opened with the mode in BX.	It is either
;	opened initially in the mode computed above, or reopened
;	in the next mode determined from the above table after
;	an open failure.

;
;		File
;-----------------------------------------------
;    |	doesn't  |      exists     |  OpenFlag
;    |	exist	 |		   |	in HEX
;-----------------------------------------------
;sqi |	fail	 |	open file  |	01
;sqo |	create	 |	replace    |	12
;rnd |	create	 |	open file  |	11
;-----------------------------------------------
;

DOPEN_OPEN:

	MOV	DI,BX		;save mode for possible reopen
	CALL	DiskOpenHelper	; open file with mode in BX
				; AX = error code if error
				; BX = file handle
	JC	OPEN_FAILED	; brif open failed

;	The OPEN succeeded.  The only error condition that could
;	occur is if a file is to be appended with only a write
;	access.  If this is so, close the file and fake a
;	PATH/FILE ACCESS ERROR.

	CMP	b$FILMOD,MD_APP ; test if append mode
	JNE	JMP_DOPEN_PROCESS ; brif not -- process open
	CMP	DI,1		;test if WRITE access
	JNE	JMP_DOPEN_PROCESS ; brif not -- process open
	CALL	DO_CLOSE	; file is append with write mode and
				;exists cannot be accessed...
	JMP	SHORT ERCACD	; path/file access error

;	The OPEN failed.  If mode was sequential input, either give
;	correct access error (PERMISSION DENIED if sharing conflict
;	or PATH/FILE ACCESS ERROR if directory access conflict) or
;	FILE NOT FOUND.

OPEN_FAILED:			
	CMP	AX,ERRPNF	;test if PATH NOT FOUND error
	JE	ERCPNF		;if so, then report it
	CMP	b$FILMOD,MD_SQI ; test if input sequential
	JNE	DOPEN_NOT_SQI_FAIL ;if not, then jump
	CMP	AX,ERRACD	; test if access error
	JE	DOPEN_ACCESS_ERROR ;if so, jump to process it
ERCFNF:				
	JMP	B$ERR_FNF	;jump to FILE NOT FOUND

ERCPNF:				
	JMP	B$ERR_PNF	; jump to PATH NOT FOUND

DOPEN_NOT_SQI_FAIL:
	CMP	AX,ERRFNF	; test if FILE NOT FOUND
	JNE	DOPEN_NEXT_ACCESS ;else error forces next one
	MOV	DX,OFFSET DGROUP:b$PATHNAM ; address of file pathname
	XOR	CX,CX		;attributes - none
	MOV	AH,C_CREAT	;create file function
	CALLOS			;and make the DOS call
				; AX = error code or handle
	JC	DOPEN_CREATE_ERROR ; if creation error, jump
	XCHG	BX,AX		; get handle in BX
	CALL	DO_CLOSE	; close the file
	MOV	BX,DI		;get the same access type
	CALL	DiskOpenHelper	; and reopen the file
				; AX = error code if CF
				; BX = file handle
	JNC	DOPEN_PROCESS	;jump if success

;	The OPEN failed with the current access.  If an access
;	failure occurred and the OPEN is allowed to retry using
;	another access ([b$ACCESS]=ACCESS_NONE), determine the
;	new access and retry the OPEN.

DOPEN_NEXT_ACCESS:
	CMP	AX,ERRACD	; test if access error
	JNE	DOPEN_NOT_ACCESS_ERROR ;if not, then branch
	CMP	[b$ACCESS],ACCESS_NONE ;is a retry possible?
	JNE	DOPEN_ACCESS_ERROR ;if not, just process error
	TEST	b$FILMOD,MD_RND+MD_BIN ; test for random or binary modes
	JE	DOPEN_TRY_APPEND_RETRY ; if not, then jump
	OR	DI,DI		;is access READ?
	JE	DOPEN_ACCESS_ERROR ;if so, then jump
	MOV	BX,DI		;get access code
	DEC	BX		;r/w->write or write->read
	JMP	DOPEN_OPEN	;retry random OPEN now

JMP_DOPEN_PROCESS:		; Code is too big and ugly for relative
	JMP	SHORT DOPEN_PROCESS ; jumps to DOPEN_PROCESS.

DOPEN_TRY_APPEND_RETRY:
	CMP	b$FILMOD,MD_APP ; test for append mode
	JNE	DOPEN_ACCESS_ERROR ;jump if not
	CMP	DI,2		;test if read/write
	JNE	DOPEN_ACCESS_ERROR ;jump if not
	MOV	BX,1		;make access WRITE
	JMP	DOPEN_OPEN	;retry append OPEN now

;	OPEN failed with error code 5 (carry set).  Use extended error
;	call (if DOS 3 or later) to determine reported error.
;	"PATH/FILE ACCESS ERROR" is reported when failure is due to
;	directory restriction.	"PERMISSION DENIED" is for DOS 2 or
;	OPEN access conflict.

DOPEN_ACCESS_ERROR:
	JMP	B$OpenErr	; give proper error message, with SI <> FDB.
				; (FL_CHAR bit of FD_FLAGS always clear)

;	Error not access-related.

DOPEN_NOT_ACCESS_ERROR:
	CMP	AX,ERRFNF	; error was FILE NOT FOUND?
	JE	ERCFNF		; brif so
	CMP	b$FILMOD,MD_SQO ; interpreter compatability
	JE	ERCTMF		; brif sequential output -- too many files
ERCACD:				
	JMP	B$ERR_ACD

DOPEN_CREATE_ERROR:		
	CMP	AX,ERRACD	; test if access error
	JNE	DOPEN_NOT_ACCESS_ERROR ; if not, then branch
	CALL	B$GETEXTERR	; get extended error after creation
	JC	ERCTMF		; if DOS 2, then give too many files
	CMP	AX,52H		; test if directory entry creation failed
	JNE	ERCACD		; if not, then path/access error

ERCTMF:				
	JMP	B$ERR_TMF	; too many files

;	OPEN has been completed.  Finish details needed for BASCOM.
;	BX = file handle

DOPEN_PROCESS:
	POP	AX		; AX = output from B$GET_PATHNAME
	POP	DX		; DX = file number
	POP	CX		; restore buffer size
	XCHG	DX,BX		; BX = file #, DX = file handle
	PUSH	DX		; save file handle

				; allocate the FDB, and fill some fields
	PUSH	CX		; save buffer size
	ADD	CX,PATH_LEN	; add extra space for pathname
	MOV	DL,255 		; (DL) = width
				; fields
	MOV	AH,255		; (AH) = all file modes legal
	CALL	B$DEVOPN 	; Allocate file block, set up some fields
	FDB_PTR ES,SI,SI	; (ES:)SI = *FDB
	POP	CX		; get back buffer size
	MOV	FileDB.FD_VRECL,CX  ; set record length/buffer size

	LEA	DI,FileDB.FD_BUFFER ; ES:DI = address to put pathname in the
	ADD	DI,CX		;		FDB (after I/O buffer)
	MOV	CX,PATH_LEN	; CX = length of pathname (including null)
	PUSH	SI		; save FDB address
	MOV	SI,OFFSET DGROUP:b$PATHNAM ; DS:SI = pathname address
	REP	MOVSB		; and copy pathname into FDB
	POP	SI		; SI = FDB address
	POP	BX		; BX = file handle

	MOV	FileDB.FD_HANDLE,BX ; save file handle
	OR	FileDB.FD_FLAGS,FL_NEOF ;set flag for no EOF
	mov	al,0
	callos	ioctl		;discover whether character device
	mov	al,dl
	test	al,fl_char	;Is it a device?
	jz	nochar		;Brif not a character device

	AND	AL,FL_CHAR+FL_CONOUT+FL_CONINP ; Clean all bits except
				; FL_CHAR, FL_CONINP, and FL_CONOUT
	OR	FileDB.FD_FLAGS,AL  ;update FDB flags

	mov	al,1
	or	dx,32		; set raw - preserve bits
	mov	dh,0		; Must set high byte to zero !
	CALLOS	IOCTL,ERCIOE	; set raw mode -- I/O error upon failure

				;Don't make CON out RAW if DOS 2.+
	TEST	b$FILMOD,MD_RND+MD_BIN ; random or binary char device?
	JNZ	NOCHAR		; brif so -- these files have a buffer size
	MOV	FileDB.FD_VRECL,1 ;yes, set block size to one
	CMP	b$FILMOD,MD_APP ; if append, convert to MD_SQO
	jne	nochar
	MOV	b$FILMOD,MD_SQO 

nochar:
	MOV	AL,b$FILMOD	
	mov	FileDB.FD_MODE,al ;set mode
	TEST	FileDB.FD_FLAGS,FL_CHAR ; char device?
	JNZ	NoTruncate	; brif so -- don't truncate file
	TEST	AL,MD_SQO	; output?
	JZ	NoTruncate	; brif not -- don't truncate file
	OR	FileDB.FD_FLAGS,FL_TRUNC ; truncate file upon first write
NoTruncate:			
	cmp	al,MD_APP	; is it append?
	JNE	OpenExit	; brif not -- exit
	cCall	B$FILESIZE	; seek to end of file [DX|AX] = file size/pos
	MOV	CX,AX		; [DX|CX] = file size
	OR	AX,DX		; empty file?
	JZ	EmptyApp	; brif so -- don't seek back

;	An empty file opened by BASCOM10 has a 1A (^Z) at the begining of
;	a block of 128 characters which constitutes the file. Before this
;	change the SEEK routine ]was seeking to one past the end of 128
;	characters thereby retaining a ^Z at the beginning.  The new
;	algorithm first seeks to the LAST BLOCK of 128 characters and
;	then searches for the first available ^Z or end of file as the
;	case may be and starts appending from that point.

	SUB	CX,128		; get the last block of 128
	SBB	DX,0		; characters
	JNB	appfi1		;brif file is more than 128 chars
	XOR	CX,CX		; set postion to zero
	XOR	DX,DX		
appfi1:				; [DX|CX] = new position
	CALL	B$SeekFromStart ; position file pointer ([DX|AX] = result)
	XCHG	AX,CX		; [DX|CX] = file position

	MOV	b$CLOS_FDB,SI	; deallocate FDB and close file if error
	CALL	B$DISK_SINP	; read a char.  Destroys AX.
	MOV	b$CLOS_FDB,0	; finished with critical section

	JB	appfi2		; brif got a ctrl z
	ADD	CX,1		; check the next guy
	ADC	DX,0		
	JMP	SHORT appfi1	; loop around

appfi2:				; [DX|CX] = last position
	CALL	B$SeekFromStart ; back up over CTRL Z ([DX|AX] = result)
	XCHG	AX,CX		; [DX|CX] = current position

EmptyApp:
	MOV	FileDB.FD_BUFCNT,0 ; nothing in buffer
				; No need to clear FD_INBUFCNT, since it
				; will never be referenced again.
; commented out this code and associated code in DISK_LOC because LOC
; could return negative values if we SEEK to before where we started.
;	MOV	FileDB.FD_LOGREC,CX ; save starting position for append files
;	MOV	FileDB.FD_HIGHLR,DX 
OpenExit: 			; done
cEnd

ERCIOE: 				
	CALL	B$LHDALC	; deallocate FDB
	JMP	B$ERR_IOE	; device I/O error

;*** 
; DO_CLOSE -- close a file.
;
;Purpose:
;	Closes a file whose handle is in BX.  Added with [15] to save code.
;	Closes file but does not dealocate FDB upon INT 24 error.
;Entry:
;	BX = file handle
;Exit:
;	None
;Uses:
;	None
;Preserves:
;
;Exceptions:
;	None
;
;******************************************************************************

cProc	DO_CLOSE,<NEAR>
cBegin
	MOV	b$CLOS_HANDLE,BX ; close file, no FDB dealloc on INT24 error
	CALL	B$CLOSE		; close the file
	MOV	b$CLOS_HANDLE,0	; finished with critical section
cEnd


;*** 
; DiskOpenHelper -- open a file.
;
;Purpose:
;	Actually open a file whose pathname is in b$PATHNAM.
;
;Entry:
;	b$PATHNAM = pathname of file to open.
;	BX	=  mode of open
;	CX	= special open flag if OS/2
;
;Exit:
;	AX	= error code if error, 0 otherwise
;	BX	= file descriptor (if no error)
;	IF	NOT OM_DOS5
;		Carry set if error; clear otherwise.
;Uses:
;	DX
;Preserves:
;	None
;Exceptions:
;	None
;
;******************************************************************************

cProc	DiskOpenHelper,<NEAR>
cBegin

	MOV	DX,OFFSET DGROUP:b$PATHNAM ; address of pathname
	OR	BL,[b$LOCKTYPE];add access code for DOS 3.0

	CALLOS	OPEN,,,,DX,BX
	JC	OpenRet		; brif error
	XCHG	BX,AX		; BX = file descriptor
	XOR	AX,AX		; AX = 0 (no error -- clears carry)
OpenRet:
cEnd

	PAGE
;***
;B$CHKFOPEN -- check if file already open.
;
;Purpose:
;	Re-written as part of [11].
;
;	Checks for file already open by searching all FDBs, and comparing
;	their pathname fields, if they exist.
;
;Entry:
;	DI = pointer to standard processed pathname (from B$GET_PATHNAME)
;	ES = DS (only for NOT FV_FARFDB case)
;
;Exit:
;	None
;Uses:
;	AX,BX
;Exceptions:
;	B$ERR_FAO -- file already open
;****

cProc	B$CHKFOPEN,<NEAR,PUBLIC>,<SI>
cBegin
	XOR	SI,SI		;prepare to get first FDB

CHKFO_LOOP:
	CALL	B$LHNXTFIL	; point to next FDB in SI
	JZ	CHKFO_DONE	;if no more, then jump to exit
	FDB_PTR ES,SI,SI	; (ES:)SI = *FDB

;check pathname field of FDB pointed to by [SI] for match with pathname in [DI]
	CMP	FileDB.FD_DEVICE,0 ;does this FDB have a pathname field?
	JNE	CHKFO_LOOP	;brif not -- pathnames don't match
	LEA	BX,FileDB.FD_BUFFER ;BX = pathname2 address
	ADD	BX,FileDB.FD_VRECL  

	XCHG	BX,SI		;SI = pathname2 address
	PUSH	DI		;save pathname1 address

CMP_LOOP:			;compare the two pathname strings for equality
	LODSB			;load byte from filename2 into AL
	SCASB			;compare bytes
	JNZ	NEXT_FDB	;brif not equal -- try next FDB
	OR	AL,AL		;last byte?
	JNZ	CMP_LOOP	;brif not -- check another character
	JMP	B$ERR_FAO	; names matched. File already open error

NEXT_FDB:			;ZF if match, NZ if not a match
	POP	DI		;restore pathname1 address
	XCHG	BX,SI		;restore SI to FDB pointer
	JMP	SHORT CHKFO_LOOP ;try next FDB

CHKFO_DONE:
cEnd				;End of B$CHKFOPEN

;*** 
; B$OPEN_DEV and B$DEVOPN -- Special device open common routines.
;	 Re-wrote as part of [32].
;
;Purpose:
;	Allocates an FDB for a device.
;	B$DEVOPN is called when a buffer is to be allocated (if a non-zero
;	buffer size is specified), while B$OPEN_DEV is called when no buffer
;	is to be allocated (sets CX to 0)
;
;Entry:
;	[AL] = file device
;	[AH] = valid file modes
;	[CX] = size of buffer(s) (not including basic FDB size)
;	[DL] = file width
;	[BX] = file number
;
;Exit:
;	[SI] = pointer/handle to allocated FDB.
;	FD_DEVICE, FD_WIDTH, and FD_MODE fields of FDB initialized.
;
;Uses:
;
;Preserves:
;	AX,BX,DX (B$DEVOPN preserves CX)
;
;Exceptions:
;	B$ERR_BFM -- Bad file mode
;
;******************************************************************************


cProc	B$OPEN_DEV,<PUBLIC,NEAR> 
cBegin				
	XOR	CX,CX		; specify no buffer to be allocated
cEnd	nogen			; fall through into B$DEVOPN

cProc	B$DEVOPN,<PUBLIC,NEAR>,<CX> 
cBegin				

	TEST	[b$FILMOD],AH	;Check for valid file mode
	JZ	ercbfm1 	;  Bad file mode

	JCXZ	NO_BUFFER	;brif buffer not requested
	ADD	CX,FDB_EXTRA	;add in space for extra FDB fields
NO_BUFFER:
	XCHG	BX,CX		;put length in BX, file number in CX
	ADD	BX,FDB_SIZE	;set size of data block needed
	PUSH	DX		; save file width
	MOV	DL,LH_FILE	;set type of entry to allocate
	CALL	B$LHALC_CPCT	; compact local heap, and allocate FDB
	POP	DX		;restore file width
	XCHG	BX,CX		;[BX] = file number
	MOV	CL,b$FILMOD	;get file mode of open
	MOV	FileDB.FD_MODE,CL ;and save it in the FDB

	MOV	FileDB.FD_DEVICE,AL ;set file device
	MOV	FileDB.FD_WIDTH,DL  ;set file width
cEnd				


ercbfm1: JMP	B$ERR_BFM	;Bad file mode

	SUBTTL	open interface -- B$OPEN & B$OOPN
	page
;***
;B$OPEN -- open a disk file using new syntax
;void B$OPEN(sd *psdName,I2 channel,I2 cbRecord,U2 ModeAccessLock)
;
;Purpose:
;	This interface is for opening a file using the syntax as follows:
;
;	OPEN "filespec" [FOR mode] [ACCESS access] [locking] AS [#] filenum
;								    [LEN=recl]
;	where	mode	={INPUT, OUTPUT, APPEND, RANDOM},
;		access	={READ, WRITE, READ WRITE}
;		locking ={SHARED, LOCK {READ | WRITE | READ WRITE} }.
;	If FOR clause is omitted, the default file mode is random.
;
;	In BASCOM 2.0, multi-interfaces are used.  The usage is as follows:
;
;	OPEN "filespec" [FOR mode] [sharing] AS [#]filenum [LEN=record len]
;		|	    |		|	    |		|
;		|	  $DKO	      $DKA	    |		|   $DKM
;		|___________________________________|___________|_____|
;
;	Where $DKO & $DKA set flags and do some checks, and $DKM dispatchs
;	to the open routine.
;
;	In BASCOM 3.0, a single interface is used, B$OPEN, which has all
;	opening information in the stack when entering.  The order of
;	parameters are different from the one above.  The correct order is
;	defined in "Entry" section.
;
;	When entering from the compiler, the value of access is different
;	from the actual needs, so that the modification is necessary.  The
;	reason for making the value different is to detect more easily the
;	legal use of access & locking clauses (network features).
;
;	sdName/*psdName	sd for file name
;
;	channel 	1-255		valid
;			0,256-65535	illegal function call
;
;	cbRecord	0		illegal function call
;			1-32767 	valid
;			32767-65534	illegal function call
;			65535		default (-1)
;
;	* Note: LEN=0 in the statement now gives 'illegal function call'
;
;	ModeAccessLock (the following input values are adjusted to
;		    correspond to those used in the runtime)
;
;	    mode	MD_SQI		=1h	input
;			MD_SQO		=2h	output
;			MD_RND		=4h	random
;			MD_DEFAULT	=4h	default (to random)
;			MD_APP		=8h	append
;			MD_BIN		=20h	binary		[29]
;
;	    access	ACCESS_DEFAULT	=  0h	no access clause
;			ACCESS_READ	=100h	access read
;			ACCESS_WRITE	=200h	access write
;			ACCESS_BOTH	=300h	access read write
;
;	* the actual access value needed by DOS func. call for opening are
;	  0, 1 & 2 for access read, access write and access read write
;	  respectively.
;
;	    lock
;			LOCK_COMPATIBLE =0000h	compatible mode
;			LOCK_DEFAULT	=0000h	no lock clause
;			LOCK_BOTH	=1000h	lock read write
;			LOCK_WRITE	=2000h	lock write
;			LOCK_READ	=3000h	lock read
;			LOCK_SHARED	=4000h	shared (lock none)
;
;	Symbols listed above will be available in a runtime include file
;	called "runtime.inc".
;
;	Algorithm -- Pseudo C code
;
;	B$OPEN(file_name,file_num,record_length,ModeAccessLock)
;	sd	*file_name
;	int	file_num,record_length
;	ushort	ModeAccessLock
;	{
;	    b$ACCESS = ModeAccessLock >> 8 & 0x0F;	/* save access */
;	    b$LOCKTYPE = ModeAccessLock >> 8 & 0xF0;	/* save lock */
;	    if (access || lock) 	/* has access or locking clause ? */
;		if DOSVER < 3.0 	/* dos version has to be above 3.0 */
;		    error("illegal function call")
;	    openit(AX_open_mode,BX_file_num,CX_rec_length,DX_sd_filename)
;	}
;Entry:
;	Parameters were pushed in the stack.
;	sd	sdName		(file name)
;	int	Channel 	(file number)
;	int	cbRecord	(record length)
;	ushort	ModeAccessLock	(file mode, access right, locking status)
;Exit:
;	b$PTRFIL is reset
;Uses:
;	none
;Exceptions:
;	(1) file name error	-- Bad file name (B$ERR_BFN)
;	(2) access & locking	-- Illegal function call (B$ERR_AFE)
;				-- Path/file access error
;				-- Permission denied
;	(3) file number 	-- illegal file number (B$ERR_INF)
;	(4) general		-- File already open (B$ERR_FAO)
;				-- File not found (B$ERR_FAO)
;*******************************************************************************

cProc	B$OPEN,<PUBLIC,FAR>
	ParmSD	sdName		; sd to filename
	ParmW	Channel 	;I2, file #
	ParmW	cbRecord	;I2, record len
	ParmW	ModeAccessLock	;U2, file mode, access method, sharing status
cBegin
	MOV	AX,ModeAccessLock	; get lock/access/mode info
	MOV	BL,AH		;get the lock type
	AND	BL,0F0H 	;isolate lock from access
	AND	AH,0FH		;isolate access from lock
	MOV	[b$ACCESS],AH	;save access
	MOV	[b$LOCKTYPE],BL	; save it
	OR	AH,BL		;has access clause or locking clause ?
	JZ	DISPATCH	;Brif not, go dispatch
	cCall	B$DOS3CHECK	;must be 3.0 or above
	JB	ERCAFE		;Brif not, give advanced feature call
DISPATCH:
	XOR	AH,AH		;isolate mode from lock/access
	MOV	BX,Channel	;file number in BX
	MOV	CX,cbRecord	;record length in CX
	GetpSD	DX,sdName	; [DX] = psdName
	cCall	B$OPENIT	;dispatch to actual open routine
cEnd				;end of B$OPEN

ERCAFE: JMP	B$ERR_AFE	;give advanced feature error

	page
;***
;B$OOPN -- old open form
;void B$OOPN(U2 mode, I2 channel, SD sdName, I2 cbRecord)
;
;Purpose:
;	Simular to B$OPEN, B$OOPN is the single interface for old open form.
;	(refer to the procedure head comments of B$OPEN for detail)
;
;	In BASCOM 2.0, the mode passed in is a *sd to the mode string, whereas
;	in BASCOM 3.0, the mode passed in is an U2, which is simular to B$OPEN.
;
;	Algorithm -- pseudo C code
;
;	B$OOPN(psdMode, channel, sdName, cbRecord)
;	ushort	mode
;	int	channel,cbRecord
;	SD	sdName
;	{
;	    b$ACCESS=b$LOCKTYPE=0;	/* no access or locking clause */
;
;	    substitute mode of "I" into MD_SQI
;	    substitute mode of "O" into MD_SQO
;	    substitute mode of "R" into MD_RND
;	    substitute mode of "A" into MD_APP
;	    substitute mode of "B" into MD_BIN;		[29]
;
;	    openit(AX_open_mode,BX_file_num,CX_cbRecord,DX_sd_filename)
;	}
;Entry:
;	Parameters were pushed in stack.
;	SD	sdMode		(file mode)
;	int	Channel 	(file number)
;	SD	sdName		(file name)
;	int	cbRecord	(record length)
;Exit:
;	b$PTRFIL is reset
;Uses:
;	per convention
;Exceptions:
;	(1) file name error	-- Bad file name (B$ERR_BFN)
;	(2) access & locking	-- Illegal function call (B$ERR_AFE)
;				-- Path/file access error
;				-- Permission denied
;	(3) file number 	-- illegal file number (B$ERR_INF)
;	(4) general		-- File already open (B$ERR_FAO)
;				-- File not found (B$ERR_FAO)
;*******************************************************************************

cProc	B$OOPN,<PUBLIC,FAR>

	ParmSD	sdMode		:[33] sd, file mode
	ParmW	Channel 	;I2, file number
	ParmSD	sdName		:sd, file name
	ParmW	cbRecord	;I2, record length
cBegin
	MOV	[b$ACCESS],ACCESS_DEFAULT	;default compatible mode
	MOV	[b$LOCKTYPE],LOCK_DEFAULT	; default no locking clause
	GetpSD	BX,sdMode	; DX = *sd of file mode
	MOV	CX,[BX] 	;get the length
	JCXZ	ERCBFM1 	;Brif length = 0 -- "bad file mode"
	PUSH	BX		;save sd
	MOV	BX,2[BX]	;get the pointer to the first character
	MOV	BL,BYTE PTR [BX];BL has the character
	AND	BL,0DFH 	;convert lower case to upper case
	MOV	AX,MD_SQI	; MD_SQI = 1
	CMP	BL,"I"		;is input ?
	JZ	ModeSet 	;Brif yes
	INC	AX		; MD_SQO = 2
	CMP	BL,"O"		;is output ?
	JZ	ModeSet 	;Brif yes
	MOV	AL,MD_RND	; MD_RND = 4
	CMP	BL,"R"		;is random ?
	JZ	ModeSet 	;Brif yes
	MOV	AL,MD_APP	; MD_APP = 8
	CMP	BL,"A"		;is append ?
	JZ	ModeSet 	; Brif yes
	CMP	BL,"B"		; is binary ?
	JNZ	ERCBFM1 	;Brif not, give "Bad file mode"
	MOV	AL,MD_BIN	; MD_BIN = 20H
ModeSet:
	POP	BX		;recover sd
	cCall	B$STDALCTMP	;dealloc if temp sd
	MOV	BX,Channel	;file number in BX
	MOV	CX,cbRecord	;record length in CX
	GetpSD	DX,sdName	; DX = *sd of file name
	cCall	B$OPENIT	;dispatch to actual open routine
cEnd				;end of B$OOPN

sEnd	RT_TEXT

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\dkinit.asm ===
TITLE	DKINIT.ASM - Disk I/O Initialization/Termination module
;***
;DKINIT.ASM - Disk I/O	initialization/termination module
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This module contains Disk I/O initialization and termination
;	support for the BASIC 3.0 runtime.  Most of this initialization
;	and termination is also necessary for programs which use device
;	I/O without using disk I/O.  This module will be present in a
;	user's program when a program contains statements which need
;	disk OR device I/O.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;
;	Code Segments
;
	USESEG	<INIT_CODE>	;Initialization
	USESEG	<DV_TEXT>	;Device I/O
	USESEG	<DK_TEXT>	;Disk I/O

;
;	Data Segments
;
	USESEG	<_BSS>		;runtime data (uninitialized)
	USESEG	<_DATA> 	;runtime data (initialized)
	USESEG	<XIB>		; initializer start segment
	USESEG	<XI>		;initializer segment
	USESEG	<XIE>		; initializer end segment

	INCLUDE seg.inc
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE nhutil.inc
	INCLUDE rtps.inc

	INCLUDE compvect.inc	;component vectors

	INITIALIZER	B$xDKINI	;put B$xDKINI in initializer list.

	SUBTTL	Code Externals
	PAGE

	externFP	B$PEOS

sBegin	DV_TEXT
	externNP	B$NearRet	;for dispatch vectors in compvect.inc
	PUBLIC	b$dkused		;This public is defined here and
b$dkused equ 0				;  referenced in dkutil so that
					;  dkinit is pulled in when appropriate
	externNP	B$CLOSF		;closes all open files
	externFP	B$IOINI		;installs int handlers
	externNP	B$IOCLOS	;resets int handlers
	externNP	B$TEST_CLOSE	;test if in CLOSE at INT24 time

sEnd	DV_TEXT

sBegin	DK_TEXT
	externNP	B$FLUSH
sEnd	DK_TEXT

	SUBTTL	Runtime data definitions for BASIC Disk I/O
	PAGE

sBegin	_DATA
;
;	external data
;
	externW b$run_disp	; RUN time initialization dispatch table
	externW b$clrt_disp	; CLEAR statement support dispatch table
	externW b$shli_disp	; Shell initialization dispatch table
	externW b$shlt_disp	; Shell termination dispatch table
	externW b$pTEST_CLOSE	; conditional vector to B$TEST_CLOSE
	externW b$end_disp	; END time termination dispatch table
	externW b$err_disp	; error dispatch table
	externW b$pFLUSH	; conditional vector to B$FLUSH
	externB	b$FInput	
	InpTTY	= 0		; possible values of b$FInput
	InpDsk	= 1		
	InpDefault = 0FFh	
sEnd	_DATA

	SUBTTL	Runtime Disk I/O  Initialization
	PAGE
assumes CS,INIT_CODE
sBegin	INIT_CODE

;***
;B$xDKINI - Disk I/O  initializer
;PLM B$xDKINI()
;
;Purpose:
;	Initializer for Disk I/O  component.  This routine is called
;	by the Crt0 startup before _main is called.  It will update the
;	indirect dispatch tables for the Disk I/O  routines.  This
;	insures that the only time that Disk I/O  is accessed is when
;	this module is linked into the user program.
;
;Entry:
;	None.
;
;Exit:
;	Appropriate dispatch vectors filled.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xDKINI,<FAR>
cBegin
;
;	update "RUN" time initialization dispatch address to B$CLOSF	
;
	MOV	WORD PTR [b$run_disp].DK_RVEC,DV_TEXTOFFSET B$CLOSF	
;
;	update CLEAR statement dispatch address to B$CLOSF		
;
	MOV	WORD PTR [b$clrt_disp].DK_CLTVEC,DV_TEXTOFFSET B$CLOSF	
;
;	update END statement dispatch address to B$CLOSF		
;
	MOV	WORD PTR [b$end_disp].DK_EVEC,DK_TEXTOFFSET B$CLOSF	

;
;	update SHELL statement initialization dispatch address to B$IOINI   
;
	MOV	WORD PTR [b$shli_disp].DK_SIVEC,DK_TEXTOFFSET B$IOINI	
;
;	update SHELL statement termination dispatch address to B$IOCLOS 
;
	MOV	WORD PTR [b$shlt_disp].DK_STVEC,DK_TEXTOFFSET B$IOCLOS	

;
;	update error dispatch address to B$DKERR
;
	MOV	WORD PTR [b$err_disp].DK_ERVEC,DK_TEXTOFFSET B$DKERR	

;	initialize granularity dispatchers.

	MOV	b$pFLUSH, DK_TEXTOFFSET B$FLUSH ; Set vector to point to
						;	  real routine
	MOV	b$pTEST_CLOSE, DK_TEXTOFFSET B$TEST_CLOSE ; Set vector to
							; real routine
cEnd
sEnd	INIT_CODE

assumes CS,DK_TEXT
sBegin	DK_TEXT

;***
;B$DKERR
;Purpose:
;	Error processing for DK component.
;	Added with [3].
;
;Entry:
;
;Exit:
;
;Uses:
;
;Exceptions:
;
;****


cProc	B$DKERR,<NEAR>
cBegin
	or	b$FInput,InpDsk	; keep B$PEOS from blowing away stack by
				; mapping InpTTY to InpDsk.
	cCALL	B$PEOS		;process print end-of-stmt
cEnd

sEnd	DK_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\dbtrace.asm ===
TITLE	DBTRACE - 8086 Basic Compiler Debug and Trace Routines
;***
; DBTRACE - 8086 Basic Compiler Debug and Trace Routines
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Debug trace routines for use with the /D switch in the compiler.
;
; BASIC Syntax mapping to included runtime entry points:
;
; - Array References - Bounds check generated when /D (debug) in effect:
;
;    Example:
;
;      a$(4,5) = "foo"
;      -------
;	  |
;	$AEDA
;
; - TROFF Statement:
;
;	TROFF
;	  |
;      B$TROF
;
; - TRON Statement:
;
;	TRON
;	  |
;      B$TRON
;
;******************************************************************************
	INCLUDE switch.inc	;Rutime switch file
	INCLUDE rmacros.inc	;General runtime macros

	USESEG	INIT_CODE	;Initialization
	useSeg	ER_TEXT 	
	USESEG	DB_TEXT 	;User Debug component
	USESEG	DV_TEXT 	
	USESEG	_DATA		;Initialized Data
	USESEG	_BSS		;Uninitialized Data
	USESEG	<XIB>		; XIB and XIE must bracket XI!
	USESEG	XI		;initializer segment
	USESEG	<XIE>		

	INCLUDE seg.inc 	;Segment definitions

	INCLUDE compvect.inc	;component vectors
	INCLUDE messages.inc	;Text message number definitions

	INCLUDE dc.inc
	INCLUDE event.inc
	INCLUDE addr.inc	;module header definitions
	INCLUDE const.inc	; bit flag definitions

	INITIALIZER	B$xDBINI	;put B$xDBINI in initializer list

sBegin	_DATA			

	externW b$ini_disp	;One time initialization dispatch table

	externW	b$IPOLKEY	; vector for B$POLKEY for /O granularity.
	externW	b$pInitKeys1	; vector for B$InitKeys1 for /O granularity.
	externB	b$IOFLAG	; Misc. IO flags.
	externB	b$CtrlFlags	; contains trace on bit
	externB	b$EventFlags	; misc event flags

sEnd	_DATA			

sBegin	_BSS			

	externW	b$userflags	;user specified compile flags

sEnd	_BSS			

sBegin	DV_TEXT 		
	externNP B$NearRet	;for disp vectors in compvect.inc
sEnd	DV_TEXT 		


sBegin	DB_TEXT 		
	externNP B$$WCHT
	externNP B$RDKYBD
	externNP B$BREAK_CHK

sEnd	DB_TEXT 		

sBegin	ER_TEXT 		

	externNP B$ERR_INT	
	externNP B$PUTUI	; Type an unsigned integer to console.

sEnd	ER_TEXT 		



	SUBTTL	Runtime User Debugging Initialization
	PAGE
assumes CS,INIT_CODE		; from here to sEnd INIT_CODE
sBegin	INIT_CODE

;***
;B$xDBINI - User Debug initializer
;void pascal B$xDBINI()
;
;Purpose:
;	Initializer for User Debugging(/D) component.  This routine is called
;	by the Crt0 startup before _main is called.  It will update the
;	indirect dispatch tables for the user debug routines.  This
;	insures that the only time that user debug is accessed is when
;	this module is linked into the user program.
;
;Entry:
;	None.
;
;Exit:
;	b$ini_disp.DB_IVEC	- contains pointer to B$DBINI
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xDBINI,<FAR>
cBegin
;
;	update "ONE" time initialization dispatch address to B$DBINI
;
	MOV	WORD PTR [b$ini_disp].DB_IVEC,DB_TEXTOFFSET B$DBINI
cEnd
sEnd	INIT_CODE		; from here to previous sBegin
	PAGE

sBegin	DB_TEXT 		

	assumes CS,DB_TEXT	

;***
; B$LINA - Print trace message if trace flag is set
;
; Purpose:
;	Runtime Entry Point, if /D in effect.
;	Called at the start of each statement when /D in effect, to print
;	'[n]' where n is the line number of the statement, iff the trace
;	flag is set. Also checks (first) for ^break.
; Input:
;	NONE
; Output:
;	NONE
; Modifies:
;	F
;****

cProc	B$LINA,<PUBLIC,FAR,FORCEFRAME> 
cBegin
	call	B$BREAK_CHK	; won't return if ^break occured
cEnd				


;***
; B$DBINI - start trapping for Printer Echo, Pause key, & ^Break.
;
; Purpose:
;	Runtime Entry Point.
; Input:
;	NONE
; Output:
;	NONE
; Modifies:
;	ALL
;****
cProc	B$DBINI,<NEAR,PUBLIC>,<SI>	
cBegin				

	mov	[b$IPOLKEY],offset $dpolkey ; may be changed by B$InitKeys1

	MOV	AL,ENABLE_TRAP	
	CALL	[b$pInitKeys1]	; initialize key trapping if present
	OR	b$CtrlFlags,DSwitch ; indicate /d present after call
NoInit: 			
cEnd				

Dpolkey proc	near
;***
; $DPOLKEY -  dummy polkey routine
;
; Purpose:
;	Same as real POLKEY except function keys are ignored. Used when /D
;	is set but not /V
;Entry:     none
;Exit:	    none
;Modifies:  none
;****

$Dpolkey:			;this routine was completely
	push	ax		;rewritten - mostly taken from
	push	bx		;the interpreter
Pollop:
	xor	ax,ax		;Read trapped keys function code
	call	B$RDKYBD 	;OEM dependent key trap routine
	dec	bx
	jz	errint		;Fn, cursor, or user key -- error
	inc	bx
	jz	polkyx		;No key was trapped
	inc	bx
	jz	wasctc		;^C / <break> function
	inc	bx
	jz	wascts		;^S / <pause> function
	inc	bx
	jnz	pollop		;Not <print-screen> func. - ignore, poll
				;next

Wasctp: 			;<printer echo> function
	XOR	b$IOFLAG,LPR_ECHO ; Toggle the printer echo flag
	jmp	short pollop	;Key found, so there may be more

Wascts: 			;^S / <pause> function
	XOR	b$EventFlags,PAUSEF ; Toggle the pause flag
	jmp	short pollop	;Key found, so there may be more

Wasctc: 			;flag ^Break found
	OR	b$EventFlags,CNTLC	; ^Break is reported last so
	AND	b$EventFlags,NOT PAUSEF	; turn off pause and exit

Polkyx:
	TEST	b$EventFlags,PAUSEF ; Test for pause processing
	jnz	pollop		;Pause in process, wait for "unpause"
poldon:
	pop	bx
	pop	ax
	ret

errint: jmp	B$ERR_INT	

dpolkey endp


;***
; B$TRON - Set trace flag
;
; Purpose:
;	Runtime Entry Point, if /D in effect.
;	Set trace flag.
; Input:
;	NONE
; Output:
;	bit traceon of b$CtrlFlags is set
; Modifies:
;	NONE
;****
cProc	B$TRON,<PUBLIC,FAR>	
cBegin				
cEnd

;***
; B$TROF - Clear trace flag
;
; Purpose:
;	Runtime Entry Point, if /D in effect.
;	Clear trace flag.
; Input:
;	NONE
; Output:
;	bit traceon of b$CtrlFlags is cleared
; Modifies:
;	NONE
;****
cProc	B$TROF,<PUBLIC,FAR>	
cBegin				
cEnd				

;
;Routine recreated with [27] for backward compatibility with old QLIBS.
;
;***
;B$TYPUI - Write an unsigned 16-bit integer to console via print code
;
;Purpose:
;	Write AX as a 16-bit unsigned integer for linenumbers. Note that
;	this routine can not be put with B$PUTUI as this routine will
;	always pull in PRINT code because of B$$WCHT.
;
;Entry:
;	[AX] = integer to be printed
;
;Exit:
;	None.
;
;Uses:
;	Per Convention
;
;Exceptions:
;	None.
;****
	PUBLIC	B$TYPUI				
cProc	B$TYPUI,<NEAR>				
cBegin
	MOV	CX,DB_TEXTOFFSET B$$WCHT	;Use Print routines
	CALL	B$PUTUI				;And display the number
cEnd

sEnd	DB_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\dkio.asm ===
TITLE	DKIO - Disk I/O Drivers
	page	56,132
;***
; DKIO - Disk I/O Drivers
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module came from iodisk.asm.  Iodisk.asm has been split into
;	three files, -- diskio.asm, dkopen.asm and fileio.asm.	This file
;	contains all dispatching routines (drivers) for a disk or a device
;	I/O, except disk open.	Disk open is in dkopen.asm.  Fileio.asm
;	contains the file I/O interfaces, for example, LOCK, UNlOCK, etc.
;
;	The following is the disk dispatch table.  Each entry is the addr.
;	of the actual working routine.	The routine name is composed by the
;	prefix "DISK_" and the function name, e.g., DISK_EOF is the routine
;	name for EOF function.
;
;	B$D_DISK:
;		 ________
;		|	 |
;		| EOF	 |
;		|--------|
;		| LOC	 |
;		|--------|
;		| LOF	 |
;		|--------|
;		| CLOSE  | = $DISK_CLOSE in gwini.asm
;		|--------|
;		| WIDTH  |
;		|--------|
;		| RANDIO |
;		|--------|
;		| OPEN	 | = B$DISKOPEN in dkopen.asm
;		|--------|
;		| BAKC	 |
;		|--------|
;		| SINP	 |
;		|--------|
;		| SOUT	 |
;		|--------|
;		| GPOS	 |
;		|--------|
;		| GWID	 |
;		|--------|
;		| DWID   |		
;		|--------|
;		| BLKIN  |
;		|--------|
;		| BLKOUT |
;		|________|
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

;Code segmetns
	useSeg	DK_TEXT
	useSeg	ER_TEXT
	useSeg	NH_TEXT
	useSeg	RT_TEXT
;Data segments
	useSeg	_DATA
	useSeg	_BSS

	INCLUDE seg.inc
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE ascii.inc
	INCLUDE idmac.inc	
	INCLUDE rtps.inc	; constants shared with QBI

	SUBTTL	data definitions
	page
sBegin	_DATA
	externW b$CLOS_FDB	
	externW B$ENTRY_BUFCNT	
sEnd;_DATA

sBegin	_BSS

externD b$RECPTR		; pointer to random record

	externW b$PTRFIL	
sEnd;_BSS

	SUBTTL	code externals
	page
sBegin	DK_TEXT
	externNP	B$GETEXTERR ;defined in GWIO.ASM
	externNP	B$DISKOPEN
sEnd;DK_TEXT

sBegin	RT_TEXT
	externNP	B$TEST_CLOSE	; close file and deallocate FDB
	externNP	B$Mul32x16	; 32 by 16 bit multiply
sEnd;RT_TEXT

sBegin	NH_TEXT
	externNP	B$LHDALC_CPCT	
	externNP	B$LHFDBLOC	
sEnd;NH_TEXT

sBegin	ER_TEXT
	externNP	B$ERR_BFM
	externNP	B$ERR_BRN
	externNP	B$ERR_DFL
	externNP	B$ERR_FOV
	externNP	B$ERR_IFN
	externNP	B$ERR_IOE
	externNP	B$ERR_ACD
	externNP	B$ERR_FWP
	externNP	B$ERR_FC	
sEnd;ER_TEXT


	assumes CS,DK_TEXT
sBegin	DK_TEXT
	SUBTTL	disk dispatch table
	page

DSPMAC	MACRO	func
	DW	DISK_&func
	ENDM

labelNP <PUBLIC,B$D_DISK>
	DSPNAM

	SUBTTL	disk dispatch routines
	SUBTTL	backup one character
	page
;***
;B$DISK_BAKC -- bakcup one character
;B$IDISK_BAKC -- Far (QB3) interface to backup one character
;
;Purpose:
;	Backup one character for a disk file.  Only valid for input files.
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	file position is updated.
;Uses:
;	none
;Preserves: (optional)
;	all, except flags
;Exceptions:
;	none
;*******************************************************************************

labelNP  DISK_BAKC			

cProc	B$DISK_BAKC,<NEAR,PUBLIC>	

cBegin
	DEC	FileDB.FD_BUFCNT	; one less read/unwritten character
cEnd					;exit

cProc	B$IDISK_BAKC,<FAR,PUBLIC>,<SI> 

cBegin				
	FDB_PTR ES,SI,b$PTRFIL	;get FDB pointer
	DbAssertRel	SI,NE,0,DK_TEXT,<Invalid FDB ptr in B$IDISK_BAKC> 
	cCall	B$DISK_BAKC	;Back up a char
cEnd				
	SUBTTL	disk close
	page
;***
;DISK_CLOSE -- close disk file.  Moved here with [24].
;
;Purpose:
;	close disk file.
;*******************************************************************************
DISK_CLOSE:
	PUSH	BX		; save registers
	PUSH	CX
	PUSH	DX
	MOV	b$CLOS_FDB,SI	; mark that we are closing a file
				; in case write prot error
	MOV	BX,FileDB.FD_HANDLE ; argument is file descriptor
	TEST	FileDB.FD_FLAGS,FL_CHAR ; is this a character dev?
	JNZ	CLOSE1		; brif so -- do not do flushes
	TEST	FileDB.FD_MODE,MD_SQO OR MD_APP ; Seq. or append output ?
	JZ	CLOSE1		; no, nothing to do
	CALL	B$FLUSH	; flush buffer if it contains data,
				; and clear FD_BUFCNT
	CALL	B$FILESIZE	; seek to end of file before closing


CLOSE1:
	CALL	B$CLOSE	; close the file and
	MOV	b$CLOS_FDB,0	; clear closing file flag
	POP	DX		; restore registers
	POP	CX
	POP	BX
	JMP	B$LHDALC_CPCT	; deallocate FDB, compact local heap,
				; and return

	SUBTTL	file EOF
	page
;***
;DISK_EOF -- detect if EOF
;
;Purpose:
;	Return true (-1) if a end-of-file is encountered, otherwise returns
;	false (0).  This is only significant for a file opened for sequential
;	input or for a communications file.
;
;	A true (-1) for a communication file means the buffer is empty.
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	[AX]	= 0 or -1
;Uses:
;	none
;Preserves: (optional)
;	all, except flags
;Exceptions:
;	B$ERR_BFM -- bad file mode
;*******************************************************************************

cProc	DISK_EOF,<NEAR>

cBegin
	TEST	FileDB.FD_MODE,MD_SQO+MD_APP	; output or append?
	JNZ	ERCBFM		; brif so -- bad file mode
	MOV	AX,-1		;set to true (AX=-1)

	TEST	FileDB.FD_FLAGS,FL_NEOF ;bit set if not EOF
	JZ	DskEofExit	;Brif EOF

	TEST	FileDB.FD_MODE,MD_RND+MD_BIN ; random or binary?
	JNZ	Not_Eof		; Brif so -- just return flag value

	PUSH	AX		;save AX
	cCall	B$DISK_SINP	;]Get one char, on return [AL]=char
	POP	AX		;get back AX
	JC	DskEofExit	;Brif EOF
	cCall	DISK_BAKC	;backup over it (all register preserved)

Not_Eof:			
	INC	AX		;set to false
DskEofExit:			;result in AX
cEnd				;exit

ERCBFM: JMP	B$ERR_BFM

	SUBTTL	disk LOC
	page
;***
;DISK_LOC -- file LOC
;
;Purpose:
;	Returns current file position.
;
;	For a disk file, LOC returns the last record number been referred.
;	A record for a sequential file has 128 bytes.  For a character device,
;
;	NOTE:  This routine takes the advantage of 128-byte record length of
;		a sequential file.  Should this be changed, the part, Div128,
;		has to be changed to "call $div32".
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	[DX|AX] = current location in the file
;Uses:
;	Per Convention
;Exceptions:
;	B$ERR_BRN -- bad record number
;*******************************************************************************

cProc	DISK_LOC,<NEAR>

cBegin
	CALL	GetPosition		; get byte position for seq files
					; and record number for random.
	JNC	LOCExit			; brif char device or random/binary

; Commented the subtraction out.  With the ability to seek before the
; initial position, LOC could return a negative result.  Also commented
; out code in DISK_OPEN.
;	CMP	FileDB.FD_MODE,MD_APP	; is it append ?
;	JNE	NotApp			; Brif not -- don't add initial pos.
;	SUB	AX,FileDB.FD_LOGREC	; subtract lower and upper words of
;	SBB	DX,FileDB.FD_HIGHLR	; initial position
; NotApp:					
				; divide result by 128
	MOV	CX,7			;div 128 = shr 7
	XOR	BX,BX			;BX is for detect whether there is
					; the remainder.  CLEARS CARRY
RCRLoop:				;divide loop
	RCR	DX,1			;rotate upper word one bit
	RCR	AX,1			;rotate lower word one bit
	RCR	BX,1			;BX is for detect whether there is
					; the remainder
					;NOTE: carry is reset
	LOOP	RCRLoop 		;loop until done

	; The below code needed for compatability reasons. What a waste!
	CMP	FileDB.FD_MODE,MD_SQI	;is input ? (input is pre-read)
	JNZ	LOCExit 		;Brif not

	OR	BX,BX			;has partial block ?
	JZ	TestZero		;Brif not

	ADD	AX,1			;include partial block
	ADC	DX,0
	JMP	SHORT LOCExit		;exit to caller
TestZero:				;test if LOC is 0
	OR	BX,DX			;give one if result is zero
	OR	BX,AX
	JNZ	LOCExit 		;Brif already nonzero
	INC	AX			;set LOC result to 1

LOCExit:
cEnd					;exit to caller

	SUBTTL	disk seek supporting routines
	page

;*** 
; GetPosition -- get current byte-position/record number in file.
;
;Purpose:
;	Return current byte position for sequential files, or current
;	record number for random/binary files.
;
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	[DX|AX] = current location in the file
;	Carry set if Sequential file and not FL_CHAR
;	Carry clear otherwise
;Uses:
;	Per Convention
;
;Preserves:
;
;Exceptions:
;	B$ERR_BRN -- bad record number
;
;******************************************************************************
cProc	GetPosition,<NEAR>
cBegin

	TEST	FileDB.FD_MODE,MD_RND+MD_BIN ; random or binary?
	JNZ	RndPosition		; Brif so

	MOV	AX,1			; assume LOC = 1
	XOR	DX,DX
	TEST	FileDB.FD_FLAGS,FL_CHAR ; is character device ?
	JNZ	NotSeqFile		; Brif yes -- Exit with LOC = 1

	CALL	GetFilePos 		; [DX|AX] = position

	TEST	FileDB.FD_MODE,MD_SQI	; mode = input?
	JZ	OutputMode		; brif not -- just add count
	SUB	AX,FileDB.FD_INBUFCNT	; subtract # chars placed in
	SBB	DX,0			; buffer by last disk read

OutputMode:				
	ADD	AX,FileDB.FD_BUFCNT	; add # read/unwritten chars in
	ADC	DX,0			; buffer to get current position
	STC				; set carry for test in DISK_LOC
	JNS	GetPosExit		; exit
	JMP	B$ERR_BRN		; brif overflow -- bad record number

RndPosition:
	MOV	AX,FileDB.FD_LOGREC	; get lower word
	MOV	DX,FileDB.FD_HIGHLR	; get upper word
	TEST	FileDB.FD_FLAGS,FL_CHAR ; is character device ?
	JZ	NotSeqFile		; Brif not -- clear carry and exit
	XCHG	AX,CX			; CX = FD_LOGREC
	MOV	AX,FileDB.FD_VRECL	; record length
	CALL	B$MUL32			; [DX|CX]=[DX|CX]*[AX]
	XCHG	AX,CX			; [DX|AX]=result
NotSeqFile:
	CLC				; clear carry for test in DISK_LOC

GetPosExit:				;exit with flags set
cEnd


	SUBTTL	disk SEEK
	page
;*** 
; B$FSEK -- get current byte offset into file.  Added with revision [19].
;
;Purpose:
;	Return the current record number (1-relative).  Sequential files
;	and BINARY files are considered to have a record length of 1.
;Entry:
;	None
;Exit:
;	[DX|AX] = 1-relative current record number or byte ofset for the
;		  next operation.
;		0 for non-disk devices.
;Uses:
;	Per convention
;Preserves:
;
;Exceptions:
;
;******************************************************************************
cProc	B$FSEK,<FAR,PUBLIC>,<SI>
parmW	FileNum		; file number
cBegin
	MOV	BX,FileNum	; BX = file number
	XOR	AX,AX		; assume zero value
	XOR	DX,DX
	CALL	SeekCommon	;(ES:)[SI] = FDB, do error checking
	JNZ	FSeekExit	; brif not disk -- exit with value = 0.
	CALL	GetPosition	; [DX|AX] = current record number
				; or byte offset for sequential files
	ADD	AX,1		; make 1-relative
	ADC	DX,0
	JS	ERCBRN2		; brif overflow -- bad record number
FSeekExit:
cEnd

;*** 
; B$SSEK -- Seek to a record in file.  Added with revision [19].
;
;Purpose:
;
;Entry:
;	None
;Exit:
;	FL_NEOF bit of FD_FLAGS set appropriately
;Uses:
;	Per convention
;Preserves:
;
;Exceptions:
;	B$ERR_BRN -- Bad record number
;
;******************************************************************************
cProc	B$SSEK,<FAR,PUBLIC>,<SI>
parmW	FileNum		; file number
parmD	RecNum		; record number
cBegin
	MOV	BX,FileNum	; BX = file number
	CALL	SeekCommon	;(ES:)[SI] = FDB, do error checking
	JNZ	SSeekExit	; brif not disk -- exit without doing anything
	TEST	FileDB.FD_FLAGS,FL_CHAR ; char device?
	JNZ	SSeekExit	; brif so -- exit without doing anything
	TEST	FileDB.FD_MODE,MD_SQO+MD_APP ; output or append?
	JZ	NoFlush		; brif not -- don't flush buffer
	CALL	B$FLUSH	; flush buffer if it contains data

NoFlush:			
	TEST	FileDB.FD_MODE,MD_SQI ; input?
	JZ	DoSeek		; brif not -- don't touch count
	MOV	WORD PTR FileDB.FD_INBUFCNT,0 ; clear input buffer count
DoSeek:				
	MOV	CX,off_RecNum	; low word of record number/byte offset
	MOV	DX,seg_RecNum	; high word of record number/byte offset
	MOV	AL,RELFLG	; tell Locate record number is specified
	CALL	Locate		; translate record # to 0-relative byte offset
				; in [DX|CX]
	CALL	B$SeekFromStart ; seek from start of file, and check for error
	OR	FileDB.FD_FLAGS,FL_NEOF ; assume no EOF after seek
SSeekExit:
cEnd


ERCBRN2: JMP	B$ERR_BRN	; bad record number


;*** 
; SeekCommon -- Common routine used by B$SSEK and B$FSEK to save code.
;
;Purpose:
;	Added with [19]
;
;Entry:
;	BX = file number
;Exit:
;	(ES:)[SI]   = *FDB
;	ZF if disk file -- NZ if non-disk device
;Uses:
;	None
;Preserves:
;	All
;Exceptions:
;	B$ERR_IFN -- bad file number
;
;******************************************************************************
cProc	SeekCommon,<NEAR>
cBegin
	CALL	B$LHFDBLOC	; SI = *FDB
	JZ	ERCIFN		; brif FDB not found -- bad file number
	FDB_PTR ES,SI,SI	;get FDB ptr from handle in SI
	CMP	FileDB.FD_DEVICE,0 ; non-disk device?
cEnd

ERCIFN:	JMP	B$ERR_IFN	




	page

;***
;B$SeekFromStart -- seek from start of file to specified byte position
;
;Purpose:
;	Set file position by seeking from the begining of the file with the
;	offset given in [DX|CX]
;Entry:
;	(ES:)[SI]   = *FDB
;	[DX|CX] = offset
;Exit:
;	file position is set.
;	[DX|AX] = file position
;Uses:
;	Per convention
;Preserves:
;	BX
;Exceptions:
;	B$ERR_BRN -- bad record number
;*******************************************************************************
cProc	B$SeekFromStart,<PUBLIC,NEAR>
cBegin
	XOR	AX,AX			;seek from the begining of the file
	JMP	SHORT DosSeek		;do seek, and check for error
cEnd	nogen				;exit via DosSeek

	page
;***
;B$FILESIZE -- get file size
;
;Purpose:
;	Get file size by seeking from the end of the file with offset 0.
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	file position is set to EOF.
;	[DX|AX] = file size
;Uses:
;	Per convention
;Preserves:
;	BX
;Exceptions:
;	B$ERR_BRN -- bad record number
;*******************************************************************************

cProc	B$FILESIZE,<PUBLIC,NEAR>

cBegin
	MOV	AX,2		;seek to end + (zero) offset
	JMP	SHORT SeekZeroOffset 
cEnd	nogen			;exit via SeekZeroOffset

	page
;***
;GetFilePos -- get file position
;
;Purpose:
;	Get file position by seeking from the current position with offset 0.
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	[DX|AX] = current file position
;Uses:
;	Per convention
;Preserves:
;	BX
;Exceptions:
;	B$ERR_BRN -- bad record number
;*******************************************************************************

cProc	GetFilePos,<NEAR>
cBegin
	MOV	AX,1		; ask for seek to current + (zero) offset
	SKIP	2		; skip over SeekToStart
cEnd	<nogen>			; fall into SeekZeroOffset


;***
;SeekToStart -- seek to start of file.  Added with [19].
;
;Purpose:
;	Seek from start of file with offset 0
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	file position is set to start of file.
;	[DX|AX] = start file position
;Uses:
;	Per convention
;Preserves:
;	BX
;Exceptions:
;	B$ERR_BRN -- bad record number
;*******************************************************************************

cProc	SeekToStart,<NEAR>
cBegin
	XOR	AX,AX		; seek from start
cEnd	<nogen>			; fall into SeekZeroOffset

;***
;SeekZeroOffset -- Do seek from offset zero.  Added with [19].
;
;Purpose:
;	Get file position by seeking with method in AX with offset 0.
;Entry:
;	(ES:)[SI]   = *FDB
;	AX = seek method (described in DosSeek)
;Exit:
;	[DX|AX] = current file position
;Uses:
;	Per convention
;Preserves:
;	BX
;Exceptions:
;	B$ERR_BRN -- bad record number
;*******************************************************************************

cProc	SeekZeroOffset,<NEAR>
cBegin
	XOR	CX,CX		; set offset to zero
	MOV	DX,CX
cEnd	<nogen>			; fall into DosSeek


;***
;DosSeek
;
;Purpose:
;	Seek to the location desired.
;Entry:
;	(ES:)[SI]   = *FDB
;	[DX|CX] = distance to move
;	[AX]	= seek method (0, 1 or 2)
;			0 = seek from start
;			1 = seek from current
;			2 = seek from end
;Exit:
;	If no error
;		[DX|AX] = has the result (seg:off)
;Uses:
;	Per convention
;
;Preserves:
;	BX
;Exceptions:
;	B$ERR_BRN -- bad record number
;
;*******************************************************************************

cProc	DosSeek,<NEAR>,<BX>
cBegin

	XCHG	CX,DX		; [CX|DX] = position
	CALLOS	LSeek,ERCBRN2,<FileDB.FD_HANDLE> 
	FDB_PTR ES		;refresh FDB SEG jic global memory moved

cEnd

	SUBTTL	disk LOF
	page
;***
;DISK_LOF -- length of the file
;
;Purpose:
;	Returns the length of the file.
;
;	If the file is a communications file, LOF returns the free spaces in
;	the buffer.
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	[DX|AX] = length of the file
;Uses:
;	none
;Exceptions:
;	B$ERR_BRN -- bad record number
;*******************************************************************************

cProc	DISK_LOF,<NEAR>

cBegin
	TEST	FileDB.FD_FLAGS,FL_CHAR ;is character device ?
	JNZ	CharDevLOF		;Brif yes
	TEST	FileDB.FD_MODE,MD_SQO OR MD_APP ; output or append?
	JZ	NotOutApp		; Brif not -- don't flush buffer
	CALL	B$FLUSH		; flush buffer if it contains data
					; (this MIGHT increase file size)
NotOutApp:
	CALL	GetFilePos 		; [DX|AX] = position
	PUSH	DX			; save current position
	PUSH	AX			
	cCall	B$FILESIZE		; get file size in [DX|AX]
	POP	CX			; CX = low word of current pos
	POP	BX			; BX = high word of current pos
	PUSH	DX			; save file size
	PUSH	AX			
	MOV	DX,BX			; [DX|CX] = original position
	CALL	B$SeekFromStart	; set file original position
	POP	AX			; get file size back
	POP	DX			

	JMP	SHORT LOFExit
CharDevLOF:
	MOV	AX,1		;non-random length is 1
	XOR	DX,DX
	TEST	FileDB.FD_MODE,MD_RND+MD_BIN ; random or binary?
	JE	LOFExit			; Brif not -- exit
	MOV	AX,FileDB.FD_FSIZ_LO	
	MOV	DX,FileDB.FD_FSIZ_HI	

LOFExit:
cEnd				;exit

	SUBTTL	disk WIDTH
	page
;***
;DISK_WIDTH -- set file width
;
;Purpose:
;	Set file width while the file is open.
;Entry:
;	(ES:)[SI]   = *FDB
;	[DL]	= file width
;Exit:
;	file width is set.
;Uses:
;	none
;Preserves: (optional)
;	all
;Exceptions:
;	none
;*******************************************************************************

cProc	DISK_WIDTH,<NEAR>

cBegin
	MOV	FileDB.FD_WIDTH,DL	;set file width
cEnd

	SUBTTL	get output position
	page
;***
;DISK_GPOS -- get output position
;
;Purpose:
;	Get current output position.
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	[AH]	= current output position
;Uses:
;	none
;Preserves: (optional)
;	all
;Exceptions:
;	none
;*******************************************************************************

cProc	DISK_GPOS,<NEAR>

cBegin
	MOV	AH,FileDB.FD_OUTPS	;get file output position
cEnd

	SUBTTL	get file width
	page
;***
;DISK_GWID -- get file width
;
;Purpose:
;	Get file width.
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	[AH]	= file width
;Uses:
;	none
;Preserves: (optional)
;	all
;Exceptions:
;	none
;*******************************************************************************

cProc	DISK_GWID,<NEAR>

cBegin
	MOV	AH,FileDB.FD_WIDTH	;get file width
cEnd

DISK_DWID	EQU	B$ERR_FC	; illegal funtion call error

	SUBTTL	disk serial input
	page
;***
;B$DISK_SINP --disk serial input
;B$IDISK_SINP -- Far (QB3) interface for disk serial input
;
;Purpose:
;	Input one character from disk.
;
;	This routine is terrible.  It has four exit points -- namely,
;
;	SetEofFlag -- when read null from disk, set flag and carry and exit
;	EofFlag    -- when an EOF character is read, or the EOF flag has been
;			set, set carry and exit
;	NotEofExit -- when a normal character is get, clear carry and exit
;	SinpExit   -- final exit point, just exit (usually the carry has been
;			processed and exit via this point)
;Entry:
;Exit:
;	[AL]	= char
;	[CX]	= 0 if EOF detected (B$IDISK_SINP only)
;	FDB deallocated and file closed if error and called from OPEN
;Uses:
;	none
;Preserves:
;	BX,CX,DX,DI
;Exceptions:
;	B$ERR_FWP -- permission denied
;	B$ERR_ACD -- path/file access error
;	B$ERR_FOV -- field overflow (from FovChk)
;*******************************************************************************

cProc	B$IDISK_SINP,<PUBLIC,FAR>,<SI> 

cBegin					
	FDB_PTR ES,SI,b$PTRFIL		;get FDB pointer
	DbAssertRel	SI,NE,0,DK_TEXT,<Invalid FDB ptr in B$IDISK_SINP> 
	OR	FileDB.FD_FLAGS,FL_BIN	; specify binary access (no ^Z EOF)
	cCall	B$DISK_SINP		;call disk seq input
	MOV	CX,0			; don't touch flags
	JC	BISINPExit		;brif end of file
	DEC	CX			;set CX non zero
BISINPExit:				
cEnd					


labelNP  DISK_SINP			
cProc	B$DISK_SINP,<PUBLIC,NEAR>,<BX,CX,DX,DI> ;save BX,CX,DX,DI

cBegin

	TEST	FileDB.FD_FLAGS,FL_NEOF ;had EOF encountered ?
	JZ	EofExit 		;Brif EOF

	CMP	FileDB.FD_MODE,MD_RND	
	JE	RndGetChar		;input from random

	LEA	DI,FileDB.FD_BUFFER	;DI=*buffer

	MOV	BX,FileDB.FD_BUFCNT	;BX = next unread char position
	CMP	BX,FileDB.FD_INBUFCNT	;any unread chars left ?
	JNE	GetOneChar		;Brif yes, go get it

	MOV	AL,NOT PUTFLG		;indicate read
	MOV	BX,FileDB.FD_VRECL	;length to be read

	PUSH	ES			;preserve ES
	PUSH	DS			;set ES=DS
	POP	ES			

	cCall	DosReadWrite		;fill one buffer, on return
					; if CY then error, & AX=error code
					; else AX has the actual read/write
					; bytes
	POP	ES			;recover ES
	JB	B$AnalyzeErr		; Brif error

	FDB_PTR ES			;freshen FDB seg
	OR	AX,AX			; is end-of-file ?
	JZ	SetEofFlag		;Brif yes, set FD_FLAGS

	MOV	FileDB.FD_INBUFCNT,AX	; set # bytes in input buffer
	XOR	BX,BX			; get from the begining of buffer
	MOV	FileDB.FD_BUFCNT,BX	; # read bytes in buffer = 0

GetOneChar:
	MOV	AL,FileDB.FD_BUFFER[BX] ;get byte from buffer[BX]
	INC	FileDB.FD_BUFCNT	;one less in the buffer

	TEST	FileDB.FD_FLAGS,FL_CHAR+FL_BIN ;EOF is nonsensical for char
					; devices or binary files
	JNZ	SinpExit		;Brif yes (exit with NC)
	CMP	AL,EOFCHR		;is EOF char ?
	JNZ	NotEofExit		;exit

	cCall	DISK_BAKC		;backup to keep EOF

SetEofFlag:
	AND	FileDB.FD_FLAGS,NOT FL_NEOF ;set EOF flag
EofExit:				;EOF encountered
	MOV	AL,EOFCHR		;return EOF character
	STC				;set carry
	JMP	SHORT SinpExit		;exit

RndGetChar:				;input from random file
	CALL	FovChk			;field overflow check, on return
					; BX has the current offset
	MOV	AL,FileDB.FD_BUFFER[BX-1] ;get character
NotEofExit:				;clear carry and exit
	CLC				;clear carry

SinpExit:
cEnd					; pop bx,di, and exit

	PAGE
;*** 
; B$AnalyzeErr, B$OpenErr -- analyze error code, and give proper error.
;
;Purpose:
;	Save some code and standardize error reporting by file I/O routines.
;Entry:
;	AX = error code from DosReadWrite
;	For B$AnalyzeErr, SI = *FDB (or 0 if no FDB)
;Exit:
;	None
;Uses:
;	None
;
;Exceptions:
;	B$ERR_IOE -- device I/O error
;	B$ERR_FWP -- permission denied
;	B$ERR_ACD -- path/file access error
;
;******************************************************************************
cProc	B$AnalyzeErr,<NEAR>		
cBegin

	OR	SI,SI			; valid FDB?
	JZ	B$OpenErr		; brif not
	FDB_PTR ES			; restore FDB SEG in ES
	TEST	FileDB.FD_FLAGS,FL_CHAR ; char device ?
	PUSHF				; save this test
	CALL	B$TEST_CLOSE		; if closing flag set, close file
					; and deallocate FDB
	POPF				; char device?
	JNZ	DeviceIOError		; brif so -- device I/O error

labelNP	<PUBLIC,B$OpenErr>		

	cCall	B$GETEXTERR		; ZF if DOS 3 and sharing/locking error
	JNZ	PathAccessError		; brif not (DOS 3 and sharing/locking)

PermissionDenied:
	JMP	B$ERR_FWP		; Permission denied error
PathAccessError:
	JMP	B$ERR_ACD		; Path/File access error
DeviceIOError:
	JMP	B$ERR_IOE		; device I/O error

cEnd	<nogen>			; nothing leaves from here


;***
;FovChk -- field overflow check
;
;Purpose:
;	Check whether the field is overflow.
;Entry:
;	(ES:)[SI]   = *FDB
;Exit:
;	[BX]	= updated position in the buffer
;Uses:
;	none
;Exceptions:
;	B$ERR_FOV -- field overflow
;*******************************************************************************

cProc	FovChk,<NEAR>

cBegin
	MOV	BX,FileDB.FD_BUFCNT	;get current position
	CMP	BX,FileDB.FD_VRECL	;check for end of record
	JE	ERCFOV			;Yes - field overflow
	INC	BX			;bump pointer
	MOV	FileDB.FD_BUFCNT,BX	;update position
cEnd					;exit

ERCFOV:
	MOV	AX,B$ENTRY_BUFCNT	; Restoring the buffer position
	MOV	FileDB.FD_BUFCNT,AX	; to what it was before execution
					; of current statement

	JMP	B$ERR_FOV		; Field Over Flow Error
	page

;*** 
; B$CHK_WRITE -- Check to see that we got what we requested.
;		Added as part of [20].
;
;Purpose:
;
;Entry:
;	(ES:)[SI]   = *FDB
;
;Exit:
;	None
;Uses:
;	Flags
;
;Preserves:
;	All
;
;Exceptions:
;	B$ERR_DFL -- disk full
;	B$ERR_IOE -- I/O error
;
;******************************************************************************
cProc	B$CHK_WRITE,<NEAR>		
cBegin
	CMP	AX,CX			; bytes written the same as required ?
	JE	GotAll			; Brif yes -- no error

;	Check for DOS 2.0 bug when writing to CONOUT.  DOS 2.0 reports
;	n-1 bytes written when requested to write n bytes to CON when
;	CON is in raw mode.

	TEST	FileDB.FD_FLAGS,FL_CONOUT ; Is this CON OUT?
	JZ	Shortchanged		; brif not -- error
	PUSH	AX			; save return count
	INC	AX			; Add one to count
	CMP	AX,CX			; did DOS report 1 less requested count?
	POP	AX			; restore register
	JE	GotAll			; Brif so -- no error

Shortchanged:
	TEST	FileDB.FD_FLAGS,FL_CHAR ; char device?
	PUSHF				; save this test
	MOV	b$CLOS_FDB,SI		; make B$TEST_CLOSE close file
	CALL	B$TEST_CLOSE		; close file with NO ERROR CHECKING,
					; and deallocate FDB
	POPF				; was it a char device?
	JNZ	DeviceIOError		; brif so -- I/O error
	JMP	B$ERR_DFL		; give disk full error

GotAll:
cEnd

	SUBTTL	disk serial output
	page
;***
;DISK_SOUT -- disk serial output
;
;Purpose:
;	Output one char to a file.
;Entry:
;	(ES:)[SI]   = *FDB
;	[AL]	= character
;Exit:
;	none
;Uses:
;	none
;Preserves:
;	BX
;Exceptions:
;	B$ERR_FOV -- field overflow (from FovChk)
;*******************************************************************************

;***
;B$UpdateOUTPS - Update the OUTPS field of a FDB
;
;Purpose:
;	This shared code correctly sets the OUTPS field of a FDB for
;	a new character that is entered into the output buffer.
;
;Entry:
;	AL - character being entered into FDB output buffer
;	(ES:)[SI]   = *FDB
;
;Exit:
;	FileDB.FD_OUTPS set properly
;
;Uses:
;	Flags.
;
;Preserves:
;	None.
;
;Exceptions:
;	None.
;*******************************************************************************

DbPub	DISK_SOUT
cProc	DISK_SOUT,<NEAR>

cBegin
	CMP	FileDB.FD_MODE,MD_RND	
	JE	RndWrtChar	;serial output to random


	TEST	FileDB.FD_FLAGS,FL_CHAR ;can't write EOF char to a char device
	JZ	NotCharDev
	CMP	AL,EOFCHR		;is EOF char ?
	JE	SoutExit		;Brif yes, exit
NotCharDev:
	PUSH	BX			; save BX
	MOV	BX,FileDB.FD_BUFCNT	;# in buffer
	CMP	BX,FileDB.FD_VRECL	;is full ?
	JB	BufferReady		;Brif not, no flush buffer
	PUSH	CX			; B$FLUSH destroys CX
	CALL	B$FLUSH		; flush the buffer
	POP	CX			
	XOR	BX,BX			; new offset into buffer is 0
	; prior to this change, the buffer was cleared with ClearBuffer
	; each flush.  This should not be needed for output files.

BufferReady:
	MOV	FileDB.FD_BUFFER[BX],AL ;store char in buffer
	INC	FileDB.FD_BUFCNT	;update buffer count
	JMP	SHORT UpdateCurloc	

RndWrtChar:				;serial output to random file
	PUSH	BX			; save BX
	cCall	FovChk			;check for field overflow, on return
					; BX is the updated buffer offset
	MOV	FileDB.FD_BUFFER[BX-1],AL   ;store character

UpdateCurloc:
	POP	BX			; get back BX


	CMP	AL,NEWLINE		;is new line ?
	JNZ	UpdateOutpos		;Brif not
	MOV	FileDB.FD_OUTPS,0	;zero position
	JMP	SHORT SoutExit		;exit

UpdateOutpos:				;update current location
	CMP	AL,' '			;is printable character ?
					; (NC if yes)
	CMC				;reverse the carry
	ADC	FileDB.FD_OUTPS,0	;add 1 if printing character
SoutExit:
cEnd					;exit


	SUBTTL	disk OPEN
	page
;***
;DISK_OPEN -- open a file
;
;Purpose:
;	Open a file.  Code is in dkopen.asm.
;*******************************************************************************

DISK_OPEN	EQU	B$DISKOPEN

	SUBTTL	disk block input/output
	page
;***
;DISK_BLKIN -- disk block input
;DISK_BLKOUT -- disk block output
;
;Purpose:
;	Rewritten as part of revision [11].
;	DISK_BLKIN - disk block input, used for BLOAD only.
;	DISK_BLKOUT - disk block output, used for BSAVE only.
;		File position is assumed as already set, the read
;		or write will position the file to the next byte
;		after the operation.
;Entry:
;	(ES:)[SI]   = DGROUP offset of FDB of file to be loaded/saved
;	DX:BX   = source (segment:offset)
;	CX	= maximum number of bytes to read/write
;Exit:
;	CY set - error in read or write.
;	   clear - no error.
;Uses:
;	AX,CX,DX.
;Exceptions:
;	None.
;*******************************************************************************


cProc	DISK_BLKOUT,<NEAR>
cBegin
	MOV	AH,C_WRITE	;set DOS 3 function to write file
	SKIP	2		; skip over DISK_BLKIN
cEnd	nogen

cProc	DISK_BLKIN,<NEAR>
cBegin
	MOV	AH,C_READ	;set DOS 3 function to read file
cEnd	nogen

cProc	DISK_BLK,<NEAR>,<BX,DS>
cBegin
	PUSH	FileDB.FD_HANDLE ;handle on stack while DS=DGROUP
	MOV	DS,DX		;set DS to segment of memory to operate upon

	ASSUME	DS:NOTHING	

	MOV	DX,BX		;set to offset of memory
	POP	BX		;pop handle to register for call
	INT	21H		;perform either DOS 3 read or write
	JC	DISK_BLK_ERR	;if error in operation, then jump
	CMP	AX,CX		;test completion - carry set if not complete
DISK_BLK_ERR:
cEnd

	ASSUME	DS:DGROUP	


	SUBTTL	clear buffer
	page
;***
;ClrRestBuf -- fill remainder of buffer with 0's.  Added with [21].
;
;Purpose:
;	Fill the remainder of buffer with 0's after a short read.
;Entry:
;	[AX]	= number of valid bytes in buffer
;	[CX]	= number of bytes to clear (# requested - # read)
;	[ES:DI] = *buffer
;Exit:
;	End of buffer filled with 0's
;Uses:
;	CX
;Preserves:
;	AX,BX,DX
;Exceptions:
;	none
;*******************************************************************************

cProc	ClrRestBuf,<NEAR>,<AX,CX,DI>

cBegin
	ADD	DI,AX		; [ES:DI] = address to start clear
	XOR	AX,AX		; fill with nulls
	SHR	CX,1		; make length word
	REP	STOSW		; store word
	JNC	ClrBufExit	; brif no odd byte -- exit
	STOSB			; store odd byte
ClrBufExit:
cEnd				; return to caller

	SUBTTL	random I/O supporting routine
	page
;***
; B$MUL32 - 16x32 bit multiply with error checking
;
;Purpose:
;
;Entry:
;	[DX:CX] = multiplicand
;	[AX]	= multiplier
;
;Exit:
;	[DX:CX] = [DX:CX] * [AX]
;
;Uses:
;	AX
;
;Preserves:
;	BX
;
;Exceptions:
;	B$ERR_BRN -- bad record number upon overflow
;
;******************************************************************************
cProc	B$MUL32,<NEAR,PUBLIC>,BX 
cBegin				
	xchg	ax,cx		; get multiplier into cx, low word into ax
	call	B$Mul32x16	; [DX|AX] = [DX|AX] * [CX]
	xchg	ax,cx		; [DX|CX] = result
	jc	ERCBRN		; brif overflow
cEnd				


;***
;Locate -- locate the positon in a file
;
;Purpose:
;	This routine checks whether a given record number is legal.  If it is
;	fine, translate it into the number of bytes.
;Entry:
;	(ES:)[SI]   = *FDB
;	[DX|CX] = record number if user specified
;	[AL]	= flag
;	the flag is defined as the follows:
;		RELFLG ==> record number specified
;
;Exit:
;	[DX|CX] = the location in bytes
;	FileDB.FD_BUFCNT = 0
;Uses:
;	None
;Preserves:
;	AX,BX
;Exceptions:
;	B$ERR_BRN -- bad record number
;*******************************************************************************
cProc	Locate,<NEAR>
cBegin
	TEST	AL,RELFLG		;record number specified?
	JZ	RelRecNum		; Brif not -- use next record # 

	OR	DX,DX			;test upper word of record
	JS	ERCBRN			;Brif negative, "bad record number"
	JNZ	RecNumOK		;Brif positive, record number is OK
	JCXZ	ERCBRN			;Brif low word = 0, "bad record number"
RecNumOK:				
	SUB	CX,1			;make it 0-relative
	SBB	DX,0
	TEST	FileDB.FD_MODE,MD_BIN+MD_RND ; random or binary?
	JZ	LocateExit		; brif not -- exit with [DX|CX] =
					; byte offset
	MOV	FileDB.FD_LOGREC,CX	;save the new referred record #
	MOV	FileDB.FD_HIGHLR,DX	

RelRecNum:
	MOV	CX,FileDB.FD_LOGREC	;[DX|CX] = current logical record
	MOV	DX,FileDB.FD_HIGHLR	
	TEST	FileDB.FD_MODE,MD_BIN	; (SPEED) binary mode?
	JNZ	LocateExit		; brif so -- exit w/o multiplying 
					; by VRECL, since it is 1

	PUSH	AX			; save register
	MOV	AX,FileDB.FD_VRECL	;multiplier
	CALL	B$MUL32			; [DX|CX] = [DX|CX] * [AX]
	POP	AX			; restore register
LocateExit:
	MOV	FileDB.FD_BUFCNT,0	;no read/unwritten bytes in buffer
cEnd					;exit to caller


ERCBRN: JMP	B$ERR_BRN	; bad record number

	SUBTTL	disk random I/O
	page
;***
;DISK_RANDIO -- low level routine to access a file for GET/PUT
;
;Purpose:
;	This routine reads from/writes to a file a record.
;Entry:
;	[AL]		= flags
;			  Bit 0: 1 if PUT, else GET
;			  BIT 1: 1 if explicit record number specified
;			  BIT 2: 1 if record variable specified
;	[BX]		= record length to be written
;	[CX|DX] 	= user specified record number if GET/PUT
;	(ES:)[SI]	= *FDB
;	[b$RECPTR]	= Pointer to the data to be written
;
;Exit:
;	[AX]		= number of bytes actual read/write
;	one buffer is filled/flushed
;Uses:
;	none
;Exceptions:
;	B$ERR_IOE -- device I/O error
;	B$ERR_FWP -- permission denied
;	B$ERR_ACD -- path/file access error
;	B$ERR_BRN -- bad record number (from Locate)
;*******************************************************************************

cProc	DISK_RANDIO,<NEAR>,<CX,DI> 

cBegin
	XCHG	DX,CX		
	CALL	Locate		;[DX|CX] = DWORD byte position of record

	TEST	FileDB.FD_FLAGS,FL_CHAR 
	JNZ	GetPutCharDev	;Brif it is a character device
	test	al,VarStrData	; processing data of var len string?
	jnz	GiveDosCall	; brif so -- don't do the seek.  File is
				; correctly positioned past count word.
	push	ax		; save flags
	CALL	B$SeekFromStart ;seek to set file location (preserves BX)
	pop	ax		; restore flags

GiveDosCall:			;issue the Dos call (AL = Flags)
	PUSH	AX		;save flags
	LES	DI,[b$RECPTR]	; address of buffer
	cCall	DosReadWrite	;issue the Dos call, on return if CY then
				; error happened, AX=error code, else
				; [AX] has the actual number of
				; read/write
	POP	DX		;get back flag in DX
	JB	JMP_AnalyzeErr1	; error return

	FDB_PTR ES			;freshen FDB seg
	TEST	FileDB.FD_MODE,MD_BIN	; binary mode?
	JZ	NotBin			; brif not -- don't adjust count
	ADD	FileDB.FD_LOGREC,AX	; add number actually read/written
	JMP	SHORT IsBin		; to record count
NotBin:					
	test	dl,VarStrLen		; length of variable length string?
	jnz	NoIncrement		; brif not -- don't increment rec #
	ADD	FileDB.FD_LOGREC,1	; increment record number
IsBin:					
	ADC	FileDB.FD_HIGHLR,0	
	JS	ERCBRN			; brif overflow -- bad record number
NoIncrement:				
	OR	FileDB.FD_FLAGS,FL_NEOF ; assume no EOF
	TEST	DL,PUTFLG		; is put ?
	JNZ	PutBuf			; Brif yes

	MOV	CX,BX			; requested count
	SUB	CX,AX			; CX = number we didn't get
	JCXZ	GetPutExit		; Brif got all we requested
	AND	FileDB.FD_FLAGS,NOT FL_NEOF ;clear bit to indicate EOF
	CALL	ClrRestBuf		; clear rest of buffer
	JMP	SHORT GetPutExit	;exit

GetPutCharDev:
	TEST	AL,PUTFLG		; test if PUT or GET
					;   (bug fix -- was: NOT PUTFLG)
	JZ	GiveDosCall		;if GET just do the dos call

	; For random char devices, LOF is just total # bytes 'PUT'
	ADD	FileDB.FD_FSIZ_LO,BX	; add amount to write to file size
	ADC	FileDB.FD_FSIZ_HI,0	; don't bother doing overflow check.
					; So what if size wraps to 0?
	JMP	SHORT GiveDosCall

PutBuf:				
	MOV	CX,BX		; CX = requested count, AX = # written
	CALL	B$CHK_WRITE	; check if all chars written

GetPutExit:
cEnd				;exit to the caller

JMP_AnalyzeErr1:		
	JMP	B$AnalyzeErr	; give appropriate error message


	SUBTTL	low level file I/O -- file access
	page
;***
;DosReadWrite -- issue the DOS call for file read/write
;
;Purpose:
;	Read/write a buffer via DOS call.
;Entry:
;	[AL]	= flag
;	[BX]	= Length of data to be read
;	[SI]	= *FDB
;	[ES:DI] = *buffer
;Exit:
;	b$CSRPOS = 0 (invalid) if console output.
;	if CY
;		[AX] = error code
;	else
;		[AX] = actual number of bytes read/written
;	ES:[SI] = *FDB (for FV_FARFDB only)
;Uses:
;	none
;Preserves: (optional)
;	BX,CX,DX
;Exceptions:
;	none
;*******************************************************************************

cProc	DosReadWrite,<NEAR>,<BX,CX,DX>

cBegin
	TEST	AL,PUTFLG	;is put/write ?

	MOV	CX,BX		; [CX] = buffer length
	MOV	BX,FileDB.FD_HANDLE ; file handle
	MOV	DX,DI		;buffer address
	JNZ	DosCallWrite	;Brif PUT/WRITE
	MOV	AH,C_READ	;read the record in GET
	SKIP	2		
DosCallWrite:
	MOV	AH,C_WRITE	;write the record in PUT
DosCallExit:			
	PUSH	DS		; save DS
	PUSH	ES		
	POP	DS		; [DS:DX] = pointer to data

	ASSUME	DS:NOTHING	


	INT	21H		;do the call
	POP	DS		; restore DS

	ASSUME	DS:DGROUP	


cEnd				;exit to caller

	PAGE
;***
;B$SEEKSTART - seek to beginning of current file.
;
;Purpose:
;	Added as part of revision [12].
;	Seeks to beginning of file pointed to by b$PTRFIL.
;	Used to back up file ptr when a Binary load has
;	been detected.
;Entry:
;	b$PTRFIL - points to current fdb.
;Exit:
;	file ptr repositioned to beginning of current file.
;Uses:
;	Per convention.
;Exceptions:
;	Bad file number (from SeekToStart)
;****

cProc	B$SEEKSTART,<FAR,PUBLIC>,<SI>
cBegin
	FDB_PTR ES,SI,b$PTRFIL	;get FDB pointer
	DbAssertRel	SI,NE,0,DK_TEXT,<Invalid FDB ptr in B$SEEKSTART> 
	CALL	SeekToStart	; seek to start of file & check for errors
cEnd
	PAGE
;***
;B$BUFI, B$BUFO - Binary/Ascii Load/Save support
;
;Purpose:
; Added as part of revision [12].
; B$BUFI reads a block of data from the current file. B$BUFO writes a block
; of data to the current file. Requests for zero length reads/writes will be
; ignored. QB3 must call OPEN code to open file, followed by a call to B$CHAN
; to set the channel number. QB3 must also ensure that no heap movement occurs
; while B$BUFI and B$BUFO are active. QB3 is responsible for closing file
; (B$CLOS also clears b$PTRFIL) even if error occurs.
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Entry:
;	b$PTRFIL - contains current FDB ptr.
;	stack parms:
;	fpData - far pointer to data buffer.
;	cbData - count of bytes to read/write.
;Exit:
;	CX = 0 if CbBytes couldn't be read by B$BUFI
;Uses:
;	Per convention.
;Exceptions:
;	None.
;Note: Possible speed optimizations
;	DosReadWrite currently CLEARS buffer before input. (could eliminate)
;
;****

cProc	B$BUFI,<FAR,PUBLIC>
cBegin	<nogen>
	XOR	AL,AL		;[AL]=I/O flag
	SKIP	2		;skip next instruction
cEnd	<nogen>

cProc	B$BUFO,<FAR,PUBLIC>
cBegin	<nogen>
	MOV	AL,PUTFLG	;[AL]=I/O flag
cEnd	<nogen> 		;fall into BufIOCommon

cProc	BufIOCommon,<FAR>,<ES,DI,SI>
parmD	fpData			;ptr to IO buffer
parmW	cbData			;count of bytes to read/write
cBegin
	CBW			;[AX] = I/O flag
	MOV	CX,cbData	;[CX] = count to read/write
	JCXZ	BufIOExit	;brif no data to read/write
	FDB_PTR ES,SI,b$PTRFIL	;get FDB pointer
	LES	DI,fpData	;[ES:DI] = fpData
	MOV	BX,CX		;[BX] = count of data to read/write
DbAssertRel	SI,NE,0,DK_TEXT,<Invalid fdb ptr in B$BUFI/B$BUFO>
	PUSH	AX		;save I/O type
	PUSH	BX		;save requested byte count
	CALL	DosReadWrite	;do block input
	POP	BX		;recover requested count of bytes
	JC	JMP_AnalyzeErr2	; exit if error (PSW.C set)
	CMP	AX,BX		;did we read 'em or writ 'em all
	POP	CX		;recover I/O type 0 for input.
	JC	BufError	;issue error
BufIOExit:
	INC	CX		;return CX=0 eof on read
cEnd

BufError:
	JCXZ	BufIEof 	;EOF if couldn't read all chars
	JMP	B$ERR_DFL	;Disk full if output
BufIEof:
	DEC	CX		;make CX = FFFF so incremented to 0 for EOF
	JMP	SHORT BufIOExit ;return with CX=0 for eof on read

;***
; B$FLUSH - Flush the sequential output buffer.  Moved here with [27].
;
;Purpose:
;	Flush a buffer if it contains any data.
;	No write is done unless buffer contains data
;	If bit FL_TRUNC of FD_FLAGS is set (set at open time for OUTPUT files),
;	a 0-length write is done before the buffer is flushed in order to set
;	the file size.
;
;Entry:
;	(ES:)[SI]   = *FDB
;
;Exit:
;	One buffer is flushed
;	FileDB.FD_BUFCNT = 0
;
;Uses:
;	CX
;Preserves:
;	AX,BX,DX
;
;******************************************************************************
cProc	B$FLUSH,<NEAR,PUBLIC>
cBegin

	XOR	CX,CX		; CX = 0
	TEST	FileDB.FD_FLAGS,FL_TRUNC ; truncate file at this time?
	JZ	NoTrunc		; brif not -- don't truncate file
	AND	FileDB.FD_FLAGS,NOT FL_TRUNC ; reset truncate flag
	CALL	B$FlushCount	; write 0 bytes to set file size
NoTrunc:

	XCHG	CX,FileDB.FD_BUFCNT ; clear count in FDB and get count in CX
	JCXZ	FlushExit	; if nothing in buffer, just return
cEnd	nogen			; fall into B$FlushCount


;***
;B$FlushCount - Flush n bytes of the sequential output buffer.
;
;Purpose:
;	Write a specified number of chars from the sequential file buffer
;	without checking for a zero buffer count.
;
;Entry:
;	(ES:)[SI]   = *FDB
;	CX = number of chars to write
;
;Exit:
;	One buffer is flushed
;	FileDB.FD_BUFCNT IS NOT CHANGED!
;
;Uses:
;	None
;Preserves:
;	All
;
;******************************************************************************
cProc	B$FlushCount,<NEAR,PUBLIC> ; Rename and make public
cBegin

	PUSH	AX		; save registers
	PUSH	BX
	PUSH	DX
	LEA	DX,FileDB.FD_BUFFER ; DX = sequential access buffer address
	MOV	BX,FileDB.FD_HANDLE ; BX = file descriptor
	CALLOS	write		;write it
	JB	JMP_AnalyzeErr2	;go if error
	CALL	B$CHK_WRITE	; check to see that we got all we requested
	POP	DX		; restore registers
	POP	BX
	POP	AX
FlushExit:
cEnd


JMP_AnalyzeErr2:		
	JMP	B$AnalyzeErr	; give appropriate error message
				; file forced close and FDB deallocated
				; if closing flag set.

;*** 
;B$CLOSE -- close a file
;
;Purpose:
;
;Entry:
;	[ES:]si = *FDB
;	BX = handle
;
;Exit:
;	File closed.
;
;Uses:
;	None
;
;Preserves:
;	All
;
;Exceptions:
;	All those generated by B$AnalyzeErr.
;
;******************************************************************************

cProc	B$CLOSE,<NEAR,PUBLIC>,<AX>
cBegin

	CALLOS	close,JMP_AnalyzeErr2,bx ; make sure we don't try to close
				; this file again if we have error

cEnd

sEnd	;DK_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\dkstmt.asm ===
TITLE	DKSTMT - Disk I/O Interfaces
	page	56,132
;***
;DKSTMT - Disk I/O Interfaces
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains disk I/O interfaces for BASIC statements.
;
;	This module came from iodisk.asm, which had been split into three
;	modules, -- diskio.asm, dkopen.asm and fileio.asm.  Diskio.asm
;	contains all drivers for disk I/O except disk open and close.
;	Disk open is in dkopen.asm.  This module contains interfaces for
;	file I/O statements.
;
;BASIC Syntax mapping to included runtime entry points:
;
;- FILES Statement:
;
;     FILES Statement:
;
;     FILES [filespec]
;	 |
;     B$FILS
;
;- KILL Statement:
;
;     KILL filespec
;	 |
;     B$KILL
;
;- LOCK Statement:
;
;     LOCK [#]filenum [{, record} | [start] TO end]
;	 |
;     B$LOCK
;
;- NAME Statement:
;
;     NAME oldname AS newname
;	 |
;     B$NAME
;
;- RESET Statement:
;
;     RESET
;	 |
;     B$REST
;
;- UNLOCK Statement:
;
;     UNLOCK [#]filenum [{, record} | [start] TO end]
;	  |
;	B$LOCK
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

;Code segmetns
	useSeg	DK_TEXT
	useSeg	ER_TEXT
	useSeg	NH_TEXT
	useSeg	RT_TEXT		
;Data segments
	useSeg	CONST
	useSeg	_DATA
	useSeg	_BSS

	INCLUDE seg.inc

	INCLUDE ascii.inc
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE idmac.inc		
	INCLUDE messages.inc
	INCLUDE rtps.inc		
	INCLUDE string.inc		

	SUBTTL	local constant definitions
	page

sBegin	CONST

	externB	b$EightSpaces		; buffer of 8 spaces
	staticB DirStr,"<DIR> "

sEnd	CONST

sBegin	_DATA


sEnd	_DATA

sBegin	_BSS

	externB b$PATHNAM 		; defined in GWINI.ASM
	externB b$Buf2 		; defined in GWINI.ASM
	b$PATHNAM2 EQU b$Buf2		
	externW b$PN_NAME		



sEnd	_BSS

	SUBTTL	code externals
	page

sBegin	DK_TEXT


	externNP	B$GET_PATHNAME	
	externNP	B$GET_CUR_DIR	
	externFP	B$PSI4		
	externNP	B$PUTS		
	externNP	B$OUTCNT		
	externNP	B$$WCHT
	externNP	B$$TCR
	externNP	B$TTY_GPOS
	externNP	B$TTY_GWID
	externNP	B$CLOSF
	externNP	B$CHKFOPEN	
	externNP	B$DOS3CHECK	;check for >= DOS 3.00
	externNP	B$MUL32	

sEnd	DK_TEXT

sBegin	NH_TEXT

	externNP	B$STDALCTMP
	externNP	B$LHFDBLOC	

sEnd	NH_TEXT

sBegin	ER_TEXT

	externNP	B$PUTNUM	; output message

	externNP	B$ERR_FC
	externNP	B$ERR_BFN
	externNP	B$ERR_BRN
	externNP	B$ERR_FAE
	externNP	B$ERR_FNF
	externNP	B$ERR_IFN
	externNP	B$ERR_ACD
	externNP	B$ERR_FWP
	externNP	B$ERR_AFE
	externNP	B$ERR_PNF	
	externNP	B$ERR_RAD	

sEnd	ER_TEXT

sBegin	RT_TEXT				
sEnd	RT_TEXT				


	PAGE

	assumes CS,DK_TEXT

sBegin	DK_TEXT

;***
;B$KILL - KILL filename
;
;Purpose:
;
;Entry:
; fname = filename sdesc
;
;Exit:
;
;Uses:
; Per convention
;
;Exceptions:
;	B$ERR_FNF -- for file not found
;	B$ERR_ACD -- for access denied
;	B$ERR_FAO -- for file already open
;
;******************************************************************************
cProc	B$KILL,<FAR,PUBLIC>,<SI,DI,ES> 
parmSD	fname			
cbegin				


	PUSH	DS		; set ES=DS for string operations
	POP	ES		
	MOV	BX,fname	; get *sd of filename
	MOV	DI,OFFSET DGROUP:b$PATHNAM ; Where to put the pathname
	CALL	B$GET_PATHNAME	; generate pathname, checking for errors
				; sets ES = DS
	CALL	B$STDALCTMP	;delete temporaries
	CALL	SearchNoDir	; find first file, or give "file not found"

KILL_NEXT:
;	DI --> pointer to processed filename

	PUSH	DI		; save pathname buffer address
	MOV	DI,b$PN_NAME	; DI = address past last "\" in pathname
				; (filename.ext field of pathname)
	mov	si,offset dgroup:b$PATHNAM2+30 ; Where dos put the filename

				; store name into the name field of pathname
dkk22:
	lodsb			;get a byte from the filename
	stosb			;store it into the pathname
	or	al,al		;end ?
	jnz	dkk22		;no

	pop	di		;--> pathname
	CALL	B$CHKFOPEN	; Check for conflict with open files
				; (doesn't return if error)

				; delete the link
	mov	dx,di		; DX = address of pathname to delete
	CALLOS	unlink,,,,dx
	JB	KILL_ERR	; give proper error message
	CALLOS	FINDN		;find next
	JNB	KILL_NEXT	; found next, continue


cEnd				

KILL_ERR:
	CMP	AX,ERRACD	;test if access error
	JNE	ERFNF		; if not, then KILL defaults to file not
				; found error
	JMP	B$ERR_ACD	  ;treat as access error
ERFNF:				
	JMP	B$ERR_FNF	; File not found

;***
; B$NAME - Name statement
;
;Purpose:
; Rename a file
;
;Entry:
; oldname = Name of existing file
; newname = name to change to
;
;Exit:
;
;Uses:
; Per convention
;
;Exceptions:
; B$ERR_FAE if newname already exists.
;
;******************************************************************************
cProc	B$NAME,<FAR,PUBLIC>,<ES,SI,DI> 
parmSD	oldname 		
parmSD	newname 		
cBegin				


	PUSH	DS		; set ES=DS
	POP	ES		

	GetpSD	BX,newname	
	MOV	DI,OFFSET DGROUP:b$PATHNAM2 
	CALL	NAME_COMMON	; do common processing for second name

	GetpSD	BX,oldname	; source pathname sdesc
	MOV	DI,OFFSET DGROUP:b$PATHNAM 
	CALL	NAME_COMMON	; do common processing for first name

	MOV	DX,OFFSET DGROUP:b$PATHNAM ;source
	MOV	DI,OFFSET DGROUP:b$PATHNAM2 ;destination
	CALLOS	RENAME		
	JC	NAME_ERR	


cEnd				

NAME_ERR: 			
	CMP	AL,ERRFNF	; file not found?
	JE	ERFNF		; brif so
	CMP	AL,ERRPNF	; path not found?
	JE	ERPNF		; brif so
	CMP	AL,ERRACD	; access denied?
	JE	ERFAE		; brif so -- File already exists
	CMP	AL,ERRNSD	; not same device?
	JE	ERRAD		; brif so -- Rename across disks
				; default to Illegal function call error
				; for NAME if not one of the above.
ERFC:
	JMP	B$ERR_FC	; Illegal function call
ERFAE:				
	JMP	B$ERR_FAE	; File already exists
ERPNF:
	JMP	B$ERR_PNF	; Path not found
ERRAD:				
	JMP	B$ERR_RAD	; Rename across disks
ERBFN:				
	JMP	B$ERR_BFN	; Bad file name
ERCFNF2:			
	JMP	SHORT ERFNF	; give "file not found" error

;*** 
; NAME_COMMON - common processing.  Added as part of [14].
;
;Purpose:
;	Common processing for each filename of B$NAME.
;
;	Algorithm:
;		call B$GET_PATHNAME
;		if (wildcards in filename) then error		
;		deallocate the string temp
;		if (file already open) then error
;
;Entry:
;	DI =	*space for pathname
;	BX =	pointer to user-specified filename string descriptor
;
;Exit:
;	DI =	*processed pathname
;	CX =	length of pathname (including null byte)
;
;Uses:
;	per convention
;
;Preserves:
;
;Exceptions:
;	B$ERR_BFN -- for bad file name
;	B$ERR_FAO -- for file already open
;
;******************************************************************************
NAME_COMMON:
	CALL	B$GET_PATHNAME	; Scan file name
				; sets ES = DS
	cCall	B$STDALCTMP	; deallocate string temp
	TEST	AL,FN_WILD	; wildcards in filename?
	JNZ	ERBFN 		; brif so -- error
				; [DI] = processed pathname
				; [CX] = number of bytes in pathname
	JMP	B$CHKFOPEN	; check for file already open and return
				; (doesn't return if error)

;*** 
; Search/SearchNoDir - search for file
;
;Purpose:
;	Search for files
;Entry:
;	b$PATHNAM has pathname to search for
;Exit:
;	Conditions after DOS search function:
;		b$PATHNAM2 has directory entry for first matching file
;		DX -> b$PATHNAM
;	ZF ==> file found, NZ ==> error
;
;Uses:
;	AX,CX,DX
;
;Preserves:
;
;Exceptions:
;
;******************************************************************************
Search:				
	mov	cx,ATTR_SUBDIR	; Search attributes
	SKIP	2		; eat the XOR and fall into common code

cProc	SearchNoDir,<NEAR>	; no directory
cBegin				
	xor	cx,cx		;no search attributes (files only)

	MOV	DX,OFFSET DGROUP:b$PATHNAM2 
	CALLOS	BUFF		;Set buffer address
	MOV	DX,OFFSET DGROUP:b$PATHNAM ; Address of pathname to search
	CALLOS	FINDF		; Use new one
	JC	ERCFNF2		; brif error -- file not found
cEnd				

	SUBTTL	B$REST - Reset statement
	PAGE
;***
; B$REST - Reset statement
;
;Purpose:
; Runtime entry. Close all open files.
;
;******************************************************************************
cProc	B$REST,<FAR,PUBLIC,FORCEFRAME> 
cBegin
	CALL	B$CLOSF		;Close all files

	CALLOS	GDRV		;Get drive number
	PUSH	AX
	CALLOS	REST		;Restore
	POP	AX
	MOV	DL,AL
	CALLOS	SDRV		;Set drive number

cEnd				

	SUBTTL	FILE interface
	page
newlin: 			;moved here from below
	CALL	B$TTY_GPOS
	XCHG	AL,AH
	ADD	AL,18		;Position after next file name
	CALL	B$TTY_GWID
	CMP	AL,AH
	RET


;***
;B$FILS - FILES Statement
;
;Purpose:
; Print a listing of all files in the current directory, which match the given
; string pattern
;
;Input:
; fname = filename sd
;
;Output:
; None
;
;Modifies:
; Per convention
;
;Exceptions:
; Control could be transfered to error code, such as B$ERR_FNF
;
;******************************************************************************
cProc	B$FILS,<FAR,PUBLIC>,<ES,DI,SI> 
parmW	fname
cBegin


	PUSH	DS		; set ES=DS for string operations
	POP	ES		
	MOV	BX,fname
	MOV	DI,OFFSET DGROUP:b$PATHNAM 
	call	B$GET_PATHNAME	; convert to standard pathname format
	CALL	B$STDALCTMP	;delete string if temp

	PUSH	DI		; save pathname buffer address
	
	MOV	AX,[DI]		; load drive letter and colon into AX
	MOV	DI,OFFSET DGROUP:b$PATHNAM2 ; buffer for current directory
	PUSH	DI		; save buffer address (for printing)
	STOSW			; store drive letter and ":" into buffer
	SUB	AX,':' SHL 8 + 'A' - 1 ; convert AX to drive number (1-26)
	XCHG	AX,DX		; DX = drive number

	CALL	B$GET_CUR_DIR 	; store current directory path for this
				; drive into buffer, after the drive letter

	; print the current directory for specified drive
	POP	AX		; AX = buffer offset
	PUSH	DX		; save drive number
	MOV	DX,DS		; DX = buffer segment
	CALL	B$PUTS		; print the null-terminated buffer
	CALL	B$$TCR		; print a CR

	; add "*.*" to the pathname if necessary
				; CX and DX preserved from above
	POP	DX		; restore drive number
	POP	DI		; restore pathname buffer address
	PUSH	DX		; save drive number for free space check
	ADD	DI,CX		; one past null byte
	DEC	DI		; DI = address of null byte
	CMP	DI,b$PN_NAME	; does pathname end with a "\"?
	JNZ	NO_ADD_EXT	; brif not -- don't add the extention
	MOV	AX,".*"		; add "*." to the pathname
	STOSW			
	MOV	AX,"*"		; add "*0" to the pathname
	STOSW			

NO_ADD_EXT:			

	CALL	Search		; search for first file with this name
				; or give "file not found"
d2off:
	mov	si,offset dgroup:b$PATHNAM2+30 ; name
	mov	cx,8
	mov	dx,"."
	call	outnam
	mov	cx,4
	xor	dx,dx
	call	outnam
	mov	si,offset dgroup:b$EightSpaces	
	cmp	byte ptr b$PATHNAM2+21,ATTR_SUBDIR ; check for directory attr
	jne	d2space
	mov	si,offset dgroup:DirStr
d2space:
	mov	cx,6		; print 6 chars
	CALL	B$OUTCNT		; print CX bytes

	call	newlin
	jl	findn
	call	B$$TCR
findn:
	callos	findn
	jnb	d2off

	CALL	B$$TCR		; list of files done -- output a CR
	POP	DX		; get back drive number
	CALLOS	FREES		;get disk free space
	mul	cx		;[ax]=bytes/sect*sect/alloc
	mul	bx		;[dxax]=[ax]*free alloc units
	PUSH	DX		; pass the I4
	PUSH	AX		
	call	B$PSI4		; and output that
	MOV	AX,MS_BYTESFREE ;output "Bytes free"
	cCall	B$PUTNUM	;output the message


cEnd				

outnam:
	mov	al," "
	cmp	byte ptr[si],dh ;end of string?
	je	atend
	cmp	byte ptr[si],dl ;possible end of name
	je	atend
	lodsb
atend:
	call	B$$WCHT		;write char
	loop	outnam
	ret

	page

	SUBTTL	LOCK/UNLOCK interfaces
	page

ERCFNF: JMP	B$ERR_FNF	;file not found
ERCAFE: JMP	B$ERR_AFE	;advanced feature

;***
;B$LOCK -- LOCK/UNLOCK statement interface
;void B$LOCK (I2 channel, I4 first_rec, I4 last_rec, U2 mode)
;
;Purpose:
;	Lock or unlock an opened file according to the value of mode.  The
;	file must be opened using the new OPEN syntax with the lock clause,
;	and DOS version must be 3.0 or above;otherwise a runtime error will
;	occur.	Between 2.0 and 3.0, the range of record number is slightly
;	different.  In 2.0, a 24-bit record number is supported, whereas a
;	31-bit record number is supported.
;
;	Note: BASICA 3.2 supports 32-bit record number.
;
;	BASCOM 2.0 uses two separate interfaces, $ULK & $LK0, for UNLOCK and
;	LOCK statement respectively.  In BASCOM 3.0, a single interface is
;	used with mode containing valuable information. The beauty of the mode
;	is that the first bit tells whether it is a lock or an unlock, and the
;	second bit tells whether it is to lock/unlock the whole file or not.
;
;	The syntax for LOCK/UNLOCK is as follows:
;	LOCK/UNLOCK [#]channel [,[first-rec] [TO last-rec]]
;
;	B$CHAN WILL NOT be called prior to B$LOCK, this routine has to
;	check the file is opened or not.
;
;	The 'first-rec' is the 'from' record # and 'last-rec' is the 'to'
;	record #.  The default 'first-rec' is 1 and the default 'last-rec'
;	is the same record number as the 'first-rec.'  For example,
;	"LOCK #1, TO 3" will generate first=1, last=3 & mode=2, and
;	"UNLOCK #1, 5" will generate first=5, last=5 & mode=3.
;
;	NOTE: Currently, record number is only meaningful to the random file.
;		Sequential file is always lock/unlocked the whole file, and
;		there is no range check of 'first-rec' or 'last-rec' for a
;		sequential file.  (the compiler or the interpreter parser
;		does check whether the parameter is a numerical type.)
;
;	The low order byte of mode may contain the following values according
;	to different situations (the high order word should wlays be IGNORED,
;	as the interpeter uses it):
;
;	mode = 0 -- lock entire file
;	mode = 2 -- lock from first to last
;
;	mode = 1 -- unlock entire file
;	mode = 3 -- unlock from first to last
;
;	The reason is illustrated as the following bit map.
;	mode:
;		_________________________________
;		| 0 | 0 | 0 | 0 | 0 | 0 | X | Y |
;		---------------------------------
;		MSB				LSB
;	where:
;	X is used to represent whether to lock/unlock the whole file, and
;	Y is used to decide whether it is a lock or is an unlock.
;
;	The runtime may then use one AND, instead of one AND & one SHR, before
;	call DOS lock/unlock function. (The value needed in AL is 0 for lock
;	and 1 for unlock.  Refer to the next paragraph.)
;
;	The DOS function call for lock/unlock a file needs:
;	[AH]	=	5CH
;	[AL]	=	0	-- lock
;			1	-- unlock
;	[BX]	=	file handle
;	[CX]	=	offset high
;	[DX]	=	offset low
;	[SI]	=	length high
;	[DI]	=	length low
;Entry:
;	Parameters are pushed in stack
;	int		channel
;	long int	first_rec
;	long int	last_rec
;	ushort		mode
;Exit:
;	none
;Uses:
;	none
;Exceptions:
;
;*******************************************************************************

cProc	B$LOCK,<PUBLIC,FAR>,<SI,DI>	;push di,si
	ParmW	Channel 	;I2 file number
	ParmD	First		;I4 first record number
	ParmD	Last		;I4 last record number
	ParmW	Mode		;U2 mode
cBegin				;set up stack frame
	cCall	B$DOS3CHECK	;must be DOS 3.0 or above
	JB	ERCAFE		;Brif not, give "advanced feature"
	MOV	BX,Channel	;get file number
	CALL	B$LHFDBLOC	;NZ then SI has the pointer to FDB
	JZ	ERCIFN		; Brif not, give "bad file number"
	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB
	MOV	BX,FileDB.FD_HANDLE ; get file handle in BX
	PUSH	BX		;save file handle
	TEST	Mode,LOCK_1stToLast ; test the "entire file" bit
	JZ	LockEntire	; jump if we want to lock it all
	TEST	FileDB.FD_MODE,MD_RND+MD_BIN	
				; is opened for random or binary ?
	JNZ	 LockOffset	; Brif yes, record number is meaningful

LockEntire:			
	XOR	CX,CX		;starting record
	MOV	DX,CX		;(0-relative)
	MOV	SI,CX		;offset
	DEC	SI		;SI=0FFFFh
	MOV	DI,SI		;lock the whole file
	JMP	SHORT LockFile	;go lock it
ERCIFN: JMP	B$ERR_IFN	; bad file number
LockOffset:
	MOV	CX,Off_First	; get first record number low
	MOV	DX,Seg_First	; get first record number high
	OR	DX,DX		; negative number?
	JS	ERCBRN		; Brif yes, give "bad record number"
	SUB	CX,1		;decrement one, set carry if not big enough
	SBB	DX,0		;if CY ([DX|CX] = 0), then give error
	PUSH	CX		;save 0-relative first rec# low
	PUSH	DX		;save 0-relative first rec# high
	JB	ERCBRN		;give "bad record number"
	MOV	AX,CX		;get a copy of rec# low
	OR	AX,DX		;is 0 ?
	MOV	AX,FileDB.FD_VRECL ; [AX] = multiplicant (also used below)
	JZ	LockLen 	;Brif yes, no translate needed, to get length

	PUSH	AX		;save multiplicand
	cCall	B$MUL32	;[DX|CX]=[DX|CX]*[AX], if CY then overflow
				; generates Bad record number on overflow
	POP	AX		
LockLen:
	POP	SI		;get first 0-relative first rec# high
	POP	DI		;get first 0-relative first rec# low
	PUSH	CX		;push low offset
	PUSH	DX		;push high offset
	MOV	CX,Off_Last	; get Second record number low
	MOV	DX,Seg_Last	; get Second record number high
	MOV	BX,CX		
	OR	BX,DX		; Make sure non-zero
	JZ	ERCBRN		
	OR	DX,DX		; negative number?
	JS	ERCBRN		; Brif yes, give "bad record number"
	SUB	CX,DI		;calculate how many records
	SBB	DX,SI		;[DX|CX]= second# - (first# - 1)
	JB	ERCBRN		; Brif second > first, give bad record num
				; [AX] = multiplicant, set up above...
	cCall	B$MUL32	;[DX|CX]=[DX|CX]*[AX], if CY then overflow
				; generates Bad record number on overflow
	MOV	DI,CX		;DI=length low
	MOV	SI,DX		;SI=length high
	POP	CX		;CX=offset high
	POP	DX		;DX=offset low
LockFile:
	POP	BX		;get back file handle
	MOV	AX,Mode 	;get mode
	AND	AL,1		;lock or unlock
	CALLOS	LOCKING,ULKERR	;go lock it
cEnd				;pop si,di and exit to caller

ULKERR:
	CMP	AX,ERRIVH	;invalid handle ?
	JZ	ERCIFN		;bad file number
	JMP	B$ERR_FWP	;now "Permission Denied"
ERCBRN: JMP	B$ERR_BRN	; bad record number


cEnd

sEnd	DK_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\draw.asm ===
PAGE	56,132
	TITLE	DRAW - Draw Statement Support
;***
; DRAW - Draw Statement Support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - DRAW Statement:
;
;      DRAW string
;	 |
;      $DRA
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	_BSS		
	USESEG	_DATA		
	USESEG	CONST		
	USESEG	GR_TEXT 	

	INCLUDE seg.inc 	;segment definitions
	INCLUDE	rtps.inc	; variable types
	INCLUDE string.inc	


sBegin	_BSS			
;
;****************************************************************************
; External low-level function vectors
;****************************************************************************
;
externW b$SetAttr		
externW b$MapXYC		

	externW B$GRPACX 	;defined in GWDATA.ASM
	externW B$GRPACY 	;defined in GWDATA.ASM
	externD B$GRFACX 	;defined in GWDATA.ASM
	externD B$GRFACY 	;defined in GWDATA.ASM
	externB B$DRWFLG	;defined in GWDATA.ASM
	externW B$DRWSCL 	;defined in GWDATA.ASM
	externW B$DRWANG 	;defined in GWDATA.ASM
	externB b$ScreenMode	; defined in LLCGRP.ASM

	externW B$ASPRF		;defined in GWDATA.ASM
	externB B$DFRACX 	;defined in GWDATA.ASM
	externB B$DFRACY 	;defined in GWDATA.ASM
	externW B$COSA		;defined in GWDATA.ASM
	externW B$MSINA		;defined in GWDATA.ASM
	externW B$DSINA		;defined in GWDATA.ASM


	externB	b$Buf3		
	$BGTNUL EQU b$Buf3	
	externW B$TILFLG 	;defined in GWDATA.ASM
	externW B$TIPROG 	;defined in GWDATA.ASM
	externW B$TILNDX 	;defined in GWDATA.ASM

sEnd	_BSS			

sBegin	CONST			

	externD b$FP_256	; s.p. constant 256.0

	.8087			
	staticD FP_PI180,0.017453293	; s.p. PI/180

sEnd	CONST			

	externFP B$COS4	
	externFP B$SIN4	

assumes CS,GR_TEXT		
sBegin	GR_TEXT 		

	externNP B$GRMODE	




	externNP B$ftolrnd	; force to integer in AX

	externNP B$ERR_FC	
	externNP B$STCPCT	; Compact string space
	externNP B$STGETFRESIZ	; Get available size in string space

	externNP B$fmlds	
	externNP B$fmldw	

;low-level routines:
	externNP B$PaintInit	
	externNP B$SCINIT	; Performs screen initialization

	externNP B$INVIEW	


	externNP B$PAINTBEG	
	externNP B$INTQNOCPCT	; Init paint queue w/o compaction.


	SUBTTL	GML - Graphics Macro Language Support

	externNP B$GTABSC	
	externNP B$CLINE2	

MLCMD	MACRO	MC,ACTION
	DB	mc
	DW	OFFSET action
ENDM
MLARG	MACRO	MC,ACTION
	DB	mc+128
	DW	OFFSET action
ENDM

;EXT.CO  FETCHR,VARGET
	externNP B$VALSCN	
	externNP B$DECFET	
	externNP B$MACLNG	
	externNP B$MCLXEQ	
	externNP B$FETCHZ	


;***
;B$DRAW - process Draw statement
;
;Purpose:
;	Execute macro language substring containing DRAW commands.
;Entry:
;	sdDraw == string descriptor
;Exit:
;	None.
;Uses:
;	Per convention.
;Exceptions:
;	Control could be transfered to B$ERR_FC
;****
cProc	B$DRAW,<PUBLIC,FAR>,<SI,DI> 
parmSD	sdDraw			
cBegin				

	CALL	B$SCINIT	; initialize screen if not already done
	GetpSD	BX,sdDraw	; BX = psdDraw
	XOR	AL,AL		;CLEAR OUT DRAW FLAGS
	call	B$GRMODE	; are we in a graphics mode?
	JNZ	OKDRAW		;Brif in Graphics mode
	JMP	B$ERR_FC	  ; else error
OKDRAW: 			;In graphics mode: OK to draw

;	At this point, check if adequate room exists for a potential paint queue
;	If not, then compact the string heap now. The compaction cannot be done
;	later since it will invalidate the MCL string offsets.

	PUSH	BX		; Save psd
	CALL	B$STGETFRESIZ	; Determine the free size
	CMP	BX,900		; Is there space for 100 entries?
	JAE	DRAW_PROCEED	; Brif so - no need to compact
	CALL	B$STCPCT	; Else compact only the string space
DRAW_PROCEED:			
	POP	BX		; Get back BX (psd)

	MOV	DX,OFFSET DRWTAB ;DISPATCH TABLE FOR GML
	MOV	B$DRWFLG,AL	; AL must still be zero!
	CALL	B$MACLNG 	; GO DO IT.
cEnd				

DRWTAB:
	MLARG	"U",DRUP	;UP    ;GPS 29-JUN-83 ASM86 doesn't like DUP
	MLARG	"D",DDOWN	;DOWN
	MLARG	"L",DLEFT	;LEFT
	MLARG	"R",DRIGHT	;RIGHT
	MLCMD	"M",DMOVE	;MOVE
	MLARG	"E",DRWEEE	;-,-
	MLARG	"F",DRWFFF	;+,-
	MLARG	"G",DRWGGG	;+,+
	MLARG	"H",DRWHHH	;-,+
	MLARG	"A",DANGLE	;ANGLE COMMAND
	MLCMD	"T",TANGLE	;360 Degree Angle Command
	MLCMD	"B",DNOPLT	;MOVE WITHOUT PLOTTING
	MLCMD	"N",DNOMOV	;DON'T CHANGE CURRENT COORDS
	MLCMD	"X",B$MCLXEQ	;EXECUTE STRING
	MLARG	"C",DCOLR	;COLOR
	MLARG	"S",DSCALE	;SCALE
	MLCMD	"P",DPAINT	;PAINT fc,bc
	DB	00		;END OF TABLE

subttl	DRAW subcommands
page



;***
;	The following series of entry points handle integer arguments
;	to draw subcommands.  These entry points are the ones contained
;	in the draw subcommand dispatch table and are entered by a jump
;	from the macro language processor (mclprc.asm).  However, if a
;	"V1" draw subcommand is in effect (indicated by b$fTrans being
;	TRUE), then the draw subcommand arguments are interpreted as
;	floating point rather than integer arguments.  Floating point
;	arguments are handled by the corresponding routines with an "F"
;	prefix in the name (see above).  The two cases (integer or
;	floating point arguments) are distinguished before the dispatch
;	as follows:  mclprc.asm executes "cmp b$fTrans, TRUE" just prior
;	the the dispatch.  Thus psw.z will be set iff floating point 
;	arguments are being used.  Therefore each entry point for integer
;	args branches to the corresponding routine for floating point
;	args iff psw.z is set.  The psw is also stored in ah after the
;	"cmp b$fTrans,TRUE" and before the dispatch.
;****

;***
;DRUP
;Purpose:
;       Move up using integer args.
;Input:
;	ah = psw
;	psw.z set if args are f.p.
;       psw.z clear if args are integer
;Outputs:
;	move up specified amount
;****
DRUP:
        NEG     DX                      ;MOVE +0,-Y
;***
;DDOWN
;Purpose:
;       Move down using integer args.
;Input:
;	ah = psw
;	psw.z set if args are f.p.
;       psw.z clear if args are integer
;Outputs:
;	move down specified amount
;****
DDOWN:                                  ;MOVE +0,+Y
        MOV     CX,0                    ;DX=0
	JMP	SHORT DOMOVR		; TREAT AS RELATIVE MOVE
;***
;DLEFT
;Purpose:
;       Move left using integer args.
;Input:
;	ah = psw
;	psw.z set if args are f.p.
;       psw.z clear if args are integer
;Outputs:
;	move left specified amount
;****
DLEFT:
        NEG     DX                      ;MOVE -X,+0
;***
;DRIGHT
;Purpose:
;       Move right using integer args.
;Input:
;	ah = psw
;	psw.z set if args are f.p.
;       psw.z clear if args are integer
;Outputs:
;	move right specified amount
;****
DRIGHT:                                 ;MOVE +X,+0
        MOV     CX,DX                   ;[CX]=VALUE
        MOV     DX,0                    ;DY=0
	JMP	SHORT DOMOVR		; TREAT AS RELATIVE MOVE
;***
;DRWHHH
;Purpose:
;       Move up and left using integer args.
;Input:
;	ah = psw
;	psw.z set if args are f.p.
;       psw.z clear if args are integer
;Outputs:
;	move up and left specified amount
;****
DRWHHH:
        NEG     DX                      ;MOVE -X,-Y
;***
;DRWFFF
;Purpose:
;       Move down and right using integer args.
;Input:
;	ah = psw
;	psw.z set if args are f.p.
;       psw.z clear if args are integer
;Outputs:
;	move down and right specified amount
;****
DRWFFF:
        MOV     CX,DX                   ;MOVE +X,+Y
	JMP	SHORT DOMOVR		; TREAT AS RELATIVE MOVE
;***
;DRWEEE
;Purpose:
;       Move up and right using integer args.
;Input:
;	ah = psw
;	psw.z set if args are f.p.
;       psw.z clear if args are integer
;Outputs:
;	move up and right specified amount
;****
DRWEEE:
DRWHHC:					; continuation of DRWGGG
        MOV     CX,DX                   ;MOVE +X,-Y
        NEG     DX
	JMP	SHORT DOMOVR		; TREAT AS RELATIVE MOVE
;***
;DRWGGG
;Purpose:
;       Move down and left using integer args.
;Input:
;	ah = psw
;	psw.z set if args are f.p.
;       psw.z clear if args are integer
;Outputs:
;	move down and left specified amount
;****
DRWGGG:
        NEG     DX                      ;MOVE -X,+Y
        JMP     SHORT DRWHHC            ;MAKE DY POSITIVE & GO

;***
;DMOVE
;Purpose:
;       Move to the specified location
;Input:
;	b$fTrans TRUE if coords to be interpreted as floating point
;	b$fTrans FALSE if coords to be interpreted as integer
;Outputs:
;	graphics cursor position updated
;****
DMOVE:
	CALL	B$FETCHZ 	;GET NEXT CHAR AFTER COMMA
	CMP	AL,'+'		;IF '+' OR '-' THEN RELATIVE
	JZ	MOVREL
	CMP	AL,'-'
MOVREL:
	PUSHF			;SAVE ABS/REL FLAG ON STACK
	CALL	B$DECFET 	;BACK UP SO B$VALSCN WILL SEE "-"
	CALL	B$VALSCN 	;GET X VALUE
	PUSH	DX		;SAVE IT
GetComma:			
	CALL	B$FETCHZ 	;NOW CHECK FOR COMMA
	CMP	AL,','		;COMMA?
	JZ	MOVRE2
	JMP	B$ERR_FC
MOVRE2:
	CALL	B$VALSCN 	;[DX]= Y
	POP	CX		;[CX]= X
	MOV	BX,8080h	; x,y fraction is 1/2
	POPF			;GET ABS/REL FLAG

	JNZ	DRWABS		;NZ - ABSOLUTE


DOMOVR:
	CALL	DSCLDE		;ADJUST Y OFFSET BY SCALE
	PUSH	DX		;SAVE Y OFFSET
	MOV	DX,CX		;GET X INTO [DX]
	CALL	DSCLDE		;GO SCALE IT.
	MOV	CX,DX		;[CX]= Adjusted x
	POP	DX		;[DX]= Adjusted y
	XOR	AX,AX		;Assume no low order 8 bits
	CMP	BYTE PTR B$COSA+2,0 ;Check for cos(ang) = 0 (poss. no turnangle)
	JZ	CHKSINE 	;  brif cos(0) = 0; if sin(ang) = 0, no TA given
	CMP	BYTE PTR B$COSA+3,LOW 0 ;Check for 180 with B$COSA neg., B$DSINA= 0
	JNS	FRCANG		;brif cos(ang) was a positive number
CHKSINE:
	CMP	WORD PTR B$DSINA+2,0 ;If exp 0, then Angle is 0.
	JZ	DRWAFN		;Skip floating stuff if no angle..

; else calculate:
; Delta y [DXAH]:= (x*B$MSINA)+(y*B$COSA)
; Delta x [CXAL]:= (x*B$COSA) +(y*B$DSINA)

FRCANG:
	PUSH	DX		;Save y
	PUSH	CX		;Save x
	MOV	BX,OFFSET DGROUP:B$COSA
	CALL	FMULDX		;ST0 = (y*B$COSA)
	POP	DX		;Get x
	PUSH	DX
	MOV	BX,OFFSET DGROUP:B$MSINA
	CALL	FADARG		;[CXAL]= (x*B$MSINA)+(y*B$COSA)
	POP	DX		;Get x
	POP	BX		;Get y
	PUSH	CX
	PUSH	AX		;Save 24 bit y delta
	PUSH	BX		;Save y
	MOV	BX,OFFSET DGROUP:B$COSA
	CALL	FMULDX		;ST0 = (x*B$COSA)
	POP	DX		;Get y
	MOV	BX,OFFSET DGROUP:B$DSINA
	CALL	FADARG		;[CXAL]= (x*B$COSA)+(y*B$DSINA)
	POP	DX
	MOV	AH,DL		;[CXAL]= x Delta
	POP	DX		;[DXAH]= y Delta
DRWAFN:
	ADD	AL,[B$DFRACX]	;incr x low
	JNB	DRWXNC		;Brif no ovf
	INC	CX		;incr x high
DRWXNC:
	ADD	AH,[B$DFRACY]	;incr y low
	JNB	ANGPOS		;Brif no ovf
	INC	DX		;incr y high
ANGPOS:
	PUSH	AX		;Save fractional x,y
	CALL	B$GTABSC 	;[CX]= True x, [DX]= True y
	POP	BX		;Want fractional x,y in [BX]
DRWABS:
	MOV	AL,BYTE PTR B$DRWFLG ;SEE WHETHER WE PLOT OR NOT
	ADD	AL,AL		;CHECK HI BIT
	JB	DSTPOS		;JUST SET POSITION.
	PUSH	AX		;SAVE THIS FLAG
	PUSH	BX		;Save fractional x,y
	PUSH	CX		;SAVE X,Y COORDS
	PUSH	DX		;BEFORE SCALE SO REFLECT DISTANCE OFF
	CALL	B$CLINE2
	POP	DX
	POP	CX		;GET THEM BACK
	POP	BX
	POP	AX		;GET BACK FLAG
DSTPOS:
	ADD	AL,AL		;SEE WHETHER TO STORE COORDS
	JB	DNSTOR		;DON'T UPDATE IF B6=1
	MOV	B$GRPACY,DX	;UPDATE GRAPHICS AC
	MOV	B$GRPACX,CX
	MOV	WORD PTR [B$DFRACX],BX ;Store fractional x,y
DNSTOR:
	MOV	BYTE PTR B$DRWFLG,0 ; CLEAR SPECIAL FUNCTION FLAGS
	RET


DNOMOV:
	MOV	AL,64		;SET BIT SIX IN FLAG BYTE
	JMP	SHORT DSTFLG
DNOPLT:
	MOV	AL,128		;SET BIT 7
DSTFLG:
	OR	BYTE PTR B$DRWFLG,AL ;STORE UPDATED BYTE
	RET

DPAINT:

;	Initialize the paint queue without compacting it.

	cCALL	B$INTQNOCPCT	; Initialize it w/o compaction
	XOR	AL,AL
	MOV	BYTE PTR B$TILNDX,AL ;Clear Tile index
	MOV	BYTE PTR B$TIPROG,AL ;Clear Tile proceed flag
	MOV	BYTE PTR B$TILFLG,AL ;Initially no FG_TILE
	MOV	BYTE PTR $BGTNUL,AL ;Setup Null BG FG_TILE pattern
	CALL	B$VALSCN 	;GET Fill color
	PUSH	DX		;SAVE IT
	CALL	B$FETCHZ 	;NOW CHECK FOR COMMA
	CMP	AL,','		;COMMA?
	JZ	DPAIN2
	JMP	B$ERR_FC
DPAIN2:
	CALL	B$VALSCN 	;[DX]= Border Color
	POP	AX		;[AL]= fill color
	PUSH	DX		;In case SetAttr trashes DX
	CALL	[b$SetAttr]	;Set Fill attribute
	POP	DX
	JB	NCFCER		;Brif illegal
	MOV	AL,DL		;[AL]= Border color
	CALL	B$PaintInit	;Init Paint, check border attr
	JB	NCFCER		;Brif illegal
	MOV	CX,[B$GRPACX]	;[CX]= x
	MOV	DX,[B$GRPACY]	;[DX:= y
;The label PNTDRW no longer exists due to restructuring of PAINT statement
;12/7/83 JMB
;	JMP	PNTDRW		;Do the PAINT..
	CALL	B$INVIEW
	JNB	PAIRET		;Exit if out of FG_VIEW
	CALL	[b$MapXYC]	;Graphics cursor:=(CX,DX)
	JMP	B$PAINTBEG	;Go Paint it

DSCALE:
	JNB	NCFCER		;FC ERROR IF NO ARG
	CMP	DX,256		;MAKE SURE LESS THAN 256
	JNB	NCFCER
	OR	DX,DX
	JZ	NCFCER		;DONT ALLOW SCALE OF ZERO
	MOV	BYTE PTR B$DRWSCL,DL ;STORE SCALE FACTOR
PAIRET: 			;Early return from paint in draw
	RET

NCFCER:				; moved here to fix jump out of range
	JMP	B$ERR_FC

DSCLDE:
	MOV	AL,BYTE PTR B$DRWSCL ;GET SCALE FACTOR
	OR	AL,AL		;ZERO MEANS NO SCALING
	JNZ	DSCLD0
	RET
DSCLD0:
	MOV	BX,0
DSCLP:
	ADD	BX,DX		;ADD IN [DX] SCALE TIMES
	DEC	AL
	JNZ	DSCLP
	XCHG	DX,BX		;PUT IT BACK IN [DX]
	MOV	AL,DH		;SEE IF VALUE IS NEGATIVE
	ADD	AL,AL
	PUSHF			;SAVE RESULTS OF TEST
	JNB	DSCPOS
	DEC	DX		;MAKE IT TRUNCATE DOWN
DSCPOS:
	SHR	DX,1		;DIVIDE BY FOUR
	SHR	DX,1
	POPF			;SEE IF WAS NEGATIVE
	JNB	DSCPOX		;ALL DONE IF WAS POSITIVE
DSCPO1:
	OR	DH,192		;OR IN HIGH 2 BITS TO MAKE NEGATIVE
	INC	DX		;ADJUST SO TRUNCATING TO LOWER VALUE
DSCPOX:
	RET
DCOLR:
	JNB	NCFCER		;FC ERROR IF NO ARG
	MOV	AL,DL		;GO SET ATTRIBUTE
	CALL	[b$SetAttr]	
	JB	NCFCER		;ERROR IF ILLEGAL ATTRIBUTE
	RET


DANGLE:
	JNB	NCFCER		;ERROR IF NO ARG
	CMP	DL,4		;MAKE SURE LESS THAN 4
	JNB	NCFCER		;ERROR IF NOT
	MOV	AL,90		;Map B$DRWANG 0,1,2 or 3
	MUL	DL		;    to 0,90,180 or 270 degrees
	MOV	DX,AX
	JMP	SHORT TANGL1
TANGLE:
	CALL	B$FETCHZ 	;Get char after "T"
	CMP	AL,'A'		;Must be Angle
	JNZ	NCFCER		;else error
	CALL	B$VALSCN 	;[DX]= degrees
	MOV	AX,360
	OR	DX,DX		;See if negative
	JNS	TANGL0
	ADD	DX,AX		;neg so add 360 (let 'em go backwards)
TANGL0:
	CMP	AX,DX		;Must be .le. 360 degrees
	JB	NCFCER		; else error..
TANGL1:
;IFN	 SCNROT,<
;	 CALL	 SCNDIR
;	 JZ	 NoARot 	 ;Screen is horizontal
;	 SUBI	 DX,360d	 ;Swap X and Y
;	 NEG	 DX
;NoARot:
;>				 ;IFN FG_SCRNROT
	MOV	BYTE PTR B$DRWANG,DL
	MOV	BX,DX


	CALL	B$fmldw		; push [BX] to ST0
	FMUL	FP_PI180	; RAD(ang)= ang*(PI/180)
	FLD	ST(0)		; duplicate this on numeric stack
	CALL	B$COS4 		; ST0 = cos((Rad(ang))
	FSTP	DWORD PTR B$COSA ; B$COSA= COS((Rad(ang)), ST1 = Rad(ang)
	CALL	B$SIN4 		; Take Sin
	FLD	ST(0)		; duplicate SIN((Rad(ang)) on numeric stack
	CALL	GTASPF		; Get Aspect in [CXDX]
	CALL	B$fmlds		; load aspect to numeric stack
	FMUL		  ; ST0 = SIN((Rad(ang))*Aspect,ST1 = SIN(Rad(ang))
	FCHS		  ; ST0 = -SIN((Rad(ang))*Aspect, ST1 unchanged
	FSTP	DWORD PTR B$MSINA ; B$MSINA= -SIN((Rad(x))*Aspect
	CALL	B$fmlds		; ST0 = Aspect, ST1 = SIN(Rad(ang))
	FDIV			; ST0 = SIN((Rad(ang))/Aspect
	FSTP	DWORD PTR B$DSINA ; B$DSINA= SIN((Rad(ang))/Aspect
	FWAIT			
	RET			

;FMULDX
;Purpose:
;	Given an integer in DX and the address of a s.p. number in BX,
;	multiply the two numbers, leaving the result on top of numeric stack
;Entry:
;	DX contains an integer operand
;	BX is a pointer to an s.p. operand
;Exit:
;	ST0 contains the result of the multiplication
;Preserves:
;	SI, DI
FMULDX: 			
	PUSH	BX		
	MOV	BX,DX		
	CALL	B$fmldw		; push number on numeric stack
	POP	BX		
	FMUL	DWORD PTR [BX]	; multiply s.p. number time integer
	RET			

;FADARG
;Purpose:
;	Given an integer in DX and the address of a s.p. number in BX,
;	multiply the two numbers, with the result in ST0. Next,
;	add arguments at ST0 and ST1. Scale result by 2^8 (i.e., multiply
;	by 256), put 24-bit result in CX,AL (also in DX,AX)
;Entry:
;	DX contains an integer operand
;	BX is a pointer to an s.p. operand
;Exit:
;	CX,AL contains 24-bit result.
;Preserves:
;	SI, DI
FADARG:
	CALL	FMULDX		; multiply integer in DX by s.p. # at [BX]
	FADD			; ST0 = ST0 + ST1
	FMUL	b$FP_256	; scale result by 2^8 (i.e., mult. by 256)
	CALL	B$ftolrnd	; round, pop from ST0, get result in DX:AX
	MOV	CH,DL		
	MOV	CL,AH		; in [CX,AL]
	RET			


GTASPF:
	MOV	CX,WORD PTR [B$ASPRF+2]
	MOV	DX,WORD PTR [B$ASPRF]
	RET


sEnd	GR_TEXT 		
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\dkutil.asm ===
TITLE	DKUTIL - Disk/Device I/O Utility Routines
	page	56,132
;***
; DKUTIL - Disk/Device I/O Utility Routines
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This module contains utility routines and dispatch tables
;	used by both disk and device I/O routines.  It will be
;	present in a user program containing any disk or device
;	I/O statements.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

;Code segments:
	useSeg	NH_TEXT 	;near heap
	useSeg	ER_TEXT 	;error handling
	useSeg	CN_TEXT 	;console I/O
	useSeg	DV_TEXT 	;device independent I/O
	useSeg	RT_TEXT 	;runtime core

;Data segments:
	useSeg	_DATA		;initialized variables
	useSeg	_BSS		;uninitialized variable

	INCLUDE seg.inc 	;set up segments
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE ascii.inc
	INCLUDE idmac.inc
	INCLUDE const.inc
	INCLUDE rtps.inc	;constants shared with QBI

	SUBTTL	local constant definitions
	page

	TTY	EQU	0	;default b$PTRFIL is TTY

	PRSTM	EQU	0	;print statement
	CHANL	EQU	1	;#
	USING	EQU	2	;using
	WRSTM	EQU	4	;write statement
	LPSTM	EQU	8	;lprint statement


	SUBTTL	data definitions
	page

sBegin	_DATA			;initialized variables
	globalW b$pDevTable,DevTable,1 ;pointer to device table
	externB b$PRFG 	;print flag (in PRNVAL.ASM), may be combined
				; from below:
				;0: PRINT stmt
				;1: # (channel)
				;2: USING
				;4: WRITE stmt
				;8: LPRINT stmt
				;e.g. 3 means PRINT # USING

	externB b$IOFLAG	;Misc. IO flags.  Defined in GWINI.ASM
	externB b$BAS_EXT	;defined in FILENAME.ASM

sEnd				;end of _DATA

sBegin	_BSS			;uninitialized variables

	globalW b$RECPTR,,2	;User define type (record) pointer
	staticW DispAddr,,1	;kept the dispatch address


	globalB b$EOL,,1	;set when in B$$WCLF

	externW b$PTRFIL	;defined in global.inc
	externB b$FILMOD	;defined in GWINI.ASM
	externB b$PATHNAM	;defined in GWINI.ASM
	externW b$Buf2		;defined in GWINI.ASM
	PATH_LEN EQU b$Buf2	;save area for pathname length
				;sort of a waste, but convenient

	externB b$LPTFDB
	externB b$Chaining
	externW b$CLOS_FDB
	externW b$CLOS_HANDLE	
sEnd	;_BSS

	SUBTTL	code segments externals
	page

sBegin	NH_TEXT 		;near heap
	externNP	B$LHFDBLOC
	externNP	B$LHNXTFIL
	externNP	B$STDALCTMP	
sEnd

sBegin	ER_TEXT 		;error code component
	externNP B$ERR_BFM
	externNP B$ERR_IFN
	externNP B$ERR_BFN
	externNP B$ERR_FAO
	externNP B$ERR_FC

	externNP B$ERR_RVR	;Record variable required
sEnd

sBegin	CN_TEXT 		;console I/O
	externNP	B$TTY_SINP
	externNP	B$TTY_SOUT
	externNP	B$TTY_GPOS
	externNP	B$TTY_GWID
	externNP	B$TTY_BLKIN
	externNP	B$TTY_BLKOUT
	externNP	B$TYPSTR1
sEnd

sBegin	DV_TEXT 		;device I/O
	externNP	b$dkused	;to pull in dkinit...
	externNP	B$GET_PATHNAME
	externNP	B$GET_DEV_NUM
	externNP	B$ADD_EXT
	externNP	B$STDGET
sEnd

sBegin	RT_TEXT 			;runtime core
	externNP	B$LHDALC_CPCT	;Deallocate FDB and compact
sEnd


assumes cs,DV_TEXT
sBegin	DV_TEXT


;*** 
;DoClose -- perform device close function.
;
;Purpose:
;	Closes a file.  Saves a bit of code by setting close function flag
;	and falling into B$PtrDispatch.
;
;Entry:
;	[SI] =	pointer/handle to FDB
;Exit:
;	None
;Uses:
;	Per convention
;
;Exceptions:
;	Many -- from individual close routines
;
;******************************************************************************
cProc	DoClose,<NEAR>
cBegin
	MOV	AH,DV_CLOSE	; dispatch to close routine
cEnd	<nogen>			; fall into B$PtrDispatch

;***
;B$PtrDispatch -- dispatch according to the device number in the FDB
;B$DevDispatch -- dispatch according to the device number specified
;
;Purpose:
;	Dispatch to the desired I/O routine for devices.
;	B$PtrDispatch first gets device number from file control block, and
;	then does the same thing as B$DevDispatch.
;Entry:
;	[AH] =	function number (minor #)
;
;	if B$PtrDispatch then
;		[SI] =	pointer/handle to FDB
;		BX,CX,DX may contain other parameters needed by dispatched
;		function
;
;	if B$DevDispatch then
;		[AL] =	device number (major #)
;		when B$DevDispatch is called from Open functions:
;			[BX] =	file number
;			[CX] =	record length (0 is default)
;			[DX] =	*sd of file name
;			[b$ACCESS]  =	access right
;			[b$LOCKTYPE] = lock type
;
;	AX,BX,CX,DX & SI are reserved and passed to the dispatched routine.
;	DI contains the address of dispatched routine.
;
;Exit:
;	AX-DX as returned by dispatched routines
;Uses:
;	none
;Exceptions:
;	Many -- by the dispatched routines
;*******************************************************************************

cProc	B$PtrDispatch,<NEAR,PUBLIC>,<DI,SI> 
cBegin
DbAssertRel SI,NE,0,DV_TEXT,<B$PtrDispatch: NULL FDB pointer>	
	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB
	PUSH	AX		;save AX (popped later)
	MOV	AL,FileDB.FD_DEVICE ;[AL] = device number (0 for disks)
CommDisp:			;common routine for Ptr/Dev dispatch
	NEG	AL		;since device number is -1 to -n
	CBW			;extend to word (i.e. make AH=0)
	SAL	AX,1		;AX = device table offset (word entries)
	MOV	DI,[b$pDevTable] ;DI = device table address
				; [DI] = byte count of table 
	CMP	AX,CS:[DI]	; is offset within range of device table?
	JB	TableOK		; brif so -- no problem
DbHalt	DV_TEXT,<Uninitialized dispatch table in B$PtrDispatch>	
externNP B$ERR_DNA		
	JMP	B$ERR_DNA	; give device unavailable error
				; NOTE:  THIS SHOULD NEVER HAPPPEN!!!

TableOk:			
	INC	DI		; DI = pointer to device table
	INC	DI		
	XCHG	AX,BX		;use BX for table reference
	MOV	DI,CS:[DI+BX]	;get pointer to dispatch table for device
	XCHG	BX,DI		;DI = offset, BX = pointer to dispatch table
	XCHG	AX,BX		;restore BX to entry value, AX = disp table ptr
	MOV	[DispAddr],AX	;save it in mem-loc

	POP	AX		;[AH] = function number
	PUSH	AX		;save function number & device number
	XCHG	AH,AL		;[AL] = function number
	CBW			;convert to word (make AH=0)
	PUSH	DI		;save DI
	MOV	DI,[DispAddr]	;get addr of device dispatch table
	ADD	DI,AX		;add function code offset to dispatch
	MOV	AX,CS:[DI]	;get the address of routine
	MOV	[DispAddr],AX	;store in [DispAddr]
DbAssertRel	AX,NZ,0,DV_TEXT,<0 value in dispatch table in B$PtrDispatch>
	POP	DI		;get back DI
	POP	AX		;get back AX
	CALL	[DispAddr]	;dispatch & execute routine
				;[AL]=device #, [AH]=function #
				;[DI]=offset to dispatch table
				;if B$PtrDispatch, (ES:)[SI]=*FDB
				;if B$DevDispatch called from B$OPENIT,
				;  [BX]=file number, [CX]=record length,
				;  [DX]=*sd of file name
cEnd				;exit to caller

cProc	B$DevDispatch,<NEAR,PUBLIC>,<DI,SI> ;match to B$PtrDispatch
cBegin
	PUSH	AX			;save AX (popped later)
	JMP	SHORT CommDisp		;jump to common code
cEnd	<nogen> 			;exit via B$PtrDispatch


	SUBTTL	open supporting routines
	page
;***
;B$OPENIT -- common routine for both open interfaces
;
;Purpose:
;	This routine checks the validity of the file name and file number,
;	and also checks whether the channel has already been opened.  If
;	none has problem, it dispatches to the actual device opening routine.
;Entry:
;	AX		= open mode
;	BX		= channel (file number)
;	CX		= record length
;	DX		= *sd of file name
;	[b$ACCESS]	= access right
;	[b$LOCKTYPE]	= locking mode
;
;	Please refer to the procedure head comments of B$OPEN for the detail
;	description of the values for channel, record length, access & lock.
;Exit:
;	b$PTRFIL is reset
;	string decscriptor deallocated
;Uses:
;	per convention
;Exceptions:
;	(1) file name error	-- Bad file name (B$ERR_BFN)
;	(2) access & locking	-- Path/file access error
;				-- Permission denied
;	(3) file number 	-- Illegal file number (B$ERR_IFN)
;	(4) general		-- File already open (B$ERR_FAO)
;				-- File not found (B$ERR_FAO)
;	(5)record number	-- illegal function call (B$ERR_FC)
;*******************************************************************************

cProc	B$OPENIT,<PUBLIC,NEAR>,<SI>	;save SI

cBegin


	MOV	[b$FILMOD],AL	;save mode for further use
	PUSH	CX		;save record length
	cCall	B$CHKNAM	;check valid file name and file number,
				; on return BX = valid file number and
				; AL = device # (major #) for dispatch
				; file name is saved in b$PATHNAM
	CALL	B$LHFDBLOC	;if file found for the given file number (in
				; BX), SI=*FDB and NZ
	JNZ	ERCFAO		;Brif file already open
	POP	CX		;record length in CX
	INC	CX		;test for rec len = -1 (default)
	JZ	DefRec		;go for default converted to 0 value
	DEC	CX		;restore true rec len
	OR	CX,CX		; Overflow flag might have been set by
				; decrement (for 8000 ==> 7FFF).
	JLE	ERCFC		;go if len <= 0 (illegal func call)
DefRec: 			
	MOV	AH,DV_OPEN	;AH = routine # (minor #) for dispatch
	CALL	B$DevDispatch	;dispatch it
	MOV	[b$PTRFIL],TTY	;reset pointer to FDB


cEnd				;pop SI and exit

ERCFC:	JMP	B$ERR_FC	;illegal function call

;***
;B$CHKNAM -- scan file name & file number
;
;Purpose:
;	Check the validity of file name & file number, if both are good,
;	get the device number (major #) for dispatching.
;	If the name is for file 0 (BLOAD/BSAVE) then this routine appends the
;	extention ".BAS" to the filename if it doesn't already have one.
;Entry:
;	BX	= file number
;			-1		internal file
;			1-255		valid file number
;			0,256-65534	invalid file number
;	DX	= *sd of file name
;Exit:
;	AL	= device number (result from B$GET_DEV_NUM)
;	BX	= 0	if used as an internal file (BLOAD/BSAVE ...)
;		= 1-255 valid file number
;	CX	= count of chars (including null) in pathname
;	for disk files, 
;		[b$PATHNAM] = fully-specified, null-terminated pathname
;	for devices,
;		[b$PATHNAM] = null-terminated option string (including "XXXX:")
;Uses:
;	AH
;Exceptions:
;	Bad file name		(B$ERR_BFN)
;	Illegal file number	(B$ERR_IFN)
;*******************************************************************************

cProc	B$CHKNAM,<NEAR>,<SI,DI,ES>

cBegin
	XCHG	DX,BX		;DX = file number, BX = psdFileName
	MOV	DI,OFFSET DGROUP:b$PATHNAM ;destination to store pathname
	PUSH	DS		; set ES=DS
	POP	ES		
	MOV	CX,[BX] 	; get count of chars in string
	JCXZ	ERCIFN		;brif null filename -- Bad file number
				;Yes, this is a stupid message, but its
				;required for compatability reasons.
	CALL	B$GET_DEV_NUM	;check for device, placing device # in AL
				;and device option string in b$PATHNAM
	JZ	NOT_DEVICE	;brif not device -- process name

	MOV	SI,[BX+2]	; get start address
	PUSH	CX		;save count
	REP	MOVSB		;copy the string into b$PATHNAM
	MOV	[DI],CL		;null-terminate the string
	POP	CX		;restore count (doesn't include null)
	INC	DX		;file # = -1 (BLOAD/BSAVE)?
	JZ	ERCFC		;brif so -- devices not valid for BLOAD/BSAVE
	JMP	SHORT CHK_NUMBER

NOT_DEVICE:
	CALL	B$GET_PATHNAME	;scan filename and store pathname in *[DI]
				;AL = return flags
				;CX = len of pathname (including null)
	TEST	AL,FN_WILD	;wildcard in pathname?
				;filename detected?
	JNZ	ERCBFN		;Brif yes, give "Bad file name"

	INC	DX		;-1 is interal use (BSAVE/BLOAD), change to 0
	JNZ	NotFile0	;Brif not for Bload/Bsave
				;BLOAD and BSAVE need to append '.BAS' to
				;pathname if it doesn't have an extention

				;CX and AL preserved from B$GET_PATHNAME
	MOV	SI,OFFSET DGROUP:b$BAS_EXT ;append ".BAS" extention to
	CALL	B$ADD_EXT	;pathname if no extention present.  Also
				;checks for pathname overflow, and updates
				;count in CX
	XOR	AL,AL		;indicate disk device
	JMP	SHORT SCANX	;exit

NotFile0:			;check file number
	XOR	AL,AL		;indicate disk device
CHK_NUMBER:
	DEC	DX		;get back file number, file # = 0?
	JZ	ERCIFN		;Brif so, give "illegal file number"
	OR	DH,DH		;is greater than 255 ?
	JNZ	ERCIFN		;illegal file number
SCANX:
	CALL	B$STDALCTMP	; dealloc string if temp (all regs saved)
	MOV	PATH_LEN,CX	;save count until dispatched to xxxx_OPEN
	XCHG	DX,BX		;return file number in BX
cEnd


ERCFAO: JMP	B$ERR_FAO	;File already open
ERCBFN: JMP	B$ERR_BFN	;Bad file name
ERCIFN: JMP	B$ERR_IFN	;illegal file number

	SUBTTL	close interface -- B$CLOS
	PAGE
;***
;B$CLOS -- close statement
;viod B$CLOS(I2 channel, I2 channel, ..., cParams)
;
;Purpose:
;	This is the interface of CLOSE statement.  In BASCOM 2.0, there are
;	two interfaces, $DCA and $DKC to handle the close.  $DCA closes all
;	files (no parameter given in CLOSE stmt), and $DKC closes the files
;	given.	In BASCOM 3.0, only one interface is used.  Parameters were
;	pushed in stack with the parameter count followed.
;
;	Note: cProc with PLM convention can't handle variable parameters.  In
;	this routine, enter and exit have to be special handled.
;
;	The following is one of the proposed method to handle variable
;	parameters.
;
;cProc	Name,<PUBLIC,FAR>,<DI>	;save DI
;	ParmW	UnknownParam	;potential parameter, NOTE:  MUST use
;				; "cEnd nogen" at the end of the procedure
;				; and handle exit process explicitly
;	ParmW	cParam		;parameter count, last parameter
;
;cBegin 			;use DI as the pointer to walk in the stack
;				;(SI or BX will be another candidate as the
;				; walking register, however if BX is used,
;				; user has to make sure BX won't be changed
;				; within the routine)
;	.
;	.			;save other registers
;	.
;	LEA	DI,UnknownParam ;DI points to one below the parameter count
;	MOV	CX,cParam	;CX has the parameter count
;	JCXZ	NoParm		;no parameter
;ParmLoop:
;	MOV	BX,[DI] 	;get parameter in BX (for example)
;	.
;	.			;do whatever needed for each parameter
;	.
;	ADD	DI,2		;DI points to next parameter
;	LOOP	Parameter_Loop
;NoParm:
;	.
;	.			;do whatever needed for no parameter
;	.
;ExitProc:
;	.			;restore registers if any
;	.
;	MOV	SP,DI		;clean stack
;	MOV	DI,[BP-2]	;get back DI
;	LEA	BX,[BP+2]	;bx=*return addr
;	MOV	BP,[BP] 	;get back BP
;	JMP	DWORD PTR [BX]	;return to caller
;cEnd	nogen			;no code generated
;
;Entry:
;	Parameters were pushed in stack.
;	int	channel
;		.
;		.
;		.
;	int	channel
;	ushort	cParams
;Exit:
;	clears b$PTRFIL
;	none
;Uses:
;	none
;Exceptions:
;	list of possible abnormal exit points (i.e. FCERR)
;*******************************************************************************

				;NOTE!: This routine has a manually
				;generated epilogue due to variable number
				;of parameters.  If you change the prologue,
				;here you must also change the epilogue
				;further down.

cProc	B$CLOS,<PUBLIC,FAR>	; don't save any registers here
	ParmW	UnknownParam	;potential parameter
	ParmW	cParam		;parameter count
cBegin				;generate stack frame
	PUSH	SI		;save SI and DI explicitly to avoid confusion
	PUSH	DI		
	LEA	DI,UnknownParam ;DI points to the one below parameter count
	MOV	CX,cParam	;CX=*cParam
	JCXZ	NoParm		;no parameter, close all files
ParmLoop:
	MOV	BX,[DI] 	;file number in BX
	CALL	B$LHFDBLOC	;SI=*FDB (NZ) if file found
	JZ	NextParm	;file not opened, go next one
	CALL	DoClose 	;process the close
NextParm:
	INC	DI		;next parameter
	INC	DI
	LOOP	ParmLoop	;loop until all done
	JMP	SHORT ExitProc	;clear stack and exit
NoParm:
	CALL	B$CLOSF		;close all files (destroys all registers)
ExitProc:
	MOV	BX,DI		; BX = old SP
	POP	DI		; get back DI
	POP	SI		;get back SI
	MOV	AX,[BP+2]	; [DX:AX] = return address
	MOV	DX,[BP+4]	
	MOV	BP,[BP] 	; get back old BP
	MOV	SP,BX		; clean the stack LAST, so that interrupts
				; don't bash stuff below the SP
	MOV	[b$PTRFIL],0	;clear b$PTRFIL
	PUSH	DX		;put return address back on stack
	PUSH	AX
	RET			;return to caller
cEnd	nogen			;no code generated

	SUBTTL	Runtime Internal routines
	page

;_____	File Dispatch Routines	-------------------------------------------

	page
;***
;B$$RCH - Read a byte
;DBCS-callback
;
;Purpose:
;	Reads a byte of data from the device designated by b$PTRFIL.
;	If we are handling KANJI characters, we have to disassemble
;	them as they come from B$STDGET (when b$PTRFIL == 0).  B$STDGET
;	will return the entire 2 byte character, while we only want to
;	return a single byte.
;
;Entry:
;	b$PTRFIL set properly
;
;Exit:
;	AL = character
;	AH = trashed
;	PSW.C set if no char ready
;	PSW.Z set if no char ready and FO_REDIRECT
;		(this will only happen if redirected input completely read)
;Uses:
;	Per Convention
;
;Preserves:
;	BX, CX, DX
;
;Exceptions:
;	None.
;****
cProc	B$$RCH,<NEAR,PUBLIC>
cBegin
	PUSH	SI
	MOV	SI,b$PTRFIL
	OR	SI,SI
	JNZ	getch1

	TEST	b$IOFLAG,RED_INP ;Input redirected ?
	jz	getch0		;brif not
	call	B$STDGET	;AX = value, PSW.Z set = no valid byte
	POP	SI
	ret
getch0:
	CALL	B$TTY_SINP	;Console input
	JMP	SHORT GETCH2

GETCH1:
	MOV	AH,DV_SINP	;file input
	CALL	B$PtrDispatch

GETCH2:
	POP	SI		; restore register
	JC	GETCH3		;branch if PSW.C set
	OR	SP,SP		; Clear PSW.Z
	RET
GETCH3:
	OR	SP,SP		; clear PSW.Z (and PSW.C)
	STC			; but set PSW.C again
cEnd				; return to caller

;***
; B$$WCH - Output character in (AL)
;
;	Inputs:
;		al = character to output
;		b$PTRFIL
;		DV_SOUT
;	Outputs:
;		none
;	Modifies:
;		ah
;	Exceptions
;		exit through B$TTY_SOUT
;		Bad file mode for binary files
;****
cProc	B$$WCH,<NEAR,PUBLIC>
cBegin
	PUSH	SI
	MOV	SI,b$PTRFIL
	OR	SI,SI
	JNZ	putch1

; Redirected output must be done after two byte codes collected. Move check
; for redir out to B$TTY_SOUT.

	POP	SI
	JMP	B$TTY_SOUT	;Console output

PUTCH1:
	FDB_PTR ES,SI,SI		;(ES:)[SI] = *FDB
	TEST	FileDB.FD_MODE,MD_BIN	;binary mode?
	JZ	NotBinary
	JMP	B$ERR_BFM	;brif so -- bad file mode
NotBinary:
	MOV	AH,DV_SOUT

ptrdsp: CALL	B$PtrDispatch	;Call Dispatch |Moved here from
	POP	SI		;Restore SI    |B$$BCH which is
cEnd				;and return    |no longer in existance

	page
;***
; B$$POS - Get current file position
;
;	Inputs:
;		b$PTRFIL
;		DV_GPOS
;	Outputs:
;		ah = file position
;	Exceptions
;		Exit through B$TTY_GPOS or PTRDSP
;****
cProc	B$$POS,<NEAR,PUBLIC>
cBegin
	PUSH	SI
	MOV	SI,[b$PTRFIL]
	OR	SI,SI
	JNZ	getps1

	POP	SI
	JMP	B$TTY_GPOS	;Get TTY position

getps1: MOV	AH,DV_GPOS	;Get position
	JMP	ptrdsp
cEnd	<nogen>

	page
;***
; B$$WID - Get current file width
;
;	Inputs:
;		b$PTRFIL
;		$DV_GWID
;	Outputs:
;		ah = file width
;	Exceptions:
;		Exit though B$TTY_GWID or PTRDSP
;****
cProc	B$$WID,<NEAR,PUBLIC>
cBegin
	PUSH	SI
	MOV	SI,[b$PTRFIL]
	OR	SI,SI
	JNZ	getwd1

	POP	SI
	JMP	B$TTY_GWID

getwd1: MOV	AH,DV_GWID
	JMP	ptrdsp
cEnd	<nogen>

	SUBTTL
	PAGE
;***
;   B$BIN - block input
;							;block transfer support
;	Entry	[bx] =	offset of destination		;for bload, bsave
;		[cx] =	maximum number of bytes to read
;		[dx] =	DS of destination
;	exit	?
;****
cProc	B$BIN,<NEAR,PUBLIC>
cBegin
	PUSH	SI
	MOV	SI,[b$PTRFIL]
	OR	SI,SI
	JNZ	blkin1

	POP	SI
	JMP	B$TTY_BLKIN

blkin1: MOV	AH,DV_blkin
	JMP	ptrdsp
cEnd	<nogen>

;***
;B$BOT - Block output
;							;block transfer support
;	Entry	[bx] =	offset of destination		;for bload, bsave
;		[cx] =	number of bytes to write
;		[dx] =	DS of destination
;****

cProc	B$BOT	<NEAR,PUBLIC>
cBegin
	PUSH	SI
	MOV	SI,[b$PTRFIL]
	OR	SI,SI
	JNZ	blkot1

	POP	SI
	JMP	B$TTY_BLKOUT

blkot1: MOV	AH,DV_blkout
	JMP	ptrdsp
cEnd	<nogen>

	PAGE
CRLF_LEN= 2			;Length of CR/LF sequence on disk


;   Moved here from out.asm

;***
;B$$WCLF - Write new line
;
;	USES	F
;
;****

cProc	B$$WCLF,<NEAR,PUBLIC>,<AX,BX,SI>
cBegin
	MOV	b$EOL,1		; processing end-of-line
	MOV	SI,[b$PTRFIL]
	OR	SI,SI		;Check for keyboard output
	JZ	wcspec		;  Yes - do special CR/LF
	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB

	TEST	FileDB.FD_DEVICE,80H	;Test for special device
	JZ	WCLF_NOT_SPEC		;If not, then jump

	MOV	AL,ASCCR	;get carriage-return
	CALL	B$$WCH		;and output it
	CMP	FileDB.FD_DEVICE,DN_SCRN ;Test if SCRN device
	JE	NO_OUTPUT_LF	;If so, do not output Linefeed

	CMP	FileDB.FD_DEVICE,DN_COM1 ;test against first COM
	JG	OUTPUT_LF	;if before, then output LF
	CMP	FileDB.FD_DEVICE,DN_LPT1 ;test against last COM
	JG	NO_OUTPUT_LF	;if within COM, jump
OUTPUT_LF:
	mov	al,asclf	; get line feed
	call	B$$WCH		; and output it
NO_OUTPUT_LF:
NOTSPEC:
	JMP	SHORT WCLXT	;jump to exit
WCLF_NOT_SPEC:

	CMP	FileDB.FD_MODE,MD_RND	;Check for random
	JNE	wcdisk		;  No - do disk CR/LF
	TEST	b$PRFG,WRSTM	;WRITE statement?
	JZ	wcdisk		;brif not -- just do disk CR/LF

	MOV	BX,FileDB.FD_VRECL  ;Get field length
	SUB	BX,FileDB.FD_BUFCNT ;Subtract off bytes already written
	SUB	BX,CRLF_LEN	;    and two more for CR/LF
	MOV	AL,' '		;Write (BX) spaces

;	This is tricky because DISK_SOUT will give FOV error if
;	(BX) is negative.

wspc:	JZ	wcdisk		;(BX) = 0 - done
	CALL	B$$WCH		;Write space
	DEC	BX		;Decrement (BX)
	JMP	wspc		;Keep on looping until (BX) = 0

wcdisk:
	MOV	AL,ASCCR
	CALL	B$$WCH		;Output CR
	MOV	AL,ASCLF
	CALL	B$$WCH		;Output LF
	JMP	SHORT wclxt

wcspec: MOV	AL,ASCCR	;Output CR only
	CALL	B$$WCH

wclxt:
	MOV	b$EOL,0		; reset to FALSE
cEnd

;***
; B$PRTSTR, B$PRT_TYPCNT, B$PRT_OUTCNT - Type string given descriptor
; Inputs:
;	BX = Address of string descriptor
; Outputs:
;	None.
; Modifieis:
;	CX,SI,AX,F destroyed.
;****

cProc	B$PRTSTR,<NEAR,PUBLIC>
cBegin
	MOV	CX,[BX]		; [CX] = string length

labelNP <PUBLIC,B$PRT_TYPCNT>
	MOV	SI,[BX+2]	; DS:SI = data ptr
	JCXZ	RETL
	push	si		
	MOV	SI,b$PTRFIL
	OR	SI,SI		;is there an open file?
	JZ	PRT_STR_SCRN	;brif not - - - print to screen
	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB
	CMP	FileDB.FD_DEVICE,DN_SCRN    
	JZ	PRT_STR_SCRN	;brif file is opened to the screen
	pop	si		

labelNP <PUBLIC,B$PRT_OUTCNT>
	LODSB			; AL = char
	CALL	B$$WCH		; output char
	LOOP	B$PRT_OUTCNT
RETL:				
cEnd				

PRT_STR_SCRN:
	pop	si		
	JMP	B$TYPSTR1	;print this to the screen

;*** 
; B$CLOSF - Close all files.
;
;Purpose:
;	Close all open files.
;Entry:
;	None
;Exit:
;	None
;Uses:
;	Per convention
;Exceptions:
;	None
;******************************************************************************
cProc	B$CLOSF,<NEAR,PUBLIC>,<SI>
cBegin
	CMP	b$Chaining,0	; Are we chaining?
	JNZ	CLOSF_EXIT	;scram if so - don't close em
CLOSF_LOOP:
	XOR	SI,SI		; flag to get first file
	CALL	B$LHNXTFIL	; SI = next FDB pointer
	JZ	CLOSF_END	; brif no more files -- exit loop
CLOSF_CLOSE:
	CALL	DoClose		; process the close
	JMP	SHORT CLOSF_LOOP ; do the next one

CLOSF_END:
	MOV	SI,OFFSET DGROUP:b$LPTFDB ; SI = LPRINT FDB
	TEST	FileDB.FD_FLAGS,FL_LPT_OPN  ;LPRINT open?
	JE	CLOSF_EXIT	; brif not -- just exit
	AND	FileDB.FD_FLAGS,NOT FL_LPT_OPN	;clear the open flag
	CALL	DoClose		; do the close (doesn't deallocate b$LPTFDB)
CLOSF_EXIT:
cEnd


;***
;DevTable -- device dispatch table
;
;Purpose:
;	Device dispatch table for disk only, generated by DEVMAC macro,
;	is used to select the individual device dispatch table (which
;	can only be disk in this case).  If devices are brought in as
;	well, this table is replaced (during one-time initialization in
;	dvinit) with a full disk/device table.
;	Note:	DEVMAC redefins DEVMAC in devdef.inc.
;Entry:
;	none
;Exit:
;	DevTable is set up
;Uses:
;	none
;*******************************************************************************

DEVMAC	MACRO	DeviceName
	externW	B$D_&DeviceName
	DW	B$D_&DeviceName	;;each entry is the address of
	ENDM			;; individual device table

labelW	DevTable		;device table
	DW	2		; # of bytes in table (for error checking)
	DEVMAC	DISK		; generate entry for disks


;*** 
;B$TEST_CLOSE.
;
;Purpose:
;
;Entry:
;
;Exit:
;
;Uses:
;
;Preserves:
;	All
;Exceptions:
;	Possible INT 24 error upon close (?)
;
;******************************************************************************
cProc	B$TEST_CLOSE,<NEAR,PUBLIC>,<SI,BX>	
cBegin

	MOV	BX,b$CLOS_HANDLE ; get handle to close
	OR	BX,BX		; coming from the open code?
	JNZ	CloseIt		; brif so
	MOV	SI,b$CLOS_FDB	;get FDB entry if closing file
	OR	SI,SI		;test if truly closing the file
	JZ	TEST_CLS_DONE	;if not, then just return
	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB
	MOV	BX,FileDB.FD_HANDLE ;get handle from FDB
CloseIt:
	PUSH	AX		;save register
	CALLOS	close,,BX	;Close the file, like it or not....
	POP	AX		;restore register
	XOR	SI,SI		
	XCHG	SI,b$CLOS_FDB	;get close flag and clear it
	OR	SI,SI		;test flag, dealloc it?
	JZ	NoDealloc	
	CALL	B$LHDALC_CPCT	;deallocate FDB and compact local heap
NoDealloc:			
	MOV	b$CLOS_HANDLE,0	; clear flag
TEST_CLS_DONE:
cEnd

sEnd	;DV_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\dvinit.asm ===
TITLE	DVINIT.ASM - Device I/O Initialization/Termination module
;***
;DVINIT.ASM - Device I/O  initialization/termination module
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains Device I/O initialization and termination
;	support for the BASIC 3.0 runtime.  This module will only be present
;	in a user's program when a program contains statements which need
;	generalized device I/O.
;
;******************************************************************************

	INCLUDE switch.inc
	INCLUDE rmacros.inc

;
;	Code Segments
;
	USESEG	<INIT_CODE>	;Initialization
	USESEG	<DV_TEXT>	;Device I/O
	USESEG	<OI_TEXT>	;comm/printer I/O
	USESEG	<RT_TEXT>	

;
;	Data Segments
;
	USESEG	<_BSS>		;runtime data (uninitialized)
	USESEG	<_DATA> 	;runtime data (initialized)
	USESEG	<XIB>		; XIB and XIE must bracket XI!
	USESEG	<XI>		;initializer segment
	USESEG	<XIE>		

	INCLUDE seg.inc
	INCLUDE baslibma.inc
	INCLUDE devdef.inc	
	INCLUDE files.inc	
	INCLUDE nhutil.inc	
	INCLUDE const.inc	
	INCLUDE rtps.inc	

	INCLUDE compvect.inc	;component vectors

	INITIALIZER	B$xDVINI	;put B$xDVINI in initializer list.

	SUBTTL	Code Externals
	PAGE

sBegin	OI_TEXT 			
	externNP	B$LPTECHO	
sEnd	OI_TEXT 			

sBegin	DV_TEXT 			
	externNP	B$NearRet	;for disp vectors in compvect.inc
	externNP	B$CommSave	
	externNP	B$CommRestore	
sEnd	DV_TEXT 			

	SUBTTL	Runtime data definitions for BASIC Device I/O
	PAGE
sBegin	_BSS			
	externW b$LPTFDB	
	externB b$FILMOD	;GLOBAL.INC -
	externB b$TTY_BAKCHR	;defined in iotty
sEnd	_BSS			

sBegin	_DATA
;
;	external data
;
	externW b$pDevTable	
	externW b$run_disp	;RUN time initialization dispatch table
	externW b$pLPTECHO	; conditional vector to B$LPTECHO
	externW b$pKYBD_OPEN	; conditional vector to KYBD_OPEN
	externW b$pSCRN_OPEN	; conditional vector to SCRN_OPEN
	externB b$SCRNWIDTH	; logical width of SCRN:
	externW b$pCommSave	; conditional vector to B$CommSave
	externW b$pCommRestore	; conditional vector to B$CommRestore
sEnd	_DATA

sBegin	RT_TEXT 		

	PUBLIC	b$devused	; The compiler will generate a reference
b$devused equ 0 		; to b$devused if it decides that a user
				; program needs device I/O support.  This
				; causes dvinit to get drug in.
	externNP B$OPEN_DEV	

assumes cs,RT_TEXT

;	These macros are used to define the dispatch table entry
;	equates for the communication and cassette devices.  The
;	macro is invoked with the device operation (I or C), the device
;	type (COM or CAS), and the number of devices (NUM_RS232 or
;	NUM_CASS).

DevDspEquates	MACRO	Dop,Dtype,Dnum
	Dindex	= 0		;;value to pass to item generation macro

	REPT	Dnum		;;one item for each device defined
	Dindex	= Dindex + 1	;;update the counter
	DevItem	Dop,Dtype,%Dindex ;;define item with op (I or C), type (COM
				;;or CAS), and counter
	ENDM

	ENDM	;;DevDspEquates

DevItem	MACRO	Dop,Dtype,Dindex
	externNP B$&Dop&_&Dtype&Dindex ;;define ext (e.g., externNP $I_COM3)
Dop&_&Dtype&Dindex EQU B$&Dop&_&Dtype&Dindex ;;define the equate...
				;;(e.g., I_COM3 EQU $I_COM3)
	ENDM	;;DevItem

;	Device initialization dispatch address generator

DEVMAC	MACRO	ARG
	DW	I_&ARG
	ENDM

;	Define the equates in the form "I_CASx EQU B$I_CASx".

	DevDspEquates	I,CAS,NUM_CASS

;	Define the equates in the form "I_COMx EQU B$I_COMx".

	DevDspEquates	I,COM,NUM_RS232

INIDEV_TABLE LABEL WORD

	DEVNAM			;Device initialization addresses

INIDEV_END LABEL WORD		;End of table

iniwid= 80			;Initial printer width

sEnd	RT_TEXT 		


	SUBTTL	Runtime Device I/O  Initialization
	PAGE
assumes CS,INIT_CODE
sBegin	INIT_CODE

;***
;B$xDVINI - Device I/O  initializer
;PLM B$xDVINI()
;
;Purpose:
;	Initializer for Device I/O  component.	This routine is called
;	by the Crt0 startup before _main is called.  It will update the
;	indirect dispatch tables for the Device I/O  routines.	This
;	insures that the only time that Device I/O  is accessed is when
;	this module is linked into the user program.
;
;Entry:
;	None.
;
;Exit:
;	b$run_disp.DV_RVEC	- contains pointer to B$INIDEV
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****
cProc	B$xDVINI,<FAR>
cBegin
;
;	update "RUN" time initialization dispatch address to B$INIDEV	
;
	MOV	WORD PTR [b$run_disp].DV_RVEC,DV_TEXTOFFSET B$INIDEV	
;
;	initialize granularity dispatchers.

	MOV	b$pLPTECHO, OI_TEXTOFFSET B$LPTECHO ; Set vector to point
						    ;     to real routine
	MOV	b$pKYBD_OPEN, DV_TEXTOFFSET KYBD_OPEN ; Set vector to point
						      ;	to real routine
	MOV	b$pSCRN_OPEN, DV_TEXTOFFSET SCRN_OPEN ; Set vector to point
						      ;	to real routine
	MOV	b$pDevTable, DV_TEXTOFFSET DevTable   ; Set vector to point
						      ;	to full table
	MOV	b$pCommSave, DV_TEXTOFFSET B$CommSave ; Set vector to point
						      ;	to real routine
	MOV	b$pCommRestore,DV_TEXTOFFSET B$CommRestore ; Set vector to
							   ;   real routine

cEnd
sEnd	INIT_CODE

	SUBTTL RUN time initialization for device independent I/O
	PAGE
assumes CS,DV_TEXT
sBegin	DV_TEXT

	SUBTTL Device Dispatch Routines
	PAGE
;***
; B$INIDEV - Device initialization dispatcher
;
;	This routine calls initialization routines for each device
;	in the device table.
;****
cProc	B$INIDEV,<NEAR>,<BX,DI>	
cBegin

	MOV	BX,OFFSET INIDEV_TABLE-2 ;Adjust for no disk entry
	MOV	DI,LAST_DEVICE_OFFSET-2 ;Use actual offset of last device

devlp:	PUSH	BX
	PUSH	DI
	CALL	WORD PTR CS:[BX+DI] ;Dispatch to device routine
	POP	DI
	POP	BX
	DEC	DI
	DEC	DI
	JNZ	devlp		;Loop until device offset = 0

cEnd

	PAGE

;-----	Device Action Routines	---------------------------------------------

;	These routines are always called from special device dispatchers.
;	The registers are set up as follows:
;		(DI) = device offset
;	The remaining registers are used to pass parameters.

devio	PROC	NEAR

;	Device initialization routines
;		Device control blocks are initialized in data segment.
;	ENTRY	(DI) = Device offset
;	USES	any but DI

I_LPT1:
	MOV	b$LPTFDB.FD_MODE,MD_SQO ; Initialize LPRINT file data block
	MOV	b$LPTFDB.FD_DEVICE,DN_LPT1 
	MOV	b$LPTFDB.FD_WIDTH,iniwid   
I_LPT2: 			;no special initialization (at Basic Start-up)
I_LPT3:
I_LPT4:
I_KYBD:	
I_SCRN:
I_CONS:
I_PIPE:
	RET			; just return

;	Device close routines

;	ENTRY	(DI) = Device offset
;	USES	any but DI


KYBD_OPEN:
	XOR	DL,DL		; DL = width
	MOV	BYTE PTR [b$TTY_BAKCHR],DL ; Clear keyboard backup flag/char
	MOV	AH,MD_SQI	;Valid open modes

	JMP	B$OPEN_DEV	; allocate FDB with no buffer

;***
; SCRN_OPEN - open the SCRN: device as a file.  Re-written as part of [16].
;
; Purpose:
;	Create an Fdb associated with a given file number for the screen
;	Allows SCRN: to be opened as either OUTPUT or RANDOM.
; Input:
;	[AL] == file device (?)
;	[BX] == file #
; Output:
;	(ES:)[SI] = *FDB
; Modifies:
;	AX,DX
;****
SCRN_OPEN:
	MOV	DL,[b$SCRNWIDTH]	;(DL) = width
	MOV	AH,MD_SQO+MD_RND	;Set legal modes
	CALL	B$OPEN_DEV		; allocate FDB with no buffer
	FDB_PTR ES,SI,SI		;(ES:)[SI] = *FDB
	MOV	b$FILMOD,MD_SQO 	;Force sequential output
	MOV	FileDB.FD_MODE,MD_SQO	;Force sequential output
	RET

DEVIO	ENDP

	SUBTTL	device table & device dispatch routine
	page
;***
;DevTable -- contains address of all individual device dispatch tables
;
;Purpose:
;	It contains address of all individual device dispatch tables.  The
;	procedure of I/O dispatching is first to get the address of
;	individual device table from here (DevTable) by refering the
;	device number (major #, formed by DN_<device>), and second, to
;	dispatch to the address of desired I/O function from individual
;	device table by refering the function number (minor #, formed by
;	DV_<func>).
;
;	Each individual device dispatch table has the name formed by the
;	prefix $D_ and the device name, e.g. B$D_DISK.
;
;	Each entry in the DevTable is associated with one device number
;	(major #), which has the symbolic name formed by the prefix DN_ and
;	the device name, e.g. DN_KYBD is the device number for keyboard and
;	its value is -1.
;
;	The following table contains names of each individual device table,
;	the associated symbols of device numbers and values, and the module
;	they reside.  DevTable is acutally the first column of the
;	following table.
;	_________________________________________________
;	| B$D_DISK | DN_DISK |	0  | iodisk		|
;	|----------|---------|-----|--------------------|
;	| B$D_KYBD | DN_KYBD | - 1 | iotty		|
;	|----------|---------|-----|--------------------|
;	| B$D_SCRN | DN_SCRN | - 2 | iotty		|
;	|----------|---------|-----|--------------------|
;	| B$D_CONS | DN_CONS | - 3 | iocons		|
;	|----------|---------|-----|--------------------|
;	| $D_CAS1  | DN_CAS1 | - 4 | gwcass		|
;	\..........|.........|.....|....................\
;	| $D_CAS4  | DN_CAS4 | - 7 | gwcass		|
;	|----------|---------|-----|--------------------|
;	| B$D_COM1 | DN_COM1 | - 8 | gwcom		|
;	\..........|.........|.....|....................\
;	| $D_COM8  | DN_COM8 | -15 | gwcom		|
;	|----------|---------|-----|--------------------|
;	| B$D_LPT1 | DN_LPT1 | -16 | iolpt		|
;	\..........|.........|.....|....................\
;	| B$D_LPT4 | DN_LPT4 | -19 | iolpt		|
;	|__________|_________|_____|____________________|
;	* the number of CAS, COM & LPT may vary.
;
;-------
;Individual device dispatch table ($D_<device name>):
;-------
;	Each device dispatch table, which is similar to one column of the
;	following table, contains addresses of all routines (I/O functions)
;	performing special device functions.  Each entry in the device
;	dispatch table is associated with one function number (minor #,
;	actually the offset to that table), which has the symbolic name
;	formed by the prefix DV_ and the function name, e.g. DV_CLOSE (=6).
;
;	All dispatching routines have the name formed by
;	<DeviceName>_<FunctionName>, e.g. DISK_OPEN is the routine which opens
;	the disk file, and COM_CLOSE is the one which closes COM port.
;
;	The following table shows:
;	(1) the functions for each device (in the first column), and
;	(2) the actual working routines for I/O functions of KYBD, SCRN, CONS
;	    and LPT. (The symbolic name of each routine is still formed as
;	    usual, but there doesn't have actual code for that label.  Each
;	    label is defined by EQU to the actual working routine.  For
;	    example, label KYBD_EOF is defined by KYBD_EOF EQU B$ERR_FC.)
;	DISK & COM don't have equates.
;	______________________________________________________________
;	| func	 | KYBD       | SCRN	   | CONS	| LPT	     |
;	|________|____________|____________|____________|____________|
;	| EOF	 | B$ERR_FC   | B$ERR_FC   | B$ERR_BFM	| B$ERR_FC   |
;	|--------|------------|------------|------------|------------|
;	| LOC	 | B$ERR_FC   | B$ERR_FC   | B$ERR_BFM	| B$ERR_FC   |
;	|--------|------------|------------|------------|------------|
;	| LOF	 | B$ERR_FC   | B$ERR_FC   | B$ERR_BFM	| B$ERR_FC   |
;	|--------|------------|------------|------------|------------|
;	| CLOSE  | B$LHDALC   | B$LHDALC   | B$LHDALC	| B$LPTCLOSE |
;	|--------|------------|------------|------------|------------|
;	| WIDTH  | B$ERR_FC   | $SCRNWID   |		|	     |
;	|--------|------------|------------|------------|------------|
;	| RANDIO | B$ERR_FC   | B$ERR_FC   | B$ERR_BFM	| B$ERR_FC   |
;	|--------|------------|------------|------------|------------|
;	| OPEN	 |	      | 	   |		|	     |
;	|--------|------------|------------|------------|------------|
;	| BAKC	 | B$TTY_BAKC | B$ERR_FC   | B$ERR_BFM	| B$ERR_FC   |
;	|--------|------------|------------|------------|------------|
;	| SINP	 | B$TTY_SINP | B$ERR_FC   | B$ERR_BFM	| B$ERR_FC   |
;	|--------|------------|------------|------------|------------|
;	| SOUT	 | B$ERR_FC   | B$TTY_SOUT |		| B$LPTOUT   |
;	|--------|------------|------------|------------|------------|
;	| GPOS	 | B$ERR_FC   | B$TTY_GPOS |		|	     |
;	|--------|------------|------------|------------|------------|
;	| GWID	 | B$ERR_FC   | B$TTY_GWID |		|	     |
;	|--------|------------|------------|------------|------------|
;	| BLKIN  | B$ERR_FC   | B$ERR_FC   | B$ERR_BFM	| B$ERR_FC   |
;	|--------|------------|------------|------------|------------|
;	| BLKOUT | B$ERR_FC   | B$ERR_FC   | B$ERR_BFM	| B$ERR_FC   |
;	|________|____________|____________|____________|____________|
;
;	The following table shows where the routines reside.
;	_________________________________
;	| DISK_xxxx	| dkio.asm	|
;	|---------------|---------------|
;	| KYBD_xxxx	| iotty.asm	|
;	|---------------|---------------|
;	| SCRN_xxxx	| iotty.asm	|
;	|---------------|---------------|
;	| CON_xxxx	| iocons.asm	|
;	|---------------|---------------|
;	| CAS_xxxx	| gwcass.asm	|
;	|---------------|---------------|
;	| COM_xxxx	| gwcom.asm	|
;	|---------------|---------------|
;	| LPT_xxxx	| iolpt.asm	|
;	|_______________|_______________|
;
;*******************************************************************************

	page
;***
;DevTable -- device dispatch table
;
;Purpose:
;	Device dispatch table, which is generated by macros DEVMAC & DEVNAM,
;	is used to select the individual device dispatch table.
;	Note:	DEVMAC redefins DEVMAC in devdef.inc.
;		DEVNAM is defined in devdef.inc
;Entry:
;	none
;Exit:
;	DevTable is set up
;Uses:
;	none
;*******************************************************************************

DEVMAC	MACRO	DeviceName
	EXTRN	B$D_&DeviceName:NEAR	;;all entries are externals
	DW	B$D_&DeviceName 	;;each entry is the address of
					;; individual device table
	ENDM

labelW	DevTable		;device table

	DW	EndOfDevTable-DevTable-2 ; count of bytes in table (not
					 ;	 including count word)
	DEVMAC	DISK		;Disks are treated as device type 0
	DEVNAM			;Rest of devices
EndOfDevTable:			; label for count calculation

sEnd	DV_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\dynamic.asm ===
TITLE	DYNAMIC - Dynamic array support
	PAGE	56,132
;***
; DYNAMIC.ASM - Dynamic array support
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - DIM/REDIM Statement - Generates runtime call if $DYNAMIC was specified:
;
;	B$DDIM(hi 1, lo 1,... hi n, lo n, element size, ndims+typ<<8, pAd)
;	B$RDIM(hi 1, lo 1,... hi n, lo n, element size, ndims+typ<<8, pAd)
;
; - Dynamic array access routine - one call:
;
;	B$HARY(index 1, ..., index n, nindex) with BX = pointer to AD
;
; - ERASE Statement - generates one call:
;
;      ERASE arrayname {,arrayname}
;
;	B$ERAS(array desc)
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	useSeg	_DATA		
	useSeg	_BSS		
	useSeg	FH_TEXT 	

	INCLUDE seg.inc 	
	INCLUDE array.inc	;far heap and array descriptor structures
	INCLUDE pointers.inc	;pointer reference macros
	INCLUDE baslibma.inc	
	INCLUDE nhutil.inc
	INCLUDE idmac.inc	

sBegin	_BSS			
	externB	b$HugeShift	;OS Selector increment for HUGE access
	externW	b$Buf1		; temporary buffer
sEnd	_BSS




sBegin	FH_TEXT 		
assumes CS,FH_TEXT		
;
;	Dynamic array runtime support
;


externNP B$FHAlloc		;FHINIT - far heap allocation
externNP B$FHDealloc		;FHINIT - far heap deallocation
externNP B$LHALC_CPCT		; compact heap and allocate heap entry
externNP B$LHDALC		; deallocate heap entry and compact heap
externNP B$LH_CPCT		; compact heap
externNP B$STDALC
externNP B$FHTestRaiseBottom	; attempt to reclaim DGROUP from FH
externNP B$ADArraySize		; Compute array size

externNP B$ERR_BS		;bad subscript error
externNP B$ERR_DD		;double dimension error


	SUBTTL	B$DDIM & B$RDIM - dimension & redimension
	PAGE
;***
; B$ADIM - DIM a dynamic array
; I4 pascal B$ADIM(I2 lo1, I2 hi1, ..., I2 loN, I2 hiN, I2 cbelem,	
;		      U2 ndims+typ<<8, ad *pAd)
;
; B$DDIM - DIM a dynamic array
; void pascal B$DDIM(I2 lo1, I2 hi1, ..., I2 loN, I2 hiN, I2 cbelem,	
;		      U2 ndims+typ<<8, ad *pAd)
;
; B$RDIM - REDIM a dynamic array
; void pascal B$RDIM(I2 lo1, I2 hi1, ..., I2 loN, I2 hiN, I2 cbelem,	
;		      U2 ndims+typ<<8, ad *pAd)
;
;Purpose:
; Runtime Entry Point. DIM Statement for dynamic arrays. If the array is
; already defined, an error is returned. REDIM Statement for dynamic arrays. If
; the array is already defined, it is released and then reallocated.
;
; B$ADIM performs all the functions of B$DDIM, except it does not actually
; allocate space for the array. It is used to fill in an array descriptor, and
; return the size of the array. [14]
;
; NOTE: In the interpeter (QB), the pointer to the array descriptor is actually
; a pointer into the variable heap. This heap cannot move during this
; operation.
;
;Inputs:
; lb	= lower bound for dimension n (lo1 through loN, above)
; ub	= upper bound for dimension n (hi1 through hiN, above)
; cbelem= element size
; ndtyp = number of dimensions (byte) & flags
; pAd	= pointer to array descriptor
;		(FV_LONGPTR only: pAd is a long ptr to the Ad)
;
;Outputs:
; [DX:AX] = resulting size of the array (B$ADIM only)
; Input parameters are removed from the stack.
;
;Modifies:
; Per convention
;
;*****************************************************************************
cProc	B$ADIM,<FAR,PUBLIC>	
cBegin	nogen			
	MOV	AL,1		; non-zero to indicate dim
	SKIP	2		; skip next instruction
cEnd	nogen			; fall into B$RDIM

cProc	B$RDIM,<FAR,PUBLIC>	
cBegin	nogen			
	XOR	AL,AL		; zero to indicate re-dim
	SKIP	2		; skip next instruction
cEnd	nogen			; fall into B$DDIM

cProc	B$DDIM,<FAR,PUBLIC>	
cBegin	nogen			
	MOV	AL,0FFH 	; flag to indicate dim
cEnd	nogen			


cProc	DIM_COMMON,FAR		
parmW	lb			;[4] lower bound for dimension n
parmW	ub			;[4] upper bound for dimension n
parmW	cbelem			; element size
parmW	ndtyp			; number of dimensions (byte) & flags
parmW	pAd			; pointer to array descriptor
cBegin				


	PUSH	SI		
	PUSH	DI		

	OR	AL,AL		; see who we were called as
	CBW			; [AX] = entry type
	XCHG	AX,DI		; [DI] = entry type (NOTE: Used way below)
	JNZ	BDDIM_5 	; Jump if dim (don't erase first)

;
;	Erase the present array if allocated.
;
	cCall	<FAR PTR B$ERAS>,pAd ; call runtime routine to erase array
;
;	Test if array is already allocated.  If so, clean the stack and
;	process the error.
;
BDDIM_5:			
	mov	bx,pAD		
	CMP	[bx].AD_fhd.FHD_hData,0    ;test if AD segment is zero
	JZ	BDDimNotAlloc	;if so, then not allocated, continue
	JMP	B$ERR_DD	;jump to double-dimensioned array error

;	Array is not allocated.  Fill in the AD from the stack variables.

BDDimNotAlloc:
	MOV	CX,ndtyp	; get number of dimensions and flags
	MOV	WORD PTR [bx].AD_cDims,CX  ;put flags, number of dims in AD
	MOV	AX,cbelem	; get size of an element in bytes
	MOV	[bx].AD_cbElement,AX	;and also put into AD
	XOR	CH,CH		;leave number of dimensions in CX
	LEA	SI,ub		;[4] point at lb entry of last index def
;
;	For each dimension, move the lower bound and compute the count
;	from the information on the stack.
;
;	[SI]			 -> upper bound of dimension on stack	
;	[SI+2]			 -> lower bound of dimension on stack	
;	ds:[bx].AD_tDM.DM_cElements -> count of elements of dimension in AD
;	ds:[bx].AD_tDM.DM_iLbound   -> lower bound of dimension in AD
;
	PUSH	BX		;save registers during move
	XOR	DX,DX		; [DX] = offset adjustment
BDDimLoop:
	lods	word ptr DGROUP:[si]	;get upper bound of current dimension
	SUB	AX,DGROUP:[SI] 	;subtract lower bound to count less 1
	JS	BDDimBadSubscript ; if lower > upper, bad subscript
	INC	AX		;increment to get real count of dimension
	MOV	[bx].AD_tDM.DM_cElements,AX ;put count of dimension into AD
	MUL	DX		; [AX] = offset adjustment * cElements
	XCHG	AX,DX		; [DX] = offset adjustment
	lods	word ptr DGROUP:[si]	;get lower bound of current dimension
	MOV	[bx].AD_tDM.DM_iLbound,AX  ;put into lower bound in AD
	SUB	DX,AX		; update offset adjustment
	ADD	BX,SIZE DM	;move AD pointers to next dimension entry
	LOOP	BDDimLoop

	POP	BX		;restore registers...
	XCHG	AX,DX		; [AX] = offset adjustment
	MUL	[bx].AD_cbElement	; Account for element size
	MOV	[bx].AD_oAdjusted,AX	; Store offset adjustment
;
;	With the information now in the AD pointed by BX, compute the
;	size of the array to allocate.
;
	CALL	B$ADArraySize	; compute the size in DX:AX
DJMP	JC	BDDimBadSubscript ;if too large, then give bad subscript error
        MOV     [bx].AD_fhd.FHD_cPara,AX; save byte count
	DEC	DI		; [DI] = entry type-1
	JZ	BDDimExit	; B$ADIM? if so, then go exit.
;
;	Jump if array is huge.	For a near or far array, give a bad
;	subscript error if the size is 64K or more.
;

	MOV	[bx].AD_fhd.FHD_oData,size AHD	; default offset

	TEST	[bx].AD_fFeatures,FADF_HUGE	;test if array is huge
	JNZ	BDDimHuge	;if huge, then jump
	CMP	DX,1		; byte count < 64K?
	JB	Less64K		; brif so -- value ok
	JA	BDDimBadSubscript ; brif > 64K -- give bad-subscript error
	OR	AX,AX		; byte count = 64K?
	JNZ	BDDimBadSubscript ; brif not -- give bad-subscript error
Less64K:			
;
;	Jump if array is far.  For a near array, allocate through the
;	near heap manager and jump to exit.
;
	TEST	[bx].AD_fFeatures,FADF_FAR ;test if array is far
	JNZ	BDDimAlloc	;if far, then just allocate directly
	MOV	CX,BX		;get array descriptor offset
	MOV	DL,LH_ARRAY	;set near heap entry type
	XCHG	BX,AX		;get size in bytes of entry to allocation
	CALL	B$LHALC_CPCT	; compact heap and allocate heap entry
	MOV	BX,CX		;get array descriptor pointer back
	MOV	[bx].AD_fhd.FHD_hData,DGROUPSEG ;save DGROUP segment/SB
						;  in descriptor
	MOV	[bx].AD_fhd.FHD_oData,SI   ;save base offset in descriptor
	ADD	[bx].AD_oAdjusted,SI	   ;Save adjusted offset
	JMP	SHORT BDDimExit ;jump to exit routine
;
; Place in center for relative jumps
;
BDDimBadSubscript:
	JMP	B$ERR_BS	;jump to bad-subscript error



;
;	Array is huge.	Determine 64K MOD <element-size> to compute
;	the array offset. (Value is remainder of integer divide of
;	64K by the element size.)
;
BDDimHuge:
	OR	DX,DX		; skip offset calc for arrays < 64k
	JZ	BDDimAlloc	
	PUSH	AX		;save size of allocation now in...
	PUSH	DX		;DX:AX since they are used by DIV
	XOR	AX,AX		;load 64K into DX:AX - 0 in AX...
	CWD			
	INC	DX		;...and 1 in DX
	DIV	[bx].AD_cbElement  ;divide 64K in DX:AX by element size
	MOV	[bx].AD_fhd.FHD_oData,DX ;move remainder into the AD offset
	ADD	[bx].AD_oAdjusted,DX	;Save adjusted offset
	OR	DX,DX		;test if remainder (MOD) is zero
	POP	DX		;restore array byte size...
	POP	AX		;in DX:AX
	JZ	BDDimAlloc	;if remainder was zero, then just allocate
	ADD	AX,[bx].AD_fhd.FHD_oData   ;make room for alignment
	ADC	DX,0		
	CMP	DX,1		;test if array was less than 128K
	JA	BDDimBadSubscript ;if 128K or more and nonzero offset, then err

BDDimAlloc:
	CALL	B$FHAlloc	;allocate FH entry of size DX:AX at desc BX

BDDimExit:
	MOV	CX,ndtyp	; CL = number of dimensions on stack
	XOR	CH,CH		; Clear high byte
	SHL	CX,1		; number of parameter bytes <dim #>*4
	SHL	CX,1		
	ADD	CX,6		; space for rest of parms
	MOV	b$Buf1,CX	; save # of bytes of parms to clear

	POP	DI		; restore registers
	POP	SI		

cEnd	nogen			

	JMP	CleanStack	; clean up stack and return

HAryErrorPopBP: 		
	POP	BP		;get back frame pointer (must be pushed last)
HAryError:			
	JMP	B$ERR_BS	;process bad subscript error

	SUBTTL	B$HARY - compute huge array element pointer
	PAGE
;***
;B$HARY - compute huge array element pointer
;void pascal B$HARY(BX: ad* pAd, i1, ..., iN, ci)
;
;Purpose:
; Runtime entry point. With the array descriptor and indices given, compute the
; segmented pointer to the huge array element.
;
; NOTE: In the interpeter (QB), the pointer to the array descriptor is actually
; a pointer into the variable heap. This heap cannot move during this
; operation.
;
;Entry:
; [BX]	= offset of array descriptor
; iN	= element index
; ci	= count of element indecies
;
;Exit:
; ES:BX = far pointer to array element.
;
;Uses:
; None.
;
;Preserves:
; AX,CX,DX	(Compiler requirement)
;
;Exceptions:
;	Error for unallocated array, bad subscript, or index number
;	inconsistency.
;******************************************************************************
cProc	B$HARY,<FAR,PUBLIC>	
parmW	iNdecies		; indecies
parmW	ci			; count of indecies
cBegin				
	PUSH	AX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	PUSH	DI

;
;	SI:DI are used to accumulate the 32-bit offset of the array element.
;	CX is the loop counter for each index of the array access.
;	BX points to within the array descriptor.
;	BP points to within the stack frame.
;	DX:AX are used for intermediate calculations (including MUL).
;
;	Clear the offset accumulation in SI:DI and get and check the
;	number of indices in the array.
;
	XOR	SI,SI		;clear the running...
	MOV	DI,SI		;...accumulator for the offset
	MOV	CX,ci		; get number of indices from stack
	CMP	CL,[BX].AD_cDims ;test against dimensions in the AD
	JNE	HAryError	;if not the same, then jump to error
;
;	Within the offset calculation loop for each index, BP points
;	to the current index in the stack frame and BX points to the
;	current dimension count in the array descriptor.  Indices are
;	processed from last to first.
;
	PUSH	BX		;save registers again...
	PUSH	BP		;(save BP last for error routines)

	ADD	BP,8		;point to last index in the frame
	ADD	BX,AD_tDM	; points to first DM, last dim count...
	JMP	SHORT HAryStart ;jump to start within the loop
;
;	Calculation loop.  Adjust BP and BX to point to the next
;	index in the array.
;
HAryLoop:

	INC	BP		;point BP to next word...
	INC	BP		;...up the frame on the stack
	ADD	BX,SIZE DM	; point BX to the next index in the AD

;	Multiply SI:DI by the new dimension count.  Since each
;	index is in legal range in the AD, overflow is not possible.

	MOV	AX,DI		;get low word of accumulator
	MUL	[BX].DM_cElements ;multiply by current dimension count
	MOV	DI,AX		;put low word of product in accumulator
	MOV	AX,SI		;get high word of accumulator
	MOV	SI,DX		;accumulator SI:DI has first product
	MUL	[BX].DM_cElements ;multiply high word by count
	ADD	SI,AX		;add low word to high word of accumulator

;	Start within loop.  Get the array index and check if it is
;	within the bounds specified in the AD.	If not, report an error.

HAryStart:
	MOV	AX,[BP] 	;get the array index
	SUB	AX,[BX].DM_iLbound ;subtract lower bound to get index offset
	JL	HAryErrorPopBP	;if negative, then error
	CMP	AX,[BX].DM_cElements ;test if equal or larger than count
	JGE	HAryErrorPopBP	;if so, then error

;	Add array index offset to the accumulator in SI:DI.
;	Loop if more dimensions to process.

	ADD	DI,AX		;add index offset to DI...
	ADC	SI,0		;...and propagate carry to SI
	LOOP	HAryLoop	;loop on CX if more to process

	POP	BP		;restore registers saved before loop
	POP	BX

;	Finish the offset calculation by multiplying by the element
;	size and adding the AD offset.

	MOV	AX,DI		;get low word of accumulator
	MUL	[BX].AD_cbElement ;multiply by element byte count
	MOV	DI,AX		;put low word of product in accumulator
	MOV	AX,SI		;get high word of accumulator
	MOV	SI,DX		;accumulator SI:DI has first product
	MUL	[BX].AD_cbElement ;multiply high word by count
	ADD	SI,AX		;add low word to high word of accumulator

	ADD	DI,[BX].AD_fhd.FHD_oData ;add offset to accumulator...
Finish: 			
	ADC	SI,CX		;...and propagate the carry (CX=0 from LOOP)

;	From the 32-bit offset in SI:DI, compute the far pointer in ES:BX.

	GETSEG	AX,[BX].AD_fhd.FHD_hData,BX	;get segment from the AD
	OR	AX,AX		;test if segment is zero
	JZ	BadSubError	;if so, then array is unallocated
	MOV	CL,b$HugeShift ;get OS dependent shift count...
;	MOV	CL,12		;conversion count from 64K to 16...
	SHL	SI,CL		;...to calculate segment
	ADD	AX,SI		;segment is calculated (far ptr in AX:DI)

;	Move far pointer in AX:DI to ES:BX.

	MOV	ES,AX		;move segment of pointer
NearArray:			
	MOV	BX,DI		;move offset of pointer

	MOV	AX,ci		; AX = number of dimensions on stack
	INC	AX		; 1 extra parameter
	SHL	AX,1		; number of parameter bytes <dim #>*2 + 2
	MOV	b$Buf1,AX	; save # of bytes of parms to clear

	POP	DI		;restore registers
	POP	SI
	POP	DX
	POP	CX
	POP	AX

cEnd	nogen			; fall into CleanStack

;*** 
; CleanStack -- Common return for B$HARY and DIM_COMMON.  Added with [18].
;
;Purpose:
;	Clears variable number of bytes off the stack that are below BP and
;	a return address. Restores BP and jumps to the desired return address.
;
;Entry:
;	b$Buf1 = number of bytes to clear
;Exit:
;	None
;Uses:
;	b$Buf1
;Preserves:
;	All
;Exceptions:
;	None
;
;******************************************************************************
CleanStack:
	POP	BP		; restore BP
	POP	[b$Buf1+2]	; [b$Buf1+2] = far return address
	POP	[b$Buf1+4]
	ADD	SP,b$Buf1	; clean parameters from stack
	JMP	DWORD PTR [b$Buf1+2] ; return far

BadSubError:			
	JMP	B$ERR_BS	;process bad subscript error

	SUBTTL	B$LBND and B$UBND - LBOUND and UBOUND Functions
	PAGE
;***
; B$LBND and B$UBND - LBOUND and UBOUND Functions
; Added rev [11]
;
; Function:
;	Return the lowest or highest legal index for a
;	specified array dimension.
;
; NOTE: In the interpeter (QB), the pointer to the array descriptor is actually
; a pointer into the variable heap. This heap cannot move during this
; operation.
;
; Inputs:
;	pAd	ds relative array descriptor offset
;		(FV_LONGPTR only: pAd is a long ptr to the Ad)
;	iDim	1 relative index to array dimension
;
; Ouputs:
;	ax	lower or upper bound of the indicated dimension
;
; Registers:
;	none
;
;******************************************************************************

cProc	B$LBND,<FAR,PUBLIC>
cBegin	nogen
	XOR	CX,CX				;cx = 0 == LBOUND
	SKIP	2
cEnd	nogen					;fall OVER MOV CX,SP

cProc	B$UBND,<FAR,PUBLIC>
cBegin	nogen
	MOV	CX,SP				;cx <> 0 == UBOUND
cEnd	nogen					;fall INTO common routine

cProc	ULbound,FAR				;common routine to fall into
parmW	pAd					;pointer to array descriptor
parmW	iDim					;Index to desired dimension
cBegin

	MOV	DX,iDim
	mov	bx,pAd				;get pAD into register
	XOR	AX,AX				;Assume iDim out of range case
	CMP	[bx].AD_fhd.FHD_hData,AX	;test if segment is zero
	JZ	BadSubError			; Branch if unallocated
	SUB	DL,[BX].AD_cDims		;not this many dimensions?
	JA	BadSubError			; out of range: bad sub
						; treats negs as out of range
.errnz	(SIZE DM)-4
	NEG	DL				;Index to DIM info
						; Zero relative, always +
	SHL	DX,1				;To word offset
	SHL	DX,1				;2 word fields in DM
	ADD	BX,DX				;Index to dim iDim information
	MOV	AX,[BX.AD_tDM.DM_iLbound]	;Lower bound
	JCXZ	BOUNDX				;Return LBOUND
	ADD	AX,[BX.AD_tDM.DM_cElements]	;Count of elements
	DEC	AX				;To highest index
BOUNDX:

cEnd

	SUBTTL	B$ERAS - erase an array
	PAGE
;***
; B$ERAS - erase an array
; B$IErase - erase an array, but do not try to reclaim dgroup.
;
;Purpose:
; With the array descriptor given, erase the array.  For dynamic arrays, the
; space is deallocated. For static arrays, the array is only cleared. For
; static string arrays, the strings are deallocated.
;
; NOTE: In the interpeter (QB), the pointer to the array descriptor is actually
; a pointer into the variable heap. This heap cannot move during this
; operation.
;
;Entry:
;	pAd	ds relative array descriptor offset
;		(FV_LONGPTR only: pAd is a long ptr to the Ad)
;Exit:
;	None.
;Uses:
;	AX, BX, CX, DX.
;Exceptions:
;	None.
;******************************************************************************
cProc	B$ERAS,<FAR,PUBLIC>	
cBegin	nogen			


	MOV	AX,1		; nz to allow heap movement
	SKIP	2		

cEnd	nogen			

cProc	B$IErase,<FAR,PUBLIC>	
cBegin	nogen			

	XOR	AX,AX		; z to disable heap movement


cEnd	nogen			

cProc	ERASE_COMMON,FAR,<SI,DI>
parmW	pAd			
cBegin				

;	Get the array descriptor and test if array is static or dynamic.

	mov	bx,pAd			;get pAD into register
	mov	cx,[bx].AD_fhd.FHD_hData 
	jcxz	ErasReturn		 ; nothing to do if unalloc'd

	TEST	[bx].AD_fFeatures,FADF_STATIC ;test if a static array
	JNZ	ErasStatic		;if static, then jump

;	Dynamic array.	If not allocated, then just return.  Then test
;	if it is a string array.

	xor	si,si			
	MOV	[bx].AD_fhd.FHD_cPara,si;clear size field
	xchg	si,[bx].AD_fhd.FHD_hData;Get segment/SB, mark deallocated
	TEST	[bx].AD_fFeatures,FADF_SD;test if a string array
	JZ	ErasDynNumAry		;if not, dealloc dynamic numeric array

;	Dynamic string array.  Get the array offset and deallocate it.

	MOV	SI,[bx].AD_fhd.FHD_oData   ;get offset of array from AD
	PUSH	AX		; Save compaction flag
	CALL	B$LHDALC	; deallocate heap entry and compact heap
	POP	CX		; [CX] = compaction flag
	JCXZ	ErasReturn	
	CALL	B$LH_CPCT	; Compact when we're allowed to
	JMP	SHORT ErasReturn ;done - jump to return

;	Dynamic numeric array.	Deallocate it through its descriptor.

ErasDynNumAry:
	PUSH	AX		; Save movement flag
	cCall	B$FHDealloc	; deallocate the FH entry
	POP	CX		
	JCXZ	ErasReturn	; if movement not allowed, just return
	cCall	B$FHTestRaiseBottom ; Else try to reclaim DGROUP
	JMP	SHORT ErasReturn ;done - jump to return

;	Static array.  First get the base offset and compute its size.
;	Test if string or numeric.

ErasStatic:
	CALL	B$ADArraySize	; get the array size in bytes in DX:AX
	MOV	CX,AX		;put the size into CX
	MOV	DI,[bx].AD_fhd.FHD_oData   ;get the base offset from the AD
	TEST	[bx].AD_fFeatures,FADF_SD  ;test if string array
	JZ	ErasStatNumAry	;if not, then numeric and jump

;	Static string array.  Deallocate all strings referenced in
;	loop with BX pointing to each descriptor in the entry.

	SHR	CX,1		;divide byte count to get word count

	SHR	CX,1		;divide word count to get number of strings
	PUSH	BX		; Save array pointer
	MOV	BX,DI		;point to start of entry
ErasStatLoop:
	CALL	B$STDALC	;deallocate the string pointed by desc at BX
	ADD	BX,4		;point to the next descriptor
	LOOP	ErasStatLoop	;loop until done with entry
        MOV     CX,AX           ;get the length of entry back
	POP	BX		; get AD pointer back

;       Static array.  Clear the array entry of CX bytes at offset DI.

ErasStatNumAry:
	INC	CX		; Round up length if odd.
	SHR	CX,1		;Number of words to be cleared.
        XOR     AX,AX           ;value to clear entry
	GETSEG	ES,[bx].AD_fhd.FHD_hData,,<SIZE,LOAD>	;get seg from the AD
        REP     STOSW           ;clear the entry

;	Done - restore and return.

ErasReturn:

cEnd				

sEnd				
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\dvstmt.asm ===
TITLE	DVSTMT - Device Independent I/O Statements
	page	56,132
;***
; DVSTMT - Device Independent I/O Statements
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;
; BASIC Syntax mapping to included runtime entry points:
;
; - EOF Function:
;
;     EOF(file number)
;      |
;    I2 B$FEOF
;
; - LOC Function:
;
;      LOC(file number)
;	|
;     I4 B$FLOC
;
; - LOF Function:
;
;      LOF(file number)
;	|
;     I4 B$FLOF
;
; - CLOSE Statement - B$CLOS, no matter having parameters or not
;
;      CLOSE [[#]file number [,[#]filenumber...]]
;
;    Examples:
;
;      CLOSE		     CLOSE #1		     CLOSE 1,2
;	 |			    |			    |
;    B$CLOS			B$CLOS 		B$CLOS
;    parameter count 0		parameter count 1	parameter count 2
;    no parameter		1 in stack		2 & 1 in stack
;
; - WIDTH Statement:
;
;    Four different Syntax possibilities map to four runtime entry points:
;
;      WIDTH size			 WIDTH LPRINT size
;	 |				   |
;      B$WIDT				 B$LWID
;
;
;      WIDTH filenumber, size		 WIDTH device, size
;	 |				   |
;      B$DWID				 B$DWID
;
; - GET Statement - calls B$GET1 if no record number specified, or
;			  B$GET2 if a record number specified
;			  B$GET3 if record variable, but no record number
;			  B$GET4 if record variable, and record number
;
;      GET [#]filenumber [,[record number][,record variable]]
;
;    Examples:
;
;	GET #1		GET #2,4	GET #2,,FOO	GET #2,4,FOO
;	|		|		|		|
;	B$GET1 	B$GET2 	B$GET3 	B$GET4
;
;	Record Number is I4.
;
; - PUT Statement - calls B$PUT1 if no record number specified, or
;			  B$PUT2 if a record number specified
;			  B$PUT3 if record variable, but no record number
;			  B$PUT4 if record variable, and record number
;
;      PUT [#]filenumber [,[record number][,record variable]]
;
;    Examples:
;
;	PUT #1		PUT #2,4	PUT #2,,FOO	PUT #2,4,FOO
;	|		|		|		|
;	B$PUT1 	B$PUT2 	B$PUT3 	B$PUT4
;
; - OPEN Statement:
;
;    Two syntaxes are allowed:
;
;      OPEN mode,[#]filenumber,"filespec" [,reclength]
;	B$OOPN, which has C definition as follows with parameters in stack.
;	B$OOPN(U2 mode, I2 channel, sd *psdName, I2 cbRecord)
;	(refering the procedure head comments of B$OPEN for detail)
;
;      OPEN "filespec" [FOR mode][locktype] AS [#]filenumber [LEN=reclength]
;	B$OPEN, which has C definition as follows with parameters in stack.
;	B$OPEN(sd *psdName,I2 channel,I2 cbRecord,U2 mode,I2 access,I2 lock)
;	(refering the procedure head comments of B$OPEN for detail)
;
; - FILEATTR function
;
;	FILEATTR(file number, field)
;	|
;	I4 B$FATR
;
; - FREEFILE function
;
;	FREEFILE
;	|
;	I2 B$FREF
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

;Code segments:
	useSeg	NH_TEXT 	;near heap
	useSeg	ER_TEXT 	;error handling
	useSeg	DV_TEXT 	;device independent I/O

;Data segments:
	useSeg	_DATA		;initialized variables
	useSeg	_BSS		;uninitialized variable

	INCLUDE seg.inc 	;set up segments
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE ascii.inc
	INCLUDE idmac.inc
	INCLUDE const.inc	
	INCLUDE rtps.inc	; constants shared with QBI

	SUBTTL	local constant definitions
	page

	InpSts	EQU	6	;input status for IOCTL

	TTY	EQU	0	;default b$PTRFIL is TTY

	PRSTM	EQU	0	;print statement
	CHANL	EQU	1	;#
	USING	EQU	2	;using
	WRSTM	EQU	4	;write statement
	LPSTM	EQU	8	;lprint statement

	SUBTTL	data definitions
	page

sBegin	_DATA			;initialized variables
	externB	b$IOFLAG	; Misc. IO flags.  Defined in GWINI.ASM
sEnd				;end of _DATA

sBegin	_BSS			;uninitialized variables

	staticW DispAddr,,1	; kept the dispatch address


	externW b$Buf2		; defined in GWINI.ASM
	PATH_LEN EQU b$Buf2	; save area for pathname length
				; sort of a waste, but convenient
	externW b$RECPTR
sEnd	;_BSS

	SUBTTL	code segments externals
	page

sBegin	DV_TEXT
	externNP	B$PtrDispatch
sEnd

sBegin	NH_TEXT 		;near heap
	externNP	B$LHFDBLOC	
	externNP	B$LHNXTFIL	
	externNP	B$LHLOCFDB	

	externFP	B$STDL		
	externNP	B$STALC 	

sEnd

sBegin	ER_TEXT 		;error code component
	externNP B$ERR_RVR
	externNP B$ERR_BFM
	externNP B$ERR_BRL	; Bad record length
	externNP B$ERR_FSA
	externNP B$ERR_BRN
	externNP B$ERR_IFN
	externNP B$ERR_FC
sEnd

	assumes CS,DV_TEXT	
sBegin	DV_TEXT 		; device I/O

	SUBTTL	LOC interface -- B$FLOC
	page
;***
;B$FLOC -- the current file location
;I4 B$FLOC (I2 channel)
;
;Purpose:
;	This function returns the current file location.  For a random or
;	sequential file, it returns the last record number been read/written
;	(a sequential has fix record length -- 128 bytes).  For a comm.
;	file, it returns the number of bytes in the input buffer waiting to
;	be read.
;Entry:
;	Parameter is in stack.
;	int	Channel
;Exit:
;	[DX|AX] = file location
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;*******************************************************************************

cProc	B$FLOC,<PUBLIC,FAR>
	ParmW	Channel 	;I2, channel #
cBegin
	MOV	AH,DV_LOC	;LOC function
LocLof: 			;common for LOC & LOF
	MOV	BX,Channel	;BX has the file number
	cCall	ComDsp		;dispatch to the actual working routine
				;(xxxx_LOC return results in DX:AX)
cEnd				;exit to caller

	SUBTTL	LOF interface -- B$FLOF
	page
;***
;B$FLOF -- return the length of the file
;I4 B$FLOF(I2 channel)
;
;Purpose:
;	For a disk file, it returns the size of the file.  For a comm.
;	file, it returns the amount of free space in the input buffer.
;Entry:
;	Parameter is in stack.
;	int	channel
;Exit:
;	[DX|AX] = bytes allocated for the file
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;*******************************************************************************

cProc	B$FLOF,<PUBLIC,FAR>
	ParmW	Channel 	;I2 channel #
cBegin
	MOV	AH,DV_LOF	;LOF Function
	JMP	SHORT LocLof	;dispatch to the actual working routine and
				; exit via B$FLOC
cEnd	nogen			;no code generated

	SUBTTL	WIDTH interface -- B$FWID
	page
;***
;B$FWID -- change the width of a file
;void B$FWID(I2 channel, I2 size)
;
;Purpose:
;	This routine changes the file width while the file is opened.
;	This is meaningful for LPT?.
;
;	Syntax is: WIDTH #filenum,filesiz
;
;	The routine sets the file width BEFORE file open is B$DWID.
;	The routine sets the screen width is B$WIDT.
;	The routine sets the LPRINT width is B$LWID.
;Entry:
;	Parameters in stack.
;	int	channel
;	int	wid
;Exit:
;	none
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;*******************************************************************************

cProc	B$FWID,<PUBLIC,FAR>
	ParmW	Channel 	;I2, channel #
	ParmW	Wid		;I2, width
cBegin
	MOV	BX,Channel	;BX has the file number
	MOV	DX,Wid		;DL has the width
	or	dh,dh		; if width > 255 error
	jnz	ercfc		; and
	or	dl,dl		; if width = 0 error
	jz	ercfc		

	MOV	AH,DV_WIDTH	;File width function
	cCall	ComDsp		;dispatch to the actual working routine
cEnd				;exit to caller

ercfc:	JMP	B$ERR_FC


	SUBTTL	Sequential random I/O interfaces -- B$GET1 & B$PUT1
	page
;***
;B$GET1 -- get a record sequentially
;void B$GET1(I2 channel)
;
;Purpose:
;	Get a record into random buffer if there is no record number specified.
;Entry:
;	Parameter in stack.
;	int	Channel
;Exit:
;	a record is read into the random buffer
;
;	Note: while calling RndDsp,
;		[BX]	= file number (used by B$LHFDBLOC/B$LocateFDB)
;		[AL]	= GET + Sequential flag (refer to RndDsp)
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;	bad file mode -- B$ERR_BFM
;*******************************************************************************

cProc	B$GET1,<PUBLIC,FAR>
	ParmW	Channel 	;I2, file number
cBegin
	XOR	AL,AL		;indicate GET without a specified RecNum
RndIO1:
	MOV	BX,Channel	;BX has the channel #
	cCall	RndDsp		;do it
cEnd				;exit to caller

;***
;B$PUT1 -- put a record sequentially
;void B$PUT1(I2 Channel)
;
;Purpose:
;	Put a record into random buffer with no specified record number.
;Entry:
;	Parameter in stack.
;	int		Channel
;Exit:
;	a record is put into the random buffer
;
;	Note: while calling RndDsp,
;		[BX]	= file number (used by B$LHFDBLOC/B$LocateFDB)
;		[AL]	= PUT + Sequential flag (refer to RndDsp)
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;	bad file mode -- B$ERR_BFM
;*******************************************************************************

cProc	B$PUT1,<PUBLIC,FAR>
	ParmW	Channel 	;I2 file number
cBegin
	MOV	AL,PutFlg	;indicate PUT without a specified RecNum
	JMP	SHORT RndIO1	;do it
cEnd	nogen			;exit to caller via B$GET1

	SUBTTL	Relative random I/O interfaces -- B$GET2 & B$PUT2
	page
;***
;B$GET2 -- get the record with record number specified
;void B$GET2(I2 Channel, I4 recnum)
;
;Purpose:
;	Get the record specified into random buffer.
;Entry:
;	Parameters in stack.
;	int		Channel
;	long int	RecNum
;Exit:
;	the record is read into random buffer
;
;	Note: while calling RndDsp,
;		[BX]	= file number (used by B$LHFDBLOC/B$LocateFDB)
;		[AL]	= GET + Relative flag (refer to RndDsp)
;		[CX|DX] = I4 specified record number
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;	bad file mode -- B$ERR_BFM
;	bad record number -- B$ERR_BRN
;*******************************************************************************
cProc	B$GET2,<PUBLIC,FAR>
	ParmW	Channel 	;I2 file number
	ParmD	RecNum		;I4 record number
cBegin
	MOV	AL,RelFlg	;indicate GET with record number specified
RndIO2:
	MOV	CX,Seg_RecNum	;CX = RecNum high
	OR	CX,CX		;can't be negative number
	JS	ERCBRN		;Brif negative, give "bad record number"
	MOV	DX,Off_RecNum	;DX = RecNum low
	MOV	BX,CX		;another copy of RecNum high in BX
	OR	BX,DX		;can't be zero
	JZ	ERCBRN		;Brif zero, give "bad record number"
	MOV	BX,Channel	;BX has the channel number
	cCall	RndDsp		;do the work
cEnd				;exit to caller

ERCBRN: JMP	B$ERR_BRN	;bad record number

;***
;B$PUT2 -- put a record with specified record number
;void B$PUT2(I2 Channel, I4 RecNum)
;
;Purpose:
;	Put a record into random buffer with specified record number.
;Entry:
;	Parmaters in stack.
;	int		Channel
;	long int	RecNum
;Exit:
;	a record is put into the random buffer.
;
;	Note: while calling RndDsp,
;		[BX]	= file number (used by B$LHFDBLOC/B$LocateFDB)
;		[AL]	= PUT + Relative flag (refer to RndDsp)
;		[CX|DX] = I4 specified record number
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;	bad file mode -- B$ERR_BFM
;	bad record number -- B$ERR_BRN
;*******************************************************************************

cProc	B$PUT2,<PUBLIC,FAR>
	ParmW	Channel 	;I2 file number
	ParmD	RecNum		;I4 record number
cBegin
	MOV	AL,RelFlg+PutFlg
				;indicate this is PUT with specified Rec Num
	JMP	SHORT RndIO2	;do it
cEnd	nogen			;exit via B$GET2

	SUBTTL	Relative random I/O interfaces -- B$GET3 & B$PUT3
	page
;***
;B$GET3 -- get the record with a record variable specified
;void B$GET3(I2 Channel, TYP far *recptr, I2 reclen)
;
;Purpose:
;	Get the record specified into the users record variable
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Entry:
;	Parameters in stack.
;	int		Channel
;	typ far 	*RecPtr
;	int		RecLen
;
;Exit:
;
;Note: while calling RndDsp,
;	[BX]	= file number (used by B$LHFDBLOC/B$LocateFDB)
;	[AL]	= GET + Record flag (refer to RndDsp)
;	[SI]	= record length
;	[ES:DI] = Pointer to the users record
;
;Uses:
;	none
;
;Exceptions:
;	illegal file number -- B$ERR_IFN
;	bad file mode -- B$ERR_BFM
;	bad record number -- B$ERR_BRN
;*******************************************************************************

cProc	B$GET3,<PUBLIC,FAR>
ParmW	Channel 		; I2 file number
ParmD	RecPtr			; far record pointer
ParmW	RecLen			; i2 record length
cBegin
	MOV	AL,RecFlg	; indicate GET with record variable specified
RndIO3: 			
	MOV	BX,Channel	; [BX] = channel number
	PUSH	SI		
	PUSH	DI		
	PUSH	ES		

	MOV	SI,RecLen	; [SI] = Record length
	LES	DI,RecPtr	; [ES:DI] = Record Pointer
	cCall	RndDsp		; do the work

	POP	ES		
	POP	DI		
	POP	SI		
cEnd				; exit to caller

;***
;B$PUT3 -- put a record from specified record variable
;void B$PUT3(I2 Channel, TYP far *recptr, I2 reclen)
;
;Purpose:
;	Put a record from record var
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Entry:
;	Parameters in stack.
;	int		Channel
;	typ far 	*RecPtr
;	int		RecLen
;
;Exit:
;
;Note: while calling RndDsp,
;	[BX]	= file number (used by B$LHFDBLOC/B$LocateFDB)
;	[AL]	= PUT + Record flag (refer to RndDsp)
;	[SI]	= record length
;	[ES:DI] = Pointer to the users record
;
;Uses:
;	none
;
;Exceptions:
;	illegal file number -- B$ERR_IFN
;	bad file mode -- B$ERR_BFM
;	bad record number -- B$ERR_BRN
;*******************************************************************************
cProc	B$PUT3,<PUBLIC,FAR>	
ParmW	Channel 		; I2 file number
ParmD	RecPtr			; far record pointer
ParmW	RecLen			; i2 record length
cBegin				
	MOV	AL,RecFlg+PutFlg; indicate this is PUT with record var
	JMP	SHORT RndIO3	; do it
cEnd	nogen			; exit via B$GET3

	SUBTTL	Relative random I/O interfaces -- B$GET4 & B$PUT4
	page
;***
;B$GET4 -- get the record with record number specified to record var
;void B$GET4(I2 Channel, I4 recnum, TYP far *recptr, I2 reclen)
;
;Purpose:
;	Get the record specified into user record
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Entry:
;	Parameters in stack.
;	int		Channel
;	long int	RecNum
;	typ far 	*RecPtr
;	int		RecLen
;
;Exit:
;
;Note: while calling RndDsp,
;	[BX]	= file number (used by B$LHFDBLOC/B$LocateFDB)
;	[AL]	= GET + Relative flag (refer to RndDsp)
;	[CX|DX] = I4 specified record number
;	[SI]	= record length
;	[ES:DI] = Pointer to the users record
;
;Uses:
;	none
;
;Exceptions:
;	illegal file number -- B$ERR_IFN
;	bad file mode -- B$ERR_BFM
;	bad record number -- B$ERR_BRN
;*******************************************************************************
cProc	B$GET4,<PUBLIC,FAR>	
ParmW	Channel 		; I2 file number
ParmD	RecNum			; I4 record number
ParmD	RecPtr			; far record pointer
ParmW	RecLen			; I2 record length
cBegin

	MOV	AL,RelFlg+RecFlg; indicate GET with record number & var
RndIO4:
	MOV	CX,Seg_RecNum	; CX = RecNum high
	OR	CX,CX		; can't be negative number
	JS	ERCBRN		; Brif negative, give "bad record number"
	MOV	DX,Off_RecNum	; DX = RecNum low
	MOV	BX,CX		; another copy of RecNum high in BX
	OR	BX,DX		; can't be zero
	JZ	ERCBRN		; Brif zero, give "bad record number"
	MOV	BX,Channel	; BX has the channel number
	PUSH	SI		
	PUSH	DI		
	PUSH	ES		

	MOV	SI,RecLen	; [SI] = Record length
	LES	DI,RecPtr	; [ES:DI] = Record Pointer
	cCall	RndDsp		; do the work

	POP	ES		
	POP	DI		
	POP	SI		
cEnd				; exit to caller

;***
;B$PUT4 -- put a record with specified record number from record var
;void B$PUT4(I2 Channel, I4 RecNum, TYP far *recptr, I2 reclen)
;
;Purpose:
;	Put a record from record var with specified record number.
;
; NOTE: This routine can take a far pointer to a movable item in a heap. This
; routine cannot directly or indirectly cause heap movement.
;
;Entry:
;	Parmaters in stack.
;	int		Channel
;	long int	RecNum
;	typ far 	*RecPtr
;	int		RecLen
;
;Exit:
;
;Note: while calling RndDsp,
;	[BX]	= file number (used by B$LHFDBLOC/B$LocateFDB)
;	[AL]	= GET + Relative flag (refer to RndDsp)
;	[CX|DX] = I4 specified record number
;	[SI]	= record length
;	[ES:DI] = Pointer to the users record
;
;Uses:
;	none
;
;Exceptions:
;	illegal file number -- B$ERR_IFN
;	bad file mode -- B$ERR_BFM
;	bad record number -- B$ERR_BRN
;*******************************************************************************
cProc	B$PUT4,<PUBLIC,FAR>	
ParmW	Channel 		; I2 file number
ParmD	RecNum			; I4 record number
ParmD	RecPtr			; far record pointer
ParmW	RecLen			; I2 record length
cBegin				
	MOV	AL,RelFlg+PutFlg+RecFlg ; indicate PUT Rec Num & Rec Var
	JMP	SHORT RndIO4	; do it
cEnd	nogen			; exit via B$GET4

Locals	PROC	NEAR
	SUBTTL	B$FREF - Return next available file number
	PAGE
;***
; B$FREF - Return next available file number
; int pascal B$FREF(void)
;
;Purpose:
; Runtime entry point to return the next available file number. This is done
; by a pretty dumb repetative linear search of all FDBs, trying all file
; numbers starting at 1. Anything more intelligent is probably more effort
; than it's worth, since the call to FREEFILE will more often than not be
; followed by an OPEN call, which is probably I/O bound.
;
;Entry:
; None.
;
;Exit:
; [AX]	= Next available file number.
;
;Uses:
; Per convention.
;
;Exceptions:
; B$ERR_SSC, if the heap is screwed up.
;
;******************************************************************************
cProc	B$FREF,<FAR,PUBLIC,FORCEFRAME>,<SI> 
cBegin				

	XOR	AX,AX		; [AX] = potential "next" file number
FREF_5: 			; Loop to restart at beging of FDB chain
	XOR	SI,SI		; [SI] = Flag to get first FDB pointer
	INC	AX		; [AX] = next potential "next" filenumber
FREF_10:			; Loop for each FDB
	CALL	B$LHNXTFIL	; [SI] = pointer to next FDB
	JZ	FREF_90 	; Jump if no more FDB's (we're done)
	CALL	B$LHLOCFDB	; [BL] = filenumber associated with FDB
	CMP	AL,BL		; See if our "guess" is being used
	JNZ	FREF_10 	; loop to go check next FDB if not used
	JMP	FREF_5		; else loop to attempt a new guess
FREF_90:			; FDB chain end found, and guess not used

cEnd				

	SUBTTL	EOF interface -- B$FEOF
	page
;***
;B$FEOF -- function which detects the EOF for a file
;I2 B$FEOF(I2 Channel)
;
;Purpose:
;	Detect whether the EOF is reached.  This function is only significant
;	for  a input or communication file.
;
;	Note: EOF won't return true (-1) for a random file, even if you GET
;		a record beyond the file end.  However, that GET gets a null
;		record.
;
;Entry:
;	Parameter in stack.
;	int	Channel
;Exit:
;	[AX]	= -1	EOF is reached for a sequential input file, or
;			communication buffer is empty
;		= 0	EOF is not reached yet
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;*******************************************************************************

cProc	B$FEOF,<PUBLIC,FAR>
	ParmW	Channel 	;I2, file number
cBegin
	MOV	BX,Channel	;BX has file number

	OR	BX,BX		;special for standard input ?
	JZ	REDIR		;Brif yes
	MOV	AH,DV_EOF	;end of file function
	cCall	ComDsp		; do it, on return [AX] has the result

	JMP	SHORT EOFExit	;exit to caller
REDIR:
	TEST	b$IOFLAG,RED_INP ; is input file redirected ?
	JZ	ERCIFN		; Brif not, give "illegal file number"
	MOV	AX,C_IOCTL SHL 8 + InpSts ; get input status
	INT	21h		; is the end of a file ?
				;[AL] = 0FFH if not end of file
				;[AL] = 0    if end of file
	CBW			;result in AX
	NOT	AX		; and pervert
EOFExit:

cEnd				;clear stack and return

	SUBTTL	B$FATR - FILEATTR function
	PAGE
;***
; B$FATR - FILEATTR function
; I4 pascal B$FATR(I2 channel, I2 fieldid)
;
;Purpose:
; Returns specific information from an FDB, based on the fieldid value. This
; interface allows us to muck with the FDB, and still provide the same info
; to the user in a stable fasion.
;
;Entry:
; channel	= File number to be queried
; fieldid	= field number to be returned
;
;Exit:
; [DX:AX]	= requested information
;
;Uses:
; Per convention
;
;Exceptions:
; B$ERR_FC	= Bad field number
;
;******************************************************************************
cProc	B$FATR,<FAR,PUBLIC>,<SI> 
parmW	channel 		; file to futz with
parmW	fieldid 		; field desired
cBegin				

	MOV	BX,channel	; [BX] = File's channel #
	cCall	B$LHFDBLOC	; [SI] = FDB pointer (NZ if found)
	JNZ	FATR_3		; Jump if so
	JMP	B$ERR_IFN	; else bad file number

FATR_3: 			
	MOV	BX,fieldid	; [BX] = user requested field
	DEC	BX		; Make it zero-relative
	CMP	BX,FIELDID_MAX	; See if in range
	JB	FATR_5		; Jump if valid request
	JMP	B$ERR_FC	; Else illegal function call

FATR_5: 			
	ADD	BX,BX		; [BX] = word offset into table
	XOR	AX,AX		; Init I4 return value
	CWD			
	FDB_PTR ES,SI,SI	;(ES:)[SI] = * FDB
	ADD	SI,CS:[BX].FIELDOFF_TABLE ; FDB field by fun. (zero rel)
	JMP	CS:[BX].FIELDDISP_TABLE   ; Dispatches by fun. (zero rel)

FATR_TWO:			; Dispatch point for two byte fields
	LODS	WORD PTR FileDB ; Load FDB word
	JMP	SHORT FATR_90	

FATR_ONE:			; Dispatch point for one byte fields
	LODS	BYTE PTR FileDB ; Load FDB byte

FATR_90:			

cEnd				

ERCIFN: JMP	B$ERR_IFN	;illegal file number

	SUBTTL	general I/O supporting routines
	page
;***
;ComDsp -- common dispatch routine
;
;Purpose:
;	This common dispatch routine checks the legality of the channel
;	and then dispatch to the actual working routine.
;Entry:
;	[AH]		= fucntion number (minor #)
;	[BX]		= file number
;Exit:
;	depends on function
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;*******************************************************************************

cProc	ComDsp,<NEAR>,<SI>	;save SI

cBegin
	CALL	B$LHFDBLOC	;[SI] = file data block pointer
	JZ	ERCIFN		;Error - illegal file number
	CALL	B$PtrDispatch	; dispatch to the working routine
cEnd				;pop si and exit to caller

;***
;RndDsp -- dispatch for random I/O
;
;Purpose:
;	Check the legality of the file number and the file mode.  If both
;	OK, dispatch to the working routine.
;Entry:
;	[AL]		= flags
;			  Bit 0: 1 if PUT, else GET
;			  BIT 1: 1 if explicit record number specified
;			  BIT 2: 1 if record variable specified
;	[BX]		= file number
;	[CX:DX] 	= record number if RelFlg is on. Note: use [CX|DX] here
;			  for the consistence with DOS function call
;	[ES:DI] 	= record variable address, if RecFlg is on
;	[SI]		= record variable length, if RecFlg is on
;
;
;Exit:
;	a record is in random buffer
;Uses:
;	none
;Exceptions:
;	illegal file number -- B$ERR_IFN
;	bad file mode -- B$ERR_BFM
;*******************************************************************************

cProc	VarStrLenDsp,<NEAR>,<SI,ES,DI>	
cBegin					
	jmp	VarStrLen_Entry 	
cEnd	<nogen> 			

cProc	RndDsp,<NEAR>,<SI,ES,DI> 
cBegin
	PUSH	SI		; preserve record length
	CALL	B$LHFDBLOC	;NZ & [SI]=*FDB if file number found
	POP	BX		; [BX] = length of record variable
	JZ	ERCIFN		;Brif not found, give "illegal file number"

	FDB_PTR ES,SI,SI	;(ES:)[SI] = *FDB
	TEST	FileDB.FD_MODE,MD_RND+MD_BIN ; random or binary?
	JNZ	RND_OR_BIN	
	JMP	ERCBFM		; brif not - bad file mode
RND_OR_BIN:
	TEST	AL,RecFlg	; See if record variable passed
	JNZ	RndDsp_5	; Jump if it was

	TEST	FileDB.FD_MODE,MD_BIN ; binary mode?
	JZ	NOT_BIN 	
	JMP	ERCRVR		; brif so -- record variable required
NOT_BIN:

	PUSH	DS		; Form...
	POP	ES		;   pointer in...
	LEA	DI,FileDB.FD_BUFFER ;[ES:DI] ptr to record (field buffer)
	MOV	BX,FileDB.FD_VRECL  ;[BX] = length of record (LEN= length)
	JMP	SHORT RndDsp_15 ; go finish dispatch

RndDsp_5:			; record variable was passed in
	OR	BX,BX		; 0-length read/write?
	JNZ	NotSD		; brif not -- not a string descriptor
				; A 0-length means that we have a string
				; descriptor and that we must dereference
				; ES:DI = string descriptor address


	TEST	FileDB.FD_MODE,MD_BIN ; binary mode?
	JNZ	NotVarLenStr	; brif so -- no special string handling


;	Special code to handle puts/gets from/into variable-length strings.
;	For random files, the length of the string will be placed in the file
;	before the string data.

	push	ax		; save flags
	push	cx		; save optional record #
	push	dx		

	mov	bx,2		; length to read/write
	or	al,VarStrLen	; don't increment record # after next op.
	test	AL,PutFlg	; PUT statement?
	jnz	PutStrLen	; brif so -- output length

				; GET statement
	;(othewise, ES should be equal to ds/ss)

	push	bx		; save '2'
	push	di		; save SD offset
	push	ax		; space for length on stack
	mov	di,sp		; ES:DI = addr of length word
	call	VarStrLenDsp	; read length of string into ES:DI
	pop	ax		; AX = length to read (new str length)
	pop	di		; DI = SD offset
	pop	bx		; BX = 2 (total # to read)

	FDB_PTR  ES,si,si	 ; restore (ES:)[SI] = *FDB for ChkRandom
	add	bx,ax		
	call	ChkRandom	; do verification

	push	ax		; save length
	cCall	B$STDL,<DI>	; deallocate existing string
	pop	cx		; restore CX = length

	jcxz	RestoreState	; brif zero-length string -- don't do ALLOC

	mov	bx,cx		; BX = new string length
	call	B$STALC 	; alloc string with new length, BX=*str data
	mov	[di],cx 	; set SD string length
	mov	[di+2],bx	; set SD string address
	mov	[bx-2],di	; set back pointer
	jmp	short RestoreState 

PutStrLen:			; PUT statement, DS:[DI] = str len (from SD)
	push	bx		; save '2'
	add	bx,[di] 	; bx = 2+string length

	call	ChkRandom	; do verification
	pop	bx		; restore bx = 2
	call	VarStrLenDsp	; write length of string to file


RestoreState:			
	pop	dx		; restore optional record #
	pop	cx		
	pop	ax		; restore flags
	or	al,VarStrData	; don't seek before next get/put

NotVarLenStr:			


	MOV	BX,ES:[DI]	; BX = string length
	MOV	DI,ES:[DI+2]	; DS:DI = string address
	PUSH	DS		; ES:DI = string address
	POP	ES		
	OR	BX,BX		; null string?
	JZ	RndExit 	; brif so -- return without doing anything
	FDB_PTR ES		;restore FDG SEG in ES

NotSD:				
	TEST	FileDB.FD_MODE,MD_BIN ; binary mode?
	JNZ	RndDsp_15	; brif so -- skip checks for bad record
				; length and field statement
VarStrLen_Entry:
	call	ChkRandom

RndDsp_15:			
	MOV	[b$RECPTR],DI	
	MOV	[b$RECPTR+2],ES ; [b$RECPTR] = record pointer
	MOV	AH,DV_RANDIO	;AH=function number (minor #)
	CALL	B$PtrDispatch	; dispatch to the working routine
RndExit:			
cEnd				;pop si, exit to caller


;*** 
;ChkRandom -- verify stuff before RANDOM file I/O
;
;Purpose:
;	Added with revision [43] to save code.
;
;Entry:
;	BX = length to read/write (includes count word for variable-length
;		strings as record variables).
;Exit:
;	None
;Uses:
;	None
;Preserves:
;	All
;Exceptions:
;	Bad record length, Field statement active
;
;******************************************************************************
cProc	ChkRandom,<NEAR>
cBegin
	CMP	BX,FileDB.FD_VRECL	; record too long?
	JA	ERCBRL			; brif so -- Bad record length
	TEST	FileDB.FD_FLAGS,FL_FIELD ; FIELD stmt active for this FDB?
	JNZ	ERCFSA			; brif so -- FIELD statement active
cEnd

ERCBRL: JMP	B$ERR_BRL
ERCFSA: JMP	B$ERR_FSA

; FIELDOFF_TABLE
;
; Table of FDB fields offsets that FILEATTR will return. Each entry contains
; the location within the FDB of the field to be returned.
;
; FIELDDISP_TABLE
; table of routine offsets to execute to fetch a particular field.
;
labelW	FIELDOFF_TABLE		
	DW	FD_MODE 	; 1: File Mode
	DW	FD_HANDLE	; 2: DOS file handle

labelW	FIELDDISP_TABLE 	
	DW	FATR_ONE	; 1: File Mode: one byte
	DW	FATR_TWO	; 2: DOS file handle: two byte

FIELDID_MAX	=	2		; last entry in table

Locals	ENDP

ERCBFM: JMP	B$ERR_BFM	;bad file mode
ERCRVR: JMP	B$ERR_RVR	;record variable required

sEnd	;DV_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\erhandlr.asm ===
TITLE	ERHANDLR - Error trapping for 8086 Basic Compiler
        page ,132
;***
; ERHANDLR - Error trapping for 8086 Basic Compiler
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
; This module contains the run-time support for on-error handling.
;
;******************************************************************************
	INCLUDE switch.inc	;Rutime switch file
	INCLUDE rmacros.inc	;General runtime macros

	useSeg	_BSS		
	useSeg	_DATA		
	useSeg	ER_TEXT 	
	useSeg	NH_TEXT 	

	INCLUDE seg.inc 	;Segment definitions
	INCLUDE addr.inc	;Frame and module specific data definitions
	INCLUDE	baslibma.inc	; need the SKIP macro
	INCLUDE idmac.inc	
	INCLUDE messages.inc	;error message label definitions
	INCLUDE stack.inc	


sBegin	_BSS			

externW b$errnum		; Error number encountered
externB b$inonerr		; flag indicating we're in an on error
externW b$curlevel		; current program level
externW	b$curframe		; current BASIC frame parameter
externD b$errmod		; error module name address
externW	b$cCSubs		
externW	b$cNonQBIFrames		

sEnd	_BSS			

sBegin	NH_TEXT 		
externNP B$STDALCALLTMP 	
sEnd	NH_TEXT 		

externFP	B$CONERR	
externFP	B$ClearRange	

sBegin	ER_TEXT 		

externNP B$GETMODCODE		;Get module specific code data.
externNP	B$IONERR	; interpreter-specific on error handler
externNP	B$IErrSaveState	
externNP	B$IErrRestState	
externNP B$ERR_RE		


assumes CS,ER_TEXT		

;******************************************************************************
;
; Runtime Error Handling
;
; ON ERROR processing
;
; When an error occurs, the common runtime error handler will first call
; B$ONERR to allow us to attempt to process any ON ERROR statement that
; may apply. To get the runtime context, we rely on the
; fact that the passed frame pointer points to stack entries as follows:
;
;	  +-->	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;	User	|						|
;	Program \   Defined by Compiler/Interpreter & Runtime	\
;	Frame	|						| <-+
;	  +-->	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+   |
;		|						|   |
;		\ 	User program local storage		\   |
;		\   Gosubs on stack on common runtime entry	\   |
;		|						|   |
;	  +-->	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+   |
;	  |	|						|   |
;	  |	\ 	Parameters to Common Runtime Entry	\   |
;	Common	|						|   |
;	Runtime +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+   |
;	Entry	| CS						|   |
;	Frame	+  Far return address into BASIC program code	+   |
;	  |	| IP						|   |
;	  |	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+   |
;	  |	|	BP value on entry to Common Runtime	| --+ <- pframe
;	  +-->	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;
; From this frame we get the the user program frame (defined elsewhere), from
; which we can find the data structure containing the ON ERROR address for the
; user program if it exists. If this does exist we can perform the ON ERROR.
;
; To process the ON ERROR, we first use the frame to determine the line number
; at which the error occured. The stack is then reset to an appropriate level,
; and we perform the GOSUB.
;
; See erproc.asm for more information on error handling.
;
;******************************************************************************

	SUBTTL	B$ONERR -- Find ON ERROR handler if possible
	PAGE
;
;*** 
;B$ONERR - Find most recent BASIC error handler if any
; Call via [b$pONERR] for /O granularity.
;
;Purpose:
;	This routine will search through BASIC stack frames starting with
;	the one in which the error occurred until it finds one with an
;	error handler or until there are no more BASIC stack frames left 
;	to check.  It will also stop if it encounters a BASIC event handler
;	at the previous level.  If it finds an error handler, it will adjust
;	the environment to look as if the error occurred at the current 
;	statement of that module.  Otherwise, nothing is changed. 
;
;Entry:
;	[b$curframe] valid.
;	[BX] = frame parameter preceding [b$curframe] in BP chain.
;	IF EI_QB THEN [b$cCSubs], [b$cNonQBIFrames] valid.
;	[b$errnum] <> 98xxh.
;
;Exit:
;	No error handler found.
;
;Uses:
;	Per convention.
;
;Preserves:
;	None.
;
;Exceptions:
;	None.
;
;******************************************************************************
cProc	B$ONERR,<PUBLIC,NEAR>
cBegin

DbAssertRelB	<BYTE PTR [b$errnum+1]>,NE,<98h>,ER_TEXT,<Bad errnum in B$ONERR>
DbAssertRel	<[BX]>,E,<[b$curframe]>,ER_TEXT,<Bad frame parameter in B$ONERR>

	PUSH	[b$curframe]
	PUSH	[b$curlevel]
	PUSH	[b$cCSubs]		; save original [b$cCSubs]
	PUSH	[b$cNonQBIFrames]	; save original [b$cNonQBIFrames]
	cCall	B$IErrSaveState		; allow interpreter to save state
;
; This is the main loop that walks the BASIC frame chain and calls either
; B$IONERR or B$NCONERR as appropriate.
;
ONERR_10:
	CMP	[b$curframe],0
DJMP	JZ	ONERR_EXIT		; reached the end of BASIC chain
;
; Skip over non-BASIC frames in the BP-chain to find the frame immediately
; preceding the BASIC frame in the BP chain.
;
ONERR_20:
	MOV	DX,BX			;DX = old value of BX
	MOV	BX,[BX]			;use bp chain
DbAssertTsT	BX,Z,1,ER_TEXT,<Odd BP value found in B$ONERR> 
DbAssertRel	BX,NZ,0,ER_TEXT,<Bad BP chain in B$ONERR>
	CMP	BX,[b$curframe]
	JNE	ONERR_20
	; [DX] = frame preceding [BX]
	PUSH	DX			; parameter to B$xONERR
	CMP	[b$cCSubs],0		; check for interpreting module
	JNZ	ONERR_30		
	cCall	B$IONERR		;returns AX = 0 => quit
	JMP	SHORT ONERR_40
ONERR_30:
	cCall	B$NCONERR		; returns AX = 0 => quit
ONERR_40:
	OR 	AX,AX			;AX <> 0 => no error handler
	JZ	ONERR_EXIT		;quit - restore org. env. & return
DbAssertRelB	<[b$inonerr]>,Z,0,ER_TEXT,<b$inonerr was TRUE in B$ONERR loop>
	DEC	[b$curlevel]
	JS	ONERR_EXIT		; kind of redundent check
; addjust [b$cCSubs] to reflect current frame
;
	CMP	[b$cCSubs],0		; are we already interpreting?
	JZ	ONERR_60		; brif interpreting
	DEC	[b$cCSubs]		; adjust [b$cCSubs]
	JNZ	ONERR_60		; need to adjust b$cNonQBIFrames?
	DEC	[b$cNonQBIFrames]	; yes -- decrement
ONERR_60:
;
; Walk the BASIC frame chain to check for an error handler in the next
; previous BASIC module.
;
	MOV	BX,[b$curframe]
	MOV	AX,[BX].FR_BFRAME	;[AX] = NEXT BASIC FRAME
	MOV	[b$curframe],AX		;update b$curframe
DJMP	JMP	SHORT ONERR_10		

					; error handler not found
ONERR_EXIT:				; restore original error state
	cCall	B$IErrRestState		; allow interpreter to restore state
	POP	[b$cNonQBIFrames]	; restore original [b$cNonQBIFrames]
	POP	[b$cCSubs]
	POP	[b$curlevel]
	POP	[b$curframe]
cEnd

	SUBTTL	B$CONERR - Compiler ON ERROR Processing - Enhanced version
	PAGE
;***
; B$CONERR - Handle ON ERROR Processing -new version
; B$NCONERR - New error handling COMPILER ON ERROR processing
; void B$CONERR(U2 pframe)
;
;Purpose:
; If enabled, performs ON ERROR transfer of control within the user program.
; This is the NEW version of B$CONERR.  Changes and enhancements should only be
; made to this version.  The old version in erbcproc.asm should not be changed.
; It is necessary for backward compatibility with QB4 QLB's.
;
; We check the module data area for the address of an ON ERROR routine. If
; one is available, we:
;	- Save the error address (offset & segment)
;	- Get and save the statement number
;	- If the error was "Out Of Memory" reset the gosub count to zero
;	- Deallocate local storage and temp. string descriptors as necessary
;	- Reset the stack (SP & BP) to execution levels:
;		BP = [b$curframe].
;		SP = [b$curframe] - <local storage> - (<GOSUB level> X 2).
;	- Perform the GO TO
;
;Entry:
; pframe	= Pointer to a frame one level below b$curframe
; [b$curframe]	= basic-level frame.
; [b$errnum]	= error number
;
;Exit:
; [b$errmod]	= far address of module name
; IF AX = 0 THEN
;	no error trapping is possible
; ELSE
; 	no error handler found
; ENDIF
; IF an error handler is found THEN
;	[b$erradr]	= far address of error in the compiled code
;	[b$errlin]	= line number of error
; ENDIF
;
; Doesn't return if an active BASIC error handler is available.
;
;******************************************************************************

cProc	B$NCONERR,<PUBLIC,NEAR>	; new name for B$CONERR

parmW	pframe			; frame pointer one level below error time
cBegin

	XOR	AX,AX		; Get first byte
	cCall	B$GETMODCODE	; AL = first byte, [BX] = code segment
	MOV	AX,CX		; CX = module header offset (0 for DOS3)
	ADD	AX,OF_MOD	
	MOV	WORD PTR [b$errmod],AX ; Far pointer to module name
	MOV	WORD PTR [b$errmod + 2],BX 

	CMP	[b$inonerr],FALSE ; Are we in on-error handler?
DJMP	JNZ	BCONERR_90	; Jump if we are, error-within-error occurred
	MOV	AX,b$errnum	; get error number
	OR	AH,AH		; See if valid trappable error
	JNZ	BCONERR_90	; Jump if [b$errnum] > 255, internal error

	XCHG	DX,BX		; DX = user code segment
	PUSH	CX		; save module header offset
	POP	BX		; restore module header offset
	PUSH	DS		; save DGROUP
	MOV	DS,DX		; [DS] = user code seg
	MOV	BX,DS:[BX].OF_DAT ; [BX] = mod specif data offset
	POP	DS		; [DS] = DGROUP restored
	MOV	CX,[BX].OFD_ONERROR ; [CX] = on error address
	MOV	BX,pframe	; [BX] = pointer to rt entry frame
DbAssertRel	DX,E,<[BX].FR_RETSEG>,ER_TEXT,<Bad user code seg in B$NCONERR>
	PUSH	BX		; push frame parameter for old B$CONERR
	JCXZ	BCONERR_80	; Jump if no address specified - quit
;
; The error can be trapped. Set the "in on error handler" flag, and call the
; appropriate on error handler.
;
	MOV	AX,[BX] 	; AX = [b$curframe]
	MOV	BX,AX		; BX = AX = [b$curframe]
	SUB	AX,[BX].FR_CLOCALS ; [AX] = [b$curframe] - locals/temps
	SUB	AX,[BX].FR_GOSUB ; [AX] = [b$curframe] - locals - gosubs/2
	SUB	AX,[BX].FR_GOSUB ; [AX] = [b$curframe] - locals - gosubs
	SUB	AX,FR_SIZE+2	; can combine 3 instructions for QB case
	PUSH	BP		; old_BP = FROM parameter to B$ClearRange
	PUSH	AX		; new_SP-2 = TO parameter to B$ClearRange
	CALL	B$ClearRange	; deallocate local variables on STACK
	MOV	AX,[b$curlevel]	; deallocate temp strings > [b$curlevel]
	CALL	B$STDALCALLTMP	; dealloc temp strings no longer needed

BCONERR_80:			; no error handler - check for event handler
	cCALL	B$CONERR	; frame parameter pushed way above
	MOV	[b$inonerr],FALSE ; necessary after call to old B$CONERR
; check if the curent frame is for an event handler
	MOV	BX,[b$curframe]	
	CALL	B$CEvtHndlr	; returns AX = 0 if an event handler frame
	SKIP	2		; JMP SHORT BCONERR_100
BCONERR_90:			
	XOR	AX,AX		; return AX = 0 means process fatal error
BCONERR_100:			
cEnd

	SUBTTL	RESUME helpers
	PAGE
;***
; B$RESUMED - Set up for RESUME of some sort
; Interpreter Entry
; Moved here from erproc.asm
;
;Purpose:
; If RESUME [linenumber|linelabel], reset program level to 0 and deallocate
;	all temporary strings.
; Ensure that error is in progress, and then clean flags
;
;Entry:
; [AX]	= RESUME type, 0     = RESUME [linenumber|linelabel]
;		       non-0 = other RESUME
;	(parameter on stack for OE_WIN)
;
;Exit:
; if ready to resume. Flags cleared
;
;Exceptions:
; Aborts if no error in progress
;
;******************************************************************************

cProc	B$RESUMED,<PUBLIC,FAR,FORCEFRAME> ; moved here from erproc.asm
cBegin				
	OR	AX,AX		;resume to level 0?
	JNZ	NotLev0 	;go if not
	MOV	b$curlevel,AX	;set current level to main level (0)
	CALL	B$STDALCALLTMP	;dealloc all temp strings
NotLev0:			
	cCall	B$RES_SETUP	; Perform Function
cEnd				


;***
; B$RES_SETUP - Set up for RESUME of some sort
; Moved here from erproc.asm
;
;Purpose:
; Ensure that error is in progress, and then clean flags
;
;Entry:
; none
;
;Exit:
; if ready to resume. Flags cleared
;
;Exceptions:
; Aborts if no error in progress
;
;******************************************************************************
cProc	B$RES_SETUP,<NEAR,PUBLIC> ; moved here from erproc.asm
cBegin				

	XOR	CX,CX		
	MOV	[b$errnum],CX	; if error below, this gets reset anyway
	XCHG	CL,[b$inonerr]	
	JCXZ	RES_SETUP_OOPS	; brif wern't in error handler
cEnd				

RES_SETUP_OOPS: 		
	POP	AX		; Discard local return
	JMP	B$ERR_RE	

;*** 
;B$CEvtHndlr - Checks if a frame is an event handler
;
;Purpose:
;	Determine whether the frame is for an active compiled event handler.
;	Moved this code back with [6].
;
;	NOTE: this code is duplicated in ERROR.ASM.
;
;Entry:
;	BX = pointer to the COMPILED BASIC frame to check (ie. [b$curframe]).
;
;Exit:
;	AX = 0 IFF an event handler is detected.
;
;Uses:
;	AX, BX.
;
;Exceptions:
;	None.
;
;******************************************************************************
cProc	B$CEvtHndlr,<NEAR>	
cBegin
;
; This is the compiler-specific logic to check for a BASIC event handler:
;
	MOV	AX,[BX].FR_GOSUB ; AX = count of GOSUBS
DbAssertRel	AX,GE,0,ER_TEXT,<More than 32767 GOSUBs in B$CEvtHndlr> ;
	DEC	AX		; if AX = 0, return AX <> 0
	JS	No_handler	; no gosubs => no event handler
	SUB	BX,[BX].FR_CLOCALS ; BX = BX - number of local bytes
	MOV	AX,[BX-FR_SIZE-2] ; AX = 0 IFF event handler
No_Handler:
cEnd				; return

sEnd	ER_TEXT 		


	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\dvpipe.asm ===
TITLE	DVPIPE - Support for the PIPE: device
;***
; DVPIPE - device IO support for the PIPE: device
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This module contains the device specific interface for the pipe
;	device.
;
;	The following is the pipe dispatch table.  Each entry is the addr.
;	of the actual working routine.	The routine name is composed by the
;	prefix "PIPE_" and the function name, e.g., PIPE_EOF is the routine
;	name for EOF function.
;
;	B$D_PIPE:
;		 ________
;		|	 |
;		| EOF	 |
;		|--------|
;		| LOC	 |
;		|--------|
;		| LOF	 |
;		|--------|
;		| CLOSE  |
;		|--------|
;		| WIDTH  | *
;		|--------|
;		| RANDIO | = B$ERR_BFM
;		|--------|
;		| OPEN	 |
;		|--------|
;		| BAKC	 |
;		|--------|
;		| SINP	 |
;		|--------|
;		| SOUT	 | = B$PIPE_SOUT in dkio.asm
;		|--------|
;		| GPOS	 | *
;		|--------|
;		| GWID	 | *
;		|--------|
;		| DWID	 | = B$ERR_FC
;		|--------|
;		| BLKIN  | = B$ERR_BFM
;		|--------|
;		| BLKOUT | = B$ERR_BFM
;		|________|
;	* = could use disk io routine with marginal savings.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	USESEG	ER_TEXT
	USESEG	DV_TEXT
	USESEG	DK_TEXT
	USESEG	NH_TEXT
	USESEG	RT_TEXT
	USESEG	OS_TEXT
	USESEG	_DATA
	USESEG	_BSS

	INCLUDE seg.inc
	INCLUDE baslibma.inc
	INCLUDE devdef.inc
	INCLUDE files.inc
	INCLUDE oscalls.inc
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE idmac.inc	; Debugging Macros


sBegin	ER_TEXT
	externNP B$ERR_DNA	;device not available
sEnd

assumes CS,DV_TEXT
sBegin	DV_TEXT

DSPMAC	MACRO	FUNC
	DW	B$ERR_DNA
	ENDM


;Map all dispatch routines to device not available

labelNP <PUBLIC, B$D_PIPE>	
	DSPNAM

sEnd	DV_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\error.asm ===
TITLE	ERROR - Error trapping for 8086 Basic Compiler
        page ,132
;***
; ERROR - Error trapping for 8086 Basic Compiler
;
;	Copyright <C> 1986, 1987, Microsoft Corporation
;
;Purpose:
; This module contains the run-time support for error trapping in addition to
; the standard routines.
;
; BASIC Syntax mapping to included runtime entry points:
;
; - ERR Variable:
;
;      v = ERR
;	    |
;	  B$FERR
;
;
; - ERL Variable:
;
;      v = ERL
;	    |
;	  B$FERL
;
;
; - ON ERROR Statement:
;
;      ON ERROR GOTO line
;      ------------------
;	       |
;	     B$OEGA
;
;
; - RESUME Statement
;
;      RESUME [0 | NEXT | line]
;
;    Examples:
;
;      RESUME	       RESUME 0 	 RESUME NEXT	      RESUME 10
;	  |	       -------- 	 -----------	      ---------
;	  |		   |		      | 		   |
;      B$RES0	       B$RES0		   B$RESN		B$RESA
;
;
;******************************************************************************
	INCLUDE switch.inc	;Rutime switch file
	INCLUDE rmacros.inc	;General runtime macros

	useSeg	_BSS		
	useSeg	_DATA		
	useSeg	ER_TEXT 	
	useSeg	NH_TEXT 	

	INCLUDE seg.inc 	;Segment definitions
	INCLUDE addr.inc	;Frame and module specific data definitions
	INCLUDE idmac.inc	
	INCLUDE messages.inc	;error message label definitions
	INCLUDE stack.inc	

sBegin	_BSS			

externD b$erradr		; Far ptr to basic error address
externW b$errnum		; Error number encountered
externW b$errlin		; Basic line number of error
externB b$inonerr		; flag indicating we're in an on error
externW b$curlevel		;current program level
externW b$curframe		; pointer to current BASIC frame
externW	b$cCSubs		; <> 0 means compiled code

sEnd	_BSS			

externFP B$EXSA		; clear frame state info

externFP B$SERR		
externFP B$CEND		

sBegin	NH_TEXT 		
externNP B$STDALCALLTMP 	
sEnd	NH_TEXT 		

sBegin	ER_TEXT 		

externNP B$CALCLINE		;Get line number & start address of stmnt
externNP B$GETMODCODE		;Get module specific code data.
externNP B$RES_SETUP		;Clear flags for RESUME

assumes CS,ER_TEXT		

	SUBTTL	B$OEGA - ON ERROR GOTO statement handler
	PAGE
;***
; B$OEGA - ON ERROR GOTO statement handler
;
;Purpose:
; sets the address to which an error is to branch. If zero, and we are in an
; on error handler, then declare a fatal error.
;
;Entry:
; erradr = statement address or 0
;
;Exit:
; Sets error vector with line number address
;
;Exceptions:
; erradr == 0 and an error is in progress, will jump to B$SERR instead of
; returning.
;
;******************************************************************************
cProc	B$OEGA,<FAR,PUBLIC>	
parmD	erradr			
cBegin				

	MOV	AL,OF_DAT	;Get location of module specific data
	PUSH	SI		
	CALL	B$GETMODCODE	;From the module specific code segment
	XCHG	AX,SI		;Into SI

	MOV	CX,off_erradr	; [CX] = offset of on error target
	INC	CX		
	JCXZ	OEGA_3		; disable error handling if CX = -1 or 0
	DEC	CX		
OEGA_3:				
	MOV	[SI].OFD_ONERROR,CX ; Set error vector
	POP	SI
	JCXZ	OEGA_10 	; jump if not setting a valid address
OEGA_5: 			

cEnd				

;
;	In error handling routine, must pretend we just had last error
;
OEGA_10:			
	CMP	[b$inonerr],CL ; Test if error in progress
	JE	OEGA_5		; No - just return
	MOV	BP,[BP] 	;restore to user program frame
	ADD	SP,8		;toss return address and param
	PUSH	[b$errnum]	;parameter is the error number
	PUSH	[WORD PTR b$erradr +2] ;"Return Address" use error segment
	PUSH	[WORD PTR b$erradr]	;"Return Address" Use error offset
	JMP	B$SERR 	;Process error (Never Returns)

	SUBTTL	B$RESA - RESume At line number
	PAGE
;***
; B$RESA - RESume At line number
;
;Purpose:
; Runtime entry for the RESUME <linenumber> statement
;
;Entry:
; [AX] = Address to RESUME to.
;
;Exit:
; to address. Clears on-error-in-progress
;
;Exceptions:
; Aborts if no error in progress
;
;******************************************************************************
cProc	B$RESA,<FAR,PUBLIC,FORCEFRAME> 
cBegin				

; Warning!  This assumes B$RES_SETUP never returns with AX trashed
	CALL	B$RES_SETUP	;perform initial RESUME stuff

	PUSH	AX		; save address to resume to
	MOV	BX,[b$curframe]	; current BASIC frame
	MOV	BX,[BX]		; want previous BASIC frame
	CALL	B$CEvtHndlr	; Was it an event handler?
	OR	AX,AX		; AX = 0 if an event handler
	POP 	BX		; [BX] = address to resume to
	JZ	RESRET		; treat event handlers specially

	XOR	AX,AX		; set to zero for string dealloc
	CALL	B$STDALCALLTMP	;dealloc all temp strings
	CMP	[b$curlevel],1	; check for main module
	JE	RESRET		; At main level - use old frame
	MOV	[b$curlevel],AX	; set [b$curlevel] to main level (AX=0)
	DEC	[b$cCSubs]	; INCed in B$ENSA
	MOV	[BP].FR_RETOFF,BX ; replace return offset with resume addr.
cEnd				; RETF to resume address

	SUBTTL	B$RES0 - RESUME [0]
	PAGE
;***
; B$RES0 - RESUME [0]
; void pascal B$RES0()
;
;Purpose:
; Runtime Entry Point for RESUME [0]
;
;Input:
; NONE
;
;Output:
; Clears error flags and error number
;
;******************************************************************************
cProc	B$RES0,<FAR,PUBLIC,FORCEFRAME> 
cBegin				

	CALL	B$RES_SETUP	; clear error flags and error number

	MOV	AX,[WORD PTR b$erradr]  ;Get error address
	MOV	BX,[BP] 	;Get User program frame pointer
	cCall	B$CALCLINE	; [BX] = address of start of statement
DbAssertFlags  NZ,ER_TEXT,<Statement start not found in B$RES0>       

RESRET: 			; moved here from B$RESA
	POP	BP		; Restore saved BP
	POP	AX		; Throw away return offset
	XCHG	AX,BX		; [AX] = return offset
	POP	DX		; [DX:AX] = resume address
	CALL	B$EXSA		; Preserves DX:AX
	PUSH	DX		
	PUSH	AX		; Save line number as offset
	RET			; Return

cEnd	nogen			

	SUBTTL	B$RESN - RESUME NEXT
	PAGE
;***
; B$RESN - RESUME NEXT
; void pascal B$RESN
;
; Purpose:
;	Runtime Entry Point - RESUME NEXT
;
; Input:
;	NONE
;
; Output:
;	NONE
;
;******************************************************************************
cProc	B$RESN,<FAR,PUBLIC,FORCEFRAME>,SI 
cBegin				

	CALL	B$RES_SETUP	; clear error flags and error number

	PUSH	DS		;Save DS
	MOV	AL,OF_STA	
	CALL	B$GETMODCODE	; Get statement number address table
	XCHG	AX,SI
	MOV	CX,[WORD PTR b$erradr]	; Get return offset
	MOV	DS,BX		; Get module CS
	MOV	BX,-1		;Start out with maximum address

rsnlop: LODSW			;(AX) = next address to check
	OR	AX,AX		;Check if end of table
	JZ	rsnend		;  Yes

	CMP	AX,CX		;Are we less than original address
	JB	rsnnxt		;  Yes - skip this one
	CMP	AX,BX		;Are we less than current closest
	JAE	rsnnxt		;  No - skip this one

	XCHG	AX,BX		;Save address in (BX) as new closest

rsnnxt: INC	SI		;Skip line number entry
	INC	SI
	JMP	rsnlop		;Keep looping

rsnend:
	POP	DS		;restore DGROUP to DS
	INC	BX		;Bump by 1 to map -1 to 0 (maybe)
	JNZ	rsnret		;  Not 0 - return to user program
	JMP	B$CEND 	; Resume off the bottom is an END

rsnret:
	DEC	BX		;Restore to correct values
	POP	SI		;Restore SI
	JMP	RESRET		; go return

cEnd	nogen			

	SUBTTL	ERR and ERL funcitons
	PAGE
;***
; B$FERR - ERR function
; I2 pascal B$FERR()
;
;Purpose:
; Runtime Entry Point - ERR function
;
;Input:
; NONE
;
;Output:
; [AX] = error number
;
;******************************************************************************
cProc	B$FERR,<FAR,PUBLIC>	
cBegin				
	MOV	AX,[b$errnum]	;Get error number
cEnd				

;***
; B$FERL - ERL function
; I4 pascal B$FERL()
;
;Purpose:
; Runtime Entry Point - ERL function
;
;Input:
; NONE
;
;Output:
; [DX:AX] = error line number
;
;******************************************************************************
cProc	B$FERL,<FAR,PUBLIC>	
cBegin				
	MOV	AX,[b$errlin]	
	XOR	DX,DX		
cEnd				

;*** 
;B$CEvtHndlr - Checks if a frame is an event handler
;
;Purpose:
;	Determine whether the frame is for an active compiled event handler.
;
;Entry:
;	BX = pointer to the COMPILED BASIC frame to check (ie. [b$curframe]).
;
;Exit:
;	AX = 0 IFF an event handler is detected.
;
;Uses:
;	AX, BX.
;
;Exceptions:
;	None.
;
;******************************************************************************
cProc	B$CEvtHndlr,<PUBLIC,NEAR> 
cBegin				
;
; This is the compiler-specific logic to check for a BASIC event handler:
;
	MOV	AX,[BX].FR_GOSUB ; AX = count of GOSUBS
DbAssertRel	AX,GE,0,ER_TEXT,<More than 32767 GOSUBs in B$CEvtHndlr> ;
	DEC	AX		; if AX = 0, return AX <> 0
	JS	No_handler	; no gosubs => no event handler
	SUB	BX,[BX].FR_CLOCALS ; BX = BX - number of local bytes
	MOV	AX,[BX-FR_SIZE-2] ; AX = 0 IFF event handler
No_Handler:			
cEnd				; return

sEnd	ER_TEXT 		

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\erproc.asm ===
TITLE	ERPROC.ASM - Common Runtime Error Processor
	PAGE	56,132
;***
; ERPROC.ASM - Common Runtime Error Processor
;
;	Copyright <C> 1986, 1987 Microsoft Corporation
;
;Purpose:
; Contains the common runtime entry point for generalized error handling. Also
; includes the runtime internal entry point for error handling.
;
;******************************************************************************
	INCLUDE switch.inc	;Runtime switch file
	INCLUDE rmacros.inc	;General runtime macros

	useSeg	ER		;We use the error code segments
	useSeg	GR_TEXT 	
	useSeg	RT_TEXT 	
	useSeg	NH_TEXT 	
	useSeg	_TEXT 		
	useSeg	_BSS		; we use _BSS
	useSeg	_DATA		;And we use _DATA

	INCLUDE seg.inc 	;Segment definitions
	INCLUDE baslibma.inc	; Skip macro
	INCLUDE compvect.inc	; component dispatch vectors structures
	INCLUDE idmac.inc	;  Internal debugging stuff
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE const.inc	; misc constants
	INCLUDE files.inc	; CALLOS macro and constants

ASCLF	=	0AH		;Linefeed character
	SUBTTL	Data Definitions
	PAGE
sBegin	_DATA
; *****************************************************************************
;
;	Data
;
; *****************************************************************************

	externW b$curframe	; current user frame pointer
	externW b$errnum	;Error number
	externW b$cCSubs	;flag indicating compiler in execution
	externB	b$messages	; drag in C startup messages
	externD	b$errmod	; error module name address
	externB b$inonerr	;flag indicating on-error in progress

	externW b$err_disp	; error dispatch table
	externB b$PRFG		; print using active flag
	externW __aexit_rtn	; terminating function


sEnd	_DATA

sBegin	_BSS			

	globalB b$errinfo,,1	; Supplemental error info
	globalW b$errvec,,1	; error vector (0=none, else address)

	globalW b$pSTDALCTMP,B$NearRet ; indirect B$STDALCTMP vector
	globalW b$pSTDALCALLTMP,B$NearRet ; indirect B$STDALCALLTMP vector


	externW b$curlevel	;current program level

sEnd				

	SUBTTL	Code Definitions
	PAGE
; *****************************************************************************
;
;	External Routines
;
; *****************************************************************************
	externFP __FMSG_TEXT	; Get message text from number


	externFP __fpreset	; reset mathpack

	externFP _exit		

sBegin	RT_TEXT

	externNP B$NearRet	; stub routine

	externFP B$COMP_DISP	; component dispatcher
sEnd	RT_TEXT

sBegin	ER_TEXT 		;All code goes in this segment

	externNP B$FERROR	;Product Fatal Runtime Error handler
	externNP B$ONERR	; don't drag it in for /O modularity

	externFP B$CONERR	;Compiler ON-ERROR handler
	externNP B$GETDS 	

assumes CS,ER_TEXT		;only cs

	SUBTTL	Error Handling Overview
	PAGE
;******************************************************************************
;
;	Common Runtime Error Handling
;
;	The common runtime error handler serves primarily as a funnel for all
;	error processing. Actual error processing, such as ON ERROR or fatal
;	error handling, is specific enough to each environment, that the
;	details of that are left to the compiler or interpeter specific error
;	handling routines.
;
;	There are two entry points:
;
;	B$SERR is the common runtime error handling routine. This is used by
;	code external to the common runtime (like the interpeter or compiler)
;	and accepts as a parameter a valid BASIC error number.
;
;	B$RUNERR is the runtime internal entry point, and accepts an extended
;	range of error numbers, to allow for non-trappable non-BASIC errors
;	(such as initialization errors, internal errors and the like), that we
;	still want to funnel through here.
;
;	If we have an error during the C startup initialization, we jump
;	directly to the routine FatalError.  If we were in an input statement
;	when the error occurred, we jump to a special input error handler.
;	Otherwise, we call B$ONERR and try to find a BASIC error handler.
;
;	B$ONERR will save the initial error state and then walk the chain of
;	BASIC frames until it finds an active error handler or it gives up and
;	returns to B$RUNERR.  If B$ONERR returns, we call B$FERROR to print a
;	fatal error message and die.  B$ONERR will return if the the error is
;	not a valid trappable BASIC error or if we were already in a BASIC 
;	error handler when the error occurred.  It will also return if it 
;	reaches the end of the BASIC frame chain without finding an active
;	BASIC error handler or if it finds an active event handler first.
;	In any of these situations where an error handler is not found, we
;	restore the original error state and call B$FERROR.
;
;	At each stage of walking the BASIC frame chain we determine whether
;	that particular BASIC frame was from a compiled or interpreted module
;	and call either B$IONERR (interpreter-specific routine) or B$NCONERR
;	(compiler-specific routine) as appropriate.  These routines do most
;	of the actual work for B$ONERR.  If they find a BASIC error handler,
;	they clean up the stack, deallocating any necessary local storage,
;	and jump to the BASIC error handler.  Otherwise, they return to 
;	B$ONERR with a flag set to indicate what the problem was.  B$ONERR uses
;	this flag in along with other information to decide whether to keep
;	walking the BASIC frame chain or to give up and return to B$RUNERR.
;
;	Note:  the environment specific ON ERROR code MUST make use of the
;	frame to determine context for error recovery.
;
;	BP points to the runtime entry frame as below:
;
;		^	Stack on common runtime entry		^
;		|						|
;		+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;		|						|
;		\ 	Parameters to Common Runtime Entry	\
;		|						|
;		+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;	BP-4 -> | CS						|
;		+	Far return address to calling code	+
;	BP-2 -> | IP						|
;		+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;	BP   -> |		BP value on entry		|
;		+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;		|						|
;
;	As noted above, the common runtime error handler can be invoked either
;	of two ways, and the contents of the stack differ slightly. If B$SERR
;	is called, then the "Parameters to Common Runtime Entry" is the error
;	number, and the far return is to the routine which called B$SERR. If
;	B$RUNERR is called from within the runtime, then the parameters and
;	return address relate to the original common runtime entry point which
;	was called.
;
;	If B$ONERR does return to B$RUNERR, then the error was not trappable.
;	The common error handler then branches to B$FERROR, the fatal error
;	handler with the error number as a parameter, and with BP as above.
;	(Note that this implies BP was not altered by the routine B$ONERR.)
;	B$FERROR is a product specific routine which is to handle the fatal
;	error as appropriate, either by printing and terminating in the case of
;	the compiler; or by printing a message, cleaning off the stack, and
;	returning to a known state in the case of the intepreter.
;
;	External environment specific routines required:
;
;	void pascal B$NCONERR(U2 errnum)   /* new compiler ON ERROR handler */
;	void pascal B$CONERR(U2 errnum)    /* old compiler ON ERROR handler */
;	void pascal B$FERROR(U2 errnum)    /* product fatal error handler   */
;	void pascal B$IONERR(U2 errnum)    /* interpeter ON ERROR handler   */
;
;******************************************************************************
	SUBTTL	B$ERR_?? - Runtime internal error vectors
	PAGE
;***
; B$ERR_?? - Runtime Internal Errors
;OEM-callback routine
;
;Purpose:
; Declare a particular error. Used internal to the runtime, these vectors
; are jumpped to to declare an error of a particular type.  If applicable,
; the ON ERROR handler will be called, otherwise the program will terminate
; (compiler) or return to the interpreter.
;
; The error that is defined is specified by a 2 or 3 digit code that replaces
; the ?? in B$ERR_??.	Thus, the error for illegal function call (FC) would
; be B$ERR_FC.  All the defined error functions are listed below, along
; with the basic error number and the text of the error.
;
; These entries do NOT modify the stack or frame in any way.
;
; The following errors are defined:
;
;		  Basic
;     Error	Error Code	Text of Error
;     -----	----------	-------------
;     B$ERR_SN     2		"Syntax error"
;     B$ERR_RG     3		"RETURN without GOSUB"
;     B$ERR_OD     4		"Out of DATA"
;     B$ERR_FC     5		"Illegal function call"
;     B$ERR_OV     6		"Overflow"
;     B$ERR_OM     7		"Out of memory"
;     B$ERR_BS     9		"Subscript out of range"
;     B$ERR_DD     10		"Duplicate definition"
;     B$ERR_DV0    11		"Division by zero"
;     B$ERR_TM     13		"Type mismatch"
;     B$ERR_OS     14		"Out of string space"
;     B$ERR_ST     16		"String formula too complex"
;     B$ERR_NR     19		"No RESUME"
;     B$ERR_RE     20		"RESUME without error"
;     B$ERR_DTO    24		"Device timeout"
;     B$ERR_DVF    25		"Device fault"
;     B$ERR_OTP    27		"Out of paper"
;     B$ERR_RVR    40		"Variable required"
;     B$ERR_FOV    50		"FIELD overflow"
;     B$ERR_INT    51		"Internal error"
;     B$ERR_IFN    52		"Bad file name or number"
;     B$ERR_FNF    53		"File not found"
;     B$ERR_BFM    54		"Bad file mode"
;     B$ERR_FAO    55		"File already open"
;     B$ERR_FSA    56		"FIELD statement active"
;     B$ERR_IOE    57		"Device I/O error"
;     B$ERR_FAE    58		"File already exists"
;     B$ERR_BRL    59		"Bad record length"
;     B$ERR_DFL    61		"Disk full"
;     B$ERR_RPE    62		"Input past end of file"
;     B$ERR_BRN    63		"Bad record number"
;     B$ERR_BFN    64		"Bad file name"
;     B$ERR_TMF    67		"Too many files"
;     B$ERR_DNA    68		"Device unavailable"
;     B$ERR_CBO    69		"Communication-buffer overflow"
;     B$ERR_FWP    70		"Permission denied"
;     B$ERR_DNR    71		"Disk not ready"
;     B$ERR_DME    72		"Disk-media error"
;     B$ERR_AFE    73		"Advanced feature unavailable"
;     B$ERR_RAD    74		"Rename across disks"
;     B$ERR_ACD    75		"Path/File access error"
;     B$ERR_PNF    76		"Path not found"
;     B$ERR_UPE    255 	"Unprintable error"
;
;Entry:
; None. (Entry itself determines error)
;
;Exit:
; None. Transfer of control is either handled by environment specific ON ERROR
; handler, or we fatal error, again to an environment specific handler.
;
;******************************************************************************

RTEDEF	MACRO	code,label,number,text,noskip
	IFNB	<label>
label	EQU	number		;;Define message symbol
	ENDIF
	IFNB	<code>		;;if there is an entry code
	PUBLIC	B$ERR_&code	;;entry point
B$ERR_&code:
	IF	number LE 255	;
	MOV	BL,number	;;load up number
	IFB	<noskip>	;; If needed
	DB	0B8H		;;MOV AX, ... to skip next two instruc bytes
	ENDIF			;; IFB <noskip>
	ELSE			;; IF number LE 255
	MOV	BL,0		;; indicate fatal (skipped on fall in)
	MOV	CX,number	;; Now create number
	JMP	SHORT DUMMY_10	;; now jump around the rest
	ENDIF			;; IF number LE 255
	ENDIF
	ENDM


cProc	DUMMY,<NEAR>
cBegin

	INCLUDE messages.inc	;Get the messages, and generate the entries

DUMMY_10:			
	MOV	BH,0		; [BX] = error message number
	OR	BX,BX		; see if fatal error
	JNZ	DUMMY_20	; jump if not
	XCHG	BX,CX		; else get fatal error number in BX
DUMMY_20:			; [BX] = error number
	JMP	SHORT B$RUNERR	

cEnd	nogen			

;******************************************************************************
;
; Entry points which provide additional information for b$errinfo
;
;******************************************************************************

cProc	B$ERR_OM_NH,PUBLIC	; Out of memory in near heap
cBegin	nogen			
	MOV	AL,OMErr_NH	
	SKIP	2		
cEnd	nogen			

cProc	B$ERR_OM_FH,PUBLIC	; Out of memory in far heap
cBegin	nogen			
	MOV	AL,OMErr_FH	
cEnd	nogen			

	MOV	b$errinfo,AL	; save additional info
	MOV	BX,BE_MEMORY	; error code
	JMP	SHORT B$RUNERRINFO 



cProc	B$FrameFC,<PUBLIC,NEAR,FORCEFRAME> ; FORCEFRAME for error recovery
cBegin				
	JMP	B$ERR_FC	; illegal function call error
cEnd				

cProc	B$FrameAFE,<PUBLIC,NEAR,FORCEFRAME> ; FORCEFRAME for error recovery
cBegin				
	JMP	B$ERR_AFE	; advanced feature error
cEnd				

	SUBTTL	B$SERR - Declare runtime error
	PAGE
;***
; B$SERR - Declare runtime error
; void pascal B$SERR(U2 errnum)
;
;Purpose:
; Common Runtime Entry Point: ERROR statement
; Declare an error. Transfers control to the appropriate environment handler to
; process ON ERROR if appropriate.
;
; This routine DOES set up a frame.
;
;Entry:
; errnum	= BASIC error number
;
;Exit:
; None. Transfer of control is either handled by environment specific ON ERROR
; handler, or we fatal error, to the product specific handler.
;
;******************************************************************************
cProc	B$SERR,<PUBLIC,FAR>
	parmW	errnum		;single parameter, the error number.
cBegin

	MOV	BX,errnum	;Pick up the error code
	OR	BX,BX		; Check if BX = 0
	JZ	ILL_FC		;Brif so - Illegal function call error
	OR	BH,BH		; See if gt 255
	JZ	SERR_5		;Jump if okay
ILL_FC:				
	MOV	BX,BE_ILLFUN	; Else change to illegal function call
SERR_5: 			
	JMP	SHORT B$RUNERR ; Jump to runtime error handler

cEnd	nogen

	SUBTTL	8086 Error Interrupt Vectors
	PAGE
;***
; B$DIV0, B$OVFR - Divide by zero and Overflow interupt/exceptions
;
;Purpose:
; Hardware exception handlers for Divide by Zero and Overflow processor
; execptions.
;
;Entry:
; Return address and flags on the stack.
;
;Exit:
; Doesn't. Vectors to error handler.
;
;Uses:
;
;******************************************************************************
cProc	B$DIV0,<FAR,PUBLIC>
cBegin
	MOV	CL,BE_DIVIDE0	;[BL] = Basic error code
	JMP	SHORT EXCEPTION ;Go process
cEnd	nogen

cProc	B$OVFR,<FAR,PUBLIC>
cBegin
	MOV	CL,BE_OVERFLOW	;[BL] = Basic error code
	CMP	[b$cCSubs],0	;Executing within interpeted code?
	JZ	EXCEPTION	;Then the error code is correct
	CMP	BP,[b$curframe] ;Executing within compiled code?
	JZ	EXCEPTION	;Then the error code is correct
	MOV	CL,BE_ILLFUN	;Else error within runtime, Illegal Function

EXCEPTION:
	POP	AX		; [AX] = IP of exception
	POP	DX		; [DX] = CS of exception
	POPF			; Restore interrupt status

	PUSH	DX		; CS of exception
	PUSH	AX		; IP of exception

	CALL	B$GETDS		; [BX] = Data segment
	.erre	ID_SSEQDS	; Assert SS = DS
	MOV	ES,BX		; restore extra segment
	MOV	DS,BX		; restore data segment

	XOR	BH,BH		
	MOV	BL,CL		; [BX] = error number

cEnd	nogen			; fall into B$RUNERR

	SUBTTL	B$RUNERR - Runtime internal error handler
	PAGE
;***
; B$RUNERR - Runtime Internal Error Handler
;
;Purpose:
; Declare an error. Transfers control to the appropriate environment handler to
; process ON ERROR if appropriate.
;
;
; NOTE: FAR PROC's in Windows save an odd BP value in the frame.
;	The actual pointer is 1 less.  AND w/NOT 1 realigns if even OR odd.
;
;Entry:
; [BP]	= frame pointer. If equal to [b$curframe], the far address of the
;	  error is assumed to be on the top of the stack, and a new frame is
;	  created.
; [BX]	= BASIC or internal error number.
;
;Exit:
; None. Transfer of control is either handled by environment specific ON ERROR
; handler, or we jump to an environment specific fatal error handler, B$FERROR. 
;
;******************************************************************************
labelNP <PUBLIC,__BRUNERR>	; Quicklib compatibility label
cProc	B$RUNERR,<NEAR,PUBLIC>
cBegin
	MOV	b$errinfo,0	; Entry this way assumes no supplemental
labelNP <PUBLIC,B$RUNERRINFO>	




	MOV	CX,[b$errvec]	; see if error during input
	JCXZ	BRUNERR_5	; Jump if not
	JMP	CX		; [CX] = address to branch to, [BX] = err#
BRUNERR_5:			

	MOV	DX,BX		; [DX] = the error number

	MOV	CX,BP		; [CX] = current frame pointer
	CMP	CX,[b$curframe]; See if it is the top level frame
	JNZ	BRUNERR_20	; Jump if not, we already have a frame

BRUNERR_15:			
	PUSH	BP		; create the frame
	MOV	BP,SP		
	MOV	BX,BP		; [BX] = pointer to error frame
	JMP	SHORT BRUNERR_30

;
; Walk the frame chain to look for the top level frame.
;
BRUNERR_20:			
	MOV	BX,CX		; [BX] = current frame pointer
	JCXZ	BRUNERR_15	; Jump if end of chain found (make best ofit)
	MOV	CX,[BX] 	; [CX] = next frame in chain
	CMP	CX,[b$curframe]	; See if top level frame found
	JNZ	BRUNERR_20	; jump if not done with stack walk
;
; Terminate any I/O operation that was in progress, and determine whether this
; error can be trapped.
;
; [BX] = pointer to frame containing return address of basic-level error
; [DX] = error number
;
BRUNERR_30:			
	PUSH	BX		; Push frame parameter to B$FERROR
	MOV	[b$errnum],DX	; Save error number
	PUSH	BX		; save frame parameter around call

	MOV	SI,OFFSET DGROUP:b$err_disp	; get dispatch table addr
	CALL	FAR PTR B$COMP_DISP		; do table dispatches
	MOV	b$PRFG,0	; clear print using flag

	CALL	__fpreset	; Unconditionally reset Math Support

	POP	BX		; restore BX = frame parameter
	CMP	BYTE PTR [b$errnum+1], HIGH FE_NOTHINGBASE  ; = 98h?
	JE	RUNERR_40	; skip on error handling for 9800h range

	cCALL	B$ONERR		; do on error handling
	CMP	[b$cCSubs],0	;See if we were interpreting at the time
	JNZ	RUNERR_35	
	MOV	WORD PTR [b$errmod+2],0 ; 0 = error in interpreter
	JMP	SHORT RUNERR_40 
RUNERR_35:			
	POP	BX		; Restore frame parameter to BX
	PUSH	BX		; Push frame parameter to B$FERROR again
	PUSH	BX		; Push frame parameter to B$CONERR
	cCALL	B$CONERR	; set up b$errmod, b$errlin, etc.

;
; On error handler returned. The error could not be trapped. Handle fatal error
; as appropriate.
;
RUNERR_40:

	MOV	[b$inonerr],FALSE ;No longer in on error
	cCall	B$FERROR	;Process fatal error (param pushed way above)
DbHalt ER_TEXT,<B$FERROR returned>

cEnd	B$RUNERR

	SUBTTL	C Startup error handler
	PAGE


;*** 
; FatalError -- Print fatal error message to STDOUT and die. [40]
;
;Purpose:
;	Added with revision [29] to handle C startup errors.
;	Prints specified C startup message to STDOUT.
;	Jumps to the termination routine specified by __aexit_rtn.
;	Currently, the possible routines are:
;		_exit, __exit, and B$terminate (all in CRT0DAT.ASM)
;	If the routines are moved to another segment besides _TEXT,
;	__aexit_rtn will have to be made into a FAR pointer.
;
;	Also handles Non-C startup errors such as those produced in the
;	CHAIN function, when memory is so screwed up that normal recovery
;	is impossible.
;
;Entry:
;	DS = SS = DGROUP
;	BX = error number
;Exit:
;	If C startup message, returns via routine specified by __aexit_rtn.
;	Otherwise, returns directly to DOS without doing any C termination.
;	
;Uses:
;	All
;Exceptions:
;	None
;******************************************************************************
cProc	FatalError,<FAR>
cBegin

	PUSH	BX		; save error number

	MOV	AX,FE_STARTUPEND ; CR/LF,"runtime error"
	CALL	PUTNUM		; print the message
	
	POP	AX		; AX = error message number
	CALL	PUTNUM		; print the message

	MOV	AL,255		; return code = -1
	PUSH	AX		; put it on the stack for termination routine
				; (must be preserved, too).
	PUSH	AX		; space on stack as if we CALLED exit routine
	PUSH	AX		; 	FAR (to set up its frame correctly)

	MOV	BX,SEG _exit	; termination function segment
	PUSH	BX		;    (functions are FAR, but called NEAR)
	PUSH	__aexit_rtn	; termination function offset
	RET			; RETF will jump to error routine
cEnd	<nogen>


;*** 
; B$PUTNUM  -- print error message to STDOUT..
;
;Purpose:
;	Used to print messages using DOS when PRINT support may not be there.
;	Added with revision [29].
; 	Modified to be used with all fatal errors [31].
;
;	Gets the message text associated with an error message number, and
;	prints the text to STDOUT.
;
;Entry:
;	DS = SS = DGROUP
;	AX = error number
;Exit:
;	None
;Uses:
;	Per convention
;Preserves:
;	SI
;Exceptions:
;
;******************************************************************************

cProc	PUTNUM,<NEAR>,<SI>	
cBegin

	cCall	__FMSG_TEXT,AX	; returns DX:AX = message address
	mov	si,ax		; DX:SI = message address
PUTNUM_15:			
	push	ds		; save DS
	mov	ds,dx		; DS:SI = message address
	lodsb			; AL = next character to print
	pop 	ds		; restore DS
	or	al,al		; check for null
	jz	PUTNUM_20	; brif at end of string
	cCall	B$PUTCHR	; print the character
	jmp 	SHORT PUTNUM_15	; and go back for more...
PUTNUM_20:			
cEnd


;*** 
; B$PUTCHR -- print char to stdout
;
;Purpose:
;	print char to stdout
;Entry:
;	AL = char to print
;Exit:
;	None
;Uses:
;	AX
;Exceptions:
;	None
;******************************************************************************
cProc	B$PUTCHR,<PUBLIC,NEAR>,<DX> 
cBegin				
	mov	dx,ax		
	callos	DCIO		; display the character through DOS
cEnd				


;***
; B$PUTUI - Write an unsigned 16-bit integer to console
; Moved here with revision [62]
;
;Purpose:
; Write an unsigned 16-bit integer to console via DOS
;
;Entry:
; [AX]	= 16-bit unsigned integer to be printed
; [CX]	= Near offset of routine to call to print characters.
;
;Exit:
; None.
;
;Uses:
; Per convention.
;****
cProc	B$PUTUI <PUBLIC,NEAR>	
cBegin
	MOV	BX,10		; prepare to divide by 10
	XOR	DX,DX		; null marks end of string
PUTUI_5:
	PUSH	DX		; save digit on stack
	XOR	DX,DX
	DIV	BX		; using BX forces 16-bit quotient capability
	ADD	DL,'0'		; add 30H for ASCII '0'
	OR	AX,AX		; check if there are more digits to print
	JNZ	PUTUI_5		; brif
	MOV	AX,DX
PUTUI_10:			; print the string
	cCall	CX		; print a digit
	POP	AX		; get next digit
	OR	AX,AX		; more digits to print?
	JNZ	PUTUI_10	; brif
cEnd





sEnd	; ER_TEXT

sBegin	_TEXT			
assumes	CS,_TEXT		

;*** 
;__amsg_exit, B$amsg_exit -- print C fatal startup message and terminate
;
;Purpose:
;	Moved here with revision [48]
;
;Entry:
;	AX = C startup error message number
;
;Exit:
;
;Uses:
;
;Preserves:
;
;Exceptions:
;
;******************************************************************************

labelNP	<PUBLIC,__amsg_exit>		

cProc	amsg_exit,<NEAR>		
cBegin
 	XCHG	AX,BX			; BX = BASIC error number
 	MOV	BH,FE_STARTUPBASE SHR 8	; BH = 9Ah (C startup error)
 	PUSH	SS			; set DS = SS = DGROUP
 	POP	DS
 	JMP	FAR PTR FatalError	; print error message and terminate
cEnd	<nogen>

sEnd	; _TEXT

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\evtcom.asm ===
TITLE	EVTCOM - Communications event handling
;***
; EVTCOM - Communications event handling
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Event trapping support for com ports
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - COM(n) Statement - 3 syntax variants map to 3 entry points:
;
;      COM(n) ON       COM(n) OFF	 COM(n) STOP
;      ---------       ----------	 -----------
;	   |		    |		      |
;	B$ETC0	 	 B$ETC1		   B$ETC2
;
;******************************************************************************
	INCLUDE switch.inc

	INCLUDE rmacros.inc
	INCLUDE baslibma.inc
	INCLUDE comdcb.inc

	useSeg	EV_TEXT
	useSeg	ER_TEXT
	useSeg	_DATA
	useSeg	_BSS
	useSeg	XIB
	useSeg	XI
	useSeg	XIE

	INCLUDE seg.inc
	INCLUDE idmac.inc
	INCLUDE event.inc

	INITIALIZER	B$xCOMTRAPINIT

sBegin	_BSS
externW b$COM_DCB
sEnd	_BSS

sBegin	_DATA
externW B$PollDispTable
sEnd	_DATA

sBegin	ER_TEXT
externNP B$ERR_CBO
externNP B$ERR_IOE
externNP B$ERR_FC
sEnd

sBegin	EV_TEXT
assumes CS,EV_TEXT

externNP B$COMLOC
externNP B$EVNT_SET
externNP B$TestTrap
externNP B$ReqTrap
externNP B$settbl
externNP B$ONFUN

	Subttl	Communications polling routines
	PAGE

;***
;B$POLCOM -
;
;Purpose:
;	POLCOM is called by CHKINT at beginning of every BASIC statement
;	(INT 3). For each COM device which is opened to a device, it calls
;	COM_TRAP if that device has input data waiting.
;
;Entry:
;	None.
;
;Exit - AX, BX, CX, DX can be used (restored by CHKINT).
;	 All other registers are preserved.
;****

cProc	B$POLCOM,<NEAR>
cBegin
	PUSH	DI
	PUSH	SI
	MOV	DI,OFFSET DGROUP:b$COM_DCB ;DI points to device control block 1
	MOV	DX,NUM_RS232	;[DH]=COM unit#, [DL]=number of COM units
POLCML: CALL	POLCM1		;test unit 1 for trap
	ADD	DI,SIZE COMDCB	;DI points to next device control block
	INC	DH		;Bump unit id
	DEC	DL		;Decrement unit counter
	JNZ	POLCML		;branch if any more to test
	POP	SI
	POP	DI
cEnd

;***
;POLCM1
;
;Purpose:
;	 POLCM1 checks 1 COM device to see if input is waiting, if so,
;	 it calls COM_TRAP
;
;Entry: [dh,dl] = [unit#,units remaining]
;	[di]	= CMnDCB
;
;Exit:
;	none.
;Uses:
;	SI
;Exceptions:
;	none
;****

cProc	POLCM1,<NEAR>
cBegin
	MOV	SI,[DI].CD_CMFDB ;SI points to FDB (if device is opened)
	OR	SI,SI
	JZ	PLCM1X		;return if device not opened
	MOV	AH,DH		;[AH]=Unit#
	PUSH	DX		;save Unit#
	CALL	GCOMSZ		;[DX]=number of bytes queued
	CMP	DX,[DI].CD_CMEVT ;test if any new character have been rcved
	MOV	[DI].CD_CMEVT,DX ;update value in case of event
	POP	DX		;restore Unit#
	MOV	AL,DH		;[AL]=trap id (0..n)
	JE	PLCM1X		;branch if no new com data queued
	CALL	COM_TRAP	; so ON-COM service routine will be called
PLCM1X:
cEnd

;***
;GCOMSZ - read comm bytes
;
;Purpose:
;	 Get COM bytes in queue
;	 Does error processing if gets error from COM channel
;
;Entry:
;	 AH = unit number
;
;Exit:
;	 DX=bytes in queue
;
;Uses:
;	 Per Convention
;
;Exceptions:
;	May call B$ERR_CBO or B$ERR_IOE
;****
cProc	GCOMSZ,<NEAR>
cBegin
	PUSH	AX
	CALL	B$COMLOC
	OR	AH,AH
	JNZ	CMERR		;Got error from COM
	POP	AX
cEnd

;Output COM Error Message

CMERR:
	DEC	AH
	JNZ	IOERR
	JMP	B$ERR_CBO	; and give "Comm Buffer Overflow"
IOERR:
	JMP	B$ERR_IOE	; and give "Device I/O Error".

	SUBTTL	COM (n) [ON,OFF,STOP] Statement
	PAGE

;***
; c$ETC0, B$ETC1, B$ETC2 - COM (n) [ON,OFF,STOP] Statement
;
; Purpose:
;	Dispatch COM statement depending upon following clauses:
;
;	COM (n)       ON      Enable  COM(n) Trapping.
;	COM (n)       OFF     Disable COM(n) Trapping.
;	COM (n)       STOP    Suspend COM(n) Trapping.
;
;	WHERE: (n) is in [1..NUM_RS232]
; Input:
;	parm1 == (n)
; Output:
;	Event set in trap table, or error
;****

labelFP	<PUBLIC,B$ETC0>		; COM(n) ON
	MOV	DL,$ON
	SKIP	2
labelFP	<PUBLIC,B$ETC1>		; COM(n) OFF
	MOV	DL,$OFF
	SKIP	2
labelFP	<PUBLIC,B$ETC2>		; COM(n) STOP
	MOV	DL,$STOP

cProc	COMON_PROC,<FAR>,<SI,ES>
parmW	commPort
cBegin
	MOV	BX,[commPort]
	DEC	BX
	CMP	BX,NUM_RS232	;In range?
	JNB	EVNT_ERROR	;Brif not

	MOV	CL,COMOFF
	XOR	si,si		; no low-level routine for trapping
	CALL	B$EVNT_SET	; jump to common exit
cEnd

EVNT_ERROR:
	JMP	B$ERR_FC

; COM_TRAP - Interrupt Trap Request for COM.
; Entry:
;	[al]	trap id [0..COMn-1]:

cProc	COM_TRAP,<NEAR>
cBegin

	ADD	AL,COMOFF	;Add Base Index to COM Traps
	CALL	B$TestTrap	;See if Traps ON.
	JZ	COM_TRAPX	;Brif not.
	CALL	B$ReqTrap	;Trap Enabled. Issue Request.
COM_TRAPX:
cEnd

;***
;****
cProc	B$ONCA,<FAR,PUBLIC>
parmW	comport
parmD	fpHandler
cBegin
	MOV	CX,(NUM_RS232 SHL 8) + COMOFF
	MOV	BX,comport	; [BX] = requested comport
	JMP	B$ONFUN 	; ON COM...

cEnd	nogen

;***
;B$xCOMTRAPINIT - Initializer for COM trapping
;
;Purpose:
;	Put address of B$POLCOM in polling dispatch table
;
;Entry:
;	None
;Exit:
;	None
;Uses:
;	None
;
;Exceptions:
;****
cProc	B$xCOMTRAPINIT,<FAR>	
cBegin
	MOV	[B$PollDispTable + (RS232_IND * 2)],OFFSET B$POLCOM
cEnd

sEnd	EV_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\evtpen.asm ===
TITLE	EVTPEN - Lightpen event handling
;***
; EVTPEN - Lightpen event handling
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Event trapping support for lightpen.
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - PEN Statement - 3 syntax variants map to 3 entry points:
;
;      PEN ON	    PEN OFF	   PEN STOP
;      ------	    -------	   --------
;	  |	       |	       |
;	B$EPE0      B$EPE1	     B$EPE2
;
; - PEN Function:
;
;      v = PEN(n)
;	    |
;	B$FPEN
;
;******************************************************************************
	INCLUDE switch.inc

	INCLUDE rmacros.inc

	useSeg	EV_TEXT
	useSeg	ER_TEXT
	useSeg	_DATA
	useSeg	_BSS
	useSeg	XIB
	useSeg	XI
	useSeg	XIE


	INCLUDE seg.inc
	INCLUDE idmac.inc
	INCLUDE event.inc
	INCLUDE baslibma.inc

	INITIALIZER	B$xPENTRAPINIT

sBegin	_DATA
externW	B$PollDispTable
sEnd	_DATA

sBegin	_BSS
globalW b$PNDOWN,?,1		; pen down flag
externW b$TRP_LITEPEN
sEnd	_BSS

sBegin	ER_TEXT
	externNP   B$ERR_FC	
sEnd

sBegin	EV_TEXT
assumes CS,EV_TEXT

externNP B$RDPEN
externNP B$TestTrap
externNP B$ReqTrap
externNP B$EVNT_SET
externNP B$settbl

	SUBTTL	PEN Traps
	PAGE

;***
;B$POLPEN
;
;Purpose:
;	Determine if a PEN event has occurred.
;	If it has, then EVTRP is called to signal the occurrance.
;Entry:
;	none
;Exit:
;	none
;Modifies:
;	AX, BX, CX, DX can be used (restored by CHKINT).
;	All other registers are preserved.
;****

cProc	B$POLPEN,<NEAR>	
cBegin				; New routine
	MOV	AL,0D
	CALL	B$RDPEN		;Request "trap-occurred" flag
	mov	b$PNDOWN,bx	; save the flag
	OR	BX,BX
	JE	POLPEX		;branch if no PEN interrupt
	MOV	AL,PENOFF
	CALL	B$TestTrap	;Trapping ON?
	JZ	POLPEX		;NO
	CALL	B$ReqTrap	;Enabled, Issue Request.
	cmp	word ptr b$TRP_LITEPEN+1,-1 ; "on pen gosub xxxx" present?
	jz	polpex		; brif not present
	mov	b$PNDOWN,0	; else if present clear b$PNDOWN
POLPEX:
cEnd

;***
; B$EPE0, B$EPE1, B$EPE2  - PEN [ON,OFF,STOP] Statement
;
; Purpose:
;	Dispatch PEN statement depending upon following clauses:
;
;	PEN	   ON	   Enable  PEN Trapping.
;	PEN	   OFF	   Disable PEN Trapping.
;	PEN	   STOP    Suspend PEN Trapping.
; Input:
;	NONE
; Output:
;	Event set in trap table, or error
;****

labelFP	<PUBLIC,B$EPE0>		; PEN ON
	MOV	DL,$ON
	SKIP	2
labelFP	<PUBLIC,B$EPE1>		; PEN OFF
	MOV	DL,$OFF
	SKIP	2
labelFP	<PUBLIC,B$EPE2>		; PEN STOP
	MOV	DL,$STOP

cProc	PENS_PROC,<FAR>,<SI,ES>
cBegin
	MOV	CL,PENOFF
	MOV	SI,EV_TEXTOFFSET B$RDPEN ; routine to en/disable trapping
	XOR	BL,BL
	CALL	B$EVNT_SET
cEnd

;#*****************************************************************************

cProc	B$ONPA,<FAR,PUBLIC>
parmD	fpHandler
cBegin
	MOV	AL,PENOFF
	LEA	BX,[fpHandler]	; parm to settbl
	call	B$settbl	  ; ON PEN...
cEnd


	SUBTTL	PEN FUNCTION
	PAGE

;***
;B$FPEN - Light Pen Function.
;
;Purpose:
;	Runtime Entry Point.
;	Syntax: X = PEN(n)
;		Read the Light Pen, Where n:
;		0 -	Was Pen down since last poll (-1 yes, 0 no).
;		1 -	X Pixel value when last depressed (0-319,639).
;		2 -	Y Pixel value when last depressed (0-199).
;		3 -	Current Pen switch value (-1 down, 0 up).
;		4 -	X Pixel last value valid with pen down.
;		5 -	Y Pixel last value valid with pen down.
;		6 -	Y value read when last depressed (0-24).
;			  (Char Row).
;		7 -	X value read when last depressed (0-39,79).
;			  (Char Col).
;		8 -	Y last value valid with pen down. (Char Row).
;		9 -	X last value valid with pen down. (Char Col).
;	    The parm (in BX) is passed into the low level routine
;	    which has identical functionality
;Entry:
;	nPen == (n) parameter
;Exit:
;	[AX] == Function result
;Uses:
;	Per convention
;Exceptions:
;	B$ERR_FC
;****

max_pen_arg =	9d		;current legal pen arguments are [0..9]
cProc	B$FPEN,<PUBLIC,FAR>
parmW	nPen
cBegin
	MOV	AX,nPen 	; Get pen function number
	CMP	AX,max_pen_arg
	JA	PEN_ERROR	; make sure that [bh] is also 0
	OR	AL,AL		; polling the pen ?
	JNZ	PEF1		; brif not
	XCHG	AX,b$PNDOWN	; else use b$PNDOWN as the polled
				; result and clear the b$PNDOWN flag
	OR	AX,AX		; was it down since the last poll ?
	JNZ	PEFRET		; brif so
PEF1:
	CALL	B$RDPEN		; [BX] = 16 bit return value
	XCHG	AX,BX		; return it in AX
PEFRET:
cEnd

PEN_ERROR:
	JMP	B$ERR_FC	;complain

;***
;B$xPENTRAPINIT - Initializer for LITEPEN trapping
;
;Purpose:
;	Put address of B$POLPEN in polling dispatch table
;
;Entry:
;	None
;Exit:
;	None
;Uses:
;	None
;
;Exceptions:
;****
cProc	B$xPENTRAPINIT,<FAR>
cBegin
	MOV	[B$PollDispTable + (LITEPEN_IND * 2)],OFFSET B$POLPEN
cEnd

sEnd	EV_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\evtpla.asm ===
TITLE	EVTPLA - Play event handling
;***
; EVTPLA - Play event handling
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Event trapping support for PLAY.
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - PLAY ON | OFF | STOP Statement - 3 possible entry points:
;
;      PLAY(n) ON	  PLAY(n) OFF	    PLAY(n) STOP
;      ----------	  -----------	    ------------
;	   |		       |		  |
;	B$ETL0		    B$ETL1	       B$ETL2
;
;******************************************************************************
	INCLUDE switch.inc

	INCLUDE rmacros.inc

	useSeg	EV_TEXT
	useSeg	ER_TEXT
	useSeg	_DATA
	useSeg	XIB
	useSeg	XI
	useSeg	XIE

	INCLUDE seg.inc
	INCLUDE event.inc
	INCLUDE baslibma.inc
	INCLUDE idmac.inc

	INITIALIZER	B$xPLATRAPINIT

sBegin	_DATA
externW	B$PollDispTable
sEnd	_DATA

sBegin	ER_TEXT
externNP B$ERR_FC
sEnd	ER_TEXT

sBegin	EV_TEXT
assumes CS,EV_TEXT

externNP B$RDPLAY
externNP B$TestTrap
externNP B$ReqTrap
externNP B$EVNT_SET
externNP B$settbl
externNP B$ONFUN

;***
;B$POLPLA
;
;Purpose:
;	Determine if a PLAY event has occurred.
;	If it has, then EVTRP is called to signal the occurrance.
;Entry:
;	none
;Exit:
;	none
;Modifies:
;	AX, BX, CX, DX can be used (restored by CHKINT).
;	All other registers are preserved.
;****

cProc	B$POLPLA,<NEAR>
cBegin
	MOV	AL,0D
	CALL	B$RDPLAY	;Request "trap-occurred" flag
	OR	BX,BX
	JE	POLPLX		;branch if no PLAer interrupt
	MOV	AL,PLAOFF	; NBA
	CALL	B$TestTrap	;Trapping ON?
	JZ	POLPLX		;NO
	CALL	B$ReqTrap	;Enabled, Issue Request.
POLPLX:
cEnd

	SUBTTL	PLAY [ON,OFF,STOP] Statement
	PAGE

;***
; B$ETL0, B$ETL1, B$ETL2  - PLAY  [ON,OFF,STOP] Statement
;
; Purpose:
;	Dispatch PLAY statement depending upon following clauses:
;
;	PLAY	    ON	    Enable  PLAY Trapping.
;	PLAY	    OFF     Disable PLAY Trapping.
;	PLAY	    STOP    Suspend PLAY Trapping.
; Input:
;	NONE
; Output:
;	Event set in trap table, or error
;****

labelFP	<PUBLIC,B$ETL0>		; PLAY ON
	MOV	DL,$ON
	SKIP	2
labelFP	<PUBLIC,B$ETL1>		; PLAY OFF
	MOV	DL,$OFF
	SKIP	2
labelFP	<PUBLIC,B$ETL2>		; PLAY STOP
	MOV	DL,$STOP

cProc	PLAON_PROC,<FAR>,<SI,ES>
cBegin
	MOV	CL,PLAOFF	; NHL
	MOV	SI,EV_TEXTOFFSET B$RDPLAY
	XOR	BL,BL
	CALL	B$EVNT_SET	;Set Event
cEnd

;***
;****

cProc	B$ONLA,<FAR,PUBLIC>
parmW	notecount
parmD	fpHandler
cBegin

	MOV	BX,notecount	; [BX] = note count
	mov	al,set_note_cnt ; report n to oem
	call	B$RDPLAY
	jc	EVNT_error	; oem didn't like value for on play

	mov	al,plaoff	; NFL
	LEA	BX,[fpHandler]	;parm to settbl
	call	B$settbl	
cEnd

EVNT_ERROR:
	JMP	B$ERR_FC

;***
;B$xPLATRAPINIT - Initializer for PLAY trapping
;
;Purpose:
;	Put address of B$POLPLA in polling dispatch table
;
;Entry:
;	None
;Exit:
;	None
;Uses:
;	None
;
;Exceptions:
;****
cProc	B$xPLATRAPINIT,<FAR>	
cBegin
	MOV	[B$PollDispTable + (SOUND_IND * 2)],OFFSET B$POLPLA
cEnd
sEnd	EV_TEXT


	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\evtuev.asm ===
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\evtstg.asm ===
TITLE	EVTSTG - Joystick Trigger (STRIG) event handling
;***
; EVTSTG - Joystick Trigger (STRIG) event handling
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Event trapping support for joystick trigger (STRIG)
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; STRIG(n) Statement - 3 syntax variants map to 3 entry points:
;
;      STRIG(n) ON	  STRIG(n) OFF	    STRIG(n) STOP
;      -----------	  ------------	    -------------
;	    |			|		   |
;	 B$ETS0		     B$ETS1		B$ETS2
;
; STICK Function:
;
;      v = STICK(n)
;	     |
;	B$STIK
;
;
; STRIG Function:
;
;      v = STRIG(x)
;	     |
;	B$FSTG
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	useSeg	EV_TEXT
	useSeg	ER_TEXT
	useSeg	_DATA
	useSeg	XIB
	useSeg	XI
	useSeg	XIE

	INCLUDE seg.inc
	INCLUDE event.inc
	INCLUDE baslibma.inc
	INCLUDE idmac.inc

	INITIALIZER	B$xSTGTRAPINIT

sBegin	_DATA
externW	B$PollDispTable
externW	b$pJoystInt
sEnd	_DATA

sBegin	ER_TEXT
externNP B$ERR_FC
sEnd	ER_TEXT

sBegin	EV_TEXT
assumes CS,EV_TEXT

externNP B$RDTRIG
externNP B$RDSTIK	
externNP B$TestTrap
externNP B$ReqTrap
externNP B$EVNT_SET
externNP B$settbl
externNP B$ONFUN
externNP B$JoystInt

	SUBTTL	STRIG Traps

;***
;B$POLSTG - Poll for a STRIG event.
;
;Purpose:
; POLSTG is called by CHKINT at beginning of every BASIC statement (NEWSTT).
; If a STRIG interrupt has occured, it sets the appropriate bit in b$TRPTBL
; which will cause the BASIC program's pen service routine (ON STRIG(N) GOSUB)
; to be invoked.
;
;Entry:
;	 None.
;
;Exit:
;	 AX, BX, CX, DX can be used (restored by CHKINT).
;	 All other registers are preserved.
;
;Uses:
;	 Per Convention
;
;Exceptions:
;	 None.
;****

cProc	B$POLSTG,<NEAR>
cBegin
	MOV	AX,100H 	; [AL] = joystick trigger #0 (for B$RDTRIG)
				; [AH] = latched (not current) flag

STGILP:
	PUSH	AX		; save current trigger id
	ADD	AL,STGOFF
	CALL	B$TestTrap	; [BX] points to event mask PSW.Z if
	POP	AX		;  STRIG(n) <ON|STOP> has been done
	PUSH	AX
	JZ	STGI1		; don't call B$RDTRIG if event not enabled
	CALL	B$RDTRIG	;  [AL]=0/1 if trig is not-pressed/pressed
	OR	AL,AL
	JZ	STGI1		; brif this trigger has not interrupted
	POP	AX		; restore [AL] = joystick trigger id
	PUSH	AX
	CALL	B$ReqTrap	; Signal the occurance of a TRIGGER EVENT

STGI1:	POP	AX
	INC	AL
	CMP	AL,NUM_JOYST
	JB	STGILP		;branch if more triggers to poll
cEnd

	SUBTTL	STRIG [ON,OFF,STOP] Statement
	PAGE

;***
; B$ETS0, B$ETS1, B$ETS2 - STRIG (n) [ON,OFF,STOP] Statement
;
; Purpose:
;	Dispatch STRIG statement depending upon following clauses:
;
;	STRIG (n)	ON	Enable	STRIG(n) Trapping.
;	STRIG (n)	OFF	Disable STRIG(n) Trapping.
;	STRIG (n)	STOP	Suspend STRIG(n) Trapping.
;
;	WHERE:
;		(n) is Trigger 0 or 2.
; Input:
;	parm1 == (n)
; Output:
;	Event set in trap table, or error
;****

labelFP	<PUBLIC,B$ETS0>		; STRIG(n) ON
	MOV	DL,$ON
	SKIP	2
labelFP	<PUBLIC,B$ETS1>		; STRIG(n) OFF
	MOV	DL,$OFF
	SKIP	2
labelFP	<PUBLIC,B$ETS2>		; STRIG(n) STOP
	MOV	DL,$STOP

cProc	STRIG_PROC,<FAR>,<SI,ES>
parmW	strigParm
cBegin
	MOV	BX,[strigParm]
	ROR	BL,1		;Divide by 2 so get 0,1,2 or 3
	CMP	BX,NUM_JOYST	;rolling BX sets high order bit
	JNB	JOYST_ERROR	;Brif .gt. MAX

	cmp	dl,$ON		; rdtrig must be called to ensure
	jnz	ts_cnt		; that an event occurring while

	mov	al,bl		; strig(n) was turn off doesnt
	mov	ah,1		; generate a false event or prevent
	call	B$RDTRIG	; detection of future events
ts_cnt: MOV	CL,STGOFF
	xor	si,si		; no low-level to start trapping

	CALL	B$EVNT_SET	;Set Event
cEnd

JOYST_ERROR:
	JMP	B$ERR_FC	; give Illegal function call error

;#*****************************************************************************

cProc	B$ONSA,<FAR,PUBLIC>
parmW	strignum
parmD	fpHandler
cBegin
	MOV	BX,strignum	; [BX] = requested strig
	MOV	CX,(NUM_JOYST SHL 8) + STGOFF
	ROR	BL,1		; Divide by 2 so get 0,1,2 or 3
	inc	bx		; Make base 1 so onfun can make it base 0
	jmp	B$ONFUN 
cEnd	nogen


	SUBTTL	STICK FUNCTION

;***
;B$STIK - Joystick Function
;
;Purpose:
;	Runtime Entry Point.
;	Syntax: X = STICK(n)
;
;	Get the X or Y coordinate of joystick A or B
;
;Entry:
;	nStik = stick to get info for
;Exit:
;	AX = X/Y coord of joystick A/B
;Uses:
;	Per Convention
;Exceptions:
;	B$ERR_FC
;****
cProc	B$STIK,<PUBLIC,FAR>
parmW	nStik
cBegin
	MOV	AX,nStik	; get stick function code
	CMP	AX,NUM_JOYST	; it should be 0,1,2,3
	JNB	JOYST_ERROR	; brif not - Illegal function call
	CALL	B$RDSTIK	; call low levels to get coord for stick
	JC	JOYST_ERROR	; complain if low level didn't like arg
	XCHG	AX,BX		; put ret val in AX
cEnd

	SUBTTL	STRIG FUNCTION

;***
;B$FSTG - Read STICK Trigger Function
;
;Purpose:
;	Runtime Entry Point.
;	Syntax: X = STRIG(n)
;
;	If: n = 0 Returns -1 if the trigger has been fired since
;		  the last STRIG(0) call.  If not, STRIG(0)
;		  returns 0...
;		1 Return -1 if trigger is currently down.  If
;		  up, then STRIG(1) returns 0.
;
;		  STRIG(2) and STRIG(3) coorespond to (0) and
;		  (1) above, but apply to Joystick 'B'...
;Entry:
;	nTrig == n
;Exit:
;	[AX] = return value
;Uses:
;	Per convention
;Exceptions:
;	B$ERR_IFC
;****
cProc	B$FSTG,<PUBLIC,FAR>
parmW	nTrig
cBegin
	MOV	AX,nTrig	; get trig number/function(should be 0-7)
	MOV	BL,AL		; Save trig number
	SHR	AX,1		; should become 0-3
	CMP	AX,NUM_JOYST	; check if <= 3
	JNB	JOYST_ERROR	; brif not - Illegal Function Call
	MOV	AH,BL		; [AH] = "n" of ON STRIG(n)
	INC	AH		; map (0,1,....) to (1,2,...)
	AND	AH,01h		; [AH] = (1,0,1,0)
	CALL	B$RDTRIG	; [AL] = [0..1] for [~pressed,pressed]
	JC	JOYST_ERROR	; error if low level didn't like it.
	CBW			; [AX] = return value
cEnd

;***
;B$xSTGTRAPINIT - Initializer for STRIG trapping
;
;Purpose:
;	Put address of B$POLSTG in polling dispatch table
;
;Entry:
;	None
;Exit:
;	None
;Uses:
;	None
;
;Exceptions:
;****
cProc	B$xSTGTRAPINIT,<FAR>
cBegin
	MOV	[B$PollDispTable + (JOYST_IND * 2)],OFFSET B$POLSTG
	MOV	b$pJoystInt,EV_TEXTOFFSET B$JoystInt ; check for joystick
						; activity in CLOCKTIC.
cEnd
sEnd	EV_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\evtkey.asm ===
TITLE	EVTKEY - Keytrapping event handling
;***
; EVTKEY - Keytrapping event handling
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Event trapping support for keytrapping.
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - KEY(n) Statement - 3 syntax variants map to 3 entry points:
;
;      KEY(n) ON       KEY(n) OFF	 KEY(n) STOP
;      ---------       ----------	 -----------
;	   |		    |		      |
;	B$ETK0	 	 B$ETK1 	   B$ETK2
;
; SLEEP [n] Statement
;
;      SLEEP [n]
;      ---------
;	   |
;	B$SLEP
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc

	useSeg	EV_TEXT
	useSeg	ER_TEXT
	useSeg	RT_TEXT
	useSeg	INIT_CODE
	useSeg	_DATA
	useSeg	_BSS
	useSeg	XIB
	useSeg	XI
	useSeg	XIE

	INCLUDE seg.inc
	INCLUDE event.inc
	INCLUDE const.inc
	INCLUDE baslibma.inc
	INCLUDE idmac.inc

	INITIALIZER	B$xKEYTRAPINIT

sBegin	_BSS
externW b$RcoFlg
sEnd	_BSS

sBegin	_DATA
externB b$EventFlags		;misc event flags. Bits defined in EVENT.INC
externW B$PollDispTable
externW b$pInitKeys1		;vector for B$InitKeys1
externW b$pInitKeys2		;vector for B$InitKeys2
sEnd	_DATA


sBegin	ER_TEXT
externNP B$ERR_FC
sEnd	ER_TEXT




sBegin	EV_TEXT
assumes CS,EV_TEXT

	externNP B$SetKybdInt	;install keyboard interrupt handler
	externNP B$SetClockInt	;install clock interrupt handler
	externNP B$SleepInit	;set up sleep timeout

externNP B$InitKeys1		;keytrapping init for /D or ON KEY & friends
externNP B$POLKEY
externNP B$RDKYBD
externNP B$TrapAddr
externNP B$TestTrap
externNP B$ReqTrap
externNP B$EVNT_SET
externNP B$OnTrap
externNP B$OffTrap
externNP B$StopTrap
externNP B$settbl
externNP B$ONFUN

	SUBTTL	KEY (n) [ON,OFF,STOP] Statement
	PAGE
;***
; B$ETK0, B$ETK1, B$ETK2 - KEY (n) [ON,OFF,STOP] Statement
;
; Purpose:
;	Dispatch KEY statement depending upon following clauses:
;
;	KEY (n)       ON      Enable  KEY(n) Trapping.
;	KEY (n)       OFF     Disable KEY(n) Trapping.
;	KEY (n)       STOP    Suspend KEY(n) Trapping.
;
;	WHERE:
;		(n) is Softkey 1..NUM_TKEYS.
;		If (n) is 0 then ON, OFF, and STOP
;		apply to all keys 1 thru NUM_TKEYS...
; Input:
;	parm1 == (n)
; Output:
;	Event set in trap table, or error
;****

labelFP	<PUBLIC,B$ETK0>		; KEY(n) ON
	MOV	DL,$ON		
	SKIP	2
labelFP	<PUBLIC,B$ETK1>		; KEY(n) OFF
	MOV	DL,$OFF 	
	SKIP	2
labelFP	<PUBLIC,B$ETK2>		; KEY(n) STOP
	MOV	DL,$STOP	

cProc	KEYON_PROC,<FAR>,<SI,ES>
parmW	keyNum
cBegin				
	mov	bx,[keyNum]	
	OR	BX,BX		; KEY(0)?
	JNZ	NOT_ALL_KEYS	; Brif not do all keys.

	;SET KEY(0) STATUS
	;	 KEY(0) <status> SETS ALL KEYS TO <status>

	PUSH	DI		

	DEC	DL		; cheap test of ON/OFF/STOP token
.errnz	$ON - 0
	JS	KYON		; brif DL == $ON - Set all keys to ON
.errnz	$OFF - 1
	JZ	KYOFF		; brif DL = $OFF - Set all keys to OFF
	;default - fall through for DL = $STOP

	MOV	DI,EV_TEXTOFFSET B$StopTrap
	JMP	SHORT KEYALL
KYON:
	MOV	DI,EV_TEXTOFFSET B$OnTrap
	JMP	SHORT KEYALL
KYOFF:
	MOV	DI,EV_TEXTOFFSET B$OffTrap
KEYALL:
	MOV	CX,NUM_TKEYS
KEYAL1:
	PUSH	CX		;Save counter
	PUSH	DI		;Save funct dispatch
	MOV	AL,KEYOFF
	ADD	AL,CL		;index to NUM_TKEYS
	MOV	CH,CL		; CH key number
	DEC	AL		;Adjust to base 0.
	MOV	SI,EV_TEXTOFFSET KEYALX ; NOTE: this is the return address
	PUSH	SI			;     NOTE: which will eventually get
	MOV	SI,EV_TEXTOFFSET B$RDKYBD; NOTE: control. This is the adr
	PUSH	DI			;     NOTE: B$TrapAddr  will exit.
	JMP	B$TrapAddr	; Get Trap Table, do function.
KEYALX:
	POP	DI		;Dispatch addr.
	POP	CX		;counter.
	LOOP	KEYAL1		;Until all keys done..
	POP	DI		; restore this prior to exit
	JMP	SHORT KEYON_EXIT1

NOT_ALL_KEYS:
	mov	ch,bl		; save keynum for B$RDKYBD
	DEC	BX		;MAKE IT 0 TO NUM_TKEYS-1
	CMP	BX,NUM_TKEYS
	JNB	EVNT_ERROR	;Brif .gt. NUM_TKEYS-1

	TEST	b$RcoFlg,0FFH	; is ronco presented ?
	JZ	ChkUsrKy	; Brif not

	CMP	BX,NUM_TKEYS-2	; is F11,F12
	JAE	NoError 	; Brif yes
ChkUsrKy:			; check user defined keys
	CMP	BX,NUM_TKEYS-2-NUM_GAP	; is legal user defined keys ?
	JAE	EVNT_ERROR	; Brif not
NoError:			; # is in legal range
	MOV	CL,KEYOFF
	MOV	SI,EV_TEXTOFFSET B$RDKYBD ;lo-level rtn to start/stop traping
KEYON_EXIT:			; shared exit
	CALL	B$EVNT_SET	;Set Event..
KEYON_EXIT1:
cEnd

EVNT_ERROR:
	JMP	B$ERR_FC

;***
;B$InitKeys2 -- initialize keytrapping stuff
;
;****
cProc	B$InitKeys2,<PUBLIC,NEAR>
cBegin

; Now disable all function keys, cursor keys & user-defined keys

	MOV	AL,DISABLE_TRAP ; Function to disable trapping
	MOV	DX,NUM_TKEYS	; Start with maximum trappable key
DISA_KEY:			; Loop until DX = 0
	CLI
	CALL	B$RDKYBD	; Disable it
	STI
	DEC	DX		; Step to next key
	JNZ	DISA_KEY	; and loop back
cEnd

;#*****************************************************************************
cProc	B$ONKA,<FAR,PUBLIC>
parmW	keynum
parmD	fpHandler
cBegin				
	MOV	BX,keynum	; [BX] = requested key
	MOV	CH,NUM_TKEYS-2-NUM_GAP	; if no ronco presented, last legal
				;  key is 25, NUM_TKEYS including the gap
				;  and F11/F12
	TEST	b$RcoFlg,0FFH	; is ronco present ?
	JZ	ChkEnd		; Brif not
	CMP	BL,CH		; is legal user defined keys
	JBE	RoncoHere	; Brif yes
	CMP	BL,NUM_TKEYS-2	; is possibly F11 or F12 ?
	JBE	EVNT_ERROR	; Brif not
RoncoHere:			
	MOV	CH,NUM_TKEYS	; extended the range
				; 0 or beyond the range will be checked in
				; ONFUN
ChkEnd:
	MOV	CL,KEYOFF
	JMP	B$ONFUN

cEnd	nogen

	SUBTTL	SLEEP statement
	page

;*** 
; B$SLEP -- Wait for a given amount of time or for a BASIC event.
;
;Purpose:
;	Wait until one of the following occurs:
;		N seconds have elapsed
;		A trapable BASIC event occurs
;		A key is hit
;
;	If N = 0 (compiler also generates N = 0 if parameter not specified)
;	it functions as if N = infinite.
;
;Entry:
;	Number of seconds to sleep on stack
;
;Exit:
;	None
;
;Uses:
;	Per convention
;
;Exceptions:
;	None
;
;******************************************************************************
cProc	B$SLEP,<FAR,PUBLIC>
parmD	secs			; # seconds to wait (0 if no parm)
cBegin

	call	B$SetKybdInt	; install kybd int handler if not already done.
NoKybdInst:			
	call	B$SetClockInt	; set up clock interrupt if not already done

	mov	dx,seg_secs	; DX = high word of # seconds
	mov	ax,off_secs	; AX = low word of # seconds

	mov	cx,dx		; zero seconds specified?
	or	cx,ax
	jz	NoTimeout	; brif so -- no timeout


	cmp	DX,2		; is it more than SCTIOC can handle?
	jae	NoTimeout	; brif so -- assume no timeout
	call	B$SleepInit	; set up number of seconds to sleep
	OR	b$EventFlags,SLEEPtmr ; activate SLEEP timout timer

NoTimeout:
	OR	b$EventFlags,InSLEEP ; set in SLEEP statement flag

EventLoop:
	test	b$EventFlags,InSLEEP ; have any events occured?
	jnz	EventLoop	; brif not -- loop until one occurs


cEnd




	page
;***
;B$xKEYTRAPINIT - Initializer for KEY trapping
;
;Purpose:
;	Put address of B$POLKEY in polling dispatch table
;
;Entry:
;	None
;Exit:
;	None
;Uses:
;	None
;
;Exceptions:
;****
cProc	B$xKEYTRAPINIT,<FAR>
cBegin
	MOV	[B$PollDispTable + (TKEYS_IND * 2)],EV_TEXTOFFSET B$POLKEY
	MOV	[b$pInitKeys1],EV_TEXTOFFSET B$InitKeys1
	MOV	[b$pInitKeys2],EV_TEXTOFFSET B$InitKeys2
NoKybdInit:				
cEnd

sEnd	EV_TEXT
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\evttim.asm ===
TITLE	EVTTIM - Timer event handling
;***
; EVTTIM - Timer event handling
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Event trapping support for timer.
;
; BASIC Syntax mapping to included runtime entry points:
;
;
; - TIMER(n) Statement - 3 syntax variants map to 3 entry points:
;
;      TIMER(n) ON	  TIMER(n) OFF	    TIMER(n) STOP
;      -----------	  ------------	    -------------
;	    |			|		   |
;	 B$ETT0		     B$ETT1		B$ETT2
;
;******************************************************************************
	INCLUDE switch.inc

	INCLUDE rmacros.inc

	useSeg	EV_TEXT
	useSeg	ER_TEXT
	useSeg	_DATA
	useSeg	XIB
	useSeg	XI
	useSeg	XIE

	INCLUDE seg.inc
	INCLUDE event.inc
	INCLUDE baslibma.inc
	INCLUDE idmac.inc

	INITIALIZER	B$xTIMTRAPINIT

sBegin	_DATA
externW	B$PollDispTable
sEnd	_DATA

sBegin	ER_TEXT
externNP B$ERR_FC
sEnd	ER_TEXT

sBegin	EV_TEXT
assumes CS,EV_TEXT

externNP B$RTIMR
externNP B$TestTrap
externNP B$ReqTrap
externNP B$EVNT_SET
externNP B$settbl
externNP B$ONFUN

	SUBTTL	TIMER Statement, Function, and Trapping Support
;***
;POLTIM
;Purpose:
;	Determine if a timer event has occurred.
;	If it has, then EVTRP is called to signal the occurrance.
;Entry:
;Exit:
;Modifies:
;	 AX, BX, CX, DX can be used (restored by CHKINT).
;	 All other registers are preserved.
;****

cProc	B$POLTIM,<NEAR>
cBegin
	MOV	AL,0D
	CALL	B$RTIMR		; Request "trap-occurred" flag
	OR	BX,BX
	JE	POLTIX		;branch if no timer interrupt
	MOV	AL,TIMOFF
	CALL	B$TestTrap	;Trapping ON?
	JZ	POLTIX		;NO
	CALL	B$ReqTrap	;Enabled, Issue Request.
POLTIX:
cEnd

	SUBTTL	TIMER [ON,OFF,STOP] Statement
	PAGE

;***
; B$ETT0, B$ETT1, B$ETT2  - TIMER  [ON,OFF,STOP] Statement
;
; Purpose:
;	Dispatch TIMER statement depending upon following clauses:
;
;	TIMER	     ON      Enable  TIMER Trapping.
;	TIMER	     OFF     Disable TIMER Trapping.
;	TIMER	     STOP    Suspend TIMER Trapping.
; Input:
;	NONE
; Output:
;	Event set in trap table, or error
;****

labelFP	<PUBLIC,B$ETT0>		; TIMER ON
	MOV	DL,$ON
	SKIP	2
labelFP	<PUBLIC,B$ETT1>		; TIMER OFF
	MOV	DL,$OFF
	SKIP	2
labelFP	<PUBLIC,B$ETT2>		; TIMER STOP
	MOV	DL,$STOP

cProc	TIMON_PROC,<FAR>,<SI,ES>
cBegin
	MOV	CL,TIMOFF
	MOV	SI,EV_TEXTOFFSET B$RTIMR
	XOR	BL,BL
	CALL	B$EVNT_SET	;Set Event
cEnd

EVNT_ERROR:
	JMP	B$ERR_FC	; give Illegal function call error
;***
;****

cProc	B$ONTA,<FAR,PUBLIC>,<ES>
parmD	timecount
parmD	fpHandler
cBegin

	push	dx		; save user routine
	mov	dx,off_timecount ; low word of timer value.
	mov	ax,seg_timecount ; high word of timer value.
	mov 	cx,ax		; CX contains high word
	or	ax,dx		; is input zero?
	jz	EVNT_ERROR	; brif so -- illegal function call
	jcxz	NUMOK		; brif input < 64k -- it's o.k.
	loop	EVNT_ERROR	; brif input >= 0x20000
	inc	cx		; restore high word to 1
	cmp	dx,5181H	; greater than 86400 (X'15181') ?
	jnb	EVNT_ERROR	; brif so -- out of range
NUMOK:				; CL/DX contains valid 24-bit integer
	mov	al,set_interval ; tell oem the interval
	call	B$RTIMR
	jc	EVNT_ERROR	; oem didn't like value for on timer

	pop	dx		; restore user routine
	mov	al,TIMOFF	; offset of timer into b$TRPTBL
	lea	bx,[fpHandler]	; parm to settbl
	call	B$settbl
cEnd

;***
;B$xTIMTRAPINIT - Initializer for TIMER trapping
;
;Purpose:
;	Put address of B$POLTIM in polling dispatch table
;
;Entry:
;	None
;Exit:
;	None
;Uses:
;	None
;
;Exceptions:
;****
cProc	B$xTIMTRAPINIT,<FAR>	
cBegin
	MOV	[B$PollDispTable + (TIMER_IND * 2)],OFFSET B$POLTIM
cEnd
sEnd	EV_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\fhdebug.asm ===
TITLE	FHDEBUG - FAR HEAP DEBUG CODE

;***
;FHDEBUG.ASM - Far Heap Debugging Code for the BASIC 3 Common Runtime
;
;	Copyright (C) Microsoft Corp. 1986.
;
;****

	SUBTTL	INCLUDES AND DEFINITIONS FOLLOWS
	PAGE	56,132

INCLUDE switch.inc
INCLUDE rmacros.inc

	USESEG	<FH_TEXT>
	USESEG	<_BSS>
	USESEG	<_DATA>

INCLUDE seg.inc
INCLUDE idmac.inc
INCLUDE array.inc


	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\fhutil.asm ===
TITLE	FHUTIL - Far Heap and Array Utility routines
	PAGE	56,132
;***
;FHUTIL - Far Heap and Array Utility routines
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
; Contains utility routines used in Far Heap and general array accessing.
;
;******************************************************************************
	INCLUDE switch.inc
	INCLUDE rmacros.inc	;Runtime Macro Defintions

	useSeg	_DATA
	useSeg	FH_TEXT

	INCLUDE seg.inc
	INCLUDE array.inc	;far heap and array descriptor structures
	INCLUDE idmac.inc

sBegin	FH_TEXT
assumes CS,FH_TEXT

	SUBTTL	B$ADArraySize - compute array size from descriptor
	PAGE
;***
;B$ADArraySize - compute array size from descriptor
;
;Purpose:
;	To compute the array size in bytes from its descriptor.
;	This value is the product of the element size and the
;	size of each dimension.
;
;	For FV_LONGPTR versions:
;	    return value is not defined if array is not dimensioned
;
;Entry:
;	ds:bx = offset of array descriptor.
;Exit:
;	CY = set if overflow, else cleared.
;	DX:AX = 32-bit size of the array in bytes (invalid if overflow).
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	B$ADArraySize,<NEAR,PUBLIC>,<BX,CX,SI,DI>
cBegin

;	Get the number of dimensions from the descriptor.

	MOV	CL,[BX].AD_cDims ;move the dimension number
	XOR	CH,CH		;make a word value

DbAssertRel	CX,NE,0,FH_TEXT,<Array with zero dimensions in B$ADArraySize>

;	Initialize the running product in SI:DI to the element size.

	MOV	DI,[BX].AD_cbElement ;get the element size
	XOR	SI,SI		;make a doubleword value

;	For each dimension, multiply SI:DI by the element count.

ADArraySizeLoop:
	MOV	AX,DI		;get low-order word of running product
	MUL	[BX].AD_tDM.DM_cElements ;get first product of loop
	MOV	DI,AX		;move low-order word of first product
	MOV	AX,SI		;get high-order word of running product
	MOV	SI,DX		;running product now has first product
	MUL	[BX].AD_tDM.DM_cElements ;get second product of loop
	JC	ADArraySizeOflo ;if high-order word nonzero, then overflow
	ADD	SI,AX		;add low-order word to high-order running prod
	JC	ADArraySizeOflo ;if carry, then overflow
	ADD	BX,SIZE DM	;add size of array dim info - clears carry
	LOOP	ADArraySizeLoop ;loop until done

;	Move final result to DX:AX.

	MOV	AX,DI		;move low-order result and..
	MOV	DX,SI		;the high-order result

;	Exit with carry set if overflow in computation (> 32 bits),
;	else with carry clear.

NotDimmed:			
ADArraySizeOflo:

cEnd

sEnd
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\fhinit.asm ===
TITLE	FHINIT - Far Heap Initialization and Support
	PAGE	56,132
;***
;FHINIT.ASM - Far Heap Initialization for the BASIC 3 Common Runtime
;
;	Copyright (C) Microsoft Corp. 1986.
;
;*****************************************************************************

	SUBTTL	INCLUDES AND DEFINITIONS FOLLOWS

INCLUDE switch.inc
INCLUDE rmacros.inc

	USESEG	<INIT_CODE>	;Initialization
	USESEG	<BR_DATA>	
	USESEG	<_DATA>
	USESEG	<_BSS>
	USESEG	<NH_TEXT>
	USESEG	<RT_TEXT>	
	USESEG	<FH_TEXT>
	USESEG	<DV_TEXT>	
	USESEG	<XIB>		
	USESEG	<XI>		
	USESEG	<XIE>		
	USESEG	<BC_SAB>	
	USESEG	<BC_SA> 	

INCLUDE seg.inc
INCLUDE idmac.inc
INCLUDE messages.inc		
INCLUDE compvect.inc		
INCLUDE array.inc
INCLUDE smchain.inc		
INCLUDE oscalls.inc		
INCLUDE	addr.inc		
INCLUDE baslibma.inc		
INCLUDE string.inc		
INCLUDE stack2.inc		

	externFP	B$ERR_OM_FH	; out of memory error
	externFP	B$ERR_MEM	;arena destroyed error
	externNP	B$ERR_FHC	;bad memory block address


	externFP	B$ULAllocDataImage ;alloc UL data images for restart
	externFP	B$ULDataRelease ;dealloc UL data images
	externFP	CompressHelp	; compress and close help system
	externFP	ShrinkHelp	; compress help system (stay open)
	externFP	fEditorActive	
	externFP	CompressBufs	

	INITIALIZER	B$xFHINI	;put B$xFHINI in initializer list.

	SUBTTL	DATA DEFINITIONS

sBegin	BR_DATA

	externW __acmdseg	; C startup __psp

sEnd	BR_DATA

sBegin	_DATA

	externW b$ini_disp	;One time initialization dispatch table
	externW b$clrt_disp	;CLEAR dispatch table
	externW b$run_disp	;RUN dispatch table
	externW b$pFHRaiseBottom ;Vector to B$FHRaiseBottom
	externW b$pFHLowerTop	;Vector to B$FHLowerTop
	externW b$shli_disp	;Shell initialization dispatch table
	externW b$shlt_disp	;Shell termination dispatch table

	externB b$Chaining	;non-zero if we are CHAINING

sEnd	_DATA

sBegin	_BSS


	globalB b$FHDStart,,<SIZE FHD>	 ; starting FHD for list




	globalB b$FHDEnd,,<SIZE FHD> ;ending FHD for list

	externW b$NH_first	;NHINIT - starting offset of near heap
	externW b$NH_last	;NHINIT - ending offset of near heap

	externW b$UcodeOff	;offset of usercode header
	externW b$UcodeSeg	;segment of usercode header


sEnd	_BSS

sBegin	DV_TEXT 		
	externNP B$NearRet	;for disp vectors in compvect.inc
sEnd	DV_TEXT 		


sBegin	NH_TEXT

	externNP	B$NHMOV 	;move near heap

sEnd	NH_TEXT

sBegin	RT_TEXT 			
sEnd	RT_TEXT 			

	PAGE
	SUBTTL	Far Heap Initialization

assumes CS,INIT_CODE
sBegin	INIT_CODE

;***
;B$xFHINI - Far Heap initializer
;PLM B$xFHINI()
;
;Purpose:
;	Initializer for Far Heap component.  This routine is called
;	by the Crt0 startup before _main is called.  It will update the
;	indirect dispatch tables for the far heap routines.  This
;	insures that the only time that the far heap is accessed is when
;	this module is linked into the user program.
;
;Entry:
;	None.
;
;Exit:
;	Appropriate dispatch vectors filled.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****************************************************************************

cProc	B$xFHINI,<FAR>
cBegin

;	update "ONE" time initialization dispatch address to B$FHIni

	MOV	WORD PTR [b$ini_disp].FH_IVEC,FH_TEXTOFFSET B$FHIni 

;	update CLEAR time initialization dispatch address to B$FHClear

	MOV	WORD PTR [b$clrt_disp].FH_CLTVEC,FH_TEXTOFFSET B$FHClear


;	update RUN time initialization dispatch address to B$FHClear

	MOV	WORD PTR [b$run_disp].FH_RVEC,FH_TEXTOFFSET B$FHClear  



cEnd

sEnd	INIT_CODE


ASSUMES CS, FH_TEXT
sBegin	FH_TEXT


;***
; B$FHIni - One time initialization for far heap (DOS 3 & 5)
;
;Purpose:
;	One time initialization for the far heap.  For DOS 3, this routine
;	allocates all available memory and sets up the initial free space.
;	Set vector b$pFHRaiseBottom to B$FHRaiseBottom (DOS 3).
;	Set vector b$pFHLowerTop to B$FHLowerTop (DOS 3).
;
;Entry:
;	None.
;
;Exit:
;	Allocates memory and inits descriptor chain (DOS 3)
;
;Uses:
;	None.
;
;Exceptions:
;	Out of memory condition if allocation cannot be done.
;******************************************************************************

FHIniError:
	JMP	B$ERR_MEM	;report out of memory error

DbPub	B$FHIni 		
cProc	B$FHIni,<NEAR>,<ES>	
cBegin

	MOV	b$pFHRaiseBottom, FH_TEXTOFFSET B$FHRaiseBottom 	 
	MOV	b$pFHLowerTop, FH_TEXTOFFSET B$FHLowerTop		
	MOV	ES,__acmdseg	;get address for CODE/DGROUP block
	MOV	BX,0FFFFH	;ask for maximum memory possible...
	MOV	AH,4AH		;so DOS will get maximum size...
	CALL	B$FHMemDosCall	;call to perform INT and handle fatal errors
	JNC	FHIniError	;call should always fail
	MOV	AH,4AH		;allocate the maximum block, leaving none
	CALL	B$FHMemDosCall	;remaining for any other process
	JC	FHIniError	;error if allocation failed

;	Build the FHD list static descriptors b$FHDStart and b$FHDEnd.

	MOV	AX,b$NH_last	;get last offset of near heap
	INC	AX		;nxt word (+2) + nxt para (+0F) - one para (10)
	MOV	CL,4		;...and shift by four...
	SHR	AX,CL		;...to get paragraph size
	INC	AX		;put paragraph back that was subtracted
	MOV	CX,DS		;get starting segment of DGROUP
	ADD	CX,AX		;add to get lower boundary paragraph
	MOV	b$FHDEnd.FHD_hData,CX ;put lower boundary in static descriptor
	MOV	CX,ES		;get start of CODE/DGROUP block
	ADD	CX,BX		;add maximum size to get upper boundary
	MOV	b$FHDStart.FHD_hData,CX ; put upper boundary in static desc
	XOR	AX,AX		;clear for repeated use below
	MOV	b$FHDStart.FHD_cPara,AX ; size of starting entry in list is zero
	MOV	b$FHDStart.FHD_pNext,OFFSET DGROUP:b$FHDEnd ; start points to end
	MOV	b$FHDEnd.FHD_cPara,AX ;size of ending entry in list is zero
	MOV	b$FHDEnd.FHD_pNext,AX ;last entry points to null - end of list

;	Allocate Preinited Data images for quick restartability
	CALL	B$ULAllocDataImage


cEnd

;***
; B$FHClear - CLEAR support for far heap
;
;Purpose:
;	Added routine as part of revision [22].
;	Far heap support for the CLEAR statement.  Deallocate all
;	entries either in COMMON or in the user variables.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	B$FHClear,<NEAR,PUBLIC>,<BX,ES> 
cBegin

	CMP	b$UcodeSeg,0	;test if any compiled code
	JZ	FHClearRet	;if not, just return

	LES	BX,DWORD PTR b$UcodeOff ;ES:BX = seg:off of usercode header
	MOV	AX,OFFSET FHClearEntry ;get offset to routine for each entry
	CALL	B$FHSelect	;select the far heap entries to deallocate



FHClearRet:

cEnd

;***
; FHClearEntry - FHSelect routine for CLEAR support
;
;Purpose:
;	Added as part of revision [22].
;	Returns flag to deallocate any FH entry in COMMON or
;	the user variables.
;Entry:
;	ES:BX = far pointer to usercode header
;	SI = pointer to FH descriptor to check.
;Exit:
;	AX = 0 - do not deallocate entry described at SI.
;	AX <> 0 - deallocate entry described at SI.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	FHClearEntry,<NEAR>,<SI>	
cBegin
	MOV	AX,-1		;default to deallocate entry

;	Test if descriptor is in the user variables.  If so, flag deallocation.

	CMP	SI,ES:[BX].OF_DAT ;test against lower bound of user variables
	JB	FHClrEntCommon	;if too low, then test for COMMON area
	CMP	SI,ES:[BX].OF_FT ;test against upper bound of user variables
	JB	FHClrEntDealloc	;if within bounds, then jump to flag deallocate

;	Test if descriptor is in COMMON.  If so, flag deallocation.

FHClrEntCommon:

	CMP	b$Chaining,0	;are we CHAINing in interpreter?
	JNZ	FHClrEntNoDealloc ;don't deallocate COMMON entries if so

	SUB	SI,ES:[BX].OF_COM ; compute offset of descriptor in COMMON
	JB	FHClrEntNoDealloc ;if below COMMON, then flag no dealloc
	CMP	SI,ES:[BX].SZ_COM ; test if offset if with COMMON
				; this use of SZ_COM is OK, since we are
				; looking at ALL the modules
	JB	FHClrEntDealloc	;if in COMMON, then deallocate

;	Increment AX to 0 for no deallocation, else leave at -1.

FHClrEntNoDealloc:
	INC	AX		;set to zero for no deallocation
FHClrEntDealloc:

cEnd
	SUBTTL	B$FHClearRange - Delete entries in a range
	PAGE
;*** 
; B$FHClearRange - Delete entries in a range (QBI Only)
; Added Rev [39]
; needed for BC6 also now
;
;Purpose:
; Delete all far heap entries whose descriptors fall into a passed DGROUP
; range.
;
;Entry:
; [AX]	= start of the range to deallocate in
; [BX]	= end of range
;
;Exit:
; none
;
;Uses:
; Per convention
;
;******************************************************************************
cProc	B$FHClearRange,<NEAR,PUBLIC>
cBegin
	XCHG	AX,CX		;[CX] = start of range
	MOV	AX,OFFSET FHClearRangeEntry
	Call	B$FHSelect
cEnd

;*** 
; B$FHClearRangeEntry - Delete entry if in a range (QBI Only)
; needed for BC6 also now
; Added Rev [39]
;
;Purpose:
; Delete far heap entry if descriptor falls into a passed DGROUP range.
;
;Entry:
; [CX]	= start of the range to deallocate in
; [BX]	= end of range
; [SI]	= address of heap descriptor
;
;Exit:
; [AX]	= Non-zero if entry to be deallocated
;
;Uses:
; Per convention
;
;******************************************************************************
cProc	FHClearRangeEntry,NEAR
cBegin
	XOR	AX,AX		;Assume not deallocating
	CMP	SI,CX
	JB	ClearRangeSkip	;Jump if below range
	CMP	SI,BX
	JA	ClearRangeSkip	;Jump if above range
	DEC	AX		;[AX] = -1
ClearRangeSkip:
cEnd

;***
;B$FHAllocFAR - far entrypoint for B$FHAlloc.
;
;Purpose:
;	Added with revision [75].
;	Far entrypoint for B$FHAlloc (called from LOADRTM segment).
;Entry:
;	Same as B$FHAlloc
;Exit:
;	Same as B$FHAlloc
;Uses:
;	Same as B$FHAlloc
;Exceptions:
;	Same as B$FHAlloc
;******************************************************************************
cProc	B$FHAllocFAR,<FAR,PUBLIC>
cBegin
	CALL	B$FHAlloc
cEnd

;***
; B$FHAlloc - allocate a far heap entry (DOS 3 & 5)
;
;Purpose:
;	Calls B$IFHAlloc to allocate an entry of the requested size.
;	If the allocation attempt fails, an Out of Memory runtime error
;	is issued.
;Entry:
;	DX:AX = 32-bit size in bytes.
;	BX = unallocated far heap descriptor for allocated entry.
;Exit:
;	[BX].FHD_hData <> segment if allocated (0 if unallocated)
;Uses:
;	None.
;Exceptions:
;	Out of memory condition if allocation cannot be done.
;Note:
;	For DOS 5 the cPara field is never altered by the
;	Far Heap manager.
;******************************************************************************

cProc	B$FHAlloc,<PUBLIC,NEAR>,<AX> 
cBegin				
	cCall	B$IFHAlloc	;call common allocation code
	OR	AX,AX		;did allocation succeed?
	JNZ	FHAllocSuccess	;brif no error
	JMP	B$ERR_OM_FH	;issue out of memory error if failed
FHAllocSuccess: 		
cEnd


;***
; B$IFHAlloc - allocate a far heap entry (return error code on fail)(DOS 3 & 5)
;
;Purpose:
;	Allocates a far heap entry of the given size.  The far heap is
;	first scanned from its upper to lower boundary using a first-fit
;	algorithm.  If no space is found of sufficient size, a compaction
;	is done and the resulting unallocated space is tested.	If still
;	no room, the near heap is shrunk and the space reclaimed to the
;	far heap to provide the allocation.
;Entry:
;	DX:AX = 32-bit size in bytes.
;	BX = unallocated far heap descriptor for allocated entry.
;Exit:
;	AX = zero if not enough memory is present for requested allocation.
;	[BX].FHD_hData <> segment if allocated (0 if unallocated)
;Uses:
;	None.
;Exceptions:
;	None.
;Note:
;	For DOS 5 the cPara field is never altered by the
;	Far Heap manager.
;******************************************************************************

IFHAllocDone:			

cProc	B$IFHAlloc,<NEAR,PUBLIC>,<BX,CX,DX,SI,DI,ES> 
cBegin

;This routine can cause movement of the near heap, thus potentially
;invalidating the entry pointer to this routine if it is in the near heap.

DbAssertRel BX,B,b$NH_first,<FH_TEXT>,<Attempted to Far alloc with owner in near heap>

;	Convert size DX:AX from bytes to paragraphs.

	CALL	FHByteToPara	;change DX:AX bytes to paragraphs in DX:AX
	OR	DX,DX		;test if more than 1M bytes requested
	JNZ	FHAllocError	;if so, give error immediately

DbAssertRel	AX,NZ,0,FH_TEXT,<Cannot B$FHAlloc a buffer of size 0>

;	To allocate a far heap entry, a first-fit allocation is attempted.
;	SI traverses down the far heap descriptor list.  FHTryAlloc is used
;	to determine if any unallocated space exists adjacent to the lower
;	boundary of the far heap entry described by SI.

	MOV	SI,OFFSET DGROUP:b$FHDStart ;set pointer to first desc in list
FHAllocLoop:
	CALL	FHTryAlloc	;try to allocate AX para adjacent to desc at SI
	JNC	FHAllocDone	;if success, then jump to finish
	MOV	SI,[SI].FHD_pNext ;get pointer to next descriptor in the list
	CMP	SI,OFFSET DGROUP:b$FHDEnd ;test if final descriptor
	JNZ	FHAllocLoop	;if not last descriptor, then jump to try again

;	If first-fit fails, next compact the far heap and test the resulting
;	unallocated space.

	CALL	FHTryAllocCompact ; compact to combine the free areas,
				; and try to allocate again
	JNC	FHAllocDone	;if success, then jump to finish

;	If compaction fails, shrink the near heap enough to get the necessary
;	room for the allocation.

	MOV	DX,AX		;save request amount in DX
	CALL	FHParaSize	;get size of unallocated entry in AX
	SUB	AX,DX		;compute negative of size needed yet...
	NEG	AX		;...now value is positive
	CALL	B$FHLowerBottom   ;attempt to lower the FH bottom for more room
	XCHG	AX,DX		; [AX] = original allocation request
	CALL	FHTryAllocCompact ; compact to combine the free areas,
				; and try to allocate again

	JNC	FHAllocDone	; if success, then jump to finish

;	If there was not enough near heap space, then release user lib
;	data images, recover released space and retry allocation.

	PUSH	AX		;save original allocation request
	PUSH	BX		; Save FHD
	CALL	B$ULDataRelease ;free UL data images (if present)
	POP	BX		
	POP	AX		;[AX] = original allocation request
	CALL	FHTryAllocCompact ; compact to combine the free areas,
				; and try to allocate again
	JNC	FHAllocDone	; it worked, don't keep trying!

;	If there was STILL not enough space, then have the help engine close
;	down to release the remaining memory that it has, and re-try.

	PUSH	AX		; save registers
	PUSH	BX		
	CALL	CompressHelp	; have help engine shrink down to minimum
	POP	BX		; restore registers
	POP	AX		
	CALL	FHTryAllocCompact ; compact to combine the free areas,
				; and try to allocate again
NoHelpShrink:			

	JNC	FHAllocDone	;if success, then return

FHAllocError:			
	XOR	AX,AX		;return error code - no memory available

;	Allocation succeeded - done.

FHAllocDone:

cEnd


;***
; FHByteToPara - convert size in bytes to paragraphs (DOS 3)
;
;Purpose:
;	Shift the 32-bit value given right four times to compute
;	paragraphs.
;Entry:
;	DX:AX = 32-bit number of bytes
;Exit:
;	DX:AX = 32-bit number of paragraphs
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	FHByteToPara,<NEAR>
cBegin

	ADD	AX,0FH		;round up DX:AX to the...
	ADC	DX,0		;...nearest paragraph
	SHR	DX,1		;shift DX:AX...
	RCR	AX,1		;...once
	SHR	DX,1		;and...
	RCR	AX,1		;...twice
	SHR	DX,1		;and...
	RCR	AX,1		;...thrice
	SHR	DX,1		;and...
	RCR	AX,1		;...four times to get the paragraphs

cEnd

;***
; FHTryAlloc/FHTryAllocCompact - try to allocate after a specific entry (DOS 3)
;
;Purpose:
;	Given a DGROUP offset to a far heap descriptor and its corresponding
;	far heap entry, compute the size of the unallocated space adjacent
;	to the lower boundary of the entry.  Allocate the upper part of the
;	space if large enough to satisfy the allocation request.
;
;	FHTryAllocCompact added with revision [74] to compact far heap before
;	trying to do the allocation.
;
;Entry:
;	SI = DGROUP offset of allocated far heap descriptor to test
;	     for the adjacent unallocated entry.
;	BX = DGROUP offset of unallocated far heap descriptor to be
;	     allocated.
;	AX = Size of allocation request in paragraphs.
;Exit:
;	CF clear = allocation successful - descriptor at BX filled
;	     and linked into the far heap descriptor list.
;	CF set = allocation failed - descriptor at BX unchanged.
;Uses:
;	BX, CX, DX, DI.
;Exceptions:
;	None.
;******************************************************************************

cProc	FHTryAllocCompact,<NEAR>
cBegin
	cCall	B$FHCompact		; compact the heap to combine new free
					; areas
cEnd	<nogen>				; fall into FHTryAlloc

cProc	FHTryAlloc,<NEAR>,<AX>
cBegin

;DbAssertRel	 [BX].FHD_hData,z,0,FH_TEXT,<FHTryAlloc: entry already allocated> 

;	Determine the location and size of the unallocated region in the
;	far heap by determining the lower boundary of the given allocated
;	far heap entry and upper boundary of the next allocated far heap
;	entry.	The unallocated region is exclusively between these two
;	values.

	MOV	DI,[SI].FHD_pNext ;get descriptor pointer of next heap entry
	MOV	DX,[SI].FHD_hData ;get start segment of given heap entry
	MOV	CX,[DI].FHD_hData ;get start segment of next heap entry
	ADD	CX,[DI].FHD_cPara ;add size to get seg past upper bound of next
	SUB	CX,DX		;compute negative size of unallocated region
	NEG	CX		;negate to get correct size
	SUB	DX,AX		;get allocated seg to be adjacent given entry

;	Test if the unallocation region of size CX paragraphs is large
;	enough to satisfy the allocation request of AX paragraphs.  If
;	not, then jump with carry set to exit.

	CMP	CX,AX		;test if region is large enough for allocation
	JB	FHTryFail	;jump with CARRY set for failure

;	Allocation succeeded - new entry is AX paragraphs in length at
;	DX:0.  Note that the allocation is taken from the upper part of
;	the unallocated region to try to minimize compaction.  The new
;	far heap descriptor segment and length is filled and is linked
;	between the given and next descriptor in the list.

	MOV	[BX].FHD_hData,DX ;fill in segment value of new descriptor
	MOV	[BX].FHD_cPara,AX ;fill in paragraph size of new descriptor
	MOV	[BX].FHD_pNext,DI ;new descriptor is linked to next descriptor
	MOV	[SI].FHD_pNext,BX ;given descriptor is linked to new descriptor

;	Clear the entry using B$FHMove with BX=DX.  Return CARRY clear.

	MOV	BX,DX		;set equal so B$FHMove clears the entry
	CALL	B$FHMove	;clear the entry at DX:0 for AX paragraphs
	CLC			;clear carry flag for success

FHTryFail:

cEnd

;***
;B$FHRealloc - Reallocate a far heap entry (DOS 3 & 5)
;
;Purpose:
;	Dos 3 support added with revision [32].
;	Added as part of revision [11].
;	Reallocate a block of memory from DOS.
;Entry:
;	DX:AX = 32-bit total size in bytes to reallocate.
;	BX = DGROUP offset of FH descriptor.
;Exit:
;	AX = 0 means reallocation failed.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************


cProc	B$FHRealloc,<PUBLIC,NEAR>,<SI,DI,ES>
localV	FHDTmp,<SIZE FHD>
cBegin

	MOV	CX,AX		;save byte size of request in DI:CX
	mov	DI,dx		
	cCall	FHByteToPara	;[DX:AX] = para size of request
DbAssertRel	DX,Z,0,<FH_TEXT>,<Reallocation request too large after rounding in B$FHRealloc>
	CMP	AX,[BX].FHD_cPara ;are we growing this entry?
	JBE	RealcSaveSize	;brif not - save new size and exit

;This routine can cause movement of the near heap, thus potentially
;invalidating the entry pointer to this routine if it is in the near heap.

DbAssertRel BX,B,b$NH_first,<FH_TEXT>,<Attempted a Far realloc with owner in near heap>

;	We need to grow the entry.  Our reallocation strategy is:
;
;	  1. Check the adjacent entry.	If there is enough free space
;	     to satisfy the allocation, use it.
;	  2. Try to allocate a new entry of the requested size.  If
;	     successful, copy data to newly allocated heap entry, and
;	     change the owner of the entry to be the descriptor passed
;	     to us on entry to B$FHRealloc.
;	  3. As a last resort, see if enough room exists for the additional
;	     amount requested.	If so, then move all far heap entries
;	     from the requested entry to the last allocated entry, down
;	     by the additional amount.	The requested entry can then
;	     reclaim the freed space to satisfy the allocation request.

;	Check the adjacent entry for enough free space.

	cCall	FHPrevDesc	;[SI] = descriptor before [BX]
	MOV	DX,[SI].FHD_hData
	SUB	DX,[BX].FHD_hData ;[DX] = total paras available for allocation
	CMP	DX,AX		;is it enough to satisfy the request?
	JB	RealcNew	;brif not

RealcSaveSize:

;	Enough free space exists between this entry and adjacent entry.

	MOV	[BX].FHD_cPara,AX ;update size
	JMP	SHORT RealcDone ;exit

RealcNew:

;	Try to allocate a new entry of requested size.

	XCHG	AX,CX		;[AX]=low word of byte count, [CX]=para count
	mov	dx,di		; [DX:AX] = byte count of original request
	PUSH	BX		;save entry FHD
	LEA	BX,FHDTmp	;point to temp FHD
	cCall	B$IFHAlloc	;try to allocate a new entry
	MOV	SI,BX		;save new FHD
	POP	BX		;recover entry FHD
	OR	AX,AX		;was alloc successful?
	JZ	RealcPartial	;brif not, try to allocate incremental diff

;	The allocation succeded. Copy the entry and change the owner.

	MOV	AX,[BX].FHD_cPara ;get size of original entry
	PUSH	BX		;save original FHD
	MOV	BX,[BX].FHD_hData ;get start of area to move
	MOV	DX,[SI].FHD_hData ;get destination
	PUSH	CX		;save para size of allocation
	cCall	B$FHMove	;move the data
	POP	CX		;recover para size of new allocation
	POP	BX		;recover entry FHD
	cCall	B$FHDealloc	;deallocate entry FHD

;	Now make the entry FHD the owner of the newly allocated heap entry.

	MOV	AX,[SI].FHD_hData
	MOV	[BX].FHD_hData,AX ;update segment of allocation
	MOV	AX,[SI].FHD_pNext
	MOV	[BX].FHD_pNext,AX ;update ptr to next descriptor in chain
	MOV	[BX].FHD_cPara,CX ;update size of entry
	PUSH	BX		;save entry FHD
	MOV	BX,SI		;get FHD of newly allocated entry
	cCall	FHPrevDesc	;find the FHD which points to new FHD
	POP	BX		;recover entry FHD
	MOV	[SI].FHD_pNext,BX ;replace new FHD with entry FHD in chain
	JMP	SHORT RealcDone ;exit

RealcPartial:

;	Check to see if enough room exists for current entry to expand
;	Note: we are assuming that the attempted allocation above caused
;	compaction of the far heap to high memory, leaving one free
;	entry at the end of the far heap (lower memory).

	SUB	CX,[BX].FHD_cPara ;compute amount needed to grow entry
	PUSH	BX		;save entry FHD
	MOV	BX,OFFSET DGROUP:b$FHDEnd ;get ending heap descriptor
	cCall	FHPrevDesc	;find last allocated descriptor
	MOV	DI,SI		;[DI] = last allocated FHD
	cCall	FHParaSize	;[AX] = size of Free entry
	POP	BX		;recover entry FHD
	CMP	AX,CX		;does enough memory exist to satisfy allocation?
	JNB	RealcPartialOk	;brif so

	XOR	AX,AX		;return AX=0 meaning not enough memory
	JMP	SHORT RealcDone ;exit

RealcPartialOk:

;	Enough memory exists.  Move free space adjacent to current allocation
;	and allocate it to the Entry FHD.

	PUSH	BX		;save entry FHD
	PUSH	CX		;save increment of allocation
	MOV	AX,[BX].FHD_hData ;get current start of allocation
	ADD	AX,[BX].FHD_cPara ;compute end of current allocation
	MOV	BX,[DI].FHD_hData ;get start of area to move
	SUB	AX,BX		;compute amount of data to move
	MOV	DX,BX		;start of data - size needed = ...
	SUB	DX,CX		;... start of data destination
	cCall	B$FHMove	;move the data
	POP	AX		;recover increment needed
	POP	SI		;recover entry FHD

;	Data is moved, now update all .FHD_hData fields for owners of
;	the moved data.

	XOR	BX,BX		;adjust all descriptors
	MOV	DX,BX		;starting with the Entry FHD to the
	DEC	DX		;end of the descriptor chain
	NEG	AX		;make negative to move heap down
	cCall	FHAdjDescSegSI	;adjust the descriptors
	MOV	BX,SI		;[BX] = entry FHD
	SUB	[BX].FHD_cPara,AX ;update the size to reflect the allocation

RealcDone:
cEnd

;***
;B$FHDeallocFAR - far entrypoint for B$FHDealloc.
;
;Purpose:
;	Added with revision [75].
;	Far entrypoint for B$FHDealloc (called from LOADRTM segment).
;Entry:
;	Same as B$FHDealloc
;Exit:
;	Same as B$FHDealloc
;Uses:
;	Same as B$FHDealloc
;Exceptions:
;	Same as B$FHDealloc
;******************************************************************************
cProc	B$FHDeallocFAR,<FAR,PUBLIC>
cBegin
	CALL	B$FHDealloc
cEnd

;***
; B$FHDealloc - deallocate a far heap entry (DOS 3 & 5)
;
;Purpose:
;	Deallocate the far heap entry referenced by the given
;	far heap descriptor.
;Entry:
;	BX = far heap descriptor of entry to be deallocated
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	Fatal internal error if descriptor not in descriptor list.
;******************************************************************************

cProc	B$FHDealloc,<NEAR,PUBLIC>,<AX,SI>
cBegin

;	Determine the far heap descriptor preceding the one to
;	be deallocated using FHPrevDesc.  Remove the descriptor
;	to be deallocated from the descriptor list and then clear
;	the descriptor segment (FHD_hData).

	CALL	FHPrevDesc	;pointer to previous FHD is in SI
	MOV	AX,[BX].FHD_pNext ;get FHD after the one to be deallocated
	MOV	[SI].FHD_pNext,AX ;link this with the previous FHD


	MOV	[BX].FHD_hData,0 ;clear the deallocated FHD segment value

cEnd

;***
; FHPrevDesc, B$FHPrevDescSI - get previous descriptor in list (DOS 3 & 5)
;
;Purpose:
;	Given a far heap descriptor in the descriptor list,
;	determine its predecessor in the list.
;Entry:
;	BX = FHD offset of the far heap descriptor
;	SI = FHD offset of FHD to start search with (B$FHPrevDescSI only)
;Exit:
;	SI = FHD offset of the predecessor FHD to that pointed
;	     pointer by BX
;Uses:
;	None.
;Exceptions:
;	Fatal internal error if given FHD not in descriptor list.
;******************************************************************************

cProc	FHPrevDesc,<NEAR>
cBegin

	MOV	SI,OFFSET DGROUP:b$FHDStart ;get first FHD of the list
cEnd	<nogen> 		;fall into B$FHPrevDescSI

cProc	B$FHPrevDescSI,<NEAR,PUBLIC> 
cBegin				

FHPrevLoop:
	CMP	[SI].FHD_pNext,BX ;test if predecessor to entry FHD
	JE	FHPrevFound	;if found, then exit with SI set
	MOV	SI,[SI].FHD_pNext ;get the next FHD in the descriptor list
	CMP	SI,OFFSET DGROUP:b$FHDEnd ;test if final descriptor
	JNZ	FHPrevLoop	;if not, then loop to process next FHD
	JMP	SHORT FHPrevError ;fatal error if FHD not found
FHPrevFound:

cEnd

FHPrevError:
	JMP	B$ERR_FHC	;give far heap inconsistency error

;***
; B$FHCompact - compact the far heap (DOS 3 & 5)
;
;Purpose:
;	Compact the far heap entries to upper memory within the
;	far heap.
;	This routine is a nop for DOS 5.
;
;Entry:
;	None.
;Exit:
;	SI = DGROUP offset of the next to last far heap descriptor
;	     in the FHD list.
;Uses:
;	None.
;Exceptions:
;	Fatal internal error if far heap inconsistency.
;******************************************************************************

cProc	B$FHCompact,<NEAR,PUBLIC>,<AX,BX,CX,DX,DI,ES>
cBegin

	CALL	ShrinkHelp	; Kick the help system to release all

	call	CompressBufs	; compress the document buffers

;	SI is a pointer that traverses down the far heap descriptor
;	list starting at b$FHDStart.  DX points to the segment in the
;	compacted far heap space.

	MOV	SI,OFFSET DGROUP:b$FHDStart ;initialize the FHD list pointer
	MOV	DX,[SI].FHD_hDATA ;get segment pointer to compacted space

;	This loop is executed for each entry in the far heap.  SI points
;	to the descriptor in the list while BX points to the start of the
;	far heap entry referenced by the descriptor.

FHCompactLoop:
	MOV	BX,[SI].FHD_hData ;get segment referenced by descriptor at SI
	MOV	AX,[SI].FHD_cPara ;get the length of the far heap entry
	SUB	DX,AX		;compute entry start segment after compaction
	CMP	BX,DX		;test source and destination if movement needed
	JE	FHCompactSkip	;if no movement needed, just skip to next entry
	CALL	B$FHMove	;move the entry from BX:0 to DX:0
	MOV	[SI].FHD_hData,DX ;update descriptor with new entry segment
FHCompactSkip:

;	Save the descriptor pointer in AX in case of exit.  Check far heap
;	consistency by ensuring segments of adjacent descriptors in the list
;	are not increasing.  Advance SI to the next descriptor in the list
;	and, if not the last, loop to process it.

	MOV	AX,SI		;save the descriptor pointer
	MOV	SI,[SI].FHD_pNext ;point to next descriptor in the list
	CMP	[SI].FHD_hData,BX ;test if entry segments are not increasing
	JA	FHCompactError	;if not, then internal error
	CMP	SI,OFFSET DGROUP:b$FHDEnd ;test if last is reserved descriptor
	JNE	FHCompactLoop	;if not, process it

;	Finished with the compaction.  Check whether the last descriptor is
;	the special one reserved.  Set exit variable with next to last
;	descriptor in the list.  This is used to directly determine the size
;	and location of the unallocated space in the far heap.

	CMP	[SI].FHD_cPara,0 ;test if entry size is zero
	JNZ	FHCompactError	;if not, then internal error
	CMP	[SI].FHD_pNext,0 ;test if link field is zero
	JNZ	FHCompactError	;if not, then internal error
	MOV	SI,AX		;set exit variable to next to last descriptor

cEnd

FHCompactError:
	JMP	B$ERR_FHC	;give far heap inconsistency error


;***
; B$FHMove - move or clear a far heap region (DOS 3)
;
;Purpose:
;	Moves a far heap region either up or down within the far heap
;	or clears a far heap region to zeroes.	The region may consist
;	of one or more far heap entries, even the entire heap.
;
;Entry:
;	BX = starting segment of the far heap region to move
;	DX = destination segment of the far heap region
;	AX = size of region to move in paragraphs
;
;Exit:
;	if BX > DX, move AX paragraphs down from BX:0 to DX:0
;	if BX < DX, move AX paragraphs up from BX:0 to DX:0
;	if BX = DX, clear AX paragraphs from BX:0
;
;Uses:
;	AX, BX, CX, DX, DI, ES.
;Exceptions:
;	None.
;******************************************************************************

;	Since the repeated string move instruction (REP MOVSW) is used,
;	a memory region must be split into a number of 64K-byte
;	partitions followed by final partition of less than 64K bytes.
;
;	For moving a region down in memory, the lowest word in the
;	region is moved down first, followed by the next up to the
;	highest word in the region.  To implement this using the minimum
;	number of string move instructions, the first partition is defined
;	at the lower boundary of the region with any succeeding partitions
;	located 64K bytes (or 1000H paragraphs) higher in memory.  The
;	string moves are executed with the direction flag cleared (CLD).
;
;	For moving a region up in memory, the highest word in the
;	region is moved up first, followed by the next down to the lowest
;	word in the region.  The first partition is defined from the
;	upper boundary of the region with any succeeding partitions
;	located 64K bytes (or 1000H paragraphs) lower in memory.  The
;	the string moves are executed with the direction flag set (STD).
;
;	For clearing a region in memory, each partition is cleared
;	separately.  The partitions are defined from lowest word in the
;	region to the highest as in moving the region down.  The first
;	word of the partition is cleared and then a repeated string move
;	propagated the cleared word to the end of the partition.

cProc	B$FHMove,<PUBLIC,NEAR>,<SI,DS> 
cBegin

; Add assertion to check if FH is expected to be stable.
DbAssertRel	[B$FHStable],Z,0,FH_TEXT,<Attempted to relocate far heap when not expected to.>

;	On procedure entry, the direction flag is assumed cleared and BX
;	and DX point to the lower boundary of the region before and after
;	the move, respectively.  For moving down or clearing, BX and DX
;	also point to the start of the first partition to be moved or
;	cleared.

	CMP	BX,DX		;test if moving down or clearing region
	JAE	FHMoveLoop	;if so, then jump to start of partition loop

;	For moving up the direction flag must be set and BX and DX point
;	to the end of the region which is also the end of the first
;	partition.  They will be adjusted to the partition start before
;	the string move is done.

	STD			;set direction flag - moves go from high to low
	ADD	BX,AX		;source pointer at partition end
	ADD	DX,AX		;destination pointer at partition end

;	This loop is executed for each partition.  The size of the partition
;	in paragraphs is computed.  AX contains the number of paragraphs
;	left to process.

FHMoveLoop:
	MOV	CX,1000H	;get default size of partition
	CMP	CX,AX		;test if a full partition can be processed
	JB	FHNotLast	;if so, then jump to use the default size
	MOV	CX,AX		;othewise use the remaining paragraphs
FHNotLast:
	SUB	AX,CX		;update paragraphs left to process

;	If moving up, update the partition pointers in BX and DX to the
;	start of the next partition lower in memory.

	CMP	BX,DX		;test if moving entry up
	JAE	FHNotUpNext	;if not, jump to set segments
	SUB	BX,CX		;point to start of source partition
	SUB	DX,CX		;point to start of destination partition
FHNotUpNext:

;	Set segment registers in preparation to string move.

	MOV	DS,BX		;set the source segment register
	MOV	ES,DX		;set the destination segment register

;	If moving down or clearing, update the partition pointers in
;	BX and DX to start of the next partition up in memory.

	CMP	BX,DX		;test if moving down or clearing
	JB	FHNotDownNext	;if not, then jump to set the count
	ADD	BX,CX		;point to start of next source partition
	ADD	DX,CX		;point to start of next destination partition
FHNotDownNext:

;	Compute the word count for the string move.

	SHL	CX,1		;Paragraphs to words - shift once...
	SHL	CX,1		;...and twice...
	SHL	CX,1		;...and thrice for the word count

;	Compute the source offset.  If moving down or clearing, the offset
;	is zero.  If moving up, the offset is the byte offset of the last
;	word in the partition.

	XOR	SI,SI		;assume source offset is zero
	CMP	BX,DX		;test if moving entry up
	JAE	FHNotUpOffset	;if not, then use jump to use the zero offset
	MOV	SI,CX		;get the word count for partition
	DEC	SI		;make zero-relative word index
	SHL	SI,1		;shift to make byte offset of last word
FHNotUpOffset:

;	Compute the destination offset.  If moving up or down, it is the
;	same as the source offset.  If clearing, it is two more than the
;	source offset.	Clearing uses a string move to overlap an initial
;	zero word entry through the entire partition.

	MOV	DI,SI		;assume moving - destination same as source
	CMP	BX,DX		;test if clearing partition
	JNE	FHNotClear	;if not, then jump to perfrom string move
	MOV	[SI],SI 	;clear the first word of the partition
	INC	DI		;set destination pointer to...
	INC	DI		;the next word in the partition
	DEC	CX		;first word is already zero
FHNotClear:

;	Perform the string move.  If any more partitions, then loop to
;	process them.

	REP	MOVSW		;move or clear the partition
	OR	AX,AX		;test if more partitions to process
	JNZ	FHMoveLoop	;if so, then jump
	CLD			;clear the direction flag

cEnd

;***
; B$FHTestRaiseBottom - raise bottom only if below DGROUP end
; B$FHRaiseBottom - raise the bottom of the far heap (DOS 3)
;
;Purpose:
; Raise the bottom boundary of the far heap to allow the released space to be
; used for near heap allocations. The far heap is raised to maximize the near
; heap size.
;
;Entry:
; None.
;
;Exit:
; None.
;
;Uses:
; AX	  (B$FHTestRaiseBottom)
; None.
;
;Exceptions:
; None.
;
;******************************************************************************
cProc	B$FHTestRaiseBottom,<NEAR,PUBLIC> ; Important: no frame
cBegin				
	MOV	AX,DS		; [AX] = paragraph base of dgroup
	ADD	AH,10H		; [AX] = paragraph base of dgroup + 64k
	CMP	AX,b$FHDEnd.FHD_hData ; See if FH below end of DGROUP
	JA	B$FHRaiseBottom ; Jump if it is, see if can reclaim DGROUP
cEnd				

;  Make B$FHRaiseBottom be called by vector

cProc	B$FHRaiseBottom,<NEAR,PUBLIC>,<AX,BX,CX,DX,SI>
cBegin

;	Compute the paragraphs to raise the far heap to maximize the
;	near heap size.

	MOV	DX,0FFFEH	;get maximum DGROUP for near heap
	SUB	DX,b$NH_last	;subtract to get maximum amount to raise
	MOV	CL,4		;byte-to-paragraph shift count
	SHR	DX,CL		;compute maximum paragraphs to raise

;	Compute the paragraphs of free space in the far heap.

	CALL	B$FHCompact	;compact the far heap (SI = desc of top entry)
	CALL	FHParaSize	;get paragraphs of free space

;	Select the minimum of the two values to use to raise the far heap.

	CMP	AX,DX		;compare available room with maximum request
	JB	FHRaiseBotAvail ;if available room less than max, jump
	MOV	AX,DX		;else use the maximum
FHRaiseBotAvail:
	ADD	b$FHDEnd.FHD_hData,AX ;adjust the bottom FH boundary

;	Raise the top of the near heap by AX paragraphs.

	SHL	AX,CL		;movement amount now in bytes (CL still 4)
	MOV	CX,AX		;new near heap ending offset is...
	ADD	CX,b$NH_last	;...adjusted by the amount
	MOV	AX,b$NH_first	;use present near heap starting offset
	CALL	B$NHMOV 	;raise the near heap top
	MOV	b$NH_last,CX	;update the near heap ending offset

cEnd

;***
; B$FHLowerBottom - lower bottom boundary of far heap. (DOS 3)
;
;Purpose:
;	Lower the bottom boundary of the far heap to allow the released
;	space to be used for far heap allocations. If the far heap
;	cannot be lowered by the requested amount, it is lowered the
;	maximum amount possible.  The top of the near heap is lowered
;	as necessary.
;Entry:
;	AX = number of paragraphs requested to lower.
;Exit:
;	None
;Uses:
;	AX
;Exceptions:
;	Fatal error due to near heap inconsistency.
;******************************************************************************

cProc	B$FHLowerBottom,<NEAR,PUBLIC>,<CX>
cBegin

;	First screen the request for unreasonable requests.  This includes
;	a request at or over 1000H paragraphs (64K bytes).

	TEST	AH,0F0H 	;test if request is 64K bytes or over
	JNZ	FHLowerBotMax	;if so, just try for maximum request

;	Convert the request to bytes and compute the new ending offset.
;	If the byte request is larger than the near heap ending offset,
;	then just try the maximum request.

	MOV	CL,4		;paragraph-to-byte shift is four...
	SHL	AX,CL		;shift to get bytes to lower near heap
	MOV	CX,b$NH_last	;get present ending offset of near heap
	SUB	CX,AX		;compute new ending offset in request
	JC	FHLowerBotMax	;if ending offset would be negative, then max

;	If this ending offset is before the current starting offset,
;	then just try maximum request.

	MOV	AX,b$NH_first	;get start of near heap for move operation
; Fix comparison order in CMP.
	CMP	CX,AX		;test if starting offset before computed ending
	JBE	FHLowerBotMax	;if so, just try for maximum room available

;	Try to lower the far heap by the request amount.

	CALL	B$NHMOV	;lower near heap to maximum size
	JNC	FHLowerBotDone	;if successful, jump to clean up and exit

;	If the near heap cannot be lowered by the requested amount,
;	lower it by the maximum amount possible.

FHLowerBotMax:
	MOV	AX,b$NH_first	;get the near heap starting offset
	XOR	CX,CX		;set offset for maximum release of near heap
	CALL	B$NHMOV 	;lower near heap to maximum size
;
; After the lowering, update the near heap ending offset variable, and compute
; the new start of the far heap, which is the immediately following paragraph.
;
FHLowerBotDone:
	MOV	b$NH_last,CX	; update new near heap ending offset
	XCHG	AX,CX		; [AX] = end of near heap
	MOV	CL,4		; [CL] = byte to para chift count
	ADD	AX,10H		; [AX] = end of near heap + 1 para
	RCR	AX,CL		
	AND	AH,01FH 	; [AX] = para dgroup offset of far heap
	MOV	CX,DS		
	ADD	AX,CX		; [AX] = absolute para far heap start
	MOV	b$FHDEnd.FHD_hData,AX ; Set the new far heap base

cEnd

;***
; B$FHRaiseTop - raise top boundary of far heap (DOS 3)
;
;Purpose:
;	Raise the top boundary of the far heap to allow the reclaimed
;	space to be used for far heap allocations.  If the far heap
;	cannot be raised by the requested amount, it is raised the
;	maximum amount possible.
;Entry:
;	AX = number of paragraphs requested to raise.
;Exit:
;	AX = number of paragraphs actually reclaimed.
;Uses:
;	None.
;Exceptions:
;	Fatal error due to far heap inconsistency.
;******************************************************************************

cProc	B$FHRaiseTop,<NEAR,PUBLIC>,<BX,ES>
cBegin

;	Calculate the paragraph increment from the current far heap
;	top to the theoretical maximum paragraph.  Attempt to reallocate
;	with the minimum of this value and the requested value.

	MOV	BX,b$FHDStart.FHD_hData ;get the top of the far heap
	NOT	BX		;invert for calculation 0FFFFH-FHTop
	CMP	AX,BX		;test for minimum of the two values
	JB	FHRaiseTopReq	;if request if less, then use it
	MOV	AX,BX		;use the calculated maximum value
FHRaiseTopReq:
	CALL	FHSetTop	;attempt to reset the far heap top

cEnd

;***
; B$FHLowerTop - lower top boundary of far heap (DOS 3)
;
;Purpose:
;	Lower the top boundary of the far heap to allow the released
;	space to be used for external allocations. If the far heap
;	cannot be lowered by the requested amount, it is lowered the
;	maximum amount possible.
;Entry:
;	AX = number of paragraphs requested to lower.
;Exit:
;	AX = number of paragraphs actually released.
;Uses:
;	None.
;Exceptions:
;	Fatal error due to far heap inconsistency.
;******************************************************************************

cProc	B$FHLowerTop,<NEAR,PUBLIC>,<BX,CX,DX,SI,DI,ES>
cBegin

;	First, compact the far heap and determine the size of the
;	unallocated space after compaction.

	MOV	CX,AX		;save requested allocation
	CALL	B$FHCompact	;compact - SI is next to last desc in list
	CALL	FHParaSize	;get unallocated size in AX

;	We will need to use the FHD_hData field from the descriptor pointed
;	to by SI, but the descriptor may move during B$FHLowerBottom.  So get
;	the seg value now.  (The descriptor may move but the data won't.)
	MOV	SI,[SI].FHD_hData ; get data seg of entry

;	Test if request can fit within the unallocated space left.
	;if enough, then branch to move heap

	CMP	CX,AX		;test request against unallocated space
	JBE	FHLowTopFit	;if enough, then branch to move heap

;	Compute the room still needed from the near heap and try to
;	obtain it.

	SUB	AX,CX		;subtract request size from unalloc space...
	NEG	AX		;...and negate to compute room needed
	CALL	B$FHLowerBottom ;try to lower far heap bottom AX paragraphs

;	Set up for far heap move.  Get present far heap starting
;	paragraph in BX.

FHLowTopFit:
	MOV	BX,SI		;segment of next to last entry is start

;	Compute new starting paragraph in DX.

	MOV	DX,BX		;start with present ending segment
	SUB	DX,CX		;subtract request size (size if full request)
	JB	FHLowMaxDown	;if wraparound, just use lower FH bound
	CMP	DX,b$FHDEnd.FHD_hData ;test if all memory requested released
	JA	FHLowTopFull	;if so, then jump to process full request
FHLowMaxDown:			
	MOV	DX,b$FHDEnd.FHD_hData ;set to partial request (end of heap)
FHLowTopFull:
;
; Check for the source and destination apara's to be the same. If they are, we
; didn't release anything, and needn't do more.
;
	XOR	AX,AX		; return value if no movement
	CMP	BX,DX		
	JZ	FHLowTopDone	; nothing to move, just quit.

;	Compute size of entire allocated far heap for move and perform
;	the move down in memory.

	MOV	AX,b$FHDStart.FHD_hData ;get starting segment of far heap
	SUB	AX,BX		;subtract ending segment for allocated size
	CALL	B$FHMove	;move far heap data to new location

;	Compute the actual distance moved.  Since the move was down,
;	this value is negative.  Set the far heap top to update the
;	descriptor and reallocate the DOS block to reflect the new
;	starting segment.

	MOV	AX,DX		;get new ending segment of far heap
	SUB	AX,BX		;subtract old ending segment to get distance
	CALL	FHSetTop	;reallocate the block to release the space

;	Adjust all allocated descriptors in the descriptor list to
;	reflect the far heap movement.

	XOR	BX,BX		;adjust all descriptors - lowest starting...
	MOV	DX,0FFFFH	;...and highest ending offset to adjust
	CALL	B$FHAdjDescSeg	;adjust all descriptor segments by AX

;	Negate the sense of the move to return a positive value.

	NEG	AX		;return positive paragraphs returned
FHLowTopDone:			

cEnd

;***
; B$FHByteSize - get size of unallocated entry after compaction (DOS 3)
;
;Purpose:
;	Return the size in bytes of the unallocated entry,
;	if present, after a far heap compaction is performed.
;Entry:
;	SI = DGROUP offset to next to last far heap descriptor in
;	     the descriptor list.  Returned by the far heap compaction
;	     routine B$FHCompact.
;Exit:
;	DX:AX = size in bytes of the unallocated entry.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	B$FHByteSize,<NEAR,PUBLIC>
cBegin

;	Get the entry size in paragraphs in AX and then convert to
;	bytes in DX:AX.

	CALL	FHParaSize	;get entry size in paragraphs
	MOV	DX,AX		;move into both registers
	MOV	CL,4		;shift count for lower word
	SHL	AX,CL		;compute low-word byte size
	MOV	CL,12		;shift count for upper word
	SHR	DX,CL		;compute high-word byte size

cEnd

;***
; FHParaSize - get size of unallocated entry after compaction (DOS 3)
;
;Purpose:
;	Return the size in paragraphs of the unallocated entry,
;	if present, after a far heap compaction is performed.
;Entry:
;	SI = DGROUP offset to next to last far heap descriptor in
;	     the descriptor list.  Returned by the far heap compaction
;	     routine B$FHCompact.
;Exit:
;	AX = size in paragraphs of the unallocated entry.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	FHParaSize,<NEAR>
cBegin

;	Size of entry is the difference between the segment values
;	of the next-to-last entry in the descriptor list and the
;	last entry.

	MOV	AX,[SI].FHD_hData ;get value of next-to-last entry
	SUB	AX,b$FHDEnd.FHD_hData ;subtract value of last entry

cEnd

;***
;B$FHSelect, B$FHSelectSI - Call a proc for each FH descriptor (DOS 3 & 5)
;
;Purpose:
;	Added as part of revision [11].
;	This routine is used to indirectly dispatch to a routine
;	for each FH descriptor.  The called routine takes specific
;	action for the descriptor and returns a flag stating whether
;	or not to deallocate the entry.
;Entry:
;	SI    = Address of descriptor to start with (B$FHSelectSI only)
;	AX    = Address of near routine to dispatch to
;	BX    = parameter passed/returned from dispatch routine
;	CX    = parameter passed/returned to dispatched routine
;Exit:
;	None.
;Uses:
;	Per Convention.
;Exceptions:
;	None.
;******************************************************************************
cProc	B$FHSelectSI,<NEAR,PUBLIC>,<SI>
cBegin
	JMP	SHORT FHSelect	;jmp to common code
cEnd	<nogen>

cProc	B$FHSelect,<PUBLIC,NEAR>,<SI>
cBegin
	MOV	SI,OFFSET DGROUP:b$FHDStart ;point to start of descriptor chain

FHSelect:
	PUSH	DI
	XCHG	AX,DI		;DI points to address of routine to call


SelectLoop:
	MOV	SI,[SI].FHD_pNext ;get ptr to next descriptor in chain
	CMP	SI,OFFSET DGROUP:b$FHDEnd ;test if final descriptor
	JZ	SelectDone	;brif so - finished

DbAssertRel	SI,NZ,-1,FH_TEXT,<FHSelect found pNext field containing 0FFFFH>



	CALL	DI		;call routine
	OR	AX,AX		;deallocate entry?
	JZ	SelectLoop	;brif not - get next descriptor
	PUSH	BX
	MOV	BX,SI
	cCall	B$FHDealloc	;deallocate entry
	POP	BX
	JMP	SHORT SelectLoop ;go get next descriptor
SelectDone:
	POP	DI
cEnd


;***
; B$FHAdjDesc,B$FHAdjDescSI - adjust a range of far heap descriptor (DOS 3 & 5)
;
;Purpose:
;	Added as part of revision [11].
;	To adjust selected far heap descriptors by adding a given
;	value to the pNext field in each descriptor.  The
;	selection is determined by the DGROUP offset of the
;	descriptor being in the specified range.  The static
;	starting and ending descriptors are never adjusted here.
;	These routines are used when Far Heap DESCRIPTORS are moved.
;Entry:
;	AX = adjustment value to the pNext field of each affected
;	     far heap descriptor.
;	BX = lower DGROUP offset of descriptor range, inclusive.
;	DX = upper DGROUP offset of descriptor range, exclusive.
;	SI = address of descriptor to start adjustment with.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	B$FHAdjDescSI,<NEAR,PUBLIC>,<SI>
cBegin
	JMP	SHORT FHAdjDescCommon
cEnd	<nogen>

cProc	B$FHAdjDesc,<NEAR,PUBLIC>,<SI>
cBegin
	MOV	SI,OFFSET DGROUP:b$FHDStart ;Start with beginning of list

FHAdjDescCommon:
	XCHG	AX,CX		;CX = desc adjustment
	XOR	AX,AX		;no segment adjustment
	cCall	FHAdjDesc	;call common routine to adjust seg/desc
cEnd


;***
; B$FHAdjDescSeg,FHAdjDescSegSI - adjust a range of far heap descriptor segments (DOS 3)
;
;Purpose:
;	FHAdjDescSegSI added as part of revision [32].
;	Renamed and rewritten as part of revision [11].
;	To adjust selected far heap descriptors by adding a given
;	value to the segment value in each descriptor.	The
;	selection is determined by the DGROUP offset of the
;	descriptor being in the specified range.  The static
;	starting and ending descriptors are never adjusted here.
;	This routine is used when Far Heap DATA is moved.
;Entry:
;	AX = adjustment value to the segment of each affected
;	     far heap descriptor.
;	BX = lower DGROUP offset of descriptor range, inclusive.
;	DX = upper DGROUP offset of descriptor range, exclusive.
;	SI = descriptor to start adjustments with (FHAdjDescSegSI only)
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	FHAdjDescSegSI,<NEAR>,<SI>
cBegin
	JMP	SHORT AdjDescSegCommon
cEnd	<nogen>

cProc	B$FHAdjDescSeg,<NEAR,PUBLIC>,<SI>
cBegin
	MOV	SI,b$FHDStart.FHD_pNext ;[16]start with second FH desc in list

AdjDescSegCommon:		
	XOR	CX,CX		;No adjustment for pNext field
	cCall	FHAdjDesc	;common routine to adjust seg/descriptor
cEnd


;***
; FHAdjDesc - adjust a range of far heap descriptors (DOS 3 & 5)
;
;Purpose:
;	Added as part of revision [11].
;	To adjust selected far heap descriptors by adding a given
;	value to the segment value and/or to the pNext field in each
;	descriptor.  The selection is determined by the DGROUP offset
;	of the descriptor being in the specified range.  The static
;	starting and ending descriptors are never adjusted here.
;	This routine is used when Far Heap DATA and or Far Heap
;	descriptors are moved.
;Entry:
;	AX = adjustment value to the segment of each affected
;	     far heap descriptor.
;	CX = adjustment value to the pNext field of each affected
;	     far heap descriptor.
;	BX = lower DGROUP offset of descriptor range, inclusive.
;	DX = upper DGROUP offset of descriptor range, exclusive.
;	SI = ptr to FHD to start search with.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	FHAdjDesc,<NEAR,PUBLIC>,<SI,DI>
cBegin

;	Using SI, traverse the descriptor list until the ending of the
;	descriptor list is reached.

	MOV	DI,SI		;fall into loop

FHAdjDescLoop:
	MOV	SI,DI		;[SI] = current desc location
	MOV	DI,[SI].FHD_pNext ;[DI] = next descriptor in the list
	OR	DI,DI		;test if end of descriptor list
	JZ	FHAdjDescDone	;if so, then done

DbAssertRel	DI,NZ,-1,FH_TEXT,<FHAdjDesc found a pNext field containing 0FFFFH>

;	For each descriptor, adjust if in the specified range.

	CMP	DI,BX		;test against lower range, inclusive
	JB	FHAdjDescLoop	;if less, then loop for next
	CMP	DI,DX		;test against upper range, exclusive
	JAE	FHAdjDescLoop	;if more or equal, then loop for next
	ADD	[SI].FHD_hData,AX ;in range - adjust FH segment
	ADD	[SI].FHD_pNext,CX ;in range - adjust FH desc list
	JMP	SHORT FHAdjDescLoop ;loop for next descriptor

;	Done - restore and return.

FHAdjDescDone:

cEnd
	PAGE
;***
; B$FHAdjOneDesc - adjust a far heap descriptor (DOS 3 & 5)
;
;Purpose:
; Added as part of revision [44].
; This routine is called when a single far heap descriptor is about to be
; moved. We traverse the FHD chain in search of the FHD containing a pNext that
; points to the FHD about to move, and then we adjust that pNext to reflect the
; movement. This routine adjusts only one FHD, and stops as soon as a match is
; found, or the end of the FHD chain is found.
;
; NOTE: THIS ROUTINE IS SPEED CRITICAL. The code below is written for speed.
; The main loop deals with TWO successive FHDs each time through the loop to
; eliminate a bit of pointer movement.
;
;Entry:
; [CX]	= adjustment value to the pNext field of the affected far heap
;	  descriptor.
; [DX]	= pointer to FHD which is about to move.
;
;Exit:
; None.
;
;Uses:
; Per Convention
;
;Exceptions:
; None.
;******************************************************************************

cProc	B$FHAdjOneDesc,<NEAR,PUBLIC>,<SI>
cBegin

	MOV	SI,OFFSET DGROUP:b$FHDStart ;Start with beginning of list
ADJONELOOP:

DbAssertRel	SI,NZ,0,FH_TEXT,<FHAdjOneDesc hit end of FarHeap Chain>
	MOV	BX,[SI].FHD_pNext ;[BX] = next descriptor in the list
	CMP	BX,DX		;do we point to the FHD of interest?
	JZ	ADJONESI	;Then adjust the next pointer via BX

DbAssertRel	BX,NZ,0,FH_TEXT,<FHAdjOneDesc hit end of FarHeap Chain>
	MOV	SI,[BX].FHD_pNext ;[SI] = next descriptor in the list
	CMP	SI,DX		;do we point to the FHD of interest?
	JNZ	ADJONELOOP	;Loop until we do or are done

	MOV	SI,BX		;[SI] = pointer to preceding FDH for adjust
ADJONESI:
	ADD	[SI].FHD_pNext,CX ;adjust FH desc list
ADJONEDONE:

cEnd



;***
; B$SETM - SETMEM function runtime entry point (DOS 3 & 5)
;
;Purpose:
;	To attempt to adjust the top limit of the far heap by the
;	(signed) number of bytes in the input parameter.  The function
;	returns the space allocated for both the near and far heaps in bytes.
;Entry:
;	[SP+4] = low-order word of adjustment value.
;	[SP+6] = high-order word of adjustment value.
;Exit:
;	DX:AX = 32-bit size of near and far heaps in bytes.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	B$SETM,<FAR,PUBLIC>
	parmD	incr
cBegin

;	Get adjustment value in DX:AX.

	MOV	AX,off_incr	;get low-order word
	MOV	DX,seg_incr	;get high-order word


;	Test sign of adjustment value and jump if negative.

	OR	DX,DX		;test if adjustment is negative
	JS	FHSetMemNeg	;if so, then jump

;	Positive adjustment.  Get request in AX and raise far heap top.

	CALL	FHSetMemReq	;get request value in AX
	CALL	B$FHRaiseTop	;attempt to raise far heap top
	JMP	SHORT FHSetMemCommon  ;jump to common code to finish

;	Negative adjustment.  Negate value, get request in AX, and lower
;	the far heap

FHSetMemNeg:
	NEG	AX		;negate lower word of value in DX:AX
	ADC	DX,0		;propagate carry to upper word
	NEG	DX		;and negate upper word to finish
FHSetMemLower:			
	CALL	FHSetMemReq	;get request value in AX
	CALL	B$FHLowerTop	;attempt to lower far heap top

;	Common code.  Calculate size of far and near heaps and
;	return value to caller.

FHSetMemCommon:
	CALL	B$FHTestRaiseBottom ; and attempt to raise bottom also
	CALL	FHSetMemValue	;compute size in DX:AX

				; 32K near heap + 128K far heap
	call	fEditorActive	; did we start with /Editor
	jnz	SetMem_Exit	; brif so, allow anything
	cmp	dx,2		; less than 128K total free?
	jb	SetMem_Exit	; brif so -- exit
	ja	TooBig		; brif more than 172K free -- too much free
	or	ax,ax		; less than 128K + 32K free?
	jns	SetMem_Exit	; brif so -- exit

TooBig:				; Reserve <ABOUT> 128K + 32K heap space
	sub	ax,7ff0h	; Can't do 8000h or it will infinite loop!)
	sbb	dx,2		
	jmp	FHSetMemLower	; lower top of far heap by DX:AX
	
SetMem_Exit:			

cEnd

;***
; FHSetMemReq - compute SETMEM request value (DOS 3)
;
;Purpose:
;	Convert the given request value in bytes to paragraphs.
;	If more than 1M bytes, return 0FFFFH paragraphs.
;Entry:
;	DX:AX = 32-bit request value in bytes.
;Exit:
;	AX = 16-bit request value in paragraphs.
;Uses:
;	DX.
;Exceptions:
;	None.
;******************************************************************************

cProc	FHSetMemReq,<NEAR>
cBegin

	CALL	FHByteToPara	;convert DX:AX in bytes to DX:AX in paragraphs
	OR	DX,DX		;test if over 0FFFFH paragraphs
	JZ	FHSetMemReqOK	;if not, then request is okay as is
	MOV	AX,0FFFFH	;set maximum request
FHSetMemReqOK:

cEnd

;***
; FHSetMemValue - compute the SETMEM function value (DOS 3)
;
;Purpose:
;	Compute the size of the near and far heaps in bytes.
;	This is the value returned by the SETMEM function.
;Entry:
;	None.
;Exit:
;	DX:AX = size of heaps in bytes.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************

cProc	FHSetMemValue,<NEAR>,<CX>
cBegin

;	Compute the paragraph start of the near heap.

	MOV	AX,b$NH_first	;get DGROUP offset of the near heap start
	MOV	CL,4		;byte-to-paragraph factor is 4
	SHR	AX,CL		;get paragraph offser to DGROUP of NH start
	MOV	CX,DS		;get DGROUP paragraph value
	ADD	AX,CX		;add to get paragraph start of near heap

;	Difference from far heap start to near heap start is value
;	to compute.  Convert size from paragraphs to bytes.

	MOV	DX,b$FHDStart.FHD_hData ;get starting (top) paragraph of FH
	SUB	DX,AX		;paragraph size of near and far heaps
	MOV	AX,DX		;move into both registers
	MOV	CL,4		;shift count for lower word
	SHL	AX,CL		;compute low-word byte size
	MOV	CL,12		;shift count for upper word
	SHR	DX,CL		;compute high-word byte size

cEnd

;***
; FHSetTop - set new top of the far heap. (DOS 3)
;
;Purpose:
;	Set the new top of the far heap by reallocating the DOS
;	memory block containing the program and updating the starting
;	descriptor which defines the top of the far heap.
;Entry:
;	AX = number of paragraphs to adjust the far heap top.
;	     (positive grows, negative shrinks)
;Exit:
;	AX = number of paragraphs actually adjusted.  This number
;	     may be different than the entry value if the heap grows
;	     and insufficient memory is available.
;Uses:
;	ES.
;Exceptions:
;	Fatal error if DOS reallocation fails with legal pool size.
;
;******************************************************************************

cProc	FHSetTop,<NEAR>,<BX>
cBegin

;	Attempt to reallocate the DOS block with the given increment
;	of size.

	MOV	ES,__acmdseg	;get DOS memory block address
	MOV	BX,b$FHDStart.FHD_hData ;get top segment of the far heap
	SUB	BX,__acmdseg	;subtract to get present block size
	ADD	BX,AX		;add increment to get new block size
	MOV	AH,4AH		;get DOS function to reallocate
	CALL	B$FHMemDosCall	;call to perform INT and handle fatal errors
	JNC	FHSetTopDone	;if no error, then jump

;	Reallocation failed with attempted increment.  Try to reallocate
;	with the given maximum size returned in BX.

	MOV	AH,4AH		;try the reallocation again
	CALL	B$FHMemDosCall	;call to perform INT and handle fatal errors
	JC	FHSetTopError	;if reallocation failed, then fatal error

;	Reallocation with new block size in BX succeeded.  Update the
;	far heap descriptor for the top of far heap.

FHSetTopDone:
	ADD	BX,__acmdseg	;add to get new top far heap segment
	MOV	AX,BX		;move top segment...
	SUB	AX,b$FHDStart.FHD_hData ;and subtract to get change in top seg
	MOV	b$FHDStart.FHD_hData,BX ;update new top segment in descriptor

cEnd

FHSetTopError:
	JMP	B$ERR_OM_FH	;give out of memory error


;***
; B$FHMemDosCall - perform memory DOS call (DOS 3)
;
;Purpose:
;	Performs the INT 21H for the DOS allocate, deallocate, and
;	reallocate calls.  Error checking is done here to save space.
;Entry:
;	Setup for the appropriate DOS call, this call replaces the
;	INT 21H instruction.  The DOS calls used are allocate memory
;	(48H), deallocate memory (49H), and reallocate memory (4AH).
;Exit:
;	Post-INT 21H register changes.
;Uses:
;	Post-INT 21H register changes.
;Exceptions:
;	B$ERR_MEM if arena is trashed.
;	B$ERR_FHC if bad memory block address.
;******************************************************************************

cProc	B$FHMemDosCall,<NEAR,PUBLIC>
cBegin

	INT	21H		;perform the DOS call
	JNC	FHMemDosReturn	;if successful, then exit now
	CMP	AX,8		;test if out of memory
	JNE	FHMemDosError	;if not, then jump to trap error
	STC			;set the carry again
FHMemDosReturn:

cEnd

FHMemDosError:
	CMP	AX,7		;test if error was arena destroyed
	JNE	FHMemDosBlock	;if not, then invalid block was used
	JMP	B$ERR_MEM	;jump to fatal error for arena destroyed
FHMemDosBlock:
	JMP	B$ERR_FHC	;jump to fatal error for inconsistenct FH

sEnd	FH_TEXT


	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\fhchn.asm ===
TITLE	FHCHN - Far Heap CHAIN & SHELL Support
	PAGE	56,132
;***
;FHCHN.ASM - Far Heap CHAIN & SHELL for the BASIC 3 Common Runtime
;
;	Copyright (C) Microsoft Corp. 1988.
;
;*****************************************************************************

	SUBTTL	INCLUDES AND DEFINITIONS FOLLOWS

INCLUDE switch.inc
INCLUDE rmacros.inc

	USESEG	<INIT_CODE>	;Initialization
	USESEG	<BR_DATA>
	USESEG	<_DATA>
	USESEG	<_BSS>
	USESEG	<NH_TEXT>
	USESEG	<RT_TEXT>
	USESEG	<FH_TEXT>
	USESEG	<DV_TEXT>
	USESEG	<XIB>
	USESEG	<XI>
	USESEG	<XIE>
	USESEG	<BC_SAB>
	USESEG	<BC_SA>

INCLUDE seg.inc
INCLUDE idmac.inc
INCLUDE compvect.inc		
INCLUDE messages.inc
INCLUDE array.inc
INCLUDE smchain.inc
INCLUDE oscalls.inc
INCLUDE addr.inc
INCLUDE baslibma.inc
INCLUDE string.inc
INCLUDE stack2.inc

	externNP	B$ERR_FHC	;bad memory block address


	INITIALIZER	B$xFHCHNINI	;put B$xFHCHNINI in initializer list


	SUBTTL	DATA DEFINITIONS

sBegin	BR_DATA


	externW __acmdseg	;C startup __psp

sEnd	BR_DATA

sBegin	_DATA

	externW b$shli_disp	;Shell initialization dispatch table
	externW b$shlt_disp	;Shell termination dispatch table

sEnd	_DATA

sBegin	_BSS

	externW b$FHDStart	;starting FHD for list

	externB b$FHDULNearData
	externB b$FHDULFarData



	externW b$FHDEnd	  ;ending FHD for list

	staticW ShellRestore,,1 ;FH growth on shell restoration

	externW b$NH_first	;NHINIT - starting offset of near heap
	externW b$NH_last	;NHINIT - ending offset of near heap



sEnd	_BSS

sBegin	DV_TEXT 		
	externNP B$NearRet	;for disp vectors in compvect.inc
sEnd	DV_TEXT 		


sBegin	NH_TEXT
	externNP B$NHMOV	;move near heap
sEnd	NH_TEXT


sBegin	FH_TEXT

	externNP B$FHSelect
	externNP B$FHMemDosCall
	externNP B$FHCompact
	externNP B$FHLowerTop
	externNP B$FHRaiseTop
	externNP B$FHLowerBottom
	externNP B$FHRaiseBottom

sEnd	FH_TEXT

	PAGE
	SUBTTL	Far Heap Initialization

assumes CS,INIT_CODE
sBegin	INIT_CODE

;***
;B$xFHCHNINI - Far Heap initializer for chain/shell module
;PLM B$xFHCHNINI()
;
;Purpose:
;	Added with revision [1].
;	Initializer for chain/shell module of the Far Heap component.
;	This routine is called by the Crt0 startup before _main is
;	called.  It will update the indirect dispatch tables for the
;	far heap routines needed by chain/shell.  This insures that
;	the only time these routines are accessed is when this module
;	is linked into the user program.
;
;Entry:
;	None.
;
;Exit:
;	Appropriate dispatch vectors filled.
;
;Uses:
;	None.
;
;Exceptions:
;	None.
;****************************************************************************

cProc	B$xFHCHNINI,<FAR>
cBegin


;	update SHELL time initialization dispatch address to FHShlIni

	MOV	WORD PTR [b$shli_disp].FH_SIVEC,FH_TEXTOFFSET FHShlIni

;	update SHELL time termination dispatch address to B$FHShlTerm

	MOV	WORD PTR [b$shlt_disp].FH_STVEC,FH_TEXTOFFSET B$FHShlTerm

cEnd

sEnd	INIT_CODE

sBegin	FH_TEXT
ASSUMES CS, FH_TEXT

	PAGE
	SUBTTL	Far Heap CHAIN Support

;***
; B$FHShlTerm - Pre SHELL "termination" (DOS 3)
;
;Purpose:
;	In preparation for the SHELL statement, compress both the
;	far and near heaps to the lowest memory possible.  Note the
;	shrinkage amount for restoration after the SHELL executes.
;Entry:
;	None
;Exit:
;	ShellRestore - contains amount released.
;Uses:
;	None.
;Exceptions:
;	Fatal error due to far heap inconsistency.
;******************************************************************************

cProc	B$FHShlTerm,<PUBLIC,NEAR> ; PUBLIC used to drag in file /O
cBegin

	MOV	AX,0FFFFH	;attempt maximum compression of FH
	CALL	B$FHLowerTop	;compress - AX returns amount done
	MOV	ShellRestore,AX ;save amount for shell restoration

cEnd

;***
; FHShlIni - Post SHELL memory recovery (DOS 3)
;
;Purpose:
;	After the SHELL statement has executed, grow the far heap to
;	its previous size.  Grow the near heap to its maximum amount.
;Entry:
;	ShellRestore - contains amout of memory to try to recover
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	Fatal error due to far heap inconsistency.
;******************************************************************************

cProc	FHShlIni,<NEAR>
cBegin
	MOV	AX,ShellRestore ;recall amount of compression before SHELL
	CALL	B$FHRaiseTop	;raise the size of FH to preSHELL level
	CALL	B$FHRaiseBottom ;raise the near heap to its maximum level
cEnd

;***
; B$FHClean  - Far heap clean for CHAIN statement (DOS 3 & 5 RTM)
;
;Purpose:
;	Far heap setup for CHAIN statement.  Cleans FH of entries
;	whose descriptors are not in COMMON.
;Entry:
;	None.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************


;***
; FHClean - Clean FH of Non-COMMON entries (DOS 3 & 5 RTM)
;
;Purpose:
;	Clean far heap of entries whose descriptors are not
;	within COMMON.
;	If QBI, don't deallocate b$FHDULNearData and b$FHDULFarData.  These
;	two contain clean images of the user-lib preinited data (if UL loaded)
;	that are used to reinitialize the UL Data after CHAIN or RUN.
;
;Entry:
;	SI - ptr to FH descriptor to check
;Exit:
;	AX - 0 means don't deallocate entry
;Uses:
;	None.
;Exceptions:
;	None.
;******************************************************************************


;***
; B$FHPostChain - Far heap recovery for CHAIN statement (DOS 3 RTM)
;
;Purpose:
;	Finish DGROUP reconstruction after new program has been
;	chained.  The far and near heap have been recleaned if
;	COMMON truncation occurred.
;Entry:
;	BX = new starting offset of near heap.
;	CX = DGROUP saved area segment.
;	DS = ES = new program DGROUP segment.
;Exit:
;	None.
;Uses:
;	None.
;Exceptions:
;	Error if near heap or far heap inconsistency.
;******************************************************************************


;***
;B$FHAdjPreChain - Adjust FH selectors and Give to Child process (DOS 5 RTM)
;
;Purpose:
;	This routine is used for DOS 5 CHAIN.  It will give all far
;	heap segments to the child process and adjust the descriptor chain.
;Entry:
;	CX = Child process ID
;Exit:
;	AX = DGROUP pointer to first FH descriptor in descriptor chain.
;Uses:
;	None.
;Exceptions:
;	None.
;*****************************************************************************


;***
;FHGiveSeg - give FH segment to child process (DOS 5 RTM)
;
;Purpose:
;	This routine is called once for each descriptor in the far heap
;	descriptor chain.  It will give the selector contained in the
;	descriptor to the chained process and update the selector in
;	the FH descriptor.
;Entry:
;	CX = Child process ID
;	SI = DGROUP offset of FH descriptor
;Exit:
;	AX = flag specifing whether or not to deallocate this entry
;		0 - means don't deallocate
;Uses:
;	Per Convention.
;Preserves:
;	CX,
;Exceptions:
;	None.
;******************************************************************************


;***
;B$FHAdjPostChain - Adjust FH selectors after CHAIN (DOS 5 RTM)
;
;Purpose:
;	This routine is used for DOS 5 CHAIN.  It will adjust all far
;	heap descriptors in the descriptor chain, deallocing any entries
;	truncated by the new COMMON bounds.
;Entry:
;	AX = Shared memory handle
;Exit:
;	None.
;Uses:
;	Per Convention.
;Exceptions:
;	None.
;*****************************************************************************

assumes	ES,DGROUP		

;***
;FHClean5 - Clean truncated COMMON FH entries (DOS 5 RTM)
;
;Purpose:
;	This routine is used for DOS 5 CHAIN.  It deallocates any far
;	entries with descriptors that are truncated by the new COMMON
;	boundaries.  The descriptors for these entries are removed
;	from the descriptor chain.
;Entry:
;	BX - size of new COMMON
;	DS - shared memory segment
;	ES - DGROUP
;	SI - Descriptor to check for cleaning
;Exit:
;	AX - 0 means don't deallocate entry
;Uses:
;	Per Convention.
;Preserves:
;	BX,CX
;Exceptions:
;	None.
;******************************************************************************


;***
; B$FHPreChain - Prepare far heap (and DGROUP) for CHAIN (DOS 3 RTM)
;
;Purpose:
;	Prepare the DGROUP for chaining.  This routine is entered
;	with both near and far heaps cleaned (nonCOMMON entries
;	removed) and the new stack defined.  The data segment is
;	truncated to RTM data, COMMON statics, a 200H-byte stack,
;	and compressed near and far heaps.  This data is placed in
;	high memory and the DS is adjusted.
;Entry:
;	AX - new DGROUP offset of near heap.
;Exit:
;	DS - new high data segment location.
;Uses:
;	AX, BX, CX, DX, SI, DI.
;Exceptions:
;	Errors due to near or far heap inconsistency.
;******************************************************************************


sEnd	FH_TEXT

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\runtime\rt\fout.asm ===
TITLE	FOUT - Free-format numeric output
;***
; FOUT - Free-format numeric output
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Floating Point versions of the routines in IFOUT.ASM
;
;	This file is dragged in by the label B$FloatCONASC
;
;
;******************************************************************************
	INCLUDE switch.inc	
	INCLUDE rmacros.inc	; Runtime Macro Defintions

	USESEG	_DATA		
	USESEG	_BSS		
	USESEG	_TEXT		
	USESEG	RT_TEXT 	
	USESEG	XIB		; XIB and XIE must bracket XI!
	USESEG	XI		;initializer segment
	USESEG	XIE		
	USESEG	INIT_CODE	

	INCLUDE seg.inc 	
	INCLUDE	baslibma.inc	
	INCLUDE rtps.inc	; constants shared with QBI
	INCLUDE idmac.inc	



sBegin	_DATA			

	externW B$AC		
	externW B$DAC		

sEnd	_DATA			

sBegin	_BSS			

	externB b$SIGN 		; defined in CONASC.ASM
	externB b$VTYP		; defined in GWDATA.ASM

sEnd	_BSS			




assumes CS,RT_TEXT		
sBegin	RT_TEXT 		

	externNP B$ASCRND	

;***
;B$FloatFOUTBX - Free-format numeric output for non-integers
;
;Purpose:
;	Format number for printing, using BASIC's formatting rules.
;
;Entry:
;	BX = ptr to Number to be formatted
;	[b$VTYP] = VT_R4, VT_R8 or VT_CY
;
;Exit:
;	BX = Address of ASCII string, terminated by 00
;	AX = Length of string (not including terminating 00)
;
;Uses:
;	Per convention.
;
;Exceptions:
;	None.
;****
PUBLIC	B$FloatFOUTBX		
cProc	B$FloatFOUTBX,<NEAR>,<ES,SI,DI>       
cBegin				
	PUSH	DS		
	POP	ES		
	MOV	AL,[b$VTYP]	
	AND	AX,0FH		;mask I4s to count of bytes to move
	MOV	SI,BX
	MOV	DI,OFFSET DGROUP:B$AC ;point to B$AC
	CMP	AX,4		;<= 4 byte quantity?
	JBE	FourByteVar	 ;brif so
	SUB	DI,4		;use DAC instead of AC
FourByteVar:
	XCHG	AX,CX
	SHR	CX,1		;Count of words
	REP	MOVSW

	CALL	B$FloatCONASC	;Most of the work's done here

;Number has been converted to ASCII and is sitting at buffer pointed to by DI.
;	SI = address of result buffer
;	CX = number of significant figures
;	DL has the base 10 exponent of the right end of the digit string.

	MOV	BX,7		; If SP, use 7 digits, but limit 7 to right
	CMP	[b$VTYP],VT_R8	; What type?
	JB	RNDDIG		; If I2 or R4, use R4 parameters
	MOV	BX,16		; For R8 or I4, 16 digits, limit 16 to right
RNDDIG:
	MOV	AL,BL
	CALL	B$ASCRND	;Round to AL digits
	MOV	AX,DX		; [AX] = exponent
	PUSH	DX		; save it also
	CWD			; sign extend
	XOR	AX,DX		; [AX] = ABS(exponent)
	SUB	AX,DX		; adjust
	POP	DX		; [DX] = exponent
	CMP	AX,BX		;Too many digits to right of decimal point?
	JG	SCINOT		;If so, use scientific notation
	MOV	AX,DX		
	ADD	AX,CX		; AL=number of digits to left of dec.pt.
	CMP	AX,BX		; Too many?
	JG	SCINOT		;If so, use scientific notation
	XCHG	AX,CX		;CX has digits needed to left of dec. pt.
	XCHG	AX,BX		;BX has digits available from buffer
	OR	CX,CX		;Any to left?
	JLE	LESS1		;If not, start with decimal point
LEFTDP:
	MOVSB			;Move digits to final buffer
	DEC	BX		;Limit to available digits
	LOOPNZ	LEFTDP
	MOV	AL,"0"
	REP	STOSB		;Fill in with place-holding zeros if needed
	JZ	PUTEND		;If out of digits, were done(flags from DEC BX)
PUTDP:
	MOV	AL,"."
	STOSB			;Put in decimal point
	MOV	AL,"0"		;Used only if we came from LESS1
	REP	STOSB		;Add leading zeros if a small number
	MOV	CX,BX		;Number of digits left
	REP	MOVSB
PUTEND:
	MOV	BX,OFFSET DGROUP:b$SIGN ;Leave pointer to buffer
	MOV	AX,DI
	SUB	AX,BX		;Length of string
	MOV	BYTE PTR[DI],0	;Put in terminating zero
cEnd				

LESS1:
;Come here if number is less than one and therefore has no digits to
;left of the decimal point.
	NEG	CX		;Number of place-holding zeros needed
	JMP	PUTDP		;   after the decimal point

SCINOT:
	MOVSB			;Move first digit to final buffer
	DEC	CX		;Account for digit already moved
	JZ	EXP		;Skip decimal point if only one digit
	MOV	AL,"."
	STOSB
	ADD	DX,CX		; Correct exponent for decimal point position
	REP	MOVSB		;All other digits go after decimal point
EXP:
	MOV	AX,"+E" 	;Prepare "E+" if positive exponent
	OR	DX,DX		; Check exponent sign
	JNS	POSEXP
	NEG	DX		; Force exponent positive
	MOV	AH,"-"
POSEXP:
	CMP	[b$VTYP],VT_R8	; Is type double precision?
	JNZ	SCISNGL
	DEC	AX		;Convert the "E" to "D"
SCISNGL:
	STOSW
	MOV	AX,DX		; [AX] = exponent
	MOV	BL,100		
	DIV	BL		; [AL] = hundreds count
	OR	AL,AL		; See if any
	JZ	SCISMALL	; jump if not
	OR	AL,"0"		; turn into hundreds digit
	STOSB	