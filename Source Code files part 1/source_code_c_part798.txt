_SLOT2_MASK)) | (*Old & INST_SLOT2_MASK);
        break;

    default:
        return E_INVALIDARG;
    }
            
    // restore template to MLI if displaced instruction was MOVL
    if (*Mli)
    {
        New = (PULONG64)TempInstr;
        *New &= ~((INST_TEMPL_MASK >> 1) << 1); // set template to MLI
        *New |= 0x4;
    }
        
    Status = Services->WriteVirtual(Process, Aligned, TempInstr,
                                    IA64_BP_LEN, &Done);
    if (Status == S_OK && Done != IA64_BP_LEN)
    {
        Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    return Status;
}

void
Ia64MachineInfo::AdjustPCPastBreakpointInstruction(PADDR Addr, 
                                                   ULONG BreakType)
{
    DBG_ASSERT(BreakType == DEBUG_BREAKPOINT_CODE);

    if (IsIA32InstructionSet()) 
    {
        //
        // IA32 instruction set
        //
        SetPC(AddrAdd(Addr, 1));
    } 
    else 
    {
        //
        // IA64 instruction set
        //
        if ((Flat(*Addr) & 0xf) != 8) 
        {
            SetPC(AddrAdd(Addr, 4));
        } 
        else 
        {
            SetPC(AddrAdd(Addr, 8));
        }
    }
}

void
Ia64MachineInfo::InsertThreadDataBreakpoints(void)
{
    DBG_ASSERT(g_Thread->m_NumDataBreaks <= m_MaxDataBreakpoints);

    BpOut("Thread %d data %d\n",
          g_Thread->m_UserId, g_Thread->m_NumDataBreaks);

    // The kernel automatically sets PSR.db for the
    // kernel so this code only needs to manipulate PSR.db
    // for user-mode debugging.

    ULONG64 RegIPSR;
    ULONG RegDBD;
    ULONG RegDBDEnd;
    ULONG RegDBI;
    ULONG RegDBIEnd;

    // Start with all breaks turned off.
    if (IS_USER_TARGET(m_Target))
    {
        RegIPSR = GetReg64(STIPSR);
        RegIPSR &= ~((ULONG64)1 << PSR_DB);
        
        RegDBD = REGDBD0;
        RegDBDEnd = min(REGDBD7 + 1,
                        REGDBD0 + 2 * m_MaxDataBreakpoints);
        RegDBI = REGDBI0;
        RegDBIEnd = min(REGDBI7 + 1,
                        REGDBI0 + 2 * m_MaxDataBreakpoints);
    }
    else
    {
        RegDBD = KRDBD0;
        RegDBDEnd = min(KRDBD7 + 1,
                        KRDBD0 + 2 * m_MaxDataBreakpoints);
        RegDBI = KRDBI0;
        RegDBIEnd = min(KRDBI7 + 1,
                        KRDBI0 + 2 * m_MaxDataBreakpoints);
    }
    
    if (g_Thread->m_NumDataBreaks > 0)
    {
        ULONG i;
                
        for (i = 0; i < g_Thread->m_NumDataBreaks; i++)
        {
            Breakpoint* Bp = g_Thread->m_DataBreakBps[i];
            ULONG ProcType = Bp->GetProcType();

            DBG_ASSERT((ProcType == IMAGE_FILE_MACHINE_IA64) || 
                       (ProcType == IMAGE_FILE_MACHINE_I386));

            ULONG64 Addr, Control;

            if (ProcType == IMAGE_FILE_MACHINE_I386) 
            {
                Addr = (ULONG)Flat(*Bp->GetAddr());
                Control = ((X86OnIa64DataBreakpoint*)Bp)->m_Control;
            } 
            else 
            {
                Addr = Flat(*Bp->GetAddr());
                Control = ((Ia64DataBreakpoint*)Bp)->m_Control;
            }
                        
            if (Bp->m_DataAccessType == DEBUG_BREAK_EXECUTE) 
            {
                BpOut("  ibp %d at %p\n", i, Addr);
                SetReg64(RegDBI++, Addr);
                SetReg64(RegDBI++, Control);
            }
            else
            {
                BpOut("  dbp %d at %p\n", i, Addr);
                SetReg64(RegDBD++, Addr);
                SetReg64(RegDBD++, Control);
            }
        }
        
        RegIPSR |= ((ULONG64)1 << PSR_DB); 
    }

    // Make sure unused debug registers are clear.
    while (RegDBD < RegDBDEnd)
    {
        SetReg64(RegDBD++, 0);
    }

    while (RegDBI < RegDBIEnd)
    {
        SetReg64(RegDBI++, 0);
    }

    if (IS_USER_TARGET(m_Target))
    {
        SetReg64(STIPSR, RegIPSR);
    }
}

void
Ia64MachineInfo::RemoveThreadDataBreakpoints(void)
{
    if (IS_USER_TARGET(m_Target))
    {
        ULONG64 RegIPSR;

        RegIPSR = GetReg64(STIPSR);
        RegIPSR &= ~((ULONG64)1 << PSR_DB);
        SetReg64(STIPSR, RegIPSR);
    }
    else
    {
        for (UINT i = 1; i < 2 * m_MaxDataBreakpoints; i += 2) 
        {
            SetReg64(KRDBD0 + i, 0);
            SetReg64(KRDBI0 + i, 0);
        }
    }
}

ULONG
Ia64MachineInfo::IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                             ULONG FirstChance,
                                             PADDR BpAddr,
                                             PADDR RelAddr)
{
    if (Record->ExceptionCode == STATUS_BREAKPOINT)
    {
        // Data breakpoints come in as SINGLE_STEP so
        // this must be a code breakpoint.
        return EXBS_BREAKPOINT_CODE;
    }
    else if (Record->ExceptionCode == STATUS_SINGLE_STEP)
    {
        DBG_ASSERT(Record->NumberParameters >= 5);
        
        // Data breakpoints put the faulting address in
        // the exception information, whereas a true single
        // step exception sets the address to zero.
        if (Record->ExceptionInformation[1])
        {
            // This should be read, write or execute interrupt.
            DBG_ASSERT(Record->ExceptionInformation[4] &
                       (((ULONG64)1 << ISR_X) | 
                        ((ULONG64)1 << ISR_W) | 
                        ((ULONG64)1 << ISR_R)));
            
            ADDRFLAT(BpAddr, Record->ExceptionInformation[1]);
            return EXBS_BREAKPOINT_DATA;
        }
        else if (Record->ExceptionInformation[4] & 0x4) 
        {
            // Must be taken branch exception
            if (RelAddr) 
            {
                // TrapFrame->StIIPA contains actual branch address
                ADDRFLAT(RelAddr, Record->ExceptionInformation[3]); 
            }
            return EXBS_STEP_BRANCH;
        }
        else
        {
            // Must be a real single-step.
            return EXBS_STEP_INSTRUCTION;
        }
    }
    
    return EXBS_NONE;
}

BOOL
Ia64MachineInfo::IsCallDisasm (PCSTR Disasm)
{
    return (strstr(Disasm, " br.call") || strstr(Disasm, ")br.call")) &&
        !strstr(Disasm, "=0)");
}

BOOL
Ia64MachineInfo::IsReturnDisasm (PCSTR Disasm)
{
    return (strstr(Disasm, " br.ret") || strstr(Disasm, ")br.ret")) &&
        !strstr(Disasm, "=0)");
}

BOOL
Ia64MachineInfo::IsSystemCallDisasm(PCSTR Disasm)
{
    return (strstr(Disasm, " break ") || strstr(Disasm, ")break ")) &&
        strstr(Disasm, " 18000") && !strstr(Disasm, "=0)");
}
    
BOOL
Ia64MachineInfo::IsDelayInstruction (PADDR Addr)
{
    return FALSE;        // EM does not implement delay slot
}

void
Ia64MachineInfo::GetEffectiveAddr (PADDR Addr, PULONG Size)
{
    ErrOut("! IA64 does not set EA during disasm !\n");
    ADDRFLAT(Addr, 0);
    *Size = 1;
}

void
Ia64MachineInfo::GetNextOffset(ProcessInfo* Process, BOOL StepOver,
                               PADDR NextAddr, PULONG NextMachine)
{
    ULONG64 returnvalue;
    ULONG64 firaddr, syladdr;
    ADDR    fir;
    ULONG   slot;
    EM_IL   location;

    // Default NextMachine to the same machine.
    *NextMachine = m_ExecTypes[0];
    
    // Check support for hardware stepping.  Older
    // kernels did not handle it properly.
    BOOL UseTraceFlag =
        !IS_KERNEL_TARGET(m_Target) ||
        (m_Target->m_KdVersion.Flags & DBGKD_VERS_FLAG_HSS);

    ULONG instr_length;
    EM_Decoder_Info info;

    IEL_ZERO(location);

    firaddr = GetReg64(STIIP);        // get bundle address from IIP
    ADDRFLAT( &fir, firaddr );
    if (m_Target->ReadVirtual(Process, Flat(fir),
                              &g_Ia64Disinstr, sizeof(U128),
                              &instr_length) != S_OK)
    {
        instr_length = 0;
    }
    
    slot = (ULONG)((GetReg64(STIPSR) >> PSR_RI) & 0x3);        //  get slot number from ISR.ei
    syladdr = firaddr | slot ;
    IEL_ASSIGNU(location, *(U64*)(&syladdr));

    // assume next slot is the target address
    // convert bundle address - firaddr to EM address
    // the slot# of Gambit internal address is at bit(0,1)
    // EM address slot# is at bit(2,3)
    switch (slot) 
    {
    case 0:
        returnvalue = firaddr + 4;
        break;

    case 1:
        returnvalue = firaddr + 8;
        break;

    case 2:
        returnvalue = firaddr + 16;
        break;

    default:
        WarnOut("GetNextOffset: illegal EM address: %s",
                FormatAddr64(firaddr));
    }

    if (!InitDecoder()) 
    {
        ErrOut("EM decoder library(DECEM.DLL) not active\n");

        // We can't analyze the current instruction to
        // determine how and where to step so just rely
        // on hardware tracing if possible.
        if (UseTraceFlag)
        {
            returnvalue = OFFSET_TRACE;
        }
    } 
    else 
    {
        EM_Decoder_Err err = (*pfnEM_Decoder_decode)(DecoderId,
                                                     g_Ia64Disinstr,
                                                     instr_length,
                                                     location,
                                                     &info);

        if (err == EM_DECODER_NO_ERROR) 
        {
#if 0
            dprintf("GNO inst at %I64x:%d is %d\n",
                    firaddr, slot, info.inst);
#endif
            if (info.EM_info.em_bundle_info.b_template == EM_template_mlx &&
                slot == 1)
            {
                // Increment return offset since L+X instructions take
                // two instruction slots.
                switch (returnvalue & 0xf)
                {
                case 8:
                    returnvalue = returnvalue + 8;
                    break;

                default:
                    WarnOut("GetNextOffset: illegal L+X address: %s",
                            FormatAddr64(firaddr));
                    break;
                }
            }
            
            switch (info.inst)
            {
            // break imm21
            //
            case EM_BREAK_I_IMM21:
            case EM_BREAK_M_IMM21:
            case EM_BREAK_B_IMM21:
            case EM_BREAK_F_IMM21:

                // Stepping over a syscall instruction must set the breakpoint
                // at the caller's return address, not the inst after the
                // syscall.  Stepping into a syscall is not allowed
                // from user-mode.
                if (!StepOver && IS_KERNEL_TARGET(m_Target) && UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if (info.src1.type == EM_DECODER_IMMEDIATE) 
                {
                    if (info.src1.imm_info.imm_type == 
                        EM_DECODER_IMM_UNSIGNED)
                    {
                        if (((IEL_GETDW0(info.src1.imm_info.val64) & 0x1c0000) == 
                              IA64_BREAK_SYSCALL_BASE) ||
                            ((IEL_GETDW0(info.src1.imm_info.val64) & 0x1c0000) == 
                              IA64_BREAK_FASTSYS_BASE))
                        {
                            returnvalue = GetReg64(BRRP);
                        }
                    }
                }
                break;

            //
            // IP-Relative call B3           - br.call b1=target25
            //
            case EM_BR_CALL_SPNT_FEW_B1_TARGET25:
            case EM_BR_CALL_SPNT_MANY_B1_TARGET25:
            case EM_BR_CALL_SPTK_FEW_B1_TARGET25:
            case EM_BR_CALL_SPTK_MANY_B1_TARGET25:
            case EM_BR_CALL_DPNT_FEW_B1_TARGET25:
            case EM_BR_CALL_DPNT_MANY_B1_TARGET25:
            case EM_BR_CALL_DPTK_FEW_B1_TARGET25:
            case EM_BR_CALL_DPTK_MANY_B1_TARGET25:
            case EM_BR_CALL_SPNT_FEW_CLR_B1_TARGET25:
            case EM_BR_CALL_SPNT_MANY_CLR_B1_TARGET25:
            case EM_BR_CALL_SPTK_FEW_CLR_B1_TARGET25:
            case EM_BR_CALL_SPTK_MANY_CLR_B1_TARGET25:
            case EM_BR_CALL_DPNT_FEW_CLR_B1_TARGET25:
            case EM_BR_CALL_DPNT_MANY_CLR_B1_TARGET25:
            case EM_BR_CALL_DPTK_FEW_CLR_B1_TARGET25:
            case EM_BR_CALL_DPTK_MANY_CLR_B1_TARGET25:

                // 64-bit target L+X forms.
            case EM_BRL_CALL_SPTK_FEW_B1_TARGET64:
            case EM_BRL_CALL_SPTK_MANY_B1_TARGET64:
            case EM_BRL_CALL_SPNT_FEW_B1_TARGET64:
            case EM_BRL_CALL_SPNT_MANY_B1_TARGET64:
            case EM_BRL_CALL_DPTK_FEW_B1_TARGET64:
            case EM_BRL_CALL_DPTK_MANY_B1_TARGET64:
            case EM_BRL_CALL_DPNT_FEW_B1_TARGET64:
            case EM_BRL_CALL_DPNT_MANY_B1_TARGET64:
            case EM_BRL_CALL_SPTK_FEW_CLR_B1_TARGET64:
            case EM_BRL_CALL_SPTK_MANY_CLR_B1_TARGET64:
            case EM_BRL_CALL_SPNT_FEW_CLR_B1_TARGET64:
            case EM_BRL_CALL_SPNT_MANY_CLR_B1_TARGET64:
            case EM_BRL_CALL_DPTK_FEW_CLR_B1_TARGET64:
            case EM_BRL_CALL_DPTK_MANY_CLR_B1_TARGET64:
            case EM_BRL_CALL_DPNT_FEW_CLR_B1_TARGET64:
            case EM_BRL_CALL_DPNT_MANY_CLR_B1_TARGET64:

                if (StepOver) 
                {
                    //
                    // Step over the subroutine call;
                    //
                    break;
                }

                // fall through
                //
            //
            // IP-Relative branch B1         - br.cond target25
            //
            case EM_BR_COND_SPNT_FEW_TARGET25:
            case EM_BR_COND_SPNT_MANY_TARGET25:
            case EM_BR_COND_SPTK_FEW_TARGET25:
            case EM_BR_COND_SPTK_MANY_TARGET25:
            case EM_BR_COND_DPNT_FEW_TARGET25:
            case EM_BR_COND_DPNT_MANY_TARGET25:
            case EM_BR_COND_DPTK_FEW_TARGET25:
            case EM_BR_COND_DPTK_MANY_TARGET25:
            case EM_BR_COND_SPNT_FEW_CLR_TARGET25:
            case EM_BR_COND_SPNT_MANY_CLR_TARGET25:
            case EM_BR_COND_SPTK_FEW_CLR_TARGET25:
            case EM_BR_COND_SPTK_MANY_CLR_TARGET25:
            case EM_BR_COND_DPNT_FEW_CLR_TARGET25:
            case EM_BR_COND_DPNT_MANY_CLR_TARGET25:
            case EM_BR_COND_DPTK_FEW_CLR_TARGET25:
            case EM_BR_COND_DPTK_MANY_CLR_TARGET25:

                // 64-bit target L+X forms.
            case EM_BRL_COND_SPTK_FEW_TARGET64:
            case EM_BRL_COND_SPTK_MANY_TARGET64:
            case EM_BRL_COND_SPNT_FEW_TARGET64:
            case EM_BRL_COND_SPNT_MANY_TARGET64:
            case EM_BRL_COND_DPTK_FEW_TARGET64:
            case EM_BRL_COND_DPTK_MANY_TARGET64:
            case EM_BRL_COND_DPNT_FEW_TARGET64:
            case EM_BRL_COND_DPNT_MANY_TARGET64:
            case EM_BRL_COND_SPTK_FEW_CLR_TARGET64:
            case EM_BRL_COND_SPTK_MANY_CLR_TARGET64:
            case EM_BRL_COND_SPNT_FEW_CLR_TARGET64:
            case EM_BRL_COND_SPNT_MANY_CLR_TARGET64:
            case EM_BRL_COND_DPTK_FEW_CLR_TARGET64:
            case EM_BRL_COND_DPTK_MANY_CLR_TARGET64:
            case EM_BRL_COND_DPNT_FEW_CLR_TARGET64:
            case EM_BRL_COND_DPNT_MANY_CLR_TARGET64:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }
        
                if ((info.pred.valid == TRUE) && 
                    (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1) // if PR[qp] = 1
                    {
                        if (info.src1.type == EM_DECODER_IP_RELATIVE) {
                            // imm_info.val64 is sign-extended (imm21 << 4)
                            returnvalue = (IEL_GETQW0(info.src1.imm_info.val64)) + 
                                          firaddr;
                        }
                    }
                }
                break;

            //                               - br.wexit target25
            case EM_BR_WEXIT_SPNT_FEW_TARGET25:
            case EM_BR_WEXIT_SPNT_MANY_TARGET25:
            case EM_BR_WEXIT_SPTK_FEW_TARGET25:
            case EM_BR_WEXIT_SPTK_MANY_TARGET25:
            case EM_BR_WEXIT_DPNT_FEW_TARGET25:
            case EM_BR_WEXIT_DPNT_MANY_TARGET25:
            case EM_BR_WEXIT_DPTK_FEW_TARGET25:
            case EM_BR_WEXIT_DPTK_MANY_TARGET25:
            case EM_BR_WEXIT_SPNT_FEW_CLR_TARGET25:
            case EM_BR_WEXIT_SPNT_MANY_CLR_TARGET25:
            case EM_BR_WEXIT_SPTK_FEW_CLR_TARGET25:
            case EM_BR_WEXIT_SPTK_MANY_CLR_TARGET25:
            case EM_BR_WEXIT_DPNT_FEW_CLR_TARGET25:
            case EM_BR_WEXIT_DPNT_MANY_CLR_TARGET25:
            case EM_BR_WEXIT_DPTK_FEW_CLR_TARGET25:
            case EM_BR_WEXIT_DPTK_MANY_CLR_TARGET25:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if ((info.pred.valid == TRUE) && 
                    (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1)  // if PR[qp] = 1, epilog
                    {
                        if (GetReg64(APEC) <= 1) // WEXIT; branch if EC = 0 or 1
                        {
                            if (info.src1.type == EM_DECODER_IP_RELATIVE) {
                                returnvalue = 
                                    (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                            }
                        }
                    }
                }                                   // if PR[qp] = 0, kernel; fall-thru
                break;

            //                               - br.wtop target25
            case EM_BR_WTOP_SPNT_FEW_TARGET25:
            case EM_BR_WTOP_SPNT_MANY_TARGET25:
            case EM_BR_WTOP_SPTK_FEW_TARGET25:
            case EM_BR_WTOP_SPTK_MANY_TARGET25:
            case EM_BR_WTOP_DPNT_FEW_TARGET25:
            case EM_BR_WTOP_DPNT_MANY_TARGET25:
            case EM_BR_WTOP_DPTK_FEW_TARGET25:
            case EM_BR_WTOP_DPTK_MANY_TARGET25:
            case EM_BR_WTOP_SPNT_FEW_CLR_TARGET25:
            case EM_BR_WTOP_SPNT_MANY_CLR_TARGET25:
            case EM_BR_WTOP_SPTK_FEW_CLR_TARGET25:
            case EM_BR_WTOP_SPTK_MANY_CLR_TARGET25:
            case EM_BR_WTOP_DPNT_FEW_CLR_TARGET25:
            case EM_BR_WTOP_DPNT_MANY_CLR_TARGET25:
            case EM_BR_WTOP_DPTK_FEW_CLR_TARGET25:
            case EM_BR_WTOP_DPTK_MANY_CLR_TARGET25:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if ((info.pred.valid == TRUE) && 
                    (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1) // if PR[qp] = 1, epilog
                    {
                        if (GetReg64(APEC) > 1)  // WTOP; branch if EC > 1
                        {
                            if (info.src1.type == EM_DECODER_IP_RELATIVE)
                            {
                                returnvalue = 
                                    (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                            }
                        }
                    }
                }
                else // if PR[qp] = 0, kernel; branch
                {
                    if (info.src1.type == EM_DECODER_IP_RELATIVE) {
                        returnvalue = 
                            (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                    }
                }
                break;

            //
            // IP-Relative counted branch B2 - br.cloop target25
            //
            case EM_BR_CLOOP_SPNT_FEW_TARGET25:
            case EM_BR_CLOOP_SPNT_MANY_TARGET25:
            case EM_BR_CLOOP_SPTK_FEW_TARGET25:
            case EM_BR_CLOOP_SPTK_MANY_TARGET25:
            case EM_BR_CLOOP_DPNT_FEW_TARGET25:
            case EM_BR_CLOOP_DPNT_MANY_TARGET25:
            case EM_BR_CLOOP_DPTK_FEW_TARGET25:
            case EM_BR_CLOOP_DPTK_MANY_TARGET25:
            case EM_BR_CLOOP_SPNT_FEW_CLR_TARGET25:
            case EM_BR_CLOOP_SPNT_MANY_CLR_TARGET25:
            case EM_BR_CLOOP_SPTK_FEW_CLR_TARGET25:
            case EM_BR_CLOOP_SPTK_MANY_CLR_TARGET25:
            case EM_BR_CLOOP_DPNT_FEW_CLR_TARGET25:
            case EM_BR_CLOOP_DPNT_MANY_CLR_TARGET25:
            case EM_BR_CLOOP_DPTK_FEW_CLR_TARGET25:
            case EM_BR_CLOOP_DPTK_MANY_CLR_TARGET25:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if (GetReg64(APLC)) // branch if LC != 0
                {
                    if (info.src1.type == EM_DECODER_IP_RELATIVE)
                    {
                        returnvalue = 
                            (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                    }
                }
                break;

            //                               - br.cexit target25
            case EM_BR_CEXIT_SPNT_FEW_TARGET25:
            case EM_BR_CEXIT_SPNT_MANY_TARGET25:
            case EM_BR_CEXIT_SPTK_FEW_TARGET25:
            case EM_BR_CEXIT_SPTK_MANY_TARGET25:
            case EM_BR_CEXIT_DPNT_FEW_TARGET25:
            case EM_BR_CEXIT_DPNT_MANY_TARGET25:
            case EM_BR_CEXIT_DPTK_FEW_TARGET25:
            case EM_BR_CEXIT_DPTK_MANY_TARGET25:
            case EM_BR_CEXIT_SPNT_FEW_CLR_TARGET25:
            case EM_BR_CEXIT_SPNT_MANY_CLR_TARGET25:
            case EM_BR_CEXIT_SPTK_FEW_CLR_TARGET25:
            case EM_BR_CEXIT_SPTK_MANY_CLR_TARGET25:
            case EM_BR_CEXIT_DPNT_FEW_CLR_TARGET25:
            case EM_BR_CEXIT_DPNT_MANY_CLR_TARGET25:
            case EM_BR_CEXIT_DPTK_FEW_CLR_TARGET25:
            case EM_BR_CEXIT_DPTK_MANY_CLR_TARGET25:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if (!GetReg64(APLC)) // if LC = 0, epilog
                {
                    if (GetReg64(APEC) <= 1) // CEXIT; branch if EC = 0 or 1
                    {
                        if (info.src1.type == EM_DECODER_IP_RELATIVE)
                        {
                            returnvalue = 
                                (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                        }
                    }
                }                                                    // if LC > 0, kernel; fall-thru
                break;

            //                               - br.ctop target25
            case EM_BR_CTOP_SPNT_FEW_TARGET25:
            case EM_BR_CTOP_SPNT_MANY_TARGET25:
            case EM_BR_CTOP_SPTK_FEW_TARGET25:
            case EM_BR_CTOP_SPTK_MANY_TARGET25:
            case EM_BR_CTOP_DPNT_FEW_TARGET25:
            case EM_BR_CTOP_DPNT_MANY_TARGET25:
            case EM_BR_CTOP_DPTK_FEW_TARGET25:
            case EM_BR_CTOP_DPTK_MANY_TARGET25:
            case EM_BR_CTOP_SPNT_FEW_CLR_TARGET25:
            case EM_BR_CTOP_SPNT_MANY_CLR_TARGET25:
            case EM_BR_CTOP_SPTK_FEW_CLR_TARGET25:
            case EM_BR_CTOP_SPTK_MANY_CLR_TARGET25:
            case EM_BR_CTOP_DPNT_FEW_CLR_TARGET25:
            case EM_BR_CTOP_DPNT_MANY_CLR_TARGET25:
            case EM_BR_CTOP_DPTK_FEW_CLR_TARGET25:
            case EM_BR_CTOP_DPTK_MANY_CLR_TARGET25:

                if (!GetReg64(APLC)) // if LC = 0, epilog
                {
                    if (GetReg64(APEC) > 1) // CTOP; branch if EC > 1
                    {
                        if (info.src1.type == EM_DECODER_IP_RELATIVE) 
                        {
                            returnvalue = 
                                (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                        }
                    }
                }
                else // if LC > 0, kernel; branch
                {
                    if (info.src1.type == EM_DECODER_IP_RELATIVE) 
                    {
                        returnvalue = 
                            (IEL_GETQW0(info.src1.imm_info.val64)) + firaddr;
                    }
                }
                break;

            //
            // Indirect call B5            - br.call b1=b2
            //
            case EM_BR_CALL_SPNT_FEW_B1_B2:
            case EM_BR_CALL_SPNT_MANY_B1_B2:
            case EM_BR_CALL_SPTK_FEW_B1_B2:
            case EM_BR_CALL_SPTK_MANY_B1_B2:
            case EM_BR_CALL_DPNT_FEW_B1_B2:
            case EM_BR_CALL_DPNT_MANY_B1_B2:
            case EM_BR_CALL_DPTK_FEW_B1_B2:
            case EM_BR_CALL_DPTK_MANY_B1_B2:
            case EM_BR_CALL_SPNT_FEW_CLR_B1_B2:
            case EM_BR_CALL_SPNT_MANY_CLR_B1_B2:
            case EM_BR_CALL_SPTK_FEW_CLR_B1_B2:
            case EM_BR_CALL_SPTK_MANY_CLR_B1_B2:
            case EM_BR_CALL_DPNT_FEW_CLR_B1_B2:
            case EM_BR_CALL_DPNT_MANY_CLR_B1_B2:
            case EM_BR_CALL_DPTK_FEW_CLR_B1_B2:
            case EM_BR_CALL_DPTK_MANY_CLR_B1_B2:

                if (StepOver) 
                {
                    //
                    // Step over the subroutine call;
                    //
                    break;
                }

                // fall through
                //
            //
            // Indirect branch B4           - br.ia b2
            //
            case EM_BR_IA_SPNT_FEW_B2:
            case EM_BR_IA_SPNT_MANY_B2:
            case EM_BR_IA_SPTK_FEW_B2:
            case EM_BR_IA_SPTK_MANY_B2:
            case EM_BR_IA_DPNT_FEW_B2:
            case EM_BR_IA_DPNT_MANY_B2:
            case EM_BR_IA_DPTK_FEW_B2:
            case EM_BR_IA_DPTK_MANY_B2:
            case EM_BR_IA_SPNT_FEW_CLR_B2:
            case EM_BR_IA_SPNT_MANY_CLR_B2:
            case EM_BR_IA_SPTK_FEW_CLR_B2:
            case EM_BR_IA_SPTK_MANY_CLR_B2:
            case EM_BR_IA_DPNT_FEW_CLR_B2:
            case EM_BR_IA_DPNT_MANY_CLR_B2:
            case EM_BR_IA_DPTK_FEW_CLR_B2:
            case EM_BR_IA_DPTK_MANY_CLR_B2:

                if (UseTraceFlag)
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }
                
                // Unconditional branch to IA32 so the machine
                // changes.
                *NextMachine = IMAGE_FILE_MACHINE_I386;
                
                // fall through
                //
            //                              - br.cond b2
            case EM_BR_COND_SPNT_FEW_B2:
            case EM_BR_COND_SPNT_MANY_B2:
            case EM_BR_COND_SPTK_FEW_B2:
            case EM_BR_COND_SPTK_MANY_B2:
            case EM_BR_COND_DPNT_FEW_B2:
            case EM_BR_COND_DPNT_MANY_B2:
            case EM_BR_COND_DPTK_FEW_B2:
            case EM_BR_COND_DPTK_MANY_B2:
            case EM_BR_COND_SPNT_FEW_CLR_B2:
            case EM_BR_COND_SPNT_MANY_CLR_B2:
            case EM_BR_COND_SPTK_FEW_CLR_B2:
            case EM_BR_COND_SPTK_MANY_CLR_B2:
            case EM_BR_COND_DPNT_FEW_CLR_B2:
            case EM_BR_COND_DPNT_MANY_CLR_B2:
            case EM_BR_COND_DPTK_FEW_CLR_B2:
            case EM_BR_COND_DPTK_MANY_CLR_B2:

                // If we're in user-mode we can't necessarily
                // use hardware stepping here because this
                // may be a branch into the EPC region for
                // a system call that we do not want to trace.
                if (!StepOver && IS_KERNEL_TARGET(m_Target) && UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if ((info.pred.valid == TRUE) && 
                    (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1) // if PR[qp] = 1
                    {
                        if (info.src1.type == EM_DECODER_REGISTER) 
                        {
                            if (info.src1.reg_info.type == EM_DECODER_BR_REG)
                            {
                                returnvalue = GetReg64(info.src1.reg_info.value + BRRP);

                                // Check for syscall (IA64_MM_EPC_VA) then 
                                // return address is in B0
                                if (!IS_KERNEL_TARGET(m_Target) &&
                                    (returnvalue == IA64_MM_EPC_VA + 0x20)) 
                                {
                                    returnvalue = GetReg64(BRRP);
                                }
                            }
                        }
                    }
                }
                break;

            //                              - br.ret b2
            case EM_BR_RET_SPNT_FEW_B2:
            case EM_BR_RET_SPNT_MANY_B2:
            case EM_BR_RET_SPTK_FEW_B2:
            case EM_BR_RET_SPTK_MANY_B2:
            case EM_BR_RET_DPNT_FEW_B2:
            case EM_BR_RET_DPNT_MANY_B2:
            case EM_BR_RET_DPTK_FEW_B2:
            case EM_BR_RET_DPTK_MANY_B2:
            case EM_BR_RET_SPNT_FEW_CLR_B2:
            case EM_BR_RET_SPNT_MANY_CLR_B2:
            case EM_BR_RET_SPTK_FEW_CLR_B2:
            case EM_BR_RET_SPTK_MANY_CLR_B2:
            case EM_BR_RET_DPNT_FEW_CLR_B2:
            case EM_BR_RET_DPNT_MANY_CLR_B2:
            case EM_BR_RET_DPTK_FEW_CLR_B2:
            case EM_BR_RET_DPTK_MANY_CLR_B2:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if ((info.pred.valid == TRUE) && 
                    (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1) // if PR[qp] = 1
                    {
                        if (info.src1.type == EM_DECODER_REGISTER) 
                        {
                            if (info.src1.reg_info.type == EM_DECODER_BR_REG)
                            {
                                returnvalue = GetReg64(info.src1.reg_info.value + BRRP);
                            }
                        }
                    }
                }
                break;

            // chk always branches under debugger

            case EM_CHK_S_I_R2_TARGET25:
            case EM_CHK_S_M_R2_TARGET25:
            case EM_CHK_S_F2_TARGET25:
            case EM_CHK_A_CLR_R1_TARGET25:
            case EM_CHK_A_CLR_F1_TARGET25:
            case EM_CHK_A_NC_R1_TARGET25:
            case EM_CHK_A_NC_F1_TARGET25:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                if ((info.pred.valid == TRUE) && (info.pred.type == EM_DECODER_PRED_REG)) 
                {
                    if ((GetReg64(PREDS) >> info.pred.value) & 0x1) // if PR[qp] = 1
                    {
                        returnvalue = 
                            IEL_GETQW0(info.src2.imm_info.val64) + firaddr;
                    }
                }
                break;

            default:

                if (UseTraceFlag) 
                {
                    returnvalue = OFFSET_TRACE;
                    break;
                }

                break;
            }
        }
        else if (UseTraceFlag)
        {
            // We can't analyze the current instruction to
            // determine how and where to step so just rely
            // on hardware tracing if possible.
            returnvalue = OFFSET_TRACE;
        }
        else
        {
            ErrOut("em_decoder_decode: %s\n",
                   (*pfnEM_Decoder_err_msg)((EM_Decoder_Err) err));
        }
    }

    ADDRFLAT( NextAddr, returnvalue );
}

BOOL
Ia64MachineInfo::GetPrefixedSymbolOffset(ProcessInfo* Process,
                                         ULONG64 SymOffset,
                                         ULONG Flags,
                                         PULONG64 PrefixedSymOffset)
{
    ULONG64 EntryPoint;
    ULONG64 HalfBundle;
    
    if (m_Target->ReadPointer(Process, this, SymOffset, &EntryPoint) != S_OK)
    {
        if (Flags & GETPREF_VERBOSE)
        {
            ErrOut("Ia64MachineInfo::GetPrefixedSymbolOffset: "
                   "Unable to read IA64 PLABEL entry point @ 0x%I64x\n",
                   SymOffset);
        }
        return FALSE;
    }
    
    *PrefixedSymOffset = EntryPoint;

    if (m_Target->
        ReadAllVirtual(Process, EntryPoint,
                       &HalfBundle, sizeof(HalfBundle)) != S_OK)
    {
        if (Flags & GETPREF_VERBOSE)
        {
            WarnOut("Ia64MachineInfo::GetPrefixedSymbolOffset: "
                    "Reading half bundle @ 0x%I64x failed\n", EntryPoint);
        }
    }
    else
    {
        PEM_TEMPLATE_INFO TemplInfo;
        
        TemplInfo = EmTemplateInfo(GET_TEMPLATE(HalfBundle));
        if (TemplInfo && (TemplInfo->slot[0].unit != No_Unit))
        {
#if 0
            dprintf("Ia64MachineInfo::GetPrefixedSymbolOffset: "
                    "Seems to be a valid bundle: %s.\n", 
                    TemplInfo->name);
#endif
        }
        else if (Flags & GETPREF_VERBOSE)
        {
            WarnOut("Ia64MachineInfo::GetPrefixedSymbolOffset: "
                    "Read IA64 PLABEL entry point @ 0xI64x is NOT "
                    "a valid bundle...\n", 
                    EntryPoint);
        }
    }

    return TRUE;
}

void
Ia64MachineInfo::IncrementBySmallestInstruction (PADDR Addr)
{
    if ((Flat(*Addr) & 0xf) == 8)
    {
        AddrAdd(Addr, 8);
    }
    else
    {
        AddrAdd(Addr, 4);
    }
}

void
Ia64MachineInfo::DecrementBySmallestInstruction (PADDR Addr)
{
    if ((Flat(*Addr) & 0xf) == 0)
    {
        AddrSub(Addr, 8);
    }
    else
    {
        AddrSub(Addr, 4);
    }
}

void 
Ia64MachineInfo::PrintStackFrameAddressesTitle(ULONG Flags)
{
    if (Flags & DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY)
    {
        MachineInfo::PrintStackFrameAddressesTitle(Flags);
    }
    else 
    {
        PrintMultiPtrTitle("Child-SP", 1);
        PrintMultiPtrTitle("Child-BSP", 1);
        PrintMultiPtrTitle("RetAddr", 1);
    }
}

void 
Ia64MachineInfo::PrintStackFrameAddresses(ULONG Flags, 
                                          PDEBUG_STACK_FRAME StackFrame)
{
    if (Flags & DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY)
    {
        MachineInfo::PrintStackFrameAddresses(Flags, StackFrame);
    }
    else
    {
        dprintf("%s %s %s ", 
                FormatAddr64(StackFrame->StackOffset),
                FormatAddr64(StackFrame->FrameOffset),
                FormatAddr64(StackFrame->ReturnOffset));
    }
}

void 
Ia64MachineInfo::PrintStackArgumentsTitle(ULONG Flags)
{
    if (Flags & DEBUG_STACK_NONVOLATILE_REGISTERS)
    {
        return;
    }
    MachineInfo::PrintStackArgumentsTitle(Flags);
}

void 
Ia64MachineInfo::PrintStackArguments(ULONG Flags, 
                                     PDEBUG_STACK_FRAME StackFrame)
{
    if (Flags & DEBUG_STACK_NONVOLATILE_REGISTERS)
    {
        return;
    }
    MachineInfo::PrintStackArguments(Flags, StackFrame);
}

void 
Ia64MachineInfo::PrintStackNonvolatileRegisters(ULONG Flags, 
                                                PDEBUG_STACK_FRAME StackFrame,
                                                PCROSS_PLATFORM_CONTEXT Context,
                                                ULONG FrameNum)
{
    ULONGLONG   Registers[96+2];
    ULONGLONG   RegisterHome = Context->IA64Context.RsBSP;
    ULONG       RegisterCount;
    ULONG       RegisterNumber;
    ULONG       ReadLength;
    ULONG       i;

    i = (ULONG)Context->IA64Context.StIFS & 0x3fff;

    if (FrameNum == 0)
    {
        RegisterCount = i & 0x7f;
    }
    else
    {
        RegisterCount = (i >> 7) & 0x7f;
    }

    // Sanity.

    if (RegisterCount > 96)
    {
        return;
    }

    if (RegisterHome & 3)
    {
        return;
    }

#if 0

    //
    // This is only for debugging this function.
    //

    dprintf("  IFS   %016I64x  PFS  %016I64x\n",
            Context->IA64Context.StIFS,
            Context->IA64Context.RsPFS);
#endif

    if (RegisterCount == 0)
    {
#if 0 
//        //
//        // Not much point doing anything in this case.
//        //
//
//        dprintf("\n");
//        return;
#endif
        // Display at least 4 registers
        RegisterCount = 4;
    }

    //
    // Calculate the number of registers to read from the
    // RSE stack.  For every 63 registers there will be at
    // at least one NaT collection register, depending on
    // where we start, there may be another one.
    //
    // First, starting at the current BSP, if we cross a 64 (0x40)
    // boundry, then we have an extra.
    //

    ReadLength = (((((ULONG)Context->IA64Context.RsBSP) >> 3) & 0x1f) +
                  RegisterCount) >> 6;

    //
    // Add 1 for every 63 registers.
    //

    ReadLength = (RegisterCount / 63) + RegisterCount;
    ReadLength *= sizeof(ULONGLONG);

    //
    // Read the registers for this frame.
    //

    if (m_Target->ReadAllVirtual(g_Process, RegisterHome,
                                 Registers, ReadLength) != S_OK)
    {
        //
        // This shouldn't have happened.
        //

        ErrOut("-- Couldn't read registers BSP=%I64x, length %d.\n",
               RegisterHome,
               ReadLength);
        return;
    }

    //
    // Note: the following code should be altered to understand
    //       NaTs as they come from the register stack (currently
    //       it ignores them).
    //

    RegisterNumber = 32;
    for (i = 0; RegisterCount; RegisterHome += sizeof(ULONGLONG), i++)
    {
        //
        // For now, just skip NaT collection registers.  Every
        // 64th entry is a NaT collection register and the RSE
        // stack is nicely aligned so any entry at an address
        // ending in 63*8 is a NaT entry.
        //
        // 63 * 8  ==  0x3f << 3  ==  0x1f8
        //

        if ((RegisterHome & 0x1f8) == 0x1f8)
        {
            continue;
        }

        if ((RegisterNumber & 3) == 0)
        {
            if (RegisterNumber <= 99)
            {
                dprintf(" ");
            }
            dprintf("r%d", RegisterNumber);
        }

        dprintf(" %s", FormatAddr64(Registers[i]));

        if ((RegisterNumber & 3) == 3)
        {
            dprintf("\n");
        }

        RegisterNumber++;
        RegisterCount--;
    }

    if ((RegisterNumber & 3) != 0)
    {
        dprintf("\n");
    }
    dprintf("\n");
}

void
Ia64MachineInfo::PrintStackFrameMemoryUsage(PDEBUG_STACK_FRAME CurFrame,
                                            PDEBUG_STACK_FRAME PrevFrame)
{
    if (CurFrame->FrameOffset >= PrevFrame->FrameOffset &&
        CurFrame->StackOffset >= PrevFrame->StackOffset)
    {
        dprintf(" %6x ",
                (ULONG)(CurFrame->FrameOffset - PrevFrame->FrameOffset) +
                (ULONG)(CurFrame->StackOffset - PrevFrame->StackOffset));
    }
    else
    {
        dprintf("        ");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\i386_mach.hpp ===
//----------------------------------------------------------------------------
//
// X86 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __I386_MACH_HPP__
#define __I386_MACH_HPP__

//
// NOTE: Be very careful when using machine-specific header files
// such as nt<plat>.h.  The machine implementation class is
// compiled for all platforms so the nt<plat>.h file will be the
// one for the build platform, not necessarily the platform
// of the machine implementation.  ntdbg.h contains many cross-platform
// types and definitions that can be used to avoid problems.
//

//----------------------------------------------------------------------------
//
// X86 instruction support exists on many different processors.
// BaseX86MachineInfo contains implementations of MachineInfo
// methods that apply to all machines supporting X86 instructions.
//
//----------------------------------------------------------------------------

#define NUMBER_OF_387_REGS (X86_ST_LAST - X86_ST_FIRST + 1)
#define NUMBER_OF_XMMI_REGS (X86_XMM_LAST - X86_XMM_FIRST + 1)

#define X86_MAX_INSTRUCTION_LEN 16
#define X86_INT3_LEN 1
 
class BaseX86MachineInfo : public MachineInfo
{
public:
    BaseX86MachineInfo(TargetInfo* Target)
        : MachineInfo(Target) {}

    // MachineInfo.
    virtual void Assemble(ProcessInfo* Process,
                          PADDR Addr, PSTR Input);
    virtual BOOL Disassemble(ProcessInfo* Process,
                             PADDR Addr, PSTR Buffer, BOOL EffAddr);

    virtual BOOL IsBreakpointInstruction(ProcessInfo* Process, PADDR Addr);
    virtual HRESULT InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                ULONG Flags,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual HRESULT RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual void AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                   ULONG BreakType);
    
    virtual BOOL IsCallDisasm(PCSTR Disasm);
    virtual BOOL IsReturnDisasm(PCSTR Disasm);
    virtual BOOL IsSystemCallDisasm(PCSTR Disasm);
    virtual BOOL IsDelayInstruction(PADDR Addr);

    virtual void GetEffectiveAddr(PADDR Addr, PULONG Size);
    virtual void GetNextOffset(ProcessInfo* Process, BOOL StepOver,
                               PADDR NextAddr, PULONG NextMachine);

    virtual void IncrementBySmallestInstruction(PADDR Addr);
    virtual void DecrementBySmallestInstruction(PADDR Addr);

    // BaseX86MachineInfo.
protected:
    ULONG GetMmxRegOffset(ULONG Index, ULONG Fpsw)
    {
        // The FP register area where the MMX registers are
        // aliased onto is stored out relative to the stack top.  MMX
        // register assignments are fixed, though, so we need to
        // take into account the current FP stack top to correctly
        // determine which slot corresponds to which MMX
        // register.
        return (Index - (Fpsw >> 11)) & 7;
    }
    
    void DIdoModrm(ProcessInfo* Process, char **, int, BOOL);
    void OutputSymbol(char **, PUCHAR, int, int);
    BOOL OutputExactSymbol(char **, PUCHAR, int, int);
    ULONG GetSegReg(int SegOpcode);
    int ComputeJccEa(int Opcode, BOOL EaOut);
};

//----------------------------------------------------------------------------
//
// X86MachineInfo is the MachineInfo implementation specific
// to a true X86 processor.
//
//----------------------------------------------------------------------------

extern BOOL g_X86InCode16;
extern BOOL g_X86InVm86;

class X86MachineInfo : public BaseX86MachineInfo
{
public:
    X86MachineInfo(TargetInfo* Target);

    // MachineInfo.
    virtual HRESULT Initialize(void);
    virtual HRESULT InitializeForProcessor(void);
    
    virtual void GetSystemTypeInfo(PSYSTEM_TYPE_INFO Info);
    virtual void GetDefaultKdData(PKDDEBUGGER_DATA64 KdData);
    
    virtual void InitializeContext
        (ULONG64 Pc, PDBGKD_ANY_CONTROL_REPORT ControlReport);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);
    virtual HRESULT ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG FromSver,
                                       ULONG FromSize, PVOID From);
    virtual HRESULT ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG ToSver, ULONG ToSize, PVOID To);
    virtual void InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version);
    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              ULONG64 Stack);
    virtual HRESULT GetContextFromFiber(ProcessInfo* Process,
                                        ULONG64 FiberBase,
                                        PCROSS_PLATFORM_CONTEXT Context,
                                        BOOL Verbose);
    virtual HRESULT GetContextFromTrapFrame(ULONG64 TrapBase,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            BOOL Verbose);
    virtual HRESULT GetContextFromTaskSegment(ULONG64 TssBase,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              BOOL Verbose);
    virtual void GetScopeFrameFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                          PDEBUG_STACK_FRAME ScopeFrame);
    virtual void GetStackDefaultsFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                             LPADDRESS64 Instr,
                                             LPADDRESS64 Stack,
                                             LPADDRESS64 Frame);
    virtual HRESULT GetScopeFrameRegister(ULONG Reg,
                                          PDEBUG_STACK_FRAME ScopeFrame,
                                          PULONG64 Value);
    virtual HRESULT SetScopeFrameRegister(ULONG Reg,
                                          PDEBUG_STACK_FRAME ScopeFrame,
                                          ULONG64 Value);
    virtual void SanitizeMemoryContext(PCROSS_PLATFORM_CONTEXT Context);
    
    virtual HRESULT GetExdiContext(IUnknown* Exdi,
                                   PEXDI_CONTEXT Context,
                                   EXDI_CONTEXT_TYPE CtxType);
    virtual HRESULT SetExdiContext(IUnknown* Exdi,
                                   PEXDI_CONTEXT Context,
                                   EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                               PEXDI_CONTEXT ExdiContext,
                                               EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                             EXDI_CONTEXT_TYPE CtxType,
                                             PCROSS_PLATFORM_CONTEXT Context);
    virtual void ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                              EXDI_CONTEXT_TYPE CtxType,
                                              ULONG Start, ULONG Count,
                                              PDESCRIPTOR64 Descs);
    virtual void ConvertExdiContextFromSpecial
        (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
         PEXDI_CONTEXT ExdiContext,
         EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextToSpecial
        (PEXDI_CONTEXT ExdiContext,
         EXDI_CONTEXT_TYPE CtxType,
         PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    
    virtual int GetType(ULONG Reg);
    virtual HRESULT GetVal(ULONG Reg, REGVAL* Val);
    virtual HRESULT SetVal(ULONG Reg, REGVAL* Val);

    virtual void GetPC(PADDR Address);
    virtual void SetPC(PADDR Address);
    virtual void GetFP(PADDR Address);
    virtual void GetSP(PADDR Address);
    virtual ULONG64 GetArgReg(void);
    virtual ULONG64 GetRetReg(void);
    virtual ULONG GetSegRegNum(ULONG SegReg);
    virtual HRESULT GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc);

    virtual void OutputAll(ULONG Mask, ULONG OutMask);
    
    virtual HRESULT SetAndOutputTrapFrame(ULONG64 TrapBase,
                                          PCROSS_PLATFORM_CONTEXT Context);
    virtual HRESULT SetAndOutputTaskSegment(ULONG64 TssBase,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            BOOL Extended);

    virtual TRACEMODE GetTraceMode(void);
    virtual void SetTraceMode(TRACEMODE Mode);
    virtual BOOL IsStepStatusSupported(ULONG Status);

    virtual void KdUpdateControlSet
        (PDBGKD_ANY_CONTROL_SET ControlSet);

    virtual ULONG ExecutingMachine(void);

    virtual HRESULT SetPageDirectory(ThreadInfo* Thread,
                                     ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ThreadInfo* Thread, ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastVal);
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset);
    virtual void DecodePte(ULONG64 Pte, PULONG64 PageFrameNumber,
                           PULONG Flags);

    virtual HRESULT NewBreakpoint(DebugClient* Client, 
                                  ULONG Type, 
                                  ULONG Id, 
                                  Breakpoint** RetBp);

    virtual void InsertThreadDataBreakpoints(void);
    virtual void RemoveThreadDataBreakpoints(void);
    virtual ULONG IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr);
    
    virtual void PrintStackFrameAddressesTitle(ULONG Flags);
    virtual void PrintStackFrameAddresses(ULONG Flags, 
                                          PDEBUG_STACK_FRAME StackFrame);
    virtual void PrintStackArgumentsTitle(ULONG Flags);
    virtual void PrintStackArguments(ULONG Flags, 
                                     PDEBUG_STACK_FRAME StackFrame);
    virtual void PrintStackCallSiteTitle(ULONG Flags);
    virtual void PrintStackCallSite(ULONG Flags, 
                                    PDEBUG_STACK_FRAME StackFrame, 
                                    PSYMBOL_INFO SiteSymbol,
                                    PSTR SymName,
                                    DWORD64 Displacement);
    virtual void PrintStackFrameMemoryUsage(PDEBUG_STACK_FRAME CurFrame,
                                            PDEBUG_STACK_FRAME PrevFrame);

    virtual void OutputFunctionEntry(PVOID RawEntry);

    virtual HRESULT ReadKernelProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);
    
    virtual HRESULT GetAlternateTriageDumpDataRanges(ULONG64 PrcbBase,
                                                     ULONG64 ThreadBase,
                                                     PADDR_RANGE Ranges);

    // X86MachineInfo.
protected:
    BOOL m_SupportsBranchTrace;
    BOOL m_ResetBranchTrace;

    void KdGetSpecialRegistersFromContext(void);
    void KdSetSpecialRegistersInContext(void);

    ULONG GetIntReg(ULONG regnum);
    PULONG64 GetMmxRegSlot(ULONG regnum);
    void GetMmxReg(ULONG regnum, REGVAL *val);
    void GetFloatReg(ULONG regnum, REGVAL *val);
};

//
// X86 register names that are reused in other places.
//

extern char g_Gs[];
extern char g_Fs[];
extern char g_Es[];
extern char g_Ds[];
extern char g_Edi[];
extern char g_Esi[];
extern char g_Ebx[];
extern char g_Edx[];
extern char g_Ecx[];
extern char g_Eax[];
extern char g_Ebp[];
extern char g_Eip[];
extern char g_Cs[];
extern char g_Efl[];
extern char g_Esp[];
extern char g_Ss[];
extern char g_Dr0[];
extern char g_Dr1[];
extern char g_Dr2[];
extern char g_Dr3[];
extern char g_Dr6[];
extern char g_Dr7[];
extern char g_Cr0[];
extern char g_Cr2[];
extern char g_Cr3[];
extern char g_Cr4[];
extern char g_Gdtr[];
extern char g_Gdtl[];
extern char g_Idtr[];
extern char g_Idtl[];
extern char g_Tr[];
extern char g_Ldtr[];
extern char g_Di[];
extern char g_Si[];
extern char g_Bx[];
extern char g_Dx[];
extern char g_Cx[];
extern char g_Ax[];
extern char g_Bp[];
extern char g_Ip[];
extern char g_Fl[];
extern char g_Sp[];
extern char g_Bl[];
extern char g_Dl[];
extern char g_Cl[];
extern char g_Al[];
extern char g_Bh[];
extern char g_Dh[];
extern char g_Ch[];
extern char g_Ah[];
extern char g_Iopl[];
extern char g_Of[];
extern char g_Df[];
extern char g_If[];
extern char g_Tf[];
extern char g_Sf[];
extern char g_Zf[];
extern char g_Af[];
extern char g_Pf[];
extern char g_Cf[];
extern char g_Vip[];
extern char g_Vif[];

extern char g_Fpcw[];
extern char g_Fpsw[];
extern char g_Fptw[];
extern char g_St0[];
extern char g_St1[];
extern char g_St2[];
extern char g_St3[];
extern char g_St4[];
extern char g_St5[];
extern char g_St6[];
extern char g_St7[];

extern char g_Mm0[];
extern char g_Mm1[];
extern char g_Mm2[];
extern char g_Mm3[];
extern char g_Mm4[];
extern char g_Mm5[];
extern char g_Mm6[];
extern char g_Mm7[];

extern char g_Mxcsr[];
extern char g_Xmm0[];
extern char g_Xmm1[];
extern char g_Xmm2[];
extern char g_Xmm3[];
extern char g_Xmm4[];
extern char g_Xmm5[];
extern char g_Xmm6[];
extern char g_Xmm7[];

//----------------------------------------------------------------------------
//
// This class handles the case of X86 instructions executing natively
// on an IA64 processor.  It operates just as the X86 machine does
// except that:
//   Context state is retrieved and set through the
//   IA64 register state as defined in the X86-on-IA64 support.
//
// Implementation is in the IA64 code.
//
//----------------------------------------------------------------------------

class X86OnIa64MachineInfo : public X86MachineInfo
{
public:
    X86OnIa64MachineInfo(TargetInfo* Target);

    virtual HRESULT UdGetContextState(ULONG State);
    virtual HRESULT UdSetContext(void);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);

    virtual HRESULT GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc);

    virtual HRESULT NewBreakpoint(DebugClient* Client, 
                                  ULONG Type, 
                                  ULONG Id, 
                                  Breakpoint** RetBp);

    virtual ULONG IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr);
    
private:
    void X86ContextToIa64(PX86_NT5_CONTEXT X86Context,
                          PIA64_CONTEXT Ia64Context);
    void Ia64ContextToX86(PIA64_CONTEXT Ia64Context,
                          PX86_NT5_CONTEXT X86Context);
};

//----------------------------------------------------------------------------
//
// This class handles the case of IA32 instructions executing
// on an AMD64 processor.  It operates just as the X86 machine does
// except that:
//   Context state is retrieved and set through the
//   AMD64 register state as defined in the IA32-on-AMD64 support.
//
// Implementation is in the AMD64 code.
//
//----------------------------------------------------------------------------

class X86OnAmd64MachineInfo : public X86MachineInfo
{
public:
    X86OnAmd64MachineInfo(TargetInfo* Target);

    virtual HRESULT UdGetContextState(ULONG State);
    virtual HRESULT UdSetContext(void);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);

    virtual HRESULT GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc);

private:
    void X86ContextToAmd64(PX86_NT5_CONTEXT X86Context,
                           PAMD64_CONTEXT Amd64Context);
    void Amd64ContextToX86(PAMD64_CONTEXT Amd64Context,
                           PX86_NT5_CONTEXT X86Context);
};

#endif // #ifndef __I386_MACH_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ia64_mach.hpp ===
//----------------------------------------------------------------------------
//
// IA64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __IA64_MACH_HPP__
#define __IA64_MACH_HPP__

//
// NOTE: Be very careful when using machine-specific header files
// such as nt<plat>.h.  The machine implementation class is
// compiled for all platforms so the nt<plat>.h file will be the
// one for the build platform, not necessarily the platform
// of the machine implementation.  ntdbg.h contains many cross-platform
// types and definitions that can be used to avoid problems.
//

class Ia64MachineInfo : public MachineInfo
{
public:
    Ia64MachineInfo(TargetInfo* Target);

    // MachineInfo.
    virtual HRESULT Initialize(void);
    
    virtual void GetSystemTypeInfo(PSYSTEM_TYPE_INFO Info);
    virtual void GetDefaultKdData(PKDDEBUGGER_DATA64 KdData);
    
    virtual void InitializeContext
        (ULONG64 Pc, PDBGKD_ANY_CONTROL_REPORT ControlReport);
    virtual HRESULT KdGetContextState(ULONG State);
    virtual HRESULT KdSetContext(void);
    virtual HRESULT ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG FromSver,
                                       ULONG FromSize, PVOID From);
    virtual HRESULT ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG ToSver, ULONG ToSize, PVOID To);
    virtual void InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version);
    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              ULONG64 Stack);
    virtual HRESULT GetContextFromFiber(ProcessInfo* Process,
                                        ULONG64 FiberBase,
                                        PCROSS_PLATFORM_CONTEXT Context,
                                        BOOL Verbose);
    virtual HRESULT GetContextFromTrapFrame(ULONG64 TrapBase,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            BOOL Verbose);
    virtual void GetScopeFrameFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                          PDEBUG_STACK_FRAME ScopeFrame);
    virtual HRESULT GetScopeFrameRegister(ULONG Reg,
                                          PDEBUG_STACK_FRAME ScopeFrame,
                                          PULONG64 Value);
    virtual HRESULT SetScopeFrameRegister(ULONG Reg,
                                          PDEBUG_STACK_FRAME ScopeFrame,
                                          ULONG64 Value);

    virtual HRESULT GetExdiContext(IUnknown* Exdi,
                                   PEXDI_CONTEXT Context,
                                   EXDI_CONTEXT_TYPE CtxType);
    virtual HRESULT SetExdiContext(IUnknown* Exdi,
                                   PEXDI_CONTEXT Context,
                                   EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                               PEXDI_CONTEXT ExdiContext,
                                               EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                             EXDI_CONTEXT_TYPE CtxType,
                                             PCROSS_PLATFORM_CONTEXT Context);
    virtual void ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                              EXDI_CONTEXT_TYPE CtxType,
                                              ULONG Start, ULONG Count,
                                              PDESCRIPTOR64 Descs);
    virtual void ConvertExdiContextFromSpecial
        (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
         PEXDI_CONTEXT ExdiContext,
         EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextToSpecial
        (PEXDI_CONTEXT ExdiContext,
         EXDI_CONTEXT_TYPE CtxType,
         PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    
    virtual int GetType(ULONG Reg);
    virtual HRESULT GetVal(ULONG Reg, REGVAL* Val);
    virtual HRESULT SetVal(ULONG Reg, REGVAL* Val);

    virtual void GetPC(PADDR Address);
    virtual void SetPC(PADDR Address);
    virtual void GetFP(PADDR Address);
    virtual void GetSP(PADDR Address);
    virtual ULONG64 GetArgReg(void);
    virtual ULONG64 GetRetReg(void);

    virtual void OutputAll(ULONG Mask, ULONG OutMask);
    
    virtual HRESULT SetAndOutputTrapFrame(ULONG64 TrapBase,
                                          PCROSS_PLATFORM_CONTEXT Context);

    virtual TRACEMODE GetTraceMode(void);
    virtual void SetTraceMode(TRACEMODE Mode);
    virtual BOOL IsStepStatusSupported(ULONG Status);

    virtual void KdUpdateControlSet
        (PDBGKD_ANY_CONTROL_SET ControlSet);

    virtual ULONG ExecutingMachine(void);

    virtual HRESULT SetPageDirectory(ThreadInfo* Thread,
                                     ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ThreadInfo* Thread, ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastVal);
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset);
    virtual void DecodePte(ULONG64 Pte, PULONG64 PageFrameNumber,
                           PULONG Flags);

    virtual void Assemble(ProcessInfo* Process,
                          PADDR Addr, PSTR Input);
    virtual BOOL Disassemble(ProcessInfo* Process,
                             PADDR Addr, PSTR Buffer, BOOL EffAddr);

    virtual HRESULT NewBreakpoint(DebugClient* Client, 
                                  ULONG Type, 
                                  ULONG Id, 
                                  Breakpoint** RetBp);

    virtual BOOL IsBreakpointInstruction(ProcessInfo* Process, PADDR Addr);
    virtual HRESULT InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                ULONG Flags,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual HRESULT RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen);
    virtual void AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                   ULONG BreakType);
    virtual void InsertThreadDataBreakpoints(void);
    virtual void RemoveThreadDataBreakpoints(void);
    virtual ULONG IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr);
    
    virtual BOOL IsCallDisasm(PCSTR Disasm);
    virtual BOOL IsReturnDisasm(PCSTR Disasm);
    virtual BOOL IsSystemCallDisasm(PCSTR Disasm);
    
    virtual BOOL IsDelayInstruction(PADDR Addr);
    virtual void GetEffectiveAddr(PADDR Addr, PULONG Size);
    virtual void GetNextOffset(ProcessInfo* Process, BOOL StepOver,
                               PADDR NextAddr, PULONG NextMachine);
    virtual BOOL GetPrefixedSymbolOffset(ProcessInfo* Process,
                                         ULONG64 SymOffset,
                                         ULONG Flags,
                                         PULONG64 PrefixedSymOffset);

    virtual void IncrementBySmallestInstruction(PADDR Addr);
    virtual void DecrementBySmallestInstruction(PADDR Addr);

    virtual void OutputFunctionEntry(PVOID RawEntry);
    virtual HRESULT ReadDynamicFunctionTable(ProcessInfo* Process,
                                             ULONG64 Table,
                                             PULONG64 NextTable,
                                             PULONG64 MinAddress,
                                             PULONG64 MaxAddress,
                                             PULONG64 BaseAddress,
                                             PULONG64 TableData,
                                             PULONG TableSize,
                                             PWSTR OutOfProcessDll,
                                             PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable);
    virtual PVOID FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize);
    virtual HRESULT GetUnwindInfoBounds(ProcessInfo* Process,
                                        ULONG64 TableBase,
                                        PVOID RawTableEntries,
                                        ULONG EntryIndex,
                                        PULONG64 Start,
                                        PULONG Size);

    virtual HRESULT ReadKernelProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);
    
    virtual HRESULT GetAlternateTriageDumpDataRanges(ULONG64 PrcbBase,
                                                     ULONG64 ThreadBase,
                                                     PADDR_RANGE Ranges);
    
    virtual void PrintStackFrameAddressesTitle(ULONG Flags);
    virtual void PrintStackFrameAddresses(ULONG Flags, 
                                          PDEBUG_STACK_FRAME StackFrame);
    virtual void PrintStackArgumentsTitle(ULONG Flags);
    virtual void PrintStackArguments(ULONG Flags, 
                                     PDEBUG_STACK_FRAME StackFrame);

    virtual void PrintStackNonvolatileRegisters(ULONG Flags, 
                                                PDEBUG_STACK_FRAME StackFrame,
                                                PCROSS_PLATFORM_CONTEXT Context,
                                                ULONG FrameNum);
    virtual void PrintStackFrameMemoryUsage(PDEBUG_STACK_FRAME CurFrame,
                                            PDEBUG_STACK_FRAME PrevFrame);

    // Ia64MachineInfo.
    BOOL IsIA32InstructionSet(VOID);

    void SetKernelPageDirectory(ULONG64 PageDir)
    {
        m_KernPageDir = PageDir;
    }

protected:
    ULONG64 m_KernPageDir;
    ULONG64 m_IfsOverride;
    ULONG64 m_BspOverride;

    HRESULT GetRotatingRegVal(ULONG Reg,
                              ULONG64 Bsp,
                              ULONG64 FrameMarker,
                              REGVAL* Val);
    HRESULT SetRotatingRegVal(ULONG Reg,
                              ULONG64 Bsp,
                              ULONG64 FrameMarker,
                              REGVAL* Val);
    
    HRESULT GetStackedRegVal(IN ProcessInfo* Process,
                             IN ULONG64 RsBSP, 
                             IN ULONG64 FrameMarker,
                             IN ULONG64 RsRNAT, 
                             IN ULONG Reg, 
                             OUT REGVAL* Val);
    HRESULT SetStackedRegVal(IN ProcessInfo* Process,
                             IN ULONG64 RsBSP, 
                             IN ULONG64 FrameMarker,
                             IN ULONG64 *RsRNAT, 
                             IN ULONG Reg, 
                             IN REGVAL* Val);

    friend class X86OnIa64MachineInfo;
};

#endif // #ifndef __IA64_MACH_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\instr.cpp ===
//----------------------------------------------------------------------------
//
// Functions dealing with instructions, such as assembly or disassembly.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

ADDR g_DisasmSearchStartAddress;
ADDR g_DisasmSearchLastPc;
char g_DisasmSearchLastPattern[256];

ULONG g_AsmOptions;

ULONG g_X86BiosBaseAddress;

// This array must be in DEBUG_ASMOPT bit order.
PCSTR g_AsmOptionNames[] =
{
    "verbose",
    "no_code_bytes",
    "ignore_output_width",
};

void
DotAsm(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG Flags = 0;
    PSTR Arg;
    ULONG i;
    
    for (;;)
    {
        //
        // Parse out a single flag argument.
        //

        if (!PeekChar() || *g_CurCmd == ';')
        {
            break;
        }
        
        Arg = g_CurCmd;
        
        while (*g_CurCmd && !isspace(*g_CurCmd))
        {
            g_CurCmd++;
        }
        if (isspace(*g_CurCmd))
        {
            *g_CurCmd++ = 0;
        }

        //
        // Find value for argument.
        //

        for (i = 0; i < DIMA(g_AsmOptionNames); i++)
        {
            if (!_stricmp(Arg, g_AsmOptionNames[i]))
            {
                break;
            }
        }
        if (i < DIMA(g_AsmOptionNames))
        {
            Flags |= 1 << i;
        }
        else
        {
            ErrOut("Unknown assembly option '%s'\n", Arg);
        }
    }

    if (Cmd->Name[3] != '-')
    {
        g_AsmOptions |= Flags;
    }
    else
    {
        g_AsmOptions &= ~Flags;
    }

    NotifyChangeEngineState(DEBUG_CES_ASSEMBLY_OPTIONS, g_AsmOptions, TRUE);
    
    dprintf("Assembly options:");
    if (g_AsmOptions == 0)
    {
        dprintf(" <default>\n");
    }
    else
    {
        for (i = 0; i < DIMA(g_AsmOptionNames); i++)
        {
            if (g_AsmOptions & (1 << i))
            {
                dprintf(" %s", g_AsmOptionNames[i]);
            }
        }
        dprintf("\n");
    }
}

void
ParseInstrGrep(void)
{
    ADDR NextGrepAddr;
    ADDR CurrGrepAddr;
    char SourceLine[MAX_DISASM_LEN];
    PSTR Pattern;
    char Save;
    ULONG64 Length;

    if (IS_CUR_CONTEXT_ACCESSIBLE())
    {
        g_Machine->GetPC(&g_DisasmSearchLastPc);
    }

    Pattern = StringValue(STRV_SPACE_IS_SEPARATOR |
                          STRV_ESCAPED_CHARACTERS |
                          STRV_ALLOW_EMPTY_STRING, &Save);
    if (Pattern)
    {
        g_DisasmSearchLastPattern[0] = '*';
        g_DisasmSearchLastPattern[1] = 0;
        while (Pattern[0] == '*')
        {
            Pattern++;
        }
        CatString(g_DisasmSearchLastPattern, Pattern,
                  DIMA(g_DisasmSearchLastPattern));
        if (Pattern[strlen(Pattern) - 1] != '*')
        {
            CatString(g_DisasmSearchLastPattern, "*",
                      DIMA(g_DisasmSearchLastPattern));
        }
        *g_CurCmd = Save;

        Length = DEBUG_INVALID_OFFSET;
        g_PrefixSymbols = TRUE;
        GetRange(&g_DisasmSearchStartAddress, &Length, 1,
                 SEGREG_CODE, DEFAULT_RANGE_LIMIT);
        g_PrefixSymbols = FALSE;
    }

    if (!Flat(g_DisasmSearchStartAddress))
    {
        if (IS_CUR_CONTEXT_ACCESSIBLE())
        {
            dprintf("Search address set to ");
            dprintAddr(&g_DisasmSearchLastPc);
            dprintf("\n");
            g_DisasmSearchStartAddress = g_DisasmSearchLastPc;
        }
        else
        {
            ErrOut("Search address required\n");
        }
        return;
    }
    
    NextGrepAddr = g_DisasmSearchStartAddress;

    while (Length == DEBUG_INVALID_OFFSET ||
           Length-- > 0)
    {
        CurrGrepAddr = NextGrepAddr;
        if (!g_Machine->
            Disassemble(g_Process, &NextGrepAddr, SourceLine, FALSE))
        {
            break;
        }

        if (MatchPattern(SourceLine, g_DisasmSearchLastPattern))
        {
            g_LastEvalResult.SetU64(Flat(CurrGrepAddr));
            g_DisasmSearchStartAddress = NextGrepAddr;
            OutputSymAddr(Flat(CurrGrepAddr),
                          SYMADDR_FORCE | SYMADDR_LABEL | SYMADDR_SOURCE,
                          NULL);
            dprintf("%s", SourceLine);

            if (Length == DEBUG_INVALID_OFFSET)
            {
                return;
            }
        }

        if (CheckUserInterrupt())
        {
            return;
        }
    }
}

void
TryAssemble(PADDR Addr)
{
    char Assemble[MAX_DISASM_LEN];

    //
    // Set local prompt and command.
    //

    g_CommandStart = Assemble;
    g_CurCmd = Assemble;
    g_PromptLength = 9;

    Assemble[0] = '\0';

    while (TRUE)
    {
        char Ch;
        
        dprintAddr(Addr);
        GetInput("", Assemble, sizeof(Assemble), GETIN_LOG_INPUT_LINE);
        g_CurCmd = Assemble;
        RemoveDelChar(g_CurCmd);
        do
        {
            Ch = *g_CurCmd++;
        }
        while (Ch == ' ' || Ch == '\t');
        if (Ch == '\0')
        {
            break;
        }
        g_CurCmd--;

        DBG_ASSERT(fFlat(*Addr) || fInstrPtr(*Addr));
        g_Machine->Assemble(g_Process, Addr, g_CurCmd);
    }
}

void
ParseAssemble(void)
{
    //
    // Save present prompt and command.
    //

    PSTR StartSave = g_CommandStart;   //  saved start of cmd buffer
    PSTR CommandSave = g_CurCmd;       //  current ptr in cmd buffer
    ULONG PromptSave = g_PromptLength;  //  size of prompt string
    BOOL Done = FALSE;
    char Ch;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }
    
    if ((Ch = PeekChar()) != '\0' && Ch != ';')
    {
        GetAddrExpression(SEGREG_CODE, &g_AssemDefault);
    }

    while (!Done)
    {
        __try
        {
            TryAssemble(&g_AssemDefault);

            // If assembly returned normally we're done.
            Done = TRUE;
        }
        __except(CommandExceptionFilter(GetExceptionInformation()))
        {
            // If illegal input was encountered keep looping.
        }
    }

    //
    // Restore entry prompt and command.
    //

    g_CommandStart = StartSave;
    g_CurCmd = CommandSave;
    g_PromptLength = PromptSave;
}

void
ParseUnassemble(void)
{
    char Ch;
    ULONG64 Length;
    BOOL HasLength;
    char Text[MAX_DISASM_LEN];
    
    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }
    
    Ch = (char)tolower(*g_CurCmd);
    if (Ch == 'r')
    {
        g_CurCmd++;
    }
    else if (IS_KERNEL_TARGET(g_Target) && Ch == 'x')
    {
        g_CurCmd += 1;
    }
    
    Length = (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_IA64) ? 9 : 8;  
    g_PrefixSymbols = TRUE;
    HasLength = GetRange(&g_UnasmDefault, &Length, 0, SEGREG_CODE,
                         DEFAULT_RANGE_LIMIT);
    g_PrefixSymbols = FALSE;

    if (IS_KERNEL_TARGET(g_Target) && Ch == 'x')
    {
        ADDR Addr;
        
        if (g_X86BiosBaseAddress == 0)
        {
            ULONG64 SymAddr;
            
            if (GetOffsetFromSym(g_Process, "hal!HalpEisaMemoryBase",
                                 &SymAddr, NULL) != 1)
            {
                error(VARDEF);
            }
            if (g_Target->
                ReadAllVirtual(g_Process, SymAddr,
                               &g_X86BiosBaseAddress,
                               sizeof(ULONG)) != S_OK)
            {
                g_X86BiosBaseAddress = 0;
                error(MEMORY);
            }
        }

        Addr = g_UnasmDefault;
        Addr.flat += (g_X86BiosBaseAddress + (Addr.seg << 4));
        Addr.off = Addr.flat;
        Addr.type = ADDR_V86 | INSTR_POINTER;
        while (Length-- > 0)
        {
            g_Target->m_Machines[MACHIDX_I386]->
                Disassemble(g_Process, &Addr, Text, TRUE);
            Addr.flat = Addr.off;
            dprintf("%s", Text);
        }
        g_UnasmDefault = Addr;
        g_UnasmDefault.off -=
            (g_X86BiosBaseAddress + (Addr.seg << 4));
        g_UnasmDefault.flat = g_UnasmDefault.off;
    }
    else
    {
        MachineInfo* Machine;

        if (Ch == 'r')
        {
            // Force V86-mode address to force 16-bit disassembly.
            // We leave the flat address so that the actual
            // address used is not changed and we tweak
            // the seg:off pair to represent a count from the
            // start address.
            g_UnasmDefault.seg = 0;
            g_UnasmDefault.off = Flat(g_UnasmDefault) & 0xffff;
            g_UnasmDefault.type = ADDR_V86 | FLAT_COMPUTED |
                FLAT_BASIS;
            Machine = g_Target->m_Machines[MACHIDX_I386];
        }
        else
        {
            Machine = g_Machine;
        }
        
        BOOL Status;
        ADDR EndAddr;
        ULONG SymAddrFlags = SYMADDR_FORCE | SYMADDR_LABEL | SYMADDR_SOURCE;

        ADDRFLAT(&EndAddr, Length);

        while ((HasLength && Length--) ||
               (!HasLength && AddrLt(g_UnasmDefault, EndAddr)))
        {
            OutputSymAddr(Flat(g_UnasmDefault), SymAddrFlags, NULL);
            Status = Machine->
                Disassemble(g_Process, &g_UnasmDefault, Text, FALSE);
            dprintf("%s", Text);
            if (!Status)
            {
                error(MEMORY);
            }

            SymAddrFlags &= ~SYMADDR_FORCE;

            if (CheckUserInterrupt())
            {
                return;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ia64_reg.h ===
/****************************************************************************
 *                                                                          *
 * The following enumeration is ordered to match the _CONTEXT record.       *
 * Enumerations after STIFS is ordered to match the _KSPECIAL_REGISTERS     *
 * record.    The ORDERING IS NECESSARY for GetRegValue() to index into the *
 * Context record correctly.                                                *
 *                                                                          *
 * SRxxx may be moved as a group only.                                      *
 *                                                                          *
 * Each floating point register occupies two numbers to address the         *
 * Float128 as two high and low 64-bit parts                                *
 *                                                                          *
 ****************************************************************************/

enum {
    /* Begin of _CONTEXT */

// Debug breakpoint registers
    REGDBI0, REGDBI1, REGDBI2, REGDBI3, REGDBI4, REGDBI5, REGDBI6, REGDBI7,
    REGDBD0, REGDBD1, REGDBD2, REGDBD3, REGDBD4, REGDBD5, REGDBD6, REGDBD7,

    /* all floating point high's are inserted for space */
// Lower floating 
//    FLTZERO, FLTONE,
    FLTS0, FLTS0H, FLTS1, FLTS1H, FLTS2, FLTS2H, FLTS3, FLTS3H, FLTT0, FLTT0H, 
    FLTT1, FLTT1H, FLTT2, FLTT2H, FLTT3, FLTT3H, FLTT4, FLTT4H, FLTT5, FLTT5H, 
    FLTT6, FLTT6H,  FLTT7, FLTT7H, FLTT8, FLTT8H, FLTT9, FLTT9H, 

// high floating saved
    FLTS4, FLTS4H, 
    FLTS5, FLTS5H, FLTS6, FLTS6H, FLTS7, FLTS7H, FLTS8, FLTS8H, FLTS9, FLTS9H, 
    FLTS10, FLTS10H, FLTS11, FLTS11H, FLTS12, FLTS12H, FLTS13, FLTS13H, FLTS14, FLTS14H, 
    FLTS15, FLTS15H, FLTS16, FLTS16H, FLTS17, FLTS17H, FLTS18, FLTS18H, FLTS19, FLTS19H,

// high floating temp 
    FLTF32, FLTF32H, FLTF33, FLTF33H, FLTF34, FLTF34H, FLTF35, FLTF35H, FLTF36, FLTF36H,
    FLTF37, FLTF37H, FLTF38, FLTF38H, FLTF39, FLTF39H, FLTF40, FLTF40H, FLTF41, FLTF41H, 
    FLTF42, FLTF42H, FLTF43, FLTF43H, FLTF44, FLTF44H, FLTF45, FLTF45H, FLTF46, FLTF46H, 
    FLTF47, FLTF47H, FLTF48, FLTF48H, FLTF49, FLTF49H, FLTF50, FLTF50H, FLTF51, FLTF51H, 
    FLTF52, FLTF52H, FLTF53, FLTF53H, FLTF54, FLTF54H, FLTF55, FLTF55H, FLTF56, FLTF56H, 
    FLTF57, FLTF57H, FLTF58, FLTF58H, FLTF59, FLTF59H, FLTF60, FLTF60H, FLTF61, FLTF61H,
    FLTF62, FLTF62H, FLTF63, FLTF63H, FLTF64, FLTF64H, FLTF65, FLTF65H, FLTF66, FLTF66H, 
    FLTF67, FLTF67H, FLTF68, FLTF68H, FLTF69, FLTF69H, FLTF70, FLTF70H, FLTF71, FLTF71H, 
    FLTF72, FLTF72H, FLTF73, FLTF73H, FLTF74, FLTF74H, FLTF75, FLTF75H, FLTF76, FLTF76H, 
    FLTF77, FLTF77H, FLTF78, FLTF78H, FLTF79, FLTF79H, FLTF80, FLTF80H, FLTF81, FLTF81H, 
    FLTF82, FLTF82H, FLTF83, FLTF83H, FLTF84, FLTF84H, FLTF85, FLTF85H, FLTF86, FLTF86H, 
    FLTF87, FLTF87H, FLTF88, FLTF88H, FLTF89, FLTF89H, FLTF90, FLTF90H, FLTF91, FLTF91H,
    FLTF92, FLTF92H, FLTF93, FLTF93H, FLTF94, FLTF94H, FLTF95, FLTF95H, FLTF96, FLTF96H, 
    FLTF97, FLTF97H, FLTF98, FLTF98H, FLTF99, FLTF99H, FLTF100, FLTF100H, FLTF101, FLTF101H, 
    FLTF102, FLTF102H, FLTF103, FLTF103H, FLTF104, FLTF104H, FLTF105, FLTF105H, FLTF106, FLTF106H, 
    FLTF107, FLTF107H, FLTF108, FLTF108H, FLTF109, FLTF109H, FLTF110, FLTF110H, FLTF111, FLTF111H, 
    FLTF112, FLTF112H, FLTF113, FLTF113H, FLTF114, FLTF114H, FLTF115, FLTF115H, FLTF116, FLTF116H, 
    FLTF117, FLTF117H, FLTF118, FLTF118H, FLTF119, FLTF119H, FLTF120, FLTF120H, FLTF121, FLTF121H, 
    FLTF122, FLTF122H, FLTF123, FLTF123H, FLTF124, FLTF124H, FLTF125, FLTF125H, FLTF126, FLTF126H, 
    FLTF127, FLTF127H, 
    
    STFPSR,                                          // FP Status saved

// Integer registers
//    INTZERO,
    INTGP, INTT0, INTT1, INTS0, INTS1,
    INTS2, INTS3, INTV0, INTT2, INTT3, INTT4,
    INTSP, INTTEB, INTT5, INTT6, INTT7, INTT8,
    INTT9, INTT10, INTT11, INTT12, INTT13, INTT14,
    INTT15, INTT16, INTT17, INTT18, INTT19, INTT20, 
    INTT21, INTT22, 

    INTNATS,                                         // Nat bits for r1-r31
    PREDS,                                           // predicates saved

// Branch registers
    BRRP, BRS0, BRS1, BRS2, BRS3, BRS4, BRT0, BRT1,

// System registers      - from _CONTEXT record
    APUNAT, APLC, APEC, APCCV, APDCR,                // other application reg's
    RSPFS, RSBSP, RSBSPSTORE, RSRSC, RSRNAT,         // register stack info

    STIPSR, STIIP, STIFS,                            // trap status info

    StFCR,                                           // iA32 copy of Ar21
    Eflag,                                           // iA32 (Ar24)
    SegCSD,                                          // iA32 Descriptor(Ar25)
    SegSSD,                                          // iA32 Descriptor(Ar26)
    Cflag,                                           // iA32 (Ar27)
    STFSR,                                           // x86 FP status    
    STFIR,
    STFDR,

    /* End of _CONTEXT             */

    INTR32, INTR33, INTR34, INTR35, INTR36, INTR37, INTR38, INTR39,
    INTR40, INTR41, INTR42, INTR43, INTR44, 
    INTR45, INTR46, INTR47, INTR48, INTR49,
    INTR50, INTR51, INTR52, INTR53, INTR54, 
    INTR55, INTR56, INTR57, INTR58, INTR59,
    INTR60, INTR61, INTR62, INTR63, INTR64, 
    INTR65, INTR66, INTR67, INTR68, INTR69,
    INTR70, INTR71, INTR72, INTR73, INTR74, 
    INTR75, INTR76, INTR77, INTR78, INTR79,
    INTR80, INTR81, INTR82, INTR83, INTR84, 
    INTR85, INTR86, INTR87, INTR88, INTR89,
    INTR90, INTR91, INTR92, INTR93, INTR94, 
    INTR95, INTR96, INTR97, INTR98, INTR99,
    INTR100, INTR101, INTR102, INTR103, INTR104, 
    INTR105, INTR106, INTR107, INTR108, INTR109,
    INTR110, INTR111, INTR112, INTR113, INTR114,
    INTR115, INTR116, INTR117, INTR118, INTR119,
    INTR120, INTR121, INTR122, INTR123, INTR124, 
    INTR125, INTR126, INTR127,

    /* Begin of _KSPECIAL_REGISTER */

// Kernel debug breakpoint registers
    KRDBI0, KRDBI1, KRDBI2, KRDBI3, KRDBI4, KRDBI5, KRDBI6, KRDBI7,
    KRDBD0, KRDBD1, KRDBD2, KRDBD3, KRDBD4, KRDBD5, KRDBD6, KRDBD7,

// Kernel performance monitor registers
    KRPFC0, KRPFC1, KRPFC2, KRPFC3, KRPFC4, KRPFC5, KRPFC6, KRPFC7,
    KRPFD0, KRPFD1, KRPFD2, KRPFD3, KRPFD4, KRPFD5, KRPFD6, KRPFD7,

// Kernel bank shadow registers
    INTH16, INTH17, INTH18, INTH19, INTH20, INTH21, INTH22, INTH23,
    INTH24, INTH25, INTH26, INTH27, INTH28, INTH29, INTH30, INTH31,

// System registers     - from _KSPECIAL_REGISTERS record
    // application registers

    // CPUID registers
    ACPUID0, ACPUID1, ACPUID2, ACPUID3, ACPUID4, ACPUID5, ACPUID6, ACPUID7,

    // kernel registers
    APKR0, APKR1, APKR2, APKR3, APKR4, APKR5, APKR6, APKR7,
    APITC, APITM, APIVA, APPTA,	APGPTA, 
    STISR, STIDA, STIITR, STIIPA, STIIM, STIHA,

    // SAPIC registers
    SALID, SAIVR, SATPR, SAEOI, SAIRR0, SAIRR1, SAIRR2, SAIRR3,
    SAITV, SAPMV,  SACMCV, SALRR0, SALRR1,
    
    // region registers
    SRRR0, SRRR1, SRRR2, SRRR3, SRRR4, SRRR5, SRRR6, SRRR7,

    // protection key regs
    SRPKR0, SRPKR1, SRPKR2, SRPKR3, SRPKR4, SRPKR5, SRPKR6, SRPKR7, 
    SRPKR8, SRPKR9, SRPKR10, SRPKR11, SRPKR12, SRPKR13, SRPKR14, SRPKR15,
    
    // translation lookaside registers
    SRTRI0, SRTRI1, SRTRI2, SRTRI3, SRTRI4, SRTRI5, SRTRI6, SRTRI7,
    SRTRD0, SRTRD1, SRTRD2, SRTRD3, SRTRD4, SRTRD5, SRTRD6, SRTRD7,

    //  machine specific registers
    SMSR0, SMSR1, SMSR2, SMSR3, SMSR4, SMSR5, SMSR6, SMSR7,
    /* End of _KSPECIAL_REGISTERS */

// IPSR flags

    IPSRBN, IPSRED, IPSRRI, IPSRSS, IPSRDD, IPSRDA, IPSRID, IPSRIT, 
    IPSRME, IPSRIS, IPSRCPL, IPSRRT, IPSRTB, IPSRLP, IPSRDB, 
    IPSRSI, IPSRDI, IPSRPP, IPSRSP, IPSRDFH, IPSRDFL, IPSRDT, 
    IPSRPK, IPSRI, IPSRIC, IPSRAC, IPSRUP, IPSRBE, IPSROR,

// FPSR flags

    FPSRMDH, FPSRMDL, FPSRSF3, FPSRSF2, FPSRSF1, FPSRSF0,
    FPSRTRAPID, FPSRTRAPUD, FPSRTRAPOD, FPSRTRAPZD, FPSRTRAPDD, FPSRTRAPVD,

// Predicate registers
//  PR0, 
          PR1,  PR2,  PR3,
    PR4,  PR5,  PR6,  PR7,
    PR8,  PR9,  PR10, PR11,
    PR12, PR13, PR14, PR15,
    PR16, PR17, PR18, PR19,
    PR20, PR21, PR22, PR23,
    PR24, PR25, PR26, PR27,
    PR28, PR29, PR30, PR31,
    PR32, PR33, PR34, PR35,
    PR36, PR37, PR38, PR39,
    PR40, PR41, PR42, PR43,
    PR44, PR45, PR46, PR47,
    PR48, PR49, PR50, PR51,
    PR52, PR53, PR54, PR55,
    PR56, PR57, PR58, PR59,
    PR60, PR61, PR62, PR63,

    };


#define IA64_DBBASE          REGDBI0
#define IA64_DBLAST          REGDBD7
#define IA64_FLTBASE         FLTS0
#define IA64_FLTLAST         FLTF127
#define IA64_REGBASE         INTGP
#define IA64_ARBASE          APUNAT
#define IA64_SRBASE          KRDBI0
#define IA64_SREND           SMSR7
#define IA64_FLAGBASE        IPSRBN

#define IA64_DB_COUNT (IA64_DBLAST - IA64_DBBASE + 1)

// Debug register flags.
#define IA64_DBR_RDWR           0xC000000000000000UI64
#define IA64_DBR_RD             0x8000000000000000UI64
#define IA64_DBR_WR             0x4000000000000000UI64
#define IA64_DBR_EXEC           0x8000000000000000UI64
#define IA64_DBG_MASK_MASK      0x00FFFFFFFFFFFFFFUI64
#define IA64_DBG_REG_PLM_USER   0x0800000000000000UI64
#define IA64_DBG_REG_PLM_ALL    0x0F00000000000000UI64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\image.hpp ===
//----------------------------------------------------------------------------
//
// Image information.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#ifndef __IMAGE_HPP__
#define __IMAGE_HPP__

#define UNKNOWN_IMAGE_NAME "Unknown_Module"

enum IMAGE_SYM_STATE
{
    ISS_UNKNOWN,
    ISS_MATCHED,
    ISS_MISMATCHED_SYMBOLS,
    ISS_UNKNOWN_TIMESTAMP,
    ISS_UNKNOWN_CHECKSUM,
    ISS_BAD_CHECKSUM
};

enum INAME
{
    INAME_IMAGE_PATH,
    INAME_IMAGE_PATH_TAIL,
    INAME_MODULE,
};

// Special value meaning all images for some functions which
// accept image base qualifiers.
#define IMAGE_BASE_ALL ((ULONG64)-1)

struct MODULE_ALIAS_LIST
{
    ULONG Length;
    PCSTR* Aliases;
    PCSTR BaseModule;
};

enum
{
    MODALIAS_KERNEL,
    MODALIAS_HAL,
    MODALIAS_KDCOM,
    
    MODALIAS_COUNT
};

extern MODULE_ALIAS_LIST g_AliasLists[];

MODULE_ALIAS_LIST* FindModuleAliasList(PCSTR ImageName,
                                       PBOOL NameInList);

//----------------------------------------------------------------------------
//
// ImageInfo.
//
//----------------------------------------------------------------------------

#define MAX_MODULE 64

class ImageInfo
{
public:
    ImageInfo(ProcessInfo* Process, PSTR ImagePath, ULONG64 Base, BOOL Link);
    ~ImageInfo(void);

    ProcessInfo* m_Process;
    ImageInfo* m_Next;
    ULONG m_Linked:1;
    ULONG m_Unloaded:1;
    ULONG m_FileIsDemandMapped:1;
    ULONG m_MapAlreadyFailed:1;
    ULONG m_CorImage:1;
    ULONG m_UserMode:1;
    HANDLE m_File;
    DWORD64 m_BaseOfImage;
    DWORD m_SizeOfImage;
    DWORD m_CheckSum;
    DWORD m_TimeDateStamp;
    IMAGE_SYM_STATE m_SymState;
    CHAR m_ModuleName[MAX_MODULE];
    CHAR m_OriginalModuleName[MAX_MODULE];
    CHAR m_ImagePath[MAX_IMAGE_PATH];
    // Executable image mapping information for images
    // mapped with minidumps.
    CHAR m_MappedImagePath[MAX_IMAGE_PATH];
    PVOID m_MappedImageBase;
    class MappedMemoryMap* m_MemMap;
    ULONG m_TlsIndex;
    ULONG m_MachineType;
    
    void DeleteResources(BOOL FullDelete);
    
    BOOL LoadExecutableImageMemory(MappedMemoryMap* MemMap, BOOL Verbose);
    void UnloadExecutableImageMemory(void);
    BOOL DemandLoadImageMemory(BOOL CheckIncomplete, BOOL Verbose);

    HRESULT GetTlsIndex(void);
    ULONG GetMachineTypeFromHeader(void);
    ULONG CvRegToMachine(CV_HREG_e CvReg);

    void OutputVersionInformation(void);

    void ValidateSymbolLoad(PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 DefLoad);

    HRESULT FindSysAssert(ULONG64 Offset,
                          PSTR FileName,
                          ULONG FileNameChars,
                          PULONG Line,
                          PSTR AssertText,
                          ULONG AssertTextChars);
    
    ULONG GetMachineType(void)
    {
        if (m_MachineType != IMAGE_FILE_MACHINE_UNKNOWN)
        {
            return m_MachineType;
        }
        else
        {
            return GetMachineTypeFromHeader();
        }
    }

    void ReloadSymbols(void);
    
    void FillModuleParameters(PDEBUG_MODULE_PARAMETERS Params);

private:
    BOOL MapImageRegion(MappedMemoryMap* MemMap,
                        PVOID FileMapping,
                        ULONG Rva, ULONG Size, ULONG RawDataOffset,
                        BOOL AllowOverlap);
};

PSTR UnknownImageName(ULONG64 ImageBase, PSTR Buffer, ULONG BufferChars);
PSTR ValidateImagePath(PSTR ImagePath, ULONG ImagePathChars,
                       ULONG64 ImageBase,
                       PSTR AnsiBuffer, ULONG AnsiBufferChars);
PSTR ConvertAndValidateImagePathW(PWSTR ImagePath, ULONG ImagePathChars,
                                  ULONG64 ImageBase,
                                  PSTR AnsiBuffer, ULONG AnsiBufferChars);
PSTR PrepareImagePath(PSTR ImagePath);

PVOID
FindImageFile(IN ProcessInfo* Process,
              IN PCSTR ImagePath,
              IN ULONG SizeOfImage,
              IN ULONG CheckSum,
              IN ULONG TimeDateStamp,
              OUT HANDLE* FileHandle,
              OUT PSTR MappedImagePath);

BOOL DemandLoadReferencedImageMemory(ProcessInfo* Process,
                                     ULONG64 Addr, ULONG Size);

BOOL
GetModnameFromImage(ProcessInfo* Process,
                    ULONG64   BaseOfDll,
                    HANDLE    File,
                    LPSTR     Name,
                    ULONG     NameSize,
                    BOOL      SearchExportFirst);

BOOL
GetHeaderInfo(IN  ProcessInfo* Process,
              IN  ULONG64 BaseOfDll,
              OUT LPDWORD CheckSum,
              OUT LPDWORD TimeDateStamp,
              OUT LPDWORD SizeOfImage);

#endif // #ifndef __IMAGE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\instr.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _INSTR_H_
#define _INSTR_H_

extern ULONG g_AsmOptions;

void DotAsm(PDOT_COMMAND Cmd, DebugClient* Client);

void ParseInstrGrep(void);
void ParseAssemble(void);
void ParseUnassemble(void);

#endif // #ifndef _INSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ia64_reg.cpp ===
//----------------------------------------------------------------------------
//
// IA64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
// Copyright (C) Intel Corporation, 1995.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"
#include "ia64_dis.h"

//
// Define saved register masks.
//
#define SAVED_FLOATING_MASK 0xfff00000  // saved floating registers
#define SAVED_INTEGER_MASK 0xf3ffff02   // saved integer registers

//
// Number of Data Breakpoints available under IA64 
//
// XXX olegk - increase to 4 in future 
// (and then remove appropriate check at MapDbgSlotIa64ToX86)
#define IA64_REG_MAX_DATA_BREAKPOINTS 2

//
// This parallels ntreg.h. Symbol assignment models ksia64.h
//

CHAR    szDBI0[] = "dbi0";
CHAR    szDBI1[] = "dbi1";
CHAR    szDBI2[] = "dbi2";
CHAR    szDBI3[] = "dbi3";
CHAR    szDBI4[] = "dbi4";
CHAR    szDBI5[] = "dbi5";
CHAR    szDBI6[] = "dbi6";
CHAR    szDBI7[] = "dbi7";

CHAR    szDBD0[] = "dbd0";
CHAR    szDBD1[] = "dbd1";
CHAR    szDBD2[] = "dbd2";
CHAR    szDBD3[] = "dbd3";
CHAR    szDBD4[] = "dbd4";
CHAR    szDBD5[] = "dbd5";
CHAR    szDBD6[] = "dbd6";
CHAR    szDBD7[] = "dbd7";

CHAR    szF32[] = "f32";    // High floating point temporary (scratch) registers
CHAR    szF33[] = "f33";
CHAR    szF34[] = "f34";
CHAR    szF35[] = "f35";
CHAR    szF36[] = "f36";
CHAR    szF37[] = "f37";
CHAR    szF38[] = "f38";
CHAR    szF39[] = "f39";
CHAR    szF40[] = "f40";
CHAR    szF41[] = "f41";
CHAR    szF42[] = "f42";
CHAR    szF43[] = "f43";
CHAR    szF44[] = "f44";
CHAR    szF45[] = "f45";
CHAR    szF46[] = "f46";
CHAR    szF47[] = "f47";
CHAR    szF48[] = "f48";
CHAR    szF49[] = "f49";

CHAR    szF50[] = "f50";
CHAR    szF51[] = "f51";
CHAR    szF52[] = "f52";
CHAR    szF53[] = "f53";
CHAR    szF54[] = "f54";
CHAR    szF55[] = "f55";
CHAR    szF56[] = "f56";
CHAR    szF57[] = "f57";
CHAR    szF58[] = "f58";
CHAR    szF59[] = "f59";
CHAR    szF60[] = "f60";
CHAR    szF61[] = "f61";
CHAR    szF62[] = "f62";
CHAR    szF63[] = "f63";
CHAR    szF64[] = "f64";
CHAR    szF65[] = "f65";
CHAR    szF66[] = "f66";
CHAR    szF67[] = "f67";
CHAR    szF68[] = "f68";
CHAR    szF69[] = "f69";
CHAR    szF70[] = "f70";
CHAR    szF71[] = "f71";
CHAR    szF72[] = "f72";
CHAR    szF73[] = "f73";
CHAR    szF74[] = "f74";
CHAR    szF75[] = "f75";
CHAR    szF76[] = "f76";
CHAR    szF77[] = "f77";
CHAR    szF78[] = "f78";
CHAR    szF79[] = "f79";
CHAR    szF80[] = "f80";
CHAR    szF81[] = "f81";
CHAR    szF82[] = "f82";
CHAR    szF83[] = "f83";
CHAR    szF84[] = "f84";
CHAR    szF85[] = "f85";
CHAR    szF86[] = "f86";
CHAR    szF87[] = "f87";
CHAR    szF88[] = "f88";
CHAR    szF89[] = "f89";
CHAR    szF90[] = "f90";
CHAR    szF91[] = "f91";
CHAR    szF92[] = "f92";
CHAR    szF93[] = "f93";
CHAR    szF94[] = "f94";
CHAR    szF95[] = "f95";
CHAR    szF96[] = "f96";
CHAR    szF97[] = "f97";
CHAR    szF98[] = "f98";
CHAR    szF99[] = "f99";

CHAR    szF100[] = "f100";
CHAR    szF101[] = "f101";
CHAR    szF102[] = "f102";
CHAR    szF103[] = "f103";
CHAR    szF104[] = "f104";
CHAR    szF105[] = "f105";
CHAR    szF106[] = "f106";
CHAR    szF107[] = "f107";
CHAR    szF108[] = "f108";
CHAR    szF109[] = "f109";
CHAR    szF110[] = "f110";
CHAR    szF111[] = "f111";
CHAR    szF112[] = "f112";
CHAR    szF113[] = "f113";
CHAR    szF114[] = "f114";
CHAR    szF115[] = "f115";
CHAR    szF116[] = "f116";
CHAR    szF117[] = "f117";
CHAR    szF118[] = "f118";
CHAR    szF119[] = "f119";
CHAR    szF120[] = "f120";
CHAR    szF121[] = "f121";
CHAR    szF122[] = "f122";
CHAR    szF123[] = "f123";
CHAR    szF124[] = "f124";
CHAR    szF125[] = "f125";
CHAR    szF126[] = "f126";
CHAR    szF127[] = "f127";

CHAR    szFPSR[] = "fpsr";
CHAR    szFSR[] = "fsr";
CHAR    szFIR[] = "fir";
CHAR    szFDR[] = "fdr";
CHAR    szFCR[] = "fcr"; 

CHAR    szGP[]  = "gp";        // global pointer
CHAR    szSP[] = "sp";         // stack pointer
CHAR    szR32[] = "r32";
CHAR    szR33[] = "r33";
CHAR    szR34[] = "r34";
CHAR    szR35[] = "r35";
CHAR    szR36[] = "r36";
CHAR    szR37[] = "r37";
CHAR    szR38[] = "r38";
CHAR    szR39[] = "r39";
CHAR    szR40[] = "r40";
CHAR    szR41[] = "r41";
CHAR    szR42[] = "r42";
CHAR    szR43[] = "r43";
CHAR    szR44[] = "r44";
CHAR    szR45[] = "r45";
CHAR    szR46[] = "r46";
CHAR    szR47[] = "r47";
CHAR    szR48[] = "r48";
CHAR    szR49[] = "r49";
CHAR    szR50[] = "r50";
CHAR    szR51[] = "r51";
CHAR    szR52[] = "r52";
CHAR    szR53[] = "r53";
CHAR    szR54[] = "r54";
CHAR    szR55[] = "r55";
CHAR    szR56[] = "r56";
CHAR    szR57[] = "r57";
CHAR    szR58[] = "r58";
CHAR    szR59[] = "r59";
CHAR    szR60[] = "r60";
CHAR    szR61[] = "r61";
CHAR    szR62[] = "r62";
CHAR    szR63[] = "r63";
CHAR    szR64[] = "r64";
CHAR    szR65[] = "r65";
CHAR    szR66[] = "r66";
CHAR    szR67[] = "r67";
CHAR    szR68[] = "r68";
CHAR    szR69[] = "r69";
CHAR    szR70[] = "r70";
CHAR    szR71[] = "r71";
CHAR    szR72[] = "r72";
CHAR    szR73[] = "r73";
CHAR    szR74[] = "r74";
CHAR    szR75[] = "r75";
CHAR    szR76[] = "r76";
CHAR    szR77[] = "r77";
CHAR    szR78[] = "r78";
CHAR    szR79[] = "r79";
CHAR    szR80[] = "r80";
CHAR    szR81[] = "r81";
CHAR    szR82[] = "r82";
CHAR    szR83[] = "r83";
CHAR    szR84[] = "r84";
CHAR    szR85[] = "r85";
CHAR    szR86[] = "r86";
CHAR    szR87[] = "r87";
CHAR    szR88[] = "r88";
CHAR    szR89[] = "r89";
CHAR    szR90[] = "r90";
CHAR    szR91[] = "r91";
CHAR    szR92[] = "r92";
CHAR    szR93[] = "r93";
CHAR    szR94[] = "r94";
CHAR    szR95[] = "r95";
CHAR    szR96[] = "r96";
CHAR    szR97[] = "r97";
CHAR    szR98[] = "r98";
CHAR    szR99[] = "r99";
CHAR    szR100[] = "r100";
CHAR    szR101[] = "r101";
CHAR    szR102[] = "r102";
CHAR    szR103[] = "r103";
CHAR    szR104[] = "r104";
CHAR    szR105[] = "r105";
CHAR    szR106[] = "r106";
CHAR    szR107[] = "r107";
CHAR    szR108[] = "r108";
CHAR    szR109[] = "r109";
CHAR    szR110[] = "r110";
CHAR    szR111[] = "r111";
CHAR    szR112[] = "r112";
CHAR    szR113[] = "r113";
CHAR    szR114[] = "r114";
CHAR    szR115[] = "r115";
CHAR    szR116[] = "r116";
CHAR    szR117[] = "r117";
CHAR    szR118[] = "r118";
CHAR    szR119[] = "r119";
CHAR    szR120[] = "r120";
CHAR    szR121[] = "r121";
CHAR    szR122[] = "r122";
CHAR    szR123[] = "r123";
CHAR    szR124[] = "r124";
CHAR    szR125[] = "r125";
CHAR    szR126[] = "r126";
CHAR    szR127[] = "r127";


CHAR    szINTNATS[] = "intnats";
CHAR    szPREDS[] = "preds";

CHAR    szB0[] = "b0";          // branch return pointer
CHAR    szB1[] = "b1";          // branch saved (preserved)
CHAR    szB2[] = "b2";
CHAR    szB3[] = "b3";
CHAR    szB4[] = "b4";
CHAR    szB5[] = "b5";
CHAR    szB6[] = "b6";          // branch temporary (scratch) registers
CHAR    szB7[] = "b7";

CHAR    szCSD[] = "csd";        // iA32 CS descriptor
CHAR    szSSD[] = "ssd";        // iA32 SS descriptor

CHAR    szAPUNAT[] = "unat";
CHAR    szAPLC[] = "lc";
CHAR    szAPEC[] = "ec";
CHAR    szAPCCV[] = "ccv";
CHAR    szAPDCR[] = "dcr";
CHAR    szRSPFS[] = "pfs";
CHAR    szRSBSP[] = "bsp";
CHAR    szRSBSPSTORE[] = "bspstore";
CHAR    szRSRSC[] = "rsc";
CHAR    szRSRNAT[] = "rnat";

CHAR    szEFLAG[] = "eflag";    // iA32 Eflag
CHAR    szCFLAG[] = "cflag";    // iA32 Cflag

CHAR    szSTIPSR[] = "ipsr";
CHAR    szSTIIP[] = "iip";
CHAR    szSTIFS[] = "ifs";

CHAR    szKDBI0[] = "kdbi0";
CHAR    szKDBI1[] = "kdbi1";
CHAR    szKDBI2[] = "kdbi2";
CHAR    szKDBI3[] = "kdbi3";
CHAR    szKDBI4[] = "kdbi4";
CHAR    szKDBI5[] = "kdbi5";
CHAR    szKDBI6[] = "kdbi6";
CHAR    szKDBI7[] = "kdbi7";

CHAR    szKDBD0[] = "kdbd0";
CHAR    szKDBD1[] = "kdbd1";
CHAR    szKDBD2[] = "kdbd2";
CHAR    szKDBD3[] = "kdbd3";
CHAR    szKDBD4[] = "kdbd4";
CHAR    szKDBD5[] = "kdbd5";
CHAR    szKDBD6[] = "kdbd6";
CHAR    szKDBD7[] = "kdbd7";

CHAR    szKPFC0[] = "kpfc0";
CHAR    szKPFC1[] = "kpfc1";
CHAR    szKPFC2[] = "kpfc2";
CHAR    szKPFC3[] = "kpfc3";
CHAR    szKPFC4[] = "kpfc4";
CHAR    szKPFC5[] = "kpfc5";
CHAR    szKPFC6[] = "kpfc6";
CHAR    szKPFC7[] = "kpfc7";

CHAR    szKPFD0[] = "kpfd0";
CHAR    szKPFD1[] = "kpfd1";
CHAR    szKPFD2[] = "kpfd2";
CHAR    szKPFD3[] = "kpfd3";
CHAR    szKPFD4[] = "kpfd4";
CHAR    szKPFD5[] = "kpfd5";
CHAR    szKPFD6[] = "kpfd6";
CHAR    szKPFD7[] = "kpfd7";

CHAR    szH16[] = "h16";          // kernel bank shadow (hidden) registers
CHAR    szH17[] = "h17";
CHAR    szH18[] = "h18";
CHAR    szH19[] = "h19";
CHAR    szH20[] = "h20";
CHAR    szH21[] = "h21";
CHAR    szH22[] = "h22";
CHAR    szH23[] = "h23";
CHAR    szH24[] = "h24";
CHAR    szH25[] = "h25";
CHAR    szH26[] = "h26";
CHAR    szH27[] = "h27";
CHAR    szH28[] = "h28";
CHAR    szH29[] = "h29";
CHAR    szH30[] = "h30";
CHAR    szH31[] = "h31";

CHAR    szACPUID0[] = "cpuid0";
CHAR    szACPUID1[] = "cpuid1";
CHAR    szACPUID2[] = "cpuid2";
CHAR    szACPUID3[] = "cpuid3";
CHAR    szACPUID4[] = "cpuid4";
CHAR    szACPUID5[] = "cpuid5";
CHAR    szACPUID6[] = "cpuid6";
CHAR    szACPUID7[] = "cpuid7";


CHAR    szAPKR0[] = "kr0";
CHAR    szAPKR1[] = "kr1";
CHAR    szAPKR2[] = "kr2";
CHAR    szAPKR3[] = "kr3";
CHAR    szAPKR4[] = "kr4";
CHAR    szAPKR5[] = "kr5";
CHAR    szAPKR6[] = "kr6";
CHAR    szAPKR7[] = "kr7";

CHAR    szAPITC[] = "itc";
CHAR    szAPITM[] = "itm";
CHAR    szAPIVA[] = "iva";
CHAR    szAPPTA[] = "pta";
CHAR    szAPGPTA[] = "apgta";
CHAR    szSTISR[] = "isr";
CHAR    szSTIDA[] = "ifa";
CHAR    szSTIDTR[] = "idtr";
CHAR    szSTIITR[] = "itir";
CHAR    szSTIIPA[] = "iipa";
CHAR    szSTIIM[] = "iim";
CHAR    szSTIHA[] = "iha";

CHAR    szSALID[] = "lid";
CHAR    szSAIVR[] = "ivr";
CHAR    szSATPR[] = "tpr";
CHAR    szSAEOI[] = "eoi";
CHAR    szSAIRR0[] = "irr0";
CHAR    szSAIRR1[] = "irr1";
CHAR    szSAIRR2[] = "irr2";
CHAR    szSAIRR3[] = "irr3";
CHAR    szSAITV[] = "itv";
CHAR    szSAPMV[] = "pmv";
CHAR    szSALRR0[] = "lrr0";
CHAR    szSALRR1[] = "lrr1";
CHAR    szSACMCV[] = "cmcv";

CHAR    szRR0[] = "rr0";
CHAR    szRR1[] = "rr1";
CHAR    szRR2[] = "rr2";
CHAR    szRR3[] = "rr3";
CHAR    szRR4[] = "rr4";
CHAR    szRR5[] = "rr5";
CHAR    szRR6[] = "rr6";
CHAR    szRR7[] = "rr7";

CHAR    szPKR0[] = "pkr0";
CHAR    szPKR1[] = "pkr1";
CHAR    szPKR2[] = "pkr2";
CHAR    szPKR3[] = "pkr3";
CHAR    szPKR4[] = "pkr4";
CHAR    szPKR5[] = "pkr5";
CHAR    szPKR6[] = "pkr6";
CHAR    szPKR7[] = "pkr7";
CHAR    szPKR8[] = "pkr8";
CHAR    szPKR9[] = "pkr9";
CHAR    szPKR10[] = "pkr10";
CHAR    szPKR11[] = "pkr11";
CHAR    szPKR12[] = "pkr12";
CHAR    szPKR13[] = "pkr13";
CHAR    szPKR14[] = "pkr14";
CHAR    szPKR15[] = "pkr15";

CHAR    szTRI0[] = "tri0";
CHAR    szTRI1[] = "tri1";
CHAR    szTRI2[] = "tri2";
CHAR    szTRI3[] = "tri3";
CHAR    szTRI4[] = "tri4";
CHAR    szTRI5[] = "tri5";
CHAR    szTRI6[] = "tri6";
CHAR    szTRI7[] = "tri7";
CHAR    szTRD0[] = "trd0";
CHAR    szTRD1[] = "trd1";
CHAR    szTRD2[] = "trd2";
CHAR    szTRD3[] = "trd3";
CHAR    szTRD4[] = "trd4";
CHAR    szTRD5[] = "trd5";
CHAR    szTRD6[] = "trd6";
CHAR    szTRD7[] = "trd7";

CHAR    szSMSR0[] = "SMSR0";
CHAR    szSMSR1[] = "SMSR1";
CHAR    szSMSR2[] = "SMSR2";
CHAR    szSMSR3[] = "SMSR3";
CHAR    szSMSR4[] = "SMSR4";
CHAR    szSMSR5[] = "SMSR5";
CHAR    szSMSR6[] = "SMSR6";
CHAR    szSMSR7[] = "SMSR7";


// IPSR flags

CHAR    szIPSRBN[] =  "ipsr.bn";
CHAR    szIPSRED[] =  "ipsr.ed";
CHAR    szIPSRRI[] =  "ipsr.ri";
CHAR    szIPSRSS[] =  "ipsr.ss";
CHAR    szIPSRDD[] =  "ipsr.dd";
CHAR    szIPSRDA[] =  "ipsr.da";
CHAR    szIPSRID[] =  "ipsr.id";
CHAR    szIPSRIT[] =  "ipsr.it";
CHAR    szIPSRME[] =  "ipsr.me";
CHAR    szIPSRIS[] =  "ipsr.is";
CHAR    szIPSRCPL[] = "ipsr.cpl";
CHAR    szIPSRRT[] =  "ipsr.rt";
CHAR    szIPSRTB[] =  "ipsr.tb";
CHAR    szIPSRLP[] =  "ipsr.lp";
CHAR    szIPSRDB[] =  "ipsr.db";
CHAR    szIPSRSI[] =  "ipsr.si";
CHAR    szIPSRDI[] =  "ipsr.di";
CHAR    szIPSRPP[] =  "ipsr.pp";
CHAR    szIPSRSP[] =  "ipsr.sp";
CHAR    szIPSRDFH[] = "ipsr.dfh";
CHAR    szIPSRDFL[] = "ipsr.dfl";
CHAR    szIPSRDT[] =  "ipsr.dt";
CHAR    szIPSRPK[] =  "ipsr.pk";
CHAR    szIPSRI[]  =  "ipsr.i";
CHAR    szIPSRIC[] =  "ipsr.ic";
CHAR    szIPSRAC[] =  "ipsr.ac";
CHAR    szIPSRUP[] =  "ipsr.up";
CHAR    szIPSRBE[] =  "ipsr.be";
CHAR    szIPSROR[] =  "ipsr.or";

// FPSR flags

CHAR    szFPSRMDH[] =    "fpsr.mdh";
CHAR    szFPSRMDL[] =    "fpsr.mdl";
CHAR    szFPSRSF3[] =    "fpsr.sf3";
CHAR    szFPSRSF2[] =    "fpsr.sf2";
CHAR    szFPSRSF1[] =    "fpsr.sf1";
CHAR    szFPSRSF0[] =    "fpsr.sf0";
CHAR    szFPSRTRAPID[] = "fpsr.id";
CHAR    szFPSRTRAPUD[] = "fpsr.ud";
CHAR    szFPSRTRAPOD[] = "fpsr.od";
CHAR    szFPSRTRAPZD[] = "fpsr.zd";
CHAR    szFPSRTRAPDD[] = "fpsr.dd";
CHAR    szFPSRTRAPVD[] = "fpsr.vd";

// Predicate registers
//CHAR    szPR0[] = "p0";
CHAR szPR1[]  = "p1";
CHAR szPR2[]  = "p2";
CHAR szPR3[]  = "p3";
CHAR szPR4[]  = "p4";
CHAR szPR5[]  = "p5";
CHAR szPR6[]  = "p6";
CHAR szPR7[]  = "p7";
CHAR szPR8[]  = "p8";
CHAR szPR9[]  = "p9";
CHAR szPR10[] = "p10";
CHAR szPR11[] = "p11";
CHAR szPR12[] = "p12";
CHAR szPR13[] = "p13";
CHAR szPR14[] = "p14";
CHAR szPR15[] = "p15";
CHAR szPR16[] = "p16";
CHAR szPR17[] = "p17";
CHAR szPR18[] = "p18";
CHAR szPR19[] = "p19";
CHAR szPR20[] = "p20";
CHAR szPR21[] = "p21";
CHAR szPR22[] = "p22";
CHAR szPR23[] = "p23";
CHAR szPR24[] = "p24";
CHAR szPR25[] = "p25";
CHAR szPR26[] = "p26";
CHAR szPR27[] = "p27";
CHAR szPR28[] = "p28";
CHAR szPR29[] = "p29";
CHAR szPR30[] = "p30";
CHAR szPR31[] = "p31";
CHAR szPR32[] = "p32";
CHAR szPR33[] = "p33";
CHAR szPR34[] = "p34";
CHAR szPR35[] = "p35";
CHAR szPR36[] = "p36";
CHAR szPR37[] = "p37";
CHAR szPR38[] = "p38";
CHAR szPR39[] = "p39";
CHAR szPR40[] = "p40";
CHAR szPR41[] = "p41";
CHAR szPR42[] = "p42";
CHAR szPR43[] = "p43";
CHAR szPR44[] = "p44";
CHAR szPR45[] = "p45";
CHAR szPR46[] = "p46";
CHAR szPR47[] = "p47";
CHAR szPR48[] = "p48";
CHAR szPR49[] = "p49";
CHAR szPR50[] = "p50";
CHAR szPR51[] = "p51";
CHAR szPR52[] = "p52";
CHAR szPR53[] = "p53";
CHAR szPR54[] = "p54";
CHAR szPR55[] = "p55";
CHAR szPR56[] = "p56";
CHAR szPR57[] = "p57";
CHAR szPR58[] = "p58";
CHAR szPR59[] = "p59";
CHAR szPR60[] = "p60";
CHAR szPR61[] = "p61";
CHAR szPR62[] = "p62";
CHAR szPR63[] = "p63";

// Aliases: allow aliases to general purpose registers that are
// known by more than one name, eg r12 = rsp.

CHAR    szR1GP[]  =      "r1";
CHAR    szR12SP[] =      "r12";
CHAR    szRA[]    =      "ra";
CHAR    szRP[]    =      "rp";
CHAR    szRET0[]  =      "ret0";
CHAR    szRET1[]  =      "ret1";
CHAR    szRET2[]  =      "ret2";
CHAR    szRET3[]  =      "ret3";
CHAR    szFARG0[] =      "farg0";
CHAR    szFARG1[] =      "farg1";
CHAR    szFARG2[] =      "farg2";
CHAR    szFARG3[] =      "farg3";
CHAR    szFARG4[] =      "farg4";
CHAR    szFARG5[] =      "farg5";
CHAR    szFARG6[] =      "farg6";
CHAR    szFARG7[] =      "farg7";


REGDEF IA64Regs[] =
{
    
    szDBI0, REGDBI0, szDBI1, REGDBI1, szDBI2, REGDBI2, szDBI3, REGDBI3,
    szDBI4, REGDBI4, szDBI5, REGDBI5, szDBI6, REGDBI6, szDBI7, REGDBI7,
    szDBD0, REGDBD0, szDBD1, REGDBD1, szDBD2, REGDBD2, szDBD3, REGDBD3,
    szDBD4, REGDBD4, szDBD5, REGDBD5, szDBD6, REGDBD6, szDBD7, REGDBD7,

//    g_F0, FLTZERO, g_F1, FLTONE,
    g_F2, FLTS0, g_F3, FLTS1,
    g_F4, FLTS2, g_F5, FLTS3, g_F6, FLTT0, g_F7, FLTT1,
    g_F8, FLTT2, g_F9, FLTT3, g_F10, FLTT4, g_F11, FLTT5,
    g_F12, FLTT6, g_F13, FLTT7, g_F14, FLTT8, g_F15, FLTT9,
    g_F16, FLTS4, g_F17, FLTS5, g_F18, FLTS6, g_F19, FLTS7,
    g_F20, FLTS8, g_F21, FLTS9, g_F22, FLTS10, g_F23, FLTS11,
    g_F24, FLTS12, g_F25, FLTS13, g_F26, FLTS14, g_F27, FLTS15,
    g_F28, FLTS16, g_F29, FLTS17, g_F30, FLTS18, g_F31, FLTS19,
    szF32, FLTF32, szF33, FLTF33, szF34, FLTF34, szF35, FLTF35,
    szF36, FLTF36, szF37, FLTF37, szF38, FLTF38, szF39, FLTF39,
    szF40, FLTF40, szF41, FLTF41, szF42, FLTF42, szF43, FLTF43,
    szF44, FLTF44, szF45, FLTF45, szF46, FLTF46, szF47, FLTF47,
    szF48, FLTF48, szF49, FLTF49, szF50, FLTF50, szF51, FLTF51,
    szF52, FLTF52, szF53, FLTF53, szF54, FLTF54, szF55, FLTF55,
    szF56, FLTF56, szF57, FLTF57, szF58, FLTF58, szF59, FLTF59,
    szF60, FLTF60, szF61, FLTF61, szF62, FLTF62, szF63, FLTF63,
    szF64, FLTF64, szF65, FLTF65, szF66, FLTF66, szF67, FLTF67,
    szF68, FLTF68, szF69, FLTF69, szF70, FLTF70, szF71, FLTF71,
    szF72, FLTF72, szF73, FLTF73, szF74, FLTF74, szF75, FLTF75,
    szF76, FLTF76, szF77, FLTF77, szF78, FLTF78, szF79, FLTF79,
    szF80, FLTF80, szF81, FLTF81, szF82, FLTF82, szF83, FLTF83,
    szF84, FLTF84, szF85, FLTF85, szF86, FLTF86, szF87, FLTF87,
    szF88, FLTF88, szF89, FLTF89, szF90, FLTF90, szF91, FLTF91,
    szF92, FLTF92, szF93, FLTF93, szF94, FLTF94, szF95, FLTF95,
    szF96, FLTF96, szF97, FLTF97, szF98, FLTF98, szF99, FLTF99,
    szF100, FLTF100, szF101, FLTF101, szF102, FLTF102, szF103, FLTF103,
    szF104, FLTF104, szF105, FLTF105, szF106, FLTF106, szF107, FLTF107,
    szF108, FLTF108, szF109, FLTF109, szF110, FLTF110, szF111, FLTF111,
    szF112, FLTF112, szF113, FLTF113, szF114, FLTF114, szF115, FLTF115,
    szF116, FLTF116, szF117, FLTF117, szF118, FLTF118, szF119, FLTF119,
    szF120, FLTF120, szF121, FLTF121, szF122, FLTF122, szF123, FLTF123,
    szF124, FLTF124, szF125, FLTF125, szF126, FLTF126, szF127, FLTF127,

    szFPSR, STFPSR, 

//    g_R0, INTZERO,
    szGP, INTGP, g_R2, INTT0, g_R3, INTT1,
    g_R4, INTS0, g_R5, INTS1, g_R6, INTS2, g_R7, INTS3,
    g_R8, INTV0, g_R9, INTT2, g_R10, INTT3, g_R11, INTT4,
    szSP, INTSP, g_R13, INTTEB, g_R14, INTT5, g_R15, INTT6,
    g_R16, INTT7, g_R17, INTT8, g_R18, INTT9, g_R19, INTT10,
    g_R20, INTT11, g_R21, INTT12, g_R22, INTT13, g_R23, INTT14,
    g_R24, INTT15, g_R25, INTT16, g_R26, INTT17, g_R27, INTT18,
    g_R28, INTT19, g_R29, INTT20, g_R30, INTT21, g_R31, INTT22,

    szINTNATS, INTNATS, 

    szR32, INTR32, szR33, INTR33, szR34, INTR34, szR35, INTR35,
    szR36, INTR36, szR37, INTR37, szR38, INTR38, szR39, INTR39,
    szR40, INTR40, szR41, INTR41, szR42, INTR42, szR42, INTR42,
    szR43, INTR43, szR44, INTR44, szR45, INTR45, szR46, INTR46,
    szR47, INTR47, szR48, INTR48, szR49, INTR49, szR50, INTR50,
    szR51, INTR51, szR52, INTR52, szR53, INTR53, szR54, INTR54,
    szR55, INTR55, szR56, INTR56, szR57, INTR57, szR58, INTR58,
    szR59, INTR59, szR60, INTR60, szR61, INTR61, szR62, INTR62,
    szR63, INTR63, szR64, INTR64, szR65, INTR65, szR66, INTR66,
    szR67, INTR67, szR68, INTR68, szR69, INTR69, szR70, INTR70,
    szR71, INTR71, szR72, INTR72, szR73, INTR73, szR74, INTR74,
    szR75, INTR75, szR76, INTR76, szR77, INTR77, szR78, INTR78,
    szR79, INTR79, szR80, INTR80, szR81, INTR81, szR82, INTR82,
    szR83, INTR83, szR84, INTR84, szR85, INTR85, szR86, INTR86,
    szR87, INTR87, szR88, INTR88, szR89, INTR89, szR90, INTR90,
    szR91, INTR91, szR92, INTR92, szR93, INTR93, szR94, INTR94,
    szR95, INTR95, szR96, INTR96, szR97, INTR97, szR98, INTR98,
    szR99, INTR99, szR100, INTR100, szR101, INTR101, szR102, INTR102,
    szR103, INTR103, szR104, INTR104, szR105, INTR105, szR106, INTR106,
    szR107, INTR107, szR108, INTR108, szR109, INTR109, szR110, INTR110,
    szR111, INTR111, szR112, INTR112, szR113, INTR113, szR114, INTR114,
    szR115, INTR115, szR116, INTR116, szR117, INTR117, szR118, INTR118,
    szR119, INTR119, szR120, INTR120, szR121, INTR121, szR122, INTR122,
    szR123, INTR123, szR124, INTR124, szR125, INTR125, szR126, INTR126,
    szR127, INTR127,


    szPREDS, PREDS,

    szB0, BRRP, szB1, BRS0, szB2, BRS1, szB3, BRS2,
    szB4, BRS3, szB5, BRS4, szB6, BRT0, szB7, BRT1,

    szAPUNAT, APUNAT, szAPLC, APLC,
    szAPEC, APEC, szAPCCV, APCCV, szAPDCR, APDCR, szRSPFS, RSPFS,
    szRSBSP, RSBSP, szRSBSPSTORE, RSBSPSTORE, szRSRSC, RSRSC, szRSRNAT, RSRNAT,

    szSTIPSR, STIPSR, szSTIIP, STIIP, szSTIFS, STIFS,

    szFCR, StFCR,
    szEFLAG, Eflag, 
    szCSD, SegCSD, 
    szSSD, SegSSD,  
    szCFLAG, Cflag,
    szFSR, STFSR, 
    szFIR, STFIR, 
    szFDR, STFDR,

// IPSR flags

    szIPSRBN, IPSRBN,
    szIPSRED, IPSRED, szIPSRRI, IPSRRI, szIPSRSS, IPSRSS, szIPSRDD, IPSRDD,
    szIPSRDA, IPSRDA, szIPSRID, IPSRID, szIPSRIT, IPSRIT, szIPSRME, IPSRME,
    szIPSRIS, IPSRIS, szIPSRCPL, IPSRCPL, szIPSRRT, IPSRRT, szIPSRTB, IPSRTB,
    szIPSRLP, IPSRLP, szIPSRDB, IPSRDB, szIPSRSI, IPSRSI, szIPSRDI, IPSRDI,
    szIPSRPP, IPSRPP, szIPSRSP, IPSRSP, szIPSRDFH, IPSRDFH, szIPSRDFL, IPSRDFL,
    szIPSRDT, IPSRDT, szIPSRPK, IPSRPK, szIPSRI, IPSRI, szIPSRIC, IPSRIC,
    szIPSRAC, IPSRAC, szIPSRUP, IPSRUP, szIPSRBE, IPSRBE, szIPSROR, IPSROR,

// FPSR flags

    szFPSRMDH, FPSRMDH, szFPSRMDL, FPSRMDL,
    szFPSRSF3, FPSRSF3, szFPSRSF2, FPSRSF2,
    szFPSRSF1, FPSRSF1, szFPSRSF0, FPSRSF0,
    szFPSRTRAPID, FPSRTRAPID, szFPSRTRAPUD, FPSRTRAPUD,
    szFPSRTRAPOD, FPSRTRAPOD, szFPSRTRAPZD, FPSRTRAPZD,
    szFPSRTRAPDD, FPSRTRAPDD, szFPSRTRAPVD, FPSRTRAPVD,

// Predicate registers
//  szPR0, PR0, 
                  szPR1,  PR1,  szPR2,  PR2,  szPR3,  PR3,
    szPR4,  PR4,  szPR5,  PR5,  szPR6,  PR6,  szPR7,  PR7,
    szPR8,  PR8,  szPR9,  PR9,  szPR10, PR10, szPR11, PR11,
    szPR12, PR12, szPR13, PR13, szPR14, PR14, szPR15, PR15,
    szPR16, PR16, szPR17, PR17, szPR18, PR18, szPR19, PR19,
    szPR20, PR20, szPR21, PR21, szPR22, PR22, szPR23, PR23,
    szPR24, PR24, szPR25, PR25, szPR26, PR26, szPR27, PR27,
    szPR28, PR28, szPR29, PR29, szPR30, PR30, szPR31, PR31,
    szPR32, PR32, szPR33, PR33, szPR34, PR34, szPR35, PR35,
    szPR36, PR36, szPR37, PR37, szPR38, PR38, szPR39, PR39,
    szPR40, PR40, szPR41, PR41, szPR42, PR42, szPR43, PR43,
    szPR44, PR44, szPR45, PR45, szPR46, PR46, szPR47, PR47,
    szPR48, PR48, szPR49, PR49, szPR50, PR50, szPR51, PR51,
    szPR52, PR52, szPR53, PR53, szPR54, PR54, szPR55, PR55,
    szPR56, PR56, szPR57, PR57, szPR58, PR58, szPR59, PR59,
    szPR60, PR60, szPR61, PR61, szPR62, PR62, szPR63, PR63,

// Aliases

    szR1GP, INTGP, szR12SP, INTSP, szRA, BRRP, szRP, BRRP,
    szRET0, INTV0, szRET1, INTT2, szRET2, INTT3, szRET3, INTT4,
    szFARG0, FLTT2, szFARG1, FLTT3, szFARG2, FLTT4, szFARG3, FLTT5,
    szFARG4, FLTT6, szFARG5, FLTT7, szFARG6, FLTT8, szFARG7, FLTT9, 

    NULL, 0,
};

REGDEF g_Ia64KernelRegs[] =
{
    szKDBI0, KRDBI0, szKDBI1, KRDBI1, szKDBI2, KRDBI2, szKDBI3, KRDBI3,
    szKDBI4, KRDBI4, szKDBI5, KRDBI5, szKDBI6, KRDBI6, szKDBI7, KRDBI7,

    szKDBD0, KRDBD0, szKDBD1, KRDBD1, szKDBD2, KRDBD2, szKDBD3, KRDBD3,
    szKDBD4, KRDBD4, szKDBD5, KRDBD5, szKDBD6, KRDBD6, szKDBD7, KRDBD7,

    szKPFC0, KRPFC0, szKPFC1, KRPFC1, szKPFC2, KRPFC2, szKPFC3, KRPFC3,
    szKPFC4, KRPFC4, szKPFC5, KRPFC5, szKPFC6, KRPFC6, szKPFC7, KRPFC7,

    szKPFD0, KRPFD0, szKPFD1, KRPFD1, szKPFD2, KRPFD2, szKPFD3, KRPFD3,
    szKPFD4, KRPFD4, szKPFD5, KRPFD5, szKPFD6, KRPFD6, szKPFD7, KRPFD7,

    szH16, INTH16, szH17, INTH17, szH18, INTH18, szH19, INTH19,
    szH20, INTH20, szH21, INTH21, szH22, INTH22, szH23, INTH23,
    szH24, INTH24, szH25, INTH25, szH26, INTH26, szH27, INTH27,
    szH28, INTH28, szH29, INTH29, szH30, INTH30, szH31, INTH31,

    szACPUID0, ACPUID0, szACPUID1, ACPUID1, szACPUID2, ACPUID2, szACPUID3, ACPUID3, 
    szACPUID4, ACPUID4, szACPUID5, ACPUID5, szACPUID6, ACPUID6, szACPUID7, ACPUID7,

    szAPKR0, APKR0, szAPKR1, APKR1, szAPKR2, APKR2, szAPKR3, APKR3,
    szAPKR4, APKR4, szAPKR5, APKR5, szAPKR6, APKR6, szAPKR7, APKR7,

    szAPITC, APITC, szAPITM, APITM, szAPIVA, APIVA,
    szAPPTA, APPTA, szAPGPTA, APGPTA, 
    szSTISR, STISR, szSTIDA, STIDA,
    szSTIITR, STIITR, szSTIIPA, STIIPA, szSTIIM, STIIM, szSTIHA, STIHA,

    szSALID, SALID,
    szSAIVR, SAIVR, szSATPR, SATPR, szSAEOI, SAEOI, szSAIRR0, SAIRR0,
    szSAIRR1, SAIRR1, szSAIRR2, SAIRR2, szSAIRR3, SAIRR3, szSAITV, SAITV,
    szSAPMV, SAPMV, szSACMCV, SACMCV, szSALRR0, SALRR0, szSALRR1, SALRR1,

    szRR0, SRRR0, szRR1, SRRR1, szRR2, SRRR2, szRR3, SRRR3,
    szRR4, SRRR4, szRR5, SRRR5, szRR6, SRRR6, szRR7, SRRR7,

    szPKR0, SRPKR0, szPKR1, SRPKR1, szPKR2, SRPKR2, szPKR3, SRPKR3,
    szPKR4, SRPKR4, szPKR5, SRPKR5, szPKR6, SRPKR6, szPKR7, SRPKR7,
    szPKR8, SRPKR8, szPKR9, SRPKR9, szPKR10, SRPKR10, szPKR11, SRPKR11,
    szPKR12, SRPKR12, szPKR13, SRPKR13, szPKR14, SRPKR14, szPKR15, SRPKR15,

    szTRI0, SRTRI0, szTRI1, SRTRI1, szTRI2, SRTRI2, szTRI3, SRTRI3,
    szTRI4, SRTRI4, szTRI5, SRTRI5, szTRI6, SRTRI6, szTRI7, SRTRI7,
    szTRD0, SRTRD0, szTRD1, SRTRD1, szTRD2, SRTRD2, szTRD3, SRTRD3,
    szTRD4, SRTRD4, szTRD5, SRTRD5, szTRD6, SRTRD6, szTRD7, SRTRD7,

    szSMSR0, SMSR0, szSMSR1, SMSR1, szSMSR2, SMSR2, szSMSR3, SMSR3, 
    szSMSR4, SMSR4, szSMSR5, SMSR5, szSMSR6, SMSR6, szSMSR7, SMSR7,

    NULL, 0,
};

REGSUBDEF IA64SubRegs[] =
{
    // IPSR flags

    { IPSRBN, STIPSR, 44, 1 },          //  BN Register bank #
    { IPSRED, STIPSR, 43, 1 },          //  ED Exception deferal
    { IPSRRI, STIPSR, 41, 0x3 },        //  RI Restart instruction
    { IPSRSS, STIPSR, 40, 1 },          //  SS Single step enable
    { IPSRDD, STIPSR, 39, 1 },          //  DD Data debug fault disable
    { IPSRDA, STIPSR, 38, 1 },          //  DA Disable access and dirty-bit faults
    { IPSRID, STIPSR, 37, 1 },          //  ID Instruction debug fault disable
    { IPSRIT, STIPSR, 36, 1 },          //  IT Instruction address translation
    { IPSRME, STIPSR, 35, 1 },          //  ME Machine check abort mamsk
    { IPSRIS, STIPSR, 34, 1 },          //  IS Instruction set
    { IPSRCPL,STIPSR, 32, 0x3 },        //  CPL Current privilege level
    { IPSRRT, STIPSR, 27, 1 },          //  RT Rigister stack translation
    { IPSRTB, STIPSR, 26, 1 },          //  TB Taaaaken branch trap
    { IPSRLP, STIPSR, 25, 1 },          //  LP Lower privilege transfer trap
    { IPSRDB, STIPSR, 24, 1 },          //  DB Debug breakpoint fault
    { IPSRSI, STIPSR, 23, 1 },          //  SI Secure interval timer(ITC)
    { IPSRDI, STIPSR, 22, 1 },          //  DI Disable instruction set transition
    { IPSRPP, STIPSR, 21, 1 },          //  PP Privileged performance monitor enable
    { IPSRSP, STIPSR, 20, 1 },          //  SP Secure performance monitors
    { IPSRDFH,STIPSR, 19, 1 },          //  DFH Disabled floating-point high register set, f16-f127
    { IPSRDFL,STIPSR, 18, 1 },          //  DFL Disabled floating-point low register set, f0-f15
    { IPSRDT, STIPSR, 17, 1 },          //  DT Data address translation
//  { ?,      STIPSR, 16, 1 },          //  (reserved)
    { IPSRPK, STIPSR, 15, 1 },          //  PK Protection key enabled
    { IPSRI,  STIPSR, 14, 1 },          //  I  Interrupt unmask
    { IPSRIC, STIPSR, 13, 1 },          //  IC Interruption collection
    { IPSRAC, STIPSR,  3, 1 },          //  AC Alignment check
    { IPSRUP, STIPSR,  2, 1 },          //  UP User performance monitor enabled
    { IPSRBE, STIPSR,  1, 1 },          //  BE Big-Endian
    { IPSROR, STIPSR,  0, 1 },          //  OR Ordered memory reference

    // FPSR flags

    { FPSRMDH,    STFPSR, 63,      1 }, //  MDH Upper floating point register written
    { FPSRMDL,    STFPSR, 62,      1 }, //  MDL Lower floating point register written
    { FPSRSF3,    STFPSR, 45, 0x1fff }, //  SF3 Alternate status field 3
    { FPSRSF2,    STFPSR, 32, 0x1fff }, //  SF2 Alternate status field 2
    { FPSRSF1,    STFPSR, 19, 0x1fff }, //  SF1 Alternate status field 1
    { FPSRSF0,    STFPSR,  6, 0x1fff }, //  SF0 Main status field
    { FPSRTRAPID, STFPSR,  5,      1 }, //  TRAPID Inexact floating point trap
    { FPSRTRAPUD, STFPSR,  4,      1 }, //  TRAPUD Underflow floating point trap
    { FPSRTRAPOD, STFPSR,  3,      1 }, //  TRAPOD Overflow flating point trap
    { FPSRTRAPZD, STFPSR,  2,      1 }, //  TRAPZD Zero devide floating point trap
    { FPSRTRAPDD, STFPSR,  1,      1 }, //  TRAPDD Denormal/Unnormal operand floating point trap
    { FPSRTRAPVD, STFPSR,  0,      1 }, //  TRAPVD Invalid operation floating point trap

    // Predicate registers
//  { PR0,  PREDS,  0, 1 },
    { PR1,  PREDS,  1, 1 },
    { PR2,  PREDS,  2, 1 },
    { PR3,  PREDS,  3, 1 },
    { PR4,  PREDS,  4, 1 },
    { PR5,  PREDS,  5, 1 },
    { PR6,  PREDS,  6, 1 },
    { PR7,  PREDS,  7, 1 },
    { PR8,  PREDS,  8, 1 },
    { PR9,  PREDS,  9, 1 },
    { PR10, PREDS, 10, 1 },
    { PR11, PREDS, 11, 1 },
    { PR12, PREDS, 12, 1 },
    { PR13, PREDS, 13, 1 },
    { PR14, PREDS, 14, 1 },
    { PR15, PREDS, 15, 1 },
    { PR16, PREDS, 16, 1 },
    { PR17, PREDS, 17, 1 },
    { PR18, PREDS, 18, 1 },
    { PR19, PREDS, 19, 1 },
    { PR20, PREDS, 20, 1 },
    { PR21, PREDS, 21, 1 },
    { PR22, PREDS, 22, 1 },
    { PR23, PREDS, 23, 1 },
    { PR24, PREDS, 24, 1 },
    { PR25, PREDS, 25, 1 },
    { PR26, PREDS, 26, 1 },
    { PR27, PREDS, 27, 1 },
    { PR28, PREDS, 28, 1 },
    { PR29, PREDS, 29, 1 },
    { PR30, PREDS, 30, 1 },
    { PR31, PREDS, 31, 1 },
    { PR32, PREDS, 32, 1 },
    { PR33, PREDS, 33, 1 },
    { PR34, PREDS, 34, 1 },
    { PR35, PREDS, 35, 1 },
    { PR36, PREDS, 36, 1 },
    { PR37, PREDS, 37, 1 },
    { PR38, PREDS, 38, 1 },
    { PR39, PREDS, 39, 1 },
    { PR40, PREDS, 40, 1 },
    { PR41, PREDS, 41, 1 },
    { PR42, PREDS, 42, 1 },
    { PR43, PREDS, 43, 1 },
    { PR44, PREDS, 44, 1 },
    { PR45, PREDS, 45, 1 },
    { PR46, PREDS, 46, 1 },
    { PR47, PREDS, 47, 1 },
    { PR48, PREDS, 48, 1 },
    { PR49, PREDS, 49, 1 },
    { PR50, PREDS, 50, 1 },
    { PR51, PREDS, 51, 1 },
    { PR52, PREDS, 52, 1 },
    { PR53, PREDS, 53, 1 },
    { PR54, PREDS, 54, 1 },
    { PR55, PREDS, 55, 1 },
    { PR56, PREDS, 56, 1 },
    { PR57, PREDS, 57, 1 },
    { PR58, PREDS, 58, 1 },
    { PR59, PREDS, 59, 1 },
    { PR60, PREDS, 60, 1 },
    { PR61, PREDS, 61, 1 },
    { PR62, PREDS, 62, 1 },
    { PR63, PREDS, 63, 1 },

    { 0, 0, 0 }
};

#define REGALL_HIGHFLOAT        REGALL_EXTRA0
#define REGALL_DREG             REGALL_EXTRA1
REGALLDESC IA64ExtraDesc[] =
{
    REGALL_HIGHFLOAT,  "High floating pointer registers (f32-f127)",
    REGALL_DREG,       "User debug registers",
    0,                 NULL,
};

#define REGALL_SPECIALREG       REGALL_EXTRA2
REGALLDESC g_Ia64KernelExtraDesc[] =
{
    REGALL_SPECIALREG, "KSPECIAL_REGISTERS",
    0,                 NULL,
};

RegisterGroup g_Ia64BaseGroup =
{
    0, IA64Regs, IA64SubRegs, IA64ExtraDesc
};
RegisterGroup g_Ia64KernelGroup =
{
    0, g_Ia64KernelRegs, NULL, g_Ia64KernelExtraDesc
};

// First ExecTypes entry must be the actual processor type.
ULONG g_Ia64ExecTypes[] =
{
    IMAGE_FILE_MACHINE_IA64, IMAGE_FILE_MACHINE_I386
};

// This array must be sorted by CV reg value.
CvRegMap g_Ia64CvRegMap[] =
{
    // Branch Registers

    { CV_IA64_Br0, BRRP},
    { CV_IA64_Br1, BRS0},
    { CV_IA64_Br2, BRS1},
    { CV_IA64_Br3, BRS2},
    { CV_IA64_Br4, BRS3},
    { CV_IA64_Br5, BRS4},
    { CV_IA64_Br6, BRT0},
    { CV_IA64_Br7, BRT1},

    // Predicate Registers

    { CV_IA64_Preds, PREDS},

    // Banked General Registers
/*
    { CV_IA64_IntH0, IntH0},
    { CV_IA64_IntH1, IntH1},
    { CV_IA64_IntH2, IntH2},
    { CV_IA64_IntH3, IntH3},
    { CV_IA64_IntH4, IntH4},
    { CV_IA64_IntH5, IntH5},
    { CV_IA64_IntH6, IntH6},
    { CV_IA64_IntH7, IntH7},
    { CV_IA64_IntH8, IntH8},
    { CV_IA64_IntH9, IntH9},
    { CV_IA64_IntH10, IntH10},
    { CV_IA64_IntH11, IntH11},
    { CV_IA64_IntH12, IntH12},
    { CV_IA64_IntH13, IntH13},
    { CV_IA64_IntH14, IntH14},
    { CV_IA64_IntH15, IntH15},

    // Special Registers

    { CV_IA64_Ip, Ip},
    { CV_IA64_Umask, Umask},
    { CV_IA64_Cfm, Cfm},
    { CV_IA64_Psr, Psr},

    // Banked General Registers

    { CV_IA64_Nats, Nats},
    { CV_IA64_Nats2, Nats2},
    { CV_IA64_Nats3, Nats3},
*/
    // General-Purpose Registers

    // INTEGER REGISTER
  //  { CV_IA64_IntR0, IntZero},
    { CV_IA64_IntR1, INTGP},
    { CV_IA64_IntR2, INTT0},
    { CV_IA64_IntR3, INTT1},
    { CV_IA64_IntR4, INTS0},
    { CV_IA64_IntR5, INTS1},
    { CV_IA64_IntR6, INTS2},
    { CV_IA64_IntR7, INTS3},
    { CV_IA64_IntR8, INTV0},
//    { CV_IA64_IntR9, INTAP},
    { CV_IA64_IntR10, INTT2},
    { CV_IA64_IntR11, INTT3},
    { CV_IA64_IntR12, INTSP},
    { CV_IA64_IntR13, INTT4},
    { CV_IA64_IntR14, INTT5},
    { CV_IA64_IntR15, INTT6},
    { CV_IA64_IntR16, INTT7},
    { CV_IA64_IntR17, INTT8},
    { CV_IA64_IntR18, INTT9},
    { CV_IA64_IntR19, INTT10},
    { CV_IA64_IntR20, INTT11},
    { CV_IA64_IntR21, INTT12},
    { CV_IA64_IntR22, INTT13},
    { CV_IA64_IntR23, INTT14},
    { CV_IA64_IntR24, INTT15},
    { CV_IA64_IntR25, INTT16},
    { CV_IA64_IntR26, INTT17},
    { CV_IA64_IntR27, INTT18},
    { CV_IA64_IntR28, INTT19},
    { CV_IA64_IntR29, INTT20},
    { CV_IA64_IntR30, INTT21},
    { CV_IA64_IntR31, INTT22},

    // Register Stack
    { CV_IA64_IntR32, INTR32},
    { CV_IA64_IntR33, INTR33},
    { CV_IA64_IntR34, INTR34},
    { CV_IA64_IntR35, INTR35},
    { CV_IA64_IntR36, INTR36},
    { CV_IA64_IntR37, INTR37},
    { CV_IA64_IntR38, INTR38},
    { CV_IA64_IntR39, INTR39},
    { CV_IA64_IntR40, INTR40},
    { CV_IA64_IntR41, INTR41},
    { CV_IA64_IntR42, INTR42},
    { CV_IA64_IntR43, INTR43},
    { CV_IA64_IntR44, INTR44},
    { CV_IA64_IntR45, INTR45},
    { CV_IA64_IntR46, INTR46},
    { CV_IA64_IntR47, INTR47},
    { CV_IA64_IntR48, INTR48},
    { CV_IA64_IntR49, INTR49},
    { CV_IA64_IntR50, INTR50},
    { CV_IA64_IntR51, INTR51},
    { CV_IA64_IntR52, INTR52},
    { CV_IA64_IntR53, INTR53},
    { CV_IA64_IntR54, INTR54},
    { CV_IA64_IntR55, INTR55},
    { CV_IA64_IntR56, INTR56},
    { CV_IA64_IntR57, INTR57},
    { CV_IA64_IntR58, INTR58},
    { CV_IA64_IntR59, INTR59},
    { CV_IA64_IntR60, INTR60},
    { CV_IA64_IntR61, INTR61},
    { CV_IA64_IntR62, INTR62},
    { CV_IA64_IntR63, INTR63},
    { CV_IA64_IntR64, INTR64},
    { CV_IA64_IntR65, INTR65},
    { CV_IA64_IntR66, INTR66},
    { CV_IA64_IntR67, INTR67},
    { CV_IA64_IntR68, INTR68},
    { CV_IA64_IntR69, INTR69},
    { CV_IA64_IntR70, INTR70},
    { CV_IA64_IntR71, INTR71},
    { CV_IA64_IntR72, INTR72},
    { CV_IA64_IntR73, INTR73},
    { CV_IA64_IntR74, INTR74},
    { CV_IA64_IntR75, INTR75},
    { CV_IA64_IntR76, INTR76},
    { CV_IA64_IntR77, INTR77},
    { CV_IA64_IntR78, INTR78},
    { CV_IA64_IntR79, INTR79},
    { CV_IA64_IntR80, INTR80},
    { CV_IA64_IntR81, INTR81},
    { CV_IA64_IntR82, INTR82},
    { CV_IA64_IntR83, INTR83},
    { CV_IA64_IntR84, INTR84},
    { CV_IA64_IntR85, INTR85},
    { CV_IA64_IntR86, INTR86},
    { CV_IA64_IntR87, INTR87},
    { CV_IA64_IntR88, INTR88},
    { CV_IA64_IntR89, INTR89},
    { CV_IA64_IntR90, INTR90},
    { CV_IA64_IntR91, INTR91},
    { CV_IA64_IntR92, INTR92},
    { CV_IA64_IntR93, INTR93},
    { CV_IA64_IntR94, INTR94},
    { CV_IA64_IntR95, INTR95},
    { CV_IA64_IntR96, INTR96},
    { CV_IA64_IntR97, INTR97},
    { CV_IA64_IntR98, INTR98},
    { CV_IA64_IntR99, INTR99},
    { CV_IA64_IntR100, INTR100},
    { CV_IA64_IntR101, INTR101},
    { CV_IA64_IntR102, INTR102},
    { CV_IA64_IntR103, INTR103},
    { CV_IA64_IntR104, INTR104},
    { CV_IA64_IntR105, INTR105},
    { CV_IA64_IntR106, INTR106},
    { CV_IA64_IntR107, INTR107},
    { CV_IA64_IntR108, INTR108},
    { CV_IA64_IntR109, INTR109},
    { CV_IA64_IntR110, INTR110},
    { CV_IA64_IntR111, INTR111},
    { CV_IA64_IntR112, INTR112},
    { CV_IA64_IntR113, INTR113},
    { CV_IA64_IntR114, INTR114},
    { CV_IA64_IntR115, INTR115},
    { CV_IA64_IntR116, INTR116},
    { CV_IA64_IntR117, INTR117},
    { CV_IA64_IntR118, INTR118},
    { CV_IA64_IntR119, INTR119},
    { CV_IA64_IntR120, INTR120},
    { CV_IA64_IntR121, INTR121},
    { CV_IA64_IntR122, INTR122},
    { CV_IA64_IntR123, INTR123},
    { CV_IA64_IntR124, INTR124},
    { CV_IA64_IntR125, INTR125},
    { CV_IA64_IntR126, INTR126},
    { CV_IA64_IntR127, INTR127},

    // Floating-Point Registers

    // Low Floating Point Registers
//    { CV_IA64_FltF0, FltZero},
//    { CV_IA64_FltF1, FltOne},
    { CV_IA64_FltF2, FLTS0},
    { CV_IA64_FltF3, FLTS1},
    { CV_IA64_FltF4, FLTS2},
    { CV_IA64_FltF5, FLTS3},
    { CV_IA64_FltF6, FLTT0},
    { CV_IA64_FltF7, FLTT1},
    { CV_IA64_FltF8, FLTT2},
    { CV_IA64_FltF9, FLTT3},
    { CV_IA64_FltF10, FLTT4},
    { CV_IA64_FltF11, FLTT5},
    { CV_IA64_FltF12, FLTT6},
    { CV_IA64_FltF13, FLTT7},
    { CV_IA64_FltF14, FLTT8},
    { CV_IA64_FltF15, FLTT9},
    { CV_IA64_FltF16, FLTS4},
    { CV_IA64_FltF17, FLTS5},
    { CV_IA64_FltF18, FLTS6},
    { CV_IA64_FltF19, FLTS7},
    { CV_IA64_FltF20, FLTS8},
    { CV_IA64_FltF21, FLTS9},
    { CV_IA64_FltF22, FLTS10},
    { CV_IA64_FltF23, FLTS11},
    { CV_IA64_FltF24, FLTS12},
    { CV_IA64_FltF25, FLTS13},
    { CV_IA64_FltF26, FLTS14},
    { CV_IA64_FltF27, FLTS15},
    { CV_IA64_FltF28, FLTS16},
    { CV_IA64_FltF29, FLTS17},
    { CV_IA64_FltF30, FLTS18},
    { CV_IA64_FltF31, FLTS19},

    // High Floating POINT REGISters
    { CV_IA64_FltF32, FLTF32},
    { CV_IA64_FltF33, FLTF33},
    { CV_IA64_FltF34, FLTF34},
    { CV_IA64_FltF35, FLTF35},
    { CV_IA64_FltF36, FLTF36},
    { CV_IA64_FltF37, FLTF37},
    { CV_IA64_FltF38, FLTF38},
    { CV_IA64_FltF39, FLTF39},
    { CV_IA64_FltF40, FLTF40},
    { CV_IA64_FltF41, FLTF41},
    { CV_IA64_FltF42, FLTF42},
    { CV_IA64_FltF43, FLTF43},
    { CV_IA64_FltF44, FLTF44},
    { CV_IA64_FltF45, FLTF45},
    { CV_IA64_FltF46, FLTF46},
    { CV_IA64_FltF47, FLTF47},
    { CV_IA64_FltF48, FLTF48},
    { CV_IA64_FltF49, FLTF49},
    { CV_IA64_FltF50, FLTF50},
    { CV_IA64_FltF51, FLTF51},
    { CV_IA64_FltF52, FLTF52},
    { CV_IA64_FltF53, FLTF53},
    { CV_IA64_FltF54, FLTF54},
    { CV_IA64_FltF55, FLTF55},
    { CV_IA64_FltF56, FLTF56},
    { CV_IA64_FltF57, FLTF57},
    { CV_IA64_FltF58, FLTF58},
    { CV_IA64_FltF59, FLTF59},
    { CV_IA64_FltF60, FLTF60},
    { CV_IA64_FltF61, FLTF61},
    { CV_IA64_FltF62, FLTF62},
    { CV_IA64_FltF63, FLTF63},
    { CV_IA64_FltF64, FLTF64},
    { CV_IA64_FltF65, FLTF65},
    { CV_IA64_FltF66, FLTF66},
    { CV_IA64_FltF67, FLTF67},
    { CV_IA64_FltF68, FLTF68},
    { CV_IA64_FltF69, FLTF69},
    { CV_IA64_FltF70, FLTF70},
    { CV_IA64_FltF71, FLTF71},
    { CV_IA64_FltF72, FLTF72},
    { CV_IA64_FltF73, FLTF73},
    { CV_IA64_FltF74, FLTF74},
    { CV_IA64_FltF75, FLTF75},
    { CV_IA64_FltF76, FLTF76},
    { CV_IA64_FltF77, FLTF77},
    { CV_IA64_FltF78, FLTF78},
    { CV_IA64_FltF79, FLTF79},
    { CV_IA64_FltF80, FLTF80},
    { CV_IA64_FltF81, FLTF81},
    { CV_IA64_FltF82, FLTF82},
    { CV_IA64_FltF83, FLTF83},
    { CV_IA64_FltF84, FLTF84},
    { CV_IA64_FltF85, FLTF85},
    { CV_IA64_FltF86, FLTF86},
    { CV_IA64_FltF87, FLTF87},
    { CV_IA64_FltF88, FLTF88},
    { CV_IA64_FltF89, FLTF89},
    { CV_IA64_FltF90, FLTF90},
    { CV_IA64_FltF91, FLTF91},
    { CV_IA64_FltF92, FLTF92},
    { CV_IA64_FltF93, FLTF93},
    { CV_IA64_FltF94, FLTF94},
    { CV_IA64_FltF95, FLTF95},
    { CV_IA64_FltF96, FLTF96},
    { CV_IA64_FltF97, FLTF97},
    { CV_IA64_FltF98, FLTF98},
    { CV_IA64_FltF99, FLTF99},
    { CV_IA64_FltF100, FLTF100},
    { CV_IA64_FltF101, FLTF101},
    { CV_IA64_FltF102, FLTF102},
    { CV_IA64_FltF103, FLTF103},
    { CV_IA64_FltF104, FLTF104},
    { CV_IA64_FltF105, FLTF105},
    { CV_IA64_FltF106, FLTF106},
    { CV_IA64_FltF107, FLTF107},
    { CV_IA64_FltF108, FLTF108},
    { CV_IA64_FltF109, FLTF109},
    { CV_IA64_FltF110, FLTF110},
    { CV_IA64_FltF111, FLTF111},
    { CV_IA64_FltF112, FLTF112},
    { CV_IA64_FltF113, FLTF113},
    { CV_IA64_FltF114, FLTF114},
    { CV_IA64_FltF115, FLTF115},
    { CV_IA64_FltF116, FLTF116},
    { CV_IA64_FltF117, FLTF117},
    { CV_IA64_FltF118, FLTF118},
    { CV_IA64_FltF119, FLTF119},
    { CV_IA64_FltF120, FLTF120},
    { CV_IA64_FltF121, FLTF121},
    { CV_IA64_FltF122, FLTF122},
    { CV_IA64_FltF123, FLTF123},
    { CV_IA64_FltF124, FLTF124},
    { CV_IA64_FltF125, FLTF125},
    { CV_IA64_FltF126, FLTF126},
    { CV_IA64_FltF127, FLTF127},

    // Application Registers

    { CV_IA64_ApKR0, APKR0},
    { CV_IA64_ApKR1, APKR1},
    { CV_IA64_ApKR2, APKR2},
    { CV_IA64_ApKR3, APKR3},
    { CV_IA64_ApKR4, APKR4},
    { CV_IA64_ApKR5, APKR5},
    { CV_IA64_ApKR6, APKR6},
    { CV_IA64_ApKR7, APKR7},
/*    { CV_IA64_AR8, AR8},
    { CV_IA64_AR9, AR9},
    { CV_IA64_AR10, AR10},
    { CV_IA64_AR11, AR11},
    { CV_IA64_AR12, AR12},
    { CV_IA64_AR13, AR13},
    { CV_IA64_AR14, AR14},
    { CV_IA64_AR15, AR15},*/
    { CV_IA64_RsRSC, RSRSC},
    { CV_IA64_RsBSP, RSBSP},
    { CV_IA64_RsBSPSTORE, RSBSPSTORE},
    { CV_IA64_RsRNAT, RSRNAT},
//    { CV_IA64_AR20, AR20},
    { CV_IA64_StFCR, StFCR},
//    { CV_IA64_AR22, AR22},
//    { CV_IA64_AR23, AR23},
    { CV_IA64_EFLAG, Eflag},
    { CV_IA64_CSD, SegCSD},
    { CV_IA64_SSD, SegSSD},
    { CV_IA64_CFLG, Cflag},
    { CV_IA64_StFSR, STFSR},
    { CV_IA64_StFIR, STFIR},
    { CV_IA64_StFDR, STFDR},
//    { CV_IA64_AR31, AR31},
    { CV_IA64_ApCCV, APCCV},
//    { CV_IA64_AR33, AR33},
//    { CV_IA64_AR34, AR34},
//    { CV_IA64_AR35, AR35},
    { CV_IA64_ApUNAT, APUNAT},
//    { CV_IA64_AR37, AR37},
//    { CV_IA64_AR38, AR38},
//    { CV_IA64_AR39, AR39},
    { CV_IA64_StFPSR, STFPSR},
//    { CV_IA64_AR41, AR41},
//    { CV_IA64_AR42, AR42},
//    { CV_IA64_AR43, AR43},
    { CV_IA64_ApITC, APITC},
/*    { CV_IA64_AR45, AR45},
    { CV_IA64_AR46, AR46},
    { CV_IA64_AR47, AR47},
    { CV_IA64_AR48, AR48},
    { CV_IA64_AR49, AR49},
    { CV_IA64_AR50, AR50},
    { CV_IA64_AR51, AR51},
    { CV_IA64_AR52, AR52},
    { CV_IA64_AR53, AR53},
    { CV_IA64_AR54, AR54},
    { CV_IA64_AR55, AR55},
    { CV_IA64_AR56, AR56},
    { CV_IA64_AR57, AR57},
    { CV_IA64_AR58, AR58},
    { CV_IA64_AR59, AR59},
    { CV_IA64_AR60, AR60},
    { CV_IA64_AR61, AR61},
    { CV_IA64_AR62, AR62},
    { CV_IA64_AR63, AR63},*/
    { CV_IA64_RsPFS, RSPFS},
    { CV_IA64_ApLC, APLC},
    { CV_IA64_ApEC, APEC},
/*    { CV_IA64_AR67, AR67},
    { CV_IA64_AR68, AR68},
    { CV_IA64_AR69, AR69},
    { CV_IA64_AR70, AR70},
    { CV_IA64_AR71, AR71},
    { CV_IA64_AR72, AR72},
    { CV_IA64_AR73, AR73},
    { CV_IA64_AR74, AR74},
    { CV_IA64_AR75, AR75},
    { CV_IA64_AR76, AR76},
    { CV_IA64_AR77, AR77},
    { CV_IA64_AR78, AR78},
    { CV_IA64_AR79, AR79},
    { CV_IA64_AR80, AR80},
    { CV_IA64_AR81, AR81},
    { CV_IA64_AR82, AR82},
    { CV_IA64_AR83, AR83},
    { CV_IA64_AR84, AR84},
    { CV_IA64_AR85, AR85},
    { CV_IA64_AR86, AR86},
    { CV_IA64_AR87, AR87},
    { CV_IA64_AR88, AR88},
    { CV_IA64_AR89, AR89},
    { CV_IA64_AR90, AR90},
    { CV_IA64_AR91, AR91},
    { CV_IA64_AR92, AR92},
    { CV_IA64_AR93, AR93},
    { CV_IA64_AR94, AR94},
    { CV_IA64_AR95, AR95},
    { CV_IA64_AR96, AR96},
    { CV_IA64_AR97, AR97},
    { CV_IA64_AR98, AR98},
    { CV_IA64_AR99, AR99},
    { CV_IA64_AR100, AR100},
    { CV_IA64_AR101, AR101},
    { CV_IA64_AR102, AR102},
    { CV_IA64_AR103, AR103},
    { CV_IA64_AR104, AR104},
    { CV_IA64_AR105, AR105},
    { CV_IA64_AR106, AR106},
    { CV_IA64_AR107, AR107},
    { CV_IA64_AR108, AR108},
    { CV_IA64_AR109, AR109},
    { CV_IA64_AR110, AR110},
    { CV_IA64_AR111, AR111},
    { CV_IA64_AR112, AR112},
    { CV_IA64_AR113, AR113},
    { CV_IA64_AR114, AR114},
    { CV_IA64_AR115, AR115},
    { CV_IA64_AR116, AR116},
    { CV_IA64_AR117, AR117},
    { CV_IA64_AR118, AR118},
    { CV_IA64_AR119, AR119},
    { CV_IA64_AR120, AR120},
    { CV_IA64_AR121, AR121},
    { CV_IA64_AR122, AR122},
    { CV_IA64_AR123, AR123},
    { CV_IA64_AR124, AR124},
    { CV_IA64_AR125, AR125},
    { CV_IA64_AR126, AR126},
    { CV_IA64_AR127, AR127},
*/
    // Control RegisteRS

    { CV_IA64_ApDCR, APDCR},
    { CV_IA64_ApITM, APITM},
    { CV_IA64_ApIVA, APIVA},
//    { CV_IA64_CR3, CR3},
//    { CV_IA64_CR4, CR4},
//    { CV_IA64_CR5, CR5},
//    { CV_IA64_CR6, CR6},
//    { CV_IA64_CR7, CR7},
    { CV_IA64_ApPTA, APPTA},
//    { CV_IA64_CR9, CR9},
//    { CV_IA64_CR10, CR10},
//    { CV_IA64_CR11, CR11},
//    { CV_IA64_CR12, CR12},
//    { CV_IA64_CR13, CR13},
//    { CV_IA64_CR14, CR14},
//    { CV_IA64_CR15, CR15},
    { CV_IA64_StIPSR, STIPSR},
    { CV_IA64_StISR, STISR},
    { CV_IA64_CR18,  STIDA},
    { CV_IA64_StIIP, STIIP},
//    { CV_IA64_StIDTR, STIDTR},
    { CV_IA64_StIFA, STIITR},
    { CV_IA64_StIIPA, STIIPA},
    { CV_IA64_StIFS, STIFS},
    { CV_IA64_StIIM, STIIM},
    { CV_IA64_StIHA, STIHA},
/*    { CV_IA64_CR26, CR26},
    { CV_IA64_CR27, CR27},
    { CV_IA64_CR28, CR28},
    { CV_IA64_CR29, CR29},
    { CV_IA64_CR30, CR30},
    { CV_IA64_CR31, CR31},
    { CV_IA64_CR32, CR32},
    { CV_IA64_CR33, CR33},
    { CV_IA64_CR34, CR34},
    { CV_IA64_CR35, CR35},
    { CV_IA64_CR36, CR36},
    { CV_IA64_CR37, CR37},
    { CV_IA64_CR38, CR38},
    { CV_IA64_CR39, CR39},
    { CV_IA64_CR40, CR40},
    { CV_IA64_CR41, CR41},
    { CV_IA64_CR42, CR42},
    { CV_IA64_CR43, CR43},
    { CV_IA64_CR44, CR44},
    { CV_IA64_CR45, CR45},
    { CV_IA64_CR46, CR46},
    { CV_IA64_CR47, CR47},
    { CV_IA64_CR48, CR48},
    { CV_IA64_CR49, CR49},
    { CV_IA64_CR50, CR50},
    { CV_IA64_CR51, CR51},
    { CV_IA64_CR52, CR52},
    { CV_IA64_CR53, CR53},
    { CV_IA64_CR54, CR54},
    { CV_IA64_CR55, CR55},
    { CV_IA64_CR56, CR56},
    { CV_IA64_CR57, CR57},
    { CV_IA64_CR58, CR58},
    { CV_IA64_CR59, CR59},
    { CV_IA64_CR60, CR60},
    { CV_IA64_CR61, CR61},
    { CV_IA64_CR62, CR62},
    { CV_IA64_CR63, CR63},
    { CV_IA64_CR64, CR64},
    { CV_IA64_CR65, CR65},*/
    { CV_IA64_SaLID, SALID},
//    { CV_IA64_CR67, CR67},
//    { CV_IA64_CR68, CR68},
//    { CV_IA64_CR69, CR69},
//    { CV_IA64_CR70, CR70},
    { CV_IA64_SaIVR, SAIVR},
    { CV_IA64_SaTPR, SATPR},
//    { CV_IA64_CR73, CR73},
//    { CV_IA64_CR74, CR74},
    { CV_IA64_SaEOI, SAEOI},
/*    { CV_IA64_CR76, CR76},
    { CV_IA64_CR77, CR77},
    { CV_IA64_CR78, CR78},
    { CV_IA64_CR79, CR79},
    { CV_IA64_CR80, CR80},
    { CV_IA64_CR81, CR81},
    { CV_IA64_CR82, CR82},
    { CV_IA64_CR83, CR83},
    { CV_IA64_CR84, CR84},
    { CV_IA64_CR85, CR85},
    { CV_IA64_CR86, CR86},
    { CV_IA64_CR87, CR87},
    { CV_IA64_CR88, CR88},
    { CV_IA64_CR89, CR89},
    { CV_IA64_CR90, CR90},
    { CV_IA64_CR91, CR91},
    { CV_IA64_CR92, CR92},
    { CV_IA64_CR93, CR93},
    { CV_IA64_CR94, CR94},
    { CV_IA64_CR95, CR95},*/
    { CV_IA64_SaIRR0, SAIRR0},
//    { CV_IA64_CR97, CR97},
    { CV_IA64_SaIRR1, SAIRR1},
//    { CV_IA64_CR99, CR99},
    { CV_IA64_SaIRR2, SAIRR2},
//    { CV_IA64_CR101, CR101},
    { CV_IA64_SaIRR3, SAIRR3},
/*    { CV_IA64_CR103, CR103},
    { CV_IA64_CR104, CR104},
    { CV_IA64_CR105, CR105},
    { CV_IA64_CR106, CR106},
    { CV_IA64_CR107, CR107},
    { CV_IA64_CR108, CR108},
    { CV_IA64_CR109, CR109},
    { CV_IA64_CR110, CR110},
    { CV_IA64_CR111, CR111},
    { CV_IA64_CR112, CR112},
    { CV_IA64_CR113, CR113},*/
    { CV_IA64_SaITV, SAITV},
//    { CV_IA64_CR115, CR115},
    { CV_IA64_SaPMV, SAPMV},
    { CV_IA64_SaLRR0, SALRR0},
    { CV_IA64_SaLRR1, SALRR1},
    { CV_IA64_SaCMCV, SACMCV},
//    { CV_IA64_CR120, CR120},
//    { CV_IA64_CR121, CR121},
//    { CV_IA64_CR122, CR122},
//    { CV_IA64_CR123, CR123},
//    { CV_IA64_CR124, CR124},
//    { CV_IA64_CR125, CR125},
//    { CV_IA64_CR126, CR126},
//    { CV_IA64_CR127, CR127},

    // Protection Key Registers

    { CV_IA64_Pkr0, SRPKR0},
    { CV_IA64_Pkr1, SRPKR1},
    { CV_IA64_Pkr2, SRPKR2},
    { CV_IA64_Pkr3, SRPKR3},
    { CV_IA64_Pkr4, SRPKR4},
    { CV_IA64_Pkr5, SRPKR5},
    { CV_IA64_Pkr6, SRPKR6},
    { CV_IA64_Pkr7, SRPKR7},
    { CV_IA64_Pkr8, SRPKR8},
    { CV_IA64_Pkr9, SRPKR9},
    { CV_IA64_Pkr10, SRPKR10},
    { CV_IA64_Pkr11, SRPKR11},
    { CV_IA64_Pkr12, SRPKR12},
    { CV_IA64_Pkr13, SRPKR13},
    { CV_IA64_Pkr14, SRPKR14},
    { CV_IA64_Pkr15, SRPKR15},

    // REGION REGISTERS

    { CV_IA64_Rr0, SRRR0},
    { CV_IA64_Rr1, SRRR1},
    { CV_IA64_Rr2, SRRR2},
    { CV_IA64_Rr3, SRRR3},
    { CV_IA64_Rr4, SRRR4},
    { CV_IA64_Rr5, SRRR5},
    { CV_IA64_Rr6, SRRR6},
    { CV_IA64_Rr7, SRRR7},

    // PERFORMANCE MONITOR DATA REGISTERS

    { CV_IA64_PFD0, KRPFD0},
    { CV_IA64_PFD1, KRPFD1},
    { CV_IA64_PFD2, KRPFD2},
    { CV_IA64_PFD3, KRPFD3},
    { CV_IA64_PFD4, KRPFD4},
    { CV_IA64_PFD5, KRPFD5},
    { CV_IA64_PFD6, KRPFD6},
    { CV_IA64_PFD7, KRPFD7},

    // PERFORMANCE MONITOR CONFIG REGISTERS

    { CV_IA64_PFC0, KRPFC0},
    { CV_IA64_PFC1, KRPFC1},
    { CV_IA64_PFC2, KRPFC2},
    { CV_IA64_PFC3, KRPFC3},
    { CV_IA64_PFC4, KRPFC4},
    { CV_IA64_PFC5, KRPFC5},
    { CV_IA64_PFC6, KRPFC6},
    { CV_IA64_PFC7, KRPFC7},

    // INSTRUCTION TRANSLATION REGISTERS

    { CV_IA64_TrI0, SRTRI0},
    { CV_IA64_TrI1, SRTRI1},
    { CV_IA64_TrI2, SRTRI2},
    { CV_IA64_TrI3, SRTRI3},
    { CV_IA64_TrI4, SRTRI4},
    { CV_IA64_TrI5, SRTRI5},
    { CV_IA64_TrI6, SRTRI6},
    { CV_IA64_TrI7, SRTRI7},

    // DATA TRANSLATION REGISTERS

    { CV_IA64_TrD0, SRTRD0},
    { CV_IA64_TrD1, SRTRD1},
    { CV_IA64_TrD2, SRTRD2},
    { CV_IA64_TrD3, SRTRD3},
    { CV_IA64_TrD4, SRTRD4},
    { CV_IA64_TrD5, SRTRD5},
    { CV_IA64_TrD6, SRTRD6},
    { CV_IA64_TrD7, SRTRD7},

    // INSTRUCTION BREAKPOINT REGISTERS

    { CV_IA64_DbI0, KRDBI0},
    { CV_IA64_DbI1, KRDBI1},
    { CV_IA64_DbI2, KRDBI2},
    { CV_IA64_DbI3, KRDBI3},
    { CV_IA64_DbI4, KRDBI4},
    { CV_IA64_DbI5, KRDBI5},
    { CV_IA64_DbI6, KRDBI6},
    { CV_IA64_DbI7, KRDBI7},

    // DATA BREAKPOINT REGISTERS

    { CV_IA64_DbD0, KRDBD0},
    { CV_IA64_DbD1, KRDBD1},
    { CV_IA64_DbD2, KRDBD2},
    { CV_IA64_DbD3, KRDBD3},
    { CV_IA64_DbD4, KRDBD4},
    { CV_IA64_DbD5, KRDBD5},
    { CV_IA64_DbD6, KRDBD6},
    { CV_IA64_DbD7, KRDBD7},
};

BOOL 
SplitIa64Pc(ULONG64 Pc, ULONG64* Bundle, ULONG64* Slot)
{
    ULONG64 SlotVal = Pc & 0xf;

    switch (SlotVal) 
    {
    case 0: 
    case 4: 
    case 8:  
        SlotVal >>= 2;
        break;
    default: 
        return FALSE;
    } 

    if (Slot) 
    {
        *Slot = SlotVal;
    }
    if (Bundle) 
    {
        *Bundle = Pc & ~(ULONG64)0xf;
    }

    return TRUE;
}

ULONG
RotateGr(ULONG Reg, ULONG64 FrameMarker)
{
    DBG_ASSERT(Reg >= INTR32 && Reg <= INTR127);

    ULONG SorGr = (ULONG)IA64_FM_SOR(FrameMarker) * 8;

    // Rotation only occurs within the defined rotating area.
    if ((Reg - INTR32) >= SorGr)
    {
        return Reg;
    }

    ULONG Rot = (ULONG)IA64_FM_RRB_GR(FrameMarker) % SorGr;
    if (!Rot)
    {
        return Reg;
    }

    return ((Reg - INTR32) + Rot) % SorGr + INTR32;
}

ULONG
RotateFr(ULONG Reg, ULONG64 FrameMarker)
{
    // The size of the rotating FP area is fixed.
    const ULONG SorFr = 96;
    ULONG Rot = (ULONG)IA64_FM_RRB_FR(FrameMarker) % SorFr;
    
    // Rotation only occurs within the defined rotating area.
    if (!Rot || Reg < FLTF32)
    {
        return Reg;
    }

    DBG_ASSERT(Reg <= FLTF127);

    // FP register indices are padded with duplicates to
    // make context indexing by 64-bits work out, so
    // condense and reexpand when rotating.
    return ((Reg - FLTF32) / 2 + Rot) % SorFr * 2 + FLTF32;
}

ULONG64
RotatePr(ULONG64 Val, ULONG64 FrameMarker, BOOL Get)
{
    // The size of the rotating predicate area is fixed.
    const ULONG SorPr = 48;
    ULONG64 FixedBits;
    ULONG64 RotBits;
    ULONG Rot;
    ULONG64 MaskLow, MaskHigh;
    
    Rot = (ULONG)IA64_FM_RRB_PR(FrameMarker) % SorPr;
    if (!Rot)
    {
        return Val;
    }
    
    FixedBits = Val & 0xffff;
    RotBits = Val >> 16;
    if (Get)
    {
        //
        // Rotate bits from underlying positions into rotated positions.
        // This is a rotate-to-lower-bit-position by Rot.
        //
        
        MaskLow = (1UI64 << Rot) - 1;
        MaskHigh = ((1UI64 << SorPr) - 1) & ~MaskLow;
        return FixedBits |
            ((((RotBits & MaskLow) << (SorPr - Rot)) |
              ((RotBits & MaskHigh) >> Rot)) << 16);
    }
    else
    {
        //
        // Rotate bits from rotated positions into underlying positions.
        // This is a rotate-to-higher-bit-position by Rot.
        //
        
        MaskHigh = ((1UI64 << Rot) - 1) << (SorPr - Rot);
        MaskLow = ((1UI64 << SorPr) - 1) & ~MaskHigh;
        return FixedBits |
            ((((RotBits & MaskLow) << Rot) |
              ((RotBits & MaskHigh) >> (SorPr - Rot))) << 16);
    }
}

Ia64MachineInfo::Ia64MachineInfo(TargetInfo* Target)
    : MachineInfo(Target)
{
    m_FullName = "Intel IA64";
    m_AbbrevName = "ia64";
    m_PageSize = IA64_PAGE_SIZE;
    m_PageShift = IA64_PAGE_SHIFT;
    m_NumExecTypes = 2;
    m_ExecTypes = g_Ia64ExecTypes;
    m_Ptr64 = TRUE;
    m_RetRegIndex = INTV0;
    
    m_AllMask = REGALL_INT64 | REGALL_DREG,
        
    m_MaxDataBreakpoints = IA64_REG_MAX_DATA_BREAKPOINTS;
    m_SymPrefix = NULL;

    m_SizeCanonicalContext = sizeof(IA64_CONTEXT);
    m_SverCanonicalContext = NT_SVER_XP;

    m_CvRegMapSize = DIMA(g_Ia64CvRegMap);
    m_CvRegMap = g_Ia64CvRegMap;
    
    m_KernPageDir = 0;
    m_IfsOverride = 0;
    m_BspOverride = 0;
}

HRESULT
Ia64MachineInfo::Initialize(void)
{
    m_Groups[0] = &g_Ia64BaseGroup;
    m_NumGroups = 1;
    if (IS_KERNEL_TARGET(m_Target))
    {
        m_Groups[m_NumGroups] = &g_Ia64KernelGroup;
        m_NumGroups++;
    }

    return MachineInfo::Initialize();
}

void
Ia64MachineInfo::GetSystemTypeInfo(PSYSTEM_TYPE_INFO Info)
{
    Info->TriagePrcbOffset = IA64_TRIAGE_PRCB_ADDRESS;
    Info->SizeTargetContext = sizeof(IA64_CONTEXT);
    Info->OffsetTargetContextFlags = FIELD_OFFSET(IA64_CONTEXT, ContextFlags);
    Info->SizeControlReport = sizeof(IA64_DBGKD_CONTROL_REPORT);
    Info->OffsetSpecialRegisters = IA64_DEBUG_CONTROL_SPACE_KSPECIAL;
    Info->SizeKspecialRegisters = sizeof(IA64_KSPECIAL_REGISTERS);
    Info->SizePageFrameNumber = sizeof(ULONG64);
    Info->SizePte = sizeof(ULONG64);
    Info->SizeDynamicFunctionTable = sizeof(IA64_DYNAMIC_FUNCTION_TABLE);
    Info->SizeRuntimeFunction = sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY);

    Info->SharedUserDataOffset = 0;
    Info->UmSharedUserDataOffset = 0;
    Info->UmSharedSysCallOffset = 0;
    Info->UmSharedSysCallSize = 0;
    if (m_Target->m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        Info->SharedUserDataOffset = IS_KERNEL_TARGET(m_Target) ?
            IA64_KI_USER_SHARED_DATA : MM_SHARED_USER_DATA_VA;
        Info->UmSharedUserDataOffset = MM_SHARED_USER_DATA_VA;
    }
}

void
Ia64MachineInfo::GetDefaultKdData(PKDDEBUGGER_DATA64 KdData)
{
    //
    // Parts of the data block may already be filled out
    // so don't destroy anything that's already set.
    //

    // The MmVirtualTranslationBase field was added post-XP.
    // The address used for Merced XP is well-known, though,
    // so set the appropriate constant.  We aren't actually
    // checking for Merced because the processor ID isn't
    // initialized and can't be initialized until KiProcessorBlock
    // is located, which is long after this.
    if (!KdData->MmVirtualTranslationBase)
    {
        KdData->MmVirtualTranslationBase = 0x1ffffe0000000000;
    }

    if (!KdData->OffsetKThreadApcProcess)
    {
        KdData->SizePrcb = IA64_KPRCB_SIZE;
        KdData->OffsetKThreadInitialStack = IA64_KTHREAD_INITSTACK_OFFSET;
        KdData->OffsetEprocessPeb = IA64_PEB_IN_EPROCESS;
        KdData->OffsetKThreadApcProcess = IA64_KTHREAD_APCPROCESS_OFFSET;
        KdData->OffsetKThreadTeb = IA64_KTHREAD_TEB_OFFSET;
        KdData->OffsetKThreadKernelStack = IA64_KTHREAD_KERNELSTACK_OFFSET;
        KdData->OffsetKThreadState = IA64_KTHREAD_STATE_OFFSET;
        KdData->OffsetKThreadNextProcessor = IA64_KTHREAD_NEXTPROCESSOR_OFFSET;
        KdData->OffsetKThreadBStore = IA64_KTHREAD_BSTORE_OFFSET;
        KdData->OffsetKThreadBStoreLimit = IA64_KTHREAD_BSTORELIMIT_OFFSET;
        KdData->OffsetEprocessParentCID = IA64_PCID_IN_EPROCESS;
        KdData->OffsetEprocessDirectoryTableBase =
            IA64_DIRECTORY_TABLE_BASE_IN_EPROCESS;
        KdData->SizeEProcess = IA64_EPROCESS_SIZE;

        KdData->SizePrcb = IA64_KPRCB_SIZE;
        KdData->OffsetPrcbCurrentThread = DEF_KPRCB_CURRENT_THREAD_OFFSET_64;
        KdData->OffsetPrcbMhz = IA64_2462_KPRCB_MHZ;
        KdData->OffsetPrcbCpuType = IA64_KPRCB_PROCESSOR_MODEL;
        KdData->OffsetPrcbVendorString = IA64_KPRCB_VENDOR_STRING;
        KdData->OffsetPrcbProcStateContext = IA64_KPRCB_CONTEXT;
        KdData->OffsetPrcbNumber = IA64_KPRCB_NUMBER;
        KdData->SizeEThread = IA64_ETHREAD_SIZE;

        if (m_Target->m_BuildNumber > 3558)
        {
            KdData->OffsetEprocessPeb =
                IA64_3555_PEB_IN_EPROCESS;
            KdData->OffsetKThreadApcProcess =
                IA64_3555_KTHREAD_APCPROCESS_OFFSET;
            KdData->OffsetKThreadTeb =
                IA64_3555_KTHREAD_TEB_OFFSET;
            KdData->OffsetKThreadKernelStack =
                IA64_3555_KTHREAD_KERNELSTACK_OFFSET;
            KdData->OffsetKThreadState =
                IA64_3555_KTHREAD_STATE_OFFSET;
            KdData->OffsetKThreadNextProcessor =
                IA64_3555_KTHREAD_NEXTPROCESSOR_OFFSET;
            KdData->OffsetKThreadBStore =
                IA64_3555_KTHREAD_BSTORE_OFFSET;
            KdData->OffsetKThreadBStoreLimit =
                IA64_3555_KTHREAD_BSTORELIMIT_OFFSET;
            KdData->SizeEThread =
                IA64_3555_ETHREAD_SIZE;
        }
    }

    if (!KdData->SizePcr)
    {
        KdData->SizePcr = IA64_KPCR_SIZE;
        KdData->OffsetPcrSelfPcr = 0;
        KdData->OffsetPcrCurrentPrcb = IA64_KPCR_PRCB;
        KdData->OffsetPcrContainedPrcb = 0;
        KdData->OffsetPcrInitialBStore = IA64_KPCR_INITIAL_BSTORE;
        KdData->OffsetPcrBStoreLimit = IA64_KPCR_BSTORE_LIMIT;
        KdData->OffsetPcrInitialStack = IA64_KPCR_INITIAL_STACK;
        KdData->OffsetPcrStackLimit = IA64_KPCR_STACK_LIMIT;
        KdData->OffsetPrcbPcrPage = IA64_KPRCB_PCR_PAGE;
        KdData->OffsetPrcbProcStateSpecialReg = IA64_KPRCB_SPECIAL_REG;
    }
}

void
Ia64MachineInfo::
InitializeContext(ULONG64 Pc,
                  PDBGKD_ANY_CONTROL_REPORT ControlReport)
{
    if (Pc)
    {
        ULONG Slot;

        m_ContextState = MCTX_PC;
        Slot = (ULONG)(Pc & 0xc) >> 2;
        m_Context.IA64Context.StIIP = Pc & ~(0xf);
        m_Context.IA64Context.StIPSR &= ~(IPSR_RI_MASK);
        m_Context.IA64Context.StIPSR |=  (ULONGLONG)Slot << PSR_RI;
    }
    else
    {
        m_Context.IA64Context.StIIP = Pc;
    }

    if (Pc && ControlReport != NULL)
    {
        CacheReportInstructions
            (Pc, ControlReport->IA64ControlReport.InstructionCount,
             ControlReport->IA64ControlReport.InstructionStream);
    }
}

HRESULT
Ia64MachineInfo::KdGetContextState(ULONG State)
{
    HRESULT Status;
        
    if (State >= MCTX_CONTEXT && m_ContextState < MCTX_CONTEXT)
    {
        Status = m_Target->GetContext(m_Target->m_RegContextThread->m_Handle,
                                      &m_Context);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_CONTEXT;
    }
    
    if (State >= MCTX_FULL && m_ContextState < MCTX_FULL)
    {
        Status = m_Target->GetTargetSpecialRegisters
            (m_Target->m_RegContextThread->m_Handle,
             (PCROSS_PLATFORM_KSPECIAL_REGISTERS)&m_Special.IA64Special);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_FULL;
    }

    return S_OK;
}

HRESULT
Ia64MachineInfo::KdSetContext(void)
{
    HRESULT Status;

    // XP's kernel checks the context DBD and DBI registers
    // to see if it should be setting IPSR.DB.  It needs to
    // check the special registers instead, as that's where
    // the kernel-specific settings are.  The context controls
    // the user mode state.  Just copy over the
    // user state so that kernel processor breakpoints work.
    // The kernel was fixed for XP server and is not necessary.
    if (m_Target->m_BuildNumber < 3555)
    {
        memcpy(&m_Context.IA64Context.DbI0, &m_Special.IA64Special.KernelDbI0,
               16 * sizeof(ULONG64));
    }
    
    Status = m_Target->SetContext(m_Target->m_RegContextThread->m_Handle,
                                  &m_Context);
    if (Status != S_OK)
    {
        return Status;
    }

    Status = m_Target->SetTargetSpecialRegisters
        (m_Target->m_RegContextThread->m_Handle,
         (PCROSS_PLATFORM_KSPECIAL_REGISTERS)&m_Special.IA64Special);
    if (Status != S_OK)
    {
        return Status;
    }

    return S_OK;
}

HRESULT
Ia64MachineInfo::ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                    ULONG FromSver, ULONG FromSize, PVOID From)
{
    if (FromSize < sizeof(IA64_CONTEXT))
    {
        return E_INVALIDARG;
    }

    memcpy(Context, From, sizeof(IA64_CONTEXT));
    return S_OK;
}

HRESULT
Ia64MachineInfo::ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                  ULONG ToSver, ULONG ToSize, PVOID To)
{
    if (ToSize < sizeof(IA64_CONTEXT))
    {
        return E_INVALIDARG;
    }

    memcpy(To, Context, sizeof(IA64_CONTEXT));
    return S_OK;
}

void
Ia64MachineInfo::InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version)
{
    Context->IA64Context.ContextFlags =
        IA64_CONTEXT_FULL | IA64_CONTEXT_DEBUG;
}

HRESULT
Ia64MachineInfo::GetContextFromThreadStack(ULONG64 ThreadBase,
                                           PCROSS_PLATFORM_CONTEXT Context,
                                           ULONG64 Stack)
{
    HRESULT Status;
    IA64_KSWITCH_FRAME SwitchFrame;

    if ((Status = m_Target->ReadAllVirtual(m_Target->m_ProcessHead,
                                           Stack +
                                           IA64_STACK_SCRATCH_AREA, 
                                           &SwitchFrame, 
                                           sizeof(SwitchFrame))) != S_OK)
    {
        return Status;
    }

    ZeroMemory(Context, sizeof(*Context));
    
    Context->IA64Context.IntSp = Stack;
    Context->IA64Context.Preds = SwitchFrame.SwitchPredicates;
    Context->IA64Context.StIIP = SwitchFrame.SwitchRp;
    Context->IA64Context.StFPSR = SwitchFrame.SwitchFPSR;
    Context->IA64Context.BrRp = SwitchFrame.SwitchRp;
    Context->IA64Context.RsPFS = SwitchFrame.SwitchPFS;
    Context->IA64Context.StIFS = SwitchFrame.SwitchPFS;

    SHORT BsFrameSize = 
        (SHORT)(SwitchFrame.SwitchPFS >> IA64_PFS_SIZE_SHIFT) & 
        IA64_PFS_SIZE_MASK;
    SHORT TempFrameSize = 
        BsFrameSize - (SHORT)((SwitchFrame.SwitchBsp >> 3) & 
                              IA64_NAT_BITS_PER_RNAT_REG);

    while (TempFrameSize > 0) 
    {
        BsFrameSize++;
        TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
    } 

    Context->IA64Context.RsBSP = 
        SwitchFrame.SwitchBsp - (BsFrameSize * sizeof(ULONGLONG));

    Context->IA64Context.FltS0 = SwitchFrame.SwitchExceptionFrame.FltS0;
    Context->IA64Context.FltS1 = SwitchFrame.SwitchExceptionFrame.FltS1;
    Context->IA64Context.FltS2 = SwitchFrame.SwitchExceptionFrame.FltS2;
    Context->IA64Context.FltS3 = SwitchFrame.SwitchExceptionFrame.FltS3;
    Context->IA64Context.FltS4 = SwitchFrame.SwitchExceptionFrame.FltS4;
    Context->IA64Context.FltS5 = SwitchFrame.SwitchExceptionFrame.FltS5;
    Context->IA64Context.FltS6 = SwitchFrame.SwitchExceptionFrame.FltS6;
    Context->IA64Context.FltS7 = SwitchFrame.SwitchExceptionFrame.FltS7;
    Context->IA64Context.FltS8 = SwitchFrame.SwitchExceptionFrame.FltS8;
    Context->IA64Context.FltS9 = SwitchFrame.SwitchExceptionFrame.FltS9;
    Context->IA64Context.FltS10 = SwitchFrame.SwitchExceptionFrame.FltS10;
    Context->IA64Context.FltS11 = SwitchFrame.SwitchExceptionFrame.FltS11;
    Context->IA64Context.FltS12 = SwitchFrame.SwitchExceptionFrame.FltS12;
    Context->IA64Context.FltS13 = SwitchFrame.SwitchExceptionFrame.FltS13;
    Context->IA64Context.FltS14 = SwitchFrame.SwitchExceptionFrame.FltS14;
    Context->IA64Context.FltS15 = SwitchFrame.SwitchExceptionFrame.FltS15;
    Context->IA64Context.FltS16 = SwitchFrame.SwitchExceptionFrame.FltS16;
    Context->IA64Context.FltS17 = SwitchFrame.SwitchExceptionFrame.FltS17;
    Context->IA64Context.FltS18 = SwitchFrame.SwitchExceptionFrame.FltS18;
    Context->IA64Context.FltS19 = SwitchFrame.SwitchExceptionFrame.FltS19;
    Context->IA64Context.IntS0 = SwitchFrame.SwitchExceptionFrame.IntS0;
    Context->IA64Context.IntS1 = SwitchFrame.SwitchExceptionFrame.IntS1;
    Context->IA64Context.IntS2 = SwitchFrame.SwitchExceptionFrame.IntS2;
    Context->IA64Context.IntS3 = SwitchFrame.SwitchExceptionFrame.IntS3;
    Context->IA64Context.IntNats = SwitchFrame.SwitchExceptionFrame.IntNats;
    Context->IA64Context.BrS0 = SwitchFrame.SwitchExceptionFrame.BrS0;
    Context->IA64Context.BrS1 = SwitchFrame.SwitchExceptionFrame.BrS1;
    Context->IA64Context.BrS2 = SwitchFrame.SwitchExceptionFrame.BrS2;
    Context->IA64Context.BrS3 = SwitchFrame.SwitchExceptionFrame.BrS3;
    Context->IA64Context.BrS4 = SwitchFrame.SwitchExceptionFrame.BrS4;
    Context->IA64Context.ApEC = SwitchFrame.SwitchExceptionFrame.ApEC;
    Context->IA64Context.ApLC = SwitchFrame.SwitchExceptionFrame.ApLC;

    return S_OK;
}

HRESULT
Ia64MachineInfo::GetContextFromFiber(ProcessInfo* Process,
                                     ULONG64 FiberBase,
                                     PCROSS_PLATFORM_CONTEXT Context,
                                     BOOL Verbose)
{
    HRESULT Status;
    IA64_FIBER Fiber;

    if ((Status = m_Target->
         ReadAllVirtual(Process, FiberBase, &Fiber, sizeof(Fiber))) != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Unable to read fiber data at %s\n",
                   FormatMachineAddr64(this, FiberBase));
        }
        return Status;
    }

    if ((Status = ConvertContextFrom(Context, m_Target->m_SystemVersion,
                                     m_Target->m_TypeInfo.SizeTargetContext,
                                     &Fiber.FiberContext)) != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Unable to convert context to canonical form\n");
        }
        return Status;
    }

    if (Verbose)
    {
        dprintf("Fiber at %s  Fiber data: %s\n",
                FormatMachineAddr64(this, FiberBase),
                FormatMachineAddr64(this, Fiber.FiberData));
        dprintf("  Stack base: %s  Stack limit: %s\n",
                FormatMachineAddr64(this, Fiber.StackBase),
                FormatMachineAddr64(this, Fiber.StackLimit));
        dprintf("  Backing store base: %s  Backing store limit: %s\n",
                FormatMachineAddr64(this, Fiber.DeallocationBStore),
                FormatMachineAddr64(this, Fiber.BStoreLimit));
    }
    
    return S_OK;
}

HRESULT
Ia64MachineInfo::GetContextFromTrapFrame(ULONG64 TrapBase,
                                         PCROSS_PLATFORM_CONTEXT Context,
                                         BOOL Verbose)
{
    HRESULT Status;
    IA64_KTRAP_FRAME TrapContents;
    DWORD64 Bsp;
    ULONG SizeOfFrame;
    SHORT temp;

    if ((Status = m_Target->ReadAllVirtual(m_Target->m_ProcessHead,
                                           TrapBase, &TrapContents,
                                           sizeof(TrapContents))) != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Unable to read trap frame at %s\n",
                   FormatMachineAddr64(this, TrapBase));
        }
        return Status;
    }

    SizeOfFrame = (ULONG)(TrapContents.StIFS & (IA64_PFS_SIZE_MASK));

    if (TrapContents.PreviousMode == 1 /*UserMode*/)
    {
        ULONG64 RsBSPSTORE = TrapContents.RsBSPSTORE;

        //
        // Calculate where the stacked registers are for the function which trapped.  
        // The regisisters are stored in the kernel backing store notCalculated the users.  
        // First calculate the start of the kernel store based on trap address, since 
        // this is a user mode trap we should start at the begining of the kernel stack
        // so just round up the trap address to a page size.  Next calculate the actual 
        // BSP for the function.  This depends on the  BSP and BSPstore at the time of
        // the trap.  Note that the trap handle start the kernel backing store on the 
        // same alignment as the user's BSPstore.  
        // 

        //Calculated
        // Round trap address to a page boundary. The should be the Initial kernel BSP.
        //

        Bsp = (TrapBase + IA64_PAGE_SIZE - 1) & ~(DWORD64)(IA64_PAGE_SIZE - 1);

        //
        // Start the actual stack on the same bountry as the users.
        //

        Bsp += RsBSPSTORE & IA64_RNAT_ALIGNMENT;

        //
        // The BSP of the trap handler is right after all the user values have been
        // saved.  The unsaved user values is the differenc of BSP and BSPStore.
        //

        Bsp += TrapContents.RsBSP - RsBSPSTORE;
    }
    else
    {
        //
        // For kernel mode the actual BSP is saved.
        //

        Bsp = TrapContents.RsBSP;
    }

    //
    //  Now backup by the size of the faulting functions frame.
    //

    Bsp -= (SizeOfFrame * sizeof(ULONGLONG));

    //
    // Adjust for saved RNATs
    //

    temp = (SHORT)(Bsp >> 3) & IA64_NAT_BITS_PER_RNAT_REG;
    temp += (SHORT)SizeOfFrame - IA64_NAT_BITS_PER_RNAT_REG;
    while (temp >= 0)
    {
        Bsp -= sizeof(ULONGLONG);
        temp -= IA64_NAT_BITS_PER_RNAT_REG;
    }

    ZeroMemory(Context, sizeof(*Context));
    
#define CPCXT(Fld) Context->IA64Context.Fld = TrapContents.Fld

    CPCXT(BrRp); CPCXT(BrT0); CPCXT(BrT1);

    CPCXT(FltT0); CPCXT(FltT1); CPCXT(FltT2); CPCXT(FltT3); CPCXT(FltT4);
    CPCXT(FltT5); CPCXT(FltT6); CPCXT(FltT7); CPCXT(FltT8); CPCXT(FltT9);

    CPCXT(ApUNAT); CPCXT(ApCCV); CPCXT(ApDCR); CPCXT(Preds); 

    CPCXT(RsRSC); CPCXT(RsRNAT); CPCXT(RsBSPSTORE); CPCXT(RsBSP); CPCXT(RsPFS);

    CPCXT(StIPSR); CPCXT(StIIP); CPCXT(StIFS); CPCXT(StFPSR);
    CPCXT(IntSp);  CPCXT(IntGp); CPCXT(IntV0); CPCXT(IntTeb); CPCXT(IntNats);

    CPCXT(IntT0);  CPCXT(IntT1);  CPCXT(IntT2);  CPCXT(IntT3);  CPCXT(IntT4);  
    CPCXT(IntT5);  CPCXT(IntT6);  CPCXT(IntT7);  CPCXT(IntT8);  CPCXT(IntT9);  
    CPCXT(IntT10); CPCXT(IntT11); CPCXT(IntT12); CPCXT(IntT13); CPCXT(IntT14);
    CPCXT(IntT15); CPCXT(IntT16); CPCXT(IntT17); CPCXT(IntT18); CPCXT(IntT19);
    CPCXT(IntT20); CPCXT(IntT21); CPCXT(IntT22); 

    Context->IA64Context.RsBSP = Bsp; // Store the real Bsp
#undef CPCXT

    return S_OK;
}

void 
Ia64MachineInfo::GetScopeFrameFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                          PDEBUG_STACK_FRAME ScopeFrame)
{
    ZeroMemory(ScopeFrame, sizeof(*ScopeFrame));
    ScopeFrame->InstructionOffset = Context->IA64Context.StIIP;
    ScopeFrame->StackOffset       = Context->IA64Context.IntSp;
    ScopeFrame->FrameOffset       = Context->IA64Context.RsBSP;
}

HRESULT
Ia64MachineInfo::GetScopeFrameRegister(ULONG Reg,
                                       PDEBUG_STACK_FRAME ScopeFrame,
                                       PULONG64 Value)
{
    HRESULT Status;
    REGVAL RegVal;
    
    switch(Reg)
    {
    case INTSP:
        *Value = ScopeFrame->StackOffset;
        return S_OK;
    case RSBSP:
        *Value = ScopeFrame->FrameOffset;
        return S_OK;
    case STIFS:
        *Value = IA64_SAVE_IFS(ScopeFrame);
        return S_OK;
    default:
        m_IfsOverride = IA64_SAVE_IFS(ScopeFrame);
        m_BspOverride = ScopeFrame->FrameOffset;
        
        Status = FullGetVal(Reg, &RegVal);
        
        m_IfsOverride = 0;
        m_BspOverride = 0;
        
        if (Status != S_OK)
        {
            return Status;
        }
        *Value = RegVal.I64;
        return S_OK;
    }
}

HRESULT
Ia64MachineInfo::SetScopeFrameRegister(ULONG Reg,
                                       PDEBUG_STACK_FRAME ScopeFrame,
                                       ULONG64 Value)
{
    REGVAL RegVal;
    HRESULT Status;
    
    switch(Reg)
    {
    case INTSP:
        ScopeFrame->StackOffset = Value;
        return S_OK;
    case RSBSP:
        ScopeFrame->FrameOffset = Value;
        return S_OK;
    case STIFS:
        IA64_SAVE_IFS(ScopeFrame) = Value;
        return S_OK;
    default:
        m_IfsOverride = IA64_SAVE_IFS(ScopeFrame);
        m_BspOverride = ScopeFrame->FrameOffset;
        
        RegVal.Type = GetType(Reg);
        RegVal.I64 = Value;
        Status = FullSetVal(Reg, &RegVal);
        
        m_IfsOverride = 0;
        m_BspOverride = 0;
        return Status;
    }
}

HRESULT
Ia64MachineInfo::GetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context,
                                EXDI_CONTEXT_TYPE CtxType)
{
    DBG_ASSERT(CtxType == EXDI_CTX_IA64);

    // Always ask for everything.
    Context->IA64Context.RegGroupSelection.fIntegerRegs = TRUE;
    Context->IA64Context.RegGroupSelection.fBranchRegs = TRUE;
    Context->IA64Context.RegGroupSelection.fLowFloatRegs = TRUE;
    Context->IA64Context.RegGroupSelection.fHighFloatRegs = TRUE;
    Context->IA64Context.RegGroupSelection.fDebugRegs = TRUE;
    Context->IA64Context.RegGroupSelection.fControlRegs = TRUE;
    Context->IA64Context.RegGroupSelection.fSystemRegs = TRUE;
    return ((IeXdiIA64Context*)Exdi)->GetContext(&Context->IA64Context);
}

HRESULT
Ia64MachineInfo::SetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context,
                                EXDI_CONTEXT_TYPE CtxType)
{
    DBG_ASSERT(CtxType == EXDI_CTX_IA64);
    // Don't change the existing group selections on the assumption
    // that there was a full get prior to any modifications so
    // all groups are valid.
    return ((IeXdiIA64Context*)Exdi)->SetContext(Context->IA64Context);
}

void
Ia64MachineInfo::ConvertExdiContextFromContext
    (PCROSS_PLATFORM_CONTEXT Context, PEXDI_CONTEXT ExdiContext,
     EXDI_CONTEXT_TYPE CtxType)
{
    DBG_ASSERT(CtxType == EXDI_CTX_IA64);

    if (Context->IA64Context.ContextFlags & IA64_CONTEXT_INTEGER)
    {
        ExdiContext->IA64Context.IntR1 = Context->IA64Context.IntGp;
        ExdiContext->IA64Context.IntR2 = Context->IA64Context.IntT0;
        ExdiContext->IA64Context.IntR3 = Context->IA64Context.IntT1;
        ExdiContext->IA64Context.IntR4 = Context->IA64Context.IntS0;
        ExdiContext->IA64Context.IntR5 = Context->IA64Context.IntS1;
        ExdiContext->IA64Context.IntR6 = Context->IA64Context.IntS2;
        ExdiContext->IA64Context.IntR7 = Context->IA64Context.IntS3;
        ExdiContext->IA64Context.IntR8 = Context->IA64Context.IntV0;
        ExdiContext->IA64Context.IntR9 = Context->IA64Context.IntT2;
        ExdiContext->IA64Context.IntR10 = Context->IA64Context.IntT3;
        ExdiContext->IA64Context.IntR11 = Context->IA64Context.IntT4;
        ExdiContext->IA64Context.IntR12 = Context->IA64Context.IntSp;
        ExdiContext->IA64Context.IntR13 = Context->IA64Context.IntTeb;
        ExdiContext->IA64Context.IntR14 = Context->IA64Context.IntT5;
        ExdiContext->IA64Context.IntR15 = Context->IA64Context.IntT6;
        ExdiContext->IA64Context.IntR16 = Context->IA64Context.IntT7;
        ExdiContext->IA64Context.IntR17 = Context->IA64Context.IntT8;
        ExdiContext->IA64Context.IntR18 = Context->IA64Context.IntT9;
        ExdiContext->IA64Context.IntR19 = Context->IA64Context.IntT10;
        ExdiContext->IA64Context.IntR20 = Context->IA64Context.IntT11;
        ExdiContext->IA64Context.IntR21 = Context->IA64Context.IntT12;
        ExdiContext->IA64Context.IntR22 = Context->IA64Context.IntT13;
        ExdiContext->IA64Context.IntR23 = Context->IA64Context.IntT14;
        ExdiContext->IA64Context.IntR24 = Context->IA64Context.IntT15;
        ExdiContext->IA64Context.IntR25 = Context->IA64Context.IntT16;
        ExdiContext->IA64Context.IntR26 = Context->IA64Context.IntT17;
        ExdiContext->IA64Context.IntR27 = Context->IA64Context.IntT18;
        ExdiContext->IA64Context.IntR28 = Context->IA64Context.IntT19;
        ExdiContext->IA64Context.IntR29 = Context->IA64Context.IntT20;
        ExdiContext->IA64Context.IntR30 = Context->IA64Context.IntT21;
        ExdiContext->IA64Context.IntR31 = Context->IA64Context.IntT22;
        ExdiContext->IA64Context.IntNats = Context->IA64Context.IntNats;
        ExdiContext->IA64Context.Preds = Context->IA64Context.Preds;
        ExdiContext->IA64Context.Br0 = Context->IA64Context.BrRp;
        ExdiContext->IA64Context.Br1 = Context->IA64Context.BrS0;
        ExdiContext->IA64Context.Br2 = Context->IA64Context.BrS1;
        ExdiContext->IA64Context.Br3 = Context->IA64Context.BrS2;
        ExdiContext->IA64Context.Br4 = Context->IA64Context.BrS3;
        ExdiContext->IA64Context.Br5 = Context->IA64Context.BrS4;
        ExdiContext->IA64Context.Br6 = Context->IA64Context.BrT0;
        ExdiContext->IA64Context.Br7 = Context->IA64Context.BrT1;
    }
    
    if (Context->IA64Context.ContextFlags & IA64_CONTEXT_LOWER_FLOATING_POINT)
    {
        ExdiContext->IA64Context.StFPSR = Context->IA64Context.StFPSR;
        ExdiContext->IA64Context.FltF2 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS0;
        ExdiContext->IA64Context.FltF3 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS1;
        ExdiContext->IA64Context.FltF4 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS2;
        ExdiContext->IA64Context.FltF5 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS3;
        ExdiContext->IA64Context.FltF6 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltT0;
        ExdiContext->IA64Context.FltF7 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltT1;
        ExdiContext->IA64Context.FltF8 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltT2;
        ExdiContext->IA64Context.FltF9 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltT3;
        ExdiContext->IA64Context.FltF10 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltT4;
        ExdiContext->IA64Context.FltF11 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltT5;
        ExdiContext->IA64Context.FltF12 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltT6;
        ExdiContext->IA64Context.FltF13 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltT7;
        ExdiContext->IA64Context.FltF14 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltT8;
        ExdiContext->IA64Context.FltF15 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltT9;
    }

    if (Context->IA64Context.ContextFlags &
        IA64_CONTEXT_HIGHER_FLOATING_POINT)
    {
        ExdiContext->IA64Context.StFPSR = Context->IA64Context.StFPSR;
        ExdiContext->IA64Context.FltF16 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS4;
        ExdiContext->IA64Context.FltF17 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS5;
        ExdiContext->IA64Context.FltF18 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS6;
        ExdiContext->IA64Context.FltF19 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS7;
        ExdiContext->IA64Context.FltF20 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS8;
        ExdiContext->IA64Context.FltF21 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS9;
        ExdiContext->IA64Context.FltF22 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS10;
        ExdiContext->IA64Context.FltF23 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS11;
        ExdiContext->IA64Context.FltF24 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS12;
        ExdiContext->IA64Context.FltF25 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS13;
        ExdiContext->IA64Context.FltF26 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS14;
        ExdiContext->IA64Context.FltF27 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS15;
        ExdiContext->IA64Context.FltF28 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS16;
        ExdiContext->IA64Context.FltF29 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS17;
        ExdiContext->IA64Context.FltF30 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS18;
        ExdiContext->IA64Context.FltF31 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltS19;
        ExdiContext->IA64Context.FltF32 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF32;
        ExdiContext->IA64Context.FltF33 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF33;
        ExdiContext->IA64Context.FltF34 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF34;
        ExdiContext->IA64Context.FltF35 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF35;
        ExdiContext->IA64Context.FltF36 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF36;
        ExdiContext->IA64Context.FltF37 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF37;
        ExdiContext->IA64Context.FltF38 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF38;
        ExdiContext->IA64Context.FltF39 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF39;
        ExdiContext->IA64Context.FltF40 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF40;
        ExdiContext->IA64Context.FltF41 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF41;
        ExdiContext->IA64Context.FltF42 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF42;
        ExdiContext->IA64Context.FltF43 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF43;
        ExdiContext->IA64Context.FltF44 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF44;
        ExdiContext->IA64Context.FltF45 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF45;
        ExdiContext->IA64Context.FltF46 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF46;
        ExdiContext->IA64Context.FltF47 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF47;
        ExdiContext->IA64Context.FltF48 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF48;
        ExdiContext->IA64Context.FltF49 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF49;
        ExdiContext->IA64Context.FltF50 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF50;
        ExdiContext->IA64Context.FltF51 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF51;
        ExdiContext->IA64Context.FltF52 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF52;
        ExdiContext->IA64Context.FltF53 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF53;
        ExdiContext->IA64Context.FltF54 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF54;
        ExdiContext->IA64Context.FltF55 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF55;
        ExdiContext->IA64Context.FltF56 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF56;
        ExdiContext->IA64Context.FltF57 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF57;
        ExdiContext->IA64Context.FltF58 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF58;
        ExdiContext->IA64Context.FltF59 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF59;
        ExdiContext->IA64Context.FltF60 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF60;
        ExdiContext->IA64Context.FltF61 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF61;
        ExdiContext->IA64Context.FltF62 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF62;
        ExdiContext->IA64Context.FltF63 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF63;
        ExdiContext->IA64Context.FltF64 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF64;
        ExdiContext->IA64Context.FltF65 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF65;
        ExdiContext->IA64Context.FltF66 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF66;
        ExdiContext->IA64Context.FltF67 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF67;
        ExdiContext->IA64Context.FltF68 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF68;
        ExdiContext->IA64Context.FltF69 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF69;
        ExdiContext->IA64Context.FltF70 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF70;
        ExdiContext->IA64Context.FltF71 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF71;
        ExdiContext->IA64Context.FltF72 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF72;
        ExdiContext->IA64Context.FltF73 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF73;
        ExdiContext->IA64Context.FltF74 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF74;
        ExdiContext->IA64Context.FltF75 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF75;
        ExdiContext->IA64Context.FltF76 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF76;
        ExdiContext->IA64Context.FltF77 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF77;
        ExdiContext->IA64Context.FltF78 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF78;
        ExdiContext->IA64Context.FltF79 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF79;
        ExdiContext->IA64Context.FltF80 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF80;
        ExdiContext->IA64Context.FltF81 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF81;
        ExdiContext->IA64Context.FltF82 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF82;
        ExdiContext->IA64Context.FltF83 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF83;
        ExdiContext->IA64Context.FltF84 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF84;
        ExdiContext->IA64Context.FltF85 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF85;
        ExdiContext->IA64Context.FltF86 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF86;
        ExdiContext->IA64Context.FltF87 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF87;
        ExdiContext->IA64Context.FltF88 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF88;
        ExdiContext->IA64Context.FltF89 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF89;
        ExdiContext->IA64Context.FltF90 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF90;
        ExdiContext->IA64Context.FltF91 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF91;
        ExdiContext->IA64Context.FltF92 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF92;
        ExdiContext->IA64Context.FltF93 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF93;
        ExdiContext->IA64Context.FltF94 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF94;
        ExdiContext->IA64Context.FltF95 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF95;
        ExdiContext->IA64Context.FltF96 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF96;
        ExdiContext->IA64Context.FltF97 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF97;
        ExdiContext->IA64Context.FltF98 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF98;
        ExdiContext->IA64Context.FltF99 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF99;
        ExdiContext->IA64Context.FltF100 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF100;
        ExdiContext->IA64Context.FltF101 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF101;
        ExdiContext->IA64Context.FltF102 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF102;
        ExdiContext->IA64Context.FltF103 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF103;
        ExdiContext->IA64Context.FltF104 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF104;
        ExdiContext->IA64Context.FltF105 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF105;
        ExdiContext->IA64Context.FltF106 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF106;
        ExdiContext->IA64Context.FltF107 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF107;
        ExdiContext->IA64Context.FltF108 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF108;
        ExdiContext->IA64Context.FltF109 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF109;
        ExdiContext->IA64Context.FltF110 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF110;
        ExdiContext->IA64Context.FltF111 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF111;
        ExdiContext->IA64Context.FltF112 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF112;
        ExdiContext->IA64Context.FltF113 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF113;
        ExdiContext->IA64Context.FltF114 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF114;
        ExdiContext->IA64Context.FltF115 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF115;
        ExdiContext->IA64Context.FltF116 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF116;
        ExdiContext->IA64Context.FltF117 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF117;
        ExdiContext->IA64Context.FltF118 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF118;
        ExdiContext->IA64Context.FltF119 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF119;
        ExdiContext->IA64Context.FltF120 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF120;
        ExdiContext->IA64Context.FltF121 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF121;
        ExdiContext->IA64Context.FltF122 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF122;
        ExdiContext->IA64Context.FltF123 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF123;
        ExdiContext->IA64Context.FltF124 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF124;
        ExdiContext->IA64Context.FltF125 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF125;
        ExdiContext->IA64Context.FltF126 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF126;
        ExdiContext->IA64Context.FltF127 =
            *(IA64_FLOAT128*)&Context->IA64Context.FltF127;
    }

    if (Context->IA64Context.ContextFlags & IA64_CONTEXT_DEBUG)
    {
        ExdiContext->IA64Context.DbI0 = Context->IA64Context.DbI0;
        ExdiContext->IA64Context.DbI1 = Context->IA64Context.DbI1;
        ExdiContext->IA64Context.DbI2 = Context->IA64Context.DbI2;
        ExdiContext->IA64Context.DbI3 = Context->IA64Context.DbI3;
        ExdiContext->IA64Context.DbI4 = Context->IA64Context.DbI4;
        ExdiContext->IA64Context.DbI5 = Context->IA64Context.DbI5;
        ExdiContext->IA64Context.DbI6 = Context->IA64Context.DbI6;
        ExdiContext->IA64Context.DbI7 = Context->IA64Context.DbI7;
        ExdiContext->IA64Context.DbD0 = Context->IA64Context.DbD0;
        ExdiContext->IA64Context.DbD1 = Context->IA64Context.DbD1;
        ExdiContext->IA64Context.DbD2 = Context->IA64Context.DbD2;
        ExdiContext->IA64Context.DbD3 = Context->IA64Context.DbD3;
        ExdiContext->IA64Context.DbD4 = Context->IA64Context.DbD4;
        ExdiContext->IA64Context.DbD5 = Context->IA64Context.DbD5;
        ExdiContext->IA64Context.DbD6 = Context->IA64Context.DbD6;
        ExdiContext->IA64Context.DbD7 = Context->IA64Context.DbD7;
    }

    if (Context->IA64Context.ContextFlags & IA64_CONTEXT_CONTROL)
    {
        ExdiContext->IA64Context.IntR1 = Context->IA64Context.IntGp;
        ExdiContext->IA64Context.IntR12 = Context->IA64Context.IntSp;
        ExdiContext->IA64Context.Br0 = Context->IA64Context.BrRp;
        ExdiContext->IA64Context.StFPSR = Context->IA64Context.StFPSR;
        ExdiContext->IA64Context.ApUNAT = Context->IA64Context.ApUNAT;
        ExdiContext->IA64Context.ApLC = Context->IA64Context.ApLC;
        ExdiContext->IA64Context.ApEC = Context->IA64Context.ApEC;
        ExdiContext->IA64Context.ApCCV = Context->IA64Context.ApCCV;
        ExdiContext->IA64Context.ApDCR = Context->IA64Context.ApDCR;
        ExdiContext->IA64Context.RsPFS = Context->IA64Context.RsPFS;
        ExdiContext->IA64Context.RsBSP = Context->IA64Context.RsBSP;
        ExdiContext->IA64Context.RsBSPSTORE = Context->IA64Context.RsBSPSTORE;
        ExdiContext->IA64Context.RsRSC = Context->IA64Context.RsRSC;
        ExdiContext->IA64Context.RsRNAT = Context->IA64Context.RsRNAT;
        ExdiContext->IA64Context.StIPSR = Context->IA64Context.StIPSR;
        ExdiContext->IA64Context.StIIP = Context->IA64Context.StIIP;
        ExdiContext->IA64Context.StIFS = Context->IA64Context.StIFS;
    }

    if (Context->IA64Context.ContextFlags & (IA64_CONTEXT_CONTROL |
                                             IA64_CONTEXT_IA32_CONTROL))
    {
        ExdiContext->IA64Context.StFCR = Context->IA64Context.StFCR;
        ExdiContext->IA64Context.Eflag = Context->IA64Context.Eflag;
        ExdiContext->IA64Context.SegCSD = Context->IA64Context.SegCSD;
        ExdiContext->IA64Context.SegSSD = Context->IA64Context.SegSSD;
        ExdiContext->IA64Context.Cflag = Context->IA64Context.Cflag;
        ExdiContext->IA64Context.StFSR = Context->IA64Context.StFSR;
        ExdiContext->IA64Context.StFIR = Context->IA64Context.StFIR;
        ExdiContext->IA64Context.StFDR = Context->IA64Context.StFDR;
    }
}

void
Ia64MachineInfo::ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                             EXDI_CONTEXT_TYPE CtxType,
                                             PCROSS_PLATFORM_CONTEXT Context)
{
    DBG_ASSERT(CtxType == EXDI_CTX_IA64);

    Context->IA64Context.IntGp = ExdiContext->IA64Context.IntR1;
    Context->IA64Context.IntT0 = ExdiContext->IA64Context.IntR2;
    Context->IA64Context.IntT1 = ExdiContext->IA64Context.IntR3;
    Context->IA64Context.IntS0 = ExdiContext->IA64Context.IntR4;
    Context->IA64Context.IntS1 = ExdiContext->IA64Context.IntR5;
    Context->IA64Context.IntS2 = ExdiContext->IA64Context.IntR6;
    Context->IA64Context.IntS3 = ExdiContext->IA64Context.IntR7;
    Context->IA64Context.IntV0 = ExdiContext->IA64Context.IntR8;
    Context->IA64Context.IntT2 = ExdiContext->IA64Context.IntR9;
    Context->IA64Context.IntT3 = ExdiContext->IA64Context.IntR10;
    Context->IA64Context.IntT4 = ExdiContext->IA64Context.IntR11;
    Context->IA64Context.IntSp = ExdiContext->IA64Context.IntR12;
    Context->IA64Context.IntTeb = ExdiContext->IA64Context.IntR13;
    Context->IA64Context.IntT5 = ExdiContext->IA64Context.IntR14;
    Context->IA64Context.IntT6 = ExdiContext->IA64Context.IntR15;
    Context->IA64Context.IntT7 = ExdiContext->IA64Context.IntR16;
    Context->IA64Context.IntT8 = ExdiContext->IA64Context.IntR17;
    Context->IA64Context.IntT9 = ExdiContext->IA64Context.IntR18;
    Context->IA64Context.IntT10 = ExdiContext->IA64Context.IntR19;
    Context->IA64Context.IntT11 = ExdiContext->IA64Context.IntR20;
    Context->IA64Context.IntT12 = ExdiContext->IA64Context.IntR21;
    Context->IA64Context.IntT13 = ExdiContext->IA64Context.IntR22;
    Context->IA64Context.IntT14 = ExdiContext->IA64Context.IntR23;
    Context->IA64Context.IntT15 = ExdiContext->IA64Context.IntR24;
    Context->IA64Context.IntT16 = ExdiContext->IA64Context.IntR25;
    Context->IA64Context.IntT17 = ExdiContext->IA64Context.IntR26;
    Context->IA64Context.IntT18 = ExdiContext->IA64Context.IntR27;
    Context->IA64Context.IntT19 = ExdiContext->IA64Context.IntR28;
    Context->IA64Context.IntT20 = ExdiContext->IA64Context.IntR29;
    Context->IA64Context.IntT21 = ExdiContext->IA64Context.IntR30;
    Context->IA64Context.IntT22 = ExdiContext->IA64Context.IntR31;
    Context->IA64Context.IntNats = ExdiContext->IA64Context.IntNats;
    Context->IA64Context.Preds = ExdiContext->IA64Context.Preds;
    Context->IA64Context.BrRp = ExdiContext->IA64Context.Br0;
    Context->IA64Context.BrS0 = ExdiContext->IA64Context.Br1;
    Context->IA64Context.BrS1 = ExdiContext->IA64Context.Br2;
    Context->IA64Context.BrS2 = ExdiContext->IA64Context.Br3;
    Context->IA64Context.BrS3 = ExdiContext->IA64Context.Br4;
    Context->IA64Context.BrS4 = ExdiContext->IA64Context.Br5;
    Context->IA64Context.BrT0 = ExdiContext->IA64Context.Br6;
    Context->IA64Context.BrT1 = ExdiContext->IA64Context.Br7;
    
    Context->IA64Context.StFPSR = ExdiContext->IA64Context.StFPSR;
    memcpy(&Context->IA64Context.FltS0, &ExdiContext->IA64Context.FltF2,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS1, &ExdiContext->IA64Context.FltF3,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS2, &ExdiContext->IA64Context.FltF4,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS3, &ExdiContext->IA64Context.FltF5,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltT0, &ExdiContext->IA64Context.FltF6,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltT1, &ExdiContext->IA64Context.FltF7,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltT2, &ExdiContext->IA64Context.FltF8,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltT3, &ExdiContext->IA64Context.FltF9,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltT4, &ExdiContext->IA64Context.FltF10,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltT5, &ExdiContext->IA64Context.FltF11,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltT6, &ExdiContext->IA64Context.FltF12,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltT7, &ExdiContext->IA64Context.FltF13,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltT8, &ExdiContext->IA64Context.FltF14,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltT9, &ExdiContext->IA64Context.FltF15,
           sizeof(IA64_FLOAT128));
    
    Context->IA64Context.StFPSR = ExdiContext->IA64Context.StFPSR;
    memcpy(&Context->IA64Context.FltS4, &ExdiContext->IA64Context.FltF16,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS5, &ExdiContext->IA64Context.FltF17,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS6, &ExdiContext->IA64Context.FltF18,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS7, &ExdiContext->IA64Context.FltF19,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS8, &ExdiContext->IA64Context.FltF20,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS9, &ExdiContext->IA64Context.FltF21,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS10, &ExdiContext->IA64Context.FltF22,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS11, &ExdiContext->IA64Context.FltF23,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS12, &ExdiContext->IA64Context.FltF24,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS13, &ExdiContext->IA64Context.FltF25,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS14, &ExdiContext->IA64Context.FltF26,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS15, &ExdiContext->IA64Context.FltF27,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS16, &ExdiContext->IA64Context.FltF28,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS17, &ExdiContext->IA64Context.FltF29,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS18, &ExdiContext->IA64Context.FltF30,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltS19, &ExdiContext->IA64Context.FltF31,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF32, &ExdiContext->IA64Context.FltF32,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF33, &ExdiContext->IA64Context.FltF33,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF34, &ExdiContext->IA64Context.FltF34,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF35, &ExdiContext->IA64Context.FltF35,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF36, &ExdiContext->IA64Context.FltF36,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF37, &ExdiContext->IA64Context.FltF37,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF38, &ExdiContext->IA64Context.FltF38,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF39, &ExdiContext->IA64Context.FltF39,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF40, &ExdiContext->IA64Context.FltF40,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF41, &ExdiContext->IA64Context.FltF41,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF42, &ExdiContext->IA64Context.FltF42,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF43, &ExdiContext->IA64Context.FltF43,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF44, &ExdiContext->IA64Context.FltF44,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF45, &ExdiContext->IA64Context.FltF45,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF46, &ExdiContext->IA64Context.FltF46,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF47, &ExdiContext->IA64Context.FltF47,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF48, &ExdiContext->IA64Context.FltF48,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF49, &ExdiContext->IA64Context.FltF49,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF50, &ExdiContext->IA64Context.FltF50,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF51, &ExdiContext->IA64Context.FltF51,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF52, &ExdiContext->IA64Context.FltF52,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF53, &ExdiContext->IA64Context.FltF53,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF54, &ExdiContext->IA64Context.FltF54,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF55, &ExdiContext->IA64Context.FltF55,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF56, &ExdiContext->IA64Context.FltF56,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF57, &ExdiContext->IA64Context.FltF57,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF58, &ExdiContext->IA64Context.FltF58,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF59, &ExdiContext->IA64Context.FltF59,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF60, &ExdiContext->IA64Context.FltF60,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF61, &ExdiContext->IA64Context.FltF61,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF62, &ExdiContext->IA64Context.FltF62,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF63, &ExdiContext->IA64Context.FltF63,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF64, &ExdiContext->IA64Context.FltF64,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF65, &ExdiContext->IA64Context.FltF65,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF66, &ExdiContext->IA64Context.FltF66,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF67, &ExdiContext->IA64Context.FltF67,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF68, &ExdiContext->IA64Context.FltF68,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF69, &ExdiContext->IA64Context.FltF69,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF70, &ExdiContext->IA64Context.FltF70,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF71, &ExdiContext->IA64Context.FltF71,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF72, &ExdiContext->IA64Context.FltF72,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF73, &ExdiContext->IA64Context.FltF73,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF74, &ExdiContext->IA64Context.FltF74,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF75, &ExdiContext->IA64Context.FltF75,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF76, &ExdiContext->IA64Context.FltF76,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF77, &ExdiContext->IA64Context.FltF77,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF78, &ExdiContext->IA64Context.FltF78,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF79, &ExdiContext->IA64Context.FltF79,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF80, &ExdiContext->IA64Context.FltF80,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF81, &ExdiContext->IA64Context.FltF81,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF82, &ExdiContext->IA64Context.FltF82,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF83, &ExdiContext->IA64Context.FltF83,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF84, &ExdiContext->IA64Context.FltF84,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF85, &ExdiContext->IA64Context.FltF85,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF86, &ExdiContext->IA64Context.FltF86,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF87, &ExdiContext->IA64Context.FltF87,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF88, &ExdiContext->IA64Context.FltF88,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF89, &ExdiContext->IA64Context.FltF89,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF90, &ExdiContext->IA64Context.FltF90,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF91, &ExdiContext->IA64Context.FltF91,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF92, &ExdiContext->IA64Context.FltF92,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF93, &ExdiContext->IA64Context.FltF93,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF94, &ExdiContext->IA64Context.FltF94,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF95, &ExdiContext->IA64Context.FltF95,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF96, &ExdiContext->IA64Context.FltF96,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF97, &ExdiContext->IA64Context.FltF97,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF98, &ExdiContext->IA64Context.FltF98,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF99, &ExdiContext->IA64Context.FltF99,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF100, &ExdiContext->IA64Context.FltF100,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF101, &ExdiContext->IA64Context.FltF101,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF102, &ExdiContext->IA64Context.FltF102,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF103, &ExdiContext->IA64Context.FltF103,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF104, &ExdiContext->IA64Context.FltF104,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF105, &ExdiContext->IA64Context.FltF105,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF106, &ExdiContext->IA64Context.FltF106,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF107, &ExdiContext->IA64Context.FltF107,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF108, &ExdiContext->IA64Context.FltF108,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF109, &ExdiContext->IA64Context.FltF109,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF110, &ExdiContext->IA64Context.FltF110,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF111, &ExdiContext->IA64Context.FltF111,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF112, &ExdiContext->IA64Context.FltF112,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF113, &ExdiContext->IA64Context.FltF113,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF114, &ExdiContext->IA64Context.FltF114,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF115, &ExdiContext->IA64Context.FltF115,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF116, &ExdiContext->IA64Context.FltF116,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF117, &ExdiContext->IA64Context.FltF117,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF118, &ExdiContext->IA64Context.FltF118,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF119, &ExdiContext->IA64Context.FltF119,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF120, &ExdiContext->IA64Context.FltF120,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF121, &ExdiContext->IA64Context.FltF121,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF122, &ExdiContext->IA64Context.FltF122,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF123, &ExdiContext->IA64Context.FltF123,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF124, &ExdiContext->IA64Context.FltF124,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF125, &ExdiContext->IA64Context.FltF125,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF126, &ExdiContext->IA64Context.FltF126,
           sizeof(IA64_FLOAT128));
    memcpy(&Context->IA64Context.FltF127, &ExdiContext->IA64Context.FltF127,
           sizeof(IA64_FLOAT128));

    Context->IA64Context.DbI0 = ExdiContext->IA64Context.DbI0;
    Context->IA64Context.DbI1 = ExdiContext->IA64Context.DbI1;
    Context->IA64Context.DbI2 = ExdiContext->IA64Context.DbI2;
    Context->IA64Context.DbI3 = ExdiContext->IA64Context.DbI3;
    Context->IA64Context.DbI4 = ExdiContext->IA64Context.DbI4;
    Context->IA64Context.DbI5 = ExdiContext->IA64Context.DbI5;
    Context->IA64Context.DbI6 = ExdiContext->IA64Context.DbI6;
    Context->IA64Context.DbI7 = ExdiContext->IA64Context.DbI7;
    Context->IA64Context.DbD0 = ExdiContext->IA64Context.DbD0;
    Context->IA64Context.DbD1 = ExdiContext->IA64Context.DbD1;
    Context->IA64Context.DbD2 = ExdiContext->IA64Context.DbD2;
    Context->IA64Context.DbD3 = ExdiContext->IA64Context.DbD3;
    Context->IA64Context.DbD4 = ExdiContext->IA64Context.DbD4;
    Context->IA64Context.DbD5 = ExdiContext->IA64Context.DbD5;
    Context->IA64Context.DbD6 = ExdiContext->IA64Context.DbD6;
    Context->IA64Context.DbD7 = ExdiContext->IA64Context.DbD7;

    Context->IA64Context.IntGp = ExdiContext->IA64Context.IntR1;
    Context->IA64Context.IntSp = ExdiContext->IA64Context.IntR12;
    Context->IA64Context.BrRp = ExdiContext->IA64Context.Br0;
    Context->IA64Context.StFPSR = ExdiContext->IA64Context.StFPSR;
    Context->IA64Context.ApUNAT = ExdiContext->IA64Context.ApUNAT;
    Context->IA64Context.ApLC = ExdiContext->IA64Context.ApLC;
    Context->IA64Context.ApEC = ExdiContext->IA64Context.ApEC;
    Context->IA64Context.ApCCV = ExdiContext->IA64Context.ApCCV;
    Context->IA64Context.ApDCR = ExdiContext->IA64Context.ApDCR;
    Context->IA64Context.RsPFS = ExdiContext->IA64Context.RsPFS;
    Context->IA64Context.RsBSP = ExdiContext->IA64Context.RsBSP;
    Context->IA64Context.RsBSPSTORE = ExdiContext->IA64Context.RsBSPSTORE;
    Context->IA64Context.RsRSC = ExdiContext->IA64Context.RsRSC;
    Context->IA64Context.RsRNAT = ExdiContext->IA64Context.RsRNAT;
    Context->IA64Context.StIPSR = ExdiContext->IA64Context.StIPSR;
    Context->IA64Context.StIIP = ExdiContext->IA64Context.StIIP;
    Context->IA64Context.StIFS = ExdiContext->IA64Context.StIFS;

    Context->IA64Context.StFCR = ExdiContext->IA64Context.StFCR;
    Context->IA64Context.Eflag = ExdiContext->IA64Context.Eflag;
    Context->IA64Context.SegCSD = ExdiContext->IA64Context.SegCSD;
    Context->IA64Context.SegSSD = ExdiContext->IA64Context.SegSSD;
    Context->IA64Context.Cflag = ExdiContext->IA64Context.Cflag;
    Context->IA64Context.StFSR = ExdiContext->IA64Context.StFSR;
    Context->IA64Context.StFIR = ExdiContext->IA64Context.StFIR;
    Context->IA64Context.StFDR = ExdiContext->IA64Context.StFDR;
}

void
Ia64MachineInfo::ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                              EXDI_CONTEXT_TYPE CtxType,
                                              ULONG Start, ULONG Count,
                                              PDESCRIPTOR64 Descs)
{
    DBG_ASSERT(CtxType == EXDI_CTX_IA64);

    while (Count-- > 0)
    {
        Descs->Flags = SEGDESC_INVALID;
        Descs++;
    }
}

void
Ia64MachineInfo::ConvertExdiContextFromSpecial
    (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
     PEXDI_CONTEXT ExdiContext, EXDI_CONTEXT_TYPE CtxType)
{
    DBG_ASSERT(CtxType == EXDI_CTX_IA64);

    ExdiContext->IA64Context.DbI0 = Special->IA64Special.KernelDbI0;
    ExdiContext->IA64Context.DbI1 = Special->IA64Special.KernelDbI1;
    ExdiContext->IA64Context.DbI2 = Special->IA64Special.KernelDbI2;
    ExdiContext->IA64Context.DbI3 = Special->IA64Special.KernelDbI3;
    ExdiContext->IA64Context.DbI4 = Special->IA64Special.KernelDbI4;
    ExdiContext->IA64Context.DbI5 = Special->IA64Special.KernelDbI5;
    ExdiContext->IA64Context.DbI6 = Special->IA64Special.KernelDbI6;
    ExdiContext->IA64Context.DbI7 = Special->IA64Special.KernelDbI7;
    ExdiContext->IA64Context.DbD0 = Special->IA64Special.KernelDbD0;
    ExdiContext->IA64Context.DbD1 = Special->IA64Special.KernelDbD1;
    ExdiContext->IA64Context.DbD2 = Special->IA64Special.KernelDbD2;
    ExdiContext->IA64Context.DbD3 = Special->IA64Special.KernelDbD3;
    ExdiContext->IA64Context.DbD4 = Special->IA64Special.KernelDbD4;
    ExdiContext->IA64Context.DbD5 = Special->IA64Special.KernelDbD5;
    ExdiContext->IA64Context.DbD6 = Special->IA64Special.KernelDbD6;
    ExdiContext->IA64Context.DbD7 = Special->IA64Special.KernelDbD7;

    ExdiContext->IA64Context.PfC0 = Special->IA64Special.KernelPfC0;
    ExdiContext->IA64Context.PfC1 = Special->IA64Special.KernelPfC1;
    ExdiContext->IA64Context.PfC2 = Special->IA64Special.KernelPfC2;
    ExdiContext->IA64Context.PfC3 = Special->IA64Special.KernelPfC3;
    ExdiContext->IA64Context.PfC4 = Special->IA64Special.KernelPfC4;
    ExdiContext->IA64Context.PfC5 = Special->IA64Special.KernelPfC5;
    ExdiContext->IA64Context.PfC6 = Special->IA64Special.KernelPfC6;
    ExdiContext->IA64Context.PfC7 = Special->IA64Special.KernelPfC7;
    ExdiContext->IA64Context.PfD0 = Special->IA64Special.KernelPfD0;
    ExdiContext->IA64Context.PfD1 = Special->IA64Special.KernelPfD1;
    ExdiContext->IA64Context.PfD2 = Special->IA64Special.KernelPfD2;
    ExdiContext->IA64Context.PfD3 = Special->IA64Special.KernelPfD3;
    ExdiContext->IA64Context.PfD4 = Special->IA64Special.KernelPfD4;
    ExdiContext->IA64Context.PfD5 = Special->IA64Special.KernelPfD5;
    ExdiContext->IA64Context.PfD6 = Special->IA64Special.KernelPfD6;
    ExdiContext->IA64Context.PfD7 = Special->IA64Special.KernelPfD7;

    ExdiContext->IA64Context.IntH16 = Special->IA64Special.IntH16;
    ExdiContext->IA64Context.IntH17 = Special->IA64Special.IntH17;
    ExdiContext->IA64Context.IntH18 = Special->IA64Special.IntH18;
    ExdiContext->IA64Context.IntH19 = Special->IA64Special.IntH19;
    ExdiContext->IA64Context.IntH20 = Special->IA64Special.IntH20;
    ExdiContext->IA64Context.IntH21 = Special->IA64Special.IntH21;
    ExdiContext->IA64Context.IntH22 = Special->IA64Special.IntH22;
    ExdiContext->IA64Context.IntH23 = Special->IA64Special.IntH23;
    ExdiContext->IA64Context.IntH24 = Special->IA64Special.IntH24;
    ExdiContext->IA64Context.IntH25 = Special->IA64Special.IntH25;
    ExdiContext->IA64Context.IntH26 = Special->IA64Special.IntH26;
    ExdiContext->IA64Context.IntH27 = Special->IA64Special.IntH27;
    ExdiContext->IA64Context.IntH28 = Special->IA64Special.IntH28;
    ExdiContext->IA64Context.IntH29 = Special->IA64Special.IntH29;
    ExdiContext->IA64Context.IntH30 = Special->IA64Special.IntH30;
    ExdiContext->IA64Context.IntH31 = Special->IA64Special.IntH31;

    ExdiContext->IA64Context.ApCPUID0 = Special->IA64Special.ApCPUID0;
    ExdiContext->IA64Context.ApCPUID1 = Special->IA64Special.ApCPUID1;
    ExdiContext->IA64Context.ApCPUID2 = Special->IA64Special.ApCPUID2;
    ExdiContext->IA64Context.ApCPUID3 = Special->IA64Special.ApCPUID3;
    ExdiContext->IA64Context.ApCPUID4 = Special->IA64Special.ApCPUID4;
    ExdiContext->IA64Context.ApCPUID5 = Special->IA64Special.ApCPUID5;
    ExdiContext->IA64Context.ApCPUID6 = Special->IA64Special.ApCPUID6;
    ExdiContext->IA64Context.ApCPUID7 = Special->IA64Special.ApCPUID7;

    ExdiContext->IA64Context.ApKR0 = Special->IA64Special.ApKR0;
    ExdiContext->IA64Context.ApKR1 = Special->IA64Special.ApKR1;
    ExdiContext->IA64Context.ApKR2 = Special->IA64Special.ApKR2;
    ExdiContext->IA64Context.ApKR3 = Special->IA64Special.ApKR3;
    ExdiContext->IA64Context.ApKR4 = Special->IA64Special.ApKR4;
    ExdiContext->IA64Context.ApKR5 = Special->IA64Special.ApKR5;
    ExdiContext->IA64Context.ApKR6 = Special->IA64Special.ApKR6;
    ExdiContext->IA64Context.ApKR7 = Special->IA64Special.ApKR7;

    ExdiContext->IA64Context.ApITC = Special->IA64Special.ApITC;
        
    ExdiContext->IA64Context.ApITM = Special->IA64Special.ApITM;
    ExdiContext->IA64Context.ApIVA = Special->IA64Special.ApIVA;
    ExdiContext->IA64Context.ApPTA = Special->IA64Special.ApPTA;
    ExdiContext->IA64Context.ApGPTA = Special->IA64Special.ApGPTA;

    ExdiContext->IA64Context.StISR = Special->IA64Special.StISR;
    ExdiContext->IA64Context.StIFA = Special->IA64Special.StIFA;
    ExdiContext->IA64Context.StITIR = Special->IA64Special.StITIR;
    ExdiContext->IA64Context.StIIPA = Special->IA64Special.StIIPA;
    ExdiContext->IA64Context.StIIM = Special->IA64Special.StIIM;
    ExdiContext->IA64Context.StIHA = Special->IA64Special.StIHA;

    ExdiContext->IA64Context.SaLID = Special->IA64Special.SaLID;
    ExdiContext->IA64Context.SaIVR = Special->IA64Special.SaIVR;
    ExdiContext->IA64Context.SaTPR = Special->IA64Special.SaTPR;
    ExdiContext->IA64Context.SaEOI = Special->IA64Special.SaEOI;
    ExdiContext->IA64Context.SaIRR0 = Special->IA64Special.SaIRR0;
    ExdiContext->IA64Context.SaIRR1 = Special->IA64Special.SaIRR1;
    ExdiContext->IA64Context.SaIRR2 = Special->IA64Special.SaIRR2;
    ExdiContext->IA64Context.SaIRR3 = Special->IA64Special.SaIRR3;
    ExdiContext->IA64Context.SaITV = Special->IA64Special.SaITV;
    ExdiContext->IA64Context.SaPMV = Special->IA64Special.SaPMV;
    ExdiContext->IA64Context.SaCMCV = Special->IA64Special.SaCMCV;
    ExdiContext->IA64Context.SaLRR0 = Special->IA64Special.SaLRR0;
    ExdiContext->IA64Context.SaLRR1 = Special->IA64Special.SaLRR1;

    ExdiContext->IA64Context.Rr0 = Special->IA64Special.Rr0;
    ExdiContext->IA64Context.Rr1 = Special->IA64Special.Rr1;
    ExdiContext->IA64Context.Rr2 = Special->IA64Special.Rr2;
    ExdiContext->IA64Context.Rr3 = Special->IA64Special.Rr3;
    ExdiContext->IA64Context.Rr4 = Special->IA64Special.Rr4;
    ExdiContext->IA64Context.Rr5 = Special->IA64Special.Rr5;
    ExdiContext->IA64Context.Rr6 = Special->IA64Special.Rr6;
    ExdiContext->IA64Context.Rr7 = Special->IA64Special.Rr7;

    ExdiContext->IA64Context.Pkr0 = Special->IA64Special.Pkr0;
    ExdiContext->IA64Context.Pkr1 = Special->IA64Special.Pkr1;
    ExdiContext->IA64Context.Pkr2 = Special->IA64Special.Pkr2;
    ExdiContext->IA64Context.Pkr3 = Special->IA64Special.Pkr3;
    ExdiContext->IA64Context.Pkr4 = Special->IA64Special.Pkr4;
    ExdiContext->IA64Context.Pkr5 = Special->IA64Special.Pkr5;
    ExdiContext->IA64Context.Pkr6 = Special->IA64Special.Pkr6;
    ExdiContext->IA64Context.Pkr7 = Special->IA64Special.Pkr7;
    ExdiContext->IA64Context.Pkr8 = Special->IA64Special.Pkr8;
    ExdiContext->IA64Context.Pkr9 = Special->IA64Special.Pkr9;
    ExdiContext->IA64Context.Pkr10 = Special->IA64Special.Pkr10;
    ExdiContext->IA64Context.Pkr11 = Special->IA64Special.Pkr11;
    ExdiContext->IA64Context.Pkr12 = Special->IA64Special.Pkr12;
    ExdiContext->IA64Context.Pkr13 = Special->IA64Special.Pkr13;
    ExdiContext->IA64Context.Pkr14 = Special->IA64Special.Pkr14;
    ExdiContext->IA64Context.Pkr15 = Special->IA64Special.Pkr15;

    ExdiContext->IA64Context.TrI0 = Special->IA64Special.TrI0;
    ExdiContext->IA64Context.TrI1 = Special->IA64Special.TrI1;
    ExdiContext->IA64Context.TrI2 = Special->IA64Special.TrI2;
    ExdiContext->IA64Context.TrI3 = Special->IA64Special.TrI3;
    ExdiContext->IA64Context.TrI4 = Special->IA64Special.TrI4;
    ExdiContext->IA64Context.TrI5 = Special->IA64Special.TrI5;
    ExdiContext->IA64Context.TrI6 = Special->IA64Special.TrI6;
    ExdiContext->IA64Context.TrI7 = Special->IA64Special.TrI7;
    ExdiContext->IA64Context.TrD0 = Special->IA64Special.TrD0;
    ExdiContext->IA64Context.TrD1 = Special->IA64Special.TrD1;
    ExdiContext->IA64Context.TrD2 = Special->IA64Special.TrD2;
    ExdiContext->IA64Context.TrD3 = Special->IA64Special.TrD3;
    ExdiContext->IA64Context.TrD4 = Special->IA64Special.TrD4;
    ExdiContext->IA64Context.TrD5 = Special->IA64Special.TrD5;
    ExdiContext->IA64Context.TrD6 = Special->IA64Special.TrD6;
    ExdiContext->IA64Context.TrD7 = Special->IA64Special.TrD7;

    ExdiContext->IA64Context.SrMSR0 = Special->IA64Special.SrMSR0;
    ExdiContext->IA64Context.SrMSR1 = Special->IA64Special.SrMSR1;
    ExdiContext->IA64Context.SrMSR2 = Special->IA64Special.SrMSR2;
    ExdiContext->IA64Context.SrMSR3 = Special->IA64Special.SrMSR3;
    ExdiContext->IA64Context.SrMSR4 = Special->IA64Special.SrMSR4;
    ExdiContext->IA64Context.SrMSR5 = Special->IA64Special.SrMSR5;
    ExdiContext->IA64Context.SrMSR6 = Special->IA64Special.SrMSR6;
    ExdiContext->IA64Context.SrMSR7 = Special->IA64Special.SrMSR7;
}

void
Ia64MachineInfo::ConvertExdiContextToSpecial
    (PEXDI_CONTEXT ExdiContext, EXDI_CONTEXT_TYPE CtxType,
     PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    DBG_ASSERT(CtxType == EXDI_CTX_IA64);

    Special->IA64Special.KernelDbI0 = ExdiContext->IA64Context.DbI0;
    Special->IA64Special.KernelDbI1 = ExdiContext->IA64Context.DbI1;
    Special->IA64Special.KernelDbI2 = ExdiContext->IA64Context.DbI2;
    Special->IA64Special.KernelDbI3 = ExdiContext->IA64Context.DbI3;
    Special->IA64Special.KernelDbI4 = ExdiContext->IA64Context.DbI4;
    Special->IA64Special.KernelDbI5 = ExdiContext->IA64Context.DbI5;
    Special->IA64Special.KernelDbI6 = ExdiContext->IA64Context.DbI6;
    Special->IA64Special.KernelDbI7 = ExdiContext->IA64Context.DbI7;
    Special->IA64Special.KernelDbD0 = ExdiContext->IA64Context.DbD0;
    Special->IA64Special.KernelDbD1 = ExdiContext->IA64Context.DbD1;
    Special->IA64Special.KernelDbD2 = ExdiContext->IA64Context.DbD2;
    Special->IA64Special.KernelDbD3 = ExdiContext->IA64Context.DbD3;
    Special->IA64Special.KernelDbD4 = ExdiContext->IA64Context.DbD4;
    Special->IA64Special.KernelDbD5 = ExdiContext->IA64Context.DbD5;
    Special->IA64Special.KernelDbD6 = ExdiContext->IA64Context.DbD6;
    Special->IA64Special.KernelDbD7 = ExdiContext->IA64Context.DbD7;

    Special->IA64Special.KernelPfC0 = ExdiContext->IA64Context.PfC0;
    Special->IA64Special.KernelPfC1 = ExdiContext->IA64Context.PfC1;
    Special->IA64Special.KernelPfC2 = ExdiContext->IA64Context.PfC2;
    Special->IA64Special.KernelPfC3 = ExdiContext->IA64Context.PfC3;
    Special->IA64Special.KernelPfC4 = ExdiContext->IA64Context.PfC4;
    Special->IA64Special.KernelPfC5 = ExdiContext->IA64Context.PfC5;
    Special->IA64Special.KernelPfC6 = ExdiContext->IA64Context.PfC6;
    Special->IA64Special.KernelPfC7 = ExdiContext->IA64Context.PfC7;
    Special->IA64Special.KernelPfD0 = ExdiContext->IA64Context.PfD0;
    Special->IA64Special.KernelPfD1 = ExdiContext->IA64Context.PfD1;
    Special->IA64Special.KernelPfD2 = ExdiContext->IA64Context.PfD2;
    Special->IA64Special.KernelPfD3 = ExdiContext->IA64Context.PfD3;
    Special->IA64Special.KernelPfD4 = ExdiContext->IA64Context.PfD4;
    Special->IA64Special.KernelPfD5 = ExdiContext->IA64Context.PfD5;
    Special->IA64Special.KernelPfD6 = ExdiContext->IA64Context.PfD6;
    Special->IA64Special.KernelPfD7 = ExdiContext->IA64Context.PfD7;

    Special->IA64Special.IntH16 = ExdiContext->IA64Context.IntH16;
    Special->IA64Special.IntH17 = ExdiContext->IA64Context.IntH17;
    Special->IA64Special.IntH18 = ExdiContext->IA64Context.IntH18;
    Special->IA64Special.IntH19 = ExdiContext->IA64Context.IntH19;
    Special->IA64Special.IntH20 = ExdiContext->IA64Context.IntH20;
    Special->IA64Special.IntH21 = ExdiContext->IA64Context.IntH21;
    Special->IA64Special.IntH22 = ExdiContext->IA64Context.IntH22;
    Special->IA64Special.IntH23 = ExdiContext->IA64Context.IntH23;
    Special->IA64Special.IntH24 = ExdiContext->IA64Context.IntH24;
    Special->IA64Special.IntH25 = ExdiContext->IA64Context.IntH25;
    Special->IA64Special.IntH26 = ExdiContext->IA64Context.IntH26;
    Special->IA64Special.IntH27 = ExdiContext->IA64Context.IntH27;
    Special->IA64Special.IntH28 = ExdiContext->IA64Context.IntH28;
    Special->IA64Special.IntH29 = ExdiContext->IA64Context.IntH29;
    Special->IA64Special.IntH30 = ExdiContext->IA64Context.IntH30;
    Special->IA64Special.IntH31 = ExdiContext->IA64Context.IntH31;

    Special->IA64Special.ApCPUID0 = ExdiContext->IA64Context.ApCPUID0;
    Special->IA64Special.ApCPUID1 = ExdiContext->IA64Context.ApCPUID1;
    Special->IA64Special.ApCPUID2 = ExdiContext->IA64Context.ApCPUID2;
    Special->IA64Special.ApCPUID3 = ExdiContext->IA64Context.ApCPUID3;
    Special->IA64Special.ApCPUID4 = ExdiContext->IA64Context.ApCPUID4;
    Special->IA64Special.ApCPUID5 = ExdiContext->IA64Context.ApCPUID5;
    Special->IA64Special.ApCPUID6 = ExdiContext->IA64Context.ApCPUID6;
    Special->IA64Special.ApCPUID7 = ExdiContext->IA64Context.ApCPUID7;

    Special->IA64Special.ApKR0 = ExdiContext->IA64Context.ApKR0;
    Special->IA64Special.ApKR1 = ExdiContext->IA64Context.ApKR1;
    Special->IA64Special.ApKR2 = ExdiContext->IA64Context.ApKR2;
    Special->IA64Special.ApKR3 = ExdiContext->IA64Context.ApKR3;
    Special->IA64Special.ApKR4 = ExdiContext->IA64Context.ApKR4;
    Special->IA64Special.ApKR5 = ExdiContext->IA64Context.ApKR5;
    Special->IA64Special.ApKR6 = ExdiContext->IA64Context.ApKR6;
    Special->IA64Special.ApKR7 = ExdiContext->IA64Context.ApKR7;

    Special->IA64Special.ApITC = ExdiContext->IA64Context.ApITC;
        
    Special->IA64Special.ApITM = ExdiContext->IA64Context.ApITM;
    Special->IA64Special.ApIVA = ExdiContext->IA64Context.ApIVA;
    Special->IA64Special.ApPTA = ExdiContext->IA64Context.ApPTA;
    Special->IA64Special.ApGPTA = ExdiContext->IA64Context.ApGPTA;

    Special->IA64Special.StISR = ExdiContext->IA64Context.StISR;
    Special->IA64Special.StIFA = ExdiContext->IA64Context.StIFA;
    Special->IA64Special.StITIR = ExdiContext->IA64Context.StITIR;
    Special->IA64Special.StIIPA = ExdiContext->IA64Context.StIIPA;
    Special->IA64Special.StIIM = ExdiContext->IA64Context.StIIM;
    Special->IA64Special.StIHA = ExdiContext->IA64Context.StIHA;

    Special->IA64Special.SaLID = ExdiContext->IA64Context.SaLID;
    Special->IA64Special.SaIVR = ExdiContext->IA64Context.SaIVR;
    Special->IA64Special.SaTPR = ExdiContext->IA64Context.SaTPR;
    Special->IA64Special.SaEOI = ExdiContext->IA64Context.SaEOI;
    Special->IA64Special.SaIRR0 = ExdiContext->IA64Context.SaIRR0;
    Special->IA64Special.SaIRR1 = ExdiContext->IA64Context.SaIRR1;
    Special->IA64Special.SaIRR2 = ExdiContext->IA64Context.SaIRR2;
    Special->IA64Special.SaIRR3 = ExdiContext->IA64Context.SaIRR3;
    Special->IA64Special.SaITV = ExdiContext->IA64Context.SaITV;
    Special->IA64Special.SaPMV = ExdiContext->IA64Context.SaPMV;
    Special->IA64Special.SaCMCV = ExdiContext->IA64Context.SaCMCV;
    Special->IA64Special.SaLRR0 = ExdiContext->IA64Context.SaLRR0;
    Special->IA64Special.SaLRR1 = ExdiContext->IA64Context.SaLRR1;

    Special->IA64Special.Rr0 = ExdiContext->IA64Context.Rr0;
    Special->IA64Special.Rr1 = ExdiContext->IA64Context.Rr1;
    Special->IA64Special.Rr2 = ExdiContext->IA64Context.Rr2;
    Special->IA64Special.Rr3 = ExdiContext->IA64Context.Rr3;
    Special->IA64Special.Rr4 = ExdiContext->IA64Context.Rr4;
    Special->IA64Special.Rr5 = ExdiContext->IA64Context.Rr5;
    Special->IA64Special.Rr6 = ExdiContext->IA64Context.Rr6;
    Special->IA64Special.Rr7 = ExdiContext->IA64Context.Rr7;

    Special->IA64Special.Pkr0 = ExdiContext->IA64Context.Pkr0;
    Special->IA64Special.Pkr1 = ExdiContext->IA64Context.Pkr1;
    Special->IA64Special.Pkr2 = ExdiContext->IA64Context.Pkr2;
    Special->IA64Special.Pkr3 = ExdiContext->IA64Context.Pkr3;
    Special->IA64Special.Pkr4 = ExdiContext->IA64Context.Pkr4;
    Special->IA64Special.Pkr5 = ExdiContext->IA64Context.Pkr5;
    Special->IA64Special.Pkr6 = ExdiContext->IA64Context.Pkr6;
    Special->IA64Special.Pkr7 = ExdiContext->IA64Context.Pkr7;
    Special->IA64Special.Pkr8 = ExdiContext->IA64Context.Pkr8;
    Special->IA64Special.Pkr9 = ExdiContext->IA64Context.Pkr9;
    Special->IA64Special.Pkr10 = ExdiContext->IA64Context.Pkr10;
    Special->IA64Special.Pkr11 = ExdiContext->IA64Context.Pkr11;
    Special->IA64Special.Pkr12 = ExdiContext->IA64Context.Pkr12;
    Special->IA64Special.Pkr13 = ExdiContext->IA64Context.Pkr13;
    Special->IA64Special.Pkr14 = ExdiContext->IA64Context.Pkr14;
    Special->IA64Special.Pkr15 = ExdiContext->IA64Context.Pkr15;

    Special->IA64Special.TrI0 = ExdiContext->IA64Context.TrI0;
    Special->IA64Special.TrI1 = ExdiContext->IA64Context.TrI1;
    Special->IA64Special.TrI2 = ExdiContext->IA64Context.TrI2;
    Special->IA64Special.TrI3 = ExdiContext->IA64Context.TrI3;
    Special->IA64Special.TrI4 = ExdiContext->IA64Context.TrI4;
    Special->IA64Special.TrI5 = ExdiContext->IA64Context.TrI5;
    Special->IA64Special.TrI6 = ExdiContext->IA64Context.TrI6;
    Special->IA64Special.TrI7 = ExdiContext->IA64Context.TrI7;
    Special->IA64Special.TrD0 = ExdiContext->IA64Context.TrD0;
    Special->IA64Special.TrD1 = ExdiContext->IA64Context.TrD1;
    Special->IA64Special.TrD2 = ExdiContext->IA64Context.TrD2;
    Special->IA64Special.TrD3 = ExdiContext->IA64Context.TrD3;
    Special->IA64Special.TrD4 = ExdiContext->IA64Context.TrD4;
    Special->IA64Special.TrD5 = ExdiContext->IA64Context.TrD5;
    Special->IA64Special.TrD6 = ExdiContext->IA64Context.TrD6;
    Special->IA64Special.TrD7 = ExdiContext->IA64Context.TrD7;

    Special->IA64Special.SrMSR0 = ExdiContext->IA64Context.SrMSR0;
    Special->IA64Special.SrMSR1 = ExdiContext->IA64Context.SrMSR1;
    Special->IA64Special.SrMSR2 = ExdiContext->IA64Context.SrMSR2;
    Special->IA64Special.SrMSR3 = ExdiContext->IA64Context.SrMSR3;
    Special->IA64Special.SrMSR4 = ExdiContext->IA64Context.SrMSR4;
    Special->IA64Special.SrMSR5 = ExdiContext->IA64Context.SrMSR5;
    Special->IA64Special.SrMSR6 = ExdiContext->IA64Context.SrMSR6;
    Special->IA64Special.SrMSR7 = ExdiContext->IA64Context.SrMSR7;
}

int
Ia64MachineInfo::GetType(ULONG Reg)
{
    if (Reg >= IA64_FLTBASE && Reg <= IA64_FLTLAST)
    {
        return REGVAL_FLOAT82;
    }
    else if ((Reg >= INTGP && Reg <= INTT22) ||
             (Reg >= INTR32 && Reg <= INTR127))
    {
        return REGVAL_INT64N;
    }
    else if (Reg < IA64_FLAGBASE)
    {
        return REGVAL_INT64;
    }
    else
    {
        return REGVAL_SUB64;
    }
}

HRESULT
Ia64MachineInfo::GetRotatingRegVal(ULONG Reg,
                                   ULONG64 Bsp,
                                   ULONG64 FrameMarker,
                                   REGVAL* Val)
{
    if (Reg >= IA64_FLTBASE && Reg <= IA64_FLTLAST)
    {
        Reg = RotateFr(Reg, FrameMarker);
        Val->Type = REGVAL_FLOAT82;
        Val->F16Parts.High = 0;
        memcpy(Val->F82,
               (PULONGLONG)&m_Context.IA64Context.DbI0 + Reg,
               sizeof(Val->F82));
    }
    else if ((Reg >= INTGP) && (Reg <= INTT22)) 
    {
        Val->Type = REGVAL_INT64N;
        Val->Nat = (UCHAR)
            ((m_Context.IA64Context.IntNats >> (Reg - INTGP + 1)) & 0x1);
        Val->I64 =
            *((PULONGLONG)&m_Context.IA64Context.IntGp + Reg - INTGP);
    }
    else if ((Reg >= INTR32) && (Reg <= INTR127))
    {
        Val->Type = REGVAL_INT64N;
        Reg = RotateGr(Reg, FrameMarker) - INTR32;
        if (Reg >= IA64_FM_SOF(FrameMarker))
        {
#if 0
            ErrOut("Ia64MachineInfo::GetVal: "
                   "out-of-frame register r%ld requested\n",
                   Reg + 32);
            return E_INVALIDARG;
#else
            Val->I64 = 0;
            Val->Nat = TRUE;
            return S_OK;
#endif
        }
        return GetStackedRegVal(g_Process,
                                Bsp,
                                FrameMarker,
                                m_Context.IA64Context.RsRNAT,
                                Reg, Val);
    }
    else if (Reg < IA64_SRBASE)
    {
        Val->Type = REGVAL_INT64;
        Val->I64 = *((PULONGLONG)&m_Context.IA64Context.DbI0 + Reg);
        if (Reg == PREDS)
        {
            Val->I64 = RotatePr(Val->I64, FrameMarker, TRUE);
        }
    }
    else
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

HRESULT
Ia64MachineInfo::GetVal(ULONG Reg, REGVAL* Val)
{
    HRESULT Status;
    
    switch(m_ContextState)
    {
    case MCTX_PC:
        switch (Reg)
        {
        case STIIP:
            Val->Type = REGVAL_INT64;
            Val->I64 = m_Context.IA64Context.StIIP;
            return S_OK;
        }
        goto MctxContext;

    case MCTX_REPORT:
#if 0
        // place holder for Debug/Segment registers manipulation via
        // Control REPORT message
        switch (Reg)
        {
        case KRDBI0:
            Val->Type = REGVAL_INT64;
            Val->I64 = SpecialRegContext.KernelDbi0;
            return S_OK;
        }
#endif

        //
        // Requested register was not in MCTX_REPORT - go get the next
        // context level.
        //

    case MCTX_NONE:
    MctxContext:
        if ((Status = GetContextState(MCTX_CONTEXT)) != S_OK)
        {
            return Status;
        }
        // Fallthrough!
        
    case MCTX_CONTEXT:
        if ((Status =
             GetRotatingRegVal(Reg,
                               m_IfsOverride ?
                               m_BspOverride :
                               m_Context.IA64Context.RsBSP,
                               m_IfsOverride ?
                               IA64_FM_FROM_FS(m_IfsOverride) :
                               IA64_FM_FROM_FS(m_Context.IA64Context.StIFS),
                               Val)) != E_NOINTERFACE)
        {
            if (Status != S_OK)
            {
                return Status;
            }
        }

        //
        // The requested register is not in our current context, load up
        // a complete context
        //

        if ((Status = GetContextState(MCTX_FULL)) != S_OK)
        {
            return Status;
        }
    }

    //
    // We must have a complete context...
    //

    if ((Status =
         GetRotatingRegVal(Reg,
                           m_IfsOverride ?
                           m_BspOverride :
                           m_Context.IA64Context.RsBSP,
                           m_IfsOverride ?
                           IA64_FM_FROM_FS(m_IfsOverride) :
                           IA64_FM_FROM_FS(m_Context.IA64Context.StIFS),
                           Val)) != E_NOINTERFACE)
    {
        return Status;
    }
    else if (IS_KERNEL_TARGET(m_Target) && Reg <= IA64_SREND)
    {
        Val->Type = REGVAL_INT64;
        Val->I64 = *((PULONGLONG)&m_Special.IA64Special.KernelDbI0 +
                     (Reg - IA64_SRBASE));
        return S_OK;
    }
    else
    {
        ErrOut("Ia64MachineInfo::GetVal: "
               "unknown register %lx requested\n", Reg);
        return E_INVALIDARG;
    }
}

HRESULT
Ia64MachineInfo::SetRotatingRegVal(ULONG Reg,
                                   ULONG64 Bsp,
                                   ULONG64 FrameMarker,
                                   REGVAL* Val)
{
    if (Reg >= IA64_FLTBASE && Reg <= IA64_FLTLAST)
    {
        Reg = RotateFr(Reg, FrameMarker);
        memcpy((PULONGLONG)&m_Context.IA64Context.DbI0 + Reg,
               Val->F82, sizeof(Val->F82));
    }
    else if ((Reg >= INTGP) && (Reg <= INTT22))
    {
        ULONG64 Mask = (0x1i64 << (Reg - INTGP + 1));
        
        if (Val->Nat)
        {
            m_Context.IA64Context.IntNats |= Mask;
        }
        else
        {
            m_Context.IA64Context.IntNats &= ~Mask;
            *((PULONGLONG)&m_Context.IA64Context.DbI0 + Reg) = Val->I64;
        }
    }
    else if ((Reg >= INTR32) && (Reg <= INTR127))
    {
        Reg = RotateGr(Reg, FrameMarker) - INTR32;
        if (Reg >= IA64_FM_SOF(FrameMarker))
        {
            ErrOut("Ia64MachineInfo::SetVal: "
                   "out-of-frame register r%ld requested\n",
                   Reg + 32);
            return E_INVALIDARG;
        }
        return SetStackedRegVal(g_Process,
                                Bsp,
                                FrameMarker,
                                &m_Context.IA64Context.RsRNAT,
                                Reg, Val);
    }
    else if (Reg < IA64_SRBASE)
    {
        ULONG64 RawVal = Val->I64;
        
        if (Reg == PREDS)
        {
            RawVal = RotatePr(RawVal, FrameMarker, FALSE);
        }
        *((PULONGLONG)&m_Context.IA64Context.DbI0 + Reg) = RawVal;
    }
    else
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

HRESULT
Ia64MachineInfo::SetVal(ULONG Reg, REGVAL* Val)
{
    HRESULT Status;
    
    if (m_ContextIsReadOnly)
    {
        return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    
    BOOL Ia32InstructionSet = IsIA32InstructionSet();

    // Optimize away some common cases where registers are
    // set to their current value.

    if ((Reg == STIIP) && (m_ContextState >= MCTX_PC))
    {
        if (Val->Type != REGVAL_INT64)
        {
            return E_INVALIDARG;
        }

        ULONG64 Slot, Bundle;

        if ((Ia32InstructionSet && 
             (m_Context.IA64Context.StIIP == Val->I64)) ||
            ((SplitIa64Pc(Val->I64, &Bundle, &Slot) &&
             (Bundle == m_Context.IA64Context.StIIP) &&
             (Slot == ((m_Context.IA64Context.StIPSR & IPSR_RI_MASK) >> 
                       PSR_RI)))))
        {
            return S_OK;
        }
    }
         
    if ((Status = GetContextState(MCTX_DIRTY)) != S_OK)
    {
        return Status;
    }
    
    if (Reg == STIIP) 
    {
        ULONG64 Bundle, Slot;

        if ((Val->Type != REGVAL_INT64) || 
            !(Ia32InstructionSet || SplitIa64Pc(Val->I64, &Bundle, &Slot)))
        {
            return E_INVALIDARG;
        }

        if (Ia32InstructionSet) 
        {
            m_Context.IA64Context.StIIP = Val->I64;
        }
        else
        {
            m_Context.IA64Context.StIIP = Bundle;
            (m_Context.IA64Context.StIPSR &= ~(IPSR_RI_MASK)) |= 
                (ULONGLONG)Slot << PSR_RI;
        }
    }
    else if ((Status =
              SetRotatingRegVal(Reg,
                                m_IfsOverride ?
                                m_BspOverride :
                                m_Context.IA64Context.RsBSP,
                                m_IfsOverride ?
                                IA64_FM_FROM_FS(m_IfsOverride) :
                                IA64_FM_FROM_FS(m_Context.IA64Context.StIFS),
                                Val)) != E_NOINTERFACE)
    {
        if (Status != S_OK)
        {
            return Status;
        }
    }
    else if (IS_KERNEL_TARGET(m_Target) && Reg <= IA64_SREND)
    {
        *((PULONGLONG)&m_Special.IA64Special.KernelDbI0 +
          (Reg - IA64_SRBASE)) = Val->I64;
    }
    else
    {
        ErrOut("Ia64MachineInfo::SetVal: "
               "unknown register %lx requested\n", Reg);
        return E_INVALIDARG;
    }

    NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS,
                              RegCountFromIndex(Reg));
    return S_OK;
}

void
Ia64MachineInfo::GetPC (PADDR Address)
{
    ULONG64 value, slot;

    // get slot# from IPSR.ri and place them in bit(2-3)
    slot = (GetReg64(STIPSR) >> (PSR_RI - 2)) & 0xc;
    // Do not use ISR.ei which does not contain the restart instruction slot.

    value = GetReg64(STIIP) | slot;
    ADDRFLAT(Address, value);
}

void
Ia64MachineInfo::SetPC (PADDR paddr)
{
    SetReg64(STIIP, Flat(*paddr));
}

void
Ia64MachineInfo::GetFP(PADDR Address)
{
    //  IA64 software convention has no frame pointer defined.
    //    FP_REG need to be derived from virtual unwind of stack.

    DEBUG_STACK_FRAME StackFrame;

    StackTrace( NULL,
                0, 0, 0, STACK_ALL_DEFAULT, &StackFrame, 1, 0, 0, FALSE );
    ADDRFLAT(Address, StackFrame.FrameOffset);
}

void
Ia64MachineInfo::GetSP(PADDR Address)
{
    ADDRFLAT(Address, GetReg64(INTSP));
}

ULONG64
Ia64MachineInfo::GetArgReg(void)
{
    return GetReg64(INTT0);
}

ULONG64
Ia64MachineInfo::GetRetReg(void)
{
    return GetReg64(INTV0);
}

/*** RegOutputAll - output all registers and present instruction
*
*   Purpose:
*       Function of "r" command.
*
*       To output the current register state of the processor.
*       All integer registers are output as well as processor status
*       registers in the _CONTEXT record.  Important flag fields are
*       also output separately. OutDisCurrent is called to output the
*       current instruction(s).
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*************************************************************************/

void
Ia64MachineInfo::OutputAll(ULONG Mask, ULONG OutMask)
{
    int       RegIndex, Col = 0;
    int       LastOut;
    USHORT    NumStackReg;
    REGVAL    Val;
    ULONG     i;

    if (GetContextState(MCTX_FULL) != S_OK)
    {
        ErrOut("Unable to retrieve register information\n");
        return;
    }
    
    // Output user debug registers

    if (Mask & REGALL_DREG)
    {
        for (RegIndex = IA64_DBBASE;
             RegIndex <= IA64_DBLAST;
             RegIndex++)
        {
            MaskOut(OutMask, "%9s = %16I64x", 
                    RegNameFromIndex(RegIndex),
                    GetReg64(RegIndex));
            if (RegIndex % 2 == 1)
            {
                MaskOut(OutMask, "\n");
            }
            else
            {
                MaskOut(OutMask, "\t");
            }
        }
        MaskOut(OutMask, "\n");
    }

    if (Mask & (REGALL_INT32 | REGALL_INT64))
    {
        if (Mask & REGALL_SPECIALREG)
        {
            // + ARs + DBs + SRs
            LastOut = IA64_SREND + 1;
        }
        else
        {
            // INTs, PREDS, BRs,
            LastOut = IA64_SRBASE;
        }

        NumStackReg = (USHORT)(GetReg64(STIFS) & IA64_PFS_SIZE_MASK);

        //   Output all registers, skip INTZERO and floating point registers

        for (RegIndex = IA64_REGBASE; RegIndex < LastOut; RegIndex++)
        {
            if (RegIndex == BRRP || RegIndex == PREDS || RegIndex == APUNAT ||
                RegIndex == IA64_SRBASE || RegIndex == INTR32) 
            {
                if (Col % 2 == 1)
                {
                    MaskOut(OutMask, "\n");
                }
                MaskOut(OutMask, "\n");
                Col = 0;
            }

            if (INTGP <= RegIndex && RegIndex <= INTT22)
            {
                if (GetVal(RegIndex, &Val) == S_OK)
                {
                    MaskOut(OutMask, "%9s = %16I64x %1lx",
                            RegNameFromIndex(RegIndex),
                            Val.I64, Val.Nat);
                }
                if (Col % 2 == 1)
                {
                    MaskOut(OutMask, "\n");
                }
                else
                {
                    MaskOut(OutMask, "\t");
                }
                Col++;
            }
            else if (INTR32 <= RegIndex && RegIndex <= INTR127)
            {
                if ((NumStackReg != 0) && GetVal(RegIndex, &Val) == S_OK)
                {
                    MaskOut(OutMask, "%9s = %16I64x %1lx",
                            RegNameFromIndex(RegIndex),
                            Val.I64, Val.Nat);
                    NumStackReg--;
                    if (Col % 2 == 1)
                    {
                        MaskOut(OutMask, "\n");
                    }
                    else
                    {
                        MaskOut(OutMask, "\t");
                    }
                    Col++;
                }
            }
            else
            {
                MaskOut(OutMask, "%9s = %16I64x",
                        RegNameFromIndex(RegIndex),
                        GetReg64(RegIndex));
                if (Col % 2 == 1)
                {
                    MaskOut(OutMask, "\n");
                }
                else
                {
                    MaskOut(OutMask, "\t");
                }
                Col++;
            }
        }
        MaskOut(OutMask, "\n");

/*
        //    Output IPSR flags
        MaskOut(OutMask, "\n\tipsr:\tbn ed ri ss dd da id it tme is cpl rt tb lp db\n");
        MaskOut(OutMask, "\t\t %1lx %1lx  %1lx  %1lx  %1lx  %1lx  %1lx  %1lx  %1lx   %1lx  %1lx   %1lx  %1lx  %1lx  %1lx\n",
                GetSubReg32(IPSRBN),
                GetSubReg32(IPSRED),
                GetSubReg32(IPSRRI),
                GetSubReg32(IPSRSS),
                GetSubReg32(IPSRDD),
                GetSubReg32(IPSRDA),
                GetSubReg32(IPSRID),
                GetSubReg32(IPSRIT),
                GetSubReg32(IPSRME),
                GetSubReg32(IPSRIS),
                GetSubReg32(IPSRCPL),
                GetSubReg32(IPSRRT),
                GetSubReg32(IPSRTB),
                GetSubReg32(IPSRLP),
                GetSubReg32(IPSRDB));
        MaskOut(OutMask, "\t\tsi di pp sp dfh dfl dt bn pk i ic ac up be or\n");
        MaskOut(OutMask, "\t\t %1lx  %1lx  %1lx  %1lx  %1lx   %1lx   %1lx  %1lx  %1lx %1lx  %1lx  %1lx  %1lx  %1lx\n",
                GetSubReg32(IPSRSI),
                GetSubReg32(IPSRDI),
                GetSubReg32(IPSRPP),
                GetSubReg32(IPSRSP),
                GetSubReg32(IPSRDFH),
                GetSubReg32(IPSRDFL),
                GetSubReg32(IPSRDT),
                GetSubReg32(IPSRPK),
                GetSubReg32(IPSRI),
                GetSubReg32(IPSRIC),
                GetSubReg32(IPSRAC),
                GetSubReg32(IPSRUP),
                GetSubReg32(IPSRBE),
                GetSubReg32(IPSROR));
*/
    }

    if (Mask & REGALL_FLOAT)
    {
/*
        //    Output FPSR flags
        MaskOut(OutMask, "\n\tfpsr:\tmdh mdl  sf3  sf2  sf1  sf0  id ud od zd dd vd\n");
        MaskOut(OutMask, "\t\t %1lx   %1lx  %04lx %04lx %04lx %04lx   %1lx  %1lx  %1lx  %1lx  %1lx  %1lx\n",
                GetSubReg32(FPSRMDH),
                GetSubReg32(FPSRMDL),
                GetSubReg32(FPSRSF3),
                GetSubReg32(FPSRSF2),
                GetSubReg32(FPSRSF1),
                GetSubReg32(FPSRSF0),
                GetSubReg32(FPSRTRAPID),
                GetSubReg32(FPSRTRAPUD),
                GetSubReg32(FPSRTRAPOD),
                GetSubReg32(FPSRTRAPZD),
                GetSubReg32(FPSRTRAPDD),
                GetSubReg32(FPSRTRAPVD));
*/

        //
        // Print the low floating point register set, skip FLTZERO & FLTONE
        //

        MaskOut(OutMask, "\n");
        for (i = IA64_FLTBASE; i < FLTF32; i += 2)
        {
            GetVal(i, &Val);
            MaskOut(OutMask, "%9s = %I64x %I64x\n", RegNameFromIndex(i),
                    Val.F16Parts.High, Val.F16Parts.Low);
        }
    }

    if (Mask & REGALL_HIGHFLOAT)
    {
        //
        // Print the low floating point register set, skip FLTZERO & FLTONE
        //

        MaskOut(OutMask, "\n");
        for (i = FLTF32 ; i <= FLTF127; i += 2)
        {
            GetVal(i, &Val);
            MaskOut(OutMask, "%9s = %I64x %I64x\n", RegNameFromIndex(i),
                    Val.F16Parts.High, Val.F16Parts.Low);
        }
    }
}

#define HIGH128(x) (((FLOAT128 *)(&x))->HighPart)
#define LOW128(x) (((FLOAT128 *)(&x))->LowPart)

#define HIGHANDLOW128(x) HIGH128(x), LOW128(x)

HRESULT
Ia64MachineInfo::SetAndOutputTrapFrame(ULONG64 TrapBase,
                                       PCROSS_PLATFORM_CONTEXT Context)
{
    HRESULT Status;
    IA64_KTRAP_FRAME TrapContents;
    ULONG64 Address = TrapBase, IntSp;
    DWORD64 DisasmAddr;
    DWORD64 Displacement;
    DWORD64 Bsp, RealBsp;
    DWORD SizeOfFrame;
    DWORD i;
    SHORT temp;
    CHAR Buffer[80];
    ULONG64 StIIP, StISR;

    if ((Status = m_Target->ReadAllVirtual(m_Target->m_ProcessHead,
                                           Address, &TrapContents,
                                           sizeof(TrapContents))) != S_OK)
    {
        ErrOut("Unable to read trap frame at %s\n",
               FormatMachineAddr64(this, Address));
        return Status;
    }

    dprintf("f6 (ft0) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT0) );
    dprintf("f7 (ft1) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT1));
    dprintf("f8 (ft2) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT2));
    dprintf("f9 (ft3) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT3));
    dprintf("f10 (ft3) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT4));
    dprintf("f11 (ft4) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT5));
    dprintf("f12 (ft5) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT6));
    dprintf("f13 (ft6) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT7));
    dprintf("f14 (ft7) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT8));
    dprintf("f15 (ft8) =\t %016I64x %016I64x\n" , HIGHANDLOW128(TrapContents.FltT9));

    dprintf("unat =\t %016I64lx\t", TrapContents.ApUNAT);
    dprintf("ccv =\t %016I64lx\n" , TrapContents.ApCCV);
    dprintf("dcr =\t %016I64lx\t" , TrapContents.ApDCR);
    dprintf("preds =\t %016I64lx\n",TrapContents.Preds);

    dprintf("rsc =\t %016I64lx\t",  TrapContents.RsRSC);

    SizeOfFrame = (ULONG)(TrapContents.StIFS & (IA64_PFS_SIZE_MASK));

    if (TrapContents.PreviousMode == 1 /*UserMode*/)
    {
        ULONG64 RsBSPSTORE=TrapContents.RsBSPSTORE;
        dprintf("rnat =\t %016I64lx\n", TrapContents.RsRNAT);
        dprintf("bspstore=%016I64lx\n", RsBSPSTORE);

        //
        // Calculate where the stacked registers are for the function which trapped.  
        // The regisisters are stored in the kernel backing store notCalculated the users.  
        // First calculate the start of the kernel store based on trap address, since 
        // this is a user mode trap we should start at the begining of the kernel stack
        // so just round up the trap address to a page size.  Next calculate the actual 
        // BSP for the function.  This depends on the  BSP and BSPstore at the time of
        // the trap.  Note that the trap handle start the kernel backing store on the 
        // same alignment as the user's BSPstore.  
        // 

        //Calculated
        // Round trap address to a page boundary. The should be the Initial kernel BSP.
        //

        Bsp = (Address + IA64_PAGE_SIZE - 1) & ~(DWORD64)(IA64_PAGE_SIZE - 1);

        //
        // Start the actual stack on the same bountry as the users.
        //

        Bsp += RsBSPSTORE & IA64_RNAT_ALIGNMENT;

        //
        // The BSP of the trap handler is right after all the user values have been
        // saved.  The unsaved user values is the differenc of BSP and BSPStore.
        //

        Bsp += TrapContents.RsBSP - RsBSPSTORE;

    }
    else
    {
        dprintf("rnat =\t ???????? ????????\n", TrapContents.RsRNAT);
        dprintf("bspstore=???????? ????????\n", TrapContents.RsBSPSTORE);

        //
        // For kernel mode the actual BSP is saved.
        //

        Bsp = TrapContents.RsBSP;
    }

    //
    //  Now backup by the size of the faulting functions frame.
    //

    Bsp -= (SizeOfFrame * sizeof(ULONGLONG));

    //
    // Adjust for saved RNATs
    //

    temp = (SHORT)(Bsp >> 3) & IA64_NAT_BITS_PER_RNAT_REG;
    temp += (SHORT)SizeOfFrame - IA64_NAT_BITS_PER_RNAT_REG;
    while (temp >= 0)
    {
        Bsp -= sizeof(ULONGLONG);
        temp -= IA64_NAT_BITS_PER_RNAT_REG;
    }

    dprintf("bsp =\t %016I64lx\t",  TrapContents.RsBSP);
    dprintf("Real bsp = %016I64lx\n",  RealBsp = Bsp);


    dprintf("r1 (gp) =\t %016I64lx\t" ,  TrapContents.IntGp);
    dprintf("r2 (t0) =\t %016I64lx\n" ,  TrapContents.IntT0);
    dprintf("r3 (t1) =\t %016I64lx\t" ,  TrapContents.IntT1);
    dprintf("r8 (v0) =\t %016I64lx\n" ,  TrapContents.IntV0);
    dprintf("r9 (t2) =\t %016I64lx\t" ,  TrapContents.IntT2);
    dprintf("r10 (t3) =\t %016I64lx\n" ,  TrapContents.IntT3);
    dprintf("r11 (t4) =\t %016I64lx\t" ,  TrapContents.IntT4);
    dprintf("r12 (sp) =\t %016I64lx\n" ,  IntSp = TrapContents.IntSp);
    dprintf("r13 (teb) =\t %016I64lx\t" , TrapContents.IntTeb);
    dprintf("r14 (t5) =\t %016I64lx\n" ,  TrapContents.IntT5);
    dprintf("r15 (t6) =\t %016I64lx\t" ,  TrapContents.IntT6);
    dprintf("r16 (t7) =\t %016I64lx\n" ,  TrapContents.IntT7);
    dprintf("r17 (t8) =\t %016I64lx\t" ,  TrapContents.IntT8);
    dprintf("r18 (t9) =\t %016I64lx\n" ,  TrapContents.IntT9);
    dprintf("r19 (t10) =\t %016I64lx\t" , TrapContents.IntT10);
    dprintf("r20 (t11) =\t %016I64lx\n" , TrapContents.IntT11);
    dprintf("r21 (t12) =\t %016I64lx\t" , TrapContents.IntT12);
    dprintf("r22 (t13) =\t %016I64lx\n" , TrapContents.IntT13);
    dprintf("r23 (t14) =\t %016I64lx\t" , TrapContents.IntT14);
    dprintf("r24 (t15) =\t %016I64lx\n" , TrapContents.IntT15);
    dprintf("r25 (t16) =\t %016I64lx\t" , TrapContents.IntT16);
    dprintf("r26 (t17) =\t %016I64lx\n" , TrapContents.IntT17);
    dprintf("r27 (t18) =\t %016I64lx\t" , TrapContents.IntT18);
    dprintf("r28 (t19) =\t %016I64lx\n" , TrapContents.IntT19);
    dprintf("r29 (t20) =\t %016I64lx\t" , TrapContents.IntT20);
    dprintf("r30 (t21) =\t %016I64lx\n" , TrapContents.IntT21);
    dprintf("r31 (t22) =\t %016I64lx\n" , TrapContents.IntT22);

    //
    // Print out the stack registers.
    //

    for ( i = 0; i < SizeOfFrame; Bsp += sizeof(ULONGLONG))
    {
        ULONGLONG reg;

        //
        // Skip the NAT values.
        //

        if ((Bsp & IA64_RNAT_ALIGNMENT) == IA64_RNAT_ALIGNMENT)
        {
            continue;
        }

        if (m_Target->ReadAllVirtual(m_Target->m_ProcessHead,
                                     Bsp, &reg, sizeof(reg)) != S_OK)
        {
            dprintf("Cannot read backing register store at %16I64x\n", Bsp);
        }

        dprintf("r%d =\t\t %016I64lx", (i + 32), reg);

        if ((i % 2) == 1)
        {
            dprintf("\n");
        }
        else
        {
            dprintf("\t");
        }

        i++;
    }

    dprintf("\n");


    dprintf("b0 (brrp) =\t %016I64lx\n", TrapContents.BrRp);
    dprintf("b6 (brt0) =\t %016I64lx\n", TrapContents.BrT0);
    dprintf("b7 (brt1) =\t %016I64lx\n", TrapContents.BrT1);


    dprintf("nats =\t %016I64lx\n", TrapContents.IntNats);
    dprintf("pfs =\t %016I64lx\n",  TrapContents.RsPFS);

    dprintf("ipsr =\t %016I64lx\n", TrapContents.StIPSR);
    dprintf("isr =\t %016I64lx\n" , (StISR = TrapContents.StISR));
    dprintf("ifa =\t %016I64lx\n" , TrapContents.StIFA);
    dprintf("iip =\t %016I64lx\n" , StIIP = TrapContents.StIIP);
    dprintf("iipa =\t %016I64lx\n", TrapContents.StIIPA);
    dprintf("ifs =\t %016I64lx\n" , TrapContents.StIFS);
    dprintf("iim =\t %016I64lx\n" , TrapContents.StIIM);
    dprintf("iha =\t %016I64lx\n" , TrapContents.StIHA);

    dprintf("fpsr =\t\t  %08lx\n" , TrapContents.StFPSR);


    //  iA32 status info ???

    dprintf("oldirql =\t  %08lx\n" , TrapContents.OldIrql);
    dprintf("previousmode =\t  %08lx\n" , TrapContents.PreviousMode);
    dprintf("trapframe =\t  %08lx\n" , TrapContents.TrapFrame);

    ULONG TrapFrameType = (ULONG)(TrapContents.EOFMarker) & 0xf;

    switch (TrapFrameType)
    {
    case IA64_SYSCALL_FRAME:
        dprintf("Trap Type: syscall\n");
        break;
    case IA64_INTERRUPT_FRAME:
        dprintf("Trap Type: interrupt\n");
        break;
    case IA64_EXCEPTION_FRAME:
        dprintf("Trap Type: exception\n");
        break;
    case IA64_CONTEXT_FRAME:
        dprintf("Trap Type: context\n");
        break;
    default:
        dprintf("Trap Type: unknown\n");
        break;
    }

    DisasmAddr = StIIP;

    //
    // Adjust for the bundle. 
    //

    DisasmAddr += ((StISR >> 41) & 3) * 4;

    GetSymbol(DisasmAddr, Buffer, sizeof(Buffer), &Displacement);
    dprintf("\n%s+0x%I64x\n", Buffer, Displacement);
    
    ADDR    tempAddr;

    Type(tempAddr) = ADDR_FLAT | FLAT_COMPUTED;
    Off(tempAddr) = Flat(tempAddr) = DisasmAddr;
    if (Disassemble(m_Target->m_ProcessHead, &tempAddr, Buffer, FALSE))
    {
        dprintf(Buffer);
    }
    else
    {
        dprintf("???????????????\n", DisasmAddr);
    }
    
    GetScopeFrameFromContext(Context, &g_LastRegFrame);
        
    SetCurrentScope(&g_LastRegFrame, Context, m_SizeCanonicalContext);

    return S_OK;
}

TRACEMODE
Ia64MachineInfo::GetTraceMode (void)
{
    if (IS_KERNEL_TARGET(m_Target))
    {
        return m_TraceMode;
    }
    else
    {
        ULONG64 Ipsr = GetReg64(STIPSR);
        if (Ipsr & (1I64 << PSR_SS)) 
        {
            return TRACE_INSTRUCTION;
        }
        else if (Ipsr & (1I64 << PSR_TB)) 
        {
            return TRACE_TAKEN_BRANCH;
        }
        else 
        {
            return TRACE_NONE;
        }
    }
}

void
Ia64MachineInfo::SetTraceMode (TRACEMODE Mode)
{
    DBG_ASSERT(Mode == TRACE_NONE ||
               Mode == TRACE_INSTRUCTION ||
               Mode == TRACE_TAKEN_BRANCH);

    if (IS_KERNEL_TARGET(m_Target))
    {
        m_TraceMode = Mode;
    }
    else 
    {
        ULONG64 Ipsr, IpsrSave;
        Ipsr = IpsrSave = GetReg64(STIPSR);

        Ipsr &= ~(1I64 << PSR_SS);
        Ipsr &= ~(1I64 << PSR_TB);

        switch (Mode) 
        {
        case TRACE_INSTRUCTION:
            Ipsr |= (1I64 << PSR_SS);
            break;
        case TRACE_TAKEN_BRANCH:
            Ipsr |= (1I64 << PSR_TB);
            break;
        }
        
        if (Ipsr != IpsrSave)
        {
            SetReg64(STIPSR, Ipsr);
        }
    }
}

BOOL
Ia64MachineInfo::IsStepStatusSupported(ULONG Status)
{
    switch (Status) 
    {
    case DEBUG_STATUS_STEP_INTO:   // TRACE_INSTRUCTION
    case DEBUG_STATUS_STEP_OVER:   
    case DEBUG_STATUS_STEP_BRANCH: // TRACE_TAKEN_BRANCH
        return TRUE;
    default:
        return FALSE;
    }
}

void
Ia64MachineInfo::KdUpdateControlSet
    (PDBGKD_ANY_CONTROL_SET ControlSet)
{
    switch (GetTraceMode()) 
    {
    case TRACE_NONE:
        ControlSet->IA64ControlSet.Continue = 
            IA64_DBGKD_CONTROL_SET_CONTINUE_NONE;
        break;

    case TRACE_INSTRUCTION:
        ControlSet->IA64ControlSet.Continue = 
            IA64_DBGKD_CONTROL_SET_CONTINUE_TRACE_INSTRUCTION;
        break;

    case TRACE_TAKEN_BRANCH:
        ControlSet->IA64ControlSet.Continue = 
            IA64_DBGKD_CONTROL_SET_CONTINUE_TRACE_TAKEN_BRANCH;
        break;
    }

    if (!g_WatchFunctions.IsStarted() && g_WatchBeginCurFunc != 1)
    {
        ControlSet->IA64ControlSet.CurrentSymbolStart = 0;
        ControlSet->IA64ControlSet.CurrentSymbolEnd = 0;
    }
    else
    {
        ControlSet->IA64ControlSet.CurrentSymbolStart = g_WatchBeginCurFunc;
        ControlSet->IA64ControlSet.CurrentSymbolEnd = g_WatchEndCurFunc;
    }
}

ULONG
Ia64MachineInfo::ExecutingMachine(void)
{
    if (IsIA32InstructionSet())
    {
        return IMAGE_FILE_MACHINE_I386;
    }

    return IMAGE_FILE_MACHINE_IA64;
}

HRESULT
Ia64MachineInfo::SetPageDirectory(ThreadInfo* Thread,
                                  ULONG Idx, ULONG64 PageDir,
                                  PULONG NextIdx)
{
    HRESULT Status;

    switch(Idx)
    {
    case PAGE_DIR_USER:
        if (PageDir == 0)
        {
            if ((Status = m_Target->ReadImplicitProcessInfoPointer
                 (Thread,
                  m_Target->m_KdDebuggerData.OffsetEprocessDirectoryTableBase,
                  &PageDir)) != S_OK)
            {
                return Status;
            }
        }
        *NextIdx = PAGE_DIR_SESSION;
        break;

    case PAGE_DIR_SESSION:
        if (PageDir == 0)
        {
            if ((Status = m_Target->
                 ReadImplicitProcessInfoPointer
                 (Thread,
                  m_Target->m_KdDebuggerData.OffsetEprocessDirectoryTableBase +
                  5 * sizeof(ULONG64), &PageDir)) != S_OK)
            {
                return Status;
            }
        }
        *NextIdx = PAGE_DIR_KERNEL;
        break;

    case PAGE_DIR_KERNEL:
        if (PageDir == 0)
        {
            PageDir = m_KernPageDir;
            if (PageDir == 0)
            {
                ErrOut("Invalid IA64 kernel page directory base 0x%I64x\n",
                       PageDir);
                return E_FAIL;
            }
        }
        *NextIdx = PAGE_DIR_COUNT;
        break;

    case 4:
    case 5:
        // There's a directly mapped physical section for
        // most of regions 4 and 5 so allow the default to be
        // set for this directory index.
        if (PageDir != 0)
        {
            return E_INVALIDARG;
        }
        *NextIdx = Idx + 1;
        break;
        
    default:
        return E_INVALIDARG;
    }

    // Sanitize the value.
    m_PageDirectories[Idx] =
        ((PageDir & IA64_VALID_PFN_MASK) >> IA64_VALID_PFN_SHIFT) <<
        IA64_PAGE_SHIFT;
    return S_OK;
}

#define IA64_PAGE_FILE_INDEX(Entry) \
    (((ULONG)(Entry) >> 28) & MAX_PAGING_FILE_MASK)
#define IA64_PAGE_FILE_OFFSET(Entry) \
    (((Entry) >> 32) << IA64_PAGE_SHIFT)

HRESULT
Ia64MachineInfo::GetVirtualTranslationPhysicalOffsets(ThreadInfo* Thread,
                                                      ULONG64 Virt,
                                                      PULONG64 Offsets,
                                                      ULONG OffsetsSize,
                                                      PULONG Levels,
                                                      PULONG PfIndex,
                                                      PULONG64 LastVal)
{
    HRESULT Status;

    *Levels = 0;
    
    if (m_Translating)
    {
        return E_UNEXPECTED;
    }
    m_Translating = TRUE;
    
    ULONG Vrn = (ULONG)((Virt & IA64_REGION_MASK) >> IA64_REGION_SHIFT);
    
    //
    // Reset the page directory in case it was 0
    //
    if (m_PageDirectories[Vrn] == 0)
    {
        if ((Status = SetDefaultPageDirectories(Thread, 1 << Vrn)) != S_OK)
        {
            m_Translating = FALSE;
            return Status;
        }
    }

    KdOut("Ia64VtoP: Virt %s, pagedir %d:%s\n",
          FormatMachineAddr64(this, Virt), Vrn,
          FormatDisp64(m_PageDirectories[Vrn]));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = m_PageDirectories[Vrn];
        OffsetsSize--;
    }
        
    //
    // Certain ranges of the system are mapped directly.
    //

    if ((Virt >= IA64_PHYSICAL1_START) && (Virt <= IA64_PHYSICAL1_END))
    {
        *LastVal = Virt - IA64_PHYSICAL1_START;

        KdOut("Ia64VtoP: Direct phys 1 %s\n",
              FormatDisp64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }
    if ((Virt >= IA64_PHYSICAL2_START) && (Virt <= IA64_PHYSICAL2_END))
    {
        *LastVal = Virt - IA64_PHYSICAL2_START;

        KdOut("Ia64VtoP: Direct phys 2 %s\n",
              FormatDisp64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }
    if ((Virt >= IA64_PHYSICAL3_START) && (Virt <= IA64_PHYSICAL3_END))
    {
        *LastVal = Virt - IA64_PHYSICAL3_START;

        KdOut("Ia64VtoP: Direct phys 3 %s\n",
              FormatDisp64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }

    // If we're still translating and there's no page
    // directory we have a garbage address.
    if (m_PageDirectories[Vrn] == 0)
    {
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }

    ULONG64 Addr;
    ULONG64 Entry;

    //
    // On IA64 the page tables themselves have special virtual
    // addresses that need to be handled differently when
    // translating.  The level within the paging hierarchy
    // must be determined and translation started at the
    // appropriate level.
    //

    if (m_Target->m_KdDebuggerData.MmVirtualTranslationBase)
    {
        ULONG64 Mask = m_Target->m_KdDebuggerData.MmVirtualTranslationBase;

        if ((Virt & Mask) == Mask &&
            (Virt & ~(IA64_REGION_MASK | Mask)) < (1UI64 << IA64_PDE1_SHIFT))
        {
            // PTE VA, skip PDE1 translation.
            KdOut("Ia64VtoP: PTE VA\n");
            Entry = (m_PageDirectories[Vrn] >> IA64_PAGE_SHIFT) <<
                IA64_VALID_PFN_SHIFT;
            goto Pde2Addr;
        }

        Mask |= Mask >> (IA64_PDE1_SHIFT - IA64_PDE2_SHIFT);
        if ((Virt & Mask) == Mask &&
            (Virt & ~(IA64_REGION_MASK | Mask)) < (1UI64 << IA64_PDE2_SHIFT))
        {
            // PDE2 VA, skip PDE1 and PDE2 translation.
            KdOut("Ia64VtoP: PDE2 VA\n");
            Entry = (m_PageDirectories[Vrn] >> IA64_PAGE_SHIFT) <<
                IA64_VALID_PFN_SHIFT;
            goto PteAddr;
        }

        Mask |= Mask >> (IA64_PDE2_SHIFT - IA64_PTE_SHIFT);
        if ((Virt & Mask) == Mask &&
            (Virt & ~(IA64_REGION_MASK | Mask)) < IA64_PAGE_SIZE)
        {
            // PDE1 VA, skip to page offset.
            KdOut("Ia64VtoP: PDE1 VA\n");
            Entry = (m_PageDirectories[Vrn] >> IA64_PAGE_SHIFT) <<
                IA64_VALID_PFN_SHIFT;
            goto PageAddr;
        }
    }

    // Default, normal page VA.
    Addr = (((Virt >> IA64_PDE1_SHIFT) & IA64_PDE_MASK) * sizeof(Entry)) +
        m_PageDirectories[Vrn];
    
    Status = m_Target->ReadAllPhysical(Addr, &Entry, sizeof(Entry));
    
    KdOut("Ia64VtoP: PDE1 %s - %016I64x, 0x%X\n",
          FormatDisp64(Addr), Entry, Status);
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = Addr;
        OffsetsSize--;
    }
        
    if (Status != S_OK)
    {
        KdOut("Ia64VtoP: PDE1 read error 0x%X\n", Status);
        m_Translating = FALSE;
        return Status;
    }

    if (Entry == 0)
    {
        KdOut("Ia64VtoP: zero PDE1\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> IA64_PDE2_SHIFT) & IA64_PDE_MASK) *
                sizeof(Entry)) + IA64_PAGE_FILE_OFFSET(Entry);

        KdOut("Ia64VtoP: pagefile PDE2 %d:%s\n",
              IA64_PAGE_FILE_INDEX(Entry), FormatDisp64(Addr));
        
        if ((Status = m_Target->
             ReadPageFile(IA64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Ia64VtoP: PDE1 not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
    Pde2Addr:
        Addr = (((Virt >> IA64_PDE2_SHIFT) & IA64_PDE_MASK) * sizeof(Entry)) +
            (((Entry & IA64_VALID_PFN_MASK) >> IA64_VALID_PFN_SHIFT) <<
             IA64_PAGE_SHIFT);

        Status = m_Target->ReadAllPhysical(Addr, &Entry, sizeof(Entry));
    
        KdOut("Ia64VtoP: PDE2 %s - %016I64x, 0x%X\n",
              FormatDisp64(Addr), Entry, Status);
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if (Status != S_OK)
        {
            KdOut("Ia64VtoP: PDE2 read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }

    // Check for a large page.  Large pages can
    // never be paged out so also check for the present bit.
    if ((Entry & (IA64_LARGE_PAGE_PDE_MASK | 1)) ==
        (IA64_LARGE_PAGE_PDE_MARK | 1))
    {
        *LastVal = (((Entry & IA64_VALID_PFN_MASK) >> IA64_VALID_PFN_SHIFT) <<
                    IA64_PAGE_SHIFT) +
            (Virt & (IA64_LARGE_PAGE_SIZE - 1));
        
        KdOut("Ia64VtoP: Large page mapped phys %s\n",
              FormatDisp64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }
        
    if (Entry == 0)
    {
        KdOut("Ia64VtoP: zero PDE2\n");
        m_Translating = FALSE;
        return HR_PAGE_NOT_AVAILABLE;
    }
    else if (!(Entry & 1))
    {
        Addr = (((Virt >> IA64_PTE_SHIFT) & IA64_PTE_MASK) *
                sizeof(Entry)) + IA64_PAGE_FILE_OFFSET(Entry);

        KdOut("Ia64VtoP: pagefile PTE %d:%s\n",
              IA64_PAGE_FILE_INDEX(Entry), FormatDisp64(Addr));
        
        if ((Status = m_Target->
             ReadPageFile(IA64_PAGE_FILE_INDEX(Entry), Addr,
                          &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("Ia64VtoP: PDE2 not present, 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    else
    {
    PteAddr:
        Addr = (((Virt >> IA64_PTE_SHIFT) & IA64_PTE_MASK) * sizeof(Entry)) +
            (((Entry & IA64_VALID_PFN_MASK) >> IA64_VALID_PFN_SHIFT) <<
             IA64_PAGE_SHIFT);

        Status = m_Target->ReadAllPhysical(Addr, &Entry, sizeof(Entry));
    
        KdOut("Ia64VtoP: PTE %s - %016I64x, 0x%X\n",
              FormatDisp64(Addr), Entry, Status);
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if (Status != S_OK)
        {
            KdOut("Ia64VtoP: PTE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
    }
    
    if (!(Entry & 0x1) &&
        ((Entry & IA64_MM_PTE_PROTOTYPE_MASK) ||
         !(Entry & IA64_MM_PTE_TRANSITION_MASK)))
    {
        if (Entry == 0)
        {
            KdOut("Ia64VtoP: zero PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else if (Entry & IA64_MM_PTE_PROTOTYPE_MASK)
        {
            KdOut("Ia64VtoP: prototype PTE\n");
            Status = HR_PAGE_NOT_AVAILABLE;
        }
        else
        {
            *PfIndex = IA64_PAGE_FILE_INDEX(Entry);
            *LastVal = (Virt & (IA64_PAGE_SIZE - 1)) +
                IA64_PAGE_FILE_OFFSET(Entry);
            KdOut("Ia64VtoP: PTE not present, pagefile %d:%s\n",
                  *PfIndex, FormatDisp64(*LastVal));
            Status = HR_PAGE_IN_PAGE_FILE;
        }
        m_Translating = FALSE;
        return Status;
    }

 PageAddr:
    //
    // This is a page which is either present or in transition.
    // Return the physical address for the request virtual address.
    //
    
    *LastVal = (((Entry & IA64_VALID_PFN_MASK) >> IA64_VALID_PFN_SHIFT) <<
                 IA64_PAGE_SHIFT) | (Virt & (IA64_PAGE_SIZE - 1));
    
    KdOut("Ia64VtoP: Mapped phys %s\n", FormatDisp64(*LastVal));

    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = *LastVal;
        OffsetsSize--;
    }
        
    m_Translating = FALSE;
    return S_OK;
}

HRESULT
Ia64MachineInfo::GetBaseTranslationVirtualOffset(PULONG64 Offset)
{
    if (m_Target->m_KdDebuggerData.MmVirtualTranslationBase)
    {
        *Offset = m_Target->m_KdDebuggerData.MmVirtualTranslationBase;
        return S_OK;
    }
    
    if (IS_LOCAL_KERNEL_TARGET(m_Target))
    {
        CROSS_PLATFORM_KSPECIAL_REGISTERS Special;
        HRESULT Status;
        
        // We can't actually load a context when
        // local kernel debugging but we can
        // read the special registers and get
        // the PTA value from there.
        if ((Status = m_Target->GetTargetSpecialRegisters
             (VIRTUAL_THREAD_HANDLE(0), &Special)) != S_OK)
        {
            return Status;
        }

        *Offset = Special.IA64Special.ApPTA;
    }
    else
    {
        *Offset = GetReg64(APPTA);
        if (*Offset == 0)
        {
            return E_FAIL;
        }
    }

    m_Target->m_KdDebuggerData.MmVirtualTranslationBase = *Offset;
    return S_OK;
}

void
Ia64MachineInfo::DecodePte(ULONG64 Pte, PULONG64 PageFrameNumber,
                           PULONG Flags)
{
    *PageFrameNumber = (Pte & IA64_VALID_PFN_MASK) >> IA64_VALID_PFN_SHIFT;
    *Flags = (Pte & 1) ? MPTE_FLAG_VALID : 0;
}

void
Ia64MachineInfo::OutputFunctionEntry(PVOID RawEntry)
{
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY Entry =
        (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)RawEntry;
    
    dprintf("BeginAddress      = %s\n",
            FormatMachineAddr64(this, Entry->BeginAddress));
    dprintf("EndAddress        = %s\n",
            FormatMachineAddr64(this, Entry->EndAddress));
    dprintf("UnwindInfoAddress = %s\n",
            FormatMachineAddr64(this, Entry->UnwindInfoAddress));
}

HRESULT
Ia64MachineInfo::ReadDynamicFunctionTable(ProcessInfo* Process,
                                          ULONG64 Table,
                                          PULONG64 NextTable,
                                          PULONG64 MinAddress,
                                          PULONG64 MaxAddress,
                                          PULONG64 BaseAddress,
                                          PULONG64 TableData,
                                          PULONG TableSize,
                                          PWSTR OutOfProcessDll,
                                          PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable)
{
    HRESULT Status;

    if ((Status = m_Target->
         ReadAllVirtual(Process, Table, &RawTable->IA64Table,
                        sizeof(RawTable->IA64Table))) != S_OK)
    {
        return Status;
    }

    *NextTable = RawTable->IA64Table.Links.Flink;
    *MinAddress = RawTable->IA64Table.MinimumAddress;
    *MaxAddress = RawTable->IA64Table.MaximumAddress;
    *BaseAddress = RawTable->IA64Table.BaseAddress;
    if (RawTable->IA64Table.Type == IA64_RF_CALLBACK)
    {
        ULONG Done;
        
        *TableData = 0;
        *TableSize = 0;
        if ((Status = m_Target->
             ReadVirtual(Process, RawTable->IA64Table.OutOfProcessCallbackDll,
                         OutOfProcessDll, (MAX_PATH - 1) * sizeof(WCHAR),
                         &Done)) != S_OK)
        {
            return Status;
        }

        OutOfProcessDll[Done / sizeof(WCHAR)] = 0;
    }
    else
    {
        *TableData = RawTable->IA64Table.FunctionTable;
        *TableSize = RawTable->IA64Table.EntryCount *
            sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY);
        OutOfProcessDll[0] = 0;
    }
    return S_OK;
}

PVOID
Ia64MachineInfo::FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                          ULONG64 Address,
                                          PVOID TableData,
                                          ULONG TableSize)
{
    ULONG i;
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY Func;
    static IMAGE_IA64_RUNTIME_FUNCTION_ENTRY s_RetFunc;

    Func = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)TableData;
    for (i = 0; i < TableSize / sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY); i++)
    {
        if (Address >= IA64_RF_BEGIN_ADDRESS(Table->IA64Table.BaseAddress, Func) &&
            Address < IA64_RF_END_ADDRESS(Table->IA64Table.BaseAddress, Func))
        {
            // The table data is temporary so copy the data into
            // a static buffer for longer-term storage.
            s_RetFunc.BeginAddress = Func->BeginAddress;
            s_RetFunc.EndAddress = Func->EndAddress;
            s_RetFunc.UnwindInfoAddress = Func->UnwindInfoAddress;
            return (PVOID)&s_RetFunc;
        }

        Func++;
    }

    return NULL;
}

HRESULT
Ia64MachineInfo::GetUnwindInfoBounds(ProcessInfo* Process,
                                     ULONG64 TableBase,
                                     PVOID RawTableEntries,
                                     ULONG EntryIndex,
                                     PULONG64 Start,
                                     PULONG Size)
{
    HRESULT Status;
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY FuncEnt =
        (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)RawTableEntries + EntryIndex;
    IA64_UNWIND_INFO Info;
    
    *Start = TableBase + FuncEnt->UnwindInfoAddress;
    if ((Status = m_Target->
         ReadAllVirtual(Process, *Start, &Info, sizeof(Info))) != S_OK)
    {
        return Status;
    }
    *Size = sizeof(Info) + Info.DataLength * sizeof(ULONG64);

    return S_OK;
}

HRESULT
Ia64MachineInfo::ReadKernelProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    HRESULT Status;
    ULONG64 Prcb;
    ULONG Data[4];

    if ((Status = m_Target->
         GetProcessorSystemDataOffset(Processor, DEBUG_DATA_KPRCB_OFFSET,
                                      &Prcb)) != S_OK)
    {
        return Status;
    }

    if ((Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        Prcb + m_Target->m_KdDebuggerData.OffsetPrcbCpuType,
                        Data, sizeof(Data))) != S_OK)
    {
        return Status;
    }

    Id->Ia64.Model = Data[0];
    Id->Ia64.Revision = Data[1];
    Id->Ia64.Family = Data[2];
    Id->Ia64.ArchRev = Data[3];
    
    if ((Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead, Prcb +
                        m_Target->m_KdDebuggerData.OffsetPrcbVendorString,
                        Id->Ia64.VendorString,
                        sizeof(Id->Ia64.VendorString))) != S_OK)
    {
        return Status;
    }

    return S_OK;
}

HRESULT
Ia64MachineInfo::GetAlternateTriageDumpDataRanges(ULONG64 PrcbBase,
                                                  ULONG64 ThreadBase,
                                                  PADDR_RANGE Ranges)
{
    HRESULT Status;
    PADDR_RANGE Range = Ranges;
    ULONG64 PcrBase;
    ULONG64 PcrInitialBStore;
    ULONG64 PcrBStoreLimit;
    ULONG64 PcrInitialStack;
    ULONG64 PcrStackLimit;
    ULONG64 ThInitialBStore;
    ULONG64 ThBStoreLimit;
    ULONG64 ThInitialStack;
    ULONG64 ThStackLimit;
    
#define MAX_ALT_DATA_SIZE 8192

    //
    // In certain failures there is a switch from
    // the current thread's stack and store to
    // a special stack and store.  The PCR contains
    // stack and store pointers which will be different
    // from the current thread's stack and store pointers
    // so save the extra stack and store if they are.
    //
        
    if ((Status = m_Target->
         GetProcessorSystemDataOffset(CURRENT_PROC,
                                      DEBUG_DATA_KPCR_OFFSET,
                                      &PcrBase)) != S_OK ||
        (Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        PcrBase +
                        m_Target->m_KdDebuggerData.OffsetPcrInitialBStore,
                        &PcrInitialBStore,
                        sizeof(PcrInitialBStore))) != S_OK ||
        (Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        PcrBase +
                        m_Target->m_KdDebuggerData.OffsetPcrBStoreLimit,
                        &PcrBStoreLimit, sizeof(PcrBStoreLimit))) != S_OK ||
        (Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        PcrBase +
                        m_Target->m_KdDebuggerData.OffsetPcrInitialStack,
                        &PcrInitialStack, sizeof(PcrInitialStack))) != S_OK ||
        (Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        PcrBase +
                        m_Target->m_KdDebuggerData.OffsetPcrStackLimit,
                        &PcrStackLimit, sizeof(PcrStackLimit))) != S_OK ||
        (Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        ThreadBase +
                        m_Target->m_KdDebuggerData.OffsetKThreadInitialStack,
                        &ThInitialStack, sizeof(ThInitialStack))) != S_OK ||
        (Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        ThreadBase +
                        m_Target->m_KdDebuggerData.OffsetKThreadKernelStack,
                        &ThStackLimit, sizeof(ThStackLimit))) != S_OK ||
        (Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        ThreadBase +
                        m_Target->m_KdDebuggerData.OffsetKThreadBStore,
                        &ThInitialBStore, sizeof(ThInitialBStore))) != S_OK ||
        (Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        ThreadBase +
                        m_Target->m_KdDebuggerData.OffsetKThreadBStoreLimit,
                        &ThBStoreLimit, sizeof(ThBStoreLimit))) != S_OK)
    {
        return Status;
    }

    if (PcrInitialBStore != ThInitialBStore ||
        PcrBStoreLimit != ThBStoreLimit)
    {
        ULONG FrameSize = GetReg32(STIFS) & IA64_PFS_SIZE_MASK;
        ULONG64 StoreTop = GetReg64(RSBSP);
            
        // Add in a ULONG64 for every register in the
        // current frame.  While doing so, check for
        // spill entries.
        while (FrameSize-- > 0)
        {
            StoreTop += sizeof(ULONG64);
            if ((StoreTop & 0x1f8) == 0x1f8)
            {
                // Spill will be placed at this address so
                // account for it.
                StoreTop += sizeof(ULONG64);
            }
        }
        
        if (StoreTop < PcrInitialBStore || StoreTop >= PcrBStoreLimit)
        {
            // BSP isn't in the PCR store range so
            // just save the whole thing.
            StoreTop = PcrBStoreLimit;
        }

        Range->Size = (ULONG)(StoreTop - PcrInitialBStore);
        if (Range->Size > MAX_ALT_DATA_SIZE)
        {
            Range->Size = MAX_ALT_DATA_SIZE;
            Range->Base = StoreTop - Range->Size;
        }
        else
        {
            Range->Base = PcrInitialBStore;
        }

        Range++;
    }

    if (PcrInitialStack != ThInitialStack ||
        PcrStackLimit != ThStackLimit)
    {
        Range->Base = GetReg64(INTSP);
        if (Range->Base < PcrStackLimit || Range->Base >= PcrInitialStack)
        {
            // SP isn't in the PCR stack range so
            // just save the whole thing.
            Range->Base = PcrStackLimit;
        }

        Range->Size = (ULONG)(PcrInitialStack - Range->Base);
        if (Range->Size > MAX_ALT_DATA_SIZE)
        {
            Range->Size = MAX_ALT_DATA_SIZE;
        }
            
        Range++;
    }

    return S_OK;
}

BOOL
Ia64MachineInfo::IsIA32InstructionSet(VOID)
{
    return ((GetReg64(STIPSR) & (1I64 << PSR_IS)) ? TRUE : FALSE);
}

HRESULT
Ia64MachineInfo::GetStackedRegVal(
    IN ProcessInfo* Process,
    IN ULONG64 RsBSP, 
    IN ULONG64 FrameMarker,
    IN ULONG64 RsRNAT, 
    IN ULONG Reg, 
    OUT REGVAL* Val
    )
{
    HRESULT Status;
    SHORT Index;
    SHORT Temp;
    SHORT FrameSize = (SHORT)IA64_FM_SOF(FrameMarker);
    ULONG64 TargetAddress;
    ULONG64 TargetNatAddress;

    Index = (SHORT)(RsBSP >> 3) & NAT_BITS_PER_RNAT_REG;
    Temp = Index + FrameSize - NAT_BITS_PER_RNAT_REG;
    while (Temp >= 0)
    {
        FrameSize++;
        Temp -= NAT_BITS_PER_RNAT_REG;
    }

    TargetAddress = RsBSP;
    while (Reg > 0)
    {
        Reg -= 1;
        TargetAddress += 8;
        if ((TargetAddress & 0x1F8) == 0x1F8)
        {
            TargetAddress += 8;
        }
    }

    if ((Status = m_Target->
         ReadAllVirtual(Process,
                        TargetAddress, (PUCHAR)&Val->I64, 8)) != S_OK)
    {
        ErrOut("Unable to read memory location %I64x\n", TargetAddress);
        return Status;
    }

    Index = (SHORT)((TargetAddress - (TargetAddress & ~(0x1F8i64))) >> 3);
    TargetNatAddress = TargetAddress | 0x1F8;
    if (TargetNatAddress <= (RsBSP + (FrameSize * sizeof(ULONG64))))
    {
        //
        // update backing store
        //

        if ((Status = m_Target->
             ReadAllVirtual(Process,
                            TargetNatAddress, (PUCHAR)&RsRNAT, 8)) != S_OK)
        {
            ErrOut("Unable to read memory location %I64x\n", TargetNatAddress);
            return Status;
        }
    }

    Val->Nat = (UCHAR)(RsRNAT >> Index) & 0x1;
    return S_OK;
}

HRESULT
Ia64MachineInfo::SetStackedRegVal(
    IN ProcessInfo* Process,
    IN ULONG64 RsBSP, 
    IN ULONG64 FrameMarker,
    IN ULONG64 *RsRNAT, 
    IN ULONG Reg, 
    IN REGVAL* Val
    )
{
    HRESULT Status;
    SHORT Index;
    SHORT Temp;
    SHORT FrameSize = (SHORT)IA64_FM_SOF(FrameMarker);
    ULONG64 Mask;
    ULONG64 LocalRnat;
    ULONG64 TargetAddress;
    ULONG64 TargetNatAddress;

    Index = (SHORT)(RsBSP >> 3) & NAT_BITS_PER_RNAT_REG;
    Temp = Index + FrameSize - NAT_BITS_PER_RNAT_REG;
    while (Temp >= 0)
    {
        FrameSize++;
        Temp -= NAT_BITS_PER_RNAT_REG;
    }

    TargetAddress = RsBSP;
    while (Reg > 0)
    {
        Reg -= 1;
        TargetAddress += 8;
        if ((TargetAddress & 0x1F8) == 0x1F8)
        {
            TargetAddress += 8;
        }
    }

    if ((Status = m_Target->
         WriteAllVirtual(Process, TargetAddress, &Val->I64, 8)) != S_OK)
    {
        ErrOut("Unable to write memory location %I64x\n", TargetAddress);
        return Status;
    }

    Index = (SHORT)((TargetAddress - (TargetAddress & ~(0x1F8i64))) >> 3);
    TargetNatAddress = TargetAddress | 0x1F8;
    Mask = 0x1i64 << Index;

    if (TargetNatAddress <= (RsBSP + (FrameSize * sizeof(ULONG64))))
    {
        if ((Status = m_Target->
             ReadAllVirtual(Process,
                            TargetNatAddress, (PUCHAR)&LocalRnat, 8)) != S_OK)
        {
            ErrOut("Unable to read memory location %I64x\n", TargetNatAddress);
            return Status;
        }

        if (Val->Nat)
        {
            LocalRnat |= Mask;
        }
        else
        {
            LocalRnat &= ~Mask;
        }
        if ((Status = m_Target->
             WriteAllVirtual(Process,
                             TargetNatAddress, &LocalRnat, 8)) != S_OK)
        {
            ErrOut("Unable to write memory location %I64x\n",TargetNatAddress);
            return Status;
        }
    }
    else
    {
        if (Val->Nat)
        {
            *RsRNAT |= Mask;
        }
        else
        {
            *RsRNAT &= ~Mask;
        }
    }

    return S_OK;
}
    
//----------------------------------------------------------------------------
//
// X86OnIa64MachineInfo.
//
//----------------------------------------------------------------------------

X86OnIa64MachineInfo::X86OnIa64MachineInfo(TargetInfo* Target)
    : X86MachineInfo(Target)
{
    m_MaxDataBreakpoints = min(m_MaxDataBreakpoints, 
                               IA64_REG_MAX_DATA_BREAKPOINTS);
}

HRESULT
X86OnIa64MachineInfo::UdGetContextState(ULONG State)
{
    HRESULT Status;
    
    if ((Status = m_Target->m_Machines[MACHIDX_IA64]->
         UdGetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }

    Ia64ContextToX86(&m_Target->m_Machines[MACHIDX_IA64]->
                     m_Context.IA64Context,
                     &m_Context.X86Nt5Context);
    m_ContextState = MCTX_FULL;

    return S_OK;
}

HRESULT
X86OnIa64MachineInfo::UdSetContext(void)
{
    m_Target->m_Machines[MACHIDX_IA64]->
        InitializeContextFlags(&m_Target->m_Machines[MACHIDX_IA64]->m_Context,
                               m_Target->m_SystemVersion);
    X86ContextToIa64(&m_Context.X86Nt5Context,
                     &m_Target->m_Machines[MACHIDX_IA64]->
                     m_Context.IA64Context);
    return m_Target->m_Machines[MACHIDX_IA64]->UdSetContext();
}

HRESULT
X86OnIa64MachineInfo::KdGetContextState(ULONG State)
{
    HRESULT Status;
    
    dprintf("The context is partially valid. "
            "Only x86 user-mode context is available.\n");
    if ((Status = m_Target->m_Machines[MACHIDX_IA64]->
         KdGetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }

    Ia64ContextToX86(&m_Target->m_Machines[MACHIDX_IA64]->
                     m_Context.IA64Context,
                     &m_Context.X86Nt5Context);
    m_ContextState = MCTX_FULL;

    return S_OK;
}

HRESULT
X86OnIa64MachineInfo::KdSetContext(void)
{
    dprintf("The context is partially valid. "
            "Only x86 user-mode context is available.\n");
    m_Target->m_Machines[MACHIDX_IA64]->
        InitializeContextFlags(&m_Target->m_Machines[MACHIDX_IA64]->m_Context,
                               m_Target->m_SystemVersion);
    X86ContextToIa64(&m_Context.X86Nt5Context,
                     &m_Target->m_Machines[MACHIDX_IA64]->
                     m_Context.IA64Context);
    return m_Target->m_Machines[MACHIDX_IA64]->KdSetContext();
}

HRESULT
X86OnIa64MachineInfo::GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc)
{
    // XXX drewb - This should probably use the
    // descriptor information embedded in the IA64 context.
    
    ULONG RegNum = GetSegRegNum(SegReg);
    if (RegNum == 0)
    {
        return E_INVALIDARG;
    }

    return m_Target->EmulateNtX86SelDescriptor(m_Target->m_RegContextThread,
                                               this, GetIntReg(RegNum), Desc);
}

HRESULT
X86OnIa64MachineInfo::NewBreakpoint(DebugClient* Client, 
                                    ULONG Type,
                                    ULONG Id,
                                    Breakpoint** RetBp)
{
    HRESULT Status;

    switch(Type & (DEBUG_BREAKPOINT_CODE | DEBUG_BREAKPOINT_DATA))
    {
    case DEBUG_BREAKPOINT_CODE:
        *RetBp = new CodeBreakpoint(Client, Id, IMAGE_FILE_MACHINE_I386);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    case DEBUG_BREAKPOINT_DATA:
        *RetBp = new X86OnIa64DataBreakpoint(Client, Id);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    default:
        // Unknown breakpoint type.
        Status = E_NOINTERFACE;
        break;
    }

    return Status;
}

ULONG
X86OnIa64MachineInfo::IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                                  ULONG FirstChance,
                                                  PADDR BpAddr,
                                                  PADDR RelAddr)
{
    //
    // XXX olegk - This is pure hack to eliminate need to map unavalable 
    // in 64-bit context ISR register to DR6.
    // We using the fact that Code Breakpoint is recognized normally and 
    // for Data Breakpoint ISR register is avalable as 5th parameter of 
    // exception record.
    //
    ULONG Exbs = 
        X86MachineInfo::IsBreakpointOrStepException(Record, 
                                                    FirstChance,
                                                    BpAddr, RelAddr);

    if (Exbs == EXBS_BREAKPOINT_CODE) 
    {
        return Exbs;
    }

    if (Record->ExceptionCode == STATUS_WX86_SINGLE_STEP)
    {
        ULONG64 Isr = Record->ExceptionInformation[4]; // Trap code is 2 lower bytes
        ULONG TrapCode = ULONG(Isr & ISR_CODE_MASK);
        ULONG Vector = (ULONG)(Isr >> ISR_IA_VECTOR) & 0xff;

        if (Vector != 1) 
        {
            return EXBS_NONE;
        }

        if (Isr & (1 << ISR_TB_TRAP))
        {
            ADDRFLAT(RelAddr, Record->ExceptionInformation[3]);
            return EXBS_STEP_BRANCH;
        }
        else if (Isr & (1 << ISR_SS_TRAP))
        {
            return EXBS_STEP_INSTRUCTION;
        }
        else {
            if (Isr & ((ULONG64)1 << ISR_X))  // Exec Data Breakpoint
            {
                return EXBS_BREAKPOINT_DATA;
            }
            else // Data Breakpoint
            {
                for (int i = 0; i < 4; ++i)
                {
                    if (TrapCode & (1 << (4 + i))) 
                    {
                        ULONG Addr = GetReg32(X86_DR0 + i);
                        if (Addr) 
                        {
                            ADDRFLAT(BpAddr, Addr);
                            return EXBS_BREAKPOINT_DATA;
                        }
                    }
                }
            }
        }
    }

    return EXBS_NONE;
}

VOID
Wow64CopyFpFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID Byte10Fp,
    IN ULONG NumRegs);

VOID
Wow64CopyFpToIa64Byte16(
    IN PVOID Byte10Fp,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs);

VOID
Wow64CopyXMMIToIa64Byte16(
    IN PVOID ByteXMMI,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs);

VOID
Wow64CopyXMMIFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID ByteXMMI,
    IN ULONG NumRegs);

VOID
Wow64RotateFpTop(
    IN ULONGLONG Ia64_FSR,
    IN OUT FLOAT128 UNALIGNED *ia32FxSave);

VOID
Wow64CopyIa64FromSpill(
    IN PFLOAT128 SpillArea,
    IN OUT FLOAT128 UNALIGNED *ia64Fp,
    IN ULONG NumRegs);

VOID
Wow64CopyIa64ToFill(
    IN FLOAT128 UNALIGNED *ia64Fp,
    IN OUT PFLOAT128 FillArea,
    IN ULONG NumRegs);

BOOL
MapDbgSlotIa64ToX86(
    UINT    Slot,
    ULONG64 Ipsr,
    ULONG64 DbD,
    ULONG64 DbD1,
    ULONG64 DbI,
    ULONG64 DbI1,
    ULONG*  Dr7,
    ULONG*  Dr);

void
MapDbgSlotX86ToIa64(
    UINT     Slot,
    ULONG    Dr7,
    ULONG    Dr,
    ULONG64* Ipsr,
    ULONG64* DbD,
    ULONG64* DbD1,
    ULONG64* DbI,
    ULONG64* DbI1);

void
X86OnIa64MachineInfo::Ia64ContextToX86(
    PIA64_CONTEXT ContextIa64,
    PX86_NT5_CONTEXT ContextX86)
{
    FLOAT128 tmpFloat[NUMBER_OF_387_REGS];
    ULONG Ia32ContextFlags = ContextX86->ContextFlags;

    ULONG Tid = GetCurrentThreadId();
    DebugClient* Client;
 
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_ThreadId == Tid)
        {
            break;
        }
    }

    DBG_ASSERT((Client!=NULL));

    if (!((Ia64MachineInfo*)m_Target->m_Machines[MACHIDX_IA64])->
        IsIA32InstructionSet())
    {
        if (g_Wow64exts == NULL)
        {
            dprintf("Need to load wow64exts.dll to retrieve context!\n");
            return;
        }
        (*g_Wow64exts)(WOW64EXTS_GET_CONTEXT, 
                       (ULONG64)Client,
                       (ULONG64)ContextX86,
                       (ULONG64)NULL);
        return;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_CONTROL) == VDMCONTEXT_CONTROL)
    {
        //
        // And the control stuff
        //
        ContextX86->Ebp    = (ULONG)ContextIa64->IntTeb;
        ContextX86->SegCs  = X86_KGDT_R3_CODE|3;
        ContextX86->Eip    = (ULONG)ContextIa64->StIIP;
        ContextX86->SegSs  = X86_KGDT_R3_DATA|3;
        ContextX86->Esp    = (ULONG)ContextIa64->IntSp;
        ContextX86->EFlags = (ULONG)ContextIa64->Eflag;

        //
        // Map single step flag (EFlags.tf = EFlags.tf || PSR.ss)
        //
        if (ContextIa64->StIPSR & (1I64 << PSR_SS))
        {
            ContextX86->EFlags |= X86_BIT_FLAGTF;
        }
    }

    if ((Ia32ContextFlags & VDMCONTEXT_INTEGER)  == VDMCONTEXT_INTEGER)
    {
        //
        // Now for the integer state...
        //
        ContextX86->Edi = (ULONG)ContextIa64->IntT6;
        ContextX86->Esi = (ULONG)ContextIa64->IntT5;
        ContextX86->Ebx = (ULONG)ContextIa64->IntT4;
        ContextX86->Edx = (ULONG)ContextIa64->IntT3;
        ContextX86->Ecx = (ULONG)ContextIa64->IntT2;
        ContextX86->Eax = (ULONG)ContextIa64->IntV0;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_SEGMENTS) == VDMCONTEXT_SEGMENTS)
    {
        //
        // These are constants (and constants are used on ia32->ia64
        // transition, not saved values) so make our life easy...
        //
        ContextX86->SegGs = 0;
        ContextX86->SegEs = X86_KGDT_R3_DATA|3;
        ContextX86->SegDs = X86_KGDT_R3_DATA|3;
        ContextX86->SegSs = X86_KGDT_R3_DATA|3;
        ContextX86->SegFs = X86_KGDT_R3_TEB|3;
        ContextX86->SegCs = X86_KGDT_R3_CODE|3;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_EXTENDED_REGISTERS) ==
        VDMCONTEXT_EXTENDED_REGISTERS)
    {
        PX86_FXSAVE_FORMAT xmmi =
            (PX86_FXSAVE_FORMAT) ContextX86->ExtendedRegisters;
        
        xmmi->ControlWord   = (USHORT)(ContextIa64->StFCR & 0xffff);
        xmmi->StatusWord    = (USHORT)(ContextIa64->StFSR & 0xffff);
        xmmi->TagWord       = (USHORT)(ContextIa64->StFSR >> 16) & 0xffff;
        xmmi->ErrorOpcode   = (USHORT)(ContextIa64->StFIR >> 48);
        xmmi->ErrorOffset   = (ULONG) (ContextIa64->StFIR & 0xffffffff);
        xmmi->ErrorSelector = (ULONG) (ContextIa64->StFIR >> 32);
        xmmi->DataOffset    = (ULONG) (ContextIa64->StFDR & 0xffffffff);
        xmmi->DataSelector  = (ULONG) (ContextIa64->StFDR >> 32);
        xmmi->MXCsr         = (ULONG) (ContextIa64->StFCR >> 32) & 0xffff;

        //
        // Copy over the FP registers.  Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert from spill/fill format to 80-bit double extended format
        //
        Wow64CopyIa64FromSpill((PFLOAT128) &(ContextIa64->FltT2),
                               (PFLOAT128) xmmi->RegisterArea,
                               NUMBER_OF_387_REGS);

        //
        // Rotate the registers appropriately
        //
        Wow64RotateFpTop(ContextIa64->StFSR, (PFLOAT128) xmmi->RegisterArea);

        //
        // Finally copy the xmmi registers
        //
        Wow64CopyXMMIFromIa64Byte16(&(ContextIa64->FltS4),
                                    xmmi->Reserved3,
                                    NUMBER_OF_XMMI_REGS);
    }

    if ((Ia32ContextFlags & VDMCONTEXT_FLOATING_POINT) ==
        VDMCONTEXT_FLOATING_POINT)
    {
        //
        // Copy over the floating point status/control stuff
        //
        ContextX86->FloatSave.ControlWord   = (ULONG)(ContextIa64->StFCR & 0xffff);
        ContextX86->FloatSave.StatusWord    = (ULONG)(ContextIa64->StFSR & 0xffff);
        ContextX86->FloatSave.TagWord       = (ULONG)(ContextIa64->StFSR >> 16) & 0xffff;
        ContextX86->FloatSave.ErrorOffset   = (ULONG)(ContextIa64->StFIR & 0xffffffff);
        ContextX86->FloatSave.ErrorSelector = (ULONG)(ContextIa64->StFIR >> 32);
        ContextX86->FloatSave.DataOffset    = (ULONG)(ContextIa64->StFDR & 0xffffffff);
        ContextX86->FloatSave.DataSelector  = (ULONG)(ContextIa64->StFDR >> 32);

        //
        // Copy over the FP registers into temporary space
        // Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert from spill/fill format to 80-bit double extended format
        //
        Wow64CopyIa64FromSpill((PFLOAT128) &(ContextIa64->FltT2),
                               (PFLOAT128) tmpFloat,
                               NUMBER_OF_387_REGS);
        //
        // Rotate the registers appropriately
        //
        Wow64RotateFpTop(ContextIa64->StFSR, tmpFloat);

        //
        // And put them in the older FNSAVE format (packed 10 byte values)
        //
        Wow64CopyFpFromIa64Byte16(tmpFloat,
                                  ContextX86->FloatSave.RegisterArea,
                                  NUMBER_OF_387_REGS);
    }

    if ((Ia32ContextFlags & VDMCONTEXT_DEBUG_REGISTERS) ==
        VDMCONTEXT_DEBUG_REGISTERS)
    {
        // Ia64 -> X86
        BOOL Valid = TRUE;
        Valid &= MapDbgSlotIa64ToX86(0, ContextIa64->StIPSR, ContextIa64->DbD0, ContextIa64->DbD1, ContextIa64->DbI0, ContextIa64->DbI1, &ContextX86->Dr7, &ContextX86->Dr0);
        Valid &= MapDbgSlotIa64ToX86(1, ContextIa64->StIPSR, ContextIa64->DbD2, ContextIa64->DbD3, ContextIa64->DbI2, ContextIa64->DbI3, &ContextX86->Dr7, &ContextX86->Dr1);
        Valid &= MapDbgSlotIa64ToX86(2, ContextIa64->StIPSR, ContextIa64->DbD4, ContextIa64->DbD5, ContextIa64->DbI4, ContextIa64->DbI5, &ContextX86->Dr7, &ContextX86->Dr2);
        Valid &= MapDbgSlotIa64ToX86(3, ContextIa64->StIPSR, ContextIa64->DbD6, ContextIa64->DbD7, ContextIa64->DbI6, ContextIa64->DbI7, &ContextX86->Dr7, &ContextX86->Dr3);

        if (!Valid)
        {
            WarnOut("Wasn't able to map IA64 debug registers consistently!!!\n");
        }

        //
        // Map single step flag (EFlags.tf = EFlags.tf || PSR.ss)
        //
        if (ContextIa64->StIPSR & (1I64 << PSR_SS))
        {
            ContextX86->EFlags |= X86_BIT_FLAGTF;
        }
    }
}

void
X86OnIa64MachineInfo::X86ContextToIa64(
    PX86_NT5_CONTEXT ContextX86,
    PIA64_CONTEXT ContextIa64)
{
   
    FLOAT128 tmpFloat[NUMBER_OF_387_REGS];
    ULONG Ia32ContextFlags = ContextX86->ContextFlags;

    ULONG Tid = GetCurrentThreadId();
    DebugClient* Client;
 
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_ThreadId == Tid)
        {
            break;
        }
    }

    DBG_ASSERT((Client!=NULL));

    if (!((Ia64MachineInfo*)m_Target->m_Machines[MACHIDX_IA64])->
        IsIA32InstructionSet())
    {
        if (g_Wow64exts == NULL)
        {
            dprintf("Need to load wow64exts.dll to retrieve context!\n");
            return;
        }
        (*g_Wow64exts)(WOW64EXTS_SET_CONTEXT, 
                       (ULONG64)Client,
                       (ULONG64)ContextX86,
                       (ULONG64)NULL);
        return;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_CONTROL) == VDMCONTEXT_CONTROL)
    {
        //
        // And the control stuff
        //
        ContextIa64->IntTeb = ContextX86->Ebp;
        ContextIa64->StIIP = ContextX86->Eip;
        ContextIa64->IntSp = ContextX86->Esp;
        ContextIa64->Eflag = ContextX86->EFlags;

        //
        // Map single step flag (PSR.ss = PSR.ss || EFlags.tf)
        //
        if (ContextX86->EFlags & X86_BIT_FLAGTF) 
        {
            ContextIa64->StIPSR |= (1I64 << PSR_SS);
        }

        //
        // The segments (cs and ds) are a constant, so reset them.
        // gr17 has LDT and TSS, so might as well reset
        // all of them while we're at it...
        // These values are forced in during a transition (see simulate.s)
        // so there is no point to trying to get cute and actually
        // pass in the values from the X86 context record
        //
        ContextIa64->IntT8 = ((X86_KGDT_LDT|3) << 32) 
                           | ((X86_KGDT_R3_DATA|3) << 16)
                           | (X86_KGDT_R3_CODE|3);

    }

    if ((Ia32ContextFlags & VDMCONTEXT_INTEGER) == VDMCONTEXT_INTEGER)
    {
        //
        // Now for the integer state...
        //
         ContextIa64->IntT6 = ContextX86->Edi;
         ContextIa64->IntT5 = ContextX86->Esi;
         ContextIa64->IntT4 = ContextX86->Ebx;
         ContextIa64->IntT3 = ContextX86->Edx;
         ContextIa64->IntT2 = ContextX86->Ecx;
         ContextIa64->IntV0 = ContextX86->Eax;
    }

    if ((Ia32ContextFlags & VDMCONTEXT_SEGMENTS) == VDMCONTEXT_SEGMENTS)
    {
        //
        // These are constants (and constants are used on ia32->ia64
        // transition, not saved values) so make our life easy...
        // These values are forced in during a transition (see simulate.s)
        // so there is no point to trying to get cute and actually
        // pass in the values from the X86 context record
        //
        ContextIa64->IntT7 =  ((X86_KGDT_R3_TEB|3) << 32)
                           | ((X86_KGDT_R3_DATA|3) << 16)
                           | (X86_KGDT_R3_DATA|3);
    }

    if ((Ia32ContextFlags & VDMCONTEXT_EXTENDED_REGISTERS) ==
        VDMCONTEXT_EXTENDED_REGISTERS)
    {
        PX86_FXSAVE_FORMAT xmmi =
            (PX86_FXSAVE_FORMAT) ContextX86->ExtendedRegisters;
 
        //
        // And copy over the floating point status/control stuff
        //
        ContextIa64->StFCR = (ContextIa64->StFCR & 0xffffffffffffe040i64) |
                             (xmmi->ControlWord & 0xffff) |
                             ((ULONG64)(xmmi->MXCsr & 0xffff) << 32);

        ContextIa64->StFSR = (ContextIa64->StFSR & 0xffffffff00000000i64) | 
                             (xmmi->StatusWord & 0xffff) | 
                             ((ULONG64)(xmmi->TagWord & 0xffff) << 16);

        ContextIa64->StFIR = (xmmi->ErrorOffset & 0xffffffff) | 
                             ((ULONG64)xmmi->ErrorSelector << 32);

        ContextIa64->StFDR = (xmmi->DataOffset & 0xffffffff) | 
                             ((ULONG64)xmmi->DataSelector << 32);

        //
        // Don't touch the original ia32 context. Make a copy.
        //
        memcpy(tmpFloat, xmmi->RegisterArea, 
               NUMBER_OF_387_REGS * sizeof(FLOAT128));
        
        // 
        // Rotate registers back since st0 is not necessarily f8
        //
        {
            ULONGLONG RotateFSR = (NUMBER_OF_387_REGS - 
                                   ((ContextIa64->StFSR >> 11) & 0x7)) << 11;
            Wow64RotateFpTop(RotateFSR, tmpFloat);
        }

        //
        // Copy over the FP registers.  Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert to spill/fill format from 80-bit double extended format
        //
        Wow64CopyIa64ToFill((PFLOAT128) tmpFloat,
                            (PFLOAT128) &(ContextIa64->FltT2),
                            NUMBER_OF_387_REGS);

        //
        // Copy over the xmmi registers and convert them into a format
        // that spill/fill can use
        //
        Wow64CopyXMMIToIa64Byte16(xmmi->Reserved3, 
                                  &(ContextIa64->FltS4), 
                                  NUMBER_OF_XMMI_REGS);
    }

    if ((Ia32ContextFlags & VDMCONTEXT_FLOATING_POINT) ==
        VDMCONTEXT_FLOATING_POINT)
    {
        //
        // Copy over the floating point status/control stuff
        // Leave the MXCSR stuff alone
        //
        ContextIa64->StFCR = (ContextIa64->StFCR & 0xffffffffffffe040i64) | 
                             (ContextX86->FloatSave.ControlWord & 0xffff);

        ContextIa64->StFSR = (ContextIa64->StFSR & 0xffffffff00000000i64) | 
                             (ContextX86->FloatSave.StatusWord & 0xffff) | 
                             ((ULONG64)(ContextX86->FloatSave.TagWord & 0xffff) << 16);

        ContextIa64->StFIR = (ContextX86->FloatSave.ErrorOffset & 0xffffffff) | 
                             ((ULONG64)ContextX86->FloatSave.ErrorSelector << 32);

        ContextIa64->StFDR = (ContextX86->FloatSave.DataOffset & 0xffffffff) | 
                             ((ULONG64)ContextX86->FloatSave.DataSelector << 32);


        //
        // Copy over the FP registers from packed 10-byte format
        // to 16-byte format
        //
        Wow64CopyFpToIa64Byte16(ContextX86->FloatSave.RegisterArea,
                                tmpFloat,
                                NUMBER_OF_387_REGS);

        // 
        // Rotate registers back since st0 is not necessarily f8
        //
        {
            ULONGLONG RotateFSR = (NUMBER_OF_387_REGS - 
                                   ((ContextIa64->StFSR >> 11) & 0x7)) << 11;
            Wow64RotateFpTop(RotateFSR, tmpFloat);
        }

        //
        // Now convert from 80 bit extended format to fill/spill format
        //
        Wow64CopyIa64ToFill((PFLOAT128) tmpFloat,
                            (PFLOAT128) &(ContextIa64->FltT2),
                            NUMBER_OF_387_REGS);
    }

    if ((Ia32ContextFlags & VDMCONTEXT_DEBUG_REGISTERS) ==
        VDMCONTEXT_DEBUG_REGISTERS)
    {
        // X86 -> Ia64
        MapDbgSlotX86ToIa64(0, ContextX86->Dr7, ContextX86->Dr0, &ContextIa64->StIPSR, &ContextIa64->DbD0, &ContextIa64->DbD1, &ContextIa64->DbI0, &ContextIa64->DbI1);
        MapDbgSlotX86ToIa64(1, ContextX86->Dr7, ContextX86->Dr1, &ContextIa64->StIPSR, &ContextIa64->DbD2, &ContextIa64->DbD3, &ContextIa64->DbI2, &ContextIa64->DbI3);
        MapDbgSlotX86ToIa64(2, ContextX86->Dr7, ContextX86->Dr2, &ContextIa64->StIPSR, &ContextIa64->DbD4, &ContextIa64->DbD5, &ContextIa64->DbI4, &ContextIa64->DbI5);
        MapDbgSlotX86ToIa64(3, ContextX86->Dr7, ContextX86->Dr3, &ContextIa64->StIPSR, &ContextIa64->DbD6, &ContextIa64->DbD7, &ContextIa64->DbI6, &ContextIa64->DbI7);

        //
        // Map single step flag (PSR.ss = PSR.ss || EFlags.tf)
        //
        if (ContextX86->EFlags & X86_BIT_FLAGTF) 
        {
            ContextIa64->StIPSR |= (1I64 << PSR_SS);
        }
    }
        
}

//
// Helper functions for context conversion
// --copied from \nt\base\wow64\cpu\context\context.c
//

//
// This allows the compiler to be more efficient in copying 10 bytes
// without over copying...
//
#pragma pack(push, 2)
typedef struct _ia32fpbytes {
    ULONG significand_low;
    ULONG significand_high;
    USHORT exponent;
} IA32FPBYTES, *PIA32FPBYTES;
#pragma pack(pop)

VOID
Wow64CopyFpFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID Byte10Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    PIA32FPBYTES from, to;

    from = (PIA32FPBYTES) Byte16Fp;
    to = (PIA32FPBYTES) Byte10Fp;

    for (i = 0; i < NumRegs; i++) {
        *to = *from;
        from = (PIA32FPBYTES) (((UINT_PTR) from) + 16);
        to = (PIA32FPBYTES) (((UINT_PTR) to) + 10);
    }
}

VOID
Wow64CopyFpToIa64Byte16(
    IN PVOID Byte10Fp,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    PIA32FPBYTES from, to;  // UNALIGNED

    from = (PIA32FPBYTES) Byte10Fp;
    to = (PIA32FPBYTES) Byte16Fp;

    for (i = 0; i < NumRegs; i++) {
        *to = *from;
        from = (PIA32FPBYTES) (((UINT_PTR) from) + 10);
        to = (PIA32FPBYTES) (((UINT_PTR) to) + 16);
    }
}

//
// Alas, nothing is easy. The ia32 xmmi instructions use 16 bytes and pack
// them as nice 16 byte structs. Unfortunately, ia64 handles it as 2 8-byte
// values (using just the mantissa part). So, another conversion is required
//
VOID
Wow64CopyXMMIToIa64Byte16(
    IN PVOID ByteXMMI,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    UNALIGNED ULONGLONG *from;
    ULONGLONG *to;

    from = (PULONGLONG) ByteXMMI;
    to = (PULONGLONG) Byte16Fp;

    //
    // although we have NumRegs xmmi registers, each register is 16 bytes
    // wide. This code does things in 8-byte chunks, so total
    // number of times to do things is 2 * NumRegs...
    //
    NumRegs *= 2;

    for (i = 0; i < NumRegs; i++) {
        *to++ = *from++;        // Copy over the mantissa part
        *to++ = 0x1003e;        // Force the exponent part
                                // (see ia64 eas, ia32 FP section - 6.2.7
                                // for where this magic number comes from)
    }
}

VOID
Wow64CopyXMMIFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID ByteXMMI,
    IN ULONG NumRegs)
{
    ULONG i;
    ULONGLONG *from;
    UNALIGNED ULONGLONG *to;

    from = (PULONGLONG) Byte16Fp;
    to = (PULONGLONG) ByteXMMI;

    //
    // although we have NumRegs xmmi registers, each register is 16 bytes
    // wide. This code does things in 8-byte chunks, so total
    // number of times to do things is 2 * NumRegs...
    //
    NumRegs *= 2;

    for (i = 0; i < NumRegs; i++) {
        *to++ = *from++;        // Copy over the mantissa part
        from++;                 // Skip over the exponent part
    }
}

VOID
Wow64RotateFpTop(
    IN ULONGLONG Ia64_FSR,
    IN OUT FLOAT128 UNALIGNED *ia32FxSave)
/*++

Routine Description:

    On transition from ia64 mode to ia32 (and back), the f8-f15 registers
    contain the st[0] to st[7] fp stack values. Alas, these values don't
    map one-one, so the FSR.top bits are used to determine which ia64
    register has the top of stack. We then need to rotate these registers
    since ia32 context is expecting st[0] to be the first fp register (as
    if FSR.top is zero). This routine only works on full 16-byte ia32
    saved fp data (such as from ExtendedRegisters - the FXSAVE format).
    Other routines can convert this into the older FNSAVE format.

Arguments:

    Ia64_FSR - The ia64 FSR register. Has the FSR.top needed for this routine

    ia32FxSave - The ia32 fp stack (in FXSAVE format). Each ia32 fp register
                 uses 16 bytes.

Return Value:

    None.  

--*/
{
    ULONG top = (ULONG) ((Ia64_FSR >> 11) & 0x7);

    if (top) {
        FLOAT128 tmpFloat[NUMBER_OF_387_REGS];
        ULONG i;
        for (i = 0; i < NUMBER_OF_387_REGS; i++) {
            tmpFloat[i] = ia32FxSave[i];
        }

        for (i = 0; i < NUMBER_OF_387_REGS; i++) {
            ia32FxSave[i] = tmpFloat[(i + top) % NUMBER_OF_387_REGS];
        }
    }
}

//
// And now for the final yuck... The ia64 context for floating point
// is saved/loaded using spill/fill instructions. This format is different
// than the 10-byte fp format so we need a conversion routine from spill/fill
// to/from 10byte fp
//

VOID
Wow64CopyIa64FromSpill(
    IN PFLOAT128 SpillArea,
    IN OUT FLOAT128 UNALIGNED *ia64Fp,
    IN ULONG NumRegs)
/*++

Routine Description:

    This function copies fp values from the ia64 spill/fill format
    into the ia64 80-bit format. The exponent needs to be adjusted
    according to the EAS (5-12) regarding Memory to Floating Point
    Register Data Translation in the ia64 floating point chapter

Arguments:

    SpillArea - The ia64 area that has the spill format for fp

    ia64Fp - The location which will get the ia64 fp in 80-bit
             double-extended format

    NumRegs - Number of registers to convert

Return Value:

    None.

--*/
{
    ULONG i;

    for (i = 0; i < NumRegs; i++) {
        ULONG64 Sign = ((SpillArea->HighPart & (1i64 << 17)) != 0);
        ULONG64 Significand = SpillArea->LowPart; 
        ULONG64 Exponent = SpillArea->HighPart & 0x1ffff; 

        if (Exponent && Significand) 
        {
            if (Exponent == 0x1ffff) // NaNs and Infinities
            {   
                Exponent = 0x7fff;
            }
            else 
            {
                ULONG64 Rebias = 0xffff - 0x3fff;
                Exponent -= Rebias;
            }
        }

        ia64Fp->HighPart = (Sign << 15) | Exponent;
        ia64Fp->LowPart = Significand;

        ia64Fp++;
        SpillArea++;
    }
}

VOID
Wow64CopyIa64ToFill(
    IN FLOAT128 UNALIGNED *ia64Fp,
    IN OUT PFLOAT128 FillArea,
    IN ULONG NumRegs)
/*++

Routine Description:

    This function copies fp values from the ia64 80-bit format
    into the fill/spill format used by the os for save/restore
    of the ia64 context. The only magic here is putting back some
    values that get truncated when converting from spill/fill to 
    80-bits. The exponent needs to be adjusted according to the
    EAS (5-12) regarding Memory to Floating Point Register Data
    Translation in the ia64 floating point chapter

Arguments:

    ia64Fp - The ia64 fp in 80-bit double-extended format

    FillArea - The ia64 area that will get the fill format for fp
                  for the copy into the ia64 context area

    NumRegs - Number of registers to convert

Return Value:

    None.

--*/
{
    ULONG i;

    for (i = 0; i < NumRegs; i++) {
        ULONG64 Sign = ((ia64Fp->HighPart & (1i64 << 15)) != 0);
        ULONG64 Significand = ia64Fp->LowPart; 
        ULONG64 Exponent = ia64Fp->HighPart & 0x7fff;

        if (Exponent && Significand) 
        {
            if (Exponent == 0x7fff) // Infinity
            {
                Exponent = 0x1ffff;
            }
            else 
            {
                ULONGLONG Rebias = 0xffff-0x3fff;
                Exponent += Rebias;
            }
        }

        FillArea->LowPart = Significand;
        FillArea->HighPart = (Sign << 17) | Exponent;

        ia64Fp++;
        FillArea++;
    }
}

ULONG 
MapDbgSlotIa64ToX86_GetSize(ULONG64 Db1, BOOL* Valid)
{
    ULONG64 Size = (~Db1 & IA64_DBG_MASK_MASK);
    if (Size > 3)
    {
        *Valid = FALSE;
    }
    return (ULONG)Size;
}

void 
MapDbgSlotIa64ToX86_InvalidateAddr(ULONG64 Db, BOOL* Valid)
{
    if (Db != (ULONG64)(ULONG)Db) 
    {
        *Valid = FALSE;
    }
}

ULONG
MapDbgSlotIa64ToX86_ExecTypeSize(
    UINT     Slot,
    ULONG64  Db,
    ULONG64  Db1,
    BOOL* Valid)
{
    ULONG TypeSize;

    if (!(Db1 >> 63)) 
    {
        *Valid = FALSE;
    }

    TypeSize = (MapDbgSlotIa64ToX86_GetSize(Db1, Valid) << 2); 
    MapDbgSlotIa64ToX86_InvalidateAddr(Db, Valid);
   
    return TypeSize;
}

ULONG
MapDbgSlotIa64ToX86_DataTypeSize(
    UINT     Slot,
    ULONG64  Db,
    ULONG64  Db1,
    BOOL* Valid)
{
    ULONG TypeSize = (ULONG)(Db1 >> 62);

    if ((TypeSize != 1) && (TypeSize != 3))
    {
        *Valid = FALSE;
    }

    TypeSize |= (MapDbgSlotIa64ToX86_GetSize(Db1, Valid) << 2); 
    MapDbgSlotIa64ToX86_InvalidateAddr(Db, Valid);
    
    return TypeSize;
}

BOOL
MapDbgSlotIa64ToX86(
    UINT    Slot,
    ULONG64 Ipsr,
    ULONG64 DbD,
    ULONG64 DbD1,
    ULONG64 DbI,
    ULONG64 DbI1,
    ULONG*  Dr7,
    ULONG*  Dr)
{
    BOOL DataValid = TRUE, ExecValid = TRUE, Valid = TRUE;
    ULONG DataTypeSize, ExecTypeSize;

    // XXX olegk - remove this after IA64_REG_MAX_DATA_BREAKPOINTS will be changed to 4
    if (Slot >= IA64_REG_MAX_DATA_BREAKPOINTS) 
    {
        return TRUE;
    }

    DataTypeSize = MapDbgSlotIa64ToX86_DataTypeSize(Slot, DbD, DbD1, &DataValid);
    ExecTypeSize = MapDbgSlotIa64ToX86_ExecTypeSize(Slot, DbI, DbI1, &ExecValid);
    
    if (DataValid)
    {
        if (!ExecValid)
        {
            *Dr = (ULONG)DbD;
            *Dr7 |= (X86_DR7_LOCAL_EXACT_ENABLE |
                     (1 << Slot * 2) |
                     (DataTypeSize << (16 + Slot * 4)));
            return !DbI && !DbI1;
        }
    }
    else if (ExecValid)
    {
        *Dr = (ULONG)DbI;
        *Dr7 |= (X86_DR7_LOCAL_EXACT_ENABLE |
                 (1 << Slot * 2) |
                 (ExecTypeSize << (16 + Slot * 4)));
        return !DbD && !DbD1;
    }
    
    *Dr7 &= ~(X86_DR7_LOCAL_EXACT_ENABLE |  
              (0xf << (16 + Slot * 4)) | 
              (1 << Slot * 2));

    if (!DbD && !DbD1 && !DbI && !DbI1)
    {
        *Dr = 0;
        return TRUE;
    }
     
    *Dr = ~(ULONG)0;

    return FALSE;
}

void
MapDbgSlotX86ToIa64(
    UINT     Slot,
    ULONG    Dr7,
    ULONG    Dr,
    ULONG64* Ipsr,
    ULONG64* DbD,
    ULONG64* DbD1,
    ULONG64* DbI,
    ULONG64* DbI1)
{
    UINT TypeSize;
    ULONG64 Control;

    if (!(Dr7 & (1 << Slot * 2)))
    {
        return;
    }

    if (Dr == ~(ULONG)0) 
    {
        return;
    }

    TypeSize = Dr7 >> (16 + Slot * 4);

    Control = (IA64_DBG_REG_PLM_USER | IA64_DBG_MASK_MASK) & 
              ~(ULONG64)(TypeSize >> 2);

    switch (TypeSize & 0x3) 
    {
    case 0x0: // Exec
        *DbI1 = Control | IA64_DBR_EXEC;        
        *DbI = Dr;
        break;
    case 0x1: // Write
        *DbD1 = Control | IA64_DBR_WR;
        *DbD = Dr;
        break;
    case 0x3: // Read/Write
        *DbD1 = Control | IA64_DBR_RD | IA64_DBR_WR;
        *DbD = Dr;
        break;
    default:
        return;
    }
    *Ipsr |= (1i64 << PSR_DB); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\machine.hpp ===
//----------------------------------------------------------------------------
//
// Abstraction of processor-specific information.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __MACHINE_HPP__
#define __MACHINE_HPP__

// These context information states are intended to be shared among
// processors so they may not all apply to each processor.  The important
// thing is that they are ordered from less information to more.
// Each state includes all the information from the states that precede it.
// More states can be inserted anywhere as new processors require them.
#define MCTX_NONE         0     // No context information.
#define MCTX_PC           1     // Program counter.
#define MCTX_DR67_REPORT  2     // X86: DR6,7 control report.
#define MCTX_REPORT       3     // Control report.
#define MCTX_CONTEXT      4     // Kernel protocol context information.
#define MCTX_FULL         5     // All possible information.
#define MCTX_DIRTY        6     // Dirty context, implies full information.

// Constant offset value returned from GetNextOffset to indicate the
// trace flag should be used.
#define OFFSET_TRACE ((ULONG64)(LONG64)-1)
#define OFFSET_TRACE_32 ((ULONG)OFFSET_TRACE)

// Distinguished error code for GetVirtualTranslationPhysicalOffsets
// to indicate that all translations were successful but
// the page was not present.  In this case the LastVal value
// will contain the page file offset and PfIndex will contain
// the page file number.
#define HR_PAGE_IN_PAGE_FILE  HRESULT_FROM_NT(STATUS_PAGE_FAULT_PAGING_FILE)
// Translation could not complete and a page file location
// for the data could not be determined.
#define HR_PAGE_NOT_AVAILABLE HRESULT_FROM_NT(STATUS_NO_PAGEFILE)

#define MAX_PAGING_FILE_MASK 0xf

//
// Segment register access.
// Processors which do not support segment registers return
// zero for the segment register number.
//

enum
{
    // Descriptor table pseudo-segments.  The GDT does
    // not have a specific register number.
    // These pseudo-segments should be first so that
    // index zero is not used for a normal segreg.
    SEGREG_GDT,
    SEGREG_LDT,

    // Generic segments.
    SEGREG_CODE,
    SEGREG_DATA,
    SEGREG_STACK,
    
    // Extended segments.
    SEGREG_ES,
    SEGREG_FS,
    SEGREG_GS,
    
    SEGREG_COUNT
};

#define FORM_VM86       0x00000001
#define FORM_CODE       0x00000002
#define FORM_SEGREG     0x00000004

#define X86_FORM_VM86(Efl) \
    (X86_IS_VM86(Efl) ? FORM_VM86 : 0)

#define X86_RPL_MASK 3

#define MPTE_FLAG_VALID 0x00000001

#define PAGE_ALIGN(Machine, Addr) \
    ((Addr) & ~((ULONG64)((Machine)->m_PageSize - 1)))
#define NEXT_PAGE(Machine, Addr) \
    (((Addr) + (Machine)->m_PageSize) & \
     ~((ULONG64)((Machine)->m_PageSize - 1)))

typedef struct _ADDR_RANGE
{
    ULONG64 Base;
    ULONG Size;
} ADDR_RANGE, *PADDR_RANGE;

#define MAX_ALT_ADDR_RANGES 4

//
// InsertBreakpointInstruction flags.  These
// are processor specific.
//

#define IBI_DEFAULT        0x00000000

// The low six bits on IA64 indicate which predicate
// register to use in the break instruction.
#define IBI_IA64_PRED_MASK 0x0000003f

//----------------------------------------------------------------------------
//
// Abstract interface for machine information.  All possible
// machine-specific implementations of this interface exist at
// all times.  The effective implementation is selected when
// SetEffMachine is called.  For generic access the abstract
// interface should be used.  In machine-specific code the
// specific implementation classes can be used.
//
// IMPORTANT: Be very careful when using machine-specific header files
// such as nt<plat>.h.  The machine implementation class is
// compiled for all platforms so the nt<plat>.h file will be the
// one for the build platform, not necessarily the platform
// of the machine implementation.  ntdbg.h contains many cross-platform
// types and definitions that can be used to avoid problems.
//
//----------------------------------------------------------------------------

extern BOOL g_PrefixSymbols;
extern BOOL g_ContextChanged;

struct RegisterGroup
{
    // Counted automatically.
    ULONG NumberRegs;
    // Regs is assumed to be non-NULL in all groups.
    // SubRegs and AllExtraDesc may be NULL in any group.
    REGDEF* Regs;
    REGSUBDEF* SubRegs;
    REGALLDESC* AllExtraDesc;
};

// Trace modes used by SetTraceMode/GetTraceMode functions
typedef enum 
{
    TRACE_NONE, 
    TRACE_INSTRUCTION,
    TRACE_TAKEN_BRANCH
} TRACEMODE;

// These enumerants are abstract values but currently
// only IA64 actually has different page directories
// so set them up to match the IA64 mapping for convenience.
enum
{
    PAGE_DIR_USER,
    PAGE_DIR_SESSION,
    PAGE_DIR_KERNEL = 7,
    PAGE_DIR_COUNT
};

// For machines which only support a single page directory
// take it from the kernel slot.  All will be updated so
// this is an arbitrary choice.
#define PAGE_DIR_SINGLE PAGE_DIR_KERNEL

// All directories bit mask.
#define PAGE_DIR_ALL ((1 << PAGE_DIR_COUNT) - 1)

// Flags for GetPrefixedSymbolOffset.
#define GETPREF_VERBOSE 0x00000001

#define MAX_REGISTER_GROUPS 8

struct CvRegMap
{
    CV_HREG_e CvReg;
    ULONG Machine;
};

struct ContextSave
{
    ULONG ContextState;
    BOOL ReadOnly;
    CROSS_PLATFORM_CONTEXT Context;
    CROSS_PLATFORM_KSPECIAL_REGISTERS Special;
    DESCRIPTOR64 SegRegDesc[SEGREG_COUNT];
};

class MachineInfo
{
public:
    MachineInfo(TargetInfo* Target);
    virtual ~MachineInfo(void);

    TargetInfo* m_Target;
    
    // Descriptive information.
    PCSTR m_FullName;
    PCSTR m_AbbrevName;
    ULONG m_PageSize;
    ULONG m_PageShift;
    ULONG m_NumExecTypes;
    // First entry must be the actual processor type.
    PULONG m_ExecTypes;
    BOOL m_Ptr64;
    ULONG m_RetRegIndex;
    
    // Automatically counted from regs in base initialization.
    ULONG m_NumRegs;
    ULONG m_NumGroups;
    RegisterGroup* m_Groups[MAX_REGISTER_GROUPS];
    ULONG m_AllMask;
    // Collected automatically from groups.
    ULONG m_AllMaskBits;
    ULONG m_MaxDataBreakpoints;
    PCSTR m_SymPrefix;
    // Computed automatically.
    ULONG m_SymPrefixLen;

    // Size of the canonical context kept in the MachineInfo.
    ULONG m_SizeCanonicalContext;
    // System version of the canonical context.  Can be compared
    // against a system version to see if the target provides
    // canonical contexts or not.
    ULONG m_SverCanonicalContext;

    // Context could be kept per-thread
    // so that several can be around at once for a cache.
    // That would also make the save/restore stuff unnecessary.
    ULONG m_ContextState;
    CROSS_PLATFORM_CONTEXT m_Context;
    CROSS_PLATFORM_KSPECIAL_REGISTERS m_Special;

    // Segment register descriptors.  These will only
    // be valid on processors that support them, otherwise
    // they will be marked invalid.
    DESCRIPTOR64 m_SegRegDesc[SEGREG_COUNT];
    
    // Holds the current page directory offsets.
    ULONG64 m_PageDirectories[PAGE_DIR_COUNT];
    BOOL m_Translating;
    
    BOOL m_ContextIsReadOnly;

    USHORT m_MainCodeSeg;

    ULONG m_CvRegMapSize;
    CvRegMap* m_CvRegMap;
    
    virtual HRESULT Initialize(void);
    virtual HRESULT InitializeForProcessor(void);

    virtual void GetSystemTypeInfo(PSYSTEM_TYPE_INFO Info) = 0;
    virtual void GetDefaultKdData(PKDDEBUGGER_DATA64 KdData) = 0;
    
    ULONG CvRegToMachine(CV_HREG_e CvReg);
    
    virtual void InitializeContext
        (ULONG64 Pc, PDBGKD_ANY_CONTROL_REPORT ControlReport) = 0;
    HRESULT GetContextState(ULONG State);
    HRESULT SetContext(void);
    // Base implementations use Get/SetThreadContext for
    // any request.
    virtual HRESULT UdGetContextState(ULONG State);
    virtual HRESULT UdSetContext(void);
    virtual HRESULT KdGetContextState(ULONG State) = 0;
    virtual HRESULT KdSetContext(void) = 0;
    // Base implementation sets ContextState to NONE.
    virtual void InvalidateContext(void);
    // Context conversion is version-based rather than size-based
    // as the size is ambiguous in certain cases.  For example,
    // ALPHA_CONTEXT and ALPHA_NT5_CONTEXT are the same size
    // so additional information is necessary to distinguish them.
    virtual HRESULT ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG FromSver,
                                       ULONG FromSize, PVOID From) = 0;
    virtual HRESULT ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                     ULONG ToSver, ULONG ToSize, PVOID To) = 0;
    virtual void InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                        ULONG Version) = 0;
    virtual HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              ULONG64 Stack) = 0;
    virtual HRESULT GetContextFromFiber(ProcessInfo* Process,
                                        ULONG64 FiberBase,
                                        PCROSS_PLATFORM_CONTEXT Context,
                                        BOOL Verbose) = 0;
    virtual HRESULT GetContextFromTrapFrame(ULONG64 TrapBase,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            BOOL Verbose) = 0;
    // Base implementation fails for platforms that don't
    // have task segments.
    virtual HRESULT GetContextFromTaskSegment(ULONG64 TssBase,
                                              PCROSS_PLATFORM_CONTEXT Context,
                                              BOOL Verbose);
    virtual void GetScopeFrameFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                          PDEBUG_STACK_FRAME ScopeFrame) = 0;
    // Base implementation zeros addresses.
    virtual void GetStackDefaultsFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                             LPADDRESS64 Instr,
                                             LPADDRESS64 Stack,
                                             LPADDRESS64 Frame);
    virtual HRESULT GetScopeFrameRegister(ULONG Reg,
                                          PDEBUG_STACK_FRAME ScopeFrame,
                                          PULONG64 Value) = 0;
    virtual HRESULT SetScopeFrameRegister(ULONG Reg,
                                          PDEBUG_STACK_FRAME ScopeFrame,
                                          ULONG64 Value) = 0;
                                          
    // Base implementation does nothing.
    virtual void SanitizeMemoryContext(PCROSS_PLATFORM_CONTEXT Context);

    // Base implementations return E_NOTIMPL.
    virtual HRESULT GetExdiContext(IUnknown* Exdi,
                                   PEXDI_CONTEXT Context,
                                   EXDI_CONTEXT_TYPE CtxType);
    virtual HRESULT SetExdiContext(IUnknown* Exdi,
                                   PEXDI_CONTEXT Context,
                                   EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                               PEXDI_CONTEXT ExdiContext,
                                               EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                             EXDI_CONTEXT_TYPE CtxType,
                                             PCROSS_PLATFORM_CONTEXT Context);
    virtual void ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                              EXDI_CONTEXT_TYPE CtxType,
                                              ULONG Start, ULONG Count,
                                              PDESCRIPTOR64 Descs);
    virtual void ConvertExdiContextFromSpecial
        (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
         PEXDI_CONTEXT ExdiContext,
         EXDI_CONTEXT_TYPE CtxType);
    virtual void ConvertExdiContextToSpecial
        (PEXDI_CONTEXT ExdiContext,
         EXDI_CONTEXT_TYPE CtxType,
         PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
             
    virtual int GetType(ULONG Reg) = 0;
    virtual HRESULT GetVal(ULONG Reg, REGVAL* Val) = 0;
    virtual HRESULT SetVal(ULONG Reg, REGVAL* Val) = 0;

    virtual void GetPC(PADDR Address) = 0;
    virtual void SetPC(PADDR Address) = 0;
    virtual void GetFP(PADDR Address) = 0;
    virtual void GetSP(PADDR Address) = 0;
    virtual ULONG64 GetArgReg(void) = 0;
    virtual ULONG64 GetRetReg(void) = 0;
    // Base implementations return zero and FALSE.
    virtual ULONG GetSegRegNum(ULONG SegReg);
    virtual HRESULT GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc);

    virtual void OutputAll(ULONG Mask, ULONG OutMask) = 0;
    
    virtual HRESULT SetAndOutputTrapFrame(ULONG64 TrapBase,
                                          PCROSS_PLATFORM_CONTEXT Context) = 0;
    // Base implementation fails for platforms that don't
    // have task segments.
    virtual HRESULT SetAndOutputTaskSegment(ULONG64 TssBase,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            BOOL Extended);

    virtual TRACEMODE GetTraceMode(void) = 0;
    virtual void SetTraceMode(TRACEMODE Mode) = 0;

    // Returns true if trace mode appropriate to specified execution status 
    // (e.g. DEBUG_STATUS_STEP_OVER, DEBUG_STATUS_STEP_INTO,
    // DEBUG_STATUS_STEP_BRANCH...) supported by the machine.
    virtual BOOL IsStepStatusSupported(ULONG Status) = 0;

    void QuietSetTraceMode(TRACEMODE Mode)
    {
        BOOL ContextChangedOrg = g_ContextChanged;
        SetTraceMode(Mode);
        g_ContextChanged = ContextChangedOrg;
    }

    // Base implementation does nothing.
    virtual void KdUpdateControlSet
        (PDBGKD_ANY_CONTROL_SET ControlSet);

    virtual ULONG ExecutingMachine(void) = 0;

    virtual HRESULT SetPageDirectory(ThreadInfo* Thread,
                                     ULONG Idx, ULONG64 PageDir,
                                     PULONG NextIdx) = 0;
    HRESULT SetDefaultPageDirectories(ThreadInfo* Thread, ULONG Mask);
    virtual HRESULT GetVirtualTranslationPhysicalOffsets
        (ThreadInfo* Thread, ULONG64 Virt, PULONG64 Offsets, ULONG OffsetsSize,
         PULONG Levels, PULONG PfIndex, PULONG64 LastVal) = 0;
    virtual HRESULT GetBaseTranslationVirtualOffset(PULONG64 Offset) = 0;
    virtual void DecodePte(ULONG64 Pte, PULONG64 PageFrameNumber,
                           PULONG Flags) = 0;

    virtual void Assemble(ProcessInfo* Process,
                          PADDR Addr, PSTR Input) = 0;
    virtual BOOL Disassemble(ProcessInfo* Process,
                             PADDR Addr, PSTR Buffer, BOOL EffAddr) = 0;

    // Creates new Breakpoint object compatible with specific machine
    virtual HRESULT NewBreakpoint(DebugClient* Client, 
                                  ULONG Type, 
                                  ULONG Id, 
                                  Breakpoint** RetBp);

    virtual BOOL IsBreakpointInstruction(ProcessInfo* Process, PADDR Addr) = 0;
    virtual HRESULT InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                ULONG Flags,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen) = 0;
    virtual HRESULT RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen) = 0;
    virtual void AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                   ULONG BreakType) = 0;
    // Base implementations do nothing for platforms which
    // do not support data breakpoints.
    virtual void InsertThreadDataBreakpoints(void);
    virtual void RemoveThreadDataBreakpoints(void);
    // Base implementation returns EXCEPTION_BRAKEPOINT_ANY
    // for STATUS_BREAKPOINT.
    virtual ULONG IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                              ULONG FirstChance,
                                              PADDR BpAddr,
                                              PADDR RelAddr);

    virtual BOOL IsCallDisasm(PCSTR Disasm) = 0;
    virtual BOOL IsReturnDisasm(PCSTR Disasm) = 0;
    virtual BOOL IsSystemCallDisasm(PCSTR Disasm) = 0;
    
    virtual BOOL IsDelayInstruction(PADDR Addr) = 0;
    virtual void GetEffectiveAddr(PADDR Addr, PULONG Size) = 0;
    // Some processors, such as IA64, have instructions which
    // switch between instruction sets, thus the machine type
    // of the next offset may be different from the current machine.
    // If the NextAddr is OFFSET_TRACE the NextMachine is ignored.
    virtual void GetNextOffset(ProcessInfo* Process, BOOL StepOver,
                               PADDR NextAddr, PULONG NextMachine) = 0;
    // Base implementation returns the value from StackWalk.
    virtual void GetRetAddr(PADDR Addr);
    // Base implementation does nothing for machines which
    // do not have symbol prefixing.
    virtual BOOL GetPrefixedSymbolOffset(ProcessInfo* Process,
                                         ULONG64 SymOffset,
                                         ULONG Flags,
                                         PULONG64 PrefixedSymOffset);

    virtual void IncrementBySmallestInstruction(PADDR Addr) = 0;
    virtual void DecrementBySmallestInstruction(PADDR Addr) = 0;

    // Output function entry information for the given entry.
    virtual void OutputFunctionEntry(PVOID RawEntry) = 0;
    // Base implementation returns E_UNEXPECTED.
    virtual HRESULT ReadDynamicFunctionTable(ProcessInfo* Process,
                                             ULONG64 Table,
                                             PULONG64 NextTable,
                                             PULONG64 MinAddress,
                                             PULONG64 MaxAddress,
                                             PULONG64 BaseAddress,
                                             PULONG64 TableData,
                                             PULONG TableSize,
                                             PWSTR OutOfProcessDll,
                                             PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable);
    // Base implementation returns NULL.
    virtual PVOID FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                           ULONG64 Address,
                                           PVOID TableData,
                                           ULONG TableSize);
    // Base implementation returns E_UNEXPECTED.
    virtual HRESULT GetUnwindInfoBounds(ProcessInfo* Process,
                                        ULONG64 TableBase,
                                        PVOID RawTableEntries,
                                        ULONG EntryIndex,
                                        PULONG64 Start,
                                        PULONG Size);

    virtual HRESULT ReadKernelProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id) = 0;
    
    // Base implementation discards page directory entries.
    virtual void FlushPerExecutionCaches(void);

    // Base implementation does nothing.
    virtual HRESULT GetAlternateTriageDumpDataRanges(ULONG64 PrcbBase,
                                                     ULONG64 ThreadBase,
                                                     PADDR_RANGE Ranges);
    
    // Stack output functions
    virtual void PrintStackFrameAddressesTitle(ULONG Flags);
    virtual void PrintStackFrameAddresses(ULONG Flags, 
                                          PDEBUG_STACK_FRAME StackFrame);
    virtual void PrintStackArgumentsTitle(ULONG Flags);
    virtual void PrintStackArguments(ULONG Flags, 
                                     PDEBUG_STACK_FRAME StackFrame);
    virtual void PrintStackCallSiteTitle(ULONG Flags);
    virtual void PrintStackCallSite(ULONG Flags, 
                                    PDEBUG_STACK_FRAME StackFrame, 
                                    PSYMBOL_INFO SiteSymbol,
                                    PSTR SymName,
                                    DWORD64 Displacement);
    virtual void PrintStackNonvolatileRegisters
        (ULONG Flags, 
         PDEBUG_STACK_FRAME StackFrame,
         PCROSS_PLATFORM_CONTEXT Context,
         ULONG FrameNum);
    virtual void PrintStackFrameMemoryUsage(PDEBUG_STACK_FRAME CurFrame,
                                            PDEBUG_STACK_FRAME PrevFrame);

    //
    // Helpers for convenient value access.
    //
    // Note that the basic methods here do not get the register
    // type as is done in the generic code.  All of these methods
    // assume that the proper call is being made for the register.
    // The Get/SetReg methods also only operate on real registers, not
    // subregisters.  Use the Get/SetSubReg methods when dealing
    // with subregisters.
    //
    // Alternately, FullGet/SetVal perform all the necessary
    // work for typing and subregisters.
    //
    
    USHORT GetReg16(ULONG Reg)
    {
        REGVAL RegVal;
        RegVal.I64 = 0;
        GetVal(Reg, &RegVal);
        return RegVal.I16;
    }
    ULONG GetReg32(ULONG Reg)
    {
        REGVAL RegVal;
        RegVal.I64 = 0;
        GetVal(Reg, &RegVal);
        return RegVal.I32;
    }
    void SetReg32(ULONG Reg, ULONG Val)
    {
        REGVAL RegVal;
        RegVal.Type = REGVAL_INT32;
        RegVal.I64 = (ULONG64)Val;
        SetVal(Reg, &RegVal);
    }
    ULONG64 GetReg64(ULONG Reg)
    {
        REGVAL RegVal;
        RegVal.I64 = 0;
        GetVal(Reg, &RegVal);
        return RegVal.I64;
    }
    HRESULT SetReg64(ULONG Reg, ULONG64 Val)
    {
        REGVAL RegVal;
        RegVal.Type = REGVAL_INT64;
        RegVal.I64 = Val;
        RegVal.Nat = FALSE;
        return SetVal(Reg, &RegVal);
    }
    ULONG GetSubReg32(ULONG SubReg)
    {
        REGVAL RegVal;
        REGSUBDEF* SubDef = RegSubDefFromIndex(SubReg);

        if (!SubDef) 
        {
            return 0;
        }

        RegVal.I64 = 0;
        GetVal(SubDef->FullReg, &RegVal);
        return (ULONG)((RegVal.I64 >> SubDef->Shift) & SubDef->Mask);
    }

    HRESULT FullGetVal(ULONG Reg, REGVAL* Val);
    ULONG FullGetVal32(ULONG Reg)
    {
        REGVAL RegVal;
        RegVal.I64 = 0;
        FullGetVal(Reg, &RegVal);
        return RegVal.I32;
    }
    ULONG64 FullGetVal64(ULONG Reg)
    {
        REGVAL RegVal;
        RegVal.I64 = 0;
        FullGetVal(Reg, &RegVal);
        return RegVal.I64;
    }
    HRESULT FullSetVal(ULONG Reg, REGVAL* Val);
    HRESULT FullSetVal32(ULONG Reg, ULONG Val)
    {
        REGVAL RegVal;
        ZeroMemory(&RegVal, sizeof(RegVal));
        RegVal.Type = GetType(Reg);
        RegVal.I32 = Val;
        return FullSetVal(Reg, &RegVal);
    }
    HRESULT FullSetVal64(ULONG Reg, ULONG64 Val)
    {
        REGVAL RegVal;
        ZeroMemory(&RegVal, sizeof(RegVal));
        RegVal.Type = GetType(Reg);
        RegVal.I64 = Val;
        return FullSetVal(Reg, &RegVal);
    }
    
    // Helper function to initialize an ADDR given a flat
    // offset from a known segment or segment register.
    void FormAddr(ULONG SegOrReg, ULONG64 Off, ULONG Flags,
                  PADDR Address);

    REGSUBDEF* RegSubDefFromIndex(ULONG Index);
    REGDEF* RegDefFromIndex(ULONG Index);
    REGDEF* RegDefFromCount(ULONG Count);
    ULONG RegCountFromIndex(ULONG Index);
    
    ContextSave* PushContext(PCROSS_PLATFORM_CONTEXT Context);
    void PopContext(ContextSave* Save);
        
protected:
    TRACEMODE m_TraceMode;

    // Common helpers for disassembly.
    PCHAR m_Buf, m_BufStart;
    
    void BufferHex(ULONG64 Value, ULONG Length, BOOL Signed);
    void BufferInt(ULONG64 Value, ULONG MinLength, BOOL Signed);
    void BufferBlanks(ULONG BufferPos);
    void BufferString(PCSTR String);

    void PrintMultiPtrTitle(const CHAR* Title, USHORT PtrNum);
};

extern ULONG g_PossibleProcessorTypes[MACHIDX_COUNT];

MachineInfo* NewMachineInfo(ULONG Index, ULONG BaseMachineType,
                            TargetInfo* Target);
MachineIndex MachineTypeIndex(ULONG Machine);

// g_AllMachines has a NULL at MACHIDX_COUNT to handle errors.
#define MachineTypeInfo(Target, Machine) \
    (Target)->m_Machines[MachineTypeIndex(Machine)]

void CacheReportInstructions(ULONG64 Pc, ULONG Count, PUCHAR Stream);

BOOL IsImageMachineType64(DWORD MachineType);

extern CHAR g_F0[], g_F1[], g_F2[], g_F3[], g_F4[], g_F5[];
extern CHAR g_F6[], g_F7[], g_F8[], g_F9[], g_F10[], g_F11[];
extern CHAR g_F12[], g_F13[], g_F14[], g_F15[], g_F16[], g_F17[];
extern CHAR g_F18[], g_F19[], g_F20[], g_F21[], g_F22[], g_F23[];
extern CHAR g_F24[], g_F25[], g_F26[], g_F27[], g_F28[], g_F29[];
extern CHAR g_F30[], g_F31[];

extern CHAR g_R0[], g_R1[], g_R2[], g_R3[], g_R4[], g_R5[];
extern CHAR g_R6[], g_R7[], g_R8[], g_R9[], g_R10[], g_R11[];
extern CHAR g_R12[], g_R13[], g_R14[], g_R15[], g_R16[], g_R17[];
extern CHAR g_R18[], g_R19[], g_R20[], g_R21[], g_R22[], g_R23[];
extern CHAR g_R24[], g_R25[], g_R26[], g_R27[], g_R28[], g_R29[];
extern CHAR g_R30[], g_R31[];

#endif // #ifndef __MACHINE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\machine.cpp ===
//----------------------------------------------------------------------------
//
// Abstraction of processor-specific information.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

ULONG g_PossibleProcessorTypes[MACHIDX_COUNT] =
{
    IMAGE_FILE_MACHINE_I386,
    IMAGE_FILE_MACHINE_IA64,
    IMAGE_FILE_MACHINE_AMD64,
    IMAGE_FILE_MACHINE_ARM,
};

// TRUE when symbol prefixing should be done.
BOOL g_PrefixSymbols;

// TRUE if context changed while processing
BOOL g_ContextChanged;

//
// Pushed context space cache.
//

#define CONTEXT_PUSH_CACHE_SIZE 2

ContextSave* g_ContextPushCache[CONTEXT_PUSH_CACHE_SIZE];

//----------------------------------------------------------------------------
//
// MachineInfo.
//
//----------------------------------------------------------------------------

MachineInfo::MachineInfo(TargetInfo* Target)
{
    m_Target = Target;
}

MachineInfo::~MachineInfo(void)
{
    if (g_Machine == this)
    {
        g_Machine = NULL;
    }
    if (g_EventMachine == this)
    {
        g_EventMachine = NULL;
    }
}

HRESULT
MachineInfo::Initialize(void)
{
    m_TraceMode = TRACE_NONE;

    m_ContextState = MCTX_NONE;
    m_ContextIsReadOnly = FALSE;
    m_MainCodeSeg = 0;

    m_NumRegs = 0;
    // Every machine supports basic integer and FP registers.
    m_AllMaskBits = DEBUG_REGISTERS_ALL;

    m_SymPrefixLen = m_SymPrefix != NULL ? strlen(m_SymPrefix) : 0;

    ZeroMemory(m_PageDirectories, sizeof(m_PageDirectories));
    m_Translating = FALSE;

    ULONG i;

    for (i = 0; i < SEGREG_COUNT; i++)
    {
        m_SegRegDesc[i].Flags = SEGDESC_INVALID;
    }

    ZeroMemory(&m_Context, sizeof(m_Context));
    InitializeContextFlags(&m_Context, m_SverCanonicalContext);

    DBG_ASSERT(m_MaxDataBreakpoints <= MAX_DATA_BREAKS);

    //
    // Count register definitions.
    //

    RegisterGroup* Group;

    DBG_ASSERT(m_NumGroups <= MAX_REGISTER_GROUPS);

    for (i = 0; i < m_NumGroups; i++)
    {
        Group = m_Groups[i];

        Group->NumberRegs = 0;

        REGDEF* Def = Group->Regs;
        while (Def->Name != NULL)
        {
            Group->NumberRegs++;
            Def++;
        }

        m_NumRegs += Group->NumberRegs;

        REGALLDESC* Desc = Group->AllExtraDesc;
        if (Desc != NULL)
        {
            while (Desc->Bit != 0)
            {
                m_AllMaskBits |= Desc->Bit;
                Desc++;
            }
        }
    }

    return S_OK;
}

HRESULT
MachineInfo::InitializeForProcessor(void)
{
    // Placeholder.
    return S_OK;
}

ULONG
MachineInfo::CvRegToMachine(CV_HREG_e CvReg)
{
    int Low, High, Mid;

    // Assume that a zero means no register.  This
    // is true enough for CV mappings other than the 68K.
    if (CvReg == 0)
    {
        return CvReg;
    }

    Low = 0;
    High = m_CvRegMapSize - 1;
    while (Low <= High)
    {
        Mid = (Low + High) / 2;
        if (m_CvRegMap[Mid].CvReg == CvReg)
        {
            return m_CvRegMap[Mid].Machine;
        }
        else if (m_CvRegMap[Mid].CvReg < CvReg)
        {
            Low = Mid + 1;
        }
        else
        {
            High = Mid - 1;
        }
    }

    ErrOut("CvRegToMachine(%s) conversion failure for 0x%x\n",
           m_AbbrevName, CvReg);
    return 0;
}

HRESULT
MachineInfo::GetContextState(ULONG State)
{
    if (m_Target->m_RegContextThread == NULL)
    {
        // No error message here as this can get hit during
        // Reload("NT") initialization when accessing paged-out memory.
        // It's also noisy in other failure cases, so rely
        // on higher-level error output.
        return E_UNEXPECTED;
    }

    for (ULONG i = 0; i < m_Target->m_Machine->m_NumExecTypes; i++)
    {
        if (m_Target->m_Machine->m_ExecTypes[i] == m_ExecTypes[0])
        {
            break;
        }
    }
    if (i >= m_Target->m_Machine->m_NumExecTypes)
    {
        ErrOut("Machine is not a possible execution machine\n");
        return E_UNEXPECTED;
    }

    if (State == MCTX_DIRTY)
    {
        g_ContextChanged = TRUE;
    }

    if (m_ContextState >= State)
    {
        return S_OK;
    }

    HRESULT Status = E_UNEXPECTED;

    // Dump support is built into the Ud/Kd routines.
    if (IS_USER_TARGET(m_Target))
    {
        Status = UdGetContextState(State);
    }
    else if (IS_KERNEL_TARGET(m_Target))
    {
        Status = KdGetContextState(State);
    }

    if (Status != S_OK)
    {
        ErrOut("GetContextState failed, 0x%X\n", Status);
        return Status;
    }

    if (State == MCTX_DIRTY)
    {
        DBG_ASSERT(m_ContextState >= MCTX_FULL);
        m_ContextState = State;
    }

    DBG_ASSERT(State <= m_ContextState);
    return S_OK;
}

HRESULT
MachineInfo::SetContext(void)
{
    if (m_ContextState != MCTX_DIRTY)
    {
        // Nothing to write.
        return S_OK;
    }

    if (m_Target->m_RegContextThread == NULL)
    {
        ErrOut("No current thread in SetContext\n");
        return E_UNEXPECTED;
    }

    if (m_ContextIsReadOnly)
    {
        ErrOut("Context cannot be modified\n");
        return E_UNEXPECTED;
    }

    for (ULONG i = 0; i < m_Target->m_Machine->m_NumExecTypes; i++)
    {
        if (m_Target->m_Machine->m_ExecTypes[i] == m_ExecTypes[0])
        {
            break;
        }
    }
    if (i >= m_Target->m_Machine->m_NumExecTypes)
    {
        ErrOut("Machine is not a possible execution machine\n");
        return E_UNEXPECTED;
    }

    HRESULT Status = E_UNEXPECTED;

    if (IS_DUMP_TARGET(m_Target))
    {
        ErrOut("Can't set dump file contexts\n");
        return E_UNEXPECTED;
    }
    else if (IS_USER_TARGET(m_Target))
    {
        Status = UdSetContext();
    }
    else if (IS_KERNEL_TARGET(m_Target))
    {
        Status = KdSetContext();
    }

    if (Status != S_OK)
    {
        ErrOut("SetContext failed, 0x%X\n", Status);
        return Status;
    }

    // No longer dirty.
    m_ContextState = MCTX_FULL;
    return S_OK;
}

HRESULT
MachineInfo::UdGetContextState(ULONG State)
{
    // MCTX_CONTEXT and MCTX_FULL are the same in user mode.
    if (State >= MCTX_CONTEXT && m_ContextState < MCTX_FULL)
    {
        HRESULT Status = m_Target->
            GetContext(m_Target->m_RegContextThread->m_Handle,
                       &m_Context);
        if (Status != S_OK)
        {
            return Status;
        }

        Status = m_Target->GetTargetSegRegDescriptors
            (m_Target->m_RegContextThread->m_Handle,
             0, SEGREG_COUNT, m_SegRegDesc);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_FULL;
    }

    return S_OK;
}

HRESULT
MachineInfo::UdSetContext(void)
{
    return m_Target->SetContext(m_Target->m_RegContextThread->m_Handle,
                                &m_Context);
}

void
MachineInfo::InvalidateContext(void)
{
    m_ContextState = MCTX_NONE;
    m_Target->InvalidateTargetContext();

    ULONG i;

    for (i = 0; i < SEGREG_COUNT; i++)
    {
        m_SegRegDesc[i].Flags = SEGDESC_INVALID;
    }
}

HRESULT
MachineInfo::GetContextFromTaskSegment(ULONG64 TssBase,
                                       PCROSS_PLATFORM_CONTEXT Context,
                                       BOOL Verbose)
{
    // Only x86 has task segments, so fail everywhere else.
    if (Verbose)
    {
        ErrOut("Processor does not have task segments\n");
    }
    return E_UNEXPECTED;
}

void
MachineInfo::GetStackDefaultsFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                         LPADDRESS64 Instr,
                                         LPADDRESS64 Stack,
                                         LPADDRESS64 Frame)
{
    // Zeroed addresses are interpreted as defaults by
    // the dbghelp stack walking code.  Any pure-flat-address
    // processor can use this.
    ZeroMemory(Instr, sizeof(*Instr));
    ZeroMemory(Stack, sizeof(*Stack));
    ZeroMemory(Frame, sizeof(*Frame));
}

void
MachineInfo::SanitizeMemoryContext(PCROSS_PLATFORM_CONTEXT Context)
{
    // Nothing to do.
}

HRESULT
MachineInfo::GetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context,
                            EXDI_CONTEXT_TYPE CtxType)
{
    return E_NOTIMPL;
}

HRESULT
MachineInfo::SetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context,
                            EXDI_CONTEXT_TYPE CtxType)
{
    return E_NOTIMPL;
}

void
MachineInfo::ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                           PEXDI_CONTEXT ExdiContext,
                                           EXDI_CONTEXT_TYPE CtxType)
{
    // Nothing to do.
}

void
MachineInfo::ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                         EXDI_CONTEXT_TYPE CtxType,
                                         PCROSS_PLATFORM_CONTEXT Context)
{
    // Nothing to do.
}

void
MachineInfo::ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                          EXDI_CONTEXT_TYPE CtxType,
                                          ULONG Start, ULONG Count,
                                          PDESCRIPTOR64 Descs)
{
    // Nothing to do.
}

void
MachineInfo::ConvertExdiContextFromSpecial
    (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
     PEXDI_CONTEXT ExdiContext, EXDI_CONTEXT_TYPE CtxType)
{
    // Nothing to do.
}

void
MachineInfo::ConvertExdiContextToSpecial
    (PEXDI_CONTEXT ExdiContext, EXDI_CONTEXT_TYPE CtxType,
     PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    // Nothing to do.
}

ULONG
MachineInfo::GetSegRegNum(ULONG SegReg)
{
    return 0;
}

HRESULT
MachineInfo::GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc)
{
    return E_UNEXPECTED;
}

HRESULT
MachineInfo::SetAndOutputTaskSegment(ULONG64 TssBase,
                                     PCROSS_PLATFORM_CONTEXT Context,
                                     BOOL Extended)
{
    ErrOut("Processor does not have task segments\n");
    return E_UNEXPECTED;
}

void
MachineInfo::KdUpdateControlSet(PDBGKD_ANY_CONTROL_SET ControlSet)
{
    // Nothing to do.
}

HRESULT
MachineInfo::SetDefaultPageDirectories(ThreadInfo* Thread, ULONG Mask)
{
    HRESULT Status;
    ULONG i;
    ULONG64 OldDirs[PAGE_DIR_COUNT];

    //
    // Triage dumps only have virtual memory and no physical
    // translations so we want to catch any usage of page
    // directories as they have no effect.
    DBG_ASSERT(IS_KERNEL_TARGET(m_Target) && !IS_KERNEL_TRIAGE_DUMP(m_Target));

    memcpy(OldDirs, m_PageDirectories, sizeof(m_PageDirectories));
    i = 0;
    while (i < PAGE_DIR_COUNT)
    {
        // Pass on the set to machine-specific code.
        if (Mask & (1 << i))
        {
            if ((Status = SetPageDirectory(Thread, i, 0, &i)) != S_OK)
            {
                memcpy(m_PageDirectories, OldDirs, sizeof(m_PageDirectories));
                return Status;
            }
        }
        else
        {
            i++;
        }
    }

    // Try and validate that the new kernel page directory is
    // valid by checking an address that should always
    // be available.
    if ((Mask & (1 << PAGE_DIR_KERNEL)) &&
        IS_KERNEL_TARGET(m_Target) &&
        m_Target->m_KdDebuggerData.PsLoadedModuleList)
    {
        LIST_ENTRY64 List;

        if ((Status = m_Target->
             ReadListEntry(m_Target->m_ProcessHead,
                           this, m_Target->m_KdDebuggerData.PsLoadedModuleList,
                           &List)) != S_OK)
        {
            // This page directory doesn't seem valid so restore
            // the previous setting and fail.
            memcpy(m_PageDirectories, OldDirs, sizeof(m_PageDirectories));
        }
    }

    return Status;
}

HRESULT
MachineInfo::NewBreakpoint(DebugClient* Client,
                           ULONG Type,
                           ULONG Id,
                           Breakpoint** RetBp)
{
    return E_NOINTERFACE;
}

void
MachineInfo::InsertThreadDataBreakpoints(void)
{
    // Nothing to do.
}

void
MachineInfo::RemoveThreadDataBreakpoints(void)
{
    // Nothing to do.
}

ULONG
MachineInfo::IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                         ULONG FirstChance,
                                         PADDR BpAddr,
                                         PADDR RelAddr)
{
    return Record->ExceptionCode == STATUS_BREAKPOINT ?
        EXBS_BREAKPOINT_ANY : EXBS_NONE;
}

void
MachineInfo::GetRetAddr(PADDR Addr)
{
    DEBUG_STACK_FRAME StackFrame;

    if (StackTrace(NULL,
                   0, 0, 0, STACK_ALL_DEFAULT,
                   &StackFrame, 1, 0, 0, FALSE) > 0)
    {
        ADDRFLAT(Addr, StackFrame.ReturnOffset);
    }
    else
    {
        ErrOut("StackTrace failed\n");
        ADDRFLAT(Addr, 0);
    }
}

BOOL
MachineInfo::GetPrefixedSymbolOffset(ProcessInfo* Proces,
                                     ULONG64 SymOffset,
                                     ULONG Flags,
                                     PULONG64 PrefixedSymOffset)
{
    DBG_ASSERT(m_SymPrefix == NULL);
    // This routine should never be called since there's no prefix.
    return FALSE;
}

HRESULT
MachineInfo::ReadDynamicFunctionTable(ProcessInfo* Process,
                                      ULONG64 Table,
                                      PULONG64 NextTable,
                                      PULONG64 MinAddress,
                                      PULONG64 MaxAddress,
                                      PULONG64 BaseAddress,
                                      PULONG64 TableData,
                                      PULONG TableSize,
                                      PWSTR OutOfProcessDll,
                                      PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable)
{
    // No dynamic function table support.
    return E_UNEXPECTED;
}

PVOID
MachineInfo::FindDynamicFunctionEntry(PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE Table,
                                      ULONG64 Address,
                                      PVOID TableData,
                                      ULONG TableSize)
{
    // No dynamic function tables so no match.
    return NULL;
}

HRESULT
MachineInfo::GetUnwindInfoBounds(ProcessInfo* Process,
                                 ULONG64 TableBase,
                                 PVOID RawTableEntries,
                                 ULONG EntryIndex,
                                 PULONG64 Start,
                                 PULONG Size)
{
    // No dynamic function tables.
    return E_UNEXPECTED;
}

void
MachineInfo::FlushPerExecutionCaches(void)
{
    // Dump targets don't really execute so there's no need
    // to throw away settings, plus the page directories
    // are set to important values during initialization so
    // throwing them away would lead to problems.
    if (!IS_DUMP_TARGET(m_Target))
    {
        ZeroMemory(m_PageDirectories, sizeof(m_PageDirectories));
    }
    m_Translating = FALSE;
}

HRESULT
MachineInfo::GetAlternateTriageDumpDataRanges(ULONG64 PrcbBase,
                                              ULONG64 ThreadBase,
                                              PADDR_RANGE Ranges)
{
    return E_NOTIMPL;
}

void
MachineInfo::PrintStackFrameAddressesTitle(ULONG Flags)
{
    if (!(Flags & DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY))
    {
        PrintMultiPtrTitle("Child-SP", 1);
    }
    PrintMultiPtrTitle("RetAddr", 1);
}

void
MachineInfo::PrintStackFrameAddresses(ULONG Flags,
                                      PDEBUG_STACK_FRAME StackFrame)
{
    if (!(Flags & DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY))
    {
        dprintf("%s ", FormatAddr64(StackFrame->StackOffset));
    }

    dprintf("%s ", FormatAddr64(StackFrame->ReturnOffset));
}

void
MachineInfo::PrintStackArgumentsTitle(ULONG Flags)
{
    dprintf(": ");
    PrintMultiPtrTitle("Args to Child", 4);
    dprintf(": ");
}

void
MachineInfo::PrintStackArguments(ULONG Flags,
                                 PDEBUG_STACK_FRAME StackFrame)
{
    dprintf(": %s %s %s %s : ",
            FormatAddr64(StackFrame->Params[0]),
            FormatAddr64(StackFrame->Params[1]),
            FormatAddr64(StackFrame->Params[2]),
            FormatAddr64(StackFrame->Params[3]));
}

void
MachineInfo::PrintStackCallSiteTitle(ULONG Flags)
{
    dprintf("Call Site");
}

void
MachineInfo::PrintStackCallSite(ULONG Flags,
                                PDEBUG_STACK_FRAME StackFrame,
                                PSYMBOL_INFO SiteSymbol,
                                PSTR SymName,
                                DWORD64 Displacement)
{
    if (SymName[0])
    {
        dprintf("%s", SymName);

        if (!(Flags & DEBUG_STACK_PARAMETERS) ||
            !ShowFunctionParameters(StackFrame))
        {
            // We dont see the parameters
        }

        if (Displacement)
        {
            dprintf("+");
        }
    }
    if (Displacement || !SymName[0])
    {
        dprintf("0x%s", FormatDisp64(Displacement));
    }
}

void
MachineInfo::PrintStackNonvolatileRegisters(ULONG Flags,
                                            PDEBUG_STACK_FRAME StackFrame,
                                            PCROSS_PLATFORM_CONTEXT Context,
                                            ULONG FrameNum)
{
    // Empty base implementation.
}

void
MachineInfo::PrintStackFrameMemoryUsage(PDEBUG_STACK_FRAME CurFrame,
                                        PDEBUG_STACK_FRAME PrevFrame)
{
    if (CurFrame->FrameOffset >= PrevFrame->FrameOffset)
    {
        dprintf(" %6x ",
                (ULONG)(CurFrame->StackOffset - PrevFrame->StackOffset));
    }
    else
    {
        dprintf("        ");
    }
}

HRESULT
MachineInfo::FullGetVal(ULONG Reg, REGVAL* Val)
{
    HRESULT Status;
    int Type;
    REGSUBDEF* SubDef;

    Type = GetType(Reg);
    if (Type == REGVAL_SUB32 || Type == REGVAL_SUB64)
    {
        SubDef = RegSubDefFromIndex(Reg);
        if (SubDef == NULL)
        {
            return E_INVALIDARG;
        }

        Reg = SubDef->FullReg;
    }

    if ((Status = GetVal(Reg, Val)) != S_OK)
    {
        return Status;
    }

    if (Type == REGVAL_SUB32 || Type == REGVAL_SUB64)
    {
        if (Val->Type == REGVAL_SUB32)
        {
            Val->I64Parts.High = 0;
        }

        Val->Type = Type;
        Val->I64 = (Val->I64 >> SubDef->Shift) & SubDef->Mask;
    }

    return S_OK;
}

HRESULT
MachineInfo::FullSetVal(ULONG Reg, REGVAL* Val)
{
    HRESULT Status;
    REGSUBDEF* SubDef;
    REGVAL BaseVal;

    if (Val->Type == REGVAL_SUB32 || Val->Type == REGVAL_SUB64)
    {
        // Look up subreg definition.
        SubDef = RegSubDefFromIndex(Reg);
        if (SubDef == NULL)
        {
            return E_INVALIDARG;
        }

        Reg = SubDef->FullReg;

        if ((Status = GetVal(Reg, &BaseVal)) != S_OK)
        {
            return Status;
        }

        if (Val->Type == REGVAL_SUB32)
        {
            Val->I64Parts.High = 0;
        }

        if (Val->I64 > SubDef->Mask)
        {
            return E_INVALIDARG;
        }

        BaseVal.I64 =
            (BaseVal.I64 & ~(SubDef->Mask << SubDef->Shift)) |
            ((Val->I64 & SubDef->Mask) << SubDef->Shift);

        Val = &BaseVal;
    }

    if ((Status = SetVal(Reg, Val)) != S_OK)
    {
        return Status;
    }

    return S_OK;
}

void
MachineInfo::FormAddr(ULONG SegOrReg, ULONG64 Off,
                      ULONG Flags, PADDR Address)
{
    PDESCRIPTOR64 SegDesc = NULL;
    DESCRIPTOR64 Desc;

    Address->off = Off;

    if (Flags & FORM_SEGREG)
    {
        ULONG SegRegNum = GetSegRegNum(SegOrReg);
        if (SegRegNum)
        {
            Address->seg = GetReg16(SegRegNum);
        }
        else
        {
            Address->seg = 0;
        }
    }
    else
    {
        Address->seg = (USHORT)SegOrReg;
    }

    if (Flags & FORM_VM86)
    {
        Address->type = ADDR_V86;
    }
    else if (Address->seg == 0)
    {
        // A segment wasn't used or segmentation doesn't exist.
        Address->type = ADDR_FLAT;
    }
    else
    {
        HRESULT Status;

        if (Flags & FORM_SEGREG)
        {
            Status = GetSegRegDescriptor(SegOrReg, &Desc);
        }
        else
        {
            Status = m_Target->
                GetSelDescriptor(m_Target->m_RegContextThread, this,
                                 SegOrReg, &Desc);
        }

        if (Status == S_OK)
        {
            SegDesc = &Desc;
            if (((Flags & FORM_CODE) && (Desc.Flags & X86_DESC_LONG_MODE)) ||
                ((Flags & FORM_CODE) == 0 && g_Amd64InCode64))
            {
                Address->type = ADDR_1664;
            }
            else if (Desc.Flags & X86_DESC_DEFAULT_BIG)
            {
                Address->type = ADDR_1632;
            }
            else
            {
                Address->type = ADDR_16;
            }
            if ((Flags & FORM_CODE) &&
                ((m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386 &&
                  Address->type == ADDR_1632) ||
                 (m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64 &&
                  Address->type == ADDR_1664)))
            {
                if ( m_MainCodeSeg == 0 )
                {
                    if ( Desc.Base == 0 )
                    {
                        m_MainCodeSeg = Address->seg;
                    }
                }
                if ( Address->seg == m_MainCodeSeg )
                {
                    Address->type = ADDR_FLAT;
                }
            }
        }
        else
        {
            Address->type = ADDR_16;
        }
    }

    ComputeFlatAddress(Address, SegDesc);
}

REGSUBDEF*
MachineInfo::RegSubDefFromIndex(ULONG Index)
{
    RegisterGroup* Group;
    REGSUBDEF* SubDef;
    ULONG GroupIdx;

    for (GroupIdx = 0;
         GroupIdx < m_NumGroups;
         GroupIdx++)
    {
        Group = m_Groups[GroupIdx];

        SubDef = Group->SubRegs;
        if (SubDef == NULL)
        {
            continue;
        }

        while (SubDef->SubReg != REG_ERROR)
        {
            if (SubDef->SubReg == Index)
            {
                return SubDef;
            }

            SubDef++;
        }
    }

    return NULL;
}

REGDEF*
MachineInfo::RegDefFromIndex(ULONG Index)
{
    REGDEF* Def;
    RegisterGroup* Group;
    ULONG GroupIdx;

    for (GroupIdx = 0;
         GroupIdx < m_NumGroups;
         GroupIdx++)
    {
        Group = m_Groups[GroupIdx];

        Def = Group->Regs;
        while (Def->Name != NULL)
        {
            if (Def->Index == Index)
            {
                return Def;
            }

            Def++;
        }
    }

    return NULL;
}

REGDEF*
MachineInfo::RegDefFromCount(ULONG Count)
{
    RegisterGroup* Group;
    ULONG GroupIdx;

    for (GroupIdx = 0;
         GroupIdx < m_NumGroups;
         GroupIdx++)
    {
        Group = m_Groups[GroupIdx];

        if (Count < Group->NumberRegs)
        {
            return Group->Regs + Count;
        }

        Count -= Group->NumberRegs;
    }

    return NULL;
}

ULONG
MachineInfo::RegCountFromIndex(ULONG Index)
{
    REGDEF* Def;
    RegisterGroup* Group;
    ULONG Count;
    ULONG GroupIdx;

    Count = 0;
    for (GroupIdx = 0;
         GroupIdx < m_NumGroups;
         GroupIdx++)
    {
        Group = m_Groups[GroupIdx];

        Def = Group->Regs;
        while (Def->Name != NULL)
        {
            if (Def->Index == Index)
            {
                return Count + (ULONG)(Def - Group->Regs);
            }

            Def++;
        }

        Count += Group->NumberRegs;
    }

    return NULL;
}

ContextSave*
MachineInfo::PushContext(PCROSS_PLATFORM_CONTEXT Context)
{
    ULONG i;
    ContextSave* Save;

    Save = NULL;
    for (i = 0; i < CONTEXT_PUSH_CACHE_SIZE; i++)
    {
        if (g_ContextPushCache[i])
        {
            Save = g_ContextPushCache[i];
            g_ContextPushCache[i] = NULL;
            break;
        }
    }

    if (!Save)
    {
        // If this allocation fails we simply don't push
        // and the current context is destroyed.  This
        // is detected in pop and things are set up
        // to recover whatever context is possible.
        Save = new ContextSave;
        if (!Save)
        {
            ErrOut("ERROR: Unable to allocate push context\n");
        }
    }

    if (Save)
    {
        Save->ContextState = m_ContextState;
        Save->ReadOnly = m_ContextIsReadOnly;
        Save->Context = m_Context;
        Save->Special = m_Special;
        memcpy(Save->SegRegDesc, m_SegRegDesc, sizeof(m_SegRegDesc));
    }

    if (Context)
    {
        m_Context = *Context;
        m_ContextState = MCTX_FULL;
        m_ContextIsReadOnly = TRUE;
    }
    else
    {
        m_ContextState = MCTX_NONE;
        m_Target->InvalidateTargetContext();
        m_ContextIsReadOnly = FALSE;
    }

    return Save;
}

void
MachineInfo::PopContext(ContextSave* Save)
{
    DBG_ASSERT(m_ContextState != MCTX_DIRTY);

    // If target context reloads were allowed we have
    // to reset the target context to get back any
    // previous state.
    if (!m_ContextIsReadOnly)
    {
        m_Target->InvalidateTargetContext();
    }

    if (!Save)
    {
        // There was an allocation failure during push and
        // the context was destroyed.  Reset things to
        // a no-context state.
        m_ContextState = MCTX_NONE;
        m_ContextIsReadOnly = FALSE;
    }
    else
    {
        ULONG i;

        m_ContextState = Save->ContextState;
        m_ContextIsReadOnly = Save->ReadOnly;
        m_Context = Save->Context;
        m_Special = Save->Special;
        memcpy(m_SegRegDesc, Save->SegRegDesc, sizeof(m_SegRegDesc));

        for (i = 0; i < CONTEXT_PUSH_CACHE_SIZE; i++)
        {
            if (!g_ContextPushCache[i])
            {
                g_ContextPushCache[i] = Save;
                break;
            }
        }
        if (i >= CONTEXT_PUSH_CACHE_SIZE)
        {
            delete Save;
        }
    }
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

MachineInfo*
NewMachineInfo(ULONG Index, ULONG BaseMachineType,
               TargetInfo* Target)
{
    switch(Index)
    {
    case MACHIDX_I386:
        // There are different X86 machines due to
        // the emulations available on various systems and CPUs.
        switch(BaseMachineType)
        {
        case IMAGE_FILE_MACHINE_IA64:
            return new X86OnIa64MachineInfo(Target);
        case IMAGE_FILE_MACHINE_AMD64:
            return new X86OnAmd64MachineInfo(Target);
        default:
            return new X86MachineInfo(Target);
        }
        break;
    case MACHIDX_IA64:
        return new Ia64MachineInfo(Target);
    case MACHIDX_AMD64:
        return new Amd64MachineInfo(Target);
    case MACHIDX_ARM:
        return new ArmMachineInfo(Target);
    }

    return NULL;
}

MachineIndex
MachineTypeIndex(ULONG Machine)
{
    switch(Machine)
    {
    case IMAGE_FILE_MACHINE_I386:
        return MACHIDX_I386;
    case IMAGE_FILE_MACHINE_IA64:
        return MACHIDX_IA64;
    case IMAGE_FILE_MACHINE_AMD64:
        return MACHIDX_AMD64;
    case IMAGE_FILE_MACHINE_ARM:
        return MACHIDX_ARM;
    default:
        return MACHIDX_COUNT;
    }
}

void
CacheReportInstructions(ULONG64 Pc, ULONG Count, PUCHAR Stream)
{
    // There was a long-standing bug in the kernel
    // where it didn't properly remove all breakpoints
    // present in the instruction stream reported to
    // the debugger.  If this kernel suffers from the
    // problem just ignore the stream contents.
    if (Count == 0 || g_Target->m_BuildNumber < 2300)
    {
        return;
    }

    g_Process->m_VirtualCache.Add(Pc, Stream, Count);
}

BOOL
IsImageMachineType64(DWORD MachineType)
{
    switch (MachineType)
    {
    case IMAGE_FILE_MACHINE_AXP64:
    case IMAGE_FILE_MACHINE_IA64:
    case IMAGE_FILE_MACHINE_AMD64:
        return TRUE;
    default:
        return FALSE;
    }
}

//----------------------------------------------------------------------------
//
// Common code and constants.
//
//----------------------------------------------------------------------------

UCHAR g_HexDigit[16] =
{
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};

void
MachineInfo::BufferHex(ULONG64 Value,
                       ULONG Length,
                       BOOL Signed)
{
    CHAR Digit[32];
    LONG Index = 0;

    DBG_ASSERT(Length <= sizeof(Digit));

    if (Signed && (LONG64)Value < 0)
    {
        *m_Buf++ = '-';
        Value = -(LONG64)Value;
    }

    do
    {
        Digit[Index++] = g_HexDigit[Value & 0xf];
        Value >>= 4;
    }
    while ((Signed && Value) || (!Signed && Index < (LONG)Length));

    while (--Index >= 0)
    {
        *m_Buf++ = Digit[Index];
    }
}

void
MachineInfo::BufferInt(ULONG64 Value,
                       ULONG MinLength,
                       BOOL Signed)
{
    CHAR Digit[97];
    LONG Index = 0, MaxDig;
    BOOL Neg;

    DBG_ASSERT(MinLength <= sizeof(Digit));

    if (Signed && (LONG64)Value < 0)
    {
        Neg = TRUE;
        Value = -(LONG64)Value;
    }
    else
    {
        Neg = FALSE;
    }

    do
    {
        Digit[Index++] = (char)((Value % 10) + '0');
        Value /= 10;
    }
    while (Value);

    if (Neg)
    {
        Digit[Index++] = '-';
    }
    MaxDig = Index;

    while ((ULONG)Index < MinLength)
    {
        *m_Buf++ = ' ';
        Index++;
    }

    while (--MaxDig >= 0)
    {
        *m_Buf++ = Digit[MaxDig];
    }
}

void
MachineInfo::BufferBlanks(ULONG Count)
{
    // Guarantees that at least one blank is always buffered.
    do
    {
        *m_Buf++ = ' ';
    }
    while (m_Buf < m_BufStart + Count);
}

void
MachineInfo::BufferString(PCSTR String)
{
    while (*String)
    {
        *m_Buf++ = *String++;
    }
}

void
MachineInfo::PrintMultiPtrTitle(const CHAR* Title, USHORT PtrNum)
{
    size_t PtrLen = (strlen(FormatAddr64(0)) + 1) * PtrNum;
    size_t TitleLen = strlen(Title);

    if (PtrLen < TitleLen)
    {
        // Extremly rare case so keep it simple while slow
        for (size_t i = 0; i < PtrLen - 1; ++i)
        {
            dprintf("%c", Title[i]);
        }
        dprintf(" ");
    }
    else
    {
        dprintf(Title);

        if (PtrLen > TitleLen)
        {
            char Format[16];
            _snprintf(Format, sizeof(Format) - 1,
                      "%% %ds", PtrLen - TitleLen);
            dprintf(Format, "");
        }
    }
}

CHAR g_F0[]  = "f0";
CHAR g_F1[]  = "f1";
CHAR g_F2[]  = "f2";
CHAR g_F3[]  = "f3";
CHAR g_F4[]  = "f4";
CHAR g_F5[]  = "f5";
CHAR g_F6[]  = "f6";
CHAR g_F7[]  = "f7";
CHAR g_F8[]  = "f8";
CHAR g_F9[]  = "f9";
CHAR g_F10[] = "f10";
CHAR g_F11[] = "f11";
CHAR g_F12[] = "f12";
CHAR g_F13[] = "f13";
CHAR g_F14[] = "f14";
CHAR g_F15[] = "f15";
CHAR g_F16[] = "f16";
CHAR g_F17[] = "f17";
CHAR g_F18[] = "f18";
CHAR g_F19[] = "f19";
CHAR g_F20[] = "f20";
CHAR g_F21[] = "f21";
CHAR g_F22[] = "f22";
CHAR g_F23[] = "f23";
CHAR g_F24[] = "f24";
CHAR g_F25[] = "f25";
CHAR g_F26[] = "f26";
CHAR g_F27[] = "f27";
CHAR g_F28[] = "f28";
CHAR g_F29[] = "f29";
CHAR g_F30[] = "f30";
CHAR g_F31[] = "f31";

CHAR g_R0[]  = "r0";
CHAR g_R1[]  = "r1";
CHAR g_R2[]  = "r2";
CHAR g_R3[]  = "r3";
CHAR g_R4[]  = "r4";
CHAR g_R5[]  = "r5";
CHAR g_R6[]  = "r6";
CHAR g_R7[]  = "r7";
CHAR g_R8[]  = "r8";
CHAR g_R9[]  = "r9";
CHAR g_R10[] = "r10";
CHAR g_R11[] = "r11";
CHAR g_R12[] = "r12";
CHAR g_R13[] = "r13";
CHAR g_R14[] = "r14";
CHAR g_R15[] = "r15";
CHAR g_R16[] = "r16";
CHAR g_R17[] = "r17";
CHAR g_R18[] = "r18";
CHAR g_R19[] = "r19";
CHAR g_R20[] = "r20";
CHAR g_R21[] = "r21";
CHAR g_R22[] = "r22";
CHAR g_R23[] = "r23";
CHAR g_R24[] = "r24";
CHAR g_R25[] = "r25";
CHAR g_R26[] = "r26";
CHAR g_R27[] = "r27";
CHAR g_R28[] = "r28";
CHAR g_R29[] = "r29";
CHAR g_R30[] = "r30";
CHAR g_R31[] = "r31";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\image.cpp ===
//----------------------------------------------------------------------------
//
// Image information.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include <common.ver>

#define DBG_MOD_LIST 0
#define DBG_IMAGE_MAP 0

#define HAL_MODULE_NAME     "hal"
#define KDHWEXT_MODULE_NAME "kdcom"

// User-mode minidump can be created with data segments
// embedded in the dump.  If that's the case, don't map
// such sections.
#define IS_MINI_DATA_SECTION(SecHeader)                                       \
    (IS_USER_MINI_DUMP(m_Process->m_Target) &&                                \
     ((SecHeader)->Characteristics & IMAGE_SCN_MEM_WRITE) &&                  \
     ((SecHeader)->Characteristics & IMAGE_SCN_MEM_READ) &&                   \
     (((SecHeader)->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) ||    \
      ((SecHeader)->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA)))

static char s_Blanks16[] = "                ";

PCSTR g_VerStrings[] =
{
    "CompanyName",
    "ProductName",
    "InternalName",
    "OriginalFilename",
    "ProductVersion",
    "FileVersion",
    "PrivateBuild",
    "SpecialBuild",
    "FileDescription",
    "LegalCopyright",
    "LegalTrademarks",
    "Comments",
};

PCSTR g_KernelAliasList[] =
{
    "ntoskrnl.exe",
    "ntkrnlpa.exe",
    "ntkrnlmp.exe",
    "ntkrpamp.exe"
};

PCSTR g_HalAliasList[] =
{
    "halaacpi.dll",
    "halacpi.dll",
    "halapic.dll",
    "halmacpi.dll",
    "halmps.dll",
    "hal.dll",
    "hal486c.dll",
    "halborg.dll",
    "halsp.dll"
};

PCSTR g_KdAliasList[] =
{
    "kdcom.dll",
    "kd1394.dll"
};

MODULE_ALIAS_LIST g_AliasLists[] =
{
    DIMA(g_KernelAliasList), g_KernelAliasList, KERNEL_MODULE_NAME,
    DIMA(g_HalAliasList), g_HalAliasList, HAL_MODULE_NAME,
    DIMA(g_KdAliasList), g_KdAliasList, KDHWEXT_MODULE_NAME,
};

#define MAX_ALIAS_COUNT DIMA(g_HalAliasList)

MODULE_ALIAS_LIST*
FindModuleAliasList(PCSTR ImageName,
                    PBOOL NameInList)
{
    MODULE_ALIAS_LIST* List = g_AliasLists;
    ULONG ListIdx, AliasIdx;

    // Currently alias lists are always looked up by
    // scanning the list for the given name.  If a hit
    // is found, it's always in the list.  In the future
    // we may allow list searches by artificial names.
    if (NameInList)
    {
        *NameInList = TRUE;
    }

    for (ListIdx = 0; ListIdx < MODALIAS_COUNT; ListIdx++)
    {
        DBG_ASSERT(List->Length <= MAX_ALIAS_COUNT);

        for (AliasIdx = 0; AliasIdx < List->Length; AliasIdx++)
        {
            if (!_strcmpi(ImageName, List->Aliases[AliasIdx]))
            {
                return List;
            }
        }

        List++;
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// ImageInfo.
//
//----------------------------------------------------------------------------

ImageInfo::ImageInfo(ProcessInfo* Process,
                     PSTR ImagePath, ULONG64 Base, BOOL Link)
{
    m_Process = Process;
    // We need some information for the image immediately
    // as it's used when inserting the image into the process' list.
    m_BaseOfImage = Base;
    if (ImagePath)
    {
        CopyString(m_ImagePath, ImagePath, DIMA(m_ImagePath));
    }
    else
    {
        m_ImagePath[0] = 0;
    }

    m_Next = NULL;
    m_Linked = FALSE;
    m_Unloaded = FALSE;
    m_FileIsDemandMapped = FALSE;
    m_MapAlreadyFailed = FALSE;
    m_CorImage = FALSE;
    m_UserMode = IS_USER_TARGET(m_Process->m_Target) ? TRUE : FALSE;
    m_File = NULL;
    m_SizeOfImage = 0;
    m_CheckSum = 0;
    m_TimeDateStamp = 0;
    m_SymState = ISS_UNKNOWN;
    m_ModuleName[0] = 0;
    m_OriginalModuleName[0] = 0;
    m_MappedImagePath[0] = 0;
    m_MappedImageBase = NULL;
    m_MemMap = NULL;
    m_TlsIndex = 0xffffffff;
    m_MachineType = IMAGE_FILE_MACHINE_UNKNOWN;

    if (m_Process && Link)
    {
        m_Process->InsertImage(this);
    }
}

ImageInfo::~ImageInfo(void)
{
#if DBG_MOD_LIST
    dprintf("DelImage:\n"
            " ImagePath       %s\n"
            " BaseOfImage     %I64x\n"
            " SizeOfImage     %x\n",
            m_ImagePath,
            m_BaseOfImage,
            m_SizeOfImage);
#endif

    DeleteResources(TRUE);

    if (m_Process && m_Linked)
    {
        // Save the process that was linked with for later use.
        ProcessInfo* Linked = m_Process;

        // Unlink so that the process's module list no longer
        // refers to this image.
        m_Process->RemoveImage(this);

        // Notify with the saved process in order to mark any resulting
        // defered breakpoints due to this mod unload
        NotifyChangeSymbolState(DEBUG_CSS_UNLOADS, m_BaseOfImage, Linked);
    }
}

void
ImageInfo::DeleteResources(BOOL FullDelete)
{
    if (m_Process)
    {
        SymUnloadModule64(m_Process->m_SymHandle, m_BaseOfImage);
    }

    // Unmap the memory for this image.
    UnloadExecutableImageMemory();
    // The mapped image path can be set by demand-mapping
    // of images from partial symbol loads so force it
    // to be zeroed always.
    m_MappedImagePath[0] = 0;
    ClearStoredTypes(m_BaseOfImage);
    g_GenTypes.DeleteByImage(m_BaseOfImage);
    if (m_File && (m_FileIsDemandMapped || FullDelete))
    {
        CloseHandle(m_File);
        m_File = NULL;
        m_FileIsDemandMapped = FALSE;
    }

    g_LastDump.AvoidUsingImage(this);
    g_LastEvalResult.AvoidUsingImage(this);
    if (g_ScopeBuffer.CheckedForThis &&
        g_ScopeBuffer.ThisData.m_Image == this)
    {
        g_ScopeBuffer.CheckedForThis = FALSE;
        ZeroMemory(&g_ScopeBuffer.ThisData,
                   sizeof(g_ScopeBuffer.ThisData));
    }
}

BOOL
ImageInfo::MapImageRegion(MappedMemoryMap* MemMap,
                          PVOID FileMapping,
                          ULONG Rva, ULONG Size, ULONG RawDataOffset,
                          BOOL AllowOverlap)
{
    HRESULT Status;

    // Mark the region with the image structure to identify the
    // region as an image area.
    if ((Status = MemMap->AddRegion(m_BaseOfImage + Rva, Size,
                                    (PUCHAR)FileMapping + RawDataOffset,
                                    this, AllowOverlap)) != S_OK)
    {
        ErrOut("Unable to map %s section at %s, %s\n",
               m_ImagePath,
               FormatAddr64(m_BaseOfImage + Rva),
               FormatStatusCode(Status));

        // Conflicting region data is not a critical failure
        // unless the incomplete information flag is set.
        if (Status != HR_REGION_CONFLICT ||
            (g_EngOptions & DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION))
        {
            UnloadExecutableImageMemory();
            return FALSE;
        }
    }

#if DBG_IMAGE_MAP_REGIONS
    dprintf("Map %s: %s to %s\n",
            m_ImagePath,
            FormatAddr64(m_BaseOfImage + Rva),
            FormatAddr64(m_BaseOfImage + Rva + Size - 1));
#endif

    return TRUE;
}

BOOL
ImageInfo::LoadExecutableImageMemory(MappedMemoryMap* MemMap,
                                     BOOL Verbose)
{
    PVOID FileMapping;

    if (m_MappedImageBase)
    {
        // Memory is already mapped.
        return TRUE;
    }

    if (m_MapAlreadyFailed)
    {
        // We've already tried to map this image and
        // failed, so just quit right away.  This prevents
        // tons of duplicate failure messages and wasted time.
        // A reload will discard this ImageInfo and allow
        // a new attempt, so it doesn't prevent the user
        // from retrying with different parameters later.
        return FALSE;
    }

    if (m_FileIsDemandMapped)
    {
        // This image has already been partially mapped
        // so we can't do a full mapping.  We could actually
        // make this work if necessary but there are no
        // cases where this is interesting right now.
        ErrOut("Can't fully map a partially mapped image\n");
        return FALSE;
    }

    DBG_ASSERT(m_File == NULL);

    FileMapping = FindImageFile(m_Process,
                                m_ImagePath,
                                m_SizeOfImage,
                                m_CheckSum,
                                m_TimeDateStamp,
                                &m_File,
                                m_MappedImagePath);
    if (FileMapping == NULL)
    {
        if (Verbose)
        {
            ErrOut("Unable to load image %s\n", m_ImagePath);
        }
        m_MapAlreadyFailed = TRUE;
        return FALSE;
    }

    PIMAGE_NT_HEADERS Header = ImageNtHeader(FileMapping);

    // Header was already validated in MapImageFile.
    DBG_ASSERT(Header != NULL);

    // Map the header so we have it later.
    // Mark it with the image structure that this mapping is for.
    if (MemMap->AddRegion(m_BaseOfImage,
                          Header->OptionalHeader.SizeOfHeaders,
                          FileMapping, this, FALSE) != S_OK)
    {
        UnmapViewOfFile(FileMapping);
        if (m_File != NULL)
        {
            CloseHandle(m_File);
            m_File = NULL;
        }
        m_MappedImagePath[0] = 0;
        m_MapAlreadyFailed = TRUE;
        ErrOut("Unable to map image header memory for %s\n",
               m_ImagePath);
        return FALSE;
    }

    // Mark the image as having some mapped memory.
    m_MappedImageBase = FileMapping;
    m_MemMap = MemMap;

    PIMAGE_DATA_DIRECTORY DebugDataDir;
    IMAGE_DEBUG_DIRECTORY UNALIGNED * DebugDir = NULL;

    // Due to a linker bug, some images have debug data that is not
    // included as part of a section.  Scan the debug data directory
    // and map anything that isn't already mapped.
    switch(Header->OptionalHeader.Magic)
    {
    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
        DebugDataDir = &((PIMAGE_NT_HEADERS32)Header)->OptionalHeader.
            DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
        break;
    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
        DebugDataDir = &((PIMAGE_NT_HEADERS64)Header)->OptionalHeader.
            DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
        break;
    default:
        DebugDataDir = NULL;
        break;
    }

    //
    // Map all the sections in the image at their
    // appropriate offsets from the base address.
    //

    ULONG i;

#if DBG_IMAGE_MAP
    dprintf("Map %s: base %s, size %x, %d sections, mapping %p\n",
            m_ImagePath, FormatAddr64(m_BaseOfImage),
            m_SizeOfImage, Header->FileHeader.NumberOfSections,
            FileMapping);
#endif

    PIMAGE_SECTION_HEADER SecHeader = IMAGE_FIRST_SECTION(Header);
    for (i = 0; i < Header->FileHeader.NumberOfSections; i++)
    {
        BOOL AllowOverlap = FALSE;

#if DBG_IMAGE_MAP
        dprintf("  %2d: %8.8s v %08x s %08x p %08x char %X\n", i,
                SecHeader->Name, SecHeader->VirtualAddress,
                SecHeader->SizeOfRawData, SecHeader->PointerToRawData,
                SecHeader->Characteristics);
#endif

        if (SecHeader->SizeOfRawData == 0)
        {
            // Probably a BSS section that describes
            // a zero-filled data region and so is not
            // present in the executable.  This should really
            // map to the appropriate page full of zeroes but
            // for now just ignore it.
            SecHeader++;
            continue;
        }

        if (IS_MINI_DATA_SECTION(SecHeader))
        {
            // Don't map any data sections as their content
            // may or may not be correct.  Rather than presenting
            // data which may be wrong just leave it out.
            SecHeader++;
            continue;
        }

        if (DebugDataDir != NULL &&
            DebugDataDir->VirtualAddress >= SecHeader->VirtualAddress &&
            DebugDataDir->VirtualAddress < SecHeader->VirtualAddress +
            SecHeader->SizeOfRawData)
        {
#if DBG_IMAGE_MAP
            dprintf("    DebugDataDir found in sec %d at %X (%X)\n",
                    i, DebugDataDir->VirtualAddress,
                    DebugDataDir->VirtualAddress - SecHeader->VirtualAddress);
#endif

            DebugDir = (PIMAGE_DEBUG_DIRECTORY)
                ((PUCHAR)FileMapping + (DebugDataDir->VirtualAddress -
                                        SecHeader->VirtualAddress +
                                        SecHeader->PointerToRawData));
        }

        // As a sanity check make sure that the mapped region will
        // fall within the overall image bounds.
        if (SecHeader->VirtualAddress >= m_SizeOfImage ||
            SecHeader->VirtualAddress + SecHeader->SizeOfRawData >
            m_SizeOfImage)
        {
            WarnOut("WARNING: Image %s section %d extends "
                    "outside of image bounds\n",
                    m_ImagePath, i);
        }

        if (!MapImageRegion(MemMap, FileMapping,
                            SecHeader->VirtualAddress,
                            SecHeader->SizeOfRawData,
                            SecHeader->PointerToRawData,
                            AllowOverlap))
        {
            m_MapAlreadyFailed = TRUE;
            return FALSE;
        }

        SecHeader++;
    }

    if (DebugDir != NULL)
    {
        i = DebugDataDir->Size / sizeof(*DebugDir);

#if DBG_IMAGE_MAP
        dprintf("    %d debug dirs\n", i);
#endif

        while (i-- > 0)
        {
#if DBG_IMAGE_MAP
            dprintf("    Dir %d at %p\n", i, DebugDir);
#endif

            // If this debug directory's data is past the size
            // of the image it's a good indicator of the problem.
            if (DebugDir->AddressOfRawData != 0 &&
                DebugDir->PointerToRawData >= m_SizeOfImage &&
                !MemMap->GetRegionInfo(m_BaseOfImage +
                                       DebugDir->AddressOfRawData,
                                       NULL, NULL, NULL, NULL))
            {
#if DBG_IMAGE_MAP
                dprintf("    Mapped hidden debug data at RVA %08x, "
                        "size %x, ptr %08x\n",
                        DebugDir->AddressOfRawData, DebugDir->SizeOfData,
                        DebugDir->PointerToRawData);
#endif

                if (MemMap->AddRegion(m_BaseOfImage +
                                      DebugDir->AddressOfRawData,
                                      DebugDir->SizeOfData,
                                      (PUCHAR)FileMapping +
                                      DebugDir->PointerToRawData,
                                      this, FALSE) != S_OK)
                {
                    ErrOut("Unable to map extended debug data at %s\n",
                           FormatAddr64(m_BaseOfImage +
                                        DebugDir->AddressOfRawData));
                }
            }

            DebugDir++;
        }
    }

    if (g_SymOptions & SYMOPT_DEBUG)
    {
        CompletePartialLine(DEBUG_OUTPUT_SYMBOLS);
        MaskOut(DEBUG_OUTPUT_SYMBOLS, "DBGENG:  %s - Mapped image memory\n",
                m_MappedImagePath);
    }

    return TRUE;
}

void
ImageInfo::UnloadExecutableImageMemory(void)
{
    ULONG64 RegBase;
    ULONG RegSize;

    if (!m_MappedImageBase)
    {
        // Nothing mapped.
        return;
    }

    DBG_ASSERT(m_MemMap && m_File);

    //
    // This routine is called in various shutdown and deletion
    // paths so it can't really fail.  Fortunately,
    // all of this image's memory regions are tagged with
    // the image pointer, so we can avoid all the work of
    // walking the image sections and so forth.  We simply
    // scan the map for any sections marked with this image
    // and remove them.  This guarantees
    // that no mapped memory from this image will remain.
    //

    for (;;)
    {
        if (!m_MemMap->GetRegionByUserData(this, &RegBase, &RegSize))
        {
            break;
        }

        m_MemMap->RemoveRegion(RegBase, RegSize);
    }

    UnmapViewOfFile(m_MappedImageBase);
    CloseHandle(m_File);

    m_MappedImageBase = NULL;
    m_File = NULL;
    m_MappedImagePath[0] = 0;
    m_MemMap = NULL;
}

BOOL
ImageInfo::DemandLoadImageMemory(BOOL CheckIncomplete, BOOL Verbose)
{
    if (!IS_DUMP_WITH_MAPPED_IMAGES(m_Process->m_Target))
    {
        return TRUE;
    }

    if (!LoadExecutableImageMemory(&((DumpTargetInfo*)m_Process->m_Target)->
                                   m_ImageMemMap, Verbose))
    {
        // If the caller has requested that we fail on
        // incomplete information fail the module load.
        // We don't do this if we're reusing an existing
        // module under the assumption that it's better
        // to continue and try to complete the reused
        // image rather than deleting it.
        if (CheckIncomplete &&
            (g_EngOptions & DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION))
        {
            return FALSE;
        }
    }

    return TRUE;
}

HRESULT
ImageInfo::GetTlsIndex(void)
{
    HRESULT Status;
    IMAGE_NT_HEADERS64 Hdrs;
    ULONG64 Addr;

    // Check to see if it's already set.
    if (m_TlsIndex != 0xffffffff)
    {
        return S_OK;
    }

    if ((Status = m_Process->m_Target->
         ReadImageNtHeaders(m_Process, m_BaseOfImage, &Hdrs)) != S_OK)
    {
        return Status;
    }

    if (Hdrs.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size == 0)
    {
        // No TLS usage.
        m_TlsIndex = 0;
        return S_OK;
    }

    Addr = m_BaseOfImage + Hdrs.OptionalHeader.
        DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
    if (Hdrs.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        IMAGE_TLS_DIRECTORY64 Tls;

        if ((Status = m_Process->m_Target->
             ReadAllVirtual(m_Process, Addr, &Tls, sizeof(Tls))) != S_OK)
        {
            return Status;
        }

        Addr = Tls.AddressOfIndex;
    }
    else
    {
        IMAGE_TLS_DIRECTORY32 Tls;

        if ((Status = m_Process->m_Target->
             ReadAllVirtual(m_Process, Addr, &Tls, sizeof(Tls))) != S_OK)
        {
            return Status;
        }

        Addr = EXTEND64(Tls.AddressOfIndex);
    }

    if ((Status = m_Process->m_Target->
         ReadAllVirtual(m_Process, Addr, &m_TlsIndex,
                        sizeof(m_TlsIndex))) != S_OK)
    {
        m_TlsIndex = 0xffffffff;
    }

    return Status;
}

ULONG
ImageInfo::GetMachineTypeFromHeader(void)
{
    ULONG Machine = IMAGE_FILE_MACHINE_UNKNOWN;
    IMAGE_DOS_HEADER DosHdr;
    IMAGE_NT_HEADERS64 NtHdr;
    ULONG Done;

    //
    // Try to read the memory headers.
    //

    if (m_Process->m_Target->
        ReadAllVirtual(m_Process, m_BaseOfImage,
                       &DosHdr, sizeof(DosHdr)) == S_OK &&
        DosHdr.e_magic == IMAGE_DOS_SIGNATURE &&
        m_Process->m_Target->
        ReadAllVirtual(m_Process, m_BaseOfImage + DosHdr.e_lfanew,
                       &NtHdr,
                       FIELD_OFFSET(IMAGE_NT_HEADERS64,
                                    FileHeader.NumberOfSections)) == S_OK &&
        NtHdr.Signature == IMAGE_NT_SIGNATURE &&
        MachineTypeIndex(NtHdr.FileHeader.Machine) != MACHIDX_COUNT)
    {
        Machine = NtHdr.FileHeader.Machine;
    }

    //
    // Try to read the file headers.
    //

    if (Machine == IMAGE_FILE_MACHINE_UNKNOWN &&
        m_File &&
        SetFilePointer(m_File, 0, NULL, FILE_BEGIN) !=
            INVALID_SET_FILE_POINTER &&
        ReadFile(m_File, &DosHdr, sizeof(DosHdr), &Done, NULL) &&
        Done == sizeof(DosHdr) &&
        DosHdr.e_magic == IMAGE_DOS_SIGNATURE &&
        SetFilePointer(m_File, DosHdr.e_lfanew, NULL, FILE_BEGIN) !=
            INVALID_SET_FILE_POINTER &&
        ReadFile(m_File, &NtHdr,
                 FIELD_OFFSET(IMAGE_NT_HEADERS64,
                              FileHeader.NumberOfSections), &Done, NULL) &&
        Done == FIELD_OFFSET(IMAGE_NT_HEADERS64,
                             FileHeader.NumberOfSections) &&
        NtHdr.Signature == IMAGE_NT_SIGNATURE &&
        MachineTypeIndex(NtHdr.FileHeader.Machine) != MACHIDX_COUNT)
    {
        Machine = NtHdr.FileHeader.Machine;
    }

    m_MachineType = Machine;
    return Machine;
}

ULONG
ImageInfo::CvRegToMachine(CV_HREG_e CvReg)
{
    ULONG MachType;

    // Assume that a zero means no register.  This
    // is true enough for CV mappings other than the 68K.
    if (CvReg == 0)
    {
        return CvReg;
    }

    if ((MachType = GetMachineType()) == IMAGE_FILE_MACHINE_UNKNOWN)
    {
        // Default to the native machine type if we can't
        // determine a specific machine type.
        MachType = m_Process->m_Target->m_MachineType;
    }

    return MachineTypeInfo(m_Process->m_Target, MachType)->
        CvRegToMachine(CvReg);
}

void
ImageInfo::OutputVersionInformation(void)
{
    TargetInfo* Target = m_Process->m_Target;
    VS_FIXEDFILEINFO FixedVer;
    ULONG i;
    char Item[128];
    char VerString[128];

    if (Target->
        GetImageVersionInformation(m_Process, m_ImagePath, m_BaseOfImage, "\\",
                                   &FixedVer, sizeof(FixedVer), NULL) == S_OK)
    {
        dprintf("    File version:     %d.%d.%d.%d\n",
                FixedVer.dwFileVersionMS >> 16,
                FixedVer.dwFileVersionMS & 0xFFFF,
                FixedVer.dwFileVersionLS >> 16,
                FixedVer.dwFileVersionLS & 0xFFFF);
        dprintf("    Product version:  %d.%d.%d.%d\n",
                FixedVer.dwProductVersionMS >> 16,
                FixedVer.dwProductVersionMS & 0xFFFF,
                FixedVer.dwProductVersionLS >> 16,
                FixedVer.dwProductVersionLS & 0xFFFF);

        FixedVer.dwFileFlags &= FixedVer.dwFileFlagsMask;
        dprintf("    File flags:       %X (Mask %X)",
                FixedVer.dwFileFlags, FixedVer.dwFileFlagsMask);
        if (FixedVer.dwFileFlags & VS_FF_DEBUG)
        {
            dprintf(" Debug");
        }
        if (FixedVer.dwFileFlags & VS_FF_PRERELEASE)
        {
            dprintf(" Pre-release");
        }
        if (FixedVer.dwFileFlags & VS_FF_PATCHED)
        {
            dprintf(" Patched");
        }
        if (FixedVer.dwFileFlags & VS_FF_PRIVATEBUILD)
        {
            dprintf(" Private");
        }
        if (FixedVer.dwFileFlags & VS_FF_SPECIALBUILD)
        {
            dprintf(" Special");
        }
        dprintf("\n");

        dprintf("    File OS:          %X", FixedVer.dwFileOS);
        switch(FixedVer.dwFileOS & 0xffff0000)
        {
        case VOS_DOS:
            dprintf(" DOS");
            break;
        case VOS_OS216:
            dprintf(" OS/2 16-bit");
            break;
        case VOS_OS232:
            dprintf(" OS/2 32-bit");
            break;
        case VOS_NT:
            dprintf(" NT");
            break;
        case VOS_WINCE:
            dprintf(" CE");
            break;
        default:
            dprintf(" Unknown");
            break;
        }
        switch(FixedVer.dwFileOS & 0xffff)
        {
        case VOS__WINDOWS16:
            dprintf(" Win16");
            break;
        case VOS__PM16:
            dprintf(" Presentation Manager 16-bit");
            break;
        case VOS__PM32:
            dprintf(" Presentation Manager 16-bit");
            break;
        case VOS__WINDOWS32:
            dprintf(" Win32");
            break;
        default:
            dprintf(" Base");
            break;
        }
        dprintf("\n");

        dprintf("    File type:        %X.%X",
                FixedVer.dwFileType, FixedVer.dwFileSubtype);
        switch(FixedVer.dwFileType)
        {
        case VFT_APP:
            dprintf(" App");
            break;
        case VFT_DLL:
            dprintf(" Dll");
            break;
        case VFT_DRV:
            dprintf(" Driver");
            break;
        case VFT_FONT:
            dprintf(" Font");
            break;
        case VFT_VXD:
            dprintf(" VXD");
            break;
        case VFT_STATIC_LIB:
            dprintf(" Static library");
            break;
        default:
            dprintf(" Unknown");
            break;
        }
        dprintf("\n");

        dprintf("    File date:        %08X.%08X\n",
                FixedVer.dwFileDateMS, FixedVer.dwFileDateLS);
    }

    for (i = 0; i < DIMA(g_VerStrings); i++)
    {
        sprintf(Item, "\\StringFileInfo\\%04x%04x\\%s",
                VER_VERSION_TRANSLATION, g_VerStrings[i]);
        if (SUCCEEDED(Target->GetImageVersionInformation
                      (m_Process, m_ImagePath, m_BaseOfImage, Item,
                       VerString, sizeof(VerString), NULL)))
        {
            PCSTR Blanks;
            int Len = strlen(g_VerStrings[i]);
            if (Len > 16)
            {
                Len = 16;
            }
            Blanks = s_Blanks16 + Len;
            dprintf("    %.16s:%s %s\n", g_VerStrings[i], Blanks, VerString);
        }
    }
}

void
ImageInfo::ValidateSymbolLoad(PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 DefLoad)
{
    //
    // If we had a 0 timestamp for the image, try to update it
    // from the image since for NT4 - XP, the kernel
    // does not report timestamps in the initial symbol load
    // module
    //

    if (m_BaseOfImage && !m_TimeDateStamp)
    {
        DWORD CheckSum;
        DWORD TimeDateStamp;
        DWORD SizeOfImage;

        if (GetHeaderInfo(m_Process,
                          m_BaseOfImage,
                          &CheckSum,
                          &TimeDateStamp,
                          &SizeOfImage))
        {
            m_TimeDateStamp = TimeDateStamp;
        }
    }

    m_SymState = ISS_MATCHED;

    if (DefLoad->TimeDateStamp == 0 ||
        m_TimeDateStamp == 0 ||
        m_TimeDateStamp == UNKNOWN_TIMESTAMP)
    {
        dprintf("*** WARNING: Unable to verify timestamp for %s\n",
                DefLoad->FileName);
        m_SymState = ISS_UNKNOWN_TIMESTAMP;
    }
    else if (DefLoad->CheckSum == 0 ||
             m_CheckSum == 0 ||
             m_CheckSum == UNKNOWN_CHECKSUM)
    {
        dprintf("*** WARNING: Unable to verify checksum for %s\n",
                DefLoad->FileName);
        m_SymState = ISS_UNKNOWN_CHECKSUM;
    }
    else if (DefLoad->CheckSum != m_CheckSum)
    {
        m_SymState = ISS_BAD_CHECKSUM;

        if (m_Process->m_Target->m_MachineType == IMAGE_FILE_MACHINE_I386)
        {
            if (IS_USER_TARGET(m_Process->m_Target) ||
                m_Process->m_Target->m_NumProcessors == 1)
            {
                char FileName[_MAX_FNAME];

                //
                // See if this is an MP image with the
                // lock table removed by setup. If
                // it is and the timestamps match, don't
                // print the invalid checksum warning.
                //

                _splitpath(DefLoad->FileName, NULL, NULL, FileName, NULL);

                if ((!_stricmp(FileName, "kernel32") ||
                     (IS_KERNEL_TARGET(m_Process->m_Target) &&
                      !_stricmp(FileName, "win32k")) ||
                     !_stricmp(FileName, "wow32") ||
                     !_stricmp(FileName, "ntvdm") ||
                     !_stricmp(FileName, "ntdll")) &&
                    m_TimeDateStamp == DefLoad->TimeDateStamp)
                {
                    m_SymState = ISS_MATCHED;
                }
            }
        }

        if (m_SymState == ISS_BAD_CHECKSUM)
        {
            //
            // Only print the message if the timestamps
            // are wrong.
            //

            if (m_TimeDateStamp != DefLoad->TimeDateStamp)
            {
                dprintf("*** WARNING: symbols timestamp "
                        "is wrong 0x%08x 0x%08x for %s\n",
                        m_TimeDateStamp,
                        DefLoad->TimeDateStamp,
                        DefLoad->FileName);
            }
        }
    }

    IMAGEHLP_MODULE64 SymModInfo;

    SymModInfo.SizeOfStruct = sizeof(SymModInfo);
    if (SymGetModuleInfo64(m_Process->m_SymHandle, m_BaseOfImage, &SymModInfo))
    {
        if (SymModInfo.SymType == SymExport)
        {
            WarnOut("*** ERROR: Symbol file could not be found."
                    "  Defaulted to export symbols for %s - \n",
                    DefLoad->FileName);
        }
        if (SymModInfo.SymType == SymNone)
        {
            WarnOut("*** ERROR: Module load completed but "
                    "symbols could not be loaded for %s\n",
                    DefLoad->FileName);
        }

        // If the load reports a mismatched PDB or DBG file
        // that overrides the other symbol states.
        if (SymModInfo.PdbUnmatched ||
            SymModInfo.DbgUnmatched)
        {
            m_SymState = ISS_MISMATCHED_SYMBOLS;

            if ((g_SymOptions & SYMOPT_DEBUG) &&
                SymModInfo.SymType != SymNone &&
                SymModInfo.SymType != SymExport)
            {
                // We loaded some symbols but they don't match.
                // Give a !sym noisy message referring to the
                // debugger documentation.
                CompletePartialLine(DEBUG_OUTPUT_SYMBOLS);
                MaskOut(DEBUG_OUTPUT_SYMBOLS,
                        "DBGENG:  %s has mismatched symbols - "
                        "type \".hh dbgerr003\" for details\n",
                        DefLoad->FileName);
            }
        }
    }
}

HRESULT
ImageInfo::FindSysAssert(ULONG64 Offset,
                         PSTR FileName,
                         ULONG FileNameChars,
                         PULONG Line,
                         PSTR AssertText,
                         ULONG AssertTextChars)
{
#if 0
    HRESULT Status;
    IMAGEHLP_LINE64 SymLine;
    ULONG Disp32;
    ULONG64 Disp64;
    SYMBOL_INFO_AND_NAME SymInfo;
    PSTR Text;

    // Look for DbgAssertBreak annotation for the given offset.
    if (!SymFromAddrByTag(m_Process->m_SymHandle, Offset, SymTagAnnotation,
                        &Disp64, SymInfo) ||
        Disp64 != 0)
    {
        return E_NOINTERFACE;
    }

    Text = SymInfo->Name;
    if (strcmp(Text, "DbgAssertBreak"))
    {
        return E_NOINTERFACE;
    }
    Text += strlen(Text) + 1;

    // Get the file and line for reference.
    if (!GetLineFromAddr(m_Process, Offset, &SymLine, &Disp32))
    {
        return E_NOINTERFACE;
    }

    //
    // Found a match, return the information.
    //

    Status = FillStringBuffer(SymLine.FileName, 0,
                              FileName, FileNameChars, NULL);
    *Line = SymLine.LineNumber;
    if (FillStringBuffer(Text, 0,
                         AssertText, AssertTextChars, NULL) == S_FALSE)
    {
        Status = S_FALSE;
    }

    return Status;
#else
    // Removing this to keep the API out of the .Net server release.
    return E_NOINTERFACE;
#endif
}

void
ImageInfo::ReloadSymbols(void)
{
    // Force all symbols to be unloaded so that symbols will
    // be reloaded with any updated settings.
    SymUnloadModule64(m_Process->m_SymHandle, m_BaseOfImage);
    ClearStoredTypes(m_BaseOfImage);
    if (!SymLoadModule64(m_Process->m_SymHandle,
                         m_File,
                         PrepareImagePath(m_ImagePath),
                         m_ModuleName,
                         m_BaseOfImage,
                         m_SizeOfImage))
    {
        ErrOut("Unable to reload %s\n", m_ModuleName);
    }
}

void
ImageInfo::FillModuleParameters(PDEBUG_MODULE_PARAMETERS Params)
{
    Params->Base = m_BaseOfImage;
    Params->Size = m_SizeOfImage;
    Params->TimeDateStamp = m_TimeDateStamp;
    Params->Checksum = m_CheckSum;
    Params->Flags = 0;
    if (m_SymState == ISS_BAD_CHECKSUM)
    {
        Params->Flags |= DEBUG_MODULE_SYM_BAD_CHECKSUM;
    }
    if (m_UserMode)
    {
        Params->Flags |= DEBUG_MODULE_USER_MODE;
    }
    Params->SymbolType = DEBUG_SYMTYPE_DEFERRED;
    Params->ImageNameSize = strlen(m_ImagePath) + 1;
    Params->ModuleNameSize = strlen(m_ModuleName) + 1;
    Params->LoadedImageNameSize = 0;
    Params->SymbolFileNameSize = 0;
    ZeroMemory(Params->Reserved, sizeof(Params->Reserved));

    IMAGEHLP_MODULE64 ModInfo;

    ModInfo.SizeOfStruct = sizeof(ModInfo);
    if (SymGetModuleInfo64(m_Process->m_SymHandle,
                           m_BaseOfImage, &ModInfo))
    {
        // DEBUG_SYMTYPE_* values match imagehlp's SYM_TYPE.
        // Assert some key equivalences.
        C_ASSERT(DEBUG_SYMTYPE_PDB == SymPdb &&
                 DEBUG_SYMTYPE_EXPORT == SymExport &&
                 DEBUG_SYMTYPE_DEFERRED == SymDeferred &&
                 DEBUG_SYMTYPE_DIA == SymDia);

        Params->SymbolType = (ULONG)ModInfo.SymType;
        Params->LoadedImageNameSize = strlen(ModInfo.LoadedImageName) + 1;
        Params->SymbolFileNameSize = strlen(ModInfoSymFile(&ModInfo)) + 1;
    }

    Params->MappedImageNameSize = strlen(m_MappedImagePath) + 1;
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

PSTR
UnknownImageName(ULONG64 ImageBase, PSTR Buffer, ULONG BufferChars)
{
    PrintString(Buffer, BufferChars,
                UNKNOWN_IMAGE_NAME "_%s", FormatAddr64(ImageBase));
    return Buffer;
}

PSTR
ValidateImagePath(PSTR ImagePath, ULONG ImagePathChars,
                  ULONG64 ImageBase,
                  PSTR AnsiBuffer, ULONG AnsiBufferChars)
{
    if (!ImagePath || !ImagePathChars)
    {
        WarnOut("Missing image name, possible corrupt data.\n");
        goto Invalid;
    }

    if (ImagePathChars >= MAX_IMAGE_PATH)
    {
        WarnOut("Image path too long, possible corrupt data.\n");
        goto Invalid;
    }

    // Incoming path may not be terminated, so force it
    // in the copy buffer.
    CopyNString(AnsiBuffer, ImagePath, ImagePathChars, AnsiBufferChars);

    if (IsValidName(AnsiBuffer))
    {
        return AnsiBuffer;
    }

    // Converted name doesn't look valid, fall into
    // replacement case.

 Invalid:
    return UnknownImageName(ImageBase, AnsiBuffer, AnsiBufferChars);
}

PSTR
ConvertAndValidateImagePathW(PWSTR ImagePath, ULONG ImagePathChars,
                             ULONG64 ImageBase,
                             PSTR AnsiBuffer, ULONG AnsiBufferChars)
{
    if (!ImagePath || !ImagePathChars)
    {
        WarnOut("Missing image name, possible corrupt data.\n");
        goto Invalid;
    }

    if (ImagePathChars >= MAX_IMAGE_PATH)
    {
        WarnOut("Image path too long, possible corrupt data.\n");
        goto Invalid;
    }

    //
    // Dumps, particularly kernel minidumps, can sometimes
    // have bad module name string entries.  There's no guaranteed
    // way of detecting such bad strings so we use a simple
    // two-point heuristic:
    // 1. If we can't convert the Unicode to ANSI, consider it bad.
    //    The WCTMB call will fail if the name is too long also,
    //    but this isn't a bad thing.
    // 2. If the resulting name doesn't contain an any alphanumeric
    //    characters, consider it bad.
    //

    ULONG Used =
        WideCharToMultiByte(CP_ACP, 0, ImagePath, ImagePathChars,
                            AnsiBuffer, AnsiBufferChars,
                            NULL, NULL);
    if (!Used)
    {
        goto Invalid;
    }
    if (Used < AnsiBufferChars)
    {
        AnsiBuffer[Used] = 0;
    }
    else
    {
        AnsiBuffer[AnsiBufferChars - 1] = 0;
    }

    if (IsValidName(AnsiBuffer))
    {
        return AnsiBuffer;
    }

    // Converted name doesn't look valid, fall into
    // replacement case.

 Invalid:
    return UnknownImageName(ImageBase, AnsiBuffer, AnsiBufferChars);
}

PSTR
PrepareImagePath(PSTR ImagePath)
{
    // dbghelp will sometimes scan the path given to
    // SymLoadModule for the image itself.  There
    // can be cases where the scan uses fuzzy matching,
    // so we want to be careful to only pass in a path
    // for dbghelp to use when the path can safely be
    // used.
    if ((IS_LIVE_USER_TARGET(g_Target) &&
         ((LiveUserTargetInfo*)g_Target)->m_Local) ||
        IS_LOCAL_KERNEL_TARGET(g_Target))
    {
        return ImagePath;
    }
    else
    {
        return (PSTR)PathTail(ImagePath);
    }
}

typedef struct _FIND_MODULE_DATA
{
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    BOOL Silent;
    PVOID FileMapping;
    HANDLE FileHandle;
} FIND_MODULE_DATA, *PFIND_MODULE_DATA;

PVOID
OpenMapping(
    IN PCSTR FilePath,
    OUT HANDLE* FileHandle
    )
{
    HANDLE File;
    HANDLE Mapping;
    PVOID View;
    ULONG OldMode;

    *FileHandle = NULL;

    if (g_SymOptions & SYMOPT_FAIL_CRITICAL_ERRORS)
    {
        OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    }

    File = CreateFile(
                FilePath,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if (g_SymOptions & SYMOPT_FAIL_CRITICAL_ERRORS)
    {
        SetErrorMode(OldMode);
    }

    if ( File == INVALID_HANDLE_VALUE )
    {
        return NULL;
    }

    Mapping = CreateFileMapping (
                        File,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );
    if ( !Mapping )
    {
        CloseHandle ( File );
        return FALSE;
    }

    View = MapViewOfFile (
                        Mapping,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );

    CloseHandle (Mapping);

    *FileHandle = File;
    return View;
}

PVOID
MapImageFile(
    PCSTR FilePath,
    ULONG SizeOfImage,
    ULONG CheckSum,
    ULONG TimeDateStamp,
    BOOL Silent,
    HANDLE* FileHandle
    )
{
    PVOID FileMapping;
    PIMAGE_NT_HEADERS NtHeader;

    FileMapping = OpenMapping(FilePath, FileHandle);
    if (!FileMapping)
    {
        return NULL;
    }
    NtHeader = ImageNtHeader(FileMapping);
    if ((NtHeader == NULL) ||
        (CheckSum && NtHeader->OptionalHeader.CheckSum &&
         (NtHeader->OptionalHeader.CheckSum != CheckSum)) ||
        (SizeOfImage != 0 &&
         NtHeader->OptionalHeader.SizeOfImage != SizeOfImage) ||
        (TimeDateStamp != 0 &&
         NtHeader->FileHeader.TimeDateStamp != TimeDateStamp))
    {
        //
        // The image data does not match the request.
        //

        if (!Silent && (g_SymOptions & SYMOPT_DEBUG))
        {
            CompletePartialLine(DEBUG_OUTPUT_SYMBOLS);
            MaskOut(DEBUG_OUTPUT_SYMBOLS,
                    (NtHeader) ? "DBGENG:  %s image header does not "
                    "match memory image header.\n" :
                    "DBGENG:  %s - image not mapped.\n",
                    FilePath);
        }

        UnmapViewOfFile(FileMapping);
        CloseHandle(*FileHandle);
        *FileHandle = NULL;
        return NULL;
    }

    return FileMapping;
}

BOOL CALLBACK
FindFileInPathCallback(PSTR FileName, PVOID CallerData)
{
    PFIND_MODULE_DATA FindModuleData = (PFIND_MODULE_DATA)CallerData;

    FindModuleData->FileMapping =
        MapImageFile(FileName, FindModuleData->SizeOfImage,
                     (g_SymOptions & SYMOPT_EXACT_SYMBOLS) ?
                     FindModuleData->CheckSum : 0,
                     FindModuleData->TimeDateStamp,
                     FindModuleData->Silent,
                     &FindModuleData->FileHandle);

    // The search stops when FALSE is returned, so
    // return FALSE when we've found a match.
    return FindModuleData->FileMapping == NULL;
}

BOOL
FindExecutableCallback(
    HANDLE File,
    PSTR FileName,
    PVOID CallerData
    )
{
    PFIND_MODULE_DATA FindModuleData;

    DBG_ASSERT ( CallerData );
    FindModuleData = (PFIND_MODULE_DATA) CallerData;

    FindModuleData->FileMapping =
        MapImageFile(FileName, FindModuleData->SizeOfImage,
                     (g_SymOptions & SYMOPT_EXACT_SYMBOLS) ?
                     FindModuleData->CheckSum : 0,
                     FindModuleData->TimeDateStamp,
                     FindModuleData->Silent,
                     &FindModuleData->FileHandle);

    return FindModuleData->FileMapping != NULL;
}

PVOID
FindImageFile(
    IN ProcessInfo* Process,
    IN PCSTR ImagePath,
    IN ULONG SizeOfImage,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp,
    OUT HANDLE* FileHandle,
    OUT PSTR MappedImagePath
    )

/*++

Routine Description:

    Find the executable image on the SymbolPath that matches ModuleName,
    CheckSum. This function takes care of things like renamed kernels and
    hals, and multiple images with the same name on the path.

Return Values:

    File mapping or NULL.

--*/

{
    ULONG i;
    HANDLE File;
    ULONG AliasCount = 0;
    PCSTR AliasList[MAX_ALIAS_COUNT + 3];
    FIND_MODULE_DATA FindModuleData;
    MODULE_ALIAS_LIST* ModAlias;
    PSTR SearchPaths[2];
    ULONG WhichPath;
    BOOL ModInAliasList;

    DBG_ASSERT ( ImagePath != NULL && ImagePath[0] != 0 );

    PCSTR ModuleName = PathTail(ImagePath);

    //
    // Build an alias list. For normal modules, modules that are not the
    // kernel, the hal or a dump driver, this list will contain exactly one
    // entry with the module name. For kernel, hal and dump drivers, the
    // list will contain any number of known aliases for the specific file.
    //

    ModAlias = FindModuleAliasList(ModuleName, &ModInAliasList);
    if (ModAlias)
    {
        // If the given module is in the alias list already
        // don't put in a duplicate.
        if (!ModInAliasList)
        {
            AliasList[AliasCount++] = ModuleName;
        }

        for (i = 0; i < ModAlias->Length; i++)
        {
            AliasList[AliasCount++] = ModAlias->Aliases[i];
        }
    }
    else
    {
        if (_strnicmp(ModuleName, "dump_scsiport", 11) == 0)
        {
            AliasList[0] = "diskdump.sys";
            AliasCount = 1;
        }
        else if (_strnicmp(ModuleName, "dump_", 5) == 0)
        {
            //
            // Setup dump driver alias list
            //

            AliasList[0] = &ModuleName[5];
            AliasList[1] = ModuleName;
            AliasCount = 2;
        }
        else
        {
            AliasList[0] = ModuleName;
            AliasCount = 1;
        }
    }

    //
    // Search on the image path first, then on the symbol path.
    //

    SearchPaths[0] = g_ExecutableImageSearchPath;
    SearchPaths[1] = g_SymbolSearchPath;

    for (WhichPath = 0; WhichPath < DIMA(SearchPaths); WhichPath++)
    {
        if (!SearchPaths[WhichPath] || !SearchPaths[WhichPath][0])
        {
            continue;
        }

        //
        // First try to find it in a symbol server or
        // directly on the search path.
        //

        for (i = 0; i < AliasCount; i++)
        {
            FindModuleData.SizeOfImage = SizeOfImage;
            FindModuleData.CheckSum = CheckSum;
            FindModuleData.TimeDateStamp = TimeDateStamp;
            FindModuleData.Silent = FALSE;
            FindModuleData.FileMapping = NULL;
            FindModuleData.FileHandle = NULL;

            if (SymFindFileInPath(Process->m_SymHandle,
                                  SearchPaths[WhichPath],
                                  (PSTR)AliasList[i],
                                  UlongToPtr(TimeDateStamp),
                                  SizeOfImage, 0, SSRVOPT_DWORD,
                                  MappedImagePath,
                                  FindFileInPathCallback, &FindModuleData))
            {
                if (FileHandle)
                {
                    *FileHandle = FindModuleData.FileHandle;
                }
                return FindModuleData.FileMapping;
            }
        }

        //
        // Initial search didn't work so do a full tree search.
        //

        for (i = 0; i < AliasCount; i++)
        {
            FindModuleData.SizeOfImage = SizeOfImage;
            FindModuleData.CheckSum = CheckSum;
            FindModuleData.TimeDateStamp = TimeDateStamp;
            // FindExecutableImageEx displays its own
            // debug output so don't display any in
            // the callback.
            FindModuleData.Silent = TRUE;
            FindModuleData.FileMapping = NULL;
            FindModuleData.FileHandle = NULL;

            File = FindExecutableImageEx((PSTR)AliasList[i],
                                         SearchPaths[WhichPath],
                                         MappedImagePath,
                                         FindExecutableCallback,
                                         &FindModuleData);
            if ( File != NULL && File != INVALID_HANDLE_VALUE )
            {
                CloseHandle (File);
            }

            if ( FindModuleData.FileMapping != NULL )
            {
                if (FileHandle)
                {
                    *FileHandle = FindModuleData.FileHandle;
                }
                return FindModuleData.FileMapping;
            }
        }
    }

    //
    // No path searches found the image so just try
    // the given path as a last-ditch check.
    //

    strcpy(MappedImagePath, ImagePath);
    FindModuleData.FileMapping =
        MapImageFile(ImagePath, SizeOfImage, CheckSum, TimeDateStamp,
                     FALSE, FileHandle);
    if (FindModuleData.FileMapping == NULL)
    {
        MappedImagePath[0] = 0;
        if (FileHandle)
        {
            *FileHandle = NULL;
        }

        if (g_SymOptions & SYMOPT_DEBUG)
        {
            CompletePartialLine(DEBUG_OUTPUT_SYMBOLS);
            MaskOut(DEBUG_OUTPUT_SYMBOLS,
                    "DBGENG:  %s - Couldn't map image from disk.\n",
                    ImagePath);
        }
    }
    return FindModuleData.FileMapping;
}

BOOL
DemandLoadReferencedImageMemory(ProcessInfo* Process,
                                ULONG64 Addr, ULONG Size)
{
    ImageInfo* Image;
    BOOL Hit = FALSE;

    //
    // If we are handling a mini dump, we may need to
    // map image memory to respond to a memory read.
    // If the given address falls within a module's range
    // map its image memory.
    //
    // Some versions of the linker produced images
    // where important debug records were outside of
    // the image range, so add a fudge factor to the
    // image size to include potential extra data.
    //

    if (Process)
    {
        for (Image = Process->m_ImageHead; Image; Image = Image->m_Next)
        {
            if (Addr + Size > Image->m_BaseOfImage &&
                Addr < Image->m_BaseOfImage + Image->m_SizeOfImage + 8192)
            {
                if (!Image->DemandLoadImageMemory(TRUE, FALSE))
                {
                    return FALSE;
                }

                Hit = TRUE;
            }
        }
    }

    return Hit;
}

ULONG
ReadImageData(ProcessInfo* Process,
              ULONG64 Address,
              HANDLE  File,
              LPVOID  Buffer,
              ULONG   Size)
{
    ULONG Result;

    if (File)
    {
        if (SetFilePointer(File, (ULONG)Address, NULL,
                           FILE_BEGIN) == INVALID_SET_FILE_POINTER)
        {
            return 0;
        }

        if (!ReadFile(File, Buffer, Size, &Result, NULL) ||
            Result < Size)
        {
            return 0;
        }
    }
    else
    {
        if (Process->m_Target->
            ReadVirtual(Process, Address, Buffer, Size, &Result) != S_OK ||
            Result < Size)
        {
            return 0;
        }
    }

    return Size;
}

BOOL
GetModnameFromImageInternal(ProcessInfo* Process,
                            ULONG64 BaseOfDll,
                            HANDLE File,
                            LPSTR Name,
                            ULONG NameSize,
                            BOOL SearchExportFirst)
{
    IMAGE_DEBUG_DIRECTORY DebugDir;
    PIMAGE_DEBUG_MISC Misc;
    PIMAGE_DEBUG_MISC MiscTmp;
    PIMAGE_SECTION_HEADER SecHdr = NULL;
    IMAGE_NT_HEADERS64 Hdrs64;
    PIMAGE_NT_HEADERS32 Hdrs32 = (PIMAGE_NT_HEADERS32)&Hdrs64;
    IMAGE_DOS_HEADER DosHdr;
    DWORD Rva;
    DWORD RvaExport = 0;
    int NumDebugDirs;
    int i;
    int j;
    int Len;
    BOOL Succ = FALSE;
    USHORT NumberOfSections;
    USHORT Characteristics;
    ULONG64 Address;
    DWORD Sig;
    DWORD Bytes;
    CHAR ExportName[MAX_IMAGE_PATH];
    CHAR DebugName[MAX_IMAGE_PATH];

    ExportName[0] = 0;
    DebugName[0] = 0;
    Name[0] = 0;

    if (File)
    {
        BaseOfDll = 0;
    }

    Address = BaseOfDll;

    if (!ReadImageData( Process, Address, File, &DosHdr, sizeof(DosHdr) ))
    {
        return FALSE;
    }

    if (DosHdr.e_magic == IMAGE_DOS_SIGNATURE)
    {
        Address += DosHdr.e_lfanew;
    }

    if (!ReadImageData( Process, Address, File, &Sig, sizeof(Sig) ))
    {
        return FALSE;
    }

    if (Sig != IMAGE_NT_SIGNATURE)
    {
        IMAGE_FILE_HEADER FileHdr;
        IMAGE_ROM_OPTIONAL_HEADER RomHdr;

        if (!ReadImageData( Process, Address, File,
                            &FileHdr, sizeof(FileHdr) ))
        {
            return FALSE;
        }
        Address += sizeof(FileHdr);
        if (!ReadImageData( Process, Address, File, &RomHdr, sizeof(RomHdr) ))
        {
            return FALSE;
        }
        Address += sizeof(RomHdr);

        if (RomHdr.Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC)
        {
            NumberOfSections = FileHdr.NumberOfSections;
            Characteristics = FileHdr.Characteristics;
            NumDebugDirs = Rva = 0;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        //
        // Read the head as a 64 bit header and cast it appropriately.
        //

        if (!ReadImageData( Process, Address, File, &Hdrs64, sizeof(Hdrs64) ))
        {
            return FALSE;
        }

        if (IsImageMachineType64(Hdrs32->FileHeader.Machine))
        {
            Address += sizeof(IMAGE_NT_HEADERS64);
            NumberOfSections = Hdrs64.FileHeader.NumberOfSections;
            Characteristics = Hdrs64.FileHeader.Characteristics;
            NumDebugDirs = Hdrs64.OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size /
                sizeof(IMAGE_DEBUG_DIRECTORY);
            Rva = Hdrs64.OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
            RvaExport = Hdrs64.OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        }
        else
        {
            Address += sizeof(IMAGE_NT_HEADERS32);
            NumberOfSections = Hdrs32->FileHeader.NumberOfSections;
            Characteristics = Hdrs32->FileHeader.Characteristics;
            NumDebugDirs = Hdrs32->OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size /
                sizeof(IMAGE_DEBUG_DIRECTORY);
            Rva = Hdrs32->OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
            RvaExport = Hdrs32->OptionalHeader.
                DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        }
    }

    Bytes = NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER;
    SecHdr = (PIMAGE_SECTION_HEADER)malloc( Bytes );
    if (!SecHdr)
    {
        return FALSE;
    }

    if (!ReadImageData( Process, Address, File, SecHdr, Bytes ))
    {
        goto Finish;
    }

    //
    // Let try looking at the export table to see if we can find the image
    // name.
    //

    if (RvaExport)
    {
        for (i = 0; i < NumberOfSections; i++)
        {
            if (RvaExport >= SecHdr[i].VirtualAddress &&
                RvaExport < SecHdr[i].VirtualAddress + SecHdr[i].SizeOfRawData)
            {
                break;
            }
        }

        if (i < NumberOfSections)
        {
            DWORD TmpRva = RvaExport;
            ULONG64 ExportNameRva = 0;
            CHAR  Char;

            if (File)
            {
                TmpRva = TmpRva -
                    SecHdr[i].VirtualAddress + SecHdr[i].PointerToRawData;
            }

            if (ReadImageData(Process,
                              TmpRva + FIELD_OFFSET(IMAGE_EXPORT_DIRECTORY,
                                                    Name) +
                              BaseOfDll, File, &ExportNameRva, sizeof(DWORD)))
            {
                if (File)
                {
                    ExportNameRva = ExportNameRva - SecHdr[i].VirtualAddress +
                        SecHdr[i].PointerToRawData;
                }

                ExportNameRva += BaseOfDll;

                Succ = TRUE;
                Len = 0;
                do
                {
                    if (!ReadImageData( Process, ExportNameRva,
                                        File, &Char, sizeof(Char)))
                    {
                        Succ = FALSE;
                        break;
                    }
                    ExportNameRva++;
                    ExportName[Len] = Char;
                    Len++;
                } while (Char && (Len < sizeof(ExportName)));
            }
        }
    }

    //
    // Now get the name from the debug directory eixsts, get that.
    //

    if (!Rva || !NumDebugDirs)
    {
        goto Finish;
    }

    for (i = 0; i < NumberOfSections; i++)
    {
        if (Rva >= SecHdr[i].VirtualAddress &&
            Rva < SecHdr[i].VirtualAddress + SecHdr[i].SizeOfRawData)
        {
            break;
        }
    }

    if (i >= NumberOfSections)
    {
        goto Finish;
    }

    Rva = Rva - SecHdr[i].VirtualAddress;
    if (File)
    {
        Rva += SecHdr[i].PointerToRawData;
    }
    else
    {
        Rva += SecHdr[i].VirtualAddress;
    }

    for (j = 0; j < NumDebugDirs; j++)
    {
        if (!ReadImageData(Process, Rva + (sizeof(DebugDir) * j) + BaseOfDll,
                           File, &DebugDir, sizeof(DebugDir)))
        {
            break;
        }

        if (DebugDir.Type == IMAGE_DEBUG_TYPE_MISC &&
            ((!File && DebugDir.AddressOfRawData) ||
             (File && DebugDir.PointerToRawData)))
        {
            Len = DebugDir.SizeOfData;
            Misc = MiscTmp = (PIMAGE_DEBUG_MISC)malloc(Len);
            if (!Misc)
            {
                break;
            }

            if (File)
            {
                Address = DebugDir.PointerToRawData;
            }
            else
            {
                Address = DebugDir.AddressOfRawData + BaseOfDll;
            }

            Len = ReadImageData( Process, Address, File, Misc, Len);

            while (Len >= sizeof(*Misc) &&
                   Misc->Length &&
                   (ULONG)Len >= Misc->Length)
            {
                if (Misc->DataType != IMAGE_DEBUG_MISC_EXENAME)
                {
                    Len -= Misc->Length;
                    Misc = (PIMAGE_DEBUG_MISC)
                            (((LPSTR)Misc) + Misc->Length);
                }
                else
                {
                    PVOID ExeName = (PVOID)&Misc->Data[ 0 ];

                    if (!Misc->Unicode)
                    {
                        CatString(DebugName, (LPSTR)ExeName, DIMA(DebugName));
                        Succ = TRUE;
                    }
                    else
                    {
                        Succ = WideCharToMultiByte(CP_ACP,
                                                   0,
                                                   (LPWSTR)ExeName,
                                                   -1,
                                                   DebugName,
                                                   sizeof(DebugName),
                                                   NULL,
                                                   NULL) != 0;
                    }

                    //
                    //  Undo stevewo's error
                    //

                    if (_stricmp(&DebugName[strlen(DebugName) - 4],
                                 ".DBG") == 0)
                    {
                        char Path[MAX_IMAGE_PATH];
                        char Base[_MAX_FNAME];

                        _splitpath(DebugName, NULL, Path, Base, NULL);
                        if (strlen(Path) == 4)
                        {
                            Path[strlen(Path) - 1] = 0;
                            CopyString(DebugName, Base, DIMA(DebugName));
                            CatString(DebugName, ".", DIMA(DebugName));
                            CatString(DebugName, Path, DIMA(DebugName));
                        }
                        else if (Characteristics & IMAGE_FILE_DLL)
                        {
                            CopyString(DebugName, Base, DIMA(DebugName));
                            CatString(DebugName, ".dll", DIMA(DebugName));
                        }
                        else
                        {
                            CopyString(DebugName, Base, DIMA(DebugName));
                            CatString(DebugName, ".exe", DIMA(DebugName));
                        }
                    }
                    break;
                }
            }

            free(MiscTmp);

            if (Succ)
            {
                break;
            }
        }
        else if ((DebugDir.Type == IMAGE_DEBUG_TYPE_CODEVIEW) &&
                 ((!File && DebugDir.AddressOfRawData) ||
                  (File && DebugDir.PointerToRawData)) &&
                 (DebugDir.SizeOfData > sizeof(NB10IH)))
        {
            DWORD   Signature;
            char    Path[MAX_IMAGE_PATH];
            char    Base[_MAX_FNAME];

            // Mapped CV info.  Read the data and see what the content is.

            if (File)
            {
                Address = DebugDir.PointerToRawData;
            }
            else
            {
                Address = DebugDir.AddressOfRawData + BaseOfDll;
            }

            if (!ReadImageData( Process, Address, File, &Signature,
                                sizeof(Signature) ))
            {
                break;
            }

            // NB10 or PDB7 signature?
            if (Signature == NB10_SIG ||
                Signature == RSDS_SIG)
            {
                ULONG HdrSize = Signature == NB10_SIG ?
                    sizeof(NB10IH) : sizeof(RSDSIH);

                Address += HdrSize;

                if ((DebugDir.SizeOfData - sizeof(HdrSize)) > MAX_PATH)
                {
                    // Something's wrong here.  The record should only contain
                    // a MAX_PATH path name.
                    break;
                }

                if (DebugDir.SizeOfData - HdrSize > NameSize)
                {
                    break;
                }
                if (!ReadImageData(Process, Address, File, DebugName,
                                   DebugDir.SizeOfData - HdrSize))
                {
                    break;
                }

                _splitpath(DebugName, NULL, Path, Base, NULL);

                // Files are sometimes generated with .pdb appended
                // to the image name rather than replacing the extension
                // of the image name, such as foo.exe.pdb.
                // splitpath only takes off the outermost extension,
                // so check and see if the base already has an extension
                // we recognize.
                PSTR Ext = strrchr(Base, '.');
                if (Ext != NULL &&
                    (!strcmp(Ext, ".exe") || !strcmp(Ext, ".dll") ||
                     !strcmp(Ext, ".sys")))
                {
                    // The base already has an extension so use
                    // it as-is.
                    CopyString(DebugName, Base, DIMA(DebugName));
                }
                else if (Characteristics & IMAGE_FILE_DLL)
                {
                    CopyString(DebugName, Base, DIMA(DebugName));
                    CatString(DebugName, ".dll", DIMA(DebugName));
                }
                else
                {
                    CopyString(DebugName, Base, DIMA(DebugName));
                    CatString(DebugName, ".exe", DIMA(DebugName));
                }

                Succ = TRUE;
            }
        }
    }

Finish:

    //
    // Now lets pick the name we want :
    //

    PCHAR RetName;

    if (SearchExportFirst)
    {
        RetName = ExportName[0] ? ExportName : DebugName;
    }
    else
    {
        RetName = DebugName[0] ? DebugName : ExportName;
    }

    CatString(Name, RetName, NameSize);

    free(SecHdr);
    return Succ;
}

BOOL
GetModnameFromImage(ProcessInfo* Process,
                    ULONG64   BaseOfDll,
                    HANDLE    File,
                    LPSTR     Name,
                    ULONG     NameSize,
                    BOOL      SearchExportFirst)
{
    BOOL Status = GetModnameFromImageInternal(Process, BaseOfDll, NULL, Name,
                                              NameSize, SearchExportFirst);
    if (!Status && File != NULL)
    {
        Status = GetModnameFromImageInternal(Process, BaseOfDll, File, Name,
                                             NameSize, SearchExportFirst);
    }
    return Status;
}

BOOL
GetHeaderInfo(IN  ProcessInfo* Process,
              IN  ULONG64 BaseOfDll,
              OUT LPDWORD CheckSum,
              OUT LPDWORD TimeDateStamp,
              OUT LPDWORD SizeOfImage)
{
    IMAGE_NT_HEADERS32 Hdrs32;
    IMAGE_DOS_HEADER DosHdr;
    ULONG64 Address;
    DWORD Sig;

    *CheckSum = UNKNOWN_CHECKSUM;
    *TimeDateStamp = UNKNOWN_TIMESTAMP;
    *SizeOfImage = 0;

    if (!Process)
    {
        return FALSE;
    }

    Address = BaseOfDll;

    if (!ReadImageData( Process, Address, NULL, &DosHdr, sizeof(DosHdr) ))
    {
        return FALSE;
    }

    if (DosHdr.e_magic == IMAGE_DOS_SIGNATURE)
    {
        Address += DosHdr.e_lfanew;
    }

    if (!ReadImageData( Process, Address, NULL, &Sig, sizeof(Sig) ))
    {
        return FALSE;
    }

    if (Sig != IMAGE_NT_SIGNATURE)
    {
        IMAGE_FILE_HEADER FileHdr;

        if (!ReadImageData( Process, Address, NULL,
                            &FileHdr, sizeof(FileHdr) ))
        {
            return FALSE;
        }

        *CheckSum      = 0;
        *TimeDateStamp = FileHdr.TimeDateStamp;
        *SizeOfImage   = 0;

        return TRUE;
    }

    // Attempt to read as a 32bit header, then reread if the image
    // type is 64bit.  This works because IMAGE_FILE_HEADER, which is
    // at the start of the IMAGE_NT_HEADERS, is the same on 32bit NT
    // and 64bit NT and IMAGE_NT_HEADER32 <= IMAGE_NT_HEADER64.
    if (!ReadImageData( Process, Address, NULL, &Hdrs32, sizeof(Hdrs32) ))
    {
        return FALSE;
    }

    if (IsImageMachineType64(Hdrs32.FileHeader.Machine))
    {
        // Image is 64bit.  Reread as a 64bit structure.
        IMAGE_NT_HEADERS64 Hdrs64;

        if (!ReadImageData( Process, Address, NULL, &Hdrs64, sizeof(Hdrs64) ))
        {
            return FALSE;
        }

        *CheckSum      = Hdrs64.OptionalHeader.CheckSum;
        *TimeDateStamp = Hdrs64.FileHeader.TimeDateStamp;
        *SizeOfImage   = Hdrs64.OptionalHeader.SizeOfImage;
    }
    else
    {
        *CheckSum      = Hdrs32.OptionalHeader.CheckSum;
        *TimeDateStamp = Hdrs32.FileHeader.TimeDateStamp;
        *SizeOfImage   = Hdrs32.OptionalHeader.SizeOfImage;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\makefile.inc ===
$O\dbgeng_p.hpp $O\dbgeng_p.cpp $O\dbgeng_s.hpp $O\dbgeng_s.cpp: \
            ..\published\dbgeng.w ..\dbg-common\rremgen.pl
        perl ..\dbg-common\rremgen.pl -g $O ..\published\dbgeng.w
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\memcmd.h ===
//----------------------------------------------------------------------------
//
// memcmd.h
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _MEMCMD_H_
#define _MEMCMD_H_

extern TypedData g_LastDump;
extern ADDR g_DumpDefault;

void ParseDumpCommand(void);
void ParseEnterCommand(void);

ULONG DumpAsciiMemory(PADDR, ULONG);
ULONG DumpUnicodeMemory (PADDR startaddr, ULONG count);
void DumpByteMemory(PADDR, ULONG);
void DumpWordMemory(PADDR, ULONG);
void DumpDwordMemory(PADDR startaddr, ULONG count, BOOL fDumpSymbols);
void DumpDwordAndCharMemory(PADDR, ULONG);
void DumpListMemory(PADDR, ULONG, ULONG, BOOL);
void DumpFloatMemory(PADDR Start, ULONG Count);
void DumpDoubleMemory(PADDR Start, ULONG Count);
void DumpQuadMemory(PADDR Start, ULONG Count, BOOL fDumpSymbols);
void DumpByteBinaryMemory(PADDR startaddr, ULONG count);
void DumpDwordBinaryMemory(PADDR startaddr, ULONG count);
void DumpSelector(ULONG Selector, ULONG Count);

void InteractiveEnterMemory(CHAR Type, PADDR Address, ULONG Size);

void CompareTargetMemory(PADDR, ULONG, PADDR);
void MoveTargetMemory(PADDR, ULONG, PADDR);

void ParseFillMemory(void);
void ParseSearchMemory(void);

void InputIo(ULONG64, UCHAR);
void OutputIo(ULONG64, ULONG, UCHAR);

#endif // #ifndef _MEMCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\mcache.hpp ===
//----------------------------------------------------------------------------
//
// Memory cache object.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef __MCACHE_HPP__
#define __MCACHE_HPP__

typedef struct _CACHE* PCACHE;

//----------------------------------------------------------------------------
//
// MemoryCache.
//
//----------------------------------------------------------------------------

class MemoryCache
{
public:
    MemoryCache(ULONG MaxSize);
    ~MemoryCache(void);

    HRESULT Read(IN ULONG64 BaseAddress,
                 IN PVOID UserBuffer,
                 IN ULONG TransferCount,
                 OUT PULONG BytesRead);
    HRESULT Write(IN ULONG64 BaseAddress,
                  IN PVOID UserBuffer,
                  IN ULONG TransferCount,
                  OUT PULONG BytesWritten);

    void Add(IN ULONG64 BaseAddress,
             IN PVOID UserBuffer,
             IN ULONG Length);
    void Remove(IN ULONG64 BaseAddress,
                IN ULONG Length);
    void Empty(void);

    void ParseCommands(void);
    
    //
    // Internal methods.
    //
    
    virtual HRESULT ReadUncached(IN ULONG64 BaseAddress,
                                 IN PVOID UserBuffer,
                                 IN ULONG TransferCount,
                                 OUT PULONG BytesRead) = 0;
    virtual HRESULT WriteUncached(IN ULONG64 BaseAddress,
                                  IN PVOID UserBuffer,
                                  IN ULONG TransferCount,
                                  OUT PULONG BytesWritten) = 0;

    PCACHE Lookup(ULONG64 Offset,
                  ULONG   Length,
                  PULONG  LengthUsed);

    void InsertNode(IN PCACHE node);

    PUCHAR Alloc(IN ULONG Length);
    VOID Free(IN PUCHAR Memory,
              IN ULONG  Length);
    
    VOID PurgeType(ULONG type);

    VOID SetForceDecodePtes(BOOL Enable, TargetInfo* Target);

    void Dump(void);
    void DumpNode(PCACHE Node);

    BOOL ChangeSuspend(BOOL Active)
    {
        if (Active)
        {
            if (m_Suspend > 0)
            {
                m_Suspend--;
                return TRUE;
            }
        }
        else if (m_Suspend < 0xffffffff)
        {
            m_Suspend++;
            return TRUE;
        }

        return FALSE;
    }
    
    TargetInfo* m_Target;
    
    ULONG m_MaxSize;
    ULONG m_UserSize;
    BOOL m_DecodePTEs;
    BOOL m_ForceDecodePTEs;
    ULONG m_Suspend;

    ULONG m_Reads, m_CachedReads, m_UncachedReads;
    ULONG64 m_CachedBytes, m_UncachedBytes;
    ULONG m_Misses;
    ULONG m_Size;
    ULONG m_NodeCount;
    BOOL m_PurgeOverride;
    PCACHE m_Root;
};

//----------------------------------------------------------------------------
//
// VirtualMemoryCache.
//
//----------------------------------------------------------------------------

class VirtualMemoryCache : public MemoryCache
{
public:
    VirtualMemoryCache(void)
        : MemoryCache(1000 * 1024)
    {
        m_Process = NULL;
    }

    void SetProcess(ProcessInfo* Process);
    
    virtual HRESULT ReadUncached(IN ULONG64 BaseAddress,
                                 IN PVOID UserBuffer,
                                 IN ULONG TransferCount,
                                 OUT PULONG BytesRead);
    virtual HRESULT WriteUncached(IN ULONG64 BaseAddress,
                                  IN PVOID UserBuffer,
                                  IN ULONG TransferCount,
                                  OUT PULONG BytesWritten);

    ProcessInfo* m_Process;
};

//----------------------------------------------------------------------------
//
// PhysicalMemoryCache.
//
//----------------------------------------------------------------------------

class PhysicalMemoryCache : public MemoryCache
{
public:
    PhysicalMemoryCache(void)
        : MemoryCache(1000 * 1024) {}
    
    void SetTarget(TargetInfo* Target);
    
    virtual HRESULT ReadUncached(IN ULONG64 BaseAddress,
                                 IN PVOID UserBuffer,
                                 IN ULONG TransferCount,
                                 OUT PULONG BytesRead);
    virtual HRESULT WriteUncached(IN ULONG64 BaseAddress,
                                  IN PVOID UserBuffer,
                                  IN ULONG TransferCount,
                                  OUT PULONG BytesWritten);
};

#endif // #ifndef __MCACHE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\mcache.cpp ===
//----------------------------------------------------------------------------
//
// Memory cache object.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#define DBG_CACHE 0
#if DBG_CACHE
#define DPCACHE(Args) g_NtDllCalls.DbgPrint Args
#else
#define DPCACHE(Args)
#endif

typedef struct _CACHE
{
    RTL_SPLAY_LINKS     SplayLinks;
    ULONG64             Offset;
    ULONG               Length;
    USHORT              Flags;
    union
    {
        PUCHAR      Data;
        HRESULT     Status;
    } u;
} CACHE, *PCACHE;

#define C_ERROR         0x0001      // Cache of error code
#define C_DONTEXTEND    0x0002      // Don't try to extend

#define LARGECACHENODE  1024        // Size of large cache node

//----------------------------------------------------------------------------
//
// MemoryCache.
//
//----------------------------------------------------------------------------

MemoryCache::MemoryCache(ULONG MaxSize)
{
    m_Target = NULL;
    m_MaxSize = MaxSize;
    m_UserSize = m_MaxSize;
    m_Reads = 0;
    m_CachedReads = 0;
    m_UncachedReads = 0;
    m_CachedBytes = 0;
    m_UncachedBytes = 0;
    m_Misses = 0;
    m_Size = 0;
    m_NodeCount = 0;
    m_PurgeOverride = FALSE;
    m_DecodePTEs = TRUE;
    m_ForceDecodePTEs = FALSE;
    m_Suspend = 0;
    m_Root = NULL;
}

MemoryCache::~MemoryCache(void)
{
    Empty();
}

HRESULT
MemoryCache::Read(IN ULONG64 BaseAddress,
                  IN PVOID UserBuffer,
                  IN ULONG TransferCount,
                  IN PULONG BytesRead)
/*++

    This function returns the specified data from the system being debugged
    using the current mapping of the processor.  If the data is not
    in the cache, it will then be read from the target system.

Arguments:

    BaseAddress - Supplies the base address of the memory to be
        copied into the UserBuffer.

    TransferCount - Amount of data to be copied to the UserBuffer.

    UserBuffer - Address to copy the requested data.

    BytesRead - Number of bytes which could actually be copied

--*/
{
    HRESULT     Status;
    PCACHE      Node, Node2;
    ULONG       NextLength;
    ULONG       i, SuccRead;
    PUCHAR      NodeData;

    *BytesRead = 0;

    if (TransferCount == 0)
    {
        return S_OK;
    }
    
    if (m_MaxSize == 0 || m_Suspend)
    {
        //
        // Cache is off
        //

        goto ReadDirect;
    }

    DPCACHE(("CACHE: Read req %s:%x\n",
             FormatAddr64(BaseAddress), TransferCount));
    
    m_Reads++;

    Node = Lookup(BaseAddress, TransferCount, &NextLength);
    Status = S_OK;

    for (;;)
    {
        BOOL Cached = FALSE;
        
        if (Node == NULL || Node->Offset > BaseAddress)
        {
            //
            // We are missing the leading data, read it into the cache
            //

            if (Node)
            {
                //
                // Only get (exactly) enough data to reach neighboring cache
                // node. If an overlapped read occurs between the two nodes,
                // the data will be concatenated then.
                //

                NextLength = (ULONG)(Node->Offset - BaseAddress);
            }

            NodeData = Alloc(NextLength);
            Node = (PCACHE)Alloc(sizeof(CACHE));

            if (NodeData == NULL || Node == NULL)
            {
                //
                // Out of memory - just read directly to UserBuffer
                //

                if (NodeData)
                {
                    Free(NodeData, NextLength);
                }
                if (Node)
                {
                    Free((PUCHAR)Node, sizeof (CACHE));
                }

                m_UncachedReads++;
                m_UncachedBytes += TransferCount;
                goto ReadDirect;
            }

            //
            // Read missing data into cache node
            //

            Node->Offset = BaseAddress;
            Node->u.Data = NodeData;
            Node->Flags  = 0;

            m_Misses++;
            m_UncachedReads++;

            Status = ReadUncached(BaseAddress, Node->u.Data,
                                  NextLength, &SuccRead);
            if (Status == HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT))
            {
                Free(NodeData, NextLength);
                Free((PUCHAR)Node, sizeof (CACHE));
                DPCACHE(("CACHE: Read failed, %x\n", Status));
                return Status;
            }
            else if (Status != S_OK)
            {
                //
                // There was an error, cache the error for the starting
                // byte of this range
                //

                Free(NodeData, NextLength);
                if (Status != HRESULT_FROM_NT(STATUS_UNSUCCESSFUL) &&
                    Status != HRESULT_FROM_WIN32(ERROR_PARTIAL_COPY))
                {
                    //
                    // For now be safe, don't cache this error
                    //

                    Free((PUCHAR)Node, sizeof (CACHE));
                    ErrOut("ReadMemoryError %08lx at %s\n",
                           Status, FormatAddr64(BaseAddress));
                    DPCACHE(("CACHE: Read partial %x, status %x\n",
                             *BytesRead, Status));
                    return *BytesRead > 0 ? S_OK : Status;
                }

                Node->Length = 1;
                Node->Flags |= C_ERROR;
                Node->u.Status = Status;

                DPCACHE(("CACHE:   Error %x node at %s\n",
                         Status, FormatAddr64(BaseAddress)));
            }
            else
            {
                m_UncachedBytes += SuccRead;
                Node->Length = SuccRead;
                if (SuccRead != NextLength)
                {
                    //
                    // Some data was not transfered, cache what was returned
                    //

                    Node->Flags |= C_DONTEXTEND;
                    m_Size -= (NextLength - SuccRead);
                }

                DPCACHE(("CACHE:   Added %s:%x, flags %x\n",
                         FormatAddr64(BaseAddress),
                         Node->Length, Node->Flags));
            }

            //
            // Insert cache node into splay tree
            //

            InsertNode(Node);
        }
        else
        {
            Cached = TRUE;
            m_CachedReads++;
        }

        if (Node->Flags & C_ERROR)
        {
            //
            // Hit an error range, we're done
            //

            DPCACHE(("CACHE: Read partial %x, error node %x\n",
                     *BytesRead, Node->u.Status));
            return *BytesRead > 0 ? S_OK : Node->u.Status;
        }

        //
        // Move available data to UserBuffer
        //

        i = (ULONG)(BaseAddress - Node->Offset);
        NodeData = Node->u.Data + i;
        i = (ULONG)Node->Length - i;
        if (TransferCount < i)
        {
            i = TransferCount;
        }
        memcpy(UserBuffer, NodeData, i);

        if (Cached)
        {
            m_CachedBytes += i;
        }
        
        TransferCount -= i;
        BaseAddress += i;
        UserBuffer = (PVOID)((PUCHAR)UserBuffer + i);
        *BytesRead += i;

        if (!TransferCount)
        {
            //
            // All of the user's data has been transfered
            //

            DPCACHE(("CACHE: Read success %x\n", *BytesRead));
            return S_OK;
        }

        //
        // Look for another cache node with more data
        //

        Node2 = Lookup(BaseAddress, TransferCount, &NextLength);
        if (Node2)
        {
            if ((Node2->Flags & C_ERROR) == 0  &&
                Node2->Offset == BaseAddress  &&
                Node2->Length + Node->Length < LARGECACHENODE)
            {
                //
                // Data is continued in node2, adjoin the neigboring
                // cached data in node & node2 together.
                //

                NodeData = Alloc(Node->Length + Node2->Length);
                if (NodeData != NULL)
                {
                    DPCACHE(("CACHE:   Merge %s:%x with %s:%x\n",
                             FormatAddr64(Node->Offset), Node->Length,
                             FormatAddr64(Node2->Offset), Node2->Length));
                    
                    memcpy(NodeData, Node->u.Data, Node->Length);
                    memcpy(NodeData + Node->Length, Node2->u.Data,
                           Node2->Length);
                    Free(Node->u.Data, Node->Length);
                    Node->u.Data  = NodeData;
                    Node->Length += Node2->Length;
                    m_Root = (PCACHE)pRtlDelete((PRTL_SPLAY_LINKS)Node2);
                    Free (Node2->u.Data, Node2->Length);
                    Free ((PUCHAR)Node2, sizeof (CACHE));
                    m_NodeCount--;
                    continue;
                }
            }

            //
            // Only get enough data to reach the neighboring cache Node2
            //

            NextLength = (ULONG)(Node2->Offset - BaseAddress);
            if (NextLength == 0)
            {
                //
                // Data is continued in Node2, go get it.
                //

                Node = Node2;
                continue;
            }
        }
        else
        {
            if (Node->Length > LARGECACHENODE)
            {
                //
                // Current cache node is already big enough. Don't extend
                // it, add another cache node.
                //

                Node = NULL;
                continue;
            }
        }

        //
        // Extend the current node to include missing data
        //

        if (Node->Flags & C_DONTEXTEND)
        {
            Node = NULL;
            continue;
        }

        NodeData = Alloc(Node->Length + NextLength);
        if (!NodeData)
        {
            Node = NULL;
            continue;
        }

        memcpy(NodeData, Node->u.Data, Node->Length);
        Free(Node->u.Data, Node->Length);
        Node->u.Data = NodeData;

        //
        // Add new data to end of this node
        //

        m_Misses++;
        m_UncachedReads++;

        Status = ReadUncached(BaseAddress, Node->u.Data + Node->Length,
                              NextLength, &SuccRead);
        if (Status == HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT))
        {
            m_Size -= NextLength;
            DPCACHE(("CACHE: Read add failed, %x\n", Status));
            return Status;
        }
        else if (Status != S_OK)
        {
            //
            // Return to error to the caller
            //

            Node->Flags |= C_DONTEXTEND;
            m_Size -= NextLength;
            ErrOut("ReadMemoryError %08lx at %s\n",
                   Status, FormatAddr64(BaseAddress));
            DPCACHE(("CACHE: Read add partial %x, status %x\n",
                     *BytesRead, Status));
            return *BytesRead > 0 ? S_OK : Status;
        }

        m_UncachedBytes += SuccRead;
        if (SuccRead != NextLength)
        {
            Node->Flags |= C_DONTEXTEND;
            m_Size -= (NextLength - SuccRead);
        }

        Node->Length += SuccRead;

        DPCACHE(("CACHE:   Extended %s:%x to %x, flags %x\n",
                 FormatAddr64(BaseAddress),
                 Node->Length - SuccRead, Node->Length, Node->Flags));
        
        // Loop, and move data to user's buffer
    }

ReadDirect:
    Status = ReadUncached(BaseAddress, UserBuffer, TransferCount, &SuccRead);
    *BytesRead += SuccRead;

    if (Status != HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT))
    {
        Status = *BytesRead > 0 ? S_OK : Status;
    }

    DPCACHE(("CACHE: Read uncached %x, status %x\n",
             *BytesRead, Status));
    
    return Status;
}

HRESULT
MemoryCache::Write(IN ULONG64 BaseAddress,
                   IN PVOID UserBuffer,
                   IN ULONG TransferCount,
                   OUT PULONG BytesWritten)
{
    // Remove data from cache before writing through to target system.
    Remove(BaseAddress, TransferCount);

    return WriteUncached(BaseAddress, UserBuffer,
                         TransferCount, BytesWritten);
}


PCACHE
MemoryCache::Lookup(ULONG64 Offset,
                    ULONG   Length,
                    PULONG  LengthUsed)
/*++

Routine Description:

    Walks the cache tree looking for a matching range closest to
    the supplied Offset.  The length of the range searched is based on
    the past length, but may be adjusted slightly.

    This function will always search for the starting byte.

Arguments:

    Offset  - Starting byte being looked for in cache

    Length  - Length of range being looked for in cache

    LengthUsed - Length of range which was really searched for

Return Value:

    NULL    - data for returned range was not found
    PCACHE  - leftmost cachenode which has data for returned range

--*/
{
    PCACHE  Node, Node2;
    ULONG64 SumOffsetLength;

    if (Length < 0x80 && m_Misses > 3)
    {
        // Try to cache more than a tiny amount.
        Length = 0x80;
    }

    SumOffsetLength = Offset + Length;
    if (SumOffsetLength < Length)
    {
        //
        // Offset + Length wrapped.  Adjust Length to be only
        // enough bytes before wrapping.
        //

        Length = (ULONG)(0 - Offset);
        SumOffsetLength = (ULONG64)-1;
    }

    DPCACHE(("CACHE:   Lookup(%s, %x) -> ",
             FormatAddr64(Offset), Length));
    
    //
    // Find leftmost cache node for BaseAddress through BaseAddress+Length
    //

    Node2 = NULL;
    Node  = m_Root;
    while (Node != NULL)
    {
        if (SumOffsetLength <= Node->Offset)
        {
            Node = (PCACHE)RtlLeftChild(&Node->SplayLinks);
        }
        else if (Node->Offset + Node->Length <= Offset)
        {
            Node = (PCACHE)RtlRightChild(&Node->SplayLinks);
        }
        else
        {
            if (Node->Offset <= Offset)
            {
                //
                // Found starting byte
                //

                *LengthUsed = Length;
                DPCACHE(("found %s:%x, flags %x, used %x\n",
                         FormatAddr64(Node->Offset),
                         Node->Length, Node->Flags, Length));
                return Node;
            }

            //
            // Check to see if there's a node which has a match closer
            // to the start of the requested range
            //

            Node2  = Node;
            Length = (ULONG)(Node->Offset - Offset);
            SumOffsetLength = Node->Offset;
            Node   = (PCACHE)RtlLeftChild(&Node->SplayLinks);
        }
    }

#if DBG_CACHE
    if (Node2)
    {
        DPCACHE(("found %s:%x, flags %x, used %x\n",
                 FormatAddr64(Node2->Offset), Node2->Length,
                 Node2->Flags, Length));
    }
    else
    {
        DPCACHE(("not found\n"));
    }
#endif

    *LengthUsed = Length;
    return Node2;
}

VOID
MemoryCache::InsertNode(IN PCACHE Node)
{
    PCACHE Node2;
    ULONG64 BaseAddress;

    //
    // Insert cache node into splay tree
    //

    RtlInitializeSplayLinks(&Node->SplayLinks);

    m_NodeCount++;
    if (m_Root == NULL)
    {
        m_Root = Node;
        return;
    }

    Node2 = m_Root;
    BaseAddress = Node->Offset;
    for (; ;)
    {
        if (BaseAddress < Node2->Offset)
        {
            if (RtlLeftChild(&Node2->SplayLinks))
            {
                Node2 = (PCACHE) RtlLeftChild(&Node2->SplayLinks);
                continue;
            }
            RtlInsertAsLeftChild(Node2, Node);
            break;
        }
        else
        {
            if (RtlRightChild(&Node2->SplayLinks))
            {
                Node2 = (PCACHE) RtlRightChild(&Node2->SplayLinks);
                continue;
            }
            RtlInsertAsRightChild(Node2, Node);
            break;
        }
    }
    
    m_Root = (PCACHE)pRtlSplay((PRTL_SPLAY_LINKS)Node2);
}

VOID
MemoryCache::Add(IN ULONG64 BaseAddress,
                 IN PVOID UserBuffer,
                 IN ULONG Length)
/*++

Routine Description:

    Insert some data into the cache.

Arguments:

    BaseAddress - Virtual address

    Length      - length to cache

    UserBuffer  - data to put into cache

Return Value:

--*/
{
    PCACHE  Node;
    PUCHAR  NodeData;

    if (m_MaxSize == 0)
    {
        //
        // Cache is off
        //

        return;
    }

    //
    // Delete any cached info which hits range
    //

    Remove (BaseAddress, Length);

    NodeData = Alloc (Length);
    Node = (PCACHE) Alloc (sizeof (CACHE));
    if (NodeData == NULL || Node == NULL)
    {
        //
        // Out of memory - don't bother
        //

        if (NodeData)
        {
            Free (NodeData, Length);
        }
        if (Node)
        {
            Free ((PUCHAR)Node, sizeof (CACHE));
        }

        return;
    }

    //
    // Put data into cache node
    //

    Node->Offset = BaseAddress;
    Node->Length = Length;
    Node->u.Data = NodeData;
    Node->Flags  = 0;
    memcpy(NodeData, UserBuffer, Length);
    InsertNode(Node);

    DPCACHE(("CACHE:   Add direct %s:%x\n",
             FormatAddr64(Node->Offset), Node->Length));
}

PUCHAR
MemoryCache::Alloc(IN ULONG Length)
/*++

Routine Description:

    Allocates memory for virtual cache, and tracks total memory
    usage.

Arguments:

    Length  - Amount of memory to allocate

Return Value:

    NULL    - too much memory is in use, or memory could not
              be allocated

    Otherwise, returns to address of the allocated memory

--*/
{
    PUCHAR Mem;

    if (m_Size + Length > m_MaxSize)
    {
        return NULL;
    }

    if (!(Mem = (PUCHAR)malloc (Length)))
    {
        //
        // Out of memory - don't get any larger
        //

        m_Size = m_MaxSize + 1;
        return NULL;
    }

    m_Size += Length;
    return Mem;
}


VOID
MemoryCache::Free(IN PUCHAR Memory,
                  IN ULONG  Length)
/*++
Routine Description:

    Free memory allocated with Alloc.  Adjusts cache is use totals.

Arguments:

    Memory  - Address of allocated memory

    Length  - Length of allocated memory

Return Value:

    NONE

--*/
{
    m_Size -= Length;
    free(Memory);
}


VOID
MemoryCache::Remove(IN ULONG64 BaseAddress,
                    IN ULONG TransferCount)
/*++

Routine Description:

    Invalidates range from the cache.

Arguments:

    BaseAddress - Starting address to purge
    TransferCount - Length of area to purge

Return Value:

    NONE

--*/
{
    PCACHE  Node;
    ULONG   Used;

    //
    // Invalidate any data in the cache which covers this range
    //

    while (Node = Lookup(BaseAddress, TransferCount, &Used))
    {
        //
        // For now just delete the entire cache node which hits the range
        //

        DPCACHE(("CACHE:   Remove %s:%x, flags %x\n",
                 FormatAddr64(Node->Offset), Node->Length, Node->Flags));
        
        m_Root = (PCACHE) pRtlDelete (&Node->SplayLinks);
        if (!(Node->Flags & C_ERROR))
        {
            Free (Node->u.Data, Node->Length);
        }
        Free ((PUCHAR)Node, sizeof (CACHE));
        m_NodeCount--;
    }
}

VOID
MemoryCache::Empty(void)
/*++

Routine Description:

    Purges to entire cache

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    PCACHE Node, Node2;

    m_Reads = 0;
    m_CachedReads = 0;
    m_UncachedReads = 0;
    m_CachedBytes = 0;
    m_UncachedBytes = 0;
    m_Misses = 0;
    if (!m_Root)
    {
        return;
    }

    if (m_PurgeOverride != 0)
    {
        WarnOut("WARNING: cache being held\n");
        return;
    }

    DPCACHE(("CACHE: Empty cache\n"));
    
    Node2 = m_Root;
    Node2->SplayLinks.Parent = NULL;

    while ((Node = Node2) != NULL)
    {
        if ((Node2 = (PCACHE) Node->SplayLinks.LeftChild) != NULL)
        {
            Node->SplayLinks.LeftChild = NULL;
            continue;
        }
        if ((Node2 = (PCACHE) Node->SplayLinks.RightChild) != NULL)
        {
            Node->SplayLinks.RightChild = NULL;
            continue;
        }

        Node2 = (PCACHE) Node->SplayLinks.Parent;
        if (!(Node->Flags & C_ERROR))
        {
            free (Node->u.Data);
        }
        free (Node);
    }

    m_Size = 0;
    m_NodeCount = 0;
    m_Root = NULL;
}

VOID
MemoryCache::PurgeType(ULONG Type)
/*++

Routine Description:

    Purges all nodes from the cache which match type in question

Arguments:

    Type    - type of entries to purge from the cache
                0 - entries of errored ranges
                1 - plus, node which cache user mode entries

Return Value:

    NONE

--*/
{
    PCACHE Node, Node2;

    if (!m_Root)
    {
        return;
    }

    DPCACHE(("CACHCE: Purge type %x\n", Type));
    
    //
    // this purges the selected cache entries by copy the all the
    // cache nodes except from the ones we don't want
    //

    Node2 = m_Root;
    Node2->SplayLinks.Parent = NULL;
    m_Root = NULL;

    while ((Node = Node2) != NULL)
    {
        if ((Node2 = (PCACHE)Node->SplayLinks.LeftChild) != NULL)
        {
            Node->SplayLinks.LeftChild = NULL;
            continue;
        }
        if ((Node2 = (PCACHE)Node->SplayLinks.RightChild) != NULL)
        {
            Node->SplayLinks.RightChild = NULL;
            continue;
        }

        Node2 = (PCACHE) Node->SplayLinks.Parent;

        m_NodeCount--;

        if (Node->Flags & C_ERROR)
        {
            // remove this one from the tree
            Free ((PUCHAR)Node, sizeof (CACHE));
            continue;
        }

        if ((Type == 1) && (Node->Offset < m_Target->m_SystemRangeStart))
        {
            // remove this one from the tree
            Free (Node->u.Data, Node->Length);
            Free ((PUCHAR)Node, sizeof (CACHE));
            continue;
        }

        // copy to the new tree
        InsertNode(Node);
    }
}

VOID
MemoryCache::SetForceDecodePtes(BOOL Enable, TargetInfo* Target)
{
    m_ForceDecodePTEs = Enable;
    if (Enable)
    {
        m_MaxSize = 0;
    }
    else
    {
        m_MaxSize = m_UserSize;
    }
    Empty();

    if (Target)
    {
        Target->m_PhysicalCache.ChangeSuspend(Enable);
        Target->m_PhysicalCache.Empty();
    }
}

void
MemoryCache::ParseCommands(void)
{
    ULONG64 Address;

    while (*g_CurCmd == ' ')
    {
        g_CurCmd++;
    }

    _strlwr(g_CurCmd);

    BOOL Parsed = TRUE;
        
    if (IS_KERNEL_TARGET(m_Target))
    {
        if (strcmp (g_CurCmd, "decodeptes") == 0)
        {
            PurgeType(0);
            m_DecodePTEs = TRUE;
        }
        else if (strcmp (g_CurCmd, "nodecodeptes") == 0)
        {
            m_DecodePTEs = FALSE;
        }
        else if (strcmp (g_CurCmd, "forcedecodeptes") == 0)
        {
            SetForceDecodePtes(TRUE, m_Target);
        }
        else if (strcmp (g_CurCmd, "noforcedecodeptes") == 0)
        {
            SetForceDecodePtes(FALSE, m_Target);
        }
        else
        {
            Parsed = FALSE;
        }
    }

    if (Parsed)
    {
        // Command already handled.
    }
    else if (strcmp (g_CurCmd, "hold") == 0)
    {
        m_PurgeOverride = TRUE;
    }
    else if (strcmp (g_CurCmd, "unhold") == 0)
    {
        m_PurgeOverride = FALSE;
    }
    else if (strcmp (g_CurCmd, "flushall") == 0)
    {
        Empty();
    }
    else if (strcmp (g_CurCmd, "flushu") == 0)
    {
        PurgeType(1);
    }
    else if (strcmp (g_CurCmd, "suspend") == 0)
    {
        ChangeSuspend(FALSE);
    }
    else if (strcmp (g_CurCmd, "nosuspend") == 0)
    {
        ChangeSuspend(TRUE);
    }
    else if (strcmp (g_CurCmd, "dump") == 0)
    {
        Dump();
        goto Done;
    }
    else if (*g_CurCmd == 'f')
    {
        while (*g_CurCmd >= 'a'  &&  *g_CurCmd <= 'z')
        {
            g_CurCmd++;
        }
        Address = GetExpression();
        Remove(Address, 4096);
        dprintf("Cached info for address %s for 4096 bytes was flushed\n",
                FormatAddr64(Address));
    }
    else if (*g_CurCmd)
    {
        if (*g_CurCmd < '0'  ||  *g_CurCmd > '9')
        {
            dprintf(".cache [{cachesize} | hold | unhold\n");
            dprintf(".cache [flushall | flushu | flush addr]\n");
            if (IS_KERNEL_TARGET(m_Target))
            {
                dprintf(".cache [decodeptes | nodecodeptes]\n");
                dprintf(".cache [forcedecodeptes | noforcedecodeptes]\n");
            }
            goto Done;
        }
        else
        {
            ULONG NewSize;
            
            NewSize = (ULONG)GetExpression() * 1024;
            if (0 > (LONG)NewSize)
            {
                dprintf("*** Cache size %ld (%#lx KB) is too large - "
                        "cache unchanged.\n", NewSize, KBYTES(NewSize));
            }
            else if (m_ForceDecodePTEs)
            {
                dprintf("Cache size update deferred until "
                        "noforcedecodeptes\n");
                m_UserSize = NewSize;
            }
            else
            {
                m_UserSize = NewSize;
                m_MaxSize = m_UserSize;
                if (m_MaxSize == 0)
                {
                    Empty();
                }
            }
        }
    }

    dprintf("\n");
    dprintf("Max cache size is       : %ld bytes (%#lx KB) %s\n",
            m_MaxSize, KBYTES(m_MaxSize),
            m_MaxSize ? "" : "(cache is off)");
    dprintf("Total memory in cache   : %ld bytes (%#lx KB) \n",
            m_Size - m_NodeCount * sizeof(CACHE),
            KBYTES(m_Size - m_NodeCount * sizeof(CACHE)));
    dprintf("Number of regions cached: %ld\n", m_NodeCount);

    ULONG TotalPartial;
    ULONG64 TotalBytes;
    double PerCached;

    TotalPartial = m_CachedReads + m_UncachedReads;
    TotalBytes = m_CachedBytes + m_UncachedBytes;
    dprintf("%d full reads broken into %d partial reads\n",
            m_Reads, TotalPartial);
    PerCached = TotalPartial ?
        (double)m_CachedReads * 100.0 / TotalPartial : 0.0;
    dprintf("    counts: %d cached/%d uncached, %.2lf%% cached\n",
            m_CachedReads, m_UncachedReads, PerCached);
    PerCached = TotalBytes ?
        (double)m_CachedBytes * 100.0 / TotalBytes : 0.0;
    dprintf("    bytes : %I64d cached/%I64d uncached, %.2lf%% cached\n",
            m_CachedBytes, m_UncachedBytes, PerCached);

    if (m_DecodePTEs)
    {
        dprintf ("** Transition PTEs are implicitly decoded\n");
    }

    if (m_ForceDecodePTEs)
    {
        dprintf("** Virtual addresses are translated to "
                "physical addresses before access\n");
    }
    
    if (m_PurgeOverride)
    {
        dprintf("** Implicit cache flushing disabled **\n");
    }

    if (m_Suspend)
    {
        dprintf("** Cache access is suspended\n");
    }
    
Done:
    while (*g_CurCmd && *g_CurCmd != ';')
    {
        g_CurCmd++;
    }
}

void
MemoryCache::Dump(void)
{
    dprintf("Current size %x, max size %x\n",
            m_Size, m_MaxSize);
    dprintf("%d nodes:\n", m_NodeCount);
    DumpNode(m_Root);
}

void
MemoryCache::DumpNode(PCACHE Node)
{
    if (Node->SplayLinks.LeftChild)
    {
        DumpNode((PCACHE)Node->SplayLinks.LeftChild);
    }
    
    dprintf("  offset %s, length %3x, flags %x, status %08x\n",
            FormatAddr64(Node->Offset), Node->Length,
            Node->Flags, (Node->Flags & C_ERROR) ? Node->u.Status : S_OK);
    
    if (Node->SplayLinks.RightChild)
    {
        DumpNode((PCACHE)Node->SplayLinks.RightChild);
    }
}

//----------------------------------------------------------------------------
//
// VirtualMemoryCache.
//
//----------------------------------------------------------------------------

void
VirtualMemoryCache::SetProcess(ProcessInfo* Process)
{
    m_Process = Process;
    m_Target = m_Process->m_Target;
}

HRESULT
VirtualMemoryCache::ReadUncached(IN ULONG64 BaseAddress,
                                 IN PVOID UserBuffer,
                                 IN ULONG TransferCount,
                                 OUT PULONG BytesRead)
{
    return m_Target->ReadVirtualUncached(m_Process, BaseAddress, UserBuffer,
                                         TransferCount, BytesRead);
}

HRESULT
VirtualMemoryCache::WriteUncached(IN ULONG64 BaseAddress,
                                  IN PVOID UserBuffer,
                                  IN ULONG TransferCount,
                                  OUT PULONG BytesWritten)
{
    return m_Target->WriteVirtualUncached(m_Process, BaseAddress, UserBuffer,
                                          TransferCount, BytesWritten);
}
    
//----------------------------------------------------------------------------
//
// PhysicalMemoryCache.
//
//----------------------------------------------------------------------------

void
PhysicalMemoryCache::SetTarget(TargetInfo* Target)
{
    m_Target = Target;
}

HRESULT
PhysicalMemoryCache::ReadUncached(IN ULONG64 BaseAddress,
                                  IN PVOID UserBuffer,
                                  IN ULONG TransferCount,
                                  OUT PULONG BytesRead)
{
    return m_Target->ReadPhysicalUncached(BaseAddress, UserBuffer,
                                          TransferCount, PHYS_FLAG_DEFAULT,
                                          BytesRead);
}

HRESULT
PhysicalMemoryCache::WriteUncached(IN ULONG64 BaseAddress,
                                   IN PVOID UserBuffer,
                                   IN ULONG TransferCount,
                                   OUT PULONG BytesWritten)
{
    return m_Target->WritePhysicalUncached(BaseAddress, UserBuffer,
                                           TransferCount, PHYS_FLAG_DEFAULT,
                                           BytesWritten);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\memcmd.cpp ===
//----------------------------------------------------------------------------
//
// Functions dealing with memory access, such as reading, writing,
// dumping and entering.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

TypedData g_LastDump;

ADDR g_DumpDefault;  //  default dump address

#define MAX_VFN_TABLE_OFFSETS 16

ULONG g_ObjVfnTableOffset[MAX_VFN_TABLE_OFFSETS];
ULONG64 g_ObjVfnTableAddr[MAX_VFN_TABLE_OFFSETS];
ULONG g_NumObjVfnTableOffsets;

BOOL CALLBACK
LocalSymbolEnumerator(PSYMBOL_INFO SymInfo,
                      ULONG        Size,
                      PVOID        Context)
{
    ULONG64 Value = g_Machine->CvRegToMachine((CV_HREG_e)SymInfo->Register);
    ULONG64 Address = SymInfo->Address;

    TranslateAddress(SymInfo->ModBase,
                     SymInfo->Flags, (ULONG)Value, &Address, &Value);
    
    VerbOut("%s ", FormatAddr64(Address));
    dprintf("%15s = ", SymInfo->Name);
    if (SymInfo->Flags & SYMFLAG_REGISTER)
    {
        dprintf("%I64x\n", Value);
    }
    else
    {
        if (!DumpSingleValue(SymInfo))
        {
            dprintf("??");
        }
        dprintf("\n");
    }

    if (CheckUserInterrupt())
    {
        return FALSE;
    }

    return TRUE;
}

void
ParseDumpCommand(void)
{
    CHAR    Ch;
    ULONG64 Count;
    ULONG   Size;
    ULONG   Offset;
    BOOL    DumpSymbols;

    static CHAR s_DumpPrimary = 'b';
    static CHAR s_DumpSecondary = ' ';

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }
    
    Ch = (CHAR)tolower(*g_CurCmd);
    if (Ch == 'a' || Ch == 'b' || Ch == 'c' || Ch == 'd' ||
        Ch == 'f' || Ch == 'g' || Ch == 'l' || Ch == 'u' ||
        Ch == 'w' || Ch == 's' || Ch == 'q' || Ch == 't' ||
        Ch == 'v' || Ch == 'y' || Ch == 'p')
    {
        if (Ch == 'd' || Ch == 's')
        {
            s_DumpPrimary = *g_CurCmd;
        }
        else if (Ch == 'p')
        {
            // 'p' maps to the effective pointer size dump.
            s_DumpPrimary = g_Machine->m_Ptr64 ? 'q' : 'd';
        }
        else
        {
            s_DumpPrimary = Ch;
        }

        g_CurCmd++;

        s_DumpSecondary = ' ';
        if (s_DumpPrimary == 'd' || s_DumpPrimary == 'q')
        {
            if (*g_CurCmd == 's')
            {
                s_DumpSecondary = *g_CurCmd++;
            }
        }
        else if (s_DumpPrimary == 'l')
        {
            if (*g_CurCmd == 'b')
            {
                s_DumpSecondary = *g_CurCmd++;
            }
        }
        else if (s_DumpPrimary == 'y')
        {
            if (*g_CurCmd == 'b' || *g_CurCmd == 'd')
            {
                s_DumpSecondary = *g_CurCmd++;
            }
        }
    }

    switch(s_DumpPrimary)
    {
    case 'a':
        Count = 384;
        GetRange(&g_DumpDefault, &Count, 1, SEGREG_DATA,
                 DEFAULT_RANGE_LIMIT);
        DumpAsciiMemory(&g_DumpDefault, (ULONG)Count);
        break;

    case 'b':
        Count = 128;
        GetRange(&g_DumpDefault, &Count, 1, SEGREG_DATA,
                 DEFAULT_RANGE_LIMIT);
        DumpByteMemory(&g_DumpDefault, (ULONG)Count);
        break;

    case 'c':
        Count = 32;
        GetRange(&g_DumpDefault, &Count, 4, SEGREG_DATA,
                 DEFAULT_RANGE_LIMIT);
        DumpDwordAndCharMemory(&g_DumpDefault, (ULONG)Count);
        break;

    case 'd':
        Count = 32;
        DumpSymbols = s_DumpSecondary == 's';
        GetRange(&g_DumpDefault, &Count, 4, SEGREG_DATA,
                 DEFAULT_RANGE_LIMIT);
        DumpDwordMemory(&g_DumpDefault, (ULONG)Count, DumpSymbols);
        break;

    case 'D':
        Count = 15;
        GetRange(&g_DumpDefault, &Count, 8, SEGREG_DATA,
                 DEFAULT_RANGE_LIMIT);
        DumpDoubleMemory(&g_DumpDefault, (ULONG)Count);
        break;

    case 'f':
        Count = 16;
        GetRange(&g_DumpDefault, &Count, 4, SEGREG_DATA,
                 DEFAULT_RANGE_LIMIT);
        DumpFloatMemory(&g_DumpDefault, (ULONG)Count);
        break;

    case 'g':
        Offset = (ULONG)GetExpression();
        Count = 8;
        if (*g_CurCmd && *g_CurCmd != ';')
        {
            Count = (ULONG)GetExpression() - Offset;
            // It's unlikely that people want to dump hundreds
            // of selectors.  People often mistake the second
            // number for a count and if it's less than the
            // first they'll end up with a negative count.
            if (Count > 0x800)
            {
                error(BADRANGE);
            }
        }
        DumpSelector(Offset, (ULONG)Count);
        break;

    case 'l':
        BOOL followBlink;

        Count = 32;
        Size = 4;
        followBlink = s_DumpSecondary == 'b';

        if ((Ch = PeekChar()) != '\0' && Ch != ';')
        {
            GetAddrExpression(SEGREG_DATA, &g_DumpDefault);
            if ((Ch = PeekChar()) != '\0' && Ch != ';')
            {
                Count = GetExpression();
                if ((Ch = PeekChar()) != '\0' && Ch != ';')
                {
                    Size = (ULONG)GetExpression();
                }
            }
        }
        DumpListMemory(&g_DumpDefault, (ULONG)Count, Size, followBlink);
        break;

    case 'q':
        Count = 16;
        DumpSymbols = s_DumpSecondary == 's';
        GetRange(&g_DumpDefault, &Count, 8, SEGREG_DATA,
                 DEFAULT_RANGE_LIMIT);
        DumpQuadMemory(&g_DumpDefault, (ULONG)Count, DumpSymbols);
        break;

    case 's':
    case 'S':
        UNICODE_STRING64 UnicodeString;
        ADDR BufferAddr;

        Count = 1;
        GetRange(&g_DumpDefault, &Count, 2, SEGREG_DATA,
                 DEFAULT_RANGE_LIMIT);
        while (Count--)
        {
            if (g_Target->ReadUnicodeString(g_Process,
                                            g_Machine, Flat(g_DumpDefault),
                                            &UnicodeString) == S_OK)
            {
                ADDRFLAT(&BufferAddr, UnicodeString.Buffer);
                if (s_DumpPrimary == 'S')
                {
                    DumpUnicodeMemory( &BufferAddr,
                                         UnicodeString.Length / sizeof(WCHAR));
                }
                else
                {
                    DumpAsciiMemory( &BufferAddr, UnicodeString.Length );
                }
            }
        }
        break;

    case 't': 
    case 'T':
       SymbolTypeDumpEx(g_Process->m_SymHandle,
                        g_Process->m_ImageHead,
                        g_CurCmd);
       break;

    case 'u':
        Count = 384;
        GetRange(&g_DumpDefault, &Count, 2, SEGREG_DATA,
                 DEFAULT_RANGE_LIMIT);
        DumpUnicodeMemory(&g_DumpDefault, (ULONG)Count);
        break;

    case 'v':
        RequireCurrentScope();
        EnumerateLocals(LocalSymbolEnumerator, NULL);
        break;

    case 'w':
        Count = 64;
        GetRange(&g_DumpDefault, &Count, 2, SEGREG_DATA,
                 DEFAULT_RANGE_LIMIT);
        DumpWordMemory(&g_DumpDefault, (ULONG)Count);
        break;

    case 'y':
        switch(s_DumpSecondary)
        {
        case 'b':
            Count = 32;
            GetRange(&g_DumpDefault, &Count, 1, SEGREG_DATA,
                     DEFAULT_RANGE_LIMIT);
            DumpByteBinaryMemory(&g_DumpDefault, (ULONG)Count);
            break;

        case 'd':
            Count = 8;
            GetRange(&g_DumpDefault, &Count, 4, SEGREG_DATA,
                     DEFAULT_RANGE_LIMIT);
            DumpDwordBinaryMemory(&g_DumpDefault, (ULONG)Count);
            break;

        default:
            error(SYNTAX);
        }
        break;

    default:
        error(SYNTAX);
        break;
    }
}

//----------------------------------------------------------------------------
//
// DumpValues
//
// Generic columnar value dumper.  Returns the number of values
// printed.
//
//----------------------------------------------------------------------------

class DumpValues
{
public:
    DumpValues(ULONG Size, ULONG Columns);

    ULONG Dump(PADDR Start, ULONG Count);

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val) = 0;
    virtual BOOL PrintValue(void) = 0;
    virtual void PrintUnknown(void) = 0;

    // Optional worker methods.  Base implementations do nothing.
    virtual void EndRow(void);
    
    // Fixed members controlling how this instance dumps values.
    ULONG m_Size;
    ULONG m_Columns;

    // Work members during dumping.
    UCHAR* m_Value;
    ULONG m_Col;
    PADDR m_Start;

    // Optional per-row values.  Out is automatically reset to
    // Base at the beginning of every row.
    UCHAR* m_Base;
    UCHAR* m_Out;
};

DumpValues::DumpValues(ULONG Size, ULONG Columns)
{
    m_Size = Size;
    m_Columns = Columns;
}

ULONG
DumpValues::Dump(PADDR Start, ULONG Count)
{
    ULONG   Read;
    UCHAR   ReadBuffer[512];
    ULONG   Idx;
    ULONG   Block;
    BOOL    First = TRUE;
    ULONG64 Offset;
    ULONG   Printed;
    BOOL    RowStarted;
    ULONG   PageVal;
    ULONG64 NextOffs, NextPage;

    Offset = Flat(*Start);
    Printed = 0;
    RowStarted = FALSE;
    m_Start = Start;
    m_Col = 0;
    m_Out = m_Base;

    while (Count > 0)
    {
        Block = sizeof(ReadBuffer) / m_Size;
        Block = min(Count, Block);
        g_Target->NearestDifferentlyValidOffsets(Offset, &NextOffs, &NextPage);
        PageVal = (ULONG)(NextPage - Offset + m_Size - 1) / m_Size;
        Block = min(Block, PageVal);

        if (fnotFlat(*Start) ||
            g_Target->ReadVirtual(g_Process, Flat(*Start),
                                  ReadBuffer, Block * m_Size, &Read) != S_OK)
        {
            Read = 0;
        }
        Read /= m_Size;
        if (Read < Block && NextOffs < NextPage)
        {
            // In dump files data validity can change from
            // one byte to the next so we cannot assume that
            // stepping by pages will always be correct.  Instead,
            // if we didn't have a successful read we step just
            // past the end of the valid data or to the next
            // valid offset, whichever is farther.
            if (Offset + (Read + 1) * m_Size < NextOffs)
            {
                Block = (ULONG)(NextOffs - Offset + m_Size - 1) / m_Size;
            }
            else
            {
                Block = Read + 1;
            }
        }
        m_Value = ReadBuffer;
        Idx = 0;

        if (First && Read >= 1)
        {
            First = FALSE;
            GetValue(&g_LastDump);
            g_LastDump.SetDataSource(TDATA_MEMORY, Flat(*Start), 0);
        }

        while (Idx < Block)
        {
            while (m_Col < m_Columns && Idx < Block)
            {
                if (m_Col == 0)
                {
                    dprintAddr(Start);
                    RowStarted = TRUE;
                }

                if (Idx < Read)
                {
                    if (!PrintValue())
                    {
                        // Increment address since this value was
                        // examined, but do not increment print count
                        // or column since no output was produced.
                        AddrAdd(Start, m_Size);
                        goto Exit;
                    }

                    m_Value += m_Size;
                }
                else
                {
                    PrintUnknown();
                }

                Idx++;
                Printed++;
                m_Col++;
                AddrAdd(Start, m_Size);
            }

            if (m_Col == m_Columns)
            {
                EndRow();
                m_Out = m_Base;
                dprintf("\n");
                RowStarted = FALSE;
                m_Col = 0;
            }

            if (CheckUserInterrupt())
            {
                return Printed;
            }
        }

        Count -= Block;
        Offset += Block * m_Size;
    }

 Exit:
    if (RowStarted)
    {
        EndRow();
        m_Out = m_Base;
        dprintf("\n");
    }

    return Printed;
}

void
DumpValues::EndRow(void)
{
    // Empty base implementation.
}

/*** DumpAsciiMemory - output ascii strings from memory
*
*   Purpose:
*       Function of "da<range>" command.
*
*       Outputs the memory in the specified range as ascii
*       strings up to 32 characters per line.  The default
*       display is 12 lines for 384 characters total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of characters to display as ascii
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "?",
*       but no errors are returned.
*
*************************************************************************/

class DumpAscii : public DumpValues
{
public:
    DumpAscii(void)
        : DumpValues(sizeof(UCHAR), (sizeof(m_Buf) / sizeof(m_Buf[0]) - 1))
    {
        m_Base = m_Buf;
    }

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    UCHAR m_Buf[33];
};

void
DumpAscii::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_CHAR);
    Val->m_S8 = *m_Value;
}

BOOL
DumpAscii::PrintValue(void)
{
    UCHAR ch;

    ch = *m_Value;
    if (ch == 0)
    {
        return FALSE;
    }

    if (ch < 0x20 || ch > 0x7e)
    {
        ch = '.';
    }
    *m_Out++ = ch;

    return TRUE;
}

void
DumpAscii::PrintUnknown(void)
{
    *m_Out++ = '?';
}

void
DumpAscii::EndRow(void)
{
    *m_Out++ = 0;
    dprintf(" \"%s\"", m_Base);
}

ULONG
DumpAsciiMemory(PADDR Start, ULONG Count)
{
    DumpAscii Dumper;

    return Count - Dumper.Dump(Start, Count);
}

/*** DumpUnicodeMemory - output unicode strings from memory
*
*   Purpose:
*       Function of "du<range>" command.
*
*       Outputs the memory in the specified range as unicode
*       strings up to 32 characters per line.  The default
*       display is 12 lines for 384 characters total (768 bytes)
*
*   Input:
*       Start - starting address to begin display
*       Count - number of characters to display as ascii
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "?",
*       but no errors are returned.
*
*************************************************************************/

class DumpUnicode : public DumpValues
{
public:
    DumpUnicode(void)
        : DumpValues(sizeof(WCHAR), (sizeof(m_Buf) / sizeof(m_Buf[0]) - 1))
    {
        m_Base = (PUCHAR)m_Buf;
    }

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    WCHAR m_Buf[33];
};

void
DumpUnicode::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_WCHAR_T);
    Val->m_U16 = *(WCHAR *)m_Value;
}

BOOL
DumpUnicode::PrintValue(void)
{
    WCHAR ch;

    ch = *(WCHAR *)m_Value;
    if (ch == UNICODE_NULL)
    {
        return FALSE;
    }

    if (!iswprint(ch))
    {
        ch = L'.';
    }
    *(WCHAR *)m_Out = ch;
    m_Out += sizeof(WCHAR);

    return TRUE;
}

void
DumpUnicode::PrintUnknown(void)
{
    *(WCHAR *)m_Out = L'?';
    m_Out += sizeof(WCHAR);
}

void
DumpUnicode::EndRow(void)
{
    *(WCHAR *)m_Out = UNICODE_NULL;
    m_Out += sizeof(WCHAR);
    dprintf(" \"%ws\"", m_Base);
}

ULONG
DumpUnicodeMemory(PADDR Start, ULONG Count)
{
    DumpUnicode Dumper;

    return Count - Dumper.Dump(Start, Count);
}

/*** DumpByteMemory - output byte values from memory
*
*   Purpose:
*       Function of "db<range>" command.
*
*       Output the memory in the specified range as hex
*       byte values and ascii characters up to 16 bytes
*       per line.  The default display is 16 lines for
*       256 byte total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of bytes to display as hex and characters
*
*   Output:
*       None.
*
*   Notes:
*       memory location not accessible are output as "??" for
*       byte values and "?" as characters, but no errors are returned.
*
*************************************************************************/

class DumpByte : public DumpValues
{
public:
    DumpByte(void)
        : DumpValues(sizeof(UCHAR), (sizeof(m_Buf) / sizeof(m_Buf[0]) - 1))
    {
        m_Base = m_Buf;
    }

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    UCHAR m_Buf[17];
};

void
DumpByte::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_UINT8);
    Val->m_U8 = *m_Value;
}

BOOL
DumpByte::PrintValue(void)
{
    UCHAR ch;

    ch = *m_Value;

    if (m_Col == 8)
    {
        dprintf("-");
    }
    else
    {
        dprintf(" ");
    }
    dprintf("%02x", ch);

    if (ch < 0x20 || ch > 0x7e)
    {
        ch = '.';
    }
    *m_Out++ = ch;

    return TRUE;
}

void
DumpByte::PrintUnknown(void)
{
    if (m_Col == 8)
    {
        dprintf("-??");
    }
    else
    {
        dprintf(" ??");
    }
    *m_Out++ = '?';
}

void
DumpByte::EndRow(void)
{
    *m_Out++ = 0;

    while (m_Col < m_Columns)
    {
        dprintf("   ");
        m_Col++;
    }

    if ((m_Start->type & ADDR_1632) == ADDR_1632)
    {
        dprintf(" %s", m_Base);
    }
    else
    {
        dprintf("  %s", m_Base);
    }
}

void
DumpByteMemory(PADDR Start, ULONG Count)
{
    DumpByte Dumper;

    Dumper.Dump(Start, Count);
}

/*** DumpWordMemory - output word values from memory
*
*   Purpose:
*       Function of "dw<range>" command.
*
*       Output the memory in the specified range as word
*       values up to 8 words per line.  The default display
*       is 16 lines for 128 words total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of words to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????",
*       but no errors are returned.
*
*************************************************************************/

class DumpWord : public DumpValues
{
public:
    DumpWord(void)
        : DumpValues(sizeof(WORD), 8) {}

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
};

void
DumpWord::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_UINT16);
    Val->m_U16 = *(WORD *)m_Value;
}

BOOL
DumpWord::PrintValue(void)
{
    dprintf(" %04x", *(WORD *)m_Value);
    return TRUE;
}

void
DumpWord::PrintUnknown(void)
{
    dprintf(" ????");
}

void
DumpWordMemory(PADDR Start, ULONG Count)
{
    DumpWord Dumper;
    
    Dumper.Dump(Start, Count);
}

/*** DumpDwordMemory - output dword value from memory
*
*   Purpose:
*       Function of "dd<range>" command.
*
*       Output the memory in the specified range as double
*       word values up to 4 double words per line.  The default
*       display is 16 lines for 64 double words total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of double words to be displayed
*       ShowSymbols - Dump symbol for DWORD.
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

class DumpDword : public DumpValues
{
public:
    DumpDword(BOOL DumpSymbols)
        : DumpValues(sizeof(DWORD), DumpSymbols ? 1 : 4)
    {
        m_DumpSymbols = DumpSymbols;
    }

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);

    BOOL m_DumpSymbols;
};

void
DumpDword::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_UINT32);
    Val->m_U32 = *(DWORD *)m_Value;
}

BOOL
DumpDword::PrintValue(void)
{
    CHAR   SymBuf[MAX_SYMBOL_LEN];
    ULONG64  Displacement;

    dprintf(" %08lx", *(DWORD *)m_Value);

    if (m_DumpSymbols)
    {
        GetSymbol(EXTEND64(*(LONG *)m_Value),
                  SymBuf, sizeof(SymBuf), &Displacement);
        if (*SymBuf)
        {
            dprintf(" %s", SymBuf);
            if (Displacement)
            {
                dprintf("+0x%s", FormatDisp64(Displacement));
            }

            if (g_SymOptions & SYMOPT_LOAD_LINES)
            {
                OutputLineAddr(EXTEND64(*(LONG*)m_Value), " [%s @ %d]");
            }
        }
    }

    return TRUE;
}

void
DumpDword::PrintUnknown(void)
{
    dprintf(" ????????");
}

void
DumpDwordMemory(PADDR Start, ULONG Count, BOOL ShowSymbols)
{
    DumpDword Dumper(ShowSymbols);

    Dumper.Dump(Start, Count);
}

/*** DumpDwordAndCharMemory - output dword value from memory
*
*   Purpose:
*       Function of "dc<range>" command.
*
*       Output the memory in the specified range as double
*       word values up to 4 double words per line, followed by
*       an ASCII character representation of the bytes.
*       The default display is 16 lines for 64 double words total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of double words to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

class DumpDwordAndChar : public DumpValues
{
public:
    DumpDwordAndChar(void)
        : DumpValues(sizeof(DWORD), (sizeof(m_Buf) - 1) / sizeof(DWORD))
    {
        m_Base = m_Buf;
    }

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    UCHAR m_Buf[17];
};

void
DumpDwordAndChar::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_UINT32);
    Val->m_U32 = *(DWORD *)m_Value;
}

BOOL
DumpDwordAndChar::PrintValue(void)
{
    UCHAR ch;
    ULONG byte;

    dprintf(" %08x", *(DWORD *)m_Value);

    for (byte = 0; byte < sizeof(DWORD); byte++)
    {
        ch = *(m_Value + byte);
        if (ch < 0x20 || ch > 0x7e)
        {
            ch = '.';
        }
        *m_Out++ = ch;
    }

    return TRUE;
}

void
DumpDwordAndChar::PrintUnknown(void)
{
    dprintf(" ????????");
    *m_Out++ = '?';
    *m_Out++ = '?';
    *m_Out++ = '?';
    *m_Out++ = '?';
}

void
DumpDwordAndChar::EndRow(void)
{
    *m_Out++ = 0;
    while (m_Col < m_Columns)
    {
        dprintf("         ");
        m_Col++;
    }
    dprintf("  %s", m_Base);
}

void
DumpDwordAndCharMemory(PADDR Start, ULONG Count)
{
    DumpDwordAndChar Dumper;

    Dumper.Dump(Start, Count);
}

/*** DumpListMemory - output linked list from memory
*
*   Purpose:
*       Function of "dl addr length size" command.
*
*       Output the memory in the specified range as a linked list
*
*   Input:
*       Start - starting address to begin display
*       Count - number of list elements to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

void
DumpListMemory(PADDR Start,
               ULONG ElemCount,
               ULONG Size,
               BOOL  FollowBlink)
{
    ULONG64 FirstAddr;
    ULONG64 Link;
    LIST_ENTRY64 List;
    ADDR CurAddr;

    if (Type(*Start) & (ADDR_UNKNOWN | ADDR_V86 | ADDR_16 | ADDR_1632))
    {
        dprintf("[%u,%x:%x`%08x,%08x`%08x] - bogus address type.\n",
                Type(*Start),
                Start->seg,
                (ULONG)(Off(*Start)>>32),
                (ULONG)Off(*Start),
                (ULONG)(Flat(*Start)>>32),
                (ULONG)Flat(*Start)
                );
        return;
    }

    //
    // Setup to follow forward or backward links.  Avoid reading more
    // than the forward link here if going forwards. (in case the link
    // is at the end of a page).
    //

    FirstAddr = Flat(*Start);
    while (ElemCount-- != 0 && Flat(*Start) != 0)
    {
        if (FollowBlink)
        {
            if (g_Target->ReadListEntry(g_Process, g_Machine,
                                        Flat(*Start), &List) != S_OK)
            {
                break;
            }
            Link = List.Blink;
        }
        else
        {
            if (g_Target->ReadPointer(g_Process, g_Machine,
                                      Flat(*Start), &Link) != S_OK)
            {
                break;
            }
        }

        CurAddr = *Start;
        if (g_Machine->m_Ptr64)
        {
            DumpQuadMemory(&CurAddr, Size, FALSE);
        }
        else
        {
            DumpDwordMemory(&CurAddr, Size, FALSE);
        }

        //
        // If we get back to the first entry, we're done.
        //

        if (Link == FirstAddr)
        {
            break;
        }

        //
        // Bail if the link is immediately circular.
        //

        if (Flat(*Start) == Link)
        {
            break;
        }

        Flat(*Start) = Start->off = Link;
        
        if (CheckUserInterrupt())
        {
            WarnOut("-- User interrupt\n");
            return;
        }
    }
}

//----------------------------------------------------------------------------
//
// DumpFloatMemory
//
// Dumps float values.
//
//----------------------------------------------------------------------------

class DumpFloat : public DumpValues
{
public:
    DumpFloat(void)
        : DumpValues(sizeof(float), 4) {}

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
};

void
DumpFloat::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_FLOAT32);
    Val->m_F32 = *(float *)m_Value;
}

BOOL
DumpFloat::PrintValue(void)
{
    dprintf(" %16.8g", *(float *)m_Value);
    return TRUE;
}

void
DumpFloat::PrintUnknown(void)
{
    dprintf(" ????????????????");
}

void
DumpFloatMemory(PADDR Start, ULONG Count)
{
    DumpFloat Dumper;
    
    Dumper.Dump(Start, Count);
}

//----------------------------------------------------------------------------
//
// DumpDoubleMemory
//
// Dumps double values.
//
//----------------------------------------------------------------------------

class DumpDouble : public DumpValues
{
public:
    DumpDouble(void)
        : DumpValues(sizeof(double), 3) {}

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
};

void
DumpDouble::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_FLOAT64);
    Val->m_F64 = *(double *)m_Value;
}

BOOL
DumpDouble::PrintValue(void)
{
    dprintf(" %22.12lg", *(double *)m_Value);
    return TRUE;
}

void
DumpDouble::PrintUnknown(void)
{
    dprintf(" ????????????????????????");
}

void
DumpDoubleMemory(PADDR Start, ULONG Count)
{
    DumpDouble Dumper;
    
    Dumper.Dump(Start, Count);
}

/*** DumpQuadMemory - output quad value from memory
*
*   Purpose:
*       Function of "dq<range>" command.
*
*       Output the memory in the specified range as quad
*       word values up to 2 quad words per line.  The default
*       display is 16 lines for 32 quad words total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of double words to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

class DumpQuad : public DumpValues
{
public:
    DumpQuad(BOOL DumpSymbols)
        : DumpValues(sizeof(ULONGLONG), DumpSymbols ? 1 : 2)
    {
        m_DumpSymbols = DumpSymbols;
    }

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);

    BOOL m_DumpSymbols;
};

void
DumpQuad::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_UINT64);
    Val->m_U64 = *(ULONG64 *)m_Value;
}

BOOL
DumpQuad::PrintValue(void)
{
    CHAR   SymBuf[MAX_SYMBOL_LEN];
    ULONG64  Displacement;

    ULONG64 Val = *(ULONG64*)m_Value;
    dprintf(" %08lx`%08lx", (ULONG)(Val >> 32), (ULONG)Val);

    if (m_DumpSymbols)
    {
        GetSymbol(Val, SymBuf, sizeof(SymBuf), &Displacement);
        if (*SymBuf)
        {
            dprintf(" %s", SymBuf);
            if (Displacement)
            {
                dprintf("+0x%s", FormatDisp64(Displacement));
            }

            if (g_SymOptions & SYMOPT_LOAD_LINES)
            {
                OutputLineAddr(Val, " [%s @ %d]");
            }
        }
    }

    return TRUE;
}

void
DumpQuad::PrintUnknown(void)
{
    dprintf(" ????????`????????");
}

void
DumpQuadMemory(PADDR Start, ULONG Count, BOOL ShowSymbols)
{
    DumpQuad Dumper(ShowSymbols);

    Dumper.Dump(Start, Count);
}

/*** DumpByteBinaryMemory - output binary value from memory
*
*   Purpose:
*       Function of "dyb<range>" command.
*
*       Output the memory in the specified range as binary
*       values up to 32 bits per line.  The default
*       display is 8 lines for 32 bytes total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of double words to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

class DumpByteBinary : public DumpValues
{
public:
    DumpByteBinary(void)
        : DumpValues(sizeof(UCHAR), (DIMA(m_HexValue) - 1) / 3)
    {
        m_Base = m_HexValue;
    }

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    UCHAR m_HexValue[13];
};

void
DumpByteBinary::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_UINT8);
    Val->m_U8 = *m_Value;
}

BOOL
DumpByteBinary::PrintValue(void)
{
    ULONG i;
    UCHAR RawVal;

    RawVal = *m_Value;

    sprintf((PSTR)m_Out, " %02x", RawVal);
    m_Out += 3;

    dprintf(" ");
    for (i = 0; i < 8; i++)
    {
        dprintf("%c", (RawVal & 0x80) ? '1' : '0');
        RawVal <<= 1;
    }

    return TRUE;
}

void
DumpByteBinary::PrintUnknown(void)
{
    dprintf(" ????????");
    strcpy((PSTR)m_Out, " ??");
    m_Out += 3;
}

void
DumpByteBinary::EndRow(void)
{
    while (m_Col < m_Columns)
    {
        dprintf("         ");
        m_Col++;
    }
    dprintf(" %s", m_HexValue);
}

void
DumpByteBinaryMemory(PADDR Start, ULONG Count)
{
    DumpByteBinary Dumper;
    PSTR Blanks = g_Machine->m_Ptr64 ? "                 " : "        ";

    dprintf("%s  76543210 76543210 76543210 76543210\n", Blanks);
    dprintf("%s  -------- -------- -------- --------\n", Blanks);
    Dumper.Dump(Start, Count);
}

/*** DumpDwordBinaryMemory - output binary value from memory
*
*   Purpose:
*       Function of "dyd<range>" command.
*
*       Output the memory in the specified range as binary
*       values of 32 bits per line.  The default
*       display is 8 lines for 8 dwords total.
*
*   Input:
*       Start - starting address to begin display
*       Count - number of double words to be displayed
*
*   Output:
*       None.
*
*   Notes:
*       memory locations not accessible are output as "????????",
*       but no errors are returned.
*
*************************************************************************/

class DumpDwordBinary : public DumpValues
{
public:
    DumpDwordBinary(void)
        : DumpValues(sizeof(ULONG), 1)
    {
    }

protected:
    // Worker methods that derived classes must define.
    virtual void GetValue(TypedData* Val);
    virtual BOOL PrintValue(void);
    virtual void PrintUnknown(void);
    virtual void EndRow(void);

    UCHAR m_HexValue[9];
};

void
DumpDwordBinary::GetValue(TypedData* Val)
{
    Val->SetToNativeType(DNTYPE_UINT32);
    Val->m_U32 = *(PULONG)m_Value;
}

BOOL
DumpDwordBinary::PrintValue(void)
{
    ULONG i;
    ULONG RawVal;

    RawVal = *(PULONG)m_Value;

    sprintf((PSTR)m_HexValue, "%08lx", RawVal);

    for (i = 0; i < sizeof(ULONG) * 8; i++)
    {
        if ((i & 7) == 0)
        {
            dprintf(" ");
        }
        
        dprintf("%c", (RawVal & 0x80000000) ? '1' : '0');
        RawVal <<= 1;
    }

    return TRUE;
}

void
DumpDwordBinary::PrintUnknown(void)
{
    dprintf(" ???????? ???????? ???????? ????????");
    strcpy((PSTR)m_HexValue, "????????");
}

void
DumpDwordBinary::EndRow(void)
{
    dprintf("  %s", m_HexValue);
}

void
DumpDwordBinaryMemory(PADDR Start, ULONG Count)
{
    DumpDwordBinary Dumper;
    PSTR Blanks = g_Machine->m_Ptr64 ? "                 " : "        ";

    dprintf("%s   3          2          1          0\n", Blanks);
    dprintf("%s  10987654 32109876 54321098 76543210\n", Blanks);
    dprintf("%s  -------- -------- -------- --------\n", Blanks);
    Dumper.Dump(Start, Count);
}

//----------------------------------------------------------------------------
//
// DumpSelector
//
// Dumps x86 selectors.
//
//----------------------------------------------------------------------------

void
DumpSelector(ULONG Selector, ULONG Count)
{
    DESCRIPTOR64 Desc;
    ULONG Type;
    LPSTR TypeName, TypeProtect, TypeAccess;
    PSTR PreFill, PostFill, Dash;

    if (g_Machine->m_Ptr64)
    {
        PreFill = "    ";
        PostFill = "     ";
        Dash = "---------";
    }
    else
    {
        PreFill = "";
        PostFill = "";
        Dash = "";
    }
        
    dprintf("Selector   %sBase%s     %sLimit%s     "
            "Type    DPL   Size  Gran Pres\n",
            PreFill, PostFill, PreFill, PostFill);
    dprintf("-------- --------%s --------%s "
            "---------- --- ------- ---- ----\n",
            Dash, Dash);
        
    while (Count >= 8)
    {
        if (CheckUserInterrupt())
        {
            WarnOut("-- User interrupt\n");
            break;
        }
        
        dprintf("  %04X   ", Selector);
        
        if (g_Target->GetSelDescriptor(g_Thread, g_Machine,
                                       Selector, &Desc) != S_OK)
        {
            ErrOut("Unable to get descriptor\n");
            Count -= 8;
            Selector += 8;
            continue;
        }

        Type = X86_DESC_TYPE(Desc.Flags);
        if (Type & 0x10)
        {
            if (Type & 0x8)
            {
                // Code Descriptor
                TypeName = "Code ";
                TypeProtect = (Type & 2) ? "RE" : "EO";
            }
            else
            {
                // Data Descriptor
                TypeName = "Data ";
                TypeProtect = (Type & 2) ? "RW" : "RO";
            }

            TypeAccess = (Type & 1) ? " Ac" : "   ";
        }
        else
        {
            TypeProtect = "";
            TypeAccess = "";
            
            switch(Type)
            {
            case 2:
                TypeName = "LDT       ";
                break;
            case 1:
            case 3:
            case 9:
            case 0xB:
                TypeName = (Type & 0x8) ? "TSS32" : "TSS16";
                TypeAccess = (Type & 0x2) ? " Busy" : " Avl ";
                break;
            case 4:
                TypeName = "C-GATE16  ";
                break;
            case 5:
                TypeName = "TSK-GATE  ";
                break;
            case 6:
                TypeName = "I-GATE16  ";
                break;
            case 7:
                TypeName = "TRP-GATE16";
                break;
            case 0xC:
                TypeName = "C-GATE32  ";
                break;
            case 0xF:
                TypeName = "T-GATE32  ";
                break;
            default:
                TypeName = "<Reserved>";
                break;
            }
        }

        dprintf("%s %s %s%s%s  %d  %s %s %s\n",
                FormatAddr64(Desc.Base),
                FormatAddr64(Desc.Limit),
                TypeName, TypeProtect, TypeAccess,
                X86_DESC_PRIVILEGE(Desc.Flags),
                (Desc.Flags & X86_DESC_DEFAULT_BIG) ? "  Big  " : "Not Big",
                (Desc.Flags & X86_DESC_GRANULARITY) ? "Page" : "Byte",
                (Desc.Flags & X86_DESC_PRESENT) ? " P  " : " NP ");

        Count -= 8;
        Selector += 8;
    }
}

void
ParseEnterCommand(void)
{
    CHAR Ch;
    ADDR Addr1;
    UCHAR ListBuffer[STRLISTSIZE * 2];
    ULONG Count;
    ULONG Size;

    static CHAR s_EnterType = 'b';

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }
    
    Ch = (CHAR)tolower(*g_CurCmd);
    if (Ch == 'a' || Ch == 'b' || Ch == 'w' || Ch == 'd' || Ch == 'q' ||
        Ch == 'u' || Ch == 'p' || Ch == 'f')
    {
        if (*g_CurCmd == 'D')
        {
            s_EnterType = *g_CurCmd;
        }
        else
        {
            s_EnterType = Ch;
        }
        g_CurCmd++;
    }
    GetAddrExpression(SEGREG_DATA, &Addr1);
    if (s_EnterType == 'a' || s_EnterType == 'u')
    {
        AsciiList((PSTR)ListBuffer, sizeof(ListBuffer), &Count);
        if (Count == 0)
        {
            error(UNIMPLEMENT);         //TEMP
        }

        if (s_EnterType == 'u')
        {
            ULONG Ansi;
            
            // Expand ANSI to Unicode.
            Ansi = Count;
            Count *= 2;
            while (Ansi-- > 0)
            {
                ListBuffer[Ansi * 2] = ListBuffer[Ansi];
                ListBuffer[Ansi * 2 + 1] = 0;
            }
            Size = 2;
        }
        else
        {
            Size = 1;
        }
    }
    else
    {
        Size = 1;
        if (s_EnterType == 'w')
        {
            Size = 2;
        }
        else if (s_EnterType == 'd' ||
                 s_EnterType == 'f' ||
                 (s_EnterType == 'p' && !g_Machine->m_Ptr64))
        {
            Size = 4;
        }
        else if (s_EnterType == 'q' ||
                 s_EnterType == 'D' ||
                 (s_EnterType == 'p' && g_Machine->m_Ptr64))
        {
            Size = 8;
        }

        if (s_EnterType == 'f' || s_EnterType == 'D')
        {
            FloatList(ListBuffer, sizeof(ListBuffer), Size, &Count);
        }
        else
        {
            HexList(ListBuffer, sizeof(ListBuffer), Size, &Count);
        }
        if (Count == 0)
        {
            InteractiveEnterMemory(s_EnterType, &Addr1, Size);
            return;
        }
    }

    //
    // Memory was entered at the command line.
    // Write it out in the same chunks as it was entered.
    //

    PUCHAR List = &ListBuffer[0];

    while (Count)
    {
        if (fnotFlat(Addr1) ||
            g_Target->WriteAllVirtual(g_Process, Flat(Addr1),
                                      List, Size) != S_OK)
        {
            error(MEMORY);
        }
        AddrAdd(&Addr1, Size);
        
        if (CheckUserInterrupt())
        {
            WarnOut("-- User interrupt\n");
            return;
        }

        List += Size;
        Count -= Size;
    }
}

//----------------------------------------------------------------------------
//
// InteractiveEnterMemory
//
// Interactively walks through memory, displaying current contents
// and prompting for new contents.
//
//----------------------------------------------------------------------------

void
InteractiveEnterMemory(CHAR Type, PADDR Address, ULONG Size)
{
    CHAR    EnterBuf[1024];
    PSTR    Enter;
    ULONG64 Content;
    PSTR    CmdSaved = g_CurCmd;
    PSTR    StartSaved = g_CommandStart;
    ULONG64 EnteredValue;
    CHAR    Ch;

    g_PromptLength = 9 + 2 * Size;

    while (TRUE)
    {
        if (fnotFlat(*Address) ||
            g_Target->ReadAllVirtual(g_Process, Flat(*Address),
                                     &Content, Size) != S_OK)
        {
            error(MEMORY);
        }
        dprintAddr(Address);

        switch(Type)
        {
        case 'f':
            dprintf("%12.6g", *(float*)&Content);
            break;
        case 'D':
            dprintf("%22.12g", *(double*)&Content);
            break;
        default:
            switch(Size)
            {
            case 1:
                dprintf("%02x", (UCHAR)Content);
                break;
            case 2:
                dprintf("%04x", (USHORT)Content);
                break;
            case 4:
                dprintf("%08lx", (ULONG)Content);
                break;
            case 8:
                dprintf("%08lx`%08lx", (ULONG)(Content>>32), (ULONG)Content);
                break;
            }
            break;
        }

        GetInput(" ", EnterBuf, 1024, GETIN_LOG_INPUT_LINE);
        RemoveDelChar(EnterBuf);
        Enter = EnterBuf;

        if (*Enter == '\0')
        {
            g_CurCmd = CmdSaved;
            g_CommandStart = StartSaved;
            return;
        }

        Ch = *Enter;
        while (Ch == ' ' || Ch == '\t' || Ch == ';')
        {
            Ch = *++Enter;
        }

        if (*Enter == '\0')
        {
            AddrAdd(Address, Size);
            continue;
        }

        g_CurCmd = Enter;
        g_CommandStart = Enter;
        if (Type == 'f' || Type == 'D')
        {
            EnteredValue = FloatValue(Size);
        }
        else
        {
            EnteredValue = HexValue(Size);
        }

        if (fnotFlat(*Address) ||
            g_Target->WriteAllVirtual(g_Process, Flat(*Address),
                                      &EnteredValue, Size) != S_OK)
        {
            error(MEMORY);
        }
        AddrAdd(Address, Size);
    }
}

/*** CompareTargetMemory - compare two ranges of memory
*
*   Purpose:
*       Function of "c<range><addr>" command.
*
*       To compare two ranges of memory, starting at offsets
*       src1addr and src2addr, respectively, for length bytes.
*       Bytes that mismatch are displayed with their offsets
*       and contents.
*
*   Input:
*       src1addr - start of first memory region
*       length - count of bytes to compare
*       src2addr - start of second memory region
*
*   Output:
*       None.
*
*   Exceptions:
*       error exit: MEMORY - memory read access failure
*
*************************************************************************/

void
CompareTargetMemory(PADDR Src1Addr, ULONG Length, PADDR Src2Addr)
{
    ULONG CompIndex;
    UCHAR Src1Ch;
    UCHAR Src2Ch;

    for (CompIndex = 0; CompIndex < Length; CompIndex++)
    {
        if (fnotFlat(*Src1Addr) ||
            fnotFlat(*Src2Addr) ||
            g_Target->ReadAllVirtual(g_Process, Flat(*Src1Addr),
                                     &Src1Ch, sizeof(Src1Ch)) != S_OK ||
            g_Target->ReadAllVirtual(g_Process, Flat(*Src2Addr),
                                     &Src2Ch, sizeof(Src2Ch)) != S_OK)
        {
            error(MEMORY);
        }

        if (Src1Ch != Src2Ch)
        {
            dprintAddr(Src1Addr);
            dprintf(" %02x - ", Src1Ch);
            dprintAddr(Src2Addr);
            dprintf(" %02x\n", Src2Ch);
        }
        AddrAdd(Src1Addr, 1);
        AddrAdd(Src2Addr, 1);
        
        if (CheckUserInterrupt())
        {
            WarnOut("-- User interrupt\n");
            return;
        }
    }
}

/*** MoveTargetMemory - move a range of memory to another
*
*   Purpose:
*       Function of "m<range><addr>" command.
*
*       To move a range of memory starting at srcaddr to memory
*       starting at destaddr for length bytes.
*
*   Input:
*       srcaddr - start of source memory region
*       length - count of bytes to move
*       destaddr - start of destination memory region
*
*   Output:
*       memory at destaddr has moved values
*
*   Exceptions:
*       error exit: MEMORY - memory reading or writing access failure
*
*************************************************************************/

void
MoveTargetMemory(PADDR SrcAddr, ULONG Length, PADDR DestAddr)
{
    UCHAR Ch;
    ULONG64 Incr = 1;

    if (AddrLt(*SrcAddr, *DestAddr))
    {
        AddrAdd(SrcAddr, Length - 1);
        AddrAdd(DestAddr, Length - 1);
        Incr = (ULONG64)-1;
    }
    while (Length--)
    {
        if (fnotFlat(*SrcAddr) ||
            fnotFlat(*DestAddr) ||
            g_Target->ReadAllVirtual(g_Process, Flat(*SrcAddr),
                                     &Ch, sizeof(Ch)) ||
            g_Target->WriteAllVirtual(g_Process, Flat(*DestAddr),
                                      &Ch, sizeof(Ch)) != S_OK)
        {
            error(MEMORY);
        }
        AddrAdd(SrcAddr, Incr);
        AddrAdd(DestAddr, Incr);
        
        if (CheckUserInterrupt())
        {
            WarnOut("-- User interrupt\n");
            return;
        }
    }
}

/*** ParseFillMemory - fill memory with a byte list
*
*   Purpose:
*       Function of "f<range><bytelist>" command.
*
*       To fill a range of memory with the byte list specified.
*       The pattern repeats if the range size is larger than the
*       byte list size.
*
*   Input:
*       Start - offset of memory to fill
*       length - number of bytes to fill
*       *plist - pointer to byte array to define values to set
*       length - size of *plist array
*
*   Exceptions:
*       error exit: MEMORY - memory write access failure
*
*   Output:
*       memory at Start filled.
*
*************************************************************************/

void
ParseFillMemory(void)
{
    HRESULT Status;
    BOOL Virtual = TRUE;
    ADDR Addr;
    ULONG64 Size;
    UCHAR Pattern[STRLISTSIZE];
    ULONG PatternSize;
    ULONG Done;

    if (*g_CurCmd == 'p')
    {
        Virtual = FALSE;
        g_CurCmd++;
    }
    
    GetRange(&Addr, &Size, 1, SEGREG_DATA,
             DEFAULT_RANGE_LIMIT);
    HexList(Pattern, sizeof(Pattern), 1, &PatternSize);
    if (PatternSize == 0)
    {
        error(SYNTAX);
    }

    if (Virtual)
    {
        Status = g_Target->FillVirtual(g_Process, Flat(Addr), (ULONG)Size,
                                       Pattern, PatternSize,
                                       &Done);
    }
    else
    {
        Status = g_Target->FillPhysical(Flat(Addr), (ULONG)Size,
                                        Pattern, PatternSize,
                                        &Done);
    }

    if (Status != S_OK)
    {
        error(MEMORY);
    }
    else
    {
        dprintf("Filled 0x%x bytes\n", Done);
    }
}

/*** SearchTargetMemory - search memory for a set of bytes
*
*   Purpose:
*       Function of "s<range><bytelist>" command.
*
*       To search a range of memory with the byte list specified.
*       If a match occurs, the offset of memory is output.
*
*   Input:
*       Start - offset of memory to start search
*       length - size of range to search
*       *plist - pointer to byte array to define values to search
*       count - size of *plist array
*
*   Output:
*       None.
*
*   Exceptions:
*       error exit: MEMORY - memory read access failure
*
*************************************************************************/

void
SearchTargetMemory(PADDR Start,
                   ULONG64 Length,
                   PUCHAR List,
                   ULONG Count,
                   ULONG Granularity)
{
    ADDR TmpAddr = *Start;
    ULONG64 Found;
    LONG64 SearchLength = Length;
    HRESULT Status;

    do
    {
        Status = g_Target->SearchVirtual(g_Process,
                                         Flat(*Start),
                                         SearchLength,
                                         List,
                                         Count,
                                         Granularity,
                                         &Found);
        if (Status == S_OK)
        {
            ADDRFLAT(&TmpAddr, Found);
            switch(Granularity)
            {
            case 1:
                DumpByteMemory(&TmpAddr, 16);
                break;
            case 2:
                DumpWordMemory(&TmpAddr, 8);
                break;
            case 4:
                DumpDwordAndCharMemory(&TmpAddr, 4);
                break;
            case 8:
                DumpQuadMemory(&TmpAddr, 2, FALSE);
                break;
            }
            
            // Flush out the output immediately so that
            // the user can see partial results during long searches.
            FlushCallbacks();
            
            SearchLength -= Found - Flat(*Start) + Granularity;
            AddrAdd(Start, (ULONG)(Found - Flat(*Start) + Granularity));
        
            if (CheckUserInterrupt())
            {
                WarnOut("-- Memory search interrupted at %s\n",
                        FormatAddr64(Flat(*Start)));
                return;
            }
        }
    }
    while (SearchLength > 0 && Status == S_OK);
}

ULONG
ObjVfnTableCallback(PFIELD_INFO FieldInfo,
                    PVOID Context)
{
    HRESULT Status;
    
    ULONG Index = g_NumObjVfnTableOffsets++;
    if (g_NumObjVfnTableOffsets > MAX_VFN_TABLE_OFFSETS)
    {
        return S_OK;
    }
    
    if ((Status = g_Target->
         ReadPointer(g_Process, g_Machine, FieldInfo->address,
                     &g_ObjVfnTableAddr[Index])) != S_OK)
    {
        ErrOut("Unable to read vtable pointer at %s\n",
               FormatAddr64(FieldInfo->address));
        g_NumObjVfnTableOffsets--;
        return Status;
    }

    g_ObjVfnTableOffset[Index] = FieldInfo->FieldOffset;
    return S_OK;
}

void
SearchForObjectByVfnTable(ULONG64 Start, ULONG64 Length, ULONG Granularity)
{
    HRESULT Status;
    ULONG i;
    
    char Save;
    PSTR Str = StringValue(STRV_SPACE_IS_SEPARATOR ||
                           STRV_TRIM_TRAILING_SPACE ||
                           STRV_ESCAPED_CHARACTERS,
                           &Save);

    //
    // Search all of the object's members for vtable references
    // and collect them.
    //
    
    SYM_DUMP_PARAM Symbol;
    FIELD_INFO Fields[] =
    {
        {(PUCHAR)"__VFN_table", NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0,
         (PVOID)&ObjVfnTableCallback},
    };
    ULONG Err;

    ZeroMemory(&Symbol, sizeof(Symbol));
    Symbol.sName = (PUCHAR)Str;
    Symbol.nFields = 1;
    Symbol.Context = (PVOID)Str;
    Symbol.Fields = Fields;
    Symbol.size = sizeof(Symbol);
    Symbol.Options = NO_PRINT;

    g_NumObjVfnTableOffsets = 0;
    
    SymbolTypeDumpNew(&Symbol, &Err);

    if (g_NumObjVfnTableOffsets == 0)
    {
        ErrOut("Object '%s' has no vtables\n", Str);
        *g_CurCmd = Save;
        return;
    }

    TypedData SymbolType;

    if ((Err = SymbolType.
         FindSymbol(g_Process, Str, TDACC_REQUIRE,
                    g_Machine->m_Ptr64 ? 8 : 4)) ||
        (SymbolType.IsPointer() &&
         (Err = SymbolType.ConvertToDereference(TDACC_REQUIRE,
                                                g_Machine->m_Ptr64 ? 8 : 4))))
    {
        error(Err);
    }
    if (!SymbolType.m_Image)
    {
        error(TYPEDATA);
    }
        
    if (g_NumObjVfnTableOffsets > MAX_VFN_TABLE_OFFSETS)
    {
        WarnOut("%s has %d vtables, limiting search to %d\n",
                Str, g_NumObjVfnTableOffsets, MAX_VFN_TABLE_OFFSETS);
        g_NumObjVfnTableOffsets = MAX_VFN_TABLE_OFFSETS;
    }

    dprintf("%s size 0x%x, vtables: %d\n",
            Str, Symbol.TypeSize, g_NumObjVfnTableOffsets);
    for (i = 0; i < g_NumObjVfnTableOffsets; i++)
    {
        dprintf("  +%03x - %s ", g_ObjVfnTableOffset[i],
                FormatAddr64(g_ObjVfnTableAddr[i]));
        OutputSymAddr(g_ObjVfnTableAddr[i], 0, NULL);
        dprintf("\n");
    }
    dprintf("Searching...\n");

    *g_CurCmd = Save;
    
    //
    // Scan memory for the first vtable pointer found.  On
    // a hit, check that all of the other vtable pointers
    // match also.
    //

    do
    {
        ULONG64 Found;
        
        Status = g_Target->SearchVirtual(g_Process,
                                         Start,
                                         Length,
                                         &g_ObjVfnTableAddr[0],
                                         Granularity,
                                         Granularity,
                                         &Found);
        if (Status == S_OK)
        {
            // We found a hit on the first pointer.  Check
            // the others now.
            Found -= g_ObjVfnTableOffset[0];
            for (i = 1; i < g_NumObjVfnTableOffsets; i++)
            {
                ULONG64 Ptr;

                if (g_Target->ReadPointer(g_Process, g_Machine,
                                          Found + g_ObjVfnTableOffset[i],
                                          &Ptr) != S_OK ||
                    Ptr != g_ObjVfnTableAddr[i])
                {
                    break;
                }
            }

            if (i == g_NumObjVfnTableOffsets)
            {
                OutputTypeByIndex(g_Process->m_SymHandle,
                                  SymbolType.m_Image->m_BaseOfImage,
                                  SymbolType.m_BaseType,
                                  Found);
            }
                                  
            // Flush out the output immediately so that
            // the user can see partial results during long searches.
            FlushCallbacks();

            Found += Symbol.TypeSize;

            if (Found > Start)
            {
                Length -= Found - Start;
            }
            else
            {
                Length = 0;
            }
            Start = Found;
        
            if (CheckUserInterrupt())
            {
                WarnOut("-- User interrupt\n");
                return;
            }
        }
    }
    while (Length > 0 && Status == S_OK);
}

void
ParseSearchMemory(void)
{
    ADDR Addr;
    ULONG64 Length;
    UCHAR Pat[STRLISTSIZE];
    ULONG PatLen;
    ULONG Gran;
    char SearchType;

    while (*g_CurCmd == ' ')
    {
        g_CurCmd++;
    }

    Gran = 1;
    SearchType = 'b';

    if (*g_CurCmd == '-')
    {
        g_CurCmd++;
        SearchType = *g_CurCmd;
        switch(SearchType)
        {
        case 'a':
            Gran = 1;
            break;
        case 'u':
        case 'w':
            Gran = 2;
            break;
        case 'd':
            Gran = 4;
            break;
        case 'q':
            Gran = 8;
            break;
        case 'v':
            // Special object vtable search.  It's basically a multi-pointer
            // search, so the granularity is pointer-size.
            if (g_Machine->m_Ptr64)
            {
                Gran = 8;
            }
            else
            {
                Gran = 4;
            }
            break;
        default:
            error(SYNTAX);
            break;
        }
        g_CurCmd++;
    }

    // Allow very large ranges for search as it is used
    // to search large areas of memory.
    ADDRFLAT(&Addr, 0);
    Length = 16;
    GetRange(&Addr, &Length, Gran, SEGREG_DATA, 0x10000000);
    if (!fFlat(Addr))
    {
        error(BADRANGE);
    }
    
    if (SearchType == 'v')
    {
        SearchForObjectByVfnTable(Flat(Addr), Length * Gran, Gran);
        return;
    }
    else if (SearchType == 'a' || SearchType == 'u')
    {
        char Save;
        PSTR Str = StringValue(STRV_SPACE_IS_SEPARATOR ||
                               STRV_TRIM_TRAILING_SPACE ||
                               STRV_ESCAPED_CHARACTERS,
                               &Save);
        PatLen = strlen(Str);
        if (PatLen * Gran > STRLISTSIZE)
        {
            error(LISTSIZE);
        }
        if (SearchType == 'u')
        {
            MultiByteToWideChar(CP_ACP, 0,
                                Str, PatLen,
                                (PWSTR)Pat, STRLISTSIZE / sizeof(WCHAR));
            PatLen *= sizeof(WCHAR);
        }
        else
        {
            memcpy(Pat, Str, PatLen);
        }
        *g_CurCmd = Save;
    }
    else
    {
        HexList(Pat, sizeof(Pat), Gran, &PatLen);
    }
    if (PatLen == 0)
    {
        PCSTR Err = "Search pattern missing from";
        ReportError(SYNTAX, &Err);
    }
        
    SearchTargetMemory(&Addr, Length * Gran, Pat, PatLen, Gran);
}

/*** InputIo - read and output io
*
*   Purpose:
*       Function of "ib, iw, id <address>" command.
*
*       Read (input) and print the value at the specified io address.
*
*   Input:
*       IoAddress - Address to read.
*       InputType - The size type 'b', 'w', or 'd'
*
*   Output:
*       None.
*
*   Notes:
*       I/O locations not accessible are output as "??", "????", or
*       "????????", depending on size.  No errors are returned.
*
*************************************************************************/

void
InputIo(ULONG64 IoAddress, UCHAR InputType)
{
    ULONG    InputValue;
    ULONG    InputSize = 1;
    HRESULT  Status;
    CHAR     Format[] = "%01lx";

    InputValue = 0;

    if (InputType == 'w')
    {
        InputSize = 2;
    }
    else if (InputType == 'd')
    {
        InputSize = 4;
    }

    Status = g_Target->ReadIo(Isa, 0, 1, IoAddress, &InputValue, InputSize,
                              NULL);

    dprintf("%s: ", FormatAddr64(IoAddress));

    if (Status == S_OK)
    {
        Format[2] = (CHAR)('0' + (InputSize * 2));
        dprintf(Format, InputValue);
    }
    else
    {
        while (InputSize--)
        {
            dprintf("??");
        }
    }

    dprintf("\n");
}

/*** OutputIo - output io
*
*   Purpose:
*       Function of "ob, ow, od <address>" command.
*
*       Write a value to the specified io address.
*
*   Input:
*       IoAddress - Address to read.
*       OutputValue - Value to be written
*       OutputType - The output size type 'b', 'w', or 'd'
*
*   Output:
*       None.
*
*   Notes:
*       No errors are returned.
*
*************************************************************************/

void
OutputIo(ULONG64 IoAddress, ULONG OutputValue, UCHAR OutputType)
{
    ULONG    OutputSize = 1;

    if (OutputType == 'w')
    {
        OutputSize = 2;
    }
    else if (OutputType == 'd')
    {
        OutputSize = 4;
    }

    g_Target->WriteIo(Isa, 0, 1, IoAddress,
                      &OutputValue, OutputSize, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\modinfo.cpp ===
//----------------------------------------------------------------------------
//
// Module list abstraction.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

//
// Note by olegk
// We using KLDR_DATA_TABLE_ENTRY64 in some places like 
// GetModNameFromLoaderList) instead of LDR_DATA_TABLE_ENTRY assuming that 
// most important fields are the same in  these structures. 
// So I add some asserts for quick notification if  anything will change 
// (these are not fullproof checks just a basics)
//
C_ASSERT(&(((PLDR_DATA_TABLE_ENTRY64)0)->InLoadOrderLinks) ==
         &(((PKLDR_DATA_TABLE_ENTRY64)0)->InLoadOrderLinks));

C_ASSERT(&(((PLDR_DATA_TABLE_ENTRY64)0)->DllBase) ==
         &(((PKLDR_DATA_TABLE_ENTRY64)0)->DllBase));

C_ASSERT(&(((PLDR_DATA_TABLE_ENTRY64)0)->FullDllName) ==
         &(((PKLDR_DATA_TABLE_ENTRY64)0)->FullDllName));

//----------------------------------------------------------------------------
//
// Module list abstraction.
//
//----------------------------------------------------------------------------

void
ModuleInfo::ReadImageHeaderInfo(PMODULE_INFO_ENTRY Entry)
{
    HRESULT Status;
    UCHAR SectorBuffer[ 1024 ];
    PIMAGE_NT_HEADERS64 NtHeaders;
    ULONG Result;

    if (Entry->ImageInfoValid)
    {
        return;
    }

    //
    // For live debugging of both user mode and kernel mode, we have
    // to go load the checksum timestamp directly out of the image header
    // because someone decided to overwrite these fields in the OS
    // module list  - Argh !
    //

    Entry->CheckSum = UNKNOWN_CHECKSUM;
    Entry->TimeDateStamp = UNKNOWN_TIMESTAMP;

    Status = m_Target->ReadVirtual(m_Process, Entry->Base, SectorBuffer,
                                   sizeof(SectorBuffer), &Result);
    if (Status == S_OK && Result >= sizeof(SectorBuffer))
    {
        NtHeaders = (PIMAGE_NT_HEADERS64)ImageNtHeader(SectorBuffer);
        if (NtHeaders != NULL)
        {
            switch (NtHeaders->OptionalHeader.Magic)
            {
            case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
                Entry->CheckSum = ((PIMAGE_NT_HEADERS32)NtHeaders)->
                    OptionalHeader.CheckSum;
                Entry->Size = ((PIMAGE_NT_HEADERS32)NtHeaders)->
                    OptionalHeader.SizeOfImage;
                Entry->SizeOfCode = ((PIMAGE_NT_HEADERS32)NtHeaders)->
                    OptionalHeader.SizeOfCode;
                Entry->SizeOfData = ((PIMAGE_NT_HEADERS32)NtHeaders)->
                    OptionalHeader.SizeOfInitializedData;
                Entry->MajorImageVersion = ((PIMAGE_NT_HEADERS32)NtHeaders)->
                    OptionalHeader.MajorImageVersion;
                Entry->MinorImageVersion = ((PIMAGE_NT_HEADERS32)NtHeaders)->
                    OptionalHeader.MinorImageVersion;
                break;
            case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
                Entry->CheckSum = NtHeaders->OptionalHeader.CheckSum;
                Entry->Size = NtHeaders->OptionalHeader.SizeOfImage;
                Entry->SizeOfCode = NtHeaders->OptionalHeader.SizeOfCode;
                Entry->SizeOfData =
                    NtHeaders->OptionalHeader.SizeOfInitializedData;
                Entry->MajorImageVersion =
                    NtHeaders->OptionalHeader.MajorImageVersion;
                Entry->MinorImageVersion =
                    NtHeaders->OptionalHeader.MinorImageVersion;
                break;
            }

            Entry->TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
            Entry->MachineType = NtHeaders->FileHeader.Machine;

            Entry->ImageInfoValid = 1;
            Entry->ImageVersionValid = 1;
            Entry->ImageMachineTypeValid = 1;
        }
    }
}

void
ModuleInfo::InitSource(ThreadInfo* Thread)
{
    m_Thread = Thread;
    m_Process = m_Thread->m_Process;
    m_Target = m_Process->m_Target;
    m_Machine = m_Target->m_Machine;

    m_InfoLevel = MODULE_INFO_ALL;
}
    
HRESULT
NtModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    HRESULT Status;
    ULONG   Result = 0;
    ULONG   Length;
    ULONG64 Buffer;

    if (m_Cur == m_Head)
    {
        return S_FALSE;
    }

    KLDR_DATA_TABLE_ENTRY64 LdrEntry;

    Status = m_Target->
        ReadLoaderEntry(m_Process, m_Machine, m_Cur, &LdrEntry);
    if (Status != S_OK)
    {
        ErrOut("Unable to read KLDR_DATA_TABLE_ENTRY at %s - %s\n",
               FormatAddr64(m_Cur), FormatStatusCode(Status));
        return Status;
    }

    m_Cur = LdrEntry.InLoadOrderLinks.Flink;

    //
    // Get the image path if possible, otherwise
    // just use the image base name.
    //

    Entry->NamePtr = NULL;
    Entry->NameLength = 0;

    if (m_InfoLevel > MODULE_INFO_BASE_SIZE)
    {
        Length = (ULONG)(ULONG_PTR)LdrEntry.FullDllName.Length;
        Buffer = LdrEntry.FullDllName.Buffer;

        // In the NT4 dumps that we have the long name may
        // point to valid memory but the memory content is
        // rarely the correct name, so just don't bother
        // trying to read the long name on NT4.
        if (m_Target->m_SystemVersion >= NT_SVER_W2K &&
            Length != 0 && Buffer != 0 &&
            Length < (MAX_IMAGE_PATH * sizeof(WCHAR)))
        {
            Status = m_Target->ReadVirtual(m_Process, Buffer,
                                           Entry->Buffer,
                                           Length,
                                           &Result);

            if (Status != S_OK || (Result < Length))
            {
                // Make this a verbose message since it's possible the
                // name is simply paged out.
                VerbOut("Unable to read NT module Full Name "
                        "string at %s - %s\n",
                        FormatAddr64(Buffer), FormatStatusCode(Status));
                Result = 0;
            }
        }

        if (!Result)
        {
            Length = (ULONG)(ULONG_PTR)LdrEntry.BaseDllName.Length;
            Buffer = LdrEntry.BaseDllName.Buffer;
            
            if (Length != 0 && Buffer != 0 &&
                Length < (MAX_IMAGE_PATH * sizeof(WCHAR)))
            {
                Status = m_Target->ReadVirtual(m_Process, Buffer,
                                               Entry->Buffer,
                                               Length,
                                               &Result);
                
                if (Status != S_OK || (Result < Length))
                {
                    WarnOut("Unable to read NT module Base Name "
                            "string at %s - %s\n",
                            FormatAddr64(Buffer), FormatStatusCode(Status));
                    Result = 0;
                }
            }
        }

        if (!Result)
        {
            // We did not get any name - just return.
            return S_OK;
        }

        *(PWCHAR)(Entry->Buffer + Length) = UNICODE_NULL;
    
        Entry->NamePtr = &(Entry->Buffer[0]);
        Entry->UnicodeNamePtr = 1;
        Entry->NameLength = Length;
    }
    
    Entry->Base = LdrEntry.DllBase;
    Entry->Size = LdrEntry.SizeOfImage;
    Entry->CheckSum = LdrEntry.CheckSum;
    Entry->TimeDateStamp = LdrEntry.TimeDateStamp;

    //
    // Update the image information, such as timestamp and real image size,
    // directly from the image header
    //

    if (m_InfoLevel > MODULE_INFO_BASE_SIZE)
    {
        ReadImageHeaderInfo(Entry);
    }

    //
    // For newer NT builds, we also have an alternate entry in the
    // LdrDataTable to store image information in case the actual header
    // is paged out.  We do this for session space images only right now.
    //

    if (m_InfoLevel > MODULE_INFO_BASE_SIZE &&
        (LdrEntry.Flags & LDRP_NON_PAGED_DEBUG_INFO))
    {
        NON_PAGED_DEBUG_INFO di;

        Status = m_Target->ReadVirtual(m_Process,
                                       LdrEntry.NonPagedDebugInfo,
                                       &di,
                                       sizeof(di), // Only read the base struct
                                       &Result);

        if (Status != S_OK || (Result < sizeof(di)))
        {
            WarnOut("Unable to read NonPagedDebugInfo at %s - %s\n",
                    FormatAddr64(LdrEntry.NonPagedDebugInfo),
                    FormatStatusCode(Status));
            return S_OK;
        }

        Entry->TimeDateStamp = di.TimeDateStamp;
        Entry->CheckSum      = di.CheckSum;
        Entry->Size          = di.SizeOfImage;
        Entry->MachineType   = di.Machine;

        Entry->ImageInfoPartial = 1;
        Entry->ImageInfoValid = 1;
        Entry->ImageMachineTypeValid = 1;

        if (di.Flags == 1)
        {
            Entry->DebugHeader = malloc(di.Size - sizeof(di));

            if (Entry->DebugHeader)
            {
                Status = m_Target->ReadVirtual(m_Process,
                                               LdrEntry.NonPagedDebugInfo +
                                                   sizeof(di),
                                               Entry->DebugHeader,
                                               di.Size - sizeof(di),
                                               &Result);

                if (Status != S_OK || (Result < di.Size - sizeof(di)))
                {
                    WarnOut("Unable to read NonPagedDebugInfo data at %s - %s\n",
                            FormatAddr64(LdrEntry.NonPagedDebugInfo + sizeof(di)),
                            FormatStatusCode(Status));
                    return S_OK;
                }

                Entry->ImageDebugHeader = 1;
                Entry->SizeOfDebugHeader = di.Size - sizeof(di);
            }
        }
    }

    return S_OK;
}

HRESULT
NtKernelModuleInfo::Initialize(ThreadInfo* Thread)
{
    HRESULT Status;
    LIST_ENTRY64 List64;

    InitSource(Thread);
    
    if ((m_Head = m_Target->m_KdDebuggerData.PsLoadedModuleList) == 0)
    {
        //
        // This field is ALWAYS set in NT 5 targets.
        //
        // We will only fail here if someone changed the debugger code
        // and did not "make up" this structure properly for NT 4 or
        // dump targets..
        //

        ErrOut("Module List address is NULL - "
               "debugger not initialized properly.\n");
        return E_FAIL;
    }

    Status = m_Target->ReadListEntry(m_Process, m_Machine, m_Head, &List64);
    if (Status != S_OK)
    {
        // PsLoadedModuleList is a global kernel variable, so if
        // it isn't around the kernel must not be mapped and
        // we're in a very weird state.
        ErrOut("Unable to read PsLoadedModuleList\n");
        return S_FALSE;
    }

    if (!List64.Flink)
    {
        ULONG64 LoaderBlock;
        IMAGE_NT_HEADERS64 ImageHdr;
        
        //
        // In live debug sessions, the debugger connects before Mm creates
        // the actual module list.  If PsLoadedModuleList is
        // uninitialized, try to load symbols from the loader
        // block module list.
        // 
        // If there is no loader block module list but we know
        // the kernel base address and can read the image headers
        // we fake a single entry for the kernel so that kernel
        // symbols will load even without any module lists.
        //
        
        if (m_Target->m_KdDebuggerData.KeLoaderBlock &&
            m_Target->ReadPointer(m_Process, m_Machine,
                                  m_Target->m_KdDebuggerData.KeLoaderBlock,
                                  &LoaderBlock) == S_OK &&
            LoaderBlock &&
            m_Target->ReadListEntry(m_Process, m_Machine, LoaderBlock,
                                    &List64) == S_OK &&
            List64.Flink)
        {
            m_Head = LoaderBlock;
        }
        else if (m_Target->m_KdDebuggerData.KernBase &&
                 m_Target->ReadImageNtHeaders(m_Process, m_Target->
                                              m_KdDebuggerData.KernBase,
                                              &ImageHdr) == S_OK)
        {
            m_Head = m_Target->m_KdDebuggerData.KernBase;
            List64.Flink = m_Target->m_KdDebuggerData.KernBase;
        }
        else
        {
            dprintf("No module list information.  Delay kernel load.\n");
            return S_FALSE;
        }
    }
    
    m_Cur = List64.Flink;

    return S_OK;
}

HRESULT
NtKernelModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    HRESULT Status;

    if (m_Head && m_Head == m_Target->m_KdDebuggerData.KernBase)
    {
        //
        // We weren't able to locate any actual module list
        // information but we do have a kernel base and valid
        // image at that address.  Fake up a kernel module entry.
        //

        wcscpy((PWSTR)Entry->Buffer, L"kd_ntoskrnl");
        Entry->NamePtr = &(Entry->Buffer[0]);
        Entry->UnicodeNamePtr = 1;
        Entry->NameLength = wcslen((PWSTR)Entry->NamePtr) * sizeof(WCHAR);
        Entry->Base = m_Head;
        ReadImageHeaderInfo(Entry);

        m_Head = 0;
        m_Cur = 0;
        Status = S_OK;
    }
    else
    {
        Status = NtModuleInfo::GetEntry(Entry);
    }

    // We know that all kernel modules must be
    // native modules so force the machine type
    // if it isn't already set.
    if (Status == S_OK && !Entry->ImageMachineTypeValid)
    {
        Entry->MachineType = m_Machine->m_ExecTypes[0];
        Entry->ImageMachineTypeValid = 1;
    }

    return Status;
}

NtKernelModuleInfo g_NtKernelModuleIterator;

HRESULT
NtUserModuleInfo::Initialize(ThreadInfo* Thread)
{
    if (Thread)
    {
        InitSource(Thread);
    }
    return GetUserModuleListAddress(m_Thread, m_Machine, m_Peb, FALSE,
                                    &m_Head, &m_Cur) ? S_OK : S_FALSE;
}

HRESULT
NtUserModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    HRESULT Status = NtModuleInfo::GetEntry(Entry);
    if (Status == S_OK)
    {
        Entry->UserMode = TRUE;
    }

    return Status;
}

HRESULT
NtTargetUserModuleInfo::Initialize(ThreadInfo* Thread)
{
    m_Peb = 0;
    return NtUserModuleInfo::Initialize(Thread);
}

NtTargetUserModuleInfo g_NtTargetUserModuleIterator;

HRESULT
NtWow64UserModuleInfo::Initialize(ThreadInfo* Thread)
{
    HRESULT Status;
    
    InitSource(Thread);

    if (m_Target->m_Machine->m_NumExecTypes < 2)
    {
        return E_UNEXPECTED;
    }

    m_Machine = MachineTypeInfo(m_Target, m_Target->m_Machine->m_ExecTypes[1]);
    
    if ((Status = GetPeb32(&m_Peb)) != S_OK)
    {
        return Status;
    }
    
    return NtUserModuleInfo::Initialize(NULL);
}

HRESULT 
NtWow64UserModuleInfo::GetPeb32(PULONG64 Peb32)
{
    ULONG64 Teb;
    ULONG64 Teb32;
    HRESULT Status;

    if ((Status = m_Process->GetImplicitThreadDataTeb(m_Thread, &Teb)) == S_OK)
    {
        if ((Status = m_Target->
             ReadPointer(m_Process, m_Machine, Teb, &Teb32)) == S_OK)
        {
            if (!Teb32) 
            {
                return E_UNEXPECTED;
            }

            ULONG RawPeb32;
            
            Status = m_Target->
                ReadAllVirtual(m_Process, Teb32 + PEB_FROM_TEB32, &RawPeb32,
                               sizeof(RawPeb32));
            if (Status != S_OK)
            {
                ErrOut("Cannot read PEB32 from WOW64 TEB32 %s - %s\n",
                       FormatAddr64(Teb32), FormatStatusCode(Status));
                return Status;
            }

            *Peb32 = EXTEND64(RawPeb32);
        }
    }

    return Status;
}

NtWow64UserModuleInfo g_NtWow64UserModuleIterator;

HRESULT
DebuggerModuleInfo::Initialize(ThreadInfo* Thread)
{
    InitSource(Thread);
    m_Image = m_Process->m_ImageHead;
    return S_OK;
}

HRESULT
DebuggerModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Image == NULL)
    {
        return S_FALSE;
    }

    Entry->NamePtr = m_Image->m_ImagePath;
    Entry->UnicodeNamePtr = 0;
    Entry->NameLength = strlen(Entry->NamePtr);
    Entry->ModuleName = m_Image->m_ModuleName;
    Entry->File = m_Image->m_File;
    Entry->Base = m_Image->m_BaseOfImage;
    Entry->Size = m_Image->m_SizeOfImage;
    Entry->CheckSum = m_Image->m_CheckSum;
    Entry->TimeDateStamp = m_Image->m_TimeDateStamp;
    Entry->MachineType = m_Image->GetMachineType();

    Entry->ImageInfoValid = TRUE;
    Entry->ImageMachineTypeValid =
        Entry->MachineType != IMAGE_FILE_MACHINE_UNKNOWN ? TRUE : FALSE;
    Entry->UserMode = m_Image->m_UserMode;

    m_Image = m_Image->m_Next;

    return S_OK;
}

DebuggerModuleInfo g_DebuggerModuleIterator;

void
UnloadedModuleInfo::InitSource(ThreadInfo* Thread)
{
    m_Thread = Thread;
    m_Process = m_Thread->m_Process;
    m_Target = m_Process->m_Target;
    m_Machine = m_Target->m_Machine;
}
    
HRESULT
NtKernelUnloadedModuleInfo::Initialize(ThreadInfo* Thread)
{
    // Make sure that the kernel dump size doesn't exceed
    // the generic size limit.
    C_ASSERT((MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR)) + 1 <=
             MAX_INFO_UNLOADED_NAME);
    
    InitSource(Thread);

    if (m_Target->m_KdDebuggerData.MmUnloadedDrivers == 0 ||
        m_Target->m_KdDebuggerData.MmLastUnloadedDriver == 0)
    {
        return E_FAIL;
    }

    // If this is the initial module load we need to be
    // careful because much of the system isn't initialized
    // yet.  Some versions of the OS can crash when scanning
    // the unloaded module list, plus at this point we can
    // safely assume there are no unloaded modules, so just
    // don't enumerate anything.
    if (g_EngStatus & ENG_STATUS_AT_INITIAL_MODULE_LOAD)
    {
        return E_FAIL;
    }
    
    HRESULT Status;
    ULONG Read;

    if ((Status = m_Target->ReadPointer(m_Process, m_Machine,
                                        m_Target->
                                        m_KdDebuggerData.MmUnloadedDrivers,
                                        &m_Base)) != S_OK ||
        (Status = m_Target->ReadVirtual(m_Process, m_Target->
                                        m_KdDebuggerData.MmLastUnloadedDriver,
                                        &m_Index, sizeof(m_Index),
                                        &Read)) != S_OK)
    {
        return Status;
    }
    if (Read != sizeof(m_Index))
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    m_Count = 0;
    return S_OK;
}

HRESULT
NtKernelUnloadedModuleInfo::GetEntry(PSTR Name,
                                     PDEBUG_MODULE_PARAMETERS Params)
{
    if (m_Count == MI_UNLOADED_DRIVERS)
    {
        return S_FALSE;
    }

    if (m_Index == 0)
    {
        m_Index = MI_UNLOADED_DRIVERS - 1;
    }
    else
    {
        m_Index--;
    }

    ULONG64 Offset;
    ULONG Read;
    HRESULT Status;
    ULONG64 WideName;
    ULONG NameLen;

    ZeroMemory(Params, sizeof(*Params));
    Params->Flags |= DEBUG_MODULE_UNLOADED;

    if (m_Target->m_Machine->m_Ptr64)
    {
        UNLOADED_DRIVERS64 Entry;

        Offset = m_Base + m_Index * sizeof(Entry);
        if ((Status = m_Target->
             ReadAllVirtual(m_Process, Offset, &Entry, sizeof(Entry))) != S_OK)
        {
            return Status;
        }

        if (Entry.Name.Buffer == 0)
        {
            m_Count = MI_UNLOADED_DRIVERS;
            return S_FALSE;
        }

        Params->Base = Entry.StartAddress;
        Params->Size = (ULONG)(Entry.EndAddress - Entry.StartAddress);
        Params->TimeDateStamp =
            FileTimeToTimeDateStamp(Entry.CurrentTime.QuadPart);
        WideName = Entry.Name.Buffer;
        NameLen = Entry.Name.Length;
    }
    else
    {
        UNLOADED_DRIVERS32 Entry;

        Offset = m_Base + m_Index * sizeof(Entry);
        if ((Status = m_Target->
             ReadAllVirtual(m_Process, Offset, &Entry, sizeof(Entry))) != S_OK)
        {
            return Status;
        }

        if (Entry.Name.Buffer == 0)
        {
            m_Count = MI_UNLOADED_DRIVERS;
            return S_FALSE;
        }

        Params->Base = EXTEND64(Entry.StartAddress);
        Params->Size = Entry.EndAddress - Entry.StartAddress;
        Params->TimeDateStamp =
            FileTimeToTimeDateStamp(Entry.CurrentTime.QuadPart);
        WideName = EXTEND64(Entry.Name.Buffer);
        NameLen = Entry.Name.Length;
    }

    if (Name != NULL)
    {
        //
        // This size restriction is in force for minidumps only.
        // For kernel dumps, just truncate the name for now ...
        //

        if (NameLen > MAX_UNLOADED_NAME_LENGTH)
        {
            NameLen = MAX_UNLOADED_NAME_LENGTH;
        }

        WCHAR WideBuf[MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR) + 1];

        if ((Status = m_Target->
             ReadVirtual(m_Process, WideName, WideBuf, NameLen,
                         &Read)) != S_OK)
        {
            return Status;
        }

        WideBuf[NameLen / sizeof(WCHAR)] = 0;
        if (WideCharToMultiByte(CP_ACP, 0,
                                WideBuf, NameLen / sizeof(WCHAR) + 1,
                                Name,
                                MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR) + 1,
                                NULL, NULL) == 0)
        {
            return WIN32_LAST_STATUS();
        }

        Name[MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR)] = 0;
    }

    m_Count++;
    return S_OK;
}

NtKernelUnloadedModuleInfo g_NtKernelUnloadedModuleIterator;

HRESULT
NtUserUnloadedModuleInfo::Initialize(ThreadInfo* Thread)
{
    HRESULT Status;
    
    InitSource(Thread);

    if ((Status = m_Target->
         GetUnloadedModuleListHead(m_Process, &m_Base)) != S_OK)
    {
        return Status;
    }

    m_Index = 0;
    return S_OK;
}

HRESULT
NtUserUnloadedModuleInfo::GetEntry(PSTR Name,
                                   PDEBUG_MODULE_PARAMETERS Params)
{
    if (m_Index >= RTL_UNLOAD_EVENT_TRACE_NUMBER)
    {
        return S_FALSE;
    }

    ULONG64 Offset;
    HRESULT Status;
    PWSTR NameArray;
    RTL_UNLOAD_EVENT_TRACE32 Entry32;
    RTL_UNLOAD_EVENT_TRACE64 Entry64;

    // Make sure that the RTL record size doesn't exceed
    // the generic size limit.
    C_ASSERT(DIMA(Entry32.ImageName) <= MAX_INFO_UNLOADED_NAME);
    
    ZeroMemory(Params, sizeof(*Params));
    Params->Flags |= DEBUG_MODULE_UNLOADED | DEBUG_MODULE_USER_MODE;

    if (m_Machine->m_Ptr64)
    {
        Offset = m_Base + m_Index * sizeof(Entry64);
        if ((Status = m_Target->
             ReadAllVirtual(m_Process, Offset,
                            &Entry64, sizeof(Entry64))) != S_OK)
        {
            return Status;
        }

        if (Entry64.BaseAddress == 0)
        {
            m_Index = RTL_UNLOAD_EVENT_TRACE_NUMBER;
            return S_FALSE;
        }

        Params->Base = Entry64.BaseAddress;
        Params->Size = (ULONG)Entry64.SizeOfImage;
        Params->TimeDateStamp = Entry64.TimeDateStamp;
        Params->Checksum = Entry64.CheckSum;
        NameArray = Entry64.ImageName;
    }
    else
    {
        Offset = m_Base + m_Index * sizeof(Entry32);
        if ((Status = m_Target->
             ReadAllVirtual(m_Process, Offset,
                            &Entry32, sizeof(Entry32))) != S_OK)
        {
            return Status;
        }

        if (Entry32.BaseAddress == 0)
        {
            m_Index = RTL_UNLOAD_EVENT_TRACE_NUMBER;
            return S_FALSE;
        }

        Params->Base = EXTEND64(Entry32.BaseAddress);
        Params->Size = (ULONG)Entry32.SizeOfImage;
        Params->TimeDateStamp = Entry32.TimeDateStamp;
        Params->Checksum = Entry32.CheckSum;
        NameArray = Entry32.ImageName;
    }

    if (Name != NULL)
    {
        NameArray[DIMA(Entry32.ImageName) - 1] = 0;
        if (WideCharToMultiByte(CP_ACP, 0,
                                NameArray, -1,
                                Name,
                                MAX_INFO_UNLOADED_NAME,
                                NULL, NULL) == 0)
        {
            return WIN32_LAST_STATUS();
        }

        Name[MAX_INFO_UNLOADED_NAME - 1] = 0;
    }

    m_Index++;
    return S_OK;
}

NtUserUnloadedModuleInfo g_NtUserUnloadedModuleIterator;

HRESULT
ToolHelpModuleInfo::Initialize(ThreadInfo* Thread)
{
    InitSource(Thread);

    m_Snap = g_Kernel32Calls.
        CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,
                                 m_Process->m_SystemId);
    if (m_Snap == INVALID_HANDLE_VALUE)
    {
        m_Snap = NULL;
        ErrOut("Can't create snapshot\n");
        return WIN32_LAST_STATUS();
    }

    m_First = TRUE;
    m_LastId = 0;
    return S_OK;
}

HRESULT
ToolHelpModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Snap == NULL)
    {
        return S_FALSE;
    }
    
    BOOL Succ;
    MODULEENTRY32 Mod;

    Mod.dwSize = sizeof(Mod);
    if (m_First)
    {
        Succ = g_Kernel32Calls.Module32First(m_Snap, &Mod);
        m_First = FALSE;
    }
    else
    {
        // Win9x seems to require that this module ID be saved
        // between calls so stick it back in to keep Win9x happy.
        Mod.th32ModuleID = m_LastId;
        Succ = g_Kernel32Calls.Module32Next(m_Snap, &Mod);
    }
    if (!Succ)
    {
        CloseHandle(m_Snap);
        m_Snap = NULL;
        return S_FALSE;
    }

    m_LastId = Mod.th32ModuleID;
    CopyString(Entry->Buffer, Mod.szModule, DIMA(Entry->Buffer));
    Entry->NamePtr = Entry->Buffer;
    Entry->UnicodeNamePtr = 0;
    Entry->NameLength = strlen(Entry->NamePtr);
    Entry->Base = EXTEND64((ULONG_PTR)Mod.modBaseAddr);
    Entry->Size = Mod.modBaseSize;
    // Toolhelp only enumerates user-mode modules.
    Entry->UserMode = TRUE;

    //
    // Update the image informaion, such as timestamp and real image size,
    // Directly from the image header
    //

    ReadImageHeaderInfo(Entry);

    return S_OK;
}

ToolHelpModuleInfo g_ToolHelpModuleIterator;

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

BOOL
GetUserModuleListAddress(
    ThreadInfo* Thread,
    MachineInfo* Machine,
    ULONG64 Peb,
    BOOL Quiet,
    PULONG64 OrderModuleListStart,
    PULONG64 FirstEntry
    )
{
    ULONG64 PebLdrOffset;
    ULONG64 ModuleListOffset;
    ULONG64 PebLdr = 0;

    *OrderModuleListStart = 0;
    *FirstEntry = 0;

    if (!Thread || !Machine)
    {
        return FALSE;
    }
    
    //
    // Triage dumps have no user mode information.
    // User-mode minidumps don't have a loader list.
    //

    if (IS_KERNEL_TRIAGE_DUMP(Machine->m_Target) ||
        IS_USER_MINI_DUMP(Machine->m_Target))
    {
        return FALSE;
    }

    if (Machine->m_Ptr64)
    {
        PebLdrOffset     = PEBLDR_FROM_PEB64;
        ModuleListOffset = MODULE_LIST_FROM_PEBLDR64;
    }
    else
    {
        PebLdrOffset     = PEBLDR_FROM_PEB32;
        ModuleListOffset = MODULE_LIST_FROM_PEBLDR32;
    }

    if (!Peb)
    {
        if (Thread->m_Process->m_Target->
            GetImplicitProcessDataPeb(Thread, &Peb) != S_OK)
        {
            if (!Quiet)
            {
                ErrOut("Unable to get PEB pointer\n");
            }
            return FALSE;
        }
        
        if (!Peb)
        {
            // This is a common error as the idle and system process has no
            // user address space.  So only print the error if we really
            // expected to find a user mode address space:
            // The Idle and system process have a NULL parent client id - all
            // other threads have a valid ID.
            //

            ULONG64 Pcid;

            if ((Thread->m_Process->m_Target->
                 GetImplicitProcessDataParentCID(Thread, &Pcid) != S_OK) ||
                Pcid)
            {
                if (!Quiet)
                {
                    ErrOut("PEB address is NULL !\n");
                }
            }

            return FALSE;
        }
    }

    //
    // Read address the PEB Ldr data from the PEB structure
    //

    Peb += PebLdrOffset;

    if ( (Machine->m_Target->
          ReadPointer(Thread->m_Process, Machine, Peb, &PebLdr) != S_OK) ||
         (PebLdr == 0) )
    {
        if (!Quiet)
        {
            ErrOut("PEB is paged out (Peb = %s).  "
                   "Type \".hh dbgerr001\" for details\n",
                   FormatMachineAddr64(Machine, Peb));
        }
        return FALSE;
    }

    //
    // Read address of the user mode module list from the PEB Ldr Data.
    //

    PebLdr += ModuleListOffset;
    *OrderModuleListStart = PebLdr;

    if ( (Machine->m_Target->
          ReadPointer(Thread->m_Process, Machine,
                      PebLdr, FirstEntry) != S_OK) ||
         (*FirstEntry == 0) )
    {
        if (!Quiet)
        {
            ErrOut("UserMode Module List Address is NULL (Addr= %s)\n",
                   FormatMachineAddr64(Machine, PebLdr));
            ErrOut("This is usually caused by being in the wrong process\n");
            ErrOut("context or by paging\n");
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
GetModNameFromLoaderList(
    ThreadInfo* Thread,
    MachineInfo* Machine,
    ULONG64 Peb,
    ULONG64 ModuleBase,
    PSTR NameBuffer,
    ULONG BufferSize,
    BOOL FullPath
    )
{
    ULONG64 ModList;
    ULONG64 List;
    HRESULT Status;
    KLDR_DATA_TABLE_ENTRY64 Entry;
    WCHAR UnicodeBuffer[MAX_IMAGE_PATH];
    ULONG Read;

    if (!GetUserModuleListAddress(Thread, Machine, Peb, TRUE,
                                  &ModList, &List))
    {
        return FALSE;
    }

    while (List != ModList)
    {
        Status = Machine->m_Target->
            ReadLoaderEntry(Thread->m_Process, Machine, List, &Entry);
        if (Status != S_OK)
        {
            ErrOut("Unable to read LDR_DATA_TABLE_ENTRY at %s - %s\n",
                   FormatMachineAddr64(Machine, List),
                   FormatStatusCode(Status));
            return FALSE;
        }

        List = Entry.InLoadOrderLinks.Flink;

        if (Entry.DllBase == ModuleBase)
        {
            UNICODE_STRING64 Name;
            
            //
            // We found a matching entry.  Try to get the name.
            //
            if (FullPath)
            {
                Name = Entry.FullDllName;
            }
            else
            {
                Name = Entry.BaseDllName;
            }
            if (Name.Length == 0 ||
                Name.Buffer == 0 ||
                Name.Length >= sizeof(UnicodeBuffer) - sizeof(WCHAR))
            {
                return FALSE;
            }
            
            Status = Machine->m_Target->
                ReadVirtual(Thread->m_Process, Name.Buffer, UnicodeBuffer,
                            Name.Length, &Read);
            if (Status != S_OK || Read < Name.Length)
            {
                ErrOut("Unable to read name string at %s - %s\n",
                       FormatMachineAddr64(Machine, Name.Buffer),
                       FormatStatusCode(Status));
                return FALSE;
            }

            UnicodeBuffer[Name.Length / sizeof(WCHAR)] = UNICODE_NULL;

            if (!WideCharToMultiByte(CP_ACP, 0, UnicodeBuffer,
                                     Name.Length / sizeof(WCHAR) + 1,
                                     NameBuffer, BufferSize,
                                     NULL, NULL))
            {
                ErrOut("Unable to convert Unicode string %ls to ANSI\n",
                       UnicodeBuffer);
                return FALSE;
            }

            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\mmap.hpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    Manages a set of regions indexed by virtual addresses
    and backed by mapped memory.

Author:

    Matthew D Hendel (math) 16-Sept-1999

Revision History:

--*/

#ifndef __MMAP_HPP__
#define __MMAP_HPP__

#define HR_REGION_CONFLICT HRESULT_FROM_NT(STATUS_CONFLICTING_ADDRESSES)

typedef struct _MEMORY_MAP_ENTRY
{
    ULONG64 BaseOfRegion;
    ULONG SizeOfRegion;
    PVOID Region;
    PVOID UserData;
    BOOL AllowOverlap;
    struct _MEMORY_MAP_ENTRY * Next;
} MEMORY_MAP_ENTRY, * PMEMORY_MAP_ENTRY;

class MappedMemoryMap
{
public:
    MappedMemoryMap(void);
    ~MappedMemoryMap(void);

    HRESULT AddRegion(
        ULONG64 BaseOfRegion,
        ULONG SizeOfRegion,
        PVOID Buffer,
        PVOID UserData,
        BOOL AllowOverlap
        );

    BOOL ReadMemory(
        ULONG64 BaseOfRange,
        OUT PVOID Buffer,
        ULONG SizeOfRange,
        PULONG BytesRead
        );

    BOOL CheckMap(
        IN PVOID Map
        );
    
    BOOL GetRegionInfo(
        IN ULONG64 Addr,
        OUT ULONG64* BaseOfRegion, OPTIONAL
        OUT ULONG* SizeOfRegion, OPTIONAL
        OUT PVOID* Buffer, OPTIONAL
        OUT PVOID* UserData OPTIONAL
        );

    BOOL GetNextRegion(
        IN ULONG64 Addr,
        OUT PULONG64 Next
        );
    
    BOOL RemoveRegion(
        IN ULONG64 BaseOfRegion,
        IN ULONG SizeOfRegion
        );

    BOOL GetRegionByUserData(
        IN PVOID UserData,
        OUT PULONG64 Base,
        OUT PULONG Size
        );
    
private:
    PMEMORY_MAP_ENTRY AddMapEntry(ULONG64 BaseOfRegion, ULONG SizeOfRegion,
                                  PVOID Buffer, PVOID UserData,
                                  BOOL AllowOverlap);
    PMEMORY_MAP_ENTRY FindPreceedingRegion(ULONG64 Addr);
    PMEMORY_MAP_ENTRY FindContainingRegion(ULONG64 Addr);

    PMEMORY_MAP_ENTRY m_List;
    ULONG m_RegionCount;
};

#endif // #ifndef __MMAP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\mmap.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    mmap.cpp

Abstract:

    Implementation of memory map class.
    
Author:

    Matthew D Hendel (math) 16-Sep-1999

Revision History:

--*/


#include "ntsdp.hpp"

MappedMemoryMap::MappedMemoryMap(void)
{
    m_RegionCount = 0;
    m_List = NULL;
}

MappedMemoryMap::~MappedMemoryMap(void)
{
    PMEMORY_MAP_ENTRY Entry;
    PMEMORY_MAP_ENTRY Next;

    Entry = m_List;
    while ( Entry != NULL )
    {
        Next = Entry->Next;
        free ( Entry );
        Entry = Next;
    }
}

PMEMORY_MAP_ENTRY
MappedMemoryMap::AddMapEntry(ULONG64 BaseOfRegion, ULONG SizeOfRegion,
                             PVOID Buffer, PVOID UserData,
                             BOOL AllowOverlap)
{
    PMEMORY_MAP_ENTRY PrevEntry;
    PMEMORY_MAP_ENTRY MapEntry;
    
    MapEntry = (MEMORY_MAP_ENTRY *)malloc ( sizeof ( MEMORY_MAP_ENTRY ) );
    if (!MapEntry)
    {
        return NULL;
    }

    MapEntry->BaseOfRegion = BaseOfRegion;
    MapEntry->SizeOfRegion = SizeOfRegion;
    MapEntry->Region = Buffer;
    MapEntry->UserData = UserData;
    MapEntry->AllowOverlap = AllowOverlap;
    MapEntry->Next = NULL;

    //
    // Insert the element.
    //

    PrevEntry = FindPreceedingRegion(BaseOfRegion);
    if ( PrevEntry == NULL )
    {
        //
        // Insert at head.
        //
        
        MapEntry->Next = m_List;
        m_List = MapEntry;
    }
    else
    {
        //
        // Insert in order.
        //
        
        MapEntry->Next = PrevEntry->Next;
        PrevEntry->Next = MapEntry;
    }

    m_RegionCount++;

    return MapEntry;
}
    
HRESULT
MappedMemoryMap::AddRegion(
    IN ULONG64 BaseOfRegion,
    IN ULONG SizeOfRegion,
    IN PVOID Buffer,
    IN PVOID UserData,
    IN BOOL AllowOverlap
    )
{
    //
    // The region size cannot be zero.
    //
    
    if (SizeOfRegion == 0)
    {
        ErrOut("**** MappedMemoryMap::AddRegion: Empty region being added.\n");
        return S_OK;
    }

    if (IsBadReadPtr(Buffer, SizeOfRegion))
    {
        ErrOut("**** MappedMemoryMap::AddRegion: Mapping too small to map "
               "%s:%X from %p\n", FormatAddr64(BaseOfRegion),
               SizeOfRegion, Buffer);
        return E_INVALIDARG;
    }

    ULONG64 EndOfRegion;
    PMEMORY_MAP_ENTRY Entry;
    ULONG Size;

    while (SizeOfRegion > 0)
    {
        //
        // Find the first overlapping region.
        // We need to rescan the whole list as it
        // may have changed due to insertion of fragments
        // of the new region.
        //
        
        EndOfRegion = BaseOfRegion + SizeOfRegion;
        for (Entry = m_List; Entry != NULL; Entry = Entry->Next)
        {
            if (EndOfRegion > Entry->BaseOfRegion &&
                Entry->BaseOfRegion >= BaseOfRegion)
            {
                if (AllowOverlap || Entry->AllowOverlap)
                {
                    // Overlap can occur when a stack, ethread or
                    // eprocess is taken from static data in an image.
                    // For example, the x86 idle process is static
                    // data in ntoskrnl.  Triage dumps contain the
                    // eprocess data and it gets mapped and can overlap
                    // with the ntoskrnl image.
#if 0
                    WarnOut("WARNING: Allowing overlapped region %s - %s\n",
                            FormatAddr64(BaseOfRegion),
                            FormatAddr64(BaseOfRegion + SizeOfRegion - 1));
#endif
                    Entry = NULL;
                }

                break;
            }
        }

        if (Entry == NULL ||
            BaseOfRegion < Entry->BaseOfRegion)
        {
            // There's a portion of the beginning of the new
            // region which does not overlap so add it and
            // trim the description.
        
            Size = Entry == NULL ? SizeOfRegion :
                (ULONG)(Entry->BaseOfRegion - BaseOfRegion);
            if (!AddMapEntry(BaseOfRegion, Size, Buffer, UserData,
                             AllowOverlap))
            {
                return E_OUTOFMEMORY;
            }

            if (Size == SizeOfRegion)
            {
                // None of the region overlapped so we're done.
                return S_OK;
            }
        
            BaseOfRegion += Size;
            SizeOfRegion -= Size;
            Buffer = (PUCHAR)Buffer + Size;
        }

        //
        // Now handle the overlap.
        //

        if (SizeOfRegion > Entry->SizeOfRegion)
        {
            Size = Entry->SizeOfRegion;
        }
        else
        {
            Size = SizeOfRegion;
        }

        int Compare;
        
        __try
        {
            Compare = memcmp(Buffer, Entry->Region, Size);
        }
        __except(MappingExceptionFilter(GetExceptionInformation()))
        {
            return HRESULT_FROM_NT(GetExceptionCode());
        }

        if (Compare)
        {
            ErrOut("**** MappedMemoryMap::AddRegion: "
                   "Conflicting region %s - %s\n",
                   FormatAddr64(BaseOfRegion),
                   FormatAddr64(BaseOfRegion + SizeOfRegion - 1));
            return HR_REGION_CONFLICT;
        }

        // Overlap region data matched so it's OK to just
        // trim the overlap out of the new region and move
        // on to the next possible overlap.
        BaseOfRegion += Size;
        SizeOfRegion -= Size;
        Buffer = (PUCHAR)Buffer + Size;
    }
    
    return S_OK;
}

BOOL
MappedMemoryMap::ReadMemory(
    IN ULONG64 BaseOfRange,
    IN OUT PVOID Buffer,
    IN ULONG SizeOfRange,
    OUT ULONG * BytesRead
    )

/*++

Routine Description:

    Read memory from the memory map. ReadMemory can read across regions, as
    long as there is no unallocated space between regions.

    This routine will do a partial read if the region ends before
    SizeOfRange bytes have been read. In that case BytesRead will return the
    number of bytes actually read.

Arguments:

    BaseOfRange - The base address where we want to read memory from.

    SizeOfRange - The length of the region to read memory from.

    Buffer - A pointer to a buffer to read memory into.

    BytesRead - On success, the number of bytes successfully read.

Return Values:

    TRUE - If any number of bytes were successfully read from the memory map.

    FALSE - If no bytes were read.

--*/

{
    ULONG BytesToReadFromRegion;
    PMEMORY_MAP_ENTRY Entry;
    ULONG64 BaseToRead;
    ULONG SizeToRead;
    PBYTE BufferForRead;
    ULONG_PTR OffsetToRead;
    ULONG AvailSize;

    //
    // We return TRUE if we read any bytes successfully and FALSE if not.
    //

    *BytesRead = 0;
    
    BaseToRead = BaseOfRange;
    SizeToRead = SizeOfRange;
    BufferForRead = (PBYTE) Buffer;

    do
    {
        Entry = FindContainingRegion(BaseToRead);

        if ( !Entry )
        {
            if (*BytesRead)
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }

        PMEMORY_MAP_ENTRY NextEntry = Entry->Next;
        
        // Due to overlap there may be other entries
        // that need to be processed even before the
        // end of the containing region.
        AvailSize = Entry->SizeOfRegion;
        while (NextEntry != NULL)
        {
            if (NextEntry->BaseOfRegion > BaseToRead)
            {
                ULONG64 EntryDiff =
                    NextEntry->BaseOfRegion - Entry->BaseOfRegion;
                if (EntryDiff < AvailSize)
                {
                    AvailSize = (ULONG)EntryDiff;
                }
                break;
            }

            NextEntry = NextEntry->Next;
        }

        if (BaseToRead + SizeToRead > Entry->BaseOfRegion + AvailSize)
        {
            BytesToReadFromRegion = (ULONG)
                (Entry->BaseOfRegion - BaseToRead) + AvailSize;
        }
        else
        {
            BytesToReadFromRegion = SizeToRead;
        }

        OffsetToRead = (ULONG_PTR) (BaseToRead - Entry->BaseOfRegion);

        __try
        {
            RtlCopyMemory (BufferForRead,
                           (PBYTE)Entry->Region + OffsetToRead,
                           BytesToReadFromRegion
                           );
        }
        __except(MappingExceptionFilter(GetExceptionInformation()))
        {
            return FALSE;
        }

        *BytesRead += BytesToReadFromRegion;
        BaseToRead += BytesToReadFromRegion;
        SizeToRead -= BytesToReadFromRegion;
        BufferForRead += BytesToReadFromRegion;
    } while ( SizeToRead );

    return TRUE;
}
        
BOOL
MappedMemoryMap::GetRegionInfo(
    IN ULONG64 Addr,
    OUT ULONG64* BaseOfRegion, OPTIONAL
    OUT ULONG* SizeOfRegion, OPTIONAL
    OUT PVOID* Buffer, OPTIONAL
    OUT PVOID* UserData OPTIONAL
    )

/*++

Routine Description:

    Get information about the region containing the address Addr.

Arguments:

    Addr - An address that is contained within some region in the map.

    BaseOfRegion - Pointer to a buffer to return the region base.

    SizeOfRegion - Pointer to a buffer to retutn the region size.

    Buffer - Pointer to a buffer to return the region buffer pointer.

    UserData - Pointer to a buffer to return the region client param.

Return Values:

    TRUE - On success.

    FALSE - On failure.

--*/

{
    PMEMORY_MAP_ENTRY Entry;

    Entry = FindContainingRegion(Addr);

    if ( !Entry )
    {
        return FALSE;
    }

    if ( BaseOfRegion )
    {
        *BaseOfRegion = Entry->BaseOfRegion;
    }

    if ( SizeOfRegion )
    {
        *SizeOfRegion = Entry->SizeOfRegion;
    }

    if ( Buffer )
    {
        *Buffer = Entry->Region;
    }

    if ( UserData )
    {
        *UserData = Entry->UserData;
    }

    return TRUE;
}

BOOL
MappedMemoryMap::GetNextRegion(
    IN ULONG64 Addr,
    OUT PULONG64 Next
    )
{
    PMEMORY_MAP_ENTRY Entry;

    Entry = m_List;
    while (Entry != NULL)
    {
        //
        // Assuming they're in order.
        //
        
        if (Entry->BaseOfRegion > Addr)
        {
            *Next = Entry->BaseOfRegion;
            return TRUE;
        }

        Entry = Entry->Next;
    }

    return FALSE;
}
 
BOOL
MappedMemoryMap::RemoveRegion(
    IN ULONG64 BaseOfRegion,
    IN ULONG SizeOfRegion
    )
{
    // XXX drewb - This should carve the given region out of
    // any existing regions.  Right now we don't need general
    // removal functionality though so only handle the case
    // where the requested removal is an exact single region
    // match.

    PMEMORY_MAP_ENTRY PrevEntry;
    PMEMORY_MAP_ENTRY Entry;

    PrevEntry = FindPreceedingRegion(BaseOfRegion);
    if (PrevEntry != NULL)
    {
        Entry = PrevEntry->Next;
    }
    else
    {
        Entry = m_List;
    }

    if (Entry == NULL)
    {
        ErrOut("MappedMemoryMap::RemoveRegion NULL region for %s:%x\n",
               FormatAddr64(BaseOfRegion), SizeOfRegion);
        return FALSE;
    }
    else if (Entry->BaseOfRegion != BaseOfRegion ||
             Entry->SizeOfRegion != SizeOfRegion)
    {
        ErrOut("MappedMemoryMap::RemoveRegion region mismatch: "
               "%s:%x vs. entry %s:%x\n",
               FormatAddr64(BaseOfRegion), SizeOfRegion,
               FormatAddr64(Entry->BaseOfRegion), Entry->SizeOfRegion);
        return FALSE;
    }

    if (PrevEntry == NULL)
    {
        m_List = Entry->Next;
    }
    else
    {
        PrevEntry->Next = Entry->Next;
    }
    free(Entry);
    m_RegionCount--;

    return TRUE;
}

BOOL
MappedMemoryMap::GetRegionByUserData(
    IN PVOID UserData,
    OUT PULONG64 Base,
    OUT PULONG Size
    )
{
    PMEMORY_MAP_ENTRY Entry;

    Entry = m_List;
    while (Entry != NULL)
    {
        if (Entry->UserData == UserData)
        {
            *Base = Entry->BaseOfRegion;
            *Size = Entry->SizeOfRegion;
            return TRUE;
        }

        Entry = Entry->Next;
    }

    return FALSE;
}
    
//
// Private functions
//

PMEMORY_MAP_ENTRY
MappedMemoryMap::FindPreceedingRegion(
    IN ULONG64 BaseOfRegion
    )
{
    PMEMORY_MAP_ENTRY PrevEntry;
    PMEMORY_MAP_ENTRY Entry;

    PrevEntry = NULL;
    Entry = m_List;

    while (Entry != NULL)
    {
        //
        // Assuming they're in order.
        //
        
        if ( Entry->BaseOfRegion >= BaseOfRegion )
        {
            return PrevEntry;
        }

        PrevEntry = Entry;
        Entry = Entry->Next;
    }

    return PrevEntry;
}

PMEMORY_MAP_ENTRY
MappedMemoryMap::FindContainingRegion(
    IN ULONG64 Addr
    )
{
    PMEMORY_MAP_ENTRY Entry;
    PMEMORY_MAP_ENTRY ReturnEntry = NULL;

    Entry = m_List;

    //
    // We may have overlapping regions, so keep going until we find
    // the most precise one (assumed to be the one we care about)
    //

    while ( Entry != NULL )
    {
        if ( Entry->BaseOfRegion <= Addr &&
             Addr < Entry->BaseOfRegion + Entry->SizeOfRegion)
        {
            ReturnEntry = Entry;
        }
        else if (ReturnEntry != NULL &&
                 Addr >= ReturnEntry->BaseOfRegion + ReturnEntry->SizeOfRegion)
        {
            // Optimization - we can stop searching if we've already
            // found a block and have now left its region.  We can't
            // stop as long as we're in its region as there may
            // be more exact overlaps anywhere within the entire region.
            break;
        }

        Entry = Entry->Next;
    }

    return ReturnEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ntcmd.h ===
//----------------------------------------------------------------------------
//
// ntcmd.h
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _NTCMD_H_
#define _NTCMD_H_

#define HR_PROCESS_EXCEPTION EVENT_E_INTERNALEXCEPTION

#define IS_RUNNING(CmdState) \
    ((CmdState) == 'g' || (CmdState) == 'p' || \
     (CmdState) == 't' || (CmdState) == 'b')
#define IS_STEP_TRACE(CmdState) \
    ((CmdState) == 'p' || (CmdState) == 't' || (CmdState) == 'b')
#define SPECIAL_EXECUTION(CmdState) \
    ((CmdState) == 's' || (CmdState) == 'e')

extern BOOL    g_OciOutputRegs;
extern PSTR    g_CommandStart;
extern PSTR    g_CurCmd;
extern ULONG   g_PromptLength;
extern CHAR    g_LastCommand[];
extern CHAR    g_CmdState;
extern CHAR    g_SymbolSuffix;
extern ULONG   g_DefaultRadix;
extern ADDR    g_UnasmDefault;
extern ADDR    g_AssemDefault;
extern BOOL    g_SwitchedProcs;
extern API_VERSION g_NtsdApiVersion;
extern ULONG   g_DefaultStackTraceDepth;
extern BOOL    g_EchoEventTimestamps;
extern PWSTR   g_StartProcessDir;

#define COMMAND_EXCEPTION_BASE 0x0dbcd000

BOOL ChangeSymPath(PCSTR Args,
                   BOOL Append,
                   PSTR PathRet,
                   ULONG PathRetChars);

void ParseStackTrace(PULONG TraceFlags,
                     PULONG64 Frame,
                     PULONG64 Stack,
                     PULONG64 Instr,
                     PULONG Count,
                     PULONG PtrDef);

extern void OutputVersionInformation(DebugClient* Client);
extern DWORD CommandExceptionFilter(PEXCEPTION_POINTERS Info);
extern HRESULT ProcessCommands(DebugClient* Client, BOOL Nested);
extern HRESULT ProcessCommandsAndCatch(DebugClient* Client);
extern HRESULT GetPromptText(PSTR Buffer, ULONG BufferSize, PULONG TextSize);
extern void OutputPrompt(PCSTR Format, va_list Args);

void HandleBPWithStatus(void);
void CallBugCheckExtension(DebugClient* Client);

#endif // #ifndef _NTCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\modinfo.hpp ===
//----------------------------------------------------------------------------
//
// Module list abstraction.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#ifndef __MODINFO_HPP__
#define __MODINFO_HPP__

//----------------------------------------------------------------------------
//
// ModuleInfo hierarchy.
//
//----------------------------------------------------------------------------

// If the image header is paged out the true values for
// certain fields cannot be retrieved.  These placeholders
// are used instead.
#define UNKNOWN_CHECKSUM 0xffffffff
#define UNKNOWN_TIMESTAMP 0xfffffffe

typedef struct _MODULE_INFO_ENTRY
{
    // NamePtr should include a path if one is available.
    // It is the responsibility of callers to find the
    // file tail if that's all they care about.
    // If UnicodeNamePtr is false NameLength is ignored.
    PSTR NamePtr;
    ULONG UnicodeNamePtr:1;
    ULONG ImageInfoValid:1;
    ULONG ImageInfoPartial:1;
    ULONG ImageDebugHeader:1;
    ULONG ImageVersionValid:1;
    ULONG ImageMachineTypeValid:1;
    ULONG UserMode:1;
    ULONG Unused:25;
    // Length in bytes not including the terminator.
    ULONG NameLength;
    PSTR ModuleName;
    HANDLE File;
    ULONG64 Base;
    ULONG Size;
    ULONG SizeOfCode;
    ULONG SizeOfData;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    USHORT MajorImageVersion;
    USHORT MinorImageVersion;
    ULONG MachineType;
    PVOID DebugHeader;
    ULONG SizeOfDebugHeader;
    CHAR Buffer[MAX_IMAGE_PATH * sizeof(WCHAR)];
} MODULE_INFO_ENTRY, *PMODULE_INFO_ENTRY;

enum MODULE_INFO_LEVEL
{
    // Only the base and size are guaranteed to be valid.
    MODULE_INFO_BASE_SIZE,
    // Attempt to retrieve all available information.
    MODULE_INFO_ALL,
};

class ModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread) = 0;
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry) = 0;
    // Base implementation does nothing.

    // Updates the entry image info by reading the
    // image header.
    void ReadImageHeaderInfo(PMODULE_INFO_ENTRY Entry);

    void InitSource(ThreadInfo* Thread);
    
    TargetInfo* m_Target;
    MachineInfo* m_Machine;
    ProcessInfo* m_Process;
    ThreadInfo* m_Thread;
    MODULE_INFO_LEVEL m_InfoLevel;
};

class NtModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

protected:
    ULONG64 m_Head;
    ULONG64 m_Cur;
};

class NtKernelModuleInfo : public NtModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);
};

extern NtKernelModuleInfo g_NtKernelModuleIterator;

class NtUserModuleInfo : public NtModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

protected:
    ULONG64 m_Peb;
};

class NtTargetUserModuleInfo : public NtUserModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
};

extern NtTargetUserModuleInfo g_NtTargetUserModuleIterator;

class NtWow64UserModuleInfo : public NtUserModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);

private:
    HRESULT GetPeb32(PULONG64 Peb32);
};

extern NtWow64UserModuleInfo g_NtWow64UserModuleIterator;

class DebuggerModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

private:
    ImageInfo* m_Image;
};

extern DebuggerModuleInfo g_DebuggerModuleIterator;

//
// Define a generic maximum unloaded name length for all
// callers of the unloaded iterators.  This includes the terminator.
//
// Kernel mode dumps define a limit (MAX_UNLOADED_NAME_LENGTH) which
// works out to 13 characters.
//
// User-mode is currently limited to 32 characters.
//
// Pick a value which exceeds both to allow room for either.
//

#define MAX_INFO_UNLOADED_NAME 32

class UnloadedModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread) = 0;
    virtual HRESULT GetEntry(PSTR Name, PDEBUG_MODULE_PARAMETERS Params) = 0;

    void InitSource(ThreadInfo* Thread);
    
    TargetInfo* m_Target;
    MachineInfo* m_Machine;
    ProcessInfo* m_Process;
    ThreadInfo* m_Thread;
};

class NtKernelUnloadedModuleInfo : public UnloadedModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PSTR Name, PDEBUG_MODULE_PARAMETERS Params);

protected:
    ULONG64 m_Base;
    ULONG m_Index;
    ULONG m_Count;
};

extern NtKernelUnloadedModuleInfo g_NtKernelUnloadedModuleIterator;

class NtUserUnloadedModuleInfo : public UnloadedModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PSTR Name, PDEBUG_MODULE_PARAMETERS Params);

protected:
    ULONG64 m_Base;
    ULONG m_Index;
};

extern NtUserUnloadedModuleInfo g_NtUserUnloadedModuleIterator;

class ToolHelpModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

protected:
    HANDLE m_Snap;
    BOOL m_First;
    ULONG m_LastId;
};

extern ToolHelpModuleInfo g_ToolHelpModuleIterator;

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

BOOL
GetUserModuleListAddress(
    ThreadInfo* Thread,
    MachineInfo* Machine,
    ULONG64 Peb,
    BOOL Quiet,
    PULONG64 OrderModuleListStart,
    PULONG64 FirstEntry
    );

BOOL
GetModNameFromLoaderList(
    ThreadInfo* Thread,
    MachineInfo* Machine,
    ULONG64 Peb,
    ULONG64 ModuleBase,
    PSTR NameBuffer,
    ULONG BufferSize,
    BOOL FullPath
    );

void
ConvertLoaderEntry32To64(
    PKLDR_DATA_TABLE_ENTRY32 b32,
    PKLDR_DATA_TABLE_ENTRY64 b64
    );

#endif // #ifndef __MODINFO_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ntcmd.cpp ===
//----------------------------------------------------------------------------
//
// Top-level command parsing.
//
// Copyright (C) Microsoft Corporation, 1990-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// Set if registers should be displayed by default in OutCurInfo.
BOOL g_OciOutputRegs;

ULONG g_DefaultStackTraceDepth = 20;

BOOL g_EchoEventTimestamps;

BOOL g_SwitchedProcs;

// Last command executed.
CHAR g_LastCommand[MAX_COMMAND];

// State variables for top-level command processing.
PSTR g_CommandStart;            // Start of command buffer.
PSTR g_CurCmd;                  // Current pointer in command buffer.
ULONG g_PromptLength = 8;       // Size of prompt string.

ADDR g_UnasmDefault;            // Default unassembly address.
ADDR g_AssemDefault;            // Default assembly address.

ULONG g_DefaultRadix = 16;      // Default number base.

CHAR g_SymbolSuffix = 'n';      // Suffix to add to symbol if search
                                // failure - 'n'-none 'a'-'w'-append.

CHAR g_CmdState = 'i';          // State of present command processing
                                // 'i'-init; 'g'-go; 't'-trace
                                // 'p'-step; 'c'-cmd; 'b'-branch trace.

int g_RedoCount = 0;

PWSTR g_StartProcessDir;

BOOL
ChangeSymPath(PCSTR Args,
              BOOL Append,
              OUT PSTR PathRet,
              ULONG PathRetChars)
{
    TargetInfo* Target;
    ProcessInfo* Process;

    if (Args != NULL)
    {
        while (*Args == ' ' || *Args == '\t')
        {
            Args++;
        }
    }
    if (Args != NULL && *Args)
    {
        if (ChangePath(&g_SymbolSearchPath, Args, Append,
                       DEBUG_CSS_PATHS) != S_OK)
        {
            return FALSE;
        }

        ForAllLayersToProcess()
        {
            SymSetSearchPath(Process->m_SymHandle, g_SymbolSearchPath);
        }
    }

    if (PathRet)
    {
        CopyString(PathRet, g_SymbolSearchPath, PathRetChars);
    }
    else
    {
        dprintf("Symbol search path is: %s\n", g_SymbolSearchPath);
        CheckPath(g_SymbolSearchPath);
    }

    return TRUE;
}

void
CallBugCheckExtension(DebugClient* Client)
{
    HRESULT Status = E_FAIL;

    if (Client == NULL)
    {
        Client = FindExtClient();
    }
    
    if (Client != NULL)
    {
        char ExtName[32];

        // Extension name has to be in writable memory as it
        // gets lower-cased.
        strcpy(ExtName, "Analyze");
        
        // See if any existing extension DLLs are interested
        // in analyzing this bugcheck.
        CallAnyExtension(Client, NULL, ExtName, "",
                         FALSE, FALSE, &Status);
    }

    if (Status != S_OK)
    {
        if (Client == NULL)
        {
            WarnOut("WARNING: Unable to locate a client for "
                    "bugcheck analysis\n");
        }
        
        dprintf("*******************************************************************************\n");
        dprintf("*                                                                             *\n");
        dprintf("*                        Bugcheck Analysis                                    *\n");
        dprintf("*                                                                             *\n");
        dprintf("*******************************************************************************\n");

        Execute(Client, ".bugcheck", DEBUG_EXECUTE_DEFAULT);
        dprintf("\n");
        Execute(Client, "kb", DEBUG_EXECUTE_DEFAULT);
        dprintf("\n");
    }
}

void
HandleBPWithStatus(void)
{
    ULONG Status = (ULONG)g_EventMachine->GetArgReg();

    switch(Status)
    {
    case DBG_STATUS_CONTROL_C:
    case DBG_STATUS_SYSRQ:
        if ((g_EngOptions & DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION) == 0 &&
            !g_QuietMode)
        {
            dprintf("*******************************************************************************\n");
            dprintf("*                                                                             *\n");

            if (Status == DBG_STATUS_SYSRQ)
            {
                dprintf("*   You are seeing this message because you pressed the SysRq/PrintScreen     *\n");
                dprintf("*   key on your test machine's keyboard.                                      *\n");
            }

            if (Status == DBG_STATUS_DEBUG_CONTROL)
            {
                dprintf("*   You are seeing this message because you typed in .breakin from ntsd.      *\n");
            }

            if (Status == DBG_STATUS_CONTROL_C)
            {
                dprintf("*   You are seeing this message because you pressed either                    *\n");
                dprintf("*       CTRL+C (if you run kd.exe) or,                                        *\n");
                dprintf("*       CTRL+BREAK (if you run WinDBG),                                       *\n");
                dprintf("*   on your debugger machine's keyboard.                                      *\n");

            }

            dprintf("*                                                                             *\n");
            dprintf("*                   THIS IS NOT A BUG OR A SYSTEM CRASH                       *\n");
            dprintf("*                                                                             *\n");
            dprintf("* If you did not intend to break into the debugger, press the \"g\" key, then   *\n");
            dprintf("* press the \"Enter\" key now.  This message might immediately reappear.  If it *\n");
            dprintf("* does, press \"g\" and \"Enter\" again.                                          *\n");
            dprintf("*                                                                             *\n");
            dprintf("*******************************************************************************\n");
        }
        break;

    case DBG_STATUS_BUGCHECK_FIRST:
        ErrOut("\nA fatal system error has occurred.\n");
        ErrOut("Debugger entered on first try; "
               "Bugcheck callbacks have not been invoked.\n");
        // Fall through.

    case DBG_STATUS_BUGCHECK_SECOND:
        ErrOut("\nA fatal system error has occurred.\n\n");
        CallBugCheckExtension(NULL);
        break;

    case DBG_STATUS_FATAL:
        // hals call KeEnterDebugger when they panic.
        break;
    }
}

#define MAX_PROMPT 32

HRESULT
GetPromptText(PSTR Buffer, ULONG BufferSize, PULONG TextSize)
{
    char Prompt[MAX_PROMPT];
    PSTR Text = Prompt;

    if (g_NumberTargets > 1)
    {
        *Text++ = '|';
        *Text++ = '|';
        if (g_Target)
        {
            sprintf(Text, "%1ld:", g_Target->m_UserId);
            Text += strlen(Text);
        }
        else
        {
            *Text++ = '?';
            *Text++ = ':';
        }
    }
        
    if (IS_LOCAL_KERNEL_TARGET(g_Target))
    {
        strcpy(Text, "lkd");
        Text += 3;
    }
    else if (IS_KERNEL_TARGET(g_Target))
    {
        if (g_X86InVm86)
        {
            strcpy(Text, "vm");
            Text += 2;
        }
        else if (g_X86InCode16)
        {
            strcpy(Text, "16");
            Text += 2;
        }
        else if (g_Target &&
                 g_Target->m_MachineType == IMAGE_FILE_MACHINE_AMD64 &&
                 !g_Amd64InCode64)
        {
            strcpy(Text, "32");
            Text += 2;
        }

        if (g_Target == NULL ||
            g_Process == NULL ||
            g_Thread == NULL ||
            ((IS_KERNEL_FULL_DUMP(g_Target) ||
              IS_KERNEL_SUMMARY_DUMP(g_Target)) &&
              g_Target->m_KdDebuggerData.KiProcessorBlock == 0))
        {
            strcpy(Text, "?: kd");
            Text += 5;
        }
        else if (g_Target->m_NumProcessors > 1)
        {
            sprintf(Text, "%d: kd", CURRENT_PROC);
            Text += strlen(Text);
        }
        else
        {
            strcpy(Text, "kd");
            Text += 2;
        }
    }
    else if (IS_USER_TARGET(g_Target))
    {
        if (g_Process)
        {
            sprintf(Text, "%1ld:", g_Process->m_UserId);
            Text += strlen(Text);
        }
        else
        {
            *Text++ = '?';
            *Text++ = ':';
        }
            
        if (g_Thread)
        {
            sprintf(Text, "%03ld", g_Thread->m_UserId);
            Text += strlen(Text);
        }
        else
        {
            strcpy(Text, "???");
            Text += 3;
        }
    }
    else
    {
        strcpy(Text, "NoTarget");
        Text += 8;
    }

    if (g_Machine && g_Target &&
        g_Machine->m_ExecTypes[0] != g_Target->m_MachineType)
    {
        *Text++ = ':';
        strcpy(Text, g_Machine->m_AbbrevName);
        Text += strlen(Text);
    }
    
    *Text++ = '>';
    *Text = 0;
    
    return FillStringBuffer(Prompt, (ULONG)(Text - Prompt) + 1,
                            Buffer, BufferSize, TextSize);
}

void
OutputPrompt(PCSTR Format, va_list Args)
{
    char Prompt[MAX_PROMPT];

    GetPromptText(Prompt, sizeof(Prompt), NULL);
    g_PromptLength = strlen(Prompt);

    MaskOut(DEBUG_OUTPUT_PROMPT, "%s", Prompt);
    // Include space after >.
    g_PromptLength++;
    if (Format != NULL)
    {
        MaskOutVa(DEBUG_OUTPUT_PROMPT, Format, Args, TRUE);
    }
}
 
DWORD
CommandExceptionFilter(PEXCEPTION_POINTERS Info)
{
    if (Info->ExceptionRecord->ExceptionCode >=
        (COMMAND_EXCEPTION_BASE + OVERFLOW) &&
        Info->ExceptionRecord->ExceptionCode
        <= (COMMAND_EXCEPTION_BASE + UNIMPLEMENT))
    {
        // This is a legitimate command error code exception.
        return EXCEPTION_EXECUTE_HANDLER;
    }
    else
    {
        // This is some other exception that the command
        // filter isn't supposed to handle.
        ErrOut("Non-command exception %X at %s in command filter\n",
               Info->ExceptionRecord->ExceptionCode,
               FormatAddr64((ULONG64)Info->ExceptionRecord->ExceptionAddress));
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

void
ParseLoadModules(void)
{
    ImageInfo* Image;
    PSTR Pattern;
    CHAR Save;
    BOOL AnyMatched = FALSE;

    if (!g_Process)
    {
        error(BADPROCESS);
    }
    
    Pattern = 
        StringValue(STRV_SPACE_IS_SEPARATOR | STRV_TRIM_TRAILING_SPACE |
                    STRV_ESCAPED_CHARACTERS, &Save);
    _strupr(Pattern);
    
    for (Image = g_Process->m_ImageHead; Image; Image = Image->m_Next)
    {
        if (MatchPattern(Image->m_ModuleName, Pattern))
        {
            IMAGEHLP_MODULE64 ModInfo;
            
            AnyMatched = TRUE;

            ModInfo.SizeOfStruct = sizeof(ModInfo);
            if (!SymGetModuleInfo64(g_Process->m_SymHandle,
                                    Image->m_BaseOfImage, &ModInfo) ||
                ModInfo.SymType == SymDeferred)
            {
                if (!SymLoadModule64(g_Process->m_SymHandle,
                                     NULL, NULL, NULL,
                                     Image->m_BaseOfImage, 0))
                {
                    ErrOut("Symbol load for %s failed\n", Image->m_ModuleName);
                }
                else
                {
                    dprintf("Symbols loaded for %s\n", Image->m_ModuleName);
                }
            }
            else
            {
                dprintf("Symbols already loaded for %s\n",
                        Image->m_ModuleName);
            }
        }

        if (CheckUserInterrupt())
        {
            break;
        }
    }

    if (!AnyMatched)
    {
        WarnOut("No modules matched '%s'\n", Pattern);
    }
    
    *g_CurCmd = Save;
}

void
ParseProcessorCommands(void)
{
    ULONG Proc;
    PSTR Start = g_CurCmd;

    if (!g_Target)
    {
        error(BADSYSTEM);
    }
        
    Proc = 0;
    while (*g_CurCmd >= '0' && *g_CurCmd <= '9')
    {
        Proc = Proc * 10 + (*g_CurCmd - '0');
        g_CurCmd++;
    }
    if (Start == g_CurCmd)
    {
        // No digits.
        error(SYNTAX);
    }
    if (*g_CurCmd == 's')
    {
        g_CurCmd++;
    }

    if (Proc < g_Target->m_NumProcessors)
    {
        if (Proc != g_Target->m_RegContextProcessor)
        {
            if (g_Target->SwitchProcessors(Proc) == S_OK)
            {
                ResetCurrentScope();
            }
        }
    }
    else
    {
        ErrOut("%d is not a valid processor number\n", Proc);
    }
}

void
SetSuffix(void)
{
    char Ch;

    Ch = PeekChar();
    Ch = (UCHAR)tolower(Ch);

    if (Ch == ';' || Ch == '\0')
    {
        if (g_SymbolSuffix == 'n')
        {
            dprintf("n - no suffix\n");
        }
        else if (g_SymbolSuffix == 'a')
        {
            dprintf("a - ascii\n");
        }
        else
        {
            dprintf("w - wide\n");
        }
    }
    else if (Ch == 'n' || Ch == 'a' || Ch == 'w')
    {
        g_SymbolSuffix = Ch;
        g_CurCmd++;
    }
    else
    {
        error(SYNTAX);
    }
}

void
OutputVersionInformation(DebugClient* Client)
{
    DBH_DIAVERSION DiaVer;
    
    //
    // Print out the connection options if we are doing live debugging.
    //
    if (g_Target)
    {
        char Buf[2 * MAX_PATH];
        
        g_Target->GetDescription(Buf, sizeof(Buf), NULL);
        dprintf("%s\n", Buf);
    }
            
    dprintf("command line: '%s'  Debugger Process 0x%X \n",
            GetCommandLine(), GetCurrentProcessId());

    dprintf(ENGINE_MOD_NAME ":  ");
    OutputModuleIdInfo(NULL, ENGINE_DLL_NAME, NULL);

    CheckForStaleBinary(ENGINE_DLL_NAME, TRUE);
    
    dprintf("dbghelp: ");
    OutputModuleIdInfo(NULL, "dbghelp.dll", NULL);

    DiaVer.function = dbhDiaVersion;
    DiaVer.sizeofstruct = sizeof(DiaVer);
    if (dbghelp(NULL, &DiaVer))
    {
        dprintf("        DIA version: %d\n", DiaVer.ver);
    }

    // Dump information about the IA64 support DLLs if they're
    // loaded.  Don't bother forcing them to load.
    if (GetModuleHandle("decem.dll") != NULL)
    {
        dprintf("decem:   ");
        OutputModuleIdInfo(NULL, "decem.dll", NULL);
    }

    OutputExtensions(Client, TRUE);

    if (g_Wow64exts != NULL)
    {
        dprintf("WOW64 extensions loaded\n");
    }
}

void
ParseStackTrace(PULONG TraceFlags,
                PULONG64 Frame,
                PULONG64 Stack,
                PULONG64 Instr,
                PULONG Count,
                PULONG PtrDef)
{
    char Ch;
    ADDR Addr;

    Ch = PeekChar();
    *TraceFlags =
        DEBUG_STACK_COLUMN_NAMES |
        DEBUG_STACK_FRAME_ADDRESSES |
        DEBUG_STACK_SOURCE_LINE;

    if (tolower(Ch) == 'b')
    {
        g_CurCmd++;
        *TraceFlags |= DEBUG_STACK_ARGUMENTS;
    }
    else if (tolower(Ch) == 'v')
    {
        g_CurCmd++;
        *TraceFlags |=
            DEBUG_STACK_ARGUMENTS |
            DEBUG_STACK_FUNCTION_INFO |
            DEBUG_STACK_NONVOLATILE_REGISTERS;
    }
    else if (tolower(Ch) == 'd')
    {
        g_CurCmd++;
        *TraceFlags = RAW_STACK_DUMP;
    }
    else if (tolower(Ch) == 'p')
    {
        g_CurCmd++;
        *TraceFlags |= DEBUG_STACK_PARAMETERS;
    }
    Ch = PeekChar();

    if (tolower(Ch) == 'n')
    {
        if (*TraceFlags == RAW_STACK_DUMP)
        {
            error(SYNTAX);
        }
        
        g_CurCmd++;
        Ch = PeekChar();
        *TraceFlags |= DEBUG_STACK_FRAME_NUMBERS;
    }
    if (tolower(Ch) == 'f')
    {
        if (*TraceFlags == RAW_STACK_DUMP)
        {
            error(SYNTAX);
        }
        
        g_CurCmd++;
        Ch = PeekChar();
        *TraceFlags |= DEBUG_STACK_FRAME_MEMORY_USAGE;
    }
    if (Ch == 'L')
    {
        if (*TraceFlags == RAW_STACK_DUMP)
        {
            error(SYNTAX);
        }
        
        g_CurCmd++;
        Ch = PeekChar();
        *TraceFlags &= ~DEBUG_STACK_SOURCE_LINE;
    }

    if (!PeekChar() && GetCurrentScopeContext())
    {
        dprintf("  *** Stack trace for last set context - "
                ".thread/.cxr resets it\n");
    }

    *PtrDef = STACK_ALL_DEFAULT;
    *Frame = 0;
    *Stack = 0;
    *Instr = 0;
    
    if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386)
    {
        *Instr = g_Machine->GetReg64(X86_EIP);
        *PtrDef &= ~STACK_INSTR_DEFAULT;
    }

    if (PeekChar() == '=')
    {
        g_CurCmd++;
        GetAddrExpression(SEGREG_STACK, &Addr);
        *Frame = Flat(Addr);
        *PtrDef &= ~STACK_FRAME_DEFAULT;
    }
    else if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386)
    {
        g_Machine->GetFP(&Addr);
        *Frame = Flat(Addr);
        *PtrDef &= ~STACK_FRAME_DEFAULT;
    }

    *Count = g_DefaultStackTraceDepth;

    if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386 &&
        (Ch = PeekChar()) != '\0' && Ch != ';')
    {
        //
        // If only one more value it's the count
        //

        *Count = (ULONG)GetExpression();

        if ((Ch = PeekChar()) != '\0' && Ch != ';')
        {
            //
            // More than one value, set extra value for special
            // FPO backtrace.
            //

            *Instr = GetExpression();
            *Stack = EXTEND64(*Count);
            *PtrDef &= ~(STACK_INSTR_DEFAULT | STACK_STACK_DEFAULT);
            *Count = g_DefaultStackTraceDepth;
        }
    }

    if ((Ch = PeekChar()) != '\0' && Ch != ';')
    {
        *Count = (ULONG)GetExpression();
        if ((LONG)*Count < 1)
        {
            g_CurCmd++;
            error(SYNTAX);
        }
    }

    if (*Count >= 0x10000)
    {
        ErrOut("Requested number of stack frames (0x%x) is too large! "
               "The maximum number is 0xffff.\n", *Count);
        error(BADRANGE);
    }
}

void
CmdHelp(void)
{
    char Buf[16];

    // Commands available on all platforms and in all modes.

    dprintf("\nOpen debugger.chm for complete debugger documentation\n\n");
    
    dprintf("A [<address>] - assemble\n");
    dprintf("BC[<bp>] - clear breakpoint(s)\n");
    dprintf("BD[<bp>] - disable breakpoint(s)\n");
    dprintf("BE[<bp>] - enable breakpoint(s)\n");
    dprintf("BL - list breakpoints\n");
    dprintf("[thread]BP[#] <address> - set breakpoint\n");
    dprintf("C <range> <address> [passes] [command] - compare\n");
    dprintf("D[type][<range>] - dump memory\n");
    dprintf("DL[B] <address> <maxcount> <size> - dump linked list\n");
    dprintf("#[processor] DT [-n|y] [[mod!]name] [[-n|y]fields]\n");
    dprintf("                [address] [-l list] [-a[]|c|i|o|r[#]|v] - \n");
    dprintf("                dump using type information\n");
    dprintf("E[type] <address> [<list>] - enter\n");
    dprintf("F <range> <list> - fill\n");
    dprintf("[thread]G [=<address> [<address>...]] - go\n");
    dprintf("[thread]GH [=<address> [<address>...]] - "
            "go with exception handled\n");
    dprintf("[thread]GN [=<address> [<address>...]] - "
            "go with exception not handled\n");
    dprintf("J<expr> [']cmd1['];[']cmd2['] - conditional execution\n");
    dprintf("[thread|processor]K[B] <count> - stacktrace\n");
    dprintf("KD [<count>] - stack trace with raw data\n");
    dprintf("[thread|processor] KV [ <count> | =<reg> ] - "
            "stacktrace with FPO data\n");
    dprintf("L{+|-}[l|o|s|t|*] - Control source options\n");
    dprintf("LD [<module>] - refresh module information\n");
    dprintf("LM[k|l|u|v] - list modules\n");
    dprintf("LN <expr> - list nearest symbols\n");
    dprintf("LS[.] [<first>][,<count>] - List source file lines\n");
    dprintf("LSA <addr>[,<first>][,<count>] - "
            "List source file lines at addr\n");
    dprintf("LSC - Show current source file and line\n");
    dprintf("LSF[-] <file> - Load or unload a source file for browsing\n");
    dprintf("M <range> <address> - move\n");
    dprintf("N [<radix>] - set / show radix\n");
    dprintf("[thread]P[R] [=<addr>] [<value>] - program step\n");
    dprintf("Q - quit\n");

    dprintf("\n");
    GetInput("Hit Enter...", Buf, DIMA(Buf) - 1, GETIN_DEFAULT);
    dprintf("\n");

    dprintf("[thread|processor]R[F][L][M <expr>] [[<reg> [= <expr>]]] - "
            "reg/flag\n");
    dprintf("Rm[?] [<expr>] - Control prompt register output mask\n");
    dprintf("S <range> <list> - search\n");
    dprintf("SQ[e|d] - set quiet mode\n");
    dprintf("SS <n | a | w> - set symbol suffix\n");
    dprintf("SX [{e|d|i|n} [-c \"Cmd1\"] [-c2 \"Cmd2\"] [-h] "
            "{Exception|Event|*}] - event filter\n");
    dprintf("[thread]T[R] [=<address>] [<expr>] - trace\n");
    dprintf("U [<range>] - unassemble\n");
    dprintf("vercommand - show the debuggee command line\n");
    dprintf("version - show debuggee and debugger version\n");
    dprintf("vertarget - show debuggee version\n");
    dprintf("X [<*|module>!]<*|symbol> - view symbols\n");
    dprintf("<commands>; [processor] z(<expression>) - do while true\n");
    dprintf("~ - list threads status\n");
    dprintf("~#s - set default thread\n");
    dprintf("~[.|#|*|ddd]f - freeze thread\n");
    dprintf("~[.|#|*|ddd]u - unfreeze thread\n");
    dprintf("~[.|#|ddd]k[expr] - backtrace stack\n");
    dprintf("| - list processes status\n");
    dprintf("|#s - set default process\n");
    dprintf("|#<command> - default process override\n");
    dprintf("? <expr> - display expression\n");
    dprintf("? - command help\n");
    dprintf("#<string> [address] - search for a string in the dissasembly\n");
    dprintf("$< <filename> - take input from a command file\n");
    dprintf("<Enter> - repeat previous command\n");
    dprintf("; - command separator\n");
    dprintf("*|$ - comment mark\n");

    dprintf("\n");
    GetInput("Hit Enter...", Buf, DIMA(Buf) - 1, GETIN_DEFAULT);
    dprintf("\n");

    dprintf("<expr> unary ops: + - not by wo dwo qwo poi hi low\n");
    dprintf("       binary ops: + - * / mod(%%) and(&) xor(^) or(|)\n");
    dprintf("       comparisons: == (=) < > !=\n");
    dprintf("       operands: number in current radix, "
            "public symbol, <reg>\n");
    dprintf("<type> : b (byte), w (word), d[s] "
            "(doubleword [with symbols]),\n");
    dprintf("         a (ascii), c (dword and Char), u (unicode), l (list)\n");
    dprintf("         f (float), D (double), s|S (ascii/unicode string)\n");
    dprintf("         q (quadword)\n");
    dprintf("<pattern> : [(nt | <dll-name>)!]<var-name> "
            "(<var-name> can include ? and *)\n");
    dprintf("<event> : ct, et, ld, av, cc "
            "(see documentation for full list)\n");
    dprintf("<radix> : 8, 10, 16\n");
    dprintf("<reg> : $u0-$u9, $ea, $exp, $ra, $p\n");
    dprintf("<addr> : %%<32-bit address>\n");
    dprintf("<range> : <address> <address>\n");
    dprintf("        : <address> L <count>\n");
    dprintf("<list> : <byte> [<byte> ...]\n");

    if (IS_KERNEL_TARGET(g_Target))
    {
        dprintf("\n");
        dprintf("Kernel-mode options:\n");
        dprintf("~<processor>s - change current processor\n");
        dprintf("I<b|w|d> <port> - read I/O port\n");
        dprintf("O<b|w|d> <port> <expr> - write I/O\n");
        dprintf("RDMSR <MSR> - read MSR\n");
        dprintf("SO [<options>] - set kernel debugging options\n");
        dprintf("UX [<address>] - disassemble X86 BIOS code\n");
        dprintf("WRMSR <MSR> - write MSR\n");
        dprintf(".cache [size] - set vmem cache size\n");
        dprintf(".reboot - reboot target machine\n");
    }

    switch(g_Machine->m_ExecTypes[0])
    {
    case IMAGE_FILE_MACHINE_I386:
        dprintf("\n");
        dprintf("x86 options:\n");
        dprintf("BA[#] <e|r|w|i><1|2|4> <addr> - addr bp\n");
        dprintf("DG <selector> - dump selector\n");
        dprintf("KB = <base> <stack> <ip> - stacktrace from specific state\n");
        dprintf("<reg> : [e]ax, [e]bx, [e]cx, [e]dx, [e]si, [e]di, "
                "[e]bp, [e]sp, [e]ip, [e]fl,\n");
        dprintf("        al, ah, bl, bh, cl, ch, dl, dh, "
                "cs, ds, es, fs, gs, ss\n");
        dprintf("        dr0, dr1, dr2, dr3, dr6, dr7\n");
        if (IS_KERNEL_TARGET(g_Target))
        {
            dprintf("        cr0, cr2, cr3, cr4\n");
            dprintf("        gdtr, gdtl, idtr, idtl, tr, ldtr\n");
        }
        else
        {
            dprintf("        fpcw, fpsw, fptw, st0-st7, mm0-mm7\n");
        }
        dprintf("         xmm0-xmm7\n");
        dprintf("<flag> : iopl, of, df, if, tf, sf, zf, af, pf, cf\n");
        dprintf("<addr> : #<16-bit protect-mode [seg:]address>,\n");
        dprintf("         &<V86-mode [seg:]address>\n");
        break;

    case IMAGE_FILE_MACHINE_IA64:
        dprintf("\n");
        dprintf("IA64 options:\n");
        dprintf("BA[#] <r|w><1|2|4|8> <addr> - addr bp\n");
        dprintf("<reg> : r2-r31, f2-f127, gp, sp, intnats, preds, brrp, brs0-brs4, brt0, brt1,\n");
        dprintf("        dbi0-dbi7, dbd0-dbd7, kpfc0-kpfc7, kpfd0-kpfd7, h16-h31, unat, lc, ec,\n");
        dprintf("        ccv, dcr, pfs, bsp, bspstore, rsc, rnat, ipsr, iip, ifs, kr0-kr7, itc,\n");
        dprintf("        itm, iva, pta, isr, ifa, itir, iipa, iim, iha, lid, ivr, tpr, eoi,\n");
        dprintf("        irr0-irr3, itv, pmv, lrr0, lrr1, cmcv, rr0-rr7, pkr0-pkr15, tri0-tri7,\n");
        dprintf("        trd0-trd7\n");
        break;

    case IMAGE_FILE_MACHINE_AMD64:
        dprintf("\n");
        dprintf("x86-64 options:\n");
        dprintf("BA[#] <e|r|w|i><1|2|4> <addr> - addr bp\n");
        dprintf("DG <selector> - dump selector\n");
        dprintf("KB = <base> <stack> <ip> - stacktrace from specific state\n");
        dprintf("<reg> : [r|e]ax, [r|e]bx, [r|e]cx, [r|e]dx, [r|e]si, [r|e]di, "
                "[r|e]bp, [r|e]sp, [r|e]ip, [e]fl,\n");
        dprintf("        r8-r15 with b/w/d subregisters\n");
        dprintf("        al, ah, bl, bh, cl, ch, dl, dh, "
                "cs, ds, es, fs, gs, ss\n");
        dprintf("        sil, dil, bpl, spl\n");
        dprintf("        dr0, dr1, dr2, dr3, dr6, dr7\n");
        if (IS_KERNEL_TARGET(g_Target))
        {
            dprintf("        cr0, cr2, cr3, cr4\n");
            dprintf("        gdtr, gdtl, idtr, idtl, tr, ldtr\n");
        }
        else
        {
            dprintf("        fpcw, fpsw, fptw, st0-st7, mm0-mm7\n");
        }
        dprintf("         xmm0-xmm15\n");
        dprintf("<flag> : iopl, of, df, if, tf, sf, zf, af, pf, cf\n");
        dprintf("<addr> : #<16-bit protect-mode [seg:]address>,\n");
        dprintf("         &<V86-mode [seg:]address>\n");
        break;

    }
    
    dprintf("\nOpen debugger.chm for complete debugger documentation\n\n");
}


/*** ProcessCommands - high-level command processor
*
*   Purpose:
*       If no command string remains, the user is prompted to
*       input one.  Once input, this routine parses the string
*       into commands and their operands.  Error checking is done
*       on both commands and operands.  Multiple commands may be
*       input by separating them with semicolons.  Once a command
*               is parsefd, the appropriate routine (type fnXXXXX) is called
*       to execute the command.
*
*   Input:
*       g_CurCmd = pointer to the next command in the string
*
*   Output:
*       None.
*
*   Exceptions:
*       error exit: SYNTAX - command type or operand error
*       normal exit: termination on 'q' command
*
*************************************************************************/

HRESULT
ProcessCommands(DebugClient* Client, BOOL Nested)
{
    char Ch;
    ADDR Addr1;
    ADDR Addr2;
    ULONG64 Value1;
    ULONG64 Value2;
    ULONG Count;
    PSTR SavedCurCmd;
    ProcessInfo* ProcessPrevious = NULL;
    BOOL ParseProcess = FALSE;
    HRESULT Status = S_FALSE;
    PCROSS_PLATFORM_CONTEXT ScopeContext;
    DEBUG_SCOPE_STATE SaveCurrCtxtState;
    ContextSave* PushContext;
    PSTR Scan, Start;

    if (g_Process == NULL ||
        g_Thread == NULL)
    {
        WarnOut("WARNING: The debugger does not have a current "
                "process or thread\n");
        WarnOut("WARNING: Many commands will not work\n");
    }

    if (!Nested)
    {
        g_SwitchedProcs = FALSE;
    }

    do
    {
        Ch = *g_CurCmd++;
        if (Ch == '\0' ||
            (Ch == ';' && (g_EngStatus & ENG_STATUS_USER_INTERRUPT)))
        {
            if (!Nested)
            {
                g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
                g_BreakpointsSuspended = FALSE;
            }

            Status = S_OK;
            // Back up to terminating character in
            // case command processing is reentered without
            // resetting things.
            g_CurCmd--;
            break;
        }
        
EVALUATE:
        while (Ch == ' ' || Ch == '\t' || Ch == '\r' || Ch == '\n' ||
               Ch == ';')
        {
            Ch = *g_CurCmd++;
        }

        if (IS_KERNEL_TARGET(g_Target))
        {
            if (g_Target &&
                g_Target->m_NumProcessors > MAXIMUM_PROCS)
            {
                WarnOut("WARNING: Number of processors corrupted - using 1\n");
                g_Target->m_NumProcessors = 1;
            }

            if (Ch >= '0' && Ch <= '9')
            {
                if (IS_KERNEL_TRIAGE_DUMP(g_Target))
                {
                    ErrOut("Can't switch processors on a Triage dump\n");
                    error(SYNTAX);
                }
            
                Value1 = 0;
                SavedCurCmd = g_CurCmd;
                while (Ch >= '0' && Ch <= '9')
                {
                    Value1 = Value1 * 10 + (Ch - '0');
                    Ch = *SavedCurCmd++;
                }
                Ch = (char)tolower(Ch);
                if (Ch == 'r' || Ch == 'k' || Ch == 'z' ||
                    (Ch == 'd' && tolower(*SavedCurCmd) == 't'))
                {
                    if (g_Target && Value1 < g_Target->m_NumProcessors)
                    {
                        if (Value1 != g_Target->m_RegContextProcessor)
                        {
                            SaveSetCurrentProcessorThread(g_Target,
                                                          (ULONG)Value1);
                            g_SwitchedProcs = TRUE;
                        }
                    }
                    else
                    {
                        error(BADRANGE);
                    }
                }
                else
                {
                    error(SYNTAX);
                }
                g_CurCmd = SavedCurCmd;
            }
        }

        g_PrefixSymbols = FALSE;
        switch (Ch = (char)tolower(Ch)) 
        {
            case '?':
                if ((Ch = PeekChar()) == '\0' || Ch == ';')
                {
                    CmdHelp();
                }
                else if (*g_CurCmd == '?')
                {
                    TypedData Result;
                    EvalExpression* Eval;

                    g_CurCmd++;
                    Eval = GetEvaluator(DEBUG_EXPR_CPLUSPLUS, FALSE);
                    Eval->EvalCurrent(&Result);
                    ReleaseEvaluator(Eval);
                    Result.OutputTypeAndValue();
                }
                else
                {
                    DotFormats(NULL, Client);
                }
                break;
                
            case '$':
                if ( *g_CurCmd++ == '<')
                {
                    if ((Status =
                         ExecuteCommandFile(Client, (PCSTR)g_CurCmd,
                                            DEBUG_EXECUTE_ECHO)) != S_OK)
                    {
                        ErrOut("Command file execution failed, %s\n    "
                               "\"%s\"\n", FormatStatusCode(Status),
                               FormatStatus(Status));
                    }
                }
                *g_CurCmd = 0;
                break;
                
            case '~':
                if (IS_USER_TARGET(g_Target))
                {
                    if (Nested)
                    {
                        ErrOut("Ignoring recursive thread command\n");
                        break;
                    }

                    ParseThreadCmds(Client);
                }
                else
                {
                    ParseProcessorCommands();
                }
                break;
                
            case '|':
                if (*g_CurCmd == '|')
                {
                    g_CurCmd++;
                    ParseSystemCommands();
                    break;
                }
                
                if (IS_KERNEL_TARGET(g_Target))
                {
                    break;
                }
                
                if (!ParseProcess)
                {
                    ParseProcess = TRUE;
                    ProcessPrevious = g_Process;
                }
                ParseProcessCmds();
                if (!*g_CurCmd)
                {
                    ParseProcess = FALSE;
                }
                else
                {
                    Ch = *g_CurCmd++;
                    goto EVALUATE;
                }
                break;
                
            case '.':
                SavedCurCmd = g_CurCmd;
                if (!DotCommand(Client, FALSE))
                {
                    g_CurCmd = SavedCurCmd;
                    ParseBangCmd(Client, TRUE);
                }
                break;

            case '!':
                SavedCurCmd = g_CurCmd;
                if (!DotCommand(Client, TRUE))
                {
                    g_CurCmd = SavedCurCmd;
                    ParseBangCmd(Client, FALSE);
                }
                break;

            case '*':
                while (*g_CurCmd != '\0')
                {
                    g_CurCmd++;
                }
                break;

            case '#':
                ParseInstrGrep();
                break;

            case 'a':
                //
                //  Alias command or just default to pre-existing
                //  assemble command.
                //
                Ch = *g_CurCmd++;
                switch (tolower(Ch))
                {
                    //  Alias list
                case 'l':
                    ListAliases();
                    break;

                    //  Alias set
                case 's':
                    ParseSetAlias();
                    break;

                    //  Alias delete
                case 'd':
                    ParseDeleteAlias();
                    break;

                    //  Pre-existing assemble command
                default:
                    g_CurCmd--;
                    ParseAssemble();
                    break;
                }
                break;
                
            case 'b':
                Ch = *g_CurCmd++;
                Ch = (char)tolower(Ch);

                if (!g_Target || !g_Target->m_DynamicEvents)
                {
                    error(TARGETNOTSUP);
                }

                switch(Ch)
                {
                case 'p':
                case 'u':
                case 'a':
                case 'i':
                case 'w':
                case 'm':
                    ParseBpCmd(Client, Ch, NULL);
                    break;

                case 'c':
                case 'd':
                case 'e':
                    Value1 = GetIdList(TRUE);
                    ChangeBreakpointState(Client, g_Process,
                                          (ULONG)Value1, Ch);
                    break;

                case 'l':
                    if (PeekChar() != ';' && *g_CurCmd)
                    {
                        Value1 = GetIdList(TRUE);
                    }
                    else
                    {
                        Value1 = ALL_ID_LIST;
                    }
                    ListBreakpoints(Client, g_Process, (ULONG)Value1);
                    break;
                        
                default:
                    error(SYNTAX);
                    break;
                }
                break;
                
            case 'c':
                GetRange(&Addr1, &Value2, 1, SEGREG_DATA,
                         DEFAULT_RANGE_LIMIT);
                GetAddrExpression(SEGREG_DATA, &Addr2);
                CompareTargetMemory(&Addr1, (ULONG)Value2, &Addr2);
                break;

            case 'd':
                ParseDumpCommand();
                break;
            case 'e':
                ParseEnterCommand();
                break;

            case 'f':
                ParseFillMemory();
                break;

            case 'g':
                ParseGoCmd(NULL, FALSE);
                break;

            case 'i':
                Ch = (char)tolower(*g_CurCmd);
                g_CurCmd++;
                if (Ch != 'b' && Ch != 'w' && Ch != 'd')
                {
                    error(SYNTAX);
                }
                
                if (IS_USER_TARGET(g_Target) || IS_DUMP_TARGET(g_Target))
                {
                    error(SESSIONNOTSUP);
                }
                
                InputIo((ULONG)GetExpression(), Ch);
                break;
                
            case 'j':
                if (GetExpression())
                {
                    Scan = g_CurCmd;

                    // Find a semicolon or a quote

                    while (*Scan && *Scan != ';' && *Scan != '\'')
                    {
                        Scan++;
                    }
                    if (*Scan == ';')
                    {
                        *Scan = 0;
                    }
                    else if (*Scan)
                    {
                        *Scan = ' ';
                        // Find the closing quote
                        while (*Scan && *Scan != '\'')
                        {
                            Scan++;
                        }
                        *Scan = 0;
                    }
                }
                else
                {
                    Start = Scan = g_CurCmd;

                    // Find a semicolon or a quote

                    while (*Scan && *Scan != ';' && *Scan != '\'')
                    {
                        Scan++;
                    }
                    if (*Scan == ';')
                    {
                        Start = ++Scan;
                    }
                    else if (*Scan)
                    {
                        Scan++;
                        while (*Scan && *Scan++ != '\'')
                        {
                            // Empty.
                        }
                        while (*Scan && (*Scan == ';' || *Scan == ' '))
                        {
                            Scan++;
                        }
                        Start = Scan;
                    }
                    while (*Scan && *Scan != ';' && *Scan != '\'')
                    {
                        Scan++;
                    }
                    if (*Scan == ';')
                    {
                        *Scan = 0;
                    }
                    else if (*Scan)
                    {
                        *Scan = ' ';
                        // Find the closing quote
                        while (*Scan && *Scan != '\'')
                        {
                            Scan++;
                        }
                        *Scan = 0;
                    }
                    g_CurCmd = Start;
                 }
                 Ch = *g_CurCmd++;
                 goto EVALUATE;

            case 'k':
                if (IS_LOCAL_KERNEL_TARGET(g_Target))
                {
                    error(SESSIONNOTSUP);
                }
                if (!IS_CUR_CONTEXT_ACCESSIBLE())
                {
                    error(BADTHREAD);
                }
                
                SaveCurrCtxtState = g_ScopeBuffer.State;
                if (g_SwitchedProcs)
                {
                    g_ScopeBuffer.State = ScopeDefault;
                }
                
                if (ScopeContext = GetCurrentScopeContext())
                {
                    PushContext = g_Machine->PushContext(ScopeContext);
                }
                
                __try
                {
                    ULONG64 Frame, Stack, Instr;
                    ULONG PtrDef;
                    ULONG TraceFlags;
                    
                    Count = g_DefaultStackTraceDepth;
                    ParseStackTrace(&TraceFlags, &Frame, &Stack, &Instr,
                                    &Count, &PtrDef);
                    DoStackTrace(Client, Frame, Stack, Instr, PtrDef,
                                 Count, TraceFlags);
                }
                __except(CommandExceptionFilter(GetExceptionInformation()))
                {
                    // Stop command processing.
                    *g_CurCmd = 0;
                }
                
                if (ScopeContext)
                {
                    g_Machine->PopContext(PushContext);
                }

                if (g_SwitchedProcs)
                {
                    RestoreCurrentProcessorThread(g_Target);
                    g_SwitchedProcs = FALSE;
                    g_ScopeBuffer.State = SaveCurrCtxtState;
                }
                break;
            
            case 'l':
                Ch = (char)tolower(*g_CurCmd);
                if (Ch == 'n')
                {
                    g_CurCmd++;

                    if (!g_Machine || !g_Process)
                    {
                        error(BADTHREAD);
                    }
                    
                    if ((Ch = PeekChar()) != '\0' && Ch != ';')
                    {
                        GetAddrExpression(SEGREG_CODE, &Addr1);
                    }
                    else
                    {
                        ScopeContext = GetCurrentScopeContext();
                        if (ScopeContext)
                        {
                            PushContext = g_Machine->PushContext(ScopeContext);
                        }
                        g_Machine->GetPC(&Addr1);
                        if (ScopeContext)
                        {
                            g_Machine->PopContext(PushContext);
                        }
                    }
                    
                    ListNearSymbols(Flat(Addr1));
                }
                else if (Ch == '+' || Ch == '-')
                {
                    g_CurCmd++;
                    ParseSrcOptCmd(Ch);
                }
                else if (Ch == 's')
                {
                    g_CurCmd++;
                    Ch = (char)tolower(*g_CurCmd);
                    if (Ch == 'f')
                    {
                        g_CurCmd++;
                        ParseSrcLoadCmd();
                    }
                    else if (Ch == 'p')
                    {
                        g_CurCmd++;
                        ParseOciSrcCmd();
                    }
                    else
                    {
                        ParseSrcListCmd(Ch);
                    }
                }
                else if (Ch == 'm')
                {
                    ParseDumpModuleTable();
                }
                else if (Ch == 'd')
                {
                    g_CurCmd++;
                    ParseLoadModules();
                }
                else
                {
                    error(SYNTAX);
                }
                break;
                
            case 'm':
                GetRange(&Addr1, &Value2, 1, SEGREG_DATA,
                         DEFAULT_RANGE_LIMIT);
                GetAddrExpression(SEGREG_DATA, &Addr2);
                MoveTargetMemory(&Addr1, (ULONG)Value2, &Addr2);
                break;

            case 'n':
                if ((Ch = PeekChar()) != '\0' && Ch != ';')
                {
                    if (Ch == '8')
                    {
                        g_CurCmd++;
                        g_DefaultRadix = 8;
                    }
                    else if (Ch == '1')
                    {
                        Ch = *++g_CurCmd;
                        if (Ch == '0' || Ch == '6')
                        {
                            g_CurCmd++;
                            g_DefaultRadix = 10 + Ch - '0';
                        }
                        else
                        {
                            error(SYNTAX);
                        }
                    }
                    else
                    {
                        error(SYNTAX);
                    }
                    NotifyChangeEngineState(DEBUG_CES_RADIX, g_DefaultRadix,
                                            TRUE);
                }
                dprintf("base is %ld\n", g_DefaultRadix);
                break;
                
            case 'o':
                Ch = (char)tolower(*g_CurCmd);
                g_CurCmd++;
                if (Ch == 'b')
                {
                    Value2 = 1;
                }
                else if (Ch == 'w')
                {
                    Value2 = 2;
                }
                else if (Ch == 'd')
                {
                    Value2 = 4;
                }
                else
                {
                    error(SYNTAX);
                }
                
                if (IS_USER_TARGET(g_Target) || IS_DUMP_TARGET(g_Target))
                {
                    error(SESSIONNOTSUP);
                }
                
                Value1 = GetExpression();
                Value2 = HexValue((ULONG)Value2);
                OutputIo((ULONG)Value1, (ULONG)Value2, Ch);
                break;
                
            case 'w':
            case 'p':
            case 't':
                if (IS_KERNEL_TARGET(g_Target))
                {
                    if (Ch == 'w' &&
                        tolower(g_CurCmd[0]) == 'r'  &&
                        tolower(g_CurCmd[1]) == 'm'  &&
                        tolower(g_CurCmd[2]) == 's'  &&
                        tolower(g_CurCmd[3]) == 'r')
                    {
                        g_CurCmd +=4;
                        Value1 = GetExpression();
                        if (g_Target->WriteMsr((ULONG)Value1,
                                               HexValue(8)) != S_OK)
                        {
                            ErrOut ("no such msr\n");
                        }
                        break;
                    }
                }

                ParseStepTrace(NULL, FALSE, Ch);
                break;
                
            case 'q':
                char QuitArgument;
                BOOL ForceQuit;

                ForceQuit = FALSE;
                QuitArgument = (char)tolower(PeekChar());
                if (QuitArgument == 'q')
                {
                    ForceQuit = TRUE;
                    g_CurCmd++;
                    QuitArgument = (char)tolower(PeekChar());
                }
                if ((IS_LIVE_USER_TARGET(g_Target) && QuitArgument == 'd') ||
                    QuitArgument == 'k')
                {
                    g_CurCmd++;
                }
                if (PeekChar() != 0)
                {
                    error(SYNTAX);
                }

                if (!ForceQuit &&
                    Client != NULL &&
                    (Client->m_Flags & CLIENT_REMOTE))
                {
                    ErrOut("Exit a remote ntsd/cdb client "
                           "with Ctrl-b<enter>.\n"
                           "Exit a remote windbg client "
                           "with File.Exit (Alt-F4).\n"
                           "If you really want the server "
                           "to quit use 'qq'.\n");
                    break;
                }
                
                // Detach if requested.
                if (QuitArgument == 'd')
                {
                    DBG_ASSERT(IS_LIVE_USER_TARGET(g_Target));
                    
                    // If detach isn't supported warn the user
                    // and abort the quit.
                    if (((LiveUserTargetInfo*)g_Target)->m_Services->
                        DetachProcess(0) != S_OK)
                    {
                        ErrOut("The system doesn't support detach\n");
                        break;
                    }

                    if (g_SessionThread &&
                        GetCurrentThreadId() != g_SessionThread)
                    {
                        ErrOut("Detach can only be done by the server\n");
                        break;
                    }
                           
                    HRESULT DetachStatus;
                    
                    if (FAILED(DetachStatus = DetachProcesses()))
                    {
                        ErrOut("Detach failed, 0x%X\n", DetachStatus);
                    }
                }
                else if ((g_GlobalProcOptions &
                          DEBUG_PROCESS_DETACH_ON_EXIT) ||
                         (g_Target &&
                          (g_Target->m_AllProcessFlags & ENG_PROC_EXAMINED)))
                {
                    HRESULT PrepareStatus;
                    
                    if (g_SymOptions & SYMOPT_SECURE)
                    {
                        error(NOTSECURE);
                    }
                    
                    // We need to restart the program before we
                    // quit so that it's put back in a running state.
                    PrepareStatus = PrepareForSeparation();
                    if (PrepareStatus != S_OK)
                    {
                        ErrOut("Unable to prepare for detach, %s\n    \"%s\"",
                               FormatStatusCode(PrepareStatus),
                               FormatStatus(PrepareStatus));
                        break;
                    }
                }
                
                dprintf("quit:\n");

                // Force engine into a no-debuggee state
                // to indicate quit.
                g_CmdState = 'q';
                g_EngStatus |= ENG_STATUS_STOP_SESSION;
                NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                                        DEBUG_STATUS_NO_DEBUGGEE, TRUE);
                break;

            case 'r':
                if (IS_KERNEL_TARGET(g_Target))
                {
                    if (tolower(g_CurCmd[0]) == 'd'  &&
                        tolower(g_CurCmd[1]) == 'm'  &&
                        tolower(g_CurCmd[2]) == 's'  &&
                        tolower(g_CurCmd[3]) == 'r')
                    {
                        g_CurCmd +=4;
                        Value1 = GetExpression();
                        if (g_Target->ReadMsr((ULONG)Value1, &Value2) == S_OK)
                        {
                            dprintf("msr[%x] = %08x:%08x\n",
                                    (ULONG)Value1, (ULONG)(Value2 >> 32),
                                    (ULONG)Value2);
                        }
                        else
                        {
                            ErrOut("no such msr\n");
                        }
                        break;
                    }
                }

                if (ScopeContext = GetCurrentScopeContext())
                {
                    dprintf("Last set context:\n");
                    PushContext = g_Machine->PushContext(ScopeContext);
                }
                
                __try
                {
                    ParseRegCmd();
                }
                __except(CommandExceptionFilter(GetExceptionInformation()))
                {
                    // Stop command processing.
                    *g_CurCmd = 0;
                }

                if (ScopeContext)
                {
                    g_Machine->PopContext(PushContext);
                }
                if (g_SwitchedProcs)
                {
                    RestoreCurrentProcessorThread(g_Target);
                    g_SwitchedProcs = FALSE;
                }
                break;
                
            case 's':
                Ch = (char)tolower(*g_CurCmd);

                if (Ch == 's')
                {
                    g_CurCmd++;
                    SetSuffix();
                }
                else if (Ch == 'q')
                {
                    g_CurCmd++;
                    Ch = (char)tolower(*g_CurCmd);
                    if (Ch == 'e')
                    {
                        g_QuietMode = TRUE;
                        g_CurCmd++;
                    }
                    else if (Ch == 'd')
                    {
                        g_QuietMode = FALSE;
                        g_CurCmd++;
                    }
                    else
                    {
                        g_QuietMode = !g_QuietMode;
                    }
                    dprintf("Quiet mode is %s\n", g_QuietMode ? "ON" : "OFF");
                }
                else if (Ch == 'x')
                {
                    g_CurCmd++;
                    ParseSetEventFilter(Client);
                }
                else if (IS_KERNEL_TARGET(g_Target) && Ch == 'o')
                {
                    Scan = ++g_CurCmd;
                    while ((*Scan != '\0') && (*Scan != ';'))
                    {
                        Scan++;
                    }
                    Ch = *Scan;
                    *Scan = '\0';
                    ReadDebugOptions(FALSE, (*g_CurCmd == '\0' ?
                                             NULL : g_CurCmd));
                    *Scan = Ch;
                    g_CurCmd = Scan;
                }
                else
                {
                    // s, s-w, s-d, s-q.
                    ParseSearchMemory();
                }
                break;

            case 'u':
                ParseUnassemble();
                break;

            case 'v':
                Scan = g_CurCmd;
                while (*Scan && !isspace(*Scan) && *Scan != ';')
                {
                    Scan++;
                }
                Count = (ULONG)(Scan - g_CurCmd);
                if (Count == 8 &&
                    _memicmp(g_CurCmd, "ertarget", Count) == 0)
                {
                    g_CurCmd = Scan;
                    g_Target->OutputVersion();
                }
                else if (Count == 6 &&
                         _memicmp(g_CurCmd, "ersion", Count) == 0)
                {
                    g_CurCmd = Scan;
                    // Print target version, then debugger version.
                    g_Target->OutputVersion();
                    OutputVersionInformation(Client);
                }
                else if (Count == 9 &&
                         _memicmp(g_CurCmd, "ercommand", Count) == 0)
                {
                    g_CurCmd = Scan;
                    dprintf("command line: '%s'\n", GetCommandLine());
                }
                else
                {
                    error(SYNTAX);
                }
                break;

            case 'x':
                ParseExamine();
                break;

            case ';':
            case '\0':
                g_CurCmd--;
                break;

        case 'z':

            // Works like do{ cmds }while(Cond);
            // Eg. p;z(eax<2);

            if (CheckUserInterrupt())
            {
                // Eat the expression also to prevent
                // spurious extra character errors.
                GetExpression();
                g_RedoCount = 0;
                break;
            }
            if (GetExpression())
            {
                g_CurCmd = g_CommandStart;
                ++g_RedoCount;
                dprintf("redo [%d] %s\n", g_RedoCount, g_CurCmd );
                FlushCallbacks();
                Ch = *g_CurCmd++;
                goto EVALUATE;
            }
            else
            {
                g_RedoCount = 0;
            }
            break;

        default:
            error(SYNTAX);
            break;
        }
        do
        {
            Ch = *g_CurCmd++;
        } while (Ch == ' ' || Ch == '\t' || Ch == '\n' || Ch == '\r');
        if (Ch != ';' && Ch != '\0')
        {
            error(EXTRACHARS);
        }
        g_CurCmd--;
    }
    while (g_CmdState == 'c');

    if (Status == S_FALSE)
    {
        Scan = g_CurCmd;
        
        // We switched to a non-'c' cmdState so the
        // loop was exited.  Check and see if we're
        // also at the end of the command as that will
        // take precedence in what the return value is.
        while (*Scan == ' ' || *Scan == '\t' || *Scan == ';')
        {
            Scan++;
        }
        
        Status = *Scan ? S_FALSE : S_OK;
    }

    g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
    return Status;
}

HRESULT
ProcessCommandsAndCatch(DebugClient* Client)
{
    HRESULT Status;
    
    __try
    {
        Status = ProcessCommands(Client, FALSE);
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        g_CurCmd = g_CommandStart;
        *g_CurCmd = '\0';
        g_LastCommand[0] = '\0';
        Status = HR_PROCESS_EXCEPTION;
        g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\process.cpp ===
//----------------------------------------------------------------------------
//
// Process abstraction.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include <common.ver>

#define NTLDR_IMAGE_NAME         "ntldr"
#define OSLOADER_IMAGE_NAME      "osloader"
#define SETUPLDR_IMAGE_NAME      "setupldr"

#define LDR_IMAGE_SIZE           0x80000

#define CSRSS_IMAGE_NAME         "csrss.exe"
#define LSASS_IMAGE_NAME         "lsass.exe"
#define SERVICES_IMAGE_NAME      "services.exe"

void
RestrictModNameChars(PCSTR ModName, PSTR RewriteBuffer)
{
    PCSTR Scan = ModName;
    PSTR Write = RewriteBuffer;

    while (*Scan)
    {
        if ((*Scan < 'a' || *Scan > 'z') &&
            (*Scan < 'A' || *Scan > 'Z') &&
            (*Scan < '0' || *Scan > '9') &&
            *Scan != '_')
        {
            *Write++ = '_';
        }
        else
        {
            *Write++ = *Scan;
        }

        Scan++;
    }
    *Write = 0;
}

//----------------------------------------------------------------------------
//
// ProcCorDataAccessServices.
//
//----------------------------------------------------------------------------

ProcCorDataAccessServices::ProcCorDataAccessServices(void)
{
    m_Process = NULL;
}

STDMETHODIMP
ProcCorDataAccessServices::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    if (DbgIsEqualIID(InterfaceId, IID_IUnknown) ||
        DbgIsEqualIID(InterfaceId, __uuidof(ICorDataAccessServices)))
    {
        *Interface = (ICorDataAccessServices*)this;
        // No need to refcount as this class is contained.
        return S_OK;
    }
    else
    {
        *Interface = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
ProcCorDataAccessServices::AddRef(
    THIS
    )
{
    // No need to refcount as this class is contained.
    return 1;
}

STDMETHODIMP_(ULONG)
ProcCorDataAccessServices::Release(
    THIS
    )
{
    // No need to refcount as this class is contained.
    return 0;
}

HRESULT STDMETHODCALLTYPE
ProcCorDataAccessServices::GetMachineType( 
    /* [out] */ ULONG32 *machine)
{
    *machine = m_Process->m_Target->m_MachineType;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
ProcCorDataAccessServices::GetPointerSize( 
    /* [out] */ ULONG32 *size)
{
    *size = m_Process->m_Target->m_Machine->m_Ptr64 ? 8 : 4;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
ProcCorDataAccessServices::GetImageBase( 
    /* [string][in] */ LPCWSTR name,
    /* [out] */ CORDATA_ADDRESS *base)
{
    HRESULT Status;
    PSTR Ansi;
    INAME WhichName;
    ImageInfo* Image;

    if ((Status = WideToAnsi(name, &Ansi)) != S_OK)
    {
        return Status;
    }

    if (PathTail(Ansi) != Ansi)
    {
        WhichName = INAME_IMAGE_PATH;
    }
    else
    {
        WhichName = INAME_IMAGE_PATH_TAIL;
    }

    if (Image = m_Process->FindImageByName(Ansi, 0, WhichName, FALSE))
    {
        *base = Image->m_BaseOfImage;
        Status = S_OK;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    FreeAnsi(Ansi);
    return Status;
}

HRESULT STDMETHODCALLTYPE
ProcCorDataAccessServices::ReadVirtual( 
    /* [in] */ CORDATA_ADDRESS address,
    /* [length_is][size_is][out] */ PBYTE buffer,
    /* [in] */ ULONG32 request,
    /* [optional][out] */ ULONG32 *done)
{
    return m_Process->m_Target->
        ReadVirtual(m_Process, address, buffer, request, (PULONG)done);
}

HRESULT STDMETHODCALLTYPE
ProcCorDataAccessServices::WriteVirtual( 
    /* [in] */ CORDATA_ADDRESS address,
    /* [size_is][in] */ PBYTE buffer,
    /* [in] */ ULONG32 request,
    /* [optional][out] */ ULONG32 *done)
{
    return m_Process->m_Target->
        WriteVirtual(m_Process, address, buffer, request, (PULONG)done);
}

HRESULT STDMETHODCALLTYPE
ProcCorDataAccessServices::GetTlsValue(
    /* [in] */ ULONG32 index,
    /* [out] */ CORDATA_ADDRESS* value)
{
    HRESULT Status;
    ULONG64 SlotAddr;

    if ((Status = m_Process->m_CurrentThread->
         GetTlsSlotAddress((ULONG)index, &SlotAddr)) != S_OK)
    {
        return Status;
    }

    return m_Process->m_Target->
        ReadPointer(m_Process, m_Process->m_Target->m_Machine,
                    SlotAddr, value);
}

HRESULT STDMETHODCALLTYPE
ProcCorDataAccessServices::SetTlsValue(
    /* [in] */ ULONG32 index,
    /* [in] */ CORDATA_ADDRESS value)
{
    HRESULT Status;
    ULONG64 SlotAddr;

    if ((Status = m_Process->m_CurrentThread->
         GetTlsSlotAddress((ULONG)index, &SlotAddr)) != S_OK)
    {
        return Status;
    }

    return m_Process->m_Target->
        WritePointer(m_Process, m_Process->m_Target->m_Machine,
                     SlotAddr, value);
}

HRESULT STDMETHODCALLTYPE
ProcCorDataAccessServices::GetCurrentThreadId(
    /* [out] */ ULONG32* threadId)
{
    *threadId = g_Thread->m_SystemId;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
ProcCorDataAccessServices::GetThreadContext(
    /* [in] */ ULONG32 threadId,
    /* [in] */ ULONG32 contextFlags,
    /* [in] */ ULONG32 contextSize,
    /* [out, size_is(contextSize)] */ PBYTE context)
{
    HRESULT Status;
    
    if (contextSize < m_Process->m_Target->m_TypeInfo.SizeTargetContext)
    {
        return E_INVALIDARG;
    }

    ThreadInfo* Thread = m_Process->FindThreadBySystemId(threadId);
    if (!Thread)
    {
        return E_NOINTERFACE;
    }

    m_Process->m_Target->ChangeRegContext(Thread);
    
    if ((Status = m_Process->m_Target->m_Machine->
         GetContextState(MCTX_CONTEXT)) == S_OK)
    {
        Status = m_Process->m_Target->m_Machine->
            ConvertContextTo(&m_Process->m_Target->m_Machine->m_Context,
                             m_Process->m_Target->m_SystemVersion,
                             m_Process->m_Target->m_TypeInfo.SizeTargetContext,
                             context);
    }

    m_Process->m_Target->ChangeRegContext(m_Process->m_CurrentThread);

    return Status;
}

HRESULT STDMETHODCALLTYPE
ProcCorDataAccessServices::SetThreadContext(
    /* [in] */ ULONG32 threadId,
    /* [in] */ ULONG32 contextSize,
    /* [out, size_is(contextSize)] */ PBYTE context)
{
    HRESULT Status;
    
    if (contextSize < m_Process->m_Target->m_TypeInfo.SizeTargetContext)
    {
        return E_INVALIDARG;
    }

    ThreadInfo* Thread = m_Process->FindThreadBySystemId(threadId);
    if (!Thread)
    {
        return E_NOINTERFACE;
    }

    m_Process->m_Target->ChangeRegContext(Thread);
    
    if ((Status = m_Process->m_Target->m_Machine->
         GetContextState(MCTX_DIRTY)) == S_OK)
    {
        Status = m_Process->m_Target->m_Machine->
            ConvertContextFrom(&m_Process->m_Target->m_Machine->m_Context,
                               m_Process->m_Target->m_SystemVersion,
                               m_Process->m_Target->
                               m_TypeInfo.SizeTargetContext,
                               context);
        if (Status == S_OK)
        {
            NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS, DEBUG_ANY_ID);
        }
    }

    m_Process->m_Target->ChangeRegContext(m_Process->m_CurrentThread);

    return Status;
}

//----------------------------------------------------------------------------
//
// ProcessInfo.
//
//----------------------------------------------------------------------------

ProcessInfo::ProcessInfo(TargetInfo* Target,
                         ULONG SystemId,
                         HANDLE SymHandle,
                         ULONG64 SysHandle,
                         ULONG Flags,
                         ULONG Options)
{
    m_Target = Target;
    m_UserId = FindNextUserId(LAYER_PROCESS);

    m_Next = NULL;
    m_NumImages = 0;
    m_NumUnloadedModules = 0;
    m_ImageHead = NULL;
    m_ExecutableImage = NULL;
    m_SynthesizedImage = NULL;
    m_NumThreads = 0;
    m_ThreadHead = NULL;
    m_CurrentThread = NULL;
    m_SystemId = SystemId;
    m_Exited = FALSE;
    m_ModulesLoaded = FALSE;
    m_InitialBreakDone = (Flags & ENG_PROC_NO_INITIAL_BREAK) != 0;
    // Always ask for an "initial" break when the process
    // won't generate its own initial break as the first
    // break encountered will just be a normal break and
    // so should cause a break-in.
    m_InitialBreak =
        (Flags & ENG_PROC_NO_INITIAL_BREAK) ||
        IS_KERNEL_TARGET(m_Target) ||
        (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK) != 0;
    m_InitialBreakWx86 =
        (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK) != 0;
    m_DataOffset = 0;
    m_SymHandle = SymHandle;
    m_SysHandle = SysHandle;
    m_Flags = Flags;
    m_Options = Options;
    m_NumBreakpoints = 0;
    m_Breakpoints = NULL;
    m_BreakpointsTail = NULL;
    m_DynFuncTableList = 0;
    m_OopFuncTableDlls = NULL;
    m_RtlUnloadList = 0;
    
    ResetImplicitData();
    
    m_CorImage = NULL;
    m_CorImageType = COR_DLL_INVALID;
    m_CorDebugDll = NULL;
    m_CorAccess = NULL;
    m_CorServices.m_Process = this;
    
    m_VirtualCache.SetProcess(this);
    
    PCHAR CacheEnv = getenv("_NT_DEBUG_CACHE_SIZE");
    if (CacheEnv != NULL)
    {
        m_VirtualCache.m_MaxSize = atol(CacheEnv);
    }

    m_VirtualCache.m_DecodePTEs =
        IS_KERNEL_TARGET(m_Target) &&
        !(m_Target->m_KdVersion.Flags & DBGKD_VERS_FLAG_NOMM);

    m_Target->InsertProcess(this);

    SymInitialize(m_SymHandle, NULL, FALSE);
    SymRegisterCallback64(m_SymHandle, SymbolCallbackFunction,
                          (ULONG_PTR)this);

    if (IS_USER_TARGET(m_Target) &&
        m_Target->m_MachineType != IMAGE_FILE_MACHINE_I386)
    {
        SymRegisterFunctionEntryCallback64
            (m_SymHandle, TargetInfo::DynamicFunctionTableCallback,
             (ULONG_PTR)this);
    }
        
    SetSymbolSearchPath(this);
    SynthesizeSymbols();
}

ProcessInfo::~ProcessInfo(void)
{
    ClearOopFuncTableDlls();

    RELEASE(m_CorAccess);
    if (m_CorDebugDll)
    {
        FreeLibrary(m_CorDebugDll);
    }
    
    while (m_ThreadHead)
    {
        delete m_ThreadHead;
    }
    
    // Suppress notifications until all images are deleted.
    g_EngNotify++;

    while (m_ImageHead)
    {
        delete m_ImageHead;
    }
    delete m_SynthesizedImage;
    // Notification can use process information so put things
    // in a clean state before notify.
    m_SynthesizedImage = NULL;

    g_EngNotify--;
    NotifyChangeSymbolState(DEBUG_CSS_UNLOADS, 0, this);

    SymCleanup(m_SymHandle);

    RemoveProcessBreakpoints(this);

    if (m_Flags & ENG_PROC_THREAD_CLOSE_HANDLE)
    {
        DBG_ASSERT(IS_LIVE_USER_TARGET(m_Target) &&
                   ((LiveUserTargetInfo*)m_Target)->m_Services);
        ((LiveUserTargetInfo*)m_Target)->m_Services->
            CloseHandle(m_SysHandle);
    }

    m_Target->RemoveProcess(this);

    g_UserIdFragmented[LAYER_PROCESS]++;

    if (this == g_Process)
    {
        g_Process = NULL;
    }
    if (this == g_EventProcess)
    {
        g_EventProcess = NULL;
        DiscardLastEvent();
    }
    if (g_StepTraceBp && g_StepTraceBp->m_Process == this)
    {
        g_StepTraceBp->m_Process = NULL;
        if (g_WatchFunctions.IsStarted())
        {
            g_WatchFunctions.End(NULL);
        }
        ResetStepTrace();
        g_StepTraceBp->m_Flags &= ~(DEBUG_BREAKPOINT_ENABLED |
                                    BREAKPOINT_INSERTED);
    }
    if (g_ScopeBuffer.State == ScopeFromContext &&
        g_ScopeBuffer.Process == this)
    {
        ResetCurrentScopeLazy();
    }
}

ThreadInfo*
ProcessInfo::FindThreadByUserId(ULONG Id)
{
    ThreadInfo* Thread;
    
    ForProcessThreads(this)
    {
        if (Thread->m_UserId == Id)
        {
            return Thread;
        }
    }
    return NULL;
}

ThreadInfo*
ProcessInfo::FindThreadBySystemId(ULONG Id)
{
    ThreadInfo* Thread;
    
    ForProcessThreads(this)
    {
        if (Thread->m_SystemId == Id)
        {
            return Thread;
        }
    }
    return NULL;
}

ThreadInfo*
ProcessInfo::FindThreadByHandle(ULONG64 Handle)
{
    ThreadInfo* Thread;
    
    ForProcessThreads(this)
    {
        if (Thread->m_Handle == Handle)
        {
            return Thread;
        }
    }
    return NULL;
}

void
ProcessInfo::InsertThread(ThreadInfo* Thread)
{
    ThreadInfo* Cur;
    ThreadInfo* Prev;

    Prev = NULL;
    for (Cur = m_ThreadHead; Cur; Cur = Cur->m_Next)
    {
        if (Cur->m_UserId > Thread->m_UserId)
        {
            break;
        }

        Prev = Cur;
    }
        
    Thread->m_Next = Cur;
    if (!Prev)
    {
        m_ThreadHead = Thread;
    }
    else
    {
        Prev->m_Next = Thread;
    }

    m_NumThreads++;
    Thread->m_Process = this;
    if (!m_CurrentThread)
    {
        m_CurrentThread = Thread;
    }

    m_Target->AddThreadToAllProcessInfo(this, Thread);
}

void
ProcessInfo::RemoveThread(ThreadInfo* Thread)
{
    ThreadInfo* Cur;
    ThreadInfo* Prev;

    Prev = NULL;
    for (Cur = m_ThreadHead; Cur; Cur = Cur->m_Next)
    {
        if (Cur == Thread)
        {
            break;
        }

        Prev = Cur;
    }

    if (!Cur)
    {
        return;
    }
    
    if (!Prev)
    {
        m_ThreadHead = Thread->m_Next;
    }
    else
    {
        Prev->m_Next = Thread->m_Next;
    }

    m_NumThreads--;
    Thread->m_Process = NULL;
    if (m_CurrentThread == Thread)
    {
        m_CurrentThread = m_ThreadHead;
    }

    m_Target->RemoveThreadFromAllProcessInfo(this, Thread);
}

HRESULT
ProcessInfo::CreateVirtualThreads(ULONG StartId, ULONG Threads)
{
    ThreadInfo* Thread;
    
    while (Threads-- > 0)
    {
        Thread = new ThreadInfo(this, VIRTUAL_THREAD_ID(StartId), 0,
                                VIRTUAL_THREAD_HANDLE(StartId), 0, 0);
        if (!Thread)
        {
            return E_OUTOFMEMORY;
        }
        
        StartId++;
    }

    return S_OK;
}

ImageInfo*
ProcessInfo::FindImageByIndex(ULONG Index)
{
    ImageInfo* Image = m_ImageHead;
    while (Index > 0 && Image != NULL)
    {
        Index--;
        Image = Image->m_Next;
    }
    return Image;
}

ImageInfo*
ProcessInfo::FindImageByOffset(ULONG64 Offset, BOOL AllowSynth)
{
    ImageInfo* Image = m_ImageHead;
    while (Image != NULL &&
           (Offset < Image->m_BaseOfImage ||
            Offset >= Image->m_BaseOfImage + Image->m_SizeOfImage))
    {
        Image = Image->m_Next;
    }

    //
    // If synthesized symbols are allowed, check those images
    // also.
    //
    
    if (!Image &&
        AllowSynth &&
        m_SynthesizedImage &&
        Offset >= m_SynthesizedImage->m_BaseOfImage &&
        Offset < m_SynthesizedImage->m_BaseOfImage +
        m_SynthesizedImage->m_SizeOfImage)
    {
        Image = m_SynthesizedImage;
    }
    
    return Image;
}

ImageInfo*
ProcessInfo::FindImageByName(PCSTR Name, ULONG NameChars,
                             INAME Which, BOOL AllowSynth)
{
    if (NameChars == 0)
    {
        NameChars = strlen(Name);
    }
    
    ImageInfo* Image = m_ImageHead;
    while (Image != NULL)
    {
        PCSTR WhichStr;

        switch(Which)
        {
        case INAME_IMAGE_PATH:
            WhichStr = Image->m_ImagePath;
            break;
        case INAME_IMAGE_PATH_TAIL:
            WhichStr = PathTail(Image->m_ImagePath);
            break;
        case INAME_MODULE:
            if (Image->m_OriginalModuleName[0] &&
                strlen(Image->m_OriginalModuleName) == NameChars &&
                !_memicmp(Image->m_OriginalModuleName, Name, NameChars))
            {
                return Image;
            }
            WhichStr = Image->m_ModuleName;
            break;
        }

        if (strlen(WhichStr) == NameChars &&
            _memicmp(WhichStr, Name, NameChars) == 0)
        {
            break;
        }

        Image = Image->m_Next;
    }

    //
    // If synthesized symbols are allowed, check those images
    // also.
    //
    
    if (!Image &&
        AllowSynth &&
        m_SynthesizedImage &&
        Which == INAME_MODULE &&
        strlen(m_SynthesizedImage->m_ModuleName) == NameChars &&
        !_memicmp(m_SynthesizedImage->m_ModuleName, Name, NameChars))
    {
        Image = m_SynthesizedImage;
    }
    
    return Image;
}

BOOL
ProcessInfo::GetOffsetFromMod(PCSTR String, PULONG64 Offset)
{
    if (!strchr(String, '!'))
    {
        ULONG Len;
        BOOL End;
        
        //
        // Could be a module name or module$ for the end
        // of a module.
        //

        Len = strlen(String);
        if (Len == 0)
        {
            return FALSE;
        }

        if (String[Len - 1] == '$')
        {
            // Retrieving end-of-module.
            Len--;
            End = TRUE;
        }
        else
        {
            End = FALSE;
        }
        
        ImageInfo* Image = FindImageByName(String, Len, INAME_MODULE, TRUE);
        if (Image)
        {
            if (End)
            {
                *Offset = Image->m_BaseOfImage + Image->m_SizeOfImage;
            }
            else
            {
                *Offset = Image->m_BaseOfImage;
            }
            return TRUE;
        }
    }
    return FALSE;
}

COR_DLL
IsCorDll(PCSTR ImagePath)
{
    PCSTR ImagePathTail = PathTail(ImagePath);
    if (!_stricmp(ImagePathTail, "mscoree.dll"))
    {
        return COR_DLL_EE;
    }
    if (!_stricmp(ImagePathTail, "mscorwks.dll"))
    {
        return COR_DLL_WKS;
    }
    if (!_stricmp(ImagePathTail, "mscorsvr.dll"))
    {
        return COR_DLL_SVR;
    }
    return COR_DLL_INVALID;
}

void
ProcessInfo::InsertImage(ImageInfo* Image)
{
    ImageInfo* Cur;
    ImageInfo* Prev;

    Prev = NULL;
    for (Cur = m_ImageHead; Cur; Cur = Cur->m_Next)
    {
        if (Cur->m_BaseOfImage > Image->m_BaseOfImage)
        {
            break;
        }

        Prev = Cur;
    }
        
    Image->m_Next = Cur;
    if (!Prev)
    {
        m_ImageHead = Image;
    }
    else
    {
        Prev->m_Next = Image;
    }

    m_NumImages++;
    Image->m_Process = this;
    Image->m_Linked = TRUE;

    if (m_ExecutableImage == NULL)
    {
        // Try and locate the executable image entry for
        // the process to use as the process's name.
        ULONG NameLen = strlen(Image->m_ImagePath);
        if (NameLen > 4 &&
            !_stricmp(Image->m_ImagePath + NameLen - 4, ".exe"))
        {
            m_ExecutableImage = Image;
        }
    }

    COR_DLL CorDll = IsCorDll(Image->m_ImagePath);
    if (CorDll > m_CorImageType)
    {
        m_CorImage = Image;
        m_CorImageType = CorDll;
    }
}

void
ProcessInfo::RemoveImage(ImageInfo* Image)
{
    ImageInfo* Cur;
    ImageInfo* Prev;

    Prev = NULL;
    for (Cur = m_ImageHead; Cur; Cur = Cur->m_Next)
    {
        if (Cur == Image)
        {
            break;
        }

        Prev = Cur;
    }

    if (!Cur)
    {
        return;
    }
    
    if (!Prev)
    {
        m_ImageHead = Image->m_Next;
    }
    else
    {
        Prev->m_Next = Image->m_Next;
    }

    m_NumImages--;
    Image->m_Process = NULL;
    Image->m_Linked = FALSE;
    if (m_ExecutableImage == Image)
    {
        m_ExecutableImage = NULL;
    }

    if (m_CorImageType != COR_DLL_INVALID &&
        IsCorDll(Image->m_ImagePath) != COR_DLL_INVALID)
    {
        m_CorImage = NULL;
        m_CorImageType = COR_DLL_INVALID;
    }
}

BOOL
ProcessInfo::DeleteImageByName(PCSTR Name, INAME Which)
{
    ImageInfo* Image;

    for (Image = m_ImageHead; Image; Image = Image->m_Next)
    {
        PCSTR WhichStr;

        switch(Which)
        {
        case INAME_IMAGE_PATH:
            WhichStr = Image->m_ImagePath;
            break;
        case INAME_IMAGE_PATH_TAIL:
            WhichStr = PathTail(Image->m_ImagePath);
            break;
        case INAME_MODULE:
            WhichStr = Image->m_ModuleName;
            break;
        }
        
        if (!_stricmp(WhichStr, Name))
        {
            delete Image;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
ProcessInfo::DeleteImageByBase(ULONG64 BaseOfImage)
{
    ImageInfo* Image;

    for (Image = m_ImageHead; Image; Image = Image->m_Next)
    {
        if (Image->m_BaseOfImage == BaseOfImage)
        {
            delete Image;
            return TRUE;
        }
    }

    return FALSE;
}

void
ProcessInfo::DeleteImagesBelowOffset(ULONG64 Offset)
{
    ImageInfo* Image, *Next;
    ULONG Count = 0;
    
    // Suppress notifications until all images are deleted.
    g_EngNotify++;

    for (Image = m_ImageHead; Image; Image = Next)
    {
        Next = Image->m_Next;
        
        if (Image->m_BaseOfImage < Offset)
        {
            delete Image;
            Count++;
        }
    }

    g_EngNotify--;
    if (Count)
    {
        NotifyChangeSymbolState(DEBUG_CSS_UNLOADS, 0, this);
    }
}

void
ProcessInfo::DeleteImages(void)
{
    // Suppress notifications until all images are deleted.
    g_EngNotify++;

    while (m_ImageHead)
    {
        delete m_ImageHead;
    }

    g_EngNotify--;
    NotifyChangeSymbolState(DEBUG_CSS_UNLOADS, 0, this);
}

HRESULT
ProcessInfo::AddImage(PMODULE_INFO_ENTRY ModEntry,
                      BOOL ForceSymbolLoad,
                      ImageInfo** ImageAdded)
{
    ImageInfo* ImageNew;
    IMAGEHLP_MODULE64 SymModInfo;
    ULONG64 LoadAddress;
    BOOL LoadSymbols = TRUE;
    PCSTR ImagePathTail;
    MODLOAD_DATA ModLoadData;
    HRESULT Status;
    BOOL ReusedExisting = FALSE;

#if DBG_MOD_LIST
    dprintf("AddImage:\n"
            " ImagePath       %s\n"
            " File            %I64x\n"
            " BaseOfImage     %I64x\n"
            " SizeOfImage     %x\n"
            " CheckSum        %x\n"
            " ModuleName      %s\n"
            " ForceSymbolLoad %d\n",
            ModEntry->NamePtr,
            (ULONG64)(ULONG_PTR)File,
            ModEntry->Base,
            ModEntry->Size,
            ModEntry->CheckSum,
            ModEntry->ModuleName,
            ForceSymbolLoad);
#endif

    if (ModEntry->NamePtr == NULL)
    {
        WarnOut("AddImage(NULL) fails\n");
        return E_INVALIDARG;
    }

    if (ModEntry->NamePtr &&
        IS_USER_TARGET(m_Target) &&
        m_Target->m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        TranslateNtPathName(ModEntry->NamePtr);
    }
    
    //
    // Search for existing image at same base address.
    // If found, remove symbols, but leave image structure intact.
    //

    for (ImageNew = m_ImageHead; ImageNew; ImageNew = ImageNew->m_Next)
    {
        if (ImageNew->m_BaseOfImage == ModEntry->Base)
        {
            VerbOut("Force unload of %s\n", ImageNew->m_ImagePath);
            ImageNew->DeleteResources(FALSE);
            break;
        }
    }

    //
    // If we didn't reuse an existing image, allocate
    // a new one.
    //

    if (!ImageNew)
    {
        ImageNew = new ImageInfo(this,
                                 ModEntry->NamePtr, ModEntry->Base, TRUE);
        if (ImageNew == NULL)
        {
            ErrOut("Unable to allocate memory for %s symbols.\n",
                   ModEntry->NamePtr);
            return E_OUTOFMEMORY;
        }

        // Module name is set later after possible renaming.
        ImageNew->m_File = ModEntry->File;
        ImageNew->m_CheckSum = ModEntry->CheckSum;
        ImageNew->m_TimeDateStamp = ModEntry->TimeDateStamp;
        ImageNew->m_SymState = ISS_MATCHED;
        ImageNew->m_UserMode = ModEntry->UserMode;
    }
    else
    {
        ReusedExisting = TRUE;
        
        // Update the reused entry with the latest information.
        if (ModEntry->NamePtr)
        {
            CopyString(ImageNew->m_ImagePath, ModEntry->NamePtr,
                       DIMA(ImageNew->m_ImagePath));
        }
        else
        {
            ImageNew->m_ImagePath[0] = 0;
        }
    }

    // Always update the entry size as this allows users
    // to update explicit entries (.reload image.ext=base,size)
    // without having to unload them first.
    ImageNew->m_SizeOfImage = ModEntry->Size;

    ImagePathTail = PathTail(ImageNew->m_ImagePath);

    if (ForceSymbolLoad)
    {
        // Try to load the image memory right away in this
        // case to catch incomplete-information errors.
        if (!ImageNew->DemandLoadImageMemory(!ReusedExisting, TRUE))
        {
            if (!ReusedExisting)
            {
                g_EngNotify++;
                delete ImageNew;
                g_EngNotify--;
            }
            return E_OUTOFMEMORY;
        }
    }
    
    if (IS_KERNEL_TARGET(m_Target))
    {
        CHAR Buf[MAX_IMAGE_PATH];
        MODULE_ALIAS_LIST* ModAlias;
        
        //
        // Determine the actual image name for kernel images which
        // are known to have multiple identities.
        //
        
        if ((ModEntry->ModuleName &&
             _stricmp(ModEntry->ModuleName, KERNEL_MODULE_NAME) == 0) ||
             ModEntry->Base == m_Target->m_KdDebuggerData.KernBase)
        {
            ModAlias = &g_AliasLists[MODALIAS_KERNEL];
        }
        else
        {
            ModAlias = FindModuleAliasList(ImagePathTail, NULL);
        }
        if (ModAlias)
        {
            if (GetModnameFromImage(this, ModEntry->Base, NULL,
                                    Buf, sizeof(Buf), FALSE))
            {
                CopyString(ImageNew->m_ImagePath, Buf,
                           DIMA(ImageNew->m_ImagePath));
            }
            ModEntry->ModuleName = (PSTR)ModAlias->BaseModule;
        }
        else if (ImageNew->m_SizeOfImage == 0 &&
            ((_stricmp(ImagePathTail, NTLDR_IMAGE_NAME) == 0) ||
             (_stricmp(ImagePathTail, NTLDR_IMAGE_NAME ".exe") == 0) ||
             (_stricmp(ImagePathTail, OSLOADER_IMAGE_NAME) == 0) ||
             (_stricmp(ImagePathTail, OSLOADER_IMAGE_NAME ".exe") == 0) ||
             (_stricmp(ImagePathTail, SETUPLDR_IMAGE_NAME) == 0) ||
             (_stricmp(ImagePathTail, SETUPLDR_IMAGE_NAME ".exe") == 0)))
        {
            ImageNew->m_SizeOfImage = LDR_IMAGE_SIZE;
        }
    }
    else if (!IS_DUMP_TARGET(m_Target))
    {
        //
        // When debugging CSR, LSA or Services.exe, force the use of local-only
        // symbols. Otherwise we can deadlock the entire machine when trying
        // to load the symbol file from the network.
        //

        if (((LiveUserTargetInfo*)m_Target)->m_Local &&
            (_stricmp(ImagePathTail, CSRSS_IMAGE_NAME) == 0 ||
             _stricmp(ImagePathTail, LSASS_IMAGE_NAME) == 0 ||
             _stricmp(ImagePathTail, SERVICES_IMAGE_NAME) == 0))
        {
            if (g_EngOptions & DEBUG_ENGOPT_ALLOW_NETWORK_PATHS)
            {
                //
                // Since the user has chambered a round and pointed the barrel
                // of the gun at his head, we may as well tell him that it's
                // going to hurt if he pulls the trigger.
                //

                WarnOut("WARNING: Using network symbols with %s\n",
                        ImagePathTail);
                WarnOut("WARNING: You may deadlock your machine.\n");
            }
            else
            {
                g_EngOptions |= DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS;
            }
        }

        if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
        {
            DWORD NetPath;

            NetPath = NetworkPathCheck(g_SymbolSearchPath);
            if (NetPath == ERROR_FILE_OFFLINE)
            {
                ErrOut("ERROR: sympath contained network references but "
                       "they were not allowed.\n");
                ErrOut("Symbols not loaded for %s\n",
                       ImagePathTail);
                LoadSymbols = FALSE;
            }
            else if (NetPath == ERROR_BAD_PATHNAME)
            {
                VerbOut("WARNING: sympath contains invalid references.\n");
            }
        }
    }

    if (ModEntry->ModuleName == NULL)
    {
        CreateModuleNameFromPath(ImageNew->m_ImagePath,
                                 ImageNew->m_ModuleName);
        RestrictModNameChars(ImageNew->m_ModuleName, ImageNew->m_ModuleName);
        strcpy(ImageNew->m_OriginalModuleName, ImageNew->m_ModuleName);
    }
    else
    {
        RestrictModNameChars(ModEntry->ModuleName, ImageNew->m_ModuleName);
        
        //
        // We have an alias, so keep original module name from path
        //
        CreateModuleNameFromPath(ImageNew->m_ImagePath,
                                 ImageNew->m_OriginalModuleName);
        RestrictModNameChars(ImageNew->m_OriginalModuleName,
                             ImageNew->m_OriginalModuleName);
    }
    
    //
    // Check for duplicate module names and
    // image overlaps.
    //

    ImageInfo* Check;
    
    for (Check = m_ImageHead; Check != NULL; Check = Check->m_Next)
    {
        if (Check != ImageNew &&
            !_strcmpi(ImageNew->m_ModuleName, Check->m_ModuleName))
        {
            int Len = strlen(ImageNew->m_ModuleName);
            
            // Module names match, so qualify with the base address.
            // Resulting name must be unique since base addresses are.
            if (m_Target->m_Machine->m_Ptr64)
            {
                if (Len >= MAX_MODULE - 17)
                {
                    Len = MAX_MODULE - 18;
                }
                sprintf(ImageNew->m_ModuleName + Len, "_%I64x",
                        ModEntry->Base);
            }
            else
            {
                if (Len >= MAX_MODULE - 9)
                {
                    Len = MAX_MODULE - 10;
                }
                sprintf(ImageNew->m_ModuleName + Len, "_%x",
                        (ULONG)ModEntry->Base);
            }
            
            // Force all references to this module to be
            // through the exact module name and not through
            // an original name that may have been ambiguous.
            ImageNew->m_OriginalModuleName[0] = 0;
        }

        if (Check != ImageNew &&
            ImageNew->m_BaseOfImage <
            Check->m_BaseOfImage + Check->m_SizeOfImage &&
            Check->m_BaseOfImage <
            ImageNew->m_BaseOfImage + ImageNew->m_SizeOfImage)
        {
            WarnOut("WARNING: %s overlaps %s\n",
                    ImageNew->m_ModuleName,
                    Check->m_ModuleName);
        }
    }

    //
    // If we do not want to load symbolic information, just return here.
    //

    if (!LoadSymbols)
    {
        *ImageAdded = ImageNew;
        return S_OK;
    }

    if (ModEntry->DebugHeader)
    {
        ModLoadData.ssize = sizeof(ModLoadData);
        ModLoadData.ssig  = DBHHEADER_DEBUGDIRS;
        ModLoadData.data  = ModEntry->DebugHeader;
        ModLoadData.size  = ModEntry->SizeOfDebugHeader;
        ModLoadData.flags = 0;
    }

    LoadAddress = SymLoadModuleEx(m_SymHandle,
                                  ImageNew->m_File,
                                  PrepareImagePath(ImageNew->m_ImagePath),
                                  ImageNew->m_ModuleName,
                                  ImageNew->m_BaseOfImage,
                                  ImageNew->m_SizeOfImage,
                                  ModEntry->DebugHeader ? &ModLoadData : NULL,
                                  0);
    if (!LoadAddress)
    {
        Status = WIN32_LAST_STATUS();
        
        VerbOut("SymLoadModule(%N, %N, \"%s\", \"%s\", %s, %x) fails\n",
                m_SymHandle,
                ImageNew->m_File,
                ImageNew->m_ImagePath,
                ImageNew->m_ModuleName,
                FormatAddr64(ImageNew->m_BaseOfImage),
                ImageNew->m_SizeOfImage);
        
        // We don't want deletion to notify of a symbol change
        // if this is a partially newly created image.
        if (!ReusedExisting)
        {
            g_EngNotify++;
        }
        delete ImageNew;
        if (!ReusedExisting)
        {
            g_EngNotify--;
        }
        return Status;
    }

    if (!ImageNew->m_BaseOfImage)
    {
        ImageNew->m_BaseOfImage = LoadAddress;
    }

    if (ForceSymbolLoad)
    {
        SymLoadModule64(m_SymHandle,
                        NULL,
                        NULL,
                        NULL,
                        ImageNew->m_BaseOfImage,
                        0);
    }

    SymModInfo.SizeOfStruct = sizeof(SymModInfo);
    if (SymGetModuleInfo64(m_SymHandle,
                           ImageNew->m_BaseOfImage, &SymModInfo))
    {
        ImageNew->m_SizeOfImage = SymModInfo.ImageSize;
    }
    else
    {
        Status = WIN32_LAST_STATUS();

        VerbOut("SymGetModuleInfo(%N, %s) fails\n",
                m_SymHandle, FormatAddr64(ImageNew->m_BaseOfImage));

        // We don't want DelImage to notify of a symbol change
        // if this is a partially newly created image.
        if (!ReusedExisting)
        {
            g_EngNotify++;
        }
        delete ImageNew;
        if (!ReusedExisting)
        {
            g_EngNotify--;
        }
        return Status;
    }

    if (ModEntry->ImageMachineTypeValid)
    {
        ImageNew->m_MachineType = ModEntry->MachineType;
    }
    
    StartOutLine(DEBUG_OUTPUT_VERBOSE, OUT_LINE_NO_PREFIX);
    VerbOut("ModLoad: %s %s   %-8s\n",
            FormatAddr64(ImageNew->m_BaseOfImage),
            FormatAddr64(ImageNew->m_BaseOfImage + ImageNew->m_SizeOfImage),
            ImageNew->m_ImagePath);

    NotifyChangeSymbolState(DEBUG_CSS_LOADS, ImageNew->m_BaseOfImage, this);

    *ImageAdded = ImageNew;
    return S_OK;
}

void
ProcessInfo::SynthesizeSymbols(void)
{
    // SynthesizeSymbols can result in symbol
    // callbacks but the symbols involved aren't real symbols
    // so suppress notifications.
    g_EngNotify++;
    
    if (m_Target->m_TypeInfo.UmSharedUserDataOffset)
    {
        //
        // Create a fake module for the shared user
        // data area.  Add a symbol for the system
        // call stub there if a stub exists.
        //

        ImageInfo* Image;

        Image = new ImageInfo(this, "SharedUserData",
                              m_Target->m_TypeInfo.UmSharedUserDataOffset,
                              FALSE);
        if (!Image)
        {
            WarnOut("Unable to create shared user data image\n");
        }
        else
        {
            Image->m_SizeOfImage = m_Target->m_Machine->m_PageSize;
            strcpy(Image->m_ModuleName, Image->m_ImagePath);
            strcpy(Image->m_OriginalModuleName, Image->m_ImagePath);
            
            if (!SymLoadModuleEx(m_SymHandle, NULL,
                                 Image->m_ImagePath,
                                 Image->m_ModuleName, Image->m_BaseOfImage,
                                 Image->m_SizeOfImage, NULL, SLMFLAG_VIRTUAL))
            {
                WarnOut("Unable to add shared user data module\n");
                delete Image;
            }
            else if (m_Target->m_TypeInfo.UmSharedSysCallOffset &&
                     !SymAddSymbol(m_SymHandle,
                                   Image->m_BaseOfImage,
                                   "SystemCallStub",
                                   m_Target->m_TypeInfo.UmSharedSysCallOffset,
                                   m_Target->m_TypeInfo.UmSharedSysCallSize,
                                   0))
            {
                WarnOut("Unable to add system call symbol\n");
                delete Image;
            }
            else
            {
                m_SynthesizedImage = Image;
            }
        }
    }
    
    g_EngNotify--;
}

void
ProcessInfo::VerifyKernel32Version(void)
{
    ImageInfo* Image = FindImageByName("kernel32", 8, INAME_MODULE, FALSE);
    if (!Image)
    {
        return;
    }
    
    //
    // Verify the OS version matches kernel32's image version.
    //

    IMAGE_NT_HEADERS64 NtHeaders;
    
    if (m_Target->ReadImageNtHeaders(this, Image->m_BaseOfImage,
                                     &NtHeaders) == S_OK)
    {
        if (NtHeaders.OptionalHeader.MajorImageVersion !=
            m_Target->m_KdVersion.MajorVersion ||
            NtHeaders.OptionalHeader.MinorImageVersion !=
            m_Target->m_KdVersion.MinorVersion)
        {
            WarnOut("WARNING: System version is %d.%d but "
                    "kernel32.dll is version %d.%d.\n",
                    m_Target->m_KdVersion.MajorVersion,
                    m_Target->m_KdVersion.MinorVersion,
                    NtHeaders.OptionalHeader.MajorImageVersion,
                    NtHeaders.OptionalHeader.MinorImageVersion);
            if (IS_USER_DUMP(m_Target))
            {
                WarnOut("If this dump was generated by userdump.exe on "
                        "Windows NT 4.0 the dump\n"
                        "version is probably incorrect.  "
                        "Set DBGENG_FULL_DUMP_VERSION=4.0 in your\n"
                        "environment to override the dump version.\n");
            }
        }
    }
}

BOOL
ProcessInfo::DeleteExitedInfos(void)
{
    ThreadInfo* Thread;
    ThreadInfo* ThreadNext;
    BOOL DeletedSomething = FALSE;
            
    for (Thread = m_ThreadHead; Thread; Thread = ThreadNext)
    {
        ThreadNext = Thread->m_Next;
                
        if (Thread->m_Exited)
        {
            delete Thread;
            DeletedSomething = TRUE;
        }
    }

    ImageInfo* Image;
    ImageInfo* ImagePrev;
    ImageInfo* ImageNext;

    ImagePrev = NULL;
    for (Image = m_ImageHead; Image; Image = ImageNext)
    {
        ImageNext = Image->m_Next;
                    
        if (Image->m_Unloaded)
        {
            delete Image;
            DeletedSomething = TRUE;
        }
        else
        {
            ImagePrev = Image;
        }
    }

    return DeletedSomething;
}

void
ProcessInfo::PrepareForExecution(void)
{
    ThreadInfo* Thread;

    ForProcessThreads(this)
    {
        Thread->PrepareForExecution();
    }
    
    ResetImplicitData();
    m_VirtualCache.Empty();
    m_VirtualCache.SetForceDecodePtes(FALSE, m_Target);

    FlushCorState();
}

void
ProcessInfo::OutputThreadInfo(ThreadInfo* Match, BOOL Verbose)
{
    ThreadInfo* Thread;

    Thread = m_ThreadHead;
    while (Thread)
    {
        if (Match == NULL || Match == Thread)
        {
            ULONG64 DataOffset;
            HRESULT Status;
            char CurMark;

            Status =
                m_Target->
                GetThreadInfoDataOffset(Thread, 0, &DataOffset);
            if (Status != S_OK)
            {
                WarnOut("Unable to get thread data for thread %u\n",
                        Thread->m_UserId);
                DataOffset = 0;
            }

            if (Thread == g_Thread)
            {
                CurMark = '.';
            }
            else if (Thread == g_EventThread)
            {
                CurMark = '#';
            }
            else
            {
                CurMark = ' ';
            }
            
            dprintf("%c%3ld  Id: %lx.%lx Suspend: %d Teb: %s ",
                    CurMark,
                    Thread->m_UserId,
                    m_SystemId,
                    Thread->m_SystemId,
                    Thread->m_SuspendCount,
                    FormatAddr64(DataOffset));
            if (Thread->m_Frozen)
            {
                dprintf("Frozen  ");
            }
            else
            {
                dprintf("Unfrozen");
            }
            if (Thread->m_Name[0])
            {
                dprintf(" \"%s\"", Thread->m_Name);
            }
            dprintf("\n");

            if (Verbose)
            {
                dprintf("      ");
                if (!Thread->m_StartOffset)
                {
                    if (m_Target->
                        GetThreadStartOffset(Thread,
                                             &Thread->m_StartOffset) != S_OK)
                    {
                        Thread->m_StartOffset = 0;
                    }
                }
                if (Thread->m_StartOffset)
                {
                    dprintf("Start: ");
                    OutputSymAddr(Thread->m_StartOffset,
                                  SYMADDR_FORCE | SYMADDR_OFFSET, NULL);
                }
                dprintf("\n");
            }
        }

        if (CheckUserInterrupt())
        {
            break;
        }
        
        Thread = Thread->m_Next;
    }
}

HRESULT
ProcessInfo::AddOopFuncTableDll(PWSTR Dll, ULONG64 Handle)
{
    OUT_OF_PROC_FUNC_TABLE_DLL* OopDll;

    OopDll = (OUT_OF_PROC_FUNC_TABLE_DLL*)
        malloc(sizeof(*OopDll) + (wcslen(Dll) + 1) * sizeof(Dll));
    if (!OopDll)
    {
        return E_OUTOFMEMORY;
    }

    OopDll->Next = m_OopFuncTableDlls;
    m_OopFuncTableDlls = OopDll;
    OopDll->Handle = Handle;
    wcscpy((PWSTR)(OopDll + 1), Dll);

    return S_OK;
}

void
ProcessInfo::ClearOopFuncTableDlls(void)
{
    while (m_OopFuncTableDlls)
    {
        OUT_OF_PROC_FUNC_TABLE_DLL* OopDll = m_OopFuncTableDlls;
        m_OopFuncTableDlls = OopDll->Next;

        if (IS_LIVE_USER_TARGET(m_Target))
        {
            ((LiveUserTargetInfo*)m_Target)->m_Services->
                FreeLibrary(OopDll->Handle);
        }

        free(OopDll);
    }
}
    
OUT_OF_PROC_FUNC_TABLE_DLL*
ProcessInfo::FindOopFuncTableDll(PWSTR Dll)
{
    OUT_OF_PROC_FUNC_TABLE_DLL* OopDll;

    for (OopDll = m_OopFuncTableDlls; OopDll; OopDll = OopDll->Next)
    {
        if (!_wcsicmp(Dll, (PWSTR)(OopDll + 1)))
        {
            return OopDll;
        }
    }

    return NULL;
}

HRESULT
ProcessInfo::LoadCorDebugDll(void)
{
    HRESULT Status;
    MachineInfo* CorMachine;
    
    if (m_CorDebugDll)
    {
        return S_OK;
    }
    if (!m_CorImage ||
        !(CorMachine = MachineTypeInfo(m_Target,
                                       m_CorImage->GetMachineType())))
    {
        return E_UNEXPECTED;
    }

    VS_FIXEDFILEINFO CorVer;
            
    if ((Status = m_Target->
         GetImageVersionInformation(this,
                                    m_CorImage->m_ImagePath,
                                    m_CorImage->m_BaseOfImage,
                                    "\\", &CorVer, sizeof(CorVer),
                                    NULL)) != S_OK)
    {
        ErrOut("Unable to get version information for %s\n",
               m_CorImage->m_ModuleName);
        return Status;
    }

    PSTR CorDacType;

    switch(m_CorImageType)
    {
    case COR_DLL_EE:
        CorDacType = "ee";
        break;
    case COR_DLL_WKS:
        CorDacType = "wks";
        break;
    case COR_DLL_SVR:
        CorDacType = "svr";
        break;
    default:
        ErrOut("Unknown runtime DLL type %s\n",
               m_CorImage->m_ModuleName);
        return E_INVALIDARG;
    }
    
    char DacDll[MAX_PATH];
    PSTR CorImagePath = NULL;
    PSTR Tail;

    // If this is a live session we want to look for the
    // debug DLL in the same place that the runtime is.
    // If this is a dump, we want to look in the same place
    // that the runtime image file was mapped from.
    if (IS_DUMP_TARGET(m_Target) &&
        m_CorImage->m_MappedImagePath[0])
    {
        CorImagePath = m_CorImage->m_MappedImagePath;
    }
    if (!CorImagePath)
    {
        CorImagePath = m_CorImage->m_ImagePath;
    }
    
    if (!CopyString(DacDll, CorImagePath, DIMA(DacDll)))
    {
        ErrOut("Runtime debugging DLL path overflow\n");
        return E_OUTOFMEMORY;
    }

    // We need to request the debugging DLL that runs
    // using the currently running processor type and
    // that can debug the current target's processor type.
#if defined(_X86_)
    PSTR HostCpu = "x86";
#elif defined(_IA64_)
    PSTR HostCpu = "IA64";
#elif defined(_AMD64_)
    PSTR HostCpu = "AMD64";
#elif defined(_ARM_)
    PSTR HostCpu = "ARM";
#else
#error Unknown processor.
#endif

    Tail = (PSTR)PathTail(DacDll);
    
    if (!PrintString(Tail, (ULONG)(DIMA(DacDll) - (Tail - DacDll)),
                     "mscordac%s_%s_%s_%u.%u.%u.%u%s.dll",
                     CorDacType,
                     HostCpu,
                     CorMachine->m_AbbrevName,
                     CorVer.dwFileVersionMS >> 16,
                     CorVer.dwFileVersionMS & 0xffff,
                     CorVer.dwFileVersionLS >> 16,
                     CorVer.dwFileVersionLS & 0xffff,
                     (CorVer.dwFileFlags & VS_FF_DEBUG) ?
                     ((CorVer.dwFileFlags & VS_FF_PRIVATEBUILD) ?
                      ".fastchecked" : ".checked") : ""))
    {
        ErrOut("Runtime debugging DLL path overflow\n");
        return E_OUTOFMEMORY;
    }

    //
    // First try and load the debugging DLL using the same
    // path as the runtime DLL.  This makes it easy to pick
    // up debugging DLLs that come with runtime installations.
    //
    
    PSTR DllPath = DacDll;
    
    m_CorDebugDll = LoadLibrary(DllPath);
    if (!m_CorDebugDll &&
        (GetLastError() == ERROR_PATH_NOT_FOUND ||
         GetLastError() == ERROR_FILE_NOT_FOUND ||
         GetLastError() == ERROR_MOD_NOT_FOUND))
    {
        // Couldn't find it, so allow a path search.
        DllPath = Tail;
        m_CorDebugDll = LoadLibrary(DllPath);
    }
    if (!m_CorDebugDll)
    {
        Status = WIN32_LAST_STATUS();
        VerbOut("Unable to load runtime debug DLL %s, %s\n",
                DllPath, FormatStatusCode(Status));
        return Status;
    }

    PFN_CreateCorDataAccess Entry = (PFN_CreateCorDataAccess)
        GetProcAddress(m_CorDebugDll, "CreateCorDataAccess");
    if (!Entry)
    {
        Status = WIN32_LAST_STATUS();
        FreeLibrary(m_CorDebugDll);
        m_CorDebugDll = NULL;
        ErrOut("Runtime debug DLL %s missing entry point\n", DllPath);
        return Status;
    }

    if ((Status = Entry(__uuidof(ICorDataAccess), &m_CorServices,
                        (void**)&m_CorAccess)) != S_OK)
    {
        FreeLibrary(m_CorDebugDll);
        m_CorDebugDll = NULL;
        ErrOut("Runtime debug DLL %s init failure, %s\n",
                DllPath, FormatStatusCode(Status));
        return Status;
    }
        
    VerbOut("Loaded runtime debug DLL %s\n", DllPath);

    return S_OK;
}

HRESULT
ProcessInfo::IsCorCode(ULONG64 Native)
{
    HRESULT Status;

    if ((Status = LoadCorDebugDll()) != S_OK)
    {
        return Status;
    }

    return m_CorAccess->IsCorCode(Native);
}

HRESULT
ProcessInfo::ConvertNativeToIlOffset(ULONG64 Native,
                                     PULONG64 ImageBase,
                                     PULONG32 MethodToken,
                                     PULONG32 MethodOffs)
{
    HRESULT Status;

    if ((Status = LoadCorDebugDll()) != S_OK)
    {
        return Status;
    }

    if ((Status = m_CorAccess->
         GetILOffsetFromTargetAddress(Native, ImageBase,
                                      MethodToken, MethodOffs)) != S_OK)
    {
        return Status;
    }

    if (!FindImageByOffset(*ImageBase, FALSE))
    {
        IMAGE_NT_HEADERS64 NtHdr;
        char Name[MAX_IMAGE_PATH];
        
        // XXX drewb - Need to work out when the
        // module list should be updated for managed
        // code that's not system-loaded.
        // We don't know about this module, so load it
        // right now.
        if (m_Target->ReadImageNtHeaders(this, *ImageBase, &NtHdr) == S_OK &&
            GetModnameFromImage(this, *ImageBase, NULL,
                                Name, DIMA(Name), TRUE))
        {
            char ReloadCmd[MAX_IMAGE_PATH];
            PCSTR ArgsRet;

            PrintString(ReloadCmd, DIMA(ReloadCmd), "%s=0x%s,0x%x",
                        Name, FormatAddr64(*ImageBase),
                        NtHdr.OptionalHeader.SizeOfImage);
            m_Target->Reload(m_CurrentThread, ReloadCmd, &ArgsRet);

            ImageInfo* Image = FindImageByOffset(*ImageBase, FALSE);
            if (Image)
            {
                Image->m_CorImage = TRUE;
            }
        }
    }
    
    return S_OK;
}

HRESULT
ProcessInfo::GetCorSymbol(ULONG64 Native, PSTR Buffer, ULONG BufferChars,
                          PULONG64 Displacement)
{
    HRESULT Status;

    if ((Status = LoadCorDebugDll()) != S_OK)
    {
        return Status;
    }

    WCHAR SymWide[MAX_SYMBOL_LEN];
    
    if ((Status = m_CorAccess->
         GetCodeSymbolForTargetAddress(Native, SymWide, DIMA(SymWide),
                                       Displacement)) != S_OK)
    {
        return Status;
    }

    if (!WideCharToMultiByte(CP_ACP, 0, SymWide, -1,
                             Buffer, BufferChars,
                             NULL, NULL))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

ICorDataStackWalk*
ProcessInfo::StartCorStack(ULONG32 CorThreadId)
{
    HRESULT Status;
    ICorDataStackWalk* Walk;

    if ((Status = LoadCorDebugDll()) != S_OK)
    {
        return NULL;
    }

    if ((Status = m_CorAccess->StartStackWalk(CorThreadId,
                                              DAC_STACK_ALL_FRAMES,
                                              &Walk)) != S_OK)
    {
        return NULL;
    }

    return Walk;
}

HRESULT
ProcessInfo::Terminate(void)
{
    if (!IS_LIVE_USER_TARGET(m_Target))
    {
        return E_UNEXPECTED;
    }
    
    PUSER_DEBUG_SERVICES Services =
        ((LiveUserTargetInfo*)m_Target)->m_Services;
    HRESULT Status = S_OK;
    
    if (!m_Exited)
    {
        if ((m_Flags & ENG_PROC_EXAMINED) == 0 &&
            (Status = Services->TerminateProcess(m_SysHandle,
                                                 E_FAIL)) != S_OK)
        {
            ErrOut("TerminateProcess failed, %s\n",
                   FormatStatusCode(Status));
        }
        else
        {
            MarkExited();
        }
    }

    return Status;
}

HRESULT
ProcessInfo::Detach(void)
{
    if (!IS_LIVE_USER_TARGET(m_Target))
    {
        return E_UNEXPECTED;
    }
    
    PUSER_DEBUG_SERVICES Services =
        ((LiveUserTargetInfo*)m_Target)->m_Services;
    HRESULT Status = S_OK;
    
    if (!m_Exited)
    {
        if ((m_Flags & ENG_PROC_EXAMINED) == 0 &&
            (Status = Services->DetachProcess(m_SystemId)) != S_OK)
        {
            // Older systems don't support detach so
            // don't show an error message in that case.
            if (Status != E_NOTIMPL)
            {
                ErrOut("DebugActiveProcessStop(%d) failed, %s\n",
                       m_SystemId, FormatStatusCode(Status));
            }
        }
        else
        {
            MarkExited();
        }
    }

    return Status;
}

HRESULT
ProcessInfo::Abandon(void)
{
    if (!IS_LIVE_USER_TARGET(m_Target))
    {
        return E_UNEXPECTED;
    }
    
    PUSER_DEBUG_SERVICES Services =
        ((LiveUserTargetInfo*)m_Target)->m_Services;
    HRESULT Status;

    if ((Status = Services->AbandonProcess(m_SysHandle)) != S_OK)
    {
        // Older systems don't support abandon so
        // don't show an error message in that case.
        if (Status != E_NOTIMPL)
        {
            ErrOut("Unable to abandon process\n");
        }
        return Status;
    }

    // We need to continue any existing event as it won't
    // be returned from WaitForDebugEvent again.  We
    // do not want to resume execution, though.
    if (m_Target->m_DeferContinueEvent)
    {
        if ((Status = Services->ContinueEvent(DBG_CONTINUE)) != S_OK)
        {
            ErrOut("Unable to continue abandoned event, %s\n",
                   FormatStatusCode(Status));
            return Status;
        }
        m_Target->m_DeferContinueEvent = FALSE;
    }

    return Status;
}

HRESULT
ProcessInfo::GetImplicitThreadData(ThreadInfo* Thread, PULONG64 Offset)
{
    HRESULT Status;

    if (m_ImplicitThreadData == 0 ||
        (m_ImplicitThreadDataIsDefault &&
         Thread != m_ImplicitThreadDataThread))
    {
        Status = SetImplicitThreadData(Thread, 0, FALSE);
    }
    else
    {
        Status = S_OK;
    }
    
    *Offset = m_ImplicitThreadData;
    return Status;
}

HRESULT
ProcessInfo::GetImplicitThreadDataTeb(ThreadInfo* Thread, PULONG64 Offset)
{
    if (IS_USER_TARGET(m_Target))
    {
        // In user mode the thread data is the TEB.
        return GetImplicitThreadData(Thread, Offset);
    }
    else if (IS_KERNEL_TARGET(m_Target))
    {
        return ReadImplicitThreadInfoPointer
            (Thread, m_Target->m_KdDebuggerData.OffsetKThreadTeb, Offset);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

HRESULT
ProcessInfo::SetImplicitThreadData(ThreadInfo* Thread,
                                   ULONG64 Offset, BOOL Verbose)
{
    HRESULT Status;
    BOOL Default = FALSE;
    
    if (Offset == 0)
    {
        if (!Thread || Thread->m_Process != this)
        {
            if (Verbose)
            {
                ErrOut("Unable to get the current thread data\n");
            }
            return E_UNEXPECTED;
        }
        
        if ((Status = m_Target->
             GetThreadInfoDataOffset(Thread, 0, &Offset)) != S_OK)
        {
            if (Verbose)
            {
                ErrOut("Unable to get the current thread data\n");
            }
            return Status;
        }
        if (Offset == 0)
        {
            if (Verbose)
            {
                ErrOut("Current thread data is NULL\n");
            }
            return E_FAIL;
        }

        Default = TRUE;
    }

    m_ImplicitThreadData = Offset;
    m_ImplicitThreadDataIsDefault = Default;
    m_ImplicitThreadDataThread = Thread;
    return S_OK;
}

HRESULT
ProcessInfo::ReadImplicitThreadInfoPointer(ThreadInfo* Thread,
                                           ULONG Offset, PULONG64 Ptr)
{
    HRESULT Status;
    ULONG64 CurThread;

    // Retrieve the current ETHREAD.
    if ((Status = GetImplicitThreadData(Thread, &CurThread)) != S_OK)
    {
        return Status;
    }

    return m_Target->
        ReadPointer(this, m_Target->m_Machine, CurThread + Offset, Ptr);
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

ProcessInfo*
FindAnyProcessByUserId(ULONG Id)
{
    TargetInfo* Target;
    ProcessInfo* Process;

    ForAllLayersToProcess()
    {
        if (Process->m_UserId == Id)
        {
            return Process;
        }
    }
    return NULL;
}

ProcessInfo*
FindAnyProcessBySystemId(ULONG Id)
{
    TargetInfo* Target;
    ProcessInfo* Process;

    ForAllLayersToProcess()
    {
        if (Process->m_SystemId == Id)
        {
            return Process;
        }
    }
    return NULL;
}

void
ParseProcessCmds(void)
{
    char Ch;
    ProcessInfo* Process;
    ULONG Id;

    if (!g_Target)
    {
        error(BADTHREAD);
    }
    
    Ch = PeekChar();
    if (Ch == '\0' || Ch == ';')
    {
        g_Target->OutputProcessInfo(NULL);
    }
    else
    {
        Process = g_Process;
        g_CurCmd++;
        if (Ch == '.')
        {
            ;
        }
        else if (Ch == '#')
        {
            Process = g_EventProcess;
        }
        else if (Ch == '*')
        {
            Process = NULL;
        }
        else if (Ch == '[')
        {
            g_CurCmd--;
            Id = (ULONG)GetTermExpression("Process ID missing from");
            Process = FindAnyProcessByUserId(Id);
            if (Process == NULL)
            {
                error(BADPROCESS);
            }
        }
        else if (Ch == '~')
        {
            if (*g_CurCmd != '[')
            {
                error(SYNTAX);
            }
            Id = (ULONG)GetTermExpression("Process ID missing from");
            Process = FindAnyProcessBySystemId(Id);
            if (Process == NULL)
            {
                error(BADPROCESS);
            }
        }
        else if (Ch >= '0' && Ch <= '9')
        {
            Id = 0;
            do
            {
                Id = Id * 10 + Ch - '0';
                Ch = *g_CurCmd++;
            } while (Ch >= '0' && Ch <= '9');
            g_CurCmd--;
            Process = FindAnyProcessByUserId(Id);
            if (Process == NULL)
            {
                error(BADPROCESS);
            }
        }
        else
        {
            g_CurCmd--;
        }
        
        Ch = PeekChar();
        if (Ch == '\0' || Ch == ';')
        {
            g_Target->OutputProcessInfo(Process);
        }
        else
        {
            g_CurCmd++;
            if (tolower(Ch) == 's')
            {
                if (Process == NULL)
                {
                    error(BADPROCESS);
                }
                if (Process->m_CurrentThread == NULL)
                {
                    Process->m_CurrentThread = Process->m_ThreadHead;
                    if (Process->m_CurrentThread == NULL)
                    {
                        error(BADPROCESS);
                    }
                }
                SetPromptThread(Process->m_CurrentThread,
                                SPT_DEFAULT_OCI_FLAGS);
            }
            else
            {
                g_CurCmd--;
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Process creation and attach functions.
//
//----------------------------------------------------------------------------

HRESULT
TerminateProcesses(void)
{
    HRESULT Status;

    if (!AnyLiveUserTargets())
    {
        // Nothing to do.
        return S_OK;
    }
        
    if (g_SymOptions & SYMOPT_SECURE)
    {
        ErrOut("SECURE: Process termination disallowed\n");
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    Status = PrepareForSeparation();
    if (Status != S_OK)
    {
        ErrOut("Unable to prepare for termination, %s\n",
               FormatStatusCode(Status));
        return Status;
    }

    TargetInfo* Target;
    HRESULT SingleStatus;

    ForAllLayersToTarget()
    {
        // If we fail in the middle of killing things there
        // isn't much that can be done so just attempt to
        // kill as many things as possible.
        if (IS_LIVE_USER_TARGET(Target) &&
            (SingleStatus = Target->TerminateProcesses()) != S_OK)
        {
            Status = SingleStatus;
        }
    }

    DiscardLastEvent();

    return Status;
}

HRESULT
DetachProcesses(void)
{
    HRESULT Status;

    if (!AnyLiveUserTargets())
    {
        // Nothing to do.
        return S_OK;
    }
        
    if (g_SymOptions & SYMOPT_SECURE)
    {
        ErrOut("SECURE: Process detach disallowed\n");
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    Status = PrepareForSeparation();
    if (Status != S_OK)
    {
        ErrOut("Unable to prepare for detach, %s\n",
               FormatStatusCode(Status));
        return Status;
    }

    TargetInfo* Target;
    HRESULT SingleStatus;

    ForAllLayersToTarget()
    {
        // If we fail in the middle of detaching things there
        // isn't much that can be done so just attempt to
        // detach as many things as possible.
        if (IS_LIVE_USER_TARGET(Target) &&
            (SingleStatus = Target->DetachProcesses()) != S_OK)
        {
            Status = SingleStatus;
        }
    }

    DiscardLastEvent();

    return Status;
}

HRESULT
SeparateCurrentProcess(ULONG Mode, PSTR Description)
{
    if (!IS_LIVE_USER_TARGET(g_Target) ||
        g_Process == NULL)
    {
        return E_INVALIDARG;
    }
    
    if (g_SymOptions & SYMOPT_SECURE)
    {
        ErrOut("SECURE: Process separation disallowed\n");
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    
    PUSER_DEBUG_SERVICES Services =
        ((LiveUserTargetInfo*)g_Target)->m_Services;

    if ((Mode == SEP_DETACH || Mode == SEP_TERMINATE) &&
        IS_CUR_CONTEXT_ACCESSIBLE())
    {
        ADDR Pc;

        // Move the PC past any current breakpoint instruction so that
        // the process has a chance of running.
        g_Machine->GetPC(&Pc);
        if (g_Machine->IsBreakpointInstruction(g_Process, &Pc))
        {
            g_Machine->AdjustPCPastBreakpointInstruction
                (&Pc, DEBUG_BREAKPOINT_CODE);
        }
    }
        
    // Flush any buffered changes.
    if (IS_CUR_CONTEXT_ACCESSIBLE())
    {
        g_Target->FlushRegContext();
    }
    
    if (g_EventProcess == g_Process && Mode != SEP_TERMINATE)
    {
        if (g_Target->m_DeferContinueEvent)
        {
            Services->ContinueEvent(DBG_CONTINUE);
            g_Target->m_DeferContinueEvent = FALSE;
        }
    }
    
    ((LiveUserTargetInfo*)g_Target)->
        SuspendResumeThreads(g_Process, FALSE, NULL);

    HRESULT Status;
    PSTR Operation;

    switch(Mode)
    {
    case SEP_DETACH:
        Status = g_Process->Detach();
        Operation = "Detached";
        break;
    case SEP_TERMINATE:
        Status = g_Process->Terminate();
        if ((g_Process->m_Flags & ENG_PROC_EXAMINED) == 0)
        {
            Operation = "Terminated.  "
                "Exit thread and process events will occur.";
        }
        else
        {
            Operation = "Terminated";
        }
        break;
    case SEP_ABANDON:
        Status = g_Process->Abandon();
        Operation = "Abandoned";
        break;
    }
    
    if (Status == S_OK)
    {
        if (Description != NULL)
        {
            strcpy(Description, Operation);
        }

        // If we're detaching or abandoning it's safe to go
        // ahead and remove the process now so that it
        // can't be access further.
        // If we're terminating we have to wait for
        // the exit events to come through so
        // keep the process until that happens.
        if (Mode != SEP_TERMINATE)
        {
            delete g_Process;
            SetToAnyLayers(TRUE);
        }
        else
        {
            g_Process->m_Exited = FALSE;
        }
    }
    else
    {
        ((LiveUserTargetInfo*)g_Target)->
            SuspendResumeThreads(g_Process, TRUE, NULL);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\process.hpp ===
//----------------------------------------------------------------------------
//
// Process abstraction.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#ifndef __PROCESS_HPP__
#define __PROCESS_HPP__

// In the kernel debugger there is a virtual process representing
// kernel space.  It has an artificial handle and threads
// representing each processor in the machine.
// A similar scheme is used in user dump files where real
// handles don't exist.
// With multiple systems there may be multiple kernel spaces,
// so the system user ID is added to the base fake ID to
// create a unique virtual process ID.
#define VIRTUAL_PROCESS_ID_BASE 0xf0f0f0f0
#define VIRTUAL_PROCESS_HANDLE(Id) ((HANDLE)(ULONG_PTR)(Id))

enum COR_DLL
{
    // These enumerants are ordered to
    // allow mscorwks/svr to override
    // mscoree as the "known" COR image
    // by value comparison.
    COR_DLL_INVALID,
    COR_DLL_EE,
    COR_DLL_WKS,
    COR_DLL_SVR,
};

//----------------------------------------------------------------------------
//
// Thread and process information is much different bewteen
// user and kernel debugging.  The structures exist and are
// as common as possible to enable common code.
//
// In user debugging process and thread info track the system
// processes and threads being debugged.
//
// In kernel debugging there is only one process that represents
// kernel space.  There is one thread per processor, each
// representing that processor's thread state.
//
//----------------------------------------------------------------------------

#define ENG_PROC_ATTACHED          0x00000001
#define ENG_PROC_CREATED           0x00000002
#define ENG_PROC_EXAMINED          0x00000004
#define ENG_PROC_ATTACH_EXISTING   0x00000008
// Currently the only system process specially marked is CSR.
#define ENG_PROC_SYSTEM            0x00000010
#define ENG_PROC_NO_SUSPEND_RESUME 0x00000020
#define ENG_PROC_NO_INITIAL_BREAK  0x00000040
#define ENG_PROC_RESUME_AT_ATTACH  0x00000080

#define ENG_PROC_ANY_ATTACH     (ENG_PROC_ATTACHED | ENG_PROC_EXAMINED)
#define ENG_PROC_ANY_EXAMINE    (ENG_PROC_EXAMINED | ENG_PROC_ATTACH_EXISTING)

// Handle must be closed when deleted.
// This flag applies to both processes and threads.
#define ENG_PROC_THREAD_CLOSE_HANDLE 0x80000000

// The debugger set the trace flag when deferring
// breakpoint work on the last event for this thread.
#define ENG_THREAD_DEFER_BP_TRACE 0x00000001

// Processes which were created or attached but that
// have not yet generated events yet.
typedef struct _PENDING_PROCESS
{
    ULONG64 Handle;
    // Initial thread information is only valid for creations.
    ULONG64 InitialThreadHandle;
    ULONG Id;
    ULONG InitialThreadId;
    ULONG Flags;
    ULONG Options;
    struct _PENDING_PROCESS* Next;
} PENDING_PROCESS;

struct IMPLICIT_THREAD_SAVE
{
    ULONG64 Value;
    BOOL Default;
    ThreadInfo* Thread;
};

struct OUT_OF_PROC_FUNC_TABLE_DLL
{
    OUT_OF_PROC_FUNC_TABLE_DLL* Next;
    ULONG64 Handle;
    // Name data follows.
};

//----------------------------------------------------------------------------
//
// ProcCorDataAccessServices.
//
//----------------------------------------------------------------------------

class ProcCorDataAccessServices : public ICorDataAccessServices
{
public:
    ProcCorDataAccessServices(void);
    
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // ICorDataAccessServices.
    virtual HRESULT STDMETHODCALLTYPE GetMachineType( 
        /* [out] */ ULONG32 *machine);
    virtual HRESULT STDMETHODCALLTYPE GetPointerSize( 
        /* [out] */ ULONG32 *size);
    virtual HRESULT STDMETHODCALLTYPE GetImageBase( 
        /* [string][in] */ LPCWSTR name,
        /* [out] */ CORDATA_ADDRESS *base);
    virtual HRESULT STDMETHODCALLTYPE ReadVirtual( 
        /* [in] */ CORDATA_ADDRESS address,
        /* [length_is][size_is][out] */ PBYTE buffer,
        /* [in] */ ULONG32 request,
        /* [optional][out] */ ULONG32 *done);
    virtual HRESULT STDMETHODCALLTYPE WriteVirtual( 
        /* [in] */ CORDATA_ADDRESS address,
        /* [size_is][in] */ PBYTE buffer,
        /* [in] */ ULONG32 request,
        /* [optional][out] */ ULONG32 *done);
    virtual HRESULT STDMETHODCALLTYPE GetTlsValue(
        /* [in] */ ULONG32 index,
        /* [out] */ CORDATA_ADDRESS* value);
    virtual HRESULT STDMETHODCALLTYPE SetTlsValue(
        /* [in] */ ULONG32 index,
        /* [in] */ CORDATA_ADDRESS value);
    virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadId(
        /* [out] */ ULONG32* threadId);
    virtual HRESULT STDMETHODCALLTYPE GetThreadContext(
        /* [in] */ ULONG32 threadId,
        /* [in] */ ULONG32 contextFlags,
        /* [in] */ ULONG32 contextSize,
        /* [out, size_is(contextSize)] */ PBYTE context);
    virtual HRESULT STDMETHODCALLTYPE SetThreadContext(
        /* [in] */ ULONG32 threadId,
        /* [in] */ ULONG32 contextSize,
        /* [in, size_is(contextSize)] */ PBYTE context);

    ProcessInfo* m_Process;
};

//----------------------------------------------------------------------------
//
// ProcessInfo.
//
//----------------------------------------------------------------------------

class ProcessInfo
{
public:
    ProcessInfo(TargetInfo* Target,
                ULONG SystemId,
                HANDLE SymHandle,
                ULONG64 SysHandle,
                ULONG Flags,
                ULONG Options);
    ~ProcessInfo(void);

    TargetInfo* m_Target;
    
    ProcessInfo* m_Next;
    ULONG m_NumImages;
    ULONG m_NumUnloadedModules;
    ImageInfo* m_ImageHead;
    ImageInfo* m_ExecutableImage;
    ImageInfo* m_SynthesizedImage;
    ULONG m_NumThreads;
    ThreadInfo* m_ThreadHead;
    ThreadInfo* m_CurrentThread;
    ULONG m_UserId;
    ULONG m_SystemId;
    ULONG m_Exited:1;
    ULONG m_ModulesLoaded:1;
    ULONG m_InitialBreakDone:1;
    ULONG m_InitialBreak:1;
    ULONG m_InitialBreakWx86:1;
    ULONG64 m_DataOffset;
    // For kernel mode and dumps the process handle is
    // a virtual handle for the kernel/dump process.
    // dbghelp still uses HANDLE as the process handle
    // type even though we may want to pass in 64-bit
    // process handles when remote debugging.  Keep
    // a cut-down version of the handle for normal
    // use but also keep the full handle around in
    // case it's needed.
    // There is also another purpose for the two handles:
    // as dbghelp has no notion of systems we need to
    // keep all handles from all systems unique.  The
    // dbghelp handle may be further modified in order
    // to preserve uniqueness.
    HANDLE m_SymHandle;
    ULONG64 m_SysHandle;
    ULONG m_Flags;
    ULONG m_Options;
    ULONG m_NumBreakpoints;
    class Breakpoint* m_Breakpoints;
    class Breakpoint* m_BreakpointsTail;
    ULONG64 m_DynFuncTableList;
    OUT_OF_PROC_FUNC_TABLE_DLL* m_OopFuncTableDlls;
    ULONG64 m_RtlUnloadList;
    
    ULONG64 m_ImplicitThreadData;
    BOOL m_ImplicitThreadDataIsDefault;
    ThreadInfo* m_ImplicitThreadDataThread;

    ImageInfo* m_CorImage;
    COR_DLL m_CorImageType;
    HMODULE m_CorDebugDll;
    ICorDataAccess* m_CorAccess;
    ProcCorDataAccessServices m_CorServices;
    
    VirtualMemoryCache m_VirtualCache;

    ThreadInfo* FindThreadByUserId(ULONG Id);
    ThreadInfo* FindThreadBySystemId(ULONG Id);
    ThreadInfo* FindThreadByHandle(ULONG64 Handle);
    
    void InsertThread(ThreadInfo* Thread);
    void RemoveThread(ThreadInfo* Thread);
    HRESULT CreateVirtualThreads(ULONG StartId, ULONG Threads);

    ImageInfo* FindImageByIndex(ULONG Index);
    ImageInfo* FindImageByOffset(ULONG64 Offset, BOOL AllowSynth);
    ImageInfo* FindImageByName(PCSTR Name, ULONG NameChars,
                               INAME Which, BOOL AllowSynth);

    BOOL GetOffsetFromMod(PCSTR String, PULONG64 Offset);
    
    void InsertImage(ImageInfo* Image);
    void RemoveImage(ImageInfo* Image);
    BOOL DeleteImageByName(PCSTR Name, INAME Which);
    BOOL DeleteImageByBase(ULONG64 Base);
    void DeleteImagesBelowOffset(ULONG64 Offset);
    void DeleteImages(void);
    HRESULT AddImage(PMODULE_INFO_ENTRY ModEntry,
                     BOOL ForceSymbolLoad,
                     ImageInfo** ImageAdded);
    void SynthesizeSymbols(void);
    void VerifyKernel32Version(void);
    
    BOOL DeleteExitedInfos(void);
    void PrepareForExecution(void);

    void OutputThreadInfo(ThreadInfo* Match, BOOL Verbose);

    HRESULT AddOopFuncTableDll(PWSTR Dll, ULONG64 Handle);
    void ClearOopFuncTableDlls(void);
    OUT_OF_PROC_FUNC_TABLE_DLL* FindOopFuncTableDll(PWSTR Dll);

    HRESULT LoadCorDebugDll(void);
    HRESULT IsCorCode(ULONG64 Native);
    HRESULT ConvertNativeToIlOffset(ULONG64 Native,
                                    PULONG64 ImageBase,
                                    PULONG32 MethodToken,
                                    PULONG32 MethodOffs);
    HRESULT GetCorSymbol(ULONG64 Native, PSTR Buffer, ULONG BufferChars,
                         PULONG64 Displacement);
    ICorDataStackWalk* StartCorStack(ULONG32 CorThreadId);
    void FlushCorState(void)
    {
        if (m_CorDebugDll)
        {
            m_CorAccess->Flush();
        }
    }
    
    HRESULT Terminate(void);
    HRESULT Detach(void);
    HRESULT Abandon(void);

    void ResetImplicitData(void)
    {
        m_ImplicitThreadData = 0;
        m_ImplicitThreadDataIsDefault = TRUE;
        m_ImplicitThreadDataThread = NULL;
    }
    void SaveImplicitThread(IMPLICIT_THREAD_SAVE* Save)
    {
        Save->Value = m_ImplicitThreadData;
        Save->Default = m_ImplicitThreadDataIsDefault;
        Save->Thread = m_ImplicitThreadDataThread;
    }
    void RestoreImplicitThread(IMPLICIT_THREAD_SAVE* Save)
    {
        m_ImplicitThreadData = Save->Value;
        m_ImplicitThreadDataIsDefault = Save->Default;
        m_ImplicitThreadDataThread = Save->Thread;
    }
    
    HRESULT GetImplicitThreadData(ThreadInfo* Thread, PULONG64 Offset);
    HRESULT GetImplicitThreadDataTeb(ThreadInfo* Thread, PULONG64 Offset);
    HRESULT SetImplicitThreadData(ThreadInfo* Thread,
                                  ULONG64 Offset, BOOL Verbose);
    HRESULT ReadImplicitThreadInfoPointer(ThreadInfo* Thread,
                                          ULONG Offset, PULONG64 Ptr);

    void MarkExited(void)
    {
        m_Exited = TRUE;
        g_EngDefer |= ENG_DEFER_DELETE_EXITED;
    }

    PSTR GetExecutableImageName(void)
    {
        return m_ExecutableImage ?
            m_ExecutableImage->m_ImagePath :
            (m_ImageHead != NULL ?
             m_ImageHead->m_ImagePath : "?NoImage?");
    }
};

ProcessInfo* FindAnyProcessByUserId(ULONG Id);

void ParseProcessCmds(void);

HRESULT TerminateProcesses(void);
HRESULT DetachProcesses(void);

enum
{
    SEP_TERMINATE,
    SEP_DETACH,
    SEP_ABANDON,
};

HRESULT SeparateCurrentProcess(ULONG Mode, PSTR Description);

#endif // #ifndef __PROCESS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ntsdp.hpp ===
//----------------------------------------------------------------------------
//
// Global header file.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __NTSDP_HPP__
#define __NTSDP_HPP__

#pragma warning(3:4101) // Unreferenced local variable.

// Always turn GUID definitions on.  This requires a compiler
// with __declspec(selectany) to compile properly.
#define INITGUID

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define STATUS_CPP_EH_EXCEPTION    0xe06d7363

#include <windows.h>

#define _IMAGEHLP64
#include <dbghelp.h>

#include <kdbg1394.h>
#define NOEXTAPI
#include <wdbgexts.h>
#define DEBUG_NO_IMPLEMENTATION
#include <dbgeng.h>
#include <ntdbg.h>

#include "dbgsvc.h"

#include <ntsdexts.h>
#include <vdmdbg.h>
#include <ntiodump.h>

#include <assert.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <crt\io.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#undef OVERFLOW

#include <ia64inst.h>
#include <dbhpriv.h>
#include <dbgimage.h>
#include <cmnutil.hpp>
#include <pparse.hpp>
#define NTDLL_APIS
#include <dllimp.h>
#include <cvconst.h>

#include <exdi.h>
#include <dbgeng_exdi_io.h>

typedef ULONG32 mdToken;
typedef mdToken mdMethodDef;
#include <cordac.h>


// Could not go into system header because CRITICAL_SECTION not defined in the
// kernel.

__inline
void
CriticalSection32To64(
    IN PRTL_CRITICAL_SECTION32 Cr32,
    OUT PRTL_CRITICAL_SECTION64 Cr64
    )
{
    COPYSE(Cr64,Cr32,DebugInfo);
    Cr64->LockCount = Cr32->LockCount;
    Cr64->RecursionCount = Cr32->RecursionCount;
    COPYSE(Cr64,Cr32,OwningThread);
    COPYSE(Cr64,Cr32,LockSemaphore);
    COPYSE(Cr64,Cr32,SpinCount);
}


//
// Pointer-size-specific system structures.
//

typedef struct _EXCEPTION_DEBUG_INFO32 {
    EXCEPTION_RECORD32 ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO32, *LPEXCEPTION_DEBUG_INFO32;

typedef struct _CREATE_THREAD_DEBUG_INFO32 {
    ULONG hThread;
    ULONG lpThreadLocalBase;
    ULONG lpStartAddress;
} CREATE_THREAD_DEBUG_INFO32, *LPCREATE_THREAD_DEBUG_INFO32;

typedef struct _CREATE_PROCESS_DEBUG_INFO32 {
    ULONG hFile;
    ULONG hProcess;
    ULONG hThread;
    ULONG lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    ULONG lpThreadLocalBase;
    ULONG lpStartAddress;
    ULONG lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO32, *LPCREATE_PROCESS_DEBUG_INFO32;

typedef struct _EXIT_THREAD_DEBUG_INFO32 {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO32, *LPEXIT_THREAD_DEBUG_INFO32;

typedef struct _EXIT_PROCESS_DEBUG_INFO32 {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO32, *LPEXIT_PROCESS_DEBUG_INFO32;

typedef struct _LOAD_DLL_DEBUG_INFO32 {
    ULONG hFile;
    ULONG lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    ULONG lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO32, *LPLOAD_DLL_DEBUG_INFO32;

typedef struct _UNLOAD_DLL_DEBUG_INFO32 {
    ULONG lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO32, *LPUNLOAD_DLL_DEBUG_INFO32;

typedef struct _OUTPUT_DEBUG_STRING_INFO32 {
    ULONG lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO32, *LPOUTPUT_DEBUG_STRING_INFO32;

typedef struct _RIP_INFO32 {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO32, *LPRIP_INFO32;

typedef struct _DEBUG_EVENT32 {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO32 Exception;
        CREATE_THREAD_DEBUG_INFO32 CreateThread;
        CREATE_PROCESS_DEBUG_INFO32 CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO32 ExitThread;
        EXIT_PROCESS_DEBUG_INFO32 ExitProcess;
        LOAD_DLL_DEBUG_INFO32 LoadDll;
        UNLOAD_DLL_DEBUG_INFO32 UnloadDll;
        OUTPUT_DEBUG_STRING_INFO32 DebugString;
        RIP_INFO32 RipInfo;
    } u;
} DEBUG_EVENT32, *LPDEBUG_EVENT32;

typedef struct _EXCEPTION_DEBUG_INFO64 {
    EXCEPTION_RECORD64 ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO64, *LPEXCEPTION_DEBUG_INFO64;

typedef struct _CREATE_THREAD_DEBUG_INFO64 {
    ULONG64 hThread;
    ULONG64 lpThreadLocalBase;
    ULONG64 lpStartAddress;
} CREATE_THREAD_DEBUG_INFO64, *LPCREATE_THREAD_DEBUG_INFO64;

typedef struct _CREATE_PROCESS_DEBUG_INFO64 {
    ULONG64 hFile;
    ULONG64 hProcess;
    ULONG64 hThread;
    ULONG64 lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    ULONG64 lpThreadLocalBase;
    ULONG64 lpStartAddress;
    ULONG64 lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO64, *LPCREATE_PROCESS_DEBUG_INFO64;

typedef struct _EXIT_THREAD_DEBUG_INFO64 {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO64, *LPEXIT_THREAD_DEBUG_INFO64;

typedef struct _EXIT_PROCESS_DEBUG_INFO64 {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO64, *LPEXIT_PROCESS_DEBUG_INFO64;

typedef struct _LOAD_DLL_DEBUG_INFO64 {
    ULONG64 hFile;
    ULONG64 lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    ULONG64 lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO64, *LPLOAD_DLL_DEBUG_INFO64;

typedef struct _UNLOAD_DLL_DEBUG_INFO64 {
    ULONG64 lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO64, *LPUNLOAD_DLL_DEBUG_INFO64;

typedef struct _OUTPUT_DEBUG_STRING_INFO64 {
    ULONG64 lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO64, *LPOUTPUT_DEBUG_STRING_INFO64;

typedef struct _RIP_INFO64 {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO64, *LPRIP_INFO64;

typedef struct _DEBUG_EVENT64 {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    DWORD __alignment;
    union {
        EXCEPTION_DEBUG_INFO64 Exception;
        CREATE_THREAD_DEBUG_INFO64 CreateThread;
        CREATE_PROCESS_DEBUG_INFO64 CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO64 ExitThread;
        EXIT_PROCESS_DEBUG_INFO64 ExitProcess;
        LOAD_DLL_DEBUG_INFO64 LoadDll;
        UNLOAD_DLL_DEBUG_INFO64 UnloadDll;
        OUTPUT_DEBUG_STRING_INFO64 DebugString;
        RIP_INFO64 RipInfo;
    } u;
} DEBUG_EVENT64, *LPDEBUG_EVENT64;


#define STATUS_VCPP_EXCEPTION 0x406d1388
#define VCPP_DEBUG_SET_NAME 0x1000

// This structure is passed as the lpArguments field of
// RaiseException so its members need to be decoded out
// of the exception arguments array.
typedef struct tagEXCEPTION_VISUALCPP_DEBUG_INFO32
{
    DWORD dwType;               // one of the enums from above
    union
    {
        struct
        {
            DWORD szName;       // pointer to name (in user addr space)
            DWORD dwThreadID;   // thread ID (-1=caller thread)
            DWORD dwFlags;      // reserved for future use (eg User thread, System thread)
        } SetName;
    };
} EXCEPTION_VISUALCPP_DEBUG_INFO32;

typedef struct tagEXCEPTION_VISUALCPP_DEBUG_INFO64
{
    DWORD dwType;               // one of the enums from above
    DWORD __alignment;
    union
    {
        struct
        {
            DWORD64 szName;     // pointer to name (in user addr space)
            DWORD dwThreadID;   // thread ID (-1=caller thread)
            DWORD dwFlags;      // reserved for future use (eg User thread, System thread)
        } SetName;
    };
} EXCEPTION_VISUALCPP_DEBUG_INFO64;


//
// Global declarations.
//

#define ENGINE_MOD_NAME "dbgeng"
#define ENGINE_DLL_NAME ENGINE_MOD_NAME ".dll"

#define ARRAYSIZE       20
#define STRLISTSIZE     128

#define MAX_SYMBOL_LEN MAX_SYM_NAME
// Allow space for a symbol, a code address, an EA and other things in
// a line of disassembly.
#define MAX_DISASM_LEN (MAX_SYMBOL_LEN + 128)

#define MAX_THREAD_NAME 32

// Maximum number of bytes possible for a breakpoint instruction.
// Currently sized to hold an entire IA64 bundle plus flags due to
// extraction and insertion considerations.
#define MAX_BREAKPOINT_LENGTH 20

#define MAX_SOURCE_PATH 1024
#define IS_SLASH(Ch) ((Ch) == '/' || (Ch) == '\\')
#define IS_SLASH_W(Ch) ((Ch) == L'/' || (Ch) == L'\\')
#define IS_PATH_DELIM(Ch) (IS_SLASH(Ch) || (Ch) == ':')
#define IS_PATH_DELIM_W(Ch) (IS_SLASH_W(Ch) || (Ch) == L':')

#define IS_EOF(Ch) ((Ch) == 0 || (Ch) == ';')
#define IS_OCTAL_DIGIT(Ch) ((Ch) >= '0' && (Ch) <= '7')

// Maximum command string.  DbgPrompt has a limit of 512
// characters so that would be one potential limit.  We
// have users who want to use longer command lines, though,
// such as Autodump which scripts the debugger with very long
// sx commands.  The other obvious limit is MAX_SYMBOL_LEN
// since it makes sense that you should be able to give a
// command with a full symbol name, so use that.
#define MAX_COMMAND MAX_SYMBOL_LEN

// Maximum length of a full path for an image.  Technically
// this can be very large but realistically it's rarely
// greater than MAX_PATH.  Use our own constant instead
// of MAX_PATH in case we need to raise it at some point.
// If this constant is increased it's likely that changes
// to dbghelp will be required to increase buffer sizes there.
#define MAX_IMAGE_PATH MAX_PATH

#define BUILD_MAJOR_VERSION (VER_PRODUCTVERSION_W >> 8)
#define BUILD_MINOR_VERSION (VER_PRODUCTVERSION_W & 0xff)
#define BUILD_REVISION      API_VERSION_NUMBER

#define KERNEL_MODULE_NAME       "nt"

#define KBYTES(Bytes) (((Bytes) + 1023) / 1024)

// Machine type indices for machine-type-indexed things.
enum MachineIndex
{
    MACHIDX_I386,
    MACHIDX_IA64,
    MACHIDX_AMD64,
    MACHIDX_ARM,
    MACHIDX_COUNT
};

enum
{
    OPTFN_ADD,
    OPTFN_REMOVE,
    OPTFN_SET
};

// Registry keys.
#define DEBUG_ENGINE_KEY "Software\\Microsoft\\Debug Engine"

// Possibly truncates and sign-extends a value to 64 bits.
#define EXTEND64(Val) ((ULONG64)(LONG64)(LONG)(Val))

#define IsPow2(Val) \
    (((Val) & ((Val) - 1)) == 0)

enum LAYER
{
    LAYER_TARGET,
    LAYER_PROCESS,
    LAYER_THREAD,
    LAYER_COUNT
};

//
// Specific modules.
//

typedef struct _ADDR* PADDR;
typedef struct _DESCRIPTOR64* PDESCRIPTOR64;
class DebugClient;
class TargetInfo;
class MachineInfo;
class ProcessInfo;
class ThreadInfo;
class ImageInfo;
class ModuleInfo;
class UnloadedModuleInfo;
class DbgKdTransport;
struct TypedData;
typedef struct _PENDING_PROCESS* PPENDING_PROCESS;

//
// Segment descriptor values.
// Due to the descriptor caching that x86 processors
// do this may differ from the actual in-memory descriptor and
// may be retrieved in a much different way.
//

#define X86_DESC_TYPE(Flags) ((Flags) & 0x1f)

#define X86_DESC_PRIVILEGE_SHIFT 5
#define X86_DESC_PRIVILEGE(Flags) (((Flags) >> X86_DESC_PRIVILEGE_SHIFT) & 3)

#define X86_DESC_PRESENT     0x80
#define X86_DESC_LONG_MODE   0x200
#define X86_DESC_DEFAULT_BIG 0x400
#define X86_DESC_GRANULARITY 0x800

// Special flags value that marks a descriptor as invalid.
#define SEGDESC_INVALID 0xffffffff

typedef struct _DESCRIPTOR64
{
    ULONG64 Base;
    ULONG64 Limit;
    ULONG Flags;
} DESCRIPTOR64, *PDESCRIPTOR64;

// Maximum value of MAXIMUM_PROCESSORS
#define MAXIMUM_PROCS 64

#include "dbgrpc.hpp"

#include "dotcmd.h"
#include "dbgclt.hpp"
#include "addr.h"
#include "mcache.hpp"
#include "target.hpp"
#include "modinfo.hpp"
#include "image.hpp"
#include "thread.hpp"
#include "process.hpp"
#include "register.h"
#include "machine.hpp"
#include "typedata.hpp"
#include "dbgsym.hpp"
#include "callback.h"
#include "symbols.h"

#include "alias.hpp"
#include "brkpt.hpp"
#include "dbgkdtrans.hpp"
#include "event.h"
#include "expr.hpp"
#include "exts.h"
#include "float10.h"
#include "instr.h"
#include "memcmd.h"
#include "mmap.hpp"
#include "ntcmd.h"
#include "source.h"
#include "symtype.h"
#include "stepgo.hpp"
#include "stkwalk.h"
#include "util.h"
#include "vdm.h"

#include "amd64_reg.h"
#include "arm_reg.h"
#include "i386_reg.h"
#include "ia64_reg.h"

#include "arm_mach.hpp"
#include "i386_mach.hpp"
// Must come after i386_mach.hpp.
#include "amd64_mach.hpp"
#include "ia64_mach.hpp"

// Must come after target.hpp.
#include "dump.hpp"

#include "dbgsvc.hpp"

//
//  The Splay function takes as input a pointer to a splay link in a tree
//  and splays the tree.  Its function return value is a pointer to the
//  root of the splayed tree.
//

PRTL_SPLAY_LINKS
pRtlSplay (
    PRTL_SPLAY_LINKS Links
    );

//
//  The Delete function takes as input a pointer to a splay link in a tree
//  and deletes that node from the tree.  Its function return value is a
//  pointer to the root of the tree.  If the tree is now empty, the return
//  value is NULL.
//

PRTL_SPLAY_LINKS
pRtlDelete (
    PRTL_SPLAY_LINKS Links
    );


#define EnumerateLocals(CallBack, Context) \
SymEnumSymbols(g_Process->m_SymHandle, \
           0,                          \
           NULL,                       \
           CallBack,                   \
           Context                     \
           )

#endif // ifndef __NTSDP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\register.h ===
//----------------------------------------------------------------------------
//
// Register commands and support.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _REGISTER_H_
#define _REGISTER_H_

#define REG_ERROR (0xffffffffUL)

#define REG_PSEUDO_FIRST 0x7ffffe00
enum
{
    PSEUDO_LAST_EXPR = REG_PSEUDO_FIRST,
    PSEUDO_EFF_ADDR,
    PSEUDO_LAST_DUMP,
    PSEUDO_RET_ADDR,
    PSEUDO_IMP_THREAD,
    PSEUDO_IMP_PROCESS,
    PSEUDO_IMP_TEB,
    PSEUDO_IMP_PEB,
    PSEUDO_IMP_THREAD_ID,
    PSEUDO_IMP_THREAD_PROCESS_ID,
    PSEUDO_RETURN_REGISTER,
    PSEUDO_INSTRUCTION_POINTER,
    PSEUDO_EVENT_INSTRUCTION_POINTER,
    PSEUDO_PREVIOUS_INSTRUCTION_POINTER,
    PSEUDO_RELATED_INSTRUCTION_POINTER,
    PSEUDO_TEMP_0,
    PSEUDO_TEMP_1,
    PSEUDO_TEMP_2,
    PSEUDO_TEMP_3,
    PSEUDO_TEMP_4,
    PSEUDO_TEMP_5,
    PSEUDO_TEMP_6,
    PSEUDO_TEMP_7,
    PSEUDO_TEMP_8,
    PSEUDO_TEMP_9,
    PSEUDO_EXE_ENTRY,
    PSEUDO_DBG_THREAD_ID,
    PSEUDO_DBG_PROCESS_ID,
    PSEUDO_DBG_SYSTEM_ID,
    PSEUDO_AFTER_LAST
};
#define REG_PSEUDO_LAST ((int)PSEUDO_AFTER_LAST - 1)
#define REG_PSEUDO_COUNT (REG_PSEUDO_LAST - REG_PSEUDO_FIRST + 1)

#define REG_PSEUDO_TEMP_COUNT 10

#define REG_USER_FIRST 0x7fffff00
// Could support more user registers by allowing letters as names in
// addition to digits, or by allowing multiple digits.  Both may
// present compatibility issues.
#define REG_USER_COUNT 10
#define REG_USER_LAST  (REG_USER_FIRST + REG_USER_COUNT - 1)

enum
{
    REGVAL_ERROR,
    REGVAL_INT16,
    REGVAL_SUB32,
    REGVAL_INT32,
    REGVAL_SUB64,
    REGVAL_INT64,
    REGVAL_INT64N,   // 64-bit + Nat bit
    REGVAL_FLOAT8,
    // x86 80-bit FP.
    REGVAL_FLOAT10,
    // IA64 82-bit FP.
    REGVAL_FLOAT82,
    REGVAL_FLOAT16,
    REGVAL_VECTOR64,
    REGVAL_VECTOR128,
};

// Defines a mapping from register name to register index.
typedef struct _REGDEF
{
    PSTR Name;
    ULONG Index;
} REGDEF;

// Defines a mapping from an index to a portion of a register.
typedef struct _REGSUBDEF
{
    ULONG SubReg;
    ULONG FullReg;
    ULONG Shift;
    ULONG64 Mask;
} REGSUBDEF;

// Holds the contents of a register.
typedef struct _REGVAL
{
    int Type;
    union
    {
        USHORT I16;
        ULONG I32;
        struct
        {
            ULONG64 I64;
            UCHAR Nat;
        };
        struct
        {
            ULONG Low;
            ULONG High;
            UCHAR Nat;
        } I64Parts;
        double F8;
        UCHAR F10[10];
        UCHAR F82[11];
        struct
        {
            ULONG64 Low;
            LONG64 High;
        } F16Parts;
        UCHAR F16[16];
        UCHAR Bytes[16];
    };
} REGVAL;

//
// Defines sets of information to display when showing all registers.
//

// Cross-platform.  64-bit display takes precedence over 32-bit display
// if both are enabled.
#define REGALL_INT32            0x00000001
#define REGALL_INT64            0x00000002
#define REGALL_FLOAT            0x00000004

// Given specific meanings per-platform (3 is XMM on all platforms).
#define REGALL_EXTRA0           0x00000008
#define REGALL_EXTRA1           0x00000010
#define REGALL_EXTRA2           0x00000020
#define REGALL_XMMREG           0x00000040
#define REGALL_EXTRA4           0x00000080
#define REGALL_EXTRA5           0x00000100
#define REGALL_EXTRA6           0x00000200
#define REGALL_EXTRA7           0x00000400
#define REGALL_EXTRA8           0x00000800
#define REGALL_EXTRA9           0x00001000
#define REGALL_EXTRA10          0x00002000
#define REGALL_EXTRA11          0x00004000
#define REGALL_EXTRA12          0x00008000
#define REGALL_EXTRA13          0x00010000
#define REGALL_EXTRA14          0x00020000
#define REGALL_EXTRA15          0x00040000

#define REGALL_EXTRA_SHIFT      3

// Descriptions of REGALL_EXTRA flag meanings.
typedef struct _REGALLDESC
{
    ULONG Bit;
    PSTR Desc;
} REGALLDESC;

void ParseRegCmd(void);
void ExpandUserRegs(PSTR Str, ULONG StrLen);
BOOL NeedUpper(ULONG64 Val);

void GetPseudoOrRegVal(BOOL Scoped, ULONG Index, REGVAL* Val);
void SetPseudoOrRegVal(ULONG Index, REGVAL* Val);
BOOL GetPsuedoOrRegTypedData(BOOL Scoped, PCSTR Name, TypedData* Result);

PCSTR GetUserReg(ULONG index);
BOOL SetUserReg(ULONG index, PCSTR val);

ULONG RegIndexFromName(PCSTR Name);
PCSTR RegNameFromIndex(ULONG Index);
ULONG RegGetRegType(ULONG Index);

HRESULT
SetAndOutputContext(
    IN PCROSS_PLATFORM_CONTEXT TargetContext,
    IN BOOL CanonicalContext,
    IN ULONG AllMask
    );

HRESULT
SetAndOutputVirtualContext(
    IN ULONG64 ContextBase,
    IN ULONG AllMask
    );

#endif // #ifndef _REGISTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\source.cpp ===
//----------------------------------------------------------------------------
//
// Source file searching and loading.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#define DBG_SRC 0
#define VERBOSE_SRC 0

ULONG g_SrcOptions;

LPSTR g_SrcPath;
PSRCFILE g_SrcFiles;
PSRCFILE g_CurSrcFile;
ULONG g_CurSrcLine;

ULONG g_OciSrcBefore;
ULONG g_OciSrcAfter = 1;

ULONG g_LsSrcBefore = 4;
ULONG g_LsSrcTotal = 10;

PSRCFILE
LoadSrcFile(
    LPSTR PathComponent,
    LPSTR FileName,
    LPSTR RecordFileName
    )
{
    PathFile* File;
    PSRCFILE SrcFile, Realloc;
    ULONG Avail;
    ULONG BaseLen, Len, Done;
    LPSTR Cur, End;
    ULONG Lines;
    LPSTR *CurLine, LineStart;

    if (OpenPathFile(PathComponent, FileName, g_SymOptions, &File) != S_OK)
    {
        return NULL;
    }

    BaseLen = sizeof(SRCFILE) + strlen(RecordFileName) + 1;
    Len = BaseLen;
    SrcFile = NULL;
    for (;;)
    {
        if (File->QueryDataAvailable(&Avail) != S_OK)
        {
            goto EH_CloseFile;
        }
        if (Avail == 0)
        {
            if (SrcFile == NULL)
            {
                goto EH_CloseFile;
            }
            break;
        }

        Realloc = (SRCFILE *)realloc(SrcFile, Len + Avail);
        if (Realloc == NULL)
        {
            goto EH_CloseFile;
        }
        SrcFile = Realloc;
        
        if (File->Read((LPSTR)SrcFile + Len, Avail, &Done) != S_OK ||
            Done < Avail)
        {
            goto EH_CloseFile;
        }

        Len += Avail;
    }
    
    SrcFile->File = (LPSTR)(SrcFile + 1);
    strcpy(SrcFile->File, RecordFileName);
    SrcFile->RawText = (LPSTR)SrcFile + BaseLen;
    Len -= BaseLen;

    // Count lines in the source file.  Stop before the last character
    // to handle the case where there's a newline at the end of the
    // file in the same way as where there isn't one.

    Lines = 0;
    Cur = SrcFile->RawText;
    End = SrcFile->RawText + Len;
    while (Cur < End - 1)
    {
        if (*Cur++ == '\n')
        {
            Lines++;
        }
    }
    Lines++;

    SrcFile->LineText = (char **)malloc(sizeof(LPSTR) * Lines);
    if (SrcFile->LineText == NULL)
    {
        goto EH_CloseFile;
    }

    SrcFile->Lines = Lines;
    Cur = SrcFile->RawText;
    CurLine = SrcFile->LineText;
    LineStart = Cur;
    while (Cur < End - 1)
    {
        if (*Cur == '\n')
        {
            *CurLine++ = LineStart;
            *Cur = 0;
            LineStart = Cur+1;
        }
        else if (*Cur == '\r')
        {
            *Cur = 0;
        }
        Cur++;
    }
    *CurLine++ = LineStart;

    delete File;

    SrcFile->Next = g_SrcFiles;
    g_SrcFiles = SrcFile;

#if VERBOSE_SRC
    dprintf("Loaded '%s' '%s' %d lines\n", FileName, RecordFileName, Lines);
#endif

    return SrcFile;

 EH_CloseFile:
    free(SrcFile);
    delete File;
    return NULL;
}

void
DeleteSrcFile(
    PSRCFILE SrcFile
    )
{
    if (g_CurSrcFile == SrcFile)
    {
        g_CurSrcFile = NULL;
        g_CurSrcLine = 0;
    }

    free(SrcFile->LineText);
    free(SrcFile);
}

BOOL
MatchSrcFileName(
    PSRCFILE SrcFile,
    LPSTR File
    )
{
    LPSTR FileStop, MatchStop;

    //
    // SRCFILE filenames are saved as the partial path that
    // matched a source path component rather than the full path
    // of the file as loaded.  When matching against potentially full
    // path information in debug info it's useful to use the incoming
    // string as the filename and the SRCFILE filename as the match
    // string.  A full match indicates that the partial path matches
    // completely and so should be used.
    //
    // This doesn't work so well for human input where the filename is
    // likely to be just a filename with no path.  In this case there
    // won't be a full match of the match string, nor is just flipping
    // the order of strings useful because that would allow submatches
    // such as "foo.c" matching "barfoo.c".  Instead this code tests
    // two conditions:
    // 1.  Full match string match.
    // 2.  Full file string match (implies partial match string match)
    //     and the mismatch character is a path separator.
    //     This forces filenames to match completely.
    //

    if (SymMatchFileName(File, SrcFile->File, &FileStop, &MatchStop) ||
        (FileStop < File && IS_PATH_DELIM(*MatchStop)))
    {
#if DBG_SRC
        dprintf("'%s' matches '%s'\n", SrcFile->File, File);
#endif
        return TRUE;
    }
    else
    {
#if DBG_SRC
        dprintf("'%s' doesn't match '%s'\n", SrcFile->File, File);
#endif
        return FALSE;
    }
}

BOOL
UnloadSrcFile(
    LPSTR File
    )
{
    PSRCFILE SrcFile, Prev;

    Prev = NULL;
    for (SrcFile = g_SrcFiles; SrcFile != NULL; SrcFile = SrcFile->Next)
    {
        if (MatchSrcFileName(SrcFile, File))
        {
            break;
        }

        Prev = SrcFile;
    }

    if (SrcFile == NULL)
    {
        return FALSE;
    }

    if (Prev != NULL)
    {
        Prev->Next = SrcFile->Next;
    }
    else
    {
        g_SrcFiles = SrcFile->Next;
    }

    DeleteSrcFile(SrcFile);
    return TRUE;
}

void
UnloadSrcFiles(
    void
    )
{
    PSRCFILE Cur, Next;

    for (Cur = g_SrcFiles; Cur != NULL; Cur = Next)
    {
        Next = Cur->Next;

        DeleteSrcFile(Cur);
    }

    g_SrcFiles = NULL;
}

PSRCFILE
FindLoadedSrcFile(
    LPSTR File
    )
{
    PSRCFILE SrcFile;

    for (SrcFile = g_SrcFiles; SrcFile != NULL; SrcFile = SrcFile->Next)
    {
        if (MatchSrcFileName(SrcFile, File))
        {
#if DBG_SRC
            dprintf("Found loaded file '%s'\n", SrcFile->File);
#endif
            return SrcFile;
        }
    }

    return NULL;
}

BOOL
ConcatPathComponents(LPSTR Path,
                     LPSTR PathEnd,
                     LPSTR* PathOut,
                     LPSTR FilePath,
                     LPSTR Buffer,
                     ULONG BufferSize)
{
    if (PathEnd == NULL)
    {
        PathEnd = strchr(Path, ';');
        if (PathEnd != NULL)
        {
            if (PathOut != NULL)
            {
                *PathOut = PathEnd + 1;
            }
        }
        else
        {
            PathEnd = Path + strlen(Path);
            if (PathOut != NULL)
            {
                *PathOut = NULL;
            }
        }
    }

    if (PathEnd > Path)
    {
        ULONG Len = (ULONG)(PathEnd - Path);
        if (Len + 1 >= BufferSize)
        {
            return FALSE;
        }
        memcpy(Buffer, Path, Len);
        PathEnd = Buffer + (Len - 1);
        BufferSize -= Len - 1;

        // Attempt to avoid duplicating separators while forcing separation.
        if ((*PathEnd == ':' && *FilePath == ':') ||
            (IS_SLASH(*PathEnd) && IS_SLASH(*FilePath)))
        {
            FilePath++;
        }
        else if (!IS_PATH_DELIM(*PathEnd) && !IS_PATH_DELIM(*FilePath))
        {
            // We've guaranteed we have space for this character.
            *(++PathEnd) = '\\';
            BufferSize--;
        }
        
        return CopyString(PathEnd + 1, FilePath, BufferSize);
    }
    else
    {
        return CopyString(Buffer, FilePath, BufferSize);
    }
}

void
EditPathSlashes(
    LPSTR Path
    )
{
    if (!IsUrlPathComponent(Path))
    {
        return;
    }
    
    PSTR Scan = Path;
        
    // Flip all backslashes forwards.
    while (*Scan)
    {
        if (*Scan == '\\')
        {
            *Scan = '/';
        }
        
        Scan++;
    }
}

BOOL
SrcFileExists(
    LPSTR Path,
    LPSTR PathEnd,
    LPSTR* PathOut,
    LPSTR FilePath,
    LPSTR File
    )
{
    char Buffer[MAX_SOURCE_PATH];

    if (!ConcatPathComponents(Path, PathEnd, PathOut, FilePath,
                              Buffer, DIMA(Buffer)))
    {
        return FALSE;
    }
    
    if (File != NULL)
    {
        if (!CatString(Buffer, "\\", DIMA(Buffer)) ||
            !CatString(Buffer, File, DIMA(Buffer)))
        {
            return FALSE;
        }
    }

    EditPathSlashes(Buffer);

#if DBG_SRC
    dprintf("Check for existence of '%s'\n", Buffer);
#endif

    FILE_IO_TYPE IoType;
    
    return PathFileExists(Path, Buffer, g_SymOptions, &IoType);
}

BOOL
FindSrcFileOnPath(ULONG StartElement,
                  LPSTR File,
                  ULONG Flags,
                  PSTR Found,
                  ULONG FoundSize,
                  PSTR* MatchPart,
                  PULONG FoundElement)
{
    LPSTR PathSuff;
    LPSTR Path;
    LPSTR PathStart;
    LPSTR PathSep;
    LPSTR PathCharPtr;
    char PathChar;
    ULONG Elt;

    // Find the element of the path to start at.
    PathStart = FindPathElement(g_SrcPath, StartElement, &PathSep);
    if (PathStart == NULL)
    {
        goto CheckPlainFile;
    }

    // Split the given filename into a path prefix and a path
    // suffix.  Initially the path prefix is any path components
    // and the path suffix is just the filename.  If there
    // are path components attempt to match them against the source
    // path.  Keep backing up the path one component at a time
    // until a match is found or the prefix is emptied.  At
    // that point just do a plain file search along the source path.
    PathSuff = File + strlen(File);

    for (;;)
    {
        while (--PathSuff >= File)
        {
            if (IS_SLASH(*PathSuff) ||
                (*PathSuff == ':' && !IS_SLASH(*(PathSuff + 1))))
            {
                break;
            }
        }
        PathSuff++;

        // If we've run out of path prefix we're done with this
        // part of the search.
        if (PathSuff == File)
        {
            break;
        }

        char Save;
        LPSTR BestPathStart;
        LPSTR BestPathEnd;
        LPSTR BestFile;
        ULONG BestElement;
        LPSTR MatchPath;
        LPSTR MatchFile;

        Save = *(PathSuff - 1);
        *(PathSuff - 1) = 0;

#if DBG_SRC
        dprintf("Check path pre '%s' suff '%s'\n",
                File, PathSuff);
#endif

        Path = PathStart;
        Elt = StartElement;
        BestPathStart = NULL;
        BestFile = PathSuff - 2;
        while (*Path != 0)
        {
            PathSep = strchr(Path, ';');
            if (PathSep == NULL)
            {
                PathSep = Path + strlen(Path);
            }

            PathCharPtr = PathSep;
            if (!*PathSep)
            {
                // Back up off the terminator so that PathSep
                // can be advanced the same way for both
                // ';' and end-of-string cases.
                PathSep--;
            }

            // Trim trailing slashes on path components as
            // the file components have them trimmed so
            // leaving them would confuse the matching.
            if (PathCharPtr > Path && IS_SLASH(PathCharPtr[-1]))
            {
                PathCharPtr--;
            }
            PathChar = *PathCharPtr;
            if (PathChar != 0)
            {
                *PathCharPtr = 0;
            }
            
            SymMatchFileName(Path, File, &MatchPath, &MatchFile);

#if DBG_SRC
            dprintf("Match '%s' against '%s': %d (match '%s')\n",
                    Path, File, MatchFile - File, MatchFile + 1);
#endif

            *PathCharPtr = PathChar;

            if (MatchFile < BestFile &&
                SrcFileExists(Path, MatchPath + 1, NULL,
                              MatchFile + 1, PathSuff))
            {
                BestPathStart = Path;
                BestPathEnd = MatchPath + 1;
                BestFile = MatchFile + 1;
                BestElement = Elt;

                // Check for complete match or first-match mode.
                if (MatchPath < Path || MatchFile < File ||
                    (Flags & DEBUG_FIND_SOURCE_BEST_MATCH) == 0)
                {
                    break;
                }
            }

            Path = PathSep + 1;
            Elt++;
        }

        *(PathSuff - 1) = Save;

        if (BestPathStart != NULL)
        {
#if DBG_SRC
            dprintf("Found partial file '%.*s' on path '%.*s'\n",
                    PathSuff - BestFile, BestFile,
                    BestPathEnd - BestPathStart, BestPathStart);
#endif
                    
            // Return the match found.
            if (!ConcatPathComponents(BestPathStart, BestPathEnd, NULL,
                                      BestFile, Found, FoundSize))
            {
                return FALSE;
            }
            EditPathSlashes(Found);
            *MatchPart = BestFile;
            *FoundElement = BestElement;
            
#if DBG_SRC
            dprintf("Found partial file '%s' at %d\n",
                    Found, *FoundElement);
#endif
            
            return TRUE;
        }

        // Skip past separator.
        PathSuff--;
    }

    // Traverse all directories in the source path and try them with the
    // filename given.  Start with the given filename
    // to make the most restrictive check.  If
    // no match is found keep trimming components off and
    // checking again.

    PathSuff = File;
    
    for (;;)
    {
#if DBG_SRC
        dprintf("Scan all paths for '%s'\n", PathSuff);
#endif
        
        Path = PathStart;
        Elt = StartElement;
        while (Path != NULL && *Path != 0)
        {
            if (SrcFileExists(Path, NULL, &PathSep, PathSuff, NULL))
            {
                // SrcFileExists leaves PathSep set to the
                // path element after the separator so back up
                // one when forming the return path.
                if (PathSep != NULL)
                {
                    PathSep--;
                }
                
#if DBG_SRC
                dprintf("Found file suffix '%s' on path '%.*s'\n",
                        PathSuff, PathSep != NULL ?
                        PathSep - Path : strlen(Path), Path);
#endif

                if (!ConcatPathComponents(Path, PathSep, NULL, PathSuff,
                                          Found, FoundSize))
                {
                    return FALSE;
                }
                EditPathSlashes(Found);
                *MatchPart = PathSuff;
                *FoundElement = Elt;

#if DBG_SRC
                dprintf("Found file suffix '%s' at %d\n",
                        Found, *FoundElement);
#endif
            
                return TRUE;
            }

            Path = PathSep;
            Elt++;
        }

        // Trim a component from the front of the path suffix.
        PathSep = PathSuff;
        while (*PathSep != 0 &&
               !IS_SLASH(*PathSep) &&
               (*PathSep != ':' || IS_SLASH(*(PathSep + 1))))
        {
            PathSep++;
        }
        if (*PathSep == 0)
        {
            // Nothing left to trim.
            break;
        }

        PathSuff = PathSep + 1;
    }

 CheckPlainFile:

#if DBG_SRC
    dprintf("Check plain file '%s'\n", File);
#endif
    
    DWORD OldErrMode;
    DWORD FileAttrs;

    if (g_SymOptions & SYMOPT_FAIL_CRITICAL_ERRORS)
    {
        OldErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    }
    
    FileAttrs = GetFileAttributes(File);

    if (g_SymOptions & SYMOPT_FAIL_CRITICAL_ERRORS)
    {
        SetErrorMode(OldErrMode);
    }

    if (FileAttrs != -1)
    {
        CopyString(Found, File, FoundSize);
        *MatchPart = File;
        *FoundElement = -1;

#if DBG_SRC
        dprintf("Found plain file '%s' at %d\n", Found, *FoundElement);
#endif
        
        return TRUE;
    }
    
    return FALSE;
}

PSRCFILE
LoadSrcFileOnPath(
    LPSTR File
    )
{
    if (g_SrcPath == NULL)
    {
        return LoadSrcFile(NULL, File, File);
    }

    char Found[MAX_SOURCE_PATH];
    PSTR MatchPart;
    ULONG Elt;

    if (FindSrcFileOnPath(0, File, DEBUG_FIND_SOURCE_BEST_MATCH,
                          Found, DIMA(Found), &MatchPart, &Elt))
    {
        PSTR PathComponent;
        PSTR Sep;
        char SepChar;
        PSRCFILE SrcFile;

        if (Elt != -1)
        {
            PathComponent = FindPathElement(g_SrcPath, Elt, &Sep);
            SepChar = *Sep;
        }
        else
        {
            // FindSrcFileOnPath found the file directly under
            // its name instead of on the path.
            PathComponent = NULL;
            Sep = NULL;
        }
        
        SrcFile = LoadSrcFile(PathComponent, Found, MatchPart);

        if (Sep)
        {
            *Sep = SepChar;
        }
        return SrcFile;
    }
    
    dprintf("No source found for '%s'\n", File);

    return NULL;
}

PSRCFILE
FindSrcFile(
    LPSTR File
    )
{
    PSRCFILE SrcFile;

#if DBG_SRC
    dprintf("Find '%s'\n", File);
#endif

    SrcFile = FindLoadedSrcFile(File);
    if (SrcFile == NULL)
    {
        SrcFile = LoadSrcFileOnPath(File);
    }
    return SrcFile;
}

void
OutputSrcLines(
    PSRCFILE File,
    ULONG First,
    ULONG Last,
    ULONG Mark
    )
{
    ULONG i;
    LPSTR *Text;

    if (First < 1)
    {
        First = 1;
    }
    if (Last > File->Lines)
    {
        Last = File->Lines;
    }

    Text = &File->LineText[First-1];
    for (i = First; i <= Last; i++)
    {
        if (i == Mark)
        {
            dprintf(">");
        }
        else
        {
            dprintf(" ");
        }

        dprintf("%5d: %s\n", i, *Text++);
    }
}

BOOL
OutputSrcLinesAroundAddr(
    ULONG64 Offset,
    ULONG Before,
    ULONG After
    )
{
    IMAGEHLP_LINE64 Line;
    ULONG Disp;
    PSRCFILE SrcFile;

    if (!GetLineFromAddr(g_Process, Offset,
                         &Line, &Disp))
    {
        return FALSE;
    }

    SrcFile = FindSrcFile(Line.FileName);
    if (SrcFile == NULL)
    {
        return FALSE;
    }

    if (Before >= Line.LineNumber)
    {
        Before = Line.LineNumber - 1;
    }
    
    OutputSrcLines(SrcFile,
                   Line.LineNumber - Before, Line.LineNumber + After - 1,
                   Line.LineNumber);
    return TRUE;
}

ULONG
GetOffsetFromLine(
    PSTR FileLine,
    PULONG64 Offset
    )
{
    IMAGEHLP_LINE64 Line;
    LPSTR Mod;
    LPSTR File;
    LPSTR LineStr;
    LPSTR SlashF, SlashB;
    ULONG LineNum;
    ULONG Disp;
    ULONG OldSym;
    ULONG NewSym;
    BOOL  AllowDisp;
    BOOL  Ret;
    ImageInfo* Image = NULL;

    if ((g_SymOptions & SYMOPT_LOAD_LINES) == 0)
    {
        WarnOut("WARNING: Line information loading disabled\n");
    }

    OldSym = g_SymOptions;
    NewSym = g_SymOptions;
    
    // Symbol directives can prefix the source expression.
    // These can be given by sufficiently knowledgeable users
    // but they're primarily a back-channel communication
    // mechanism for windbg's source management.
    if (*FileLine == '<')
    {
        FileLine++;
        while (*FileLine != '>')
        {
            switch(*FileLine)
            {
            case 'U':
                // Restrict the search to just loaded modules.
                NewSym |= SYMOPT_NO_UNQUALIFIED_LOADS;
                break;
            default:
                error(SYNTAX);
            }

            FileLine++;
        }

        FileLine++;
    }
    
    // Crack string of the form [module!][file][:line] into its
    // components.  Note that ! is a valid filename character so
    // it's possible for ambiguity to occur between module references
    // and filenames.  This code assumes that ! is uncommon and
    // handles it as a module separator unless there's a : or \ or /
    // before it.  : can also occur in paths and is filtered
    // in a similar manner.

    File = strchr(FileLine, '!');
    LineStr = strchr(FileLine, ':');
    SlashF = strchr(FileLine, '/');
    SlashB = strchr(FileLine, '\\');

    if (File != NULL &&
        (LineStr != NULL && File > LineStr) ||
        (SlashF != NULL && File > SlashF) ||
        (SlashB != NULL && File > SlashB))
    {
        File = NULL;
    }

    if (File != NULL)
    {
        if (File == FileLine)
        {
            error(SYNTAX);
        }

        Mod = FileLine;
        *File++ = 0;
    }
    else
    {
        Mod = NULL;
        File = FileLine;
    }

    // If a module was specified check and see if it's
    // a module that's currently present as that
    // will affect which error code is returned.
    if (Mod != NULL)
    {
        Image = g_Process->FindImageByName(Mod, 0, INAME_MODULE, FALSE);
    }
    
    // Look for the first colon after path components.
    while (LineStr != NULL &&
           (LineStr < File || LineStr < SlashF || LineStr < SlashB))
    {
        LineStr = strchr(LineStr + 1, ':');
    }

    LineNum = 1;
    if (LineStr != NULL)
    {
        PSTR NumEnd;

        // A specific line was given so don't allow a displacement.
        AllowDisp = FALSE;
        *LineStr = 0;
        LineNum = strtoul(LineStr + 1, &NumEnd, 0);

        if (*NumEnd == '+')
        {
            // Setting the high bit of the line number
            // tells dbghelp to search in at-or-greater mode.
            // This may produce displacements so allow them.
            LineNum |= 0x80000000;
            AllowDisp = TRUE;
        }
        else if (*NumEnd == '~')
        {
            // Find the closest line number.
            AllowDisp = TRUE;
        }
        else if (*NumEnd && *NumEnd != ' ' && *NumEnd != '\t')
        {
            error(SYNTAX);
        }
    }
    else
    {
        AllowDisp = TRUE;
    }

    Line.SizeOfStruct = sizeof(Line);
    Ret = FALSE;

    // If this is a pure linenumber reference then we need to fill in
    // the line information with a current location before doing
    // the line-relative query.
    if (*File == 0)
    {
        ADDR Pc;

        if (Mod != NULL)
        {
            goto EH_Ret;
        }

        g_Machine->GetPC(&Pc);
        if (!GetLineFromAddr(g_Process, Flat(Pc), &Line, &Disp))
        {
            goto EH_Ret;
        }

        File = NULL;
    }

    // Establish any special symbol options requested.
    SymSetOptions(NewSym);
    
    Ret = SymGetLineFromName64(g_Process->m_SymHandle, Mod,
                               File, LineNum, (PLONG)&Disp, &Line);

    SymSetOptions(OldSym);

 EH_Ret:
    if (Mod != NULL)
    {
        *(File-1) = '!';
    }

    if (LineStr != NULL)
    {
        *LineStr = ':';
    }

    // Only return a match if it's exact or no line number was specified.
    if (Ret && (Disp == 0 || AllowDisp))
    {
        *Offset = Line.Address;
        return LINE_FOUND;
    }
    else if (Image != NULL)
    {
        return LINE_NOT_FOUND_IN_MODULE;
    }
    else
    {
        return LINE_NOT_FOUND;
    }
}

void
ParseSrcOptCmd(
    CHAR Cmd
    )
{
    char Cmd2;
    DWORD Opt;

    Cmd2 = PeekChar();
    if (Cmd2 == 'l')
    {
        g_CurCmd++;
        Opt = SRCOPT_LIST_LINE;
    }
    else if (Cmd2 == 'o')
    {
        g_CurCmd++;
        Opt = SRCOPT_LIST_SOURCE_ONLY;
    }
    else if (Cmd2 == 's')
    {
        g_CurCmd++;
        Opt = SRCOPT_LIST_SOURCE;
    }
    else if (Cmd2 == 't')
    {
        g_CurCmd++;
        Opt = SRCOPT_STEP_SOURCE;
    }
    else if (Cmd2 == '0')
    {
        // Numeric options.
        if (*(++g_CurCmd) != 'x')
        {
            error(SYNTAX);
        }
        else
        {
            g_CurCmd++;
            Opt = (DWORD)HexValue(4);
        }
    }
    else if (Cmd2 == '*')
    {
        g_CurCmd++;
        // All.
        Opt = 0xffffffff;
    }
    else if (Cmd2 != 0 && Cmd2 != ';')
    {
        error(SYNTAX);
    }
    else
    {
        // No character means display current settings.
        Opt = 0;
    }

    ULONG OldSrcOpt = g_SrcOptions;
    
    if (Cmd == '+')
    {
        g_SrcOptions |= Opt;

        if ((SymGetOptions() & SYMOPT_LOAD_LINES) == 0)
        {
            WarnOut("  WARNING: Line information loading disabled\n");
        }
    }
    else
    {
        g_SrcOptions &= ~Opt;
    }

    if ((OldSrcOpt ^ g_SrcOptions) & SRCOPT_STEP_SOURCE)
    {
        NotifyChangeEngineState(DEBUG_CES_CODE_LEVEL,
                                (g_SrcOptions & SRCOPT_STEP_SOURCE) ?
                                DEBUG_LEVEL_SOURCE : DEBUG_LEVEL_ASSEMBLY,
                                TRUE);
    }
    
    dprintf("Source options are %x:\n", g_SrcOptions);
    if (g_SrcOptions == 0)
    {
        dprintf("    None\n");
    }
    else
    {
        if (g_SrcOptions & SRCOPT_STEP_SOURCE)
        {
            dprintf("    %2x/t - Step/trace by source line\n",
                    SRCOPT_STEP_SOURCE);
        }
        if (g_SrcOptions & SRCOPT_LIST_LINE)
        {
            dprintf("    %2x/l - List source line for LN and prompt\n",
                    SRCOPT_LIST_LINE);
        }
        if (g_SrcOptions & SRCOPT_LIST_SOURCE)
        {
            dprintf("    %2x/s - List source code at prompt\n",
                    SRCOPT_LIST_SOURCE);
        }
        if (g_SrcOptions & SRCOPT_LIST_SOURCE_ONLY)
        {
            dprintf("    %2x/o - Only show source code at prompt\n",
                    SRCOPT_LIST_SOURCE_ONLY);
        }
    }
}

void
ParseSrcLoadCmd(
    void
    )
{
    LPSTR Semi;
    PSRCFILE SrcFile;
    char Cur;
    BOOL Unload;

    // Check for an unload request.
    Unload = FALSE;
    if (*g_CurCmd == '-')
    {
        g_CurCmd++;
        Unload = TRUE;
    }

    while ((Cur = *g_CurCmd) == ' ' || Cur == '\t')
    {
        g_CurCmd++;
    }

    if (Cur == 0 || Cur == ';')
    {
        error(SYNTAX);
    }

    // Look for a semicolon, otherwise assume the whole command
    // line is the file path.

    Semi = strchr(g_CurCmd, ';');
    if (Semi != NULL)
    {
        *Semi = 0;
    }

    if (Unload)
    {
        if (UnloadSrcFile(g_CurCmd))
        {
            dprintf("Unloaded '%s'\n", g_CurCmd);
        }
    }
    else
    {
        SrcFile = FindSrcFile(g_CurCmd);
        if (SrcFile == NULL)
        {
            dprintf("Unable to load '%s'\n", g_CurCmd);
        }
    }

    if (Semi != NULL)
    {
        *Semi = ';';
        g_CurCmd = Semi;
    }
    else
    {
        g_CurCmd += strlen(g_CurCmd);
    }

    if (!Unload && SrcFile != NULL)
    {
        g_CurSrcFile = SrcFile;
        g_CurSrcLine = 1;
    }
}

void
ParseSrcListCmd(
    CHAR Cmd
    )
{
    LONG First, Count;
    char Cur;
    ULONG OldBase;
    ADDR Addr;
    ULONG Mark;

    if (Cmd == '.')
    {
        g_CurCmd++;

        PDEBUG_SCOPE Scope = GetCurrentScope();
	if (Scope->Frame.InstructionOffset)
        {
	    // List current frame
	    ADDRFLAT(&Addr, Scope->Frame.InstructionOffset);
	}
        else
        {
	    // List at PC.
            if (!IS_CUR_MACHINE_ACCESSIBLE())
            {
                error(BADTHREAD);
            }
	    g_Machine->GetPC(&Addr);
	}
        Cmd = 'a';
    }
    else if (Cmd == 'a')
    {
        g_CurCmd++;

        // List at address, so get an address.
        GetAddrExpression(SEGREG_CODE, &Addr);

        // Search for and consume trailing ,
        while ((Cur = *g_CurCmd) == ' ' || Cur == '\t')
        {
            g_CurCmd++;
        }
        if (Cur == ',')
        {
            Cur = *++g_CurCmd;
            if (Cur == 0 || Cur == ';')
            {
                error(SYNTAX);
            }
        }
    }
    else if (Cmd == 'c')
    {
        g_CurCmd++;

        if (g_CurSrcFile != NULL)
        {
            dprintf("Current: %s(%d)\n", g_CurSrcFile->File, g_CurSrcLine);
        }
        else
        {
            dprintf("No current source file\n");
        }
        return;
    }

    while ((Cur = *g_CurCmd) == ' ' || Cur == '\t')
    {
        g_CurCmd++;
    }

    // Force base 10 for linenumbers.

    OldBase = g_DefaultRadix;
    g_DefaultRadix = 10;

    if (Cur == 0 || Cur == ';')
    {
        First = Cmd == 'a' ? -(LONG)g_LsSrcBefore : g_CurSrcLine;
        Count = g_LsSrcTotal;
    }
    else if (Cur == ',')
    {
        First = Cmd == 'a' ? -(LONG)g_LsSrcBefore : g_CurSrcLine;
        g_CurCmd++;
        Count = (ULONG)GetExpression();
    }
    else
    {
        First = (ULONG)GetExpression();
        if (*g_CurCmd == ',')
        {
            g_CurCmd++;
            Count = (ULONG)GetExpression();
        }
        else
        {
            Count = g_LsSrcTotal;
        }
    }

    g_DefaultRadix = OldBase;

    if (Count < 1)
    {
        error(SYNTAX);
    }

    Mark = 0;

    if (Cmd == 'a')
    {
        DWORD Disp;
        IMAGEHLP_LINE64 Line;
        PSRCFILE SrcFile;

        // Listing from the source file that Addr is in.

        if (!g_Process)
        {
            error(BADPROCESS);
        }
        
        if (!GetLineFromAddr(g_Process, Flat(Addr), &Line, &Disp))
        {
            return;
        }

        SrcFile = FindSrcFile(Line.FileName);
        if (SrcFile == NULL)
        {
            return;
        }

        g_CurSrcFile = SrcFile;
        g_CurSrcLine = Line.LineNumber;
        Mark = Line.LineNumber;
    }

    if (g_CurSrcFile == NULL)
    {
        dprintf("No current source file\n");
        return;
    }

    // Address list commands are always relative,
    // as are negative starting positions.
    if (Cmd == 'a' || First < 0)
    {
        g_CurSrcLine += First;
    }
    else
    {
        g_CurSrcLine = First;
    }

    OutputSrcLines(g_CurSrcFile, g_CurSrcLine, g_CurSrcLine + Count - 1, Mark);

    g_CurSrcLine += Count;
}

void
ParseOciSrcCmd(void)
{
    BOOL AlsoLs = FALSE;
    
    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        g_CurCmd++;
        switch(*g_CurCmd++)
        {
        case 'a':
            AlsoLs = TRUE;
            break;
        default:
            error(SYNTAX);
        }
    }

    if (PeekChar() != ';' && *g_CurCmd)
    {
        ULONG64 Val1 = GetExpression();
        ULONG64 Val2 = 0;
    
        if (PeekChar() != ';' && *g_CurCmd)
        {
            Val2 = GetExpression();
        }
        else
        {
            Val2 = (Val1 + 1) / 2;
            Val1 -= Val2;
        }

        g_OciSrcBefore = (ULONG)Val1;
        g_OciSrcAfter = (ULONG)Val2;

        if (AlsoLs)
        {
            g_LsSrcBefore = g_OciSrcBefore;
            g_LsSrcTotal = g_OciSrcBefore + g_OciSrcAfter;
        }
    }

    if ((g_SrcOptions & SRCOPT_LIST_SOURCE) == 0)
    {
        WarnOut("WARNING: Source line display is disabled\n");
    }
    
    dprintf("At the prompt, display %d source lines before and %d after\n",
            g_OciSrcBefore, g_OciSrcAfter);

    if (AlsoLs)
    {
        dprintf("For lsa commands, display %d source lines before\n",
                g_LsSrcBefore);
        dprintf("For ls and lsa commands, display %d source lines\n",
                g_LsSrcTotal);
    }
}

void
DotLines(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG NewOpts = g_SymOptions ^ SYMOPT_LOAD_LINES;
    
    for (;;)
    {
        if (PeekChar() == '-' || *g_CurCmd == '/')
        {
            g_CurCmd++;
            switch(*g_CurCmd++)
            {
            case 'd':
                NewOpts &= ~SYMOPT_LOAD_LINES;
                break;
            case 'e':
                NewOpts |= SYMOPT_LOAD_LINES;
                break;
            case 't':
                // Toggle, already done.
                break;
            default:
                error(SYNTAX);
            }
        }
        else
        {
            break;
        }
    }
                
    SetSymOptions(NewOpts);

    if (g_SymOptions & SYMOPT_LOAD_LINES)
    {
        dprintf("Line number information will be loaded\n");
    }
    else
    {
        dprintf("Line number information will not be loaded\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\source.h ===
//----------------------------------------------------------------------------
//
// Source file lookup and management.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _SOURCE_H_
#define _SOURCE_H_

#define SRCOPT_STEP_SOURCE      0x00000001
#define SRCOPT_LIST_LINE        0x00000002
#define SRCOPT_LIST_SOURCE      0x00000004
#define SRCOPT_LIST_SOURCE_ONLY 0x00000008

extern ULONG g_SrcOptions;
extern PSTR g_SrcPath;
extern ULONG g_OciSrcBefore, g_OciSrcAfter;

typedef struct _SRCFILE
{
    struct _SRCFILE *Next;
    LPSTR File;
    ULONG Lines;
    LPSTR *LineText;
    LPSTR RawText;
} SRCFILE, *PSRCFILE;

void UnloadSrcFiles(void);

void OutputSrcLines(PSRCFILE File, ULONG First, ULONG Last, ULONG Mark);
BOOL OutputSrcLinesAroundAddr(ULONG64 Offset, ULONG Before, ULONG After);

enum
{
    // Information was found.
    LINE_FOUND,
    // No information was found.
    LINE_NOT_FOUND,
    // A specific module was referenced and it did
    // not contain the requested line.
    LINE_NOT_FOUND_IN_MODULE,
};

ULONG GetOffsetFromLine(PSTR FileLine, PULONG64 Offset);

void ParseSrcOptCmd(CHAR Cmd);
void ParseSrcLoadCmd(void);
void ParseSrcListCmd(CHAR Cmd);
void ParseOciSrcCmd(void);

void DotLines(PDOT_COMMAND Cmd, DebugClient* Client);

BOOL FindSrcFileOnPath(ULONG StartElement,
                       LPSTR File,
                       ULONG Flags,
                       PSTR Found,
                       ULONG FoundSize,
                       PSTR* MatchPart,
                       PULONG FoundElement);

#endif // #ifndef _SOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\register.cpp ===
//----------------------------------------------------------------------------
//
// Generic register support code.  All processor-specific code is in
// the processor-specific register files.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

DEBUG_STACK_FRAME g_LastRegFrame;

PCSTR g_PseudoNames[REG_PSEUDO_COUNT] =
{
    "$exp", "$ea", "$p", "$ra", "$thread", "$proc", "$teb", "$peb",
    "$tid", "$tpid", "$retreg", "$ip", "$eventip", "$previp", "$relip",
    "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7", "$t8", "$t9",
    "$exentry", "$dtid", "$dpid", "$dsid",
};
PCSTR g_PseudoTypes[REG_PSEUDO_COUNT] =
{
    NULL, NULL, NULL, NULL,
    "nt!_ETHREAD", "nt!_EPROCESS", "nt!_TEB", "nt!_PEB",
    NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL,
};

ULONG64 g_PseudoTempVals[REG_PSEUDO_TEMP_COUNT];

PCSTR g_UserRegs[REG_USER_COUNT];

//----------------------------------------------------------------------------
//
// NeedUpper
//
// Determines whether the upper 32 bits of a 64-bit register is
// an important value or just a sign extension.
//
//----------------------------------------------------------------------------

BOOL
NeedUpper(ULONG64 Val)
{
    //
    // if the high bit of the low part is set, then the
    // high part must be all ones, else it must be zero.
    //

    return ((Val & 0xffffffff80000000L) != 0xffffffff80000000L) &&
         ((Val & 0xffffffff00000000L) != 0);
}

//----------------------------------------------------------------------------
//
// GetPseudoVal
//
// Returns pseudo-register values.
//
//----------------------------------------------------------------------------

void
GetPseudoVal(ULONG Index, TypedData* Typed)
{
    ADDR Addr;
    ULONG64 Val;
    ULONG64 Id;
    ULONG Size;

    switch(Index)
    {
    case PSEUDO_LAST_EXPR:
        *Typed = g_LastEvalResult;
        break;
        
    case PSEUDO_EFF_ADDR:
        g_Machine->GetEffectiveAddr(&Addr, &Size);
        if (fnotFlat(Addr))
        {
            error(BADREG);
        }
        switch(Size)
        {
        case 2:
            Size = DNTYPE_UINT16;
            break;
        case 4:
            Size = DNTYPE_UINT32;
            break;
        case 8:
            Size = DNTYPE_UINT64;
            break;
        default:
            Size = DNTYPE_UINT8;
            break;
        }
        Typed->SetU64(Flat(Addr));
        Typed->m_NextType = Size;
        break;
        
    case PSEUDO_LAST_DUMP:
        *Typed = g_LastDump;
        break;
        
    case PSEUDO_RET_ADDR:
        g_Machine->GetRetAddr(&Addr);
        if (fnotFlat(Addr))
        {
            error(BADREG);
        }
        Typed->SetU64(Flat(Addr));
        break;
        
    case PSEUDO_IMP_THREAD:
        if (g_Process->GetImplicitThreadData(g_Thread, &Val) != S_OK)
        {
            error(BADREG);
        }
        Typed->SetU64(Val);
        break;
        
    case PSEUDO_IMP_PROCESS:
        if (g_Target->GetImplicitProcessData(g_Thread, &Val) != S_OK)
        {
            error(BADREG);
        }
        Typed->SetU64(Val);
        break;
        
    case PSEUDO_IMP_TEB:
        if (g_Process->GetImplicitThreadDataTeb(g_Thread, &Val) != S_OK)
        {
            error(BADREG);
        }
        Typed->SetU64(Val);
        break;
        
    case PSEUDO_IMP_PEB:
        if (g_Target->GetImplicitProcessDataPeb(g_Thread, &Val) != S_OK)
        {
            error(BADREG);
        }
        Typed->SetU64(Val);
        break;
        
    case PSEUDO_IMP_THREAD_ID:
        if (g_Process->GetImplicitThreadDataTeb(g_Thread, &Val) != S_OK ||
            g_Target->ReadPointer(g_Process, g_Machine,
                                  Val + 9 * (g_Machine->m_Ptr64 ? 8 : 4),
                                  &Id) != S_OK)
        {
            error(BADREG);
        }
        Typed->SetU32((ULONG)Id);
        break;
        
    case PSEUDO_IMP_THREAD_PROCESS_ID:
        if (g_Process->GetImplicitThreadDataTeb(g_Thread, &Val) != S_OK ||
            g_Target->ReadPointer(g_Process, g_Machine,
                                  Val + 8 * (g_Machine->m_Ptr64 ? 8 : 4),
                                  &Id) != S_OK)
        {
            error(BADREG);
        }
        Typed->SetU32((ULONG)Id);
        break;

    case PSEUDO_RETURN_REGISTER:
        Typed->SetU64(g_Machine->GetRetReg());
        break;

    case PSEUDO_INSTRUCTION_POINTER:
        g_Machine->GetPC(&Addr);
        if (fnotFlat(Addr))
        {
            error(BADREG);
        }
        Typed->SetU64(Flat(Addr));
        break;
        
    case PSEUDO_EVENT_INSTRUCTION_POINTER:
        if (fnotFlat(g_EventPc))
        {
            error(BADREG);
        }
        Typed->SetU64(Flat(g_EventPc));
        break;
        
    case PSEUDO_PREVIOUS_INSTRUCTION_POINTER:
        if (fnotFlat(g_PrevEventPc))
        {
            error(BADREG);
        }
        Typed->SetU64(Flat(g_PrevEventPc));
        break;
        
    case PSEUDO_RELATED_INSTRUCTION_POINTER:
        if (fnotFlat(g_PrevRelatedPc))
        {
            error(BADREG);
        }
        Typed->SetU64(Flat(g_PrevRelatedPc));
        break;
        
    case PSEUDO_TEMP_0:
    case PSEUDO_TEMP_1:
    case PSEUDO_TEMP_2:
    case PSEUDO_TEMP_3:
    case PSEUDO_TEMP_4:
    case PSEUDO_TEMP_5:
    case PSEUDO_TEMP_6:
    case PSEUDO_TEMP_7:
    case PSEUDO_TEMP_8:
    case PSEUDO_TEMP_9:
        Typed->SetU64(g_PseudoTempVals[Index - PSEUDO_TEMP_0]);
        break;

    case PSEUDO_EXE_ENTRY:
        {
            IMAGE_NT_HEADERS64 NtHeaders;
            
            if (!g_Process ||
                !g_Process->m_ExecutableImage ||
                g_Target->ReadImageNtHeaders(g_Process,
                                             g_Process->m_ExecutableImage->
                                             m_BaseOfImage,
                                             &NtHeaders) != S_OK)
            {
                error(BADREG);
            }

            Typed->SetU64(g_Process->m_ExecutableImage->m_BaseOfImage +
                          NtHeaders.OptionalHeader.AddressOfEntryPoint);
        }
        break;

    case PSEUDO_DBG_THREAD_ID:
        Typed->SetU32(g_Thread->m_UserId);
        break;
        
    case PSEUDO_DBG_PROCESS_ID:
        Typed->SetU32(g_Process->m_UserId);
        break;
        
    case PSEUDO_DBG_SYSTEM_ID:
        Typed->SetU32(g_Target->m_UserId);
        break;
        
    default:
        error(BADREG);
    }
}

//----------------------------------------------------------------------------
//
// GetPseudoOrRegVal
//
// Gets a register or pseudo-register value.
//
//----------------------------------------------------------------------------

void
GetPseudoOrRegVal(BOOL Scoped, ULONG Index, REGVAL* Val)
{
    if (Index >= REG_PSEUDO_FIRST && Index <= REG_PSEUDO_LAST)
    {
        TypedData Typed;
        
        Val->Type = REGVAL_INT64;
        GetPseudoVal(Index, &Typed);
        Typed.ForceU64();
        if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386)
        {
            // Sign extended on X86 so "dc @$p" works as expected.
            Val->I64 = EXTEND64(Typed.m_U64);
        }
        else
        {
            Val->I64 = Typed.m_U64;
        }
    }
    else
    {
        HRESULT Status;
        PCROSS_PLATFORM_CONTEXT ScopeContext = NULL;
        ContextSave* Push;

        if (Scoped)
        {
            ScopeContext = GetCurrentScopeContext();
            if (ScopeContext)
            {
                Push = g_Machine->PushContext(ScopeContext);
            }
        }
        
        Status = g_Machine->FullGetVal(Index, Val);
        
	if (ScopeContext)
        {
            g_Machine->PopContext(Push);
        }

        if (Status != S_OK)
        {
            error(BADREG);
        }
    }
}

//----------------------------------------------------------------------------
//
// SetPseudoOrRegVal
//
// Sets a register value, performing subregister mapping if necessary.
//
//----------------------------------------------------------------------------

void
SetPseudoOrRegVal(ULONG Index, REGVAL* Val)
{
    if (Index >= REG_PSEUDO_FIRST && Index <= REG_PSEUDO_LAST)
    {
        ADDR Addr;
        
        if (Index >= PSEUDO_TEMP_0 && Index <= PSEUDO_TEMP_9)
        {
            g_PseudoTempVals[Index - PSEUDO_TEMP_0] = Val->I64;
            return;
        }

        // As a convenience allow setting the current IP
        // through its pseudo-register alias.
        switch(Index)
        {
        case PSEUDO_INSTRUCTION_POINTER:
            ADDRFLAT(&Addr, Val->I64);
            g_Machine->SetPC(&Addr);
            return;
        }
        
        error(BADREG);
    }

    if (g_Machine->FullSetVal(Index, Val) != S_OK)
    {
        error(BADREG);
    }
}

//----------------------------------------------------------------------------
//
// GetPseudoOrRegTypedData.
//
// Gets a register value as a typed piece of data for source expressions.
//
//----------------------------------------------------------------------------

BOOL
GetPsuedoOrRegTypedData(BOOL Scoped, PCSTR Name, TypedData* Result)
{
    ULONG Err;
        
    ULONG Index = RegIndexFromName(Name);
    if (Index == REG_ERROR)
    {
        return FALSE;
    }

    if (Index >= REG_PSEUDO_FIRST && Index <= REG_PSEUDO_LAST)
    {
        ULONG64 U64;
        ULONG PtrSize = g_Machine->m_Ptr64 ? 8 : 4;
        
        GetPseudoVal(Index, Result);
        U64 = Result->m_U64;

        if (IS_USER_TARGET(g_Target))
        {
            // User-mode thread and process are the same as the TEB and PEB.
            if (Index == PSEUDO_IMP_THREAD)
            {
                Index = PSEUDO_IMP_TEB;
            }
            else if (Index == PSEUDO_IMP_PROCESS)
            {
                Index = PSEUDO_IMP_PEB;
            }
        }
    
        switch(Index)
        {
        case PSEUDO_LAST_EXPR:
        case PSEUDO_LAST_DUMP:
        case PSEUDO_IMP_THREAD_ID:
        case PSEUDO_IMP_THREAD_PROCESS_ID:
        case PSEUDO_TEMP_0:
        case PSEUDO_TEMP_1:
        case PSEUDO_TEMP_2:
        case PSEUDO_TEMP_3:
        case PSEUDO_TEMP_4:
        case PSEUDO_TEMP_5:
        case PSEUDO_TEMP_6:
        case PSEUDO_TEMP_7:
        case PSEUDO_TEMP_8:
        case PSEUDO_TEMP_9:
        case PSEUDO_DBG_THREAD_ID:
        case PSEUDO_DBG_PROCESS_ID:
        case PSEUDO_DBG_SYSTEM_ID:
            // Full values already.
            break;
        
        case PSEUDO_IMP_THREAD:
        case PSEUDO_IMP_PROCESS:
        case PSEUDO_IMP_TEB:
        case PSEUDO_IMP_PEB:
            if (Err = Result->
                FindType(g_Process, g_PseudoTypes[Index - REG_PSEUDO_FIRST],
                         PtrSize))
            {
                goto BytePointer;
            }
            Result->SetDataSource(TDATA_MEMORY, U64, 0);
            if (Err = Result->ConvertToAddressOf(FALSE, PtrSize))
            {
                error(Err);
            }
            break;
        
        case PSEUDO_EFF_ADDR:
            // m_NextType is set to the type of data
            // referred to by the effective address.
            Result->SetToNativeType(Result->m_NextType);
            Result->SetDataSource(TDATA_MEMORY, U64, 0);
            if (Err = Result->ConvertToAddressOf(FALSE, PtrSize))
            {
                error(Err);
            }
            break;
            
        case PSEUDO_RET_ADDR:
        case PSEUDO_RETURN_REGISTER:
        case PSEUDO_INSTRUCTION_POINTER:
        case PSEUDO_EVENT_INSTRUCTION_POINTER:
        case PSEUDO_PREVIOUS_INSTRUCTION_POINTER:
        case PSEUDO_RELATED_INSTRUCTION_POINTER:
        case PSEUDO_EXE_ENTRY:
        BytePointer:
            // Return a byte pointer so that useful address arithmetic
            // can be done without a cast.
            Result->SetToNativeType(DNTYPE_UINT8);
            Result->SetDataSource(TDATA_MEMORY, U64, 0);
            if (Err = Result->ConvertToAddressOf(FALSE, PtrSize))
            {
                error(Err);
            }
            break;
            
        default:
            return FALSE;
        }
    }
    else
    {
        REGVAL Val;
        
        GetPseudoOrRegVal(Scoped, Index, &Val);

        // No value was read from memory.
        Result->ClearAddress();

        // Convert the regval into a TypedData native type.
        switch(Val.Type)
        {
        case REGVAL_INT16:
            Result->SetToNativeType(DNTYPE_UINT16);
            Result->m_U64 = Val.I16;
            break;
        case REGVAL_SUB32:
        case REGVAL_INT32:
            Result->SetToNativeType(DNTYPE_UINT32);
            Result->m_U64 = Val.I32;
            break;
        case REGVAL_SUB64:
        case REGVAL_INT64:
        case REGVAL_INT64N:
            Result->SetToNativeType(DNTYPE_UINT64);
            Result->m_U64 = Val.I64;
            break;
        case REGVAL_FLOAT8:
            Result->SetToNativeType(DNTYPE_FLOAT64);
            Result->m_F64 = Val.F8;
            break;
        case REGVAL_FLOAT10:
            _ULDBL12 Ld12;
            UDOUBLE D8;
            Result->SetToNativeType(DNTYPE_FLOAT64);
            _ldtold12((_ULDOUBLE*)&Val.F10, &Ld12);
            _ld12tod(&Ld12, &D8);
            Result->m_F64 = D8.x;
            break;
        case REGVAL_FLOAT82:
            Result->SetToNativeType(DNTYPE_FLOAT64);
            Result->m_F64 = Float82ToDouble((FLOAT128*)&Val.F82);
            break;
        default:
            return FALSE;
        }
    }

    return TRUE;
}

//----------------------------------------------------------------------------
//
// ScanHexVal
//
// Scans an integer register value as a hex number.
//
//----------------------------------------------------------------------------

PSTR
ScanHexVal(PSTR StrVal, REGVAL *RegVal)
{
    ULONG64 Max;
    CHAR Ch;

    switch(RegVal->Type)
    {
    case REGVAL_INT16:
        Max = 0x1000;
        break;
    case REGVAL_SUB32:
    case REGVAL_INT32:
        Max = 0x10000000;
        break;
    case REGVAL_SUB64:
    case REGVAL_INT64:
    case REGVAL_INT64N:
        Max = 0x1000000000000000;
        break;
    }

    while (*StrVal == ' ' || *StrVal == '\t')
    {
        StrVal++;
    }
    
    RegVal->Nat = 0;
    RegVal->I64 = 0;
    for (;;)
    {
        Ch = (CHAR)tolower(*StrVal);
        if ((Ch < '0' || Ch > '9') &&
            (Ch < 'a' || Ch > 'f'))
        {
            if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_IA64 &&
                Ch == 'n')
            {
                StrVal++;
                RegVal->Nat = 1;
            }
            break;
        }

        if (RegVal->I64 >= Max)
        {
            error(OVERFLOW);
        }

        Ch -= '0';
        if (Ch > 9)
        {
            Ch -= 'a' - '0' - 10;
        }
        RegVal->I64 = RegVal->I64 * 0x10 + Ch;

        StrVal++;
    }

    return StrVal;
}

//----------------------------------------------------------------------------
//
// ScanRegVal
//
// Sets a register value from a string.
//
//----------------------------------------------------------------------------

PSTR
ScanRegVal(ULONG Index, PSTR Str, BOOL Get64)
{
    if (Index >= REG_USER_FIRST && Index <= REG_USER_LAST)
    {
        SetUserReg(Index, Str);
        return Str + strlen(Str);
    }
    else
    {
        PSTR      StrVal;
        CHAR      Ch;
        REGVAL    RegVal, TmpVal;
        _ULDBL12  F12;
        int       Used;

        StrVal = Str;

        do
        {
            Ch = *StrVal++;
        } while (Ch == ' ' || Ch == '\t');

        if (Ch == 0)
        {
            error(SYNTAX);
        }
        StrVal--;

        RegVal.Type = RegGetRegType(Index);

        switch(RegVal.Type)
        {
        case REGVAL_INT16:
        case REGVAL_SUB32:
        case REGVAL_INT32:
        case REGVAL_SUB64:
        case REGVAL_INT64:
        case REGVAL_INT64N:
            if (Str == g_CurCmd)
            {
                RegVal.I64 = GetExpression();
                RegVal.Nat = 0;
                StrVal = g_CurCmd;
            }
            else
            {
                StrVal = ScanHexVal(StrVal, &RegVal);
            }
            break;
        case REGVAL_FLOAT8:
            __strgtold12(&F12, &StrVal, StrVal, 0);
            _ld12tod(&F12, (UDOUBLE *)&RegVal.F8);
            break;
        case REGVAL_FLOAT10:
            __strgtold12(&F12, &StrVal, StrVal, 0);
            _ld12told(&F12, (_ULDOUBLE *)&RegVal.F10);
            break;
        case REGVAL_FLOAT82:
            UDOUBLE UDbl;
            FLOAT128 F82;

            // read as REGVAL_FLOAT10 (80 bit) and transfer to double
            __strgtold12(&F12, &StrVal, StrVal, 0);
            _ld12tod(&F12, &UDbl);

            DoubleToFloat82(UDbl.x, &F82);

            RegVal.Type = REGVAL_FLOAT82;
            memcpy(&RegVal.F82, &F82, min(sizeof(F82), sizeof(RegVal.F82)));
            break;
        case REGVAL_FLOAT16:
            // Should implement real f16 handling.
            // For now scan as two 64-bit parts.
            TmpVal.Type = REGVAL_INT64;
            StrVal = ScanHexVal(StrVal, &TmpVal);
            RegVal.F16Parts.High = (LONG64)TmpVal.I64;
            StrVal = ScanHexVal(StrVal, &TmpVal);
            RegVal.F16Parts.Low = TmpVal.I64;
            break;
        case REGVAL_VECTOR64:
            // XXX drewb - Allow format overrides to
            // scan in any format for vectors.
            if (Str == g_CurCmd)
            {
                RegVal.I64 = GetExpression();
                RegVal.Nat = 0;
                StrVal = g_CurCmd;
            }
            else
            {
                StrVal = ScanHexVal(StrVal, &RegVal);
            }
            break;
        case REGVAL_VECTOR128:
            // XXX drewb - Allow format overrides to
            // scan in any format for vectors.
            if (sscanf(StrVal, "%f%f%f%f%n",
                       &RegVal.Bytes[3 * sizeof(float)],
                       &RegVal.Bytes[2 * sizeof(float)],
                       &RegVal.Bytes[1 * sizeof(float)],
                       &RegVal.Bytes[0],
                       &Used) != 5)
            {
                error(SYNTAX);
            }
            StrVal += Used;
            break;

        default:
            error(BADREG);
        }

        Ch = *StrVal;
        if (Ch != 0 && Ch != ',' && Ch != ';' && Ch != ' ' && Ch != '\t')
        {
            error(SYNTAX);
        }

        SetPseudoOrRegVal(Index, &RegVal);

        return StrVal;
    }
}

//----------------------------------------------------------------------------
//
// InputRegVal
//
// Prompts for a new register value.
//
//----------------------------------------------------------------------------

void
InputRegVal(ULONG Index, BOOL Get64)
{
    CHAR ValStr[_MAX_PATH];
    int Type;
    PSTR Prompt = NULL;

    if (Index >= REG_USER_FIRST && Index <= REG_USER_LAST)
    {
        Prompt = "; new value: ";
    }
    else
    {
        Type = RegGetRegType(Index);

        switch(Type)
        {
        case REGVAL_INT16:
            Prompt = "; hex int16 value: ";
            break;
        case REGVAL_SUB64:
        case REGVAL_INT64:
        case REGVAL_INT64N:
            if (Get64)
            {
                Prompt = "; hex int64 value: ";
                break;
            }
            // Fall through.
        case REGVAL_SUB32:
        case REGVAL_INT32:
            Prompt = "; hex int32 value: ";
            break;
        case REGVAL_FLOAT8:
            Prompt = "; 32-bit float value: ";
            break;
        case REGVAL_FLOAT10:
            Prompt = "; 80-bit float value: ";
            break;
        case REGVAL_FLOAT82:
            Prompt = "; 82-bit float value: ";
            break;
        case REGVAL_FLOAT16:
            Prompt = "; 128-bit float value (two 64-bit hex): ";
            break;
        case REGVAL_VECTOR64:
            Prompt = "; hex int64 value: ";
            break;
        case REGVAL_VECTOR128:
            Prompt = "; 32-bit float 4-vector: ";
            break;
        default:
            error(BADREG);
        }
    }

    GetInput(Prompt, ValStr, sizeof(ValStr), GETIN_LOG_INPUT_LINE);
    RemoveDelChar(ValStr);
    ScanRegVal(Index, ValStr, Get64);
}

//----------------------------------------------------------------------------
//
// OutputRegVal
//
// Displays the given register's value.
//
//----------------------------------------------------------------------------

void
OutputRegVal(ULONG Index, BOOL Show64,
             VALUE_FORMAT Format, ULONG Elts)
{
    if (Index >= REG_USER_FIRST && Index <= REG_USER_LAST)
    {
        Index -= REG_USER_FIRST;

        if (g_UserRegs[Index] == NULL)
        {
            dprintf("<Empty>");
        }
        else
        {
            dprintf("%s", g_UserRegs[Index]);
        }
    }
    else
    {
        REGVAL Val;
        char Buf[128];

        // Scope is managed outside of this routine.
        GetPseudoOrRegVal(FALSE, Index, &Val);

        switch(Val.Type)
        {
        case REGVAL_INT16:
            dprintf("%04x", Val.I32);
            break;
        case REGVAL_SUB32:
            dprintf("%x", Val.I32);
            break;
        case REGVAL_INT32:
            dprintf("%08x", Val.I32);
            break;
        case REGVAL_SUB64:
            if (Show64)
            {
                if (NeedUpper(Val.I64))
                {
                    dprintf("%x%08x", Val.I64Parts.High, Val.I64Parts.Low);
                }
                else
                {
                    dprintf("%x", Val.I32);
                }
            }
            else
            {
                dprintf("%x", Val.I64Parts.Low);
                if (NeedUpper(Val.I64))
                {
                    dprintf("*");
                }
            }
            break;
        case REGVAL_INT64:
            if (Show64)
            {
                dprintf("%08x%08x", Val.I64Parts.High, Val.I64Parts.Low);
            }
            else
            {
                dprintf("%08x", Val.I64Parts.Low);
                if (NeedUpper(Val.I64))
                {
                    dprintf("*");
                }
            }
            break;
        case REGVAL_INT64N:
            dprintf("%08x%08x %01x", Val.I64Parts.High, Val.I64Parts.Low,
                    Val.I64Parts.Nat);
            break;
        case REGVAL_FLOAT8:
            dprintf("%22.12g", Val.F8);
            break;
        case REGVAL_FLOAT10:
            _uldtoa((_ULDOUBLE *)&Val.F10, sizeof(Buf) - 1, Buf);
            dprintf(Buf);
            break;
        case REGVAL_FLOAT82: 
            FLOAT128 F128;
            FLOAT82_FORMAT* F82; 
            F82 = (FLOAT82_FORMAT*)&F128;
            memcpy(&F128, &Val.F82, min(sizeof(F128), sizeof(Val.F82)));
            dprintf("%22.12g (%u:%05x:%016I64x)", 
                    Float82ToDouble(&F128),
                    UINT(F82->sign), UINT(F82->exponent), 
                    ULONG64(F82->significand));
            break;
        case REGVAL_FLOAT16:
            // Should implement real f16 handling.
            // For now print as two 64-bit parts.
            dprintf("%08x%08x %08x%08x",
                    (ULONG)(Val.F16Parts.High >> 32),
                    (ULONG)Val.F16Parts.High,
                    (ULONG)(Val.F16Parts.Low >> 32),
                    (ULONG)Val.F16Parts.Low);
            break;
        case REGVAL_VECTOR64:
            if (Format == VALUE_DEFAULT ||
                !FormatValue(Format, Val.Bytes, 8, Elts,
                             Buf, DIMA(Buf)))
            {
                dprintf("%016I64x", Val.I64);
            }
            else
            {
                dprintf("%s", Buf);
            }
            break;
        case REGVAL_VECTOR128:
            if (Format == VALUE_DEFAULT ||
                !FormatValue(Format, Val.Bytes, 16, Elts,
                             Buf, DIMA(Buf)))
            {
                dprintf("%12.6g %12.6g %12.6g %12.6g",
                        *(float *)&Val.Bytes[3 * sizeof(float)],
                        *(float *)&Val.Bytes[2 * sizeof(float)],
                        *(float *)&Val.Bytes[1 * sizeof(float)],
                        *(float *)&Val.Bytes[0]);
            }
            else
            {
                dprintf("%s", Buf);
            }
            break;
        default:
            error(BADREG);
        }
    }
}

//----------------------------------------------------------------------------
//
// OutputNameRegVal
//
// Displays the given register's name and value.
//
//----------------------------------------------------------------------------

void
OutputNameRegVal(ULONG Index, BOOL Show64,
                 VALUE_FORMAT Format, ULONG Elts)
{
    if (Index >= REG_USER_FIRST && Index <= REG_USER_LAST)
    {
        dprintf("$u%d=", Index - REG_USER_FIRST);
    }
    else
    {
        REGVAL Val;

        // Validate the register before any output.
        // Scope is managed outside of this routine.
        GetPseudoOrRegVal(FALSE, Index, &Val);

        dprintf("%s=", RegNameFromIndex(Index));
    }
    OutputRegVal(Index, Show64, Format, Elts);
}

//----------------------------------------------------------------------------
//
// ShowAllMask
//
// Display given mask settings.
//
//----------------------------------------------------------------------------

void
ShowAllMask(void)
{
    dprintf("Register output mask is %x:\n", g_Machine->m_AllMask);
    if (g_Machine->m_AllMask == 0)
    {
        dprintf("    Nothing\n");
    }
    else
    {
        if (g_Machine->m_AllMask & REGALL_INT64)
        {
            dprintf("    %4x - Integer state (64-bit)\n",
                    REGALL_INT64);
        }
        else if (g_Machine->m_AllMask & REGALL_INT32)
        {
            dprintf("    %4x - Integer state (32-bit)\n",
                    REGALL_INT32);
        }
        if (g_Machine->m_AllMask & REGALL_FLOAT)
        {
            dprintf("    %4x - Floating-point state\n",
                    REGALL_FLOAT);
        }

        ULONG Bit;

        Bit = 1 << REGALL_EXTRA_SHIFT;
        while (Bit > 0)
        {
            if (g_Machine->m_AllMask & Bit)
            {
                RegisterGroup* Group;
                REGALLDESC *BitDesc = NULL;
                ULONG GroupIdx;
                
                for (GroupIdx = 0;
                     GroupIdx < g_Machine->m_NumGroups;
                     GroupIdx++)
                {
                    Group = g_Machine->m_Groups[GroupIdx];
                    
                    BitDesc = Group->AllExtraDesc;
                    if (BitDesc == NULL)
                    {
                        continue;
                    }
                    
                    while (BitDesc->Bit != 0)
                    {
                        if (BitDesc->Bit == Bit)
                        {
                            break;
                        }

                        BitDesc++;
                    }

                    if (BitDesc->Bit != 0)
                    {
                        break;
                    }
                }

                if (BitDesc != NULL && BitDesc->Bit != 0)
                {
                    dprintf("    %4x - %s\n",
                            BitDesc->Bit, BitDesc->Desc);
                }
                else
                {
                    dprintf("    %4x - ?\n", Bit);
                }
            }

            Bit <<= 1;
        }
    }
}

//----------------------------------------------------------------------------
//
// ParseAllMaskCmd
//
// Interprets commands affecting AllMask.
//
//----------------------------------------------------------------------------

void
ParseAllMaskCmd(void)
{
    CHAR Ch;

    if (!IS_MACHINE_SET(g_Target))
    {
        error(SESSIONNOTSUP);
    }
    
    g_CurCmd++;

    Ch = PeekChar();
    if (Ch == '\0' || Ch == ';')
    {
        // Show current setting.
        ShowAllMask();
    }
    else if (Ch == '?')
    {
        // Explain settings.
        g_CurCmd++;

        dprintf("    %4x - Integer state (32-bit) or\n",
                REGALL_INT32);
        dprintf("    %4x - Integer state (64-bit), 64-bit takes precedence\n",
                REGALL_INT64);
        dprintf("    %4x - Floating-point state\n",
                REGALL_FLOAT);
        
        RegisterGroup* Group;
        REGALLDESC *Desc;
        ULONG GroupIdx;
                
        for (GroupIdx = 0;
             GroupIdx < g_Machine->m_NumGroups;
             GroupIdx++)
        {
            Group = g_Machine->m_Groups[GroupIdx];
                    
            Desc = Group->AllExtraDesc;
            if (Desc != NULL)
            {
                while (Desc->Bit != 0)
                {
                    dprintf("    %4x - %s\n", Desc->Bit, Desc->Desc);
                    Desc++;
                }
            }
        }
    }
    else
    {
        ULONG Mask = (ULONG)GetExpression();
        g_Machine->m_AllMask = Mask & g_Machine->m_AllMaskBits;
        if (g_Machine->m_AllMask != Mask)
        {
            WarnOut("Ignored invalid bits %X\n", Mask & ~g_Machine->m_AllMask);
        }
    }
}

/*** ParseRegCmd - parse register command
*
*   Purpose:
*       Parse the register ("r") command.
*           if "r", output all registers
*           if "r <reg>", output only the register <reg>
*           if "r <reg> =", output only the register <reg>
*               and prompt for new value
*           if "r <reg> = <value>" or "r <reg> <value>",
*               set <reg> to value <value>
*
*           if "rm #", set all register output mask.
*
*   Input:
*       *g_CurCmd - pointer to operands in command string
*
*   Output:
*       None.
*
*   Exceptions:
*       error exit:
*               SYNTAX - character after "r" not register name
*
*************************************************************************/

#define isregchar(ch) \
    ((ch) == '$' || \
     ((ch) >= '0' && (ch) <= '9') || \
     ((ch) >= 'a' && (ch) <= 'z') || \
     (ch) == '.')

VOID
ParseRegCmd(VOID)
{
    CHAR Ch;
    ULONG AllMask;

    // rm manipulates AllMask.
    if (*g_CurCmd == 'm')
    {
        ParseAllMaskCmd();
        return;
    }

    if (IS_LOCAL_KERNEL_TARGET(g_Target))
    {
        error(SESSIONNOTSUP);
    }
    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }

    AllMask = g_Machine->m_AllMask;

    switch(*g_CurCmd++)
    {
    case 'F':
        AllMask = REGALL_FLOAT;
        break;

    case 'L':
        if (AllMask & REGALL_INT32)
        {
            AllMask = (AllMask & ~REGALL_INT32) | REGALL_INT64;
        }
        break;

    case 'M':
        AllMask = (ULONG)GetExpression();
        break;

    case 'X':
        AllMask = REGALL_XMMREG;
        break;

    default:
        g_CurCmd--;
        break;
    }

    if (AllMask & ~g_Machine->m_AllMaskBits)
    {
        WarnOut("Ignored invalid bits %X\n",
                AllMask & ~g_Machine->m_AllMaskBits);
        AllMask &= g_Machine->m_AllMaskBits;
    }
    
    // If just 'r', output information about the current thread context.

    if ((Ch = PeekChar()) == '\0' || Ch == ';')
    {
        OutCurInfo(OCI_FORCE_ALL, AllMask, DEBUG_OUTPUT_NORMAL);
        g_Machine->GetPC(&g_AssemDefault);
        g_UnasmDefault = g_AssemDefault;
    }
    else
    {
        // if [processor]r, no register can be specified.
        if (g_SwitchedProcs)
        {
            error(SYNTAX);
        }

        for (;;)
        {
            char    RegName[16];
            ULONG   Index;
            BOOL    NewLine;

            // Collect register name.
            Index = 0;

            while (Index < sizeof(RegName) - 1)
            {
                Ch = (char)tolower(*g_CurCmd);
                if (!isregchar(Ch))
                {
                    break;
                }

                g_CurCmd++;
                RegName[Index++] = Ch;
            }

            RegName[Index] = 0;

            // Check for a fixed-name alias.
            if (Index == 4 &&
                RegName[0] == '$' &&
                RegName[1] == '.' &&
                RegName[2] == 'u' &&
                isdigit(RegName[3]))
            {
                Index = REG_USER_FIRST + (RegName[3] - '0');
            }
            else if ((Index = RegIndexFromName(RegName)) == REG_ERROR)
            {
                error(BADREG);
            }

            NewLine = FALSE;

            //  if "r <reg>", output value

            if ((Ch = PeekChar()) == '\0' ||
                Ch == ',' || Ch == ';' || Ch == ':')
            {
                VALUE_FORMAT Format = VALUE_DEFAULT;
                ULONG Elts = 0;
                
                // Look for a format override.
                if (Ch == ':')
                {
                    PSTR End;
                    
                    g_CurCmd++;
                    End = ParseValueFormat(g_CurCmd, &Format, &Elts);
                    if (!End)
                    {
                        error(SYNTAX);
                    }

                    g_CurCmd = End;
                }
                    
                OutputNameRegVal(Index, AllMask & REGALL_INT64,
                                 Format, Elts);
                NewLine = TRUE;
            }
            else if (Ch == '=' || g_QuietMode)
            {
                //  if "r <reg> =", output and prompt for new value

                if (Ch == '=')
                {
                    g_CurCmd++;
                }

                if ((Ch = PeekChar()) == '\0' || Ch == ',' || Ch == ';')
                {
                    OutputNameRegVal(Index, AllMask & REGALL_INT64,
                                     VALUE_DEFAULT, 0);
                    InputRegVal(Index, AllMask & REGALL_INT64);
                }
                else
                {
                    //  if "r <reg> = <value>", set the value

                    g_CurCmd = ScanRegVal(Index, g_CurCmd,
                                          AllMask & REGALL_INT64);
                    Ch = PeekChar();
                }
            }
            else
            {
                error(SYNTAX);
            }

            if (Ch == ',')
            {
                if (NewLine)
                {
                    dprintf(" ");
                }

                while (*g_CurCmd == ' ' || *g_CurCmd == ',')
                {
                    g_CurCmd++;
                }
            }
            else
            {
                if (NewLine)
                {
                    dprintf("\n");
                }
                break;
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// ExpandUserRegs
//
// Searches for occurrences of $u<digit> and replaces them with the
// corresponding fixed-name alias string.
//
//----------------------------------------------------------------------------

void
ExpandUserRegs(PSTR Str, ULONG StrSize)
{
    PCSTR Val;
    ULONG Len;
    PSTR Copy;

    while (TRUE)
    {
        // Look for a '$'.
        while (*Str != 0 && *Str != '$')
        {
            Str++;
        }

        // End of line?
        if (*Str == 0)
        {
            break;
        }

        // Check for 'u' and a digit.
        Str++;
        if (*Str != 'u')
        {
            continue;
        }
        Str++;
        if (!isdigit(*Str))
        {
            continue;
        }

        Val = g_UserRegs[*Str - '0'];

        if (Val == NULL)
        {
            Len = 0;
        }
        else
        {
            Len = strlen(Val);
            if (Len >= StrSize)
            {
                Len = StrSize - 1;
            }
            StrSize -= Len;
        }

        Copy = Str - 2;
        Str++;

        // Move string tail to make room for the replacement text.
        memmove(Copy + Len, Str, strlen(Str) + 1);
        
        // Insert replacement text.
        if (Len > 0)
        {
            memcpy(Copy, Val, Len);
        }

        // Restart scan at beginning of replaced text to handle
        // nested replacements.
        Str = Copy;
    }
}

//----------------------------------------------------------------------------
//
// PsuedoIndexFromName
//
// Recognizes pseudo-register names.
//
//----------------------------------------------------------------------------

ULONG
PseudoIndexFromName(PCSTR Name)
{
    ULONG i;

    for (i = 0; i < REG_PSEUDO_COUNT; i++)
    {
        if (!_stricmp(g_PseudoNames[i], Name))
        {
            return i + REG_PSEUDO_FIRST;
        }
    }
    return REG_ERROR;
}

//----------------------------------------------------------------------------
//
// GetUserReg
//
// Gets a fixed-name alias value.
//
//----------------------------------------------------------------------------

PCSTR
GetUserReg(ULONG Index)
{
    return g_UserRegs[Index - REG_USER_FIRST];
}

//----------------------------------------------------------------------------
//
// SetUserReg
//
// Sets a fixed-name alias value.
//
//----------------------------------------------------------------------------

BOOL
SetUserReg(ULONG Index, PCSTR Val)
{
    PCSTR Copy;
    PCSTR Scan, Dollar;

    //
    // If somebody sets a fixed-name alias to include a alias's
    // name they can cause recursive replacement, which results
    // in a variety of bad behavior.
    // Prevent all fixed-name alias name strings from occurring within
    // their values.
    //

    Scan = Val;
    for (;;)
    {
        Dollar = strchr(Scan, '$');
        if (!Dollar)
        {
            break;
        }

        if (Dollar[1] == 'u' && isdigit(Dollar[2]))
        {
            ErrOut("Fixed-name aliases cannot contain fixed alias names\n");
            return FALSE;
        }

        Scan = Dollar + 1;
    }
    
    Index -= REG_USER_FIRST;

    Copy = _strdup(Val);
    if (Copy == NULL)
    {
        ErrOut("Unable to allocate memory for fixed-name alias value\n");
        return FALSE;
    }
    
    if (g_UserRegs[Index] != NULL)
    {
        free((PSTR)g_UserRegs[Index]);
    }

    g_UserRegs[Index] = Copy;

    return TRUE;
}

//----------------------------------------------------------------------------
//
// RegIndexFromName
//
// Maps a register index to its name string.
//
//----------------------------------------------------------------------------

ULONG
RegIndexFromName(PCSTR Name)
{
    ULONG Index;
    REGDEF* Def;
    RegisterGroup* Group;

    // Check for pseudo registers.
    Index = PseudoIndexFromName(Name);
    if (Index != REG_ERROR)
    {
        return Index;
    }
    
    if (g_Machine)
    {
        ULONG GroupIdx;
                
        for (GroupIdx = 0;
             GroupIdx < g_Machine->m_NumGroups;
             GroupIdx++)
        {
            Group = g_Machine->m_Groups[GroupIdx];
                    
            Def = Group->Regs;
            while (Def->Name != NULL)
            {
                if (!strcmp(Def->Name, Name))
                {
                    return Def->Index;
                }

                Def++;
            }
        }
    }
    
    return REG_ERROR;
}

//----------------------------------------------------------------------------
//
// RegNameFromIndex
//
// Maps a register index to its name.
//
//----------------------------------------------------------------------------

PCSTR
RegNameFromIndex(ULONG Index)
{
    REGDEF* Def;
    
    if (Index >= REG_PSEUDO_FIRST && Index <= REG_PSEUDO_LAST)
    {
        return g_PseudoNames[Index - REG_PSEUDO_FIRST];
    }

    Def = g_Machine->RegDefFromIndex(Index);
    if (Def != NULL)
    {
        return Def->Name;
    }
    else
    {
        return NULL;
    }
}

ULONG
RegGetRegType(ULONG Index)
{
    if ((Index >= REG_PSEUDO_FIRST && Index <= REG_PSEUDO_LAST) ||
        (Index >= REG_USER_FIRST && Index <= REG_USER_LAST))
    {
        if ((Index >= PSEUDO_TEMP_0 && Index <= PSEUDO_TEMP_9) ||
            Index == PSEUDO_INSTRUCTION_POINTER)
        {
            return REGVAL_INT64;
        }

        error(BADREG);
    }

    return g_Machine->GetType(Index);
}

HRESULT
SetAndOutputContext(
    IN PCROSS_PLATFORM_CONTEXT TargetContext,
    IN BOOL CanonicalContext,
    IN ULONG AllMask
    )
{
    HRESULT Status;
    CROSS_PLATFORM_CONTEXT ConvertedContext;
    PCROSS_PLATFORM_CONTEXT Context;
    ContextSave* Push;

    if (!CanonicalContext)
    {
        // Convert target context to canonical form.
        if ((Status = g_Machine->
             ConvertContextFrom(&ConvertedContext, g_Target->m_SystemVersion,
                                g_Target->m_TypeInfo.SizeTargetContext,
                                TargetContext)) != S_OK)
        {
            return Status;
        }

        Context = &ConvertedContext;
    }
    else
    {
        Context = TargetContext;
    }
    
    Push = g_Machine->PushContext(Context);

    OutCurInfo(OCI_SYMBOL | OCI_DISASM | OCI_FORCE_REG |
               OCI_ALLOW_SOURCE | OCI_ALLOW_EA,
               AllMask, DEBUG_OUTPUT_NORMAL);

    g_Machine->PopContext(Push);

    g_Machine->GetScopeFrameFromContext(Context, &g_LastRegFrame);
        
    SetCurrentScope(&g_LastRegFrame, Context,
                    g_Machine->m_SizeCanonicalContext);
    
    return S_OK;
}

HRESULT
SetAndOutputVirtualContext(
    IN ULONG64 ContextBase,
    IN ULONG AllMask
    )
{
    if (!ContextBase) 
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    CROSS_PLATFORM_CONTEXT Context;

    //
    // Read the context data out of virtual memory and
    // call into the raw context output routine.
    //
    
    if ((Status = g_Target->
         ReadAllVirtual(g_Process, ContextBase, &Context,
                        g_Target->m_TypeInfo.SizeTargetContext)) != S_OK)
    {
        return Status;
    }

    g_Machine->SanitizeMemoryContext(&Context);
    
    return SetAndOutputContext(&Context, FALSE, AllMask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\splay.cpp ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    Splay.cpp

Abstract:

    Stolen from ntos\rtl\splay.c

    Copied here to avoid pulling in an obj from another project.

--*/

#include "ntsdp.hpp"


#define SwapPointers(Type, Ptr1, Ptr2) {      \
    Type _SWAP_POINTER_TEMP;                  \
    _SWAP_POINTER_TEMP = (Ptr1);              \
    (Ptr1) = (Ptr2);                          \
    (Ptr2) = _SWAP_POINTER_TEMP;              \
    }

#define ParentsChildPointerAddress(Links) ( \
    RtlIsLeftChild(Links) ?                 \
        &(((Links)->Parent)->LeftChild)     \
    :                                       \
        &(((Links)->Parent)->RightChild)    \
    )

PRTL_SPLAY_LINKS
pRtlSubtreePredecessor (
    IN PRTL_SPLAY_LINKS Links
    );

VOID
SwapSplayLinks (
    IN PRTL_SPLAY_LINKS Link1,
    IN PRTL_SPLAY_LINKS Link2
    );


PRTL_SPLAY_LINKS
pRtlSplay (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The Splay function takes as input a pointer to a splay link in a tree
    and splays the tree.  Its function return value is a pointer to the
    root of the splayed tree.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the root of the splayed tree.

--*/

{
    PRTL_SPLAY_LINKS L;
    PRTL_SPLAY_LINKS P;
    PRTL_SPLAY_LINKS G;

    //
    //  while links is not the root we need to keep rotating it toward
    //  the root
    //

    L = Links;

    while (!RtlIsRoot(L)) {

        P = RtlParent(L);
        G = RtlParent(P);

        if (RtlIsLeftChild(L)) {

            if (RtlIsRoot(P)) {

                /*
                  we have the following case

                          P           L
                         / \         / \
                        L   c  ==>  a   P
                       / \             / \
                      a   b           b   c
                */

                //
                //  Connect P & b
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

                //
                //  Make L the root
                //

                L->Parent = L;

            } else if (RtlIsLeftChild(P)) {

                /*
                  we have the following case

                          |           |
                          G           L
                         / \         / \
                        P   d  ==>  a   P
                       / \             / \
                      L   c           b   G
                     / \                 / \
                    a   b               c   d
                */

                //
                //  Connect P & b
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect G & c
                //

                G->LeftChild = P->RightChild;
                if (G->LeftChild != NULL) {G->LeftChild->Parent = G;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

                //
                //  Connect P & G
                //

                P->RightChild = G;
                G->Parent = P;

            } else { // RtlIsRightChild(Parent)

                /*
                  we have the following case

                        |                |
                        G                L
                       / \             /   \
                      a   P           G     P
                         / \         / \   / \
                        L   d  ==>  a   b c   d
                       / \
                      b   c
                */

                //
                //  Connect G & b
                //

                G->RightChild = L->LeftChild;
                if (G->RightChild != NULL) {G->RightChild->Parent = G;}

                //
                //  Connect P & c
                //

                P->LeftChild = L->RightChild;
                if (P->LeftChild != NULL) {P->LeftChild->Parent = P;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & G
                //

                L->LeftChild = G;
                G->Parent = L;

                //
                //  Connect L & P
                //

                L->RightChild = P;
                P->Parent = L;

            }

        } else { // RtlIsRightChild(L)

            if (RtlIsRoot(P)) {

                /*
                  we have the following case

                        P               L
                       / \             / \
                      a   L           P   c
                         / \         / \
                        b   c  ==>  a   b
                */

                //
                //  Connect P & b
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect P & L
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Make L the root
                //

                L->Parent = L;

            } else if (RtlIsRightChild(P)) {

                /*
                  we have the following case

                      |                   |
                      G                   L
                     / \                 / \
                    a   P               P   d
                       / \             / \
                      b   L           G   c
                         / \         / \
                        c   d  ==>  a   b
                */

                //
                //  Connect G & b
                //

                G->RightChild = P->LeftChild;
                if (G->RightChild != NULL) {G->RightChild->Parent = G;}

                //
                //  Connect P & c
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Connect P & G
                //

                P->LeftChild = G;
                G->Parent = P;

            } else { // RtlIsLeftChild(P)

                /*
                  we have the following case

                          |              |
                          G              L
                         / \           /   \
                        P   d         P     G
                       / \           / \   / \
                      a   L    ==>  a   b c   d
                         / \
                        b   c
                */

                //
                //  Connect P & b
                //

                P->RightChild = L->LeftChild;
                if (P->RightChild != NULL) {P->RightChild->Parent = P;}

                //
                //  Connect G & c
                //

                G->LeftChild = L->RightChild;
                if (G->LeftChild != NULL) {G->LeftChild->Parent = G;}

                //
                //  Connect L & Great GrandParent
                //

                if (RtlIsRoot(G)) {
                    L->Parent = L;
                } else {
                    L->Parent = G->Parent;
                    *(ParentsChildPointerAddress(G)) = L;
                }

                //
                //  Connect L & P
                //

                L->LeftChild = P;
                P->Parent = L;

                //
                //  Connect L & G
                //

                L->RightChild = G;
                G->Parent = L;

            }
        }
    }

    return L;
}


PRTL_SPLAY_LINKS
pRtlDelete (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The Delete function takes as input a pointer to a splay link in a tree
    and deletes that node from the tree.  Its function return value is a
    pointer to the root of the tree.  If the tree is now empty, the return
    value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the root of the tree.

--*/

{
    PRTL_SPLAY_LINKS Predecessor;
    PRTL_SPLAY_LINKS Parent;
    PRTL_SPLAY_LINKS Child;

    PRTL_SPLAY_LINKS *ParentChildPtr;

    //
    //  First check to see if Links as two children.  If it does then swap
    //  Links with its subtree predecessor.  Now we are guaranteed that Links
    //  has at most one child.
    //

    if ((RtlLeftChild(Links) != NULL) && (RtlRightChild(Links) != NULL)) {

        //
        //  get the predecessor, and swap their position in the tree
        //

        Predecessor = pRtlSubtreePredecessor(Links);
        SwapSplayLinks(Predecessor, Links);

    }

    //
    //  If Links has no children then delete links by checking if it is
    //  already the root or has a parent.  If it is the root then the
    //  tree is now empty, otherwise it set the appropriate parent's child
    //  pointer (i.e., the one to links) to NULL, and splay the parent.
    //

    if ((RtlLeftChild(Links) == NULL) && (RtlRightChild(Links) == NULL)) {

        //
        //  Links has no children, if it is the root then return NULL
        //

        if (RtlIsRoot(Links)) {

            return NULL;
        }

        //
        //  Links as not children and is not the root, so to the parent's
        //  child pointer to NULL and splay the parent.
        //

        Parent = RtlParent(Links);

        ParentChildPtr = ParentsChildPointerAddress(Links);
        *ParentChildPtr = NULL;

        return pRtlSplay(Parent);

    }

    //
    //  otherwise Links has one child.  If it is the root then make the child
    //  the new root, otherwise link together the child and parent, and splay
    //  the parent.  But first remember who our child is.
    //

    if (RtlLeftChild(Links) != NULL) {
        Child = RtlLeftChild(Links);
    } else {
        Child = RtlRightChild(Links);
    }

    //
    //  If links is the root then we make the child the root and return the
    //  child.
    //

    if (RtlIsRoot(Links)) {
        Child->Parent = Child;
        return Child;
    }

    //
    //  Links is not the root, so set link's parent child pointer to be
    //  the child and the set child's parent to be link's parent, and splay
    //  the parent.
    //

    ParentChildPtr = ParentsChildPointerAddress(Links);
    *ParentChildPtr = Child;
    Child->Parent = Links->Parent;

    return pRtlSplay(RtlParent(Child));

}
#if 0

VOID
RtlDeleteNoSplay (
    IN PRTL_SPLAY_LINKS Links,
    IN OUT PRTL_SPLAY_LINKS *Root
    )

/*++

Routine Description:

    The Delete function takes as input a pointer to a splay link in a tree,
    a pointer to the callers pointer to the tree and deletes that node from
    the tree.  The caller's pointer is updated upon return.  If the tree is
    now empty, the value is NULL.

    Unfortunately, the original RtlDelete() always splays and this is not
    always a desireable side-effect.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

    Root - Pointer to the callers pointer to the root 

Return Value:

    None

--*/

{
    PRTL_SPLAY_LINKS Predecessor;
    PRTL_SPLAY_LINKS Parent;
    PRTL_SPLAY_LINKS Child;

    PRTL_SPLAY_LINKS *ParentChildPtr;

    //
    //  First check to see if Links as two children.  If it does then swap
    //  Links with its subtree predecessor.  Now we are guaranteed that Links
    //  has at most one child.
    //

    if ((RtlLeftChild(Links) != NULL) && (RtlRightChild(Links) != NULL)) {

        //
        //  get the predecessor, and swap their position in the tree
        //

        Predecessor = pRtlSubtreePredecessor(Links);

        if (RtlIsRoot(Links)) {

            //
            //  If we're switching with the root of the tree, fix the
            //  caller's root pointer
            //

            *Root = Predecessor;
        }

        SwapSplayLinks(Predecessor, Links);

    }

    //
    //  If Links has no children then delete links by checking if it is
    //  already the root or has a parent.  If it is the root then the
    //  tree is now empty, otherwise it set the appropriate parent's child
    //  pointer (i.e., the one to links) to NULL.
    //

    if ((RtlLeftChild(Links) == NULL) && (RtlRightChild(Links) == NULL)) {

        //
        //  Links has no children, if it is the root then set root to NULL
        //

        if (RtlIsRoot(Links)) {

            *Root = NULL;

            return;
        }

        //
        //  Links as not children and is not the root, so to the parent's
        //  child pointer to NULL.
        //

        ParentChildPtr = ParentsChildPointerAddress(Links);
        *ParentChildPtr = NULL;

        return;
    }

    //
    //  otherwise Links has one child.  If it is the root then make the child
    //  the new root, otherwise link together the child and parent. But first
    //  remember who our child is.
    //

    if (RtlLeftChild(Links) != NULL) {
        Child = RtlLeftChild(Links);
    } else {
        Child = RtlRightChild(Links);
    }

    //
    //  If links is the root then we make the child the root and return the
    //  child.
    //

    if (RtlIsRoot(Links)) {
        Child->Parent = Child;

        *Root = Child;

        return;
    }

    //
    //  Links is not the root, so set link's parent child pointer to be
    //  the child and the set child's parent to be link's parent.
    //

    ParentChildPtr = ParentsChildPointerAddress(Links);
    *ParentChildPtr = Child;
    Child->Parent = Links->Parent;

    return;
}


PRTL_SPLAY_LINKS
RtlSubtreeSuccessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The SubtreeSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node of
    the substree rooted at the input node.  If there is not a successor, the
    return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the subtree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      check to see if there is a right subtree to the input link
      if there is then the subtree successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = RtlRightChild(Links)) != NULL) {

        while (RtlLeftChild(Ptr) != NULL) {
            Ptr = RtlLeftChild(Ptr);
        }

        return Ptr;

    }

    //
    //  otherwise we are do not have a subtree successor so we simply return
    //  NULL
    //

    return NULL;

}

#endif

PRTL_SPLAY_LINKS
pRtlSubtreePredecessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The SubtreePredecessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the predecessor of the input node of
    the substree rooted at the input node.  If there is not a predecessor,
    the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the predecessor in the subtree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    //
    //  check to see if there is a left subtree to the input link
    //  if there is then the subtree predecessor is the right most node in
    //  the left subtree.  That is find and return P in the following diagram
    //
    //              Links
    //               /
    //              .
    //               .
    //                .
    //                 P
    //                /
    //

    if ((Ptr = RtlLeftChild(Links)) != NULL) {

        while (RtlRightChild(Ptr) != NULL) {
            Ptr = RtlRightChild(Ptr);
        }

        return Ptr;

    }

    //
    //  otherwise we are do not have a subtree predecessor so we simply return
    //  NULL
    //

    return NULL;

}

#if 0

PRTL_SPLAY_LINKS
RtlRealSuccessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The RealSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node within
    the entire tree.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the entire tree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      first check to see if there is a right subtree to the input link
      if there is then the real successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = RtlRightChild(Links)) != NULL) {

        while (RtlLeftChild(Ptr) != NULL) {
            Ptr = RtlLeftChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a right child so check to see if have a parent and if
      so find the first ancestor that we are a left decendent of. That
      is find and return P in the following diagram

                       P
                      /
                     .
                      .
                       .
                      Links
    */

    Ptr = Links;
    while (RtlIsRightChild(Ptr)) {
        Ptr = RtlParent(Ptr);
    }

    if (RtlIsLeftChild(Ptr)) {
        return RtlParent(Ptr);
    }

    //
    //  otherwise we are do not have a real successor so we simply return
    //  NULL
    //

    return NULL;

}


PRTL_SPLAY_LINKS
RtlRealPredecessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    The RealPredecessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the predecessor of the input node
    within the entire tree.  If there is not a predecessor, the return value
    is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the predecessor in the entire tree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      first check to see if there is a left subtree to the input link
      if there is then the real predecessor is the right most node in
      the left subtree.  That is find and return P in the following diagram

                  Links
                   /
                  .
                   .
                    .
                     P
                    /
    */

    if ((Ptr = RtlLeftChild(Links)) != NULL) {

        while (RtlRightChild(Ptr) != NULL) {
            Ptr = RtlRightChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a left child so check to see if have a parent and if
      so find the first ancestor that we are a right decendent of. That
      is find and return P in the following diagram

                       P
                        \
                         .
                        .
                       .
                    Links
    */

    Ptr = Links;
    while (RtlIsLeftChild(Ptr)) {
        Ptr = RtlParent(Ptr);
    }

    if (RtlIsRightChild(Ptr)) {
        return RtlParent(Ptr);
    }

    //
    //  otherwise we are do not have a real predecessor so we simply return
    //  NULL
    //

    return NULL;

}
#endif

VOID
SwapSplayLinks (
    IN PRTL_SPLAY_LINKS Link1,
    IN PRTL_SPLAY_LINKS Link2
    )

{
    PRTL_SPLAY_LINKS *Parent1ChildPtr;
    PRTL_SPLAY_LINKS *Parent2ChildPtr;

    /*
      We have the following situation


             Parent1            Parent2
                |                  |
                |                  |
              Link1              Link2
               / \                / \
              /   \              /   \
            LC1   RC1          LC2   RC2

      where one of the links can possibly be the root and one of the links
      can possibly be a direct child of the other.  Without loss of
      generality we'll make link2 be the possible and root and link1 be
      the possible child.
    */

    if ((RtlIsRoot(Link1)) || (RtlParent(Link2) == Link1)) {
        SwapPointers(PRTL_SPLAY_LINKS, Link1, Link2);
    }

    //
    //  The four cases we need to handle are
    //
    //  1. Link1 is not a child of link2 and link2 is not the root
    //  2. Link1 is not a child of link2 and link2 is     the root
    //  3. Link1 is     a child of link2 and link2 is not the root
    //  4. Link1 is     a child of link2 and link2 is     the root
    //
    //
    //  Each case will be handled separately
    //

    if (RtlParent(Link1) != Link2) {

        if (!RtlIsRoot(Link2)) {

            //
            //  Case 1 the initial steps are:
            //
            //  1. get both parent child pointers
            //  2. swap the parent child pointers
            //  3. swap the parent pointers
            //

            Parent1ChildPtr = ParentsChildPointerAddress(Link1);
            Parent2ChildPtr = ParentsChildPointerAddress(Link2);

            SwapPointers(PRTL_SPLAY_LINKS, *Parent1ChildPtr, *Parent2ChildPtr);

            SwapPointers(PRTL_SPLAY_LINKS, Link1->Parent, Link2->Parent);

        } else {

            //
            //  Case 2 the initial steps are:
            //
            //  1. Set link1's parent child pointer to link2
            //  2. Set parent pointer of link2 to link1's parent
            //  3. Set parent pointer of link1 to be itself
            //

            Parent1ChildPtr = ParentsChildPointerAddress(Link1);
            *Parent1ChildPtr = Link2;

            Link2->Parent = Link1->Parent;

            Link1->Parent = Link1;

        }

        //
        //  Case 1 and 2 common steps are:
        //
        //  1. swap the child pointers
        //

        SwapPointers(PRTL_SPLAY_LINKS, Link1->LeftChild, Link2->LeftChild);
        SwapPointers(PRTL_SPLAY_LINKS, Link1->RightChild, Link2->RightChild);

    } else { // RtlParent(Link1) == Link2

        if (!RtlIsRoot(Link2)) {

            //
            //  Case 3 the initial steps are:
            //
            //  1. Set Link2's parent child pointer to link1
            //  2. Set Link1's parent pointer to parent of link2
            //

            Parent2ChildPtr = ParentsChildPointerAddress(Link2);
            *Parent2ChildPtr = Link1;

            Link1->Parent = Link2->Parent;

        } else {

            //
            //  Case 4 the initial steps are:
            //
            //  1. Set Link1's parent pointer to be link1
            //

            Link1->Parent = Link1;

        }

        //
        //  Case 3 and 4 common steps are:
        //
        //  1. Swap the child pointers
        //  2. if link1 was a left child (i.e., RtlLeftChild(Link1) == Link1)
        //     then set left child of link1 to link2
        //     else set right child of link1 to link2
        //

        SwapPointers(PRTL_SPLAY_LINKS, Link1->LeftChild, Link2->LeftChild);
        SwapPointers(PRTL_SPLAY_LINKS, Link1->RightChild, Link2->RightChild);

        if (Link1->LeftChild == Link1) {
            Link1->LeftChild = Link2;
        } else {
            Link1->RightChild = Link2;
        }

    }

    //
    //  Case 1, 2, 3, 4 common (and final) steps are:
    //
    //  1. Fix the parent pointers of the left and right children
    //

    if (Link1->LeftChild  != NULL) {Link1->LeftChild->Parent  = Link1;}
    if (Link1->RightChild != NULL) {Link1->RightChild->Parent = Link1;}
    if (Link2->LeftChild  != NULL) {Link2->LeftChild->Parent  = Link2;}
    if (Link2->RightChild != NULL) {Link2->RightChild->Parent = Link2;}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\rpc_dbgeng.cpp ===
//----------------------------------------------------------------------------
//
// Engine interface proxies and stubs.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// Generated headers.
#include "dbgeng_p.hpp"
#include "dbgeng_s.hpp"
#include "dbgsvc_p.hpp"
#include "dbgsvc_s.hpp"

//----------------------------------------------------------------------------
//
// Initialization.
//
//----------------------------------------------------------------------------

void
DbgRpcInitializeClient(void)
{
    DbgRpcInitializeStubTables_dbgeng(DBGRPC_SIF_DBGENG_FIRST);
    DbgRpcInitializeStubTables_dbgsvc(DBGRPC_SIF_DBGSVC_FIRST);

    //
    // Ensure that released interfaces haven't changed.
    //
    
    C_ASSERT(DBGRPC_UNIQUE_IDebugAdvanced == 19156);
    C_ASSERT(DBGRPC_UNIQUE_IDebugBreakpoint == 76131);
    C_ASSERT(DBGRPC_UNIQUE_IDebugClient == 229769);
    C_ASSERT(DBGRPC_UNIQUE_IDebugClient2 == 258161);
    C_ASSERT(DBGRPC_UNIQUE_IDebugClient3 == 308255);
    C_ASSERT(DBGRPC_UNIQUE_IDebugControl == 590362);
    C_ASSERT(DBGRPC_UNIQUE_IDebugControl2 == 635813);
    C_ASSERT(DBGRPC_UNIQUE_IDebugControl3 == 706698);
    C_ASSERT(DBGRPC_UNIQUE_IDebugDataSpaces == 180033);
    C_ASSERT(DBGRPC_UNIQUE_IDebugDataSpaces2 == 231471);
    C_ASSERT(DBGRPC_UNIQUE_IDebugDataSpaces3 == 256971);
    C_ASSERT(DBGRPC_UNIQUE_IDebugEventCallbacks == 87804);
    C_ASSERT(DBGRPC_UNIQUE_IDebugInputCallbacks == 10391);
    C_ASSERT(DBGRPC_UNIQUE_IDebugOutputCallbacks == 9646);
    C_ASSERT(DBGRPC_UNIQUE_IDebugRegisters == 69746);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSymbolGroup == 53483);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSymbols == 376151);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSymbols2 == 435328);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSystemObjects == 135421);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSystemObjects2 == 155936);
    C_ASSERT(DBGRPC_UNIQUE_IDebugSystemObjects3 == 206920);
}
    
//----------------------------------------------------------------------------
//
// Proxy and stub support.
//
//----------------------------------------------------------------------------

DbgRpcStubFunction
DbgRpcGetStub(USHORT StubIndex)
{
    USHORT If = (USHORT) DBGRPC_STUB_INDEX_INTERFACE(StubIndex);
    USHORT Mth = (USHORT) DBGRPC_STUB_INDEX_METHOD(StubIndex);
    DbgRpcStubFunctionTable* Table;

    if (If <= DBGRPC_SIF_DBGENG_LAST)
    {
        Table = g_DbgRpcStubs_dbgeng;
    }
    else if (If >= DBGRPC_SIF_DBGSVC_FIRST &&
             If >= DBGRPC_SIF_DBGSVC_LAST)
    {
        Table = g_DbgRpcStubs_dbgsvc;
        If -= DBGRPC_SIF_DBGSVC_FIRST;
    }
    else
    {
        return NULL;
    }
    if (Mth >= Table[If].Count)
    {
        return NULL;
    }

    return Table[If].Functions[Mth];
}

#if DBG
PCSTR
DbgRpcGetStubName(USHORT StubIndex)
{
    USHORT If = (USHORT) DBGRPC_STUB_INDEX_INTERFACE(StubIndex);
    USHORT Mth = (USHORT) DBGRPC_STUB_INDEX_METHOD(StubIndex);
    DbgRpcStubFunctionTable* Table;
    PCSTR** Names;

    if (If <= DBGRPC_SIF_DBGENG_LAST)
    {
        Table = g_DbgRpcStubs_dbgeng;
        Names = g_DbgRpcStubNames_dbgeng;
    }
    else if (If >= DBGRPC_SIF_DBGSVC_FIRST &&
             If >= DBGRPC_SIF_DBGSVC_LAST)
    {
        Table = g_DbgRpcStubs_dbgsvc;
        Names = g_DbgRpcStubNames_dbgsvc;
        If -= DBGRPC_SIF_DBGSVC_FIRST;
    }
    else
    {
        return "!InvalidInterface!";
    }
    if (Mth >= Table[If].Count)
    {
        return "!InvalidStubIndex!";
    }

    return Names[If][Mth];
}
#endif // #if DBG

HRESULT
DbgRpcPreallocProxy(REFIID InterfaceId, PVOID* Interface,
                    DbgRpcProxy** Proxy, PULONG IfUnique)
{
    HRESULT Status;
    
    Status = DbgRpcPreallocProxy_dbgeng(InterfaceId, Interface,
                                        Proxy, IfUnique);
    
    if (Status == E_NOINTERFACE)
    {
        Status = DbgRpcPreallocProxy_dbgsvc(InterfaceId, Interface,
                                            Proxy, IfUnique);
    }

    return Status;
}

void
DbgRpcDeleteProxy(class DbgRpcProxy* Proxy)
{
    // All proxies used here are similar simple single
    // vtable proxy objects so IDebugClient can represent them all.
    delete (ProxyIDebugClient*)Proxy;
}

HRESULT
DbgRpcServerThreadInitialize(void)
{
    HRESULT Status;
    
    // eXDI requires that all threads have OLE initialized
    // for the COM RPC that's done.  We don't want
    // to do this all the time because it brings in a bunch
    // of OLE code that won't be used except in the eXDI
    // case.  The OLE code is dynlinked so only init
    // if OLE code is loaded.
    if (g_Ole32Calls.CoInitializeEx)
    {
        if (FAILED(Status = g_Ole32Calls.
                   CoInitializeEx(NULL, COM_THREAD_MODEL)))
        {
            return Status;
        }
    }

    return S_OK;
}

void
DbgRpcServerThreadUninitialize(void)
{
    if (g_Ole32Calls.CoUninitialize)
    {
        g_Ole32Calls.CoUninitialize();
    }
}

void
DbgRpcError(char* Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    MaskOutVa(DEBUG_OUTPUT_ERROR, Format, Args, TRUE);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// Generated RPC proxies and stubs.
//
//----------------------------------------------------------------------------

#include "dbgeng_p.cpp"
#include "dbgeng_s.cpp"

//----------------------------------------------------------------------------
//
// Hand-written proxies and stubs.
//
//----------------------------------------------------------------------------

STDMETHODIMP
ProxyIDebugClient::CreateClient(
    OUT PDEBUG_CLIENT* Client
    )
{
    DbgRpcConnection* Conn;

    // Always look up the owning connection.
    Conn = DbgRpcGetConnection(m_OwningThread);
    if (Conn == NULL)
    {
        return RPC_E_CONNECTION_TERMINATED;
    }

    if (GetCurrentThreadId() != m_OwningThread)
    {
        // The caller wants a new client for a new thread.
        // Create a new RPC connection based on the owning connection.
        DbgRpcTransport* Trans = Conn->m_Trans->Clone();
        if (Trans == NULL)
        {
            return E_OUTOFMEMORY;
        }

        return DbgRpcCreateServerConnection(Trans, &IID_IDebugClient,
                                            (IUnknown**)Client);
    }

    //
    // Just creating another client for the owning thread.
    // Normal RPC.
    //

    HRESULT Status;
    DbgRpcCall Call;
    PUCHAR Data;
    PDEBUG_CLIENT Proxy;

    if ((Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient_CreateClient),
                                0, sizeof(DbgRpcObjectId))) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        if ((Proxy = DbgRpcPreallocIDebugClientProxy()) == NULL)
        {
            Status = E_OUTOFMEMORY;
        }
        else
        {
            Status = Conn->SendReceive(&Call, &Data);

            if (Status == S_OK)
            {
                *Client = (PDEBUG_CLIENT)
                    ((ProxyIDebugClient*)Proxy)->
                    InitializeProxy(Conn, *(DbgRpcObjectId*)Data, Proxy);
            }
            else
            {
                delete Proxy;
            }
        }

        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMP
ProxyIDebugClient::StartProcessServer(
    IN ULONG Flags,
    IN PCSTR Options,
    IN PVOID Reserved
    )
{
    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    if (Reserved != NULL)
    {
        return E_INVALIDARG;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;
    ULONG Len = strlen(Options) + 1;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient_StartProcessServer),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Flags;
        InData += sizeof(ULONG);
        memcpy(InData, Options, Len);

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMP
ProxyIDebugClient2::CreateClient(
    OUT PDEBUG_CLIENT* Client
    )
{
    DbgRpcConnection* Conn;

    // Always look up the owning connection.
    Conn = DbgRpcGetConnection(m_OwningThread);
    if (Conn == NULL)
    {
        return RPC_E_CONNECTION_TERMINATED;
    }

    if (GetCurrentThreadId() != m_OwningThread)
    {
        // The caller wants a new client for a new thread.
        // Create a new RPC connection based on the owning connection.
        DbgRpcTransport* Trans = Conn->m_Trans->Clone();
        if (Trans == NULL)
        {
            return E_OUTOFMEMORY;
        }

        return DbgRpcCreateServerConnection(Trans, &IID_IDebugClient,
                                            (IUnknown**)Client);
    }

    //
    // Just creating another client for the owning thread.
    // Normal RPC.
    //

    HRESULT Status;
    DbgRpcCall Call;
    PUCHAR Data;
    PDEBUG_CLIENT Proxy;

    if ((Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient2_CreateClient),
                                0, sizeof(DbgRpcObjectId))) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        if ((Proxy = DbgRpcPreallocIDebugClientProxy()) == NULL)
        {
            Status = E_OUTOFMEMORY;
        }
        else
        {
            Status = Conn->SendReceive(&Call, &Data);

            if (Status == S_OK)
            {
                *Client = (PDEBUG_CLIENT)
                    ((ProxyIDebugClient*)Proxy)->
                    InitializeProxy(Conn, *(DbgRpcObjectId*)Data, Proxy);
            }
            else
            {
                delete Proxy;
            }
        }

        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMP
ProxyIDebugClient2::StartProcessServer(
    IN ULONG Flags,
    IN PCSTR Options,
    IN PVOID Reserved
    )
{
    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    if (Reserved != NULL)
    {
        return E_INVALIDARG;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;
    ULONG Len = strlen(Options) + 1;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient2_StartProcessServer),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Flags;
        InData += sizeof(ULONG);
        memcpy(InData, Options, Len);

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMP
ProxyIDebugClient3::CreateClient(
    OUT PDEBUG_CLIENT* Client
    )
{
    DbgRpcConnection* Conn;

    // Always look up the owning connection.
    Conn = DbgRpcGetConnection(m_OwningThread);
    if (Conn == NULL)
    {
        return RPC_E_CONNECTION_TERMINATED;
    }

    if (GetCurrentThreadId() != m_OwningThread)
    {
        // The caller wants a new client for a new thread.
        // Create a new RPC connection based on the owning connection.
        DbgRpcTransport* Trans = Conn->m_Trans->Clone();
        if (Trans == NULL)
        {
            return E_OUTOFMEMORY;
        }

        return DbgRpcCreateServerConnection(Trans, &IID_IDebugClient,
                                            (IUnknown**)Client);
    }

    //
    // Just creating another client for the owning thread.
    // Normal RPC.
    //

    HRESULT Status;
    DbgRpcCall Call;
    PUCHAR Data;
    PDEBUG_CLIENT Proxy;

    if ((Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient3_CreateClient),
                                0, sizeof(DbgRpcObjectId))) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        if ((Proxy = DbgRpcPreallocIDebugClientProxy()) == NULL)
        {
            Status = E_OUTOFMEMORY;
        }
        else
        {
            Status = Conn->SendReceive(&Call, &Data);

            if (Status == S_OK)
            {
                *Client = (PDEBUG_CLIENT)
                    ((ProxyIDebugClient*)Proxy)->
                    InitializeProxy(Conn, *(DbgRpcObjectId*)Data, Proxy);
            }
            else
            {
                delete Proxy;
            }
        }

        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMP
ProxyIDebugClient3::StartProcessServer(
    IN ULONG Flags,
    IN PCSTR Options,
    IN PVOID Reserved
    )
{
    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    if (Reserved != NULL)
    {
        return E_INVALIDARG;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;
    ULONG Len = strlen(Options) + 1;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient3_StartProcessServer),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Flags;
        InData += sizeof(ULONG);
        memcpy(InData, Options, Len);

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMP
ProxyIDebugClient4::CreateClient(
    OUT PDEBUG_CLIENT* Client
    )
{
    DbgRpcConnection* Conn;

    // Always look up the owning connection.
    Conn = DbgRpcGetConnection(m_OwningThread);
    if (Conn == NULL)
    {
        return RPC_E_CONNECTION_TERMINATED;
    }

    if (GetCurrentThreadId() != m_OwningThread)
    {
        // The caller wants a new client for a new thread.
        // Create a new RPC connection based on the owning connection.
        DbgRpcTransport* Trans = Conn->m_Trans->Clone();
        if (Trans == NULL)
        {
            return E_OUTOFMEMORY;
        }

        return DbgRpcCreateServerConnection(Trans, &IID_IDebugClient,
                                            (IUnknown**)Client);
    }

    //
    // Just creating another client for the owning thread.
    // Normal RPC.
    //

    HRESULT Status;
    DbgRpcCall Call;
    PUCHAR Data;
    PDEBUG_CLIENT Proxy;

    if ((Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient4_CreateClient),
                                0, sizeof(DbgRpcObjectId))) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        if ((Proxy = DbgRpcPreallocIDebugClientProxy()) == NULL)
        {
            Status = E_OUTOFMEMORY;
        }
        else
        {
            Status = Conn->SendReceive(&Call, &Data);

            if (Status == S_OK)
            {
                *Client = (PDEBUG_CLIENT)
                    ((ProxyIDebugClient*)Proxy)->
                    InitializeProxy(Conn, *(DbgRpcObjectId*)Data, Proxy);
            }
            else
            {
                delete Proxy;
            }
        }

        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMP
ProxyIDebugClient4::StartProcessServer(
    IN ULONG Flags,
    IN PCSTR Options,
    IN PVOID Reserved
    )
{
    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    if (Reserved != NULL)
    {
        return E_INVALIDARG;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;
    ULONG Len = strlen(Options) + 1;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugClient4_StartProcessServer),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Flags;
        InData += sizeof(ULONG);
        memcpy(InData, Options, Len);

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

//
// The following methods are hand-written to convert
// varargs output into simple strings before sending
// them on.
//

STDMETHODIMPV
ProxyIDebugControl::Output(
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = OutputVaList(Mask, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl::OutputVaList(
    THIS_
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    int Len;
    BOOL Ptr64;

    if (IsPointer64Bit() == S_FALSE)
    {
        Ptr64 = FALSE;
    }
    else
    {
        Ptr64 = TRUE;
    }
    
    // Need the engine lock for the global buffers.
    ENTER_ENGINE();

    if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1,
                        Ptr64))
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                         g_FormatBuffer, Args);
    }
    else
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
    }
    if (Len <= 0)
    {
        LEAVE_ENGINE();
        return E_INVALIDARG;
    }
    else
    {
        Len++;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugControl_OutputVaList),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        LEAVE_ENGINE();
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Mask;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        LEAVE_ENGINE();

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl::ControlledOutput(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = ControlledOutputVaList(OutputControl, Mask, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl::ControlledOutputVaList(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    int Len;
    BOOL Ptr64;

    if (IsPointer64Bit() == S_FALSE)
    {
        Ptr64 = FALSE;
    }
    else
    {
        Ptr64 = TRUE;
    }

    // Need the engine lock for the global buffers.
    ENTER_ENGINE();

    if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1,
                        Ptr64))
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                         g_FormatBuffer, Args);
    }
    else
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
    }
    if (Len <= 0)
    {
        LEAVE_ENGINE();
        return E_INVALIDARG;
    }
    else
    {
        Len++;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugControl_ControlledOutputVaList),
                                Len + 2 * sizeof(ULONG), 0)) == NULL)
    {
        LEAVE_ENGINE();
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = OutputControl;
        InData += sizeof(ULONG);
        *(ULONG*)InData = Mask;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        LEAVE_ENGINE();

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl::OutputPrompt(
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = OutputPromptVaList(OutputControl, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl::OutputPromptVaList(
    THIS_
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    IN va_list Args
    )
{
    int Len;

    if (Format != NULL)
    {
        BOOL Ptr64;

        if (IsPointer64Bit() == S_FALSE)
        {
            Ptr64 = FALSE;
        }
        else
        {
            Ptr64 = TRUE;
        }
        
        // Need the engine lock for the global buffers.
        ENTER_ENGINE();

        if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1,
                            Ptr64))
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                             g_FormatBuffer, Args);
        }
        else
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
        }
        if (Len <= 0)
        {
            LEAVE_ENGINE();
            return E_INVALIDARG;
        }
        else
        {
            Len++;
        }
    }
    else
    {
        Len = 0;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    // Presence/absence of text will be detected in the stub
    // by checking the input size on the call.
    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugControl_OutputPromptVaList),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        if (Format != NULL)
        {
            LEAVE_ENGINE();
        }
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = OutputControl;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        if (Format != NULL)
        {
            LEAVE_ENGINE();
        }

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl2::Output(
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = OutputVaList(Mask, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl2::OutputVaList(
    THIS_
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    int Len;
    BOOL Ptr64;

    if (IsPointer64Bit() == S_FALSE)
    {
        Ptr64 = FALSE;
    }
    else
    {
        Ptr64 = TRUE;
    }

    // Need the engine lock for the global buffers.
    ENTER_ENGINE();

    if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1,
                        Ptr64))
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                         g_FormatBuffer, Args);
    }
    else
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
    }
    if (Len <= 0)
    {
        LEAVE_ENGINE();
        return E_INVALIDARG;
    }
    else
    {
        Len++;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugControl2_OutputVaList),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        LEAVE_ENGINE();
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Mask;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        LEAVE_ENGINE();

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl2::ControlledOutput(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = ControlledOutputVaList(OutputControl, Mask, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl2::ControlledOutputVaList(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    int Len;
    BOOL Ptr64;

    if (IsPointer64Bit() == S_FALSE)
    {
        Ptr64 = FALSE;
    }
    else
    {
        Ptr64 = TRUE;
    }

    // Need the engine lock for the global buffers.
    ENTER_ENGINE();

    if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1,
                        Ptr64))
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                         g_FormatBuffer, Args);
    }
    else
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
    }
    if (Len <= 0)
    {
        LEAVE_ENGINE();
        return E_INVALIDARG;
    }
    else
    {
        Len++;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugControl2_ControlledOutputVaList),
                                Len + 2 * sizeof(ULONG), 0)) == NULL)
    {
        LEAVE_ENGINE();
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = OutputControl;
        InData += sizeof(ULONG);
        *(ULONG*)InData = Mask;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        LEAVE_ENGINE();

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl2::OutputPrompt(
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = OutputPromptVaList(OutputControl, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl2::OutputPromptVaList(
    THIS_
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    IN va_list Args
    )
{
    int Len;

    if (Format != NULL)
    {
        BOOL Ptr64;

        if (IsPointer64Bit() == S_FALSE)
        {
            Ptr64 = FALSE;
        }
        else
        {
            Ptr64 = TRUE;
        }

        // Need the engine lock for the global buffers.
        ENTER_ENGINE();

        if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1,
                            Ptr64))
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                             g_FormatBuffer, Args);
        }
        else
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
        }
        if (Len <= 0)
        {
            LEAVE_ENGINE();
            return E_INVALIDARG;
        }
        else
        {
            Len++;
        }
    }
    else
    {
        Len = 0;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    // Presence/absence of text will be detected in the stub
    // by checking the input size on the call.
    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugControl2_OutputPromptVaList),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        if (Format != NULL)
        {
            LEAVE_ENGINE();
        }
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = OutputControl;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        if (Format != NULL)
        {
            LEAVE_ENGINE();
        }

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl3::Output(
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = OutputVaList(Mask, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl3::OutputVaList(
    THIS_
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    int Len;
    BOOL Ptr64;

    if (IsPointer64Bit() == S_FALSE)
    {
        Ptr64 = FALSE;
    }
    else
    {
        Ptr64 = TRUE;
    }

    // Need the engine lock for the global buffers.
    ENTER_ENGINE();

    if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1,
                        Ptr64))
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                         g_FormatBuffer, Args);
    }
    else
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
    }
    if (Len <= 0)
    {
        LEAVE_ENGINE();
        return E_INVALIDARG;
    }
    else
    {
        Len++;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugControl3_OutputVaList),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        LEAVE_ENGINE();
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = Mask;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        LEAVE_ENGINE();

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl3::ControlledOutput(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = ControlledOutputVaList(OutputControl, Mask, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl3::ControlledOutputVaList(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Mask,
    IN PCSTR Format,
    IN va_list Args
    )
{
    int Len;
    BOOL Ptr64;

    if (IsPointer64Bit() == S_FALSE)
    {
        Ptr64 = FALSE;
    }
    else
    {
        Ptr64 = TRUE;
    }

    // Need the engine lock for the global buffers.
    ENTER_ENGINE();

    if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1,
                        Ptr64))
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                         g_FormatBuffer, Args);
    }
    else
    {
        Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
    }
    if (Len <= 0)
    {
        LEAVE_ENGINE();
        return E_INVALIDARG;
    }
    else
    {
        Len++;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugControl3_ControlledOutputVaList),
                                Len + 2 * sizeof(ULONG), 0)) == NULL)
    {
        LEAVE_ENGINE();
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = OutputControl;
        InData += sizeof(ULONG);
        *(ULONG*)InData = Mask;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        LEAVE_ENGINE();

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

STDMETHODIMPV
ProxyIDebugControl3::OutputPrompt(
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    ...
    )
{
    va_list Args;
    HRESULT Status;

    if (::GetCurrentThreadId() != m_OwningThread)
    {
        return E_INVALIDARG;
    }

    va_start(Args, Format);
    Status = OutputPromptVaList(OutputControl, Format, Args);
    va_end(Args);
    return Status;
}

STDMETHODIMP
ProxyIDebugControl3::OutputPromptVaList(
    THIS_
    IN ULONG OutputControl,
    IN OPTIONAL PCSTR Format,
    IN va_list Args
    )
{
    int Len;

    if (Format != NULL)
    {
        BOOL Ptr64;

        if (IsPointer64Bit() == S_FALSE)
        {
            Ptr64 = FALSE;
        }
        else
        {
            Ptr64 = TRUE;
        }

        // Need the engine lock for the global buffers.
        ENTER_ENGINE();

        if (TranslateFormat(g_FormatBuffer, Format, Args, OUT_BUFFER_SIZE - 1,
                            Ptr64))
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1,
                             g_FormatBuffer, Args);
        }
        else
        {
            Len = _vsnprintf(g_OutBuffer, OUT_BUFFER_SIZE - 1, Format, Args);
        }
        if (Len <= 0)
        {
            LEAVE_ENGINE();
            return E_INVALIDARG;
        }
        else
        {
            Len++;
        }
    }
    else
    {
        Len = 0;
    }

    DbgRpcConnection* Conn;
    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    // Presence/absence of text will be detected in the stub
    // by checking the input size on the call.
    if ((Conn = DbgRpcGetConnection(m_OwningThread)) == NULL ||
        (Data = Conn->StartCall(&Call, m_ObjectId,
                                DBGRPC_STUB_INDEX(m_InterfaceIndex,
                                                  DBGRPC_SMTH_IDebugControl3_OutputPromptVaList),
                                Len + sizeof(ULONG), 0)) == NULL)
    {
        if (Format != NULL)
        {
            LEAVE_ENGINE();
        }
        Status = E_OUTOFMEMORY;
    }
    else
    {
        PUCHAR InData = Data;
        *(ULONG*)InData = OutputControl;
        InData += sizeof(ULONG);
        memcpy(InData, g_OutBuffer, Len);

        if (Format != NULL)
        {
            LEAVE_ENGINE();
        }

        Status = Conn->SendReceive(&Call, &Data);
        Conn->FreeData(Data);
    }

    return Status;
}

HRESULT
SFN_IDebugClient_StartProcessServer(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Flags = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugClient*)__drpc_If)->
        StartProcessServer(Flags, (PSTR)__drpc_InData, NULL);
}

HRESULT
SFN_IDebugClient2_StartProcessServer(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Flags = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugClient2*)__drpc_If)->
        StartProcessServer(Flags, (PSTR)__drpc_InData, NULL);
}

HRESULT
SFN_IDebugClient3_StartProcessServer(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Flags = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugClient3*)__drpc_If)->
        StartProcessServer(Flags, (PSTR)__drpc_InData, NULL);
}

HRESULT
SFN_IDebugClient4_StartProcessServer(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Flags = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugClient4*)__drpc_If)->
        StartProcessServer(Flags, (PSTR)__drpc_InData, NULL);
}

HRESULT
SFN_IDebugControl_OutputVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Mask = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugControl*)__drpc_If)->
        Output(Mask, "%s", (PSTR)__drpc_InData);
}

HRESULT
SFN_IDebugControl_ControlledOutputVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG OutputControl = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    ULONG Mask = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugControl*)__drpc_If)->
        ControlledOutput(OutputControl, Mask, "%s", (PSTR)__drpc_InData);
}

HRESULT
SFN_IDebugControl_OutputPromptVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG OutputControl = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    if (__drpc_Call->InSize > sizeof(ULONG))
    {
        return ((IDebugControl*)__drpc_If)->
            OutputPrompt(OutputControl, "%s", (PSTR)__drpc_InData);
    }
    else
    {
        return ((IDebugControl*)__drpc_If)->OutputPrompt(OutputControl, NULL);
    }
}

HRESULT
SFN_IDebugControl2_OutputVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Mask = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugControl2*)__drpc_If)->
        Output(Mask, "%s", (PSTR)__drpc_InData);
}

HRESULT
SFN_IDebugControl2_ControlledOutputVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG OutputControl = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    ULONG Mask = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugControl2*)__drpc_If)->
        ControlledOutput(OutputControl, Mask, "%s", (PSTR)__drpc_InData);
}

HRESULT
SFN_IDebugControl2_OutputPromptVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG OutputControl = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    if (__drpc_Call->InSize > sizeof(ULONG))
    {
        return ((IDebugControl2*)__drpc_If)->
            OutputPrompt(OutputControl, "%s", (PSTR)__drpc_InData);
    }
    else
    {
        return ((IDebugControl2*)__drpc_If)->OutputPrompt(OutputControl, NULL);
    }
}

HRESULT
SFN_IDebugControl3_OutputVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG Mask = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugControl3*)__drpc_If)->
        Output(Mask, "%s", (PSTR)__drpc_InData);
}

HRESULT
SFN_IDebugControl3_ControlledOutputVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG OutputControl = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    ULONG Mask = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    return ((IDebugControl3*)__drpc_If)->
        ControlledOutput(OutputControl, Mask, "%s", (PSTR)__drpc_InData);
}

HRESULT
SFN_IDebugControl3_OutputPromptVaList(
    IUnknown* __drpc_If,
    DbgRpcConnection* __drpc_Conn,
    DbgRpcCall* __drpc_Call,
    PUCHAR __drpc_InData,
    PUCHAR __drpc_OutData
    )
{
    ULONG OutputControl = *(ULONG*)__drpc_InData;
    __drpc_InData += sizeof(ULONG);
    if (__drpc_Call->InSize > sizeof(ULONG))
    {
        return ((IDebugControl3*)__drpc_If)->
            OutputPrompt(OutputControl, "%s", (PSTR)__drpc_InData);
    }
    else
    {
        return ((IDebugControl3*)__drpc_If)->OutputPrompt(OutputControl, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\stepgo.cpp ===
//----------------------------------------------------------------------------
//
// Handles stepping, tracing and go.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#define DBG_KWT 0
#define DBG_UWT 0

Breakpoint* g_GoBreakpoints[MAX_GO_BPS];
ULONG g_NumGoBreakpoints;

// Pass count of trace breakpoint.
ULONG   g_StepTracePassCount;
ULONG64 g_StepTraceInRangeStart = (ULONG64)-1;
ULONG64 g_StepTraceInRangeEnd;
BOOL    g_StepTraceToCall;

IMAGEHLP_LINE64 g_SrcLine;      //  Current source line for step/trace
BOOL g_SrcLineValid;            //  Validity of SrcLine information

BOOL    g_WatchTrace;
BOOL    g_WatchWhole;
ADDR    g_WatchTarget;
ULONG64 g_WatchInitialSP;
ULONG64 g_WatchBeginCurFunc = 1;
ULONG64 g_WatchEndCurFunc;

WatchFunctions g_WatchFunctions;

void
ResetStepTrace(void)
{
    g_WatchBeginCurFunc = 1;
    g_WatchEndCurFunc = 0;
    g_WatchTrace = FALSE;
    g_WatchInitialSP = 0;
    g_StepTraceInRangeStart = (ULONG64)-1;
    g_StepTraceInRangeEnd = 0;
    g_StepTraceToCall = FALSE;
}

//----------------------------------------------------------------------------
//
// WatchFunctions.
//
//----------------------------------------------------------------------------

WatchFunctions::WatchFunctions(void)
{
    m_Started = FALSE;
    SetDefaultParameters();
}

void
WatchFunctions::Start(void)
{
    ULONG i;

    m_TotalInstr = 0;
    m_TotalWatchTraceEvents = 0;
    m_TotalWatchThreadMismatches = 0;

    for (i = 0; i < WF_BUCKETS; i++)
    {
        m_Funcs[i] = NULL;
    }
    
    m_Sorted = NULL;
    m_CallTop = NULL;
    m_CallBot = NULL;
    m_CallLevel = 0;
    m_Started = TRUE;
}

void
WatchFunctions::End(PADDR PcAddr)
{
    g_StepTracePassCount = 0;
    g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
    g_Target->ClearBreakIn();

    if (!m_Started)
    {
        return;
    }
        
    ULONG TotalInstr;
    
    if (IS_KERNEL_TARGET(g_Target))
    {
        PDBGKD_TRACE_DATA td = (PDBGKD_TRACE_DATA)g_StateChangeData;
        if (g_WatchWhole)
        {
            if (td[1].s.Instructions == TRACE_DATA_INSTRUCTIONS_BIG)
            {
                TotalInstr = td[2].LongNumber;
            }
            else
            {
                TotalInstr = td[1].s.Instructions;
            }
        }
        else
        {
            BOOL StepOver;
           
            if (PcAddr != NULL)
            {
                g_Target->ProcessWatchTraceEvent(td, PcAddr, &StepOver);
            }
        
            while (m_CallTop != NULL)
            {
                PopCall();
            }

            TotalInstr = m_TotalInstr;
        }
        
        g_BreakpointsSuspended = FALSE;
        g_WatchInitialSP = 0;
    }
    else
    {
        if (m_CallTop != NULL)
        {
            OutputCall(m_CallTop, WCALL_OTHER);
        }

        while (m_CallTop != NULL)
        {
            PopCall();
        }

        TotalInstr = m_TotalInstr;
        if (m_OutputCalls)
        {
            dprintf("\n");
        }
    }

    m_Started = FALSE;

    if (m_OutputSummary)
    {
        dprintf("%d instructions were executed in %d events "
                "(%d from other threads)\n",
                TotalInstr,
                m_TotalWatchTraceEvents,
                m_TotalWatchThreadMismatches);

        if (!g_WatchWhole)
        {
            OutputFunctions();
        }
    
        if (!IS_KERNEL_TARGET(g_Target))
        {
            OutputSysCallFunctions();
        }

        dprintf("\n");
    }
    
    Clear();
}

void
WatchFunctions::OutputFunctions(void)
{
    WatchFunction* Func;
    
    dprintf("\n%-43.43s Invocations MinInst MaxInst AvgInst\n",
            "Function Name");

    for (Func = m_Sorted; Func != NULL; Func = Func->Sort)
    {
        dprintf("%-47.47s%8d%8d%8d%8d\n",
                Func->Symbol, Func->Calls,
                Func->MinInstr, Func->MaxInstr,
                Func->Calls ? Func->TotalInstr / Func->Calls : 0);
    }
}

void
WatchFunctions::OutputSysCallFunctions(void)
{
    WatchFunction* Func;
    ULONG TotalSysCalls = 0;
    
    for (Func = m_Sorted; Func != NULL; Func = Func->Sort)
    {
        TotalSysCalls += Func->SystemCalls;
    }

    if (TotalSysCalls == 1)
    {
        dprintf("\n%d system call was executed\n", TotalSysCalls);
    }
    else
    {
        dprintf("\n%d system calls were executed\n", TotalSysCalls);
    }

    if (TotalSysCalls == 0)
    {
        return;
    }
    
    dprintf("\nCalls  System Call\n");

    for (Func = m_Sorted; Func != NULL; Func = Func->Sort)
    {
        if (Func->SystemCalls > 0)
        {
            dprintf("%5d  %s\n", Func->SystemCalls, Func->Symbol);
        }
    }
}

WatchFunction*
WatchFunctions::FindAlways(PSTR Sym, ULONG64 Start)
{
    WatchFunction* Func = Find(Sym);
    if (Func == NULL)
    {
        Func = Add(Sym, Start);
    }
    return Func;
}

WatchCallStack*
WatchFunctions::PushCall(WatchFunction* Func)
{
    WatchCallStack* Call = new WatchCallStack;
    if (Call != NULL)
    {
        ZeroMemory(Call, sizeof(*Call));
        
        Call->Prev = m_CallTop;
        Call->Next = NULL;
        if (m_CallTop == NULL)
        {
            m_CallBot = Call;
        }
        else
        {
            m_CallTop->Next = Call;
            m_CallLevel++;
        }
        m_CallTop = Call;

        Call->Func = Func;
        Call->Level = m_CallLevel;
    }
    return Call;
}

void
WatchFunctions::PopCall(void)
{
    if (m_CallTop == NULL)
    {
        return;
    }

    WatchCallStack* Call = m_CallTop;
    
    if (Call->Prev != NULL)
    {
        Call->Prev->Next = Call->Next;
    }
    else
    {
        m_CallBot = Call->Next;
    }
    if (Call->Next != NULL)
    {
        Call->Next->Prev = Call->Prev;
    }
    else
    {
        m_CallTop = Call->Prev;
    }

    m_CallLevel = m_CallTop != NULL ? m_CallTop->Level : 0;
    
    ReuseCall(Call, NULL);
    delete Call;
}

#define MAXPCOFFSET 10

WatchCallStack*
WatchFunctions::PopCallsToCallSite(PADDR Pc)
{
    WatchCallStack* Call = m_CallTop;
    while (Call != NULL)
    {
        if ((Flat(*Pc) - Flat(Call->CallSite)) < MAXPCOFFSET)
        {
            break;
        }

        Call = Call->Prev;
    }

    if (Call == NULL)
    {
        // No matching call site found.
        return NULL;
    }

    // Pop off calls above the call site.
    while (m_CallTop != Call)
    {
        PopCall();
    }

    return m_CallTop;
}

WatchCallStack*
WatchFunctions::PopCallsToFunctionStart(ULONG64 Start)
{
    WatchCallStack* Call = m_CallTop;
    while (Call != NULL)
    {
        if (Start == Call->Func->StartOffset)
        {
            break;
        }

        Call = Call->Prev;
    }

    if (Call == NULL)
    {
        // No matching calling function found.
        return NULL;
    }

    // Pop off calls above the calling function.
    while (m_CallTop != Call)
    {
        PopCall();
    }

    return m_CallTop;
}

void
WatchFunctions::ReuseCall(WatchCallStack* Call,
                          WatchFunction* ReinitFunc)
{
    if (Call->Prev != NULL)
    {
        Call->Prev->ChildInstrCount +=
            Call->InstrCount + Call->ChildInstrCount;
    }

    WatchFunction* Func = Call->Func;
    if (Func != NULL)
    {
        Func->Calls++;
        Func->TotalInstr += Call->InstrCount;
        m_TotalInstr += Call->InstrCount;
        if (Func->MinInstr > Call->InstrCount)
        {
            Func->MinInstr = Call->InstrCount;
        }
        if (Func->MaxInstr < Call->InstrCount)
        {
            Func->MaxInstr = Call->InstrCount;
        }
    }

    ZeroMemory(&Call->CallSite, sizeof(Call->CallSite));
    Call->Func = ReinitFunc;
    Call->Level = m_CallLevel;
    Call->InstrCount = 0;
    Call->ChildInstrCount = 0;
}

#define MAX_INDENT_LEVEL 50

void
WatchFunctions::IndentForCall(WatchCallStack* Call)
{
    LONG i;
    
    if (Call->Level < MAX_INDENT_LEVEL)
    {
        for (i = 0; i < Call->Level; i++)
        {
            dprintf("  ");
        }
    }
    else
    {
        for (i = 0; i < MAX_INDENT_LEVEL + 1; i++)
        {
            dprintf("  ");
        }
    }
}

void
WatchFunctions::OutputCall(WatchCallStack* Call, WATCH_CALL_TYPE Type)
{
    if (!m_OutputCalls)
    {
        return;
    }
    
    dprintf("%5ld %5ld [%3ld]", Call->InstrCount, Call->ChildInstrCount,
            Call->Level);
    IndentForCall(Call);
    dprintf(" %s", Call->Func->Symbol);

    if (Type == WCALL_RETURN && m_OutputReturnValues)
    {
        dprintf(" %s = %s",
                RegNameFromIndex(g_Machine->m_RetRegIndex),
                FormatDisp64(g_Machine->GetRetReg()));
    }
    else if (Type == WCALL_CALL && m_OutputCallAddrs)
    {
        dprintf("\n                 ");
        IndentForCall(Call);
        dprintf("     call at ");
        dprintAddr(&Call->CallSite);
        OutputLineAddr(Flat(Call->CallSite), "[%s @ %d]");
    }

    dprintf("\n");
}

void
WatchFunctions::SetDefaultParameters(void)
{
    m_MaxCallLevelAllowed = 0x7fffffff;
    m_OutputReturnValues = FALSE;
    m_OutputCallAddrs = FALSE;
    m_OutputCalls = TRUE;
    m_OutputSummary = TRUE;
}

void
WatchFunctions::ParseParameters(void)
{
    SetDefaultParameters();
    
    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        g_CurCmd++;
        switch(*g_CurCmd)
        {
        case 'l':
            if (IS_KERNEL_TARGET(g_Target))
            {
                error(SESSIONNOTSUP);
            }
            g_CurCmd++;
            m_MaxCallLevelAllowed = (LONG)GetExpression();
            break;

        case 'n':
            g_CurCmd++;
            switch(*g_CurCmd)
            {
            case 'c':
                m_OutputCalls = FALSE;
                break;
            case 's':
                m_OutputSummary = FALSE;
                break;
            default:
                ErrOut("Unknown -n option '%c'\n", *g_CurCmd);
                break;
            }
            g_CurCmd++;
            break;
            
        case 'o':
            g_CurCmd++;
            switch(*g_CurCmd)
            {
            case 'a':
                if (IS_KERNEL_TARGET(g_Target))
                {
                    error(SESSIONNOTSUP);
                }
                m_OutputCallAddrs = TRUE;
                break;
            case 'r':
                if (IS_KERNEL_TARGET(g_Target))
                {
                    error(SESSIONNOTSUP);
                }
                m_OutputReturnValues = TRUE;
                break;
            default:
                ErrOut("Unknown -o option '%c'\n", *g_CurCmd);
                break;
            }
            g_CurCmd++;
            break;
            
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            g_CurCmd++;
            break;
        }
    }
}

WatchFunction*
WatchFunctions::Add(PSTR Sym, ULONG64 Start)
{
    WatchFunction* Func = new WatchFunction;
    if (Func == NULL)
    {
        return NULL;
    }

    ZeroMemory(Func, sizeof(*Func));

    Func->StartOffset = Start;
    Func->MinInstr = -1;
    Func->SymbolLength = strlen(Sym);
    CopyString(Func->Symbol, Sym, DIMA(Func->Symbol));

    //
    // Add into appropriate hash bucket.
    //

    // Hash under full name as that's what searches will
    // hash with.
    int Bucket = Hash(Sym, Func->SymbolLength);
    Func->Next = m_Funcs[Bucket];
    m_Funcs[Bucket] = Func;
    
    //
    // Add into sorted list.
    //
    
    WatchFunction* Cur, *Prev;

    Prev = NULL;
    for (Cur = m_Sorted; Cur != NULL; Cur = Cur->Sort)
    {
        if (strcmp(Func->Symbol, Cur->Symbol) <= 0)
        {
            break;
        }
        
        Prev = Cur;
    }

    Func->Sort = Cur;
    if (Prev == NULL)
    {
        m_Sorted = Func;
    }
    else
    {
        Prev->Sort = Func;
    }
    
    return Func;
}

WatchFunction*
WatchFunctions::Find(PSTR Sym)
{
    int SymLen = strlen(Sym);
    int Bucket = Hash(Sym, SymLen);
    WatchFunction* Func = m_Funcs[Bucket];

    while (Func != NULL)
    {
        if (SymLen == Func->SymbolLength &&
            !strncmp(Sym, Func->Symbol, sizeof(Func->Symbol) - 1))
        {
            break;
        }

        Func = Func->Next;
    }

    return Func;
}

void
WatchFunctions::Clear(void)
{
    ULONG i;

    for (i = 0; i < WF_BUCKETS; i++)
    {
        WatchFunction* Func;

        while (m_Funcs[i] != NULL)
        {
            Func = m_Funcs[i]->Next;
            delete m_Funcs[i];
            m_Funcs[i] = Func;
        }
    }

    m_Sorted = NULL;
}

//----------------------------------------------------------------------------
//
// TargetInfo watch trace methods.
//
//----------------------------------------------------------------------------

HRESULT
TargetInfo::InitializeTargetControlledStepping(void)
{
    // Nothing to do.
    return S_OK;
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo watch trace methods.
//
//----------------------------------------------------------------------------

typedef struct _TRACE_DATA_SYM
{
    ULONG64 SymMin;
    ULONG64 SymMax;
} TRACE_DATA_SYM, *PTRACE_DATA_SYM;

TRACE_DATA_SYM TraceDataSyms[256];
UCHAR NextTraceDataSym = 0;   // what's the next one to be replaced
UCHAR NumTraceDataSyms = 0;   // how many are valid?

HRESULT
ConnLiveKernelTargetInfo::InitializeTargetControlledStepping(void)
{
    ULONG64 SpecialCalls[10];
    PULONG64 Call = SpecialCalls;

    g_SrcLineValid = FALSE;
    g_StepTracePassCount = 0xfffffffe;

    // Set the special calls (overkill, once per boot
    // would be enough, but this is easier).

    if (!GetOffsetFromSym(m_ProcessHead,
                          "hal!KfLowerIrql", Call, NULL) &&
        !GetOffsetFromSym(m_ProcessHead,
                          "hal!KeLowerIrql", Call, NULL))
    {
        ErrOut("Cannot find hal!KfLowerIrql/KeLowerIrql\n");
    }
    else
    {
        Call++;
    }

    if (!GetOffsetFromSym(m_ProcessHead,
                          "hal!KfReleaseSpinLock", Call, NULL) &&
        !GetOffsetFromSym(m_ProcessHead,
                          "hal!KeReleaseSpinLock", Call, NULL))
    {
        ErrOut("Cannot find hal!KfReleaseSpinLock/KeReleaseSpinLock\n");
    }
    else
    {
        Call++;
    }

#define GetSymWithErr(s)                      \
    if (!GetOffsetFromSym(m_ProcessHead,      \
                          s, Call, NULL))     \
    {                                         \
        ErrOut("Cannot find " s "\n");        \
    }                                         \
    else                                      \
    {                                         \
        Call++;                               \
    }

    GetSymWithErr("hal!HalRequestSoftwareInterrupt");
    if (g_Target->m_SystemVersion >= NT_SVER_W2K)
    {
        GetSymWithErr("hal!ExReleaseFastMutex");
        GetSymWithErr("hal!KeReleaseQueuedSpinLock");
        if (m_SystemVersion >= NT_SVER_XP)
        {
            GetSymWithErr("hal!KeReleaseInStackQueuedSpinLock");
        }
    }

    GetSymWithErr("nt!SwapContext");
    GetSymWithErr("nt!KiCallUserMode");

    // Removed in .NET server
    if (m_SystemVersion < NT_SVER_NET_SERVER)
    {
        GetSymWithErr("nt!KiUnlockDispatcherDatabase");
    }

    DBG_ASSERT((ULONG)(Call - SpecialCalls) <=
               sizeof(SpecialCalls) / sizeof(SpecialCalls[0]));

    DBGKD_MANIPULATE_STATE64 m;

    m.ApiNumber = DbgKdClearSpecialCallsApi;
    m.ReturnStatus = STATUS_PENDING;
    m_Transport->WritePacket(&m, sizeof(m),
                             PACKET_TYPE_KD_STATE_MANIPULATE,
                             NULL, 0);
    InvalidateMemoryCaches(FALSE);

    PULONG64 Send = SpecialCalls;
    
    while (Send < Call)
    {
        m.ApiNumber = DbgKdSetSpecialCallApi;
        m.ReturnStatus = STATUS_PENDING;
        m.u.SetSpecialCall.SpecialCall = *Send++;
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
    }

    KdOut("DbgKdSetSpecialCalls returns 0x00000000\n");

    return S_OK;
}

void
ConnLiveKernelTargetInfo::InitializeWatchTrace(void)
{
    ADDR SpAddr;
            
    g_Machine->GetSP(&SpAddr);
    g_WatchInitialSP = Flat(SpAddr);
    g_BreakpointsSuspended = TRUE;

    NextTraceDataSym = 0;
    NumTraceDataSyms = 0;
}

LONG
SymNumFor(ULONG64 Pc)
{
    long index;

    for ( index = 0; index < NumTraceDataSyms; index++ )
    {
        if ( (TraceDataSyms[index].SymMin <= Pc) &&
             (TraceDataSyms[index].SymMax > Pc) )
        {
            return index;
        }
    }
    return -1;
}

VOID
PotentialNewSymbol(ULONG64 Pc)
{
    if ( -1 != SymNumFor(Pc) )
    {
        return;  // we've already seen this one
    }

    TraceDataSyms[NextTraceDataSym].SymMin = g_WatchBeginCurFunc;
    TraceDataSyms[NextTraceDataSym].SymMax = g_WatchEndCurFunc;

    //
    // Bump the "next" pointer, wrapping if necessary.  Also bump the
    // "valid" pointer if we need to.
    //

    NextTraceDataSym = (NextTraceDataSym + 1) %
        (sizeof(TraceDataSyms) / sizeof(TraceDataSyms[0]));;
    if ( NumTraceDataSyms < NextTraceDataSym )
    {
        NumTraceDataSyms = NextTraceDataSym;
    }
}

void
ConnLiveKernelTargetInfo::ProcessWatchTraceEvent(PDBGKD_TRACE_DATA TraceData,
                                                 PADDR PcAddr,
                                                 PBOOL StepOver)
{
    //
    // All of the real information is captured in the TraceData unions
    // sent to us by the kernel.  Here we have two main jobs:
    //
    // 1) Print out the data in the TraceData record.
    // 2) See if we need up update the SymNum table before
    //    returning to the kernel.
    //

    char SymName[MAX_SYMBOL_LEN];
    ULONG index;
    ULONG64 qw;
    ADDR CurSP;

    // Kernel mode always traces.
    *StepOver = FALSE;
    
    g_WatchFunctions.RecordEvent();
    
    g_Machine->GetSP(&CurSP);
    if (AddrEqu(g_WatchTarget, *PcAddr) && (Flat(CurSP) >= g_WatchInitialSP))
    {
        //
        // HACK HACK HACK
        //
        // fix up the last trace entry.
        //

        ULONG lastEntry = TraceData[0].LongNumber;
        if (lastEntry != 0)
        {
            TraceData[lastEntry].s.LevelChange = -1;
            // this is wrong if we
            // filled the symbol table!
            TraceData[lastEntry].s.SymbolNumber = 0;
        }
    }

    for ( index = 1; index < TraceData[0].LongNumber; index++ )
    {
        WatchFunction* Func;
        WatchCallStack* Call;
        ULONG64 SymOff = TraceDataSyms[TraceData[index].s.SymbolNumber].SymMin;

        GetSymbol(SymOff, SymName, sizeof(SymName), &qw);
        if (!SymName[0])
        {
            SymName[0] = '0';
            SymName[1] = 'x';
            strcpy(SymName + 2, FormatAddr64(SymOff));
            qw = 0;
        }

#if DBG_KWT
        dprintf("!%2d: lev %2d instr %4u %s %s\n",
                index,
                TraceData[index].s.LevelChange,
                TraceData[index].s.Instructions ==
                TRACE_DATA_INSTRUCTIONS_BIG ?
                TraceData[index + 1].LongNumber :
                TraceData[index].s.Instructions,
                FormatAddr64(SymOff), SymName);
#endif
        
        Func = g_WatchFunctions.FindAlways(SymName, SymOff - qw);
        if (Func == NULL)
        {
            ErrOut("Unable to allocate watch function\n");
            goto Flush;
        }

        Call = g_WatchFunctions.GetTopCall();
        if (Call == NULL || TraceData[index].s.LevelChange > 0)
        {
            if (Call == NULL)
            {
                // Treat the initial entry as a pseudo-call to
                // get it pushed.
                TraceData[index].s.LevelChange = 1;
            }
            
            while (TraceData[index].s.LevelChange != 0)
            {
                Call = g_WatchFunctions.PushCall(Func);
                if (Call == NULL)
                {
                    ErrOut("Unable to allocate watch call level\n");
                    goto Flush;
                }

                TraceData[index].s.LevelChange--;
            }
        }
        else if (TraceData[index].s.LevelChange < 0)
        {
            while (TraceData[index].s.LevelChange != 0)
            {
                g_WatchFunctions.PopCall();
                TraceData[index].s.LevelChange++;
            }

            // The level change may not actually be accurate, so
            // attempt to match up the current symbol offset with
            // some level of the call stack.
            Call = g_WatchFunctions.PopCallsToFunctionStart(SymOff);
            if (Call == NULL)
            {
                WarnOut(">> Unable to match return to %s\n", SymName);
                Call = g_WatchFunctions.GetTopCall();
            }
        }
        else
        {
            // We just made a horizontal call.
            g_WatchFunctions.ReuseCall(Call, Func);
        }

        ULONG InstrCount;
        
        if (TraceData[index].s.Instructions == TRACE_DATA_INSTRUCTIONS_BIG)
        {
            InstrCount = TraceData[++index].LongNumber;
        }
        else
        {
            InstrCount = TraceData[index].s.Instructions;
        }

        if (Call != NULL)
        {
            Call->InstrCount += InstrCount;
            g_WatchFunctions.OutputCall(Call, WCALL_OTHER);
        }
    }

    //
    // now see if we need to add a new symbol
    //

    index = SymNumFor(Flat(*PcAddr));
    if (-1 == index)
    {
        /* yup, add the symbol */

        GetAdjacentSymOffsets(Flat(*PcAddr),
                              &g_WatchBeginCurFunc, &g_WatchEndCurFunc);
        if ((g_WatchBeginCurFunc == 0) ||
            (g_WatchEndCurFunc == (ULONG64)-1))
        {
            // Couldn't determine function, fake up
            // a single-byte function.
            g_WatchBeginCurFunc = g_WatchEndCurFunc = Flat(*PcAddr);
        }

        PotentialNewSymbol(Flat(*PcAddr));
    }
    else
    {
        g_WatchBeginCurFunc = TraceDataSyms[index].SymMin;
        g_WatchEndCurFunc = TraceDataSyms[index].SymMax;
    }

    if ((g_WatchBeginCurFunc <= Flat(g_WatchTarget)) &&
        (Flat(g_WatchTarget) < g_WatchEndCurFunc))
    {
        // The "exit" address is in the symbol range;
        // fix it so this isn't the case.
        if (Flat(*PcAddr) < Flat(g_WatchTarget))
        {
            g_WatchEndCurFunc = Flat(g_WatchTarget);
        }
        else
        {
            g_WatchBeginCurFunc = Flat(g_WatchTarget) + 1;
        }
    }

 Flush:
    FlushCallbacks();
}

//----------------------------------------------------------------------------
//
// UserTargetInfo watch trace methods.
//
//----------------------------------------------------------------------------

LONG g_DeferredLevelChange;

void
LiveUserTargetInfo::InitializeWatchTrace(void)
{
    g_DeferredLevelChange = 0;
}

void
LiveUserTargetInfo::ProcessWatchTraceEvent(PDBGKD_TRACE_DATA TraceData,
                                           PADDR PcAddr,
                                           PBOOL StepOver)
{
    WatchFunction* Func;
    WatchCallStack* Call;
    ULONG64 Disp64;
    CHAR Disasm[MAX_DISASM_LEN];

    // Default to tracing in.
    *StepOver = FALSE;
    
    g_WatchFunctions.RecordEvent();
    
    //
    // Get current function and see if it matches current.  If so, bump
    // count in current, otherwise, update to new level
    //

    GetSymbol(Flat(*PcAddr), Disasm, sizeof(Disasm), &Disp64);

    // If there's no symbol for the current address create a
    // fake symbol for the instruction address.
    if (!Disasm[0])
    {
        Disasm[0] = '0';
        Disasm[1] = 'x';
        strcpy(Disasm + 2, FormatAddr64(Flat(*PcAddr)));
        Disp64 = 0;
    }
    
    Func = g_WatchFunctions.FindAlways(Disasm, Flat(*PcAddr) - Disp64);
    if (Func == NULL)
    {
        ErrOut("Unable to allocate watch symbol\n");
        goto Flush;
    }
    
    ADDR PcCopy;

    PcCopy = *PcAddr;
    g_Machine->Disassemble(g_Process, &PcCopy, Disasm, FALSE);

    Call = g_WatchFunctions.GetTopCall();
    if (Call == NULL)
    {
        //
        // First symbol in the list
        //

        Call = g_WatchFunctions.PushCall(Func);
        if (Call == NULL)
        {
            ErrOut("Unable to allocate watch symbol\n");
            goto Flush;
        }

        // At least one instruction must have executed
        // in this call to register it so initialize to one.
        // Also, one instruction was executed to get to the
        // first trace point so count it here.
        Call->InstrCount += 2;
    }
    else
    {
        if (g_DeferredLevelChange < 0)
        {
            g_DeferredLevelChange = 0;

            g_WatchFunctions.OutputCall(Call, WCALL_RETURN);
            
            // We have to see if this is really returning to a call site.
            // We do this because of try-finally funnies
            LONG OldLevel = g_WatchFunctions.GetCallLevel();
            WatchCallStack* CallSite =
                g_WatchFunctions.PopCallsToCallSite(PcAddr);
            if (CallSite == NULL)
            {
                WarnOut(">> No match on ret %s\n", Disasm);
            }
            else
            {
                if (OldLevel - 1 != CallSite->Level)
                {
                    WarnOut(">> More than one level popped %d -> %d\n",
                            OldLevel, CallSite->Level);
                }
                
                ZeroMemory(&CallSite->CallSite, sizeof(CallSite->CallSite));
                Call = CallSite;
            }
        }

        if (Call->Func == Func && g_DeferredLevelChange == 0)
        {
            Call->InstrCount++;
        }
        else
        {
            g_WatchFunctions.OutputCall(Call, g_DeferredLevelChange > 0 ?
                                        WCALL_CALL : WCALL_OTHER);

            if (g_DeferredLevelChange > 0)
            {
                g_DeferredLevelChange = 0;

                Call = g_WatchFunctions.PushCall(Func);
                if (Call == NULL)
                {
                    ErrOut("Unable to allocate watch symbol\n");
                    goto Flush;
                }
            }
            else
            {
                g_WatchFunctions.ReuseCall(Call, Func);
            }

            // At least one instruction must have executed
            // in this call to register it so initialize to one.
            Call->InstrCount++;
        }
    }

#if DBG_UWT
    dprintf("! %3d %s", Call != NULL ? Call->InstrCount : -1, Disasm);
#endif
    
    //
    // Adjust watch level to compensate for kernel-mode callbacks
    //
    if (Call->InstrCount == 1)
    {
        if (!_stricmp(Call->Func->Symbol,
                      "ntdll!_KiUserCallBackDispatcher"))
        {
            g_WatchFunctions.ChangeCallLevel(1);
            Call->Level = g_WatchFunctions.GetCallLevel();
        }
        else if (!_stricmp(Call->Func->Symbol, "ntdll!_ZwCallbackReturn"))
        {
            g_WatchFunctions.ChangeCallLevel(-2);
            Call->Level = g_WatchFunctions.GetCallLevel();
        }
    }

    if (g_Machine->IsCallDisasm(Disasm))
    {
        if (g_WatchFunctions.GetCallLevel() >=
            g_WatchFunctions.m_MaxCallLevelAllowed)
        {
            // We're at the maximum allowed depth
            // so just step over the call.
            *StepOver = TRUE;
        }
        else
        {
            Call->CallSite = *PcAddr;
            g_DeferredLevelChange = 1;
        }
    }
    else if (g_Machine->IsReturnDisasm(Disasm))
    {
        g_DeferredLevelChange = -1;
    }
    else if (g_Machine->IsSystemCallDisasm(Disasm))
    {
        PSTR CallName;
        WatchCallStack* SysCall = Call;

        CallName = strchr(Call->Func->Symbol, '!');
        if (!CallName)
        {
            CallName = Call->Func->Symbol;
        }
        else
        {
            CallName++;
        }
        if (!strcmp(Call->Func->Symbol, "SharedUserData!SystemCallStub"))
        {
            // We're in a Windows XP system call thunk
            // and the interesting system call symbol is the previous level.
            SysCall = Call->Prev;
        }

        if (SysCall != NULL)
        {
            SysCall->Func->SystemCalls++;

            // ZwRaiseException returns out two levels after the call.
            if (!_stricmp(SysCall->Func->Symbol, "ntdll!ZwRaiseException") ||
                !_stricmp(SysCall->Func->Symbol, "ntdll!_ZwRaiseException"))
            {
                g_WatchFunctions.ChangeCallLevel(-1);
            }
        }

        g_WatchFunctions.ChangeCallLevel(-1);
    }

 Flush:
    FlushCallbacks();
}

//----------------------------------------------------------------------------
//
// Support functions.
//
//----------------------------------------------------------------------------

void
ParseStepTrace(ThreadInfo* Thread,
               BOOL ThreadFreeze,
               char StepType)
{
    ADDR Addr1;
    ULONG64 Value2;
    char Ch;
    CHAR AddrBuffer[MAX_SYMBOL_LEN];
    ULONG64 Displacement;
    BOOL ToCall = FALSE;

    // If there's an outstanding request for input don't
    // allow the execution status of the engine to change
    // as it could lead to a wait which cannot
    // be carried out in this situation.  It's better to fail
    // this call and have the caller try again.
    if (g_InputNesting >= 1)
    {
        error(ENGBUSY);
    }
    
    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }
    
    if (!g_Target->m_DynamicEvents)
    {
        error(TARGETNOTSUP);
    }

    if (IS_LIVE_USER_TARGET(g_Target))
    {
        TargetInfo* Target;

        ForAllLayersToTarget()
        {
            if (Target->m_AllProcessFlags & ENG_PROC_EXAMINED)
            {
                ErrOut("The debugger is not attached to some processes so\n"
                       "process execution cannot be monitored\n");
                return;
            }
            else if (Target->m_BreakInTimeout)
            {
                ErrOut("Due to the break-in timeout the debugger "
                       "cannot step or trace\n");
                return;
            }
        }
    }
    
    if (StepType == 'w')
    {
        if (IS_KERNEL_TARGET(g_Target) &&
            g_Target->m_MachineType != IMAGE_FILE_MACHINE_I386)
        {
            error(UNIMPLEMENT);
        }
        
        if ((PeekChar() == 't') ||
            (IS_KERNEL_TARGET(g_Target) && PeekChar() == 'w'))
        {
            g_WatchTrace = TRUE;
            g_WatchWhole = *g_CurCmd == 'w';
            g_WatchBeginCurFunc = g_WatchEndCurFunc = 0;
            g_CurCmd++;

            g_WatchFunctions.ParseParameters();
        }
        else
        {
            error(SYNTAX);
        }
    }
    else
    {
        g_WatchTrace = FALSE;

        //
        // if next character is 'b' and command is 't' perform branch trace
        //

        Ch = PeekChar();
        Ch = (char)tolower(Ch);
        if (StepType == 't' && Ch == 'b')
        {
            if (!g_Machine->IsStepStatusSupported(DEBUG_STATUS_STEP_BRANCH))
            {
                error(TARGETNOTSUP);                
            }

            StepType = 'b';
            g_CurCmd++;
        }
        else if (Ch == 'c')
        {
            // Step/trace to next call.
            ToCall = TRUE;
            g_CurCmd++;
        }

        //
        //  if next character is 'r', toggle flag to output registers
        //  on display on breakpoint.
        //

        Ch = PeekChar();
        if (tolower(Ch) == 'r')
        {
            g_CurCmd++;
            g_OciOutputRegs = !g_OciOutputRegs;
        }
    }

    g_Machine->GetPC(&Addr1);         // default to current PC
    if (PeekChar() == '=')
    {
        g_CurCmd++;
        GetAddrExpression(SEGREG_CODE, &Addr1);
    }

    Value2 = 1;
    if ((Ch = PeekChar()) != '\0' && Ch != ';')
    {
        Value2 = GetExpression();
    }
    else if (StepType == 'w')
    {
        GetSymbol(Flat(Addr1),
                  AddrBuffer, sizeof(AddrBuffer), &Displacement);
        if (Displacement == 0 && AddrBuffer[ 0 ] != '\0')
        {
            ADDR Addr2;
            
            g_Machine->GetRetAddr(&Addr2);
            Value2 = Flat(Addr2);
            dprintf("Tracing %s to return address %s\n",
                    AddrBuffer,
                    FormatAddr64(Value2));
            if (g_WatchWhole)
            {
                g_WatchBeginCurFunc = Value2;
                g_WatchEndCurFunc = 0;
            }
        }
    }

    if (((LONG)Value2 <= 0) && (!g_WatchTrace))
    {
        error(SYNTAX);
    }
    
    SetExecStepTrace(&Addr1,
                     Value2,  // count or watch end address
                     Thread,
                     ThreadFreeze,
                     ToCall,
                     StepType);
}

//
// Returns TRUE if the current step/trace should be passed over.
//
BOOL
StepTracePass(PADDR PcAddr)
{
    if (g_StepTraceToCall)
    {
        char Disasm[MAX_DISASM_LEN];
        ADDR Addr = *PcAddr;
        
        // We're tracing by call instructions.  Pass if
        // the current instruction isn't a call.  If we
        // can't disassemble stop stepping as we don't
        // want to miss something.
        if (g_Machine->Disassemble(g_Process, &Addr, Disasm, FALSE) &&
            !g_Machine->IsCallDisasm(Disasm) &&
            !g_Machine->IsSystemCallDisasm(Disasm))
        {
            return TRUE;
        }
    }
    
    // If we have valid source line information and we're stepping
    // by source line, check and see if we moved from one line to another.
    if ((g_SrcOptions & SRCOPT_STEP_SOURCE) && g_SrcLineValid)
    {
        IMAGEHLP_LINE64 Line;
        ULONG Disp;
        ULONG64 Disp64;
        SYMBOL_INFO SymInfo = {0};

        if (GetLineFromAddr(g_Process, Flat(*PcAddr), &Line, &Disp))
        {
            if (Line.LineNumber == g_SrcLine.LineNumber)
            {
                // The common case is that we're still in the same line,
                // so check for a name match by pointer as a very quick
                // trivial accept.  If there's a mismatch we need to
                // do the hard comparison.

                if (Line.FileName == g_SrcLine.FileName ||
                    _strcmpi(Line.FileName, g_SrcLine.FileName) == 0)
                {
                    // We're still on the same line so don't treat
                    // this as motion.
                    return TRUE;
                }
            }

            // We've changed lines so we drop one from the pass count.
            // SrcLine also needs to be updated.
            g_SrcLine = Line;
        }
        else if (SymFromAddr(g_Process->m_SymHandle,
                             Flat(*PcAddr),
                             &Disp64,
                             &SymInfo) &&
                 SymInfo.Tag == SymTagThunk)
        {
            // If we're on a thunk we just go ahead and keep
            // stepping so that things don't stop in compiler-
            // generated intermediaries like incremental compilation
            // thunks.
            return TRUE;
        }
        else
        {
            // If we can't get line number information for the current
            // address we treat it as a transition on the theory that
            // it's better to stop than to skip interesting code.
            g_SrcLineValid = FALSE;
        }
    }

    if (--g_StepTracePassCount > 0)
    {
        if (!g_WatchFunctions.IsStarted())
        {
            // If the engine doesn't break for some other reason
            // on this intermediate step it should output the
            // step information to show the user the stepping
            // path.
            g_EngDefer |= ENG_DEFER_OUTPUT_CURRENT_INFO;
        }
        
        return TRUE;
    }

    return FALSE;
}

void
SetExecStepTrace(PADDR StartAddr,
                 ULONG64 PassCount,
                 ThreadInfo* Thread,
                 BOOL ThreadFreeze,
                 BOOL ToCall,
                 char StepType)
{
    // If we're stepping a particular thread it better
    // be the current context thread so that the machine
    // activity occurs on the appropriate thread.
    DBG_ASSERT(Thread == NULL || Thread == g_Target->m_RegContextThread);

    if ((g_SrcOptions & SRCOPT_STEP_SOURCE) && fFlat(*StartAddr))
    {
        ULONG Disp;

        // Get the current line information so it's possible to
        // tell when the line changes.
        g_SrcLineValid = GetLineFromAddr(g_Process, Flat(*StartAddr),
                                         &g_SrcLine, &Disp);
    }

    g_Machine->SetPC(StartAddr);
    g_StepTracePassCount = (ULONG)PassCount;
    g_StepTraceToCall = ToCall;

    SelectExecutionThread(Thread, 
                          ThreadFreeze ? SELTHREAD_THREAD : SELTHREAD_ANY);

    if (StepType == 'w')
    {
        ULONG NextMachine;
        
        g_Target->InitializeWatchTrace();
        g_WatchFunctions.Start();
        
        g_WatchTarget = *StartAddr;
        g_Machine->GetNextOffset(g_Process, TRUE,
                                 &g_WatchTarget, &NextMachine);
        if (Flat(g_WatchTarget) != OFFSET_TRACE || PassCount != 1)
        {
            g_Target->InitializeTargetControlledStepping();
            g_StepTracePassCount = 0xfffffff;
            if (PassCount != 1)
            {
                Flat(g_WatchTarget) = PassCount;
            }
        }
        
        StepType = 't';
    }

    g_CmdState = StepType;
    switch(StepType)
    {
    case 'b':
        g_ExecutionStatusRequest = DEBUG_STATUS_STEP_BRANCH;
        break;
    case 't':
        g_ExecutionStatusRequest = DEBUG_STATUS_STEP_INTO;
        break;
    case 'p':
    default:
        g_ExecutionStatusRequest = DEBUG_STATUS_STEP_OVER;
        break;
    }

    if (Thread)
    {
        g_StepTraceBp->m_Process = Thread->m_Process;
        g_StepTraceBp->m_MatchThread = Thread;
    }
    else
    {
        g_StepTraceBp->m_Process = g_Process;
        g_StepTraceBp->m_MatchThread = g_Thread;
    }
    if (StepType == 'b')
    {
        // Assume that taken branch trace is always performed by
        // hardware so set the g_StepTraceBp address to OFFSET_TRACE
        // (the value returned by GetNextOffset to signal the
        // hardware stepping mode).
        DBG_ASSERT(g_Machine->
                   IsStepStatusSupported(DEBUG_STATUS_STEP_BRANCH));
        ADDRFLAT(g_StepTraceBp->GetAddr(), OFFSET_TRACE);
    }
    else
    {
        ULONG NextMachine;
                
        g_Machine->GetNextOffset(g_Process, g_CmdState == 'p',
                                 g_StepTraceBp->GetAddr(),
                                 &NextMachine);
        g_StepTraceBp->SetProcType(NextMachine);
    }
    GetCurrentMemoryOffsets(&g_StepTraceInRangeStart,
                            &g_StepTraceInRangeEnd);
    g_StepTraceBp->m_Flags |= DEBUG_BREAKPOINT_ENABLED;
    g_StepTraceCmdState = g_CmdState;
    
    g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
    NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                            g_ExecutionStatusRequest, TRUE);
}

void
SetExecGo(ULONG ExecStatus,
          PADDR StartAddr,
          ThreadInfo* Thread,
          BOOL ThreadFreeze,
          ULONG BpCount,
          PADDR BpArray,
          PCSTR BpCmd)
{
    ULONG Count;

    // If we're resuming a particular thread it better
    // be the current context thread so that the machine
    // activity occurs on the appropriate thread.
    DBG_ASSERT(Thread == NULL || Thread == g_Target->m_RegContextThread);

    if (IS_CUR_CONTEXT_ACCESSIBLE())
    {
        g_Machine->SetPC(StartAddr);
    }

    // Remove old go breakpoints.
    for (Count = 0; Count < g_NumGoBreakpoints; Count++)
    {
        if (g_GoBreakpoints[Count] != NULL)
        {
            RemoveBreakpoint(g_GoBreakpoints[Count]);
            g_GoBreakpoints[Count] = NULL;
        }
    }
        
    DBG_ASSERT(BpCount <= MAX_GO_BPS);
    g_NumGoBreakpoints = BpCount;
        
    // Add new go breakpoints.
    for (Count = 0; Count < g_NumGoBreakpoints; Count++)
    {
        HRESULT Status;
            
        // First try to put the breakpoint at an ID up
        // and out of the way of user breakpoints.
        Status = AddBreakpoint(NULL, g_Machine, DEBUG_BREAKPOINT_CODE |
                               BREAKPOINT_HIDDEN, 10000 + Count,
                               &g_GoBreakpoints[Count]);
        if (Status != S_OK)
        {
            // That didn't work so try letting the engine
            // pick an ID.
            Status =
                AddBreakpoint(NULL, g_Machine, DEBUG_BREAKPOINT_CODE |
                              BREAKPOINT_HIDDEN, DEBUG_ANY_ID,
                              &g_GoBreakpoints[Count]);
        }
        if (Status != S_OK)
        {
            WarnOut("Temp bp at ");
            MaskOutAddr(DEBUG_OUTPUT_WARNING, BpArray);
            WarnOut("failed.\n");
        }
        else
        {
            // Matches must be allowed so that temporary breakpoints
            // don't interfere with permanent breakpoints.
            g_GoBreakpoints[Count]->SetAddr(BpArray,
                                            BREAKPOINT_ALLOW_MATCH);
            g_GoBreakpoints[Count]->m_Flags |=
                (DEBUG_BREAKPOINT_GO_ONLY |
                 DEBUG_BREAKPOINT_ENABLED);
        }

        if (BpCmd &&
            g_GoBreakpoints[Count]->SetCommand(BpCmd) != S_OK)
        {
            WarnOut("Unable to set go breakpoint command\n");
        }
        
        BpArray++;
    }

    g_CmdState = 'g';
    if (Thread == NULL || Thread == g_StepTraceBp->m_MatchThread)
    {
        g_StepTraceBp->m_Flags &= ~DEBUG_BREAKPOINT_ENABLED;
    }
    g_ExecutionStatusRequest = ExecStatus;
    SelectExecutionThread(Thread, 
                          ThreadFreeze ? SELTHREAD_THREAD : SELTHREAD_ANY);
    NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS, ExecStatus, TRUE);
}

void
ParseGoCmd(ThreadInfo* Thread,
           BOOL ThreadFreeze)
{
    ULONG BpCount;
    ADDR BpAddr[MAX_GO_BPS];
    CHAR Ch;
    ADDR PcAddr;
    CHAR Ch2;
    ULONG ExecStatus;

    if (!AnyEventsPossible())
    {
        error(NORUNNABLE);
    }

    // If there's an outstanding request for input don't
    // allow the execution status of the engine to change
    // as it could lead to a wait which cannot
    // be carried out in this situation.  It's better to fail
    // this call and have the caller try again.
    if (g_InputNesting >= 1)
    {
        error(ENGBUSY);
    }
    
    if (AllProcessFlags() & ENG_PROC_EXAMINED)
    {
        ErrOut("The debugger is not attached so "
               "process execution cannot be monitored\n");
        return;
    }

    if (IS_RUNNING(g_CmdState))
    {
        ErrOut("Debuggee is busy, cannot go\n");
        return;
    }

    ExecStatus = DEBUG_STATUS_GO;
    Ch = (CHAR)tolower(*g_CurCmd);
    if (Ch == 'h' || Ch == 'n')
    {
        Ch2 = *(g_CurCmd + 1);
        if (Ch2 == ' ' || Ch2 == '\t' || Ch2 == '\0')
        {
            g_CurCmd++;
            ExecStatus = Ch == 'h' ? DEBUG_STATUS_GO_HANDLED :
                DEBUG_STATUS_GO_NOT_HANDLED;
        }
    }

    g_PrefixSymbols = TRUE;

    if (IS_CUR_CONTEXT_ACCESSIBLE())
    {
        g_Machine->GetPC(&PcAddr);       //  default to current PC
    }
    else
    {
        ZeroMemory(&PcAddr, sizeof(PcAddr));
    }
    
    if (PeekChar() == '=')
    {
        g_CurCmd++;
        GetAddrExpression(SEGREG_CODE, &PcAddr);
    }
    
    BpCount = 0;
    while ((Ch = PeekChar()) != '\0' && Ch != ';')
    {
        ULONG AddrSpace, AddrFlags;

        if (BpCount == DIMA(BpAddr))
        {
            error(LISTSIZE);
        }
        
        GetAddrExpression(SEGREG_CODE, BpAddr + (BpCount++));
        
        if (g_Target->
            QueryAddressInformation(g_Process, Flat(BpAddr[BpCount - 1]),
                                    DBGKD_QUERY_MEMORY_VIRTUAL,
                                    &AddrSpace, &AddrFlags) != S_OK)
        {
            ErrOut("Invalid breakpoint address\n");
            error(MEMORY);
        }

        if (AddrSpace == DBGKD_QUERY_MEMORY_SESSION ||
            !(AddrFlags & DBGKD_QUERY_MEMORY_WRITE) ||
            (AddrFlags & DBGKD_QUERY_MEMORY_FIXED))
        {
            ErrOut("Software breakpoints cannot be used on session code, "
                   "ROM code or other\nread-only memory. "
                   "Use hardware execution breakpoints (ba e) instead.\n");
            error(MEMORY);
        }            
    }

    g_PrefixSymbols = FALSE;
    
    if (IS_USER_TARGET(g_Target))
    {
        g_LastCommand[0] = '\0';    //  null out g command
    }

    //
    // Check for trailing commands so that they can be attached
    // to any go breakpoints that are being created.
    //

    PCSTR BpCmd = g_CurCmd;
    
    if (g_EngStatus & ENG_STATUS_NO_AUTO_WAIT)
    {
        while (*BpCmd == ';' || *BpCmd == ' ' || *BpCmd == '\t')
        {
            BpCmd++;
        }
        if (!*BpCmd)
        {
            BpCmd = NULL;
        }
    }
    else
    {
        // Auto-waiting is enabled so just let the auto-wait
        // handle trailing commands.
        BpCmd = NULL;
    }
    
    SetExecGo(ExecStatus, &PcAddr, Thread, ThreadFreeze,
              BpCount, BpAddr, BpCmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\stepgo.hpp ===
//----------------------------------------------------------------------------
//
// Handles stepping, tracing, watching and go.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _STEPGO_HPP_
#define _STEPGO_HPP_

struct WatchFunction
{
    ULONG64 StartOffset;
    
    // Hash bucket list.
    WatchFunction* Next;
    // Sorted list.
    WatchFunction* Sort;
    
    ULONG Calls;
    ULONG MinInstr, MaxInstr, TotalInstr;
    // This counter is incremented every time a system call
    // instruction is hit inside the function.
    ULONG SystemCalls;
    // There's no strong need to make this symbol buffer
    // MAX_SYMBOL_LEN as the output only displays half a
    // line's worth of the name.  The only real reason to
    // keep more is to reduce false sharing due to prefix
    // matches.  The buffer is large enough that this should
    // be extremely rare, plus we keep the true length
    // as a further check.
    ULONG SymbolLength;
    CHAR Symbol[256];
};

struct WatchCallStack
{
    ADDR CallSite;
    WatchFunction* Func;
    WatchCallStack* Prev, *Next;
    LONG Level;
    ULONG InstrCount, ChildInstrCount;
};

enum WATCH_CALL_TYPE
{
    WCALL_OTHER,
    WCALL_CALL,
    WCALL_RETURN,
};

//----------------------------------------------------------------------------
//
// WatchFunctions.
//
// Collects function information encountered during watch tracing.
//
//----------------------------------------------------------------------------

#define WF_BUCKETS 71

class WatchFunctions
{
public:
    WatchFunctions(void);
    
    void Start(void);
    void End(PADDR PcAddr);
    
    BOOL IsStarted(void)
    {
        return m_Started;
    }

    void OutputFunctions(void);
    void OutputSysCallFunctions(void);

    WatchFunction* FindAlways(PSTR Sym, ULONG64 Start);

    WatchCallStack* GetTopCall(void)
    {
        return m_CallTop;
    }
    WatchCallStack* PushCall(WatchFunction* Func);
    void            PopCall(void);
    WatchCallStack* PopCallsToCallSite(PADDR Pc);
    WatchCallStack* PopCallsToFunctionStart(ULONG64 Start);
    void            ReuseCall(WatchCallStack* Call,
                              WatchFunction* ReinitFunc);

    void IndentForCall(WatchCallStack* Call);
    void OutputCall(WatchCallStack* Call, WATCH_CALL_TYPE Type);

    void SetDefaultParameters(void);
    void ParseParameters(void);
    
    LONG GetCallLevel(void)
    {
        return m_CallLevel;
    }
    LONG ChangeCallLevel(LONG Delta)
    {
        m_CallLevel += Delta;
        if (m_CallLevel < 0)
        {
            m_CallLevel = 0;
        }
        return m_CallLevel;
    }

    ULONG RecordEvent(void)
    {
        return ++m_TotalWatchTraceEvents;
    }
    ULONG RecordThreadMismatch(void)
    {
        return ++m_TotalWatchThreadMismatches;
    }
    
    LONG m_MaxCallLevelAllowed;
    ULONG m_OutputReturnValues:1;
    ULONG m_OutputCallAddrs:1;
    ULONG m_OutputCalls:1;
    ULONG m_OutputSummary:1;
    
protected:
    ULONG Hash(PSTR Sym, ULONG SymLen)
    {
        // Hash on the first and last letters of the symbol.
        return ((ULONG)(UCHAR)Sym[0] +
                (ULONG)(UCHAR)Sym[SymLen - 1]) % WF_BUCKETS;
    }

    WatchFunction* Add(PSTR Sym, ULONG64 Start);
    WatchFunction* Find(PSTR Sym);
    void           Clear(void);

    BOOL m_Started;

    ULONG m_TotalInstr;
    ULONG m_TotalWatchTraceEvents;
    ULONG m_TotalWatchThreadMismatches;

    WatchFunction* m_Funcs[WF_BUCKETS];
    WatchFunction* m_Sorted;

    WatchCallStack* m_CallTop, *m_CallBot;
    LONG m_CallLevel;
};

extern WatchFunctions g_WatchFunctions;

extern ULONG      g_StepTracePassCount;
extern ULONG64    g_StepTraceInRangeStart;
extern ULONG64    g_StepTraceInRangeEnd;

extern BOOL       g_SrcLineValid;

extern BOOL       g_WatchTrace;
extern BOOL       g_WatchWhole;
extern ADDR       g_WatchTarget;
extern ULONG64    g_WatchInitialSP;
extern ULONG64    g_WatchBeginCurFunc;
extern ULONG64    g_WatchEndCurFunc;

#define MAX_GO_BPS 16

extern Breakpoint* g_GoBreakpoints[MAX_GO_BPS];
extern ULONG g_NumGoBreakpoints;

void ResetStepTrace(void);

BOOL StepTracePass(PADDR PcAddr);

void
SetExecGo(ULONG ExecStatus,
          PADDR StartAddr,
          ThreadInfo* Thread,
          BOOL ThreadFreeze,
          ULONG BpCount,
          PADDR BpArray,
          PCSTR BpCmd);

void
SetExecStepTrace(PADDR StartAddr,
                 ULONG64 PassCount,
                 ThreadInfo* Thread,
                 BOOL ThreadFreeze,
                 BOOL ToCall,
                 char StepType);

void
ParseGoCmd(ThreadInfo* Thread,
           BOOL ThreadFreeze);

void ParseStepTrace(ThreadInfo* Thread,
                    BOOL ThreadFreeze,
                    char StepType);

VOID SetupSpecialCalls(VOID);

#endif // #ifndef _STEPGO_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\stkwalk.cpp ===
//----------------------------------------------------------------------------
//
// Stack walking support.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

BOOL g_AllowCorStack = TRUE;
BOOL g_DebugCorStack;

IMAGE_IA64_RUNTIME_FUNCTION_ENTRY g_EpcRfeBuffer;
PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY g_EpcRfe;

PFPO_DATA
SynthesizeKnownFpo(PSTR Symbol, ULONG64 OffStart, ULONG64 Disp)
{
    static ULONG64 s_Nr2, s_Lu2, s_Eh3, s_Kuit;

    if (!s_Nr2 || !s_Lu2 || !s_Eh3 || !s_Kuit)
    {
        GetOffsetFromSym(g_Process, "nt!_NLG_Return2", &s_Nr2, NULL);
        GetOffsetFromSym(g_Process, "nt!_local_unwind2", &s_Lu2, NULL);
        GetOffsetFromSym(g_Process, "nt!_except_handler3", &s_Eh3, NULL);
        GetOffsetFromSym(g_Process,
                         "nt!KiUnexpectedInterruptTail", &s_Kuit, NULL);
    }
        
    if (OffStart == s_Nr2 || OffStart == s_Lu2)
    {
        static FPO_DATA s_Lu2Fpo;

        s_Lu2Fpo.ulOffStart = (ULONG)OffStart;
        s_Lu2Fpo.cbProcSize = 0x68;
        s_Lu2Fpo.cdwLocals  = 4;
        s_Lu2Fpo.cdwParams  = 0;
        s_Lu2Fpo.cbProlog   = 0;
        s_Lu2Fpo.cbRegs     = 3;
        s_Lu2Fpo.fHasSEH    = 0;
        s_Lu2Fpo.fUseBP     = 0;
        s_Lu2Fpo.reserved   = 0;
        s_Lu2Fpo.cbFrame    = FRAME_FPO;
        return &s_Lu2Fpo;
    }
    else if (OffStart == s_Eh3)
    {
        static FPO_DATA s_Eh3Fpo;

        s_Eh3Fpo.ulOffStart = (ULONG)OffStart;
        s_Eh3Fpo.cbProcSize = 0xbd;
        s_Eh3Fpo.cdwLocals  = 2;
        s_Eh3Fpo.cdwParams  = 4;
        s_Eh3Fpo.cbProlog   = 3;
        s_Eh3Fpo.cbRegs     = 4;
        s_Eh3Fpo.fHasSEH    = 0;
        s_Eh3Fpo.fUseBP     = 0;
        s_Eh3Fpo.reserved   = 0;
        s_Eh3Fpo.cbFrame    = FRAME_NONFPO;
        return &s_Eh3Fpo;
    }
    else if (OffStart == s_Kuit)
    {
        //
        // KiUnexpectedInterruptTail has three special stubs
        // following it for CommonDispatchException[0-2]Args.
        // These stubs set up for the appropriate number of
        // arguments and then call CommonDispatchException.
        // They do not have symbols or FPO data so fake some
        // up if we're in the region immediately after KUIT.
        //
        
        PFPO_DATA KuitData = (PFPO_DATA)
            SymFunctionTableAccess(g_Process->m_SymHandle, OffStart);
        if (KuitData != NULL &&
            Disp >= (ULONG64)KuitData->cbProcSize &&
            Disp < (ULONG64)KuitData->cbProcSize + 0x20)
        {
            static FPO_DATA s_CdeStubFpo;
            
            s_CdeStubFpo.ulOffStart = (ULONG)OffStart;
            s_CdeStubFpo.cbProcSize = 0x10;
            s_CdeStubFpo.cdwLocals  = 0;
            s_CdeStubFpo.cdwParams  = 0;
            s_CdeStubFpo.cbProlog   = 0;
            s_CdeStubFpo.cbRegs     = 0;
            s_CdeStubFpo.fHasSEH    = 0;
            s_CdeStubFpo.fUseBP     = 0;
            s_CdeStubFpo.reserved   = 0;
            s_CdeStubFpo.cbFrame    = FRAME_TRAP;
            return &s_CdeStubFpo;
        }
    }

    return NULL;
}
    
PFPO_DATA
SynthesizeFpoDataForModule(DWORD64 PCAddr)
{
    DWORD64     Offset;
    CHAR        symbuf[MAX_SYMBOL_LEN];

    GetSymbol(PCAddr, symbuf, sizeof(symbuf), &Offset);

    if (Offset == PCAddr)
    {
        // No symbol.
        return NULL;
    }

    PFPO_DATA KnownFpo =
        SynthesizeKnownFpo(symbuf, PCAddr - Offset, Offset);
    if (KnownFpo != NULL)
    {
        return KnownFpo;
    }

    // Not a known symbol so no FPO is available.
    return NULL;
}

PFPO_DATA
SynthesizeFpoDataForFastSyscall(ULONG64 Offset)
{
    static FPO_DATA s_FastFpo;
    
    // XXX drewb - Temporary until the fake user-shared
    // module is worked out.
    
    s_FastFpo.ulOffStart = (ULONG)Offset;
    s_FastFpo.cbProcSize = X86_SHARED_SYSCALL_SIZE;
    s_FastFpo.cdwLocals  = 0;
    s_FastFpo.cdwParams  = 0;
    s_FastFpo.cbProlog   = 0;
    s_FastFpo.cbRegs     = 0;
    s_FastFpo.fHasSEH    = 0;
    s_FastFpo.fUseBP     = 0;
    s_FastFpo.reserved   = 0;
    s_FastFpo.cbFrame    = FRAME_FPO;
    return &s_FastFpo;
}    

PFPO_DATA
ModifyFpoRecord(ImageInfo* Image, PFPO_DATA FpoData)
{
    if (FpoData->cdwLocals == 80)
    {
        static ULONG64 s_CommonDispatchException;

        // Some versions of CommonDispatchException have
        // the wrong locals size, which screws up stack
        // traces.  Detect and fix up these problems.
        if (s_CommonDispatchException == 0)
        {
            GetOffsetFromSym(g_Process,
                             "nt!CommonDispatchException",
                             &s_CommonDispatchException,
                             NULL);
        }
                
        if (Image->m_BaseOfImage + FpoData->ulOffStart ==
            s_CommonDispatchException)
        {
            static FPO_DATA s_CdeFpo;
                    
            s_CdeFpo = *FpoData;
            s_CdeFpo.cdwLocals = 20;
            FpoData = &s_CdeFpo;
        }
    }
    else if (FpoData->cdwLocals == 0 && FpoData->cdwParams == 0 &&
             FpoData->cbRegs == 3)
    {
        static ULONG64 s_KiSwapThread;

        // KiSwapThread has shrink-wrapping so that three registers
        // are pushed in only a portion of the code.  Unfortunately,
        // the most important place in the code -- the call to
        // KiSwapContext -- is outside of this region and therefore
        // the register count is wrong much more often than it's
        // correct.  Switch the register count to two to make it
        // correct more often than wrong.
        if (s_KiSwapThread == 0)
        {
            GetOffsetFromSym(g_Process,
                             "nt!KiSwapThread", &s_KiSwapThread, NULL);
        }

        if (Image->m_BaseOfImage + FpoData->ulOffStart ==
            s_KiSwapThread)
        {
            static FPO_DATA s_KstFpo;

            s_KstFpo = *FpoData;
            s_KstFpo.cbRegs = 2;
            FpoData = &s_KstFpo;
        }
    }
    else if (FpoData->fHasSEH)
    {
        static FPO_DATA s_SehFpo;

        s_SehFpo = *FpoData;
        s_SehFpo.cbFrame = FRAME_NONFPO;
        FpoData = &s_SehFpo;
    }

    return FpoData;
}

PFPO_DATA
FindFpoDataForModule(DWORD64 PCAddr)
/*++

Routine Description:

    Locates the fpo data structure in the process's linked list for the
    requested module.

Arguments:

    PCAddr        - address contained in the program counter

Return Value:

    null            - could not locate the entry
    valid address   - found the entry at the adress retured

--*/
{
    ProcessInfo* Process;
    ImageInfo* Image;
    PFPO_DATA FpoData;

    Process = g_Process;
    Image = Process->m_ImageHead;
    FpoData = 0;
    while (Image)
    {
        if ((PCAddr >= Image->m_BaseOfImage) &&
            (PCAddr < Image->m_BaseOfImage + Image->m_SizeOfImage))
        {
            FpoData = (PFPO_DATA)
                SymFunctionTableAccess(g_Process->m_SymHandle, PCAddr);
            if (!FpoData)
            {
                FpoData = SynthesizeFpoDataForModule(PCAddr);
            }
            else
            {
                FpoData = ModifyFpoRecord(Image, FpoData);
            }
            
            return FpoData;
        }
        
        Image = Image->m_Next;
    }

    ULONG64 FscBase;
    
    switch(IsInFastSyscall(PCAddr, &FscBase))
    {
    case FSC_FOUND:
        return SynthesizeFpoDataForFastSyscall(FscBase);
    }
    
    // the function is not part of any known loaded image
    return NULL;
}

LPVOID
SwFunctionTableAccess(
    HANDLE  hProcess,
    ULONG64 AddrBase
    )
{
    static IMAGE_IA64_RUNTIME_FUNCTION_ENTRY s_Ia64;
    static _IMAGE_RUNTIME_FUNCTION_ENTRY s_Amd64;

    PVOID pife;

    if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386)
    {
        return (LPVOID)FindFpoDataForModule( AddrBase );
    }

    pife = SymFunctionTableAccess64(hProcess, AddrBase);

    switch(g_Machine->m_ExecTypes[0])
    {
    case IMAGE_FILE_MACHINE_IA64:
        if (pife)
        {
            s_Ia64 = *(PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)pife;
            return &s_Ia64;
        }
        else
        {
            if (IS_KERNEL_TARGET(g_Target) &&
                (AddrBase >= IA64_MM_EPC_VA) &&
                (AddrBase < (IA64_MM_EPC_VA + IA64_PAGE_SIZE)))
            {
                return g_EpcRfe;
            }
            else
            {
                return NULL;
            }
        }
        break;

    case IMAGE_FILE_MACHINE_AMD64:
        if (pife)
        {
            s_Amd64 = *(_PIMAGE_RUNTIME_FUNCTION_ENTRY)pife;
            return &s_Amd64;
        }
        break;
    }

    return NULL;
}

DWORD64
SwTranslateAddress(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddress
    )
{
    //
    // don't support 16bit stacks
    //
    return 0;
}

BOOL
SwReadMemory(
    HANDLE  hProcess,
    ULONG64 BaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    DBG_ASSERT(hProcess == OS_HANDLE(g_Process->m_SysHandle));

    if (IS_KERNEL_TARGET(g_Target))
    {
        DWORD   BytesRead;
        HRESULT Status;

        if ((LONG_PTR)lpNumberOfBytesRead == -1)
        {
            if (g_Target->m_MachineType == IMAGE_FILE_MACHINE_I386)
            {
                BaseAddress += g_Target->m_TypeInfo.SizeTargetContext;
            }
    
            Status = g_Target->ReadControl(CURRENT_PROC,
                                           (ULONG)BaseAddress,
                                           lpBuffer,
                                           nSize,
                                           &BytesRead);
            return Status == S_OK;
        }
    }

    if (g_Target->ReadVirtual(g_Process, BaseAddress, lpBuffer, nSize,
                              lpNumberOfBytesRead) != S_OK)
    {
        // Make sure bytes read is zero.
        if (lpNumberOfBytesRead != NULL)
        {
            *lpNumberOfBytesRead = 0;
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
SwReadMemory32(
    HANDLE hProcess,
    ULONG dwBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    return SwReadMemory(hProcess,
                        EXTEND64(dwBaseAddress),
                        lpBuffer,
                        nSize,
                        lpNumberOfBytesRead);
}

DWORD64
GetKernelModuleBase(
    ULONG64 Address
    )
{
    ModuleInfo* ModIter;

    if (!(ModIter = g_Target->GetModuleInfo(FALSE)) ||
        ModIter->Initialize(g_Thread) != S_OK)
    {
        return 0;
    }

    // We only want module base and size.
    ModIter->m_InfoLevel = MODULE_INFO_BASE_SIZE;

    for (;;)
    {
        MODULE_INFO_ENTRY ModEntry;

        ZeroMemory(&ModEntry, sizeof(ModEntry));
        if (ModIter->GetEntry(&ModEntry) != S_OK)
        {
            break;
        }

        if (Address >= ModEntry.Base &&
            Address < ModEntry.Base + ModEntry.Size)
        {
            return ModEntry.Base;
        }
    }

    return 0;
}

DWORD64
SwGetModuleBase(
    HANDLE  hProcess,
    ULONG64 Address
    )
{
    if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_IA64 &&
        IS_KERNEL_TARGET(g_Target) &&
        (Address >= IA64_MM_EPC_VA) &&
        (Address < (IA64_MM_EPC_VA + IA64_PAGE_SIZE)))
    {
        Address -= (IA64_MM_EPC_VA - g_Target->m_SystemCallVirtualAddress);
    }

    ImageInfo* Image = g_Process->FindImageByOffset(Address, TRUE);
    if (Image)
    {
        return Image->m_BaseOfImage;
    }

    // This might be the JIT output for managed code.
    // There's no 'base' as such but we need to return
    // something non-zero to indicate this code is known.
    // There won't be any FPO information so the module base
    // value isn't that important.  Just return the actual address.
    if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386 &&
        g_Process->IsCorCode(Address) == S_OK)
    {
        return Address;
    }
    
    // If no regular module was found we need to look in
    // the dynamic function tables to see if an entry
    // there matches.
    ULONG64 DynBase = g_Target->
        GetDynamicFunctionTableBase(g_Process, Address);
    if (DynBase)
    {
        return DynBase;
    }
    
    if (IS_KERNEL_TARGET(g_Target))
    {
        // If no modules have been loaded there's still a possibility
        // of getting a kernel stack trace (without symbols) by going
        // after the module base directly. This also makes it possible
        // to get a stack trace when there are no symbols available.

        if (g_Process->m_ImageHead == NULL)
        {
            return GetKernelModuleBase( Address );
        }
    }

    return 0;
}

DWORD
SwGetModuleBase32(
    HANDLE hProcess,
    DWORD Address
    )
{
    return (DWORD)SwGetModuleBase(hProcess, Address);
}


void
PrintStackTraceHeaderLine(
   ULONG Flags
   )
{
    if ( (Flags & DEBUG_STACK_COLUMN_NAMES) == 0 )
    {
        return;
    }

    StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_TIMESTAMP);

    if (Flags & DEBUG_STACK_FRAME_NUMBERS)
    {
        dprintf(" # ");
    }

    if (Flags & DEBUG_STACK_FRAME_MEMORY_USAGE)
    {
        dprintf(" Memory ");
    }
    
    if (Flags & DEBUG_STACK_FRAME_ADDRESSES)
    {
        g_Machine->PrintStackFrameAddressesTitle(Flags);
    }

    if (Flags & DEBUG_STACK_ARGUMENTS)
    {
        g_Machine->PrintStackArgumentsTitle(Flags);
    }

    g_Machine->PrintStackCallSiteTitle(Flags);

    dprintf("\n");
}

VOID
PrintStackFrame(
    PDEBUG_STACK_FRAME StackFrame,
    PDEBUG_STACK_FRAME PrevFrame,
    ULONG              Flags
    )
{
    ULONG64 Displacement;
    ULONG64 InstructionOffset = StackFrame->InstructionOffset;
    SYMBOL_INFO_AND_NAME SymInfo;

    if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_IA64 &&
        IS_KERNEL_TARGET(g_Target) &&
        (InstructionOffset >= IA64_MM_EPC_VA) &&
        (InstructionOffset < (IA64_MM_EPC_VA + IA64_PAGE_SIZE)))
    {
        InstructionOffset = InstructionOffset -
            (IA64_MM_EPC_VA - g_Target->m_SystemCallVirtualAddress);
    }

    GetSymbolInfo(InstructionOffset, NULL, 0,
                  SymInfo, &Displacement);
    
    StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_TIMESTAMP);

    if (Flags & DEBUG_STACK_FRAME_NUMBERS)
    {
        dprintf("%02lx ", StackFrame->FrameNumber);
    }

    if (Flags & DEBUG_STACK_FRAME_MEMORY_USAGE)
    {
        if (PrevFrame)
        {
            g_Machine->PrintStackFrameMemoryUsage(StackFrame, PrevFrame);
        }
        else
        {
            dprintf("        ");
        }
    }

    if (Flags & DEBUG_STACK_FRAME_ADDRESSES)
    {
        g_Machine->PrintStackFrameAddresses(Flags, StackFrame);
    }
    
    if (Flags & DEBUG_STACK_ARGUMENTS)
    {
        g_Machine->PrintStackArguments(Flags, StackFrame);
    }

    g_Machine->PrintStackCallSite(Flags, StackFrame, 
                                  SymInfo, SymInfo->Name,
                                  Displacement);

    if (Flags & DEBUG_STACK_SOURCE_LINE)
    {
        OutputLineAddr(InstructionOffset, " [%s @ %d]");
    }

    dprintf( "\n" );
}

BOOL
CheckFrameValidity(PDEBUG_STACK_FRAME Frame)
{
    //
    // If the current frame's IP is not in any loaded module
    // it's likely that we won't be able to unwind.
    //
    // If the current frame's IP is in a loaded module and
    // that module does not have symbols it's very possible
    // that the stack trace will be incorrect since the
    // debugger has to guess about how to unwind the stack.
    // Non-x86 architectures have unwind info in the images
    // themselves so restrict this check to x86.
    //
    
    if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386 &&
        Frame->InstructionOffset != -1 &&
        !Frame->FuncTableEntry &&
        g_Process->IsCorCode(Frame->InstructionOffset) != S_OK)
    {
        IMAGEHLP_MODULE64 Mod;

        Mod.SizeOfStruct = sizeof(Mod);
        if (!SymGetModuleInfo64(g_Process->m_SymHandle,
                                Frame->InstructionOffset, &Mod))
        {
            WarnOut("WARNING: Frame IP not in any known module. "
                    "Following frames may be wrong.\n");
            return TRUE;
        }
        else if (Mod.SymType == SymNone || Mod.SymType == SymExport ||
                 Mod.SymType == SymDeferred)
        {
            WarnOut("WARNING: Stack unwind information not available. "
                    "Following frames may be wrong.\n");
            return TRUE;
        }
    }

    return FALSE;
}

VOID
PrintStackTrace(
    ULONG              NumFrames,
    PDEBUG_STACK_FRAME StackFrames,
    ULONG              Flags
    )
{
    ULONG i;
    BOOL SymWarning = FALSE;

    PrintStackTraceHeaderLine(Flags);

    for (i = 0; i < NumFrames; i++)
    {
        if (!SymWarning && NumFrames > 1)
        {
            SymWarning = CheckFrameValidity(StackFrames + i);
        }
            
        PrintStackFrame(StackFrames + i,
                        i > 0 ? (StackFrames + (i - 1)) : NULL,
                        Flags);
    }
}

HRESULT
UnwindCorFrame(ICorDataStackWalk* CorStack,
               PCROSS_PLATFORM_CONTEXT Context,
               PDEBUG_STACK_FRAME DbgFrame,
               LPSTACKFRAME64 VirtFrame)
{
    HRESULT Status;
    ADDRESS64 PreInstr, PreStack, PreFrame;
    ADDRESS64 PostInstr, PostStack, PostFrame;
    CorDataFrameType CorFrameType;

    g_Machine->
        GetStackDefaultsFromContext(Context,
                                    &PreInstr, &PreStack, &PreFrame);

    if ((Status = CorStack->
         SetFrameContext(g_Target->m_TypeInfo.SizeTargetContext,
                         (BYTE*)Context)) != S_OK ||
        (Status = CorStack->
         GetFrameDescription(&CorFrameType, NULL, 0)) != S_OK)
    {
        return Status;
    }
    if (CorFrameType != DAC_FRAME_COR_METHOD_FRAME)
    {
        return S_FALSE;
    }
    if ((Status = CorStack->UnwindFrame()) != S_OK ||
        (Status = CorStack->
         GetFrameContext(g_Target->m_TypeInfo.SizeTargetContext,
                         (BYTE*)Context)) != S_OK)
    {
        return Status;
    }
    
    g_Machine->
        GetStackDefaultsFromContext(Context,
                                    &PostInstr, &PostStack, &PostFrame);

    if (g_DebugCorStack)
    {
        dprintf("  COR Pre  i %08X s %08X f %08x\n"
                "      Post i %08X s %08X f %08x\n",
                (ULONG)PreInstr.Offset,
                (ULONG)PreStack.Offset,
                (ULONG)PreFrame.Offset,
                (ULONG)PostInstr.Offset,
                (ULONG)PostStack.Offset,
                (ULONG)PostFrame.Offset);
    }

    DbgFrame->InstructionOffset = PreInstr.Offset;
    DbgFrame->ReturnOffset = PostInstr.Offset;
    DbgFrame->FrameOffset = PreFrame.Offset;
    DbgFrame->StackOffset = PreStack.Offset;
    DbgFrame->FuncTableEntry = 0;
    DbgFrame->Virtual = FALSE;

    ZeroMemory(DbgFrame->Reserved,
               sizeof(DbgFrame->Reserved));
    ZeroMemory(DbgFrame->Params, 
               sizeof(DbgFrame->Params));

    // Prepare the StackWalk64 frame in case it's
    // used later.  Setting Virtual to FALSE should
    // force the stack walker to reinitialize.
    VirtFrame->Virtual = FALSE;
    VirtFrame->AddrPC = PostInstr;
    VirtFrame->AddrFrame = PostFrame;
    VirtFrame->AddrStack = PostStack;

    return S_OK;
}

DWORD
StackTrace(
    DebugClient*       Client,
    ULONG64            FramePointer,
    ULONG64            StackPointer,
    ULONG64            InstructionPointer,
    ULONG              PointerDefaults,
    PDEBUG_STACK_FRAME StackFrames,
    ULONG              NumFrames,
    ULONG64            ExtThread,
    ULONG              Flags,
    BOOL               EstablishingScope
    )
{
    STACKFRAME64 VirtualFrame;
    DWORD i;
    CROSS_PLATFORM_CONTEXT Context;
    BOOL SymWarning = FALSE;
    ULONG X86Ebp;
    ULONG Seg;
    ADDRESS64 DefInstr, DefStack, DefFrame;
    HRESULT Status;
    ICorDataStackWalk* CorStack;

    if (!EstablishingScope)
    {
        RequireCurrentScope();
    }
    
    if (g_Machine->GetContextState(MCTX_FULL) != S_OK)
    {
        return 0;
    }

    Context = *GetScopeOrMachineContext();
    g_Machine->GetStackDefaultsFromContext(&Context, &DefInstr,
                                           &DefStack, &DefFrame);

    //
    // let's start clean
    //
    ZeroMemory( StackFrames, sizeof(StackFrames[0]) * NumFrames );
    ZeroMemory( &VirtualFrame, sizeof(VirtualFrame) );

    if (IS_KERNEL_TARGET(g_Target))
    {
        //
        // if debugger was initialized at boot, usermode addresses needed for
        // stack traces on IA64 were not available.  Try it now:
        //

        if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_IA64 &&
            !g_Target->m_KdDebuggerData.KeUserCallbackDispatcher)
        {
            g_Target->QueryKernelInfo(g_Thread, FALSE);
        }

        ULONG64 ThreadData;

        // If no explicit thread is given then we use the
        // current thread.  However, the current thread is only
        // valid if the current thread is the event thread since
        // tracing back into user mode requires that the appropriate
        // user-mode memory state be active.
        if (ExtThread != 0)
        {
            ThreadData = ExtThread;
        }
        else if (g_Thread != g_EventThread ||
                 g_Process != g_EventProcess ||
                 g_Process->
                 GetImplicitThreadData(g_Thread, &ThreadData) != S_OK)
        {
            ThreadData = 0;
        }

        VirtualFrame.KdHelp.Thread = ThreadData;
        VirtualFrame.KdHelp.ThCallbackStack = ThreadData ?
            g_Target->m_KdDebuggerData.ThCallbackStack : 0;
        VirtualFrame.KdHelp.KiCallUserMode =
            g_Target->m_KdDebuggerData.KiCallUserMode;
        VirtualFrame.KdHelp.NextCallback =
            g_Target->m_KdDebuggerData.NextCallback;
        VirtualFrame.KdHelp.KeUserCallbackDispatcher =
            g_Target->m_KdDebuggerData.KeUserCallbackDispatcher;
        VirtualFrame.KdHelp.FramePointer =
            g_Target->m_KdDebuggerData.FramePointer;
        VirtualFrame.KdHelp.SystemRangeStart = g_Target->m_SystemRangeStart;
    }
    
    //
    // setup the program counter
    //
    if (PointerDefaults & STACK_INSTR_DEFAULT)
    {
        VirtualFrame.AddrPC = DefInstr;
    }
    else
    {
        VirtualFrame.AddrPC.Mode = AddrModeFlat;
        Seg = g_Machine->GetSegRegNum(SEGREG_CODE);
        VirtualFrame.AddrPC.Segment =
            Seg ? (WORD)g_Machine->FullGetVal32(Seg) : 0;
        VirtualFrame.AddrPC.Offset = InstructionPointer;
    }

    //
    // setup the frame pointer
    //
    if (PointerDefaults & STACK_FRAME_DEFAULT)
    {
        VirtualFrame.AddrFrame = DefFrame;
    }
    else
    {
        VirtualFrame.AddrFrame.Mode = AddrModeFlat;
        Seg = g_Machine->GetSegRegNum(SEGREG_STACK);
        VirtualFrame.AddrFrame.Segment =
            Seg ? (WORD)g_Machine->FullGetVal32(Seg) : 0;
        VirtualFrame.AddrFrame.Offset = FramePointer;
    }
    VirtualFrame.AddrBStore = VirtualFrame.AddrFrame;
    X86Ebp = (ULONG)VirtualFrame.AddrFrame.Offset;

    //
    // setup the stack pointer
    //
    if (PointerDefaults & STACK_STACK_DEFAULT)
    {
        VirtualFrame.AddrStack = DefStack;
    }
    else
    {
        VirtualFrame.AddrStack.Mode = AddrModeFlat;
        Seg = g_Machine->GetSegRegNum(SEGREG_STACK);
        VirtualFrame.AddrStack.Segment =
            Seg ? (WORD)g_Machine->FullGetVal32(Seg) : 0;
        VirtualFrame.AddrStack.Offset = StackPointer;
    }

    if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_IA64 &&
        IS_KERNEL_TARGET(g_Target) &&
        g_Target->m_SystemCallVirtualAddress)
    {
        PVOID FunctionEntry;

        FunctionEntry = SwFunctionTableAccess
            (g_Process->m_SymHandle, g_Target->m_SystemCallVirtualAddress);
        if (FunctionEntry != NULL)
        {
            RtlCopyMemory(&g_EpcRfeBuffer, FunctionEntry,
                          sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY));
            g_EpcRfe = &g_EpcRfeBuffer;
        }
        else
        {
            g_EpcRfe = NULL;
        }
    }

    if (g_AllowCorStack &&
        g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386)
    {
        // XXX drewb - No good way to know what runtime thread
        // to use, so always use the current one.
        CorStack = g_Process->StartCorStack(0);
    }
    else
    {
        // Non-x86 stacks can always be walked by StackWalk64
        // because of high-quality unwind information.
        CorStack = NULL;
    }
    
    for (i = 0; i < NumFrames; i++)
    {
        Status = S_FALSE;

        if (g_DebugCorStack)
        {
            dprintf("Frame %d\n", i);
        }
        
        StackFrames[i].FrameNumber = i;
    
        if (i > 0 && CorStack)
        {
            if (FAILED(Status = UnwindCorFrame(CorStack,
                                               &Context,
                                               &StackFrames[i],
                                               &VirtualFrame)))
            {
                ErrOut("Managed frame unwind failed, %s\n",
                       FormatStatusCode(Status));
                break;
            }
        }

        if (Status == S_FALSE)
        {
            // SwReadMemory doesn't currently use the thread handle
            // but send in something reasonable in case of future changes.
            if (!StackWalk64(g_Machine->m_ExecTypes[0],
                             OS_HANDLE(g_Process->m_SysHandle),
                             OS_HANDLE(g_Thread->m_Handle),
                             &VirtualFrame,
                             &Context,
                             SwReadMemory,
                             SwFunctionTableAccess,
                             SwGetModuleBase,
                             SwTranslateAddress))
            {
                break;
            }

            StackFrames[i].InstructionOffset  = VirtualFrame.AddrPC.Offset;
            StackFrames[i].ReturnOffset       = VirtualFrame.AddrReturn.Offset;
            StackFrames[i].FrameOffset        = VirtualFrame.AddrFrame.Offset;
            StackFrames[i].StackOffset        = VirtualFrame.AddrStack.Offset;
            StackFrames[i].FuncTableEntry     =
                (ULONG64)VirtualFrame.FuncTableEntry;
            StackFrames[i].Virtual            = VirtualFrame.Virtual;

            // NOTE - we have more reserved space in the DEBUG_STACK_FRAME
            memcpy(StackFrames[i].Reserved, VirtualFrame.Reserved,
                   sizeof(VirtualFrame.Reserved));
            memcpy(StackFrames[i].Params, VirtualFrame.Params,
                   sizeof(VirtualFrame.Params));

            if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_IA64 &&
                IS_KERNEL_TARGET(g_Target))
            {
                if ((VirtualFrame.AddrPC.Offset >= IA64_MM_EPC_VA) &&
                    (VirtualFrame.AddrPC.Offset <
                     (IA64_MM_EPC_VA + IA64_PAGE_SIZE)))
                {
                    VirtualFrame.AddrPC.Offset -=
                        (IA64_MM_EPC_VA -
                         g_Target->m_SystemCallVirtualAddress);
                }

                if ((i != 0) &&
                    (StackFrames[i - 1].InstructionOffset >= IA64_MM_EPC_VA) &&
                    (VirtualFrame.AddrPC.Offset <
                     (IA64_MM_EPC_VA + IA64_PAGE_SIZE)))
                {
                    StackFrames[i - 1].ReturnOffset =
                        VirtualFrame.AddrPC.Offset;
                }
            }
            else if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386)
            {
                if (StackFrames[i].FuncTableEntry) 
                {
                    PFPO_DATA FpoData = (PFPO_DATA)
                        StackFrames[i].FuncTableEntry;
                    if ((FpoData->cbFrame == FRAME_FPO) && X86Ebp &&
                        (!FpoData->fUseBP &&
                         ((SAVE_EBP(&StackFrames[i]) >> 32) != 0xEB)))
                    {
                        // EBP tag, so stack walker doesn't get confused
                        SAVE_EBP(&StackFrames[i]) = X86Ebp + 0xEB00000000;
                    }
                }
            
                X86Ebp = Context.X86Context.Ebp;
            }
        }

        if (Flags)
        {
            if (i == 0)
            {
                PrintStackTraceHeaderLine(Flags);
            }

            if (!SymWarning && NumFrames > 1)
            {
                SymWarning = CheckFrameValidity(StackFrames + i);
            }
            
            PrintStackFrame(StackFrames + i,
                            i > 0 ? (StackFrames + (i - 1)) : NULL,
                            Flags);
        
            if (Flags & DEBUG_STACK_NONVOLATILE_REGISTERS)
            {
                g_Machine->PrintStackNonvolatileRegisters(Flags, 
                                                          StackFrames + i, 
                                                          &Context, i);
            }
        }
    }

    RELEASE(CorStack);
    return i;
}

VOID
DoStackTrace(
    DebugClient*      Client,
    ULONG64           FramePointer,
    ULONG64           StackPointer,
    ULONG64           InstructionPointer,
    ULONG             PointerDefaults,
    ULONG             NumFrames,
    ULONG             TraceFlags
    )
{
    PDEBUG_STACK_FRAME StackFrames;
    ULONG NumFramesToRead;
    DWORD FrameCount;

    if (NumFrames == 0)
    {
        NumFrames = g_DefaultStackTraceDepth;
    }

    if (TraceFlags & RAW_STACK_DUMP)
    {
        DBG_ASSERT(TraceFlags == RAW_STACK_DUMP);
        NumFramesToRead = 1;
    }
    else
    {
        NumFramesToRead = NumFrames;
    }

    StackFrames = (PDEBUG_STACK_FRAME)
        malloc( sizeof(StackFrames[0]) * NumFramesToRead );
    if (!StackFrames)
    {
        ErrOut( "could not allocate memory for stack trace\n" );
        return;
    }

    if (g_Machine->m_Ptr64 &&
        (TraceFlags & DEBUG_STACK_ARGUMENTS) &&
        !(TraceFlags & DEBUG_STACK_FUNCTION_INFO))
    {
        TraceFlags |= DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY;
    }

    FrameCount = StackTrace(Client,
                            FramePointer,
                            StackPointer,
                            InstructionPointer,
                            PointerDefaults,
                            StackFrames,
                            NumFramesToRead,
                            0,
                            TraceFlags,
                            FALSE);

    if (FrameCount == 0)
    {
        ErrOut( "could not fetch any stack frames\n" );
        free(StackFrames);
        return;
    }

    if (TraceFlags & RAW_STACK_DUMP)
    {
        // Starting with the frame pointer, dump NumFrames DWORD's
        // and the symbol if possible.

        ADDR StartAddr;
        ADDRFLAT(&StartAddr, StackFrames[0].FrameOffset);

        DumpDwordMemory(&StartAddr, NumFrames, TRUE);
    }

    free(StackFrames);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\symbols.h ===
//----------------------------------------------------------------------------
//
// Symbol-handling routines.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _SYMBOLS_H_
#define _SYMBOLS_H_

typedef enum _DEBUG_SCOPE_STATE
{
    ScopeDefault,
    ScopeDefaultLazy,
    ScopeFromContext,
} DEBUG_SCOPE_STATE;

typedef struct _DEBUG_SCOPE
{
    ProcessInfo* Process;
    DEBUG_SCOPE_STATE State;
    DEBUG_STACK_FRAME Frame;
    CROSS_PLATFORM_CONTEXT Context;
    ULONG ContextState;
    FPO_DATA CachedFpo;
    BOOL CheckedForThis;
    TypedData ThisData;
} DEBUG_SCOPE, *PDEBUG_SCOPE;

struct SYMBOL_INFO_AND_NAME
{
    ULONG64 Raw[(sizeof(SYMBOL_INFO) + MAX_SYMBOL_LEN + sizeof(ULONG64) - 1) /
                sizeof(ULONG64)];

    PSYMBOL_INFO Init(void)
    {
        PSYMBOL_INFO Info = (PSYMBOL_INFO)*this;
        
        ZeroMemory(Info, sizeof(*Info));
        Info->SizeOfStruct = sizeof(*Info);
        Info->MaxNameLen = MAX_SYMBOL_LEN;
        return Info;
    }

    operator PSYMBOL_INFO(void)
    {
        return (PSYMBOL_INFO)Raw;
    }
    PSYMBOL_INFO operator->(void)
    {
        return (PSYMBOL_INFO)Raw;
    }
    SYMBOL_INFO_AND_NAME(void)
    {
        Init();
    }
};

#define MatchPattern(Str, Pat) \
    SymMatchString(Str, Pat, FALSE)

extern PCSTR g_CallConv[];

extern DEBUG_STACK_FRAME g_LastRegFrame;

// The scope buffer is only exposed so that it
// can be looked at without requiring a function call.
// Users of scope information should go through the
// scope abstraction functions.
extern DEBUG_SCOPE g_ScopeBuffer;

extern LPSTR g_SymbolSearchPath;
extern LPSTR g_ExecutableImageSearchPath;

extern ULONG g_SymOptions;
extern PIMAGEHLP_SYMBOL64 g_Sym;
extern SYMBOL_INFO_AND_NAME g_TmpSymInfo;

inline PSTR
ModInfoSymFile(PIMAGEHLP_MODULE64 ModInfo)
{
    return ModInfo->LoadedPdbName[0] ? ModInfo->LoadedPdbName :
        (ModInfo->LoadedImageName[0] ? ModInfo->LoadedImageName :
         ModInfo->ImageName);
}

void RefreshAllModules(BOOL EnsureLines);
HRESULT SetSymOptions(ULONG Options);

void
CreateModuleNameFromPath(
    LPSTR szImagePath,
    LPSTR szModuleName
    );

void
ListNearSymbols(
    ULONG64 addrStart
    );

BOOL FormatSymbolName(ImageInfo* Image,
                      ULONG64 Offset,
                      PCSTR Name,
                      PULONG64 Displacement,
                      PSTR Buffer,
                      ULONG BufferLen);
BOOL GetSymbolInfo(ULONG64 Offset,
                   PSTR Buffer,
                   ULONG BufferLen,
                   PSYMBOL_INFO SymInfo,
                   PULONG64 Displacement);
BOOL GetNearSymbol(ULONG64 Offset,
                   PSTR Buffer,
                   ULONG BufferLen,
                   PULONG64 Displacement,
                   LONG Delta);
BOOL GetLineFromAddr(ProcessInfo* Process,
                     ULONG64 Offset,
                     PIMAGEHLP_LINE64 Line,
                     PULONG Displacement);

#define GetSymbol(Offset, Buffer, BufferLen, Displacement) \
    GetSymbolInfo(Offset, Buffer, BufferLen, NULL, Displacement)

void OutputSymbolAndInfo(ULONG64 Addr);

BOOL ValidatePathComponent(PCSTR Part);
void SetSymbolSearchPath(ProcessInfo* Process);
void DeferSymbolLoad(ImageInfo*);
void LoadSymbols(ImageInfo*);
void UnloadSymbols(ImageInfo*);

BOOL IgnoreEnumeratedSymbol(ProcessInfo* Process,
                            PSTR MatchString,
                            MachineInfo* Machine,
                            PSYMBOL_INFO SymInfo);
BOOL ForceSymbolCodeAddress(ProcessInfo* Process,
                            PSYMBOL_INFO Symbol, MachineInfo* Machine);

PCSTR
PrependPrefixToSymbol(char   PrefixedString[],
                      PCSTR  pString,
                      PCSTR *RegString);

BOOL GetOffsetFromBreakpoint(PCSTR String, PULONG64 Offset);

ULONG
GetOffsetFromSym(ProcessInfo* Process,
                 PCSTR String,
                 PULONG64 Offset,
                 ImageInfo** Image);

void
GetAdjacentSymOffsets(ULONG64 AddrStart,
                      PULONG64 PrevOffset,
                      PULONG64 NextOffset);

void
GetCurrentMemoryOffsets(
    PULONG64 MemoryLow,
    PULONG64 MemoryHigh
    );

typedef enum _DMT_FLAGS
{
    DMT_SYM_IMAGE_FILE_NAME = 0x0000,
    DMT_ONLY_LOADED_SYMBOLS = 0x0001,
    DMT_ONLY_USER_SYMBOLS   = 0x0002,
    DMT_ONLY_KERNEL_SYMBOLS = 0x0004,
    DMT_VERBOSE             = 0x0008,
    DMT_SYM_FILE_NAME       = 0x0010,
    DMT_MAPPED_IMAGE_NAME   = 0x0020,
    DMT_IMAGE_PATH_NAME     = 0x0040,
    DMT_IMAGE_TIMESTAMP     = 0x0080,
    DMT_NO_SYMBOL_OUTPUT    = 0x0100,
} DMT_FLAGS;

#define DMT_STANDARD   DMT_SYM_FILE_NAME
#define DMT_NAME_FLAGS \
    (DMT_SYM_IMAGE_FILE_NAME | DMT_SYM_FILE_NAME | DMT_MAPPED_IMAGE_NAME | \
     DMT_IMAGE_PATH_NAME)

enum
{
    DMT_NAME_SYM_IMAGE,
    DMT_NAME_SYM_FILE,
    DMT_NAME_MAPPED_IMAGE,
    DMT_NAME_IMAGE_PATH,
    DMT_NAME_COUNT
};

void
DumpModuleTable(
    ULONG DMT_Flags,
    PSTR Pattern
    );

void ParseDumpModuleTable(void);
void ParseExamine(void);

BOOL
SymbolCallbackFunction(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    );

BOOL
TranslateAddress(
    IN ULONG64      ModBase,
    IN ULONG        Flags,
    IN ULONG        RegId,
    IN OUT PULONG64 Address,
    OUT PULONG64    Value
    );

BOOL SetCurrentScope(IN PDEBUG_STACK_FRAME ScopeFrame,
                     IN OPTIONAL PVOID ScopeContext,
                     IN ULONG ScopeContextSize);
BOOL ResetCurrentScope(void);
BOOL ResetCurrentScopeLazy(void);
ULONG GetCurrentScopeThisData(TypedData* Data);

inline PDEBUG_SCOPE
GetCurrentScope(void)
{
    if (g_ScopeBuffer.State == ScopeDefaultLazy)
    {
        ResetCurrentScope();
    }

    return &g_ScopeBuffer;
}
inline PCROSS_PLATFORM_CONTEXT
GetCurrentScopeContext(void)
{
    if (g_ScopeBuffer.State == ScopeFromContext)
    {
        return &g_ScopeBuffer.Context;
    }
    else
    {
        return NULL;
    }
}
inline PCROSS_PLATFORM_CONTEXT
GetScopeOrMachineContext(void)
{
    if (g_ScopeBuffer.State == ScopeFromContext)
    {
        return &g_ScopeBuffer.Context;
    }
    else
    {
        return &g_Machine->m_Context;
    }
}

// Force lazy scope to be updated so that actual
// scope data is available.
#define RequireCurrentScope() \
    GetCurrentScope()

inline void
PushScope(PDEBUG_SCOPE Buffer)
{
    *Buffer = g_ScopeBuffer;
}
inline void
PopScope(PDEBUG_SCOPE Buffer)
{
    g_ScopeBuffer = *Buffer;
}

#define LUM_OUTPUT            0x0001
#define LUM_OUTPUT_VERBOSE    0x0002
#define LUM_OUTPUT_TERSE      0x0004
#define LUM_OUTPUT_IMAGE_INFO 0x0008

void ListUnloadedModules(ULONG Flags, PSTR Pattern);

enum
{
    FSC_NONE,
    FSC_FOUND,
};

ULONG IsInFastSyscall(ULONG64 Addr, PULONG64 Base);

BOOL ShowFunctionParameters(PDEBUG_STACK_FRAME StackFrame);

#endif // #ifndef _SYMBOLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\symbols.cpp ===
//----------------------------------------------------------------------------
//
// Symbol-handling routines.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include <stddef.h>
#include <cvconst.h>

PCSTR g_CallConv[] =
{
    // Ignore near/far distinctions.
    "cdecl", "cdecl", "pascal", "pascal", "fastcall", "fastcall",
    "<skipped>", "stdcall", "stdcall", "syscall", "syscall",
    "thiscall", "MIPS", "generic", "Alpha", "PPC", "SuperH 4",
    "ARM", "AM33", "TriCore", "SuperH 5", "M32R",
};

typedef struct _OUTPUT_SYMBOL_CALLBACK
{
    PSTR Prefix;
    ULONG Verbose:1;
    ULONG ShowAddress:1;
} OUTPUT_SYMBOL_CALLBACK, *POUTPUT_SYMBOL_CALLBACK;

LPSTR g_SymbolSearchPath;
LPSTR g_ExecutableImageSearchPath;

// Symbol options that require symbol reloading to take effect.
#define RELOAD_SYM_OPTIONS \
    (SYMOPT_UNDNAME | SYMOPT_NO_CPP | SYMOPT_DEFERRED_LOADS | \
     SYMOPT_LOAD_LINES | SYMOPT_IGNORE_CVREC | SYMOPT_LOAD_ANYTHING | \
     SYMOPT_EXACT_SYMBOLS | SYMOPT_ALLOW_ABSOLUTE_SYMBOLS | \
     SYMOPT_IGNORE_NT_SYMPATH | SYMOPT_INCLUDE_32BIT_MODULES | \
     SYMOPT_PUBLICS_ONLY | SYMOPT_NO_PUBLICS | SYMOPT_AUTO_PUBLICS |\
     SYMOPT_NO_IMAGE_SEARCH)

ULONG   g_SymOptions = SYMOPT_CASE_INSENSITIVE | SYMOPT_UNDNAME |
                       SYMOPT_OMAP_FIND_NEAREST | SYMOPT_DEFERRED_LOADS |
                       SYMOPT_AUTO_PUBLICS | SYMOPT_NO_IMAGE_SEARCH |
                       SYMOPT_FAIL_CRITICAL_ERRORS;

#define SYM_BUFFER_SIZE (sizeof(IMAGEHLP_SYMBOL64) + MAX_SYMBOL_LEN)

ULONG64 g_SymBuffer[(SYM_BUFFER_SIZE + sizeof(ULONG64) - 1) / sizeof(ULONG64)];
PIMAGEHLP_SYMBOL64 g_Sym = (PIMAGEHLP_SYMBOL64) g_SymBuffer;

SYMBOL_INFO_AND_NAME g_TmpSymInfo;

PSTR g_DmtNameDescs[DMT_NAME_COUNT] =
{
    "Loaded symbol image file", "Symbol file", "Mapped memory image file",
    "Image path",
};

DEBUG_SCOPE g_ScopeBuffer;

void
RefreshAllModules(BOOL EnsureLines)
{
    TargetInfo* Target;
    ProcessInfo* Process;

    ForAllLayersToProcess()
    {
        ImageInfo* Image;

        for (Image = Process->m_ImageHead; Image; Image = Image->m_Next)
        {
            if (EnsureLines)
            {
                IMAGEHLP_MODULE64 ModInfo;

                ModInfo.SizeOfStruct = sizeof(ModInfo);
                if (SymGetModuleInfo64(g_Process->m_SymHandle,
                                       Image->m_BaseOfImage, &ModInfo) &&
                    ModInfo.LineNumbers)
                {
                    // Line number information is already loaded,
                    // so there's no need to reload this image.
                    continue;
                }
            }

            Image->ReloadSymbols();
        }
    }
}

HRESULT
SetSymOptions(ULONG Options)
{
    ULONG OldOptions = g_SymOptions;

    //
    // If we're enabling untrusted user mode we can't
    // already be in a dangerous state.
    //

    if ((Options & SYMOPT_SECURE) &&
        !(OldOptions & SYMOPT_SECURE))
    {
        ULONG Id;
        char Desc[2 * MAX_PARAM_VALUE];

        // If there are any active targets we
        // can't be sure they're safe.
        // If we have RPC servers there may be ways
        // to attack through those so disallow that.
        if (g_TargetHead ||
            DbgRpcEnumActiveServers(NULL, &Id, Desc, sizeof(Desc)))
        {
            return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        }
    }

    SymSetOptions(Options);
    g_SymOptions = SymGetOptions();
    if (g_SymOptions != Options)
    {
        // dbghelp denied the request to set options.
        return E_INVALIDARG;
    }

    NotifyChangeSymbolState(DEBUG_CSS_SYMBOL_OPTIONS, g_SymOptions, NULL);

    if ((OldOptions ^ g_SymOptions) & RELOAD_SYM_OPTIONS)
    {
        BOOL EnsureLines = FALSE;

        // If the only change was to turn on line loading
        // there's no need to reload modules which already
        // have lines loaded.  This is usually the case for
        // PDBs, so this optimization effectively avoids all
        // PDB reloading when turning on .lines.
        if ((OldOptions & ~SYMOPT_LOAD_LINES) ==
            (g_SymOptions & ~SYMOPT_LOAD_LINES) &&
            (g_SymOptions & SYMOPT_LOAD_LINES))
        {
            EnsureLines = TRUE;
        }

        RefreshAllModules(EnsureLines);
    }

    return S_OK;
}

/*
*    TranslateAddress
*         Flags            Flags returned by dbghelp
*         Address          IN Address returned by dbghelp
*                          OUT Address of symbol
*         Value            Value of the symbol if its in register
*
*/
BOOL
TranslateAddress(
    IN ULONG64      ModBase,
    IN ULONG        Flags,
    IN ULONG        RegId,
    IN OUT PULONG64 Address,
    OUT PULONG64    Value
    )
{
    BOOL Status;
    ContextSave* Push;

    PCROSS_PLATFORM_CONTEXT ScopeContext = GetCurrentScopeContext();
    if (ScopeContext)
    {
        Push = g_Machine->PushContext(ScopeContext);
    }

    if (Flags & SYMFLAG_REGREL)
    {
        ULONG64 RegContent;

        if (RegId || (Value && (RegId = (ULONG)*Value)))
        {
            if (g_Machine->
                GetScopeFrameRegister(RegId, &GetCurrentScope()->Frame,
                                      &RegContent) != S_OK)
            {
                Status = FALSE;
                goto Exit;
            }
        }
        else
        {
            DBG_ASSERT(FALSE);
            Status = FALSE;
            goto Exit;
        }

        *Address = RegContent + ((LONG64) (LONG) (ULONG) *Address);
    }
    else if (Flags & SYMFLAG_REGISTER)
    {
        if (Value)
        {
            if (RegId || (RegId = (ULONG)*Address))
            {
                if (g_Machine->
                    GetScopeFrameRegister(RegId, &GetCurrentScope()->Frame,
                                          Value) != S_OK)
                {
                    Status = FALSE;
                    goto Exit;
                }
            }
            else
            {
                DBG_ASSERT(FALSE);
                Status = FALSE;
                goto Exit;
            }
        }
    }
    else if (Flags & SYMFLAG_FRAMEREL)
    {
        PDEBUG_SCOPE Scope = GetCurrentScope();
        if (Scope->Frame.FrameOffset)
        {
            *Address += Scope->Frame.FrameOffset;

            PFPO_DATA pFpoData = (PFPO_DATA)Scope->Frame.FuncTableEntry;
            if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386 &&
                pFpoData &&
                (pFpoData->cbFrame == FRAME_FPO ||
                 pFpoData->cbFrame == FRAME_TRAP))
            {
                // Compensate for FPO's not having ebp
                *Address += sizeof(DWORD);
            }
        }
        else
        {
            ADDR FP;

            g_Machine->GetFP(&FP);
            FP.flat = (LONG64) FP.flat + *Address;
            *Address = FP.flat;
        }
    }
    else if (Flags & SYMFLAG_TLSREL)
    {
        ULONG64 TlsAddr;

        ImageInfo* Image = g_Process->FindImageByOffset(ModBase, FALSE);
        if (!Image ||
            Image->GetTlsIndex() != S_OK)
        {
            Status = FALSE;
            goto Exit;
        }

        if (g_Process->GetImplicitThreadDataTeb(g_Thread, &TlsAddr) != S_OK ||
            g_Target->ReadPointer(g_Process, g_Machine,
                                  TlsAddr + 11 * (g_Machine->m_Ptr64 ? 8 : 4),
                                  &TlsAddr) != S_OK ||
            g_Target->ReadPointer(g_Process, g_Machine,
                                  TlsAddr + Image->m_TlsIndex *
                                  (g_Machine->m_Ptr64 ? 8 : 4),
                                  &TlsAddr) != S_OK)
        {
            return MEMORY;
        }

        (*Address) += TlsAddr;
    }

    Status = TRUE;

 Exit:
    if (ScopeContext)
    {
        g_Machine->PopContext(Push);
    }
    return Status;
}

void
FillCorSymbolInfo(PSYMBOL_INFO SymInfo)
{
    // XXX drewb - Not clear what to do here.
    // Assumes the SYM_INFO was already zero-filled,
    // so just leave it zeroed.
}

BOOL
FormatSymbolName(ImageInfo* Image,
                 ULONG64 Offset,
                 PCSTR Name,
                 PULONG64 Displacement,
                 PSTR Buffer,
                 ULONG BufferLen)
{
    DBG_ASSERT(BufferLen > 0);

    if (!Image)
    {
        *Buffer = 0;
        *Displacement = Offset;
        return FALSE;
    }

    if (Name)
    {
        if (*Displacement == (ULONG64)-1)
        {
            // In some BBT cases dbghelp can tell that an offset
            // is associated with a particular symbol but it
            // doesn't have a valid offset.  Present the symbol
            // but in a way that makes it clear that it's
            // this special case.
            PrintString(Buffer, BufferLen,
                        "%s!%s <PERF> (%s+0x%I64x)",
                        Image->m_ModuleName, Name,
                        Image->m_ModuleName,
                        (Offset - Image->m_BaseOfImage));
            *Displacement = 0;
        }
        else
        {
            PrintString(Buffer, BufferLen,
                        "%s!%s", Image->m_ModuleName, Name);
        }
    }
    else
    {
        CopyString(Buffer, Image->m_ModuleName, BufferLen);
        *Displacement = Offset - Image->m_BaseOfImage;
    }

    return TRUE;
}

BOOL
GetSymbolInfo(ULONG64 Offset,
              PCHAR Buffer,
              ULONG BufferLen,
              PSYMBOL_INFO SymInfo,
              PULONG64 Displacement)
{
    ImageInfo* Image;
    PCSTR Name = NULL;
    PSYMBOL_INFO TmpInfo = g_TmpSymInfo.Init();

    if ((Image = g_Process->FindImageByOffset(Offset, TRUE)) &&
        !Image->m_CorImage)
    {
        if (SymFromAddr(g_Process->m_SymHandle, Offset,
                        Displacement, TmpInfo))
        {
            Name = TmpInfo->Name;
        }
    }
    else if (g_Process->m_CorImage)
    {
        ULONG64 IlModBase;
        ULONG32 MethodToken;
        ULONG32 MethodOffs;

        // The offset is not in any known module.
        // The managed runtime is loaded in this process,
        // so possibly the offset is in some JIT code.
        // See if the runtime knows about it.
        if (g_Process->
            ConvertNativeToIlOffset(Offset, &IlModBase,
                                    &MethodToken, &MethodOffs) == S_OK &&
            (Image = g_Process->FindImageByOffset(IlModBase, TRUE)) &&
            g_Process->
            GetCorSymbol(Offset, TmpInfo->Name, TmpInfo->MaxNameLen,
                         Displacement) == S_OK)
        {
            Name = TmpInfo->Name;
            FillCorSymbolInfo(TmpInfo);
        }
    }

    if (SymInfo)
    {
        memcpy(SymInfo, TmpInfo, FIELD_OFFSET(SYMBOL_INFO, MaxNameLen));
        Buffer = SymInfo->Name;
        BufferLen = SymInfo->MaxNameLen;
    }

    return FormatSymbolName(Image, Offset, Name, Displacement,
                            Buffer, BufferLen);
}

BOOL
GetNearSymbol(ULONG64 Offset,
              PSTR Buffer,
              ULONG BufferLen,
              PULONG64 Displacement,
              LONG Delta)
{
    ImageInfo* Image;

    if (Delta == 0)
    {
        return GetSymbol(Offset, Buffer, BufferLen, Displacement);
    }

    if (!(Image = g_Process->FindImageByOffset(Offset, TRUE)) ||
        !SymGetSymFromAddr64(g_Process->m_SymHandle, Offset,
                             Displacement, g_Sym))
    {
        return FALSE;
    }

    if (Delta < 0)
    {
        while (Delta++ < 0)
        {
            if (!SymGetSymPrev(g_Process->m_SymHandle, g_Sym))
            {
                return FALSE;
            }
        }

        if (Displacement != NULL)
        {
            *Displacement = Offset - g_Sym->Address;
        }
    }
    else if (Delta > 0)
    {
        while (Delta-- > 0)
        {
            if (!SymGetSymNext(g_Process->m_SymHandle, g_Sym))
            {
                return FALSE;
            }
        }

        if (Displacement != NULL)
        {
            *Displacement = g_Sym->Address - Offset;
        }
    }

    PrintString(Buffer, BufferLen,
                "%s!%s", Image->m_ModuleName, g_Sym->Name);
    return TRUE;
}

BOOL
GetLineFromAddr(ProcessInfo* Process,
                ULONG64 Offset,
                PIMAGEHLP_LINE64 Line,
                PULONG Displacement)
{
    ImageInfo* Image;

    Line->SizeOfStruct = sizeof(*Line);

    if (!(Image = Process->FindImageByOffset(Offset, FALSE)) ||
        Image->m_CorImage)
    {
        ULONG32 MethodToken;
        ULONG32 MethodOffs;
        SYMBOL_INFO SymInfo = {0};

        // The offset is not in any known module.
        // The managed runtime is loaded in this process,
        // so possibly the offset is in some JIT code.
        // See if the runtime knows about it.
        if (Process->
            ConvertNativeToIlOffset(Offset, &Offset,
                                    &MethodToken, &MethodOffs) != S_OK)
        {
            return FALSE;
        }

        // Need to look up the fake method RVA by
        // the method token, then add the method offset
        // to that and search by that offset for the line.
        if (!SymFromToken(Process->m_SymHandle, Offset, MethodToken, &SymInfo))
        {
            return FALSE;
        }

        Offset = SymInfo.Address + MethodOffs;
    }

    return SymGetLineFromAddr64(Process->m_SymHandle, Offset,
                                Displacement, Line);
}

void
OutputSymbolAndInfo(ULONG64 Addr)
{
    SYMBOL_INFO_AND_NAME SymInfo;
    ULONG64 Disp;

    if (GetSymbolInfo(Addr, NULL, 0, SymInfo, &Disp))
    {
        dprintf("%s", SymInfo->Name);
        ShowSymbolInfo(SymInfo);
    }
}

#define IMAGE_IS_PATTERN ((ImageInfo*)-1)

ImageInfo*
ParseModuleName(PBOOL ModSpecified)
{
    PSTR    CmdSaved = g_CurCmd;
    CHAR    Name[MAX_MODULE];
    PSTR    Dst = Name;
    CHAR    ch;
    BOOL    HasWild = FALSE;

    //  first, parse out a possible module name, either a '*' or
    //      a string of 'A'-'Z', 'a'-'z', '0'-'9', '_', '~' (or null)

    ch = PeekChar();
    g_CurCmd++;

    while ((ch >= 'A' && ch <= 'Z') ||
           (ch >= 'a' && ch <= 'z') ||
           (ch >= '0' && ch <= '9') ||
           ch == '_' || ch == '~' || ch == '*' || ch == '?')
    {
        if (ch == '*' || ch == '?')
        {
            HasWild = TRUE;
        }

        *Dst++ = ch;
        ch = *g_CurCmd++;
    }
    *Dst = '\0';
    g_CurCmd--;

    //  if no '!' after name and white space, then no module specified
    //      restore text pointer and treat as null module (PC current)

    if (PeekChar() == '!')
    {
        g_CurCmd++;
    }
    else
    {
        g_CurCmd = CmdSaved;
        Name[0] = '\0';
    }

    //  Name either has: '*' for all modules,
    //                   '\0' for current module,
    //                   nonnull string for module name.
    *ModSpecified = Name[0] != 0;
    if (HasWild)
    {
        return IMAGE_IS_PATTERN;
    }
    else if (Name[0])
    {
        return g_Process->FindImageByName(Name, 0, INAME_MODULE, TRUE);
    }
    else
    {
        return NULL;
    }
}

BOOL CALLBACK
OutputSymbolInfoCallback(
    PSYMBOL_INFO    SymInfo,
    ULONG           Size,
    PVOID           Arg
    )
{
    POUTPUT_SYMBOL_CALLBACK OutSym = (POUTPUT_SYMBOL_CALLBACK)Arg;
    ULONG64 Address = SymInfo->Address;
    ULONG64 Value = 0;
    ImageInfo* Image;

    if (OutSym->Prefix)
    {
        dprintf("%s", OutSym->Prefix);
    }

    if (SymInfo->Flags & (SYMFLAG_REGISTER |
                          SYMFLAG_REGREL |
                          SYMFLAG_FRAMEREL |
                          SYMFLAG_TLSREL))
    {
        TranslateAddress(SymInfo->ModBase, SymInfo->Flags,
                         g_Machine->
                         CvRegToMachine((CV_HREG_e)SymInfo->Register),
                         &Address, &Value);
    }

    if (OutSym->ShowAddress)
    {
        dprintf("%s  ", FormatAddr64(Address));
    }

    Image = g_Process->FindImageByOffset(SymInfo->ModBase, TRUE);
    if (Image && ((SymInfo->Flags & SYMFLAG_LOCAL) == 0))
    {
        dprintf("%s!%s", Image->m_ModuleName, SymInfo->Name);
    }
    else
    {
        dprintf("%s", SymInfo->Name);
    }

    if (OutSym->Verbose)
    {
        dprintf(" ");
        ShowSymbolInfo(SymInfo);
    }

    dprintf("\n");

    return !CheckUserInterrupt();
}

/*** ParseExamine - parse and execute examine command
*
* Purpose:
*       Parse the current command string and examine the symbol
*       table to display the appropriate entries.  The entries
*       are displayed in increasing string order.  This function
*       accepts underscores, alphabetic, and numeric characters
*       to match as well as the special characters '?', '*', '['-']'.
*
* Input:
*       g_CurCmd - pointer to current command string
*
* Output:
*       offset and string name of symbols displayed
*
*************************************************************************/

void
ParseExamine(void)
{
    CHAR    StringBuf[MAX_SYMBOL_LEN];
    UCHAR   ch;
    PSTR    String = StringBuf;
    PSTR    Start;
    PSTR    ModEnd;
    BOOL    ModSpecified;
    ULONG64 Base = 0;
    ImageInfo* Image;
    OUTPUT_SYMBOL_CALLBACK OutSymInfo;

    // Get module pointer from name in command line (<string>!).

    PeekChar();
    Start = g_CurCmd;

    Image = ParseModuleName(&ModSpecified);

    ModEnd = g_CurCmd;
    ch = PeekChar();

    // Special case the command "x <pattern>!" to dump out the module table.
    if (Image == IMAGE_IS_PATTERN &&
        (ch == ';' || ch == '\0'))
    {
        *(ModEnd - 1) = 0;
        _strupr(Start);
        DumpModuleTable(DMT_STANDARD, Start);
        return;
    }

    if (ModSpecified)
    {
        if (Image == NULL)
        {
            // The user specified a module that doesn't exist.
            error(VARDEF);
        }
        else if (Image == IMAGE_IS_PATTERN)
        {
            // The user gave a pattern string for the module
            // so we need to pass it on for dbghelp to scan with.
            memcpy(String, Start, (ModEnd - Start));
            String += ModEnd - Start;
        }
        else
        {
            // A specific image was given and found so
            // confine the search to that one image.
            Base = Image->m_BaseOfImage;
        }
    }

    g_CurCmd++;

    // Condense leading underscores into a "_#"
    // that will match zero or more underscores.  This causes all
    // underscore-prefixed symbols to match the base symbol name
    // when the pattern is prefixed by an underscore.
    if (ch == '_')
    {
        *String++ = '_';
        *String++ = '#';
        do
        {
            ch = *g_CurCmd++;
        } while (ch == '_');
    }

    ch = (UCHAR)toupper(ch);
    while (ch && ch != ';' && ch != ' ')
    {
        *String++ = ch;
        ch = (CHAR)toupper(*g_CurCmd);
        g_CurCmd++;
    }
    *String = '\0';
    g_CurCmd--;

    ZeroMemory(&OutSymInfo, sizeof(OutSymInfo));
    OutSymInfo.Verbose = TRUE;
    OutSymInfo.ShowAddress = TRUE;

    // We nee the scope for all cases since param values are displayed for
    // function in scope
    RequireCurrentScope();

    SymEnumSymbols(g_Process->m_SymHandle,
                   Base,
                   StringBuf,
                   OutputSymbolInfoCallback,
                   &OutSymInfo);
}

void
ListNearSymbols(ULONG64 AddrStart)
{
    ULONG64 Displacement;
    ImageInfo* Image;

    if (g_SrcOptions & SRCOPT_LIST_LINE)
    {
        OutputLineAddr(AddrStart, "%s(%d)%s\n");
    }

    if ((Image = g_Process->FindImageByOffset(AddrStart, TRUE)) &&
        !Image->m_CorImage)
    {
        if (!SymGetSymFromAddr64(g_Process->m_SymHandle, AddrStart,
                                 &Displacement, g_Sym))
        {
            return;
        }

        dprintf("(%s)   %s!%s",
                FormatAddr64(g_Sym->Address),
                Image->m_ModuleName,
                g_Sym->Name);

        if (Displacement)
        {
            dprintf("+0x%s   ", FormatDisp64(Displacement));
        }
        else
        {
            dprintf("   ");
        }

        if (SymGetSymNext64(g_Process->m_SymHandle, g_Sym))
        {
            dprintf("|  (%s)   %s!%s",
                    FormatAddr64(g_Sym->Address),
                    Image->m_ModuleName,
                    g_Sym->Name);
        }
        dprintf("\n");

        if (Displacement == 0)
        {
            OUTPUT_SYMBOL_CALLBACK OutSymInfo;

            dprintf("Exact matches:\n");
            FlushCallbacks();
            ZeroMemory(&OutSymInfo, sizeof(OutSymInfo));
            OutSymInfo.Prefix = "    ";
            OutSymInfo.Verbose = TRUE;
            SymEnumSymbolsForAddr(g_Process->m_SymHandle, AddrStart,
                                  OutputSymbolInfoCallback, &OutSymInfo);
        }
    }
    else
    {
        SYMBOL_INFO_AND_NAME SymInfo;

        // We couldn't find a true symbol but it may be
        // possible to find a managed symbol.
        if (GetSymbolInfo(AddrStart, NULL, 0, SymInfo, &Displacement))
        {
            dprintf("(%s)   %s", FormatAddr64(AddrStart), SymInfo->Name);
            if (Displacement)
            {
                dprintf("+0x%s", FormatDisp64(Displacement));
            }
            dprintf("\n");
        }
    }
}

void
DumpModuleTable(ULONG Flags, PSTR Pattern)
{
    ImageInfo* Image;
    IMAGEHLP_MODULE64 ModInfo;
    ULONG i;

    if (g_Target->m_Machine->m_Ptr64)
    {
        dprintf("start             end                 module name\n");
    }
    else
    {
        dprintf("start    end        module name\n");
    }

    Image = g_Process->m_ImageHead;
    while (Image)
    {
        ULONG PrimaryName;
        PSTR Names[DMT_NAME_COUNT];

        if (Pattern != NULL &&
            !MatchPattern(Image->m_ModuleName, Pattern))
        {
            Image = Image->m_Next;
            continue;
        }

        ModInfo.SizeOfStruct = sizeof(ModInfo);
        if (!SymGetModuleInfo64(g_Process->m_SymHandle,
                                Image->m_BaseOfImage, &ModInfo))
        {
            ModInfo.SymType = SymNone;
        }

        Names[DMT_NAME_SYM_IMAGE] = ModInfo.LoadedImageName;
        Names[DMT_NAME_SYM_FILE] = ModInfoSymFile(&ModInfo);
        Names[DMT_NAME_MAPPED_IMAGE] = Image->m_MappedImagePath;
        Names[DMT_NAME_IMAGE_PATH] = Image->m_ImagePath;

        if (Flags & DMT_SYM_FILE_NAME)
        {
            PrimaryName = DMT_NAME_SYM_FILE;
        }
        else if (Flags & DMT_MAPPED_IMAGE_NAME)
        {
            PrimaryName = DMT_NAME_MAPPED_IMAGE;
        }
        else if (Flags & DMT_IMAGE_PATH_NAME)
        {
            PrimaryName = DMT_NAME_IMAGE_PATH;
        }
        else
        {
            PrimaryName = DMT_NAME_SYM_IMAGE;
        }

        //
        // Skip modules filtered by flags
        //
        if ((Flags & DMT_ONLY_LOADED_SYMBOLS) &&
            (ModInfo.SymType == SymDeferred))
        {
            Image = Image->m_Next;
            continue;
        }

        if (IS_KERNEL_TARGET(g_Target))
        {
            if ((Flags & DMT_ONLY_USER_SYMBOLS) &&
                (Image->m_BaseOfImage >= g_Target->m_SystemRangeStart))
            {
                Image = Image->m_Next;
                continue;
            }

            if ((Flags & DMT_ONLY_KERNEL_SYMBOLS) &&
                (Image->m_BaseOfImage <= g_Target->m_SystemRangeStart))
            {
                Image = Image->m_Next;
                continue;
            }
        }

        dprintf("%s %s   %-8s   ",
                FormatAddr64(Image->m_BaseOfImage),
                FormatAddr64(Image->m_BaseOfImage + Image->m_SizeOfImage),
                Image->m_ModuleName);

        if (Flags & DMT_NO_SYMBOL_OUTPUT)
        {
            goto SkipSymbolOutput;
        }
        if (PrimaryName == DMT_NAME_MAPPED_IMAGE ||
            PrimaryName == DMT_NAME_IMAGE_PATH)
        {
            dprintf("  %s\n",
                    *Names[PrimaryName] ? Names[PrimaryName] : "<none>");
            goto SkipSymbolOutput;
        }

        switch(Image->m_SymState)
        {
        case ISS_MATCHED:
            dprintf( "  " );
            break;
        case ISS_MISMATCHED_SYMBOLS:
            dprintf( "M " );
            break;
        case ISS_UNKNOWN_TIMESTAMP:
            dprintf( "T " );
            break;
        case ISS_UNKNOWN_CHECKSUM:
            dprintf( "C " );
            break;
        case ISS_BAD_CHECKSUM:
            dprintf( "# " );
            break;
        }

        if (ModInfo.SymType == SymDeferred)
        {
            dprintf("(deferred)                 ");
        }
        else if (ModInfo.SymType == SymNone)
        {
            dprintf("(no symbolic information)  ");
        }
        else
        {
            switch(ModInfo.SymType)
            {
            case SymCoff:
                dprintf("(coff symbols)             ");
                break;

            case SymCv:
                dprintf("(codeview symbols)         ");
                break;

            case SymPdb:
                dprintf("(pdb symbols)              ");
                break;

            case SymExport:
                dprintf("(export symbols)           ");
                break;
            }

            dprintf("%s", *Names[PrimaryName] ? Names[PrimaryName] : "<none>");
        }

        dprintf("\n");

    SkipSymbolOutput:
        if (Flags & DMT_VERBOSE)
        {

            for (i = 0; i < DMT_NAME_COUNT; i++)
            {
                if (i != PrimaryName && *Names[i])
                {
                    dprintf("    %s: %s\n", g_DmtNameDescs[i], Names[i]);
                }
            }
        }
        if (Flags & (DMT_VERBOSE | DMT_IMAGE_TIMESTAMP))
        {
            LPSTR TimeDateStr = TimeToStr(Image->m_TimeDateStamp);
            dprintf("    Checksum: %08X  Timestamp: %s (%08X)\n",
                    Image->m_CheckSum, TimeDateStr, Image->m_TimeDateStamp);

        }
        if (Flags & DMT_VERBOSE)
        {
            Image->OutputVersionInformation();
        }

        if (CheckUserInterrupt())
        {
            break;
        }

        Image = Image->m_Next;
    }

    if ((Flags & (DMT_ONLY_LOADED_SYMBOLS | DMT_ONLY_USER_SYMBOLS)) == 0)
    {
        ULONG LumFlags = LUM_OUTPUT;

        LumFlags |= ((Flags & DMT_VERBOSE) ? LUM_OUTPUT_VERBOSE : 0);
        LumFlags |= ((Flags & DMT_IMAGE_TIMESTAMP) ?
                     LUM_OUTPUT_IMAGE_INFO : 0);
        dprintf("\n");
        ListUnloadedModules(LumFlags, Pattern);
    }
}

void
ParseDumpModuleTable(void)
{
    ULONG Flags = DMT_STANDARD;
    char Pattern[MAX_MODULE];
    PSTR Pat = NULL;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }

    g_CurCmd++;

    for (;;)
    {
        // skip white space
        while (isspace(*g_CurCmd))
        {
            g_CurCmd++;
        }

        if (*g_CurCmd == 'f')
        {
            Flags = (Flags & ~DMT_NAME_FLAGS) | DMT_IMAGE_PATH_NAME;
            g_CurCmd++;
        }
        else if (*g_CurCmd == 'i')
        {
            Flags = (Flags & ~DMT_NAME_FLAGS) | DMT_SYM_IMAGE_FILE_NAME;
            g_CurCmd++;
        }
        else if (*g_CurCmd == 'l')
        {
            Flags |= DMT_ONLY_LOADED_SYMBOLS;
            g_CurCmd++;
        }
        else if (*g_CurCmd == 'm')
        {
            g_CurCmd++;
            // skip white space
            while (isspace(*g_CurCmd))
            {
                g_CurCmd++;
            }
            Pat = Pattern;
            while (*g_CurCmd && !isspace(*g_CurCmd))
            {
                if ((Pat - Pattern) < sizeof(Pattern) - 1)
                {
                    *Pat++ = *g_CurCmd;
                }

                g_CurCmd++;
            }
            *Pat = 0;
            Pat = Pattern;
            _strupr(Pat);
        }
        else if (*g_CurCmd == 'p')
        {
            Flags = (Flags & ~DMT_NAME_FLAGS) | DMT_MAPPED_IMAGE_NAME;
            g_CurCmd++;
        }
        else if (*g_CurCmd == 't')
        {
            Flags = (Flags & ~(DMT_NAME_FLAGS)) |
                DMT_NAME_SYM_IMAGE | DMT_IMAGE_TIMESTAMP |
                DMT_NO_SYMBOL_OUTPUT;
            g_CurCmd++;
        }
        else if (*g_CurCmd == 'v')
        {
            Flags |= DMT_VERBOSE;
            g_CurCmd++;
        }
        else if (IS_KERNEL_TARGET(g_Target))
        {
            if (*g_CurCmd == 'u')
            {
                Flags |= DMT_ONLY_USER_SYMBOLS;
                g_CurCmd++;
            }
            else if (*g_CurCmd == 'k')
            {
                Flags |= DMT_ONLY_KERNEL_SYMBOLS;
                g_CurCmd++;
            }
            else
            {
                break;
            }
        }
        else
        {
            break;
        }
    }

    DumpModuleTable(Flags, Pat);
}

void
GetCurrentMemoryOffsets(PULONG64 MemoryLow,
                        PULONG64 MemoryHigh)
{
    // Default value for no source.
    *MemoryLow = (ULONG64)(LONG64)-1;
}

PCSTR
PrependPrefixToSymbol(char   PrefixedString[],
                      PCSTR  pString,
                      PCSTR *RegString)
{
    if ( RegString )
    {
        *RegString = NULL;
    }

    PCSTR bangPtr;
    int   bang = '!';
    PCSTR Tail;

    bangPtr = strchr( pString, bang );
    if ( bangPtr )
    {
        Tail = bangPtr + 1;
    }
    else
    {
        Tail = pString;
    }

    if ( strncmp( Tail, g_Machine->m_SymPrefix, g_Machine->m_SymPrefixLen ) )
    {
        ULONG Loc = (ULONG)(Tail - pString);
        if (Loc > 0)
        {
            memcpy( PrefixedString, pString, Loc );
        }
        memcpy( PrefixedString + Loc, g_Machine->m_SymPrefix,
                g_Machine->m_SymPrefixLen );
        if ( RegString )
        {
            *RegString = &PrefixedString[Loc];
        }
        Loc += g_Machine->m_SymPrefixLen;
        strcpy( &PrefixedString[Loc], Tail );
        return PrefixedString;
    }
    else
    {
        return pString;
    }
}

BOOL
ForceSymbolCodeAddress(ProcessInfo* Process,
                       PSYMBOL_INFO Symbol, MachineInfo* Machine)
{
    ULONG64 Code = Symbol->Address;

    if (Symbol->Flags & SYMFLAG_FORWARDER)
    {
        char Fwd[2 * MAX_PATH];
        ULONG Read;
        PSTR Sep;

        // The address of a forwarder entry points to the
        // string name of the function that things are forwarded
        // to.  Look up that name and try to get the address
        // from it.
        if (g_Target->ReadVirtual(Process, Symbol->Address, Fwd, sizeof(Fwd),
                                  &Read) != S_OK ||
            Read < 2)
        {
            ErrOut("Unable to read forwarder string\n");
            return FALSE;
        }

        Fwd[sizeof(Fwd) - 1] = 0;
        if (!(Sep = strchr(Fwd, '.')))
        {
            ErrOut("Unable to read forwarder string\n");
            return FALSE;
        }

        *Sep = '!';
        if (GetOffsetFromSym(Process, Fwd, &Code, NULL) != 1)
        {
            ErrOut("Unable to get address of forwarder '%s'\n", Fwd);
            return FALSE;
        }
    }
    else if (Machine &&
             Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_IA64 &&
             (Symbol->Flags & SYMFLAG_EXPORT))
    {
        // On IA64 the export entries contain the address
        // of the plabel.  We want the actual code address
        // so resolve the plabel to its code.
        if (!Machine->GetPrefixedSymbolOffset(Process, Symbol->Address,
                                              GETPREF_VERBOSE,
                                              &Code))
        {
            return FALSE;
        }
    }

    Symbol->Address = Code;
    return TRUE;
}

BOOL
GetOffsetFromBreakpoint(PCSTR String, PULONG64 Offset)
{
    ULONG Id;
    Breakpoint* Bp;

    //
    // The string must be of the form "$bp[digits]".
    //

    if (strlen(String) < 4 || _memicmp(String, "$bp", 3) != 0)
    {
        return FALSE;
    }

    String += 3;
    Id = 0;

    while (*String)
    {
        if (*String < '0' || *String > '9')
        {
            return FALSE;
        }

        Id = Id * 10 + (int)(*String - '0');

        String++;
    }

    Bp = GetBreakpointById(NULL, Id);
    if (Bp == NULL ||
        (Bp->m_Flags & DEBUG_BREAKPOINT_DEFERRED))
    {
        return FALSE;
    }

    *Offset = Flat(*Bp->GetAddr());
    return TRUE;
}

BOOL
IgnoreEnumeratedSymbol(ProcessInfo* Process,
                       PSTR MatchString,
                       MachineInfo* Machine,
                       PSYMBOL_INFO SymInfo)
{
    ULONG64 Func;

    //
    // The compiler and linker can generate thunks for
    // a variety of reasons.  For example, a "this" adjustor
    // thunk can be generated to adjust a this pointer before
    // calling into a method to account for differences between
    // derived/container classes and the base/containee classes.
    // Assume that the user doesn't care about thunks as they're
    // automatically emitted.
    //
    if (SymInfo->Tag == SymTagThunk &&
        !_stricmp(MatchString, SymInfo->Name))
    {
        // We hit a thunk for the function we're looking
        // for, just ignore it.
        return TRUE;
    }

    //
    // IA64 plabels are publics with the same name
    // as the function they refer to.  This causes
    // ambiguity problems as we end up with two
    // hits.  The plabel is rarely interesting, though,
    // so just filter them out here so that expressions
    // always evaluate to the function itself.
    //

    if ((Machine->m_ExecTypes[0] != IMAGE_FILE_MACHINE_IA64) ||
        (SymInfo->Scope != SymTagPublicSymbol) ||
        (SymInfo->Flags & SYMFLAG_FUNCTION) ||
        !Machine->GetPrefixedSymbolOffset(Process, SymInfo->Address,
                                          0, &Func))
    {
        return FALSE;
    }

    if (Func == SymInfo->Address)
    {
        // The symbol is probably a global pointing to itself
        return FALSE;
    }

    PSYMBOL_INFO FuncSymInfo;
    PSTR FuncSym;

    __try
    {
        FuncSymInfo = (PSYMBOL_INFO)
            alloca(sizeof(*FuncSymInfo) + MAX_SYMBOL_LEN * 2);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        FuncSymInfo = NULL;
    }

    if (FuncSymInfo == NULL)
    {
        return FALSE;
    }
    FuncSym = FuncSymInfo->Name;

    SYMBOL_INFO LocalSymInfo;

    // We have to save and restore the original data as
    // dbghelp always uses a single buffer to store all
    // symbol information.  The incoming symbol info
    // is going to be wiped out when we look up another symbol.
    LocalSymInfo = *SymInfo;
    strcpy(FuncSym + MAX_SYMBOL_LEN, SymInfo->Name);

    ULONG64 FuncSymDisp;

    ZeroMemory(FuncSymInfo, sizeof(*FuncSymInfo));
    FuncSymInfo->SizeOfStruct = sizeof(*FuncSymInfo);
    FuncSymInfo->MaxNameLen = MAX_SYMBOL_LEN;
    FuncSym[0] = 0;
    if (!SymFromAddr(Process->m_SymHandle, Func, &FuncSymDisp, FuncSymInfo))
    {
        FuncSymDisp = 1;
    }
    else
    {
        // Incremental linking produces intermediate thunks
        // that entry points refer to.  The thunks call on
        // to the real code.  The extra layer of code prevents
        // direct filtering; we have to chain through thunks
        // to see if the final code is the function code.
        while (FuncSymDisp == 0 &&
               FuncSymInfo->Tag == SymTagThunk &&
               strstr(FuncSym, FuncSym + MAX_SYMBOL_LEN) == NULL)
        {
            FuncSym[0] = 0;
            if (!SymFromAddr(Process->m_SymHandle, FuncSymInfo->Value,
                             &FuncSymDisp, FuncSymInfo))
            {
                FuncSymDisp = 1;
                break;
            }
        }
    }

    *SymInfo = LocalSymInfo;
    strcpy(SymInfo->Name, FuncSym + MAX_SYMBOL_LEN);
    return FuncSymDisp == 0 && strstr(FuncSym, SymInfo->Name);
}

struct COUNT_SYMBOL_MATCHES
{
    PSTR MatchString;
    ProcessInfo* Process;
    MachineInfo* Machine;
    SYMBOL_INFO ReturnSymInfo;
    CHAR SymbolNameOverflowBuffer[MAX_SYMBOL_LEN];
    ULONG Matches;
};

BOOL CALLBACK
CountSymbolMatches(
    PSYMBOL_INFO    SymInfo,
    ULONG           Size,
    PVOID           UserContext
    )
{
    COUNT_SYMBOL_MATCHES* Context =
        (COUNT_SYMBOL_MATCHES*)UserContext;

    if (IgnoreEnumeratedSymbol(Context->Process, Context->MatchString,
                               Context->Machine, SymInfo))
    {
        return TRUE;
    }

    if (Context->Matches == 1)
    {
        // We already have one match, check if we got a duplicate.
        if ((SymInfo->Address == Context->ReturnSymInfo.Address) &&
            !strcmp(SymInfo->Name, Context->ReturnSymInfo.Name))
        {
            // Looks like the same symbol, ignore it.
            return TRUE;
        }
    }

    Context->ReturnSymInfo = *SymInfo;
    if (SymInfo->NameLen < MAX_SYMBOL_LEN)
    {
        strcpy(Context->ReturnSymInfo.Name, SymInfo->Name);
    }
    Context->Matches++;

    return TRUE;
}

ULONG
MultiSymFromName(IN  ProcessInfo* Process,
                 IN  LPSTR        Name,
                 IN  ImageInfo*   Image,
                 IN  MachineInfo* Machine,
                 OUT PSYMBOL_INFO Symbol)
{
    ULONG Matches;

    RequireCurrentScope();

    if (!Image)
    {
        if (!SymFromName(Process->m_SymHandle, Name, Symbol))
        {
            return 0;
        }

        Matches = 1;
    }
    else
    {
        COUNT_SYMBOL_MATCHES Context;
        ULONG MaxName = Symbol->MaxNameLen;
        PSTR Bang;

        Bang = strchr(Name, '!');
        if (Bang &&
            !_strnicmp(Image->m_ModuleName, Name,
                       Bang - Name))
        {
            Context.MatchString = Bang + 1;
        }
        else
        {
            Context.MatchString = Name;
        }
        Context.Process = Process;
        Context.Machine = Machine;
        Context.ReturnSymInfo = *Symbol;
        if (Symbol->NameLen < MAX_SYMBOL_LEN)
        {
            strcpy(Context.ReturnSymInfo.Name, Symbol->Name);
        }
        Context.Matches = 0;
        SymEnumSymbols(Process->m_SymHandle, Image->m_BaseOfImage, Name,
                       CountSymbolMatches, &Context);
        *Symbol = Context.ReturnSymInfo;
        Symbol->MaxNameLen = MaxName;
        if (Symbol->MaxNameLen > Context.ReturnSymInfo.NameLen)
        {
            strcpy(Symbol->Name, Context.ReturnSymInfo.Name);
        }

        Matches = Context.Matches;
    }

    if (Matches == 1 &&
        !ForceSymbolCodeAddress(Process, Symbol, Machine))
    {
        return 0;
    }

    return Matches;
}

ULONG
GetOffsetFromSym(ProcessInfo* Process,
                 PCSTR String,
                 PULONG64 Offset,
                 ImageInfo** Image)
{
    CHAR ModifiedString[MAX_SYMBOL_LEN + 64];
    CHAR Suffix[2];
    SYMBOL_INFO SymInfo = {0};
    ULONG Count;

    if (Image != NULL)
    {
        *Image = NULL;
    }

    if (strlen(String) >= MAX_SYMBOL_LEN)
    {
        return 0;
    }

    //
    // We can't do anything without a current process.
    //

    if (Process == NULL)
    {
        return 0;
    }

    if ( strlen(String) == 0 )
    {
        return 0;
    }

    if (Process->GetOffsetFromMod(String, Offset) ||
        GetOffsetFromBreakpoint(String, Offset))
    {
        return 1;
    }

    //
    // If a module name was given look up the module
    // and determine the processor type so that the
    // appropriate machine is used for the following
    // machine-specific operations.
    //

    ImageInfo* StrImage;
    PCSTR ModSep = strchr(String, '!');
    if (ModSep != NULL)
    {
        StrImage = Process->
            FindImageByName(String, (ULONG)(ModSep - String),
                            INAME_MODULE, TRUE);
        if (Image != NULL)
        {
            *Image = StrImage;
        }
    }
    else
    {
        StrImage = NULL;
    }

    MachineInfo* Machine = Process->m_Target->m_EffMachine;

    if (StrImage != NULL)
    {
        Machine = MachineTypeInfo(Process->m_Target,
                                  StrImage->GetMachineType());
        if (Machine == NULL)
        {
            Machine = Process->m_Target->m_EffMachine;
        }
    }

    if ( g_PrefixSymbols && Machine->m_SymPrefix != NULL )
    {
        PCSTR PreString;
        PCSTR RegString;

        PreString = PrependPrefixToSymbol( ModifiedString, String,
                                           &RegString );
        if ( Count =
             MultiSymFromName( Process, (PSTR)PreString,
                               StrImage, Machine, &SymInfo ) )
        {
            *Offset = SymInfo.Address;
            goto GotOffsetSuccess;
        }
        if ( (PreString != String) &&
             (Count =
              MultiSymFromName( Process, (PSTR)String,
                                StrImage, Machine, &SymInfo ) ) )
        {
            // Ambiguous plabels shouldn't be further resolved,
            // so just return the information for the plabel.
            if (Count > 1)
            {
                *Offset = SymInfo.Address;
                goto GotOffsetSuccess;
            }

            if (!Machine->GetPrefixedSymbolOffset(Process, SymInfo.Address,
                                                  GETPREF_VERBOSE,
                                                  Offset))
            {
                // This symbol doesn't appear to actually
                // be a plabel so just use the symbol address.
                *Offset = SymInfo.Address;
            }
            goto GotOffsetSuccess;
        }
    }
    else if (Count =
             MultiSymFromName( Process, (PSTR)String,
                               StrImage, Machine, &SymInfo ))
    {
        *Offset = SymInfo.Address;
        goto GotOffsetSuccess;
    }

    if (g_SymbolSuffix != 'n')
    {
        strcpy( ModifiedString, String );
        Suffix[0] = g_SymbolSuffix;
        Suffix[1] = '\0';
        strcat( ModifiedString, Suffix );
        if (Count =
            MultiSymFromName( Process, ModifiedString,
                              StrImage, Machine, &SymInfo ))
        {
            *Offset = SymInfo.Address;
            goto GotOffsetSuccess;
        }
    }

    return 0;

GotOffsetSuccess:
    TranslateAddress(SymInfo.ModBase, SymInfo.Flags,
                     Machine->CvRegToMachine((CV_HREG_e)SymInfo.Register),
                     Offset, &SymInfo.Value);
    if (SymInfo.Flags & SYMFLAG_REGISTER)
    {
        *Offset = SymInfo.Value;
    }
    return Count;
}

void
CreateModuleNameFromPath(LPSTR ImagePath, LPSTR ModuleName)
{
    PSTR Scan;

    CopyString( ModuleName, PathTail(ImagePath), MAX_MODULE );
    Scan = strrchr( ModuleName, '.' );
    if (Scan != NULL)
    {
        *Scan = '\0';
    }
}

void
GetAdjacentSymOffsets(ULONG64 AddrStart,
                      PULONG64 PrevOffset,
                      PULONG64 NextOffset)
{
    DWORD64 Displacement;

    //
    // assume failure
    //
    *PrevOffset = 0;
    *NextOffset = (ULONG64) -1;

    //
    // get the symbol for the initial address
    //
    if (!SymGetSymFromAddr64(g_Process->m_SymHandle, AddrStart, &Displacement,
                             g_Sym))
    {
        return;
    }

    *PrevOffset = g_Sym->Address;

    if (SymGetSymNext64(g_Process->m_SymHandle, g_Sym))
    {
        *NextOffset = g_Sym->Address;
    }
}

BOOL
SymbolCallbackFunction(HANDLE  ProcessSymHandle,
                       ULONG   ActionCode,
                       ULONG64 CallbackData,
                       ULONG64 UserContext)
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 DefLoad;
    PIMAGEHLP_CBA_READ_MEMORY        ReadMem;
    PIMAGEHLP_CBA_EVENT              Event;
    ImageInfo*                       Image;
    ULONG                            i;
    ULONG                            OldSymOptions;
    PVOID                            Mapping;
    ProcessInfo*                     Process =
        (ProcessInfo*)(ULONG_PTR)UserContext;

    DefLoad = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD64) CallbackData;

    switch(ActionCode)
    {
    case CBA_DEBUG_INFO:
        DBG_ASSERT(CallbackData && *(LPSTR)CallbackData);
        CompletePartialLine(DEBUG_OUTPUT_SYMBOLS);
        MaskOut(DEBUG_OUTPUT_SYMBOLS, "%s", (LPSTR)CallbackData);
        return TRUE;

    case CBA_EVENT:
        Event = (PIMAGEHLP_CBA_EVENT)CallbackData;
        DBG_ASSERT(Event);
        if (Event->desc && *Event->desc)
        {
            dprintf("%s", Event->desc);
            if (Event->severity >= sevProblem)
            {
                FlushCallbacks();
            }
        }
        return TRUE;

    case CBA_DEFERRED_SYMBOL_LOAD_CANCEL:
        return PollUserInterrupt(TRUE);

    case CBA_DEFERRED_SYMBOL_LOAD_START:
        Image = Process->FindImageByOffset(DefLoad->BaseOfImage, FALSE);
        if (Image)
        {
            // Try to load the image memory right away in this
            // case to catch incomplete-information errors.
            if (!Image->DemandLoadImageMemory(TRUE, TRUE))
            {
                return FALSE;
            }

            // Update dbghelp with the latest image file handle
            // as loading image memory may have given us one.
            DefLoad->hFile = Image->m_File;

            VerbOut("Loading symbols for %s %16s ->   ",
                    FormatAddr64(DefLoad->BaseOfImage),
                    DefLoad->FileName);
            return TRUE;
        }
        break;

    case CBA_DEFERRED_SYMBOL_LOAD_PARTIAL:
        //
        // dbghelp wasn't able to get complete
        // information about an image and so had
        // to do some guessing when loading symbols.
        // Returning FALSE means do the best that
        // dbghelp can.  Returning TRUE means try
        // again with any updated data we provide here.
        // We use this as an opportunity to go out
        // and attempt to load image files to get
        // image information that may not be present in
        // the debuggee and thus we are creating information
        // that's not really present.  Hopefully we'll find
        // the right image and not come up with incorrect information.
        //

        // Don't do this if the user has asked for exact
        // symbols as the in-memory image may not exactly
        // match what's on disk even if the headers are similar.
        if (g_SymOptions & SYMOPT_EXACT_SYMBOLS)
        {
            return FALSE;
        }

        Image = Process->FindImageByOffset(DefLoad->BaseOfImage, FALSE);
        if (!Image ||
            Image->m_File ||
            Image->m_MapAlreadyFailed ||
            !(Mapping =
              FindImageFile(Process, Image->m_ImagePath, Image->m_SizeOfImage,
                            Image->m_CheckSum, Image->m_TimeDateStamp,
                            &Image->m_File, Image->m_MappedImagePath)))
        {
            return FALSE;
        }

        // This file handle is only good as long as the
        // image information doesn't change.
        Image->m_FileIsDemandMapped = TRUE;

        // We don't need the actual file mapping, just
        // the file handle.
        UnmapViewOfFile(Mapping);

        // Update dbghelp with the latest image file handle
        // as loading the image has given us one.
        DefLoad->Reparse = TRUE;
        DefLoad->hFile = Image->m_File;

        if (g_SymOptions & SYMOPT_DEBUG)
        {
            CompletePartialLine(DEBUG_OUTPUT_SYMBOLS);
            MaskOut(DEBUG_OUTPUT_SYMBOLS,
                    "DBGENG:  Partial symbol load found image %s.\n",
                    Image->m_MappedImagePath);
        }

        return TRUE;

    case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
        if (IS_KERNEL_TARGET(Process->m_Target) &&
            DefLoad->SizeOfStruct >=
            FIELD_OFFSET(IMAGEHLP_DEFERRED_SYMBOL_LOAD, Reparse))
        {
            i = 0;

            if (strncmp(DefLoad->FileName, "dump_", sizeof("dump_")-1) == 0)
            {
                i = sizeof("dump_")-1;
            }

            if (strncmp(DefLoad->FileName, "hiber_", sizeof("hiber_")-1) == 0)
            {
                i = sizeof("hiber_")-1;
            }

            if (i)
            {
                if (_stricmp (DefLoad->FileName+i, "scsiport.sys") == 0)
                {
                    strcpy (DefLoad->FileName, "diskdump.sys");
                }
                else
                {
                    strcpy(DefLoad->FileName, DefLoad->FileName+i);
                }

                DefLoad->Reparse = TRUE;
                return TRUE;
            }
        }

        if (DefLoad->FileName && *DefLoad->FileName)
        {
            VerbOut("*** Error: could not load symbols for %s\n",
                    DefLoad->FileName);
        }
        else
        {
            VerbOut("*** Error: could not load symbols [MODNAME UNKNOWN]\n");
        }
        break;

    case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:
        Image = Process->FindImageByOffset(DefLoad->BaseOfImage, FALSE);
        if (!Image)
        {
            VerbOut("\n");
            break;
        }

        // Do not load unqualified symbols in this callback since this
        // could result in stack overflow.
        OldSymOptions = SymGetOptions();
        SymSetOptions(OldSymOptions | SYMOPT_NO_UNQUALIFIED_LOADS);

        VerbOut("%s\n", DefLoad->FileName);
        Image->ValidateSymbolLoad(DefLoad);
        NotifyChangeSymbolState(DEBUG_CSS_LOADS,
                                DefLoad->BaseOfImage, Process);

        SymSetOptions(OldSymOptions);
        return TRUE;

    case CBA_SYMBOLS_UNLOADED:
        VerbOut("Symbols unloaded for %s %s\n",
                FormatAddr64(DefLoad->BaseOfImage),
                DefLoad->FileName);
        break;

    case CBA_READ_MEMORY:
        ReadMem = (PIMAGEHLP_CBA_READ_MEMORY)CallbackData;
        return Process->m_Target->
            ReadVirtual(Process,
                        ReadMem->addr,
                        ReadMem->buf,
                        ReadMem->bytes,
                        ReadMem->bytesread) == S_OK;

    case CBA_SET_OPTIONS:
        // Symbol options are set through the interface
        // so the debugger generally knows about them
        // already.  The only flags that we want to check
        // here are internal flags that can be changed through
        // !sym or other dbghelp extension commands.
        // There is no need to notify here for internal flag
        // changes.

#define DBGHELP_CHANGE_SYMOPT \
    (SYMOPT_NO_PROMPTS | \
     SYMOPT_DEBUG)

        g_SymOptions = (g_SymOptions & ~DBGHELP_CHANGE_SYMOPT) |
            (*(PULONG)CallbackData & DBGHELP_CHANGE_SYMOPT);
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

BOOL
ValidatePathComponent(PCSTR Part)
{
    if (strlen(Part) == 0)
    {
        return FALSE;
    }
    else if (!_strnicmp(Part, "SYMSRV*", 7) ||
             !_strnicmp(Part, "SRV*", 4) ||
             IsUrlPathComponent(Part))
    {
        // No easy way to validate symbol server or URL paths.
        // They're virtually always network references,
        // so just disallow all such usage when net
        // access isn't allowed.
        if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
        {
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        DWORD Attrs;
        DWORD OldMode;
        char Expand[MAX_PATH];

        // Otherwise make sure this is a valid directory.
        if (!ExpandEnvironmentStrings(Part, Expand, sizeof(Expand)))
        {
            return FALSE;
        }

        if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
        {
            // Don't call GetFileAttributes when network paths
            // are disabled as net operations may cause deadlocks.
            if (NetworkPathCheck(Expand) != ERROR_SUCCESS)
            {
                return FALSE;
            }
        }

        // We can still get to this point when debugging CSR
        // if the user has explicitly allowed net paths.
        // This check isn't important enough to risk a hang.
        if (AnySystemProcesses(TRUE))
        {
            return TRUE;
        }

        OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        Attrs = GetFileAttributes(Expand);

        SetErrorMode(OldMode);
        return Attrs != 0xffffffff && (Attrs & FILE_ATTRIBUTE_DIRECTORY);
    }
}

void
SetSymbolSearchPath(ProcessInfo* Process)
{
    LPSTR lpExePathEnv;
    size_t cbExePath;

    LPSTR lpSymPathEnv;
    LPSTR lpAltSymPathEnv;
    size_t cbSymPath;
    LPSTR NewMem;

    //
    // Load the Binary path (needed for triage dumps)
    //

    // No clue why this or the next is 18 ...
    cbExePath = 18;

    if (g_ExecutableImageSearchPath)
    {
        cbExePath += strlen(g_ExecutableImageSearchPath) + 1;
    }

    lpExePathEnv = NULL;
    if ((g_SymOptions & SYMOPT_IGNORE_NT_SYMPATH) == 0 &&
        (lpExePathEnv = getenv("_NT_EXECUTABLE_IMAGE_PATH")))
    {
        cbExePath += strlen(lpExePathEnv) + 1;
    }

    NewMem = (char*)realloc(g_ExecutableImageSearchPath, cbExePath);
    if (!NewMem)
    {
        ErrOut("Not enough memory to allocate/initialize "
               "ExecutableImageSearchPath");
        return;
    }
    if (!g_ExecutableImageSearchPath)
    {
        *NewMem = 0;
    }
    g_ExecutableImageSearchPath = NewMem;

    if ((g_SymOptions & SYMOPT_IGNORE_NT_SYMPATH) == 0)
    {
        AppendComponentsToPath(g_ExecutableImageSearchPath, lpExePathEnv,
                               TRUE);
    }

    //
    // Load symbol Path
    //

    cbSymPath = 18;
    if (g_SymbolSearchPath)
    {
        cbSymPath += strlen(g_SymbolSearchPath) + 1;
    }
    if ((g_SymOptions & SYMOPT_IGNORE_NT_SYMPATH) == 0 &&
        (lpSymPathEnv = getenv("_NT_SYMBOL_PATH")))
    {
        cbSymPath += strlen(lpSymPathEnv) + 1;
    }
    if ((g_SymOptions & SYMOPT_IGNORE_NT_SYMPATH) == 0 &&
        (lpAltSymPathEnv = getenv("_NT_ALT_SYMBOL_PATH")))
    {
        cbSymPath += strlen(lpAltSymPathEnv) + 1;
    }

    NewMem = (char*)realloc(g_SymbolSearchPath, cbSymPath);
    if (!NewMem)
    {
        ErrOut("Not enough memory to allocate/initialize "
               "SymbolSearchPath");
        return;
    }
    if (!g_SymbolSearchPath)
    {
        *NewMem = 0;
    }
    g_SymbolSearchPath = NewMem;

    if ((g_SymOptions & SYMOPT_IGNORE_NT_SYMPATH) == 0)
    {
        AppendComponentsToPath(g_SymbolSearchPath, lpAltSymPathEnv, TRUE);
        AppendComponentsToPath(g_SymbolSearchPath, lpSymPathEnv, TRUE);
    }

    SymSetSearchPath( Process->m_SymHandle, g_SymbolSearchPath );

    dprintf("Symbol search path is: %s\n",
            *g_SymbolSearchPath ?
            g_SymbolSearchPath :
            "*** Invalid *** : Verify _NT_SYMBOL_PATH setting" );

    if (g_ExecutableImageSearchPath)
    {
        dprintf("Executable search path is: %s\n",
                g_ExecutableImageSearchPath);
    }
}

BOOL
SetCurrentScope(
    IN PDEBUG_STACK_FRAME ScopeFrame,
    IN OPTIONAL PVOID ScopeContext,
    IN ULONG ScopeContextSize
    )
{
    BOOL ScopeChanged;
    PDEBUG_SCOPE Scope = &g_ScopeBuffer;

    if (Scope->State == ScopeDefaultLazy)
    {
        // It's not a lazy scope now.
        Scope->State = ScopeDefault;
    }

    if (ScopeFrame->FrameNumber != 0)
    {
        // Backup 1 byte to get correct scoped locals
        ScopeFrame->InstructionOffset--;
    }
    Scope->Process = g_Process;
    Scope->CheckedForThis = FALSE;
    ZeroMemory(&Scope->ThisData, sizeof(Scope->ThisData));

    ScopeChanged = g_Process &&
        SymSetContext(g_Process->m_SymHandle,
                      (PIMAGEHLP_STACK_FRAME) ScopeFrame,
                      ScopeContext);

    if (ScopeFrame->FrameNumber != 0)
    {
        // restore backed up byte
        ScopeFrame->InstructionOffset++;
    }

    if (ScopeContext && (sizeof(Scope->Context) >= ScopeContextSize))
    {
        memcpy(&Scope->Context, ScopeContext, ScopeContextSize);
        Scope->ContextState = MCTX_FULL;
        Scope->State = ScopeFromContext;
        NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS, DEBUG_ANY_ID);
    }

    if (ScopeChanged ||
        (ScopeFrame->FrameOffset != Scope->Frame.FrameOffset))
    {
        Scope->Frame = *ScopeFrame;
        if (ScopeFrame->FuncTableEntry)
        {
            // Cache the FPO data since the pointer is only temporary
            Scope->CachedFpo =
                *((PFPO_DATA) ScopeFrame->FuncTableEntry);
            Scope->Frame.FuncTableEntry =
                (ULONG64) &Scope->CachedFpo;
        }
        NotifyChangeSymbolState(DEBUG_CSS_SCOPE, 0, g_Process);
    }
    else
    {
        Scope->Frame = *ScopeFrame;
        if (ScopeFrame->FuncTableEntry)
        {
            // Cache the FPO data since the pointer is only temporary
            Scope->CachedFpo =
                *((PFPO_DATA) ScopeFrame->FuncTableEntry);
            Scope->Frame.FuncTableEntry =
                (ULONG64) &Scope->CachedFpo;
        }
    }

    return ScopeChanged;
}

BOOL
ResetCurrentScopeLazy(void)
{
    PDEBUG_SCOPE Scope = &g_ScopeBuffer;
    if (Scope->State == ScopeFromContext)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS, DEBUG_ANY_ID);
    }

    Scope->State = ScopeDefaultLazy;

    return TRUE;
}

BOOL
ResetCurrentScope(void)
{
    DEBUG_STACK_FRAME LocalFrame;
    PDEBUG_SCOPE Scope = &g_ScopeBuffer;

    if (Scope->State == ScopeFromContext)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS, DEBUG_ANY_ID);
    }

    Scope->State = ScopeDefault;

    ZeroMemory(&LocalFrame, sizeof(LocalFrame));

    // At the initial kernel load the system is only partially
    // initialized and is very sensitive to bad memory reads.
    // Stack traces can cause reads through unusual memory areas
    // so it's best to avoid them at this time.  This isn't
    // much of a problem since users don't usually expect a locals
    // context at this point.
    if ((IS_USER_TARGET(g_Target) ||
         (g_EngStatus & ENG_STATUS_AT_INITIAL_MODULE_LOAD) == 0) &&
        IS_CUR_CONTEXT_ACCESSIBLE())
    {
        if (!StackTrace(NULL, 0, 0, 0, STACK_ALL_DEFAULT,
                        &LocalFrame, 1, 0, 0, TRUE))
        {
            ADDR Addr;
            g_Machine->GetPC(&Addr);
            LocalFrame.InstructionOffset = Addr.off;
        }
    }

    return SetCurrentScope(&LocalFrame, NULL, 0);
}

ULONG
GetCurrentScopeThisData(TypedData* Data)
{
    PDEBUG_SCOPE Scope = GetCurrentScope();

    if (!Scope->CheckedForThis)
    {
        ULONG Tag;

        if (Scope->ThisData.FindSymbol(Scope->Process,
                                       "this",
                                       TDACC_REQUIRE,
                                       g_Machine->m_Ptr64 ? 8 : 4) ||
            !Scope->ThisData.m_Image ||
            !Scope->ThisData.IsPointer() ||
            Scope->ThisData.GetTypeTag(Scope->ThisData.m_NextType, &Tag) ||
            Tag != SymTagUDT)
        {
            ZeroMemory(&Scope->ThisData, sizeof(Scope->ThisData));
        }

        Scope->CheckedForThis = TRUE;
    }

    if (!Scope->ThisData.m_Image)
    {
        return VARDEF;
    }

    *Data = Scope->ThisData;
    return NO_ERROR;
}

void
ListUnloadedModules(ULONG Flags, PSTR Pattern)
{
    UnloadedModuleInfo* Unl;

    g_Process->m_NumUnloadedModules = 0;

    Unl = g_Target->GetUnloadedModuleInfo();
    if (Unl == NULL || Unl->Initialize(g_Thread) != S_OK)
    {
        // User-mode only has an unloaded module list
        // for .NET Server, so don't show any errors
        // if there isn't one.
        if (IS_KERNEL_TARGET(g_Target))
        {
            ErrOut("No unloaded module list present\n");
        }
        return;
    }

    char UnlName[MAX_INFO_UNLOADED_NAME];
    DEBUG_MODULE_PARAMETERS Params;

    if (Flags & LUM_OUTPUT)
    {
        dprintf("Unloaded modules:\n");
    }

    while (Unl->GetEntry(UnlName, &Params) == S_OK)
    {
        g_Process->m_NumUnloadedModules++;

        if (Pattern != NULL &&
            !MatchPattern(UnlName, Pattern))
        {
            continue;
        }

        if (Flags & LUM_OUTPUT_TERSE)
        {
            dprintf(".");
            continue;
        }

        if (Flags & LUM_OUTPUT)
        {
            dprintf("%s %s   %-8s\n",
                    FormatAddr64(Params.Base),
                    FormatAddr64(Params.Base + Params.Size),
                    UnlName);
        }

        if (Flags & ( LUM_OUTPUT_VERBOSE | LUM_OUTPUT_IMAGE_INFO))
        {
            PSTR TimeDateStr = TimeToStr(Params.TimeDateStamp);

            dprintf("    Timestamp: %s (%08X)\n",
                    TimeDateStr, Params.TimeDateStamp);
            dprintf("    Checksum:  %08X\n", Params.Checksum);
        }
    }

    dprintf("\n");
}

ULONG
ModuleMachineType(ProcessInfo* Process, ULONG64 Offset)
{
    ImageInfo* Image = Process->FindImageByOffset(Offset, FALSE);
    return Image ? Image->GetMachineType() : IMAGE_FILE_MACHINE_UNKNOWN;
}

ULONG
IsInFastSyscall(ULONG64 Addr, PULONG64 Base)
{
    if (Addr >= g_Target->m_TypeInfo.UmSharedSysCallOffset &&
        Addr < g_Target->m_TypeInfo.UmSharedSysCallOffset +
        g_Target->m_TypeInfo.UmSharedSysCallSize)
    {
        *Base = g_Target->m_TypeInfo.UmSharedSysCallOffset;
        return FSC_FOUND;
    }

    return FSC_NONE;
}

BOOL
ShowFunctionParameters(PDEBUG_STACK_FRAME StackFrame)
{
    SYM_DUMP_PARAM_EX SymFunction = {0};
    ULONG Status = 0;
    PDEBUG_SCOPE Scope = GetCurrentScope();
    DEBUG_SCOPE SavScope = *Scope;

    SymFunction.size = sizeof(SYM_DUMP_PARAM_EX);
    SymFunction.addr = StackFrame->InstructionOffset;
    SymFunction.Options = DBG_DUMP_COMPACT_OUT | DBG_DUMP_FUNCTION_FORMAT;

    //    SetCurrentScope to this function
    SymSetContext(g_Process->m_SymHandle,
                  (PIMAGEHLP_STACK_FRAME) StackFrame, NULL);
    Scope->Frame = *StackFrame;
    if (StackFrame->FuncTableEntry)
    {
        // Cache the FPO data since the pointer is only temporary
        Scope->CachedFpo = *((PFPO_DATA) StackFrame->FuncTableEntry);
        Scope->Frame.FuncTableEntry =
            (ULONG64) &Scope->CachedFpo;
    }

    if (!SymbolTypeDumpNew(&SymFunction, &Status) &&
        !Status)
    {
        Status = TRUE;
    }

    g_ScopeBuffer = SavScope;
    SymSetContext(g_Process->m_SymHandle,
                  (PIMAGEHLP_STACK_FRAME) &Scope->Frame, NULL);

    return !Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\symtype.h ===
#ifndef SYMTYPE_H
#define SYMTYPE_H

#define NONE                     0x000000

#define NO_INDENT                DBG_DUMP_NO_INDENT
#define NO_OFFSET                DBG_DUMP_NO_OFFSET
#define VERBOSE                  DBG_DUMP_VERBOSE
#define CALL_FOR_EACH            DBG_DUMP_CALL_FOR_EACH
#define ARRAY_DUMP               DBG_DUMP_ARRAY
#define LIST_DUMP                DBG_DUMP_LIST
#define NO_PRINT                 DBG_DUMP_NO_PRINT
#define GET_SIZE_ONLY            DBG_DUMP_GET_SIZE_ONLY
#define RECURSIVE1               0x000100
#define RECURSIVE2               0x000200
#define RECURSIVE3               0x000400
#define RECURS_DEF               0x000800
#define RECURSIVE        (RECURSIVE3 | RECURSIVE2 | RECURSIVE1 | RECURS_DEF)


// Dump and callback optons for fields
#define CALL_BEFORE_PRINT        DBG_DUMP_FIELD_CALL_BEFORE_PRINT
#define NO_CALLBACK_REQ          DBG_DUMP_FIELD_NO_CALLBACK_REQ
#define RECUR_ON_THIS            DBG_DUMP_FIELD_RECUR_ON_THIS
#define COPY_FIELD_DATA          DBG_DUMP_FIELD_COPY_FIELD_DATA
#define FIELD_ARRAY_DUMP         DBG_DUMP_FIELD_ARRAY
#define DBG_DUMP_FIELD_STRING    (DBG_DUMP_FIELD_DEFAULT_STRING | DBG_DUMP_FIELD_WCHAR_STRING | DBG_DUMP_FIELD_MULTI_STRING | DBG_DUMP_FIELD_GUID_STRING)

#ifdef DBG_RETURN_TYPE
#undef DBG_RETURN_TYPE
#undef DBG_RETURN_SUBTYPES
#undef DBG_RETURN_TYPE_VALUES
#endif

//
// Return the name and type data for this symbol
//
#define DBG_RETURN_TYPE                   0x00000010
//
// Return the sub-type list for the type data
//
#define DBG_RETURN_SUBTYPES               0x00001000
//
// Get the Values for this type data
//
#define DBG_RETURN_TYPE_VALUES            0x00004000


#define MAX_NAME                 MAX_SYM_NAME
#define MAX_STRUCT_DUMP_SIZE     256

#define SYM_IS_VARIABLE          0x1000

//
// Structure to store the information about most recently referred types.
//   Going through module list for type search takes time, so maintain a "cache"
//   of types.
//
typedef struct _TYPES_INFO {
    ANSI_STRING Name;          // Name of struct stored
    CHAR    ModName[30];       // Name of module (optional)
    ULONG   TypeIndex;         // Type index in module's pdb file
    HANDLE  hProcess;          // Handle of process to access the module
    ULONG64 ModBaseAddress;    // Base address of te module
    ULONG64 SymAddress;        // Address in case of a gvar / local
    ULONG   Referenced;        // Time since previous reference
    ULONG64 Value;             // Value of symbol, if its a constant
    ULONG   Flag;              // SYMFLAG_* flags
} TYPES_INFO, *PTYPES_INFO;

typedef struct _TYPES_INFO_ALL {
    ANSI_STRING Name;
    ULONG   TypeIndex;
    HANDLE  hProcess;
    ULONG64 Module;
    ULONG   Size;
    ULONG64 Offset;
    ULONG64 Address;
    ULONG   Register;
    ULONG64 Value;
    ULONG   Flags;
    ULONG   SubElements;
    ULONG64 SubAddr;
} TYPES_INFO_ALL, *PTYPES_INFO_ALL;

typedef struct _FIND_TYPE_INFO {
    ULONG Flags;
    ULONG nParams;
    CHAR  SymPrefix[8]; // may contain &,* for pointers
    TYPES_INFO_ALL FullInfo;
    ULONG64 ParentExpandAddress; // Valid if DBG_RETURN_SUBTYPES flag is used
} FIND_TYPE_INFO, *PFIND_TYPE_INFO;

#define MAX_TYPES_STORED       20
#define MINIMUM_BUFFER_LENGTH  40
#define DEBUG_LOCALS_MASK      (SYMF_REGISTER | SYMF_FRAMEREL | SYMF_REGREL)


#define IsPrintChar(c) (((UCHAR) c >= 0x20) && ((UCHAR) c <= 0x7e))
#define IsPrintWChar(wc) (((WCHAR) wc >= 0x20) && ((WCHAR) wc <= 0x7e))

typedef struct _ALT_FIELD_INFO {
    struct {
        ULONG       ReferAltInfo:1;
        ULONG       Matched:1;
        ULONG       InPtrReference:1;
        ULONG       ArrayElement:1;
        ULONG       Reserved:26;
    } FieldType;
    ULONG           ArrayElements;
} ALT_FIELD_INFO, *PALT_FIELD_INFO;

//
// Struct to keep list of parents as we go inside a structure/union during dump
//
typedef struct _TYPE_NAME_LIST {
   ULONG Type;
   LPSTR Name;
   struct _TYPE_NAME_LIST *Next;
} TYPE_NAME_LIST, *PTYPE_NAME_LIST;


typedef struct _TYPE_DUMP_INTERNAL {
   HANDLE     hProcess;         // Handle to get module information
   ULONG64    modBaseAddr;      // Module which contains symbol info


   USHORT     nElements;        // Maximum nubler of elements to dump in list
   ULONG64    NextListElement;  // This is used to store the next list elements address
   ULONG64    LastListElement;  // When we are dumping _LIST_ENTRY type, this specifies the end

   USHORT     arrElements;       // Maximum elements to dump With Array

   //
   // Stores index+1 of array element to dump.
   //
   ULONG      ArrayElementToDump;

   USHORT     StringSize;        // To get the size of string to dump

   // If we are in field1.field2, this is Offset of field1 + Offset of field2
   ULONG64    totalOffset;
   ULONG      BaseClassOffsets;

   //
   // If we are reading in data, copy it into buffer if following are set.
   // TypeDataPointer is updated to point to next location to be copied
   //
   BOOL       CopyDataInBuffer;
   PUCHAR     TypeDataPointer;

   // Tells whether to write from 0th bit or the bit's actual position, when copying bit-fields
   ULONG      BitIndex;

   ULONG      TypeOptions;
   USHORT     level;
   ULONG      FieldOptions;

   PTYPE_NAME_LIST ParentTypes;  // Stores list of all parent type names
   PTYPE_NAME_LIST ParentFields; // Stores list of all parent field names

   ULONG      rootTypeIndex;
   ULONG      typeSize;

   //
   // PtrRead becomes true just after reading the pointer
   //
   BOOL       PtrRead;

   //
   // A field may be processessed if it can be parent of some field specified
   // in Fields array. In that case InUnlistedField becomes true.
   //
   BOOL       InUnlistedField;

   //
   // Error values are set here if the Type dump call fails
   //
   ULONG      ErrorStatus;

   //
   // Memory read error at this
   //
   ULONG64    InvalidAddress;

   //
   // Tells we are in field Sym->Fields[FieldIndex]
   //
   ULONG      FieldIndex;

   ULONG      fieldNameLen;
   //
   // An array to keep track of fields internally
   //
   PALT_FIELD_INFO AltFields;

   ULONG      newLinePrinted;

   //
   // For type information of symbols
   //
   PFIND_TYPE_INFO pInfoFound;

   ULONG      FillTypeInfo:1;
   ULONG      CopyName:1;
   ULONG      RefFromPtr:1;
   ULONG      CopyDataForParent:1;
   ULONG      InBaseClass:1;
   ULONG      BitFieldRead:1;
   ULONG      DeReferencePtr:1;
   ULONG      IsAVar:1;             // Symbol is a variable (as opposed to type)
   ULONG      ValuePresent:1;       // True for constants or when value is read from registers
   ULONG      IsEnumVal:1;
   ULONG      Reserved:23;

   ULONG      NumSymParams;
   ULONG      CurrentSymParam;


   ULONG      BitFieldSize;
   ULONG      BitFieldOffset;

   ULONG64    Value;
   TYPES_INFO  LastType;
   PCHAR      Prefix;

   // lenght of string in field pointer, set for known string types
   ULONG      PointerStringLength;
} TYPE_DUMP_INTERNAL, *PTYPE_DUMP_INTERNAL;


typedef enum _DBG_TYPES {
    DBG_TYP_UNKNOWN = 0,
    DBG_TYP_POINTER,
    DBG_TYP_NUMBER,      // for int, char, short, int64
    DBG_TYP_BIT,
    DBG_TYP_STRUCT,      // for structs, class, union
    DBG_TYP_ARRAY,
} DBG_TYPES;


typedef
ULONG
(WDBGAPI*PSYM_DUMP_FIELD_CALLBACK_OLD)(
    struct _FIELD_INFO_OLD *pField,
    PVOID UserContext
    );

typedef struct _FIELD_INFO_OLD {
   PUCHAR  fName;          // Name of the field
   PUCHAR  printName;      // Name to be printed at dump
   ULONG   size;           // Size of the field
   ULONG   fOptions;       // Dump Options for the field
   ULONG64 address;        // address of the field
   PVOID   fieldCallBack;  // Return info or callBack routine for the field
} FIELD_INFO_OLD, *PFIELD_INFO_OLD;

typedef struct _SYM_DUMP_PARAM_OLD {
   ULONG               size;          // size of this struct
   PUCHAR              sName;         // type name
   ULONG               Options;       // Dump options
   ULONG64             addr;          // Address to take data for type
   PFIELD_INFO_OLD     listLink;      // fName here would be used to do list dump
   PVOID               Context;       // Usercontext passed to CallbackRoutine
   PSYM_DUMP_FIELD_CALLBACK_OLD CallbackRoutine;
                                      // Routine called back
   ULONG               nFields;       // # elements in Fields
   PFIELD_INFO_OLD     Fields;        // Used to return information about field
} SYM_DUMP_PARAM_OLD, *PSYM_DUMP_PARAM_OLD;


typedef PSYM_DUMP_FIELD_CALLBACK PSYM_DUMP_FIELD_CALLBACK_EX;

typedef FIELD_INFO FIELD_INFO_EX, *PFIELD_INFO_EX;

typedef SYM_DUMP_PARAM SYM_DUMP_PARAM_EX, *PSYM_DUMP_PARAM_EX;

typedef SYM_DUMP_PARAM_EX FAST_DUMP_INFO, *PFAST_DUMP_INFO;

class ReferencedSymbolList {
public:
    ReferencedSymbolList() {
        ZeroMemory(&m_ReferencedTypes, sizeof(m_ReferencedTypes));
    };
    ULONG StoreTypeInfo(PTYPES_INFO pInfo);
    ULONG LookupType(PCHAR Name, PCHAR Module, BOOL CompleteName);
    VOID  ClearStoredSymbols (ULONG64 ModBase);
    VOID  EnsureValidLocals (void);
    PTYPES_INFO GetStoredIndex(ULONG Index) {
        if (Index < MAX_TYPES_STORED)
        return &m_ReferencedTypes[Index];
        else return NULL;
        };

private:

    // FP & IP for scope of locals list
    ULONG64 m_FP;
    ULONG64 m_RO;
    ULONG64 m_IP;
    ULONG   m_ListSize;
    TYPES_INFO m_ReferencedTypes[MAX_TYPES_STORED];
};


//-----------------------------------------------------------------------------


class DbgTypes {
public:
    DbgTypes(PTYPE_DUMP_INTERNAL pInternalDumpInfo,
             PTYPES_INFO         pTypeInfo,
             PSYM_DUMP_PARAM_EX  pExternalDumpInfo);
    ~DbgTypes() {};

    ULONG64 GetAddress(void) {
        return m_pDumpInfo->addr ?
            (m_pDumpInfo->addr + m_pInternalInfo->totalOffset +
              m_pInternalInfo->BaseClassOffsets)  : 0;
    };

    ULONG ProcessType(ULONG TypeIndex);

    ULONG ProcessVariant(
        IN VARIANT var,
        IN LPSTR   name
    );

    BOOL CheckAndPrintStringType(
        IN ULONG TI,
        IN ULONG Size
    );

    ULONG ProcessBaseType(
        IN ULONG TypeIndex,
        IN ULONG TI,
        IN ULONG Size
        );

    ULONG ProcessPointerType(
        IN ULONG TI,
        IN ULONG ChildTI,
        IN ULONG Size
        );

    ULONG ProcessBitFieldType(
        IN ULONG               TI,
        IN ULONG               ParentTI,
        IN ULONG               length,
        IN ULONG               position
        );

    ULONG ProcessDataMemberType(
        IN ULONG               TI,
        IN ULONG               ChildTI,
        IN LPSTR               name,
        IN BOOL                bStatic
        );

    ULONG ProcessUDType(
        IN ULONG               TI,
        IN LPSTR               name
        );

    ULONG ProcessEnumerate(
        IN VARIANT             var,
        IN LPSTR               name
        );

    ULONG ProcessEnumType(
        IN ULONG               TI,
        IN LPSTR               name
        );

    ULONG ProcessArrayType(
        IN ULONG               TI,
        IN ULONG               eltTI,
        IN ULONG               count,
        IN ULONGLONG           size,
        IN LPSTR               name
        );

    ULONG ProcessVTShapeType(
        IN ULONG               TI,
        IN ULONG               count
        );

    ULONG ProcessVTableType(
        IN ULONG               TI,
        IN ULONG               ChildTI
          );

    ULONG ProcessBaseClassType(
        IN ULONG               TI,
        IN ULONG               ChildTI
        );

    ULONG ProcessFunction(
        IN ULONG               TI,
        IN ULONG               ChildTI,
        IN LPSTR               name
        );

    ULONG ProcessFunctionType(
        IN ULONG               TI,
        IN ULONG               ChildTI
        );

    ULONG ProcessFunctionArgType(
        IN ULONG               TI,
        IN ULONG               ChildTI
    );

    ULONG MatchField(
        LPSTR               fName,
        PTYPE_DUMP_INTERNAL m_pInternalInfo,
        PFIELD_INFO_EX      fields,
        ULONG               nFields,
        PULONG              ParentOfField
        );
    void CopyDumpInfo(
        ULONG Size
        );
    BOOL DumpKnownStructFormat(
        PCHAR Name
        );

    ULONG64 GetDumpAddress() {
        return m_AddrPresent ? (m_pInternalInfo->totalOffset +
                                m_pDumpInfo->addr) :
            0;
    }
    /*
    ULONG ReadTypeData (
        PUCHAR   des,
        ULONG64  src,
        ULONG    count,
        ULONG    Option
        );
    ULONG ReadInAdvance(
        ULONG64 addr,
        ULONG size,
        ULONG Options);
*/
    ULONG               m_typeIndex;
    ULONG               m_Options;
    PTYPE_DUMP_INTERNAL m_pInternalInfo;
    PSYM_DUMP_PARAM_EX  m_pDumpInfo;
    ULONG               m_ParentTag;
    ULONG               m_SymTag;
    PCHAR               m_pNextSym;
    PCHAR               m_pSymPrefix;

private:
    BOOL                m_AddrPresent;
    BOOL                m_thisPointerDump; // TRUE if DumpType is called on local var 'this'
    TYPES_INFO          m_TypeInfo;
    TYPE_DUMP_INTERNAL  m_InternalInfo;
    SYM_DUMP_PARAM_EX      m_ExtDumpInfo;
};

#define MAX_DETYPES_ALLOWED 5

typedef struct DBG_DE_TYPE {
    ULONG TypeId;
    ULONG Tag;
    ULONG StartIndex;   // Index of start char for this derived type in the main type name
    ULONG Namelength;   // Length of this derived type name
    ULONG ArrayIndex;
} DBG_DE_TYPE, *PDBG_DE_TYPE;

class DbgDerivedType : public DbgTypes {
public:
    DbgDerivedType(
        PTYPE_DUMP_INTERNAL pInternalDumpInfo,
        PTYPES_INFO         pTypeInfo,
        PSYM_DUMP_PARAM_EX     pExternalDumpInfo);
    ~DbgDerivedType();

    ULONG DumpType();

    HRESULT GenerateTypes(
        IN PCHAR TypeName
        );

    ULONG DumpSingleDimArray(
        IN PDBG_DE_TYPE        DeType,
        IN ULONG               NumElts,
        IN ULONG               ElementType
    );

    ULONG DumpPointer(
        IN PDBG_DE_TYPE        DeType,
        IN ULONG               ptrSize,
        IN ULONG               ChildIndex
        );

    ULONG DumpAddressOf(
        PDBG_DE_TYPE        DeType,
        ULONG               ptrSize,
        ULONG               ChildIndex
        );

    ULONG GetTypeSize();

private:
    ULONG m_DerivedTypeId;
    ULONG m_BaseTypeId;
    DBG_DE_TYPE m_DeTypes[MAX_DETYPES_ALLOWED];
    ULONG m_NumDeTypes;
};


//-----------------------------------------------------------------------------

BOOL
GetThisAdjustForCurrentScope(
    ProcessInfo* Process,
    PULONG thisAdjust
    );

BOOL
PrintStringIfString(
    IN HANDLE hProcess,
    IN ULONG64 ModBase,
    IN ULONG TypeOpts,
    IN ULONG StrOpts,
    IN ULONG TI,
    IN ULONG64 Address,
    IN ULONG Size
    );

ULONG
DumpKnownStruct(
    PCHAR name,
    ULONG Options,
    ULONG64 Address,
    PULONG pStringLen
    );

void
StrprintInt(
    PCHAR str, ULONG64 val, ULONG Size
    );
void
StrprintUInt(
    PCHAR str, ULONG64 val, ULONG Size
    );

BOOL
GetEnumTypeName(
    HANDLE hProcess,
    ULONG64 ModBase,
    ULONG TypeIndex,
    ULONG64 Value,
    PCHAR Name,
    PUSHORT NameLen
    );

BOOL
ParseArgumentString (
   IN LPSTR lpArgumentString,
   OUT PSYM_DUMP_PARAM_EX dp);

VOID
ClearStoredTypes (
    ULONG64 ModBase
    );

ULONG
DumpType(
    PTYPES_INFO     pTypeInfo,
    PSYM_DUMP_PARAM_EX pSym,
    PULONG          pStatus
    );

ULONG
TypeInfoFound(
    IN HANDLE hProcess,
    IN ImageInfo* pImage,
    IN PSYM_DUMP_PARAM_EX pSym,
    OUT PTYPES_INFO pTypeInfo
    );

ULONG
SymbolTypeDump(
   IN HANDLE hProcess,
   IN ImageInfo* pImage,
   IN OUT PSYM_DUMP_PARAM pSym,
   OUT PULONG pStatus
   );

ULONG
SymbolTypeDumpNew(
    IN OUT PSYM_DUMP_PARAM_EX pSym,
    OUT PULONG pStatus
    );

ULONG
SymbolTypeDumpEx(
   IN HANDLE hProcess,
   IN ImageInfo* pImage,
   IN LPSTR lpArgString);

ULONG
DumpSingleValue (
    PSYMBOL_INFO pSymInfo
    );

HRESULT
GetTypeName(
    IN OPTIONAL PCHAR       pSymName,
    IN OPTIONAL PTYPES_INFO pTypeInfo,
    OUT PANSI_STRING        TypeName
    );

ULONG
fnFieldOffset(
    PCHAR Type,
    PCHAR Field,
    OUT PULONG Offset
    );

HRESULT
GetNameFromIndex(
    PTYPES_INFO pTypeInfo,
    PCHAR       Name,
    PUSHORT     NameLen
    );

ULONG
DumpTypeAndReturnInfo(
    PTYPES_INFO     pTypeInfo,
    PSYM_DUMP_PARAM_EX pSym,
    PULONG          pStatus,
    PFIND_TYPE_INFO pReturnTypeInfo
    );

ULONG
OutputTypeByIndex(
    HANDLE hProcess,
    ULONG64 ModBase,
    ULONG TypeIndex,
    ULONG64 Address
    );

BOOL
GetExpressionTypeInfo(
    IN PCHAR TypeExpr,
    OUT PTYPES_INFO_ALL pTypeInfo
    );

void
PrintParamValue(ULONG Param);

BOOL
ShowSymbolInfo(
    PSYMBOL_INFO   pSymInfo
    );

BOOL
IsFunctionSymbol(
    PSYMBOL_INFO pSymInfo
    );

extern BOOL    g_PrintDefaultRadix;
extern BOOL    g_EnableLongStatus;
extern BOOL    g_EnableUnicode;
extern ULONG   g_TypeOptions;

#endif // SYMTYPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\stkwalk.h ===
//----------------------------------------------------------------------------
//
// Stack walking support.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _STKWALK_H_
#define _STKWALK_H_

extern BOOL g_AllowCorStack;
extern BOOL g_DebugCorStack;

#define IA64_SAVE_IFS(Frame) ((Frame)->Reserved[0])

#define SAVE_EBP(f)        (f)->Reserved[0]
#define TRAP_TSS(f)        (f)->Reserved[1]
#define TRAP_EDITED(f)     (f)->Reserved[1]
#define SAVE_TRAP(f)       (f)->Reserved[2]

#define STACK_NO_DEFAULT    0x00000000
#define STACK_INSTR_DEFAULT 0x00000001
#define STACK_STACK_DEFAULT 0x00000002
#define STACK_FRAME_DEFAULT 0x00000004
#define STACK_ALL_DEFAULT   0x00000007

// Extra flag for stack trace format that overrides all
// others and indicates a raw pointer stack dump.
#define RAW_STACK_DUMP 0x80000000

LPVOID
SwFunctionTableAccess(
    HANDLE  hProcess,
    ULONG64 AddrBase
    );

VOID
DoStackTrace(
    DebugClient*       Client,
    ULONG64            FramePointer,
    ULONG64            StackPointer,
    ULONG64            InstructionPointer,
    ULONG              PointerDefaults,
    ULONG              NumFrames,
    ULONG              TraceFlags
    );

VOID
PrintStackFrame(
    PDEBUG_STACK_FRAME StackFrame,
    PDEBUG_STACK_FRAME PrevFrame,
    ULONG              Flags
    );

VOID
PrintStackTrace(
    ULONG              NumFrames,
    PDEBUG_STACK_FRAME StackFrames,
    ULONG              Flags
    );

DWORD
StackTrace(
    DebugClient*       Client,
    ULONG64            FramePointer,
    ULONG64            StackPointer,
    ULONG64            InstructionPointer,
    ULONG              PointerDefaults,
    PDEBUG_STACK_FRAME StackFrames,
    ULONG              NumFrames,
    ULONG64            ExtThread,
    ULONG              Flags,
    BOOL               EstablishingScope
    );

#endif // #ifndef _STKWALK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\system.cpp ===
//----------------------------------------------------------------------------
//
// System methods for targets.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include <common.ver>

ULONG g_UserIdFragmented[LAYER_COUNT];
ULONG g_HighestUserId[LAYER_COUNT];

TargetInfo* g_Target;
ProcessInfo* g_Process;
ThreadInfo* g_Thread;
MachineInfo* g_Machine;

char* g_SuiteMaskNames[] =
{
    "SmallBusiness",
    "Enterprise",
    "BackOffice",
    "CommunicationServer",
    "TerminalServer",
    "SmallBusinessRestricted",
    "EmbeddedNT",
    "DataCenter",
    "SingleUserTS",
    "Personal",
    "Blade",
    "EmbeddedRestricted",
};

PCSTR g_NtSverNames[] =
{
    "Windows NT 4", "Windows 2000 RC3", "Windows 2000", "Windows XP",
    "Windows Server 2003", "Longhorn",
};
PCSTR g_W9xSverNames[] =
{
    "Windows 95", "Windows 98", "Windows 98 SE", "Windows ME",
};
PCSTR g_XBoxSverNames[] =
{
    "XBox",
};
PCSTR g_BigSverNames[] =
{
    "BIG KD Emulation",
};
PCSTR g_ExdiSverNames[] =
{
    "eXDI Device",
};
PCSTR g_NtBdSverNames[] =
{
    "Windows Boot Debugger",
};
PCSTR g_EfiSverNames[] =
{
    "EFI KD Emulation",
};
PCSTR g_WceSverNames[] =
{
    "Windows CE",
};

//----------------------------------------------------------------------------
//
// TargetInfo system methods.
//
//----------------------------------------------------------------------------

void
TargetInfo::ResetSystemInfo(void)
{
    m_NumProcesses = 0;
    m_ProcessHead = NULL;
    m_CurrentProcess = NULL;
    m_AllProcessFlags = 0;
    m_TotalNumberThreads = 0;
    m_MaxThreadsInProcess = 0;
    m_SystemId = 0;
    m_Exited = FALSE;
    m_DeferContinueEvent = FALSE;
    m_BreakInTimeout = FALSE;
    m_ProcessesAdded = FALSE;
    ZeroMemory(&m_TypeInfo, sizeof(m_TypeInfo));
    m_SystemVersion = 0;
    m_ActualSystemVersion = 0;
    m_BuildNumber = 0;
    m_CheckedBuild = 0;
    m_PlatformId = 0;
    m_ServicePackString[0] = 0;
    m_ServicePackNumber = 0;
    m_BuildLabName[0] = 0;
    m_ProductType = INVALID_PRODUCT_TYPE;
    m_SuiteMask = 0;
    m_NumProcessors = 0;
    m_MachineType = IMAGE_FILE_MACHINE_UNKNOWN;
    ZeroMemory(&m_Machines, sizeof(m_Machines));
    m_Machine = NULL;
    ZeroMemory(&m_FirstProcessorId, sizeof(m_FirstProcessorId));
    m_MachinesInitialized = FALSE;
    m_EffMachineType = IMAGE_FILE_MACHINE_UNKNOWN;
    m_EffMachineIndex = MACHIDX_COUNT;
    m_EffMachine = NULL;
    m_RegContextThread = NULL;
    m_RegContextProcessor = -1;
    m_SystemRangeStart = 0;
    m_SystemCallVirtualAddress = 0;
    ZeroMemory(&m_KdDebuggerData, sizeof(m_KdDebuggerData));
    ZeroMemory(&m_KdVersion, sizeof(m_KdVersion));
    m_KdDebuggerDataOffset = 0;
    m_KdApi64 = FALSE;

    // The physical cache is suspended by default.
    m_PhysicalCache.ChangeSuspend(FALSE);

    InvalidateMemoryCaches(FALSE);
    
    m_ExtensionSearchPath = NULL;
    ResetImplicitData();
}

void
TargetInfo::DeleteSystemInfo(void)
{
    ULONG i;

    UnloadTargetExtensionDlls(this);

    while (m_ProcessHead)
    {
        delete m_ProcessHead;
    }

    for (i = 0; i < MACHIDX_COUNT; i++)
    {
        delete m_Machines[i];
        m_Machines[i] = NULL;
    }
    
    free(m_ExtensionSearchPath);
    m_ExtensionSearchPath = NULL;
}

HRESULT
TargetInfo::ReadKdDataBlock(ProcessInfo* Process)
{
    HRESULT Status;
    ULONG Size;
    KDDEBUGGER_DATA32 LocalData32;
    KDDEBUGGER_DATA64 LocalData64;

    if (IS_KERNEL_TRIAGE_DUMP(this) &&
        !((KernelTriageDumpTargetInfo*)this)->m_HasDebuggerData)
    {
        // This dump may have a data block offset in the header
        // but the actual data block content is not present so
        // don't attempt to read it.  This is a normal occurrence
        // in older dumps so there's no error message.
        return S_FALSE;
    }
    
    if (!m_KdDebuggerDataOffset)
    {
        // NT4 doesn't have a data block so don't display a warning.
        if (m_SystemVersion > NT_SVER_NT4)
        {
            ErrOut("KdDebuggerDataBlock not available!\n");
        }

        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    //
    // Get the size of the KDDEBUGGER_DATA block.
    //

    if (m_KdApi64)
    {
        DBGKD_DEBUG_DATA_HEADER64 Header;
            
        Status = ReadAllVirtual(Process,
                                m_KdDebuggerDataOffset,
                                &Header, sizeof(Header));
        Size = Header.Size;
    }
    else
    {
        DBGKD_DEBUG_DATA_HEADER32 Header;
            
        Status = ReadAllVirtual(Process,
                                m_KdDebuggerDataOffset,
                                &Header, sizeof(Header));
        Size = Header.Size;
    }
    if (Status != S_OK || !Size)
    {
        ErrOut("*************************************"
               "*************************************\n");
        if (IS_DUMP_TARGET(this))
        {
            ErrOut("THIS DUMP FILE IS PARTIALLY CORRUPT.\n"
                   "KdDebuggerDataBlock is not present or unreadable.\n");
        }
        else
        {
            ErrOut("Unable to read debugger data block header\n");
        }
        ErrOut("*************************************"
               "*************************************\n");
        return Status != S_OK ? Status : E_FAIL;
    }

    // Only read as much of the data block as we can hold in the debugger.
    if (Size > sizeof(KDDEBUGGER_DATA64))
    {
        Size = sizeof(KDDEBUGGER_DATA64);
    }

    //
    // Now read the data
    //

    if (m_KdApi64)
    {
        if ((Status = ReadAllVirtual(Process,
                                     m_KdDebuggerDataOffset,
                                     &LocalData64, Size)) != S_OK)
        {
            ErrOut("KdDebuggerDataBlock could not be read\n");
            return Status;
        }

        if (m_Machine->m_Ptr64)
        {
            memcpy(&m_KdDebuggerData, &LocalData64, Size);
        }
        else
        {
            //
            // Sign extended for X86
            //

            //
            // Extend the header so it doesn't get whacked
            //
            ListEntry32To64((PLIST_ENTRY32)(&LocalData64.Header.List),
                            &(m_KdDebuggerData.Header.List));

            m_KdDebuggerData.Header.OwnerTag =
                LocalData64.Header.OwnerTag;
            m_KdDebuggerData.Header.Size =
                LocalData64.Header.Size;

            //
            // Sign extend all the 32 bits values to 64 bit
            //

#define UIP(f)   if (FIELD_OFFSET(KDDEBUGGER_DATA64, f) < Size)  \
                 {                                               \
                     m_KdDebuggerData.f =                        \
                         (ULONG64)(LONG64)(LONG)(LocalData64.f); \
                 }

#define CPBIT(f) m_KdDebuggerData.f = LocalData64.f;

#define CP(f)    if (FIELD_OFFSET(KDDEBUGGER_DATA64, f) < Size)    \
                 {                                                 \
                     m_KdDebuggerData.f = LocalData64.f;           \
                 }

            UIP(KernBase);
            UIP(BreakpointWithStatus);
            UIP(SavedContext);
            CP(ThCallbackStack);
            CP(NextCallback);
            CP(FramePointer);
            CPBIT(PaeEnabled);
            UIP(KiCallUserMode);
            UIP(KeUserCallbackDispatcher);
            UIP(PsLoadedModuleList);
            UIP(PsActiveProcessHead);
            UIP(PspCidTable);
            UIP(ExpSystemResourcesList);
            UIP(ExpPagedPoolDescriptor);
            UIP(ExpNumberOfPagedPools);
            UIP(KeTimeIncrement);
            UIP(KeBugCheckCallbackListHead);
            UIP(KiBugcheckData);
            UIP(IopErrorLogListHead);
            UIP(ObpRootDirectoryObject);
            UIP(ObpTypeObjectType);
            UIP(MmSystemCacheStart);
            UIP(MmSystemCacheEnd);
            UIP(MmSystemCacheWs);
            UIP(MmPfnDatabase);
            UIP(MmSystemPtesStart);
            UIP(MmSystemPtesEnd);
            UIP(MmSubsectionBase);
            UIP(MmNumberOfPagingFiles);
            UIP(MmLowestPhysicalPage);
            UIP(MmHighestPhysicalPage);
            UIP(MmNumberOfPhysicalPages);
            UIP(MmMaximumNonPagedPoolInBytes);
            UIP(MmNonPagedSystemStart);
            UIP(MmNonPagedPoolStart);
            UIP(MmNonPagedPoolEnd);
            UIP(MmPagedPoolStart);
            UIP(MmPagedPoolEnd);
            UIP(MmPagedPoolInformation);
            CP(MmPageSize);
            UIP(MmSizeOfPagedPoolInBytes);
            UIP(MmTotalCommitLimit);
            UIP(MmTotalCommittedPages);
            UIP(MmSharedCommit);
            UIP(MmDriverCommit);
            UIP(MmProcessCommit);
            UIP(MmPagedPoolCommit);
            UIP(MmExtendedCommit);
            UIP(MmZeroedPageListHead);
            UIP(MmFreePageListHead);
            UIP(MmStandbyPageListHead);
            UIP(MmModifiedPageListHead);
            UIP(MmModifiedNoWritePageListHead);
            UIP(MmAvailablePages);
            UIP(MmResidentAvailablePages);
            UIP(PoolTrackTable);
            UIP(NonPagedPoolDescriptor);
            UIP(MmHighestUserAddress);
            UIP(MmSystemRangeStart);
            UIP(MmUserProbeAddress);
            UIP(KdPrintCircularBuffer);
            UIP(KdPrintCircularBufferEnd);
            UIP(KdPrintWritePointer);
            UIP(KdPrintRolloverCount);
            UIP(MmLoadedUserImageList);

            // NT 5.1 additions

            UIP(NtBuildLab);
            UIP(KiNormalSystemCall);

            // NT 5.0 QFE additions

            UIP(KiProcessorBlock);
            UIP(MmUnloadedDrivers);
            UIP(MmLastUnloadedDriver);
            UIP(MmTriageActionTaken);
            UIP(MmSpecialPoolTag);
            UIP(KernelVerifier);
            UIP(MmVerifierData);
            UIP(MmAllocatedNonPagedPool);
            UIP(MmPeakCommitment);
            UIP(MmTotalCommitLimitMaximum);
            UIP(CmNtCSDVersion);

            // NT 5.1 additions

            UIP(MmPhysicalMemoryBlock);
            UIP(MmSessionBase);
            UIP(MmSessionSize);
            UIP(MmSystemParentTablePage);

                // Server additions

            UIP(MmVirtualTranslationBase);
            CP(OffsetKThreadNextProcessor);
            CP(OffsetKThreadTeb);
            CP(OffsetKThreadKernelStack);
            CP(OffsetKThreadInitialStack);

            CP(OffsetKThreadApcProcess);
            CP(OffsetKThreadState);
            CP(OffsetKThreadBStore);
            CP(OffsetKThreadBStoreLimit);

            CP(SizeEProcess);
            CP(OffsetEprocessPeb);
            CP(OffsetEprocessParentCID);
            CP(OffsetEprocessDirectoryTableBase);

            CP(SizePrcb);
            CP(OffsetPrcbDpcRoutine);
            CP(OffsetPrcbCurrentThread);
            CP(OffsetPrcbMhz);

            CP(OffsetPrcbCpuType);
            CP(OffsetPrcbVendorString);
            CP(OffsetPrcbProcStateContext);
            CP(OffsetPrcbNumber);

            CP(SizeEThread);

            UIP(KdPrintCircularBufferPtr);
            UIP(KdPrintBufferSize);

            UIP(KeLoaderBlock);

            CP(SizePcr);
            CP(OffsetPcrSelfPcr);
            CP(OffsetPcrCurrentPrcb);
            CP(OffsetPcrContainedPrcb);

            CP(OffsetPcrInitialBStore);
            CP(OffsetPcrBStoreLimit);
            CP(OffsetPcrInitialStack);
            CP(OffsetPcrStackLimit);

            CP(OffsetPrcbPcrPage);
            CP(OffsetPrcbProcStateSpecialReg);
            CP(GdtR0Code);
            CP(GdtR0Data);

            CP(GdtR0Pcr);
            CP(GdtR3Code);
            CP(GdtR3Data);
            CP(GdtR3Teb);

            CP(GdtLdt);
            CP(GdtTss);
            CP(Gdt64R3CmCode);
            CP(Gdt64R3CmTeb);

            UIP(IopNumTriageDumpDataBlocks);
            UIP(IopTriageDumpDataBlocks);
        }
    }
    else
    {
        if (Size != sizeof(LocalData32))
        {
            ErrOut("Someone changed the definition of KDDEBUGGER_DATA32 - "
                   "please fix\n");
            return E_FAIL;
        }

        if ((Status = ReadAllVirtual(Process,
                                     m_KdDebuggerDataOffset,
                                     &LocalData32,
                                     sizeof(LocalData32))) != S_OK)
        {
            ErrOut("KdDebuggerDataBlock could not be read\n");
            return Status;
        }

        //
        // Convert all the 32 bits fields to 64 bit
        //

#undef UIP
#undef CP
#define UIP(f) m_KdDebuggerData.f = EXTEND64(LocalData32.f)
#define CP(f) m_KdDebuggerData.f = (LocalData32.f)

        //
        // Extend the header so it doesn't get whacked
        //
        ListEntry32To64((PLIST_ENTRY32)(&LocalData32.Header.List),
                        &(m_KdDebuggerData.Header.List));
        
        m_KdDebuggerData.Header.OwnerTag =
            LocalData32.Header.OwnerTag;
        m_KdDebuggerData.Header.Size =
            LocalData32.Header.Size;
        
        UIP(KernBase);
        UIP(BreakpointWithStatus);
        UIP(SavedContext);
        CP(ThCallbackStack);
        CP(NextCallback);
        CP(FramePointer);
        CP(PaeEnabled);
        UIP(KiCallUserMode);
        UIP(KeUserCallbackDispatcher);
        UIP(PsLoadedModuleList);
        UIP(PsActiveProcessHead);
        UIP(PspCidTable);
        UIP(ExpSystemResourcesList);
        UIP(ExpPagedPoolDescriptor);
        UIP(ExpNumberOfPagedPools);
        UIP(KeTimeIncrement);
        UIP(KeBugCheckCallbackListHead);
        UIP(KiBugcheckData);
        UIP(IopErrorLogListHead);
        UIP(ObpRootDirectoryObject);
        UIP(ObpTypeObjectType);
        UIP(MmSystemCacheStart);
        UIP(MmSystemCacheEnd);
        UIP(MmSystemCacheWs);
        UIP(MmPfnDatabase);
        UIP(MmSystemPtesStart);
        UIP(MmSystemPtesEnd);
        UIP(MmSubsectionBase);
        UIP(MmNumberOfPagingFiles);
        UIP(MmLowestPhysicalPage);
        UIP(MmHighestPhysicalPage);
        UIP(MmNumberOfPhysicalPages);
        UIP(MmMaximumNonPagedPoolInBytes);
        UIP(MmNonPagedSystemStart);
        UIP(MmNonPagedPoolStart);
        UIP(MmNonPagedPoolEnd);
        UIP(MmPagedPoolStart);
        UIP(MmPagedPoolEnd);
        UIP(MmPagedPoolInformation);
        CP(MmPageSize);
        UIP(MmSizeOfPagedPoolInBytes);
        UIP(MmTotalCommitLimit);
        UIP(MmTotalCommittedPages);
        UIP(MmSharedCommit);
        UIP(MmDriverCommit);
        UIP(MmProcessCommit);
        UIP(MmPagedPoolCommit);
        UIP(MmExtendedCommit);
        UIP(MmZeroedPageListHead);
        UIP(MmFreePageListHead);
        UIP(MmStandbyPageListHead);
        UIP(MmModifiedPageListHead);
        UIP(MmModifiedNoWritePageListHead);
        UIP(MmAvailablePages);
        UIP(MmResidentAvailablePages);
        UIP(PoolTrackTable);
        UIP(NonPagedPoolDescriptor);
        UIP(MmHighestUserAddress);
        UIP(MmSystemRangeStart);
        UIP(MmUserProbeAddress);
        UIP(KdPrintCircularBuffer);
        UIP(KdPrintCircularBufferEnd);
        UIP(KdPrintWritePointer);
        UIP(KdPrintRolloverCount);
        UIP(MmLoadedUserImageList);
        //
        // DO NOT ADD ANY FIELDS HERE
        // The 32 bit structure should not be changed
        //
    }

    //
    // Sanity check the data.
    //

    if (m_KdDebuggerData.Header.OwnerTag != KDBG_TAG)
    {
        dprintf("\nKdDebuggerData.Header.OwnerTag is wrong!!!\n");
    }

    // Update any fields that weren't set from defaults
    // based on the system version information.
    m_Machine->GetDefaultKdData(&m_KdDebuggerData);

    KdOut("ReadKdDataBlock %08lx\n", Status);
    KdOut("KernBase                   %s\n",
          FormatAddr64(m_KdDebuggerData.KernBase));
    KdOut("BreakpointWithStatus       %s\n",
          FormatAddr64(m_KdDebuggerData.BreakpointWithStatus));
    KdOut("SavedContext               %s\n",
          FormatAddr64(m_KdDebuggerData.SavedContext));
    KdOut("ThCallbackStack            %08lx\n",
          m_KdDebuggerData.ThCallbackStack);
    KdOut("NextCallback               %08lx\n",
          m_KdDebuggerData.NextCallback);
    KdOut("FramePointer               %08lx\n",
          m_KdDebuggerData.FramePointer);
    KdOut("PaeEnabled                 %08lx\n",
          m_KdDebuggerData.PaeEnabled);
    KdOut("KiCallUserMode             %s\n",
          FormatAddr64(m_KdDebuggerData.KiCallUserMode));
    KdOut("KeUserCallbackDispatcher   %s\n",
          FormatAddr64(m_KdDebuggerData.KeUserCallbackDispatcher));
    KdOut("PsLoadedModuleList         %s\n",
          FormatAddr64(m_KdDebuggerData.PsLoadedModuleList));
    KdOut("PsActiveProcessHead        %s\n",
          FormatAddr64(m_KdDebuggerData.PsActiveProcessHead));
    KdOut("MmPageSize                 %s\n",
          FormatAddr64(m_KdDebuggerData.MmPageSize));
    KdOut("MmLoadedUserImageList      %s\n",
          FormatAddr64(m_KdDebuggerData.MmLoadedUserImageList));
    KdOut("MmSystemRangeStart         %s\n",
          FormatAddr64(m_KdDebuggerData.MmSystemRangeStart));
    KdOut("KiProcessorBlock           %s\n",
          FormatAddr64(m_KdDebuggerData.KiProcessorBlock));

    return S_OK;
}

HRESULT
TargetInfo::QueryKernelInfo(ThreadInfo* Thread, BOOL LoadImage)
{
    ULONG Result;
    BOOL ReadDataBlock = FALSE;

    if (!Thread)
    {
        return E_INVALIDARG;
    }
    if (IS_USER_TARGET(this))
    {
        return E_UNEXPECTED;
    }

    ProcessInfo* Process = Thread->m_Process;

    // If we know where the data block is go ahead
    // and read it in.  If the read fails it may
    // be due to a bogus data block address.
    // In that case just fall into the symbol loading
    // as we may be able to get the proper data
    // block offset from symbols and read it later.
    if (m_KdDebuggerDataOffset)
    {
        if (ReadKdDataBlock(Process) == S_OK)
        {
            ReadDataBlock = TRUE;
        }
    }

    //
    // Load kernel symbols.
    //
    
    if (LoadImage)
    {
        // Remove any previous kernel image if we know where
        // the kernel image is supposed to be.
        if (m_KdDebuggerData.KernBase)
        {
            Process->DeleteImageByBase(m_KdDebuggerData.KernBase);
        }

        //
        // Reload the kernel.  Reload may be calling QueryKernelInfo
        // so this may be a recursive call to Reload.  It's restricted
        // to just reloading the kernel, though, so we cannot recurse again.
        //

        PCSTR ArgsRet;
        
        if (Reload(Thread, KERNEL_MODULE_NAME, &ArgsRet) == E_INVALIDARG)
        {
            // The most likely cause of this is missing paths.
            // We don't necessarily need a path to load
            // the kernel, so try again and ignore path problems.
            Reload(Thread, "-P "KERNEL_MODULE_NAME, &ArgsRet);
        }
    }

    //
    // If we haven't already loaded the data block we can now try
    // and find the data block using symbols.
    //

    if (!ReadDataBlock)
    {
        if (!GetOffsetFromSym(Process,
                              "nt!KdDebuggerDataBlock",
                              &m_KdDebuggerDataOffset, NULL))
        {
            m_KdDebuggerDataOffset = 0;
        }
    
        if (ReadKdDataBlock(Process) == S_OK)
        {
            ReadDataBlock = TRUE;
        }
    }

    // The KD version and KdDebuggerData blocks should agree.
    if (ReadDataBlock &&
        (m_KdVersion.KernBase != m_KdDebuggerData.KernBase ||
         m_KdVersion.PsLoadedModuleList !=
         m_KdDebuggerData.PsLoadedModuleList))
    {
        ErrOut("Debugger can not determine kernel base address\n");
    }
    
    if (m_MachineType == IMAGE_FILE_MACHINE_IA64)
    {
        //
        // Try to determine the kernel base virtual mapping address
        // for IA64.  This should be done as early as possible
        // to enable later virtual translations to work.
        //

        if (!IS_KERNEL_TRIAGE_DUMP(this))
        {
            if (!m_KdDebuggerData.MmSystemParentTablePage)
            {
                GetOffsetFromSym(Process, "nt!MmSystemParentTablePage",
                                 &m_KdDebuggerData.MmSystemParentTablePage,
                                 NULL);
            }

            if (m_KdDebuggerData.MmSystemParentTablePage)
            {
                ULONG64 SysPtp;

                if (ReadAllVirtual(Process,
                                   m_KdDebuggerData.MmSystemParentTablePage,
                                   &SysPtp, sizeof(SysPtp)) == S_OK)
                {
                    ((Ia64MachineInfo*)m_Machines[MACHIDX_IA64])->
                        SetKernelPageDirectory(SysPtp << IA64_VALID_PFN_SHIFT);
                }
            }
        }

        //
        // Get the system call address from the debugger data block
        // Added around build 2204.
        // Default to symbols otherwise.
        //

        m_SystemCallVirtualAddress = 0;

        if (m_KdDebuggerData.KiNormalSystemCall)
        {
            if (ReadPointer(Process, m_Machine,
                            m_KdDebuggerData.KiNormalSystemCall,
                            &m_SystemCallVirtualAddress) != S_OK)
            {
                m_SystemCallVirtualAddress = 0;
            }
        }

        if (!m_SystemCallVirtualAddress)
        {
            GetOffsetFromSym(Process, "nt!KiNormalSystemCall",
                             &m_SystemCallVirtualAddress,
                             NULL);
        }

        if (!m_SystemCallVirtualAddress)
        {
            GetOffsetFromSym(Process, "nt!.KiNormalSystemCall",
                             &m_SystemCallVirtualAddress,
                             NULL);
        }

        if (!m_SystemCallVirtualAddress)
        {
            WarnOut("Could not get KiNormalSystemCall address\n");
        }
    }

    //
    // Now that we have symbols and a data block look
    // for any missing data block entries and try to
    // resolve them from symbols.
    //

    if (!IS_KERNEL_TRIAGE_DUMP(this))
    {
        if (!m_KdDebuggerData.CmNtCSDVersion)
        {
            GetOffsetFromSym(Process, "nt!CmNtCSDVersion",
                             &m_KdDebuggerData.CmNtCSDVersion,
                             NULL);
        }

        // Do an initial check for the CSD version.
        // This may need to be updated later if this
        // is early in boot and the CSD version hasn't
        // been read from the registry yet.
        if (m_KdDebuggerData.CmNtCSDVersion)
        {
            ULONG CmNtCSDVersion;
            
            if (ReadAllVirtual(Process,
                               m_KdDebuggerData.CmNtCSDVersion,
                               &CmNtCSDVersion,
                               sizeof(CmNtCSDVersion)) == S_OK)
            {
                SetNtCsdVersion(m_BuildNumber, CmNtCSDVersion);
            }
        }

        if (m_KdDebuggerData.MmUnloadedDrivers == 0)
        {
            GetOffsetFromSym(Process, "nt!MmUnloadedDrivers",
                             &m_KdDebuggerData.MmUnloadedDrivers,
                             NULL);
        }

        if (m_KdDebuggerData.MmLastUnloadedDriver == 0)
        {
            GetOffsetFromSym(Process, "nt!MmLastUnloadedDriver",
                             &m_KdDebuggerData.MmLastUnloadedDriver,
                             NULL);
        }

        if (m_KdDebuggerData.KiProcessorBlock == 0)
        {
            GetOffsetFromSym(Process, "nt!KiProcessorBlock",
                             &m_KdDebuggerData.KiProcessorBlock,
                             NULL);
        }

        if (m_KdDebuggerData.MmPhysicalMemoryBlock == 0)
        {
            GetOffsetFromSym(Process, "nt!MmPhysicalMemoryBlock",
                             &m_KdDebuggerData.MmPhysicalMemoryBlock,
                             NULL);
        }

        if (m_KdDebuggerData.KeLoaderBlock == 0)
        {
            GetOffsetFromSym(Process, "nt!KeLoaderBlock",
                             &m_KdDebuggerData.KeLoaderBlock,
                             NULL);
        }

        if (m_KdDebuggerData.IopNumTriageDumpDataBlocks == 0)
        {
            GetOffsetFromSym(Process, "nt!IopNumTriageDumpDataBlocks",
                             &m_KdDebuggerData.IopNumTriageDumpDataBlocks,
                             NULL);
        }
        if (m_KdDebuggerData.IopTriageDumpDataBlocks == 0)
        {
            GetOffsetFromSym(Process, "nt!IopTriageDumpDataBlocks",
                             &m_KdDebuggerData.IopTriageDumpDataBlocks,
                             NULL);
        }
    }

    //
    // Try to get the start of system memory.
    // This may be zero because we are looking at an NT 4 system, so try
    // looking it up using symbols.
    //

    if (!m_KdDebuggerData.MmSystemRangeStart)
    {
        GetOffsetFromSym(Process, "nt!MmSystemRangeStart",
                         &m_KdDebuggerData.MmSystemRangeStart,
                         NULL);
    }

    if (m_KdDebuggerData.MmSystemRangeStart)
    {
        if (ReadPointer(Process, m_Machine,
                        m_KdDebuggerData.MmSystemRangeStart,
                        &m_SystemRangeStart) != S_OK)
        {
            m_SystemRangeStart = 0;
        }
    }

    //
    // If we did not have symbols, at least pick a default value.
    //

    if (!m_SystemRangeStart)
    {
        switch(m_MachineType)
        {
        case IMAGE_FILE_MACHINE_IA64:
            m_SystemRangeStart = 0xE000000000000000;
            break;
        default:
            m_SystemRangeStart = 0xFFFFFFFF80000000;
            break;
        }
    }

    if (m_KdDebuggerData.KernBase < m_SystemRangeStart)
    {
        ErrOut("KdDebuggerData.KernBase < SystemRangeStart\n");
    }

    //
    // Read build lab information if possible.
    //
    
    m_BuildLabName[0] = 0;
    Result = 0;
    if (m_KdDebuggerData.NtBuildLab)
    {
        ULONG PreLen;

        strcpy(m_BuildLabName, "Built by: ");
        PreLen = strlen(m_BuildLabName);
        if (ReadVirtual(Process, m_KdDebuggerData.NtBuildLab,
                        m_BuildLabName + PreLen,
                        sizeof(m_BuildLabName) - PreLen - 1,
                        &Result) == S_OK &&
            Result >= 2)
        {
            Result += PreLen;
        }
    }

    DBG_ASSERT(Result < sizeof(m_BuildLabName));
    m_BuildLabName[Result] = 0;

    if (GetProductInfo(&m_ProductType, &m_SuiteMask) != S_OK)
    {
        m_ProductType = INVALID_PRODUCT_TYPE;
        m_SuiteMask = 0;
    }
    
    return S_OK;
}

void
TargetInfo::SetNtCsdVersion(ULONG Build, ULONG CsdVersion)
{
    m_ServicePackNumber = CsdVersion;

    if (CsdVersion == 0)
    {
        m_ServicePackString[0] = 0;
        return;
    }

    PSTR Str = m_ServicePackString;
    *Str = 0;

    if (CsdVersion & 0xFFFF)
    {
        sprintf(Str, "Service Pack %u", (CsdVersion & 0xFF00) >> 8);
        Str += strlen(Str);
        if (CsdVersion & 0xFF)
        {
            *Str++ = 'A' + (char)(CsdVersion & 0xFF) - 1;
            *Str = 0;
        }
    }

    if (CsdVersion & 0xFFFF0000)
    {
        // Prior to 2600 the upper word has two fields for
        // the release.  For XPSPs it's just a release number.
        if (Build >= 2600)
        {
            sprintf(Str, ".%u", CsdVersion >> 16);
        }
        else
        {
            if (CsdVersion & 0xFFFF)
            {
                strcpy(Str, ", ");
                Str += strlen(Str);
            }
            sprintf(Str, "RC %u", (CsdVersion >> 24) & 0xFF);
            Str += strlen(Str);
            if (CsdVersion & 0x00FF0000)
            {
                sprintf(Str, ".%u", (CsdVersion >> 16) & 0xFF);
                Str += strlen(Str);
            }
        }
    }
}

void
TargetInfo::SetKernel32BuildString(ProcessInfo* Process)
{
    m_BuildLabName[0] = 0;
    
    ImageInfo* Image = Process->
        FindImageByName("kernel32", 8, INAME_MODULE, FALSE);
    if (!Image)
    {
        return;
    }
    
    //
    // Try and look up the build lab information from kernel32.
    //
        
    char Item[64];
    ULONG PreLen;
            
    sprintf(Item, "\\StringFileInfo\\%04x%04x\\FileVersion",
            VER_VERSION_TRANSLATION);
    strcpy(m_BuildLabName, "kernel32.dll version: ");
    PreLen = strlen(m_BuildLabName);
    if (FAILED(GetImageVersionInformation
               (Process, Image->m_ImagePath, Image->m_BaseOfImage,
                Item, m_BuildLabName + PreLen,
                sizeof(m_BuildLabName) - PreLen, NULL)))
    {
        m_BuildLabName[0] = 0;
    }
}

HRESULT
TargetInfo::CreateVirtualProcess(ULONG Threads)
{
    HRESULT Status;
    ProcessInfo* Process;
    ULONG Id;
    
    // Create the virtual process.  Add the system ID
    // to the fake process ID base to keep each system's
    // fake processes separate from each other.
    Id = VIRTUAL_PROCESS_ID_BASE + m_UserId;
    Process = new ProcessInfo(this, Id,
                              VIRTUAL_PROCESS_HANDLE(Id),
                              (ULONG64)VIRTUAL_PROCESS_HANDLE(Id),
                              0, DEBUG_PROCESS_ONLY_THIS_PROCESS);
    if (!Process)
    {
        return E_OUTOFMEMORY;
    }

    if ((Status = Process->CreateVirtualThreads(0, Threads)) != S_OK)
    {
        delete Process;
    }

    return Status;
}

ProcessInfo*
TargetInfo::FindProcessByUserId(ULONG Id)
{
    ProcessInfo* Process;
    
    ForTargetProcesses(this)
    {
        if (Process->m_UserId == Id)
        {
            return Process;
        }
    }
    return NULL;
}

ProcessInfo*
TargetInfo::FindProcessBySystemId(ULONG Id)
{
    ProcessInfo* Process;
    
    ForTargetProcesses(this)
    {
        if (Process->m_SystemId == Id)
        {
            return Process;
        }
    }
    return NULL;
}

ProcessInfo*
TargetInfo::FindProcessByHandle(ULONG64 Handle)
{
    ProcessInfo* Process;
    
    ForTargetProcesses(this)
    {
        if (Process->m_SysHandle == Handle)
        {
            return Process;
        }
    }
    return NULL;
}

void
TargetInfo::InsertProcess(ProcessInfo* Process)
{
    ProcessInfo* Cur;
    ProcessInfo* Prev;

    Prev = NULL;
    for (Cur = m_ProcessHead; Cur; Cur = Cur->m_Next)
    {
        if (Cur->m_UserId > Process->m_UserId)
        {
            break;
        }

        Prev = Cur;
    }
        
    Process->m_Next = Cur;
    if (!Prev)
    {
        m_ProcessHead = Process;
    }
    else
    {
        Prev->m_Next = Process;
    }

    m_NumProcesses++;
    Process->m_Target = this;
    if (!m_CurrentProcess)
    {
        m_CurrentProcess = Process;
    }

    m_TotalNumberThreads += Process->m_NumThreads;
    if (Process->m_NumThreads > m_MaxThreadsInProcess)
    {
        m_MaxThreadsInProcess = Process->m_NumThreads;
    }
    m_AllProcessFlags |= Process->m_Flags;
}

void
TargetInfo::RemoveProcess(ProcessInfo* Process)
{
    ProcessInfo* Cur;
    ProcessInfo* Prev;

    Prev = NULL;
    for (Cur = m_ProcessHead; Cur; Cur = Cur->m_Next)
    {
        if (Cur == Process)
        {
            break;
        }

        Prev = Cur;
    }

    if (!Cur)
    {
        return;
    }
    
    if (!Prev)
    {
        m_ProcessHead = Process->m_Next;
    }
    else
    {
        Prev->m_Next = Process->m_Next;
    }

    m_NumProcesses--;
    Process->m_Target = NULL;
    if (m_CurrentProcess == Process)
    {
        m_CurrentProcess = m_ProcessHead;
    }

    ResetAllProcessInfo();
}

void
TargetInfo::ResetAllProcessInfo(void)
{
    ProcessInfo* Process;
    
    m_TotalNumberThreads = 0;
    m_AllProcessFlags = 0;
    m_MaxThreadsInProcess = 0;
    ForTargetProcesses(this)
    {
        m_TotalNumberThreads += Process->m_NumThreads;
        m_AllProcessFlags |= Process->m_Flags;
        if (Process->m_NumThreads > m_MaxThreadsInProcess)
        {
            m_MaxThreadsInProcess = Process->m_NumThreads;
        }
    }
}

void
TargetInfo::AddThreadToAllProcessInfo(ProcessInfo* Process,
                                      ThreadInfo* Thread)
{
    m_TotalNumberThreads++;
    if (Process->m_NumThreads > m_MaxThreadsInProcess)
    {
        m_MaxThreadsInProcess = Process->m_NumThreads;
    }
}

BOOL
TargetInfo::DeleteExitedInfos(void)
{
    ProcessInfo* Process;
    ProcessInfo* ProcessNext;
    BOOL DeletedSomething = FALSE;

    for (Process = m_ProcessHead; Process; Process = ProcessNext)
    {
        ProcessNext = Process->m_Next;
        
        if (Process->m_Exited)
        {
            delete Process;
            DeletedSomething = TRUE;
        }
        else
        {
            if (Process->DeleteExitedInfos())
            {
                DeletedSomething = TRUE;
            }
        }
    }

    return DeletedSomething;
}

void
TargetInfo::InvalidateMemoryCaches(BOOL VirtOnly)
{
    ProcessInfo* Process;

    ForTargetProcesses(this)
    {
        Process->m_VirtualCache.Empty();
    }

    if (!VirtOnly)
    {
        m_PhysicalCache.Empty();
    }
}

void
TargetInfo::SetSystemVersionAndBuild(ULONG Build, ULONG PlatformId)
{
    switch(PlatformId)
    {
    case VER_PLATFORM_WIN32_NT:
        m_ActualSystemVersion = NtBuildToSystemVersion(Build);
        m_SystemVersion = m_ActualSystemVersion;
        break;

    case VER_PLATFORM_WIN32_WINDOWS:
        // Win9x puts the major and minor versions in the high word
        // of the build number so mask them off.
        Build &= 0xffff;
        m_ActualSystemVersion = Win9xBuildToSystemVersion(Build);
        // Win98SE was the first Win9x version to support
        // the extended registers thread context flag.
        if (m_ActualSystemVersion >= W9X_SVER_W98SE)
        {
            m_SystemVersion = NT_SVER_W2K;
        }
        else
        {
            m_SystemVersion = NT_SVER_NT4;
        }
        break;

    case VER_PLATFORM_WIN32_CE:
        m_ActualSystemVersion = WinCeBuildToSystemVersion(Build);
        m_SystemVersion = NT_SVER_NT4;
        break;
    }

    m_BuildNumber = Build;
}

HRESULT
TargetInfo::InitializeForProcessor(void)
{
    HRESULT Status;
    ULONG i;

    //
    // Get the base processor ID for determing what
    // kind of features a processor supports.  The
    // assumption is that the processors in a machine
    // will be similar enough that retrieving this
    // for one processor is sufficient.
    // If this fails we continue on without a processor ID.
    //

    if (!IS_DUMP_TARGET(this))
    {
        GetProcessorId(0, &m_FirstProcessorId);
    }

    // Initialize with whatever processor ID information we have.
    for (i = 0; i < MACHIDX_COUNT; i++)
    {
        if ((Status = m_Machines[i]->InitializeForProcessor()) != S_OK)
        {
            return Status;
        }
    }

    return Status;
}

HRESULT
TargetInfo::InitializeMachines(ULONG MachineType)
{
    HRESULT Status;
    ULONG i;

    if (MachineTypeIndex(MachineType) == MACHIDX_COUNT)
    {
        return E_INVALIDARG;
    }
    
    if (m_KdApi64 != (m_SystemVersion > NT_SVER_NT4))
    {
        WarnOut("Debug API version does not match system version\n");
    }

    if (IsImageMachineType64(MachineType) && !m_KdApi64)
    {
        WarnOut("64-bit machine not using 64-bit API\n");
    }

    //
    // First create the initial machine instances and perform
    // basic initialization.
    //
    
    for (i = 0; i < MACHIDX_COUNT; i++)
    {
        m_Machines[i] = NewMachineInfo(i, MachineType, this);
        if (m_Machines[i] == NULL)
        {
            return E_OUTOFMEMORY;
        }

        if ((Status = m_Machines[i]->Initialize()) != S_OK)
        {
            return Status;
        }
    }

    m_MachineType = MachineType;
    m_Machine = MachineTypeInfo(this, MachineType);

    m_Machine->GetSystemTypeInfo(&m_TypeInfo);
    if (IS_KERNEL_TARGET(this))
    {
        m_Machine->GetDefaultKdData(&m_KdDebuggerData);
    }

    SetEffMachine(m_MachineType, FALSE);
    
    // X86 prefers registers to be displayed at the prompt unless
    // we're on a kernel connection where it would force a context
    // load all the time.
    if (MachineType == IMAGE_FILE_MACHINE_I386 &&
        (IS_DUMP_TARGET(this) || IS_USER_TARGET(this)))
    {
        g_OciOutputRegs = TRUE;
    }

    m_MachinesInitialized = TRUE;

    return S_OK;
}

void
TargetInfo::SetEffMachine(ULONG Machine, BOOL Notify)
{
    BOOL Changed = m_EffMachineType != Machine;
    if (Changed &&
        m_EffMachineType != IMAGE_FILE_MACHINE_UNKNOWN &&
        m_EffMachineType != m_MachineType)
    {
        // If the previous machine was not the target machine
        // it may be an emulated machine that uses the
        // target machine's context.  In that case we need to
        // make sure that any dirty registers it has get flushed
        // so that if the new effective machine is the target
        // machine it'll show changes due to changes through
        // the emulated machine.
        if (m_EffMachine->SetContext() != S_OK)
        {
            // Error already displayed.
            return;
        }
    }

    m_EffMachineType = Machine;
    m_EffMachineIndex = MachineTypeIndex(Machine);
    DBG_ASSERT(m_EffMachineIndex <= MACHIDX_COUNT);
    m_EffMachine = m_Machines[m_EffMachineIndex];

    if (g_Target == this)
    {
        g_Machine = m_EffMachine;
    
        if (Changed && Notify)
        {
            NotifyChangeEngineState(DEBUG_CES_EFFECTIVE_PROCESSOR,
                                    m_EffMachineType, TRUE);
        }
    }
}

void
TargetInfo::ChangeRegContext(ThreadInfo* Thread)
{
    if (Thread && Thread->m_Process->m_Target != this)
    {
        ErrOut("ChangeRegContext to invalid thread\n");
        return;
    }
    
    if (Thread != m_RegContextThread)
    {
        ULONG i;
        
        // Flush any old thread context.
        // We need to be careful when flushing context to
        // NT4 boxes at the initial module load because the
        // system is in a very fragile state and writing
        // back the context generally causes a bugcheck 50.
        if (m_RegContextThread != NULL &&
            m_RegContextThread->m_Handle != NULL &&
            (IS_USER_TARGET(this) ||
             m_ActualSystemVersion != NT_SVER_NT4 ||
             g_LastEventType != DEBUG_EVENT_LOAD_MODULE))
        {
            HRESULT Hr;

            // If we're flushing register context we need to make
            // sure that all machines involved are flushed so
            // that context information actually gets sent to
            // the target.
            // First flush the secondary machines to accumulate
            // context in the primary machine.
            Hr = S_OK;
            for (i = 0; i < MACHIDX_COUNT; i++)
            {
                if (m_Machines[i] != m_Machine)
                {
                    Hr = m_Machines[i]->SetContext();
                    if (Hr != S_OK)
                    {
                        break;
                    }
                }
            }
            // Now flush the primary machine.
            if (Hr == S_OK)
            {
                Hr = m_Machine->SetContext();
            }
            if (Hr != S_OK)
            {
                ErrOut("MachineInfo::SetContext failed - Thread: %N  "
                       "Handle: %I64x  Id: %x - Error == 0x%X\n",
                       m_RegContextThread,
                       m_RegContextThread->m_Handle,
                       m_RegContextThread->m_SystemId,
                       Hr);
            }
        }
        
        m_RegContextThread = Thread;
        if (m_RegContextThread != NULL)
        {
            m_RegContextProcessor = 
                VIRTUAL_THREAD_INDEX(m_RegContextThread->m_Handle);

            // We've now selected a new source of processor data so
            // all machines, both emulated and direct, must be invalidated.
            for (i = 0; i < MACHIDX_COUNT; i++)
            {
                m_Machines[i]->InvalidateContext();
            }
        }
        else
        {
            m_RegContextProcessor = -1;
        }
        
        g_LastSelector = -1;
    }
}

void
TargetInfo::FlushRegContext(void)
{
    ThreadInfo* CurThread = m_RegContextThread;
    ChangeRegContext(NULL);
    ChangeRegContext(CurThread);
}

BOOL
TargetInfo::AnySystemProcesses(BOOL LocalOnly)
{
    ULONG Flags = m_AllProcessFlags;
    
    // There isn't any way to really know that a particular
    // system is local or remote so just always assume
    // local to be conservative.

    if (IS_LIVE_USER_TARGET(this))
    {
        Flags |= ((LiveUserTargetInfo*)this)->m_AllPendingFlags;
    }
    
    return (Flags & ENG_PROC_SYSTEM) != 0;
}

void
TargetInfo::OutputProcessesAndThreads(PSTR Title)
{
    ProcessInfo* Process;
    ThreadInfo* Thread;
    ImageInfo* Image;

    // Kernel mode only has a virtual process and threads right
    // now so it isn't particularly interesting.
    if (IS_KERNEL_TARGET(this))
    {
        return;
    }
    
    VerbOut("OUTPUT_PROCESS: %s\n", Title);
    Process = m_ProcessHead;
    while (Process)
    {
        VerbOut("id: %x  Handle: %I64x  index: %d\n",
                Process->m_SystemId,
                Process->m_SysHandle,
                Process->m_UserId);
        Thread = Process->m_ThreadHead;
        while (Thread)
        {
            VerbOut("  id: %x  hThread: %I64x  index: %d  addr: %s\n",
                    Thread->m_SystemId,
                    Thread->m_Handle,
                    Thread->m_UserId,
                    FormatAddr64(Thread->m_StartOffset));
            Thread = Thread->m_Next;
        }
        Image = Process->m_ImageHead;
        while (Image)
        {
            VerbOut("  hFile: %I64x  base: %s\n",
                    (ULONG64)((ULONG_PTR)Image->m_File),
                    FormatAddr64(Image->m_BaseOfImage));
            Image = Image->m_Next;
        }
        Process = Process->m_Next;
    }
}

void
TargetInfo::OutputProcessInfo(ProcessInfo* Match)
{
    ProcessInfo* Process;

    Process = m_ProcessHead;
    while (Process)
    {
        if (Match == NULL || Match == Process)
        {
            char CurMark;
            PSTR DebugKind;
            
            if (Process == g_Process)
            {
                CurMark = '.';
            }
            else if (Process == g_EventProcess)
            {
                CurMark = '#';
            }
            else
            {
                CurMark = ' ';
            }

            DebugKind = "child";
            if (Process->m_Exited)
            {
                DebugKind = "exited";
            }
            else if (Process->m_Flags & ENG_PROC_ATTACHED)
            {
                DebugKind = (Process->m_Flags & ENG_PROC_SYSTEM) ?
                    "system" : "attach";
            }
            else if (Process->m_Flags & ENG_PROC_CREATED)
            {
                DebugKind = "create";
            }
            else if (Process->m_Flags & ENG_PROC_EXAMINED)
            {
                DebugKind = "examine";
            }
            
            dprintf("%c%3ld\tid: %lx\t%s\tname: %s\n",
                    CurMark,
                    Process->m_UserId,
                    Process->m_SystemId,
                    DebugKind,
                    Process->GetExecutableImageName());
        }
        
        Process = Process->m_Next;
    }
}

void
TargetInfo::OutputVersion(void)
{
    BOOL MpMachine;

    if (IS_USER_TARGET(this))
    {
        dprintf("%s ", SystemVersionName(m_ActualSystemVersion));
    }
    else
    {
        dprintf("%s Kernel ", SystemVersionName(m_ActualSystemVersion));
    }

    dprintf("Version %u", m_BuildNumber);

    //
    // Service packs do not necessarily revise the kernel so
    // the CSD version is actually read from the registry.
    // This means there's a time during boot when the CSD
    // version isn't set.  If the debugger connects then it
    // won't think this is a service pack build.  In order
    // to get around this poll for updates.
    //
    
    if (IS_CONN_KERNEL_TARGET(this) &&
        !m_ServicePackString[0] &&
        m_KdDebuggerData.CmNtCSDVersion)
    {
        ULONG CmNtCSDVersion;
            
        if (ReadAllVirtual(m_ProcessHead,
                           m_KdDebuggerData.CmNtCSDVersion,
                           &CmNtCSDVersion,
                           sizeof(CmNtCSDVersion)) == S_OK)
        {
            SetNtCsdVersion(m_BuildNumber, CmNtCSDVersion);
        }
    }

    // Win9x seems to set the CSD string to a space which isn't
    // very interesting so ignore it.
    if (m_ServicePackString[0] &&
        strcmp(m_ServicePackString, " ") != 0)
    {
        dprintf(" (%s)", m_ServicePackString);
    }

    MpMachine = IS_LIVE_KERNEL_TARGET(this) ?
        ((m_KdVersion.Flags & DBGKD_VERS_FLAG_MP) != 0) :
        (m_NumProcessors > 1);

    dprintf(" %s ", MpMachine ? "MP" : "UP");

    if (MpMachine)
    {
        dprintf("(%d procs) ", m_NumProcessors);
    }

    dprintf("%s %s\n",
            m_CheckedBuild == 0xC ? "Checked" : "Free",
            m_Machine != NULL ?
            m_Machine->m_FullName : "");

    if (m_ProductType != INVALID_PRODUCT_TYPE)
    {
        dprintf("Product: ");
        switch(m_ProductType)
        {
        case NtProductWinNt:
            dprintf("WinNt");
            break;
        case NtProductLanManNt:
            dprintf("LanManNt");
            break;
        case NtProductServer:
            dprintf("Server");
            break;
        default:
            dprintf("<%x>", m_ProductType);
            break;
        }

        if (m_SuiteMask)
        {
            ULONG i;
            
            dprintf(", suite:");
            for (i = 0; i < MaxSuiteType; i++)
            {
                if (m_SuiteMask & (1 << i))
                {
                    if (i < DIMA(g_SuiteMaskNames))
                    {
                        dprintf(" %s", g_SuiteMaskNames[i]);
                    }
                    else
                    {
                        dprintf(" <%x>", (1 << i));
                    }
                }
            }
        }

        dprintf("\n");
    }
    
    if (m_BuildLabName[0])
    {
        dprintf("%s\n", m_BuildLabName);
    }

    if (IS_KERNEL_TARGET(this))
    {
        dprintf("Kernel base = 0x%s PsLoadedModuleList = 0x%s\n",
                FormatAddr64(m_KdDebuggerData.KernBase),
                FormatAddr64(m_KdDebuggerData.PsLoadedModuleList));
    }

    OutputTime();
}

void
TargetInfo::OutputTime(void)
{
    ULONG64 TimeDateN = GetCurrentTimeDateN();
    if (TimeDateN)
    {
        dprintf("Debug session time: %s\n",
                 TimeToStr(FileTimeToTimeDateStamp(TimeDateN)));
    }

    ULONG64 UpTimeN = GetCurrentSystemUpTimeN();
    if (UpTimeN)
    {
        dprintf("System Uptime: %s\n", DurationToStr(UpTimeN));
    }
    else
    {
        dprintf("System Uptime: not available\n");
    }

    if (IS_USER_TARGET(this))
    {
        ULONG64 UpTimeProcessN;

        // In the startup time output we often don't have
        // a process, but some targets don't require one so
        // let the target decide.
        UpTimeProcessN = GetProcessUpTimeN(g_Process);
        if (UpTimeProcessN)
        {
            dprintf("Process Uptime: %s\n", DurationToStr(UpTimeProcessN));
        }
        else
        {
            dprintf("Process Uptime: not available\n");
        }
    }
}

void
TargetInfo::AddSpecificExtensions(void)
{
    // Only notify once for all the adds in this function;
    g_EngNotify++;
    
    //
    // Now that we have determined the type of architecture,
    // we can load the right debugger extensions
    //

    if (m_ActualSystemVersion > BIG_SVER_START &&
        m_ActualSystemVersion < BIG_SVER_END)
    {
        goto Refresh;
    }

    if (m_ActualSystemVersion > XBOX_SVER_START &&
        m_ActualSystemVersion < XBOX_SVER_END)
    {
        AddExtensionDll("kdextx86", FALSE, this, NULL);
        goto Refresh;
    }

    if (m_ActualSystemVersion > NTBD_SVER_START &&
        m_ActualSystemVersion < NTBD_SVER_END)
    {
        goto Refresh;
    }

    if (IS_KERNEL_TARGET(this))
    {
        //
        // Assume kernel mode is NT at this point.
        //
        if (m_MachineType == IMAGE_FILE_MACHINE_IA64)
        {
            //
            // We rely on force loading of extensions at the end of this
            // routine in order to get the entry point the debugger needs.
            //
            AddExtensionDll("wow64exts", FALSE, this, NULL);
        }

        if (m_MachineType == IMAGE_FILE_MACHINE_I386 &&
            m_SystemVersion > NT_SVER_START &&
            m_SystemVersion <= NT_SVER_W2K)
        {
            AddExtensionDll("kdextx86", FALSE, this, NULL);
        }
        else
        {
            //
            // For all new architectures and new X86 builds, load
            // kdexts
            //
            AddExtensionDll("kdexts", FALSE, this, NULL);
        }

        //
        // Extensions that work on all versions of the OS for kernel mode
        // Many of these are messages about legacy extensions.

        AddExtensionDll("kext", FALSE, this, NULL);
    }
    else
    {
        //
        // User mode only extensions.
        //
        
        if (m_ActualSystemVersion > NT_SVER_START &&
            m_ActualSystemVersion < NT_SVER_END)
        {
            AddExtensionDll("ntsdexts", FALSE, this, NULL);
        }
        
        AddExtensionDll("uext", FALSE, this, NULL);
    }

    if (m_ActualSystemVersion > NT_SVER_W2K &&
        m_ActualSystemVersion < NT_SVER_END)
    {
        AddExtensionDll("exts", FALSE, this, NULL);
    }

    // Load ext.dll for all versions
    AddExtensionDll("ext", FALSE, NULL, NULL);

 Refresh:

    // Always load the Dbghelp extensions last so they are first on the list
    AddExtensionDll("dbghelp", FALSE, NULL, NULL);

    EXTDLL *Ext;

    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        LoadExtensionDll(this, Ext);
    }

    g_EngNotify--;
    NotifyChangeEngineState(DEBUG_CES_EXTENSIONS, 0, TRUE);
}

void
TargetInfo::PrepareForExecution(void)
{
    ProcessInfo* Process;

    ChangeRegContext(NULL);

    ForTargetProcesses(this)
    {
        Process->PrepareForExecution();
    }
    
    ResetImplicitData();
    FlushSelectorCache();
    m_PhysicalCache.Empty();

    for (ULONG i = 0; i < MACHIDX_COUNT; i++)
    {
        m_Machines[i]->FlushPerExecutionCaches();
    }
}

//----------------------------------------------------------------------------
//
// LiveKernelTargetInfo.
//
//----------------------------------------------------------------------------

void
LiveKernelTargetInfo::ResetSystemInfo(void)
{
    m_KdMaxPacketType = 0;
    m_KdMaxStateChange = 0;
    m_KdMaxManipulate = 0;
    TargetInfo::ResetSystemInfo();
}

HRESULT
LiveKernelTargetInfo::InitFromKdVersion(void)
{
    HRESULT Status;
    BOOL Ptr64;
    
    if ((Status = GetTargetKdVersion(&m_KdVersion)) != S_OK)
    {
        ErrOut("Debugger can't get KD version information, %s\n",
               FormatStatusCode(Status));
        ZeroMemory(&m_KdVersion, sizeof(m_KdVersion));
        return Status;
    }

    if (DBGKD_MAJOR_TYPE(m_KdVersion.MajorVersion) >= DBGKD_MAJOR_COUNT)
    {
        ErrOut("KD version has unknown kernel type\n");
        ZeroMemory(&m_KdVersion, sizeof(m_KdVersion));
        return E_INVALIDARG;
    }

    if (MachineTypeIndex(m_KdVersion.MachineType) == MACHIDX_COUNT)
    {
        ErrOut("KD version has unknown processor architecture\n");
        ZeroMemory(&m_KdVersion, sizeof(m_KdVersion));
        return E_INVALIDARG;
    }

    Ptr64 =
        ((m_KdVersion.Flags & DBGKD_VERS_FLAG_PTR64) == DBGKD_VERS_FLAG_PTR64);

    // Reloads cause the version to be retrieved but
    // we don't want to completely reinitialize machines
    // in that case as some settings can be lost.  Only
    // reinitialize if there's a need to do so.
    BOOL MustInitializeMachines =
        m_MachineType != m_KdVersion.MachineType ||
        m_Machine == NULL;
    
    m_MachineType = m_KdVersion.MachineType;
    m_BuildNumber = m_KdVersion.MinorVersion;
    m_CheckedBuild = m_KdVersion.MajorVersion & 0xFF;

    //
    // Determine the OS running.
    //
    
    switch(DBGKD_MAJOR_TYPE(m_KdVersion.MajorVersion))
    {
    case DBGKD_MAJOR_NT:
    case DBGKD_MAJOR_TNT:
        m_PlatformId = VER_PLATFORM_WIN32_NT;
        m_ActualSystemVersion = NtBuildToSystemVersion(m_BuildNumber);
        m_SystemVersion = m_ActualSystemVersion;
        break;

    case DBGKD_MAJOR_XBOX:
        m_PlatformId = VER_PLATFORM_WIN32_NT;
        m_ActualSystemVersion = XBOX_SVER_1;
        m_SystemVersion = NT_SVER_W2K;
        break;

    case DBGKD_MAJOR_BIG:
        m_PlatformId = VER_PLATFORM_WIN32_NT;
        m_ActualSystemVersion = BIG_SVER_1;
        m_SystemVersion = NT_SVER_W2K;
        break;

    case DBGKD_MAJOR_EXDI:
        m_PlatformId = VER_PLATFORM_WIN32_NT;
        m_ActualSystemVersion = EXDI_SVER_1;
        m_SystemVersion = NT_SVER_W2K;
        break;

    case DBGKD_MAJOR_NTBD:
        // Special mode for the NT boot debugger where
        // the full system hasn't started yet.
        m_PlatformId = VER_PLATFORM_WIN32_NT;
        m_ActualSystemVersion = NTBD_SVER_XP;
        m_SystemVersion = NtBuildToSystemVersion(m_BuildNumber);
        break;
        
    case DBGKD_MAJOR_EFI:
        m_PlatformId = VER_PLATFORM_WIN32_NT;
        m_ActualSystemVersion = EFI_SVER_1;
        m_SystemVersion = NT_SVER_XP;
        break;
    }

    //
    // Pre-XP kernels didn't set these values so default them appropriately.
    //
    
    m_KdMaxPacketType = m_KdVersion.MaxPacketType;
    if (m_SystemVersion < NT_SVER_XP ||
        m_KdMaxPacketType == 0 ||
        m_KdMaxPacketType > PACKET_TYPE_MAX)
    {
        m_KdMaxPacketType = PACKET_TYPE_KD_CONTROL_REQUEST + 1;
    }
    
    m_KdMaxStateChange = m_KdVersion.MaxStateChange + DbgKdMinimumStateChange;
    if (m_SystemVersion < NT_SVER_XP ||
        m_KdMaxStateChange == DbgKdMinimumStateChange ||
        m_KdMaxStateChange > DbgKdMaximumStateChange)
    {
        m_KdMaxStateChange = DbgKdLoadSymbolsStateChange + 1;
    }

    m_KdMaxManipulate = m_KdVersion.MaxManipulate + DbgKdMinimumManipulate;
    if (m_SystemVersion < NT_SVER_XP ||
        m_KdMaxManipulate == DbgKdMinimumManipulate ||
        m_KdMaxManipulate > DbgKdMaximumManipulate)
    {
        m_KdMaxManipulate = DbgKdCheckLowMemoryApi + 1;
    }

    if (MustInitializeMachines)
    {
        InitializeMachines(m_MachineType);
    }

    m_KdDebuggerData.PsLoadedModuleList = m_KdVersion.PsLoadedModuleList;
    m_KdDebuggerData.KernBase = m_KdVersion.KernBase;

    if (!m_KdVersion.DebuggerDataList)
    {
        // The debugger data list is always NULL early in boot
        // so don't warn repeatedly.  Also, NT4 didn't have
        // a loader block so don't warn at all.
        if (m_SystemVersion > NT_SVER_NT4 &&
            (g_EngErr & ENG_ERR_DEBUGGER_DATA) == 0)
        {
            ErrOut("Debugger data list address is NULL\n");
        }
    }
    // Using NULL for the process disables connected KD's
    // PTE translation.  The non-paged list data does not require
    // it and a virtual translation causes all kinds of side
    // effects that are undesirable at this point in initialization.
    else if (ReadPointer(NULL, m_Machine,
                         m_KdVersion.DebuggerDataList,
                         &m_KdDebuggerDataOffset) != S_OK)
    {
        ErrOut("Unable to read head of debugger data list\n");
        m_KdDebuggerDataOffset = 0;
    }

    KdOut("Target MajorVersion       %08lx\n",
          m_KdVersion.MajorVersion);
    KdOut("Target MinorVersion       %08lx\n",
          m_KdVersion.MinorVersion);
    KdOut("Target ProtocolVersion    %08lx\n",
          m_KdVersion.ProtocolVersion);
    KdOut("Target Flags              %08lx\n",
          m_KdVersion.Flags);
    KdOut("Target MachineType        %08lx\n",
          m_KdVersion.MachineType);
    KdOut("Target MaxPacketType      %x\n",
          m_KdVersion.MaxPacketType);
    KdOut("Target MaxStateChange     %x\n",
          m_KdVersion.MaxStateChange);
    KdOut("Target MaxManipulate      %x\n",
          m_KdVersion.MaxManipulate);
    KdOut("Target KernBase           %s\n",
          FormatAddr64(m_KdVersion.KernBase));
    KdOut("Target PsLoadedModuleList %s\n",
          FormatAddr64(m_KdVersion.PsLoadedModuleList));
    KdOut("Target DebuggerDataList   %s\n",
          FormatAddr64(m_KdVersion.DebuggerDataList));

    dprintf("Connected to %s %d %s target, ptr64 %s\n",
            SystemVersionName(m_ActualSystemVersion),
            m_BuildNumber,
            m_Machine->m_FullName,
            m_Machine->m_Ptr64 ? "TRUE" : "FALSE");

    return S_OK;
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo.
//
//----------------------------------------------------------------------------

void
ConnLiveKernelTargetInfo::ResetSystemInfo(void)
{
    m_SwitchProcessor = 0;
    LiveKernelTargetInfo::ResetSystemInfo();
}

//----------------------------------------------------------------------------
//
// LiveUserTargetInfo.
//
//----------------------------------------------------------------------------

void
LiveUserTargetInfo::DeleteSystemInfo(void)
{
    DiscardPendingProcesses();
    TargetInfo::DeleteSystemInfo();
}
    
HRESULT
LiveUserTargetInfo::SetServices(PUSER_DEBUG_SERVICES Services, BOOL Remote)
{
    HRESULT Status;
    
    if ((Status = Services->Initialize(&m_ServiceFlags)) != S_OK)
    {
        return Status;
    }

    m_Services = Services;
    if (Remote)
    {
        char MachName[MAX_COMPUTERNAME_LENGTH + 1];
        char TransId[DBGRPC_MAX_IDENTITY];
                        
        m_Local = FALSE;
        if (FAILED(Services->
                   GetConnectionInfo(MachName, sizeof(MachName),
                                     NULL, 0,
                                     TransId, sizeof(TransId))))
        {
            strcpy(m_ProcessServer, "<Remote>");
        }
        else
        {
            PrintString(m_ProcessServer, DIMA(m_ProcessServer),
                        "%s (%s)", MachName, TransId);
        }
    }

    return S_OK;
}

HRESULT
LiveUserTargetInfo::InitFromServices(void)
{
    HRESULT Status;
    ULONG Machine;
                
    if ((Status = m_Services->
         GetTargetInfo(&Machine,
                       &m_NumProcessors,
                       &m_PlatformId,
                       &m_BuildNumber,
                       &m_CheckedBuild,
                       m_ServicePackString,
                       sizeof(m_ServicePackString),
                       m_BuildLabName,
                       sizeof(m_BuildLabName),
                       &m_ProductType,
                       &m_SuiteMask)) != S_OK)
    {
        ErrOut("Unable to retrieve target machine information\n");
        return Status;
    }

    SetSystemVersionAndBuild(m_BuildNumber, m_PlatformId);
    m_KdApi64 = m_SystemVersion > NT_SVER_NT4;

    // User mode can retrieve processor information at any time
    // so we can immediately call InitializeForProcessor.
    if ((Status = InitializeMachines(Machine)) != S_OK ||
        (Status = InitializeForProcessor()) != S_OK)
    {
        ErrOut("Unable to initialize target machine information\n");
    }

    return Status;
}

//----------------------------------------------------------------------------
//
// Generic layer support.
//
//----------------------------------------------------------------------------

void
SetLayersFromTarget(TargetInfo* Target)
{
    g_Target = Target;
    g_Process = NULL;
    g_Thread = NULL;
    g_Machine = NULL;
    
    if (g_Target)
    {
        g_Machine = g_Target->m_EffMachine;
        g_Process = g_Target->m_CurrentProcess;
        if (g_Process)
        {
            g_Thread = g_Process->m_CurrentThread;
        }
    }
}

void
SetLayersFromProcess(ProcessInfo* Process)
{
    g_Process = Process;
    g_Target = NULL;
    g_Thread = NULL;
    g_Machine = NULL;
    
    if (g_Process)
    {
        g_Target = g_Process->m_Target;
        g_Machine = g_Target->m_EffMachine;
        g_Thread = g_Process->m_CurrentThread;
    }
}

void
SetLayersFromThread(ThreadInfo* Thread)
{
    g_Thread = Thread;
    g_Target = NULL;
    g_Process = NULL;
    g_Machine = NULL;
    
    if (g_Thread)
    {
        g_Process = g_Thread->m_Process;
        g_Target = g_Process->m_Target;
        g_Machine = g_Target->m_EffMachine;
    }
}

void
SetToAnyLayers(BOOL SetPrompt)
{
    if (!g_Target)
    {
        SetLayersFromTarget(g_TargetHead);
    }
    else if (!g_Process)
    {
        SetLayersFromProcess(g_Target->m_ProcessHead);
    }
    else if (!g_Thread)
    {
        SetLayersFromThread(g_Process->m_ThreadHead);
    }
    if (SetPrompt && g_Thread)
    {
        SetPromptThread(g_Thread, SPT_DEFAULT_OCI_FLAGS);
    }
}

ULONG
FindNextUserId(LAYER Layer)
{
    //
    // It is very common for many layers to be created
    // without any being deleted.  Optimize this case
    // with a simple incremental ID.
    //
    if (g_UserIdFragmented[Layer] == 0)
    {
        ULONG Id = g_HighestUserId[Layer]++;
        return Id;
    }
    
    ULONG UserId = 0;
    TargetInfo* Target;
    ProcessInfo* Process;
    ThreadInfo* Thread;

    //
    // Find the lowest unused ID across all layers.
    // Every layer is given a unique ID to make identification
    // simple and unambiguous.
    //
    
    for (;;)
    {
        BOOL Match = FALSE;
        
        ForTargets()
        {
            if (Layer == LAYER_TARGET)
            {
                if (Target->m_UserId == UserId)
                {
                    Match = TRUE;
                    break;
                }
            }
            else
            {
                ForTargetProcesses(Target)
                {
                    if (Layer == LAYER_PROCESS)
                    {
                        if (Process->m_UserId == UserId)
                        {
                            Match = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        ForProcessThreads(Process)
                        {
                            if (Thread->m_UserId == UserId)
                            {
                                Match = TRUE;
                                break;
                            }
                        }
                        
                        if (Match)
                        {
                            break;
                        }
                    }
                }

                if (Match)
                {
                    break;
                }
            }
        }

        if (Match)
        {
            // There was a match so try the next ID.
            UserId++;
        }
        else
        {
            // No match, use the ID.
            break;
        }
    }

    return UserId;
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

TargetInfo*
FindTargetByUserId(ULONG Id)
{
    TargetInfo* Target;

    ForAllLayersToTarget()
    {
        if (Target->m_UserId == Id)
        {
            return Target;
        }
    }
    return NULL;
}

TargetInfo*
FindTargetBySystemId(ULONG SysId)
{
    TargetInfo* Target;

    ForAllLayersToTarget()
    {
        if (Target->m_SystemId == SysId)
        {
            return Target;
        }
    }

    return NULL;
}

TargetInfo*
FindTargetByServer(ULONG64 Server)
{
    TargetInfo* Target;
    
    ForAllLayersToTarget()
    {
        if (IS_LIVE_USER_TARGET(Target))
        {
            LiveUserTargetInfo* UserTarget = (LiveUserTargetInfo*)Target;
            
            if ((UserTarget->m_Local && Server == 0) ||
                (!UserTarget->m_Local &&
                 (ULONG64)UserTarget->m_Services == Server))
            {
                return Target;
            }
        }
    }
    
    return NULL;
}

void
SuspendAllThreads(void)
{
    TargetInfo* Target;

    ForAllLayersToTarget()
    {
        Target->SuspendThreads();
    }
}

BOOL
ResumeAllThreads(void)
{
    TargetInfo* Target;
    BOOL Error = FALSE;

    ForAllLayersToTarget()
    {
        if (!Target->ResumeThreads())
        {
            Error = TRUE;
        }
    }

    if (Error)
    {
        ErrOut("No active threads to run in event process %d\n",
               g_EventProcess->m_UserId);
        return FALSE;
    }
    
    return TRUE;
}

BOOL
DeleteAllExitedInfos(void)
{
    TargetInfo* Target;
    TargetInfo* TargetNext;
    BOOL DeletedSomething = FALSE;

    for (Target = g_TargetHead; Target; Target = TargetNext)
    {
        TargetNext = Target->m_Next;

        if (Target->m_Exited)
        {
            delete Target;
            DeletedSomething = TRUE;
        }
        else
        {
            if (Target->DeleteExitedInfos())
            {
                DeletedSomething = TRUE;
                Target->OutputProcessesAndThreads("*** exit cleanup ***");
            }
        }
    }

    return DeletedSomething;
}

BOOL
AnyActiveProcesses(BOOL FinalOnly)
{
    TargetInfo* Target;

    ForAllLayersToTarget()
    {
        if (Target->m_ProcessHead ||
            (!FinalOnly &&
             IS_LIVE_USER_TARGET(Target) &&
             ((LiveUserTargetInfo*)Target)->m_ProcessPending))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
AnySystemProcesses(BOOL LocalOnly)
{
    TargetInfo* Target;

    ForAllLayersToTarget()
    {
        if (Target->AnySystemProcesses(LocalOnly))
        {
            return TRUE;
        }
    }

    return FALSE;
}

ULONG
AllProcessFlags(void)
{
    TargetInfo* Target;
    ULONG Flags;

    Flags = 0;
    ForAllLayersToTarget()
    {
        Flags |= Target->m_AllProcessFlags;
    }
    return Flags;
}

BOOL
AnyLiveUserTargets(void)
{
    TargetInfo* Target;

    ForAllLayersToTarget()
    {
        if (IS_LIVE_USER_TARGET(Target))
        {
            return TRUE;
        }
    }

    return FALSE;
}

void
InvalidateAllMemoryCaches(void)
{
    TargetInfo* Target;

    ForAllLayersToTarget()
    {
        Target->InvalidateMemoryCaches(FALSE);
    }
}

HANDLE
GloballyUniqueProcessHandle(TargetInfo* Target, ULONG64 FullHandle)
{
    HANDLE Unique;
    ProcessInfo* Process;
    
    //
    // With multiple systems it's possible for processes
    // from different systems to have the same process handle.
    // dbghelp's module list uses only the basic process handle
    // as an identifier so we have to avoid collisions between
    // process handles among all systems.  This is a very difficult
    // problem in general so we just go for a simple solution
    // that should work most of the time:
    // We primarily care about NT and NT process handles are currently
    // always relatively small integers.  Put the system ID in
    // the topmost 8 bits to give each system its own ID space.
    // This can break at any time, but at the moment it doesn't
    // seem like the underlying assumptions will be invalidated
    // for a long time.
    //

    Unique = (HANDLE)(ULONG_PTR)
        ((Target->m_UserId << 24) | ((ULONG)FullHandle & 0xffffff));

    // Check for uniqueness to make sure.
    ForAllLayersToProcess()
    {
        if (Process->m_SymHandle == Unique)
        {
            ErrOut("ERROR: Ambiguous symbol process handle: %I64x\n",
                   (ULONG64)(ULONG_PTR)Unique);
            return Unique;
        }
    }

    return Unique;
}

ULONG
NtBuildToSystemVersion(ULONG Build)
{
    if (Build > 3499)
    {
        return NT_SVER_NET_SERVER;
    }
    else if (Build > 2195)
    {
        return NT_SVER_XP;
    }
    else if (Build > 2183)
    {
        return NT_SVER_W2K;
    }
    else if (Build > 1381)
    {
        return NT_SVER_W2K_RC3;
    }
    else
    {
        return NT_SVER_NT4;
    }
}

// Taken from http://kbinternal/kb/articles/q158/2/38.htm
//
// Release                   Version                    File dates
//    ---------------------------------------------------------------------
//    Windows 95 retail, OEM    4.00.950                      7/11/95
//    Windows 95 retail SP1     4.00.950A                     7/11/95
//    OEM Service Release 1     4.00.950A                     7/11/95
//    OEM Service Release 2     4.00.1111* (4.00.950B)        8/24/96
//    OEM Service Release 2.1   4.03.1212-1214* (4.00.950B)   8/24/96-8/27/97
//    OEM Service Release 2.5   4.03.1214* (4.00.950C)        8/24/96-11/18/97
//    Windows 98 retail, OEM    4.10.1998                     5/11/98
//    Windows 98 Second Edition 4.10.2222A                    4/23/99

ULONG
Win9xBuildToSystemVersion(ULONG Build)
{
    if (Build > 2222)
    {
        return W9X_SVER_WME;
    }
    else if (Build > 1998)
    {
        return W9X_SVER_W98SE;
    }
    else if (Build > 950)
    {
        return W9X_SVER_W98;
    }
    else
    {
        return W9X_SVER_W95;
    }
}

ULONG
WinCeBuildToSystemVersion(ULONG Build)
{
    return WCE_SVER_CE;
}

PCSTR
SystemVersionName(ULONG Sver)
{
    if (Sver > NT_SVER_START && Sver < NT_SVER_END)
    {
        return g_NtSverNames[Sver - NT_SVER_START - 1];
    }
    else if (Sver > W9X_SVER_START && Sver < W9X_SVER_END)
    {
        return g_W9xSverNames[Sver - W9X_SVER_START - 1];
    }
    else if (Sver > XBOX_SVER_START && Sver < XBOX_SVER_END)
    {
        return g_XBoxSverNames[Sver - XBOX_SVER_START - 1];
    }
    else if (Sver > BIG_SVER_START && Sver < BIG_SVER_END)
    {
        return g_BigSverNames[Sver - BIG_SVER_START - 1];
    }
    else if (Sver > EXDI_SVER_START && Sver < EXDI_SVER_END)
    {
        return g_ExdiSverNames[Sver - EXDI_SVER_START - 1];
    }
    else if (Sver > NTBD_SVER_START && Sver < NTBD_SVER_END)
    {
        return g_NtBdSverNames[Sver - NTBD_SVER_START - 1];
    }
    else if (Sver > EFI_SVER_START && Sver < EFI_SVER_END)
    {
        return g_EfiSverNames[Sver - EFI_SVER_START - 1];
    }
    else if (Sver > WCE_SVER_START && Sver < WCE_SVER_END)
    {
        return g_WceSverNames[Sver - WCE_SVER_START - 1];
    }

    return "Unknown System";
}

void
ParseSystemCommands(void)
{
    TargetInfo* Target;
    char Ch;
    ULONG UserId;
        
    if (!g_Target)
    {
        error(BADSYSTEM);
    }
    
    Ch = PeekChar();

    Target = g_Target;
    g_CurCmd++;
    if (Ch == 0 || Ch == ';')
    {
        Target = NULL;
        g_CurCmd--;
    }
    else if (Ch == '.')
    {
        // Use the current target.
    }
    else if (Ch == '#')
    {
        Target = g_EventTarget;
    }
    else if (Ch == '*')
    {
        Target = NULL;
    }
    else if (Ch == '[')
    {
        g_CurCmd--;
        UserId = (ULONG)GetTermExpression("System ID missing from");
        Target = FindTargetByUserId(UserId);
        if (Target == NULL)
        {
            error(BADSYSTEM);
        }
    }
    else if (Ch >= '0' && Ch <= '9')
    {
        UserId = 0;
        do
        {
            UserId = UserId * 10 + Ch - '0';
            Ch = *g_CurCmd++;
        } while (Ch >= '0' && Ch <= '9');
        g_CurCmd--;
        Target = FindTargetByUserId(UserId);
        if (Target == NULL)
        {
            error(BADSYSTEM);
        }
    }
    else
    {
        g_CurCmd--;
    }
        
    Ch = PeekChar();
    if (Ch == '\0' || Ch == ';')
    {
        TargetInfo* Cur;

        for (Cur = g_TargetHead; Cur; Cur = Cur->m_Next)
        {
            if (Target && Cur != Target)
            {
                continue;
            }

            if (Cur == g_Target)
            {
                Ch = '.';
            }
            else if (Cur == g_EventTarget)
            {
                Ch = '#';
            }
            else
            {
                Ch = ' ';
            }
            dprintf("%c%3d ", Ch, Cur->m_UserId);

            char Buf[2 * MAX_PATH];
            
            Cur->GetDescription(Buf, sizeof(Buf), NULL);
            dprintf("%s\n", Buf);
        }
    }
    else
    {
        g_CurCmd++;
        if (tolower(Ch) == 's')
        {
            if (Target == NULL)
            {
                error(BADSYSTEM);
            }
            if (Target == g_Target)
            {
                return;
            }
            if (Target->m_CurrentProcess == NULL)
            {
                Target->m_CurrentProcess = Target->m_ProcessHead;
                if (Target->m_CurrentProcess == NULL)
                {
                    error(BADSYSTEM);
                }
            }
            if (Target->m_CurrentProcess->m_CurrentThread == NULL)
            {
                Target->m_CurrentProcess->m_CurrentThread =
                    Target->m_CurrentProcess->m_ThreadHead;
                if (Target->m_CurrentProcess->m_CurrentThread == NULL)
                {
                    error(BADSYSTEM);
                }
            }
            Target->SwitchToTarget(g_Target);
        }
        else
        {
            g_CurCmd--;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\target.cpp ===
//----------------------------------------------------------------------------
//
// Abstraction of target-specific information.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

ULONG g_NumberTargets;
TargetInfo* g_TargetHead;

//----------------------------------------------------------------------------
//
// TargetInfo.
//
//----------------------------------------------------------------------------

TargetInfo::TargetInfo(ULONG Class, ULONG Qual, BOOL DynamicEvents)
{
    m_Class = Class;
    m_ClassQualifier = Qual;
    m_DynamicEvents = DynamicEvents;

    m_UserId = FindNextUserId(LAYER_TARGET);
    m_Next = NULL;

    m_NumEvents = 1;
    m_EventIndex = 0;
    m_NextEventIndex = 0;
    m_FirstWait = TRUE;
    m_EventPossible = FALSE;
    m_BreakInMessage = FALSE;

    FlushSelectorCache();

    m_PhysicalCache.SetTarget(this);
    
    PCHAR CacheEnv = getenv("_NT_DEBUG_CACHE_SIZE");
    if (CacheEnv != NULL)
    {
        m_PhysicalCache.m_MaxSize = atol(CacheEnv);
        m_PhysicalCache.m_UserSize = m_PhysicalCache.m_MaxSize;
    }
    
    ResetSystemInfo();
}

TargetInfo::~TargetInfo(void)
{
    DeleteSystemInfo();
    Unlink();
    
    g_UserIdFragmented[LAYER_TARGET]++;

    if (g_Target == this)
    {
        g_Target = NULL;
    }
    if (g_EventTarget == this)
    {
        g_EventTarget = NULL;
        DiscardLastEvent();
    }
}

void
TargetInfo::Link(void)
{
    TargetInfo* Cur;
    TargetInfo* Prev;

    Prev = NULL;
    for (Cur = g_TargetHead; Cur; Cur = Cur->m_Next)
    {
        if (Cur->m_UserId > this->m_UserId)
        {
            break;
        }

        Prev = Cur;
    }
        
    m_Next = Cur;
    if (!Prev)
    {
        g_TargetHead = this;
    }
    else
    {
        Prev->m_Next = this;
    }

    g_NumberTargets++;

    NotifyChangeEngineState(DEBUG_CES_SYSTEMS, m_UserId, TRUE);
}

void
TargetInfo::Unlink(void)
{
    TargetInfo* Cur;
    TargetInfo* Prev;

    Prev = NULL;
    for (Cur = g_TargetHead; Cur; Cur = Cur->m_Next)
    {
        if (Cur == this)
        {
            break;
        }

        Prev = Cur;
    }

    if (!Cur)
    {
        return;
    }
    
    if (!Prev)
    {
        g_TargetHead = this->m_Next;
    }
    else
    {
        Prev->m_Next = this->m_Next;
    }

    g_NumberTargets--;

    NotifyChangeEngineState(DEBUG_CES_SYSTEMS, DEBUG_ANY_ID, TRUE);
}

HRESULT
TargetInfo::Initialize(void)
{
    return S_OK;
}

void
TargetInfo::DebuggeeReset(ULONG Reason, BOOL FromEvent)
{
    if (Reason == DEBUG_SESSION_REBOOT)
    {
        dprintf("Shutdown occurred...unloading all symbol tables.\n");
    }
    else if (Reason == DEBUG_SESSION_HIBERNATE)
    {
        dprintf("Hibernate occurred\n");
    }

    if (FromEvent && g_EventTarget == this)
    {
        g_EngStatus &= ~ENG_STATUS_SUSPENDED;
    }
    
    DeleteSystemInfo();
    ResetSystemInfo();

    // If we were waiting for a shutdown event
    // reset the command state to indicate that
    // we successfully received the shutdown.
    if (FromEvent && SPECIAL_EXECUTION(g_CmdState))
    {
        g_CmdState = 'i';
    }
    
    DiscardedTargets(Reason);
}

HRESULT
TargetInfo::SwitchToTarget(TargetInfo* From)
{
    SetPromptThread(m_CurrentProcess->m_CurrentThread,
                    SPT_DEFAULT_OCI_FLAGS);
    return S_OK;
}

ModuleInfo*
TargetInfo::GetModuleInfo(BOOL UserMode)
{
    if (UserMode)
    {
        switch(m_PlatformId)
        {
        case VER_PLATFORM_WIN32_NT:
            return &g_NtTargetUserModuleIterator;
        case VER_PLATFORM_WIN32_WINDOWS:
        case VER_PLATFORM_WIN32_CE:
            return &g_ToolHelpModuleIterator;
        default:
            ErrOut("System module info not available\n");
            return NULL;
        }
    }
    else
    {
        if (m_PlatformId != VER_PLATFORM_WIN32_NT)
        {
            ErrOut("System module info only available on "
                   "Windows NT/2000/XP\n");
            return NULL;
        }

        DBG_ASSERT(IS_KERNEL_TARGET(this));
        return &g_NtKernelModuleIterator;
    }
}

UnloadedModuleInfo*
TargetInfo::GetUnloadedModuleInfo(void)
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        ErrOut("System unloaded module info only available on "
               "Windows NT/2000/XP\n");
        return NULL;
    }

    if (IS_KERNEL_TARGET(this))
    {
        return &g_NtKernelUnloadedModuleIterator;
    }
    else
    {
        return &g_NtUserUnloadedModuleIterator;
    }
}

HRESULT
TargetInfo::GetImageVersionInformation(ProcessInfo* Process,
                                       PCSTR ImagePath,
                                       ULONG64 ImageBase,
                                       PCSTR Item,
                                       PVOID Buffer, ULONG BufferSize,
                                       PULONG VerInfoSize)
{
    HRESULT Status;
    IMAGE_NT_HEADERS64 NtHdr;

    //
    // This default implementation attempts to read the image's
    // raw version information in memory.
    //

    if ((Status = ReadImageNtHeaders(Process, ImageBase, &NtHdr)) != S_OK)
    {
        return Status;
    }

    if (NtHdr.OptionalHeader.NumberOfRvaAndSizes <=
        IMAGE_DIRECTORY_ENTRY_RESOURCE)
    {
        // No resource information so no version information.
        return E_NOINTERFACE;
    }

    return ReadImageVersionInfo(Process, ImageBase, Item,
                                Buffer, BufferSize, VerInfoSize,
                                &NtHdr.OptionalHeader.
                                DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE]);
}

HRESULT
TargetInfo::Reload(ThreadInfo* Thread,
                   PCSTR Args, PCSTR* ArgsRet)
{
    HRESULT      Status;
    CHAR         AnsiString[MAX_IMAGE_PATH];
    LPSTR        SpecificModule = NULL;
    BOOL         SpecificWild = TRUE;
    ULONG64      Address = 0;
    ULONG        ImageSize = 0;
    PCHAR        Scan;
    ULONG        ModCount;
    BOOL         IgnoreSignature = FALSE;
    ULONG        ReloadSymOptions;
    BOOL         UnloadOnly = FALSE;
    BOOL         ReallyVerbose = FALSE;
    BOOL         LoadUserSymbols = TRUE;
    BOOL         UserModeList = IS_USER_TARGET(this);
    BOOL         ForceSymbolLoad = FALSE;
    BOOL         PrintImageListOnly = FALSE;
    BOOL         AddrLoad = FALSE;
    BOOL         UseDebuggerModuleList;
    BOOL         SkipPathChecks = FALSE;
    ModuleInfo*  ModIter;
    BOOL         Wow64ModLoaded = FALSE;
    HRESULT      RetStatus = S_OK;
    MODULE_INFO_ENTRY ModEntry = {0};
    ProcessInfo* Process;
    ImageInfo*   ImageAdded;

    if ((!IS_USER_TARGET(this) && !IS_KERNEL_TARGET(this)) ||
        !Thread)
    {
        ErrOut("Reload failure, partially initialized target\n");
        return E_UNEXPECTED;
    }

    Process = Thread->m_Process;
        
    // Historically, live user-mode reload has always
    // just used the internal module list so preserve that.
    UseDebuggerModuleList = IS_USER_TARGET(this) && !IS_DUMP_TARGET(this);

    for (;;)
    {
        while (*Args && *Args <= ' ')
        {
            Args++;
        }

        if (*Args != '/' && *Args != '-')
        {
            break;
        }
        
        Args++;
        while (*Args > ' ' && *Args != ';')
        {
            switch(*Args++)
            {
            case 'a':
                // for internal use only: loads whatever is found at the
                // passed address
                AddrLoad = TRUE;
                break;

            case 'd':
                UseDebuggerModuleList = TRUE;
                break;

            case 'f':
                ForceSymbolLoad = TRUE;
                break;

            case 'i':
                IgnoreSignature = TRUE;
                // We always force symbol loading in this
                // case as we can't delay ignoring the signature.
                ForceSymbolLoad = TRUE;
                break;

            case 'l':
                PrintImageListOnly = TRUE;
                break;

            case 'n':
                LoadUserSymbols = FALSE;
                break;

            case 'P':
                // Internal-only switch.
                SkipPathChecks = TRUE;
                break;
                    
            case 's':
                UseDebuggerModuleList = FALSE;
                break;

            case 'u':
                if (!_strnicmp(Args, "ser", 3) &&
                    (Args[3] == ' ' || Args[3] == '\t' || !Args[3]))
                {
                    UserModeList = TRUE;
                    if (!m_SystemRangeStart)
                    {
                        ErrOut("Unknown system range start, "
                               "check kernel symbols\n");
                        *ArgsRet = Args;
                        return E_INVALIDARG;
                    }
                        
                    Args += 3;
                }
                else
                {
                    UnloadOnly = TRUE;
                }
                break;

            case 'v':
                ReallyVerbose = TRUE;
                break;

            case 'w':
                SpecificWild = FALSE;
                break;
                    
            default:
                dprintf("Reload: Unknown option '%c'\n", Args[-1]);

            case '?':
                dprintf("Usage: .reload [flags] [module [= Address "
                        "[, Size] ]]\n");
                dprintf("  Flags:   /d  Use the debugger's module list\n");
                dprintf("               Default for live user-mode "
                        "sessions\n");
                dprintf("           /f  Force immediate symbol load "
                        "instead of deferred\n");
                dprintf("           /i  Force symbol load by ignoring "
                        "mismatches in the pdb signature\n"
                        "               (implies /f)\n");
                dprintf("           /l  Just list the modules.  "
                        "Kernel output same as !drivers\n");
                dprintf("           /n  Do not load from user-mode list "
                        "in kernel sessions\n");
                dprintf("           /s  Use the system's module list\n");
                dprintf("               Default for dump and kernel sessions\n");
                dprintf("           /u  Unload modules, no reload\n");
                dprintf("        /user  Load only user-mode modules "
                        "in kernel sessions\n");
                dprintf("           /v  Verbose\n");
                dprintf("           /w  No wildcard matching on "
                        "module name\n");

                dprintf("\nUse \".hh .reload\" or open debugger.chm in "
                        "the debuggers directory to get\n"
                        "detailed documentation on this command.\n\n");
                
                *ArgsRet = Args;
                return E_INVALIDARG;
            }
        }
    }

    PSTR RawString;
    ULONG RawStringLen;
            
    RawString = BufferStringValue((PSTR*)&Args,
                                  STRV_SPACE_IS_SEPARATOR |
                                  STRV_ALLOW_EMPTY_STRING |
                                  STRV_NO_MODIFICATION,
                                  &RawStringLen, NULL);
    
    *ArgsRet = Args;

    if (!RawString || !RawStringLen)
    {
        AddrLoad = FALSE;
    }
    else
    {
        if (RawStringLen >= DIMA(AnsiString))
        {
            return E_INVALIDARG;
        }

        memcpy(AnsiString, RawString, RawStringLen * sizeof(*RawString));
        AnsiString[RawStringLen] = 0;
            
        //
        // Support .reload <image.ext>=<base>,<size>.
        //

        if (Scan = strchr(AnsiString, '='))
        {
            *Scan++ = 0;

            Address = EvalStringNumAndCatch(Scan);
            if (!Address)
            {
                ErrOut("Invalid address %s\n", Scan);
                return E_INVALIDARG;
            }
            if (!m_Machine->m_Ptr64)
            {
                Address = EXTEND64(Address);
            }

            if (Scan = strchr(Scan, ','))
            {
                Scan++;
                ImageSize = (ULONG)EvalStringNumAndCatch(Scan);
                if (!ImageSize)
                {
                    ErrOut("Invalid ImageSize %s\n", Scan);
                    return E_INVALIDARG;
                }
            }
        }

        if (UnloadOnly)
        {
            BOOL Deleted;
            
            Deleted = Process->
                DeleteImageByName(AnsiString, INAME_MODULE);
            if (!Deleted)
            {
                // The user might have given an image name
                // instead of a module name so try that.
                Deleted = Process->DeleteImageByName
                    (PathTail(AnsiString), INAME_IMAGE_PATH_TAIL);
            }
            if (Deleted)
            {
                dprintf("Unloaded %s\n", AnsiString);
                return S_OK;
            }
            else
            {
                dprintf("Unable to find module '%s'\n", AnsiString);
                return E_NOINTERFACE;
            }
        }

        SpecificModule = _strdup(AnsiString);
        if (!SpecificModule)
        {
            return E_OUTOFMEMORY;
        }
                
        if (IS_KERNEL_TARGET(this) &&
            _stricmp(AnsiString, KERNEL_MODULE_NAME) == 0)
        {
            ForceSymbolLoad = TRUE;
        }
        else
        {
            if (AddrLoad)
            {
                free(SpecificModule);
                SpecificModule = NULL;
            }
        }
    }

    if (!PrintImageListOnly && !SkipPathChecks)
    {
        if (g_SymbolSearchPath == NULL ||
            *g_SymbolSearchPath == NULL)
        {
            dprintf("*********************************************************************\n");
            dprintf("* Symbols can not be loaded because symbol path is not initialized. *\n");
            dprintf("*                                                                   *\n");
            dprintf("* The Symbol Path can be set by:                                    *\n");
            dprintf("*   using the _NT_SYMBOL_PATH environment variable.                 *\n");
            dprintf("*   using the -y <symbol_path> argument when starting the debugger. *\n");
            dprintf("*   using .sympath and .sympath+                                    *\n");
            dprintf("*********************************************************************\n");
            RetStatus = E_INVALIDARG;
            goto FreeSpecMod;
        }

        if (IS_DUMP_WITH_MAPPED_IMAGES(this) &&
            (g_ExecutableImageSearchPath == NULL ||
             *g_ExecutableImageSearchPath == NULL))
        {
            dprintf("*********************************************************************\n");
            dprintf("* Analyzing Minidumps requires access to the actual executable      *\n");
            dprintf("* images for the crashed system                                     *\n");
            dprintf("*                                                                   *\n");
            dprintf("* The Executable Image Path can be set by:                          *\n");
            dprintf("*   using the _NT_EXECUTABLE_IMAGE_PATH environment variable.       *\n");
            dprintf("*   using the -i <image_path> argument when starting the debugger.  *\n");
            dprintf("*   using .exepath and .exepath+                                    *\n");
            dprintf("*********************************************************************\n");
            RetStatus = E_INVALIDARG;
            goto FreeSpecMod;
        }
    }

    //
    // If both the module name and the address are specified, then just load
    // the module right now, as this is only used when normal symbol loading
    // would have failed in the first place.
    //

    if (SpecificModule && Address)
    {
        if (IgnoreSignature)
        {
            ReloadSymOptions = SymGetOptions();
            SymSetOptions(ReloadSymOptions | SYMOPT_LOAD_ANYTHING);
        }

        ModEntry.NamePtr       = SpecificModule,
        ModEntry.Base          = Address;
        ModEntry.Size          = ImageSize;
        ModEntry.CheckSum      = -1;

        if ((RetStatus = Process->
             AddImage(&ModEntry, TRUE, &ImageAdded)) != S_OK)
        {
            ErrOut("Unable to add module at %s\n", FormatAddr64(Address));
        }

        if (IgnoreSignature)
        {
            SymSetOptions(ReloadSymOptions);
        }

        goto FreeSpecMod;
    }

    //
    // Don't unload and reset things if we are looking for a specific module
    // or if we're going to use the existing module list.
    //

    if (SpecificModule == NULL)
    {
        if (!PrintImageListOnly &&
            (!UseDebuggerModuleList || UnloadOnly))
        {
            if (IS_KERNEL_TARGET(this) && UserModeList)
            {
                // This is a .reload /user, so only delete
                // the user-mode modules.
                Process->DeleteImagesBelowOffset(m_SystemRangeStart);
            }
            else
            {
                Process->DeleteImages();
            }
        }

        if (UnloadOnly)
        {
            dprintf("Unloaded all modules\n");
            return S_OK;
        }

        if (!IS_USER_TARGET(this) && !UseDebuggerModuleList)
        {
            if (IS_LIVE_KERNEL_TARGET(this))
            {
                // This is just a refresh and hopefully won't fail.
                ((LiveKernelTargetInfo*)this)->InitFromKdVersion();
            }

            QueryKernelInfo(Thread, TRUE);
        }

        //
        // Print out the correct statement based on the type of output we
        // want to provide
        //

        if (PrintImageListOnly)
        {
            if (UseDebuggerModuleList)
            {
                dprintf("Debugger Module List Summary\n");
            }
            else
            {
                dprintf("System %s Summary\n",
                        IS_USER_TARGET(this) ? "Image" : "Driver and Image");
            }

            dprintf("Base       ");
            if (m_Machine->m_Ptr64)
            {
                dprintf("         ");
            }
#if 0
            if (Flags & 1)
            {
                dprintf("Code Size       Data Size       Resident  "
                        "Standby   Driver Name\n");
            }
            else if (Flags & 2)
            {
                dprintf("Code  Data  Locked  Resident  Standby  "
                        "Loader Entry  Driver Name\n");
            }
            else
            {
#endif

            if (UseDebuggerModuleList)
            {
                dprintf("Image Size      "
                        "Image Name        Creation Time\n");
            }
            else
            {
                dprintf("Code Size      Data Size      "
                        "Image Name        Creation Time\n");
            }
        }
        else if (UseDebuggerModuleList)
        {
            dprintf("Reloading current modules\n");
        }
        else if (!IS_USER_TARGET(this))
        {
            dprintf("Loading %s Symbols\n",
                    UserModeList ? "User" : "Kernel");
        }
    }

    //
    // Get the beginning of the module list.
    //

    if (UseDebuggerModuleList)
    {
        ModIter = &g_DebuggerModuleIterator;
    }
    else
    {
        ModIter = GetModuleInfo(UserModeList);
    }

    if (ModIter == NULL)
    {
        // Error messages already printed.
        RetStatus = E_UNEXPECTED;
        goto FreeSpecMod;
    }
    if ((Status = ModIter->Initialize(Thread)) != S_OK)
    {
        // Error messages already printed.
        // Fold unprepared-to-reload S_FALSE into S_OK.
        RetStatus = SUCCEEDED(Status) ? S_OK : Status;
        goto FreeSpecMod;
    }

    if (IgnoreSignature)
    {
        ReloadSymOptions = SymGetOptions();
        SymSetOptions(ReloadSymOptions | SYMOPT_LOAD_ANYTHING);
    }

    // Suppress notifications until everything is done.
    g_EngNotify++;

LoadLoop:
    for (ModCount=0; ; ModCount++)
    {
        // Flush regularly so the user knows something is
        // happening during the reload.
        FlushCallbacks();

        if (CheckUserInterrupt())
        {
            break;
        }

        if (ModCount > 1000)
        {
            ErrOut("ModuleList is corrupt - walked over 1000 module entries\n");
            break;
        }

        if (ModEntry.DebugHeader)
        {
            free(ModEntry.DebugHeader);
        }

        ZeroMemory(&ModEntry, sizeof(ModEntry));
        if ((Status = ModIter->GetEntry(&ModEntry)) != S_OK)
        {
            // Error message already printed in error case.
            // Works for end-of-list case also.
            break;
        }

        //
        // Check size of images
        //

        if (!ModEntry.Size)
        {
            VerbOut("Image at %s had size 0\n",
                    FormatAddr64(ModEntry.Base));

            //
            // Override this since we know all images are at least 1 page long
            //

            ModEntry.Size = m_Machine->m_PageSize;
        }

        //
        // Warn if not all the information was gathered
        //

        if (!ModEntry.ImageInfoValid)
        {
            VerbOut("Unable to read image header at %s\n",
                    FormatAddr64(ModEntry.Base));
        }

        //
        // Are we looking for a module at a specific address ?
        //

        if (AddrLoad)
        {
            if (Address < ModEntry.Base ||
                Address >= ModEntry.Base + ModEntry.Size)
            {
                continue;
            }
        }

        if (ModEntry.UnicodeNamePtr)
        {
            ModEntry.NamePtr =
                ConvertAndValidateImagePathW((PWSTR)ModEntry.NamePtr,
                                             ModEntry.NameLength /
                                             sizeof(WCHAR),
                                             ModEntry.Base,
                                             AnsiString,
                                             DIMA(AnsiString));
            ModEntry.UnicodeNamePtr = 0;
        }
        else
        {
            ModEntry.NamePtr =
                ValidateImagePath((PSTR)ModEntry.NamePtr,
                                  ModEntry.NameLength,
                                  ModEntry.Base,
                                  AnsiString,
                                  DIMA(AnsiString));
        }

        //
        // If we are loading a specific module:
        //
        // If the Module is NT, we take the first module in the list as it is
        // guaranteed to be the kernel.  Reset the Base address if it was
        // not set.
        //
        // Otherwise, actually compare the strings and continue if they don't
        // match
        //

        if (SpecificModule)
        {
            if (!UserModeList &&
                _stricmp( SpecificModule, KERNEL_MODULE_NAME ) == 0)
            {
                if (!m_KdVersion.KernBase)
                {
                    m_KdVersion.KernBase = ModEntry.Base;
                }
                if (!m_KdDebuggerData.KernBase)
                {
                    m_KdDebuggerData.KernBase = ModEntry.Base;
                }
            }
            else
            {
                if (!MatchPathTails(SpecificModule, ModEntry.NamePtr,
                                    SpecificWild))
                {
                    continue;
                }
            }
        }

        PCSTR NamePtrTail = PathTail(ModEntry.NamePtr);
        
        if (PrintImageListOnly)
        {
            PCHAR Time;

            //
            // The timestamp in minidumps was corrupt until NT5 RC3
            // The timestamp could also be invalid because it was paged out
            //    in which case it's value is UNKNOWN_TIMESTAMP.

            if (IS_KERNEL_TRIAGE_DUMP(this) &&
                (m_ActualSystemVersion > NT_SVER_START &&
                 m_ActualSystemVersion <= NT_SVER_W2K_RC3))
            {
                Time = "";
            }

            Time = TimeToStr(ModEntry.TimeDateStamp);

            if (UseDebuggerModuleList)
            {
                dprintf("%s %6lx (%4ld k) %12s  %s\n",
                        FormatAddr64(ModEntry.Base), ModEntry.Size,
                        KBYTES(ModEntry.Size), NamePtrTail,
                        Time);
            }
            else
            {
                dprintf("%s %6lx (%4ld k) %5lx (%3ld k) %12s  %s\n",
                        FormatAddr64(ModEntry.Base),
                        ModEntry.SizeOfCode, KBYTES(ModEntry.SizeOfCode),
                        ModEntry.SizeOfData, KBYTES(ModEntry.SizeOfData),
                        NamePtrTail, Time);
            }
        }
        else
        {
            //
            // Don't bother reloading the kernel if we are not specifically
            // asked since we know those symbols were reloaded by the
            // QueryKernelInfo call.
            //

            if (!SpecificModule && !UserModeList &&
                m_KdDebuggerData.KernBase == ModEntry.Base)
            {
                continue;
            }

            if (ReallyVerbose)
            {
                dprintf("AddImage: %s\n DllBase  = %s\n Size     = %08x\n "
                        "Checksum = %08x\n TimeDateStamp = %08x\n",
                        ModEntry.NamePtr, FormatAddr64(ModEntry.Base),
                        ModEntry.Size, ModEntry.CheckSum,
                        ModEntry.TimeDateStamp);
            }
            else
            {
                if (!SpecificModule)
                {
                    dprintf(".");
                }
            }

            if (Address)
            {
                ModEntry.Base = Address;
            }

            if ((RetStatus = Process->
                 AddImage(&ModEntry, ForceSymbolLoad, &ImageAdded)) != S_OK)
            {
                ErrOut("Unable to add module at %s\n",
                       FormatAddr64(ModEntry.Base));
            }
        }

        if (SpecificModule)
        {
            free( SpecificModule );
            goto Notify;
        }

        if (AddrLoad)
        {
            goto Notify;
        }
    }

    if (UseDebuggerModuleList || IS_KERNEL_TARGET(this) || UserModeList)
    {
        // print newline after all the '.'
        dprintf("\n");
    }

    if (!UseDebuggerModuleList && !UserModeList && SpecificModule == NULL)
    {
        // If we just reloaded the kernel modules
        // go through the unloaded module list.
        if (!PrintImageListOnly)
        {
            dprintf("Loading unloaded module list\n");
        }
        ListUnloadedModules(PrintImageListOnly ?
                            LUM_OUTPUT : LUM_OUTPUT_TERSE, NULL);
    }

    //
    // If we got to the end of the kernel symbols, try to load the
    // user mode symbols for the current process.
    //

    if (!UseDebuggerModuleList    &&
        (UserModeList == FALSE)   &&
        (LoadUserSymbols == TRUE) &&
        SUCCEEDED(Status))
    {
        if (!AddrLoad && !SpecificModule)
        {
            dprintf("Loading User Symbols\n");
        }

        UserModeList = TRUE;
        ModIter = GetModuleInfo(UserModeList);
        if (ModIter != NULL && ModIter->Initialize(Thread) == S_OK)
        {
            goto LoadLoop;
        }
    }

    if (!SpecificModule && !Wow64ModLoaded) 
    {
        ModIter = &g_NtWow64UserModuleIterator;
        
        Wow64ModLoaded = TRUE;
        if (ModIter->Initialize(Thread) == S_OK)
        {
            dprintf("Loading Wow64 Symbols\n");
            goto LoadLoop;
        }
    }

    // In the multiple load situation we always return OK
    // since an error wouldn't tell you much about what
    // actually occurred.
    // Specific loads that haven't already been handled are checked
    // right after this.
    RetStatus = S_OK;
    
    //
    // If we still have not managed to load a named file, just pass the name
    // and the address and hope for the best.
    //

    if (SpecificModule && !PrintImageListOnly)
    {
        WarnOut("\nModule \"%s\" was not found in the module list.\n",
                SpecificModule);
        WarnOut("Debugger will attempt to load \"%s\" at given base %s.\n\n",
                SpecificModule, FormatAddr64(Address));
        WarnOut("Please provide the full image name, including the "
                "extension (i.e. kernel32.dll)\nfor more reliable results. "
                "Base address and size overrides can be given as\n"
                ".reload <image.ext>=<base>,<size>.\n");

        ZeroMemory(&ModEntry, sizeof(ModEntry));

        ModEntry.NamePtr       = SpecificModule,
        ModEntry.Base          = Address;
        ModEntry.Size          = ImageSize;

        if ((RetStatus = Process->
             AddImage(&ModEntry, TRUE, &ImageAdded)) != S_OK)
        {
            ErrOut("Unable to add module at %s\n", FormatAddr64(Address));
        }

        free(SpecificModule);
    }

 Notify:
    // If we've gotten this far we've done one or more reloads
    // and postponed notifications.  Do them now that all the work
    // has been done.
    g_EngNotify--;
    if (SUCCEEDED(RetStatus))
    {
        NotifyChangeSymbolState(DEBUG_CSS_LOADS | DEBUG_CSS_UNLOADS, 0,
                                Process);
    }

    if (IgnoreSignature)
    {
        SymSetOptions(ReloadSymOptions);
    }

    if (ModEntry.DebugHeader)
    {
        free(ModEntry.DebugHeader);
    }

    return RetStatus;

 FreeSpecMod:
    free(SpecificModule);
    return RetStatus;
}

ULONG64
TargetInfo::GetCurrentTimeDateN(void)
{
    // No information.
    return 0;
}
 
ULONG64
TargetInfo::GetCurrentSystemUpTimeN(void)
{
    // No information.
    return 0;
}
 
ULONG64
TargetInfo::GetProcessUpTimeN(ProcessInfo* Process)
{
    // No information.
    return 0;
}
 
HRESULT
TargetInfo::GetProcessTimes(ProcessInfo* Process,
                            PULONG64 Create,
                            PULONG64 Exit,
                            PULONG64 Kernel,
                            PULONG64 User)
{
    // No information.
    return E_NOTIMPL;
}

HRESULT
TargetInfo::GetThreadTimes(ThreadInfo* Thread,
                           PULONG64 Create,
                           PULONG64 Exit,
                           PULONG64 Kernel,
                           PULONG64 User)
{
    // No information.
    return E_NOTIMPL;
}

HRESULT
TargetInfo::GetProductInfo(PULONG ProductType, PULONG SuiteMask)
{
    if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        return ReadSharedUserProductInfo(ProductType, SuiteMask);
    }
    else
    {
        return E_NOTIMPL;
    }
}

HRESULT
TargetInfo::GetEventIndexDescription(IN ULONG Index,
                                     IN ULONG Which,
                                     IN OPTIONAL PSTR Buffer,
                                     IN ULONG BufferSize,
                                     OUT OPTIONAL PULONG DescSize)
{
    switch(Which)
    {
    case DEBUG_EINDEX_NAME:
        return FillStringBuffer("Default", 0,
                                Buffer, BufferSize, DescSize);
    default:
        return E_INVALIDARG;
    }
}

HRESULT
TargetInfo::WaitInitialize(ULONG Flags,
                           ULONG Timeout,
                           WAIT_INIT_TYPE Type,
                           PULONG DesiredTimeout)
{
    // Placeholder.
    return S_OK;
}

HRESULT
TargetInfo::ReleaseLastEvent(ULONG ContinueStatus)
{
    // Placeholder.
    return S_OK;
}

HRESULT
TargetInfo::ClearBreakIn(void)
{
    // Placeholder.
    return S_OK;
}

//----------------------------------------------------------------------------
//
// LiveKernelTargetInfo miscellaneous methods.
//
// Data space methods and system objects methods are elsewhere.
//
//----------------------------------------------------------------------------

LiveKernelTargetInfo::LiveKernelTargetInfo(ULONG Qual, BOOL DynamicEvents)
        : TargetInfo(DEBUG_CLASS_KERNEL, Qual, DynamicEvents)
{
    m_ConnectOptions = NULL;
}

HRESULT
LiveKernelTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    ULONG64 BugCheckData;
    ULONG64 Data[5];
    HRESULT Status;
    ULONG Read;

    if (!(BugCheckData = m_KdDebuggerData.KiBugcheckData))
    {
        if (!GetOffsetFromSym(m_ProcessHead,
                              "nt!KiBugCheckData", &BugCheckData, NULL) ||
            !BugCheckData)
        {
            ErrOut("Unable to resolve nt!KiBugCheckData\n");
            return E_NOINTERFACE;
        }
    }

    if (m_Machine->m_Ptr64)
    {
        Status = ReadVirtual(m_ProcessHead, BugCheckData, Data,
                             sizeof(Data), &Read);
    }
    else
    {
        ULONG i;
        ULONG Data32[5];

        Status = ReadVirtual(m_ProcessHead, BugCheckData, Data32,
                             sizeof(Data32), &Read);
        Read *= 2;
        for (i = 0; i < DIMA(Data); i++)
        {
            Data[i] = EXTEND64(Data32[i]);
        }
    }

    if (Status != S_OK || Read != sizeof(Data))
    {
        ErrOut("Unable to read KiBugCheckData\n");
        return Status == S_OK ? E_FAIL : Status;
    }

    *Code = (ULONG)Data[0];
    memcpy(Args, Data + 1, sizeof(Data) - sizeof(ULONG64));
    return S_OK;
}

ULONG64
LiveKernelTargetInfo::GetCurrentTimeDateN(void)
{
    ULONG64 TimeDate;
    
    if (m_ActualSystemVersion > NT_SVER_START &&
        m_ActualSystemVersion < NT_SVER_END &&
        ReadSharedUserTimeDateN(&TimeDate) == S_OK)
    {
        return TimeDate;
    }
    else
    {
        return 0;
    }
}

ULONG64
LiveKernelTargetInfo::GetCurrentSystemUpTimeN(void)
{
    ULONG64 UpTime;
    
    if (m_ActualSystemVersion > NT_SVER_START &&
        m_ActualSystemVersion < NT_SVER_END &&
        ReadSharedUserUpTimeN(&UpTime) == S_OK)
    {
        return UpTime;
    }
    else
    {
        return 0;
    }
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo miscellaneous methods.
//
// Data space methods and system objects methods are elsewhere.
//
//----------------------------------------------------------------------------

ConnLiveKernelTargetInfo::ConnLiveKernelTargetInfo(void)
    : LiveKernelTargetInfo(DEBUG_KERNEL_CONNECTION, TRUE)
{
    m_Transport = NULL;
    ResetConnection();
}

ConnLiveKernelTargetInfo::~ConnLiveKernelTargetInfo(void)
{
    RELEASE(m_Transport);
}

#define BUS_TYPE         "_NT_DEBUG_BUS"
#define DBG_BUS1394_NAME "1394"

HRESULT
ConnLiveKernelTargetInfo::Initialize(void)
{
    HRESULT Status;
    DbgKdTransport* Trans = NULL;
    ULONG Index;

    // Try and find the transport by name.
    Index = ParameterStringParser::
        GetParser(m_ConnectOptions, DBGKD_TRANSPORT_COUNT,
                  g_DbgKdTransportNames);
    if (Index < DBGKD_TRANSPORT_COUNT)
    {
        switch(Index)
        {
        case DBGKD_TRANSPORT_COM:
            Trans = new DbgKdComTransport(this);
            break;
        case DBGKD_TRANSPORT_1394:
            Trans = new DbgKd1394Transport(this);
            break;
        }

        if (!Trans)
        {
            return E_OUTOFMEMORY;
        }
    }

    if (Trans == NULL)
    {
        PCHAR BusType;

        // Couldn't identify the transport from options so check
        // the environment.  Default to com port.
        
        if (BusType = getenv(BUS_TYPE))
        {
            if (strstr(BusType, DBG_BUS1394_NAME))
            {
                Trans = new DbgKd1394Transport(this);
                if (!Trans)
                {
                    return E_OUTOFMEMORY;
                }
            }
        }

        if (!Trans)
        {
            Trans = new DbgKdComTransport(this);
            if (!Trans)
            {
                return E_OUTOFMEMORY;
            }
        }
    }

    // Clear parameter state.
    Trans->ResetParameters();
    
    if (!Trans->ParseParameters(m_ConnectOptions))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        Status = Trans->Initialize();
        if (Status != S_OK)
        {
            ErrOut("Kernel debugger failed initialization, %s\n    \"%s\"\n",
                   FormatStatusCode(Status), FormatStatus(Status));
        }
    }

    if (Status == S_OK)
    {
        m_Transport = Trans;
        // The initial target must always be considered the
        // current partition so that it can successfully
        // attempt the first wait.
        m_CurrentPartition = TRUE;

        Status = LiveKernelTargetInfo::Initialize();
    }
    else
    {
        delete Trans;
    }
    
    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                         PULONG DescLen)
{
    HRESULT Status;
    
    if (m_Transport)
    {
        char Buf[MAX_PATH];

        m_Transport->GetParameters(Buf, sizeof(Buf));
        Status = AppendToStringBuffer(S_OK, "Remote KD: ", TRUE,
                                      &Buffer, &BufferLen, DescLen);
        return AppendToStringBuffer(Status, Buf, FALSE,
                                    &Buffer, &BufferLen, DescLen);
    }
    else
    {
        return FillStringBuffer("", 1,
                                Buffer, BufferLen, DescLen);
    }
}

void
ConnLiveKernelTargetInfo::DebuggeeReset(ULONG Reason, BOOL FromEvent)
{
    if (m_Transport != NULL)
    {
        m_Transport->Restart();
    }

    //
    // If alternate partitions were created get rid of them.
    //

    TargetInfo* Target = FindTargetBySystemId(DBGKD_PARTITION_ALTERNATE);
    if (Target == this)
    {
        Target = FindTargetBySystemId(DBGKD_PARTITION_DEFAULT);
    }
    delete Target;
    
    ResetConnection();
    m_CurrentPartition = TRUE;

    LiveKernelTargetInfo::DebuggeeReset(Reason, FromEvent);
}

HRESULT
ConnLiveKernelTargetInfo::SwitchProcessors(ULONG Processor)
{
    m_SwitchProcessor = Processor + 1;
    g_CmdState = 's';
    // Return S_FALSE to indicate that the switch is pending.
    return S_FALSE;
}

HRESULT
ConnLiveKernelTargetInfo::SwitchToTarget(TargetInfo* From)
{
    if (!IS_CONN_KERNEL_TARGET(From))
    {
        return E_NOTIMPL;
    }

    ((ConnLiveKernelTargetInfo*)From)->m_SwitchTarget = this;
    g_CmdState = 's';
    // Return S_FALSE to indicate that the switch is pending.
    return S_FALSE;
}

HRESULT
ConnLiveKernelTargetInfo::GetTargetKdVersion(PDBGKD_GET_VERSION64 Version)
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_GET_VERSION64 a = &m.u.GetVersion64;
    ULONG rc;

    m.ApiNumber = DbgKdGetVersionApi;
    m.ReturnStatus = STATUS_PENDING;
    a->ProtocolVersion = 1;  // request context records on state changes

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET);

    *Version = Reply->u.GetVersion64;

    KdOut("DbgKdGetVersion returns %08lx\n", Reply->ReturnStatus);
    return CONV_NT_STATUS(Reply->ReturnStatus);
}

HRESULT
ConnLiveKernelTargetInfo::RequestBreakIn(void)
{
    // Tell the waiting thread to break in.
    m_Transport->m_BreakIn = TRUE;
    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::ClearBreakIn(void)
{
    m_Transport->m_BreakIn = FALSE;
    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::Reboot(void)
{
    DBGKD_MANIPULATE_STATE64 m;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdRebootApi;
    m.ReturnStatus = STATUS_PENDING;

    //
    // Send the message.
    //

    m_Transport->WritePacket(&m, sizeof(m),
                             PACKET_TYPE_KD_STATE_MANIPULATE,
                             NULL, 0);
    
    InvalidateMemoryCaches(FALSE);
    DebuggeeReset(DEBUG_SESSION_REBOOT, TRUE);
    
    KdOut("DbgKdReboot returns 0x00000000\n");
    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::Crash(ULONG Code)
{
    DBGKD_MANIPULATE_STATE64 m;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdCauseBugCheckApi;
    m.ReturnStatus = STATUS_PENDING;
    *(PULONG)&m.u = Code;

    m_Transport->WritePacket(&m, sizeof(m),
                             PACKET_TYPE_KD_STATE_MANIPULATE,
                             NULL, 0);
    
    DiscardLastEvent();

    KdOut("DbgKdCrash returns 0x00000000\n");
    return S_OK;
}

void
ConnLiveKernelTargetInfo::ResetConnection(void)
{
    m_CurrentPartition = FALSE;
    m_SwitchTarget = NULL;

    m_KdpSearchPageHits = 0;
    m_KdpSearchPageHitOffsets = 0;
    m_KdpSearchPageHitIndex = 0;
    m_KdpSearchCheckPoint = 0;
    m_KdpSearchInProgress = 0;
    m_KdpSearchStartPageFrame = 0;
    m_KdpSearchEndPageFrame = 0;
    m_KdpSearchAddressRangeStart = 0;
    m_KdpSearchAddressRangeEnd = 0;
    m_KdpSearchPfnValue = 0;
}

//----------------------------------------------------------------------------
//
// LocalLiveKernelTargetInfo miscellaneous methods.
//
// Data space methods and system objects methods are elsewhere.
//
//----------------------------------------------------------------------------

HRESULT
LocalLiveKernelTargetInfo::Initialize(void)
{
    DBGKD_GET_VERSION64 Version;

    // Do a quick check to see if this kernel even
    // supports the necessary debug services.
    if (!NT_SUCCESS(g_NtDllCalls.
                    NtSystemDebugControl(SysDbgQueryVersion, NULL, 0,
                                         &Version, sizeof(Version), NULL)))
    {
        ErrOut("The system does not support local kernel debugging.\n");
        ErrOut("Local kernel debugging requires Windows XP, Administrative\n"
               "privileges, and is not supported by WOW64.\n");
        return E_NOTIMPL;
    }

    return LiveKernelTargetInfo::Initialize();
}

HRESULT
LocalLiveKernelTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                          PULONG DescLen)
{
    return FillStringBuffer("Local KD", 0,
                            Buffer, BufferLen, DescLen);
}

HRESULT
LocalLiveKernelTargetInfo::GetTargetKdVersion(PDBGKD_GET_VERSION64 Version)
{
    NTSTATUS Status = g_NtDllCalls.
        NtSystemDebugControl(SysDbgQueryVersion, NULL, 0,
                             Version, sizeof(*Version), NULL);
    return CONV_NT_STATUS(Status);
}

//----------------------------------------------------------------------------
//
// ExdiLiveKernelTargetInfo miscellaneous methods.
//
// Data space methods and system objects methods are elsewhere.
//
//----------------------------------------------------------------------------

ExdiNotifyRunChange::ExdiNotifyRunChange(void)
{
    m_Event = NULL;
}
    
ExdiNotifyRunChange::~ExdiNotifyRunChange(void)
{
    Uninitialize();
}
    
HRESULT
ExdiNotifyRunChange::Initialize(void)
{
    m_Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_Event == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

void
ExdiNotifyRunChange::Uninitialize(void)
{
    if (m_Event != NULL)
    {
        CloseHandle(m_Event);
        m_Event = NULL;
    }
}

STDMETHODIMP
ExdiNotifyRunChange::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    if (DbgIsEqualIID(IID_IUnknown, InterfaceId) ||
        DbgIsEqualIID(__uuidof(IeXdiClientNotifyRunChg), InterfaceId))
    {
        *Interface = this;
        return S_OK;
    }

    *Interface = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
ExdiNotifyRunChange::AddRef(
    THIS
    )
{
    return 1;
}

STDMETHODIMP_(ULONG)
ExdiNotifyRunChange::Release(
    THIS
    )
{
    return 0;
}

STDMETHODIMP
ExdiNotifyRunChange::NotifyRunStateChange(RUN_STATUS_TYPE ersCurrent,
                                          HALT_REASON_TYPE ehrCurrent,
                                          ADDRESS_TYPE CurrentExecAddress,
                                          DWORD dwExceptionCode)
{
    if (ersCurrent == rsRunning)
    {
        // We're waiting for things to stop so ignore this.
        return S_OK;
    }

    m_HaltReason = ehrCurrent;
    m_ExecAddress = CurrentExecAddress;
    m_ExceptionCode = dwExceptionCode;
    SetEvent(m_Event);

    return S_OK;
}

class ExdiParams : public ParameterStringParser
{
public:
    virtual ULONG GetNumberParameters(void)
    {
        // No need to get.
        return 0;
    }
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize)
    {
    }

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    CLSID m_Clsid;
    EXDI_KD_SUPPORT m_KdSupport;
    BOOL m_ForceX86;
    BOOL m_ExdiDataBreaks;
};

void
ExdiParams::ResetParameters(void)
{
    ZeroMemory(&m_Clsid, sizeof(m_Clsid));
    m_KdSupport = EXDI_KD_NONE;
    m_ForceX86 = FALSE;
    m_ExdiDataBreaks = FALSE;
}

BOOL
ScanExdiDriverList(PCSTR Name, LPCLSID Clsid)
{
    char Pattern[MAX_PARAM_VALUE];

    CopyString(Pattern, Name, DIMA(Pattern));
    _strupr(Pattern);

    HKEY ListKey;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\eXdi\\DriverList", 0,
                     KEY_ALL_ACCESS, &ListKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    ULONG Index = 0;
    BOOL Status = FALSE;
    char ValName[MAX_PARAM_VALUE];
    WCHAR WideValName[MAX_PARAM_VALUE];
    ULONG NameLen, ValLen;
    ULONG Type;
    char Value[MAX_PARAM_VALUE];

    for (;;)
    {
        NameLen = sizeof(ValName);
        ValLen = sizeof(Value);
        if (RegEnumValue(ListKey, Index, ValName, &NameLen, NULL,
                         &Type, (PBYTE)Value, &ValLen) != ERROR_SUCCESS)
        {
            break;
        }

        if (Type == REG_SZ &&
            MatchPattern(Value, Pattern) &&
            MultiByteToWideChar(CP_ACP, 0, ValName, -1, WideValName,
                                sizeof(WideValName) / sizeof(WCHAR)) > 0 &&
            g_Ole32Calls.CLSIDFromString(WideValName, Clsid) == S_OK)
        {
            Status = TRUE;
            break;
        }

        Index++;
    }

    RegCloseKey(ListKey);
    return Status;
}

BOOL
ExdiParams::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_strcmpi(Name, "CLSID"))
    {
        WCHAR WideValue[MAX_PARAM_VALUE];

        if (MultiByteToWideChar(CP_ACP, 0, Value, -1, WideValue,
                                sizeof(WideValue) / sizeof(WCHAR)) == 0)
        {
            return FALSE;
        }
        return g_Ole32Calls.CLSIDFromString(WideValue, &m_Clsid) == S_OK;
    }
    else if (!_strcmpi(Name, "Desc"))
    {
        return ScanExdiDriverList(Value, &m_Clsid);
    }
    else if (!_strcmpi(Name, "DataBreaks"))
    {
        if (!Value)
        {
            return FALSE;
        }

        if (!_strcmpi(Value, "Exdi"))
        {
            m_ExdiDataBreaks = TRUE;
        }
        else if (!_strcmpi(Value, "Default"))
        {
            m_ExdiDataBreaks = FALSE;
        }
        else
        {
            return FALSE;
        }
    }
    else if (!_strcmpi(Name, "ForceX86"))
    {
        m_ForceX86 = TRUE;
    }
    else if (!_strcmpi(Name, "Kd"))
    {
        if (!Value)
        {
            return FALSE;
        }
        
        if (!_strcmpi(Value, "Ioctl"))
        {
            m_KdSupport = EXDI_KD_IOCTL;
        }
        else if (!_strcmpi(Value, "GsPcr"))
        {
            m_KdSupport = EXDI_KD_GS_PCR;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

PCSTR g_ExdiGroupNames[] =
{
    "exdi",
};

ExdiLiveKernelTargetInfo::ExdiLiveKernelTargetInfo(void)
        : LiveKernelTargetInfo(DEBUG_KERNEL_EXDI_DRIVER, TRUE)
{
    m_Server = NULL;
    m_MarshalledServer = NULL;
    m_Context = NULL;
    m_ContextValid = FALSE;
    m_IoctlMin = DBGENG_EXDI_IOC_BEFORE_FIRST;
    m_IoctlMax = DBGENG_EXDI_IOC_BEFORE_FIRST;
    m_BpHit.Type = DBGENG_EXDI_IOCTL_BREAKPOINT_NONE;
}

ExdiLiveKernelTargetInfo::~ExdiLiveKernelTargetInfo(void)
{
    m_RunChange.Uninitialize();
    RELEASE(m_Context);
    RELEASE(m_MarshalledServer);
    RELEASE(m_Server);
    g_Ole32Calls.CoUninitialize();
}

HRESULT
ExdiLiveKernelTargetInfo::Initialize(void)
{
    HRESULT Status;

    // Load ole32.dll so we can call CoCreateInstance.
    if ((Status = InitDynamicCalls(&g_Ole32CallsDesc)) != S_OK)
    {
        return Status;
    }

    ULONG Group;

    Group = ParameterStringParser::
        GetParser(m_ConnectOptions, DIMA(g_ExdiGroupNames), g_ExdiGroupNames);
    if (Group == PARSER_INVALID)
    {
        return E_INVALIDARG;
    }

    ExdiParams Params;

    Params.ResetParameters();
    if (!Params.ParseParameters(m_ConnectOptions))
    {
        return E_INVALIDARG;
    }

    m_KdSupport = Params.m_KdSupport;
    m_ExdiDataBreaks = Params.m_ExdiDataBreaks;

    if (FAILED(Status = g_Ole32Calls.CoInitializeEx(NULL, COM_THREAD_MODEL)))
    {
        return Status;
    }
    if ((Status = g_Ole32Calls.CoCreateInstance(Params.m_Clsid, NULL,
                                                CLSCTX_LOCAL_SERVER,
                                                __uuidof(IeXdiServer),
                                                (PVOID*)&m_Server)) != S_OK)
    {
        goto EH_CoInit;
    }

    if ((Status = g_Ole32Calls.CoMarshalInterThreadInterfaceInStream
         (__uuidof(IeXdiServer), m_Server, &m_MarshalledServer)) != S_OK)
    {
        goto EH_Server;
    }

    if ((Status = m_Server->GetTargetInfo(&m_GlobalInfo)) != S_OK)
    {
        goto EH_MarshalledServer;
    }

    if (Params.m_ForceX86 ||
        m_GlobalInfo.TargetProcessorFamily == PROCESSOR_FAMILY_X86)
    {
        if (!Params.m_ForceX86 &&
            (Status = m_Server->
             QueryInterface(__uuidof(IeXdiX86_64Context),
                            (PVOID*)&m_Context)) == S_OK)
        {
            m_ContextType = EXDI_CTX_AMD64;
            m_ExpectedMachine = IMAGE_FILE_MACHINE_AMD64;
        }
        else if ((Status = m_Server->
                  QueryInterface(__uuidof(IeXdiX86ExContext),
                                 (PVOID*)&m_Context)) == S_OK)
        {
            m_ContextType = EXDI_CTX_X86_EX;
            m_ExpectedMachine = IMAGE_FILE_MACHINE_I386;
        }
        else if ((Status = m_Server->
                  QueryInterface(__uuidof(IeXdiX86Context),
                                 (PVOID*)&m_Context)) == S_OK)
        {
            m_ContextType = EXDI_CTX_X86;
            m_ExpectedMachine = IMAGE_FILE_MACHINE_I386;
        }
        else
        {
            goto EH_MarshalledServer;
        }
    }
    else if (m_GlobalInfo.TargetProcessorFamily == PROCESSOR_FAMILY_IA64)
    {
        if ((Status = m_Server->
             QueryInterface(__uuidof(IeXdiIA64Context),
                            (PVOID*)&m_Context)) == S_OK)
        {
            m_ContextType = EXDI_CTX_IA64;
            m_ExpectedMachine = IMAGE_FILE_MACHINE_IA64;
        }
    }
    else
    {
        Status = E_NOINTERFACE;
        goto EH_MarshalledServer;
    }

    DWORD HwCode, SwCode;
    
    if ((Status = m_Server->GetNbCodeBpAvail(&HwCode, &SwCode)) != S_OK)
    {
        goto EH_Context;
    }

    // We'd prefer to use software code breakpoints for our
    // software code breakpoints so that hardware resources
    // aren't consumed for a breakpoint we don't need to
    // use hardware for.  However, some servers, such as
    // the x86-64 SimNow implementation, do not support
    // software breakpoints.
    // Also, if the number of hardware breakpoints is
    // unbounded, go ahead and let the server choose.
    // SimNow advertises -1 -1 for some reason and
    // this is necessary to get things to work.

    if (SwCode > 0 && HwCode != (DWORD)-1)
    {
        m_CodeBpType = cbptSW;
    }
    else
    {
        m_CodeBpType = cbptAlgo;
    }
    
    if ((Status = m_RunChange.Initialize()) != S_OK)
    {
        goto EH_Context;
    }

    if ((Status = LiveKernelTargetInfo::Initialize()) != S_OK)
    {
        goto EH_RunChange;
    }

    //
    // Check and see if this EXDI implementation supports
    // the extended Ioctl's we've defined.
    //

    DBGENG_EXDI_IOCTL_BASE_IN IoctlIn;
    DBGENG_EXDI_IOCTL_IDENTIFY_OUT IoctlOut;
    ULONG OutUsed;

    IoctlIn.Code = DBGENG_EXDI_IOC_IDENTIFY;
    if (m_Server->
        Ioctl(sizeof(IoctlIn), (PBYTE)&IoctlIn,
              sizeof(IoctlOut), &OutUsed, (PBYTE)&IoctlOut) == S_OK &&
        IoctlOut.Signature == DBGENG_EXDI_IOCTL_IDENTIFY_SIGNATURE)
    {
        m_IoctlMin = IoctlOut.BeforeFirst;
        m_IoctlMax = IoctlOut.AfterLast;

        if (DBGENG_EXDI_IOC_GET_BREAKPOINT_HIT <= m_IoctlMin ||
            DBGENG_EXDI_IOC_GET_BREAKPOINT_HIT >= m_IoctlMax)
        {
            // Can't use EXDI data breakpoints without this ioctl.
            WarnOut("EXDI data breakpoints not supported\n");
            m_ExdiDataBreaks = FALSE;
        }
    }
    
    m_ContextValid = FALSE;
    return S_OK;

 EH_RunChange:
    m_RunChange.Uninitialize();
 EH_Context:
    RELEASE(m_Context);
 EH_MarshalledServer:
    RELEASE(m_MarshalledServer);
 EH_Server:
    RELEASE(m_Server);
 EH_CoInit:
    g_Ole32Calls.CoUninitialize();
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                         PULONG DescLen)
{
    return FillStringBuffer("eXDI KD", 0,
                            Buffer, BufferLen, DescLen);
}

HRESULT
ExdiLiveKernelTargetInfo::SwitchProcessors(ULONG Processor)
{
    HRESULT Status;
    
    if (DBGENG_EXDI_IOC_SET_CURRENT_PROCESSOR <= m_IoctlMin ||
        DBGENG_EXDI_IOC_SET_CURRENT_PROCESSOR >= m_IoctlMax)
    {
        // Switch Ioctl not supported.
        return E_NOTIMPL;
    }

    DBGENG_EXDI_IOCTL_SET_CURRENT_PROCESSOR_IN IoctlIn;
    ULONG OutUsed;

    IoctlIn.Code = DBGENG_EXDI_IOC_SET_CURRENT_PROCESSOR;
    IoctlIn.Processor = Processor;
    if ((Status = m_Server->Ioctl(sizeof(IoctlIn), (PBYTE)&IoctlIn,
                                  0, &OutUsed, (PBYTE)&IoctlIn)) != S_OK)
    {
        ErrOut("Unable to switch processors, %s\n",
               FormatStatusCode(Status));
        return Status;
    }
    
    SetCurrentProcessorThread(this, Processor, FALSE);
    return S_OK;
}

#define EXDI_IOCTL_GET_KD_VERSION ((ULONG)'VDKG')

HRESULT
ExdiLiveKernelTargetInfo::GetTargetKdVersion(PDBGKD_GET_VERSION64 Version)
{
    switch(m_KdSupport)
    {
    case EXDI_KD_IOCTL:
        //
        // User has indicated the target supports the
        // KD version ioctl.
        //

        ULONG Command;
        ULONG Retrieved;
        HRESULT Status;

        Command = EXDI_IOCTL_GET_KD_VERSION;
        if ((Status = m_Server->Ioctl(sizeof(Command), (PBYTE)&Command,
                                      sizeof(*Version), &Retrieved,
                                      (PBYTE)Version)) != S_OK)
        {
            return Status;
        }
        if (Retrieved != sizeof(*Version))
        {
            return E_FAIL;
        }

        // This mode implies a recent kernel so we can
        // assume 64-bit kd.
        m_KdApi64 = TRUE;
        break;

    case EXDI_KD_GS_PCR:
        //
        // User has indicated that a version of NT
        // is running and that the PCR can be accessed
        // through GS.  Look up the version block from
        // the PCR.
        //

        if (m_ExpectedMachine == IMAGE_FILE_MACHINE_AMD64)
        {
            ULONG64 KdVer;
            ULONG Done;
            
            if ((Status = Amd64MachineInfo::
                 StaticGetExdiContext(m_Context, &m_ContextData,
                                      m_ContextType)) != S_OK)
            {
                return Status;
            }
            if ((Status = m_Server->
                 ReadVirtualMemory(m_ContextData.Amd64Context.
                                   DescriptorGs.SegBase +
                                   AMD64_KPCR_KD_VERSION_BLOCK,
                                   sizeof(KdVer), 8, (PBYTE)&KdVer,
                                   &Done)) != S_OK)
            {
                return Status;
            }
            if (Done != sizeof(KdVer))
            {
                return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }
            if ((Status = m_Server->
                 ReadVirtualMemory(KdVer, sizeof(*Version), 8, (PBYTE)Version,
                                   &Done)) != S_OK)
            {
                return Status;
            }
            if (Done != sizeof(*Version))
            {
                return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }

            // This mode implies a recent kernel so we can
            // assume 64-bit kd.
            m_KdApi64 = TRUE;

            // Update the version block's Simulation field to
            // indicate that this is a simulated execution.
            Version->Simulation = DBGKD_SIMULATION_EXDI;
            if ((Status = m_Server->
                 WriteVirtualMemory(KdVer, sizeof(*Version), 8, (PBYTE)Version,
                                    &Done)) != S_OK)
            {
                return Status;
            }
            if (Done != sizeof(*Version))
            {
                return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            }
        }
        else
        {
            return E_INVALIDARG;
        }
        break;

    case EXDI_KD_NONE:
        //
        // Fake up a version structure.
        //

        Version->MajorVersion = DBGKD_MAJOR_EXDI << 8;
        Version->ProtocolVersion = 0;
        Version->Flags = DBGKD_VERS_FLAG_PTR64 | DBGKD_VERS_FLAG_NOMM;
        Version->MachineType = (USHORT)m_ExpectedMachine;
        Version->KernBase = 0;
        Version->PsLoadedModuleList = 0;
        Version->DebuggerDataList = 0;
        break;
    }

    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::RequestBreakIn(void)
{
    //
    // m_Server was created by the session thread but
    // RequestBreakIn can be called from any thread.
    // The thread may not be initialized for multithreading
    // and so we have to explicitly unmarshal the server
    // interface into this thread to make sure that
    // the method call will be successful regardless of
    // the COM threading model for the current thread.
    //

    if (GetCurrentThreadId() == g_SessionThread)
    {
        return m_Server->Halt();
    }
    else
    {
        HRESULT Status;
        IeXdiServer* Server;
        LARGE_INTEGER Move;

        ZeroMemory(&Move, sizeof(Move));
        if ((Status = m_MarshalledServer->
             Seek(Move, STREAM_SEEK_SET, NULL)) != S_OK ||
            (Status = g_Ole32Calls.CoUnmarshalInterface
             (m_MarshalledServer, __uuidof(IeXdiServer),
              (void **)&Server)) != S_OK)
        {
            return Status;
        }

        Status = Server->Halt();

        Server->Release();
        return Status;
    }
}

HRESULT
ExdiLiveKernelTargetInfo::Reboot(void)
{
    HRESULT Status = m_Server->Reboot();
    if (Status == S_OK)
    {
        DebuggeeReset(DEBUG_SESSION_REBOOT, TRUE);
    }
    return Status;
}

ULONG
ExdiLiveKernelTargetInfo::GetCurrentProcessor(void)
{
    if (DBGENG_EXDI_IOC_GET_CURRENT_PROCESSOR <= m_IoctlMin ||
        DBGENG_EXDI_IOC_GET_CURRENT_PROCESSOR >= m_IoctlMax)
    {
        // Ioctl unsupported so assume processor zero.
        return 0;
    }
    
    DBGENG_EXDI_IOCTL_BASE_IN IoctlIn;
    DBGENG_EXDI_IOCTL_GET_CURRENT_PROCESSOR_OUT IoctlOut;
    ULONG OutUsed;

    IoctlIn.Code = DBGENG_EXDI_IOC_GET_CURRENT_PROCESSOR;
    if (m_Server->
        Ioctl(sizeof(IoctlIn), (PBYTE)&IoctlIn,
              sizeof(IoctlOut), &OutUsed, (PBYTE)&IoctlOut) == S_OK)
    {
        return IoctlOut.Processor;
    }

    // Failure, assume processor zero.
    ErrOut("Unable to get current processor\n");
    return 0;
}

//----------------------------------------------------------------------------
//
// UserTargetInfo miscellaneous methods.
//
// Data space methods and system objects methods are elsewhere.
//
//----------------------------------------------------------------------------

LiveUserTargetInfo::LiveUserTargetInfo(ULONG Qual)
    : TargetInfo(DEBUG_CLASS_USER_WINDOWS, Qual, TRUE)
{
    m_Services = NULL;
    m_ServiceFlags = 0;
    strcpy(m_ProcessServer, "<Local>");
    m_Local = TRUE;
    m_DataBpAddrValid = FALSE;
    m_ProcessPending = NULL;
    m_AllPendingFlags = 0;
}

LiveUserTargetInfo::~LiveUserTargetInfo(void)
{
    // Force processes and threads to get cleaned up while
    // the services are still available to close handles.
    DeleteSystemInfo();
    
    RELEASE(m_Services);
}

HRESULT
LiveUserTargetInfo::Initialize(void)
{
    // Nothing to do right now.
    return TargetInfo::Initialize();
}

HRESULT
LiveUserTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen)
{
    HRESULT Status;
    
    Status = AppendToStringBuffer(S_OK, "Live user mode", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    Status = AppendToStringBuffer(Status, ": ", FALSE,
                                  &Buffer, &BufferLen, DescLen);
    Status = AppendToStringBuffer(Status, m_ProcessServer, FALSE,
                                  &Buffer, &BufferLen, DescLen);
    return Status;
}

HRESULT
LiveUserTargetInfo::GetImageVersionInformation(ProcessInfo* Process,
                                               PCSTR ImagePath,
                                               ULONG64 ImageBase,
                                               PCSTR Item,
                                               PVOID Buffer,
                                               ULONG BufferSize,
                                               PULONG VerInfoSize)
{
    HRESULT Status;
    PWSTR FileW;

    if ((Status = AnsiToWide(ImagePath, &FileW)) != S_OK)
    {
        return Status;
    }

    Status = m_Services->
        GetFileVersionInformationA(FileW, Item,
                                   Buffer, BufferSize, VerInfoSize);

    FreeWide(FileW);
    return Status;
}

ULONG64
LiveUserTargetInfo::GetCurrentTimeDateN(void)
{
    ULONG64 TimeDate;

    if (m_Services->GetCurrentTimeDateN(&TimeDate) == S_OK)
    {
        return TimeDate;
    }
    else
    {
        return 0;
    }
}

ULONG64
LiveUserTargetInfo::GetCurrentSystemUpTimeN(void)
{
    ULONG64 UpTime;

    if (m_Services->GetCurrentSystemUpTimeN(&UpTime) == S_OK)
    {
        return UpTime;
    }
    else
    {
        return 0;
    }
}

ULONG64
LiveUserTargetInfo::GetProcessUpTimeN(ProcessInfo* Process)
{
    ULONG64 UpTime;

    if (Process &&
        m_Services->GetProcessUpTimeN(Process->m_SysHandle, &UpTime) == S_OK)
    {
        return UpTime;
    }
    else
    {
        return 0;
    }
}

HRESULT
LiveUserTargetInfo::GetProcessTimes(ProcessInfo* Process,
                                    PULONG64 Create,
                                    PULONG64 Exit,
                                    PULONG64 Kernel,
                                    PULONG64 User)
{
    return m_Services->GetProcessTimes(Process->m_SysHandle,
                                       Create, Exit, Kernel, User);
}

HRESULT
LiveUserTargetInfo::GetThreadTimes(ThreadInfo* Thread,
                                   PULONG64 Create,
                                   PULONG64 Exit,
                                   PULONG64 Kernel,
                                   PULONG64 User)
{
    return m_Services->GetThreadTimes(Thread->m_Handle,
                                      Create, Exit, Kernel, User);
}

HRESULT
LiveUserTargetInfo::RequestBreakIn(void)
{
    ProcessInfo* Process = g_Process;

    if (!Process)
    {
        // No current process, so find any process.
        Process = m_ProcessHead;
        if (!Process)
        {
            return E_UNEXPECTED;
        }
    }

    return m_Services->
        RequestBreakIn(Process->m_SysHandle);
}

//----------------------------------------------------------------------------
//
// Base TargetInfo methods that trivially fail.
//
//----------------------------------------------------------------------------

#define UNEXPECTED_VOID(Class, Method, Args)                    \
void                                                            \
Class::Method Args                                              \
{                                                               \
    ErrOut("TargetInfo::" #Method " is not available in the current debug session\n"); \
}

#define UNEXPECTED_HR(Class, Method, Args)                      \
HRESULT                                                         \
Class::Method Args                                              \
{                                                               \
    ErrOut("TargetInfo::" #Method " is not available in the current debug session\n"); \
    return E_UNEXPECTED;                                        \
}

#define UNEXPECTED_ULONG64(Class, Method, Val, Args)            \
ULONG64                                                         \
Class::Method Args                                              \
{                                                               \
    ErrOut("TargetInfo::" #Method " is not available in the current debug session\n"); \
    return Val;                                                 \
}

UNEXPECTED_HR(TargetInfo, ReadVirtual, (
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    ))
UNEXPECTED_HR(TargetInfo, WriteVirtual, (
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    ))
UNEXPECTED_HR(TargetInfo, ReadPhysical, (
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT OPTIONAL PULONG BytesRead
    ))
UNEXPECTED_HR(TargetInfo, WritePhysical, (
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT OPTIONAL PULONG BytesWritten
    ))
UNEXPECTED_HR(TargetInfo, ReadControl, (
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    ))
UNEXPECTED_HR(TargetInfo, WriteControl, (
    IN ULONG Processor,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    ))
UNEXPECTED_HR(TargetInfo, ReadIo, (
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    ))
UNEXPECTED_HR(TargetInfo, WriteIo, (
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    ))
UNEXPECTED_HR(TargetInfo, ReadMsr, (
    IN ULONG Msr,
    OUT PULONG64 Value
    ))
UNEXPECTED_HR(TargetInfo, WriteMsr, (
    IN ULONG Msr,
    IN ULONG64 Value
    ))
UNEXPECTED_HR(TargetInfo, ReadBusData, (
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    ))
UNEXPECTED_HR(TargetInfo, WriteBusData, (
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    ))
UNEXPECTED_HR(TargetInfo, CheckLowMemory, (
    ))
UNEXPECTED_HR(TargetInfo, GetTargetContext, (
    ULONG64 Thread,
    PVOID Context
    ))
UNEXPECTED_HR(TargetInfo, SetTargetContext, (
    ULONG64 Thread,
    PVOID Context
    ))
UNEXPECTED_HR(TargetInfo, GetThreadIdByProcessor, (
    IN ULONG Processor,
    OUT PULONG Id
    ))
UNEXPECTED_HR(TargetInfo, GetThreadInfoDataOffset, (
    ThreadInfo* Thread,
    ULONG64 ThreadHandle,
    PULONG64 Offset))
UNEXPECTED_HR(TargetInfo, GetProcessInfoDataOffset, (
    ThreadInfo* Thread,
    ULONG Processor,
    ULONG64 ThreadData,
    PULONG64 Offset))
UNEXPECTED_HR(TargetInfo, GetThreadInfoTeb, (
    ThreadInfo* Thread,
    ULONG Processor,
    ULONG64 ThreadData,
    PULONG64 Offset))
UNEXPECTED_HR(TargetInfo, GetProcessInfoPeb, (
    ThreadInfo* Thread,
    ULONG Processor,
    ULONG64 ThreadData,
    PULONG64 Offset))
UNEXPECTED_HR(TargetInfo, GetSelDescriptor, (
    ThreadInfo* Thread,
    MachineInfo* Machine,
    ULONG Selector,
    PDESCRIPTOR64 Desc))
UNEXPECTED_HR(TargetInfo, SwitchProcessors, (
    ULONG Processor))
UNEXPECTED_HR(TargetInfo, GetTargetKdVersion, (
    PDBGKD_GET_VERSION64 Version))
UNEXPECTED_HR(TargetInfo, ReadBugCheckData, (
    PULONG Code, ULONG64 Args[4]))
UNEXPECTED_HR(TargetInfo, GetExceptionContext, (
    PCROSS_PLATFORM_CONTEXT Context))
UNEXPECTED_VOID(TargetInfo, InitializeWatchTrace, (
    void))
UNEXPECTED_VOID(TargetInfo, ProcessWatchTraceEvent, (
    PDBGKD_TRACE_DATA TraceData,
    PADDR PcAddr,
    PBOOL StepOver))
UNEXPECTED_HR(TargetInfo, WaitForEvent, (
    ULONG Flags,
    ULONG Timeout,
    ULONG ElapsedTime,
    PULONG EventStatus))
UNEXPECTED_HR(TargetInfo, RequestBreakIn, (void))
UNEXPECTED_HR(TargetInfo, Reboot, (void))
UNEXPECTED_HR(TargetInfo, Crash, (ULONG Code))
UNEXPECTED_HR(TargetInfo, InsertCodeBreakpoint, (
    ProcessInfo* Process,
    MachineInfo* Machine,
    PADDR Addr,
    ULONG InstrFlags,
    PUCHAR StorageSpace))
UNEXPECTED_HR(TargetInfo, RemoveCodeBreakpoint, (
    ProcessInfo* Process,
    MachineInfo* Machine,
    PADDR Addr,
    ULONG InstrFlags,
    PUCHAR StorageSpace))
UNEXPECTED_HR(TargetInfo, InsertTargetCountBreakpoint, (
    PADDR Addr,
    ULONG Flags))
UNEXPECTED_HR(TargetInfo, RemoveTargetCountBreakpoint, (
    PADDR Addr))
UNEXPECTED_HR(TargetInfo, QueryTargetCountBreakpoint, (
    PADDR Addr,
    PULONG Flags,
    PULONG Calls,
    PULONG MinInstr,
    PULONG MaxInstr,
    PULONG TotInstr,
    PULONG MaxCps))
UNEXPECTED_HR(TargetInfo, QueryMemoryRegion, (
    ProcessInfo* Process,
    PULONG64 Handle,
    BOOL HandleIsOffset,
    PMEMORY_BASIC_INFORMATION64 Info))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\symtype.cpp ===
/*******************************************************************
*
*    Copyright (c) 1999-2002  Microsoft Corporation
*
*    DESCRIPTIO:
*       Use PDB information to get type info and decode a symbol address
*
*    AUTHOR: Kshitiz K. Sharma
*
*    DATE:4/19/1999
*
*******************************************************************/


#include "ntsdp.hpp"
#include "cvconst.h"
#include <windef.h>
#include <time.h>

//
// Define the print routines - normal and verbose
//
#define typPrint      if (!(Options & NO_PRINT)) dprintf64
#define vprintf       if (Options & VERBOSE) typPrint
#define ExtPrint      if ((Options & DBG_RETURN_TYPE_VALUES) && (Options & DBG_RETURN_TYPE)) dprintf64
#define EXT_PRINT_INT64(v) if (((ULONG64) v) >= 10) { ExtPrint("0x%s", FormatDisp64(v));  } else { ExtPrint("%I64lx", (v));}
#define EXT_PRINT_INT(v) ExtPrint((((ULONG) v) >= 10 ? "%#lx" : "%lx"),  (v) )

//
// Store the frequently refeenced types
//
ReferencedSymbolList g_ReferencedSymbols;

ULONG64 LastReadError;
BOOL    g_EnableUnicode = FALSE;
BOOL    g_EnableLongStatus = FALSE;
BOOL    g_PrintDefaultRadix = FALSE;
ULONG   g_TypeOptions;

#define IsAPrimType(typeIndex)       (typeIndex < 0x0fff)

#define IsIdStart(c) ((c=='_') || (c=='!') || ((c>='A') &&  (c<='Z')) || ((c>='a') && (c<='z')))
#define IsIdChar(c) (IsIdStart(c) || isdigit(c))

#define TypeVerbose (Options & VERBOSE)
#define SYM_LOCAL (SYMFLAG_REGISTER | SYMFLAG_REGREL | SYMFLAG_FRAMEREL)

#define NATIVE_TO_BT(TI) \
    (IsDbgNativeType(TI) ? DbgNativeTypeEntry(TI)->CvBase : 0)

//
// Initialise the return type DEBUG_SYMBOL_PARAMETER
//

#define STORE_INFO(ti, addr, sz, sub, saddr) \
    if (m_pInternalInfo->pInfoFound && (!m_pNextSym || !*m_pNextSym) &&       \
       ((m_ParentTag != SymTagPointerType) || (m_pSymPrefix && *m_pSymPrefix == '*')) ) {       \
        PTYPES_INFO_ALL pty = &m_pInternalInfo->pInfoFound->FullInfo;         \
        pty->TypeIndex = ti; pty->Address = addr; pty->SubElements = sub;     \
        pty->Size = sz; pty->SubAddr = saddr;                                 \
    }
#define STORE_PARENT_EXPAND_ADDRINFO(addr)                                                 \
    if (m_pInternalInfo->pInfoFound && (!m_pNextSym || !*m_pNextSym) ) {                    \
       m_pInternalInfo->pInfoFound->ParentExpandAddress = addr;                             \
    }

//
// Copies a length prefix string into name, first byte gives length
//
#define GetLengthPreName(start) {\
    strncpy((char *)(name), (char *)(start)+1, *((UCHAR *)start)); \
    name[*( (UCHAR*) start)]='\0';\
}

#define Indent(nSpaces)                    \
{                                          \
  int i;                                   \
  if (!(Options & (NO_INDENT | DBG_DUMP_COMPACT_OUT))) {           \
     if (!(Options & NO_PRINT)) {                                  \
         StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_TIMESTAMP); \
     }                                     \
     for (i=0;i<nSpaces;++i) {             \
        typPrint(" ");                     \
     }                                     \
  }                                        \
}                                          \

void
ClearAllFastDumps();

ULONG
TypeInfoValueFromSymInfo(PSYMBOL_INFO SymInfo)
{
    ImageInfo* Image = g_Process ?
        g_Process->FindImageByOffset(SymInfo->ModBase, FALSE) : NULL;
    return Image ?
        Image->CvRegToMachine((CV_HREG_e)SymInfo->Register) :
        SymInfo->Register;
}

BOOL
GetThisAdjustForCurrentScope(
    ProcessInfo* Process,
    PULONG thisAdjust
    )
{
    ULONG64 disp;
    PDEBUG_SCOPE Scope = GetCurrentScope();
    SYMBOL_INFO SymInfo = {0};

    SymInfo.SizeOfStruct = sizeof(SYMBOL_INFO);

    if (SymFromAddr(Process->m_SymHandle, Scope->Frame.InstructionOffset, &disp, &SymInfo)) {
        if (SymGetTypeInfo(Process->m_SymHandle, SymInfo.ModBase,
                           SymInfo.TypeIndex, TI_GET_THISADJUST, thisAdjust)) {
            return TRUE;
        }
    }
    return FALSE;
}

LONG64
EvaluateSourceExpression(
    PCHAR pExpr
    )
{
    TypedData Result;

    EvalExpression* RelChain = g_EvalReleaseChain;
    g_EvalReleaseChain = NULL;

    __try
    {
        EvalExpression* Eval = GetCurEvaluator();
        Eval->Evaluate(pExpr, NULL, EXPRF_PREFER_SYMBOL_VALUES,
                       &Result);
        ReleaseEvaluator(Eval);
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        g_EvalReleaseChain = RelChain;
        return 0;
    }

    g_EvalReleaseChain = RelChain;

    if (Result.ConvertToU64())
    {
        return 0;
    }

    return Result.m_S64;
}

ULONG
GetNativeTypeSize(
    PCHAR Name,
    ULONG typeIndex
    )
{
    return IsDbgNativeType(typeIndex) ?
        DbgNativeTypeEntry(typeIndex)->Size : 0;
}

//
// Memory allocation routines for this file
//
PVOID
AllocateMem( ULONG l ) {
    PVOID pBuff = malloc(l);
#if DBG_TYPE
    dprintf ("Alloc'd at %x \n", pBuff);
#endif
    return  pBuff;
}

VOID
FreeMem( PVOID pBuff ) {
#ifdef DBG_TYPE
    dprintf ("Freed at %x \n", pBuff);
    --nAllocates;
#endif
    free ( pBuff );
}

/*
 * ReadTypeData
 *
 *  Reads data from source src to destination des
 *
 */
__inline ULONG
ReadTypeData (
    PUCHAR   des,
    ULONG64  src,
    ULONG    count,
    ULONG    Option
    )
{
    ULONG readCount=0;
    ADDR ad;
    if (src != 0) {
        if (!g_Machine->m_Ptr64 && !(Option & DBG_DUMP_READ_PHYSICAL)) {
            if ((ULONG64)(LONG64)(LONG) src != src) {
                src = (ULONG64) ((LONG64)((LONG) (src)));
            }
        }

        ADDRFLAT(&ad, src);
        if (IS_KERNEL_TARGET(g_Target) && (Option & DBG_DUMP_READ_PHYSICAL)) {
            if (g_Target->ReadPhysical(src, des, count, PHYS_FLAG_DEFAULT,
                                       &readCount) != S_OK) {
                return readCount;
            }
        } else if (g_Target->
                   ReadVirtual(g_Process, src, des, count, &readCount) != S_OK) {
            return readCount;
        }
        return readCount ? readCount : 1;
    }
    return FALSE;
}

//
// Read memory into destination d and store data into m_pInternalInfo->TypeDataPointer
// if Ioctl caller wants some data back
//
#define READ_BYTES(d, s, sz)                                                \
    if (!ReadTypeData((PUCHAR) (d), s, sz, m_pInternalInfo->TypeOptions)) {      \
         m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;                       \
         LastReadError = m_pInternalInfo->InvalidAddress = s; }                  \
    else if (m_pInternalInfo->CopyDataInBuffer && m_pInternalInfo->TypeDataPointer) { \
        memcpy(m_pInternalInfo->TypeDataPointer, d, sz);                         \
        /*d printf("cp %x at %#x ", sz, m_pInternalInfo->TypeDataPointer);  */   \
        m_pInternalInfo->TypeDataPointer += sz;                                  \
    }


void
TypePrintInt(
    ULONG64 Value,
    ULONG Options
    )
{
    if (!(Options & NO_PRINT))
    {
        return;
    }
    switch (g_DefaultRadix)
    {
    case 8:
        dprintf("0t%I64o", Value);
        break;
    case 10:
        dprintf("0n%I64ld", Value);
        break;
    case 16:
        dprintf("0x%I64lx", Value);
        break;
    }
}

PSTR
GetTypePrintIntFmt(
    BOOL b64bit
    )
{
    if (b64bit) {
        switch (g_DefaultRadix)
        {
        case 8:
            return "0t%I64o";
            break;
        case 10:
            return "0n%I64ld";
            break;
        case 16:
            return "0x%I64lx";
            break;
        }
    } else {
        switch (g_DefaultRadix)
        {
        case 8:
            return "0t%o";
            break;
        case 10:
            return "0n%ld";
            break;
        case 16:
            return "0x%lx";
            break;
        }
    }
    return "0x%lx";
}

//
// Reads and data is stored in kernel cache - used when we know we'd eventually
// read all this memory in parts.
//
ULONG
ReadInAdvance(ULONG64 addr, ULONG size, ULONG Options) {
    UCHAR buff[2048];
    ULONG toRead=size, read;

    while (toRead) {
        read = (toRead > sizeof (buff)) ? sizeof(buff) : toRead;
        // This caches the data if sufficient space available
        if (!ReadTypeData(buff, addr, read, Options))
            return FALSE;
        toRead -= read;
    }
    return TRUE;
}

__inline DBG_TYPES
SymTagToDbgType( ULONG SymTag)
{
    switch (SymTag) {
    case SymTagPointerType:
        return DBG_TYP_POINTER;
    case SymTagUDT:
        return DBG_TYP_STRUCT;
    case SymTagArrayType:
        return DBG_TYP_ARRAY;
    case SymTagBaseType:
        return DBG_TYP_NUMBER;
    default:
        break;
    }
    return DBG_TYP_UNKNOWN;
}

//
// Insert a child name at the end of parent name list.
//
BOOL
InsertTypeName(
    PTYPE_NAME_LIST *Top,
    PTYPE_NAME_LIST NameToInsert
    )
{
    PTYPE_NAME_LIST iterator;

    if (!Top) {
        return FALSE;
    }

    NameToInsert->Next = NULL;

    if (*Top == NULL) {
        *Top = NameToInsert;
        return TRUE;
    } else
        for (iterator=*Top; iterator->Next!=NULL; iterator=iterator->Next) ;

    iterator->Next = NameToInsert;

    return TRUE;
}

//
// Remove and return a child name at the end of parent name list.
//
PTYPE_NAME_LIST
RemoveTypeName(
    PTYPE_NAME_LIST *Top
    )
{
    PTYPE_NAME_LIST iterator, itrParent;

    if (!Top) {
        return NULL;
    }

    if (*Top == NULL) {
        return NULL;
    }

    itrParent = NULL;
    for (iterator=*Top; iterator->Next!=NULL; iterator=iterator->Next)
        itrParent=iterator;


    if (itrParent) itrParent->Next = NULL;
    else *Top=NULL;

    return iterator;
}

PCHAR
GetParentName(
    PTYPE_NAME_LIST Top
    )
{
    PTYPE_NAME_LIST iterator, itrParent;

    if (!Top) {
        return NULL;
    }

    itrParent = NULL;
    for (iterator=Top; iterator->Next!=NULL; iterator=iterator->Next)
        itrParent=iterator;


    return iterator->Name;
}

ULONG WStrlen(PWCHAR str)
{
    ULONG result = 0;

    while (*str++ != UNICODE_NULL) {
        result++;
    }

    return result;
}

PCHAR FieldNameEnd(PCHAR Fields)
{
    while (Fields && IsIdChar(*Fields)) {
        ++Fields;
    }
    if (Fields) {
        return Fields;
    }
    return NULL;
}


PCHAR NextFieldName(PCHAR Fields)
{
    BOOL FieldDeLim = FALSE;
    Fields = FieldNameEnd(Fields);
    while (Fields && *Fields) {
        if (*Fields=='.') {
            FieldDeLim = TRUE;
            ++Fields;
            break;
        } else if (!strncmp(Fields,"->", 2)) {
            FieldDeLim = TRUE;
            Fields+=2;
            break;
        }
        ++Fields;
    }
    if (FieldDeLim) {
        return Fields;
    }
    return NULL;
}

void FieldChildOptions(PCHAR ChilField, PTYPE_DUMP_INTERNAL internalOpts)
{
    internalOpts->ArrayElementToDump = 0;
    internalOpts->DeReferencePtr     = 0;

    if (ChilField) {
        switch (*ChilField) {
        case '.':
            // default - do nothing
            break;
        case '[':
            // Array - find which element requested
            ChilField++;
            if (sscanf(ChilField, "%ld", &internalOpts->ArrayElementToDump) == 1) {
                ++internalOpts->ArrayElementToDump;
            }
            break;
        case '-':
            // pointer, check and deref
            if (*(++ChilField) == '>') {
                internalOpts->DeReferencePtr = TRUE;
            }
            break;
        default:
            break;
        }
    }
}
/*
 * MatchField
 *      Routine to check whether a subfield, fName is specified in the fieldlist.
 *      If found, it returns "index of fName in fields"  +  1
 *
 *      *ParentOfField returns non-zero value is "fName" could be parent of some
 *      field in "fields" list.
 */
ULONG
DbgTypes::MatchField(
    LPSTR               fName,
    PTYPE_DUMP_INTERNAL m_pInternalInfo,
    PFIELD_INFO_EX         fields,
    ULONG               nFields,
    PULONG              ParentOfField
    )
{
    USHORT i, FieldLevel;
    PTYPE_NAME_LIST ParentType=m_pInternalInfo->ParentTypes, ParentField=m_pInternalInfo->ParentFields;
    PCHAR Next=NULL, matchName;
    BOOL fieldMatched, parentFieldMatched, parentTypeMatched;
    ULONG  matchedFieldIndex=0;
    PCHAR  ChildFields=NULL;

    *ParentOfField=0;
    for (i=0; (i<nFields) && fields[i].fName; i++) {
        PCHAR NextParentField, End;

        fieldMatched = FALSE;

        NextParentField = (matchName = (PCHAR) &fields[i].fName[0]);
        Next = NextFieldName((char *)matchName);
        FieldLevel = 1;
        parentTypeMatched  = TRUE;
        parentFieldMatched = TRUE;
        ParentField = m_pInternalInfo->ParentFields;
        ParentType  = m_pInternalInfo->ParentTypes;

        while ( Next &&
               ((ParentType && parentTypeMatched) ||
                (ParentField && parentFieldMatched))) {
            //
            // Match the parent field or type names if previous parents have matched
            // and there are more "parents" in matchName
            //

            End = FieldNameEnd(matchName);
            if (ParentField && parentFieldMatched) {

                if (strncmp( (char *)matchName,
                             ParentField->Name,
                             (End - matchName )) ||
                    ((fields[i].fOptions & DBG_DUMP_FIELD_FULL_NAME) &&
                     (strlen((char *)ParentField->Name) != (ULONG) (End - matchName)) )) {
                    parentFieldMatched = FALSE;
                    break;
                }
                ParentField = ParentField->Next;
                NextParentField = Next;

            } else {
                if (strncmp( (char *)matchName,
                             ParentType->Name,
                             (End - matchName )) ||
                    ((fields[i].fOptions & DBG_DUMP_FIELD_FULL_NAME) &&
                     (strlen((char *)ParentType->Name) != (ULONG) (End - matchName)) )) {
                    parentTypeMatched = FALSE;
                    break;
                }
                ParentType  = ParentType->Next;
            }

            FieldLevel++;
            matchName = Next;
            Next = NextFieldName(matchName);
        }

        if (parentFieldMatched && !ParentField && NextParentField) {
            PCHAR nextDot= NextFieldName( (char *)NextParentField);
            End = FieldNameEnd((PCHAR) NextParentField);

            if (nextDot &&
                !strncmp((char *)fName,
                         (char *)NextParentField,
                         (End - NextParentField)) &&
                (!(fields[i].fOptions & DBG_DUMP_FIELD_FULL_NAME) ||
                 (strlen((PCHAR) fName) == (ULONG) (End - NextParentField)))) {

                //
                // matchName :- A.b.c.d
                // Parentfields :- A.b && fName :- c
                //         then A.b.c "parent-matches" A.b.c.d
                //
                *ParentOfField = i+1;
                ChildFields = End;
#ifdef DBG_TYPE
                dprintf("Field %s parent-matched with %s NP %s Ch %s ND %s\n",
                        fields[i].fName, fName, NextParentField, ChildFields, nextDot);
#endif
                continue;
            }

        }

        if (!parentFieldMatched && !parentTypeMatched) {
            //
            // Parent names do not match
            continue;
        }

        //
        // Fields should match till the level we are in
        //
        if (FieldLevel != m_pInternalInfo->level) {
            continue;
        }

        //
        // Compare the field names
        //
        ChildFields = FieldNameEnd((char *) matchName);
        if (fields[i].fOptions & DBG_DUMP_FIELD_FULL_NAME) {
            if (!strncmp((char *)fName, (char *)matchName, (ULONG) (ChildFields - (char *)matchName)) &&
                (strlen(fName) == (ULONG) (ChildFields - (char *)matchName))) {
                fieldMatched = TRUE;
            }
        } else if (!strncmp((char *)fName, (char *)matchName, (ULONG) (ChildFields - (char *) matchName))) {
            fieldMatched = TRUE;
        }

        if (fieldMatched) {
#ifdef DBG_TYPE
            dprintf("Field %s matched with %s\n", fields[i].fName, fName);
#endif
            matchedFieldIndex = i+1;
            m_pInternalInfo->AltFields[i].FieldType.Matched = TRUE;
            m_pInternalInfo->FieldIndex = i;
        }
    }

    if (ChildFields) {

        FieldChildOptions(ChildFields, m_pInternalInfo);
        m_pNextSym = ChildFields;
    }
    return matchedFieldIndex;
}

#define MatchListField(Name, pMatched, pIsParent)                           \
{ PALT_FIELD_INFO OrigAltFields = m_pInternalInfo->AltFields;                    \
                                                                            \
  m_pInternalInfo->AltFields = &m_pInternalInfo->AltFields[m_pDumpInfo->nFields];       \
  *pMatched=MatchField(name, m_pInternalInfo, m_pDumpInfo->listLink, 1, pIsParent);\
  m_pInternalInfo->AltFields = OrigAltFields;                                    \
}\


/*
 *Function Name: printString
 *
 * Parameters: ULONG64 addr, ULONG size, ULONG Options
 *
 * Description:
 *     Prints out a normal/ wide char / multi / GUID string from addr depending on the options
 *
 * Returns: Size of string printed
 *
 */
ULONG
printString(ULONG64 addr, ULONG size, ULONG Options) {
    ULONG buffSize=2*MAX_NAME, bytesRead=0, readNow, count;
    CHAR buff[2*MAX_NAME+8];
    BOOL knownSize, done;


    if ((Options & NO_PRINT) || !addr || !(Options & DBG_DUMP_FIELD_STRING)) {
        return size;
    }

    Options &= DBG_DUMP_FIELD_STRING | DBG_DUMP_COMPACT_OUT;

    if (Options & DBG_DUMP_FIELD_GUID_STRING) {
        size=16*(Options & DBG_DUMP_FIELD_WCHAR_STRING ? 2 : 1) ; // Length of a GUID
    }

    knownSize = size;
    while (!knownSize || (bytesRead < size)) {
        USHORT start =0;

        done=FALSE;
        ZeroMemory(&buff[0], sizeof(buff));

        if (knownSize) {
            readNow=min(buffSize, size);
        } else {
            readNow=buffSize;
        }

        if (!(count = ReadTypeData((PUCHAR)&buff[0], addr + bytesRead, readNow, Options & ~DBG_DUMP_FIELD_STRING))) {
            return 0;
        }
        bytesRead+=count;

        // Print the string
        while (!done) { // For MultiStrings
            int i;
            if (Options & DBG_DUMP_FIELD_WCHAR_STRING) {
                PWCHAR wstr = (WCHAR*) &buff[start];

                for (i=0;
                     wstr[i] && IsPrintWChar(wstr[i]) || (wstr[i] == '\t' || wstr[i] == '\n');
                     ++i)
                {
                    if (wstr[i] == '\t' || wstr[i] == '\n')
                    {
                        wstr[i] = '.';
                    }
                    if ((Options & DBG_DUMP_COMPACT_OUT) || wstr[i] == '\n') {
                        wstr[i] = '?';
                    }

                }
                if (i == buffSize/sizeof(WCHAR))
                {
                    // We restrict to displaying 4k string
                    wstr[i++] = '.';
                    wstr[i++] = '.';
                    wstr[i++] = '.';
                } else if (!IsPrintWChar(wstr[i]) && wstr[i]) {
                    // Unprintable strings
                    wstr[i++] = '?';
                    wstr[i++] = '?';
                    wstr[i++] = '?';
                }
                wstr[i]=0;
                dprintf("%ws", wstr);
                done=TRUE;
                start += (i+1)*2;
                if ((Options & DBG_DUMP_FIELD_MULTI_STRING) &&
                    (*((WCHAR *) &buff[start]) != (WCHAR) NULL)) {
                    done=FALSE;;
                    dprintf(" ");
                } else {
                    size = i;
                }
            } else if (Options & DBG_DUMP_FIELD_GUID_STRING) { // GUID
                dprintf("{");
                for (i=0;i<16;i++) {
                    if ((i==4) || (i==6) || (i==8) || (i==10)) {
                        dprintf("-");
                    }
                    if (i<4) {
                        dprintf("%02x", (UCHAR) buff[3-i]);
                    } else if (i<6) {
                        dprintf("%02x", (UCHAR) buff[9-i]);
                    } else if (i<8) {
                        dprintf("%02x", (UCHAR) buff[13-i]);
                    } else {
                        dprintf("%02x", (UCHAR) buff[i]);
                    }
                } /* for */
                dprintf("}");
                return 16;
            } else { // DBG_DUMP_DEFAULT_STRING
                for (i=0;
                     buff[i] && IsPrintChar(buff[i]) || ( buff[i] == '\t' || buff[i] == '\n');
                     ++i) {
                    if ( buff[i] == '\t' || buff[i] == '\n')
                    {
                        buff[i] = '.';
                    }
                    if ((Options & DBG_DUMP_COMPACT_OUT) || buff[i] == '\n') {
                        buff[i] = '?';
                    }
                }
                if (i == buffSize)
                {
                    // We restrict to displaying 4k string
                    buff[i++] = '.';
                    buff[i++] = '.';
                    buff[i++] = '.';
                } else if (!IsPrintWChar(buff[i]) && buff[i] && buff[i] != '\t' && buff[i] != '\n') {
                    // Unprintable strings
                    buff[i++] = '?';
                    buff[i++] = '?';
                    buff[i++] = '?';
                }
                buff[i]=0;
                dprintf("%s", (CHAR*) &buff[start]);
                done=TRUE;
                start += (i+1);
                if ((Options & DBG_DUMP_FIELD_MULTI_STRING) &&
                    (*((CHAR *) &buff[start]) != (CHAR) NULL)) {
                    done = FALSE;
                    dprintf(" ");
                } else {
                    size = i;
                }
            }
        } /* while !done */
        if ((start <= readNow) || (bytesRead > MAX_NAME)) {
            knownSize = TRUE;
        }

        if (count<readNow) {
            // we can't read enough memory
            break;
        }

    }
    return bytesRead;
} /* End function printString */

//
// The string at address is :
//   { Length (2 bytes), MaxLen (2 bytes), Str address ( pointer) }
//
ULONG
printStructString(
    ULONG64 Address,
    ULONG   Option,
    ULONG   StrOpts
    )
{
    USHORT Length;
    ULONG64 StrAddress;

    if ((Option & NO_PRINT) && !(Option & DBG_RETURN_TYPE_VALUES)) {
        return 0;
    }
    if (ReadTypeData((PUCHAR) &Length, Address, sizeof(Length), Option) &&
        ReadTypeData((PUCHAR) &StrAddress,
                     Address + (g_Machine->m_Ptr64 ? 8 : 4),
                     g_Machine->m_Ptr64 ? 8 : 4,
        Option))
    {
        StrAddress = (g_Machine->m_Ptr64 ? StrAddress : (ULONG64) (LONG64) (LONG) StrAddress);
        dprintf("\"");
        printString(StrAddress, Length, StrOpts);
        dprintf("\"");
        return Length;
    }

    return 0;
}

BOOL
PrintStringIfString(
    IN HANDLE hProcess,
    IN ULONG64 ModBase,
    IN ULONG Options,
    IN ULONG StrOpts,
    IN ULONG TI,
    IN ULONG64 Address,
    IN ULONG Size
    )
{
    ULONG   Tag;
    ULONG   BaseType;
    ULONG64 Length;

    if ((Options & NO_PRINT) && !(Options & DBG_RETURN_TYPE_VALUES)) {
        return FALSE;
    }

    if (IsDbgNativeType(TI)) {
        PDBG_NATIVE_TYPE Native = DbgNativeTypeEntry(TI);
        BaseType = Native->CvBase;
        Length = Native->Size;
    } else if ((!SymGetTypeInfo(hProcess, ModBase, TI,
                                TI_GET_SYMTAG, &Tag)) ||
         (Tag != SymTagBaseType) ||
         (!SymGetTypeInfo(hProcess, ModBase, TI,
                          TI_GET_BASETYPE, &BaseType))) {
        return FALSE;

    } else {
        SymGetTypeInfo(hProcess, ModBase, TI,
               TI_GET_LENGTH, &Length);
    }

    if (!StrOpts) {
        if (BaseType == btChar || (BaseType == btUInt && Length == 1)) {
            StrOpts = DBG_DUMP_FIELD_DEFAULT_STRING;
        } else if (BaseType == btWChar) {
            StrOpts = DBG_DUMP_FIELD_WCHAR_STRING;
        } else if ((BaseType == btUInt && Length == 2)  &&
                   g_EnableUnicode) {
            BaseType = btWChar;
            StrOpts = DBG_DUMP_FIELD_WCHAR_STRING;
        } else {
            return FALSE;
        }
    }
    ExtPrint(" \"");
    typPrint(" \"");
    printString(Address, Size, StrOpts);
    ExtPrint("\"");
    typPrint("\"");
    return TRUE;
}


/*
   This sumps structs which are known to debugger in special format
*/
ULONG
DumpKnownStruct(
    PCHAR name,
    ULONG Options,
    ULONG64 Address,
    PULONG pStringLen
    )
{

    if (!strcmp(name,"_ANSI_STRING") ||
        !strcmp(name,"_STRING") ||
        (!strcmp(name, "_UNICODE_STRING"))) {
        ULONG FieldOptions = (name[1]!='U') ? DBG_DUMP_FIELD_DEFAULT_STRING : DBG_DUMP_FIELD_WCHAR_STRING;
        ULONG Len;
        typPrint(" ");
        ExtPrint(" ");
        Len = printStructString(Address, Options,
                                FieldOptions);
        if (pStringLen)
        {
            *pStringLen = Len;
        }
        return Len;

    } else if ((Options & NO_PRINT) &&
               !((Options & DBG_RETURN_TYPE_VALUES) && (Options & DBG_RETURN_TYPE))) {
        return FALSE;
    }
    if (!strcmp(name,"_GUID")) {
        typPrint(" ");
        ExtPrint(" ");
        printString(Address, 0, DBG_DUMP_FIELD_GUID_STRING);
        return TRUE;
    } else
    if ((!strcmp(name,"_LARGE_INTEGER") || !strcmp(name,"_ULARGE_INTEGER"))) {
        ULONG64 li;
        if (ReadTypeData((PUCHAR) &li,
                         Address,
                         8,
                         Options)) {
            typPrint(" %s", FormatDisp64(li));
            ExtPrint(" %s", FormatDisp64(li));
            return TRUE;
        }
    } else
    if (!strcmp(name,"_LIST_ENTRY")) {
        union {
            LIST_ENTRY32 l32;
            LIST_ENTRY64 l64;
        } u;

        if (ReadTypeData((PUCHAR) &u,
                         Address,
                         (g_Machine->m_Ptr64 ? 16 : 8),
                         Options)) {
            if (g_Machine->m_Ptr64) {
                typPrint(" [ %s - %s ]", FormatAddr64(u.l64.Flink), FormatDisp64(u.l64.Blink));
                ExtPrint(" [ %s - %s ]", FormatAddr64(u.l64.Flink), FormatDisp64(u.l64.Blink));
            } else {
                typPrint(" [ 0x%lx - 0x%lx ]", u.l32.Flink, u.l32.Blink);
                ExtPrint(" [ 0x%lx - 0x%lx ]", u.l32.Flink, u.l32.Blink);
            }
            return TRUE;
        }
    } else if (!strcmp(name,"_FILETIME")) {
        FILETIME ft;
        SYSTEMTIME syst;
        static PCHAR Months[] = {
            "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
        };
        if (ReadTypeData((PUCHAR) &ft,
                         Address,
                         sizeof(ft),
                         Options)) {
            if (FileTimeToSystemTime(&ft, &syst)) {
                typPrint(" %s %ld %02ld:%02ld:%02ld %ld",
                         Months[syst.wMonth-1],
                         syst.wDay,
                         syst.wHour,
                         syst.wMinute,
                         syst.wSecond,
                         syst.wYear);
                ExtPrint(" %s %ld %02ld:%02ld:%02ld %ld",
                         Months[syst.wMonth-1],
                         syst.wDay,
                         syst.wHour,
                         syst.wMinute,
                         syst.wSecond,
                         syst.wYear);
                return TRUE;
            }
        }
    } else if (!strncmp(name, "ATL::CComPtr", 12))
    {
        ULONG64 PtrVal;

        if (ReadTypeData((PUCHAR) &PtrVal,
                         Address,
                         sizeof(PtrVal),
                         Options))
        {
            ExtPrint(" { %s } ", FormatAddr64(PtrVal));
            typPrint(" { %s } ", FormatAddr64(PtrVal));
        }

    }
    return FALSE;
}


ULONG
GetSizeOfTypeFromIndex(ULONG64 Mod, ULONG TypIndx)
{
    SYM_DUMP_PARAM_EX Sym = {0};
    Sym.size = sizeof(SYM_DUMP_PARAM_EX); Sym.Options = (GET_SIZE_ONLY | NO_PRINT);

    TYPES_INFO ti = {0};
    ti.hProcess = g_Process->m_SymHandle;
    ti.ModBaseAddress = Mod;
    ti.TypeIndex = TypIndx;

    return DumpType(&ti, &Sym, &ti.Referenced);
}

//
// Dereference expressions end up generating fake types
// with special symtags.
//
#define TmpSymTagAddressOf   SymTagMax
#define TmpSymTagArray       (SymTagMax + 1)

DbgDerivedType::DbgDerivedType(
    PTYPE_DUMP_INTERNAL pInternalDumpInfo,
    PTYPES_INFO         pTypeInfo,
    PSYM_DUMP_PARAM_EX     pExternalDumpInfo)
    : DbgTypes(pInternalDumpInfo, pTypeInfo, pExternalDumpInfo)
{
    PDBG_GENERATED_TYPE GenType;

    if (IsDbgGeneratedType(pTypeInfo->TypeIndex) &&
        (GenType = g_GenTypes.FindById(pTypeInfo->TypeIndex)) &&
        GenType->Tag == SymTagTypedef) {
        PCHAR TypeName = (PCHAR) pExternalDumpInfo->sName;

        m_DerivedTypeId = pTypeInfo->TypeIndex;
        m_BaseTypeId = GenType->ChildId;

        // Reparse and create derived types for type expression.
        if (GenerateTypes(TypeName) == S_OK) {
            return;
        }
    } else {
        m_BaseTypeId = pTypeInfo->TypeIndex;
    }

    m_NumDeTypes = 0;
}


DbgDerivedType::~DbgDerivedType()
{
    for (ULONG i = 0; i < m_NumDeTypes; i++) {
        g_GenTypes.DeleteById(m_DeTypes[i].TypeId);
    }
}

//
// Handle &Sym.a expressions
//
ULONG
DbgDerivedType::DumpAddressOf(
    PDBG_DE_TYPE        DeType,
    ULONG               ptrSize,
    ULONG               ChildIndex
    )
{
    ULONG Options = m_pInternalInfo->TypeOptions;
    if (m_pInternalInfo->IsAVar || m_pDumpInfo->addr) {
        // Just IsAVar check should be enough, but OutputSymbol may need the other
        TYPE_DUMP_INTERNAL Save;

        Save = *m_pInternalInfo;
        vprintf("Address of %s ", m_pDumpInfo->sName);

        // Get The address of requested type / symbol
        m_pInternalInfo->TypeOptions &= ~(DBG_RETURN_TYPE_VALUES | DBG_RETURN_SUBTYPES | DBG_RETURN_TYPE);
        m_pInternalInfo->TypeOptions |= NO_PRINT;
        FIND_TYPE_INFO FindInfo={0}, *pSave;
        pSave = m_pInternalInfo->pInfoFound;
        m_pInternalInfo->pInfoFound = &FindInfo;
        DumpType();

        typPrint("%s ", FormatAddr64 (FindInfo.FullInfo.Address));
        ExtPrint("%s",  FormatAddr64 (FindInfo.FullInfo.Address));
        *m_pInternalInfo = Save;
        m_ParentTag = m_SymTag;
        m_SymTag = SymTagPointerType;
     //   m_typeIndex = FindInfo.FullInfo.TypeIndex;
        if (!(Options & DBG_RETURN_TYPE_VALUES)) {
            DumpType();
        }
        if (!FindInfo.FullInfo.TypeIndex) {
            FindInfo.FullInfo.TypeIndex = ChildIndex;
        }
        STORE_INFO(DeType->TypeId,
                   FindInfo.FullInfo.Address,
                   ptrSize,
                   1,
                   FindInfo.FullInfo.Address);
//        if (pSave) {
//            pSave->FullInfo.Value = FindInfo.FullInfo.Address;
//            pSave->FullInfo.Flags |= SYMFLAG_VALUEPRESENT;
//        }
        return ptrSize;
    }
    return ptrSize;
}


//
// Handle TYP ** expressions
//
ULONG
DbgDerivedType::DumpPointer(
    PDBG_DE_TYPE        DeType,
    ULONG               ptrSize,
    ULONG               ChildIndex
    )
{
    ULONG   Options  = m_pInternalInfo->TypeOptions;
    ULONG64 ReadAddr = 0, saveAddr=0, saveOffset=0;
    BOOL    DumpChild= TRUE;
    BOOL    CopyData=FALSE;
    PUCHAR  DataBuffer=NULL;

    if (m_pDumpInfo->addr) {
        ULONG64 PtrVal=0;

        m_pInternalInfo->PtrRead = TRUE;
        ReadAddr = m_pDumpInfo->addr + m_pInternalInfo->totalOffset;

        READ_BYTES(&PtrVal, ReadAddr, ptrSize);
        if (ptrSize!=sizeof(ULONG64)) {
            //
            // Signextend the read pointer value
            //
            PtrVal = (ULONG64) (LONG64) (LONG) PtrVal;
        }
        STORE_INFO(m_typeIndex, ReadAddr, ptrSize, 1, PtrVal);

        if (m_pInternalInfo->CopyDataInBuffer && !m_pInternalInfo->CopyDataForParent) {
            *((PULONG64) (m_pInternalInfo->TypeDataPointer - ptrSize)) = PtrVal;
            //
            // We return size as 8 for 32 bit *copied* pointers.
            //
            m_pInternalInfo->TypeDataPointer -= ptrSize;
            ptrSize = 8;
            m_pInternalInfo->TypeDataPointer += ptrSize;

            //
            // Cannot go on copying the pointed value
            //
            CopyData = TRUE;
            DataBuffer = m_pInternalInfo->TypeDataPointer;
            m_pInternalInfo->CopyDataInBuffer = FALSE;
            m_pInternalInfo->TypeDataPointer = NULL;
        }
        ExtPrint("%s", FormatAddr64(PtrVal));

        if (Options & DBG_RETURN_SUBTYPES && m_ParentTag) {
            STORE_PARENT_EXPAND_ADDRINFO(ReadAddr);

            m_pInternalInfo->RefFromPtr = 1;
            m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
            m_pInternalInfo->TypeOptions |= DBG_RETURN_TYPE;

            // NOTE :-
            //      Make this part of DumpDbgDerivedType later
            //
            DumpChild            = FALSE;//!IsDbgDerivedType(ChildIndex);
        } else if (Options & DBG_RETURN_TYPE) {
            // We found all we needed here itself

            ULONG strOpts = m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_STRING;
            // NOTE :-
            //      Make this part of DumpDbgDerivedType later
            //
            DumpChild            = !IsDbgGeneratedType(ChildIndex);

            saveAddr = m_pDumpInfo->addr;
            saveOffset = m_pInternalInfo->totalOffset;

            m_pDumpInfo->addr         = PtrVal;
            m_pInternalInfo->totalOffset = 0;

            if (CheckAndPrintStringType(ChildIndex, 0)) {
                DumpChild = FALSE;
            }
            /* if ((Options & DBG_RETURN_TYPE_VALUES) &&
                IsAPrimType(ChildIndex) &&
                ((ChildIndex == T_CHAR) || (ChildIndex == T_RCHAR) ||
                 (ChildIndex == T_WCHAR) || (ChildIndex == T_UCHAR)) ||
                strOpts) {

                if (!strOpts) {
                    strOpts |= (ChildIndex == T_WCHAR) ?
                        DBG_DUMP_FIELD_WCHAR_STRING : DBG_DUMP_FIELD_DEFAULT_STRING ;
                }
                ExtPrint(" \"");
                printString(PtrVal, 0, strOpts);
                ExtPrint("\"");
            }*/
        } else if (PtrVal) {
            typPrint("0x%s", FormatAddr64(PtrVal));

            saveAddr = m_pDumpInfo->addr;
            saveOffset = m_pInternalInfo->totalOffset;

            m_pDumpInfo->addr         = PtrVal;
            m_pInternalInfo->totalOffset = 0;

            if (!(Options & (NO_PRINT | GET_SIZE_ONLY))) {
                ULONG strOpts=m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_STRING;
                if (CheckAndPrintStringType(ChildIndex, 0)) {
                    DumpChild = FALSE;
                }
/*                if ((ChildIndex == T_CHAR)  || (ChildIndex == T_RCHAR) ||
                    (ChildIndex == T_WCHAR) || (ChildIndex == T_UCHAR) ||
                    (m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_STRING)) {
                    // SPECIAL CASE, treat every pointer as string

                    if (!strOpts) {
                        strOpts |= (ChildIndex == T_WCHAR) ?
                            DBG_DUMP_FIELD_WCHAR_STRING : DBG_DUMP_FIELD_DEFAULT_STRING ;
                    }
                    typPrint(" \"");
                    printString(PtrVal, m_pInternalInfo->StringSize, strOpts);
                    typPrint("\"");
                    DumpChild            = FALSE;
                }*/
            }

        } else {
            typPrint("%s",
                     ((m_pInternalInfo->ErrorStatus==MEMORY_READ_ERROR) && (ReadAddr == m_pInternalInfo->InvalidAddress)
                      ? "??" : "(null)"));
            DumpChild            = FALSE;
        }

        vprintf(" Ptr%s to ", (g_Machine->m_Ptr64 ? "32" : "64"));
    } else {
        typPrint("Ptr%s to ", (ptrSize==4 ? "32" : "64"));
    }


    if (!(m_pInternalInfo->TypeOptions & DBG_DUMP_COMPACT_OUT)) {
        typPrint("\n");
    }
    if (DumpChild) {
        m_typeIndex = ChildIndex;
        if (m_pInternalInfo->ArrayElementToDump) {
            // treat pointer as an array
            ULONG64 ChSize = GetTypeSize();

            m_pInternalInfo->totalOffset += ChSize * (m_pInternalInfo->ArrayElementToDump -1);
        }
        DumpType();
        if (m_pDumpInfo->addr) {
            m_pDumpInfo->addr = saveAddr;
            m_pInternalInfo->totalOffset = saveOffset;
        }
    }

    if (CopyData) {
        //
        // Restore the copy buffer values
        //
        m_pInternalInfo->CopyDataInBuffer = TRUE;
        m_pInternalInfo->TypeDataPointer =  DataBuffer;
    }

    m_pInternalInfo->TypeOptions  = Options;

    return ((m_pInternalInfo->ErrorStatus==MEMORY_READ_ERROR) && (ReadAddr == m_pInternalInfo->InvalidAddress)) ?
        0 : ptrSize;
}

//
// Handle TYPE[<array limit>] expressions, process as array element if its a var[<inxed>]
//
ULONG
DbgDerivedType::DumpSingleDimArray(
    IN PDBG_DE_TYPE        DeType,
    IN ULONG               NumElts,
    IN ULONG               EltType
    )
{
    ULONG  EltSize = GetTypeSize();
    ULONG  ArrSize = EltSize * NumElts;
    PUCHAR savedBuffer=NULL;
    ULONG  Options = m_pInternalInfo->TypeOptions;
    BOOL   CopyData=FALSE;

    if (m_pInternalInfo->IsAVar && DeType != m_DeTypes) {
        // Its a symbol, we need to dump index NumElts
        m_pInternalInfo->ArrayElementToDump = NumElts+1;
        return DumpType();
    } else {
        typPrint("[%d] ", NumElts);
    }

    if (m_pInternalInfo->CopyDataInBuffer && m_pInternalInfo->TypeDataPointer && m_pDumpInfo->addr &&
        (Options & GET_SIZE_ONLY)) {
        //
        // Copy the data
        //
        if (!ReadTypeData(m_pInternalInfo->TypeDataPointer,
                          m_pDumpInfo->addr + m_pInternalInfo->totalOffset,
                          ArrSize,
                          m_pInternalInfo->TypeOptions)) {
            m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
            m_pInternalInfo->InvalidAddress = m_pDumpInfo->addr + m_pInternalInfo->totalOffset;
            return 0;
        }

        m_pInternalInfo->TypeDataPointer += ArrSize;
        savedBuffer = m_pInternalInfo->TypeDataPointer;
        CopyData = TRUE;
        m_pInternalInfo->CopyDataInBuffer = FALSE;
    }

    STORE_INFO(m_typeIndex, m_pDumpInfo->addr + m_pInternalInfo->totalOffset, ArrSize, NumElts,
               m_pDumpInfo->addr + m_pInternalInfo->totalOffset);

    if (Options & (DBG_RETURN_TYPE)) {
        if (CheckAndPrintStringType(EltType, ArrSize)) {

        } else {
            ExtPrint("Array [%d]", NumElts);
        }
        return ArrSize;
    }

    if (Options & DBG_RETURN_SUBTYPES) {

        STORE_PARENT_EXPAND_ADDRINFO(m_pDumpInfo->addr + m_pInternalInfo->totalOffset);

        m_pInternalInfo->CopyName = 0;
    }
    if (Options & GET_SIZE_ONLY) {
        return ArrSize;
    }

    if (m_pDumpInfo->addr) {
        // Dump array contents
        ULONG64 tmp = m_pDumpInfo->addr;

        if (CheckAndPrintStringType(EltType, ArrSize)) {
                return ArrSize;
        }
    }

    ULONG szLen=0, index=0;
    ULONG64 saveAddr = m_pDumpInfo->addr;
    do {
        if (Options & DBG_RETURN_SUBTYPES) {
            m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
            m_pInternalInfo->TypeOptions |=  DBG_RETURN_TYPE;
            ++m_pInternalInfo->level;
        }
        if ((m_pInternalInfo->level && (m_pInternalInfo->FieldOptions & FIELD_ARRAY_DUMP))) {
            Indent(m_pInternalInfo->level*3);
            typPrint(" [%02d] ", index);
        }
        szLen=DumpType();

        if ((Options & DBG_DUMP_COMPACT_OUT ) && (Options & FIELD_ARRAY_DUMP) ) {
            typPrint("%s", ((szLen>8) || (index % 4 == 0)) ? "\n":" ");
        }
        if (!szLen) {
            break;
        }
        if (Options & DBG_RETURN_SUBTYPES) {
            --m_pInternalInfo->level;
        }
        m_pDumpInfo->addr+=szLen;
    } while (saveAddr && (++index < NumElts));

    m_pDumpInfo->addr = saveAddr;
    m_pInternalInfo->TypeOptions = Options;
    if (CopyData) {
        m_pInternalInfo->TypeDataPointer  = savedBuffer;
        m_pInternalInfo->CopyDataInBuffer = TRUE;
    }

    return ArrSize;
}

ULONG
DbgDerivedType::GetTypeSize()
{
    ULONG SavedOptions = m_pInternalInfo->TypeOptions,
        SaveCopyData =  m_pInternalInfo->CopyDataInBuffer;

    m_pInternalInfo->TypeOptions = (GET_SIZE_ONLY | NO_PRINT);
    m_pInternalInfo->CopyDataInBuffer = FALSE;

    ULONG Size = DumpType();

    m_pInternalInfo->TypeOptions = SavedOptions;
    m_pInternalInfo->CopyDataInBuffer = SaveCopyData;

   return Size;
}

/*++
 * GenerateTypes
 *      Input:
 *         TypeName  - String that contains special type chars eg. *, [].
 *      Returns      HRESULT
 --*/
HRESULT
DbgDerivedType::GenerateTypes(
    IN PCHAR TypeName
    )
{
    HRESULT Status;
    ULONG CurrIndex = 0;
    ULONG TypeIndex = m_BaseTypeId;

    if (!TypeName) {
        return E_INVALIDARG;
    }

    // start looking from backwords
    PCHAR Scan = TypeName;

    while (*Scan && *Scan != '*' && *Scan != '[' ) {
        ++Scan;
    }

    if (!*Scan && *TypeName != '&') {
        return E_INVALIDARG;
    }

    if (*TypeName == '&') {
        // Pointer type
        PDBG_GENERATED_TYPE AddrType = g_GenTypes.
            FindOrCreateByAttrs(m_pInternalInfo->modBaseAddr,
                                TmpSymTagAddressOf, TypeIndex, 0);
        if (!AddrType) {
            return E_OUTOFMEMORY;
        }

        m_DeTypes[CurrIndex].TypeId = AddrType->TypeId;
        m_DeTypes[CurrIndex].Tag = AddrType->Tag;
        m_DeTypes[CurrIndex].StartIndex = 0;
        m_DeTypes[CurrIndex].Namelength = (ULONG) ((ULONG64) Scan - (ULONG64) TypeName);
        CurrIndex++;
        ++TypeName;
        TypeIndex = m_DerivedTypeId;
    }

    while (*Scan == '*' || *Scan == '[' || *Scan == ' ') {
        if (CurrIndex >= MAX_DETYPES_ALLOWED) {
            Status = E_INVALIDARG;
            goto CleanTypes;
        }

        if (*Scan == '*') {
            // Pointer type
            PDBG_GENERATED_TYPE PtrType = g_GenTypes.
                FindOrCreateByAttrs(m_pInternalInfo->modBaseAddr,
                                    SymTagPointerType, TypeIndex,
                                    g_Machine->m_Ptr64 ? 8 : 4);
            if (!PtrType) {
                Status = E_OUTOFMEMORY;
                goto CleanTypes;
            }

            m_DeTypes[CurrIndex].TypeId = PtrType->TypeId;
            m_DeTypes[CurrIndex].Tag = PtrType->Tag;
            m_DeTypes[CurrIndex].StartIndex = 0;
            m_DeTypes[CurrIndex].Namelength = 1 + (ULONG) ((ULONG64) Scan - (ULONG64) TypeName);
            CurrIndex++;
            TypeIndex = m_DerivedTypeId;
        } else if (*Scan == '[') {
            PCHAR ArrParen = Scan;
            while ((*ArrParen != ']') && *ArrParen) {
                ++ArrParen;
            }
            if (*ArrParen==']') {
                ULONG ArrIndex;

                if (sscanf(Scan+1, "%ld", &ArrIndex) != 1) {
                    ArrIndex=1;
                }

                ArrIndex = (ULONG) EvaluateSourceExpression(1+Scan);

                PDBG_GENERATED_TYPE ArrType = g_GenTypes.
                    FindOrCreateByAttrs(m_pInternalInfo->modBaseAddr,
                                        TmpSymTagArray, TypeIndex, 0);
                if (!ArrType) {
                    Status = E_OUTOFMEMORY;
                    goto CleanTypes;
                }

                m_DeTypes[CurrIndex].TypeId = ArrType->TypeId;
                m_DeTypes[CurrIndex].Tag = ArrType->Tag;
                m_DeTypes[CurrIndex].ArrayIndex = ArrIndex;
                m_DeTypes[CurrIndex].StartIndex = 0;
                m_DeTypes[CurrIndex].Namelength = 1 + (ULONG) ((ULONG64) ArrParen - (ULONG64) TypeName);
                CurrIndex++;
                TypeIndex = m_DerivedTypeId;

                Scan=ArrParen;
            } else {
                // syntax error
                Status = E_INVALIDARG;
                goto CleanTypes;
            }
        }
        ++Scan;
    }

    if (!CurrIndex) {
        Status = E_FAIL;
        goto CleanTypes;
    }
    m_NumDeTypes = CurrIndex;
    return S_OK;

 CleanTypes:
    for (ULONG i = 0; i < CurrIndex; i++) {
        g_GenTypes.DeleteById(m_DeTypes[i].TypeId);
    }
    return Status;
}

/*++
* Routine to dump special types which are no defined in PDB, but can be derived
*
* eg. CHAR*, _STRUCT* etc.
*
--*/
ULONG
DbgDerivedType::DumpType(
    )
{
    ULONG Options  = m_pInternalInfo->TypeOptions;
    ULONG result, Parent = m_ParentTag;
    ULONG NumTypes, i;
    PDBG_GENERATED_TYPE GenType;

    if (!m_NumDeTypes) {
        if (!IsDbgGeneratedType(m_typeIndex))
        {
            // DbgTypes expects m_typeIndex
            return DbgTypes::ProcessType(m_typeIndex);
        }
        return DbgTypes::ProcessType(m_BaseTypeId);
    }

    m_typeIndex = m_DerivedTypeId;
    if (!IsDbgGeneratedType(m_typeIndex) || !m_pDumpInfo->sName) {
        m_pInternalInfo->ErrorStatus = SYMBOL_TYPE_INFO_NOT_FOUND;
        return 0;
    }

    NumTypes = m_NumDeTypes;
    i = --m_NumDeTypes;
    GenType = g_GenTypes.FindById(m_DeTypes[i].TypeId);

    if (GenType == NULL)
    {
        m_pInternalInfo->ErrorStatus = SYMBOL_TYPE_INFO_NOT_FOUND;
        return 0;
    }
    switch (m_DeTypes[i].Tag) {
    case TmpSymTagAddressOf:
        result = DumpAddressOf(&m_DeTypes[i],
                               g_Machine->m_Ptr64 ? 8 : 4, GenType->ChildId);
        break;
    case SymTagPointerType:
        m_ParentTag = m_SymTag; m_SymTag = SymTagPointerType;
        if (m_pInternalInfo->TypeOptions & DBG_DUMP_GET_SIZE_ONLY) {
            result = g_Machine->m_Ptr64 ? 8 : 4;
        } else {
            result = DumpPointer(&m_DeTypes[i],
                                 g_Machine->m_Ptr64 ? 8 : 4, GenType->ChildId);
        }
        break;
    case TmpSymTagArray:
        m_ParentTag = m_SymTag; m_SymTag = SymTagArrayType;
        result = DumpSingleDimArray(&m_DeTypes[i], m_DeTypes[i].ArrayIndex,
                                    GenType->ChildId);
        break;
    default:
        result = 0;
        m_pInternalInfo->ErrorStatus = SYMBOL_TYPE_INFO_NOT_FOUND;
        break;
    }

    m_NumDeTypes = NumTypes;
    m_SymTag = m_ParentTag; m_ParentTag = Parent;
    return result;
}

DbgTypes::DbgTypes(
    PTYPE_DUMP_INTERNAL pInternalDumpInfo,
    PTYPES_INFO         pTypeInfo,
    PSYM_DUMP_PARAM_EX     pExternalDumpInfo)
{
    m_pInternalInfo = pInternalDumpInfo;
    m_pDumpInfo     = pExternalDumpInfo;
    m_TypeInfo      = *pTypeInfo;
    m_typeIndex     = pTypeInfo->TypeIndex;
    m_ParentTag     = 0;
    m_SymTag        = 0;
    m_AddrPresent   = (pExternalDumpInfo->addr != 0) || pTypeInfo->Flag || pTypeInfo->SymAddress;
    m_pNextSym      = (PCHAR) (pExternalDumpInfo->nFields ? pExternalDumpInfo->Fields[0].fName : NULL);
    m_pSymPrefix    = pInternalDumpInfo->Prefix;
    if (pExternalDumpInfo->sName &&
        !strcmp((char *)pExternalDumpInfo->sName, "this")) {
        m_thisPointerDump = TRUE;
    } else {
        m_thisPointerDump = FALSE;
    }
}

void
DbgTypes::CopyDumpInfo(
    ULONG Size
    )
{
    if (m_pInternalInfo->level) {
//      m_pDumpInfo->Type = SymTagToDbgType(SymTag);
        m_pDumpInfo->TypeSize = Size;
    } else if (m_pDumpInfo->nFields) {
        PFIELD_INFO_EX CurField = &m_pDumpInfo->Fields[m_pInternalInfo->FieldIndex];

//      CurField->fType = SymTagToDbgType(SymTag);
        CurField->size = Size;
        CurField->FieldOffset = (ULONG) m_pInternalInfo->totalOffset;
    }

}


ULONG
DbgTypes::ProcessVariant(
    IN VARIANT var,
    IN LPSTR   name)
{
    CHAR Buffer[50] = {0};
    ULONG Options = m_pInternalInfo->TypeOptions;
    ULONG len=0;

    if (name) {
        typPrint(name); typPrint(" = ");
    }
    switch (var.vt) {
    case VT_UI2:
        StrprintUInt(Buffer, var.iVal, 2);
        len = 2;
        break;
    case VT_I2:
        StrprintInt(Buffer, var.iVal, 2);
        len = 2;
        break;
    case VT_R4:
        sprintf(Buffer, "%g", var.fltVal);
        len=4;
        break;
        case VT_R8:
        sprintf(Buffer, "%g", var.dblVal);
        len=8;
        break;
    case VT_BOOL:
        sprintf(Buffer, "%lx", var.lVal);
        len=4;
        break;
    case VT_I1:
        len=1;
        StrprintInt(Buffer, var.bVal, len);
        break;
    case VT_UI1:
        len=1;
        StrprintUInt(Buffer, var.bVal, len);
        break;
    case VT_I8:
        StrprintInt(Buffer, var.ullVal, 8);
        len=8;
        break;
    case VT_UI8:
        StrprintUInt(Buffer, var.ullVal, 8);
        len=8;
        break;
    case VT_I4:
    case VT_INT:
        StrprintInt(Buffer, var.lVal, 4);
        len=4;
        break;
    case VT_UI4:
    case VT_UINT:
    case VT_HRESULT:
        StrprintUInt(Buffer, var.lVal, 4);
        len=4;
        break;
    default:
        sprintf(Buffer, "UNIMPLEMENTED %lx %lx", var.vt, var.lVal);
        len=4;
        break;
    }
    typPrint(Buffer);
    ExtPrint(Buffer);
    if (m_pInternalInfo->CopyDataInBuffer && m_pInternalInfo->TypeDataPointer) {
        memcpy(m_pInternalInfo->TypeDataPointer, &var.ullVal, len);
        m_pInternalInfo->TypeDataPointer += len;
    }

    if (m_pInternalInfo->pInfoFound && (!m_pNextSym || !*m_pNextSym) &&
        ((m_ParentTag != SymTagPointerType) || (m_pSymPrefix && *m_pSymPrefix == '*')) ) {

        if (len <= sizeof(ULONG64)) {
             memcpy(&m_pInternalInfo->pInfoFound->FullInfo.Value, &var.ullVal, len);
             m_pInternalInfo->pInfoFound->FullInfo.Flags |= SYMFLAG_VALUEPRESENT;
        }
    }
    //    STORE_INFO(TypeIndex, , Size, 0,0);

    if (!(m_pInternalInfo->TypeOptions & DBG_DUMP_COMPACT_OUT)) {
        typPrint("\n");
    } else {
        typPrint("; ");
    }

    return len;
}

//
// Check if TI is a string type - CHAR, WCHAR
//
BOOL
DbgTypes::CheckAndPrintStringType(
    IN ULONG TI,
    IN ULONG Size
    )
{
    ULONG strOpts = m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_STRING;
    ULONG   Options = m_pInternalInfo->TypeOptions;

    if ((Options & NO_PRINT) && !(Options & DBG_RETURN_TYPE_VALUES)) {
        return FALSE;
    }

    return PrintStringIfString(m_pInternalInfo->hProcess,
                               m_pInternalInfo->modBaseAddr,
                               Options, strOpts,
                               TI, GetDumpAddress(), Size);
}

void
StrprintInt(PCHAR str, ULONG64 val, ULONG Size) {
    if ((Size == 4  && g_EnableLongStatus) ||
        g_PrintDefaultRadix)
    {
        StrprintUInt(str, val, Size);
        return;
    }

    switch (Size) {
    case 1:
        sprintf(str, "%ld", (CHAR) val);
        break;
    case 2:
        sprintf(str, "%ld", (SHORT) val);
        break;
    case 4:
        sprintf(str, "%ld", (LONG) val);
        break;
    case 8:
    default:
        sprintf(str, "%I64ld", val);
        break;
    }
    return;
}

void
StrprintUInt(PCHAR str, ULONG64 val, ULONG Size) {
    CHAR Buff[30];
    switch (Size) {
    case 1:
        sprintf(Buff, GetTypePrintIntFmt(FALSE), (CHAR) val);
        break;
    case 2:
        sprintf(Buff, GetTypePrintIntFmt(FALSE), (USHORT) val);
        break;
    case 4:
        sprintf(Buff, GetTypePrintIntFmt(FALSE), (ULONG) val);
        break;
    case 8:
    default:
        if (g_DefaultRadix != 16) {
            sprintf(Buff, GetTypePrintIntFmt(TRUE), val);
        } else {
            sprintf(Buff, "0x%s", FormatDisp64(val));
        }
        break;
    }
    if (val > 9) {
        strcpy(str, Buff);
    } else {
        strcpy(str, &Buff[2]);
    }
    return;
}


ULONG
DbgTypes::ProcessBaseType(
    IN ULONG TypeIndex,
    IN ULONG TI,
    IN ULONG Size)
{
    ULONG  Options = m_pInternalInfo->TypeOptions;
    PANSI_STRING NameToCopy=NULL;
    ULONG64 addr;
    PULONG pTypeReturnSize=NULL;

    addr = GetDumpAddress();

    //
    // Fill up the SYMBOL_PARAMETERS if required
    //
    if (Options & (DBG_RETURN_TYPE | DBG_RETURN_SUBTYPES)) {

        if ((Options & DBG_RETURN_SUBTYPES) &&
            TI != btVoid) {

            STORE_PARENT_EXPAND_ADDRINFO(addr);

#define CopySymParamName(name) if ((Options & DBG_RETURN_SUBTYPES) && (strlen(name)<20) && NameToCopy) strcpy(NameToCopy->Buffer, name)
        }
    }

    STORE_INFO(TypeIndex, addr, Size, 0,0);

    //
    // Check if this is a nested type
    //
    ULONG IsNestedType=0;

    if (Options & VERBOSE) {
        if (SymGetTypeInfo(m_pInternalInfo->hProcess, m_pInternalInfo->modBaseAddr,
                           TypeIndex, TI_GET_NESTED, &IsNestedType) &&
            IsNestedType &&
            (m_ParentTag == SymTagUDT)) {
            PWCHAR wName=NULL;
            Indent(m_pInternalInfo->level*3);
            if (SymGetTypeInfo(m_pInternalInfo->hProcess, m_pInternalInfo->modBaseAddr,
                               TypeIndex, TI_GET_SYMNAME, (PVOID) &wName) && wName) {
                vprintf("%ws ", wName);
                LocalFree (wName);
            }
        }
    }


    BYTE data[50] = {0};
    ULONGLONG val=0;
    if ((addr || m_pInternalInfo->ValuePresent) && (TI != btVoid)) {
        if (m_pInternalInfo->ValuePresent) {
            memcpy(data, &m_pInternalInfo->Value, Size);
            if (m_pInternalInfo->CopyDataInBuffer) {
                memcpy(m_pInternalInfo->TypeDataPointer, &m_pInternalInfo->Value, Size);
                m_pInternalInfo->TypeDataPointer += Size;
            }
            m_pInternalInfo->ValuePresent = FALSE;
        } else {
            READ_BYTES((PVOID) data, addr, Size);
        }
        switch (Size) {
        case 1:
            val = (LONG64) *((PCHAR) data) ;
            break;
        case 2:
            val = (LONG64) *((PSHORT) data) ;
            break;
        case 4:
            val = (LONG64) *((PLONG) data) ;
            break;
        case 8:
            val = *((PULONG64) data) ;
            break;
        default:
            val = *((PULONG64) data) ;
            break;
        }

        if (m_pInternalInfo->RefFromPtr) typPrint(" -> "); // Its referred from pointer

        if ((m_pInternalInfo->InvalidAddress == addr) && (m_pInternalInfo->ErrorStatus == MEMORY_READ_ERROR)) {
            ExtPrint("Error : Can't read value");
            typPrint("??\n");
            CopySymParamName("??");
            return 0;
        }
    }


    CHAR Buffer1[50] = {0}, Buffer2[50] = {0}, Buffer3[50]={0};
    PSTR PrintOnAddr=&Buffer1[0], PrintOnNoAddr=&Buffer2[0], TypRetPrint;
    TypRetPrint = PrintOnAddr;

    switch (TI) {
    case btNoType:
        vprintf("No type");
        break;
    case btVoid:
        PrintOnNoAddr = "Void";
        break;
    case btWChar: {
        WCHAR w[2], v;
        PrintOnNoAddr = "Wchar";
        v = w[0]=*((WCHAR *) &data[0]); w[1]=0;
        if (v && !IsPrintWChar(w[0])) w[0] = 0;
        sprintf(PrintOnAddr,"%#lx '%ws'", v, w);
        break;
    }
    case btInt:
        if (Size != 1) {
            sprintf(PrintOnNoAddr,"Int%lxB", Size);
            StrprintInt(PrintOnAddr, val, Size);
            TypRetPrint = &Buffer3[0];
            StrprintUInt(TypRetPrint, val, Size);
            break;
        } else {
            // fall through
        }
    case btChar:{
        CHAR c[2], v;
        v = c[0]= *((CHAR *) &data[0]); c[1]=0;
        PrintOnNoAddr = "Char";
        if (v && !IsPrintChar(c[0])) c[0] = '\0';
        sprintf(PrintOnAddr, "%ld '%s'", v, c);
        TypRetPrint = &Buffer3[0];
        sprintf(TypRetPrint, "%#lx '%s'", (ULONG) (UCHAR) v, c);
        break;
    }
    case btUInt:
        if (Size != 1) {
            sprintf(PrintOnNoAddr, "Uint%lxB", Size);
            StrprintUInt(PrintOnAddr, val, Size);
            break;
        } else {
            CHAR c[2], v;
            v = c[0]= *((CHAR *) &data[0]); c[1]=0;
            PrintOnNoAddr = "UChar";
            if (v && !IsPrintChar(c[0])) c[0] = '\0';
            sprintf(PrintOnAddr, "%ld '%s'", v, c);
            TypRetPrint = &Buffer3[0];
            sprintf(TypRetPrint, "%#lx '%s'", (ULONG) (UCHAR) v, c);
            PrintOnAddr = TypRetPrint;
            break;
    }
    case btFloat: {
        PrintOnNoAddr = "Float";

        if (Size == 4) {
            float* flt = (float *) data;
            sprintf(PrintOnAddr, "%1.10g ", *flt);
        } else if (Size == 8) {
            double* flt = (double *) data;
            sprintf(PrintOnAddr, "%1.20g ", *flt);
        } else {
            for (USHORT j= (USHORT) Size; j>0; ) {
                sprintf(PrintOnAddr, "%02lx", data[j]);
                PrintOnAddr+=2;
                if (!((--j)%4)) {
                    sprintf(PrintOnAddr, " ");
                    PrintOnAddr++;
                }
            }
        }
        break;
    }
    case btBCD:
        break;
    case btBool:
        PrintOnNoAddr = "Bool";
        sprintf(PrintOnAddr,"%I64lx", val);
        break;
#if 0
    case btShort:
        sprintf(PrintOnNoAddr,"Int%lxB", Size);
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, Size);
        break;
    case btUShort:
        sprintf(PrintOnNoAddr, "Uint%lxB", Size);
        StrprintUInt(PrintOnAddr, val, Size);
        break;
    case btLong:
        sprintf(PrintOnNoAddr, "Int%lxB", Size);
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, Size);
        break;
    case btULong:
        sprintf(PrintOnNoAddr, "Uint%lxB", Size);
        StrprintUInt(PrintOnAddr, val, Size);
        break;
    case btInt8:
        PrintOnNoAddr = "Int1B";
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, 1);
        Size=1;
        break;
    case btInt16:
        Size = 2;
        PrintOnNoAddr = "Int2B";
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, Size);
        break;
    case btInt64:
        Size = 8;
        PrintOnNoAddr = "Int8B";
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, 8);
        break;
    case btInt128:
        Size = 16;
        PrintOnNoAddr = "Int16B";
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, 8);
        break;
    case btUInt8:
        PrintOnNoAddr = "Uint1B";
        StrprintUInt(PrintOnAddr, val, Size);
        break;
    case btUInt16:
        PrintOnNoAddr = "Uint2B";
        StrprintUInt(PrintOnAddr, val, Size);
        break;
    case btUInt64:
        Size = 8;
        PrintOnNoAddr = "Uint8B";
        StrprintUInt(TypRetPrint, val, 8);
        break;
    case btUInt128:
        Size = 16;
        PrintOnNoAddr = "Uint16B";
        StrprintUInt(PrintOnAddr, val, Size);
//        sprintf(PrintOnAddr, "%I64lx", val);
//        sprintf(TypRetPrint, "0x%s", FormatDisp64(val));
        break;
#endif // 0
    case btLong:
        Size = 4;
        PrintOnNoAddr = "Int4B";
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, Size);
        break;
    case btULong:
        Size = 4;
        PrintOnNoAddr = "Uint4B";
        StrprintUInt(PrintOnAddr, val, Size);
        break;
    case btCurrency:
    case btDate:
    case btVariant:
    case btComplex:
    case btBit:
    case btBSTR:
        break;
    case btHresult:
        ULONG hrVal;
        PrintOnNoAddr = "HRESULT";
        Size = 4;
        if (addr) {
            hrVal = *((PULONG) data);
            sprintf(PrintOnAddr,"%lx", hrVal);
//            EXT_PRINT_INT(hrVal);
        }
        break;
    default:
        vprintf("Error in ProcessBaseType: Unknown TI %lx\n", TI);
        break;
    }
    CopySymParamName(PrintOnNoAddr);
    if (!addr) {
        typPrint(PrintOnNoAddr);
    } else {
        typPrint(PrintOnAddr);
//        ExtPrint(PrintOnAddr);
        ExtPrint(TypRetPrint);
    }

#undef CopySymParamName
    if (!(m_pInternalInfo->TypeOptions & DBG_DUMP_COMPACT_OUT)) {
        typPrint("\n");
    }
    if (pTypeReturnSize) {
        *pTypeReturnSize = (ULONG) Size;
    }

    return Size;
}

ULONG
DbgTypes::ProcessPointerType(
    IN ULONG TI,
    IN ULONG ChildTI,
    IN ULONG Size)
{
    ULONG64 savedOffset=m_pInternalInfo->totalOffset;
    BOOL   CopyData=FALSE, savedPtrRef=m_pInternalInfo->RefFromPtr;
    ULONG  savedOptions = m_pInternalInfo->TypeOptions;
    PVOID  savedContext = m_pDumpInfo->Context;
    PUCHAR DataBuffer;
    ULONG64 tmp, addr;
    ULONG  Options = m_pInternalInfo->TypeOptions;
    ULONG  retSize = Size;
    BOOL   ProcessSubType;

//    if ((Options & DBG_RETURN_TYPE) && m_ParentTag == SymTagPointerType) {
//        return Size;
//    }

    addr=0;
    tmp=m_pDumpInfo->addr;

    ProcessSubType = !(Options & GET_SIZE_ONLY) &&
        (!m_pInternalInfo->InUnlistedField || m_pInternalInfo->DeReferencePtr || m_pInternalInfo->ArrayElementToDump);

    ProcessSubType = ProcessSubType &&  (!(Options & DBG_DUMP_BLOCK_RECURSE) || (m_pInternalInfo->level == 0)) &&
        !(Options & DBG_DUMP_FUNCTION_FORMAT);

    if (m_pDumpInfo->addr || m_pInternalInfo->ValuePresent) {
        // Non zero address, dump value
        if (m_pInternalInfo->ValuePresent) {
            memcpy(&addr, &m_pInternalInfo->Value, Size);
            if (m_pInternalInfo->CopyDataInBuffer) {
                memcpy(m_pInternalInfo->TypeDataPointer, &m_pInternalInfo->Value, Size);
                m_pInternalInfo->TypeDataPointer += Size;
            }
            m_pInternalInfo->ValuePresent = FALSE;

        } else {
            READ_BYTES(&addr, GetDumpAddress(), Size);
        }
        if (!g_Machine->m_Ptr64) {
            //
            // Signextend the read pointer value
            //
            addr = (ULONG64) (LONG64) (LONG) addr;

        }

        STORE_INFO(TI, GetDumpAddress(), Size, 1,addr);

        if ((!m_pNextSym || !*m_pNextSym) &&
            ((m_ParentTag == SymTagPointerType) && (m_pSymPrefix && *m_pSymPrefix == '*'))) {
            ++m_pSymPrefix;
        }

        if (m_pInternalInfo->CopyDataInBuffer && !m_pInternalInfo->CopyDataForParent) {
            if (m_pInternalInfo->ErrorStatus == MEMORY_READ_ERROR &&
                m_pInternalInfo->InvalidAddress == GetDumpAddress()) {
                m_pInternalInfo->TypeDataPointer += Size;
            }
            *((PULONG64) (m_pInternalInfo->TypeDataPointer - Size)) = addr;
            //
            // We return size as 8 for 32 bit *copied* pointers.
            //
            m_pInternalInfo->TypeDataPointer -= Size;
            // advance the pointer
            retSize = 8;
            m_pInternalInfo->TypeDataPointer += retSize;

            CopyData = TRUE;
            DataBuffer = m_pInternalInfo->TypeDataPointer;
            m_pInternalInfo->CopyDataInBuffer = FALSE;
            m_pInternalInfo->TypeDataPointer  = NULL;
        }

    } else {
        if (!m_pInternalInfo->InUnlistedField) {
            typPrint("Ptr%2d ", Size*8);
            vprintf("to ");
            STORE_INFO(TI, GetDumpAddress(), Size, 1,0);

        }
    }
    if (m_pDumpInfo->addr && !m_pInternalInfo->ArrayElementToDump) {
        if (savedPtrRef) ExtPrint(" -> "); // Its referred from pointer
        ExtPrint("%s ", FormatAddr64(addr));
        m_pInternalInfo->RefFromPtr = 1;
        if (Options & (DBG_RETURN_TYPE | DBG_RETURN_SUBTYPES)) {

            if (Options & DBG_RETURN_SUBTYPES && m_ParentTag) {
                // Parent has been processed, now is time to return its subtype

                m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
                m_pInternalInfo->TypeOptions |= DBG_RETURN_TYPE;

                STORE_PARENT_EXPAND_ADDRINFO(GetDumpAddress());

                Options &= ~DBG_RETURN_SUBTYPES;
                Options |= DBG_RETURN_TYPE;
            }

            if (Options & DBG_RETURN_TYPE_VALUES) {
                m_pDumpInfo->addr=addr;
                m_pInternalInfo->totalOffset=0;
                if (CheckAndPrintStringType(ChildTI, m_pInternalInfo->PointerStringLength)) {
                    ProcessSubType = FALSE;
                }
            }
            if (Options & DBG_RETURN_TYPE) {
                m_pInternalInfo->TypeOptions &= ~DBG_RETURN_TYPE_VALUES;
                if (!m_pSymPrefix || *m_pSymPrefix != '*') {
                    ProcessSubType = FALSE;
                }
                //ProcessSubType = FALSE;
                //goto ExitPtrType;
            }
        }

        m_pDumpInfo->addr=addr;
        m_pInternalInfo->totalOffset=0;
        if (!m_pInternalInfo->InUnlistedField) {
            if (savedPtrRef) typPrint(" -> "); // Its referred from pointer
            if (addr) {
                typPrint( "0x%s ", FormatAddr64(addr));
                if (CheckAndPrintStringType(ChildTI, m_pInternalInfo->PointerStringLength)) {
                    ProcessSubType = FALSE;
                    m_pInternalInfo->PointerStringLength = 0;
                }
                if (m_thisPointerDump) {
                    // Check for thisAdjust of function in scope
                    ULONG thisAdjust;
                    GetThisAdjustForCurrentScope(g_Process, &thisAdjust);
                    if (thisAdjust) {
                        typPrint(" (-%lx)", thisAdjust);
                    }
                }
                if (!(Options & VERBOSE) &&
                    (m_pInternalInfo->level == 0) &&
                    !(Options & DBG_DUMP_COMPACT_OUT))
                    typPrint("\n");
            } else {
                typPrint("(null) ");
            }
        }

        if (ProcessSubType && !addr) ProcessSubType = FALSE;
        m_pInternalInfo->PtrRead = TRUE;
    } else {
        // Just change the atart address, do not print anything
        m_pDumpInfo->addr=addr;
        m_pInternalInfo->totalOffset=0;

    }

    if (ProcessSubType) {
        // get the type pointed by this
        if (m_pInternalInfo->ArrayElementToDump || (m_pNextSym && *m_pNextSym == '[')) {
            // treat pointer as an array
            ULONG64 ChSize;

            if (!SymGetTypeInfo(m_pInternalInfo->hProcess, m_pInternalInfo->modBaseAddr,
                                     ChildTI, TI_GET_LENGTH, (PVOID) &ChSize)) {
                return FALSE;
            }
            ULONG sParentTag = m_ParentTag;
            m_ParentTag = m_SymTag; m_SymTag = SymTagArrayType;


            ProcessArrayType(0, ChildTI, m_pInternalInfo->ArrayElementToDump,
                             ChSize* m_pInternalInfo->ArrayElementToDump, NULL);
            m_SymTag = m_ParentTag; m_ParentTag = sParentTag;
        } else {
            ProcessType(ChildTI);
        }
    } else {
        if (!(Options & DBG_DUMP_COMPACT_OUT)) typPrint("\n");
    }

//ExitPtrType:
    m_pInternalInfo->RefFromPtr = savedPtrRef ? 1 : 0;

    if (((m_pInternalInfo->InvalidAddress == GetDumpAddress()) &&
         (m_pInternalInfo->ErrorStatus == MEMORY_READ_ERROR))) {
        m_pInternalInfo->ErrorStatus = 0;
    } else if (m_pInternalInfo->ErrorStatus) {
        retSize = 0;
    }

    if (CopyData) {
        m_pInternalInfo->CopyDataInBuffer = TRUE;
        m_pInternalInfo->TypeDataPointer  = DataBuffer;
    }
    m_pInternalInfo->PtrRead = TRUE;
    m_pInternalInfo->totalOffset = savedOffset;
    m_pInternalInfo->TypeOptions = savedOptions;
    m_pDumpInfo->Context      = savedContext;
    m_pDumpInfo->addr=tmp;

    return retSize;
}

ULONG
DbgTypes::ProcessBitFieldType(
    IN ULONG               TI,
    IN ULONG               ParentTI,
    IN ULONG               length,
    IN ULONG               position)
{
    ULONG64 mask=0, tmp = 0;
    ULONG  Options = m_pInternalInfo->TypeOptions;

    vprintf("Bitfield ");

    STORE_INFO(ParentTI, GetDumpAddress(), (position + length+7)/8, 0,0);

    if (m_pDumpInfo->addr) {
        USHORT bitVal;
        UCHAR buffer[100];
        ULONG i=(position + length + 7)/8;
        ReadTypeData((PUCHAR)buffer, GetDumpAddress(), i, m_pInternalInfo->TypeOptions);
        tmp=0;

        for (i=(position + length - 1); (i!=(position-1));i--) {
            bitVal = (buffer[i/8] & (1 << (i%8))) ? 1 : 0;
            tmp = tmp << 1; tmp |= bitVal;
            mask = mask << 1; mask |=1;
            if (i == (position + length - 1)) {
                typPrint("0y%1d", bitVal);
                ExtPrint("0y%1d", bitVal);
            } else {
                typPrint("%1d", bitVal);
                ExtPrint("%1d", bitVal);
            }
        }

        if (length > 4) {
            typPrint(" (%#I64x)", tmp);
            ExtPrint(" (%#I64x)", tmp);
        }
        // Which place do we start writing the bits..
        if (!m_pInternalInfo->BitIndex) {
            m_pInternalInfo->BitIndex = TRUE;
        } else {
            tmp = tmp << position;
            mask = mask << position;
        }

        if (m_pInternalInfo->CopyDataInBuffer) {
            // Copy the bitfield values
            //    Special case, cannot read whole bytes, so do not
            //    advance the DataPointer

            // Copys using ULONGS, ULONG64 may cause alignment fault.
            PBYTE pb = (PBYTE) m_pInternalInfo->TypeDataPointer;
            while (mask) {
                *pb &= (BYTE) ~mask;
                *pb |= (BYTE) tmp;
                mask = mask >> 8*sizeof(BYTE); tmp = tmp >> 8*sizeof(BYTE);
                pb++;
            }
        }
    } else
        typPrint("Pos %d, %d Bit%s", position, length, (length==1 ? "":"s"));

    m_pInternalInfo->BitFieldRead = 1;
    m_pInternalInfo->BitFieldSize = length;
    m_pInternalInfo->BitFieldOffset = position;

    if (m_pDumpInfo->Fields &&
        (m_pDumpInfo->Fields[m_pInternalInfo->FieldIndex].fOptions & DBG_DUMP_FIELD_SIZE_IN_BITS)) {
        PFIELD_INFO_EX pField = &m_pDumpInfo->Fields[m_pInternalInfo->FieldIndex];

        pField->size = length;
        pField->address = (GetDumpAddress() << 3) + position;
    }

    if (!(Options & DBG_DUMP_COMPACT_OUT)) {
        typPrint("\n");
    }
    return (length+7)/8;
}

ULONG
DbgTypes::ProcessDataMemberType(
    IN ULONG               TI,
    IN ULONG               ChildTI,
    IN LPSTR               name,
    IN BOOL                bStatic)
{
    ULONG   off=0, szLen=0, fieldIndex=0, nameLen=0;

    ULONG   callbackResult=STATUS_SUCCESS, IsAParent=0;
    BOOL    called=FALSE, ParentCopyData=FALSE, copiedFieldData=FALSE, CopyName=m_pInternalInfo->CopyName;
    PUCHAR  ParentDataBuffer=NULL;
    TYPE_NAME_LIST fieldName = {0};
    ULONG   savedUnlisteField  = m_pInternalInfo->InUnlistedField;
    ULONG64 savedOffset   = m_pInternalInfo->totalOffset;
    ULONG64 savedAddress  = m_pDumpInfo->addr;
    ULONG   SavedBitIndex = m_pInternalInfo->BitIndex;
    ULONG   savedOptions  = m_pInternalInfo->TypeOptions;
    ULONG   savedfOptions = m_pInternalInfo->FieldOptions;
    ULONG   Options       = m_pInternalInfo->TypeOptions;
    HANDLE  hp = m_pInternalInfo->hProcess;
    ULONG64 base = m_pInternalInfo->modBaseAddr;
    BOOL    linkListFound;
    UINT    fieldNameLen=m_pInternalInfo->fieldNameLen;
    ULONG64 tmp, StaticAddr=0;

    if (bStatic) {
        if (!SymGetTypeInfo(hp, base, TI, TI_GET_ADDRESS, (PVOID) &StaticAddr)) {
            return FALSE;
        }
        if (m_pDumpInfo->addr) {
            m_pDumpInfo->addr = StaticAddr;
            m_pInternalInfo->totalOffset = 0;
        }
    } else if (!SymGetTypeInfo(hp, base, TI, TI_GET_OFFSET, (PVOID) &off)) {
        return 0;
    }

    if ((m_pDumpInfo->listLink) && (m_pInternalInfo->TypeOptions & LIST_DUMP)) {
        // Check if this is the field we want for list dump
        ULONG listIt;

        MatchListField(Name, &listIt, &IsAParent);

        if (listIt==1) {
            ULONG size;
            //
            // Save the address and type Index for the list
            //
            m_pDumpInfo->listLink->address = off + GetDumpAddress();
            m_pDumpInfo->listLink->size    = ChildTI;
            linkListFound                = TRUE;
            m_pInternalInfo->NextListElement  = 0;
            m_pInternalInfo->TypeOptions     |= NO_PRINT | GET_SIZE_ONLY;
            ParentCopyData               = m_pInternalInfo->CopyDataInBuffer;
            ParentDataBuffer             = m_pInternalInfo->TypeDataPointer;

            //
            // check if this has same type as root
            //
            if (ChildTI == m_pInternalInfo->rootTypeIndex &&
                m_pDumpInfo->addr) {
                m_pInternalInfo->NextListElement =
                    m_pDumpInfo->listLink->address;
                size = -1; // Fail the default list address finder
            } else {
                //
                // See if it is a pointer and get size
                //
                m_pDumpInfo->addr = 0;
                size  = ProcessType(ChildTI);

                m_pDumpInfo->addr = savedAddress;
                m_pInternalInfo->CopyDataInBuffer = ParentCopyData;
            }

#ifdef DBG_TYPE
            dprintf("Addr %p, off %p, fOff %d ", m_pDumpInfo->addr, m_pInternalInfo->totalOffset, off);
            dprintf("PtrRead %d, size %d, addr %p\n", m_pInternalInfo->PtrRead, size, saveAddr + m_pInternalInfo->totalOffset + off);
#endif
            m_pInternalInfo->TypeOptions=(Options=savedOptions);
            if (m_pInternalInfo->PtrRead && (size<=8) && m_pDumpInfo->addr) {
                PTYPE_NAME_LIST parTypes = m_pInternalInfo->ParentTypes;
                //
                // This field is a pointer to next elt of list.
                //
                if (!ReadTypeData((PUCHAR) &(m_pInternalInfo->NextListElement),
                                  m_pDumpInfo->listLink->address,
                                  size,
                                  m_pInternalInfo->TypeOptions)) {
                    m_pInternalInfo->InvalidAddress = GetDumpAddress();
                    m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
                }

                if (!g_Machine->m_Ptr64) {
                    m_pInternalInfo->NextListElement = (ULONG64) (LONG64) (LONG) m_pInternalInfo->NextListElement;
                }

                while (parTypes && parTypes->Next) parTypes= parTypes->Next;

                if (!strcmp(parTypes->Name, "_LIST_ENTRY")) {
                    //
                    // Parent is _LIST_LINK type
                    //
                    m_pInternalInfo->NextListElement -= (m_pInternalInfo->totalOffset + off);
                    if (!m_pInternalInfo->LastListElement) {
                        //
                        // read the other of Flink or Blink
                        //
                        if (!ReadTypeData((PUCHAR) &(m_pInternalInfo->LastListElement),
                                          GetDumpAddress() + (off ? 0 : size),
                                          size,
                                          m_pInternalInfo->TypeOptions)) {
                            m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
                            m_pInternalInfo->InvalidAddress = GetDumpAddress();
                        }

                        if (!g_Machine->m_Ptr64) {
                            m_pInternalInfo->LastListElement =
                                (ULONG64) (LONG64) (LONG) m_pInternalInfo->LastListElement;
                        }
                        m_pInternalInfo->LastListElement -= (m_pInternalInfo->totalOffset );
#ifdef DBG_TYPE
                        dprintf("Last Elt : %p, off:%x\n", m_pInternalInfo->LastListElement, off);
#endif
                    }
                    // dprintf("Next Elt : %p\n", m_pInternalInfo->NextListElement);
                }
            }
        }
    }

    if (m_pDumpInfo->nFields) {
        ULONG ListParent = IsAParent;
        // We can process only on specefied field of given struct

        fieldIndex = MatchField( name,
                                 m_pInternalInfo,
                                 m_pDumpInfo->Fields,
                                 m_pDumpInfo->nFields,
                                 &IsAParent);
        if (!IsAParent) IsAParent = ListParent;
        if (!fieldIndex && !IsAParent) {
            // Not the right field
            m_pDumpInfo->addr = savedAddress;
            m_pInternalInfo->totalOffset = savedOffset;
            return 0;
        }
    }

    fieldName.Name = &name[0];
    fieldName.Type = off;
    InsertTypeName(&m_pInternalInfo->ParentFields, &fieldName);
    m_pInternalInfo->StringSize   = 0;
    if (m_pInternalInfo->ParentTypes) {
        // We add the offsets only when this was accessed and child of some UDT
        m_pInternalInfo->totalOffset += off;
    }

    if (m_pDumpInfo->addr) {

        if (m_pInternalInfo->TypeOptions & DBG_RETURN_SUBTYPES) {

            m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
            m_pInternalInfo->TypeOptions |= DBG_RETURN_TYPE;
            m_pInternalInfo->CopyName = 0;
        }

    }


    if (IsAParent && !fieldIndex) {
        //
        // This field is not listed in Fields array, but one of its subfields is
        //
        m_pInternalInfo->InUnlistedField    = TRUE;
        m_pInternalInfo->TypeOptions       &= ~RECURSIVE;
        m_pInternalInfo->TypeOptions       |= ((ULONG) Options + RECURSIVE1) & RECURSIVE;
        Indent(m_pInternalInfo->level*3);
        if (!(Options & NO_OFFSET)) {
            if (bStatic) {
                typPrint("=%s ", FormatAddr64(StaticAddr));
            } else {
                typPrint("+0x%03lx ",  off + m_pInternalInfo->BaseClassOffsets);
            }
        }
        typPrint("%s", name);
        if (!(Options & (DBG_DUMP_COMPACT_OUT | NO_PRINT))) {
            nameLen = strlen(name);
            while (nameLen++ < fieldNameLen) typPrint(" ");
            typPrint(" : ");
        } else {
            typPrint(" ");
        }
        //
        // Array dump options are the same in the matching chain
        //
        if (m_pDumpInfo->nFields >= IsAParent)
        {
            m_pInternalInfo->FieldOptions =
                m_pDumpInfo->Fields[IsAParent-1].fOptions & DBG_DUMP_FIELD_ARRAY;
        }

        szLen = ProcessType(ChildTI);

        goto DataMemDone;
    } else {
        if (Options & DBG_DUMP_BLOCK_RECURSE) {
            m_pInternalInfo->TypeOptions       &= ~RECURSIVE;
            m_pInternalInfo->TypeOptions       |= ((ULONG) Options + RECURSIVE1) & RECURSIVE;
        }
        m_pInternalInfo->InUnlistedField = FALSE;
    }

#define ThisField m_pDumpInfo->Fields[fieldIndex-1]
//
// Signextend all copied pointer values
//
#define SignExtendPtrValue(pReadVal, sz)                                        \
{ if ((m_pInternalInfo->PtrRead) && (sz==4))   {sz=8;                                 \
     *((PULONG64) pReadVal) = (ULONG64) (LONG64) (LONG) *((PDWORD) (pReadVal)); }\
}


    if (((Options & CALL_FOR_EACH) && (fieldIndex ?
                                       !(ThisField.fOptions & NO_CALLBACK_REQ) : 1)) ||
        (m_pDumpInfo->nFields && (ThisField.fOptions & CALL_BEFORE_PRINT))) {
        //
        // We have to do a callback on this field before dumping it.
        //
        // ntsd should dump only if callback routine fails
        FIELD_INFO_EX fld;

        fld.fName = (PUCHAR)name;

        fld.address =  m_pInternalInfo->totalOffset + m_pDumpInfo->addr;
        fld.fOptions = Options;

        if (m_pDumpInfo->nFields) {
            fld.fName = ThisField.fName;
            fld.fOptions = ThisField.fOptions;
            if ( fieldIndex &&
                 (ThisField.fOptions & COPY_FIELD_DATA) &&
                 ThisField.fieldCallBack) {
                //
                // Copy the field data, if required
                //
                ParentCopyData = m_pInternalInfo->CopyDataInBuffer;
                ParentDataBuffer = m_pInternalInfo->TypeDataPointer;
                SavedBitIndex = m_pInternalInfo->BitIndex;
                m_pInternalInfo->CopyDataInBuffer = TRUE;
                m_pInternalInfo->TypeDataPointer  = (PUCHAR)ThisField.fieldCallBack;
                m_pInternalInfo->BitIndex = 0;
                copiedFieldData = TRUE;
            }
        }


        // Get size of the field
        m_pInternalInfo->TypeOptions = ( Options |= NO_PRINT | GET_SIZE_ONLY);
        SymGetTypeInfo(hp, base, ChildTI, TI_GET_LENGTH, &szLen);
        fld.size = szLen;

        if (m_pDumpInfo->addr) {
            if (!(fld.fOptions & DBG_DUMP_FIELD_RETURN_ADDRESS) && (fld.size<=8)) {
                fld.address=0;
                ReadTypeData((PUCHAR) &(fld.address),
                             (GetDumpAddress() + (m_pInternalInfo->BitFieldRead ? m_pInternalInfo->BitFieldOffset/8 : 0)),
                             (m_pInternalInfo->BitFieldRead ? (((m_pInternalInfo->BitFieldOffset % 8) + m_pInternalInfo->BitFieldSize + 7)/8) : fld.size),
                             m_pInternalInfo->TypeOptions);
                SignExtendPtrValue(&fld.address, fld.size);

                if (m_pInternalInfo->BitFieldRead) {
                    fld.address = fld.address >> (m_pInternalInfo->BitFieldOffset % 8);
                    fld.address &= (0xffffffffffffffff >> (64 - m_pInternalInfo->BitFieldSize));
                }
            }
        }

        //
        // Do Callback
        //
        if (fieldIndex &&
            ThisField.fieldCallBack &&
            !(ThisField.fOptions & COPY_FIELD_DATA)) {
            // Local for field
            callbackResult =
                (*((PSYM_DUMP_FIELD_CALLBACK_EX)
                   ThisField.fieldCallBack))(&(fld),
                                             m_pDumpInfo->Context);
            called=TRUE;
        } else if (m_pDumpInfo->CallbackRoutine != NULL) {
            // Common callback
            callbackResult=
                (*(m_pDumpInfo->CallbackRoutine))(&(fld),
                                                m_pDumpInfo->Context);
            called=TRUE;
        }
        m_pInternalInfo->TypeOptions=(Options=savedOptions);
    }

    if (callbackResult != STATUS_SUCCESS) {
        goto DataMemDone;
    }

    // Print the field name / offset
    Indent(m_pInternalInfo->level*3);
    if (!(Options & NO_OFFSET)) {
        if (bStatic) {
            typPrint("=%s ", FormatAddr64(StaticAddr));
        } else {
            typPrint("+0x%03lx ",  off + m_pInternalInfo->BaseClassOffsets);
        }
    }
    typPrint("%s", ( (fieldIndex && ThisField.printName ) ?
                     ThisField.printName : (PUCHAR)name ));

    if (fieldIndex && ThisField.printName ) {
        typPrint(" ");
    } else if (!(Options & (DBG_DUMP_COMPACT_OUT | NO_PRINT))) {
        nameLen = strlen(name);
        while (nameLen++ < fieldNameLen) typPrint(" ");
        typPrint(" : ");
    } else {
        typPrint(" ");
    }

    //
    // We need to get type of this field.
    //
    tmp = m_pDumpInfo->addr;

    if (fieldIndex &&
        (ThisField.fOptions &
         (DBG_DUMP_FIELD_STRING | DBG_DUMP_FIELD_ARRAY))) {
        m_pInternalInfo->FieldOptions =
            (ThisField.fOptions &
             (DBG_DUMP_FIELD_STRING | DBG_DUMP_FIELD_ARRAY));
        if (m_pInternalInfo->AltFields[fieldIndex-1].ArrayElements) {
            if (m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_ARRAY) {
                m_pInternalInfo->arrElements = (USHORT) m_pInternalInfo->AltFields[fieldIndex-1].ArrayElements;
            } else {
                //  m_pInternalInfo->StringSize = (USHORT) ThisField.size;
            }
        }
    }

    //
    // Special cases - handle strings
    //
    if (m_pDumpInfo->addr && !strcmp(name, "Buffer")) {
        PCHAR ParentName = NULL;


        if (!(ParentName = GetParentName(m_pInternalInfo->ParentTypes))) {
            // Must referrred directly thru one DBG_RETURN TYPES

        } else if (!strcmp(ParentName,"_ANSI_STRING") ||
                   !strcmp(ParentName,"_STRING") ||
                   (!strcmp(ParentName, "_UNICODE_STRING"))) {
            m_pInternalInfo->FieldOptions |= (ParentName[1]!='U') ? DBG_DUMP_FIELD_DEFAULT_STRING : DBG_DUMP_FIELD_WCHAR_STRING;

            // Read in the Length Field for string length to be displayed
            ReadTypeData((PBYTE) &m_pInternalInfo->StringSize,
                         (GetDumpAddress() - 2*sizeof(USHORT)),
                         sizeof(m_pInternalInfo->StringSize),
                         m_pInternalInfo->TypeOptions);
            if (ParentName[1]=='U') m_pInternalInfo->StringSize = m_pInternalInfo->StringSize << 1;
        }
    }


    if (fieldIndex && (ThisField.fOptions & RECUR_ON_THIS)) {
        // Increase the recursive dump level for this field
        m_pInternalInfo->TypeOptions |= ((ULONG) Options + RECURSIVE1) & RECURSIVE;
    } else if (IsAParent) {
        m_pInternalInfo->TypeOptions |= ((ULONG) Options + RECURSIVE1) & RECURSIVE;
    }
    if ( fieldIndex &&
         (ThisField.fOptions & COPY_FIELD_DATA) &&
         ThisField.fieldCallBack) {
        //
        // Copy the field data, if required
        //
        if (!copiedFieldData) {
            ParentCopyData = m_pInternalInfo->CopyDataInBuffer;
            ParentDataBuffer = m_pInternalInfo->TypeDataPointer;
        }
        m_pInternalInfo->CopyDataInBuffer = TRUE;
        m_pInternalInfo->TypeDataPointer  = (PUCHAR)ThisField.fieldCallBack;
    }
    // Dump the field
    ULONG bitPos;
    if (SymGetTypeInfo(hp, base, TI, TI_GET_BITPOSITION, &bitPos)) {
        ULONG64 len;
        SymGetTypeInfo(hp, base, TI, TI_GET_LENGTH, &len);
        szLen = ProcessBitFieldType(ChildTI, TI, (ULONG) len, bitPos);
    } else {
        szLen = ProcessType(ChildTI);
    }
    m_pInternalInfo->TypeOptions = savedOptions;


    if (fieldIndex && !(ThisField.fOptions & DBG_DUMP_FIELD_SIZE_IN_BITS)) {
        // Address and size are returned through Fields record
        ThisField.address = m_pInternalInfo->totalOffset +
                                m_pDumpInfo->addr;
    }

    if (fieldIndex &&
        (ThisField.fOptions &
         (DBG_DUMP_FIELD_STRING | DBG_DUMP_FIELD_ARRAY))) {
        m_pInternalInfo->TypeOptions = savedOptions;
        Options=savedOptions;
    }

    if (m_pDumpInfo->addr && fieldIndex) {
        //
        // Return data for the field, if it is asked for
        //
        if ( (ThisField.fOptions & COPY_FIELD_DATA) &&
             ThisField.fieldCallBack) {

            if (ParentCopyData && ParentDataBuffer) {
                //
                // Copy the field data, into the parent's buffer too
                //

                memcpy( ParentDataBuffer,
                        (PUCHAR) ThisField.fieldCallBack,
                        (m_pInternalInfo->TypeDataPointer - (PUCHAR) ThisField.fieldCallBack));
                ParentDataBuffer += (m_pInternalInfo->TypeDataPointer -  (PUCHAR) ThisField.fieldCallBack);
            }
            m_pInternalInfo->CopyDataInBuffer = ParentCopyData;
            m_pInternalInfo->TypeDataPointer  = ParentDataBuffer;
            m_pInternalInfo->BitIndex         = SavedBitIndex;
        }
        if (!(ThisField.fOptions & DBG_DUMP_FIELD_RETURN_ADDRESS) &&
            (szLen <= 8)) {
            ThisField.address =0;
            ReadTypeData((PBYTE)
                         &ThisField.address,
                         (GetDumpAddress() + (m_pInternalInfo->BitFieldRead ? m_pInternalInfo->BitFieldOffset/8 : 0)),
                         (m_pInternalInfo->BitFieldRead ? (((m_pInternalInfo->BitFieldOffset % 8) + m_pInternalInfo->BitFieldSize + 7)/8) : szLen),
                         m_pInternalInfo->TypeOptions);
            SignExtendPtrValue(&ThisField.address, szLen);

            if (m_pInternalInfo->BitFieldRead) {
                ThisField.address = ThisField.address >> (m_pInternalInfo->BitFieldOffset % 8);
                ThisField.address &= (0xffffffffffffffff >> (64 - m_pInternalInfo->BitFieldSize));
            }
        }
    }
    CopyDumpInfo(szLen); // - redundant  ??

    if (fieldIndex && !(ThisField.fOptions & DBG_DUMP_FIELD_SIZE_IN_BITS)) {
        // Address and size are returned through Fields record
        ThisField.size  = szLen;
    }

    if (fieldIndex) {
        ThisField.FieldOffset = (ULONG) m_pInternalInfo->totalOffset;
        ThisField.TypeId   = TI;
        ThisField.fPointer = 0;
        if (m_pInternalInfo->BitFieldRead) {
            ThisField.BitField.Size = (USHORT) m_pInternalInfo->BitFieldSize;
            ThisField.BitField.Position = (USHORT) m_pInternalInfo->BitFieldOffset;
        } else if (m_pInternalInfo->PtrRead) {
            ThisField.fPointer = 1;
        }

    }
#undef SignExtendPtrValue

    if ((m_pDumpInfo->nFields)
        && fieldIndex && !called
        && !(m_pDumpInfo->Fields[fieldIndex-1].fOptions &
             NO_CALLBACK_REQ)) {
        //
        // Do Callback, if it wasn't done earlier.
        //
        if (ThisField.fieldCallBack &&
            !(ThisField.fOptions & COPY_FIELD_DATA)) {
            callbackResult =
                (*((PSYM_DUMP_FIELD_CALLBACK_EX)
                   ThisField.fieldCallBack))(&(ThisField),
                                             m_pDumpInfo->Context);
        } else if (m_pDumpInfo->CallbackRoutine != NULL) {
            callbackResult=
                (*(m_pDumpInfo->CallbackRoutine)
                 )(&(ThisField),
                   m_pDumpInfo->Context);
        }
    }
    m_pDumpInfo->addr = tmp;

    if ((Options & DBG_DUMP_COMPACT_OUT) && (callbackResult == STATUS_SUCCESS)) {
        typPrint("  ");
    }


DataMemDone:
        RemoveTypeName(&m_pInternalInfo->ParentFields);
        m_pInternalInfo->CopyName           = CopyName ? 1 : 0;
        m_pInternalInfo->TypeOptions        = savedOptions;
        m_pInternalInfo->FieldOptions       = savedfOptions;
        m_pInternalInfo->totalOffset        = savedOffset;
        m_pInternalInfo->InUnlistedField    = savedUnlisteField;
        m_pInternalInfo->PtrRead            = FALSE;
        m_pInternalInfo->BitFieldRead       = FALSE;
        m_pDumpInfo->addr                   = savedAddress;
#undef ThisField
        return szLen;
}


/*
   This sumps structs which are known to debugger in special format
*/
BOOL
DbgTypes::DumpKnownStructFormat(
    PCHAR name
    )
{
    ULONG Options = m_pInternalInfo->TypeOptions;
    ULONG ret =  DumpKnownStruct(name, m_pInternalInfo->TypeOptions, GetDumpAddress(), &m_pInternalInfo->PointerStringLength);
    if (ret && !m_pInternalInfo->level && !(Options & DBG_DUMP_COMPACT_OUT)) {
        typPrint("\n");
    }
    // print structs if..
    //    if (m_pInternalInfo->level && !(Options & DBG_DUMP_COMPACT_OUT)) {

    return ret;
}

#define MAX_RECUR_LEVEL (((Options & RECURSIVE) >> 8) + 1)

ULONG
DbgTypes::ProcessUDType(
    IN ULONG               TI,
    IN LPSTR               name)
{
    HANDLE  hp   = m_pInternalInfo->hProcess;
    ULONG64 base = m_pInternalInfo->modBaseAddr;
    ULONG64 size=0;
    ULONG   nelements, szLen=0, saveFieldOptions = m_pInternalInfo->FieldOptions;
    ULONG   Options = m_pInternalInfo->TypeOptions;
    BOOL    IsNestedType;
    BOOL    IsBaseClass=FALSE;
    HRESULT hr;
    ULONG   thisAdjust=0;

    if (!SymGetTypeInfo(hp, base, TI, TI_GET_LENGTH, (PVOID) &size)) {
        return 0;
    }

    hr = SymGetTypeInfo(hp, base, TI, TI_GET_VIRTUALBASECLASS, &IsBaseClass) ? S_OK : E_FAIL;

    hr = SymGetTypeInfo(hp, base, TI, TI_GET_NESTED, &IsNestedType) ? S_OK : E_FAIL;

    if ((hr == S_OK) && IsNestedType && !(Options & VERBOSE) && (m_ParentTag == SymTagUDT)) {
        return 0;
    }

    if (!SymGetTypeInfo(hp, base, TI, TI_GET_CHILDRENCOUNT, (PVOID) &nelements)) {
        return 0;
    }

    TYPE_NAME_LIST structName={0};

    vprintf("UDT ");

    if ((Options & (VERBOSE)) ||
        (!(m_pInternalInfo->PtrRead && m_pDumpInfo->addr) && (m_pInternalInfo->level == MAX_RECUR_LEVEL) && !IsBaseClass)) {
        // Print name if its elements cannot be printed or asked in Options
        typPrint("%s", name);
        ExtPrint("%s", name);
        if (Options & DBG_DUMP_COMPACT_OUT) {
            typPrint(" ");
        }
    }
    vprintf(", %d elements, 0x%x bytes\n", nelements, size);

    if (( m_pInternalInfo->CopyDataInBuffer ||  // Need to go in struct if it is to be copied
          !(Options & GET_SIZE_ONLY))) {
        //
        // Insert this struct's name in list of parent type names
        //
        structName.Name = &name[0];
        structName.Type = TI;

        InsertTypeName(&m_pInternalInfo->ParentTypes, &structName);
        if (m_AddrPresent) {

            if ((m_pInternalInfo->level < MAX_RECUR_LEVEL)) {
                //
                // We would be eventually reading everything in the struct, so cache it now
                //
                if (!ReadInAdvance(GetDumpAddress(), (ULONG) size, m_pInternalInfo->TypeOptions)) {
                    m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
                    m_pInternalInfo->InvalidAddress = GetDumpAddress();
                }
            } else if (m_pInternalInfo->CopyDataInBuffer) {
                // We won't be going in this, but still need to copy all data
                if (!ReadTypeData(m_pInternalInfo->TypeDataPointer,
                                  GetDumpAddress(),
                                  (ULONG) size,
                                  m_pInternalInfo->TypeOptions)) {
                    m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
                    m_pInternalInfo->InvalidAddress = m_pDumpInfo->addr + m_pInternalInfo->totalOffset;
                }

                m_pInternalInfo->TypeDataPointer += size;
            }

            if (Options & DBG_RETURN_TYPE) {

                STORE_INFO(TI, GetDumpAddress(),(ULONG)size, nelements, GetDumpAddress());
            }

            DumpKnownStructFormat(name);
            if (m_thisPointerDump) {
                // Check for thisAdjust of function in scope

                GetThisAdjustForCurrentScope(g_Process, &thisAdjust);
                if (thisAdjust) {
                    m_pDumpInfo->addr -= (LONG)thisAdjust;
                    vprintf("thisadjust %lx\n", thisAdjust);
                }
                m_thisPointerDump = FALSE;
            }
        }

        if ((m_pInternalInfo->level >= MAX_RECUR_LEVEL) ||
            ((Options & NO_PRINT) && !m_pDumpInfo->nFields && (MAX_RECUR_LEVEL == 1) &&
             !(Options & (DBG_DUMP_BLOCK_RECURSE | DBG_RETURN_TYPE | DBG_RETURN_SUBTYPES | DBG_DUMP_CALL_FOR_EACH | DBG_DUMP_LIST)))) {
            if (!(Options & VERBOSE) && !(Options & DBG_DUMP_COMPACT_OUT)) typPrint("\n");
            RemoveTypeName(&m_pInternalInfo->ParentTypes);
            // Commenting below out for '&' symbols
            // if (m_pDumpInfo->nFields)
            {
                STORE_INFO(TI, GetDumpAddress(),(ULONG)size, nelements, GetDumpAddress());
            }
            goto ExitUdt;
            return (ULONG) size;
        } else if (m_pInternalInfo->level && !(Options & VERBOSE)) {
            typPrint("\n");
        }

        //
        // This causes baseclass types to be stored overwriting legitimate member information
        // store in a previous baseclass
        if (m_ParentTag != SymTagUDT)
        {
            STORE_INFO(TI, GetDumpAddress(),(ULONG)size, nelements, GetDumpAddress());
        }

        ULONG push = m_pInternalInfo->CopyDataForParent ;
        m_pInternalInfo->CopyDataForParent = m_pInternalInfo->CopyDataInBuffer ?  1 : push;
        m_pInternalInfo->PtrRead = FALSE;
        m_pInternalInfo->RefFromPtr = FALSE;
        TI_FINDCHILDREN_PARAMS *pChildren;

        pChildren = (TI_FINDCHILDREN_PARAMS *) AllocateMem(sizeof(TI_FINDCHILDREN_PARAMS) + sizeof(ULONG) * nelements);
        if (!pChildren) {
            m_pInternalInfo->ErrorStatus = CANNOT_ALLOCATE_MEMORY;
            return 0;
        }

        pChildren->Count = nelements;
        pChildren->Start = 0;
        if (!SymGetTypeInfo(hp, base, TI, TI_FINDCHILDREN, (PVOID) pChildren)) {
            return 0;
        }
        ULONG i=m_pDumpInfo->nFields,fieldNameLen=16;

        if (i) {
            // Calculate maximum size of fiels to be dumped
            fieldNameLen=0;
            PFIELD_INFO_EX pField = m_pDumpInfo->Fields;

            while (i--) {
                PUCHAR dot = (PUCHAR)strchr((char *)pField->fName, '.');
                if (dot && m_pInternalInfo->ParentTypes) {
                    if (!strncmp((char *)pField->fName,
                                 (char *)m_pInternalInfo->ParentTypes->Name,
                                 dot - &(pField->fName[0]))) {
                        fieldNameLen = 16; // Back to default, cannnot calculate max size now
                        break;
                    }
                }
                if (pField->printName) {
                    fieldNameLen = (fieldNameLen>=(strlen((char *)pField->printName)-2) ?
                                    fieldNameLen : (strlen((char *)pField->printName)-2)); // -2 for " :"

                } else {
                    fieldNameLen = (fieldNameLen>=strlen((char *)pField->fName) ?
                                    fieldNameLen : strlen((char *)pField->fName));
                }

                pField++;
            }
        }
        m_pInternalInfo->fieldNameLen = fieldNameLen;
        i=0;
        ++m_pInternalInfo->level;


        while (i<nelements) {
            ULONG Tag;
            BOOL b;
            b = SymGetTypeInfo(hp, base, pChildren->ChildId[i], TI_GET_SYMTAG, &Tag);
//            dprintf("[Child %lx of UDT, tag %lx] ", i, Tag);

            if (b && (Tag == SymTagData || Tag == SymTagFunction || Tag == SymTagBaseClass || Tag == SymTagVTable)) {
                ProcessType(pChildren->ChildId[i]);
            } else if (Options & VERBOSE) {
                ProcessType(pChildren->ChildId[i]);
            }
            ++i;
        }

        --m_pInternalInfo->level;

        if (thisAdjust) {
            m_pDumpInfo->addr += (LONG)thisAdjust;
            m_thisPointerDump = TRUE;
        }

        if (Options & DBG_RETURN_SUBTYPES) {
            STORE_PARENT_EXPAND_ADDRINFO(GetDumpAddress());
        }

        FreeMem(pChildren);
        m_pInternalInfo->CopyDataForParent = push;
        m_pInternalInfo->FieldOptions = saveFieldOptions;
        RemoveTypeName(&m_pInternalInfo->ParentTypes);

    }
ExitUdt:

    return (ULONG) size;
}


ULONG
DbgTypes::ProcessEnumerate(
    IN VARIANT             var,
    IN LPSTR               name)
{
    ULONG64 val=0, readVal=0;
    ULONG sz=0;
    ULONG Options = m_pInternalInfo->TypeOptions;

    if ((m_pDumpInfo->addr)) {
        m_pInternalInfo->TypeOptions |= NO_PRINT;
        m_pInternalInfo->TypeOptions &= ~(DBG_RETURN_TYPE | DBG_RETURN_TYPE_VALUES);

        sz = ProcessVariant(var, NULL);

        m_pInternalInfo->TypeOptions = Options;
        if (sz > sizeof (readVal))
            sz = sizeof(readVal);
        //
        // Read the value at address and print name only if it matches
        //
        ReadTypeData((PUCHAR) &readVal,
                     GetDumpAddress(),
                     min(m_pInternalInfo->typeSize, sizeof(readVal)), // always read typesize of data
                     m_pInternalInfo->TypeOptions);

        memcpy(&val, &var.lVal, sz);
        if (val == readVal) {
//            typPrint(" ( %s )\n", name);
            typPrint("%I64lx ( %s )\n", val, name);
            ExtPrint("%I64lx ( %s )", val, name);
            m_pInternalInfo->newLinePrinted = TRUE;
            //
            // Found the name we were looking for, get out
            //

            // STORE_INFO(0, m_pDumpInfo->addr + m_pInternalInfo->totalOffset,sz, 0,0);

            return sz;
        }
    } else {

        if (m_pDumpInfo->nFields) {
            ULONG chk, dummy;
            // We can process only on specefied field of given struct

            chk = MatchField( name, m_pInternalInfo, m_pDumpInfo->Fields, m_pDumpInfo->nFields, &dummy);

            if ((!chk) || (chk>m_pDumpInfo->nFields)) {
                // Not the right field
                return sz;
            }
        }
        // No address / too large value, list the enumerate
        Indent(m_pInternalInfo->level*3);
        sz = ProcessVariant(var, name);
//        typPrint("%s = %x\n", name, val);
//        ExtPrint("%s = %I64lx", name, val);
        m_pInternalInfo->newLinePrinted = TRUE;
    }

    return sz;
}

ULONG
DbgTypes::ProcessEnumType(
    IN ULONG               TI,
    IN LPSTR               name)
{
    HANDLE  hp   = m_pInternalInfo->hProcess;
    ULONG64 base = m_pInternalInfo->modBaseAddr;
    ULONG64 size=0;
    DWORD   nelements;
    ULONG   Options = m_pInternalInfo->TypeOptions;
    ULONG   savedOptions;
    ULONG   BaseType;

    if (!SymGetTypeInfo(hp, base, TI, TI_GET_CHILDRENCOUNT, (PVOID) &nelements)) {
//        vprintf("num elts not found\n");
    }

    vprintf("Enum ");
    if ((!(m_pDumpInfo->addr) && (m_pInternalInfo->level == MAX_RECUR_LEVEL))
        || (Options &(VERBOSE))) typPrint("%s", name);
    vprintf(",  %d total enums\n", nelements);

    if ( !(m_pDumpInfo->addr) && m_pInternalInfo->level &&
        (m_pInternalInfo->level != MAX_RECUR_LEVEL) &&
        !(Options & VERBOSE)) {
        if (!(Options & DBG_DUMP_COMPACT_OUT)) typPrint("\n");
    }

    savedOptions = m_pInternalInfo->TypeOptions;

    if (m_pDumpInfo->addr)
        m_pInternalInfo->TypeOptions |= DBG_DUMP_COMPACT_OUT;

    if (Options & DBG_RETURN_TYPE) {
        m_pInternalInfo->TypeOptions &= ~DBG_RETURN_TYPE;
    }
    assert(!(Options & DBG_RETURN_SUBTYPES));

    m_pInternalInfo->TypeOptions |= NO_PRINT;

    if (!SymGetTypeInfo(hp, base, TI, TI_GET_TYPEID, (PVOID) &BaseType)) {
        return 0;
    }
    // This will copy the value if needed
    size = ProcessType(BaseType);
    m_pInternalInfo->typeSize = (ULONG)size;
    m_pInternalInfo->TypeOptions = savedOptions;
    Options=savedOptions;

    STORE_INFO(TI, GetDumpAddress(), (ULONG) size, 0, 0);
    if ((m_pInternalInfo->typeSize > 8) && m_pDumpInfo->addr) {
        // LF_ENUMERATE won't be able to display correctly
        // ParseTypeRecord(m_pInternalInfo, pEnum->utype, m_pDumpInfo);
    } else {
        ULONG save_rti = m_pInternalInfo->rootTypeIndex;

        if ((m_pInternalInfo->level >= MAX_RECUR_LEVEL) && !m_pDumpInfo->addr) {
            typPrint("\n");
            return  (ULONG) size;
        }
        m_pInternalInfo->rootTypeIndex = BaseType;
        TI_FINDCHILDREN_PARAMS *pChildren;

        pChildren = (TI_FINDCHILDREN_PARAMS *) AllocateMem(sizeof(TI_FINDCHILDREN_PARAMS) + sizeof(ULONG) * nelements);
        if (!pChildren) {
            m_pInternalInfo->ErrorStatus = CANNOT_ALLOCATE_MEMORY;
            return 0;
        }

        pChildren->Count = nelements;
        pChildren->Start = 0;
        if (!SymGetTypeInfo(hp, base, TI, TI_FINDCHILDREN, (PVOID) pChildren)) {
            return 0;
        }
        if (!m_pDumpInfo->addr) {
            m_pInternalInfo->level++;
        }
        ULONG i=0;
        BOOL  Copy;

        Copy = m_pInternalInfo->CopyDataInBuffer;
        m_pInternalInfo->CopyDataInBuffer = FALSE;
        m_pInternalInfo->IsEnumVal = TRUE;
        m_pInternalInfo->newLinePrinted = FALSE;

        while (i<nelements && (!m_pInternalInfo->newLinePrinted || !m_pDumpInfo->addr)) {
            ProcessType(pChildren->ChildId[i++]);
        }
        m_pInternalInfo->IsEnumVal = FALSE;
        if (!m_pDumpInfo->addr) {
            m_pInternalInfo->level--;
        }
        m_pInternalInfo->rootTypeIndex = save_rti;
        if (m_pDumpInfo->addr && !m_pInternalInfo->newLinePrinted) {
            m_pInternalInfo->TypeOptions |= DBG_DUMP_COMPACT_OUT;
            ProcessBaseType(TI, btUInt, (ULONG) size);

            typPrint(" (No matching name)\n");
            ExtPrint(" (No matching name)");
            m_pInternalInfo->TypeOptions = savedOptions;
        }
        m_pInternalInfo->CopyDataInBuffer = Copy;
    }

    return (ULONG) size;
}

ULONG
DbgTypes::ProcessArrayType(
    IN ULONG               TI,
    IN ULONG               eltTI,
    IN ULONG               count,
    IN ULONGLONG           size,
    IN LPSTR               name)
{
    DWORD  arrlen=(ULONG) size, eltSize=0, index=0, CopyData=FALSE;
    BOOL   OneElement=FALSE;
    PUCHAR savedBuffer=NULL;
    ULONG  savedOptions=m_pInternalInfo->TypeOptions;
    ULONG  ArrayElementsToDump, RefedElement=0;
    PVOID  savedContext = m_pDumpInfo->Context;
    ULONG  Options = m_pInternalInfo->TypeOptions;
    ULONG64 tmp;
    BOOL   bParentArrayDump;
    BOOL   bShowFullArray;

    eltSize = (ULONG) (count ?  (size / count) : size);
    if (m_pNextSym && *m_pNextSym == '[') {
        m_pInternalInfo->ArrayElementToDump = 1 + (ULONG) EvaluateSourceExpression(++m_pNextSym);
        while (*m_pNextSym && *(m_pNextSym++) != ']') {
        };
    }

    // Dump full array if asked for for this particular field or if we
    // are in block-recursive dump
    bShowFullArray = (m_pInternalInfo->FieldOptions & FIELD_ARRAY_DUMP) ||
        (m_pInternalInfo->TypeOptions & DBG_DUMP_BLOCK_RECURSE);

    // Get the array element index

    bParentArrayDump = FALSE;
    if (m_pInternalInfo->level && bShowFullArray)
    {
        ArrayElementsToDump = m_pInternalInfo->arrElements ? m_pInternalInfo->arrElements : count;
    } else
    {
        if (Options & DBG_RETURN_SUBTYPES)
        {
            ArrayElementsToDump = count;
        } else
        {
            ArrayElementsToDump = 1;
        }
        if (!m_pInternalInfo->level && (m_pInternalInfo->TypeOptions & DBG_DUMP_ARRAY)) {
            //
            // Let top array/list dump loop take care of this
            //
            m_pInternalInfo->nElements = (USHORT) count;
            m_pInternalInfo->rootTypeIndex = eltTI;
            m_typeIndex = eltTI;
            bParentArrayDump = TRUE;
        }
    }

    if (!name) {
        name = "";
    }

    if (//m_pDumpInfo->nFields &&
        m_pInternalInfo->ArrayElementToDump) {
        //
        // Only one particular element has to be precessesed
        //
        if (m_pInternalInfo->ArrayElementToDump) {
            m_pInternalInfo->totalOffset += eltSize * (m_pInternalInfo->ArrayElementToDump -1);
            typPrint("[%d]%s ", m_pInternalInfo->ArrayElementToDump - 1, name);
        }
        RefedElement = m_pInternalInfo->ArrayElementToDump - 1;
        m_pInternalInfo->ArrayElementToDump = 0;
        arrlen = eltSize;
        OneElement = TRUE;
    } else if (ArrayElementsToDump > 1 || bShowFullArray)
    {
        vprintf("(%d elements) %s ", count, name);
        if (!m_pInternalInfo->level) arrlen = eltSize;
    } else if (!bParentArrayDump) {
        typPrint("[%d]%s ", count, name);
    }

    if (m_pInternalInfo->CopyDataInBuffer && m_pInternalInfo->TypeDataPointer && m_pDumpInfo->addr &&
        (!OneElement || (Options & GET_SIZE_ONLY)) ) {
        //
        // Copy the data
        //
        if (!ReadTypeData(m_pInternalInfo->TypeDataPointer,
                          GetDumpAddress(),
                          arrlen,
                          m_pInternalInfo->TypeOptions)) {
            m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
            m_pInternalInfo->InvalidAddress = GetDumpAddress();
            return FALSE;
        }

        m_pInternalInfo->TypeDataPointer += arrlen;
        savedBuffer = m_pInternalInfo->TypeDataPointer;
        CopyData = TRUE;
        m_pInternalInfo->CopyDataInBuffer = FALSE;
    }

    if (OneElement) {
        STORE_INFO(eltTI, GetDumpAddress(),arrlen, count, GetDumpAddress());
    } else {
        STORE_INFO(TI, GetDumpAddress(),arrlen, count, GetDumpAddress());

        if (Options & (DBG_RETURN_TYPE)) {
            if ((Options & DBG_RETURN_TYPE_VALUES) &&
                !CheckAndPrintStringType(eltTI, 0)) {
                ExtPrint("Array [%d]", count);
            }
            return arrlen;
        }

    }
    if (Options & DBG_RETURN_SUBTYPES) {
        assert (m_pInternalInfo->NumSymParams == count);

        STORE_PARENT_EXPAND_ADDRINFO(GetDumpAddress());

        m_pInternalInfo->CurrentSymParam = count;
        m_pInternalInfo->CopyName = 0;
    }
    if (Options & GET_SIZE_ONLY) {
        return arrlen;
    }

    if (m_pDumpInfo->addr && !OneElement) {
        // Dump array contents
        tmp = m_pDumpInfo->addr;

        if (!(Options & DBG_RETURN_SUBTYPES) && !bParentArrayDump) {
            if (CheckAndPrintStringType(eltTI, (ULONG) size)) {
                typPrint("\n");
                return arrlen;
            }
        }

        if (bShowFullArray)
        {
            typPrint("\n");
        }

        do {
            if (Options & DBG_RETURN_SUBTYPES) {
                m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
                m_pInternalInfo->TypeOptions |=  DBG_RETURN_TYPE;
                ++m_pInternalInfo->level;
            }
            if (m_pInternalInfo->level && bShowFullArray)
            {
                Indent(m_pInternalInfo->level*3);
                typPrint(" [%02d] ", index);
            }
            eltSize=ProcessType(eltTI);

            if ((Options & DBG_DUMP_COMPACT_OUT ) && (Options & FIELD_ARRAY_DUMP) ) {
                typPrint("%s", ((eltSize>8) || (index % 4 == 0)) ? "\n":" ");
            }
            if (!eltSize) {
                return arrlen;
            }
            if (Options & DBG_RETURN_SUBTYPES) {
                --m_pInternalInfo->level;
            }
            m_pDumpInfo->addr+=eltSize;
        } while (++index < ArrayElementsToDump);
        m_pDumpInfo->addr=tmp;
    } else {
        eltSize = ProcessType(eltTI);
    }

    if (!size && !m_pInternalInfo->level) {
        size=eltSize;  // Return something, for success
    }
    if (CopyData) {
        m_pInternalInfo->TypeDataPointer  = savedBuffer;
        m_pInternalInfo->CopyDataInBuffer = TRUE;
    }
    if (m_pInternalInfo->level == MAX_RECUR_LEVEL &&
        !(OneElement)) {
        STORE_INFO(TI, GetDumpAddress(),arrlen, count, GetDumpAddress());
    }

    return bParentArrayDump ? eltSize : arrlen;
}

ULONG
DbgTypes::ProcessVTShapeType(
    IN ULONG               TI,
    IN ULONG               count)
{
    ULONG  Options = m_pInternalInfo->TypeOptions;
    ULONG  i;

    vprintf("%d entries", count);
    for (i=0; i<count;i++) {
        // The pointers

    }
    typPrint("\n");
    return FALSE;
}


ULONG
DbgTypes::ProcessVTableType(
    IN ULONG               TI,
    IN ULONG               ChildTI)
{
    ULONG  Options = m_pInternalInfo->TypeOptions;

    if (Options & DBG_RETURN_SUBTYPES) {
        m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
        m_pInternalInfo->TypeOptions |= DBG_RETURN_TYPE;
    } else {
    }
    if (m_pDumpInfo->nFields) {
        ULONG chk, dummy;
        FIELD_INFO Field;

        // We can process only on specefied field of given struct
        chk = MatchField( "__VFN_table", m_pInternalInfo, m_pDumpInfo->Fields, m_pDumpInfo->nFields, &dummy);

        if ((!chk) || (chk>m_pDumpInfo->nFields)) {
            // Not the right field
            return FALSE;
        }
        if (!(m_pDumpInfo->Fields[chk-1].fOptions & COPY_FIELD_DATA) &&
            (m_pDumpInfo->Fields[chk-1].fieldCallBack != NULL))
        {
            // Do the callback

            ZeroMemory(&Field, sizeof(Field));
            Field.fName    = (PUCHAR) "__VFN_table";
            Field.fOptions = m_pDumpInfo->Fields[chk-1].fOptions;
            Field.address  = m_pInternalInfo->totalOffset + m_pDumpInfo->addr;
            Field.FieldOffset = m_pInternalInfo->BaseClassOffsets;
            Field.TypeId   = TI;
            if ((*((PSYM_DUMP_FIELD_CALLBACK_EX)
                   m_pDumpInfo->Fields[chk-1].fieldCallBack))(&Field,
                                                              m_pDumpInfo->Context) !=
                STATUS_SUCCESS)
            {
                return FALSE;
            }

        }
    }
    Indent(m_pInternalInfo->level*3);
    typPrint("+0x%03lx __VFN_table : ", m_pInternalInfo->BaseClassOffsets);
    TI=ProcessType(ChildTI);
    if (Options & DBG_RETURN_SUBTYPES) {

        m_pInternalInfo->CurrentSymParam--;
        m_pInternalInfo->CurrentSymParam++;

        // Force not to expand VFN table
        m_pInternalInfo->TypeOptions = Options;
    }
    return TI;
}

ULONG
DbgTypes::ProcessBaseClassType(
    IN ULONG               TI,
    IN ULONG               ChildTI)
{
    ULONG  Options = m_pInternalInfo->TypeOptions;
    DWORD szLen=0;
    ULONG Baseoffset=0;

    if (!SymGetTypeInfo(m_pInternalInfo->hProcess, m_pInternalInfo->modBaseAddr,
                       TI, TI_GET_OFFSET, (PVOID) &Baseoffset)) {
        return 0;
    }

    if (Options & VERBOSE) {
        Indent(m_pInternalInfo->level * 3);
        if (!(Options & NO_OFFSET)) {
            typPrint("+0x%03x ", Baseoffset);
        }
        typPrint("__BaseClass ");
    }
    m_pInternalInfo->BaseClassOffsets += Baseoffset;
    m_pInternalInfo->totalOffset += Baseoffset;

    --m_pInternalInfo->level;
    szLen = ProcessType(ChildTI);

    m_pInternalInfo->BaseClassOffsets -= Baseoffset;
    m_pInternalInfo->totalOffset      -= Baseoffset;
    ++m_pInternalInfo->level;

    return szLen;
}


ULONG
DbgTypes::ProcessFunction(
    IN ULONG               TI,
    IN ULONG               ChildTI,
    IN LPSTR               name)
{
    ULONG  Sz, Options = m_pInternalInfo->TypeOptions;

    if ((Options & VERBOSE) || !m_pInternalInfo->level) {
        CHAR    Buffer[MAX_NAME];
        ANSI_STRING TypeName;
        TYPES_INFO TypeInfo;

        TypeInfo = m_TypeInfo;
        TypeInfo.TypeIndex = ChildTI;
        TypeName.MaximumLength = MAX_NAME;
        TypeName.Buffer = &Buffer[0];

        if (GetTypeName(NULL, &TypeInfo, &TypeName) != S_OK) {
            strcpy(Buffer, "<UnknownType>");
        }

        Indent(m_pInternalInfo->level*3);

        vprintf("%s ", Buffer, name);
        typPrint("%s ", name);

        m_pInternalInfo->TypeOptions |= DBG_DUMP_FUNCTION_FORMAT;
        Sz = ProcessType(ChildTI);
        m_pInternalInfo->TypeOptions = Options;
        if (Options & DBG_DUMP_COMPACT_OUT) {
            vprintf("; ");
        }
        return 1;
    }
    return FALSE;
}

ULONG
DbgTypes::ProcessFunctionType(
    IN ULONG               TI,
    IN ULONG               ChildTI
    )
{
    ULONG   Options = m_pInternalInfo->TypeOptions;
    ULONG64 funcAddr, currentfuncAddr, savedAddress;
    USHORT  saveLevel = m_pInternalInfo->level;
    ULONG64 Displacement=0;
    PDEBUG_SCOPE Scope = GetCurrentScope();
    CHAR name[MAX_NAME];
    PIMAGEHLP_SYMBOL64 ImghlpSym = (PIMAGEHLP_SYMBOL64) name;

    if (Options & DBG_RETURN_TYPE)
    {
        ExtPrint(" -function-");
    }

    savedAddress = funcAddr=m_pDumpInfo->addr;
    m_pDumpInfo->addr=0;

    m_pInternalInfo->TypeOptions |= DBG_DUMP_COMPACT_OUT;
    Indent(m_pInternalInfo->level* 3);
    m_pInternalInfo->level = (USHORT) MAX_RECUR_LEVEL;
    ImghlpSym->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL64);
    // Return type
    if (TypeVerbose)
    {
        CHAR    Buffer[MAX_NAME];
        ANSI_STRING TypeName;
        TYPES_INFO TypeInfo;

        TypeInfo = m_TypeInfo;
        TypeInfo.TypeIndex = ChildTI;
        TypeName.MaximumLength = MAX_NAME;
        TypeName.Buffer = &Buffer[0];

        if (GetTypeName(NULL, &TypeInfo, &TypeName) != S_OK) {
            strcpy(Buffer, "<UnknownType>");
        }
        vprintf(" %s ", Buffer);
    }

    if (funcAddr)
    {

        ImghlpSym->MaxNameLength = sizeof(name) - sizeof(IMAGEHLP_SYMBOL64);
        if (SymGetSymFromAddr64(m_pInternalInfo->hProcess,
                                funcAddr + m_pInternalInfo->totalOffset,
                                &funcAddr,
                                ImghlpSym))
        {
            funcAddr = ImghlpSym->Address;
        }
        GetSymbol(funcAddr + m_pInternalInfo->totalOffset,
                  &name[0], sizeof(name), &Displacement);

        if (!(Options & DBG_DUMP_FUNCTION_FORMAT))
        {

            typPrint(" ");
            ExtPrint(" ");

            typPrint("%s+%I64lx", name, Displacement);
            ExtPrint("%s+%I64lx", name, Displacement);

        }
    }
    m_pInternalInfo->level = saveLevel;
    if ((Options & DBG_DUMP_FUNCTION_FORMAT) ||
        (!m_pInternalInfo->level))
    {
        CHAR    Buffer[MAX_NAME];
        ANSI_STRING TypeName;
        TYPES_INFO TypeInfo;

        // Arguments
        ULONG nArgs;
        ULONG i=0;

        if (!SymGetTypeInfo(m_pInternalInfo->hProcess, m_pInternalInfo->modBaseAddr,
                                  TI, TI_GET_CHILDRENCOUNT, (PVOID) &nArgs))
        {
            return FALSE;
        }
        TI_FINDCHILDREN_PARAMS *pChildren;

        TypeName.Buffer = &Buffer[0];
        TypeInfo = m_TypeInfo;

        pChildren = (TI_FINDCHILDREN_PARAMS *) AllocateMem(sizeof(TI_FINDCHILDREN_PARAMS) + sizeof(ULONG) * nArgs);
        typPrint("(");
        if (pChildren)
        {

            pChildren->Count = nArgs;
            pChildren->Start = 0;
            if (!SymGetTypeInfo(m_pInternalInfo->hProcess, m_pInternalInfo->modBaseAddr,
                                     TI, TI_FINDCHILDREN, (PVOID) pChildren))
            {
                m_pDumpInfo->addr=savedAddress;
                m_pInternalInfo->level = saveLevel;
                return FALSE;
            }
            m_pInternalInfo->TypeOptions |= DBG_DUMP_COMPACT_OUT;

            if (Scope->Frame.InstructionOffset &&
                SymGetSymFromAddr64(m_pInternalInfo->hProcess,
                                    Scope->Frame.InstructionOffset,
                                    &currentfuncAddr,
                                    ImghlpSym)) {
                currentfuncAddr = ImghlpSym->Address;
            } else {
                currentfuncAddr=0;
            }

            if (funcAddr == currentfuncAddr && funcAddr && !(Options & NO_PRINT)) {
                IMAGEHLP_STACK_FRAME StackFrame;

                //    SetCurrentScope to this function address, not the return address
                //    since we only want to enumerate the parameters
                g_EngNotify++;
//                StackFrame = (IMAGEHLP_STACK_FRAME) Scope->Frame;
                StackFrame.InstructionOffset = currentfuncAddr;
                SymSetContext(g_Process->m_SymHandle,
                              &StackFrame, NULL);
            }

            while (i<nArgs)
            {
                m_pInternalInfo->level = (USHORT) MAX_RECUR_LEVEL;
                TypeInfo.TypeIndex = pChildren->ChildId[i];
                TypeName.MaximumLength = MAX_NAME;
                if (GetTypeName(NULL, &TypeInfo, &TypeName) != S_OK)
                {
                    ProcessType(pChildren->ChildId[i]);
                }
                else
                {
                    typPrint(Buffer);
                }
                i++;
                //
                // If this is *the* current scoped function, print arg values too
                //
                if (funcAddr == currentfuncAddr && funcAddr && !(Options & NO_PRINT))
                {
                    // print i'th parameter
                    typPrint(" ");
                    PrintParamValue(i-1);
                }
                if (i < nArgs)
                {
                    typPrint(", ");
                }
            }
            if (funcAddr == currentfuncAddr && funcAddr && !(Options & NO_PRINT)) {
                //    Reset the scope back to original
                SymSetContext(g_Process->m_SymHandle,
                              (PIMAGEHLP_STACK_FRAME) &Scope->Frame , NULL);
                g_EngNotify--;
            }
            FreeMem(pChildren);
        }
        if (nArgs == 0 && i == 0)
        {
            typPrint(" void ");
        }
        typPrint(")");

    }
    if (funcAddr && (Options & DBG_DUMP_FUNCTION_FORMAT) && Displacement)
    {
        vprintf("+%s", FormatDisp64(Displacement));
    }
    m_pInternalInfo->TypeOptions = Options;
    m_pInternalInfo->level = saveLevel;
    if (!( Options & DBG_DUMP_COMPACT_OUT) )
    {
        typPrint("\n");
    }
    m_pDumpInfo->addr=savedAddress;
    m_pInternalInfo->level = saveLevel;
    return TRUE;
}

ULONG
DbgTypes::ProcessFunctionArgType(
    IN ULONG               TI,
    IN ULONG               ChildTI
    )
{
    ULONG   Options = m_pInternalInfo->TypeOptions;
    ULONG  sz;

    Indent(m_pInternalInfo->level *3);
//    typPrint(" arg = ");
    sz = ProcessType(ChildTI);

    return TRUE;
}


PSTR
UnicodeToAnsi(
    PWSTR pwszUnicode
    )
{
    UINT uSizeAnsi;
    PSTR pszAnsi;

    if (!pwszUnicode) {
        return NULL;
    }

    uSizeAnsi = wcslen(pwszUnicode) + 1;
    pszAnsi = (PSTR)malloc(uSizeAnsi);

    if (*pwszUnicode && pszAnsi) {

        ZeroMemory(pszAnsi, uSizeAnsi);
        if (!WideCharToMultiByte(CP_ACP, WC_SEPCHARS | WC_COMPOSITECHECK,
            pwszUnicode, wcslen(pwszUnicode),
            pszAnsi, uSizeAnsi, NULL, NULL)) {

            // Error. Free the string, return NULL.
            free(pszAnsi);
            pszAnsi = NULL;
        }
    }

    return pszAnsi;
}


ULONG
DbgTypes::ProcessType(
    IN ULONG typeIndex
    )
{
    ULONG64 Size;
    BSTR    wName= NULL;
    LPSTR   Name = "";
    ULONG   Options;
    HANDLE  hp   = m_pInternalInfo->hProcess;
    ULONG64 base = m_pInternalInfo->modBaseAddr;
    ULONG   Parent=m_ParentTag, SymTag=m_SymTag;
    BOOL    NameAllocated = FALSE;

    m_ParentTag = m_SymTag;
    Size = 0;

    if (m_pInternalInfo->CopyDataInBuffer && !m_pDumpInfo->addr) {
        m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
        m_pInternalInfo->InvalidAddress = 0;
    }

    Options = m_pInternalInfo->TypeOptions;

    if (IsDbgGeneratedType(typeIndex)) {
    } else if (IsDbgNativeType(typeIndex)) {
        Size = GetNativeTypeSize((PCHAR) m_pDumpInfo->sName, typeIndex);
        ProcessBaseType(typeIndex, NATIVE_TO_BT(typeIndex), (ULONG) Size);
        m_ParentTag = Parent; m_SymTag=SymTag;
        return (ULONG) Size;
    }

    if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMTAG, (PVOID) &m_SymTag)) {
        return FALSE;
    }
    if (g_EngStatus & ENG_STATUS_USER_INTERRUPT) {
        return FALSE;
    }
    if (0 && (m_SymTag != SymTagBaseType) && (m_pInternalInfo->level > MAX_RECUR_LEVEL)) {
        if (!(Options & DBG_DUMP_COMPACT_OUT)) typPrint("\n");
        m_pInternalInfo->newLinePrinted = TRUE;
        return FALSE;
    }

    if (m_pInternalInfo->CopyDataInBuffer && m_pInternalInfo->TypeDataPointer &&
        !m_pDumpInfo->addr)
    {
        m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
        return FALSE;
    }
    ULONG BaseId;

//    dprintf("[TAG %lx, TI %02lx, @ %p] ", m_SymTag, typeIndex, GetDumpAddress());
    switch (m_SymTag) {
    case SymTagPointerType: {

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_LENGTH, (PVOID) &Size)) {
            Size = 0;
        }


        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {

            Size = ProcessPointerType(typeIndex, BaseId, (ULONG) Size);
        }
        break;
    }
    case SymTagData: {
        enum DataKind Datakind;

        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_DATAKIND, &Datakind)) {
            BOOL  IsStatic;

            if (m_ParentTag == SymTagUDT && Datakind == DataIsGlobal) {
                // Its atuall is a static member
                Datakind = DataIsStaticMember;
            }
            IsStatic = FALSE;
            switch (Datakind) {
            case DataIsUnknown: default:
                break;
            case DataIsStaticLocal:
                IsStatic = TRUE;
            case DataIsLocal: case DataIsParam:
            case DataIsObjectPtr: case DataIsFileStatic: case DataIsGlobal:
                if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
                    // vprintf("name not found\n");
                } else if (wName) {
                    if (!wcscmp(wName, L"this") && (Datakind == DataIsLocal)) {
                        m_thisPointerDump = TRUE;
                    }
                    LocalFree (wName);
                }
                if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
                    m_pInternalInfo->rootTypeIndex = BaseId;
                    m_pInternalInfo->IsAVar = TRUE;
                    Size = ProcessType(BaseId);
                }
                break;
#define DIA_HAS_CONSTDATA
#if defined (DIA_HAS_CONSTDATA)
            case DataIsConstant:
            {
                VARIANT var = {0};

                if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
                    // vprintf("name not found\n");
                } else if (wName) {
                    Name = UnicodeToAnsi(wName);
                    if (!Name) {
                        Name = "";
                    } else {
                        NameAllocated = TRUE;
                    }
                    LocalFree (wName);
                }
                if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_VALUE, &var)) {
                    if (m_pInternalInfo->IsEnumVal) {
                        Size = ProcessEnumerate(var, Name);
                    } else {
                        Size = ProcessVariant(var, Name);
                    }
                } else {
                }
                break;
            }
#endif
            case DataIsStaticMember:
                IsStatic = TRUE;
            case DataIsMember:

                if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
                    // vprintf("name not found\n");
                } else if (wName) {
                    Name = UnicodeToAnsi(wName);
                    if (!Name) {
                        Name = "";
                    } else {
                        NameAllocated = TRUE;
                    }
                    LocalFree (wName);
                }
                if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
                    Size = ProcessDataMemberType(typeIndex, BaseId, (LPSTR) Name, IsStatic);
                }
            }

        }

        break;
    }
#if !defined (DIA_HAS_CONSTDATA)
    case SymTagConstant:
    {
        VARIANT var = {0};

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
            // vprintf("name not found\n");
        } else if (wName) {
            Name = UnicodeToAnsi(wName);
            if (!Name) {
                Name = "";
            } else {
                NameAllocated = TRUE;
            }
            LocalFree (wName);
        }
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_VALUE, &var)) {
            if (m_pInternalInfo->IsEnumVal) {
                Size = ProcessEnumerate(var, Name);
            } else {
                Size = ProcessVariant(var, Name);
            }
        } else {
        }
        break;
    }
#endif
    case SymTagUDT: {

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
            // vprintf("name not found\n");
        } else if (wName) {
            Name = UnicodeToAnsi(wName);
            if (!Name) {
                Name = "";
            } else {
                NameAllocated = TRUE;
            }
            LocalFree (wName);
        }

        Size = ProcessUDType(typeIndex, (LPSTR) Name);
        break;
    }
    case SymTagEnum: {

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
            // vprintf("name not found\n");
        } else if (wName) {
            Name = UnicodeToAnsi(wName);
            if (!Name) {
                Name = "";
            } else {
                NameAllocated = TRUE;
            }
            LocalFree (wName);
        }

        Size = ProcessEnumType(typeIndex, (LPSTR) Name);
        break;
    }
    case SymTagBaseType: {
        ULONG Basetype;

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_LENGTH, (PVOID) &Size)) {
            Size = 0;
        }

        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_BASETYPE, &Basetype)) {

            ProcessBaseType(typeIndex, Basetype, (ULONG) Size);
        }

        break;
    }
    case SymTagArrayType: {
        ULONG Count;
        ULONGLONG BaseSz;

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_LENGTH, (PVOID) &Size)) {
            Size = 0;
        }

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
            // vprintf("name not found\n");
        } else if (wName) {
            Name = UnicodeToAnsi(wName);
            if (!Name) {
                Name = "";
            } else {
                NameAllocated = TRUE;
            }
            LocalFree (wName);
        }

        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId) &&
            SymGetTypeInfo(hp, base, BaseId, TI_GET_LENGTH, (PVOID) &BaseSz)) {
            Count = (ULONG)(BaseSz ? (Size / (ULONG)(ULONG_PTR)BaseSz) : 1);
            Size = ProcessArrayType(typeIndex, BaseId, Count, Size, Name);
        }
        break;
    }
    case SymTagTypedef: {
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {

            if (m_ParentTag == SymTagUDT) {
                // Its a nested typedef
                Indent(m_pInternalInfo->level*3);

                if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
                    // vprintf("name not found\n");
                } else if (wName) {
                    typPrint("%ws ", wName);
                    LocalFree (wName);
                }
            } else {
                m_pInternalInfo->rootTypeIndex = BaseId;
            }
            Size = ProcessType(BaseId);
        } else {
        }
    }
    break;
    case SymTagBaseClass: {
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            Size = ProcessBaseClassType(typeIndex, BaseId);
        } else {
        }
    }
    break;
    case SymTagVTableShape: {
        ULONG Count;
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_COUNT, &Count)) {
            Size = ProcessVTShapeType(typeIndex, Count);
        }
    }
    break;
    case SymTagVTable: {
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            Size = ProcessVTableType(typeIndex, BaseId);
        }
    }
    break;
    case SymTagFunction: {

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
            // vprintf("name not found\n");
        } else if (wName) {
            Name = UnicodeToAnsi(wName);
            if (!Name) {
                Name = "";
            } else {
                NameAllocated = TRUE;
            }
            LocalFree (wName);
        }
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            Size = ProcessFunction(typeIndex, BaseId, Name);
        }
    }
    break;
    case SymTagFunctionType: {
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            Size = ProcessFunctionType(typeIndex, BaseId);
        }
    }
    break;
    case SymTagFunctionArgType: {
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            Size = ProcessFunctionArgType(typeIndex, BaseId);
        }
    }
    break;
    case SymTagPublicSymbol:
        // These don't have type info,
        // very likely the the pdb we have is type stripped
        typPrint("Public symbol - the pdb you are using is type stripped\n"
                 "Use full pdbs to get this command to work\n");
        break;
    default:
        typPrint("Unimplemented sym tag %lx\n", m_SymTag);
        break;
    }
    if (Name && NameAllocated) {
        FreeMem(Name);
    }
    m_ParentTag = Parent; m_SymTag=SymTag;
    return (ULONG) Size;
}




//
// Frees up all allocated memory in TypeInfoToFree
//
BOOL
FreeTypesInfo ( PTYPES_INFO TypeInfoToFree ) {

    if (TypeInfoToFree) {

        if (TypeInfoToFree->Name.Buffer) {
            FreeMem (TypeInfoToFree->Name.Buffer);
        }
        return TRUE;
    }
    return FALSE;
}

//
// This routines clears all stored type info. This should be called
// after bangReload
//
VOID
ClearStoredTypes (
    ULONG64 ModBase
    )
{
    g_ReferencedSymbols.ClearStoredSymbols(ModBase);

    if (g_Process == NULL)
    {
        return;
    }
    ClearAllFastDumps();
}

//
// This routines clears all stored type info
//
VOID
ReferencedSymbolList::ClearStoredSymbols (
    ULONG64 ModBase
    )
{
    int i;
    for (i=0;i<MAX_TYPES_STORED;i++) {
        if ((!ModBase || (m_ReferencedTypes[i].ModBaseAddress == ModBase)) &&
            m_ReferencedTypes[i].Name.Buffer) {
            m_ReferencedTypes[i].Name.Buffer[0] = '\0';
            m_ReferencedTypes[i].Referenced = -1;
        }
    }
}

//
// Lookup a type name in recently referenced types
//       Returns index in RefedTypes, if it is found; -1 otherwise
//
ULONG
ReferencedSymbolList::LookupType (
    LPSTR      Name,
    LPSTR      Module,
    BOOL       CompleteName
    )
{
    PTYPES_INFO  RefedTypes = m_ReferencedTypes;
    int i, found=-1;

    if (!Name || !Name[0]) {
        return -1;
    }
    return -1;

    EnsureValidLocals();

    for (i=0; i<MAX_TYPES_STORED; i++) {
        RefedTypes[i].Referenced++;
        if (RefedTypes[i].Name.Buffer && (found == -1)) {
            if ((CompleteName && !strcmp(Name, RefedTypes[i].Name.Buffer)) ||
                (!CompleteName && !strncmp(Name, RefedTypes[i].Name.Buffer, strlen(Name)))) {
                    if (Module) {
                        if (!_stricmp(Module, RefedTypes[i].ModName) || !Module[0] || !RefedTypes[i].ModName[0]) {
                            found = i;
                            RefedTypes[i].Referenced = 0;
                        } else {
          //                  dprintf("Mod %s != %s\n", RefedTypes[i].ModName, Module);
                        }
                    } else {
                        found = i;
                        RefedTypes[i].Referenced = 0;
                    }
                }
            }
    }

    return found;
}

VOID
ReferencedSymbolList::EnsureValidLocals(void)
{
    PDEBUG_SCOPE Scope = GetCurrentScope();
    if ((Scope->Frame.FrameOffset != m_FP) ||
        (Scope->Frame.ReturnOffset != m_RO) ||
        (Scope->Frame.InstructionOffset != m_IP))
    {
        int i;

        for (i = 0; i < MAX_TYPES_STORED; i++)
        {
            if ((m_ReferencedTypes[i].Flag & DEBUG_LOCALS_MASK) &&
                m_ReferencedTypes[i].Name.Buffer)
            {
                m_ReferencedTypes[i].Name.Buffer[0] = '\0';
                m_ReferencedTypes[i].Referenced = -1;
                m_ReferencedTypes[i].Flag = 0;
            }
        }
        m_RO = Scope->Frame.ReturnOffset;
        m_FP = Scope->Frame.FrameOffset;
        m_IP = Scope->Frame.InstructionOffset;
    }
}

//
// Store a referenced Symbol type
//
ULONG
ReferencedSymbolList::StoreTypeInfo (
    PTYPES_INFO pInfo
    )
{
    PTYPES_INFO         RefedTypes = m_ReferencedTypes;
    ULONG indexToStore=0, MaxRef=0,i;
    PTYPES_INFO pTypesInfo;
    USHORT ModLen, SymLen;

    EnsureValidLocals();
    for (i=0; i<MAX_TYPES_STORED; i++) {
        if (!RefedTypes[i].Name.Buffer || (RefedTypes[i].Referenced > MaxRef)) {
            MaxRef = (RefedTypes[i].Name.Buffer ? RefedTypes[i].Referenced : -1);
            indexToStore = i;
        }
    }

    // dprintf("Storing %s at %d\n", pSym->sName, indexToStore);
    pTypesInfo = &RefedTypes[indexToStore];
    ModLen = ( pInfo->ModName ? strlen(pInfo->ModName) : 0);
    SymLen = (USHORT)strlen( (char *)pInfo->Name.Buffer );

    if (pTypesInfo->Name.MaximumLength <= SymLen) {
        if (pTypesInfo->Name.Buffer) FreeMem (pTypesInfo->Name.Buffer);
        pTypesInfo->Name.MaximumLength = (SymLen >= MINIMUM_BUFFER_LENGTH ? SymLen + 1 : MINIMUM_BUFFER_LENGTH);
        pTypesInfo->Name.Buffer = (char *)AllocateMem (pTypesInfo->Name.MaximumLength);
    }

    if (!pTypesInfo->Name.Buffer) {
        return -1;
    }
    strcpy (pTypesInfo->Name.Buffer, (char *)pInfo->Name.Buffer);
    pTypesInfo->Name.Length = SymLen;
    if (ModLen) {

        if (sizeof( pTypesInfo->ModName) <= ModLen) {
            // truncate module name
            strncpy(pTypesInfo->ModName, pInfo->ModName, sizeof(pTypesInfo->ModName));
            pTypesInfo->ModName[sizeof(pTypesInfo->ModName) - 1] = '\0';
        } else
            strcpy (pTypesInfo->ModName, pInfo->ModName);
    }

    pTypesInfo->TypeIndex = pInfo->TypeIndex;
    pTypesInfo->Referenced = 0;
    pTypesInfo->hProcess   = pInfo->hProcess;
    pTypesInfo->ModBaseAddress = pInfo->ModBaseAddress;
    pTypesInfo->SymAddress = pInfo->SymAddress;
    pTypesInfo->Value      = pInfo->Value;
    pTypesInfo->Flag       = pInfo->Flag;
    return indexToStore;
}

/*
 * GetTypeAddressFromField
 *   Calculates the address of the type from address of its field.
 *   If FieldName is NULL, this subtracts the size of type from given address
 *   that is, it calculates the type address from its end address.
 */

ULONG64
GetTypeAddressFromField(
    ULONG64   Address,
    PUCHAR    TypeName,
    PUCHAR    FieldName
    )
{
    FIELD_INFO_EX fld={FieldName, NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM_EX Sym = {
       sizeof (SYM_DUMP_PARAM_EX), TypeName, DBG_DUMP_NO_PRINT, 0,
       NULL, NULL, NULL, 0, &fld
    };
    ULONG sz, status;

    if (!TypeName) {
        return 0;
    }

    if (FieldName) {
        //
        // Get offset and calculate Type address
        //
        Sym.nFields = 1;
    } else {
        Sym.Options |= DBG_DUMP_GET_SIZE_ONLY;
    }

    if (!(sz = SymbolTypeDumpNew(&Sym, &status))) {
        return 0;
    }

    if (FieldName) {
        return (Address - fld.address);
    } else {
        return (Address - sz);
    }
}

typedef struct NAME_AND_INDEX {
    PUCHAR  Name;
    PULONG  Index;
    ULONG64 Address;
    PSYMBOL_INFO pSymInfo;
} NAME_AND_INDEX;

typedef struct _TYPE_ENUM_CONTEXT {
    PCHAR  ModName;
    PCHAR  SymName;
    SYMBOL_INFO SI;
} TYPE_ENUM_CONTEXT;

//
// Callback routine to list symbols
//
BOOL ListIndexedTypes (LPSTR tyName, ULONG ti, PVOID ctxt)
{
    NAME_AND_INDEX* ListInfo = ((NAME_AND_INDEX *) ctxt);
    LPSTR modName = (char *)ListInfo->Name;
    if (ti || (*ListInfo->Index & VERBOSE))
    {
        dprintf(" %s!%s%s\n",
                modName,
                tyName,
                (ti ? "" : " (no type info)"));
    }
    if (CheckUserInterrupt())
    {
        return FALSE;
    }

    return TRUE;
}


//
// Callback routine to list symbols
//
BOOL ListIndexedVarsWithAddr (LPSTR tyName, ULONG ti, ULONG64 Addr, PVOID ctxt) {
    NAME_AND_INDEX* ListInfo = ((NAME_AND_INDEX *) ctxt);
    LPSTR modName = (char *)ListInfo->Name;
    if (ti || (*ListInfo->Index & VERBOSE)) {
        if (Addr) {
            dprintf64("%p  %s!%s%s\n",
                      Addr,
                      modName,
                      tyName,
                      (ti ? "" : " (no type info)"));
        } else
            dprintf("          %s!%s%s\n",
                    modName,
                    tyName,
                    (ti ? "" : " (no type info)"));
    }

    if (CheckUserInterrupt()) {
        return FALSE;
    }

    return TRUE;
}

//
// Callback routine to list symbols
//
BOOL ListTypeSyms (PSYMBOL_INFO pSym, ULONG Size, PVOID ctxt) {
    TYPE_ENUM_CONTEXT * ListInfo = ((TYPE_ENUM_CONTEXT *) ctxt);
    LPSTR modName = (char *)ListInfo->ModName;
    ULONG ti = pSym->TypeIndex;

    if (ti || (ListInfo->SI.Flags & VERBOSE)) {
        if (MatchPattern( pSym->Name, ListInfo->SymName )) {

            if (pSym->Address) {
                dprintf64("%p  %s!%s%s\n",
                          pSym->Address,
                          modName,
                          pSym->Name,
                          (ti ? "" : " (no type info)"));
            } else
                dprintf("          %s!%s%s\n",
                        modName,
                        pSym->Name,
                        (ti ? "" : " (no type info)"));
        }
    }

    if (CheckUserInterrupt()) {
        return FALSE;
    }

    return TRUE;
}

BOOL StoreFirstIndex (LPSTR tyName, ULONG ti, PVOID ctxt) {
    if (ti) {
        PULONG pTI = (PULONG) ctxt;
        *pTI = ti;
        return FALSE;
    }
    return TRUE;
}

BOOL StoreFirstNameIndex (PSYMBOL_INFO pSym, ULONG Sz, PVOID ctxt) {
    NAME_AND_INDEX *pName = (NAME_AND_INDEX *) ctxt;

    if (pSym->TypeIndex &&
        !strncmp(pSym->Name, (PCHAR) pName->Name, strlen((PCHAR) pName->Name))) {
        ULONG dw = pName->pSymInfo->MaxNameLen;

        CopyString((char *)pName->Name, pSym->Name, MAX_NAME);

        *pName->Index = pSym->TypeIndex;;
        pName->Address = pSym->Address;

        *pName->pSymInfo  = *pSym;
        pName->pSymInfo->MaxNameLen = dw;
        return FALSE;
    }
    return TRUE;
}

BOOL exactMatch = TRUE;
CHAR g_NextToken[MAX_NAME];

BOOL
IsOperator( CHAR op )
{
    switch (op)
    {
    case '+':
    case '*':
        // - or / are recognised as command options first
        return TRUE;
    default:
        return FALSE;
    }
}

CHAR
PeekNextChar(PCHAR args)
{

    while (*args == ' ' || *args == '\t')
    {
        ++args;
    }
    return *args;
}

//
// Gets next token from argumentstring
// Returns pointer to next unused char in arg
//
PCHAR
GetNextToken(
    PCHAR arg
    )
{
    PCHAR Token = &g_NextToken[0];
    BOOL ParStart=FALSE;
    CHAR cLast;
    BOOL IdToken = FALSE, FirstChar = TRUE;

    *Token=0;

AddToToken:
    while (*arg && (*arg == ' ' || *arg =='\t') ) {
        arg++;
    }

    if (!*arg) {
        return arg;
    }

    ULONG Paren = (*arg=='(' ? (arg++, ParStart=TRUE, 1) : 0);
    ULONG i=0;
    while (*arg && ((*arg != ' ' && *arg != '\t' && *arg != ';') || Paren)) {
        if (*arg=='(')
            ++Paren;
        else if (*arg == ')') {
            --Paren;
            if (ParStart && !Paren) {
                // We are done
                *Token=0;
                ++arg;
                break;
            }
        } else if ((*arg != ' ') && (*arg != '\t') && FirstChar)
        {
            FirstChar = FALSE;
            IdToken = IsIdStart(*arg);
        }
        *(Token++) = *(arg++);
    }
    *Token=0;

    // If this token looks like an identifier, we are done
    if (IdToken)
    {
        return arg;
    }

    // Check if we only copied part of what looks like an expression
    CHAR cNext = PeekNextChar(arg);

    if (IsOperator(cNext))
    {
        // copy upto the operator and repeat the process
        while (*arg && (*arg != cNext)) {
            *(Token++) = *(arg++);
        }
        // copy operator
        *(Token++) = *(arg++);
        goto AddToToken;
    }
    cLast = g_NextToken[0] ? *(Token-1) : 0;
    if (IsOperator(cLast))
    {
        goto AddToToken;
    }
    return arg;
}

ULONG
IdentifierLen(PSTR Token) {
    ULONG len = 0;

    if (!Token || !IsIdStart(*Token)) {
        return len;
    }
    while (*Token && (IsIdStart(*Token) || isdigit(*Token))) {
        Token++; len++;
    }
    return len;
}

ULONG
NextToken(
    PLONG64 pvalue
    );

//
// True if word is a symbol / type / typecast
// eg. _name, !ad, mod!x, TYPE *, TYPE*, field.mem.nmem, fld.arr[3] are all symbols
//
BOOL symNext(LPSTR numStr) {
    USHORT i=0;
    CHAR c=numStr[i];
    BOOL hex=TRUE;
    PSTR save = g_CurCmd;

    if (!strcmp(numStr, ".")) {
        // Last type
        return TRUE;
    }

    if (c == '&') {
        c = numStr[++i];
    }
    if (IsIdStart(c)) {
        // Can be a symbol
        i=0;
        while ( c &&
               (IsIdChar(c) || (c=='[') || (c=='-') || c==' ' || c=='*' || c=='.' || c==':')) {
            hex = hex && isxdigit(c);
            if (!IsIdChar(c)) {
                switch (c) {
                case '[':
                    while (numStr[++i] != ']' && numStr[i]);
                    if (numStr[i] != ']') {
                        return FALSE;
                    }
                    break;
                case '.':
                    while(numStr[i+1]=='.') ++i; // allow field.. for prefix field matches
                    if (numStr[i+1] && !IsIdStart(numStr[i+1])) {
                        return FALSE;
                    }
                case ':':
                case '*':
                    break;
                case '-':
                    if (numStr[++i] != '>') {
                        return FALSE;
                    } else if (!IsIdStart(numStr[i+1])) {
                        return FALSE;
                    }
                    break;
                case ' ':
                    while(numStr[i+1]==' ') ++i;
                    while(numStr[i+1]=='*') ++i;
                    if (numStr[i+1] && !IsIdStart(numStr[i+1])) {
                        return FALSE;
                    }
                    break;
                }
            }
            if ( c == '!') {
                // must be symbol
                return TRUE;
            }
            c=numStr[++i];
        }
        if (c || hex) {
            return FALSE;
        }
        return TRUE;;

    } else
        return FALSE;

    return FALSE;
}

BOOL
AddressNext(
    LPSTR numStr
    )
{
    int i=0;

    if ((numStr[0]=='0') && (tolower(numStr[1])=='x')) {
        i=2;
    }
    while (numStr[i] && numStr[i]!=' ') {
        if (!isxdigit(numStr[i]) && (numStr[i] !='\'')) {
            return FALSE;
        }
        ++i;
    }
    return TRUE;
}


VOID
Show_dt_Usage(
    BOOL ShowAll
    )
{
    ULONG Options=0;

    typPrint("dt - dump symbolic type information.\n");
    typPrint("dt [[-ny] [<mod-name>!]<name>[*]] [[-ny] <field>]* [<address>] \n"
             "   [-l <list-field>] [-abchioprv]\n");
    if (ShowAll) {

    typPrint("  <address>       Memory address containing the type.\n");
    typPrint("  [<module>!]<name>\n");
    typPrint("                  module : name of module, optional\n");
    typPrint("                  name: A type name or a global symbol.\n");
    typPrint("                  Use name* to see all symbols begining with `name'.\n");
    typPrint("  <field>         Dumps only the 'field-name(s)' if 'type-name' is a\n"
             "                  struct or union.                                  \n"
             "                  Format : <[((<type>.)*) | ((<subfield>.)*)]>.field\n"
             "                  Can also refer directly to array elemnt like fld[2].\n");
    typPrint("  dt <mod>!Ty*    Lists all Types, Globals and Statics of prefix Ty in <mod>\n"
             "                  -v with this also lists symbols without type info.\n");
    typPrint("  -a              Shows array elements in new line with its index.\n");
    typPrint("  -b              Dump only the contiguous block of struct.\n");
    typPrint("  -c              Compact output, print fields in same line.\n");
    typPrint("  -h              Show this help.\n");
    typPrint("  -i              Does not indent the subtypes.\n");
    typPrint("  -l <list-field> Field which is pointer to the next element in list.\n");
    typPrint("  -n <name>       Use this if name can be mistaken as an address.\n");
    typPrint("  -o              Omit the offset value of fields of struct.\n");
    typPrint("  -p              Dump from physical address.\n");
    typPrint("  -r[l]           Recursively dump the subtypes (fields) upto l levels.\n");
    typPrint("  -v              Verbose output.\n");
    typPrint("  -y <name>       Does partial match instead of default exact match of the\n"
             "                  name following -y, which can be a type or field's name.\n");
    }

    typPrint("\nUse \".hh dt\" or open debugger.chm in the debuggers "
             "directory to get\n"
             "detailed documentation on this command.\n\n");

}

/*
 * Function Name: ParseArgumentString
 *
 * Parameters: IN LPSTR lpArgumentString, PSYM_DUMP_PARAM_EX dp
 *
 * Description:
 *          Fills up dp by interpreting vcalues in lpArgumentString
 *
 * Returns: TURE on success
 *
 */
BOOL
ParseArgumentString(
    IN LPSTR lpArgumentString,
    OUT PSYM_DUMP_PARAM_EX dp
    )
{
    DWORD Options=0, maxFields=dp->nFields;
    BOOL symDone=FALSE, addrDone=FALSE, fieldDone=FALSE, listDone=FALSE;
    BOOL flag=FALSE, fullSymMatch;
    LPSTR args;
    BOOL InterpretName = FALSE;
    static CHAR LastType[256]={0};

    if (dp == NULL) {
        return FALSE;
    }

    // Parse the arguments
    dp->nFields=0;
    args = lpArgumentString;
    fullSymMatch = TRUE;
    while ((*args!=(TCHAR)NULL) && (*args!=(TCHAR)';')) {

        if ((*args=='\t') || (*args==' ')) {
            flag=FALSE;
            ++args;
            continue;
        }

        if (*args=='-' || *args=='/') {
            ++args;
            flag=TRUE;
            continue;
        }

        if (flag) {
            switch (*args) {
            case 'a': {
                ULONG Sz = isdigit(*(args+1)) ? 0 : 5;
                ULONG i  = 0;
                BOOL  SzEntered=FALSE;
                while (isdigit(*(args+1)) && (++i<5)) {
                    Sz= (*((PUCHAR) ++args) - '0') + Sz*10;
                    SzEntered = TRUE;
                }

                if (symDone) {
                    dp->Fields[dp->nFields].fOptions |= FIELD_ARRAY_DUMP;
                    dp->Fields[dp->nFields].size = SzEntered ? Sz : 0;
                } else {
                    Options |= DBG_DUMP_ARRAY;
                    dp->listLink->size = Sz;
                }
                break;
            }
            case 'b':
                Options |= DBG_DUMP_BLOCK_RECURSE;
                break;
            case 'c':
                Options |= DBG_DUMP_COMPACT_OUT;
                break;
            case 'h':
            case '?':
                Show_dt_Usage(TRUE);
                g_CurCmd = args + strlen(args);
                return FALSE;
            case 'i':
                Options |= NO_INDENT;
                break;
            case 'l':
                Options |= LIST_DUMP;
                break;
            case 'n':
                InterpretName = TRUE;
                break;
            case 'o':
                Options |= NO_OFFSET;
                break;

            case 'p':
                Options |= DBG_DUMP_READ_PHYSICAL;
                break;
            case 'r':
                if (isdigit(*(args+1))) {
                    WORD i = *(++args) -'0';
                    i = i << 8;
                    Options |=i;
                } else {
                    Options |= RECURSIVE2;
                }
                break;
            case 'v':
                Options |= VERBOSE;
                break;
            case 'x': // Obsolete, now default is exact match
                break;
            case 'y':
                if (!symDone) {
                    // partial match for symbol
                    fullSymMatch = FALSE;
                    exactMatch = FALSE;
                } else if (!fieldDone) // exact match for following field
                    fullSymMatch = FALSE;
                break;
            default:
                typPrint("Unknown argument -%c\n", *args);
                Show_dt_Usage(FALSE);
                return FALSE;
            } /* switch */

            ++args;
            continue;
        }

        args = GetNextToken(args);
        // args+= strlen(g_NextToken);
        PCHAR Token = &g_NextToken[0];
        if ((!addrDone) && !InterpretName && !symNext(Token)) {
            LPSTR i = strchr(Token,' ');
            ULONG64 addr=0;
            ULONG64 val=0;


            g_CurCmd = Token;
            addr = GetExpression();
            // dprintf("Addr %I64x, Args rem %s\n", addr, g_CurCmd);
            // sscanf(args, "%I64lx", &addr);
            dp->addr=addr;
            addrDone=TRUE;
            continue;
        }

        InterpretName = FALSE;

        if (!symDone) {
            CopyString((char *)dp->sName, Token, MAX_NAME);
            if (!strcmp(Token, ".") && LastType[0]) {
                dprintf("Using sym %s\n", LastType);
                CopyString((char *)dp->sName, LastType, MAX_NAME);
            } else if (strlen(Token) < sizeof(LastType)) {
                CopyString(LastType, Token, sizeof(LastType));
            }
            symDone=TRUE;
            fullSymMatch = TRUE;
            continue;
        }


        if (!fieldDone) {
            CopyString((char *)dp->Fields[dp->nFields].fName, Token, MAX_PATH);
            if ((Options & LIST_DUMP) && !(dp->listLink->fName[0]) && !listDone) {
                listDone=TRUE;
                CopyString((char *)dp->listLink->fName,
                           (char *)dp->Fields[dp->nFields].fName,
                           MAX_PATH);
                dp->listLink->fOptions |= fullSymMatch ? DBG_DUMP_FIELD_FULL_NAME : 0;

            } else {
                PCHAR fName = (PCHAR) dp->Fields[dp->nFields].fName;
                if (fName[strlen(fName)-1] == '.') {
                    fullSymMatch = FALSE;
                }
                dp->Fields[dp->nFields].fOptions |= fullSymMatch ? DBG_DUMP_FIELD_FULL_NAME : 0;
                dp->nFields++;
            }
            fieldDone = (maxFields <= dp->nFields);
            fullSymMatch = TRUE;
            continue;
        } else {
            typPrint("Too many fields in %s\n", args);
            // Show_dt_Usage();
            return FALSE;
        }

    }

    dp->Options = Options;

    g_CurCmd = args;
    return TRUE;

} /* End function ParseArgumentString */


BOOL
CheckFieldsMatched(
    PULONG ReturnVal,
    PTYPE_DUMP_INTERNAL pErrorInfo,
    PSYM_DUMP_PARAM_EX     pSym
    )
{
    ULONG i, OneMatched=FALSE;

    //
    // Return false if we need not continue after this.
    //
    if (*ReturnVal && !pErrorInfo->ErrorStatus) {
        if (!pSym->nFields)
            return TRUE;
        //
        // Check if any of the fields, if specified in pSym, actually matched
        //
        for (i=0; i<pSym->nFields; i++) {
            if (pErrorInfo->AltFields[i].FieldType.Matched) {
                return TRUE;
            }
        }
        pErrorInfo->ErrorStatus = FIELDS_DID_NOT_MATCH;
        return FALSE;
    }
    return TRUE;
}


//
// Callback routine to find if any symbol has type info
//
BOOL CheckIndexedType (PSYMBOL_INFO pSym, ULONG Sz, PVOID ctxt) {
    PULONG pTypeInfoPresent = (PULONG) ctxt;

    if (pSym->TypeIndex) {
        *pTypeInfoPresent = TRUE;
        return FALSE;
    }
    return TRUE;
}


ULONG
CheckForTypeInfo(
    IN HANDLE  hProcess,
    IN ULONG64 ModBaseAddress
    )
/*
  This routines checks whether the given module referred by ModBaseAddress has
  any type info or not. This is done by trying to get type info for a basic type
  like PVOID/ULONG which would always be present in a pdb.
*/
{
    ULONG TypeInfoPresent = FALSE;

    SymEnumTypes(
        hProcess,
        ModBaseAddress,
        &CheckIndexedType,
        &TypeInfoPresent);
    if (TypeInfoPresent) {
        return TRUE;
    }

    SymEnumSymbols(
        hProcess,
        ModBaseAddress,
        NULL,
        &CheckIndexedType,
        &TypeInfoPresent);
    if (TypeInfoPresent) {
        return TRUE;
    }

    return FALSE;
}

BOOL
GetModuleBase(
    IN PCHAR  ModName,
    IN ImageInfo* pImage,
    OUT PULONG64 ModBase
    )
{
    if (!ModBase || !ModName || !pImage) {
        return FALSE;
    }
    while (pImage) {
        // Look up the module list
        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT) {
            return FALSE;
        }

        if (ModName[0]) {
            if (!_stricmp(ModName, pImage->m_ModuleName)) {
                *ModBase = pImage->m_BaseOfImage;
                return TRUE;
            }
        }
        pImage = pImage->m_Next;
    }
    return FALSE;
}

ULONG
EnumerateTypes(
    IN PCHAR TypeName,
    IN ULONG Options
)
{
    PCHAR   bang;
    ULONG   i;
    ULONG64 ModBase=0;
    CHAR    modName[30], SymName[MAX_NAME];

    bang = strchr((char *)TypeName, '!');
    if (bang)
    {
        if ((ULONG)( (PCHAR)bang - (PCHAR) TypeName) < sizeof(modName))
        {
            strncpy(modName, TypeName, (ULONG)( (PCHAR)bang - (PCHAR) TypeName));
        }
        modName[(ULONG)(bang - (char *)TypeName)]='\0';
        CopyString(SymName, bang+1, sizeof(SymName));
    }
    else
    {
        return FALSE;
    }

    if (!GetModuleBase(modName, g_Process->m_ImageHead, &ModBase))
    {
        return FALSE;
    }

    PDEBUG_SCOPE Scope = GetCurrentScope();

    IMAGEHLP_MODULE64 mi;
    SymGetModuleInfo64( g_Process->m_SymHandle, ModBase, &mi );

    if (mi.SymType == SymDeferred)
    {
        SymLoadModule64( g_Process->m_SymHandle,
                         NULL,
                         PrepareImagePath(mi.ImageName),
                         mi.ModuleName,
                         mi.BaseOfImage,
                         mi.ImageSize);
    }

    if (strchr(SymName,'*'))
    {
        TYPE_ENUM_CONTEXT ListTypeSymsCtxt;
        i = -1;
        while (SymName[++i])
        {
            SymName[i] = (CHAR)toupper(SymName[i]);
        }

        ListTypeSymsCtxt.ModName = modName;
        ListTypeSymsCtxt.SymName = SymName;
        ListTypeSymsCtxt.SI.Flags= Options;

        SymEnumTypes(g_Process->m_SymHandle,
                     ModBase,
                     &ListTypeSyms,
                     &ListTypeSymsCtxt);
        SymEnumSymbols(g_Process->m_SymHandle,
                   ModBase,
                   NULL,
                   &ListTypeSyms,
                   &ListTypeSymsCtxt);
        return TRUE;
    }
    return FALSE;
}

#define NUM_ALT_NAMES 10


BOOL
CALLBACK
FindLocal(
    PSYMBOL_INFO    pSymInfo,
    ULONG           Size,
    PVOID           Context
    )
{
    PSYMBOL_INFO SymTypeInfo = (PSYMBOL_INFO) Context;

    if (!strcmp(pSymInfo->Name, SymTypeInfo->Name)) {
        memcpy(SymTypeInfo, pSymInfo, sizeof(SYMBOL_INFO));
        return FALSE;
    }
    return TRUE;
}


/*
  FindLocalSymbol
         Looks up the type information of a symbol in current Scope.

         pTypeInfo is used to store the type info, if found.

         Returns TRUE on success
*/
BOOL
FindLocalSymbol(
    IN HANDLE  hProcess,
    IN PCHAR   SymName,
    OUT PTYPES_INFO    pTypeInfo
    )
{
    ULONG sz = sizeof (SYMBOL_INFO);
    CHAR  Buffer[MAX_NAME+sizeof(SYMBOL_INFO)] = {0};
    PSYMBOL_INFO    SymTypeInfo = (PSYMBOL_INFO) &Buffer[0];

    SymTypeInfo->MaxNameLen = MAX_NAME;

    CopyString(SymTypeInfo->Name, SymName, MAX_NAME);

    EnumerateLocals(FindLocal, (PVOID) SymTypeInfo);

    if (!SymTypeInfo->TypeIndex) {

            return FALSE;

    }
    pTypeInfo->hProcess       = hProcess;
    pTypeInfo->ModBaseAddress = SymTypeInfo->ModBase;
    pTypeInfo->TypeIndex      = SymTypeInfo->TypeIndex;
    pTypeInfo->SymAddress     = SymTypeInfo->Address;
    pTypeInfo->Value = TypeInfoValueFromSymInfo(SymTypeInfo);

    if (pTypeInfo->Name.Buffer) {
        if (strlen((char *) SymName) < pTypeInfo->Name.MaximumLength) {
            CopyString(pTypeInfo->Name.Buffer, (char *) SymName, MAX_NAME);
        } else {
            strncpy(pTypeInfo->Name.Buffer, (char *)SymName, pTypeInfo->Name.MaximumLength - 1);
            pTypeInfo->Name.Buffer[pTypeInfo->Name.MaximumLength - 1]=0;
        }
    }
    if (exactMatch && (SymTypeInfo->Flags & SYMFLAG_VALUEPRESENT)) {
        pTypeInfo->Value = SymTypeInfo->Value;
    }
    pTypeInfo->Flag = SymTypeInfo->Flags | SYM_IS_VARIABLE;

    if (pTypeInfo->Name.Buffer) {
        g_ReferencedSymbols.StoreTypeInfo(pTypeInfo);
    }
    return TRUE;
}

/*
  FindTypeInfoFromModName
         Looks up the type information of a symbol in a particular module.

         pTypeInfo is used to store the type info, if found.

         Returns zero on success error no. on failure
*/
ULONG
FindTypeInfoFromModName(
    IN HANDLE  hProcess,
    IN PCHAR   ModName,
    IN PCHAR   SymName,
    IN PSYM_DUMP_PARAM_EX pSym,
    OUT PTYPES_INFO    pTypeInfo
    )
{
    ULONG64 ModBase = 0;
    ULONG res=0;
    ULONG Options = pSym->Options, typNamesz=sizeof(ULONG);    UCHAR i=0;
    ULONG          typeIndex;
    ULONG          TypeStored=-1;
    UCHAR          MatchedName[MAX_NAME+1]={0};
    UCHAR          ModuleName[30];
    BOOL           GotSymAddress=FALSE;
    CHAR           Buffer[MAX_NAME + sizeof(SYMBOL_INFO)]={0};
    PSYMBOL_INFO   SymTypeInfo = (PSYMBOL_INFO) &Buffer[0];

    i=(UCHAR)strlen((char *)SymName);
    CopyString((PCHAR) ModuleName, ModName, sizeof(ModuleName));

    if (exactMatch) {
        CopyString((PCHAR) MatchedName, ModName, sizeof(MatchedName));
        CatString((PCHAR) MatchedName, "!", sizeof(MatchedName));
        CatString((PCHAR) MatchedName, SymName, sizeof(MatchedName));
        if (!SymGetTypeFromName(hProcess,ModBase,(LPSTR) &MatchedName[0],SymTypeInfo)) {
            if (!SymFromName(
                hProcess,
                (LPSTR) &MatchedName[0],
                SymTypeInfo)) {

                return SYMBOL_TYPE_INDEX_NOT_FOUND;
            }
        }
    } else {
        // We cannot enumerate without module base
        return SYMBOL_TYPE_INDEX_NOT_FOUND;
    }
    if (!SymTypeInfo->TypeIndex) {
        return SYMBOL_TYPE_INDEX_NOT_FOUND;
    }


    typeIndex = SymTypeInfo->TypeIndex;


    // Type index and server info is correctly returned
    if (!MatchedName[0]) {
        CopyString((char *)MatchedName, (char *)SymName, sizeof(MatchedName));
    }

    if (!typeIndex) {
        vprintf("Cannot get type Index.\n");
        return SYMBOL_TYPE_INDEX_NOT_FOUND;
    }


    if (!pSym->addr) {
        //
        // See if we can get address in case it is a global symbol
        //
        if (SymTypeInfo->Address && !pSym->addr) {
            GotSymAddress = TRUE;
            SymTypeInfo->Flags |= SYM_IS_VARIABLE;

            vprintf("Got address %p for symbol\n", SymTypeInfo->Address, MatchedName);
        }
    }

    PUCHAR tmp=pSym->sName;
    ULONG64 addr = pSym->addr;

    if (!GotSymAddress) {
        pSym->addr = 0;
    }
    if (!pTypeInfo) {
        typPrint("Null pointer reference : FindTypeInfoInMod-pTypeInfo\n");
        return TRUE;
    }

    pTypeInfo->hProcess       = hProcess;
    pTypeInfo->ModBaseAddress = SymTypeInfo->ModBase;
    pTypeInfo->SymAddress     = SymTypeInfo->Address;
    pTypeInfo->TypeIndex      = SymTypeInfo->TypeIndex;
    CopyString((char *)pTypeInfo->ModName, ModName, sizeof(pTypeInfo->ModName));
    if (pTypeInfo->Name.Buffer) {
        if (strlen((char *) SymName) < pTypeInfo->Name.MaximumLength) {
            strcpy(pTypeInfo->Name.Buffer, (char *) SymName);
        } else {
            strncpy(pTypeInfo->Name.Buffer, (char *)SymName, pTypeInfo->Name.MaximumLength - 1);
            pTypeInfo->Name.Buffer[pTypeInfo->Name.MaximumLength - 1]=0;
        }
    }
    if (exactMatch && (SymTypeInfo->Flags & SYMFLAG_VALUEPRESENT)) {
        pTypeInfo->Value = SymTypeInfo->Value;
    }
    pTypeInfo->Flag = SymTypeInfo->Flags;


    //
    // Store the corresponding module information for fast future reference
    //
    if (pTypeInfo->Name.Buffer) {
        g_ReferencedSymbols.StoreTypeInfo(pTypeInfo);
    }
    if (addr) {
        // Use original value for this dump
        pTypeInfo->SymAddress = pSym->addr  = addr;
        pTypeInfo->Flag = 0;
    }

    return FALSE;
}

/*
  FindTypeInfoInMod
         Looks up the type information of a symbol in a particular module.

         pTypeInfo is used to store the type info, if found.

         Returns zero on success error no. on failure
*/
ULONG
FindTypeInfoInMod(
    IN HANDLE  hProcess,
    IN ULONG64 ModBase,
    IN PCHAR   ModName,
    IN PCHAR   SymName,
    IN PSYM_DUMP_PARAM_EX pSym,
    OUT PTYPES_INFO    pTypeInfo
    )
{
    ULONG res=0, Options = pSym->Options, typNamesz=sizeof(ULONG);
    UCHAR i=0;
    ULONG          typeIndex;
    ULONG          TypeStored=-1;
    UCHAR          MatchedName[MAX_NAME+1]={0};
    UCHAR          ModuleName[30];
    BOOL           GotSymAddress=FALSE;
    NAME_AND_INDEX ValuesStored;
    CHAR           Buffer[MAX_NAME + sizeof(SYMBOL_INFO)]={0};
    PSYMBOL_INFO   SymTypeInfo = (PSYMBOL_INFO) &Buffer[0];

    i=(UCHAR)strlen((char *)SymName);
    CopyString((PCHAR) ModuleName, ModName, sizeof(ModuleName));

    // Query for the the type / symbol name
    ValuesStored.Index    = &typeIndex;
    ValuesStored.Name     = (PUCHAR) SymName;
    ValuesStored.Address  = 0;
    ValuesStored.pSymInfo = SymTypeInfo;

    if (exactMatch) {
        if (!SymGetTypeFromName(hProcess,
                                ModBase,
                                (LPSTR) SymName,
                                SymTypeInfo)) {
            CopyString((PCHAR) MatchedName, ModName, sizeof(MatchedName));
            CatString((PCHAR) MatchedName, "!", sizeof(MatchedName));
            CatString((PCHAR) MatchedName, SymName, sizeof(MatchedName));
            SymTypeInfo->MaxNameLen = MAX_NAME;
            if (!SymFromName(
                hProcess,
                (LPSTR) &MatchedName[0],
                SymTypeInfo)) {

                return SYMBOL_TYPE_INDEX_NOT_FOUND;
            }
            // check for exact match since default symbol matching
            // is case insensitive in dbghelp
            if (strcmp(SymName, SymTypeInfo->Name) &&
                !_stricmp(SymName, SymTypeInfo->Name)) {
                return SYMBOL_TYPE_INDEX_NOT_FOUND;
            }
        }
    } else {
        if (!SymEnumTypes(hProcess,ModBase,&StoreFirstNameIndex,&ValuesStored)) {
            if (!SymEnumSymbols(
                hProcess,
                ModBase,
                NULL,
                &StoreFirstNameIndex,
                &ValuesStored)) {
                return SYMBOL_TYPE_INDEX_NOT_FOUND;
            }
        }
        CopyString((PCHAR) MatchedName, ModName, sizeof(MatchedName));
        CatString((PCHAR) MatchedName, "!", sizeof(MatchedName));
        CatString((PCHAR) MatchedName, SymName, sizeof(MatchedName));
    }
    if (!SymTypeInfo->TypeIndex) {
        return SYMBOL_TYPE_INDEX_NOT_FOUND;
    }


    typeIndex = SymTypeInfo->TypeIndex;


    // Type index and server info is correctly returned
    if (!exactMatch && strcmp((char *)MatchedName, (char *)SymName) && MatchedName[0]) {
        typPrint("Matched symbol %s\n", MatchedName);
    } else if (!MatchedName[0]) {
        CopyString((char *)MatchedName, (char *)SymName, sizeof(MatchedName));
    }

    if (!pSym->addr) {
        //
        // See if we can get address in case it is a global symbol
        //
        if (SymTypeInfo->Address && !pSym->addr) {
            GotSymAddress = TRUE;
            SymTypeInfo->Flags |= SYM_IS_VARIABLE;

            vprintf("Got address %p for symbol\n", SymTypeInfo->Address, MatchedName);
        }
    }

    PUCHAR tmp=pSym->sName;
    ULONG64 addr = pSym->addr;

    if (!exactMatch && strcmp((char *)MatchedName, (char *)SymName)) {
        CopyString(SymName, (char *) &MatchedName[0], sizeof(SymName));
    }

    if (!GotSymAddress) {
        pSym->addr = 0;
    }
    if (!pTypeInfo) {
        typPrint("Null pointer reference : FindTypeInfoInMod.pTypeInfo\n");
        return TRUE;
    }

    pTypeInfo->hProcess       = hProcess;
    pTypeInfo->ModBaseAddress = SymTypeInfo->ModBase ? SymTypeInfo->ModBase : ModBase;
    pTypeInfo->SymAddress     = SymTypeInfo->Address;
    pTypeInfo->TypeIndex      = SymTypeInfo->TypeIndex;
    CopyString((char *)pTypeInfo->ModName, ModName, sizeof(pTypeInfo->ModName));
    if (pTypeInfo->Name.Buffer) {
        if (strlen((char *) SymName) < pTypeInfo->Name.MaximumLength) {
            strcpy(pTypeInfo->Name.Buffer, (char *) SymName);
        } else {
            strncpy(pTypeInfo->Name.Buffer, (char *)SymName, pTypeInfo->Name.MaximumLength - 1);
            pTypeInfo->Name.Buffer[pTypeInfo->Name.MaximumLength - 1]=0;
        }
    }
    if (exactMatch && (SymTypeInfo->Flags & SYMFLAG_VALUEPRESENT)) {
        pTypeInfo->Value = SymTypeInfo->Value;
    }
    pTypeInfo->Flag = SymTypeInfo->Flags;


    //
    // Store the corresponding module information for fast future reference
    //
    if (pTypeInfo->Name.Buffer) {
        g_ReferencedSymbols.StoreTypeInfo(pTypeInfo);
    }
    if (addr) {
        // Use original value for this symbol
        pTypeInfo->SymAddress = pSym->addr  = addr;
        pTypeInfo->Flag = 0;
    }

    return FALSE;
}

/*
    TypeInfoFound
            Looks for the type information of the given symbol (which may either
            be a variable or a type name.

    Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize

    pImage              - Pointer to list of images (modules) for the process

    pSym                - Parameters for symbol lookup and dump

    pTypeInfo           - Used to return the type information

    Return Value:

     0 on success and error val on failure

*/

ULONG
TypeInfoFound(
    IN HANDLE hProcess,
    IN ImageInfo* pImage,
    IN PSYM_DUMP_PARAM_EX pSym,
    OUT PTYPES_INFO pTypeInfo
    )
{
    TCHAR  modName[256], symStored[MAX_NAME]={0}, nTimes=0;
    PTCHAR i, symPassed=(PTCHAR)pSym->sName;
    BOOL   modFound=FALSE, firstPass=TRUE;
    ULONG  TypeStored;
    CHAR   buff[sizeof(SYMBOL_INFO) + MAX_NAME];
    IMAGEHLP_MODULE64     mi;
    PSYMBOL_INFO psymbol;
    ULONG   Options = pSym->Options;
    static BOOL TypeInfoPresent=FALSE, TypeInfoChecked=FALSE;
    ULONG   res=0;
    ImageInfo* pImgStored=pImage;
    BOOL    FoundIt = FALSE, DbgDerivedType=FALSE;

    if (!pSym || !pTypeInfo)
    {
        vprintf("Null input values.\n");
        return NULL_SYM_DUMP_PARAM;
    }

    PDEBUG_SCOPE Scope = GetCurrentScope();

    if (pSym->sName)
    {
        CopyString(symStored, (char *)pSym->sName, sizeof(symStored));
    }
    else
    {
      //       pSym->sName = "";
    }

    // Special pointer/array type
    if (symStored[0] == '&')
    {
        DbgDerivedType = TRUE;
        CopyString(&symStored[0], &symStored[1], sizeof(symStored));
    }
    modName[0]='\0';
    if (symStored[0] != (TCHAR) NULL)
    {
        i = strchr((char *)symStored, '!');
        if (i)
        {
            if ( ((PCHAR)i - (PCHAR) symStored )< sizeof(modName))
            {
                strncpy(modName, (char *)symStored, (PCHAR)i - (PCHAR) symStored);
                modName[i - (char *)symStored]='\0';
            }
            CopyString((char *)symStored, i+1, sizeof(symStored));
            //
            // When debugging user mode, NT! should be treated as ntdll!
            //
            if (IS_USER_TARGET(g_Target))
            {
                if (!_stricmp(modName, "nt"))
                {
                    strcpy(modName, "ntdll");
                }
            }
        }
    }
    else
    {
        if (pSym->addr != 0)
        {
            DWORD64 dw=0;
            psymbol = (PSYMBOL_INFO) &buff[0];
            psymbol->MaxNameLen = MAX_NAME;
            if (SymFromAddr(hProcess, pSym->addr, &dw, psymbol))
            {
                CopyString((char *)symStored, psymbol->Name, sizeof(symStored));
                vprintf("Got symbol %s from address.\n", symStored);
                pTypeInfo->hProcess = hProcess;
                pTypeInfo->Flag = psymbol->Flags;
                pTypeInfo->ModBaseAddress = psymbol->ModBase;
                pTypeInfo->TypeIndex = psymbol->TypeIndex;
                pTypeInfo->Value = TypeInfoValueFromSymInfo(psymbol);
                pTypeInfo->SymAddress = psymbol->Address;
                if (pTypeInfo->Name.MaximumLength)
                {
                    CopyString(pTypeInfo->Name.Buffer, psymbol->Name, pTypeInfo->Name.MaximumLength);
                }
                return S_OK;
            }
            else
            {
                vprintf("No symbol associated with address.\n");
                return SYMBOL_TYPE_INDEX_NOT_FOUND;
            }
        } else if (pSym->TypeId && pSym->ModBase)
        {
            // do a sanity check if module base looks ok
            if (g_Process->FindImageByOffset(pSym->ModBase, TRUE) != NULL)
            {
                pTypeInfo->TypeIndex = pSym->TypeId;
                pTypeInfo->ModBaseAddress = pSym->ModBase;
                pTypeInfo->hProcess = hProcess;
                return S_OK;
            }
        }
    }

    //
    // Check if this is a special type
    //

    // Special pointer/array type
    if (symStored[0] == '&')
    {
        DbgDerivedType = TRUE;
        CopyString(&symStored[0], &symStored[1],sizeof(symStored));
    }
    PCHAR End = &symStored[strlen(symStored) -1];
    while (*End == '*' || *End == ']' || *End == ' ')
    {
        DbgDerivedType = TRUE;
        if (*End == '*')
        {
            // Pointer type
        }
        else if (*End == ']')
        {
//            --End;
            while (*End && (*End != '['))
            {
                --End;
            }
            // some way to check if array isdex is valid expr?
            if (*End!='[')
            {
                // syntax error
                typPrint("Syntax error in array type.\n");
                return E_INVALIDARG;
            }
        }
        *End=0;
        --End;
    }

    // Special pre-defined type
    if (!modName[0])
    {
        PDBG_NATIVE_TYPE Native = FindNativeTypeByName(symStored);
        if (Native)
        {
            pTypeInfo->TypeIndex = DbgNativeTypeId(Native);
            if (DbgDerivedType)
            {
                PDBG_GENERATED_TYPE GenType;

                // Create a type as a marker to indicate this
                // requires derived type processing.
                GenType = g_GenTypes.
                    FindOrCreateByAttrs(0, SymTagTypedef,
                                        pTypeInfo->TypeIndex, 0);
                if (!GenType)
                {
                    return E_OUTOFMEMORY;
                }

                pTypeInfo->TypeIndex = GenType->TypeId;
            }
            return S_OK;
        }
    }

    //
    // See if this type was already referenced previously, then we don't need
    // to go through module list.
    //
    TypeStored = g_ReferencedSymbols.LookupType(symStored, modName, exactMatch);
    if (TypeStored != -1)
    {
        // We already have the type index
        ANSI_STRING Name;

        Name = pTypeInfo->Name;
        RtlCopyMemory(pTypeInfo, g_ReferencedSymbols.GetStoredIndex(TypeStored), sizeof(TYPES_INFO));
        if (Name.Buffer)
        {
            CopyString(Name.Buffer, pTypeInfo->Name.Buffer, Name.MaximumLength);
        }
        pTypeInfo->Name = Name;

        if (!pSym->addr && pTypeInfo->SymAddress)
        {
            vprintf("Got Address %p from symbol.\n", pTypeInfo->SymAddress);
            pSym->addr = pTypeInfo->SymAddress;
        }
        FoundIt = TRUE;
    }

//    if (!modName[0])
    {
        if ((FoundIt && !(pTypeInfo->Flag & DEBUG_LOCALS_MASK)) ||
            !FoundIt)
        {
            //
            // Check if this can be found in local scope
            //
            if (FindLocalSymbol(hProcess, symStored, pTypeInfo))
            {
                pSym->addr = pTypeInfo->SymAddress; // Need this for statics
                FoundIt = TRUE;
            }
        }
    }

    if (FoundIt)
    {
        goto ExitSuccess;
    }

    if (modName[0])
    {
        // We first try to find it directly from dbghelp, without going
        // through dbgeng module list.
        // This helps resolve ntoskrnl! symbols
        ULONG64 modBase;

        GetModuleBase(modName, pImage, &modBase);
        if (!(res = FindTypeInfoInMod(hProcess, modBase, modName, (PCHAR) symStored, pSym, pTypeInfo)))
        {
            goto ExitSuccess;
        }
    }

    while (pImage || firstPass)
    {
        // Look up the module list
        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
        {
            return EXIT_ON_CONTROLC;
        }

        if (!pImage)
        {
            if (!modFound && modName[0])
            {
                PSTR EndOfModName;

                //
                // Reload the module if caller explicitly asked for it
                // Use a wildcard so that the extension doesn't need
                // to be known.
                //

                vprintf("Loading module %s.\n", modName);

                EndOfModName = modName + strlen(modName);
                if (EndOfModName < modName + (DIMA(modName) - 2))
                {
                    *EndOfModName = '.';
                    *(EndOfModName + 1) = '*';
                    *(EndOfModName + 2) = 0;
                }
                else
                {
                    EndOfModName = NULL;
                }

                PCSTR ArgsRet;

                if (g_Target->Reload(g_Thread, modName, &ArgsRet) == S_OK)
                {
                    pImage = pImgStored;
                }

                if (EndOfModName)
                {
                    // Restore modName.
                    *EndOfModName = 0;
                }
            }
            else
            {
                pImage = pImgStored;
            }
            firstPass = FALSE;
            continue;
        }
        if (modName[0])
        {
            if (_stricmp(modName, pImage->m_ModuleName) &&
                _stricmp(modName, pImage->m_OriginalModuleName))
            {
                pImage = pImage->m_Next;
                continue;
            }
        }
        modFound = TRUE;

        mi.SizeOfStruct = sizeof(mi);

        if (SymGetModuleInfo64( hProcess, pImage->m_BaseOfImage, &mi ))
        {
            ULONG ModSymsLoaded = FALSE;
            if (mi.SymType != SymPdb && mi.SymType != SymDia)
            {
                if (!firstPass && (mi.SymType == SymDeferred))
                {
                    // Load the deferred symbols on second pass
                    ModSymsLoaded = TRUE;
                    SymLoadModule64(hProcess,
                                    NULL,
                                    PrepareImagePath(mi.ImageName),
                                    mi.ModuleName,
                                    mi.BaseOfImage,
                                    mi.ImageSize);
                    SymGetModuleInfo64( hProcess, pImage->m_BaseOfImage, &mi );
                }
                else if (!firstPass)
                {
                    // No need to repeat, since no load done
                    pImage = pImage->m_Next;
                    continue;
                }
                if (mi.SymType != SymPdb && mi.SymType != SymDia)
                {
                    TypeInfoPresent = FALSE;
                    pImage = pImage->m_Next;
                    continue;
                }
                else
                {
                    vprintf(ModSymsLoaded ? " loaded symbols\n" : "\n");
                }
            }
            else
            {
                vprintf("\n");
            }
        }
        else
        {
            vprintf("Cannt get module info.\n");
            pImage = pImage->m_Next;
            continue;
        }

        if (!TypeInfoPresent || !TypeInfoChecked)
        {
            //
            // Check if we have the type information in pdbs
            //
            TypeInfoPresent = CheckForTypeInfo(hProcess,
                                               pImage->m_BaseOfImage);
        }

        if (TypeInfoPresent)
        {
            // Pdb symbols found, see if we can get type information.
            if (!(res = FindTypeInfoInMod(hProcess, pImage->m_BaseOfImage,
                                          pImage->m_ModuleName,
                                          (PCHAR) symStored, pSym, pTypeInfo)))
            {
                goto ExitSuccess;
            }
        }
        pImage = pImage->m_Next;
    }

    if (!TypeInfoPresent && !TypeInfoChecked && !(pSym->Options & DBG_RETURN_TYPE))
    {
        ErrOut("*************************************************************************\n"
               "***                                                                   ***\n"
               "***                                                                   ***\n"
               "***    Your debugger is not using the correct symbols                 ***\n"
               "***                                                                   ***\n"
               "***    In order for this command to work properly, your symbol path   ***\n"
               "***    must point to .pdb files that have full type information.      ***\n"
               "***                                                                   ***\n"
               "***    Certain .pdb files (such as the public OS symbols) do not      ***\n"
               "***    contain the required information.  Contact the group that      ***\n"
               "***    provided you with these symbols if you need this command to    ***\n"
               "***    work.                                                          ***\n"
               "***                                                                   ***\n"
               "***                                                                   ***\n"
               "*************************************************************************\n");
         //       TypeInfoChecked = TRUE;
    }
    res=SYMBOL_TYPE_INFO_NOT_FOUND;

    return (res);

ExitSuccess:
    if (DbgDerivedType)
    {
        PDBG_GENERATED_TYPE GenType;

        // Create a type as a marker to indicate this
        // requires derived type processing.
        GenType = g_GenTypes.NewType(0, SymTagTypedef, 0);
        if (!GenType)
        {
            return E_OUTOFMEMORY;
        }

        GenType->ChildId = pTypeInfo->TypeIndex;
        pTypeInfo->TypeIndex = GenType->TypeId;
    }
    return S_OK;
}

/*
// DumpTypeAndReturnInfo
//      This dumps the type based on given type info and symbol dump info
//
// pTypeInfo  : Has the type information required to process the type
//
// pSym       : Info on how to dump this symbol
//
// pStatus    : Error status returned here
//
// pReturnTypeInfo : Used to return Type info
//
// Return Val : Size of type dumped on success, 0 otherwise.
//
*/
ULONG
DumpTypeAndReturnInfo(
    PTYPES_INFO     pTypeInfo,
    PSYM_DUMP_PARAM_EX pSym,
    PULONG          pStatus,
    PFIND_TYPE_INFO pReturnTypeInfo
    )
{
    ULONG              Options = pSym->Options, AltNamesUsed=0;
    UCHAR              AltFieldNames[NUM_ALT_NAMES][256]={0};
    TYPE_DUMP_INTERNAL parseVars={0};
    ULONG              res, j,i ;
    UCHAR              LocalName[MAX_NAME], *saveName=pSym->sName;
    ULONG              SymRegisterId;
    DbgDerivedType *pTypeToDump = NULL;

    if (!pSym->addr) {
        pSym->addr = pTypeInfo->SymAddress;
    }

    if (pReturnTypeInfo) {
        // Copy the RETURN_TYPE flags
        Options |= pReturnTypeInfo->Flags;
    }
    res = 0;
    SymRegisterId = 0;

    //
    // Check if this is something on stack / registers
    //
    if (pTypeInfo->Flag & SYM_LOCAL) {
        PCSTR RegName;

        pSym->addr = pTypeInfo->SymAddress;

        if (pTypeInfo->Flag & SYMFLAG_REGISTER) {
            // Store register ID
            SymRegisterId = (ULONG) pTypeInfo->Value;
        }

        typPrint("Local var ");

        RegName = RegNameFromIndex((ULONG)pTypeInfo->Value);
        vprintf("[AddrFlags %lx  AddrOff %p  Reg/Val %s (%I64lx)] ",
                pTypeInfo->Flag,
                pTypeInfo->SymAddress,
                (RegName ? RegName : ""),
                pTypeInfo->Value);
        TranslateAddress(pTypeInfo->ModBaseAddress, pTypeInfo->Flag,
                         (ULONG) pTypeInfo->Value,
                         &pSym->addr, &pTypeInfo->Value);
        typPrint("@ %#p ", pSym->addr);

        if (!(Options & NO_PRINT)) {
            USHORT length = MAX_NAME;
            GetNameFromIndex(pTypeInfo, (PCHAR) &LocalName[0], &length);
            if (LocalName[0] && (LocalName[0]!='<')) {
                typPrint("Type %s", LocalName);
            }
        }
        typPrint("\n");
    } else if (pTypeInfo->Flag & SYMFLAG_TLSREL)
    {
        TranslateAddress(pTypeInfo->ModBaseAddress, pTypeInfo->Flag,
                         (ULONG) pTypeInfo->Value,
                         &pSym->addr, &pTypeInfo->Value);
    }

    //
    // Check if its a constant, then we already have its value
    //
    if (pTypeInfo->Flag & (SYMFLAG_VALUEPRESENT | SYMFLAG_REGISTER)) {
        vprintf("Const ");
        vprintf("%s = %I64lx\n", pSym->sName, pTypeInfo->Value);
        ExtPrint("%I64lx", pTypeInfo->Value);

        if ((Options & DBG_DUMP_COPY_TYPE_DATA) && pSym->Context) {
            *((PULONG64) pSym->Context) = pTypeInfo->Value;
        }
        parseVars.Value = pTypeInfo->Value;
        parseVars.ValuePresent = TRUE;
    }

    if (!(Options & LIST_DUMP)) {
        // Dump only 10 elements as default
        parseVars.nElements = 10;
        if ((pSym->Options & DBG_DUMP_ARRAY) && (pSym->listLink)) {
            parseVars.nElements = (USHORT) pSym->listLink->size;
        }
    } else {
        //
        // List dump - make sure we have a list name
        //
        if (!pSym->listLink || !pSym->listLink->fName) {
            vprintf("NULL field name for list dump - Exiting.\n");
            parseVars.ErrorStatus = NULL_FIELD_NAME;
            goto exitDumpType;
        }
    }

    if (pSym->nFields || pSym->listLink) {
        parseVars.AltFields = (PALT_FIELD_INFO) AllocateMem((pSym->nFields + (pSym->listLink ? 1 : 0))
                                                            * sizeof(ALT_FIELD_INFO));

        if (!parseVars.AltFields) {
            parseVars.ErrorStatus = CANNOT_ALLOCATE_MEMORY;
            goto exitDumpType;
        } else {
            ZeroMemory(parseVars.AltFields, (pSym->nFields + (pSym->listLink ? 1 : 0))* sizeof(ALT_FIELD_INFO));
        }
    }

    AltNamesUsed=0;
    //
    // Check if field names are properlyinitialized
    //
    for (j=0;j<pSym->nFields; j++) {
        ULONG IndexValue=0;

        if (!pSym->Fields[j].fName) {
            vprintf("NULL field name at %d - Exiting.\n", j);
            parseVars.ErrorStatus = NULL_FIELD_NAME;
            goto exitDumpType;
        }
        if (pSym->Fields[j].fOptions & DBG_DUMP_FIELD_ARRAY) {

            parseVars.AltFields[j].ArrayElements = pSym->Fields[j].size;
        }
    }


    //
    //
    // Sign extend the address
    //
    if (!g_Machine->m_Ptr64 && !(Options & DBG_DUMP_READ_PHYSICAL)) {
        pSym->addr = (ULONG64) ((LONG64)((LONG) pSym->addr));
    }

    parseVars.ErrorStatus = 0;
    parseVars.TypeOptions   = pSym->Options;
    parseVars.rootTypeIndex = pTypeInfo->TypeIndex;
    parseVars.hProcess      = pTypeInfo->hProcess;
    parseVars.modBaseAddr   = pTypeInfo->ModBaseAddress;
    if (pTypeInfo->Flag & SYM_IS_VARIABLE) {
        parseVars.IsAVar = TRUE;
    }
    Options = pSym->Options;

    if (pReturnTypeInfo) {
        parseVars.level= (pReturnTypeInfo->Flags & (DBG_RETURN_TYPE ) ) ? 1 : 0;
        parseVars.pInfoFound = pReturnTypeInfo;
        parseVars.NumSymParams = pReturnTypeInfo->nParams;
        parseVars.TypeOptions |= pReturnTypeInfo->Flags;
        parseVars.CurrentSymParam = 0;
        parseVars.Prefix     = &pReturnTypeInfo->SymPrefix[0];
        if (pReturnTypeInfo->Flags & DBG_RETURN_SUBTYPES) {
            parseVars.CopyName = 1;
        }
    }


    if ((Options & DBG_DUMP_ARRAY) && (!parseVars.nElements)) {
    //
    // Default : array dump only a maximum of 20 elements
    //
        parseVars.nElements=20;
    }
    i=0;

    //
    // Handle cases when given address is not the addres of begining of type
    //
    if (pSym->addr && (Options & (DBG_DUMP_ADDRESS_OF_FIELD | DBG_DUMP_ADDRESS_AT_END))) {
        ULONG64 addr=0;

        if ((Options & DBG_DUMP_ADDRESS_OF_FIELD) && (pSym->listLink))
            // Get address from address of field
            addr = GetTypeAddressFromField(pSym->addr, pSym->sName, pSym->listLink->fName);
        else if (Options & DBG_DUMP_ADDRESS_AT_END)
            // Get address form end of type record
            addr = GetTypeAddressFromField(pSym->addr, pSym->sName, NULL);

        if (!addr) {
            goto exitDumpType;
        }
        pSym->addr = addr;
    }

    if (pSym->sName) {
        CopyString((PCHAR)LocalName, (PCHAR)pSym->sName, sizeof(LocalName));
        pSym->sName = (PUCHAR) &LocalName[0];
    }

    //
    // Check is caller wants the whole type data and this is a primitive type
    //
    if ((Options & DBG_DUMP_COPY_TYPE_DATA) && //(IsAPrimType( parseVars.rootTypeIndex)) &&
        pSym->Context) {
        parseVars.CopyDataInBuffer = TRUE;
        parseVars.TypeDataPointer  = (PUCHAR)pSym->Context;
    }

    pTypeToDump = new DbgDerivedType(&parseVars, pTypeInfo, pSym);

    if (!pTypeToDump) {
        parseVars.ErrorStatus = CANNOT_ALLOCATE_MEMORY;
        goto exitDumpType;
    }
    do {
        if ((Options & (DBG_DUMP_ARRAY | DBG_DUMP_LIST)) &&
            (pSym->CallbackRoutine || ( pSym->listLink && pSym->listLink->fieldCallBack)) &&
            !(pSym->listLink->fOptions & NO_CALLBACK_REQ)) {
            //
            // Call the routine before each element dump
            //
            PSYM_DUMP_FIELD_CALLBACK_EX Routine=pSym->CallbackRoutine;

            if ( pSym->listLink && pSym->listLink->fieldCallBack) {
                Routine = (PSYM_DUMP_FIELD_CALLBACK_EX) pSym->listLink->fieldCallBack;
            }
            pSym->listLink->address = pSym->addr;

            if ((*Routine)(pSym->listLink, pSym->Context)) {
                // dprintf("List callback successful, exiting.\n");
                if (!res) res = -1;
                break;
            }
        }

        if ((Options & (DBG_DUMP_LIST | DBG_DUMP_ARRAY)) && (pSym->listLink) && (pSym->addr)) {
            parseVars.NextListElement =0;

            // Print heading
            if ( pSym->listLink->printName ) {
                typPrint((char *)pSym->listLink->printName);
            } else {
                if (Options & DBG_DUMP_LIST) {
                    typPrint((g_Machine->m_Ptr64 ? "%s at 0x%I64x" : "%s at 0x%x"), pSym->listLink->fName, pSym->addr);
                } else {
                    typPrint("[%d] ", i++);
                    vprintf((g_Machine->m_Ptr64 ? "at 0x%I64x" : "at 0x%x"), pSym->addr);
                }
                if (!(parseVars.TypeOptions & DBG_DUMP_COMPACT_OUT))
                    typPrint( "\n---------------------------------------------\n" );
            }
        }


//        res=ProcessType(&parseVars, parseVars.rootTypeIndex, pSym);
        res=pTypeToDump->DumpType();

        CheckFieldsMatched(&res, &parseVars, pSym);

        if (parseVars.ErrorStatus) {

            res = 0;
            break;
        }

        if (parseVars.TypeOptions & DBG_DUMP_COMPACT_OUT &&
            !(parseVars.TypeOptions & DBG_DUMP_FUNCTION_FORMAT))  typPrint( "\n" );

        if (pSym->addr) {
            if (Options & DBG_DUMP_LIST) {
                pSym->addr = parseVars.NextListElement;
                if (pSym->addr == parseVars.LastListElement) {
                    break;
                }
                if (!(parseVars.TypeOptions & DBG_DUMP_COMPACT_OUT))  typPrint( "\n" );
                // dprintf("Next :%p, Reamaining elts %d, res %d\n", pSym->addr, pParseVars->nElements, res);
            } else if (Options & DBG_DUMP_ARRAY) {
                pSym->addr +=res;
                if (parseVars.nElements) {
                    // Read a large block into cache
                    parseVars.nElements--;
                    if (!ReadInAdvance(pSym->addr, min (parseVars.nElements * res, 1000), parseVars.TypeOptions)) {
                        parseVars.InvalidAddress = pSym->addr;
                        parseVars.ErrorStatus = MEMORY_READ_ERROR;
                    }

                }
                if (!(parseVars.TypeOptions & DBG_DUMP_COMPACT_OUT))  typPrint( "\n" );
            }

            if ((Options & (DBG_DUMP_ARRAY | DBG_DUMP_LIST)) &&
                (g_EngStatus & ENG_STATUS_USER_INTERRUPT)) {
                res=0;
                break;
            }
            parseVars.totalOffset =0;
        }
        if ((parseVars.PtrRead) && (res==4) && pSym->addr) {
            res=8;
        }


        //
        // Loop for dumping lists / array
        //
    } while ( res && (Options & (DBG_DUMP_ARRAY | DBG_DUMP_LIST)) &&
              pSym->addr && ((Options & DBG_DUMP_LIST) || (parseVars.nElements)));



exitDumpType:
    *pStatus = parseVars.ErrorStatus;
    pSym->sName = saveName;
    if (parseVars.AltFields) {
        FreeMem((PVOID) parseVars.AltFields);
    }
    if (pTypeToDump) {
        delete pTypeToDump;
    }
    if (pReturnTypeInfo) {
        pReturnTypeInfo->nParams = parseVars.CurrentSymParam;

        if (!pReturnTypeInfo->FullInfo.Address && SymRegisterId) {
            // We do not have address of this expression which was in register initially
            // return the register ID.
            pReturnTypeInfo->FullInfo.Register = SymRegisterId;
            pReturnTypeInfo->FullInfo.Flags |= SYMFLAG_REGISTER;
        }

    }
    LastReadError = (parseVars.ErrorStatus == MEMORY_READ_ERROR ? parseVars.InvalidAddress : 0);
    pSym->TypeSize = res;
    pSym->TypeId = pTypeInfo->TypeIndex;
    pSym->ModBase = pTypeInfo->ModBaseAddress;
    pSym->fPointer = parseVars.PtrRead ? 1 : 0;
    return (parseVars.ErrorStatus ? 0 : res);
}

ULONG
OutputTypeByIndex(
    HANDLE hProcess,
    ULONG64 ModBase,
    ULONG TypeIndex,
    ULONG64 Address
    )
{
    TYPE_DUMP_INTERNAL parseVars = {0};
    TYPES_INFO TypeInfo = {0};
    SYM_DUMP_PARAM_EX Sym = {0};
    DbgDerivedType* pTypeToDump;

    parseVars.hProcess = hProcess;
    parseVars.modBaseAddr = ModBase;

    TypeInfo.TypeIndex = TypeIndex;
    TypeInfo.ModBaseAddress = ModBase;
    TypeInfo.hProcess = hProcess;

    Sym.size = sizeof(Sym);
    Sym.addr = Address;

    pTypeToDump = new DbgDerivedType(&parseVars, &TypeInfo, &Sym);
    if (!pTypeToDump) {
        return CANNOT_ALLOCATE_MEMORY;
    } else {
        pTypeToDump->DumpType();
        delete pTypeToDump;
        return parseVars.ErrorStatus;
    }
}

/*
// DumpType
//      This dumps the type based on given type info and symbol dump info
//
// pTypeInfo  : Has the type information required to process the type
//
// pSym       : Info on how to dump this symbol
//
// pStatus    : Error status returned here
//
// Return Val : Size of type dumped on success, 0 otherwise.
//
*/
ULONG
DumpType(
    PTYPES_INFO     pTypeInfo,
    PSYM_DUMP_PARAM_EX pSym,
    PULONG          pStatus
    )
{
    return DumpTypeAndReturnInfo(pTypeInfo, pSym, pStatus, NULL);
}

#define ENABLE_FAST_DUMP 1
#if ENABLE_FAST_DUMP

#define FAST_DUMP_DEBUG 0

// We don't want a lot of syms here, although this should be more than number of types
// an extension references on an average
#define NUM_FASTDUMP 10

FAST_DUMP_INFO g_FastDumps[NUM_FASTDUMP]={0};
UCHAR g_FastDumpNames[NUM_FASTDUMP][MAX_NAME];

void
ReleaseFieldInfo(PFIELD_INFO_EX pFlds, ULONG nFlds)
{
    while (nFlds) {
        --nFlds;
        if (pFlds[nFlds].fName)
            FreeMem(pFlds[nFlds].fName);
    }
    FreeMem(pFlds);
}

void
ClearAllFastDumps()
{
    for (int i=0; i<NUM_FASTDUMP;i++) {
        if (g_FastDumps[i].nFields) {
            ReleaseFieldInfo(g_FastDumps[i].Fields, g_FastDumps[i].nFields);
        }
    }
    ZeroMemory(g_FastDumpNames, sizeof(g_FastDumpNames));
    ZeroMemory(g_FastDumps, sizeof(g_FastDumps));
}

ULONG
FindInFastDumpAndCopy(PSYM_DUMP_PARAM_EX pSym)
{
    FAST_DUMP_INFO *pCheckType = NULL;
    PFIELD_INFO_EX  s, d;

    // Search the symbol
    ULONG UseSym=0;
    while (UseSym < NUM_FASTDUMP && pSym->sName) {
        if (!strcmp((char *) &g_FastDumpNames[UseSym][0], (char *) pSym->sName)) {
            pCheckType = &g_FastDumps[UseSym];
            assert(pCheckType->sName == &g_FastDumpNames[UseSym][0]);
            break;
        }
        ++UseSym;
    }

    if (!pCheckType) {
        return FALSE;
    }

    if (!pSym->nFields) {
        pSym->TypeSize = pCheckType->TypeSize;
        pSym->TypeId   = pCheckType->TypeId;
        pSym->ModBase  = pCheckType->ModBase;
        pSym->fPointer = pCheckType->fPointer;
        if (!pSym->addr)
        {
            pSym->addr = pCheckType->addr;
        }
        if (pSym->Options & DBG_DUMP_COPY_TYPE_DATA) {
            if (!ReadTypeData((PUCHAR) pSym->Context, pSym->addr, pSym->TypeSize, pSym->Options)) {
                return -1;
            }
            if (pSym->fPointer && !g_Machine->m_Ptr64) {
                *((PULONG64) pSym->Context) =
                    (ULONG64) (LONG64) (LONG) *((PULONG64) pSym->Context);
                pSym->TypeSize = sizeof(ULONG64); // We copied ULONG64 for 32 bit pointers so set size to 8
            }
        } else if (pSym->addr) { // check if this adress is readable
            ULONG dummy;
            if (!ReadTypeData((PUCHAR) &dummy, pSym->addr, sizeof(dummy), pSym->Options)) {
                return -1;
            }
        }
        return pSym->TypeSize;
    }

    if (!strcmp((char *)pCheckType->sName, (char *) pSym->sName)) {
        for (ULONG findIt=0;
             pSym->Fields && findIt < pSym->nFields;
             findIt++)
        {
            BOOL found = FALSE;
            for (ULONG chkFld = 0;
                 pCheckType->Fields && chkFld < pCheckType->nFields;
                 chkFld++)
            {
                if (!strcmp((char *)pCheckType->Fields[chkFld].fName,
                            (char *)pSym->Fields[findIt].fName)) {

                    // Force sign extension of symbol address on
                    // 32-bit targets to match the behavior of
                    // ReadTypeData.
                    ULONG64 SymAddr = g_Machine->m_Ptr64 ?
                        pSym->addr : EXTEND64(pSym->addr);

                    if (!SymAddr && pCheckType->addr)
                    {
                        SymAddr = pCheckType->addr;
                    }
                    s = &pCheckType->Fields[chkFld];
                    d = &pSym->Fields[findIt];

#if FAST_DUMP_DEBUG
                    dprintf("Found +%03lx %s %lx, opts %lx, %lx\n",
                            s->fOffset, s->fName, s->size, d->fOptions, s->fType);
#endif
                    //
                    // Copy the required data
                    //
                    d->BitField    = s->BitField;
                    d->size        = s->size;
                    d->address     = s->FieldOffset + SymAddr;
                    d->FieldOffset = s->FieldOffset;
                    d->fPointer    = s->fPointer;
                    if (SymAddr) {
                        PCHAR buff=NULL;
                        ULONG readSz;
                        ULONG64 readAddr = d->address;

                        if (d->fOptions & DBG_DUMP_FIELD_COPY_FIELD_DATA) {
                            buff = (PCHAR) d->fieldCallBack;
                        } else if (!(d->fOptions & DBG_DUMP_FIELD_RETURN_ADDRESS) &&
                                   (s->size <= sizeof(ULONG64))) {
                            buff = (PCHAR) &d->address;
                            d->address = 0;
                        }
                        if (buff) {

                            if (s->fPointer && !g_Machine->m_Ptr64) {
                                readSz = (g_Machine->m_Ptr64 ? 8 : 4);
                            } else {
                                readSz = s->size;
                            }

                            if (s->BitField.Size) {
                                ULONG64 readBits;
                                ULONG64 bitCopy;

                                readSz = (s->BitField.Position % 8 + s->BitField.Size + 7) /8 ;
                                readAddr += (s->BitField.Position / 8);

                                if (!ReadTypeData((PUCHAR) &readBits, readAddr, readSz, pSym->Options)) {
                                    return -1;
                                }


                                readBits = readBits >> (s->BitField.Position % 8);
                                bitCopy = ((ULONG64) 1 << s->BitField.Size);
                                bitCopy -= (ULONG64) 1;
                                readBits &= bitCopy;

                                memcpy(buff, &readBits, (s->BitField.Size + 7) /8);

                            } else {
                                if (!ReadTypeData((PUCHAR) buff, readAddr, readSz, pSym->Options)) {
                                    return -1;
                                }
                            }

                            if (s->fPointer && !g_Machine->m_Ptr64) {
                                *((PULONG64) buff) = (ULONG64) (LONG64) *((PLONG) buff);
                            }
                        }
                        if (d->fOptions & DBG_DUMP_FIELD_SIZE_IN_BITS) {
                            d->address = ((SymAddr + s->FieldOffset) << 3) + s->BitField.Position;
                            d->size    = s->BitField.Size;
                        }

                    } else if (d->fOptions & DBG_DUMP_FIELD_SIZE_IN_BITS) {
                        d->address = ((s->FieldOffset) << 3) + s->BitField.Position;
                        d->size    = s->BitField.Size;
                    }
                    if (!SymAddr) {
                        if ((d->fOptions & DBG_DUMP_FIELD_COPY_FIELD_DATA) ||
                            (!(d->fOptions & DBG_DUMP_FIELD_RETURN_ADDRESS) &&
                             (s->size <= sizeof(ULONG64)))) {
                            return -1;
                        }
                    }

                    found = TRUE;
                    break;
                }
            }
            if (!found) {
                return FALSE;
            }
        }
#if FAST_DUMP_DEBUG
        dprintf("fast match found \n");
#endif
        return pCheckType->TypeSize;

    }
    return 0;

}

void
AddSymToFastDump(
    PSYM_DUMP_PARAM_EX pSym
    )
{
    FAST_DUMP_INFO *pCheckType = NULL;
    PFIELD_INFO_EX  pMissingFields;
    ULONG           nMissingFields;
    static ULONG    symindx=0;

    // Search the symbol
    ULONG UseSym=0;
    while (UseSym < NUM_FASTDUMP && pSym->sName) {
        if (!strcmp((char *) &g_FastDumpNames[UseSym][0], (char *) pSym->sName)) {
            pCheckType = &g_FastDumps[UseSym];
            assert(pCheckType->sName == &g_FastDumpNames[UseSym][0]);
            break;
        }
        ++UseSym;
    }
    if (!pCheckType) {
        // Insert
        if (pSym->fPointer) {
            // Make sure we have right size stored with pointers
            // TypeSize was 8 for 32 bit target if pointer was read
            pSym->TypeSize = g_Machine->m_Ptr64 ? 8 : 4;
        }
        pCheckType = &g_FastDumps[symindx];
        *pCheckType = *pSym;
        pCheckType->sName = &g_FastDumpNames[symindx][0];
        CopyString((char *) &g_FastDumpNames[symindx][0],(char *) pSym->sName,
                   sizeof(g_FastDumpNames[symindx]));
        pCheckType->Fields = NULL;
        pCheckType->nFields = 0;
        symindx = ++symindx % NUM_FASTDUMP;
    }

    pMissingFields = (PFIELD_INFO_EX) AllocateMem(pSym->nFields * sizeof(FIELD_INFO_EX));

    if (!pMissingFields) {
        return ;
    }
    ZeroMemory(pMissingFields, pSym->nFields * sizeof(FIELD_INFO_EX));

    nMissingFields = 0;
    if (!strcmp((char *)pCheckType->sName, (char *) pSym->sName)) {
        for (ULONG findIt=0;
             pSym->Fields && findIt < pSym->nFields;
             findIt++)
        {
            BOOL found = FALSE;
            for (ULONG chkFld = 0;
                 pCheckType->Fields && chkFld < pCheckType->nFields;
                 chkFld++)
            {
                if (!strcmp((char *)pCheckType->Fields[chkFld].fName,
                            (char *)pSym->Fields[findIt].fName)) {
                    found = TRUE;
                    break;
                }
            }
            if (!found) {
                pMissingFields[nMissingFields].fName    = pSym->Fields[findIt].fName;
                pMissingFields[nMissingFields].size     = pSym->Fields[findIt].size;
                pMissingFields[nMissingFields].TypeId   = pSym->Fields[findIt].TypeId;
                pMissingFields[nMissingFields].BitField = pSym->Fields[findIt].BitField;
                pMissingFields[nMissingFields].fPointer = pSym->Fields[findIt].fPointer;
                pMissingFields[nMissingFields].FieldOffset  = pSym->Fields[findIt].FieldOffset;
                nMissingFields++;
            }
        }
        if (nMissingFields) {
            PFIELD_INFO_EX newFlds;

            newFlds = (PFIELD_INFO_EX) AllocateMem((pCheckType->nFields + nMissingFields)* sizeof(FIELD_INFO_EX));
            ZeroMemory(newFlds, (pCheckType->nFields + nMissingFields)* sizeof(FIELD_INFO_EX));

            if (!newFlds) {
                FreeMem(pMissingFields);
                return ;
            }

            ULONG field;
            for (field = 0; field <nMissingFields;field++) {
                newFlds[field] = pMissingFields[field];
                newFlds[field].fName = (PUCHAR) AllocateMem(strlen((PCHAR) pMissingFields[field].fName) + 1);
                if (!newFlds[field].fName) {
                    ReleaseFieldInfo(newFlds, field+1);
                    FreeMem(pMissingFields);
                    return ;
                }
                strcpy((PCHAR) newFlds[field].fName, (PCHAR) pMissingFields[field].fName);
#if FAST_DUMP_DEBUG
                dprintf("Adding +%03lx %s %lx\n",
                        newFlds[field].fOffset, newFlds[field].fName, newFlds[field].size);
#endif
            }

            if (pCheckType->nFields) {
                memcpy(&newFlds[field], pCheckType->Fields, pCheckType->nFields * sizeof(FIELD_INFO_EX));

                FreeMem(pCheckType->Fields);
            }
            pCheckType->nFields += nMissingFields;
            pCheckType->Fields = newFlds;
        }

    }
    FreeMem(pMissingFields);
}

/*
  A faster way to dump if same type is dump repeatedly - improves performance
  of extensions.
*/
ULONG
FastSymbolTypeDump(
    PSYM_DUMP_PARAM_EX pSym,
    PULONG pStatus
    )
{
    if (pSym->nFields > 1) {
        return 0;
    }
    if (!(pSym->Options & NO_PRINT) ||
        pSym->listLink ||
        (pSym->Options & (DBG_DUMP_CALL_FOR_EACH | DBG_DUMP_LIST |
                          DBG_DUMP_ARRAY | DBG_DUMP_ADDRESS_OF_FIELD |
                          DBG_DUMP_ADDRESS_AT_END)) ||
        (pSym->Context && !(pSym->Options & DBG_DUMP_COPY_TYPE_DATA))) {
        return 0;
    }
    ULONG fld;
    for (fld = 0; fld<pSym->nFields; fld++) {
        if ((pSym->Fields[fld].fOptions & (DBG_DUMP_FIELD_ARRAY | DBG_DUMP_FIELD_CALL_BEFORE_PRINT |
                                          DBG_DUMP_FIELD_STRING)) ||
            (!(pSym->Fields[fld].fOptions & DBG_DUMP_FIELD_COPY_FIELD_DATA) &&
             pSym->Fields[fld].fieldCallBack)) {
            return 0;
        }
    }

    // Make sure we have everything in
    ULONG retval;
    if (!(retval = FindInFastDumpAndCopy(pSym))) {
        ULONG64 OriginalAddress, ReturnedAddress;

        OriginalAddress = pSym->addr;
        if (retval = SymbolTypeDumpNew(pSym, pStatus)) {
            pSym->TypeSize = retval;
            ReturnedAddress = pSym->addr;
            if (!OriginalAddress && ReturnedAddress)
            {
                // We got address from symbol, this should be saved
                pSym->addr = ReturnedAddress;
            }  else
            {
                // Do not save the address caller used
                pSym->addr = 0;
            }
            AddSymToFastDump(pSym);
            pSym->addr = ReturnedAddress;
        }
    } else if (retval == -1) {
        // FindInFastDumpAndCopy returns -1 for memory read error
        retval = 0;
        *pStatus = MEMORY_READ_ERROR;
    } else {
        *pStatus = 0;
    }

    return retval;
}
#endif // ENABLE_FAST_DUMP

//
// Main routine to dunmp types
//      This looks up if the symtype info in available and then dumps the type
//
//      Returns size of the symbol dumped
ULONG
SymbolTypeDumpNew(
    IN OUT PSYM_DUMP_PARAM_EX pSym,
    OUT PULONG pStatus
    )
{
    TYPES_INFO typeInfo = {0};
    CHAR       MatchedName[MAX_NAME];
    ULONG      err;

    typeInfo.Name.Buffer = &MatchedName[0];
    typeInfo.Name.Length = typeInfo.Name.MaximumLength = MAX_NAME;

    if (pSym->size != sizeof(SYM_DUMP_PARAM_EX)) {
        if (pStatus) *pStatus = INCORRECT_VERSION_INFO;
        return FALSE;
    }

    if (pSym->Options & (DBG_RETURN_TYPE | DBG_RETURN_SUBTYPES | DBG_RETURN_TYPE_VALUES)) {
        return FALSE;
    }

    if (!(err = TypeInfoFound(
                      g_Process->m_SymHandle,
                      g_Process->m_ImageHead,
                      pSym,
                      &typeInfo))) {
        if (typeInfo.TypeIndex) {
            return DumpType(&typeInfo, pSym, pStatus);
        }

        err = SYMBOL_TYPE_INFO_NOT_FOUND;
    }

    if (pStatus) {
        *pStatus = err;
    }

    return FALSE;
}

ULONG
SymbolTypeDump(
    IN HANDLE hProcess,
    IN ImageInfo* pImage,
    IN PSYM_DUMP_PARAM   pSym,
    OUT PULONG pStatus)
/*++

Routine Description:
   This returns the size of the type of symbol if successful. This is called
   upon an IOCTL request IG_DUMP_SYMBOL_INFO or by SymBolTypeDumpEx.
   Thislooks up the module information for symbol, and loads module symbols if
   possible. If pdb symbols are found, it calls ParseTypeRecordEx for type dump from
   the module found.
   This is internal to ntsd module.

Arguments:

    pSym                - Parameters for PDB symbol dump

    pStatus             - Contains the error value on failure.

Return Value:

    Size of type is successful. 0 otherwise.

--*/
{
    ULONG ret, i;
    PSYM_DUMP_PARAM_OLD pSymSave=NULL;
    SYM_DUMP_PARAM_EX locSym = {0};
    FIELD_INFO_EX lst = {0};
    if (pSym->size == sizeof(SYM_DUMP_PARAM_OLD)) {
        pSymSave = (PSYM_DUMP_PARAM_OLD) pSym;
        // convert old to new
        memcpy(&locSym, pSymSave, sizeof(SYM_DUMP_PARAM_OLD));
        locSym.size = sizeof(SYM_DUMP_PARAM_EX);
        locSym.Fields = locSym.nFields ?
            (PFIELD_INFO_EX) AllocateMem(locSym.nFields * sizeof(FIELD_INFO_EX)) : NULL;
        if (pSymSave->listLink) {
            locSym.listLink = &lst;
            memcpy(locSym.listLink, pSymSave->listLink, sizeof(FIELD_INFO_OLD));
        }
        if (!locSym.Fields && locSym.nFields) {
            *pStatus = CANNOT_ALLOCATE_MEMORY;
            return 0;
        }
        ZeroMemory(locSym.Fields, locSym.nFields * sizeof(FIELD_INFO_EX));
        for (i=0; i<locSym.nFields; i++) {
            memcpy(&locSym.Fields[i], &pSymSave->Fields[i], sizeof(FIELD_INFO_OLD));
        }
        pSym = &locSym;
    }
    *pStatus = 0;
    pSym->fPointer = 0;
#if ENABLE_FAST_DUMP
    if (!(ret = FastSymbolTypeDump(pSym, pStatus)))
    {
        if (!*pStatus)
        {
            ret = SymbolTypeDumpNew(pSym, pStatus);
        }
    }
#else
    ret = SymbolTypeDumpNew(pSym, pStatus);
#endif

    if (pSymSave) {
        if (pSymSave->listLink) {
            locSym.listLink = &lst;
            memcpy(pSymSave->listLink, locSym.listLink, sizeof(FIELD_INFO_OLD));
        }
        for (i=0; i<locSym.nFields; i++) {
            memcpy(&pSymSave->Fields[i], &locSym.Fields[i], sizeof(FIELD_INFO_OLD));
        }
        if (locSym.Fields) {
            FreeMem(locSym.Fields);
        }
    }
    return ret;
}

/*++
  This can be used to dump variables of primitive or pointer types.
  This only dumps a single line info for Name.
  It'll not dump any sub-fields of the variable
--*/
ULONG
DumpSingleValue (
    PSYMBOL_INFO pSymInfo
    )
{
    TYPES_INFO typeInfo = {0};
    CHAR       MatchedName[MAX_NAME];
    ULONG      err;
    SYM_DUMP_PARAM_EX TypedDump = {0};
    ULONG Status=0;
    FIND_TYPE_INFO FindInfo={0};

    FindInfo.Flags = DBG_RETURN_TYPE_VALUES | DBG_RETURN_TYPE;
    FindInfo.nParams = 1;

    TypedDump.size  = sizeof(SYM_DUMP_PARAM_EX);
    TypedDump.sName = (PUCHAR) pSymInfo->Name;
    TypedDump.Options = NO_PRINT | DBG_DUMP_FUNCTION_FORMAT;
    typeInfo.Name.Buffer = &MatchedName[0];
    typeInfo.Name.Length = typeInfo.Name.MaximumLength = MAX_NAME;

    if (pSymInfo->TypeIndex) {
        typeInfo.TypeIndex = pSymInfo->TypeIndex;
        typeInfo.ModBaseAddress = pSymInfo->ModBase;
        typeInfo.Flag      = pSymInfo->Flags;
        typeInfo.SymAddress = pSymInfo->Address;
        typeInfo.hProcess  = g_Process->m_SymHandle;
        TypedDump.addr     = pSymInfo->Address;
        typeInfo.Value = TypeInfoValueFromSymInfo(pSymInfo);
    }

    if (pSymInfo->TypeIndex ||
        !(err = TypeInfoFound(
                      g_Process->m_SymHandle,
                      g_Process->m_ImageHead,
                      &TypedDump,
                      &typeInfo))) {
        if (typeInfo.TypeIndex && (typeInfo.SymAddress || typeInfo.Flag)) {
            return DumpTypeAndReturnInfo(&typeInfo, &TypedDump, &err, &FindInfo);
        }
        return TRUE;
    }
    return FALSE;
}

BOOL
GetConstantNameAndVal(
    HANDLE hProcess,
    ULONG64 ModBase,
    ULONG TypeIndex,
    PCHAR *pName,
    PULONG64 pValue
    )
{
    PWCHAR pWname;
    VARIANT var;
    ULONG len;

    *pName = NULL;
    if (!SymGetTypeInfo(hProcess, ModBase, TypeIndex,
                        TI_GET_SYMNAME, (PVOID) &pWname) ||
        !SymGetTypeInfo(hProcess, ModBase, TypeIndex,
                        TI_GET_VALUE, (PVOID) &var)) {
        return FALSE;
    }

    if (pWname) {
        *pName = UnicodeToAnsi((BSTR) pWname);
        LocalFree (pWname);
    } else {
        *pName = NULL;
        return FALSE;
    }

    switch (var.vt) {
    case VT_UI2:
    case VT_I2:
        *pValue = var.iVal;
        len = 2;
        break;
    case VT_R4:
        *pValue = (ULONG64) var.fltVal;
        len=4;
        break;
    case VT_R8:
        *pValue = (ULONG64) var.dblVal;
        len=8;
        break;
    case VT_BOOL:
        *pValue = var.lVal;
        len=4;
        break;
    case VT_I1:
    case VT_UI1:
        *pValue = var.bVal;
        len=1;
        break;
    case VT_I8:
    case VT_UI8:
        *pValue = var.ullVal;
        len=8;
        break;
    case VT_UI4:
    case VT_I4:
    case VT_INT:
    case VT_UINT:
    case VT_HRESULT:
        *pValue = var.lVal;
        len=4;
        break;
    default:
//        sprintf(Buffer, "UNIMPLEMENTED %lx %lx", var.vt, var.lVal);
        len=4;
        break;
    }
    return TRUE;
}


BOOL
GetEnumTypeName(
    HANDLE hProcess,
    ULONG64 ModBase,
    ULONG TypeIndex,
    ULONG64 Value,
    PCHAR Name,
    PUSHORT NameLen
    )
{
    ULONG nelements=0;
    // Get the childrens
    if (!SymGetTypeInfo(hProcess, ModBase, TypeIndex,
                        TI_GET_CHILDRENCOUNT, (PVOID) &nelements)) {
        return FALSE;
    }
    TI_FINDCHILDREN_PARAMS *pChildren;

    pChildren = (TI_FINDCHILDREN_PARAMS *)
        AllocateMem(sizeof(TI_FINDCHILDREN_PARAMS) +
                    sizeof(ULONG) * nelements);
    if (!pChildren) {
        return 0;
    }

    pChildren->Count = nelements;
    pChildren->Start = 0;
    if (!SymGetTypeInfo(hProcess, ModBase, TypeIndex,
                        TI_FINDCHILDREN, (PVOID) pChildren)) {
        FreeMem(pChildren);
        return 0;
    }

    for (ULONG i = 0; i< nelements; i++) {
        PCHAR pName;
        DWORD64 qwVal=0;

        // Find name and value for a child TI
        GetConstantNameAndVal(hProcess, ModBase, pChildren->ChildId[i],
                              &pName, &qwVal);

        if (pName) {
            // Fill-in name if value matches
            if (Value == qwVal) {
                if (*NameLen > strlen(pName)) {
                    strcpy(Name, pName);
                    *NameLen = strlen(pName)+1;
                    FreeMem(pName);
                    FreeMem(pChildren);
                    return TRUE;
                }
            }
            FreeMem(pName);
        }
    }

    FreeMem(pChildren);
    return FALSE;
}
HRESULT
GetNameFromIndex(
    PTYPES_INFO pTypeInfo,
    PCHAR       Name,
    PUSHORT     NameLen
    )
{
    BSTR    wName= NULL;
    LPSTR   name = NULL;
    ULONG   SymTag;

#define CopyTypeName(n) if (*NameLen > strlen(n)) {strcpy(Name, n);}; *NameLen = strlen(n)+1;

    if (!pTypeInfo->TypeIndex) {
        return E_FAIL;
    }
    if (IsDbgNativeType(pTypeInfo->TypeIndex) &&
        NATIVE_TO_BT(pTypeInfo->TypeIndex)) {
        CopyTypeName(DbgNativeTypeEntry(pTypeInfo->TypeIndex)->TypeName);
        return S_OK;
    }

    if (!SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress,
                        pTypeInfo->TypeIndex, TI_GET_SYMTAG, (PVOID) &SymTag)) {
        return E_FAIL;
    }

    if (!SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress,
                        pTypeInfo->TypeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
        // vprintf("name not found\n");
    } else if (wName) {
        name = UnicodeToAnsi(wName);
        LocalFree(wName);
    }


    switch (SymTag) {
    case SymTagPointerType: {
        ULONG TI = pTypeInfo->TypeIndex;
        TYPES_INFO ChildTI = *pTypeInfo;

        if (SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress,
                           pTypeInfo->TypeIndex, TI_GET_TYPEID, (PVOID) &ChildTI.TypeIndex)) {

            *NameLen=*NameLen-1;
            if (GetNameFromIndex(&ChildTI, Name, NameLen) == S_OK) {
                strcat(Name, "*");
            }
            *NameLen=*NameLen+1;
        }
        pTypeInfo->TypeIndex = TI;
        break;
    }
    case SymTagArrayType: {
        ULONG TI = pTypeInfo->TypeIndex;
        TYPES_INFO ChildTI = *pTypeInfo;

        if (SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress,
                           pTypeInfo->TypeIndex, TI_GET_TYPEID, (PVOID) &ChildTI.TypeIndex)) {

            *NameLen=*NameLen-2;
            if (GetNameFromIndex(&ChildTI, Name, NameLen) == S_OK) {
                strcat(Name, "[]");
            }
            *NameLen=*NameLen+1;
        }
        pTypeInfo->TypeIndex = TI;
        break;
    }
    case SymTagBaseType: {
        //
        // Its a prim type
        //
        ULONG64 length = 0;
        ULONG   base;
        BOOL    found = FALSE;
        PDBG_NATIVE_TYPE Native;
        if (SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress,
                           pTypeInfo->TypeIndex, TI_GET_BASETYPE, (PVOID) &base)) {
            SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress,
                           pTypeInfo->TypeIndex, TI_GET_LENGTH, &length);
            Native = FindNativeTypeByCvBaseType(base, (ULONG)length);
            if (Native) {
                CopyTypeName(Native->TypeName);
                found = TRUE;
            }
            if (base == 0) {
                CopyTypeName("<NoType>");
                found = TRUE;
            }
        }
        if (!found) {
            CopyTypeName("<primitive>");
        }
        break;

    }
    case SymTagData: {
        ULONG TI = pTypeInfo->TypeIndex;
        TYPES_INFO ChildTI = *pTypeInfo;
        // A variable, TI_GET_SYMNAME just gives us variable name so get type index and fetch type name
        if (SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, TI, TI_GET_TYPEID, &ChildTI.TypeIndex)) {

            GetNameFromIndex(&ChildTI, Name, NameLen);
        }
        break;
    }
    case SymTagEnum: {
        // Enum type
        if (!(pTypeInfo->Flag & SYMFLAG_VALUEPRESENT) ||
            !GetEnumTypeName(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress,
                            pTypeInfo->TypeIndex, pTypeInfo->Value,
                            Name, NameLen)) {
            if (name) {
                CopyTypeName(name);
            }
        }
        break;
    }
    case SymTagFunctionArgType: {
        ULONG TI = pTypeInfo->TypeIndex;
        TYPES_INFO ChildTI = *pTypeInfo;
        // A variable, TI_GET_SYMNAME just gives us variable name so get type index and fetch type name
        if (SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, TI, TI_GET_TYPEID, &ChildTI.TypeIndex)) {

            GetNameFromIndex(&ChildTI, Name, NameLen);
        }
        break;
    }
    case SymTagFunctionType: {
        CopyTypeName("<function>");
        break;
    }
    default:
        if (name) {
            CopyTypeName(name);
        }
        break;
    }
#undef CopyTypeName

    if (name) {
        FreeMem(name);
    }
    return S_OK;
}

/******************************************************************************
* This gets the type-name for a TYPES_INFO struct
*
* This routine only needs one of pSymName or pTypeInfo to get the type name.
*
* If both are present, This will take TypeIndex from pTypeInfo and get its name.
*
******************************************************************************/
HRESULT
GetTypeName(
    IN OPTIONAL PCHAR       pSymName,
    IN OPTIONAL PTYPES_INFO pTypeInfo,
    OUT PANSI_STRING        TypeName
    )
{

    if ((!pTypeInfo && !pSymName) || !TypeName) {
        return E_INVALIDARG;
    }

    TYPES_INFO lTypeInfo;

    if (!pTypeInfo) {
        //
        // Get type info for symbol
        //
        SYM_DUMP_PARAM_EX TypedDump = {0};
        ULONG Status=0;
        TYPES_INFO_ALL allTypeInfo;

        if (GetExpressionTypeInfo(pSymName, &allTypeInfo)) {
            // Copy what we need
            lTypeInfo.Flag = allTypeInfo.Flags;
            lTypeInfo.hProcess = allTypeInfo.hProcess;
            lTypeInfo.ModBaseAddress = allTypeInfo.Module;
            lTypeInfo.TypeIndex      = allTypeInfo.TypeIndex;
            lTypeInfo.Value          = allTypeInfo.Value;
        }
#if 0
        TypedDump.size  = sizeof(SYM_DUMP_PARAM_EX);
        TypedDump.sName = (PUCHAR) TypeName->Buffer;
        TypedDump.Options = NO_PRINT;
        TypedDump.Context = NULL;
        lTypeInfo.Name.Buffer = &MatchedName[0];
        lTypeInfo.Name.Length = lTypeInfo.Name.MaximumLength = MAX_NAME;

        if (TypeInfoFound(g_Process->m_SymHandle,
                          g_Process->m_ImageHead,
                          &TypedDump,
                          &lTypeInfo)) {
            // FAIL
            return E_FAIL;
        }
#endif
        pTypeInfo = &lTypeInfo;

    }
    TypeName->Length = TypeName->MaximumLength;
    ZeroMemory(TypeName->Buffer, TypeName->MaximumLength);
    return GetNameFromIndex(pTypeInfo, TypeName->Buffer, &TypeName->Length);

}


ULONG
SymbolTypeDumpEx(
    IN HANDLE hProcess,
    IN ImageInfo* pImage,
    IN LPSTR lpArgString
    )
{
#define MAX_FIELDS                   10
    BYTE buff[sizeof(SYM_DUMP_PARAM_EX) + MAX_FIELDS*sizeof(FIELD_INFO_EX)] = {0};
    PSYM_DUMP_PARAM_EX dp= (PSYM_DUMP_PARAM_EX) &(buff[0]);
    FIELD_INFO_EX listLnk={0};
    UCHAR sName[2000]={0}, fieldNames[MAX_FIELDS * 257]={0}, listName[257]={0};
    int i;
    ULONG Options, ErrorStatus;

    exactMatch = TRUE;
    dp->Fields = (PFIELD_INFO_EX) &(buff[sizeof(SYM_DUMP_PARAM_EX)]);
    for (i=0; i<MAX_FIELDS; i++) {
        dp->Fields[i].fName = &fieldNames[i*257];
    }
    LastReadError = 0;

    listLnk.fName = &listName[0];
    dp->size = sizeof(buff);
    dp->sName = &sName[0];
    dp->listLink = &listLnk;
    dp->nFields = MAX_FIELDS;

    if (!ParseArgumentString(lpArgString, dp)) {
        exactMatch = TRUE;
        return FALSE;
    }
    if (!dp->sName[0] && !dp->addr) {
        exactMatch = TRUE;
        return FALSE;
    }
    Options = dp->Options;

    dp->size = sizeof(SYM_DUMP_PARAM_EX);

    if (strchr((PCHAR)dp->sName, '*') &&
        !strchr((PCHAR)dp->sName, ' ') &&
        strchr((PCHAR)dp->sName, '!')) {
        EnumerateTypes((PCHAR) dp->sName, Options);
        return TRUE;
    }

    if (0 & VERBOSE) {
        ANSI_STRING Name = {MAX_NAME, MAX_NAME, (PCHAR) &fieldNames[0]};
        GetTypeName((PCHAR) &sName[0], NULL, &Name);

        dprintf("GetTypeName %s := %s\n",sName, fieldNames);
        return 1;
    }
    if (! (i=SymbolTypeDumpNew(dp, &ErrorStatus))) {
        exactMatch = TRUE;
        switch (ErrorStatus) {

        case MEMORY_READ_ERROR:
            typPrint("Memory read error %p\n", LastReadError ? LastReadError : dp->addr);
            break;

        case SYMBOL_TYPE_INDEX_NOT_FOUND:
        case SYMBOL_TYPE_INFO_NOT_FOUND:
            // Look in other modules
            typPrint("Symbol %s not found.\n", dp->sName);
            break;

        case FIELDS_DID_NOT_MATCH:
            typPrint("Cannot find specified field members.\n");
            return FALSE;

        default:
            if (CheckUserInterrupt()) {
                typPrint("Exit on Control-C\n");
            } else
                typPrint("Error %x in dt\n", ErrorStatus);
        }
        return FALSE;
    }
    exactMatch = TRUE;
    if (CheckUserInterrupt()) {
        return FALSE;
    }
    return TRUE;
}

ULONG
fnFieldOffset(
    PCHAR Type,
    PCHAR Field,
    OUT PULONG Offset
    )
{
    SYM_DUMP_PARAM_EX SymDump = {0};
    FIELD_INFO_EX     fInfo = {0};
    ULONG          Status;

    if (!Type || !Field || !Offset) {
        return E_INVALIDARG;
    }
    SymDump.size    = sizeof (SYM_DUMP_PARAM_EX);
    SymDump.sName   = (PUCHAR) Type;
    SymDump.nFields = 1;
    SymDump.Fields  = &fInfo;
    SymDump.Options = NO_PRINT;

    fInfo.fName     = (PUCHAR) Field;
    fInfo.fOptions  = DBG_DUMP_FIELD_RETURN_ADDRESS;

    SymbolTypeDumpNew(&SymDump, &Status);

    *Offset = (ULONG) fInfo.address;

    return Status;
}

#if 0
ULONG
GetExpressiopnTypeInfo(
    IN PCSTR pTypeExpr,
    OUT PGET_ALL_INFO pTypeInfo
    )
{
    return FALSE;
}

ULONG
GetChildTypeInfo(
    IN PGET_ALL_INFO pParentInfo,
    IN ULONG Count,
    OUT PGET_ALL_INFO pChildInfo
    )
{
    return 0;
}

ULONG
OutputTypeValue(
    IN PGET_ALL_INFO pTypeInfo
    )
{
    return 0;
}

#endif // 0

/*
  Takes in a complex expression like foo[0]->bar or foo.bar and return foo in Name
  If Expr is just a symbol name eg mod!foo, the routine doesn't change Name, but returns TRUE

  Returns TRUE on success.
*/
BOOL
CopySymbolName(
    PCHAR Expr,
    PCHAR *Name)
{
    PCHAR NameEnd = Expr;

    if (*NameEnd == '&') {
       ++NameEnd;
    }
    if (IsIdStart(*NameEnd) || strchr(NameEnd, '!')) {
        BOOL Bang = TRUE;
        ++NameEnd;

        while (*NameEnd && (*NameEnd != '.' && *NameEnd != '-' && *NameEnd != ' ' && *NameEnd != '[')) {
            ++NameEnd;
        }

        if (*NameEnd == '[') {
            while (*NameEnd && *NameEnd != ']') ++NameEnd;
            if (*NameEnd != ']') {
                return FALSE;
            }
            ++NameEnd;
        }

        if (!*NameEnd) {
            return TRUE;
        }

    } else {
        return FALSE;
    }

    // arrays structs and pointers
    BOOL Ptr = FALSE;

    switch (*NameEnd) {
    case '-':
        if (*(NameEnd+1) != '>') {
            return FALSE;
        }
        Ptr = TRUE;
    case '.': {
        ULONG len;
        PCHAR SymName = (PCHAR) AllocateMem(1 + (len = (ULONG) (NameEnd - Expr)));

        if (!SymName) {
            return FALSE;
        }
        strncpy(SymName, Expr, len );
        SymName[len] = 0;
        *Name = SymName;
        return TRUE;
    }
    default:
        return FALSE;
    } /* switch */

    return FALSE;
}

/*
  Evaluate and return all the useful info about types for a complex expression

 eg. foo->bar.field

*/
BOOL
GetExpressionTypeInfo(
    IN PCHAR TypeExpr,
    OUT PTYPES_INFO_ALL pTypeInfo
    )
{
    PCHAR PtrRef=0;

    switch (*TypeExpr) {
    case '&':
        break;
    case '*':
        PtrRef = TypeExpr;
        do {
            ++TypeExpr;
        } while (*TypeExpr == '*');
        break;
    case '(':
    default:
        break;
    }

    PCHAR CopiedName=NULL, SymName, FieldName=NULL;

    if (!CopySymbolName(TypeExpr, &CopiedName))
        return FALSE;

    SymName = CopiedName ? CopiedName : TypeExpr;

    SYM_DUMP_PARAM_EX SymParam = {sizeof(SYM_DUMP_PARAM_EX),0,0};
    FIELD_INFO_EX     FieldInfo ={0};

    if (CopiedName) {
        FieldName = TypeExpr + strlen(CopiedName) + 1;
        if (*FieldName == '>') {
            // pointer
           ++FieldName;
        }

        SymParam.nFields = 1;
        SymParam.Fields  = &FieldInfo;

        FieldInfo.fName = (PUCHAR) FieldName;

        FieldInfo.fOptions = DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME;
    }

    SymParam.sName = (PUCHAR) (SymName ? SymName : TypeExpr);
    ULONG err;
    TYPES_INFO     SymType={0};
    CHAR           Buffer[MAX_NAME];

    SymParam.Options = NO_PRINT;
    SymType.Name.Buffer = &Buffer[0];
    SymType.Name.MaximumLength = MAX_NAME;

    if (!TypeInfoFound(g_Process->m_SymHandle, g_Process->m_ImageHead,
                      &SymParam, &SymType)) {
        FIND_TYPE_INFO FindInfo={0};
        ULONG i=0;

        while (PtrRef && (*PtrRef == '*' || *PtrRef == '&') && (i<sizeof(FindInfo.SymPrefix))) {
            FindInfo.SymPrefix[i++] = *PtrRef;
            PtrRef++;
        }
        FindInfo.SymPrefix[i] = 0;

        pTypeInfo->hProcess = SymType.hProcess;
        if (!SymParam.nFields) {
            pTypeInfo->Register = (ULONG) SymType.Value;
            pTypeInfo->Flags    = SymType.Flag;
        }

        FindInfo.Flags = SymParam.nFields ? 0 :DBG_RETURN_TYPE;
        FindInfo.nParams = 1;

        DumpTypeAndReturnInfo(&SymType, &SymParam, &err, &FindInfo);
        ZeroMemory(pTypeInfo, sizeof(*pTypeInfo));
        FindInfo.FullInfo.hProcess = SymType.hProcess;
        FindInfo.FullInfo.Module   = SymType.ModBaseAddress;


//        dprintf64("FindInfo\n\tTI %2lx,\tAddr %p, \tSize %2lx\n\tSubs %2lx,\tSubaddr %p\tMod %p\n",
//                  FindInfo.FullInfo.TypeIndex, FindInfo.FullInfo.Address,
//                  FindInfo.FullInfo.Size, FindInfo.FullInfo.SubElements,
//                  FindInfo.FullInfo.SubAddr, FindInfo.FullInfo.Module);
        if (!err) {
            *pTypeInfo = FindInfo.FullInfo;
        }
    } else {
        err = TRUE;
    }
    if (CopiedName) {
        FreeMem(CopiedName);
    }
    return !err;
}

typedef struct _PARAM_TO_SHOW {
    ULONG StartParam;
    ULONG ParamId;
} PARAM_TO_SHOW;

BOOL
CALLBACK
ShowParam(
    PSYMBOL_INFO    pSymInfo,
    ULONG           Size,
    PVOID           Context
    )
{
    PARAM_TO_SHOW *ParamTest = (PARAM_TO_SHOW *) Context;

    // Assume parameters are enumerated first
#if _WE_GET_INFO_FROM_DIA_SAYING_WHAT_IS_PARAM_
    if (!((g_EffMachine == IMAGE_FILE_MACHINE_I386) &&
          (0 <= (LONG) pSymInfo->Address) &&
          (0x1000 > (LONG) pSymInfo->Address) &&
          (pSymInfo->Flags & SYMFLAG_REGREL)) &&
        (!(pSymInfo->Flags & SYMFLAG_PARAMETER))
        ) {
        return TRUE;
    }
#endif

    if (!strcmp("this", pSymInfo->Name)) {
        // Its implicit parameter, do not display
        return TRUE;
    }
    if (ParamTest->StartParam == 0) {
        //
        // First parameter, adjust ebp value for FPO calls
        //
        if (g_ScopeBuffer.Frame.FuncTableEntry)
        {
            if (pSymInfo->Flags & SYMFLAG_REGREL)
            {
                // Params start after 2 dwords from farame offset
                SAVE_EBP(&g_ScopeBuffer.Frame) = ((ULONG) g_ScopeBuffer.Frame.FrameOffset + 2*sizeof(DWORD)
                                   - (ULONG)pSymInfo->Address) + 0xEB00000000; // EBP tag
            }
        }
    }
    if (ParamTest->ParamId == ParamTest->StartParam) {
        dprintf("%s = ", pSymInfo->Name);
        DumpSingleValue(pSymInfo);
        return FALSE;
    }
    ParamTest->StartParam++;
    return TRUE;
}

void
PrintParamValue(ULONG Param)
{
    PARAM_TO_SHOW ParamTest;

    ParamTest.StartParam = 0;
    ParamTest.ParamId = Param;
    EnumerateLocals(ShowParam, &ParamTest);
}


/*
   Check if the symbol is a function or not
 */
BOOL
IsFunctionSymbol(PSYMBOL_INFO pSymInfo)
{
    ULONG SymTag;

    if (!pSymInfo->TypeIndex) {
        return FALSE;
    }

    if (!SymGetTypeInfo(g_Process->m_SymHandle, pSymInfo->ModBase,
                       pSymInfo->TypeIndex, TI_GET_SYMTAG, &SymTag)) {
        return FALSE;
    }
    switch (SymTag) {
    case SymTagFunctionType: {
        return TRUE;
        break;
    }
    case SymTagData: {
        SYMBOL_INFO ChildTI = *pSymInfo;
        // A variable, get type index
        if (SymGetTypeInfo(g_Process->m_SymHandle, pSymInfo->ModBase, pSymInfo->TypeIndex, TI_GET_TYPEID, &ChildTI.TypeIndex)) {
            return IsFunctionSymbol(&ChildTI);
        }
        break;
    }
    default:
        break;
    }

    return FALSE;

}

BOOL
ShowSymbolInfo(
    PSYMBOL_INFO   pSymInfo
    )
{
    ULONG SymTag;

    if (!pSymInfo->TypeIndex) {
        return FALSE;
    }

    if (!SymGetTypeInfo(g_Process->m_SymHandle, pSymInfo->ModBase,
                       pSymInfo->TypeIndex, TI_GET_SYMTAG, &SymTag)) {
        return FALSE;
    }
    switch (SymTag) {
    case SymTagFunctionType: {
        SYM_DUMP_PARAM_EX SymFunction = {0};
        ULONG Status = 0;
        TYPES_INFO TypeInfo = {0};

        TypeInfo.hProcess = g_Process->m_SymHandle;
        TypeInfo.ModBaseAddress = pSymInfo->ModBase;
        TypeInfo.TypeIndex = pSymInfo->TypeIndex;
        TypeInfo.SymAddress = pSymInfo->Address;
        SymFunction.size = sizeof(SYM_DUMP_PARAM_EX);
        SymFunction.addr = pSymInfo->Address;
        SymFunction.Options = DBG_DUMP_COMPACT_OUT | DBG_DUMP_FUNCTION_FORMAT;
        if (!DumpType(&TypeInfo, &SymFunction, &Status) &&
            !Status) {
            return FALSE;
        }
#if 0
        ULONG thisAdjust;

        if (SymGetTypeInfo(g_Process->m_SymHandle, pSymInfo->ModBase,
                           pSymInfo->TypeIndex, TI_GET_THISADJUST, &thisAdjust)) {
            dprintf("thisadjust = %lx", thisAdjust);
        }
#endif
        return TRUE;
        break;
    }
    case SymTagData: {
        SYMBOL_INFO ChildTI = *pSymInfo;
        // A variable, TI_GET_SYMNAME just gives us variable name so get type index and fetch type name
        if (SymGetTypeInfo(g_Process->m_SymHandle, pSymInfo->ModBase, pSymInfo->TypeIndex, TI_GET_TYPEID, &ChildTI.TypeIndex)) {
            return ShowSymbolInfo(&ChildTI);
        }
        break;
    }
    default:
        break;
    }

    dprintf(" = ");
    return DumpSingleValue(pSymInfo);
}



ULONG
FieldCallBack(
    PFIELD_INFO pFieldInfo,
    PVOID Context
    )
{
    dprintf("Callback for %s, type id %lx, offset %lx, address %p\n",
            pFieldInfo->fName,
            pFieldInfo->TypeId,
            pFieldInfo->FieldOffset,
            pFieldInfo->address);
    return S_OK;
}


VOID
EnumerateFields(
    PCHAR Type
    )
{
    SYM_DUMP_PARAM Symbol;
    FIELD_INFO Fields[] = {
        {(PUCHAR) "__VFN_table", NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, (PVOID) &FieldCallBack},
        {(PUCHAR) "m_p",         NULL, 0,                        0, 0, (PVOID) &FieldCallBack},
    };
    ULONG ret;

    ZeroMemory(&Symbol, sizeof(Symbol));
    Symbol.sName = (PUCHAR) Type;
    Symbol.nFields = 2;
    Symbol.Context = (PVOID) Type;
    Symbol.Fields  = Fields;
    Symbol.size    = sizeof(Symbol);

    dprintf("Enumerate fields %s\n", Type);
    SymbolTypeDumpNew(&Symbol, &ret);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\target.hpp ===
//----------------------------------------------------------------------------
//
// Abstraction of target-specific information.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __TARGET_HPP__
#define __TARGET_HPP__

#define INVALID_PRODUCT_TYPE 0

#define SELECTOR_CACHE_LENGTH 6

typedef struct _SEL_CACHE_ENTRY
{
    struct _SEL_CACHE_ENTRY* Younger;
    struct _SEL_CACHE_ENTRY* Older;
    ULONG Processor;
    ULONG Selector;
    DESCRIPTOR64 Desc;
} SEL_CACHE_ENTRY;

//----------------------------------------------------------------------------
//
// Target configuration information.
//
//----------------------------------------------------------------------------

#define IS_KERNEL_TARGET(Target) \
    ((Target) && (Target)->m_Class == DEBUG_CLASS_KERNEL)
#define IS_USER_TARGET(Target) \
    ((Target) && (Target)->m_Class == DEBUG_CLASS_USER_WINDOWS)

#define IS_CONN_KERNEL_TARGET(Target) \
    (IS_KERNEL_TARGET(Target) && \
     (Target)->m_ClassQualifier == DEBUG_KERNEL_CONNECTION)

#define IS_LOCAL_KERNEL_TARGET(Target) \
    (IS_KERNEL_TARGET(Target) && \
     (Target)->m_ClassQualifier == DEBUG_KERNEL_LOCAL)

#define IS_EXDI_KERNEL_TARGET(Target) \
    (IS_KERNEL_TARGET(Target) && \
     (Target)->m_ClassQualifier == DEBUG_KERNEL_EXDI_DRIVER)

#define IS_LIVE_USER_TARGET(Target) \
    (IS_USER_TARGET(Target) && !IS_DUMP_TARGET(Target))

#define IS_LIVE_KERNEL_TARGET(Target) \
    (IS_KERNEL_TARGET(Target) && !IS_DUMP_TARGET(Target))

// Local kernels do not need caching.  Anything else does.
#define IS_REMOTE_KERNEL_TARGET(Target) \
    (IS_LIVE_KERNEL_TARGET(Target) && \
     (Target)->m_ClassQualifier != DEBUG_KERNEL_LOCAL)

#define IS_MACHINE_SET(Target) \
    ((Target) && (Target)->m_MachinesInitialized)

// Checks whether the debuggee is in a state where it
// can be examined.  This requires that the debuggee is known
// and paused so that its state is available.
#define IS_CUR_MACHINE_ACCESSIBLE() \
    (IS_MACHINE_SET(g_Target) && !IS_RUNNING(g_CmdState) && \
     g_Process && g_Thread && g_Machine)

// Further restricts the check to just context state as a
// local kernel session can examine memory and therefore is
// accessible but it does not have a context.
#define IS_CUR_CONTEXT_ACCESSIBLE() \
    (IS_CUR_MACHINE_ACCESSIBLE() && !IS_LOCAL_KERNEL_TARGET(g_Target))

// Event variable checks do not check g_CmdState as they
// may be used in the middle of initializing the regular state.
#define IS_EVENT_MACHINE_ACCESSIBLE() \
    (IS_MACHINE_SET(g_EventTarget) && \
     g_EventProcess && g_EventThread && g_EventMachine)
#define IS_EVENT_CONTEXT_ACCESSIBLE() \
    (IS_EVENT_MACHINE_ACCESSIBLE() && !IS_LOCAL_KERNEL_TARGET(g_EventTarget))

// Simpler context check for code which may be on the suspend/
// resume path and therefore may be in the middle of initializing
// the variables that IS_CONTEXT_ACCESSIBLE checks.  This
// macro just checks whether it's possible to get any
// context information.
#define IS_CONTEXT_POSSIBLE(Target) \
    ((Target) && !IS_LOCAL_KERNEL_TARGET(Target) && \
     (Target)->m_RegContextThread != NULL)

//
// System version is an internal abstraction of build numbers
// and product types.  The only requirement is that within
// a specific system family the numbers increase for newer
// systems.
//
// Most of the debugger code is built around NT system versions
// so there's a SystemVersion variable which is always an
// NT system version.  The ActualSystemVersion contains the
// true system version which gets mapped into a compatible NT
// system version for SystemVersion.
//

enum
{
    SVER_INVALID = 0,
    
    NT_SVER_START = 4 * 1024,
    NT_SVER_NT4,
    NT_SVER_W2K_RC3,
    NT_SVER_W2K,
    NT_SVER_XP,
    NT_SVER_NET_SERVER,
    NT_SVER_LONGHORN,
    NT_SVER_END,

    W9X_SVER_START = 8 * 1024,
    W9X_SVER_W95,
    W9X_SVER_W98,
    W9X_SVER_W98SE,
    W9X_SVER_WME,
    W9X_SVER_END,
    
    XBOX_SVER_START = 12 * 1024,
    XBOX_SVER_1,
    XBOX_SVER_END,

    BIG_SVER_START = 16 * 1024,
    BIG_SVER_1,
    BIG_SVER_END,

    EXDI_SVER_START = 20 * 1024,
    EXDI_SVER_1,
    EXDI_SVER_END,

    NTBD_SVER_START = 24 * 1024,
    NTBD_SVER_XP,
    NTBD_SVER_END,
    
    EFI_SVER_START = 28 * 1024,
    EFI_SVER_1,
    EFI_SVER_END,
    
    WCE_SVER_START = 32 * 1024,
    WCE_SVER_CE,
    WCE_SVER_END,
};

//----------------------------------------------------------------------------
//
// Macros for using the implicit target/system/process/thread/machine
// globals in common target calls.
//
//----------------------------------------------------------------------------

#define CurReadVirtual(Offset, Buffer, BufferSize, Read) \
    g_Target->ReadVirtual(g_Process, Offset, Buffer, BufferSize, Read)
#define CurReadAllVirtual(Offset, Buffer, BufferSize) \
    g_Target->ReadAllVirtual(g_Process, Offset, Buffer, BufferSize)

//----------------------------------------------------------------------------
//
// This class abstracts processing of target-class-dependent
// information.  g_Target is set to the appropriate implementation
// once the class of target is known.
//
// In theory a single TargetInfo could handle multiple systems
// if the systems are all similar.  For example, a single user-mode
// TargetInfo could be used for multiple user-mode systems
// if there was a separate list of systems.  This doesn't
// enable any functionality, though, and adds significant
// complexity as now a separate list has to be maintained and
// more information has to be passed around to identify both
// system and target.  Instead a TargetInfo is created per
// system and the TargetInfo has both the role of abstracting
// manipulation of the debuggee and keeping global information
// about the debuggee.
//
//----------------------------------------------------------------------------

// Hard-coded type information for machine and platform version.
typedef struct _SYSTEM_TYPE_INFO
{
    ULONG64 TriagePrcbOffset;
    // Size of the native context for the target machine.
    ULONG SizeTargetContext;
    // Offset of the flags ULONG in the native context.
    ULONG OffsetTargetContextFlags;
    // Control space offset for special registers.
    ULONG OffsetSpecialRegisters;
    ULONG SizeControlReport;
    ULONG SizeKspecialRegisters;
    // Size of the debugger's *_THREAD partial structure.
    ULONG SizePageFrameNumber;
    ULONG SizePte;
    ULONG64 SharedUserDataOffset;
    ULONG64 UmSharedUserDataOffset;
    ULONG64 UmSharedSysCallOffset;
    ULONG UmSharedSysCallSize;
    ULONG SizeDynamicFunctionTable;
    ULONG SizeRuntimeFunction;
} SYSTEM_TYPE_INFO, *PSYSTEM_TYPE_INFO;

enum WAIT_INIT_TYPE
{
    WINIT_FIRST,
    WINIT_NOT_FIRST,
    WINIT_TEST
};

class TargetInfo
{
public:
    TargetInfo(ULONG Class, ULONG Qual, BOOL DynamicEvents);
    virtual ~TargetInfo(void);

    ULONG m_Class;
    ULONG m_ClassQualifier;
    TargetInfo* m_Next;

    void Link(void);
    void Unlink(void);

    //
    // Event information.
    //
    
    ULONG m_NumEvents;
    ULONG m_EventIndex;
    ULONG m_NextEventIndex;

    ULONG m_FirstWait:1;
    ULONG m_EventPossible:1;
    ULONG m_DynamicEvents:1;
    ULONG m_BreakInMessage:1;
    
    ULONG m_WaitTimeBase;

    //
    // Debuggee global information.
    //

    ULONG m_NumProcesses;
    ProcessInfo* m_ProcessHead;
    ProcessInfo* m_CurrentProcess;
    ULONG m_AllProcessFlags;
    ULONG m_TotalNumberThreads;
    ULONG m_MaxThreadsInProcess;
    
    ULONG m_UserId;
    ULONG m_SystemId;
    ULONG m_Exited:1;
    ULONG m_DeferContinueEvent:1;
    ULONG m_BreakInTimeout:1;
    ULONG m_Notify:1;
    ULONG m_ProcessesAdded:1;

    SYSTEM_TYPE_INFO m_TypeInfo;
    
    ULONG m_SystemVersion;
    ULONG m_ActualSystemVersion;
    ULONG m_BuildNumber;
    ULONG m_CheckedBuild;
    ULONG m_PlatformId;
    char m_ServicePackString[MAX_PATH];
    ULONG m_ServicePackNumber;
    char m_BuildLabName[272];
    ULONG m_ProductType;
    ULONG m_SuiteMask;

    ULONG m_NumProcessors;
    ULONG m_MachineType;
    // Leave one extra slot at the end so indexing
    // MACHIDX_COUNT returns NULL for the undefined case.
    MachineInfo* m_Machines[MACHIDX_COUNT + 1];
    MachineInfo* m_Machine;
    ULONG m_EffMachineType;
    MachineIndex m_EffMachineIndex;
    MachineInfo* m_EffMachine;
    DEBUG_PROCESSOR_IDENTIFICATION_ALL m_FirstProcessorId;
    BOOL m_MachinesInitialized;
    
    ThreadInfo* m_RegContextThread;
    ULONG m_RegContextProcessor;

    ULONG64 m_SystemRangeStart;
    ULONG64 m_SystemCallVirtualAddress;

    KDDEBUGGER_DATA64 m_KdDebuggerData;
    DBGKD_GET_VERSION64 m_KdVersion;
    ULONG64 m_KdDebuggerDataOffset;
    BOOL m_KdApi64;

    PhysicalMemoryCache m_PhysicalCache;

    PSTR m_ExtensionSearchPath;
    
    ULONG64 m_ImplicitProcessData;
    BOOL m_ImplicitProcessDataIsDefault;
    ThreadInfo* m_ImplicitProcessDataThread;

    virtual void ResetSystemInfo(void);
    virtual void DeleteSystemInfo(void);
               
    HRESULT ReadKdDataBlock(ProcessInfo* Process);
    HRESULT QueryKernelInfo(ThreadInfo* Thread, BOOL LoadImage);
    void SetNtCsdVersion(ULONG Build, ULONG CsdVersion);
    void SetKernel32BuildString(ProcessInfo* Process);
    HRESULT CreateVirtualProcess(ULONG Threads);
    
    ProcessInfo* FindProcessByUserId(ULONG Id);
    ProcessInfo* FindProcessBySystemId(ULONG Id);
    ProcessInfo* FindProcessByHandle(ULONG64 Handle);
    
    void InsertProcess(ProcessInfo* Process);
    void RemoveProcess(ProcessInfo* Process);
    void ResetAllProcessInfo(void);
    void AddThreadToAllProcessInfo(ProcessInfo* Process,
                                   ThreadInfo* Thread);
    void RemoveThreadFromAllProcessInfo(ProcessInfo* Process,
                                        ThreadInfo* Thread)
    {
        UNREFERENCED_PARAMETER(Process);
        UNREFERENCED_PARAMETER(Thread);
        ResetAllProcessInfo();
    }

    BOOL DeleteExitedInfos(void);

    void InvalidateMemoryCaches(BOOL VirtOnly);

    void SetSystemVersionAndBuild(ULONG Build, ULONG PlatformId);

    HRESULT InitializeForProcessor(void);
    HRESULT InitializeMachines(ULONG MachineType);
    void SetEffMachine(ULONG Machine, BOOL Notify);
    void ChangeRegContext(ThreadInfo* Thread);
    void FlushRegContext(void);

    BOOL AnySystemProcesses(BOOL LocalOnly);

    void OutputProcessesAndThreads(PSTR Title);
    void OutputProcessInfo(ProcessInfo* Match);
    void OutputVersion(void);
    void OutputTime(void);

    void AddSpecificExtensions(void);

    void PrepareForExecution(void);
    
    //
    // Pure abstraction methods.
    // Unless otherwise indicated, base implementations give
    // an error message and return E_UNEXPECTED.
    //

    // Base implementation must be called.
    virtual HRESULT Initialize(void);

    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen) = 0;
    
    // Called when a debuggee has reset but the session is
    // still active, such as a reboot during kernel debugging.
    virtual void DebuggeeReset(ULONG Reason, BOOL FromEvent);
    
    // Determines the next byte offset and next page offset
    // that might have different validity than the given offset.
    virtual void NearestDifferentlyValidOffsets(ULONG64 Offset,
                                                PULONG64 NextOffset,
                                                PULONG64 NextPage);
    
    virtual HRESULT ReadVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    // Base implementation layers on ReadVirtual.
    virtual HRESULT SearchVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        IN ULONG PatternGranularity,
        OUT PULONG64 MatchOffset
        );
    // Base implementations just call Read/WriteVirtual.
    virtual HRESULT ReadVirtualUncached(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtualUncached(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadPhysical(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysical(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesWritten
        );
    // Base implementation layers on ReadPhysical.
    virtual HRESULT PointerSearchPhysical(
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN ULONG64 PointerMin,
        IN ULONG64 PointerMax,
        IN ULONG Flags,
        OUT PULONG64 MatchOffsets,
        IN ULONG MatchOffsetsSize,
        OUT PULONG MatchOffsetsCount
        );
    // Base implementations just call Read/WritePhysical.
    virtual HRESULT ReadPhysicalUncached(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysicalUncached(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadMsr(
        IN ULONG Msr,
        OUT PULONG64 Value
        );
    virtual HRESULT WriteMsr(
        IN ULONG Msr,
        IN ULONG64 Value
        );
    virtual HRESULT ReadBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT GetProcessorSystemDataOffset(
        IN ULONG Processor,
        IN ULONG Index,
        OUT PULONG64 Offset
        );
    virtual HRESULT CheckLowMemory(
        );
    virtual HRESULT ReadHandleData(
        IN ProcessInfo* Process,
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        );
    // Base implementations layer on WriteVirtual/Physical.
    virtual HRESULT FillVirtual(
        THIS_
        IN ProcessInfo* Process,
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT PULONG Filled
        );
    virtual HRESULT FillPhysical(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT PULONG Filled
        );
    virtual HRESULT GetProcessorId(
        ULONG Processor,
        PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id
        );
    virtual HRESULT GetProcessorSpeed(
        ULONG Processor,
        PULONG Speed
        );
    virtual HRESULT GetGenericProcessorFeatures(
        ULONG Processor,
        PULONG64 Features,
        ULONG FeaturesSize,
        PULONG Used
        );
    virtual HRESULT GetSpecificProcessorFeatures(
        ULONG Processor,
        PULONG64 Features,
        ULONG FeaturesSize,
        PULONG Used
        );
    // Generic calling code assumes that tagged data can
    // be represented by a linear space with an overall
    // DUMP_BLOB_FILE_HEADER at the base offset and followed
    // by all existing blob headers and their data.
    // Base implementations fail.
    virtual HRESULT GetTaggedBaseOffset(PULONG64 Offset);
    virtual HRESULT ReadTagged(ULONG64 Offset, PVOID Buffer, ULONG BufferSize);
    
    // Base implementation silently fails as many targets do
    // not support this.
    virtual HRESULT ReadPageFile(ULONG PfIndex, ULONG64 PfOffset,
                                 PVOID Buffer, ULONG Size);

    virtual HRESULT GetUnloadedModuleListHead(ProcessInfo* Process,
                                              PULONG64 Head);

    virtual HRESULT GetFunctionTableListHead(ProcessInfo* Process,
                                             PULONG64 Head);
    virtual PVOID FindDynamicFunctionEntry(ProcessInfo* Process,
                                           ULONG64 Address);
    virtual ULONG64 GetDynamicFunctionTableBase(ProcessInfo* Process,
                                                ULONG64 Address);
    virtual HRESULT ReadOutOfProcessDynamicFunctionTable(ProcessInfo* Process,
                                                         PWSTR Dll,
                                                         ULONG64 Table,
                                                         PULONG TableSize,
                                                         PVOID* TableData);
    static PVOID CALLBACK DynamicFunctionTableCallback(HANDLE Process,
                                                       ULONG64 Address,
                                                       ULONG64 Context);
    virtual HRESULT EnumFunctionTables(IN ProcessInfo* Process,
                                       IN OUT PULONG64 Start,
                                       IN OUT PULONG64 Handle,
                                       OUT PULONG64 MinAddress,
                                       OUT PULONG64 MaxAddress,
                                       OUT PULONG64 BaseAddress,
                                       OUT PULONG EntryCount,
                                       OUT PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable,
                                       OUT PVOID* RawEntries);

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT SetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    // Retrieves segment register descriptors if they are available
    // directly.  Invalid descriptors may be returned, indicating
    // either segment registers aren't supported or that the
    // descriptors must be looked up in descriptor tables.
    // Base implementation returns invalid descriptors.
    virtual HRESULT GetTargetSegRegDescriptors(ULONG64 Thread,
                                               ULONG Start, ULONG Count,
                                               PDESCRIPTOR64 Descs);
    // Base implementations call Read/WriteSpecialRegisters.
    virtual HRESULT GetTargetSpecialRegisters
        (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    virtual HRESULT SetTargetSpecialRegisters
        (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    // Called when the current context state is being
    // discarded so that caches can be flushed.
    // Base implementation does nothing.
    virtual void InvalidateTargetContext(void);

    virtual HRESULT GetThreadIdByProcessor(
        IN ULONG Processor,
        OUT PULONG Id
        );
    virtual HRESULT GetThreadStartOffset(ThreadInfo* Thread,
                                         PULONG64 StartOffset);
    // Base implementations do nothing.
    virtual void SuspendThreads(void);
    virtual BOOL ResumeThreads(void);
    
    // This method takes both a ThreadInfo* and a "handle"
    // to make things simpler for the kernel thread-to-processor
    // mapping.  If Thread is NULL processor must be a processor
    // index in kernel mode or a thread handle in user mode.
    virtual HRESULT GetThreadInfoDataOffset(ThreadInfo* Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset);
    // In theory this method should take a ProcessInfo*.
    // Due to the current kernel process and thread structure
    // where there's only a kernel process and threads per
    // processor such a call would be useless in kernel mode.
    // Instead it allows you to either get the process data
    // for a thread of that process or get the process data
    // from a thread data.
    virtual HRESULT GetProcessInfoDataOffset(ThreadInfo* Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset);
    virtual HRESULT GetThreadInfoTeb(ThreadInfo* Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset);
    virtual HRESULT GetProcessInfoPeb(ThreadInfo* Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset);

    // This is on target rather than machine since it has
    // both user and kernel variations and the implementations
    // don't have much processor-specific code in them.
    virtual HRESULT GetSelDescriptor(ThreadInfo* Thread,
                                     MachineInfo* Machine,
                                     ULONG Selector,
                                     PDESCRIPTOR64 Desc);

    virtual HRESULT SwitchProcessors(ULONG Processor);
    virtual HRESULT SwitchToTarget(TargetInfo* From);
    
    virtual HRESULT GetTargetKdVersion(PDBGKD_GET_VERSION64 Version);
    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    virtual ModuleInfo* GetModuleInfo(BOOL UserMode);
    virtual UnloadedModuleInfo* GetUnloadedModuleInfo(void);
    // Image can be identified either by its path or base address.
    virtual HRESULT GetImageVersionInformation(ProcessInfo* Process,
                                               PCSTR ImagePath,
                                               ULONG64 ImageBase,
                                               PCSTR Item,
                                               PVOID Buffer, ULONG BufferSize,
                                               PULONG VerInfoSize);
    HRESULT Reload(ThreadInfo* Thread,
                   PCSTR Args, PCSTR* ArgsRet);

    virtual HRESULT GetExceptionContext(PCROSS_PLATFORM_CONTEXT Context);
    virtual ULONG64 GetCurrentTimeDateN(void);
    virtual ULONG64 GetCurrentSystemUpTimeN(void);
    virtual ULONG64 GetProcessUpTimeN(ProcessInfo* Process);
    virtual HRESULT GetProcessTimes(ProcessInfo* Process,
                                    PULONG64 Create,
                                    PULONG64 Exit,
                                    PULONG64 Kernel,
                                    PULONG64 User);
    virtual HRESULT GetThreadTimes(ThreadInfo* Thread,
                                   PULONG64 Create,
                                   PULONG64 Exit,
                                   PULONG64 Kernel,
                                   PULONG64 User);
    virtual HRESULT GetProductInfo(PULONG ProductType, PULONG SuiteMask);

    // Base implementation does nothing.
    virtual HRESULT InitializeTargetControlledStepping(void);
    virtual void InitializeWatchTrace(void);
    virtual void ProcessWatchTraceEvent(PDBGKD_TRACE_DATA TraceData,
                                        PADDR PcAddr,
                                        PBOOL StepOver);

    // Base implementation returns defaults.
    virtual HRESULT GetEventIndexDescription(IN ULONG Index,
                                             IN ULONG Which,
                                             IN OPTIONAL PSTR Buffer,
                                             IN ULONG BufferSize,
                                             OUT OPTIONAL PULONG DescSize);
    virtual HRESULT WaitInitialize(ULONG Flags,
                                   ULONG Timeout,
                                   WAIT_INIT_TYPE Type,
                                   PULONG DesiredTimeout);
    virtual HRESULT ReleaseLastEvent(ULONG ContinueStatus);
    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout,
                                 ULONG ElapsedTime, PULONG EventStatus);
    
    virtual HRESULT RequestBreakIn(void);
    virtual HRESULT ClearBreakIn(void);
    virtual HRESULT Reboot(void);
    virtual HRESULT Crash(ULONG Code);

    virtual HRESULT BeginInsertingBreakpoints(void);
    virtual HRESULT InsertCodeBreakpoint(ProcessInfo* Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG InstrFlags,
                                         PUCHAR StorageSpace);
    virtual HRESULT InsertDataBreakpoint(ProcessInfo* Process,
                                         ThreadInfo* Thread,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG Size,
                                         ULONG AccessType,
                                         PUCHAR StorageSpace);
    virtual void EndInsertingBreakpoints(void);
    virtual void BeginRemovingBreakpoints(void);
    virtual HRESULT RemoveCodeBreakpoint(ProcessInfo* Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG InstrFlags,
                                         PUCHAR StorageSpace);
    virtual HRESULT RemoveDataBreakpoint(ProcessInfo* Process,
                                         ThreadInfo* Thread,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG Size,
                                         ULONG AccessType,
                                         PUCHAR StorageSpace);
    virtual void EndRemovingBreakpoints(void);
    virtual HRESULT RemoveAllDataBreakpoints(ProcessInfo* Process);
    // Base implementation does nothing.
    virtual HRESULT RemoveAllTargetBreakpoints(void);
    virtual HRESULT IsDataBreakpointHit(ThreadInfo* Thread,
                                        PADDR Addr,
                                        ULONG Size,
                                        ULONG AccessType,
                                        PUCHAR StorageSpace);
    virtual HRESULT InsertTargetCountBreakpoint(PADDR Addr,
                                                ULONG Flags);
    virtual HRESULT RemoveTargetCountBreakpoint(PADDR Addr);
    virtual HRESULT QueryTargetCountBreakpoint(PADDR Addr,
                                               PULONG Flags,
                                               PULONG Calls,
                                               PULONG MinInstr,
                                               PULONG MaxInstr,
                                               PULONG TotInstr,
                                               PULONG MaxCps);

    // Returns information similar to VirtualQueryEx for
    // user-mode targets.  Used when writing dump files.
    virtual HRESULT QueryMemoryRegion(ProcessInfo* Process,
                                      PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);
    // Returns information about the kind of memory the
    // given address refers to.
    // Base implementation returns rwx with process for
    // user-mode and kernel for kernel mode.  In other words,
    // the least restrictive settings.
    virtual HRESULT QueryAddressInformation(ProcessInfo* Process,
                                            ULONG64 Address, ULONG InSpace,
                                            PULONG OutSpace, PULONG OutFlags);

    // Base implementations fail.
    virtual HRESULT StartAttachProcess(ULONG ProcessId,
                                       ULONG AttachFlags,
                                       PPENDING_PROCESS* Pending);
    virtual HRESULT StartCreateProcess(PWSTR CommandLine,
                                       ULONG CreateFlags,
                                       PBOOL InheritHandles,
                                       PWSTR CurrentDir,
                                       PPENDING_PROCESS* Pending);
    virtual HRESULT TerminateProcesses(void);
    virtual HRESULT DetachProcesses(void);
    
    //
    // Layered methods.  These are usually common code that
    // use pure methods to do their work.
    //

    HRESULT ReadAllVirtual(ProcessInfo* Process,
                           ULONG64 Address, PVOID Buffer, ULONG BufferSize)
    {
        HRESULT Status;
        ULONG Done;

        if ((Status = ReadVirtual(Process,
                                  Address, Buffer, BufferSize, &Done)) == S_OK
            && Done != BufferSize)
        {
            Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
        }
        return Status;
    }
    HRESULT WriteAllVirtual(ProcessInfo* Process,
                            ULONG64 Address, PVOID Buffer, ULONG BufferSize)
    {
        HRESULT Status;
        ULONG Done;

        if ((Status = WriteVirtual(Process,
                                   Address, Buffer, BufferSize, &Done)) == S_OK
            && Done != BufferSize)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
        }
        return Status;
    }

    HRESULT ReadAllPhysical(ULONG64 Address, PVOID Buffer, ULONG BufferSize)
    {
        HRESULT Status;
        ULONG Done;

        if ((Status = ReadPhysical(Address, Buffer, BufferSize,
                                   PHYS_FLAG_DEFAULT, &Done)) == S_OK
            && Done != BufferSize)
        {
            Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
        }
        return Status;
    }
    HRESULT WriteAllPhysical(ULONG64 Address, PVOID Buffer, ULONG BufferSize)
    {
        HRESULT Status;
        ULONG Done;

        if ((Status = WritePhysical(Address, Buffer, BufferSize,
                                    PHYS_FLAG_DEFAULT, &Done)) == S_OK
            && Done != BufferSize)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
        }
        return Status;
    }

    HRESULT ReadPointer(ProcessInfo* Process, MachineInfo* Machine,
                        ULONG64 Address, PULONG64 PointerValue);
    HRESULT WritePointer(ProcessInfo* Process, MachineInfo* Machine,
                         ULONG64 Address, ULONG64 PointerValue);
    HRESULT ReadListEntry(ProcessInfo* Process, MachineInfo* Machine,
                          ULONG64 Address, PLIST_ENTRY64 List);
    HRESULT ReadLoaderEntry(ProcessInfo* Process, MachineInfo* Machine,
                            ULONG64 Address, PKLDR_DATA_TABLE_ENTRY64 Entry);
    HRESULT ReadUnicodeString(ProcessInfo* Process, MachineInfo* Machine,
                              ULONG64 Address, PUNICODE_STRING64 String);
    
    HRESULT ReadImageVersionInfo(ProcessInfo* Process,
                                 ULONG64 ImageBase,
                                 PCSTR Item,
                                 PVOID Buffer,
                                 ULONG BufferSize,
                                 PULONG VerInfoSize,
                                 PIMAGE_DATA_DIRECTORY ResDataDir);
    HRESULT ReadImageNtHeaders(ProcessInfo* Process,
                               ULONG64 ImageBase,
                               PIMAGE_NT_HEADERS64 Headers);

    HRESULT ReadDirectoryTableBase(PULONG64 DirBase);

    HRESULT ReadSharedUserTimeDateN(PULONG64 TimeDate);
    HRESULT ReadSharedUserUpTimeN(PULONG64 UpTime);
    HRESULT ReadSharedUserProductInfo(PULONG ProductType, PULONG SuiteMask);

    // Internal routines which provide canonical context input
    // and output, applying any necessary conversions before
    // or after calling Get/SetTargetContext.
    HRESULT GetContext(
        ULONG64 Thread,
        PCROSS_PLATFORM_CONTEXT Context
        );
    HRESULT SetContext(
        ULONG64 Thread,
        PCROSS_PLATFORM_CONTEXT Context
        );

    HRESULT GetContextFromThreadStack(ULONG64 ThreadBase,
                                      PCROSS_PLATFORM_CONTEXT Context,
                                      BOOL Verbose);

    HRESULT EmulateNtX86SelDescriptor(ThreadInfo* Thread,
                                      MachineInfo* Machine,
                                      ULONG Selector,
                                      PDESCRIPTOR64 Desc);
    HRESULT EmulateNtAmd64SelDescriptor(ThreadInfo* Thread,
                                        MachineInfo* Machine,
                                        ULONG Selector,
                                        PDESCRIPTOR64 Desc);
    HRESULT EmulateNtSelDescriptor(ThreadInfo* Thread,
                                   MachineInfo* Machine,
                                   ULONG Selector,
                                   PDESCRIPTOR64 Desc);
    
    void ResetImplicitData(void)
    {
        m_ImplicitProcessData = 0;
        m_ImplicitProcessDataIsDefault = TRUE;
        m_ImplicitProcessDataThread = NULL;
    }
    
    HRESULT GetImplicitProcessData(ThreadInfo* Thread, PULONG64 Offset);
    HRESULT GetImplicitProcessDataPeb(ThreadInfo* Thread, PULONG64 Offset);
    HRESULT GetImplicitProcessDataParentCID(ThreadInfo* Thread, PULONG64 Pcid);
    HRESULT SetImplicitProcessData(ThreadInfo* Thread,
                                   ULONG64 Offset, BOOL Verbose);
    HRESULT ReadImplicitProcessInfoPointer(ThreadInfo* Thread,
                                           ULONG Offset, PULONG64 Ptr);

    // Internal implementations based on user or kernel
    // registers and data.  Placed here for sharing between
    // live and dump sessions rather than using multiple
    // inheritance.
    
    HRESULT KdGetThreadInfoDataOffset(ThreadInfo* Thread,
                                      ULONG64 ThreadHandle,
                                      PULONG64 Offset);
    HRESULT KdGetProcessInfoDataOffset(ThreadInfo* Thread,
                                       ULONG Processor,
                                       ULONG64 ThreadData,
                                       PULONG64 Offset);
    HRESULT KdGetThreadInfoTeb(ThreadInfo* Thread,
                               ULONG Processor,
                               ULONG64 ThreadData,
                               PULONG64 Offset);
    HRESULT KdGetProcessInfoPeb(ThreadInfo* Thread,
                                ULONG Processor,
                                ULONG64 ThreadData,
                                PULONG64 Offset);
    HRESULT KdGetSelDescriptor(ThreadInfo* Thread,
                               MachineInfo* Machine,
                               ULONG Selector,
                               PDESCRIPTOR64 Desc);

    void FlushSelectorCache(void);
    BOOL FindSelector(ULONG Processor, ULONG Selector,
                      PDESCRIPTOR64 Desc);
    void PutSelector(ULONG Processor, ULONG Selector,
                     PDESCRIPTOR64 Desc);

    // This selector cache is only used for kernel targets
    // but it's here on TargetInfo so that the kernel dump
    // targets inherit it.
    SEL_CACHE_ENTRY m_SelectorCache[SELECTOR_CACHE_LENGTH];
    SEL_CACHE_ENTRY* m_YoungestSel;
    SEL_CACHE_ENTRY* m_OldestSel;
};

//----------------------------------------------------------------------------
//
// LiveKernelTargetInfo.
//
//----------------------------------------------------------------------------

class LiveKernelTargetInfo : public TargetInfo
{
public:
    LiveKernelTargetInfo(ULONG Qual, BOOL DynamicEvents);
    
    // TargetInfo.
    
    virtual void ResetSystemInfo(void);

    virtual HRESULT GetProcessorId(
        ULONG Processor,
        PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id
        );
    virtual HRESULT GetProcessorSpeed(
        ULONG Processor,
        PULONG Speed
        );

    virtual HRESULT GetThreadIdByProcessor(
        IN ULONG Processor,
        OUT PULONG Id
        );
    virtual HRESULT GetThreadInfoDataOffset(ThreadInfo* Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset);
    virtual HRESULT GetProcessInfoDataOffset(ThreadInfo* Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset);
    virtual HRESULT GetThreadInfoTeb(ThreadInfo* Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset);
    virtual HRESULT GetProcessInfoPeb(ThreadInfo* Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset);

    virtual HRESULT GetSelDescriptor(ThreadInfo* Thread,
                                     MachineInfo* Machine,
                                     ULONG Selector,
                                     PDESCRIPTOR64 Desc);
    
    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);

    virtual ULONG64 GetCurrentTimeDateN(void);
    virtual ULONG64 GetCurrentSystemUpTimeN(void);
    
    // LiveKernelTargetInfo.

    HRESULT InitFromKdVersion(void);

    // Options are only valid in Initialize.
    PCSTR m_ConnectOptions;

    ULONG m_KdMaxPacketType;
    ULONG m_KdMaxStateChange;
    ULONG m_KdMaxManipulate;
};

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo.
//
//----------------------------------------------------------------------------

class ConnLiveKernelTargetInfo : public LiveKernelTargetInfo
{
public:
    ConnLiveKernelTargetInfo(void);
    virtual ~ConnLiveKernelTargetInfo(void);
    
    // TargetInfo.

    virtual void ResetSystemInfo(void);

    virtual HRESULT Initialize(void);
    
    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual void DebuggeeReset(ULONG Reason, BOOL FromEvent);
    
    virtual HRESULT ReadVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT SearchVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        IN ULONG PatternGranularity,
        OUT PULONG64 MatchOffset
        );
    virtual HRESULT ReadVirtualUncached(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtualUncached(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadPhysical(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysical(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT PointerSearchPhysical(
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN ULONG64 PointerMin,
        IN ULONG64 PointerMax,
        IN ULONG Flags,
        OUT PULONG64 MatchOffsets,
        IN ULONG MatchOffsetsSize,
        OUT PULONG MatchOffsetsCount
        );
    virtual HRESULT ReadPhysicalUncached(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysicalUncached(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadMsr(
        IN ULONG Msr,
        OUT PULONG64 Value
        );
    virtual HRESULT WriteMsr(
        IN ULONG Msr,
        IN ULONG64 Value
        );
    virtual HRESULT ReadBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT CheckLowMemory(
        );
    virtual HRESULT FillVirtual(
        THIS_
        IN ProcessInfo* Process,
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT PULONG Filled
        );
    virtual HRESULT FillPhysical(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT PULONG Filled
        );

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT SetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual HRESULT SwitchProcessors(ULONG Processor);
    virtual HRESULT SwitchToTarget(TargetInfo* From);
    
    virtual HRESULT GetTargetKdVersion(PDBGKD_GET_VERSION64 Version);

    virtual HRESULT InitializeTargetControlledStepping(void);
    virtual void InitializeWatchTrace(void);
    virtual void ProcessWatchTraceEvent(PDBGKD_TRACE_DATA TraceData,
                                        PADDR PcAddr,
                                        PBOOL StepOver);
    
    virtual HRESULT WaitInitialize(ULONG Flags,
                                   ULONG Timeout,
                                   WAIT_INIT_TYPE Type,
                                   PULONG DesiredTimeout);
    virtual HRESULT ReleaseLastEvent(ULONG ContinueStatus);
    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout,
                                 ULONG ElapsedTime, PULONG EventStatus);

    virtual HRESULT RequestBreakIn(void);
    virtual HRESULT ClearBreakIn(void);
    virtual HRESULT Reboot(void);
    virtual HRESULT Crash(ULONG Code);

    virtual HRESULT InsertCodeBreakpoint(ProcessInfo* Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG InstrFlags,
                                         PUCHAR StorageSpace);
    virtual HRESULT RemoveCodeBreakpoint(ProcessInfo* Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG InstrFlags,
                                         PUCHAR StorageSpace);
    virtual HRESULT RemoveAllDataBreakpoints(ProcessInfo* Process);
    virtual HRESULT RemoveAllTargetBreakpoints(void);
    virtual HRESULT InsertTargetCountBreakpoint(PADDR Addr,
                                                ULONG Flags);
    virtual HRESULT RemoveTargetCountBreakpoint(PADDR Addr);
    virtual HRESULT QueryTargetCountBreakpoint(PADDR Addr,
                                               PULONG Flags,
                                               PULONG Calls,
                                               PULONG MinInstr,
                                               PULONG MaxInstr,
                                               PULONG TotInstr,
                                               PULONG MaxCps);

    virtual HRESULT QueryAddressInformation(ProcessInfo* Process,
                                            ULONG64 Address, ULONG InSpace,
                                            PULONG OutSpace, PULONG OutFlags);

    // ConnLiveKernelTargetInfo.
    
    NTSTATUS WaitStateChange(OUT PDBGKD_ANY_WAIT_STATE_CHANGE StateChange,
                             OUT PVOID Buffer,
                             IN ULONG BufferLength,
                             IN BOOL SuspendEngine);
    ULONG ProcessStateChange(PDBGKD_ANY_WAIT_STATE_CHANGE StateChange,
                             PCHAR StateChangeData);

    NTSTATUS KdContinue(ULONG ContinueStatus,
                        PDBGKD_ANY_CONTROL_SET ControlSet);
    NTSTATUS KdRestoreBreakPoint(ULONG BreakPointHandle);
    NTSTATUS KdFillMemory(IN ULONG Flags,
                          IN ULONG64 Start,
                          IN ULONG Size,
                          IN PVOID Pattern,
                          IN ULONG PatternSize,
                          OUT PULONG Filled);
    NTSTATUS KdReadVirtual(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    NTSTATUS KdWriteVirtual(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    HRESULT KdReadVirtualTranslated(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    HRESULT KdWriteVirtualTranslated(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );

    // ConnLiveKernelTargetInfo.

    void ResetConnection(void);
    
    DbgKdTransport* m_Transport;
    
    BOOL m_CurrentPartition;
    TargetInfo* m_SwitchTarget;
    ULONG m_SwitchProcessor;

    ULONG64 m_KdpSearchPageHits;
    ULONG64 m_KdpSearchPageHitOffsets;
    ULONG64 m_KdpSearchPageHitIndex;

    ULONG64 m_KdpSearchCheckPoint;
    ULONG64 m_KdpSearchInProgress;

    ULONG64 m_KdpSearchStartPageFrame;
    ULONG64 m_KdpSearchEndPageFrame;

    ULONG64 m_KdpSearchAddressRangeStart;
    ULONG64 m_KdpSearchAddressRangeEnd;

    ULONG64 m_KdpSearchPfnValue;
};

//----------------------------------------------------------------------------
//
// LocalLiveKernelTargetInfo.
//
//----------------------------------------------------------------------------

class LocalLiveKernelTargetInfo : public LiveKernelTargetInfo
{
public:
    LocalLiveKernelTargetInfo(void)
        : LiveKernelTargetInfo(DEBUG_KERNEL_LOCAL, FALSE) {}
    
    // TargetInfo.
    virtual HRESULT Initialize(void);
    
    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT ReadVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadPhysical(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysical(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadMsr(
        IN ULONG Msr,
        OUT PULONG64 Value
        );
    virtual HRESULT WriteMsr(
        IN ULONG Msr,
        IN ULONG64 Value
        );
    virtual HRESULT ReadBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT CheckLowMemory(
        );

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT SetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual HRESULT GetTargetKdVersion(PDBGKD_GET_VERSION64 Version);

    virtual HRESULT WaitInitialize(ULONG Flags,
                                   ULONG Timeout,
                                   WAIT_INIT_TYPE Type,
                                   PULONG DesiredTimeout);
    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout,
                                 ULONG ElapsedTime, PULONG EventStatus);
};

//----------------------------------------------------------------------------
//
// ExdiLiveKernelTargetInfo.
//
//----------------------------------------------------------------------------

class ExdiNotifyRunChange : public IeXdiClientNotifyRunChg
{
public:
    ExdiNotifyRunChange(void);
    ~ExdiNotifyRunChange(void);
    
    HRESULT Initialize(void);
    void Uninitialize(void);
    
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IeXdiClientNotifyRunChg.
    STDMETHOD(NotifyRunStateChange)(RUN_STATUS_TYPE ersCurrent, 
                                    HALT_REASON_TYPE ehrCurrent,
                                    ADDRESS_TYPE CurrentExecAddress,
                                    DWORD dwExceptionCode);

    // ExdiNotifyRunChange.
    HANDLE m_Event;
    HALT_REASON_TYPE m_HaltReason;
    ADDRESS_TYPE m_ExecAddress;
    ULONG m_ExceptionCode;
};

typedef union _EXDI_CONTEXT
{
    CONTEXT_X86 X86Context;
    CONTEXT_X86_EX X86ExContext;
    CONTEXT_X86_64 Amd64Context;
    EXDI_CONTEXT_IA64 IA64Context;
} EXDI_CONTEXT, *PEXDI_CONTEXT;

enum EXDI_CONTEXT_TYPE
{
    EXDI_CTX_X86,
    EXDI_CTX_X86_EX,
    EXDI_CTX_AMD64,
    EXDI_CTX_IA64,
};

enum EXDI_KD_SUPPORT
{
    EXDI_KD_NONE,
    EXDI_KD_IOCTL,
    EXDI_KD_GS_PCR
};

class ExdiLiveKernelTargetInfo : public LiveKernelTargetInfo
{
public:
    ExdiLiveKernelTargetInfo(void);
    virtual ~ExdiLiveKernelTargetInfo(void);
    
    // TargetInfo.
    virtual HRESULT Initialize(void);
    
    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT ReadVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadPhysical(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysical(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadMsr(
        IN ULONG Msr,
        OUT PULONG64 Value
        );
    virtual HRESULT WriteMsr(
        IN ULONG Msr,
        IN ULONG64 Value
        );
    virtual HRESULT ReadBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT CheckLowMemory(
        );
    virtual HRESULT GetProcessorSystemDataOffset(
        IN ULONG Processor,
        IN ULONG Index,
        OUT PULONG64 Offset
        );

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT SetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT GetTargetSegRegDescriptors(ULONG64 Thread,
                                               ULONG Start, ULONG Count,
                                               PDESCRIPTOR64 Descs);
    virtual HRESULT GetTargetSpecialRegisters
        (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    virtual HRESULT SetTargetSpecialRegisters
        (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    virtual void InvalidateTargetContext(void);

    virtual HRESULT SwitchProcessors(ULONG Processor);

    virtual HRESULT GetTargetKdVersion(PDBGKD_GET_VERSION64 Version);

    virtual HRESULT WaitInitialize(ULONG Flags,
                                   ULONG Timeout,
                                   WAIT_INIT_TYPE Type,
                                   PULONG DesiredTimeout);
    virtual HRESULT ReleaseLastEvent(ULONG ContinueStatus);
    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout,
                                 ULONG ElapsedTime, PULONG EventStatus);

    virtual HRESULT RequestBreakIn(void);
    virtual HRESULT Reboot(void);

    virtual HRESULT BeginInsertingBreakpoints(void);
    virtual HRESULT InsertCodeBreakpoint(ProcessInfo* Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG InstrFlags,
                                         PUCHAR StorageSpace);
    virtual HRESULT InsertDataBreakpoint(ProcessInfo* Process,
                                         ThreadInfo* Thread,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG Size,
                                         ULONG AccessType,
                                         PUCHAR StorageSpace);
    virtual void EndInsertingBreakpoints(void);
    virtual void BeginRemovingBreakpoints(void);
    virtual HRESULT RemoveCodeBreakpoint(ProcessInfo* Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG InstrFlags,
                                         PUCHAR StorageSpace);
    virtual HRESULT RemoveDataBreakpoint(ProcessInfo* Process,
                                         ThreadInfo* Thread,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG Size,
                                         ULONG AccessType,
                                         PUCHAR StorageSpace);
    virtual void EndRemovingBreakpoints(void);
    virtual HRESULT IsDataBreakpointHit(ThreadInfo* Thread,
                                        PADDR Addr,
                                        ULONG Size,
                                        ULONG AccessType,
                                        PUCHAR StorageSpace);

    // ExdiLiveKernelTargetInfo.

    ULONG GetCurrentProcessor(void);
    ULONG ProcessRunChange(ULONG HaltReason,
                           ULONG ExceptionCode);
    
    IeXdiServer* m_Server;
    IStream* m_MarshalledServer;
    IUnknown* m_Context;
    BOOL m_ContextValid;
    EXDI_CONTEXT m_ContextData;
    EXDI_CONTEXT_TYPE m_ContextType;
    GLOBAL_TARGET_INFO_STRUCT m_GlobalInfo;
    EXDI_KD_SUPPORT m_KdSupport;
    BOOL m_ForceX86;
    ULONG m_ExpectedMachine;
    CBP_KIND m_CodeBpType;
    ExdiNotifyRunChange m_RunChange;
    DBGENG_EXDI_IOCTL_CODE m_IoctlMin;
    DBGENG_EXDI_IOCTL_CODE m_IoctlMax;
    BOOL m_ExdiDataBreaks;
    DBGENG_EXDI_IOCTL_GET_BREAKPOINT_HIT_OUT m_BpHit;
};

//----------------------------------------------------------------------------
//
// LiveUserTargetInfo.
//
//----------------------------------------------------------------------------

class LiveUserTargetInfo : public TargetInfo
{
public:
    LiveUserTargetInfo(ULONG Qual);
    virtual ~LiveUserTargetInfo(void);
    
    // TargetInfo.

    virtual void DeleteSystemInfo(void);
    
    virtual HRESULT Initialize(void);
    
    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT ReadVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadVirtualUncached(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtualUncached(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadHandleData(
        IN ProcessInfo* Process,
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        );
    virtual HRESULT GetProcessorId(
        ULONG Processor,
        PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id
        );
    virtual HRESULT GetProcessorSpeed(
        ULONG Processor,
        PULONG Speed
        );
    virtual HRESULT GetGenericProcessorFeatures(
        ULONG Processor,
        PULONG64 Features,
        ULONG FeaturesSize,
        PULONG Used
        );
    virtual HRESULT GetSpecificProcessorFeatures(
        ULONG Processor,
        PULONG64 Features,
        ULONG FeaturesSize,
        PULONG Used
        );

    virtual HRESULT GetUnloadedModuleListHead(ProcessInfo* Process,
                                              PULONG64 Head);

    virtual HRESULT GetFunctionTableListHead(ProcessInfo* Process,
                                             PULONG64 Head);
    virtual HRESULT ReadOutOfProcessDynamicFunctionTable(ProcessInfo* Process,
                                                         PWSTR Dll,
                                                         ULONG64 Table,
                                                         PULONG TableSize,
                                                         PVOID* TableData);

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT SetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual HRESULT GetThreadStartOffset(ThreadInfo* Thread,
                                         PULONG64 StartOffset);
    virtual void SuspendThreads(void);
    virtual BOOL ResumeThreads(void);

    virtual HRESULT GetThreadInfoDataOffset(ThreadInfo* Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset);
    virtual HRESULT GetProcessInfoDataOffset(ThreadInfo* Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset);
    virtual HRESULT GetThreadInfoTeb(ThreadInfo* Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset);
    virtual HRESULT GetProcessInfoPeb(ThreadInfo* Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset);

    virtual HRESULT GetSelDescriptor(ThreadInfo* Thread,
                                     MachineInfo* Machine,
                                     ULONG Selector,
                                     PDESCRIPTOR64 Desc);

    virtual HRESULT GetImageVersionInformation(ProcessInfo* Process,
                                               PCSTR ImagePath,
                                               ULONG64 ImageBase,
                                               PCSTR Item,
                                               PVOID Buffer, ULONG BufferSize,
                                               PULONG VerInfoSize);
    
    virtual ULONG64 GetCurrentTimeDateN(void);
    virtual ULONG64 GetCurrentSystemUpTimeN(void);
    virtual ULONG64 GetProcessUpTimeN(ProcessInfo* Process);
    virtual HRESULT GetProcessTimes(ProcessInfo* Process,
                                    PULONG64 Create,
                                    PULONG64 Exit,
                                    PULONG64 Kernel,
                                    PULONG64 User);
    virtual HRESULT GetThreadTimes(ThreadInfo* Thread,
                                   PULONG64 Create,
                                   PULONG64 Exit,
                                   PULONG64 Kernel,
                                   PULONG64 User);

    virtual void InitializeWatchTrace(void);
    virtual void ProcessWatchTraceEvent(PDBGKD_TRACE_DATA TraceData,
                                        PADDR PcAddr,
                                        PBOOL StepOver);
    
    virtual HRESULT WaitInitialize(ULONG Flags,
                                   ULONG Timeout,
                                   WAIT_INIT_TYPE Type,
                                   PULONG DesiredTimeout);
    virtual HRESULT ReleaseLastEvent(ULONG ContinueStatus);
    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout,
                                 ULONG ElapsedTime, PULONG EventStatus);

    virtual HRESULT RequestBreakIn(void);

    virtual HRESULT BeginInsertingBreakpoints(void);
    virtual HRESULT InsertCodeBreakpoint(ProcessInfo* Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG InstrFlags,
                                         PUCHAR StorageSpace);
    virtual HRESULT InsertDataBreakpoint(ProcessInfo* Process,
                                         ThreadInfo* Thread,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG Size,
                                         ULONG AccessType,
                                         PUCHAR StorageSpace);
    virtual void EndInsertingBreakpoints(void);
    virtual HRESULT RemoveCodeBreakpoint(ProcessInfo* Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG InstrFlags,
                                         PUCHAR StorageSpace);
    virtual HRESULT RemoveDataBreakpoint(ProcessInfo* Process,
                                         ThreadInfo* Thread,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         ULONG Size,
                                         ULONG AccessType,
                                         PUCHAR StorageSpace);
    virtual HRESULT IsDataBreakpointHit(ThreadInfo* Thread,
                                        PADDR Addr,
                                        ULONG Size,
                                        ULONG AccessType,
                                        PUCHAR StorageSpace);

    virtual HRESULT QueryMemoryRegion(ProcessInfo* Process,
                                      PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);

    virtual HRESULT StartAttachProcess(ULONG ProcessId,
                                       ULONG AttachFlags,
                                       PPENDING_PROCESS* Pending);
    virtual HRESULT StartCreateProcess(PWSTR CommandLine,
                                       ULONG CreateFlags,
                                       PBOOL InheritHandles,
                                       PWSTR CurrentDir,
                                       PPENDING_PROCESS* Pending);
    virtual HRESULT TerminateProcesses(void);
    virtual HRESULT DetachProcesses(void);
    
    // LiveUserTargetInfo.
    
    HRESULT SetServices(PUSER_DEBUG_SERVICES Services, BOOL Remote);
    HRESULT InitFromServices(void);

    ULONG ProcessDebugEvent(DEBUG_EVENT64* Event,
                            ULONG PendingFlags,
                            ULONG PendingOptions);
    ULONG ProcessEventException(DEBUG_EVENT64* Event);
    ULONG OutputEventDebugString(OUTPUT_DEBUG_STRING_INFO64* Info);

    void AddPendingProcess(PPENDING_PROCESS Pending);
    void RemovePendingProcess(PPENDING_PROCESS Pending);
    void DiscardPendingProcess(PPENDING_PROCESS Pending);
    void DiscardPendingProcesses(void);
    PPENDING_PROCESS FindPendingProcessByFlags(ULONG Flags);
    PPENDING_PROCESS FindPendingProcessById(ULONG Id);
    void VerifyPendingProcesses(void);
    void AddExamineToPendingAttach(void);

    void SuspendResumeThreads(ProcessInfo* Process,
                              BOOL Susp,
                              ThreadInfo* Match);

    PUSER_DEBUG_SERVICES m_Services;
    ULONG m_ServiceFlags;
    char m_ProcessServer[MAX_COMPUTERNAME_LENGTH + DBGRPC_MAX_IDENTITY + 8];
    ULONG m_Local:1;
    
    BOOL m_DataBpAddrValid;
    HRESULT m_DataBpAddrStatus;
    ULONG64 m_DataBpAddr;
    ULONG m_DataBpAccess;

    PPENDING_PROCESS m_ProcessPending;
    ULONG m_AllPendingFlags;
};

//----------------------------------------------------------------------------
//
// DumpTargetInfo hierarchy is in dump.hpp.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Generic layer definitions.
//
//----------------------------------------------------------------------------

extern ULONG g_NumberTargets;
extern TargetInfo* g_TargetHead;

#define ForProcessThreads(Process) \
    for (Thread = (Process)->m_ThreadHead; Thread; Thread = Thread->m_Next)
#define ForTargetProcesses(Target) \
    for (Process = (Target)->m_ProcessHead; Process; Process = Process->m_Next)
#define ForTargets() \
    for (Target = g_TargetHead; Target; Target = Target->m_Next)

#define ForAllLayers() \
    ForTargets() \
    ForTargetProcesses(Target) \
    ForProcessThreads(Process)
#define ForAllLayersToProcess() \
    ForTargets() \
    ForTargetProcesses(Target)
#define ForAllLayersToTarget() \
    ForTargets()

extern TargetInfo* g_Target;
extern ProcessInfo* g_Process;
extern ThreadInfo* g_Thread;
extern MachineInfo* g_Machine;

struct StackSaveLayers
{
    StackSaveLayers(void)
    {
        m_Target = g_Target;
        m_Process = g_Process;
        m_Thread = g_Thread;
        m_Machine = g_Machine;
    }
    ~StackSaveLayers(void)
    {
        g_Target = m_Target;
        g_Process = m_Process;
        g_Thread = m_Thread;
        g_Machine = m_Machine;
    }

    TargetInfo* m_Target;
    ProcessInfo* m_Process;
    ThreadInfo* m_Thread;
    MachineInfo* m_Machine;
};

extern ULONG g_UserIdFragmented[LAYER_COUNT];
extern ULONG g_HighestUserId[LAYER_COUNT];

void SetLayersFromTarget(TargetInfo* Target);
void SetLayersFromProcess(ProcessInfo* Process);
void SetLayersFromThread(ThreadInfo* Thread);
void SetToAnyLayers(BOOL SetPrompt);

ULONG FindNextUserId(LAYER Layer);

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

TargetInfo* FindTargetByUserId(ULONG Id);
TargetInfo* FindTargetBySystemId(ULONG SysId);
TargetInfo* FindTargetByServer(ULONG64 Server);

void SuspendAllThreads(void);
BOOL ResumeAllThreads(void);

BOOL DeleteAllExitedInfos(void);

BOOL AnyActiveProcesses(BOOL FinalOnly);
BOOL AnySystemProcesses(BOOL LocalOnly);
ULONG AllProcessFlags(void);
BOOL AnyLiveUserTargets(void);

void InvalidateAllMemoryCaches(void);

HANDLE GloballyUniqueProcessHandle(TargetInfo* Target, ULONG64 FullHandle);

ULONG NtBuildToSystemVersion(ULONG Build);
ULONG Win9xBuildToSystemVersion(ULONG Build);
ULONG WinCeBuildToSystemVersion(ULONG Build);
PCSTR SystemVersionName(ULONG Sver);

void ParseSystemCommands(void);

#endif // #ifndef __TARGET_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\typedata.cpp ===
//----------------------------------------------------------------------------
//
// Typed data abstraction.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#define DBG_BASE_SEARCH 0

// Limit array dumps to prevent large arrays from hogging space.
#define ARRAY_CHILDREN_LIMIT 100
// We know an index will be at most "[xx]"
// due to the expansion limit.
#define ARRAY_LIMIT_CHARS 5

// Special pre-defined types
DBG_NATIVE_TYPE g_DbgNativeTypes[] =
{
    {"void",           btVoid,  SymTagBaseType, 0, 0},
    {"char",           btChar,  SymTagBaseType, 1, DNTF_SIGNED | DNTF_INTEGER},
    {"wchar_t",        btWChar, SymTagBaseType, 2, DNTF_INTEGER},
    {"char",           btInt,   SymTagBaseType, 1, DNTF_SIGNED | DNTF_INTEGER},
    {"short",          btInt,   SymTagBaseType, 2, DNTF_SIGNED | DNTF_INTEGER},
    {"int",            btInt,   SymTagBaseType, 4, DNTF_SIGNED | DNTF_INTEGER},
    {"int64",          btInt,   SymTagBaseType, 8, DNTF_SIGNED | DNTF_INTEGER},
    {"unsigned char",  btUInt,  SymTagBaseType, 1, DNTF_INTEGER},
    {"unsigned short", btUInt,  SymTagBaseType, 2, DNTF_INTEGER},
    {"unsigned int",   btUInt,  SymTagBaseType, 4, DNTF_INTEGER},
    {"unsigned int64", btUInt,  SymTagBaseType, 8, DNTF_INTEGER},
    {"float",          btFloat, SymTagBaseType, 4, DNTF_SIGNED | DNTF_FLOAT},
    {"double",         btFloat, SymTagBaseType, 8, DNTF_SIGNED | DNTF_FLOAT},
    {"bool",           btBool,  SymTagBaseType, 1, 0},
    {"long",           btLong,  SymTagBaseType, 4, DNTF_SIGNED | DNTF_INTEGER},
    {"unsigned long",  btULong, SymTagBaseType, 4, DNTF_INTEGER},
    {"HRESULT",        btHresult,SymTagBaseType, 4, DNTF_SIGNED | DNTF_INTEGER},
    {"WCHAR",          btWChar, SymTagBaseType, 2, DNTF_INTEGER},
    {NULL,             btVoid,  SymTagPointerType, 4, 0},
    {NULL,             btVoid,  SymTagPointerType, 8, 0},
};

GeneratedTypeList g_GenTypes;

//----------------------------------------------------------------------------
//
// Native types.
//
//----------------------------------------------------------------------------

PDBG_NATIVE_TYPE
FindNativeTypeByName(PCSTR Name)
{
    ULONG i;
    PDBG_NATIVE_TYPE Native = g_DbgNativeTypes;

    for (i = 0; i < DNTYPE_COUNT; i++)
    {
        if (Native->TypeName &&
            !strcmp(Name, Native->TypeName))
        {
            return Native;
        }

        Native++;
    }

    return NULL;
}

PDBG_NATIVE_TYPE
FindNativeTypeByCvBaseType(ULONG CvBase, ULONG Size)
{
    ULONG i;
    PDBG_NATIVE_TYPE Native = g_DbgNativeTypes;

    for (i = 0; i < DNTYPE_COUNT; i++)
    {
        if (Native->CvTag == SymTagBaseType &&
            Native->CvBase == CvBase &&
            Native->Size == Size)
        {
            return Native;
        }

        Native++;
    }

    return NULL;
}

//----------------------------------------------------------------------------
//
// Generated types.
//
//----------------------------------------------------------------------------

GeneratedTypeList::GeneratedTypeList(void)
{
    m_Types = NULL;
    m_NextId = DBG_GENERATED_TYPE_BASE;
}

GeneratedTypeList::~GeneratedTypeList(void)
{
    DeleteByImage(IMAGE_BASE_ALL);
}

PDBG_GENERATED_TYPE
GeneratedTypeList::NewType(ULONG64 ImageBase, ULONG Tag, ULONG Size)
{
    if (m_NextId == 0xffffffff)
    {
        return NULL;
    }

    PDBG_GENERATED_TYPE GenType = new DBG_GENERATED_TYPE;
    if (GenType)
    {
        GenType->ImageBase = ImageBase;
        // Just use a simple incremental ID scheme as the
        // total number of generated types should be relatively small.
        GenType->TypeId = m_NextId++;
        GenType->Tag = Tag;
        GenType->Size = Size;
        GenType->ChildId = 0;

        GenType->Next = m_Types;
        m_Types = GenType;
    }

    return GenType;
}

void
GeneratedTypeList::DeleteByImage(ULONG64 ImageBase)
{
    PDBG_GENERATED_TYPE GenType, Prev, Next;

    Prev = NULL;
    GenType = m_Types;
    while (GenType)
    {
        Next = GenType->Next;

        // An image base of zero means delete all.
        if (ImageBase == IMAGE_BASE_ALL || GenType->ImageBase == ImageBase)
        {
            delete GenType;
            if (!Prev)
            {
                m_Types = Next;
            }
            else
            {
                Prev->Next = Next;
            }
        }
        else
        {
            Prev = GenType;
        }

        GenType = Next;
    }

    if (!m_Types)
    {
        // Everything was deleted so reset the ID counter.
        m_NextId = DBG_GENERATED_TYPE_BASE;
    }
}

void
GeneratedTypeList::DeleteById(ULONG Id)
{
    PDBG_GENERATED_TYPE GenType, Prev, Next;

    Prev = NULL;
    GenType = m_Types;
    while (GenType)
    {
        Next = GenType->Next;

        if (GenType->TypeId == Id)
        {
            delete GenType;
            if (!Prev)
            {
                m_Types = Next;
            }
            else
            {
                Prev->Next = Next;
            }
        }
        else
        {
            Prev = GenType;
        }

        GenType = Next;
    }

    if (!m_Types)
    {
        // Everything was deleted so reset the ID counter.
        m_NextId = DBG_GENERATED_TYPE_BASE;
    }
}

PDBG_GENERATED_TYPE
GeneratedTypeList::FindById(ULONG TypeId)
{
    PDBG_GENERATED_TYPE GenType;

    for (GenType = m_Types; GenType; GenType = GenType->Next)
    {
        if (GenType->TypeId == TypeId)
        {
            return GenType;
        }
    }

    return NULL;
}

PDBG_GENERATED_TYPE
GeneratedTypeList::FindByAttrs(ULONG64 ImageBase,
                               ULONG Tag, ULONG ChildId, ULONG Size)
{
    PDBG_GENERATED_TYPE GenType;

    for (GenType = m_Types; GenType; GenType = GenType->Next)
    {
        if (GenType->ImageBase == ImageBase &&
            GenType->Tag == Tag &&
            GenType->ChildId == ChildId &&
            GenType->Size == Size)
        {
            return GenType;
        }
    }

    return NULL;
}

PDBG_GENERATED_TYPE
GeneratedTypeList::FindOrCreateByAttrs(ULONG64 ImageBase,
                                       ULONG Tag,
                                       ULONG ChildId,
                                       ULONG Size)
{
    PDBG_GENERATED_TYPE GenType = FindByAttrs(ImageBase, Tag, ChildId, Size);
    if (!GenType)
    {
        GenType = NewType(ImageBase, Tag, Size);
        if (!GenType)
        {
            return NULL;
        }

        GenType->ChildId = ChildId;
    }

    return GenType;
}

//----------------------------------------------------------------------------
//
// TypedData.
//
//----------------------------------------------------------------------------

ULONG
TypedData::CheckConvertI64ToF64(ULONG64 I64, BOOL Signed)
{
    // Just warn all the time for now as this should be a rare case.
    WarnOut("WARNING: Conversion of int64 to double, "
            "possible loss of accuracy\n");
    return NO_ERROR;
}

ULONG
TypedData::CheckConvertF64ToI64(double F64, BOOL Signed)
{
    // Just warn all the time for now as this should be a rare case.
    WarnOut("WARNING: Conversion of double to int64, "
            "possible loss of accuracy\n");
    return NO_ERROR;
}

ULONG
TypedData::ConvertToBool(void)
{
    //
    // In all the conversions the original type information
    // is lost as it is assumed that the converted value
    // represents an anonymous temporary that is separate
    // from the original value's type.
    //

    switch(m_BaseType)
    {
    case DNTYPE_CHAR:
    case DNTYPE_INT8:
    case DNTYPE_UINT8:
        m_Bool = m_S8 != 0;
        break;
    case DNTYPE_WCHAR:
    case DNTYPE_WCHAR_T:
    case DNTYPE_INT16:
    case DNTYPE_UINT16:
        m_Bool = m_S16 != 0;
        break;
    case DNTYPE_INT32:
    case DNTYPE_UINT32:
    case DNTYPE_LONG32:
    case DNTYPE_ULONG32:
    case DNTYPE_HRESULT:
        m_Bool = m_S32 != 0;
        break;
    case DNTYPE_INT64:
    case DNTYPE_UINT64:
        m_Bool = m_S64 != 0;
        break;
    case DNTYPE_FLOAT32:
        m_Bool = m_F32 != 0;
        break;
    case DNTYPE_FLOAT64:
        m_Bool = m_F64 != 0;
        break;
    case DNTYPE_BOOL:
        // Identity.
        break;
    default:
        if (IsPointer())
        {
            // The full 64 bits of a pointer are always valid
            // as 32-bit pointer reads are immediately sign-extended.
            m_Bool = m_Ptr != 0;
            break;
        }
        else if (IsEnum())
        {
            m_Bool = m_S32 != 0;
            break;
        }
        else if (IsFunction())
        {
            // Allow function addresses to work like pointers.
            m_Bool = m_U64 != 0;
            break;
        }

        return TYPECONFLICT;
    }

    // Clear high bits of value.
    m_U64 = m_Bool;
    SetToNativeType(DNTYPE_BOOL);
    ClearAddress();
    return NO_ERROR;
}

ULONG
TypedData::ConvertToU64(BOOL Strict)
{
    ULONG Err;

    switch(m_BaseType)
    {
    case DNTYPE_CHAR:
    case DNTYPE_INT8:
        m_U64 = m_S8;
        break;
    case DNTYPE_INT16:
        m_U64 = m_S16;
        break;
    case DNTYPE_INT32:
    case DNTYPE_LONG32:
    case DNTYPE_HRESULT:
        m_U64 = m_S32;
        break;
    case DNTYPE_INT64:
    case DNTYPE_UINT64:
        // Identity.
        break;
    case DNTYPE_UINT8:
        m_U64 = m_U8;
        break;
    case DNTYPE_WCHAR:
    case DNTYPE_WCHAR_T:
    case DNTYPE_UINT16:
        m_U64 = m_U16;
        break;
    case DNTYPE_UINT32:
    case DNTYPE_ULONG32:
        m_U64 = m_U32;
        break;
    case DNTYPE_FLOAT32:
        if (Strict && (Err = CheckConvertF64ToI64(m_F32, TRUE)))
        {
            return Err;
        }
        m_U64 = (ULONG64)m_F32;
        break;
    case DNTYPE_FLOAT64:
        if (Strict && (Err = CheckConvertF64ToI64(m_F64, TRUE)))
        {
            return Err;
        }
        m_U64 = (ULONG64)m_F64;
        break;
    case DNTYPE_BOOL:
        m_U64 = m_Bool ? 1 : 0;
        break;
    default:
        if (IsPointer())
        {
            m_U64 = m_Ptr;
            break;
        }
        else if (IsEnum())
        {
            m_U64 = m_S32;
            break;
        }
        else if (IsFunction())
        {
            // Allow function addresses to work like pointers.
            break;
        }

        return TYPECONFLICT;
    }

    SetToNativeType(DNTYPE_UINT64);
    ClearAddress();
    return NO_ERROR;
}

ULONG
TypedData::ConvertToF64(BOOL Strict)
{
    ULONG Err;

    switch(m_BaseType)
    {
    case DNTYPE_CHAR:
    case DNTYPE_INT8:
        m_F64 = m_S8;
        break;
    case DNTYPE_INT16:
        m_F64 = m_S16;
        break;
    case DNTYPE_INT32:
    case DNTYPE_LONG32:
    case DNTYPE_HRESULT:
        m_F64 = m_S32;
        break;
    case DNTYPE_INT64:
        if (Strict && (Err = CheckConvertI64ToF64(m_S64, TRUE)))
        {
            return Err;
        }
        m_F64 = (double)m_S64;
        break;
    case DNTYPE_UINT8:
        m_F64 = m_U8;
        break;
    case DNTYPE_WCHAR:
    case DNTYPE_WCHAR_T:
    case DNTYPE_UINT16:
        m_F64 = m_U16;
        break;
    case DNTYPE_UINT32:
    case DNTYPE_ULONG32:
        m_F64 = m_U32;
        break;
    case DNTYPE_UINT64:
        if (Strict && (Err = CheckConvertI64ToF64(m_S64, FALSE)))
        {
            return Err;
        }
        m_F64 = (double)m_U64;
        break;
    case DNTYPE_FLOAT32:
        m_F64 = m_F32;
        break;
    case DNTYPE_FLOAT64:
        // Identity.
        break;
    case DNTYPE_BOOL:
        m_F64 = m_Bool ? 1.0 : 0.0;
        break;
    default:
        if (IsEnum())
        {
            m_F64 = m_S32;
            break;
        }

        return TYPECONFLICT;
    }

    SetToNativeType(DNTYPE_FLOAT64);
    ClearAddress();
    return NO_ERROR;
}

void
TypedData::ConvertToBestNativeType(void)
{
    // Arrays and UDTs have no convertible representation so
    // zero things out.  Pointers, enumerants and functions naturally
    // convert to U64, so things simplify down into:
    // 1.  If native, assume the native type.
    // 2.  If non-native, convert to U64.  If the conversion
    //     fails, zero things out.
    if (!IsDbgNativeType(m_BaseType) || IsPointer())
    {
        ForceU64();
    }
    else
    {
        SetToNativeType(m_BaseType);
    }
}

ULONG
TypedData::ConvertTo(TypedData* Type)
{
    ULONG Err;

    switch(Type->m_BaseType)
    {
    case DNTYPE_BOOL:
        Err = ConvertToBool();
        break;

    case DNTYPE_CHAR:
    case DNTYPE_WCHAR:
    case DNTYPE_WCHAR_T:
    case DNTYPE_INT8:
    case DNTYPE_UINT8:
    case DNTYPE_INT16:
    case DNTYPE_UINT16:
    case DNTYPE_INT32:
    case DNTYPE_UINT32:
    case DNTYPE_LONG32:
    case DNTYPE_ULONG32:
    case DNTYPE_INT64:
    case DNTYPE_UINT64:
    case DNTYPE_HRESULT:
        Err = ConvertToU64();
        break;

    case DNTYPE_FLOAT32:
        Err = ConvertToF64();
        if (!Err)
        {
            m_F32 = (float)m_F64;
            // Clear high bits.
            m_U64 = m_U32;
        }
        break;
    case DNTYPE_FLOAT64:
        Err = ConvertToF64();
        break;

    default:
        if (Type->IsEnum() || Type->IsPointer())
        {
            Err = ConvertToU64();
            break;
        }

        Err = TYPECONFLICT;
        break;
    }

    if (!Err)
    {
        m_BaseType = Type->m_BaseType;
        m_BaseTag = Type->m_BaseTag;
        m_BaseSize = Type->m_BaseSize;
    }
    return Err;
}

ULONG
TypedData::CastTo(TypedData* CastType)
{
    ULONG Err;
    LONG Adjust = 0;
    USHORT Source = m_DataSource;
    ULONG64 SourceOffs = m_SourceOffset;
    ULONG SourceReg = m_SourceRegister;

    //
    // If we're casting between object pointer types
    // we may need to adjust the pointer to account
    // for this pointer differences between various
    // inherited classes in a multiple inheritance case.
    //
    // Such a relationship requires that both types are
    // from the same image, so we can use this as a quick
    // rejection test.
    //

    if (IsPointer() && CastType->IsPointer() &&
        m_Image && m_Image == CastType->m_Image)
    {
        ULONG Tag, CastTag;

        if ((Err = GetTypeTag(m_NextType, &Tag)) ||
            (Err = GetTypeTag(CastType->m_NextType, &CastTag)))
        {
            return Err;
        }

        if (Tag == SymTagUDT && CastTag == SymTagUDT)
        {
            // The cast can be from derived->base, in which
            // case any offset should be added, or base->derived,
            // in which case it should be subtracted.
            if (IsBaseClass(m_NextType, CastType->m_NextType,
                            &Adjust) == NO_ERROR)
            {
                // Adjust should add.
            }
            else if (IsBaseClass(CastType->m_NextType, m_NextType,
                                 &Adjust) == NO_ERROR)
            {
                // Adjust should subtract.
                Adjust = -Adjust;
            }
        }
    }

    Err = ConvertTo(CastType);
    if (!Err)
    {
        CopyType(CastType);

        // Casting doesn't change the location of
        // an item, just its interpretation, so
        // restore the address wiped out by conversion.
        m_DataSource = Source;
        m_SourceOffset = SourceOffs;
        m_SourceRegister = SourceReg;

        if (Adjust && m_Ptr)
        {
            // Adjust will only be set for pointers.
            // NULL is never adjusted.
            m_Ptr += Adjust;
        }

        // If we've cast to a pointer type make sure
        // that the pointer value is properly sign-extended.
        if (IsPointer() && m_BaseSize == sizeof(m_U32))
        {
            m_Ptr = EXTEND64(m_Ptr);
        }
    }

    return Err;
}

ULONG
TypedData::ConvertToAddressOf(BOOL CastOnly, ULONG PtrSize)
{
    ULONG Err;
    ULONG64 Ptr;

    if (CastOnly)
    {
        Ptr = 0;
    }
    else if (Err = GetAbsoluteAddress(&Ptr))
    {
        return Err;
    }

    if (IsArray())
    {
        // If this is an array we need to update
        // the base type and size to refer to a single element.
        m_BaseType = m_NextType;
        m_BaseSize = m_NextSize;
    }
    else if (IsFunction())
    {
        // The pointer element size should be zero as you
        // can't do address arithmetic with a function pointer.
        m_BaseSize = 0;
    }

    PDBG_GENERATED_TYPE GenType =
        g_GenTypes.FindOrCreateByAttrs(m_Image ?
                                       m_Image->m_BaseOfImage : 0,
                                       SymTagPointerType,
                                       m_BaseType, PtrSize);
    if (!GenType)
    {
        return NOMEMORY;
    }

    m_NextType = m_BaseType;
    m_NextSize = m_BaseSize;
    m_Type = GenType->TypeId;
    m_BaseType = m_Type;
    m_BaseTag = (USHORT)GenType->Tag;
    m_BaseSize = GenType->Size;
    m_Ptr = Ptr;
    ClearAddress();

    return NO_ERROR;
}

ULONG
TypedData::ConvertToDereference(TypedDataAccess AllowAccess, ULONG PtrSize)
{
    ULONG Err;

    m_Type = m_NextType;
    if (Err = FindTypeInfo(TRUE, PtrSize))
    {
        return Err;
    }
    SetDataSource(TDATA_MEMORY, m_Ptr, 0);
    return ReadData(AllowAccess);
}

ULONG
TypedData::ConvertToArray(ULONG ArraySize)
{
    PDBG_GENERATED_TYPE GenType =
        g_GenTypes.FindOrCreateByAttrs(m_Image ?
                                       m_Image->m_BaseOfImage : 0,
                                       SymTagArrayType,
                                       m_BaseType, ArraySize);
    if (!GenType)
    {
        return NOMEMORY;
    }

    m_NextType = m_BaseType;
    m_NextSize = m_BaseSize;
    m_Type = GenType->TypeId;
    m_BaseType = m_Type;
    m_BaseTag = (USHORT)GenType->Tag;
    m_BaseSize = GenType->Size;
    // Leave data source unchanged.  Zero the data as array
    // data is not kept in the object.
    ClearData();

    return NO_ERROR;
}

ULONG
TypedData::SetToUdtMember(TypedDataAccess AllowAccess,
                          ULONG PtrSize, ImageInfo* Image,
                          ULONG Member, ULONG Type, ULONG Tag,
                          USHORT DataSource, ULONG64 BaseOffs, ULONG SourceReg,
                          DataKind Relation)
{
    ULONG Err;

    m_Image = Image;
    m_Type = Type;
    if (Err = FindTypeInfo(TRUE, PtrSize))
    {
        return Err;
    }
    // Reset the image in case FindTypeInfo cleared it.
    m_Image = Image;

    if (Relation == DataIsMember)
    {
        ULONG Offset;
        ULONG BitPos;

        if (Tag == SymTagVTable)
        {
            // VTables are always at offset zero.
            Offset = 0;
        }
        else if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                 m_Image->m_BaseOfImage,
                                 Member, TI_GET_OFFSET, &Offset))
        {
            return TYPEDATA;
        }

        // UDT members may be bitfields.  Bitfields
        // have an overall integer type and then
        // extra specifiers for the exact bits within
        // the type that should be used.
        if (SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                           m_Image->m_BaseOfImage,
                           Member, TI_GET_BITPOSITION, &BitPos) &&
            SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                           m_Image->m_BaseOfImage,
                           Member, TI_GET_LENGTH, &m_SourceOffset))
        {
            m_BitPos = BitPos;
            m_BitSize = (ULONG)m_SourceOffset;
            SetDataSource(DataSource | TDATA_BITFIELD,
                          BaseOffs + Offset, SourceReg);
        }
        else
        {
            SetDataSource(DataSource, BaseOffs + Offset, SourceReg);
        }
    }
    else
    {
        if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Member, TI_GET_ADDRESS, &BaseOffs))
        {
            return TYPEDATA;
        }

        SetDataSource(TDATA_MEMORY, BaseOffs, 0);
    }

    return ReadData(AllowAccess);
}

ULONG
TypedData::FindUdtMember(ULONG UdtType, PCWSTR Member,
                         PULONG MemberType, DataKind* Relation,
                         PULONG InheritOffset)
{
    ULONG NumMembers;

    if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                        m_Image->m_BaseOfImage,
                        UdtType, TI_GET_CHILDRENCOUNT, &NumMembers) ||
        NumMembers == 0)
    {
        return NOTMEMBER;
    }

    TI_FINDCHILDREN_PARAMS* Members = (TI_FINDCHILDREN_PARAMS*)
        malloc(sizeof(*Members) + sizeof(ULONG) * NumMembers);
    if (!Members)
    {
        return NOMEMORY;
    }

    Members->Count = NumMembers;
    Members->Start = 0;
    if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                        m_Image->m_BaseOfImage,
                        UdtType, TI_FINDCHILDREN, Members))
    {
        free(Members);
        return TYPEDATA;
    }

    ULONG i;
    ULONG Match = 0;

    for (i = 0; !Match && i < NumMembers; i++)
    {
        ULONG Tag;
        PWSTR MemberName, MemberStart;

        if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Members->ChildId[i], TI_GET_SYMTAG, &Tag))
        {
            continue;
        }

        if (Tag == SymTagBaseClass)
        {
            ULONG Type, BaseOffset;

            // Search base class members as they aren't
            // bubbled into the derived class.
            if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                Members->ChildId[i],
                                TI_GET_TYPEID, &Type) ||
                !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                Members->ChildId[i],
                                TI_GET_OFFSET, &BaseOffset) ||
                FindUdtMember(Type, Member, MemberType,
                              Relation, InheritOffset) != NO_ERROR)
            {
                continue;
            }

            *InheritOffset += BaseOffset;

            free(Members);
            return NO_ERROR;
        }

        if (Tag != SymTagData ||
            !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Members->ChildId[i], TI_GET_DATAKIND, Relation) ||
            (*Relation != DataIsMember &&
             *Relation != DataIsStaticMember &&
             *Relation != DataIsGlobal) ||
            !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Members->ChildId[i], TI_GET_SYMNAME, &MemberName))
        {
            continue;
        }

        // Names somtimes contain ::, such as for static members,
        // so skip that.
        if (MemberStart = wcsrchr(MemberName, ':'))
        {
            MemberStart++;
        }
        else
        {
            MemberStart = MemberName;
        }

        if (!wcscmp(Member, MemberStart))
        {
            Match = Members->ChildId[i];
        }

        LocalFree(MemberName);
    }

    free(Members);

    if (!Match)
    {
        return NOTMEMBER;
    }

    // This member is a direct member of the current UDT
    // and so has no inherited offset.
    *InheritOffset = 0;
    *MemberType = Match;
    return NO_ERROR;
}

ULONG
TypedData::ConvertToMember(PCSTR Member, TypedDataAccess AllowAccess,
                           ULONG PtrSize)
{
    ULONG UdtType;
    ULONG64 BaseOffs;
    ULONG Tag;
    USHORT DataSource;
    ULONG SourceReg;

    if (IsPointer())
    {
        UdtType = m_NextType;
        DataSource = TDATA_MEMORY;
        BaseOffs = m_Ptr;
        SourceReg = 0;
    }
    else
    {
        UdtType = m_BaseType;
        DataSource = m_DataSource & ~TDATA_THIS_ADJUST;
        BaseOffs = m_SourceOffset;
        SourceReg = m_SourceRegister;
    }

    if (!m_Image ||
        !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                        m_Image->m_BaseOfImage,
                        UdtType, TI_GET_SYMTAG, &Tag) ||
        Tag != SymTagUDT)
    {
        return NOTMEMBER;
    }

    PWSTR WideName;

    if (AnsiToWide(Member, &WideName) != S_OK)
    {
        return NOMEMORY;
    }

    ULONG Err;
    ULONG Match;
    DataKind Relation;
    ULONG InheritOffset;

    Err = FindUdtMember(UdtType, WideName, &Match, &Relation, &InheritOffset);

    free(WideName);

    if (Err)
    {
        return Err;
    }

    if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                        m_Image->m_BaseOfImage,
                        Match, TI_GET_TYPEID, &m_Type))
    {
        return TYPEDATA;
    }

    return SetToUdtMember(AllowAccess, PtrSize,
                          m_Image, Match, m_Type, SymTagData,
                          DataSource, BaseOffs + InheritOffset, SourceReg,
                          Relation);
}

ULONG
TypedData::ConvertToSource(TypedData* Dest)
{
    if (IsArray() || IsUdt())
    {
        // Only allow compound assignment between matching base types.
        if (m_BaseType != Dest->m_BaseType)
        {
            return TYPECONFLICT;
        }
        else
        {
            return NO_ERROR;
        }
    }
    else
    {
        return ConvertTo(Dest);
    }
}

void
TypedData::AvoidUsingImage(ImageInfo* Image)
{
    if (m_Image != Image)
    {
        return;
    }

    ConvertToBestNativeType();
}

ULONG
TypedData::GetAbsoluteAddress(PULONG64 Addr)
{
    ContextSave* Push;

    if (!IsInMemory())
    {
        return IMPLERR;
    }

    if (m_DataSource & TDATA_REGISTER_RELATIVE)
    {
        PCROSS_PLATFORM_CONTEXT ScopeContext = GetCurrentScopeContext();
        if (ScopeContext)
        {
            Push = g_Machine->PushContext(ScopeContext);
        }

        HRESULT Status = g_Machine->
            GetScopeFrameRegister(m_SourceRegister,
                                  &GetCurrentScope()->Frame, Addr);

        if (ScopeContext)
        {
            g_Machine->PopContext(Push);
        }

        if (Status != S_OK)
        {
            return BADREG;
        }

        (*Addr) += m_SourceOffset;
    }
    else if (m_DataSource & TDATA_FRAME_RELATIVE)
    {
        PDEBUG_SCOPE Scope = GetCurrentScope();
        if (Scope->Frame.FrameOffset)
        {
            *Addr = Scope->Frame.FrameOffset + m_SourceOffset;

            PFPO_DATA pFpoData = (PFPO_DATA)Scope->Frame.FuncTableEntry;
            if (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386 &&
                pFpoData &&
                (pFpoData->cbFrame == FRAME_FPO ||
                 pFpoData->cbFrame == FRAME_TRAP))
            {
                // Compensate for FPO's not having ebp
                (*Addr) += sizeof(DWORD);
            }
        }
        else
        {
            ADDR Frame;

            g_Machine->GetFP(&Frame);
            *Addr = Flat(Frame) + m_SourceOffset;
        }
    }
    else if (m_DataSource & TDATA_TLS_RELATIVE)
    {
        if (!m_Image ||
            m_Image->GetTlsIndex() != S_OK)
        {
            return IMPLERR;
        }

        if (g_Process->GetImplicitThreadDataTeb(g_Thread, Addr) != S_OK ||
            g_Target->ReadPointer(g_Process, g_Machine,
                                  *Addr + 11 * (g_Machine->m_Ptr64 ? 8 : 4),
                                  Addr) != S_OK ||
            g_Target->ReadPointer(g_Process, g_Machine,
                                  *Addr + m_Image->m_TlsIndex *
                                  (g_Machine->m_Ptr64 ? 8 : 4),
                                  Addr) != S_OK)
        {
            return MEMORY;
        }

        (*Addr) += m_SourceOffset;
    }
    else
    {
        *Addr = m_SourceOffset;
    }

    return NO_ERROR;
}

ULONG
TypedData::ReadData(TypedDataAccess AllowAccess)
{
    if (IsArray() || IsFunction())
    {
        // Set the pointer value of array and function references
        // to their data address so that simple evaluation of
        // the name results in a value of their address.
        return GetAbsoluteAddress(&m_Ptr);
    }

    ClearData();

    if (AllowAccess == TDACC_NONE ||
        m_DataSource == TDATA_NONE ||
        (!IsDbgNativeType(m_BaseType) && !IsPointer() && !IsEnum()))
    {
        // Data for compound types is not read locally.
        return NO_ERROR;
    }

    if (m_DataSource & TDATA_REGISTER)
    {
        ContextSave* Push;
        PCROSS_PLATFORM_CONTEXT ScopeContext = GetCurrentScopeContext();
        if (ScopeContext)
        {
            Push = g_Machine->PushContext(ScopeContext);
        }

        HRESULT Status = g_Machine->
            GetScopeFrameRegister(m_SourceRegister,
                                  &GetCurrentScope()->Frame, &m_U64);

        if (ScopeContext)
        {
            g_Machine->PopContext(Push);
        }

        if (Status != S_OK)
        {
            return BADREG;
        }
    }
    else
    {
        ULONG Err;
        ULONG64 Addr;

        if (Err = GetAbsoluteAddress(&Addr))
        {
            return Err;
        }

        if (g_Target->
            ReadAllVirtual(g_Process, Addr, &m_U64, m_BaseSize) != S_OK)
        {
            if (AllowAccess == TDACC_REQUIRE)
            {
                return MEMORY;
            }
            else
            {
                m_U64 = 0;
            }
        }

        if (IsPointer() && m_BaseSize == sizeof(m_U32))
        {
            m_Ptr = EXTEND64(m_U32);
        }

        if (IsBitfield())
        {
            // Extract the bitfield bits and discard the others.
            m_U64 = (m_U64 >> m_BitPos) & ((1UI64 << m_BitSize) - 1);
            // If the bitfield is signed, extend the sign
            // bit out as far as necessary.
            if (IsSigned() && (m_U64 & (1UI64 << (m_BitSize - 1))))
            {
                m_U64 |= 0xffffffffffffffffUI64 << m_BitSize;
            }
        }
    }

    //
    // If we're reading the value of the this pointer and
    // the current code has a this-adjust we need to
    // update the value read to account for the adjustment.
    //

    if (m_DataSource & TDATA_THIS_ADJUST)
    {
        ULONG Adjust;

        if (GetThisAdjustForCurrentScope(m_Image->m_Process, &Adjust))
        {
            m_Ptr -= Adjust;
        }
    }

    return NO_ERROR;
}

#define WRITE_BUFFER 1024

ULONG
TypedData::WriteData(TypedData* Source, TypedDataAccess AllowAccess)
{
    ULONG Err;

    if (IsFunction() ||
        (!IsDbgNativeType(m_BaseType) && !IsPointer() && !IsEnum() &&
         !IsArray() && !IsUdt()))
    {
        return TYPECONFLICT;
    }
    if (AllowAccess == TDACC_NONE)
    {
        return NO_ERROR;
    }
    if (m_DataSource == TDATA_NONE)
    {
        return MEMORY;
    }

    if (IsArray() || IsUdt())
    {
        //
        // Implement memory-to-memory copy for compound types.
        // Assume that type harmony has already been verified.
        //

        if (!Source->HasAddress() || !HasAddress())
        {
            return TYPECONFLICT;
        }

        // If the source is the same object there's nothing
        // to do as no data is stored in the TypedData itself.
        if (Source == this)
        {
            return NO_ERROR;
        }

        ULONG64 Src;
        ULONG64 Dst;

        if ((Err = Source->GetAbsoluteAddress(&Src)) ||
            (Err = GetAbsoluteAddress(&Dst)))
        {
            return Err;
        }

        PUCHAR Buffer = new UCHAR[WRITE_BUFFER];
        if (!Buffer)
        {
            return NOMEMORY;
        }

        ULONG Len = m_BaseSize;
        while (Len > 0)
        {
            ULONG Req = Len > WRITE_BUFFER ? WRITE_BUFFER : Len;
            if (g_Target->
                ReadAllVirtual(g_Process, Src, Buffer, Req) != S_OK ||
                g_Target->
                WriteAllVirtual(g_Process, Dst, Buffer, Req) != S_OK)
            {
                delete [] Buffer;
                return MEMORY;
            }

            Src += Req;
            Dst += Req;
            Len -= Req;
        }

        delete [] Buffer;
    }
    else if (m_DataSource & TDATA_REGISTER)
    {
        ContextSave* Push;
        PCROSS_PLATFORM_CONTEXT ScopeContext = GetCurrentScopeContext();
        if (ScopeContext)
        {
            Push = g_Machine->PushContext(ScopeContext);
        }

        HRESULT Status = g_Machine->
            SetScopeFrameRegister(m_SourceRegister,
                                  &GetCurrentScope()->Frame, Source->m_U64);

        if (ScopeContext)
        {
            g_Machine->PopContext(Push);
        }

        if (Status != S_OK)
        {
            return BADREG;
        }
    }
    else if (IsBitfield())
    {
        ULONG64 Data, Mask;
        ULONG64 Addr;

        if (Err = GetAbsoluteAddress(&Addr))
        {
            return Err;
        }

        if (g_Target->
            ReadAllVirtual(g_Process, Addr, &Data, m_BaseSize) != S_OK)
        {
            return MEMORY;
        }

        // Merge the bitfield bits into the surrounding bits.
        Mask = ((1UI64 << m_BitSize) - 1) << m_BitPos;
        Data = (Data & ~Mask) | ((Source->m_U64 << m_BitPos) & Mask);

        if (g_Target->
            WriteAllVirtual(g_Process, Addr, &Data, m_BaseSize) != S_OK)
        {
            return MEMORY;
        }
    }
    else
    {
        ULONG64 Addr;

        if (Err = GetAbsoluteAddress(&Addr))
        {
            return Err;
        }

        if (g_Target->
            WriteAllVirtual(g_Process, Addr,
                            &Source->m_U64, m_BaseSize) != S_OK)
        {
            return MEMORY;
        }
    }

    return NO_ERROR;
}

ULONG
TypedData::GetDataFromVariant(VARIANT* Var)
{
    switch(Var->vt)
    {
    case VT_I1:
    case VT_UI1:
        m_U8 = Var->bVal;
        break;
    case VT_I2:
    case VT_UI2:
        m_U16 = Var->iVal;
        break;
    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_HRESULT:
        m_U32 = Var->lVal;
        break;
    case VT_I8:
    case VT_UI8:
        m_U64 = Var->ullVal;
        break;
    case VT_R4:
        m_F32 = Var->fltVal;
        break;
    case VT_R8:
        m_F64 = Var->dblVal;
        break;
    case VT_BOOL:
        m_Bool = Var->lVal != 0;
        break;
    default:
        return UNIMPLEMENT;
    }

    return NO_ERROR;
}

ULONG
TypedData::CombineTypes(TypedData* Val, TypedDataOp Op)
{
    ULONG Err;

    //
    // This routine computes the resulting type of
    // simple integer and floating-point arithmetic
    // operations as the logic for many of them is
    // similar.  More specific checks and other types
    // are handled elsewhere.
    //
    // Conversions to expected types for later operations
    // is also done as the result type is computed.
    //

    if (IsPointer() || Val->IsPointer())
    {
        return TYPECONFLICT;
    }

    // The result will be large enough to hold either piece of data.
    ULONG Size = max(m_BaseSize, Val->m_BaseSize);

    // If any data is float, non-float data is promoted to float data.
    if (IsFloat() || Val->IsFloat())
    {
        if ((Err = ConvertToF64()) ||
            (Err = Val->ConvertToF64()))
        {
            return Err;
        }

        // Result is float of appropriate size.
        switch(Size)
        {
        case sizeof(m_F32):
            SetToNativeType(DNTYPE_FLOAT32);
            break;
        case sizeof(m_F64):
            SetToNativeType(DNTYPE_FLOAT64);
            break;
        default:
            return IMPLERR;
        }
    }
    else
    {
        BOOL Signed;

        // Only floats and integers can be combined.
        if (!IsInteger() || !Val->IsInteger())
        {
            return TYPECONFLICT;
        }

        Signed = IsSigned() && Val->IsSigned();

        if ((Err = ConvertToU64()) ||
            (Err = Val->ConvertToU64()))
        {
            return Err;
        }

        // Result is an integer of the appropriate sign and size.
        if (Signed)
        {
            switch(Size)
            {
            case sizeof(m_S8):
                SetToNativeType(DNTYPE_INT8);
                break;
            case sizeof(m_S16):
                SetToNativeType(DNTYPE_INT16);
                break;
            case sizeof(m_S32):
                SetToNativeType(DNTYPE_INT32);
                break;
            case sizeof(m_S64):
                SetToNativeType(DNTYPE_INT64);
                break;
            default:
                return IMPLERR;
            }
        }
        else
        {
            switch(Size)
            {
            case sizeof(m_U8):
                SetToNativeType(DNTYPE_UINT8);
                break;
            case sizeof(m_U16):
                SetToNativeType(DNTYPE_UINT16);
                break;
            case sizeof(m_U32):
                SetToNativeType(DNTYPE_UINT32);
                break;
            case sizeof(m_U64):
                SetToNativeType(DNTYPE_UINT64);
                break;
            default:
                return IMPLERR;
            }
        }
    }

    return NO_ERROR;
}

ULONG
TypedData::BinaryArithmetic(TypedData* Val, TypedDataOp Op)
{
    ULONG Err;
    BOOL ThisPtr = IsPointer(), ValPtr = Val->IsPointer();
    ULONG PostScale = 0;

    if (ThisPtr || ValPtr)
    {
        switch(Op)
        {
        case TDOP_ADD:
            // Pointer + integer results in the same type
            // as the original pointer.
            if (!ValPtr)
            {
                if (!m_NextSize || !Val->IsInteger())
                {
                    return TYPECONFLICT;
                }

                // Scale integer by pointer size.
                if (Err = Val->ConvertToU64())
                {
                    return Err;
                }
                Val->m_U64 *= m_NextSize;
            }
            else if (!ThisPtr)
            {
                if (!Val->m_NextSize || !IsInteger())
                {
                    return TYPECONFLICT;
                }

                // Scale integer by pointer size.
                if (Err = ConvertToU64())
                {
                    return Err;
                }
                m_U64 *= Val->m_NextSize;
                CopyType(Val);
            }
            else
            {
                return TYPECONFLICT;
            }
            break;

        case TDOP_SUBTRACT:
            // Pointer - integer results in the same type
            // as the original pointer.
            // Pointer - pointer results in ptrdiff_t.
            if (ThisPtr && Val->IsInteger())
            {
                if (!m_NextSize)
                {
                    return TYPECONFLICT;
                }

                if (Err = Val->ConvertToU64())
                {
                    return Err;
                }
                Val->m_U64 *= m_NextSize;
            }
            else if (ThisPtr && ValPtr)
            {
                // Rather than strictly checking the pointer
                // type we check the size.  This still prevents
                // scale mismatches but avoids problems with
                // generated types not matching their equivalents
                // registered in the PDB.
                if (m_NextSize != Val->m_NextSize || !m_NextSize)
                {
                    return TYPECONFLICT;
                }

                PostScale = m_NextSize;
                SetToNativeType(m_BaseSize == sizeof(ULONG64) ?
                                DNTYPE_INT64 : DNTYPE_INT32);
            }
            else
            {
                return TYPECONFLICT;
            }
            break;

        case TDOP_MULTIPLY:
        case TDOP_DIVIDE:
        case TDOP_REMAINDER:
            return TYPECONFLICT;

        default:
            return IMPLERR;
        }
    }
    else if (Err = CombineTypes(Val, Op))
    {
        return Err;
    }

    if (IsFloat())
    {
        switch(Op)
        {
        case TDOP_ADD:
            m_F64 += Val->m_F64;
            break;
        case TDOP_SUBTRACT:
            m_F64 -= Val->m_F64;
            break;
        case TDOP_MULTIPLY:
            m_F64 *= Val->m_F64;
            break;
        case TDOP_DIVIDE:
            if (Val->m_F64 == 0)
            {
                return OPERAND;
            }
            m_F64 /= Val->m_F64;
            break;
        case TDOP_REMAINDER:
            // There's no floating-remainder operator.
            return TYPECONFLICT;
        default:
            return IMPLERR;
        }

        if (m_BaseSize == sizeof(m_F32))
        {
            m_F32 = (float)m_F64;
            // Clear high bits.
            m_U64 = m_U32;
        }
    }
    else if (IsSigned())
    {
        switch(Op)
        {
        case TDOP_ADD:
            m_S64 += Val->m_S64;
            break;
        case TDOP_SUBTRACT:
            m_S64 -= Val->m_S64;
            break;
        case TDOP_MULTIPLY:
            m_S64 *= Val->m_S64;
            break;
        case TDOP_DIVIDE:
            if (Val->m_S64 == 0)
            {
                return OPERAND;
            }
            m_S64 /= Val->m_S64;
            break;
        case TDOP_REMAINDER:
            if (Val->m_S64 == 0)
            {
                return OPERAND;
            }
            m_S64 %= Val->m_S64;
            break;
        default:
            return IMPLERR;
        }

        if (PostScale)
        {
            m_S64 /= PostScale;
        }
    }
    else
    {
        switch(Op)
        {
        case TDOP_ADD:
            m_U64 += Val->m_U64;
            break;
        case TDOP_SUBTRACT:
            m_U64 -= Val->m_U64;
            break;
        case TDOP_MULTIPLY:
            m_U64 *= Val->m_U64;
            break;
        case TDOP_DIVIDE:
            if (Val->m_U64 == 0)
            {
                return OPERAND;
            }
            m_U64 /= Val->m_U64;
            break;
        case TDOP_REMAINDER:
            if (Val->m_U64 == 0)
            {
                return OPERAND;
            }
            m_U64 %= Val->m_U64;
            break;
        default:
            return IMPLERR;
        }

        if (PostScale)
        {
            m_U64 /= PostScale;
        }
    }

    // The result of this operation is synthesized and no
    // longer has a source.
    ClearAddress();
    return NO_ERROR;
}

ULONG
TypedData::Shift(TypedData* Val, TypedDataOp Op)
{
    ULONG Err;
    PDBG_NATIVE_TYPE Native;

    if (!IsInteger() || !Val->IsInteger())
    {
        return TYPECONFLICT;
    }

    // The result of the shift will always be an native integer
    // of the same signedness and size as the starting value.
    Native = FindNativeTypeByCvBaseType(IsSigned() ? btInt : btUInt,
                                        m_BaseSize);
    if (!Native)
    {
        return IMPLERR;
    }

    if ((Err = ConvertToU64()) ||
        (Err = Val->ConvertToU64()))
    {
        return Err;
    }

    SetToNativeType(DbgNativeTypeId(Native));
    if (IsSigned())
    {
        m_S64 = Op == TDOP_LEFT_SHIFT ?
            (m_S64 << Val->m_U64) : (m_S64 >> Val->m_U64);
    }
    else
    {
        m_U64 = Op == TDOP_LEFT_SHIFT ?
            (m_U64 << Val->m_U64) : (m_U64 >> Val->m_U64);
    }

    // The result of this operation is synthesized and no
    // longer has a source.
    ClearAddress();
    return NO_ERROR;
}

ULONG
TypedData::BinaryBitwise(TypedData* Val, TypedDataOp Op)
{
    ULONG Err;

    if (Err = CombineTypes(Val, Op))
    {
        return Err;
    }

    switch(Op)
    {
    case TDOP_BIT_OR:
        m_U64 |= Val->m_U64;
        break;
    case TDOP_BIT_XOR:
        m_U64 ^= Val->m_U64;
        break;
    case TDOP_BIT_AND:
        m_U64 &= Val->m_U64;
        break;
    default:
        return IMPLERR;
    }

    // The result of this operation is synthesized and no
    // longer has a source.
    ClearAddress();
    return NO_ERROR;
}

ULONG
TypedData::Relate(TypedData* Val, TypedDataOp Op)
{
    ULONG Err;
    BOOL ThisPtr = IsPointer(), ValPtr = Val->IsPointer();

    if (ThisPtr || ValPtr)
    {
        switch(Op)
        {
        case TDOP_EQUAL:
        case TDOP_NOT_EQUAL:
            // Any two pointers can be compared for equality.
            // Pointers can only be compared to pointers.
            // We also allow comparison with integers to make
            // address checks possible without a cast.
            if ((!ThisPtr && !IsInteger()) ||
                (!ValPtr && !Val->IsInteger()))
            {
                return TYPECONFLICT;
            }

            if ((Err = ConvertToU64()) ||
                (Err = Val->ConvertToU64()))
            {
                return Err;
            }
            break;

        case TDOP_LESS:
        case TDOP_LESS_EQUAL:
        case TDOP_GREATER:
        case TDOP_GREATER_EQUAL:
            // Pointers to the same type (size in our case,
            // see SUBTRACT) can be related to one another.
            if (!ThisPtr || !ValPtr ||
                m_NextSize != Val->m_NextSize ||
                !m_NextSize)
            {
                return TYPECONFLICT;
            }

            if ((Err = ConvertToU64()) ||
                (Err = Val->ConvertToU64()))
            {
                return Err;
            }
            break;

        default:
            return IMPLERR;
        }
    }
    else if (m_BaseType == DNTYPE_BOOL)
    {
        // Bool can only be equated to bool.
        if (Val->m_BaseType != DNTYPE_BOOL ||
            (Op != TDOP_EQUAL && Op != TDOP_NOT_EQUAL))
        {
            return TYPECONFLICT;
        }
    }
    else if (Err = CombineTypes(Val, Op))
    {
        return Err;
    }

    if (m_BaseType == DNTYPE_BOOL)
    {
        m_Bool = Op == TDOP_EQUAL ?
            m_Bool == Val->m_Bool : m_Bool != Val->m_Bool;
    }
    else if (IsFloat())
    {
        switch(Op)
        {
        case TDOP_EQUAL:
            m_Bool = m_F64 == Val->m_F64;
            break;
        case TDOP_NOT_EQUAL:
            m_Bool = m_F64 != Val->m_F64;
            break;
        case TDOP_LESS:
            m_Bool = m_F64 < Val->m_F64;
            break;
        case TDOP_GREATER:
            m_Bool = m_F64 > Val->m_F64;
            break;
        case TDOP_LESS_EQUAL:
            m_Bool = m_F64 <= Val->m_F64;
            break;
        case TDOP_GREATER_EQUAL:
            m_Bool = m_F64 >= Val->m_F64;
            break;
        }
    }
    else if (IsSigned())
    {
        switch(Op)
        {
        case TDOP_EQUAL:
            m_Bool = m_S64 == Val->m_S64;
            break;
        case TDOP_NOT_EQUAL:
            m_Bool = m_S64 != Val->m_S64;
            break;
        case TDOP_LESS:
            m_Bool = m_S64 < Val->m_S64;
            break;
        case TDOP_GREATER:
            m_Bool = m_S64 > Val->m_S64;
            break;
        case TDOP_LESS_EQUAL:
            m_Bool = m_S64 <= Val->m_S64;
            break;
        case TDOP_GREATER_EQUAL:
            m_Bool = m_S64 >= Val->m_S64;
            break;
        }
    }
    else
    {
        switch(Op)
        {
        case TDOP_EQUAL:
            m_Bool = m_U64 == Val->m_U64;
            break;
        case TDOP_NOT_EQUAL:
            m_Bool = m_U64 != Val->m_U64;
            break;
        case TDOP_LESS:
            m_Bool = m_U64 < Val->m_U64;
            break;
        case TDOP_GREATER:
            m_Bool = m_U64 > Val->m_U64;
            break;
        case TDOP_LESS_EQUAL:
            m_Bool = m_U64 <= Val->m_U64;
            break;
        case TDOP_GREATER_EQUAL:
            m_Bool = m_U64 >= Val->m_U64;
            break;
        }
    }

    // Clear high bits.
    m_U64 = m_Bool;
    SetToNativeType(DNTYPE_BOOL);

    // The result of this operation is synthesized and no
    // longer has a source.
    ClearAddress();
    return NO_ERROR;
}

ULONG
TypedData::Unary(TypedDataOp Op)
{
    ULONG Err;

    if (IsInteger())
    {
        if (Op == TDOP_NEGATE && !IsSigned())
        {
            return TYPECONFLICT;
        }

        // The result of the op will always be an native integer
        // of the same signedness and size as the starting value.
        PDBG_NATIVE_TYPE Native =
            FindNativeTypeByCvBaseType(IsSigned() ? btInt : btUInt,
                                       m_BaseSize);
        if (!Native)
        {
            return IMPLERR;
        }

        if (Err = ConvertToU64())
        {
            return Err;
        }

        SetToNativeType(DbgNativeTypeId(Native));
        if (Op == TDOP_NEGATE)
        {
            m_S64 = -m_S64;
        }
        else
        {
            m_U64 = ~m_U64;
        }
    }
    else if (Op != TDOP_BIT_NOT && IsFloat())
    {
        switch(m_BaseType)
        {
        case DNTYPE_FLOAT32:
            m_F32 = -m_F32;
            break;
        case DNTYPE_FLOAT64:
            m_F64 = -m_F64;
            break;
        default:
            return IMPLERR;
        }
    }
    else
    {
        return TYPECONFLICT;
    }

    // The result of this operation is synthesized and no
    // longer has a source.
    ClearAddress();
    return NO_ERROR;
}

ULONG
TypedData::ConstIntOp(ULONG64 Val, BOOL Signed, TypedDataOp Op)
{
    PDBG_NATIVE_TYPE Native;
    TypedData TypedVal;

    // Create a constant integer value that has the same
    // size as this value.
    Native = FindNativeTypeByCvBaseType(Signed ? btInt : btUInt, m_BaseSize);
    if (!Native)
    {
        // Not a representable integer size.
        return TYPECONFLICT;
    }

    TypedVal.SetToNativeType(DbgNativeTypeId(Native));
    TypedVal.m_U64 = Val;
    TypedVal.ClearAddress();

    switch(Op)
    {
    case TDOP_ADD:
    case TDOP_SUBTRACT:
    case TDOP_MULTIPLY:
    case TDOP_DIVIDE:
    case TDOP_REMAINDER:
        return BinaryArithmetic(&TypedVal, Op);
    case TDOP_LEFT_SHIFT:
    case TDOP_RIGHT_SHIFT:
        return Shift(&TypedVal, Op);
    case TDOP_BIT_OR:
    case TDOP_BIT_XOR:
    case TDOP_BIT_AND:
        return BinaryBitwise(&TypedVal, Op);
    default:
        return IMPLERR;
    }
}

ULONG
TypedData::FindBaseType(PULONG Type, PULONG Tag)
{
    PDBG_NATIVE_TYPE Native;
    ULONG64 Size;
    ULONG CvBase;

    // Internal types aren't typedef'd so the base type
    // is the same as the type.
    if (IsDbgNativeType(*Type) || IsDbgGeneratedType(*Type))
    {
        return NO_ERROR;
    }

    for (;;)
    {
#if DBG_BASE_SEARCH
        dprintf("  Base search type %x, tag %x\n", *Type, *Tag);
#endif

        switch(*Tag)
        {
        case SymTagBaseType:
            if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                *Type, TI_GET_LENGTH, &Size) ||
                !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                *Type, TI_GET_BASETYPE, &CvBase) ||
                !(Native = FindNativeTypeByCvBaseType(CvBase, (ULONG)Size)))
            {
                return TYPEDATA;
            }
            *Type = DbgNativeTypeId(Native);
            return NO_ERROR;

        case SymTagTypedef:
            if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                *Type, TI_GET_TYPEID, Type) ||
                !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                *Type, TI_GET_SYMTAG, Tag))
            {
                return TYPEDATA;
            }
            // Loop with new type and tag.
            break;

        case SymTagUDT:
        case SymTagEnum:
        case SymTagPointerType:
        case SymTagFunctionType:
        case SymTagArrayType:
            return NO_ERROR;

        default:
            return UNIMPLEMENT;
        }
    }

    return UNIMPLEMENT;
}

ULONG
TypedData::GetTypeLength(ULONG Type, PULONG Length)
{
    ULONG64 Size64;

    // XXX drewb - Can a type really have a size greater than 32 bits?
    if (IsDbgNativeType(Type))
    {
        PDBG_NATIVE_TYPE Native = DbgNativeTypeEntry(Type);
        *Length = Native->Size;
    }
    else if (IsDbgGeneratedType(m_Type))
    {
        PDBG_GENERATED_TYPE GenType = g_GenTypes.FindById(m_Type);
        if (!GenType)
        {
            *Length = 0;
            return TYPEDATA;
        }

        *Length = GenType->Size;
    }
    else if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                             m_Image->m_BaseOfImage,
                             Type, TI_GET_LENGTH, &Size64))
    {
        *Length = 0;
        return TYPEDATA;
    }
    else
    {
        *Length = (ULONG)Size64;
    }

    return NO_ERROR;
}

ULONG
TypedData::GetTypeTag(ULONG Type, PULONG Tag)
{
    if (IsDbgNativeType(Type))
    {
        *Tag = DbgNativeTypeEntry(Type)->CvTag;
        return NO_ERROR;
    }
    else if (IsDbgGeneratedType(Type))
    {
        PDBG_GENERATED_TYPE GenType = g_GenTypes.FindById(Type);
        if (!GenType)
        {
            return TYPEDATA;
        }

        *Tag = GenType->Tag;
        return NO_ERROR;
    }
    else
    {
        return SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                              m_Image->m_BaseOfImage,
                              Type, TI_GET_SYMTAG, Tag) ?
            NO_ERROR : TYPEDATA;
    }
}

ULONG
TypedData::IsBaseClass(ULONG Udt, ULONG BaseUdt, PLONG Adjust)
{
    ULONG Tag;
    ULONG NumMembers;

    // BaseUdt may not be a base of Udt so default
    // the adjustment to zero.
    *Adjust = 0;

    if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                        m_Image->m_BaseOfImage,
                        Udt, TI_GET_CHILDRENCOUNT, &NumMembers))
    {
        return NOTMEMBER;
    }
    if (NumMembers == 0)
    {
        // Can't possibly be a match.
        return NOTMEMBER;
    }

    TI_FINDCHILDREN_PARAMS* Members = (TI_FINDCHILDREN_PARAMS*)
        malloc(sizeof(*Members) + sizeof(ULONG) * NumMembers);
    if (!Members)
    {
        return NOMEMORY;
    }

    Members->Count = NumMembers;
    Members->Start = 0;
    if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                        m_Image->m_BaseOfImage,
                        Udt, TI_FINDCHILDREN, Members))
    {
        free(Members);
        return TYPEDATA;
    }

    ULONG i;

    for (i = 0; i < NumMembers; i++)
    {
        LONG CheckAdjust;
        BOOL IsVirtBase;
        BOOL NameMatch;
        BSTR BaseName1, BaseName2;

        if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Members->ChildId[i], TI_GET_SYMTAG, &Tag) ||
            Tag != SymTagBaseClass ||
            !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Members->ChildId[i], TI_GET_VIRTUALBASECLASS,
                            &IsVirtBase))
        {
            continue;
        }
        if (IsVirtBase)
        {
            // Apparently the VC debugger goes and examines vtables
            // and tries to derive adjusts from the functions in
            // the vtables.  This can't be very common, so just
            // fail for now.
            free(Members);
            ErrOut("Virtual base class casts not implemented");
            return UNIMPLEMENT;
        }
        if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Members->ChildId[i], TI_GET_OFFSET,
                            &CheckAdjust) ||
            !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Members->ChildId[i], TI_GET_SYMNAME, &BaseName1))
        {
            continue;
        }
        if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            BaseUdt, TI_GET_SYMNAME, &BaseName2))
        {
            LocalFree(BaseName1);
            continue;
        }

        NameMatch = wcscmp(BaseName1, BaseName2) == 0;

        LocalFree(BaseName1);
        LocalFree(BaseName2);

        if (NameMatch)
        {
            *Adjust = CheckAdjust;
            break;
        }
    }

    free(Members);
    return i < NumMembers ? NO_ERROR : NOTMEMBER;
}

ULONG
TypedData::EstimateChildrenCounts(ULONG Flags,
                                  PULONG ChildUsed, PULONG NameUsed)
{
    BOOL Udt = IsUdt();
    ULONG Type = m_BaseType;

    if (IsPointer())
    {
        ULONG Tag;

        if (Type == DNTYPE_PTR_FUNCTION32 ||
            Type == DNTYPE_PTR_FUNCTION64)
        {
            // Function pointers don't have children.
            *ChildUsed = 0;
            *NameUsed = 0;
            return NO_ERROR;
        }

        if ((Flags & CHLF_DEREF_UDT_POINTERS) &&
            m_Image &&
            SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                           m_Image->m_BaseOfImage,
                           m_NextType, TI_GET_SYMTAG, &Tag) &&
            Tag == SymTagUDT)
        {
            Udt = TRUE;
            Type = m_NextType;
            // Fall into UDT case below.
        }
        else
        {
            *ChildUsed = 1;
            *NameUsed = 2;
            return NO_ERROR;
        }
    }
    else if (IsArray())
    {
        if (m_NextSize)
        {
            *ChildUsed = m_BaseSize / m_NextSize;
            if (*ChildUsed > ARRAY_CHILDREN_LIMIT)
            {
                *ChildUsed = ARRAY_CHILDREN_LIMIT;
            }
            *NameUsed = ARRAY_LIMIT_CHARS * (*ChildUsed);
        }
        else
        {
            *ChildUsed = 0;
            *NameUsed = 0;
        }

        return NO_ERROR;
    }

    // Udt may be set in the pointer case also so don't else-if.
    if (Udt)
    {
        ULONG NumMembers;

        // Guess based on the number of members.
        if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Type, TI_GET_CHILDRENCOUNT, &NumMembers))
        {
            return TYPEDATA;
        }
        if (NumMembers == 0)
        {
            *ChildUsed = 0;
            *NameUsed = 0;
        }
        else
        {
            *ChildUsed = NumMembers;
            *NameUsed = 25 * NumMembers;
        }

        return NO_ERROR;
    }

    // Nothing else has children.
    *ChildUsed = 0;
    *NameUsed = 0;
    return NO_ERROR;
}

ULONG
TypedData::GetPointerChildren(ULONG PtrSize, ULONG Flags,
                              GetChildrenCb Callback, PVOID Context)
{
    ULONG Err;
    TypedData Child;

    if (m_BaseType == DNTYPE_PTR_FUNCTION32 ||
        m_BaseType == DNTYPE_PTR_FUNCTION64)
    {
        // Function pointers don't have children.
        return NO_ERROR;
    }

    //
    // Pointers can have one child, the pointed-to object,
    // or UDT pointers can present the UDT children for
    // simple pointer-to-struct expansion.
    //

    Child.m_Image = m_Image;
    Child.m_NextType = m_NextType;
    Child.m_Ptr = m_Ptr;
    if (Err = Child.ConvertToDereference((Flags & CHLF_DISALLOW_ACCESS) == 0 ?
                                         TDACC_REQUIRE : TDACC_NONE,
                                         PtrSize))
    {
        return Err;
    }

    if ((Flags & CHLF_DEREF_UDT_POINTERS) &&
        Child.IsUdt())
    {
        return Child.GetUdtChildren(PtrSize, Flags, Callback, Context);
    }
    else
    {
        return Callback(Context, "*", &Child);
    }
}

ULONG
TypedData::GetArrayChildren(ULONG PtrSize, ULONG Flags,
                            GetChildrenCb Callback, PVOID Context)
{
    ULONG Elts;

    //
    // The elements of an array are its children.
    //

    if (!m_NextSize)
    {
        return NO_ERROR;
    }

    // Limit array dumps to prevent large arrays from hogging space.
    Elts = m_BaseSize / m_NextSize;
    if (Elts > ARRAY_CHILDREN_LIMIT)
    {
        Elts = ARRAY_CHILDREN_LIMIT;
    }

    ULONG Err, i;
    TypedData Child;
    char Name[ARRAY_LIMIT_CHARS];

    for (i = 0; i < Elts; i++)
    {
        //
        // Array children are simply individual members
        // of the parent data area so the data source is
        // the same, just offset.  We can't use a normal
        // ConvertToDereference for this as dereferencing
        // assumes pointer chasing, not simple offsetting.
        //

        Child.m_Image = m_Image;
        Child.m_Type = m_NextType;
        if (Err = Child.FindTypeInfo(TRUE, PtrSize))
        {
            return Err;
        }
        Child.SetDataSource(m_DataSource & ~TDATA_THIS_ADJUST,
                            m_SourceOffset + i * m_NextSize,
                            m_SourceRegister);
        if (Err = Child.ReadData((Flags & CHLF_DISALLOW_ACCESS) == 0 ?
                                 TDACC_REQUIRE : TDACC_NONE))
        {
            return Err;
        }

        sprintf(Name, "[%d]", i);

        if (Err = Callback(Context, Name, &Child))
        {
            return Err;
        }
    }

    return NO_ERROR;
}

ULONG
TypedData::GetUdtChildren(ULONG PtrSize, ULONG Flags,
                          GetChildrenCb Callback, PVOID Context)
{
    ULONG Err, i;
    ULONG NumMembers;

    //
    // The members of a UDT are its children.
    //

    if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                        m_Image->m_BaseOfImage,
                        m_BaseType, TI_GET_CHILDRENCOUNT, &NumMembers))
    {
        return TYPEDATA;
    }
    if (NumMembers == 0)
    {
        return NO_ERROR;
    }

    TI_FINDCHILDREN_PARAMS* Members = (TI_FINDCHILDREN_PARAMS*)
        malloc(sizeof(*Members) + sizeof(ULONG) * NumMembers);
    if (!Members)
    {
        return NOMEMORY;
    }

    Members->Count = NumMembers;
    Members->Start = 0;
    if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                        m_Image->m_BaseOfImage,
                        m_BaseType, TI_FINDCHILDREN, Members))
    {
        Err = TYPEDATA;
        goto EH_Members;
    }

    TypedData Child;

    for (i = 0; i < NumMembers; i++)
    {
        ULONG Tag, Type;
        DataKind Relation;

        if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Members->ChildId[i], TI_GET_SYMTAG, &Tag) ||
            !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            Members->ChildId[i], TI_GET_TYPEID, &Type))
        {
            continue;
        }

        if (Tag == SymTagBaseClass)
        {
            // Treat base classes like members of the base class type.
            Relation = DataIsMember;
        }
        else if (Tag == SymTagVTable)
        {
            ULONG Count;

            // A special artificial array of function pointers member
            // is added for vtables.
            Relation = DataIsMember;
            if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                Type, TI_GET_TYPEID, &Type) ||
                !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                Type, TI_GET_COUNT, &Count))
            {
                Err = TYPEDATA;
                goto EH_Members;
            }

            PDBG_GENERATED_TYPE GenType =
                g_GenTypes.FindOrCreateByAttrs(m_Image->m_BaseOfImage,
                                               SymTagArrayType,
                                               PtrSize == 4 ?
                                               DNTYPE_PTR_FUNCTION32 :
                                               DNTYPE_PTR_FUNCTION64,
                                               Count * PtrSize);
            if (!GenType)
            {
                Err = NOMEMORY;
                goto EH_Members;
            }

            Type = GenType->TypeId;
        }
        else if (Tag != SymTagData ||
                 !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                 m_Image->m_BaseOfImage,
                                 Members->ChildId[i],
                                 TI_GET_DATAKIND, &Relation) ||
                 (Relation != DataIsMember &&
                  Relation != DataIsStaticMember &&
                  Relation != DataIsGlobal))
        {
            continue;
        }

        if (Err = Child.SetToUdtMember((Flags & CHLF_DISALLOW_ACCESS) == 0 ?
                                       TDACC_REQUIRE : TDACC_NONE,
                                       PtrSize, m_Image,
                                       Members->ChildId[i], Type, Tag,
                                       m_DataSource & ~TDATA_THIS_ADJUST,
                                       m_SourceOffset,
                                       m_SourceRegister, Relation))
        {
            goto EH_Members;
        }

        BSTR Name;
        PSTR Ansi;

        if (Tag == SymTagVTable)
        {
            ULONG64 Ptr;

            // We need to update the data address for the
            // vtable array from the offset in the class to
            // the array's location in memory.
            if (Child.GetAbsoluteAddress(&Ptr) != NO_ERROR ||
                g_Target->
                ReadAllVirtual(g_Process, Ptr, &Ptr, PtrSize) != S_OK)
            {
                Ptr = 0;
            }
            else if (PtrSize == sizeof(m_U32))
            {
                Ptr = EXTEND64(Ptr);
            }

            Child.SetDataSource(TDATA_MEMORY, Ptr, 0);

            Ansi = "__vfptr";
        }
        else
        {
            if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                Members->ChildId[i], TI_GET_SYMNAME, &Name))
            {
                Err = TYPEDATA;
                goto EH_Members;
            }

            if (WideToAnsi(Name, &Ansi) != S_OK)
            {
                Err = NOMEMORY;
                LocalFree(Name);
                goto EH_Members;
            }

            LocalFree(Name);
        }

        Err = Callback(Context, Ansi, &Child);

        if (Tag != SymTagVTable)
        {
            FreeAnsi(Ansi);
        }

        if (Err)
        {
            goto EH_Members;
        }
    }

    Err = NO_ERROR;

 EH_Members:
    free(Members);
    return Err;
}

ULONG
TypedData::GetChildren(ULONG PtrSize, ULONG Flags,
                       GetChildrenCb Callback, PVOID Context)
{
    if (IsPointer())
    {
        return GetPointerChildren(PtrSize, Flags, Callback, Context);
    }
    else if (IsArray())
    {
        return GetArrayChildren(PtrSize, Flags, Callback, Context);
    }
    else if (IsUdt())
    {
        return GetUdtChildren(PtrSize, Flags, Callback, Context);
    }
    else
    {
        // Nothing else has children.
        return NO_ERROR;
    }
}

struct GetAllChildrenContext
{
    ULONG ChildAvail;
    TypedData* Children;
    ULONG ChildUsed;
    ULONG NameAvail;
    PSTR Names;
    ULONG NameUsed;
};

ULONG
TypedData::GetAllChildrenCb(PVOID _Context, PSTR Name, TypedData* Child)
{
    GetAllChildrenContext* Context = (GetAllChildrenContext*)_Context;
    ULONG Len;

    if (Context->ChildUsed < Context->ChildAvail)
    {
        Context->Children[Context->ChildUsed] = *Child;
    }
    Context->ChildUsed++;

    Len = strlen(Name) + 1;
    if (Context->NameUsed + Len <= Context->NameAvail)
    {
        memcpy(Context->Names + Context->NameUsed, Name, Len);
    }
    Context->NameUsed += Len;

    return NO_ERROR;
}

ULONG
TypedData::GetAllChildren(ULONG PtrSize, ULONG Flags,
                          PULONG NumChildrenRet,
                          TypedData** ChildrenRet,
                          PSTR* NamesRet)
{
    ULONG Err;
    GetAllChildrenContext Context;

    //
    // First get an estimate of how much space will be needed.
    //

    if (Err = EstimateChildrenCounts(Flags, &Context.ChildAvail,
                                     &Context.NameAvail))
    {
        return Err;
    }

    if (Context.ChildAvail == 0)
    {
        // No children, we're done.
        *NumChildrenRet = 0;
        *ChildrenRet = NULL;
        *NamesRet = NULL;
        return NO_ERROR;
    }

    for (;;)
    {
        // Allocate the requested amount of memory.
        Context.Children = (TypedData*)
            malloc(Context.ChildAvail * sizeof(*Context.Children));
        Context.Names = (PSTR)
            malloc(Context.NameAvail * sizeof(*Context.Names));
        if (!Context.Children || !Context.Names)
        {
            if (Context.Children)
            {
                free(Context.Children);
            }
            if (Context.Names)
            {
                free(Context.Names);
            }
            return NOMEMORY;
        }

        Context.ChildUsed = 0;
        Context.NameUsed = 0;
        if (Err = GetChildren(PtrSize, Flags, GetAllChildrenCb, &Context))
        {
            return Err;
        }

        if (Context.ChildUsed <= Context.ChildAvail &&
            Context.NameUsed <= Context.NameAvail)
        {
            break;
        }

        // Not enough space, try again with the recomputed sizes.
        free(Context.Children);
        free(Context.Names);
        Context.ChildAvail = Context.ChildUsed;
        Context.NameAvail = Context.NameUsed;
    }

    *NumChildrenRet = Context.ChildUsed;

    //
    // Trim back excess memory if there's a lot extra.
    //

    if (Context.ChildUsed + (512 / sizeof(*Context.Children)) <
        Context.ChildAvail)
    {
        *ChildrenRet = (TypedData*)
            realloc(Context.Children, Context.ChildUsed *
                    sizeof(*Context.Children));
        if (!*ChildrenRet)
        {
            free(Context.Children);
            free(Context.Names);
            return NOMEMORY;
        }

        Context.Children = *ChildrenRet;
    }
    else
    {
        *ChildrenRet = Context.Children;
    }

    if (Context.NameUsed + (512 / sizeof(*Context.Names)) <
        Context.NameAvail)
    {
        *NamesRet = (PSTR)
            realloc(Context.Names, Context.NameUsed *
                    sizeof(*Context.Names));
        if (!*NamesRet)
        {
            free(Context.Children);
            free(Context.Names);
            return NOMEMORY;
        }

        Context.Names = *NamesRet;
    }
    else
    {
        *NamesRet = Context.Names;
    }

    return NO_ERROR;
}

ULONG
TypedData::FindType(ProcessInfo* Process, PCSTR Type, ULONG PtrSize)
{
    if (!Process)
    {
        return BADPROCESS;
    }
            
    ULONG Err;
    SYM_DUMP_PARAM_EX TypedDump = {0};
    TYPES_INFO TypeInfo = {0};

    TypedDump.size = sizeof(TypedDump);
    TypedDump.sName = (PUCHAR)Type;
    TypedDump.Options = DBG_DUMP_NO_PRINT;

    if (Err = TypeInfoFound(Process->m_SymHandle,
                            Process->m_ImageHead,
                            &TypedDump,
                            &TypeInfo))
    {
        return VARDEF;
    }

    // Image may be NULL for base types.
    m_Image = Process->FindImageByOffset(TypeInfo.ModBaseAddress, FALSE);

    m_Type = TypeInfo.TypeIndex;
    ClearAddress();
    return FindTypeInfo(TRUE, PtrSize);
}

ULONG
TypedData::FindSymbol(ProcessInfo* Process, PSTR Symbol,
                      TypedDataAccess AllowAccess, ULONG PtrSize)
{
    if (!Process)
    {
        return BADPROCESS;
    }
            
    SYMBOL_INFO SymInfo = {0};

    if (!SymFromName(Process->m_SymHandle, Symbol, &SymInfo))
    {
        // If the name doesn't resolve on it's own and there's
        // a this pointer for the current scope see if this
        // symbol is a member of the this object.
        if (strcmp(Symbol, "this") &&
            !strchr(Symbol, '!') &&
            GetCurrentScopeThisData(this) == NO_ERROR)
        {
            return ConvertToMember(Symbol, AllowAccess, PtrSize);
        }

        return VARDEF;
    }

    return SetToSymbol(Process, Symbol, &SymInfo, AllowAccess, PtrSize);
}

ULONG
TypedData::SetToSymbol(ProcessInfo* Process,
                       PSTR Symbol, PSYMBOL_INFO SymInfo,
                       TypedDataAccess AllowAccess, ULONG PtrSize)
{
    if (!Process)
    {
        return BADPROCESS;
    }
            
    ULONG Err;

    m_Image = Process->FindImageByOffset(SymInfo->ModBase, FALSE);
    if (!m_Image)
    {
        return IMPLERR;
    }

    m_Type = SymInfo->TypeIndex;
    if (Err = FindTypeInfo(FALSE, PtrSize))
    {
        return Err;
    }

    if (SymInfo->Flags & SYMFLAG_CONSTANT)
    {
        PSTR Tail;
        VARIANT Val;
        SYMBOL_INFO ConstSym = {0};

        // Look up the constant's value.
        Tail = strchr(Symbol, '!');
        if (!Tail)
        {
            Tail = Symbol;
        }
        else
        {
            Tail++;
        }
        if (!SymGetTypeFromName(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage, Tail, &ConstSym) ||
            !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            ConstSym.TypeIndex, TI_GET_VALUE, &Val))
        {
            return TYPEDATA;
        }

        ClearData();
        if (Err = GetDataFromVariant(&Val))
        {
            return Err;
        }
        ClearAddress();
    }
    else
    {
        if (SymInfo->Flags & SYMFLAG_REGISTER)
        {
            SetDataSource(TDATA_REGISTER, 0, m_Image->
                          CvRegToMachine((CV_HREG_e)SymInfo->Register));
        }
        else if (SymInfo->Flags & SYMFLAG_REGREL)
        {
            SetDataSource(TDATA_REGISTER_RELATIVE, SymInfo->Address, m_Image->
                          CvRegToMachine((CV_HREG_e)SymInfo->Register));
        }
        else if (SymInfo->Flags & SYMFLAG_FRAMEREL)
        {
            SetDataSource(TDATA_FRAME_RELATIVE, SymInfo->Address, 0);
        }
        else if (SymInfo->Flags & SYMFLAG_TLSREL)
        {
            SetDataSource(TDATA_TLS_RELATIVE, SymInfo->Address, 0);
        }
        else
        {
            SetDataSource(TDATA_MEMORY, SymInfo->Address, 0);
        }

        //
        // If we're representing "this" we need to see if
        // there's a this-adjust for the current code so
        // that we can offset the raw value to get the true
        // this value.
        //

        ULONG Adjust;

        if (!strcmp(Symbol, "this") &&
            GetThisAdjustForCurrentScope(Process, &Adjust) &&
            Adjust)
        {
            m_DataSource |= TDATA_THIS_ADJUST;
        }

        // Fetch in the actual data if necessary.
        return ReadData(AllowAccess);
    }

    return NO_ERROR;
}

ULONG
TypedData::FindTypeInfo(BOOL RequireType, ULONG PtrSize)
{
    ULONG Err;
    PDBG_NATIVE_TYPE Native = NULL;
    PDBG_GENERATED_TYPE GenType = NULL;

    if (IsDbgNativeType(m_Type))
    {
        Native = DbgNativeTypeEntry(m_Type);
        m_BaseType = m_Type;
        m_BaseTag = (USHORT)Native->CvTag;
    }
    else if (IsDbgGeneratedType(m_Type))
    {
        GenType = g_GenTypes.FindById(m_Type);
        if (!GenType)
        {
            return TYPEDATA;
        }

        // Generated types aren't typedef'd so the base type
        // is the same as the type.
        m_BaseType = GenType->TypeId;
        m_BaseTag = (USHORT)GenType->Tag;
    }
    else
    {
        if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                            m_Image->m_BaseOfImage,
                            m_Type, TI_GET_SYMTAG, &m_BaseTag))
        {
            return TYPEDATA;
        }

        if (RequireType &&
            !(m_BaseTag == SymTagUDT ||
              m_BaseTag == SymTagEnum ||
              m_BaseTag == SymTagFunctionType ||
              m_BaseTag == SymTagPointerType ||
              m_BaseTag == SymTagArrayType ||
              m_BaseTag == SymTagBaseType ||
              m_BaseTag == SymTagTypedef))
        {
            return NOTMEMBER;
        }

        ULONG Tag = m_BaseTag;
        m_BaseType = m_Type;
        if (Err = FindBaseType(&m_BaseType, &Tag))
        {
            return Err;
        }
        m_BaseTag = (USHORT)Tag;
    }

    m_NextType = 0;
    m_NextSize = 0;

    // Native pointer types are not filled out here
    // as they require context-sensitive information.
    if ((m_BaseTag == SymTagPointerType && !Native) ||
        m_BaseTag == SymTagArrayType)
    {
        ULONG NextTag=-1;

        //
        // For some types we need to look up the
        // child type and its size.
        //

        if (GenType)
        {
            m_NextType = GenType->ChildId;
        }
        else
        {
            if (!SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                m_BaseType, TI_GET_TYPEID, &m_NextType) ||
                !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                m_Image->m_BaseOfImage,
                                m_NextType, TI_GET_SYMTAG, &NextTag))
            {
                return TYPEDATA;
            }
            if (Err = FindBaseType(&m_NextType, &NextTag))
            {
                return Err;
            }
        }

        if (NextTag == SymTagFunctionType)
        {
            m_NextSize = PtrSize;
        }
        else if (Err = GetTypeLength(m_NextType, &m_NextSize))
        {
            return Err;
        }
    }

    if (m_BaseTag == SymTagFunctionType)
    {
        // Functions do not have a length.  Set
        // their size to a pointer size for
        // function pointer values recovered with
        // a bare function name.
        m_BaseSize = PtrSize;
        return NO_ERROR;
    }
    else
    {
        return GetTypeLength(m_BaseType, &m_BaseSize);
    }
}

void
TypedData::OutputSimpleValue(void)
{
    HANDLE Process;
    ULONG64 ModBase;
    ULONG64 Addr;
    BSTR Name;

    if (m_Image)
    {
        Process = m_Image->m_Process->m_SymHandle;
        ModBase = m_Image->m_BaseOfImage;
    }
    else
    {
        Process = NULL;
        ModBase = 0;
    }

    switch(m_BaseTag)
    {
    case SymTagBaseType:
        OutputNativeValue();
        break;
    case SymTagPointerType:
    case SymTagFunctionType:
        dprintf("0x%s", FormatAddr64(m_Ptr));
        if (m_BaseType == DNTYPE_PTR_FUNCTION32 ||
            m_BaseType == DNTYPE_PTR_FUNCTION64)
        {
            dprintf(" ");
            OutputSymbolAndInfo(m_Ptr);
        }
        else
        {
            PrintStringIfString(Process, ModBase, 0, 0,
                                m_NextType, m_Ptr, 0);
        }
        break;
    case SymTagArrayType:
        if (GetAbsoluteAddress(&Addr) != NO_ERROR)
        {
            Addr = 0;
        }
        if (m_NextType == DNTYPE_PTR_FUNCTION32 ||
            m_NextType == DNTYPE_PTR_FUNCTION64)
        {
            dprintf("0x%s ", FormatAddr64(Addr));
            OutputSymbolAndInfo(Addr);
            break;
        }
        else
        {
            OutputType();
            PrintStringIfString(Process, ModBase, 0, 0,
                                m_NextType, Addr, 0);
        }
        break;
    case SymTagUDT:
        OutputType();

        // Dump known structs.
        if (Process &&
            GetAbsoluteAddress(&Addr) == NO_ERROR &&
            SymGetTypeInfo(Process, ModBase,
                           m_Type, TI_GET_SYMNAME, &Name))
        {
            CHAR AnsiName[MAX_NAME];

            PrintString(AnsiName, DIMA(AnsiName), "%ws", Name);
            DumpKnownStruct(AnsiName, 0, Addr, NULL);
            LocalFree(Name);
        }
        break;
    case SymTagEnum:
        OutputEnumValue();
        break;
    default:
        dprintf("<%I64x>\n", m_U64);
        break;
    }
}

void
TypedData::OutputTypeAndValue(void)
{
    HANDLE Process;
    ULONG64 ModBase;
    ULONG64 Addr;

    if (m_Image)
    {
        Process = m_Image->m_Process->m_SymHandle;
        ModBase = m_Image->m_BaseOfImage;
    }
    else
    {
        Process = NULL;
        ModBase = 0;
    }

    if (GetAbsoluteAddress(&Addr) != NO_ERROR)
    {
        Addr = 0;
    }

    OutputType();
    switch(m_BaseTag)
    {
    case SymTagBaseType:
        dprintf(" ");
        OutputNativeValue();
        dprintf("\n");
        break;
    case SymTagPointerType:
        dprintf("0x%s\n", FormatAddr64(m_Ptr));
        if (PrintStringIfString(Process, ModBase, 0, 0,
                                m_NextType, m_Ptr, 0))
        {
            dprintf("\n");
        }
        break;
    case SymTagArrayType:
        dprintf(" 0x%s\n", FormatAddr64(Addr));
        OutputTypeByIndex(Process, ModBase, m_NextType, Addr);
        break;
    case SymTagUDT:
        dprintf("\n");
        OutputTypeByIndex(Process, ModBase, m_BaseType, Addr);
        break;
    case SymTagEnum:
        dprintf(" ");
        OutputEnumValue();
        dprintf("\n");
        break;
    case SymTagFunctionType:
        dprintf(" 0x%s\n", FormatAddr64(m_U64));
        OutputTypeByIndex(Process, ModBase, m_BaseType, Addr);
        break;
    default:
        dprintf(" <%I64x>\n", m_U64);
        break;
    }
}

#define DEC_PTR ((ULONG64)-1)

ULONG
TypedData::OutputFundamentalType(ULONG Type, ULONG BaseType, ULONG BaseTag,
                                 PULONG64 Decorations, ULONG NumDecorations)
{
    if (IsDbgNativeType(Type))
    {
        switch(Type)
        {
        case DNTYPE_PTR_FUNCTION32:
        case DNTYPE_PTR_FUNCTION64:
            dprintf("__fptr()");
            break;
        default:
            dprintf(DbgNativeTypeEntry(Type)->TypeName);
            break;
        }
        return 0;
    }
    else
    {
        BSTR Name;
        PDBG_GENERATED_TYPE GenType;
        BOOL Ptr;
        ULONG64 ArraySize;
        ULONG EltSize;

        if (IsDbgGeneratedType(Type))
        {
            GenType = g_GenTypes.FindById(Type);
            if (!GenType)
            {
                dprintf("<gentype %x>", Type);
                return 0;
            }
        }
        else
        {
            UdtKind UdtK;

            if (Type == BaseType &&
                BaseTag == SymTagUDT &&
                m_Image &&
                SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                               m_Image->m_BaseOfImage,
                               BaseType, TI_GET_UDTKIND, &UdtK))
            {
                switch(UdtK)
                {
                case UdtStruct:
                    dprintf("struct ");
                    break;
                case UdtClass:
                    dprintf("class ");
                    break;
                case UdtUnion:
                    dprintf("union ");
                    break;
                }
            }

            if (m_Image &&
                SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                               m_Image->m_BaseOfImage,
                               Type, TI_GET_SYMNAME, &Name))
            {
                dprintf("%ws", Name);
                LocalFree(Name);
                return 0;
            }

            GenType = NULL;
        }

        switch(BaseTag)
        {
        case SymTagBaseType:
            dprintf(DbgNativeTypeEntry(BaseType)->TypeName);
            return 0;
        case SymTagPointerType:
        case SymTagArrayType:
            Ptr = BaseTag == SymTagPointerType;
            if (GenType)
            {
                Type = GenType->ChildId;
                BaseType = Type;
                if (GetTypeTag(BaseType, &BaseTag))
                {
                    dprintf("<type %x>", Type);
                    return 0;
                }

                if (!Ptr)
                {
                    ArraySize = GenType->Size;
                }
            }
            else if (!m_Image)
            {
                dprintf("<%s %x>", Ptr ? "pointer" : "array", Type);
            }
            else
            {
                if ((!Ptr &&
                     !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                     m_Image->m_BaseOfImage,
                                     BaseType, TI_GET_LENGTH, &ArraySize)) ||
                    !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                    m_Image->m_BaseOfImage,
                                    BaseType, TI_GET_TYPEID, &Type) ||
                    !(BaseType = Type) ||
                    !SymGetTypeInfo(m_Image->m_Process->m_SymHandle,
                                    m_Image->m_BaseOfImage,
                                    BaseType, TI_GET_SYMTAG, &BaseTag) ||
                    FindBaseType(&BaseType, &BaseTag))
                {
                    dprintf("<type %x>", Type);
                    return 0;
                }
            }

            if (!NumDecorations)
            {
                dprintf("<ERROR: decoration overflow>");
                return 0;
            }
            
            if (Ptr)
            {
                *Decorations++ = DEC_PTR;
            }
            else
            {
                if (!ArraySize ||
                    GetTypeLength(BaseType, &EltSize) ||
                    !EltSize)
                {
                    *Decorations++ = 0;
                }
                else
                {
                    *Decorations++ = ArraySize / EltSize;
                }
            }
            
            return OutputFundamentalType(Type, BaseType, BaseTag,
                                         Decorations, --NumDecorations) + 1;
        case SymTagFunctionType:
            dprintf("Function");
            return 0;
        default:
            dprintf("<unnamed %x>", Type);
            return 0;
        }
    }
}

void
TypedData::OutputType(void)
{
    ULONG64 Decorations[32];
    ULONG NumDecorations;
    ULONG i;
    PULONG64 Dec;

    // First walk into the type structure all the way to
    // the fundamental type and output that type name.
    // Along the way, collection any decorations such as
    // pointer or array levels.
    NumDecorations = OutputFundamentalType(m_Type, m_BaseType, m_BaseTag,
                                           Decorations, DIMA(Decorations));
    if (!NumDecorations)
    {
        // No decorations so we're done.
        return;
    }

    dprintf(" ");

    //
    // First we need to output * for each pointer decoration.
    // Pointer decorations nest right-to-left, so start at
    // the deepest decoration and work outward.
    // In order to properly handle precedence between pointers
    // and arrays we have to insert parentheses when we
    // see a transition between an array and a pointer.
    //

    Dec = &Decorations[NumDecorations - 1];
    for (i = 0; i < NumDecorations; i++)
    {
        if (*Dec == DEC_PTR)
        {
            dprintf("*");
        }
        else if (Dec > Decorations &&
                 (Dec[-1] == DEC_PTR))
        {
            dprintf("(");
        }

        Dec--;
    }

    //
    // Now we need to handle close parens and array
    // bounds.  Arrays nest left-to-right so start
    // at the outermost decoration and work inward.
    //
    
    Dec = Decorations;
    for (i = 0; i < NumDecorations; i++)
    {
        if (*Dec != DEC_PTR)
        {
            if (*Dec)
            {
                dprintf("[%I64d]", *Dec);
            }
            else
            {
                dprintf("[]");
            }
        }
        else if (i < NumDecorations - 1 &&
                 Dec[1] != DEC_PTR)
        {
            dprintf(")");
        }

        Dec++;
    }
}

void
TypedData::OutputNativeValue(void)
{
    CHAR Buffer[50];
    PSTR OutValue = &Buffer[0];

    switch(m_BaseType)
    {
    case DNTYPE_VOID:
        *OutValue = 0;
        break;
    case DNTYPE_CHAR:
    case DNTYPE_INT8:
        if (!IsPrintChar(m_S8))
        {
            sprintf(OutValue, "%ld ''", m_S8);
        }
        else
        {
            sprintf(OutValue, "%ld '%c'", m_S8, m_S8);
        }
        break;
    case DNTYPE_WCHAR:
    case DNTYPE_WCHAR_T:
        if (!IsPrintWChar(m_U16))
        {
            sprintf(OutValue, "0x%lx ''", m_U16);
        }
        else
        {
            sprintf(OutValue, "0x%lx '%C'", m_U16, m_U16);
        }
        break;
    case DNTYPE_INT16:
    case DNTYPE_INT32:
    case DNTYPE_INT64:
    case DNTYPE_LONG32:
        StrprintInt(OutValue, m_S64, m_BaseSize);
        break;
    case DNTYPE_UINT8:
        if (!IsPrintChar(m_U8))
        {
            sprintf(OutValue, "0x%02lx ''", m_U8);
        }
        else
        {
            sprintf(OutValue, "0x%02lx '%c'", m_U8, m_U8);
        }
        break;
    case DNTYPE_UINT16:
    case DNTYPE_UINT32:
    case DNTYPE_UINT64:
    case DNTYPE_ULONG32:
        StrprintUInt(OutValue, m_U64, m_BaseSize);
        break;
    case DNTYPE_FLOAT32:
    case DNTYPE_FLOAT64:
        if (m_BaseSize == 4)
        {
            sprintf(OutValue, "%1.10g", m_F32);
        }
        else if (m_BaseSize == 8)
        {
            sprintf(OutValue, "%1.20g", m_F64);
        }
        break;
    case DNTYPE_BOOL:
        OutValue = m_Bool ? "true" : "false";
        break;
    case DNTYPE_HRESULT:
        sprintf(OutValue, "0x%08lx", m_U32);
        break;
    default:
        ErrOut("Unknown base type %x\n", m_BaseType);
        return;
    }

    dprintf(OutValue);
}

void
TypedData::OutputEnumValue(void)
{
    char ValName[128];
    USHORT NameLen = sizeof(ValName);

    if (GetEnumTypeName(m_Image->m_Process->m_SymHandle,
                        m_Image->m_BaseOfImage,
                        m_BaseType, m_U64, ValName, &NameLen))
    {
        dprintf("%s (%I64d)", ValName, m_U64);
    }
    else
    {
        dprintf("%I64d (No matching enumerant)", m_U64);
    }
}

BOOL
TypedData::EquivInfoSource(PSYMBOL_INFO Compare, ImageInfo* CompImage)
{
    // Don't match this-adjust or bitfield as they
    // require more complicated checks and it's easier
    // to just refresh.
    if (m_DataSource & (TDATA_THIS_ADJUST |
                        TDATA_BITFIELD))
    {
        return FALSE;
    }

    if (Compare->Flags & SYMFLAG_REGISTER)
    {
        return (m_DataSource & TDATA_REGISTER) &&
            CompImage &&
            CompImage->CvRegToMachine((CV_HREG_e)Compare->Register) ==
            m_SourceRegister;
    }
    else if (Compare->Flags & SYMFLAG_REGREL)
    {
        return (m_DataSource & TDATA_REGISTER_RELATIVE) &&
            CompImage &&
            CompImage->CvRegToMachine((CV_HREG_e)Compare->Register) ==
            m_SourceRegister &&
            Compare->Address == m_SourceOffset;
    }
    else if (Compare->Flags & SYMFLAG_FRAMEREL)
    {
        return (m_DataSource & TDATA_FRAME_RELATIVE) &&
            Compare->Address == m_SourceOffset;
    }
    else if (Compare->Flags & SYMFLAG_TLSREL)
    {
        return (m_DataSource & TDATA_TLS_RELATIVE) &&
            Compare->Address == m_SourceOffset;
    }
    else if (m_DataSource & TDATA_MEMORY)
    {
        return Compare->Address == m_SourceOffset;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\thread.cpp ===
//----------------------------------------------------------------------------
//
// Thread abstraction.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// Thread specified in thread commands.  Used for specific
// thread stepping and execution.
ThreadInfo* g_SelectedThread;
SELECT_EXECUTION_THREAD g_SelectExecutionThread = SELTHREAD_ANY;

ThreadInfo* g_RegContextSaved;
ULONG64 g_SaveImplicitThread;
ULONG64 g_SaveImplicitProcess;
ContextSave* g_SavedMachineContext;

//----------------------------------------------------------------------------
//
// ThreadInfo.
//
//----------------------------------------------------------------------------

ThreadInfo::ThreadInfo(ProcessInfo* Process,
                       ULONG SystemId,
                       ULONG64 DataOffset,
                       ULONG64 Handle,
                       ULONG Flags,
                       ULONG64 StartOffset)
{
    m_Process = Process;
    if (m_Process)
    {
        m_UserId = FindNextUserId(LAYER_THREAD);
    }
    else
    {
        m_UserId = 0xffffffff;
    }

    m_Next = NULL;
    m_SystemId = SystemId;
    m_Exited = FALSE;
    m_DataOffset = DataOffset;
    m_Handle = Handle;
    m_Flags = Flags;
    m_Name[0] = 0;
    ZeroMemory(&m_DataBreakBps, sizeof(m_DataBreakBps));
    m_NumDataBreaks = 0;
    m_EventStrings = NULL;
    m_StartOffset = StartOffset;
    m_Frozen = FALSE;
    m_SuspendCount = 0;
    m_FreezeCount = 0;
    m_InternalFreezeCount = 0;

    if (m_Process)
    {
        m_Process->InsertThread(this);
    }
}

ThreadInfo::~ThreadInfo(void)
{
    if (!m_Process)
    {
        return;
    }

    RemoveThreadBreakpoints(this);
    ClearEventStrings();

    if (m_Flags & ENG_PROC_THREAD_CLOSE_HANDLE)
    {
        DBG_ASSERT(IS_LIVE_USER_TARGET(m_Process->m_Target) &&
                   ((LiveUserTargetInfo*)m_Process->m_Target)->
                   m_Services);
        ((LiveUserTargetInfo*)m_Process->m_Target)->
            m_Services->CloseHandle(m_Handle);
    }

    if (this == m_Process->m_Target->m_RegContextThread)
    {
        m_Process->m_Target->m_RegContextThread = NULL;
        m_Process->m_Target->m_RegContextProcessor = -1;
    }
    if (m_Process->m_ImplicitThreadDataThread == this)
    {
        m_Process->ResetImplicitData();
    }
    if (m_Process->m_Target->m_ImplicitProcessDataThread == this)
    {
        m_Process->m_Target->ResetImplicitData();
    }

    m_Process->RemoveThread(this);

    g_UserIdFragmented[LAYER_THREAD]++;

    if (this == g_Thread)
    {
        g_Thread = NULL;
    }
    if (this == g_EventThread)
    {
        g_EventThread = NULL;
        DiscardLastEvent();
    }
    if (g_StepTraceBp && g_StepTraceBp->m_MatchThread == this)
    {
        g_StepTraceBp->m_MatchThread = NULL;
        if (g_WatchFunctions.IsStarted())
        {
            g_WatchFunctions.End(NULL);
        }
        ResetStepTrace();
        g_StepTraceBp->m_Flags &= ~DEBUG_BREAKPOINT_ENABLED;
    }
    if (g_DeferBp && g_DeferBp->m_MatchThread == this)
    {
        g_DeferBp->m_MatchThread = NULL;
    }
    if (g_SelectedThread == this)
    {
        SelectExecutionThread(NULL, SELTHREAD_ANY);
    }
}

EventString*
ThreadInfo::AllocEventString(ULONG Len)
{
    EventString* Str = (EventString*)malloc(sizeof(*Str) + Len);
    if (Str)
    {
        Str->String[0] = 0;
        Str->Next = NULL;
    }
    return Str;
}

void
ThreadInfo::AppendEventString(EventString* EventStr)
{
    //
    // Add at the end of the list to preserve order.
    //

    EventStr->Next = NULL;
    if (!m_EventStrings)
    {
        m_EventStrings = EventStr;
    }
    else
    {
        EventString* End = m_EventStrings;

        while (End->Next)
        {
            End = End->Next;
        }
        End->Next = EventStr;
    }
}

HRESULT
ThreadInfo::AddEventString(PSTR String)
{
    EventString* EventStr;
    ULONG Len = strlen(String);

    if (!(EventStr = AllocEventString(Len)))
    {
        return E_OUTOFMEMORY;
    }

    strcpy(EventStr->String, String);
    return S_OK;
}

void
ThreadInfo::ClearEventStrings(void)
{
    EventString* Str;

    while (m_EventStrings)
    {
        Str = m_EventStrings;
        m_EventStrings = Str->Next;
        free(Str);
    }
}

void
ThreadInfo::OutputEventStrings(void)
{
    EventString* Str;

    for (Str = g_EventThread->m_EventStrings; Str; Str = Str->Next)
    {
        dprintf("%s\n", Str->String);
    }
}

void
ThreadInfo::OutputTimes(void)
{
    ULONG64 Create, Exit, Kernel, User;

    if (m_Process->m_Target->
        GetThreadTimes(this, &Create, &Exit, &Kernel, &User) == S_OK)
    {
        dprintf("Created: %s\n", TimeToStr(FileTimeToTimeDateStamp(Create)));
        if (m_Exited)
        {
            dprintf("Exited:  %s\n", TimeToStr(FileTimeToTimeDateStamp(Exit)));
        }
        dprintf("Kernel:  %s\n", DurationToStr(Kernel));
        dprintf("User:    %s\n", DurationToStr(User));
    }
    else
    {
        ErrOut("Thread times not available\n");
    }
}

void
ThreadInfo::PrepareForExecution(void)
{
    ClearEventStrings();
}

#define TLS_BASE_SLOTS_32 0xe10
#define TLS_EXP_SLOTS_32 0xf94

#define TLS_BASE_SLOTS_64 0x1480
#define TLS_EXP_SLOTS_64 0x1780

HRESULT
ThreadInfo::GetTlsSlotAddress(ULONG Index, PULONG64 Addr)
{
    HRESULT Status;
    ULONG64 TebBase;
    ULONG BaseSlots, ExpSlots, PtrSize;

    if (m_Process->m_Target->m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        return E_NOTIMPL;
    }

    if ((Status = m_Process->m_Target->
         GetThreadInfoTeb(this, 0, 0, &TebBase)) != S_OK)
    {
        return Status;
    }

    if (m_Process->m_Target->m_Machine->m_Ptr64)
    {
        BaseSlots = TLS_BASE_SLOTS_64;
        ExpSlots = TLS_EXP_SLOTS_64;
        PtrSize = 8;
    }
    else
    {
        BaseSlots = TLS_BASE_SLOTS_32;
        ExpSlots = TLS_EXP_SLOTS_32;
        PtrSize = 4;
    }

    if (Index < TLS_MINIMUM_AVAILABLE)
    {
        *Addr = TebBase + BaseSlots + Index * PtrSize;
        return S_OK;
    }
    else
    {
        ULONG64 ExpBase;

        if (m_Process->m_Target->m_SystemVersion < NT_SVER_W2K)
        {
            return E_INVALIDARG;
        }

        if ((Status = m_Process->m_Target->
             ReadPointer(m_Process, m_Process->m_Target->m_Machine,
                         TebBase + ExpSlots, &ExpBase)) != S_OK)
        {
            return Status;
        }

        *Addr = ExpBase + Index * PtrSize;
        return S_OK;
    }
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

ThreadInfo*
FindAnyThreadByUserId(ULONG Id)
{
    TargetInfo* Target;
    ProcessInfo* Process;
    ThreadInfo* Thread;

    ForAllLayers()
    {
        if (Thread->m_UserId == Id)
        {
            return Thread;
        }
    }
    return NULL;
}

ThreadInfo*
FindAnyThreadBySystemId(ULONG Id)
{
    TargetInfo* Target;
    ProcessInfo* Process;
    ThreadInfo* Thread;

    ForAllLayers()
    {
        if (Thread->m_SystemId == Id)
        {
            return Thread;
        }
    }
    return NULL;
}

void
SetCurrentThread(ThreadInfo* Thread, BOOL Hidden)
{
    BOOL Changed = g_Thread != Thread;

    if (Thread != NULL)
    {
        Thread->m_Process->m_CurrentThread = Thread;
        Thread->m_Process->m_Target->m_CurrentProcess = Thread->m_Process;
        SetLayersFromThread(Thread);
        if (g_Target)
        {
            g_Target->ChangeRegContext(Thread);
        }
    }
    else
    {
        if (g_Target)
        {
            g_Target->ChangeRegContext(NULL);
        }
        SetLayersFromTarget(NULL);
    }

    // We're switching processors so invalidate
    // the implicit data pointers so they get refreshed.
    ResetImplicitData();

    // In kernel targets update the page directory for the current
    // processor's page directory base value so that virtual
    // memory mappings are done according to the current processor
    // state.  This only applies to full dumps because triage
    // dumps only have a single processor, so there's nothing to
    // switch, and summary dumps only guarantee that the crashing
    // processor's page directory page is saved.  A user can
    // still manually change the directory through .context if
    // they wish.
    if (IS_KERNEL_TARGET(g_Target) && IS_KERNEL_FULL_DUMP(g_Target))
    {
        if (g_Target->m_Machine->
            SetDefaultPageDirectories(Thread, PAGE_DIR_ALL) != S_OK)
        {
            WarnOut("WARNING: Unable to reset page directories\n");
        }
    }

    if (!Hidden && Changed)
    {
        if (Thread != NULL)
        {
            g_Machine->GetPC(&g_AssemDefault);
            g_UnasmDefault = g_AssemDefault;
        }

        NotifyChangeEngineState(DEBUG_CES_CURRENT_THREAD,
                                Thread != NULL ?
                                Thread->m_UserId : DEBUG_ANY_ID,
                                TRUE);
    }
}

void
SetCurrentProcessorThread(TargetInfo* Target,
                          ULONG Processor, BOOL Hidden)
{
    //
    // Switch to the thread representing a particular processor.
    // This only works with the kernel virtual threads.
    //

    DBG_ASSERT(IS_KERNEL_TARGET(Target));

    ThreadInfo* Thread = Target->m_ProcessHead->
        FindThreadBySystemId(VIRTUAL_THREAD_ID(Processor));
    DBG_ASSERT(Thread != NULL);

    if (Thread == NULL)
    {
        return;
    }
    SetCurrentThread(Thread, Hidden);
}

void
SaveSetCurrentProcessorThread(TargetInfo* Target, ULONG Processor)
{
    // This is only used for kd sessions to conserve
    // bandwidth when temporarily switching processors.
    DBG_ASSERT(IS_KERNEL_TARGET(Target));

    g_RegContextSaved = Target->m_RegContextThread;
    g_SavedMachineContext = Target->m_EffMachine->PushContext(NULL);
    Target->m_RegContextThread = NULL;
    Target->m_RegContextProcessor = -1;
    g_SaveImplicitThread = Target->m_ProcessHead->m_ImplicitThreadData;
    g_SaveImplicitProcess = Target->m_ImplicitProcessData;

    // Don't notify on this change as it is only temporary.
    g_EngNotify++;
    SetCurrentProcessorThread(Target, Processor, TRUE);
    g_EngNotify--;
}

void
RestoreCurrentProcessorThread(TargetInfo* Target)
{
    // This is only used for kd sessions to conserve
    // bandwidth when temporarily switching processors.
    DBG_ASSERT(IS_KERNEL_TARGET(Target));

    if (g_RegContextSaved != NULL)
    {
        Target->m_RegContextProcessor =
            VIRTUAL_THREAD_INDEX(g_RegContextSaved->m_Handle);
    }
    else
    {
        Target->m_RegContextProcessor = -1;
    }
    g_LastSelector = -1;
    Target->m_RegContextThread = g_RegContextSaved;
    Target->m_ProcessHead->m_ImplicitThreadData = g_SaveImplicitThread;
    Target->m_ImplicitProcessData = g_SaveImplicitProcess;
    Target->m_EffMachine->PopContext(g_SavedMachineContext);
    g_SavedMachineContext = NULL;

    // Don't notify on this change as it was only temporary.
    g_EngNotify++;
    SetCurrentThread(Target->m_RegContextThread, TRUE);
    g_EngNotify--;
}

void
SetPromptThread(ThreadInfo* Thread, ULONG OciFlags)
{
    SetCurrentThread(Thread, FALSE);
    ResetCurrentScope();
    OutCurInfo(OciFlags, g_Machine->m_AllMask,
               DEBUG_OUTPUT_PROMPT_REGISTERS);
    // Assem/unasm defaults already reset so just update
    // the dump default from them.
    g_DumpDefault = g_AssemDefault;
}

void
ParseThreadCmds(DebugClient* Client)
{
    CHAR Ch;
    ThreadInfo* Thread, *Thrd, *OrigThread;
    ULONG Id;
    ULONG TraceFlags;
    BOOL FreezeThread = FALSE;
    PCHAR Tmp;
    ULONG64 Frame, Stack, Instr;
    ULONG NumFrames, PtrDef;

    if (!g_Process)
    {
        error(BADTHREAD);
    }

    Ch = PeekChar();
    if (Ch == '\0' || Ch == ';')
    {
        g_Process->OutputThreadInfo(NULL, FALSE);
    }
    else
    {
        g_CurCmd++;

        Thread = g_Thread;
        FreezeThread = TRUE;

        if (Ch == '.')
        {
            // Current thread is the default.
        }
        else if (Ch == '#')
        {
            Thread = g_EventThread;
        }
        else if (Ch == '*')
        {
            Thread = NULL;
            FreezeThread = FALSE;
        }
        else if (Ch == '[')
        {
            g_CurCmd--;
            Id = (ULONG)GetTermExpression("Thread ID missing from");
            Thread = FindAnyThreadByUserId(Id);
            if (Thread == NULL)
            {
                error(BADTHREAD);
            }
        }
        else if (Ch == '~')
        {
            if (*g_CurCmd != '[')
            {
                error(SYNTAX);
            }
            Id = (ULONG)GetTermExpression("Thread ID missing from");
            Thread = FindAnyThreadBySystemId(Id);
            if (Thread == NULL)
            {
                error(BADTHREAD);
            }
        }
        else if (Ch >= '0' && Ch <= '9')
        {
            Id = 0;
            do
            {
                Id = Id * 10 + Ch - '0';
                Ch = *g_CurCmd++;
            }
            while (Ch >= '0' && Ch <= '9');
            g_CurCmd--;
            Thread = FindAnyThreadByUserId(Id);
            if (Thread == NULL)
            {
                error(BADTHREAD);
            }
        }
        else
        {
            g_CurCmd--;
        }

        Ch = PeekChar();
        if (Ch == '\0' || Ch == ';')
        {
            g_Process->OutputThreadInfo(Thread, TRUE);
        }
        else
        {
            g_CurCmd++;
            switch (Ch = (CHAR)tolower(Ch))
            {
            case 'b':
                Ch = (CHAR)tolower(*g_CurCmd);
                g_CurCmd++;
                if (Ch != 'p' && Ch != 'a' && Ch != 'u' && Ch != 'm')
                {
                    if (Ch == '\0' || Ch == ';')
                    {
                        g_CurCmd--;
                    }
                    error(SYNTAX);
                }
                ParseBpCmd(Client, Ch, Thread);
                break;

            case 'e':
                Tmp = g_CurCmd;
                OrigThread = g_Thread;
                for (Thrd = g_Process->m_ThreadHead;
                     Thrd;
                     Thrd = Thrd->m_Next)
                {
                    if (Thread == NULL || Thrd == Thread)
                    {
                        g_CurCmd = Tmp;
                        SetCurrentThread(Thrd, TRUE);

                        ProcessCommands(Client, TRUE);

                        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
                        {
                            g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
                            break;
                        }
                    }
                }
                SetCurrentThread(OrigThread, TRUE);
                break;

            case 'f':
            case 'u':
                if (Thread == NULL)
                {
                    Thread = g_Process->m_ThreadHead;
                    while (Thread)
                    {
                        Thread->m_Frozen = (BOOL)(Ch == 'f');
                        Thread = Thread->m_Next;
                    }
                }
                else
                {
                    Thread->m_Frozen = (BOOL)(Ch == 'f');
                }
                break;

            case 'g':
                if (Thread)
                {
                    g_Target->ChangeRegContext(Thread);
                }
                ParseGoCmd(Thread, FreezeThread);
                g_Target->ChangeRegContext(g_Thread);
                break;

            case 'k':
                if (Thread == NULL)
                {
                    Tmp = g_CurCmd;
                    for (Thread = g_Process->m_ThreadHead;
                         Thread;
                         Thread = Thread->m_Next)
                    {
                        g_CurCmd = Tmp;
                        dprintf("\n");
                        g_Process->OutputThreadInfo(Thread, FALSE);
                        g_Target->ChangeRegContext(Thread);
                        ParseStackTrace(&TraceFlags, &Frame,
                                        &Stack, &Instr, &NumFrames,
                                        &PtrDef);
                        DoStackTrace(Client, Frame, Stack, Instr, PtrDef,
                                     NumFrames, TraceFlags);
                        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    g_Target->ChangeRegContext(Thread);
                    ParseStackTrace(&TraceFlags, &Frame,
                                    &Stack, &Instr, &NumFrames,
                                    &PtrDef);
                    DoStackTrace(Client, Frame, Stack, Instr, PtrDef,
                                 NumFrames, TraceFlags);
                }

                g_Target->ChangeRegContext(g_Thread);
                break;

            case 'm':
            case 'n':
                if (!IS_LIVE_USER_TARGET(g_Target))
                {
                    error(SESSIONNOTSUP);
                }
                ((LiveUserTargetInfo*)g_Target)->
                    SuspendResumeThreads(g_Process, Ch == 'n', Thread);
                break;

            case 'p':
            case 't':
                if (Thread)
                {
                    g_Target->ChangeRegContext(Thread);
                }
                ParseStepTrace(Thread, FreezeThread, Ch);
                g_Target->ChangeRegContext(g_Thread);
                break;

            case 'r':
                if (Thread == NULL)
                {
                    Tmp = g_CurCmd;
                    for (Thread = g_Process->m_ThreadHead;
                         Thread;
                         Thread = Thread->m_Next)
                    {
                        g_CurCmd = Tmp;
                        g_Target->ChangeRegContext(Thread);
                        ParseRegCmd();
                    }
                }
                else
                {
                    g_Target->ChangeRegContext(Thread);
                    ParseRegCmd();
                }
                g_Target->ChangeRegContext(g_Thread);
                break;

            case 's':
                if (Thread == NULL)
                {
                    error(BADTHREAD);
                }
                SetPromptThread(Thread, SPT_DEFAULT_OCI_FLAGS);
                break;

            default:
                error(SYNTAX);
            }
        }
    }
}

BOOL
IsSelectedExecutionThread(ThreadInfo* Thread,
                          SELECT_EXECUTION_THREAD Type)
{
    switch(Type)
    {
    case SELTHREAD_INTERNAL_THREAD:
        // If we're checking whether this is an internally
        // selected thread we need an exact match.
        return Thread &&
            g_SelectExecutionThread == Type && Thread == g_SelectedThread;

    case SELTHREAD_THREAD:
        // For user-driven execution control there is either
        // a specific thread or a match-any state with no thread.
        return Thread && (!g_SelectedThread || Thread == g_SelectedThread);

    case SELTHREAD_ANY:
        // Check to see if any selection has been made.
        return !g_SelectedThread;

    default:
        DBG_ASSERT(FALSE);
        return FALSE;
    }
}

void
SelectExecutionThread(ThreadInfo* Thread,
                      SELECT_EXECUTION_THREAD Type)
{
    if (!Thread || Type == SELTHREAD_ANY)
    {
        g_SelectExecutionThread = SELTHREAD_ANY;
        g_SelectedThread = NULL;
    }
    else
    {
        g_SelectExecutionThread = Type;
        g_SelectedThread = Thread;
    }
}

BOOL
ThreadWillResume(ThreadInfo* Thread)
{
    // If the thread isn't selected for execution or
    // it's manually frozen it won't be resumed.
    return !Thread->m_Frozen &&
        IsSelectedExecutionThread(Thread, SELTHREAD_THREAD);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\thread.hpp ===
//----------------------------------------------------------------------------
//
// Thread abstraction.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#ifndef __THREAD_HPP__
#define __THREAD_HPP__

// In kernel mode the index is a processor index.  In user
// dumps it's the thread index in the dump.
#define VIRTUAL_THREAD_HANDLE(Index) ((ULONG64)((Index) + 1))
#define VIRTUAL_THREAD_INDEX(Handle) ((ULONG)((Handle) - 1))
#define VIRTUAL_THREAD_ID(Index) ((Index) + 1)

#define CURRENT_PROC \
    (g_Thread ? VIRTUAL_THREAD_INDEX(g_Thread->m_Handle) : (ULONG)-1)

extern ThreadInfo* g_SelectedThread;

enum SELECT_EXECUTION_THREAD
{
    SELTHREAD_ANY,
    SELTHREAD_THREAD,
    SELTHREAD_INTERNAL_THREAD,
};
extern SELECT_EXECUTION_THREAD g_SelectExecutionThread;

struct EventString
{
    EventString* Next;
    char String[1];
};

//----------------------------------------------------------------------------
//
// ThreadInfo.
//
//----------------------------------------------------------------------------

#define MAX_DATA_BREAKS 4

class ThreadInfo
{
public:
    ThreadInfo(class ProcessInfo* Process,
               ULONG SystemId,
               ULONG64 DataOffset,
               ULONG64 Handle,
               ULONG Flags,
               ULONG64 StartOffset);
    ~ThreadInfo(void);

    class ProcessInfo* m_Process;
    
    // Generic information.
    ThreadInfo* m_Next;
    ULONG m_UserId;
    ULONG m_SystemId;
    BOOL m_Exited;
    ULONG64 m_DataOffset;
    // For kernel mode and dumps the thread handle is
    // a virtual handle.
    ULONG64 m_Handle;
    ULONG m_Flags;
    // Only set by VCPP exceptions.
    char m_Name[MAX_THREAD_NAME];

    class Breakpoint* m_DataBreakBps[MAX_DATA_BREAKS];
    ULONG m_NumDataBreaks;

    EventString* m_EventStrings;
    
    // Only partially-implemented in kd.
    ULONG64 m_StartOffset;
    BOOL m_Frozen;
    ULONG m_SuspendCount;
    ULONG m_FreezeCount;
    ULONG m_InternalFreezeCount;

    EventString* AllocEventString(ULONG Len);
    void AppendEventString(EventString* EventStr);
    HRESULT AddEventString(PSTR String);
    void ClearEventStrings(void);
    void OutputEventStrings(void);

    void OutputTimes(void);

    void PrepareForExecution(void);

    HRESULT GetTlsSlotAddress(ULONG Index, PULONG64 Addr);
};

ThreadInfo* FindAnyThreadByUserId(ULONG Id);

void SetCurrentThread(ThreadInfo* Thread, BOOL Hidden);
void SetCurrentProcessorThread(TargetInfo* Target,
                               ULONG Processor, BOOL Hidden);
void SaveSetCurrentProcessorThread(TargetInfo* Target,
                                   ULONG Processor);
void RestoreCurrentProcessorThread(TargetInfo* Target);

#define SPT_DEFAULT_OCI_FLAGS \
    (OCI_SYMBOL | OCI_DISASM | OCI_FORCE_EA | OCI_ALLOW_SOURCE | \
     OCI_ALLOW_REG)
void SetPromptThread(ThreadInfo* pThread, ULONG uOciFlags);

void ParseThreadCmds(DebugClient* Client);

BOOL IsSelectedExecutionThread(ThreadInfo* Thread,
                               SELECT_EXECUTION_THREAD Type);
void SelectExecutionThread(ThreadInfo* Thread,
                           SELECT_EXECUTION_THREAD Type);
BOOL ThreadWillResume(ThreadInfo* Thread);

#endif // #ifndef __THREAD_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\typedata.hpp ===
//----------------------------------------------------------------------------
//
// Typed data abstraction.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#ifndef __TYPEDATA_HPP__
#define __TYPEDATA_HPP__

#define DBG_NATIVE_TYPE_BASE    0x80000000
#define DBG_GENERATED_TYPE_BASE 0x80001000

//
// The compiler has a set of base types which represent
// the lowest-level intrinsic types in the type system.
// PDBs don't contain information for them, just references
// to them.  The following table defines the various
// base types which the debugger might use and gives
// them artificial type IDs so that they can be
// treated like other types.
//

#define DNTF_SIGNED  0x00000001
#define DNTF_INTEGER 0x00000002
#define DNTF_FLOAT   0x00000004

enum
{
    DNTYPE_VOID = DBG_NATIVE_TYPE_BASE,
    DNTYPE_CHAR,
    DNTYPE_WCHAR_T,
    DNTYPE_INT8,
    DNTYPE_INT16,
    DNTYPE_INT32,
    DNTYPE_INT64,
    DNTYPE_UINT8,
    DNTYPE_UINT16,
    DNTYPE_UINT32,
    DNTYPE_UINT64,
    DNTYPE_FLOAT32,
    DNTYPE_FLOAT64,
    DNTYPE_BOOL,
    DNTYPE_LONG32,
    DNTYPE_ULONG32,
    DNTYPE_HRESULT,

    //
    // The following types aren't true native types but
    // are very basic aliases for native types that
    // need special identification.  For example, WCHAR
    // is here so that the debugger knows it's characters
    // and not just an unsigned short.
    //
    
    DNTYPE_WCHAR,

    //
    // Artificial pointer types for special-case handling
    // of things like vtables.
    //

    DNTYPE_PTR_FUNCTION32,
    DNTYPE_PTR_FUNCTION64,

    DNTYPE_END_MARKER
};

#define DNTYPE_FIRST DNTYPE_VOID
#define DNTYPE_LAST  (DNTYPE_END_MARKER - 1)
#define DNTYPE_COUNT (DNTYPE_LAST - DNTYPE_FIRST + 1)

#define DbgNativeArrayIndex(TypeId) \
    ((TypeId) - DNTYPE_FIRST)
#define IsDbgNativeType(TypeId) \
    ((TypeId) >= DNTYPE_FIRST && (TypeId) <= DNTYPE_LAST)
#define DbgNativeTypeEntry(TypeId) \
    (&g_DbgNativeTypes[DbgNativeArrayIndex(TypeId)])
#define DbgNativeTypeId(Nat) \
    ((ULONG)((Nat) - g_DbgNativeTypes) + DNTYPE_FIRST)

typedef struct _DBG_NATIVE_TYPE
{
    PCSTR TypeName;
    ULONG CvBase;
    ULONG CvTag;
    ULONG Size;
    ULONG Flags;
} DBG_NATIVE_TYPE, *PDBG_NATIVE_TYPE;

extern DBG_NATIVE_TYPE g_DbgNativeTypes[];

PDBG_NATIVE_TYPE FindNativeTypeByName(PCSTR Name);
PDBG_NATIVE_TYPE FindNativeTypeByCvBaseType(ULONG CvBase, ULONG Size);

//
// In addition to the native types above the debugger must
// also dynamically generate types due to casts.  For example,
// (char **) has to generate two new pointer types as there's
// no good way to look up such a type in a PDB and there's
// no guarantee the PDB will contain such a type.  Instead
// the debugger has a simple mechanism for dynamically
// creating types and assigning them artificial type IDs.
//

typedef struct _DBG_GENERATED_TYPE
{
    struct _DBG_GENERATED_TYPE* Next;
    ULONG64 ImageBase;
    ULONG TypeId;
    ULONG Tag;
    ULONG ChildId;
    ULONG Size;
} DBG_GENERATED_TYPE, *PDBG_GENERATED_TYPE;

class GeneratedTypeList
{
public:
    GeneratedTypeList(void);
    ~GeneratedTypeList(void);
    
    PDBG_GENERATED_TYPE NewType(ULONG64 ImageBase, ULONG Tag, ULONG Size);
    void DeleteByImage(ULONG64 ImageBase);
    void DeleteById(ULONG Id);
    PDBG_GENERATED_TYPE FindById(ULONG TypeId);
    PDBG_GENERATED_TYPE FindByAttrs(ULONG64 ImageBase,
                                    ULONG Tag, ULONG ChildId, ULONG Size);
    PDBG_GENERATED_TYPE FindOrCreateByAttrs(ULONG64 ImageBase,
                                            ULONG Tag,
                                            ULONG ChildId,
                                            ULONG Size);

protected:
    PDBG_GENERATED_TYPE m_Types;
    ULONG m_NextId;
};

#define IsDbgGeneratedType(TypeId) \
    ((TypeId) >= DBG_GENERATED_TYPE_BASE)

extern GeneratedTypeList g_GenTypes;

//----------------------------------------------------------------------------
//
// TypedData.
//
// Data for primitive types is stored directly in the data
// union and the size is set accordingly.  Data for non-primitive
// types is assumed to be in memory somewhere so the data union is
// not used.  In all cases the size field indicates the
// size of the data in memory and the data address field gives
// the address of the data.
//
// For pointer and array types there are two additional fields set,
// the type of the data referenced and the size of that data.
//
// Bitfields keep the bit position and length.
//
// Methods return error codes for EvalError.
//
//----------------------------------------------------------------------------

#define OPF_SCALE_LEFT   0x00000001
#define OPF_SCALE_RIGHT  0x00000002
#define OPF_SCALE_RESULT 0x00000004

#define CHLF_DEFAULT            0x00000000
// When getting the children of a pointer, if
// the pointer points to a UDT consider the
// children of the UDT to be the children of the pointer.
#define CHLF_DEREF_UDT_POINTERS 0x00000001
// Do not read data for children.
#define CHLF_DISALLOW_ACCESS    0x00000002

#define TDATA_NONE              0x0000
#define TDATA_MEMORY            0x0001
#define TDATA_REGISTER          0x0002
#define TDATA_REGISTER_RELATIVE 0x0004
#define TDATA_FRAME_RELATIVE    0x0008
#define TDATA_TLS_RELATIVE      0x0010
#define TDATA_BASE_SOURCE       0x001f

#define TDATA_THIS_ADJUST       0x4000
#define TDATA_BITFIELD          0x8000

enum TypedDataOp
{
    TDOP_ASSIGN,
    TDOP_ADD,
    TDOP_SUBTRACT,
    TDOP_MULTIPLY,
    TDOP_DIVIDE,
    TDOP_REMAINDER,
    TDOP_LEFT_SHIFT,
    TDOP_RIGHT_SHIFT,
    TDOP_BIT_OR,
    TDOP_BIT_XOR,
    TDOP_BIT_AND,
    TDOP_BIT_NOT,
    TDOP_NEGATE,
    TDOP_EQUAL,
    TDOP_NOT_EQUAL,
    TDOP_LESS,
    TDOP_LESS_EQUAL,
    TDOP_GREATER,
    TDOP_GREATER_EQUAL,
};

//
// Read/WriteData allow different forms of value access control.
// Access to the true data may be required, speculative or disallowed.
// Required in the usual mode, where the data needs to be retrieved.
// Access errors will cause error returns.
// Speculative attempts to access the value but just uses zero if
// the value is not accessible.
// Access is disallowed when expressions are being parsed only and
// not evaluated.
enum TypedDataAccess
{
    TDACC_REQUIRE,
    TDACC_ATTEMPT,
    TDACC_NONE,
};

struct TypedData
{
    ImageInfo* m_Image;
    ULONG m_Type;
    ULONG m_BaseType;
    USHORT m_BaseTag;
    USHORT m_DataSource;
    ULONG m_BaseSize;
    // For pointers the next type is the type pointed to,
    // for arrays the next type is the array element type.
    // For bitfields the bit length and position are kept.
    union
    {
        ULONG m_NextType;
        ULONG m_BitPos;
    };
    union
    {
        ULONG m_NextSize;
        ULONG m_BitSize;
    };
    
    // TDATA_MEMORY - Source offset is virtual address.
    // TDATA_REGISTER - Source register is machine register index.
    // TDATA_REGISTER_RELATIVE - Source register is machine
    //                           register index and source offset
    //                           is register offset.
    // TDATA_FRAME_RELATIVE - Source offset is frame offset.
    // TDATA_TLS_RELATIVE - Source offset is TLS area offset.
    ULONG64 m_SourceOffset;
    ULONG m_SourceRegister;
    ULONG m_Unused1;
    
    union
    {
        bool m_Bool;
        UCHAR m_U8;
        CHAR m_S8;
        USHORT m_U16;
        SHORT m_S16;
        ULONG m_U32;
        LONG m_S32;
        ULONG64 m_U64;
        LONG64 m_S64;
        float m_F32;
        double m_F64;
        ULONG64 m_Ptr;
    };

    static ULONG CheckConvertI64ToF64(ULONG64 I64, BOOL Signed);
    static ULONG CheckConvertF64ToI64(double F64, BOOL Signed);
    
    ULONG ConvertToBool(void);
    ULONG ConvertToU64(BOOL Strict = TRUE);
    ULONG ConvertToF64(BOOL Strict = TRUE);
    void ConvertToBestNativeType(void);
    ULONG ConvertTo(TypedData* Type);
    ULONG CastTo(TypedData* CastType);
    
    ULONG ConvertToAddressOf(BOOL CastOnly, ULONG PtrSize);
    ULONG ConvertToDereference(TypedDataAccess AllowAccess, ULONG PtrSize);
    ULONG ConvertToArray(ULONG ArraySize);
    ULONG ConvertToMember(PCSTR Member, TypedDataAccess AllowAccess,
                          ULONG PtrSize);
    ULONG ConvertToSource(TypedData* Dest);

    void AvoidUsingImage(ImageInfo* Image);
    void ReleaseImage(void)
    {
        AvoidUsingImage(m_Image);
    }

    ULONG GetAbsoluteAddress(PULONG64 Addr);
    ULONG ReadData(TypedDataAccess AllowAccess);
    ULONG WriteData(TypedData* Source, TypedDataAccess AllowAccess);
    ULONG GetDataFromVariant(VARIANT* Var);
    
    ULONG CombineTypes(TypedData* Val, TypedDataOp Op);
    ULONG BinaryArithmetic(TypedData* Val, TypedDataOp Op);
    ULONG Shift(TypedData* Val, TypedDataOp Op);
    ULONG BinaryBitwise(TypedData* Val, TypedDataOp Op);
    ULONG Relate(TypedData* Val, TypedDataOp Op);
    ULONG Unary(TypedDataOp Op);
    ULONG ConstIntOp(ULONG64 Val, BOOL Signed, TypedDataOp Op);
    
    ULONG FindBaseType(PULONG Type, PULONG Tag);
    ULONG GetTypeLength(ULONG Type, PULONG Length);
    ULONG GetTypeTag(ULONG Type, PULONG Tag);
    ULONG IsBaseClass(ULONG Udt, ULONG BaseUdt, PLONG Adjust);

    ULONG EstimateChildrenCounts(ULONG Flags,
                                 PULONG ChildUsed, PULONG NameUsed);
    typedef ULONG (*GetChildrenCb)(PVOID Context, PSTR Name, TypedData* Child);
    ULONG GetChildren(ULONG PtrSize, ULONG Flags,
                      GetChildrenCb Callback, PVOID Context);
    static ULONG GetAllChildrenCb(PVOID Context, PSTR Name, TypedData* Child);
    ULONG GetAllChildren(ULONG PtrSize, ULONG Flags, PULONG NumChildren,
                         TypedData** Children, PSTR* Names);
    
    ULONG FindType(ProcessInfo* Process, PCSTR Type, ULONG PtrSize);
    ULONG FindSymbol(ProcessInfo* Process, PSTR Symbol,
                     TypedDataAccess AllowAccess, ULONG PtrSize);
    ULONG SetToSymbol(ProcessInfo* Process,
                      PSTR Symbol, PSYMBOL_INFO SymInfo,
                      TypedDataAccess AllowAccess, ULONG PtrSize);

    void OutputType(void);
    void OutputSimpleValue(void);
    void OutputTypeAndValue(void);

    void ClearAddress(void)
    {
        m_DataSource = TDATA_NONE;
        m_SourceOffset = 0;
        m_SourceRegister = 0;
    }
    void ClearData(void)
    {
        m_U64 = 0;
    }

    void SetDataSource(USHORT Source, ULONG64 Offset, ULONG Register)
    {
        m_DataSource = Source;
        m_SourceOffset = Offset;
        m_SourceRegister = Register;
    }
    
    void SetToNativeType(ULONG Type)
    {
        PDBG_NATIVE_TYPE Native = DbgNativeTypeEntry(Type);
        
        m_Image = NULL;
        m_Type = Type;
        m_BaseType = Type;
        m_BaseTag = (USHORT)Native->CvTag;
        m_BaseSize = Native->Size;
        m_NextType = 0;
        m_NextSize = 0;
    }
    void SetToCvBaseType(ULONG CvBase, ULONG Size)
    {
        PDBG_NATIVE_TYPE Native = FindNativeTypeByCvBaseType(CvBase, Size);
        DBG_ASSERT(Native);
        SetToNativeType(DbgNativeTypeId(Native));
    }
    void SetU32(ULONG Val)
    {
        SetToNativeType(DNTYPE_UINT32);
        // Set U64 to clear high bits.
        m_U64 = Val;
        ClearAddress();
    }
    void SetU64(ULONG64 Val)
    {
        SetToNativeType(DNTYPE_UINT64);
        m_U64 = Val;
        ClearAddress();
    }
    void ForceU64(void)
    {
        // Don't use strict checking on the conversion.
        if (ConvertToU64(FALSE) != NO_ERROR)
        {
            SetU64(0);
        }
    }

    void CopyType(TypedData* From)
    {
        m_Image = From->m_Image;
        m_Type = From->m_Type;
        m_BaseType = From->m_BaseType;
        m_BaseTag = From->m_BaseTag;
        m_BaseSize = From->m_BaseSize;
        DBG_ASSERT(!From->IsBitfield());
        m_NextType = From->m_NextType;
        m_NextSize = From->m_NextSize;
    }
    void CopyDataSource(TypedData* From)
    {
        m_DataSource = From->m_DataSource;
        m_SourceOffset = From->m_SourceOffset;
        m_SourceRegister = From->m_SourceRegister;
    }
    void CopyData(TypedData* From)
    {
        m_U64 = From->m_U64;
    }

    BOOL EquivType(TypedData* Compare)
    {
        return m_Image == Compare->m_Image &&
            m_Type == Compare->m_Type &&
            m_BaseType == Compare->m_BaseType &&
            IsBitfield() == Compare->IsBitfield() &&
            (!IsBitfield() ||
             (m_BitPos == Compare->m_BitPos &&
              m_BitSize == Compare->m_BitSize));
    }
    BOOL EquivSource(TypedData* Compare)
    {
        return m_DataSource == Compare->m_DataSource &&
            m_SourceOffset == Compare->m_SourceOffset &&
            m_SourceRegister == Compare->m_SourceRegister &&
            IsBitfield() == Compare->IsBitfield() &&
            (!IsBitfield() ||
             (m_BitPos == Compare->m_BitPos &&
              m_BitSize == Compare->m_BitSize));
    }
    BOOL EquivInfoSource(PSYMBOL_INFO Compare, ImageInfo* CompImage);
    
    BOOL IsInteger(void)
    {
        return
            (IsDbgNativeType(m_BaseType) &&
             (DbgNativeTypeEntry(m_BaseType)->Flags & DNTF_INTEGER)) ||
            IsEnum();
    }
    BOOL IsBitfield(void)
    {
        return (m_DataSource & TDATA_BITFIELD) != 0;
    }
    BOOL IsFloat(void)
    {
        return IsDbgNativeType(m_BaseType) &&
            (DbgNativeTypeEntry(m_BaseType)->Flags & DNTF_FLOAT);
    }
    BOOL IsSigned(void)
    {
        return IsDbgNativeType(m_BaseType) &&
            (DbgNativeTypeEntry(m_BaseType)->Flags & DNTF_SIGNED);
    }
    BOOL IsPointer(void)
    {
        return m_BaseTag == SymTagPointerType;
    }
    BOOL IsEnum(void)
    {
        return m_BaseTag == SymTagEnum;
    }
    BOOL IsArray(void)
    {
        return m_BaseTag == SymTagArrayType;
    }
    BOOL IsFunction(void)
    {
        return m_BaseTag == SymTagFunctionType;
    }
    BOOL IsUdt(void)
    {
        return m_BaseTag == SymTagUDT;
    }
    BOOL HasAddress(void)
    {
        return
            (m_DataSource & (TDATA_MEMORY |
                             TDATA_REGISTER_RELATIVE |
                             TDATA_FRAME_RELATIVE |
                             TDATA_TLS_RELATIVE)) != 0 &&
            (m_DataSource & TDATA_BITFIELD) == 0;
    }
    BOOL IsInMemory(void)
    {
        return (m_DataSource & (TDATA_MEMORY |
                                TDATA_REGISTER_RELATIVE |
                                TDATA_FRAME_RELATIVE |
                                TDATA_TLS_RELATIVE)) != 0;
    }
    BOOL IsWritable(void)
    {
        return m_DataSource != TDATA_NONE;
    }

protected:
    ULONG SetToUdtMember(TypedDataAccess AllowAccess,
                         ULONG PtrSize, ImageInfo* Image,
                         ULONG Member, ULONG Type, ULONG Tag,
                         USHORT DataSource, ULONG64 BaseOffs, ULONG SourceReg,
                         DataKind Relation);
    ULONG FindUdtMember(ULONG UdtType, PCWSTR Member,
                        PULONG MemberType, DataKind* Relation,
                        PULONG InheritOffset);
    
    ULONG GetPointerChildren(ULONG PtrSize, ULONG Flags,
                             GetChildrenCb Callback, PVOID Context);
    ULONG GetArrayChildren(ULONG PtrSize, ULONG Flags,
                           GetChildrenCb Callback, PVOID Context);
    ULONG GetUdtChildren(ULONG PtrSize, ULONG Flags,
                         GetChildrenCb Callback, PVOID Context);
    
    ULONG FindTypeInfo(BOOL RequireType, ULONG PtrSize);
    
    ULONG OutputFundamentalType(ULONG Type, ULONG BaseType, ULONG BaseTag,
                                PULONG64 Decoration, ULONG NumDecorations);
    void OutputNativeValue(void);
    void OutputEnumValue(void);
};

#endif // #ifndef __TYPEDATA_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\util.cpp ===
//----------------------------------------------------------------------------
//
// General utility functions.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"
#include <sys\types.h>
#include <sys\stat.h>

PCSTR g_DefaultLogFileName = ENGINE_MOD_NAME ".log";
char  g_OpenLogFileName[MAX_PATH + 1];
BOOL  g_OpenLogFileAppended;
int   g_LogFile = -1;
ULONG g_DisableErrorPrint;

ULONG
CheckUserInterrupt(void)
{
    if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
    {
        g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
        return TRUE;
    }
    return FALSE;
}

BOOL
PollUserInterrupt(BOOL AllowPendingBreak)
{
    // Check for a simple user interrupt.
    if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
    {
        return TRUE;
    }
    // If we're running and we're supposed to be breaking in,
    // we also consider this an interrupt to prevent long
    // operations from delaying the break-in.
    if (AllowPendingBreak &&
        IS_RUNNING(g_CmdState) &&
        (g_EngStatus & ENG_STATUS_PENDING_BREAK_IN))
    {
        return TRUE;
    }
    return FALSE;
}

LONG
MappingExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
    static ULONG s_InPageErrors = 0;
    
    ULONG Code = ExceptionInfo->ExceptionRecord->ExceptionCode;
    if (Code == STATUS_IN_PAGE_ERROR)
    {
        if (++s_InPageErrors < 10)
        {
            if (s_InPageErrors % 2)
            {
                WarnOut("Ignore in-page I/O error\n");
                FlushCallbacks();
            }
            Sleep(500);
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

    s_InPageErrors = 0;
    ErrOut("Exception 0x%08x while accessing mapping\n", Code);
    FlushCallbacks();
    return EXCEPTION_EXECUTE_HANDLER;
}

void
RemoveDelChar(PSTR Buffer)
{
    PSTR BufferOld = Buffer;
    PSTR BufferNew = Buffer;

    while (*BufferOld)
    {
        if (*BufferOld == 0x7f)
        {
            if (BufferNew > Buffer)
            {
                BufferNew--;
            }
        }
        else if (*BufferOld == '\r' || *BufferOld == '\n')
        {
            *BufferNew++ = ' ';
        }
        else
        {
            *BufferNew++ = *BufferOld;
        }

        BufferOld++;
    }

    *BufferNew = '\0';
}

PCSTR
ErrorString(ULONG Error)
{
    switch(Error)
    {
    case OVERFLOW:
        return "Overflow";
    case SYNTAX:
        return "Syntax";
    case BADRANGE:
        return "Range";
    case VARDEF:
        return "Couldn't resolve";
    case EXTRACHARS:
        return "Extra character";
    case LISTSIZE:
        return "List size";
    case STRINGSIZE:
        return "String size";
    case MEMORY:
        return "Memory access";
    case BADREG:
        return "Bad register";
    case BADOPCODE:
        return "Bad opcode";
    case SUFFIX:
        return "Opcode suffix";
    case OPERAND:
        return "Operand";
    case ALIGNMENT:
        return "Alignment";
    case PREFIX:
        return "Opcode prefix";
    case DISPLACEMENT:
        return "Displacement";
    case BPLISTFULL:
        return "No breakpoint available";
    case BPDUPLICATE:
        return "Duplicate breakpoint";
    case UNIMPLEMENT:
        return "Unimplemented";
    case AMBIGUOUS:
        return "Ambiguous symbol";
    case BADTHREAD:
        return "Illegal thread";
    case BADPROCESS:
        return "Illegal process";
    case FILEREAD:
        return "File read";
    case LINENUMBER:
        return "Line number";
    case BADSEL:
        return "Bad selector";
    case BADSEG:
        return "Bad segment";
    case SYMTOOSMALL:
        return "Symbol only 1 character";
    case BPIONOTSUP:
        return "I/O breakpoints not supported";
    case NOTFOUND:
        return "No information found";
    case SESSIONNOTSUP:
        return "Operation not supported in current debug session";
    case BADSYSTEM:
        return "Illegal system";
    case NOMEMORY:
        return "Out of memory";
    case TYPECONFLICT:
        return "Type conflict";
    case TYPEDATA:
        return "Type information missing";
    case NOTMEMBER:
        return "Type does not have given member";
    case IMPLERR:
        return "Internal implementation";
    case ENGBUSY:
        return "Engine is busy";
    case TARGETNOTSUP:
        return "Operation not supported by current debuggee";
    case NORUNNABLE:
        return "No runnable debuggees";
    case NOTSECURE:
        return "SECURE: Operation disallowed";
    default:
        return "Unknown";
    }
}

/*** error - error reporting and recovery
*
*   Purpose:
*       To output an error message with a location indicator
*       of the problem.  Once output, the command line is reset
*       and the command processor is restarted.
*
*   Input:
*       errorcode - number of error to output
*
*   Output:
*       None.
*
*   Exceptions:
*       Return is made via exception to start of command processor.
*
*************************************************************************/

char g_Blanks[] =
    "                                                  "
    "                                                  "
    "                                                  "
    "                                                ^ ";

void
ReportError(
    ULONG Error,
    PCSTR* DescPtr
    )
{
    ULONG Count = g_PromptLength + 1;
    PSTR Temp = g_CommandStart;
    PCSTR Desc;

    // Reset the expression evaluators in case we're
    // hitting an error during evaluation which would
    // otherwise leave the evaluator in an inconsistent state.
    ReleaseEvaluators();
    
    if (DescPtr != NULL)
    {
        // Clear out description so it doesn't get reused.
        Desc = *DescPtr;
        *DescPtr = NULL;
    }
    else
    {
        Desc = NULL;
    }
    
    if (g_DisableErrorPrint || 
        (g_CommandStart > g_CurCmd) ||
        (g_CommandStart + MAX_COMMAND < g_CurCmd))
    {
        goto SkipErrorPrint;
    }

    while (Temp < g_CurCmd)
    {
        if (*Temp++ == '\t')
        {
            Count = (Count + 7) & ~7;
        }
        else
        {
            Count++;
        }
    }

    ErrOut(&g_Blanks[sizeof(g_Blanks) - (Count + 1)]);

    if (Desc != NULL)
    {
        ErrOut("%s '%s'\n", Desc, g_CommandStart);
    }
    else if (Error != VARDEF && Error != SESSIONNOTSUP)
    {
        ErrOut("%s error in '%s'\n",
               ErrorString(Error), g_CommandStart);
    }
    else
    {
        ErrOut("%s '%s'\n", ErrorString(Error), g_CommandStart);
    }
    
SkipErrorPrint:
    RaiseException(COMMAND_EXCEPTION_BASE + Error, 0, 0, NULL);
}

ULONG64
HexValue(ULONG Size)
{
    ULONG64 Value;

    Value = GetExpression();

    // Reverse sign extension done by expression evaluator.
    if (Size == 4 && !NeedUpper(Value))
    {
        Value = (ULONG)Value;
    }

    if (Value > (0xffffffffffffffffUI64 >> (8 * (8 - Size))))
    {
        error(OVERFLOW);
    }

    return Value;
}

void
HexList(PUCHAR Buffer, ULONG BufferSize,
        ULONG EltSize, PULONG CountRet)
{
    CHAR Ch;
    ULONG64 Value;
    ULONG Count = 0;
    ULONG i;

    while ((Ch = PeekChar()) != '\0' && Ch != ';')
    {
        if (Count >= BufferSize)
        {
            error(LISTSIZE);
        }
        
        Value = HexValue(EltSize);
        for (i = 0; i < EltSize; i++)
        {
            *Buffer++ = (UCHAR)Value;
            Value >>= 8;
        }
        Count += EltSize;
    }
    
    *CountRet = Count;
}

ULONG64
FloatValue(ULONG Size)
{
    int Scanned;
    double Value;
    ULONG64 RawValue;

    if (sscanf(g_CurCmd, "%lf%n", &Value, &Scanned) != 1)
    {
        error(SYNTAX);
    }

    g_CurCmd += Scanned;

    if (Size == 4)
    {
        float FloatVal = (float)Value;
        RawValue = *(PULONG)&FloatVal;
    }
    else
    {
        RawValue = *(PULONG64)&Value;
    }

    return RawValue;
}

void
FloatList(PUCHAR Buffer, ULONG BufferSize,
          ULONG EltSize, PULONG CountRet)
{
    CHAR Ch;
    ULONG64 Value;
    ULONG Count = 0;
    ULONG i;

    while ((Ch = PeekChar()) != '\0' && Ch != ';')
    {
        if (Count >= BufferSize)
        {
            error(LISTSIZE);
        }
        
        Value = FloatValue(EltSize);
        for (i = 0; i < EltSize; i++)
        {
            *Buffer++ = (UCHAR)Value;
            Value >>= 8;
        }
        Count += EltSize;
    }
    
    *CountRet = Count;
}

void
AsciiList(PSTR Buffer, ULONG BufferSize,
          PULONG CountRet)
{
    CHAR Ch;
    ULONG Count = 0;

    if (PeekChar() != '"')
    {
        error(SYNTAX);
    }
    
    g_CurCmd++;

    do
    {
        Ch = *g_CurCmd++;

        if (Ch == '"')
        {
            Count++;
            *Buffer++ = 0;
            break;
        }

        if (Ch == '\0' || Ch == ';')
        {
            g_CurCmd--;
            break;
        }

        if (Count >= BufferSize)
        {
            error(STRINGSIZE);
        }

        Count++;
        *Buffer++ = Ch;

    } while (1);

    *CountRet = Count;
}

PSTR
GetEscapedChar(PSTR Str, PCHAR Raw)
{
    switch(*Str)
    {
    case 0:
        error(SYNTAX);
    case '0':
        // Octal char value.
        *Raw = (char)strtoul(Str + 1, &Str, 8);
        break;
    case 'b':
        *Raw = '\b';
        Str++;
        break;
    case 'n':
        *Raw = '\n';
        Str++;
        break;
    case 'r':
        *Raw = '\r';
        Str++;
        break;
    case 't':
        *Raw = '\t';
        Str++;
        break;
    case 'x':
        // Hex char value.
        *Raw = (char)strtoul(Str + 1, &Str, 16);
        break;
    default:
        // Verbatim escape.
        *Raw = *Str;
        Str++;
        break;
    }

    return Str;
}

PSTR
BufferStringValue(PSTR* Buf, ULONG Flags,
                  PULONG Len, PCHAR Save)
{
    BOOL Quoted;
    PSTR Str;
    BOOL Escapes = FALSE;

    while (isspace(*(*Buf)))
    {
        (*Buf)++;
    }
    if (*(*Buf) == '"')
    {
        Quoted = TRUE;
        Str = ++(*Buf);
        // If the string is quoted it can always contain spaces.
        Flags &= ~STRV_SPACE_IS_SEPARATOR;
    }
    else if (!*(*Buf) &&
             !(Flags & STRV_ALLOW_EMPTY_STRING))
    {
        // No string at all.
        return NULL;
    }
    else
    {
        Quoted = FALSE;
        Str = *Buf;
        // Escaped characters can only be present in quoted strings.
        Flags &= ~STRV_ALLOW_ESCAPED_CHARACTERS;
    }
    
    while (*(*Buf) &&
           (!(Flags & STRV_SPACE_IS_SEPARATOR) || !isspace(*(*Buf))) &&
           (Quoted || *(*Buf) != ';') &&
           (!Quoted || *(*Buf) != '"'))
    {
        if (Flags & STRV_ALLOW_ESCAPED_CHARACTERS)
        {
            if (*(*Buf) == '\\')
            {
                char Raw;
                
                *Buf = GetEscapedChar((*Buf) + 1, &Raw);
                Escapes = TRUE;
            }
            else
            {
                (*Buf)++;
            }
        }
        else
        {
            (*Buf)++;
        }
    }

    if (Quoted && *(*Buf) != '"')
    {
        return NULL;
    }

    if ((Flags & (STRV_TRIM_TRAILING_SPACE |
                  STRV_NO_MODIFICATION)) == STRV_TRIM_TRAILING_SPACE)
    {
        PSTR Trim = *Buf;

        while (Trim > Str)
        {
            if (isspace(*--Trim))
            {
                *Trim = 0;
            }
            else
            {
                break;
            }
        }
    }
    
    if (Quoted && *(*Buf) == '"')
    {
        if (!(Flags & STRV_ALLOW_EMPTY_STRING) &&
            *Buf == Str)
        {
            return NULL;
        }

        // Require some kind of separator after the
        // string to keep things symmetric with the
        // non-quoted case.
        if (!isspace(*(*Buf + 1)) &&
            *(*Buf + 1) != ';' && *(*Buf + 1) != 0)
        {
            return NULL;
        }
        
        // Null the quote and advance beyond it
        // so that the buffer pointer is always pointing
        // beyond the string on exit.
        if (!(Flags & STRV_NO_MODIFICATION))
        {
            *(*Buf) = 0;
        }

        if (Len)
        {
            *Len = (ULONG)(*Buf - Str);
        }

        (*Buf)++;
    }
    else if (Len)
    {
        *Len = (ULONG)(*Buf - Str);
    }
    
    if (Flags & STRV_NO_MODIFICATION)
    {
        return Str;
    }
    
    *Save = *(*Buf);
    *(*Buf) = 0;

    if (Escapes && (Flags & STRV_COMPRESS_ESCAPED_CHARACTERS))
    {
        CompressEscapes(Str);
    }
    
    return Str;
}

PSTR
StringValue(ULONG Flags, PCHAR Save)
{
    ULONG Len;
    PSTR Str = BufferStringValue((PSTR*)&g_CurCmd, Flags, &Len, Save);
    if (Str == NULL)
    {
        error(SYNTAX);
    }
    return Str;
}

void
CompressEscapes(PSTR Str)
{
    // Scan through a string for character escapes and
    // convert them to their escape value, packing
    // the rest of the string down.  This allows for
    // in-place conversion of strings with escapes
    // inside the command buffer.

    while (*Str)
    {
        if (*Str == '\\')
        {
            char Raw;
            PSTR Slash = Str;
            Str = GetEscapedChar(Slash + 1, &Raw);

            // Copy raw value over backslash and pack down
            // trailing characters.
            *Slash = Raw;
            ULONG Len = strlen(Str) + 1;
            memmove(Slash + 1, Str, Len);
            Str = Slash + 1;
        }
        else
        {
            Str++;
        }
    }
}

void
OpenLogFile(PCSTR File,
            BOOL Append)
{
    // Close any open log file.
    CloseLogFile();

    if (Append)
    {
        g_LogFile = _open(File, O_APPEND | O_CREAT | O_RDWR,
                          S_IREAD | S_IWRITE);
    }
    else
    {
        g_LogFile = _open(File, O_APPEND | O_CREAT | O_TRUNC | O_RDWR,
                          S_IREAD | S_IWRITE);
    }

    if (g_LogFile != -1)
    {
        dprintf("Opened log file '%s'\n", File);
        CopyString(g_OpenLogFileName, File, DIMA(g_OpenLogFileName));
        g_OpenLogFileAppended = Append;

        NotifyChangeEngineState(DEBUG_CES_LOG_FILE, TRUE, TRUE);
    }
    else
    {
        ErrOut("log file could not be opened\n");
    }
}

void
CloseLogFile(void)
{
    if (g_LogFile != -1)
    {
        dprintf("Closing open log file %s\n", g_OpenLogFileName);
        _close(g_LogFile);
        g_LogFile = -1;
        g_OpenLogFileName[0] = 0;
        g_OpenLogFileAppended = FALSE;

        NotifyChangeEngineState(DEBUG_CES_LOG_FILE, FALSE, TRUE);
    }
}

void
ParseLogOpen(BOOL Append)
{
    PSTR FileName;
    char Save;
    char UniqueName[MAX_PATH];
    BOOL AppendTime = FALSE;

    // Don't look for '- as that's a reasonable filename character.
    while (PeekChar() == '/')
    {
        switch(*++g_CurCmd)
        {
        case 't':
            AppendTime = TRUE;
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }

    if (PeekChar() && *g_CurCmd != ';')
    {
        FileName = StringValue(STRV_SPACE_IS_SEPARATOR |
                               STRV_TRIM_TRAILING_SPACE, &Save);
    }
    else
    {
        FileName = (PSTR)g_DefaultLogFileName;
        Save = 0;
    }

    if (AppendTime)
    {
        if (!MakeFileNameUnique(FileName, UniqueName, DIMA(UniqueName),
                                TRUE, NULL))
        {
            error(OVERFLOW);
        }

        FileName = UniqueName;
    }
    
    OpenLogFile(FileName, Append);

    if (Save)
    {
        *g_CurCmd = Save;
    }
}

void
lprintf(PCSTR String)
{
    if (g_LogFile != -1)
    {
        _write(g_LogFile, String, strlen(String));
    }
}

void
OutputSymAddr(ULONG64 Offset,
              ULONG Flags,
              PCSTR Prefix)
{
    CHAR AddrBuffer[MAX_SYMBOL_LEN];
    ULONG64 Displacement;

    GetSymbol(Offset, AddrBuffer, sizeof(AddrBuffer), &Displacement);
    if ((!Displacement || (Flags & SYMADDR_FORCE)) && AddrBuffer[0])
    {
        if (Prefix)
        {
            dprintf("%s", Prefix);
        }
        dprintf("%s", AddrBuffer);
        if (Displacement)
        {
            dprintf("+%s", FormatDisp64(Displacement));
        }
        if (Flags & SYMADDR_OFFSET)
        {
            dprintf(" (%s)", FormatAddr64(Offset));
        }
        if (Flags & SYMADDR_SOURCE)
        {
            OutputLineAddr(Offset, " [%s @ %d]");
        }
        if (Flags & SYMADDR_LABEL)
        {
            dprintf(":\n");
        }
        else
        {
            dprintf(" ");
        }
    }
    else if (Flags & SYMADDR_OFFSET)
    {
        if (Prefix)
        {
            dprintf("%s", Prefix);
        }
        dprintf("%s", FormatAddr64(Offset));
    }
}

BOOL
OutputLineAddr(ULONG64 Offset,
               PCSTR Format)
{
    if ((g_SymOptions & SYMOPT_LOAD_LINES) == 0 ||
        !g_Process)
    {
        return FALSE;
    }
    
    IMAGEHLP_LINE Line;
    DWORD Disp;
            
    if (GetLineFromAddr(g_Process, Offset, &Line, &Disp))
    {
        char DispStr[64];

        if (Disp)
        {
            PrintString(DispStr, DIMA(DispStr), "+0x%x", Disp);
        }
        else
        {
            DispStr[0] = 0;
        }
        
        dprintf(Format, Line.FileName, Line.LineNumber, DispStr);
        return TRUE;
    }

    return FALSE;
}

/*** OutCurInfo - Display selected information about the current register
*                 state.
*
*   Purpose:
*       Source file lines may be shown.
*       Source line information may be shown.
*       Symbol information may be shown.
*       The current register set may be shown.
*       The instruction at the current program current may be disassembled
*       with any effective address displayed.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*   Notes:
*       If the disassembly is of a delayed control instruction, the
*       delay slot instruction is also output.
*
*************************************************************************/

void OutCurInfo(ULONG Flags, ULONG AllMask, ULONG RegMask)
{
    ADDR    PcValue;
    ADDR    DisasmAddr;
    CHAR    Buffer[MAX_DISASM_LEN];
    BOOL    EA;

    if (g_Process == NULL ||
        g_Thread == NULL)
    {
        WarnOut("WARNING: The debugger does not have a current "
                "process or thread\n");
        WarnOut("WARNING: Many commands will not work\n");
    }
    
    if (!IS_MACHINE_SET(g_Target) ||
        g_Process == NULL ||
        g_Thread == NULL ||
        IS_LOCAL_KERNEL_TARGET(g_Target) ||
        ((Flags & OCI_IGNORE_STATE) == 0 && IS_RUNNING(g_CmdState)) ||
        ((IS_KERNEL_FULL_DUMP(g_Target) || IS_KERNEL_SUMMARY_DUMP(g_Target)) &&
         g_Target->m_KdDebuggerData.KiProcessorBlock == 0))
    {
        // State is not available right now.
        return;
    }

    if (g_Thread == g_EventThread)
    {
        g_Thread->OutputEventStrings();
    }
    
    g_Machine->GetPC(&PcValue);

    if ((Flags & (OCI_FORCE_ALL | OCI_FORCE_REG)) ||
        ((g_SrcOptions & SRCOPT_LIST_SOURCE_ONLY) == 0 &&
         (Flags & OCI_ALLOW_REG) &&
         g_OciOutputRegs))
    {
        g_Machine->OutputAll(AllMask, RegMask);
    }

    // Output g_PrevRelatedPc address
    if (Flat(g_PrevRelatedPc) && !AddrEqu(g_PrevRelatedPc, PcValue))
    {
        if (Flags & (OCI_FORCE_ALL | OCI_SYMBOL))
        {
            OutputSymAddr(Flat(g_PrevRelatedPc), SYMADDR_FORCE, NULL);
            dprintf("(%s)", FormatAddr64(Flat(g_PrevRelatedPc)));
        }
        else
        {
            dprintf("%s", FormatAddr64(Flat(g_PrevRelatedPc)));
        }
        dprintf("\n -> ");
    }
        
    // Deliberately does not force source with force-all so that source line
    // support has no effect on default operation.
    if (Flags & (OCI_FORCE_ALL | OCI_FORCE_SOURCE | OCI_ALLOW_SOURCE))
    {
        if (g_SrcOptions & SRCOPT_LIST_SOURCE)
        {
            if (OutputSrcLinesAroundAddr(Flat(PcValue),
                                         g_OciSrcBefore, g_OciSrcAfter) &&
                (Flags & OCI_FORCE_ALL) == 0 &&
                (g_SrcOptions & SRCOPT_LIST_SOURCE_ONLY))
            {
                return;
            }
        }
        else if ((g_SrcOptions & SRCOPT_LIST_LINE) ||
                 (Flags & OCI_FORCE_SOURCE))
        {
            OutputLineAddr(Flat(PcValue), "%s(%d)%s\n");
        }
    }

    if (Flags & (OCI_FORCE_ALL | OCI_SYMBOL))
    {
        OutputSymAddr(Flat(PcValue), SYMADDR_FORCE | SYMADDR_LABEL, NULL);
    }

    if (Flags & (OCI_FORCE_ALL | OCI_DISASM))
    {
        if (Flags & (OCI_FORCE_ALL | OCI_FORCE_EA))
        {
            EA = TRUE;
        }
        else if (Flags & OCI_ALLOW_EA)
        {
            if (IS_DUMP_TARGET(g_Target) || IS_USER_TARGET(g_Target))
            {
                // Always show the EA info.
                EA = TRUE;
            }
            else
            {
                // Only show the EA information if registers were shown.
                EA = g_OciOutputRegs;
            }
        }
        else
        {
            EA = FALSE;
        }

        DisasmAddr = PcValue;
        g_Machine->Disassemble(g_Process, &DisasmAddr, Buffer, EA);
        dprintf("%s", Buffer);
        if (g_Machine->IsDelayInstruction(&PcValue))
        {
            g_Machine->Disassemble(g_Process, &DisasmAddr, Buffer, EA);
            dprintf("%s", Buffer);
        }
    }
}

#define MAX_FORMAT_STRINGS 8

LPSTR
FormatMachineAddr64(
    MachineInfo* Machine,
    ULONG64 Addr
    )
/*++

Routine Description:

    Format a 64 bit address, showing the high bits or not
    according to various flags.

    An array of static string buffers is used, returning a different
    buffer for each successive call so that it may be used multiple
    times in the same printf.

Arguments:

    Addr - Supplies the value to format

Return Value:

    A pointer to the string buffer containing the formatted number

--*/
{
    static CHAR s_Strings[MAX_FORMAT_STRINGS][22];
    static int s_Next = 0;
    LPSTR String;

    String = s_Strings[s_Next];
    ++s_Next;
    if (s_Next >= MAX_FORMAT_STRINGS)
    {
        s_Next = 0;
    }
    if (!Machine)
    {
        sprintf(String, "?%08x`%08x?", (ULONG)(Addr >> 32), (ULONG)Addr);
    }
    else if (Machine->m_Ptr64)
    {
        sprintf(String, "%08x`%08x", (ULONG)(Addr >> 32), (ULONG)Addr);
    }
    else
    {
        sprintf(String, "%08x", (ULONG)Addr);
    }
    return String;
}

LPSTR
FormatDisp64(
    ULONG64 addr
    )
/*++

Routine Description:

    Format a 64 bit address, showing the high bits or not
    according to various flags.  This version does not print
    leading 0's.

    An array of static string buffers is used, returning a different
    buffer for each successive call so that it may be used multiple
    times in the same printf.

Arguments:

    addr - Supplies the value to format

Return Value:

    A pointer to the string buffer containing the formatted number

--*/
{
    static CHAR strings[MAX_FORMAT_STRINGS][20];
    static int next = 0;
    LPSTR string;

    string = strings[next];
    ++next;
    if (next >= MAX_FORMAT_STRINGS)
    {
        next = 0;
    }
    if ((addr >> 32) != 0)
    {
        sprintf(string, "%x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    }
    else
    {
        sprintf(string, "%x", (ULONG)addr);
    }
    return string;
}

DWORD
NetworkPathCheck(
    LPCSTR PathList
    )

/*++

Routine Description:

    Checks if any members of the PathList are network paths.

Arguments:

    PathList - A list of paths separated by ';' characters.

Return Values:

    ERROR_SUCCESS - The path list contained no network or invalid paths.

    ERROR_BAD_PATHNAME - The path list contained one or more invalid paths,
            but no network paths.

    ERROR_FILE_OFFLINE - The path list contained one or more network paths.


Bugs:

    Any path containing the ';' character will totally confuse this function.

--*/

{
    CHAR EndPath0;
    CHAR EndPath1;
    LPSTR EndPath;
    LPSTR StartPath;
    DWORD DriveType;
    LPSTR Buffer = NULL;
    DWORD ret = ERROR_SUCCESS;
    BOOL AddedTrailingSlash = FALSE;

    if (PathList == NULL ||
        *PathList == '\000')
    {
        return FALSE;
    }

    Buffer = (LPSTR) malloc ( strlen (PathList) + 3);
    if (!Buffer)
    {
        return ERROR_BAD_PATHNAME;
    }
    strcpy (Buffer, PathList);
    StartPath = Buffer;

    do
    {
        if (StartPath [0] == '\\' && StartPath [1] == '\\')
        {
            ret = ERROR_FILE_OFFLINE;
            break;
        }

        EndPath = strchr (StartPath, ';');

        if (EndPath == NULL)
        {
            EndPath = StartPath + strlen (StartPath);
            EndPath0 = *EndPath;
        }
        else
        {
            EndPath0 = *EndPath;
            *EndPath = '\000';
        }

        if (EndPath [-1] != '\\')
        {
            EndPath [0] = '\\';
            EndPath1 = EndPath [1];
            EndPath [1] = '\000';
            AddedTrailingSlash = TRUE;
        }

        DriveType = GetDriveType (StartPath);

        if (DriveType == DRIVE_REMOTE)
        {
            ret = ERROR_FILE_OFFLINE;
            break;
        }
        else if (DriveType == DRIVE_UNKNOWN ||
                 DriveType == DRIVE_NO_ROOT_DIR)
        {
            //
            // This is not necessarily an error, but it may merit
            // investigation.
            //

            if (ret == ERROR_SUCCESS)
            {
                ret = ERROR_BAD_PATHNAME;
            }
        }

        EndPath [0] = EndPath0;
        if (AddedTrailingSlash)
        {
            EndPath [1] = EndPath1;
        }
        AddedTrailingSlash = FALSE;

        if (EndPath [ 0 ] == '\000')
        {
            StartPath = NULL;
        }
        else
        {
            StartPath = &EndPath [ 1 ];
        }
    } while (StartPath && *StartPath != '\000');

    free ( Buffer );
    return ret;
}

//----------------------------------------------------------------------------
//
// Returns either an ID value or ALL_ID_LIST.  In theory
// this routine could be expanded to pass back true intervals
// so a full list could be specified.
//
// Originally built up a mask for the multi-ID case but that
// was changed to return a real ID when 32 bits became
// constraining.
//
//----------------------------------------------------------------------------

ULONG
GetIdList(BOOL AllowMulti)
{
    ULONG   Value = 0;
    CHAR    ch;
    CHAR    Digits[20];
    int     i;

    //
    // Change to allow more than 32 break points to be set. Use
    // break point numbers instead of masks.
    //

    if ((ch = PeekChar()) == '*')
    {
        if (!AllowMulti)
        {
            error(SYNTAX);
        }
        
        Value = ALL_ID_LIST;
        g_CurCmd++;
    }
    else if (ch == '[')
    {
        Value = (ULONG)GetTermExpression("Breakpoint ID missing from");
    }
    else
    {
        for (i = 0; i < sizeof(Digits) - 1; i++)
        {
            if (ch >= '0' && ch <= '9')
            {
                Digits[i] = ch;
                ch = *++g_CurCmd;
            }
            else
            {
                break;
            }
        }

        Digits[i] = '\0';

        if (ch == '\0' || ch == ';' || ch == ' ' || ch == '\t')
        {
            Value = strtoul(Digits, NULL, 10);
        }
        else
        {
            error(SYNTAX);
        }
    }

    return Value;
}

void
AppendComponentsToPath(PSTR Path, PCSTR Components,
                       BOOL Validate)
{
    if (!Components || !Components[0])
    {
        return;
    }

    PSTR PathEnd;
    PCSTR Comp;

    PathEnd = Path + strlen(Path);
    Comp = Components;

    while (*Comp)
    {
        PCSTR CompEnd;
        int CompLen;

        CompEnd = strchr(Comp, ';');
        if (CompEnd)
        {
            CompLen = (int)(CompEnd - Comp);
        }
        else
        {
            CompLen = strlen(Comp);
            CompEnd = Comp + CompLen;
        }

        //
        // Check and see if this component is already in the path.
        // If it is, don't add it again.
        //
        
        PCSTR Dup, DupEnd;
        int DupLen;

        Dup = Path;
        while (*Dup)
        {
            DupEnd = strchr(Dup, ';');
            if (DupEnd)
            {
                DupLen = (int)(DupEnd - Dup);
            }
            else
            {
                DupLen = strlen(Dup);
                DupEnd = Dup + DupLen;
            }

            if (DupLen == CompLen &&
                !_memicmp(Comp, Dup, CompLen))
            {
                break;
            }

            Dup = DupEnd + (*DupEnd ? 1 : 0);
        }

        if (!*Dup)
        {
            PSTR OldPathEnd = PathEnd;
            PSTR NewStart;
        
            if (PathEnd > Path)
            {
                *PathEnd++ = ';';
            }
            NewStart = PathEnd;
            memcpy(PathEnd, Comp, CompLen);
            PathEnd += CompLen;
            *PathEnd = 0;
            
            if (Validate && !ValidatePathComponent(NewStart))
            {
                WarnOut("WARNING: %s is not accessible, ignoring\n", NewStart);
                PathEnd = OldPathEnd;
                *PathEnd = 0;
            }
        }

        Comp = CompEnd + (*CompEnd ? 1 : 0);
    }
}

//
// Sets or appends to a semicolon-delimited path.
//
HRESULT
ChangePath(PSTR* Path, PCSTR New, BOOL Append, ULONG SymNotify)
{
    ULONG NewLen, CurLen, TotLen;
    PSTR NewPath;

    if (New != NULL && *New != 0)
    {
        NewLen = strlen(New) + 1;
    }
    else if (Append)
    {
        // Nothing to append.
        return S_OK;
    }
    else
    {
        NewLen = 0;
    }

    if (*Path == NULL || **Path == 0)
    {
        // Nothing to append to.
        Append = FALSE;
    }

    if (Append)
    {
        CurLen = strlen(*Path) + 1;
    }
    else
    {
        CurLen = 0;
    }

    TotLen = CurLen + NewLen;
    if (TotLen > 0)
    {
        NewPath = (PSTR)malloc(TotLen);
        if (NewPath == NULL)
        {
            ErrOut("Unable to allocate memory for path\n");
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        NewPath = NULL;
    }

    PSTR Cat = NewPath;

    if (CurLen > 0)
    {
        memcpy(Cat, *Path, CurLen);
        Cat += CurLen - 1;
    }

    if (NewLen > 0)
    {
        *Cat = 0;
        AppendComponentsToPath(NewPath, New, FALSE);
    }

    if (*Path != NULL)
    {
        free(*Path);
    }
    *Path = NewPath;

    if (SymNotify != 0)
    {
        NotifyChangeSymbolState(SymNotify, 0, g_Process);
    }

    return S_OK;
}

void
CheckPath(PCSTR Path)
{
    PCSTR EltStart;
    PCSTR Scan;
    BOOL Space;

    if (!Path || !Path[0])
    {
        return;
    }

    for (;;)
    {
        BOOL Warned = FALSE;
        
        EltStart = Path;

        Scan = EltStart;
        while (isspace(*Scan))
        {
            Scan++;
        }
        if (Scan != EltStart)
        {
            WarnOut("WARNING: Whitespace at start of path element\n");
            Warned = TRUE;
        }

        // Find the end of the element.
        Space = FALSE;
        while (*Scan && *Scan != ';')
        {
            Space = isspace(*Scan);
            Scan++;
        }

        if (Space)
        {
            WarnOut("WARNING: Whitespace at end of path element\n");
            Warned = TRUE;
        }

        if (Scan - EltStart >= MAX_PATH)
        {
            WarnOut("WARNING: Path element is longer than MAX_PATH\n");
            Warned = TRUE;
        }

        if (Scan == EltStart)
        {
            WarnOut("WARNING: Path element is empty\n");
            Warned = TRUE;
        }
        
        if (!Warned)
        {
            char Elt[MAX_PATH];

            memcpy(Elt, EltStart, Scan - EltStart);
            Elt[Scan - EltStart] = 0;
            
            if (!ValidatePathComponent(Elt))
            {
                WarnOut("WARNING: %s is not accessible\n", Elt);
                Warned = TRUE;
            }
        }

        if (!*Scan)
        {
            break;
        }

        Path = Scan + 1;
    }
}

HRESULT
ChangeString(PSTR* Str, PULONG StrLen, PCSTR New)
{
    ULONG Len;
    PSTR Buf;

    if (New != NULL)
    {
        Len = strlen(New) + 1;
        Buf = new char[Len];
        if (Buf == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        Buf = NULL;
        Len = 0;
    }

    delete [] *Str;

    *Str = Buf;
    if (New != NULL)
    {
        memcpy(Buf, New, Len);
    }
    if (StrLen != NULL)
    {
        *StrLen = Len;
    }

    return S_OK;
}

#if DBG

void
DbgAssertionFailed(PCSTR File, int Line, PCSTR Str)
{
    char Text[512];

    _snprintf(Text, sizeof(Text),
              "Assertion failed: %s(%d)\n  %s\n",
              File, Line, Str);
    Text[sizeof(Text) - 1] = 0;
    OutputDebugStringA(Text);

    if (getenv("DBGENG_ASSERT_BREAK"))
    {
        DebugBreak();
    }
    else
    {
        ErrOut("%s", Text);
        FlushCallbacks();
    }
}

#endif // #if DBG

void
ExceptionRecordTo64(PEXCEPTION_RECORD Rec,
                    PEXCEPTION_RECORD64 Rec64)
{
    ULONG i;

    Rec64->ExceptionCode    = Rec->ExceptionCode;
    Rec64->ExceptionFlags   = Rec->ExceptionFlags;
    Rec64->ExceptionRecord  = (ULONG64)Rec->ExceptionRecord;
    Rec64->ExceptionAddress = (ULONG64)Rec->ExceptionAddress;
    Rec64->NumberParameters = Rec->NumberParameters;
    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++)
    {
        Rec64->ExceptionInformation[i] = Rec->ExceptionInformation[i];
    }
}

void
ExceptionRecord64To(PEXCEPTION_RECORD64 Rec64,
                    PEXCEPTION_RECORD Rec)
{
    ULONG i;

    Rec->ExceptionCode    = Rec64->ExceptionCode;
    Rec->ExceptionFlags   = Rec64->ExceptionFlags;
    Rec->ExceptionRecord  = (PEXCEPTION_RECORD)(ULONG_PTR)
        Rec64->ExceptionRecord;
    Rec->ExceptionAddress = (PVOID)(ULONG_PTR)
        Rec64->ExceptionAddress;
    Rec->NumberParameters = Rec64->NumberParameters;
    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++)
    {
        Rec->ExceptionInformation[i] = (ULONG_PTR)
            Rec64->ExceptionInformation[i];
    }
}

void
MemoryBasicInformationTo64(PMEMORY_BASIC_INFORMATION Mbi,
                           PMEMORY_BASIC_INFORMATION64 Mbi64)
{
#ifdef _WIN64
    memcpy(Mbi64, Mbi, sizeof(*Mbi64));
#else
    Mbi64->BaseAddress = (ULONG64) Mbi->BaseAddress;
    Mbi64->AllocationBase = (ULONG64) Mbi->AllocationBase;
    Mbi64->AllocationProtect = Mbi->AllocationProtect;
    Mbi64->__alignment1 = 0;
    Mbi64->RegionSize = Mbi->RegionSize;
    Mbi64->State = Mbi->State;
    Mbi64->Protect = Mbi->Protect;
    Mbi64->Type = Mbi->Type;
    Mbi64->__alignment2 = 0;
#endif
}

void
MemoryBasicInformation32To64(PMEMORY_BASIC_INFORMATION32 Mbi32,
                             PMEMORY_BASIC_INFORMATION64 Mbi64)
{
    Mbi64->BaseAddress = EXTEND64(Mbi32->BaseAddress);
    Mbi64->AllocationBase = EXTEND64(Mbi32->AllocationBase);
    Mbi64->AllocationProtect = Mbi32->AllocationProtect;
    Mbi64->__alignment1 = 0;
    Mbi64->RegionSize = Mbi32->RegionSize;
    Mbi64->State = Mbi32->State;
    Mbi64->Protect = Mbi32->Protect;
    Mbi64->Type = Mbi32->Type;
    Mbi64->__alignment2 = 0;
}

void
DebugEvent32To64(LPDEBUG_EVENT32 Event32,
                 LPDEBUG_EVENT64 Event64)
{
    Event64->dwDebugEventCode = Event32->dwDebugEventCode;
    Event64->dwProcessId = Event32->dwProcessId;
    Event64->dwThreadId = Event32->dwThreadId;
    Event64->__alignment = 0;
    
    switch(Event32->dwDebugEventCode)
    {
    case EXCEPTION_DEBUG_EVENT:
        ExceptionRecord32To64(&Event32->u.Exception.ExceptionRecord,
                              &Event64->u.Exception.ExceptionRecord);
        Event64->u.Exception.dwFirstChance =
            Event32->u.Exception.dwFirstChance;
        break;
        
    case CREATE_THREAD_DEBUG_EVENT:
        Event64->u.CreateThread.hThread =
            EXTEND64(Event32->u.CreateThread.hThread);
        Event64->u.CreateThread.lpThreadLocalBase =
            EXTEND64(Event32->u.CreateThread.lpThreadLocalBase);
        Event64->u.CreateThread.lpStartAddress =
            EXTEND64(Event32->u.CreateThread.lpStartAddress);
        break;
        
    case CREATE_PROCESS_DEBUG_EVENT:
        Event64->u.CreateProcessInfo.hFile =
            EXTEND64(Event32->u.CreateProcessInfo.hFile);
        Event64->u.CreateProcessInfo.hProcess =
            EXTEND64(Event32->u.CreateProcessInfo.hProcess);
        Event64->u.CreateProcessInfo.hThread =
            EXTEND64(Event32->u.CreateProcessInfo.hThread);
        Event64->u.CreateProcessInfo.lpBaseOfImage =
            EXTEND64(Event32->u.CreateProcessInfo.lpBaseOfImage);
        Event64->u.CreateProcessInfo.dwDebugInfoFileOffset =
            Event32->u.CreateProcessInfo.dwDebugInfoFileOffset;
        Event64->u.CreateProcessInfo.nDebugInfoSize =
            Event32->u.CreateProcessInfo.nDebugInfoSize;
        Event64->u.CreateProcessInfo.lpThreadLocalBase =
            EXTEND64(Event32->u.CreateProcessInfo.lpThreadLocalBase);
        Event64->u.CreateProcessInfo.lpStartAddress =
            EXTEND64(Event32->u.CreateProcessInfo.lpStartAddress);
        Event64->u.CreateProcessInfo.lpImageName =
            EXTEND64(Event32->u.CreateProcessInfo.lpImageName);
        Event64->u.CreateProcessInfo.fUnicode =
            Event32->u.CreateProcessInfo.fUnicode;
        break;
        
    case EXIT_THREAD_DEBUG_EVENT:
        Event64->u.ExitThread.dwExitCode =
            Event32->u.ExitThread.dwExitCode;
        break;
        
    case EXIT_PROCESS_DEBUG_EVENT:
        Event64->u.ExitProcess.dwExitCode =
            Event32->u.ExitProcess.dwExitCode;
        break;
        
    case LOAD_DLL_DEBUG_EVENT:
        Event64->u.LoadDll.hFile =
            EXTEND64(Event32->u.LoadDll.hFile);
        Event64->u.LoadDll.lpBaseOfDll =
            EXTEND64(Event32->u.LoadDll.lpBaseOfDll);
        Event64->u.LoadDll.dwDebugInfoFileOffset =
            Event32->u.LoadDll.dwDebugInfoFileOffset;
        Event64->u.LoadDll.nDebugInfoSize =
            Event32->u.LoadDll.nDebugInfoSize;
        Event64->u.LoadDll.lpImageName =
            EXTEND64(Event32->u.LoadDll.lpImageName);
        Event64->u.LoadDll.fUnicode =
            Event32->u.LoadDll.fUnicode;
        break;
        
    case UNLOAD_DLL_DEBUG_EVENT:
        Event64->u.UnloadDll.lpBaseOfDll =
            EXTEND64(Event32->u.UnloadDll.lpBaseOfDll);
        break;
        
    case OUTPUT_DEBUG_STRING_EVENT:
        Event64->u.DebugString.lpDebugStringData =
            EXTEND64(Event32->u.DebugString.lpDebugStringData);
        Event64->u.DebugString.fUnicode =
            Event32->u.DebugString.fUnicode;
        Event64->u.DebugString.nDebugStringLength =
            Event32->u.DebugString.nDebugStringLength;
        break;
        
    case RIP_EVENT:
        Event64->u.RipInfo.dwError =
            Event32->u.RipInfo.dwError;
        Event64->u.RipInfo.dwType =
            Event32->u.RipInfo.dwType;
        break;
    }
}

#define COPYSE(p64, p32, f) p64->f = (ULONG64)(LONG64)(LONG)p32->f

void
WaitStateChange32ToAny(IN PDBGKD_WAIT_STATE_CHANGE32 Ws32,
                       IN ULONG ControlReportSize,
                       OUT PDBGKD_ANY_WAIT_STATE_CHANGE WsAny)
{
    WsAny->NewState = Ws32->NewState;
    WsAny->ProcessorLevel = Ws32->ProcessorLevel;
    WsAny->Processor = Ws32->Processor;
    WsAny->NumberProcessors = Ws32->NumberProcessors;
    COPYSE(WsAny, Ws32, Thread);
    COPYSE(WsAny, Ws32, ProgramCounter);
    memcpy(&WsAny->ControlReport, Ws32 + 1, ControlReportSize);
    if (Ws32->NewState == DbgKdLoadSymbolsStateChange)
    {
        DbgkdLoadSymbols32To64(&Ws32->u.LoadSymbols, &WsAny->u.LoadSymbols);
    }
    else
    {
        DbgkmException32To64(&Ws32->u.Exception, &WsAny->u.Exception);
    }
}

#undef COPYSE

PSTR
TimeToStr(ULONG TimeDateStamp)
{
    LPSTR TimeDateStr;

    // Handle invalid \ page out timestamps, since ctime blows up on
    // this number

    if ((TimeDateStamp == 0) || (TimeDateStamp == UNKNOWN_TIMESTAMP))
    {
        return "unavailable";
    }
    else if (IS_LIVE_KERNEL_TARGET(g_Target) && TimeDateStamp == 0x49ef6f00)
    {
        // At boot time the shared memory data area is not
        // yet initialized.  The above value seems to be
        // the random garbage that's there so detect it and
        // ignore it.  This is highly fragile but people
        // keep asking about the garbage value.
        return "unavailable until booted";
    }
    else
    {
        // TimeDateStamp is always a 32 bit quantity on the target,
        // and we need to sign extend for 64 bit host since time_t
        // has been extended to 64 bits.


        time_t TDStamp = (time_t) (LONG) TimeDateStamp;
        TimeDateStr = ctime((time_t *)&TDStamp);

        if (TimeDateStr)
        {
            TimeDateStr[strlen(TimeDateStr) - 1] = 0;
        }
        else
        {
            TimeDateStr = "***** Invalid";
        }
    }

    return TimeDateStr;
}

PSTR LONG64FileTimeToStr(LONG64 UTCFileTimeStamp)
{
    FILETIME FileTime;

    FileTime.dwLowDateTime = (DWORD) UTCFileTimeStamp;
    FileTime.dwHighDateTime = (DWORD)(UTCFileTimeStamp >> 32);

    return FileTimeToStr(FileTime);
}

PSTR
FileTimeToStr(FILETIME UTCFileTime)
{
    //
    // Need to be able to store time string in this format:
    // Time:    Wed Dec 31 16:00:05.000 1969 (GMT-8)
    // Test value: .formats 1c100d2`1a18ff24
    // Should display: Fri Jun 29 12:31:32.406 2001 (GMT-7)
    //
    static CHAR TimeDateBuffer[39];
    PSTR TimeDateStr = TimeDateBuffer;
    FILETIME LocalFileTime;
    SYSTEMTIME UTCSysTime, LocalSysTime;
    SHORT GMTBias = 0;

    //
    // Note: month value is 1-based, day is 0-based
    //
    static LPSTR Months[] = {
        "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    };
    static LPSTR Days[] = {
        "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
    };

    FileTimeToLocalFileTime(&UTCFileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, &LocalSysTime);
    FileTimeToSystemTime(&UTCFileTime, &UTCSysTime);
    GMTBias = LocalSysTime.wHour - UTCSysTime.wHour;

    ZeroMemory(TimeDateBuffer, sizeof(TimeDateBuffer) / sizeof(TimeDateBuffer[0]));

    //
    // Ensure this looks like valid SYSTEMTIME
    //
    if ( (LocalSysTime.wYear > 1600) &&
         (LocalSysTime.wYear < 30827) &&
         (LocalSysTime.wMonth > 0) &&
         (LocalSysTime.wMonth < 13) &&
         (LocalSysTime.wDayOfWeek >= 0) &&
         (LocalSysTime.wDayOfWeek < 7) &&
         (LocalSysTime.wDay > 0) &&
         (LocalSysTime.wDay < 32) &&
         (LocalSysTime.wHour > 0) &&
         (LocalSysTime.wHour < 24) &&
         (LocalSysTime.wMilliseconds >= 0) &&
         (LocalSysTime.wMilliseconds < 1000) )
    {
        PrintString(TimeDateBuffer, DIMA(TimeDateBuffer),
                "%s %s %2d %02d:%02d:%02d.%03d %d (GMT%c%d)",
                Days[LocalSysTime.wDayOfWeek],
                Months[LocalSysTime.wMonth - 1],
                LocalSysTime.wDay,
                LocalSysTime.wHour,
                LocalSysTime.wMinute,
                LocalSysTime.wSecond,
                LocalSysTime.wMilliseconds,
                LocalSysTime.wYear,
                (GMTBias < 0) ? '-' : '+',
                abs(GMTBias) );
    }
    else
    {
        PrintString(TimeDateBuffer, DIMA(TimeDateBuffer), "***** Invalid FILETIME");
    }

    return TimeDateStr;
}

PSTR
DurationToStr(ULONG64 Duration)
{
    ULONG Seconds = FileTimeToTime(Duration);
    ULONG Millis = (ULONG)(Duration - TimeToFileTime(Seconds)) / 10000;
    ULONG Minutes = Seconds / 60;
    ULONG Hours = Minutes / 60;
    ULONG Days = Hours / 24;
    static char s_Buf[128];
    
    PrintString(s_Buf, DIMA(s_Buf), "%d days %d:%02d:%02d.%03d",
                Days, Hours % 24, Minutes % 60, Seconds % 60, Millis);
    return s_Buf;
}

PCSTR
PathTail(PCSTR Path)
{
    PCSTR Tail = Path + strlen(Path);
    while (--Tail >= Path)
    {
        if (*Tail == '\\' || *Tail == '/' || *Tail == ':')
        {
            break;
        }
    }

    return Tail + 1;
}

PCWSTR
PathTailW(PCWSTR Path)
{
    PCWSTR Tail = Path + wcslen(Path);
    while (--Tail >= Path)
    {
        if (*Tail == L'\\' || *Tail == L'/' || *Tail == L':')
        {
            break;
        }
    }

    return Tail + 1;
}

BOOL
MatchPathTails(PCSTR Path1, PCSTR Path2, BOOL Wild)
{
    PCSTR Tail1 = PathTail(Path1);
    PCSTR Tail2 = PathTail(Path2);

    return
        (!Wild && !_stricmp(Tail1, Tail2)) ||
        (Wild && MatchPattern((PSTR)Tail2, (PSTR)Tail1));
}

BOOL
IsValidName(PSTR String)
{
    while (*String)
    {
        if (*String < 0x20 || *String > 0x7e)
        {
            return FALSE;
        }
        if (isalnum(*String))
        {
            return TRUE;
        }
        ++String;
    }
    
    return FALSE;
}

BOOL
MakeFileNameUnique(PSTR OriginalName,
                   PSTR Buffer, ULONG BufferChars,
                   BOOL AppendTime, ProcessInfo* Pid)
{
    SYSTEMTIME Time;
    ULONG AppendAt;
    PSTR Dot;
    char Ext[8];

    if (!CopyString(Buffer, OriginalName, BufferChars))
    {
        return FALSE;
    }
    
    Dot = strrchr(Buffer, '.');
    if (Dot && strlen(Dot) < sizeof(Ext) - 1)
    {
        strcpy(Ext, Dot);
        *Dot = 0;
    }
    else
    {
        Dot = NULL;
    }

    if (AppendTime)
    {
        GetLocalTime(&Time);
        AppendAt = strlen(Buffer);
        if (!PrintString(Buffer + AppendAt, BufferChars - AppendAt,
                         "_%04d-%02d-%02d_%02d-%02d-%02d-%03d",
                         Time.wYear, Time.wMonth, Time.wDay,
                         Time.wHour, Time.wMinute, Time.wSecond,
                         Time.wMilliseconds))
        {
            return FALSE;
        }
    }

    if (Pid)
    {
        AppendAt = strlen(Buffer);
        if (!PrintString(Buffer + AppendAt, BufferChars - AppendAt,
                         "_%04X", Pid->m_SystemId))
        {
            return FALSE;
        }
    }
        
    if (Dot)
    {
        if (!CatString(Buffer, Ext, BufferChars))
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
GetEngineDirectory(PSTR Buffer, ULONG BufferChars)
{
    DBG_ASSERT(BufferChars >= 16);
    
    if (!GetModuleFileName(GetModuleHandle(ENGINE_DLL_NAME),
                           Buffer, BufferChars))
    {
        // Error.  Use the current directory.
        strcpy(Buffer, ".");
        return FALSE;
    }

    //
    // Remove the image name.
    //
    
    PSTR Tmp = strrchr(Buffer, '\\');
    if (!Tmp)
    {
        Tmp = strrchr(Buffer, '/');
        if (!Tmp)
        {
            Tmp = strrchr(Buffer, ':');
            if (!Tmp)
            {
                return TRUE;
            }
            
            Tmp++;
        }
    }
    
    *Tmp = 0;
    return TRUE;
}

BOOL
IsInternalPackage(void)
{
    static HRESULT s_Result = E_NOINTERFACE;
    char EngPath[MAX_PATH];
    HANDLE TriageFile;
    char TriageText[64];
    ULONG Done;

    if (SUCCEEDED(s_Result))
    {
        return s_Result == S_OK;
    }
    
    //
    // Determine if this is an internal Microsoft debugger
    // package.  Internal packages assume the existence of
    // internal servers and so on, so conservatively assume
    // this is an external package unless we're sure it's
    // an internal package.
    //

    if (!GetEngineDirectory(EngPath, DIMA(EngPath)))
    {
        return FALSE;
    }
    
    if (!CatString(EngPath, "\\winxp\\triage.ini", DIMA(EngPath)))
    {
        return FALSE;
    }
    
    TriageFile = CreateFile(EngPath, GENERIC_READ, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                            NULL);
    if (TriageFile == INVALID_HANDLE_VALUE)
    {
        // Couldn't find triage.ini, may be a system ntsd or
        // just some other problem.  If it's file-not-found
        // we don't want to keep hitting this case so
        // mark things as external.
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            s_Result = S_FALSE;
        }
        return FALSE;
    }

    s_Result = S_FALSE;

    if (ReadFile(TriageFile, TriageText, sizeof(TriageText),
                 &Done, NULL) && Done > 17 &&
        !_strnicmp(TriageText, ";internal_package", 17))
    {
        s_Result = S_OK;
    }
    
    CloseHandle(TriageFile);

    return s_Result == S_OK;
}

void
TranslateNtPathName(PSTR Path)
{
    if (Path[0] == '\\' &&
        Path[1] == '?' &&
        Path[2] == '?' &&
        Path[3] == '\\')
    {
        ULONG Len = strlen(Path) + 1;
        
        if (Path[4] == 'U' &&
            Path[5] == 'N' &&
            Path[6] == 'C' &&
            Path[7] == '\\')
        {
            // Compress \??\UNC\ to \\.
            memmove(Path + 1, Path + 7, Len - 7);
        }
        else
        {
            // Remove \??\.
            memmove(Path, Path + 4, Len - 4);
        }
    }
}
//----------------------------------------------------------------------------
//
// Shell process support.
//
//----------------------------------------------------------------------------

ULONG ShellProcess::s_PipeSerialNumber;

ShellProcess::ShellProcess(void)
{
    m_IoIn = NULL;
    m_IoOut = NULL;
    m_ProcIn = NULL;
    m_ProcOut = NULL;
    m_ProcErr = NULL;
    m_IoSignal = NULL;
    m_ProcThread = NULL;
    m_Process = NULL;
    m_ReaderThread = NULL;
    m_DefaultTimeout = 1000;
}

ShellProcess::~ShellProcess(void)
{
    Close();
}

DWORD
ShellProcess::ReaderThread(void)
{
    OVERLAPPED Overlapped;
    HANDLE WaitHandles[2];
    DWORD Error = NO_ERROR;
    UCHAR Buffer[_MAX_PATH];
    DWORD BytesRead;
    DWORD WaitStatus;

    ZeroMemory(&Overlapped, sizeof(Overlapped));
    Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (Overlapped.hEvent == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    WaitHandles[0] = Overlapped.hEvent;
    WaitHandles[1] = m_Process;

    //
    // wait for data on handle 1.
    // wait for signal on handle 2.
    //

    while (1)
    {
        //
        // Initiate the read.
        //

        ResetEvent(Overlapped.hEvent);

        if (ReadFile(m_IoOut, Buffer, sizeof(Buffer) - 1,
                     &BytesRead, &Overlapped))
        {
            //
            // Read has successfully completed, print and repeat.
            //

            Buffer[BytesRead] = 0;
            dprintf("%s", Buffer);

            // Notify the main thread that output was produced.
            SetEvent(m_IoSignal);
        }
        else
        {
            Error = GetLastError();
            if (Error != ERROR_IO_PENDING)
            {
                // The pipe can be broken if the user
                // does .shell_quit to abandon the child process.
                // There are also some other cases, but in general
                // it means that the other end of the pipe has gone
                // away so we can just stop reading.
                if (Error != ERROR_BROKEN_PIPE)
                {
                    dprintf(".shell: ReadFile failed, error == %d\n", Error);
                }
                break;
            }
            Error = NO_ERROR;

            // Flush output before waiting.
            FlushCallbacks();

            WaitStatus = WaitForMultipleObjects(2, WaitHandles, FALSE,
                                                INFINITE);
            if (WaitStatus == WAIT_OBJECT_0)
            {
                if (GetOverlappedResult(m_IoOut, &Overlapped,
                                        &BytesRead, TRUE))
                {
                    //
                    // Read has successfully completed
                    //
                    Buffer[BytesRead] = 0;
                    dprintf("%s", Buffer);

                    // Notify the main thread that output was produced.
                    SetEvent(m_IoSignal);
                }
                else
                {
                    Error = GetLastError();
                    if (Error != ERROR_BROKEN_PIPE)
                    {
                        dprintf(".shell: GetOverlappedResult failed, "
                                "error == %d\n", Error);
                    }
                    break;
                }
            }
            else if (WaitStatus == WAIT_OBJECT_0 + 1)
            {
                //
                // process exited.
                //
                dprintf(".shell: Process exited\n");
                break;
            }
            else
            {
                Error = GetLastError();
                dprintf(".shell: WaitForMultipleObjects failed; error == %d\n",
                        Error);
                break;
            }
        }
    }

    CloseHandle(Overlapped.hEvent);

    if (!Error && m_IoIn)
    {
        dprintf("Press ENTER to continue\n");
    }

    // Flush all remaining output.
    FlushCallbacks();

    // Notify the main thread that output was produced.
    SetEvent(m_IoSignal);

    return NO_ERROR;
}

DWORD WINAPI
ShellProcess::ReaderThreadCb(LPVOID Param)
{
    return ((ShellProcess*)Param)->ReaderThread();
}

BOOL
ShellProcess::CreateAsyncPipePair(OUT LPHANDLE ReadPipe,
                                  OUT LPHANDLE WritePipe,
                                  IN LPSECURITY_ATTRIBUTES SecAttr,
                                  IN DWORD Size,
                                  IN DWORD ReadMode,
                                  IN DWORD WriteMode)
{
    HANDLE ReadPipeHandle, WritePipeHandle;
    CHAR PipeNameBuffer[MAX_PATH];

    //
    // Only one valid OpenMode flag - FILE_FLAG_OVERLAPPED
    //

    if ((ReadMode | WriteMode) & (~FILE_FLAG_OVERLAPPED))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (Size == 0)
    {
        Size = 4096;
    }

    sprintf(PipeNameBuffer,
            "\\\\.\\Pipe\\Win32PipesEx.%08x.%08x",
            GetCurrentProcessId(),
            s_PipeSerialNumber++);

    //
    //  Set the default timeout to 120 seconds
    //

    ReadPipeHandle = CreateNamedPipeA(PipeNameBuffer,
                                      PIPE_ACCESS_INBOUND | ReadMode,
                                      PIPE_TYPE_BYTE | PIPE_WAIT,
                                      1,             // Number of pipes
                                      Size,          // Out buffer size
                                      Size,          // In buffer size
                                      120 * 1000,    // Timeout in ms
                                      SecAttr);
    if (ReadPipeHandle == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    WritePipeHandle = CreateFileA(PipeNameBuffer,
                                  GENERIC_WRITE,
                                  0,                         // No sharing
                                  SecAttr,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL | WriteMode,
                                  NULL);                     // Template file
    if (WritePipeHandle == INVALID_HANDLE_VALUE)
    {
        DWORD Error = GetLastError();
        CloseHandle(ReadPipeHandle);
        SetLastError(Error);
        return FALSE;
    }

    *ReadPipe = ReadPipeHandle;
    *WritePipe = WritePipeHandle;
    return TRUE;
}

HRESULT
ShellProcess::Start(PCSTR CmdString,
                    PCSTR InFile,
                    PCSTR OutFile,
                    PCSTR ErrFile)
{
    SECURITY_ATTRIBUTES SecAttr;

    // If output is going to a file input must
    // come from a file since the user won't see
    // any output to know whether input is necessary.
    if (OutFile && !InFile)
    {
        ErrOut(".shell: Input must be redirected with output\n");
        return E_INVALIDARG;
    }

    SecAttr.nLength = sizeof(SecAttr);
    SecAttr.lpSecurityDescriptor = NULL;
    SecAttr.bInheritHandle = TRUE;

    //
    // If the debugger always ran through stdin/stdout, we
    // could just run a shell and wait for it.  However, in order
    // to handle fDebugOutput, we have to open pipes and manage
    // the i/o stream for the shell.  Since we need to have that
    // code anyway, always use it.
    //

    if (InFile)
    {
        //
        // Open a file for the child process to use for input.
        //

        m_ProcIn = CreateFile(InFile, GENERIC_READ, FILE_SHARE_READ,
                              &SecAttr, OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL, NULL);
        if (m_ProcIn == INVALID_HANDLE_VALUE)
        {
            m_ProcIn = NULL;
            ErrOut(".shell: Unable to open %s\n", InFile);
            goto Exit;
        }
    }
    else
    {
        //
        // Create stdin pipe for debugger->shell.
        // Neither end needs to be overlapped.
        //

        if (!CreateAsyncPipePair(&m_ProcIn, &m_IoIn,
                                 &SecAttr, 0, 0, 0))
        {
            ErrOut(".shell: Unable to create stdin pipe.\n");
            goto Exit;
        }

        //
        // We don't want the shell to inherit our end of the pipe
        // so duplicate it to a non-inheritable one.
        //

        if (!DuplicateHandle(GetCurrentProcess(), m_IoIn,
                             GetCurrentProcess(), &m_IoIn,
                             0, FALSE,
                             DUPLICATE_SAME_ACCESS |
                             DUPLICATE_CLOSE_SOURCE))
        {
            ErrOut(".shell: Unable to duplicate stdin handle.\n");
            goto Exit;
        }
    }

    if (OutFile)
    {
        //
        // Open a file for the child process to use for output.
        //

        m_ProcOut = CreateFile(OutFile, GENERIC_WRITE, 0,
                              &SecAttr, CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);
        if (m_ProcOut == INVALID_HANDLE_VALUE)
        {
            m_ProcOut = NULL;
            ErrOut(".shell: Unable to create %s\n", OutFile);
            goto Exit;
        }
    }
    else
    {
        //
        // Create stdout shell->debugger pipe
        //

        if (!CreateAsyncPipePair(&m_IoOut, &m_ProcOut,
                                 &SecAttr, 0, FILE_FLAG_OVERLAPPED, 0))
        {
            ErrOut(".shell: Unable to create stdout pipe.\n");
            goto Exit;
        }

        //
        // We don't want the shell to inherit our end of the pipe
        // so duplicate it to a non-inheritable one.
        //

        if (!DuplicateHandle(GetCurrentProcess(), m_IoOut,
                             GetCurrentProcess(), &m_IoOut,
                             0, FALSE,
                             DUPLICATE_SAME_ACCESS |
                             DUPLICATE_CLOSE_SOURCE))
        {
            ErrOut(".shell: Unable to duplicate local stdout handle.\n");
            goto Exit;
        }
    }

    if (ErrFile)
    {
        //
        // Open a file for the child process to use for error output.
        //

        m_ProcErr = CreateFile(ErrFile, GENERIC_WRITE, 0,
                              &SecAttr, CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);
        if (m_ProcErr == INVALID_HANDLE_VALUE)
        {
            m_ProcErr = NULL;
            ErrOut(".shell: Unable to create %s\n", ErrFile);
            goto Exit;
        }
    }
    else
    {
        //
        // Duplicate shell's stdout to a new stderr.
        //

        if (!DuplicateHandle(GetCurrentProcess(), m_ProcOut,
                             GetCurrentProcess(), &m_ProcErr,
                             0, TRUE,
                             DUPLICATE_SAME_ACCESS))
        {
            ErrOut(".shell: Unable to duplicate stdout handle for stderr.\n");
            goto Exit;
        }
    }

    //
    // Create an event for output monitoring.
    //

    m_IoSignal = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_IoSignal == NULL)
    {
        ErrOut(".shell: Unable to allocate event.\n");
        goto Exit;
    }

    CHAR Shell[_MAX_PATH];
    CHAR Command[2 * _MAX_PATH];

    if (!GetEnvironmentVariable("SHELL", Shell, DIMA(Shell)))
    {
        if (!GetEnvironmentVariable("ComSpec", Shell, DIMA(Shell)))
        {
            strcpy(Shell, "cmd.exe");
        }
    }

    // Skip leading whitespace on the command string.
    // Some commands, such as "net use", can't handle it.
    if (CmdString != NULL)
    {
        while (isspace(*CmdString))
        {
            CmdString++;
        }
    }

    if (CmdString && *CmdString)
    {
        //
        // If there was a command, use SHELL /c Command
        //
        if (!CopyString(Command, Shell, DIMA(Command)) ||
            !CatString(Command, " /c \"", DIMA(Command)) ||
            !CatString(Command, CmdString, DIMA(Command)) ||
            !CatString(Command, "\"", DIMA(Command)))
        {
            ErrOut(".shell: Not enough room for command line\n");
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Exit;
        }
    }
    else
    {
        //
        // If there was no command, just run the shell
        //
        strcpy(Command, Shell);
    }

    STARTUPINFO StartInfo;
    PROCESS_INFORMATION ProcInfo;

    ZeroMemory(&StartInfo, sizeof(StartInfo));
    StartInfo.cb = sizeof(StartInfo);
    StartInfo.dwFlags = STARTF_USESTDHANDLES;
    StartInfo.hStdInput = m_ProcIn;
    StartInfo.hStdOutput = m_ProcOut;
    StartInfo.hStdError = m_ProcErr;
    StartInfo.wShowWindow = SW_SHOW;

    ZeroMemory(&ProcInfo, sizeof(ProcInfo));

    //
    // Create Child Process
    //

    if (!CreateProcess(NULL, Command, NULL, NULL, TRUE,
                       GetPriorityClass(GetCurrentProcess()),
                       NULL, NULL, &StartInfo, &ProcInfo))
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            ErrOut("%s not found\n", Shell);
        }
        else
        {
            HRESULT Status = WIN32_LAST_STATUS();
            ErrOut("CreateProcess(%s) failed, %s.\n    \"%s\"\n",
                   Command, FormatStatusCode(Status), FormatStatus(Status));
        }
        goto Exit;
    }

    m_Process = ProcInfo.hProcess;
    m_ProcThread = ProcInfo.hThread;

    if (m_IoOut)
    {
        DWORD ThreadId;

        //
        // Start reader thread to copy shell output
        //

        m_ReaderThread = CreateThread(NULL, 0, ReaderThreadCb,
                                      this, 0, &ThreadId);
        if (!m_ReaderThread)
        {
            ErrOut(".shell: Unable to create reader thread\n");
            goto Exit;
        }
    }

    WaitForProcessExit();

    Close();
    return S_OK;

 Exit:
    Close();
    return WIN32_LAST_STATUS();
}

void
ShellProcess::WaitForProcessExit(void)
{
    CHAR InputBuffer[MAX_PATH];
    DWORD BytesWritten;
    ULONG Timeout;
    ULONG BaseTimeout;
    ULONG CheckTimeout;
    BOOL ProcessExited = FALSE;

    //
    // Feed input to shell if necessary; wait for it to exit.
    //

    BaseTimeout = m_IoIn ? m_DefaultTimeout : 10 * m_DefaultTimeout;
    CheckTimeout = BaseTimeout / 10;
    Timeout = BaseTimeout;
    while (1)
    {
        ULONG WaitStatus;

        // Give the other process a little time to run.
        // This is critical when output is being piped
        // across kd as GetInput causes the machine to
        // sit in the kernel debugger input routine and
        // nobody gets any time to run.
        if (m_IoOut &&
            WaitForSingleObject(m_IoSignal, CheckTimeout) == WAIT_OBJECT_0)
        {
            // Reset the timeout since the process seems to
            // be active.
            Timeout = BaseTimeout;

            // Some output was produced so let the child keep
            // running to keep the output flowing.  If this
            // was the final output of the process, though,
            // go to the last input request.
            if (WaitForSingleObject(m_Process, 0) != WAIT_OBJECT_0)
            {
                continue;
            }
            else if (!m_IoIn)
            {
                ProcessExited = TRUE;
                break;
            }
        }

        // We've run out of immediate output, so wait for a
        // larger interval to give the process a reasonable
        // amount of time to run.  Show a message to keep
        // users in the loop.
        dprintf("<.shell waiting %d second(s) for process>\n",
                Timeout / 1000);
        FlushCallbacks();

        if (m_IoOut)
        {
            WaitStatus = WaitForSingleObject(m_IoSignal, Timeout);
            if (WaitStatus == WAIT_OBJECT_0 &&
                WaitForSingleObject(m_Process, 0) != WAIT_OBJECT_0)
            {
                // Reset the timeout since the process seems to
                // be active.
                Timeout = BaseTimeout;
                continue;
            }
        }
        else
        {
            if (WaitForSingleObject(m_Process, Timeout) == WAIT_OBJECT_0)
            {
                ProcessExited = TRUE;
                break;
            }
        }

        GetInput(m_IoIn ?
                 "<.shell process may need input>" :
                 "<.shell running: .shell_quit to abandon, ENTER to wait>",
                 InputBuffer, DIMA(InputBuffer) - 2, GETIN_LOG_INPUT_LINE);

        // The user may not want to wait, so check for
        // a magic input string that'll abandon the process.
        if (!_strcmpi(InputBuffer, ".shell_quit"))
        {
            break;
        }

        //
        // see if client is still running
        //
        if (m_IoOut && WaitForSingleObject(m_Process, 0) == WAIT_OBJECT_0)
        {
            ProcessExited = TRUE;
            break;
        }

        //
        // GetInput always returns a string without a newline
        //
        if (m_IoIn)
        {
            strcat(InputBuffer, "\n");
            if (!WriteFile(m_IoIn, InputBuffer, strlen(InputBuffer),
                           &BytesWritten, NULL))
            {
                //
                // if the write fails, we're done...
                //
                break;
            }
        }

        // The process has some input to chew on so
        // increase the amount of time we'll wait for it.
        Timeout *= 2;
    }

    if (ProcessExited)
    {
        if (!m_IoOut)
        {
            dprintf(".shell: Process exited\n");
        }
        else
        {
            // Give the reader thread time to finish up
            // with any last input.
            WaitForSingleObject(m_ReaderThread, INFINITE);
        }
    }
}

#define HCLOSE(Handle) \
    ((Handle) ? (CloseHandle(Handle), (Handle) = NULL) : NULL)

void
ShellProcess::Close(void)
{
    // Close all of the I/O handles first.
    // That will make the reader thread exit if it was running.
    HCLOSE(m_IoIn);
    HCLOSE(m_IoOut);
    HCLOSE(m_ProcIn);
    HCLOSE(m_ProcOut);
    HCLOSE(m_ProcErr);

    // Wait for the reader thread to exit.
    if (m_ReaderThread)
    {
        WaitForSingleObject(m_ReaderThread, INFINITE);
        HCLOSE(m_ReaderThread);
    }

    // Now close the child process handles.
    HCLOSE(m_ProcThread);
    HCLOSE(m_Process);

    // Close this handle after the reader thread has exited
    // to avoid it using a bad handle.
    HCLOSE(m_IoSignal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\vdm.h ===
//----------------------------------------------------------------------------
//
// vdm.h
//
// VDM debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _VDM_H_
#define _VDM_H_

#if 0
BOOL fVDMInitDone;
BOOL fVDMActive;
VDMPROCESSEXCEPTIONPROC pfnVDMProcessException;
VDMGETTHREADSELECTORENTRYPROC pfnVDMGetThreadSelectorEntry;
VDMGETPOINTERPROC pfnVDMGetPointer;
VDMGETCONTEXTPROC pfnVDMGetContext;
VDMSETCONTEXTPROC pfnVDMSetContext;
VDMGETSELECTORMODULEPROC pfnVDMGetSelectorModule;
#endif

typedef struct _segentry {
    int     type;
    LPSTR   path_name;
    WORD    selector;
    WORD    segment;
    DWORD   ImgLen;    // MODLOAD only
} SEGENTRY;

extern SEGENTRY segtable[];

ULONG VDMEvent(DEBUG_EVENT64* Event);
#define VDMEVENT_HANDLED STATUS_VDM_EVENT
#define VDMEVENT_NOT_HANDLED 0 

#endif // #ifndef _VDM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\vdm.cpp ===
//----------------------------------------------------------------------------
//
// VDM debugging support.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

BOOL fVDMInitDone;
BOOL fVDMActive;
VDMPROCESSEXCEPTIONPROC pfnVDMProcessException;
VDMGETTHREADSELECTORENTRYPROC pfnVDMGetThreadSelectorEntry;
VDMGETPOINTERPROC pfnVDMGetPointer;
VDMGETCONTEXTPROC pfnVDMGetContext;
VDMSETCONTEXTPROC pfnVDMSetContext;
VDMGETSELECTORMODULEPROC pfnVDMGetSelectorModule;

#define SEGTYPE_AVAILABLE   0
#define SEGTYPE_V86         1
#define SEGTYPE_PROT        2

#define MAXSEGENTRY 1024

SEGENTRY segtable[MAXSEGENTRY];



VOID VDMRegCmd(
    LPSTR achInput,
    X86_NT5_CONTEXT *pvc
    )
{
    DWORD dwVal;

    if ( _stricmp(achInput,"rp") == 0 )
    {
        g_Target->m_Machines[MACHIDX_I386]->
            OutputAll(g_Target->m_Machines[MACHIDX_I386]->m_AllMask,
                      DEBUG_OUTPUT_NORMAL);
        return;
    }

    if (achInput[1] != 'e')
    {
        dprintf("VDM R: can only operate on 32-bit registers\n");
        return;
    }

    if (strlen(achInput) < 6) {
        dprintf("VDM R: Missing value\n");
        return;
    }

    dwVal = strtoul(&achInput[5], NULL, 16);

    if ( _strnicmp(&achInput[2],"ax", 2) == 0 ) {
        pvc->Eax = dwVal;
    } else if ( _strnicmp(&achInput[2],"bx", 2) == 0 ) {
        pvc->Ebx = dwVal;
    } else if ( _strnicmp(&achInput[2],"cx", 2) == 0 ) {
        pvc->Ecx = dwVal;
    } else if ( _strnicmp(&achInput[2],"dx", 2) == 0 ) {
        pvc->Edx = dwVal;
    } else if ( _strnicmp(&achInput[2],"si", 2) == 0 ) {
        pvc->Esi = dwVal;
    } else if ( _strnicmp(&achInput[2],"di", 2) == 0 ) {
        pvc->Edi = dwVal;
    } else if ( _strnicmp(&achInput[2],"ip", 2) == 0 ) {
        pvc->Eip = dwVal;
    } else if ( _strnicmp(&achInput[2],"sp", 2) == 0 ) {
        pvc->Esp = dwVal;
    } else if ( _strnicmp(&achInput[2],"bp", 2) == 0 ) {
        pvc->Ebp = dwVal;
    } else if ( _strnicmp(&achInput[2],"fl", 2) == 0 ) {
        pvc->EFlags = dwVal;
    } else {
        dprintf("Invalid register\n");
        return;
    }

    dprintf("%.8X will be flushed to '%3.3s'. Use 'rp' to display pending values\n",
            dwVal,
            &achInput[1]);
}

void
DebugEvent64To(LPDEBUG_EVENT64 Event64,
               LPDEBUG_EVENT Event)
{
    Event->dwDebugEventCode = Event64->dwDebugEventCode;
    Event->dwProcessId = Event64->dwProcessId;
    Event->dwThreadId = Event64->dwThreadId;
    
    switch(Event64->dwDebugEventCode)
    {
    case EXCEPTION_DEBUG_EVENT:
        ExceptionRecord64To(&Event64->u.Exception.ExceptionRecord,
                            &Event->u.Exception.ExceptionRecord);
        Event->u.Exception.dwFirstChance =
            Event64->u.Exception.dwFirstChance;
        break;
        
    case CREATE_THREAD_DEBUG_EVENT:
        Event->u.CreateThread.hThread =
            (PVOID)(ULONG_PTR)(Event64->u.CreateThread.hThread);
        Event->u.CreateThread.lpThreadLocalBase =
            (PVOID)(ULONG_PTR)(Event64->u.CreateThread.lpThreadLocalBase);
        Event->u.CreateThread.lpStartAddress =
            (LPTHREAD_START_ROUTINE)(ULONG_PTR)(Event64->u.CreateThread.lpStartAddress);
        break;
        
    case CREATE_PROCESS_DEBUG_EVENT:
        Event->u.CreateProcessInfo.hFile =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.hFile);
        Event->u.CreateProcessInfo.hProcess =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.hProcess);
        Event->u.CreateProcessInfo.hThread =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.hThread);
        Event->u.CreateProcessInfo.lpBaseOfImage =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.lpBaseOfImage);
        Event->u.CreateProcessInfo.dwDebugInfoFileOffset =
            Event64->u.CreateProcessInfo.dwDebugInfoFileOffset;
        Event->u.CreateProcessInfo.nDebugInfoSize =
            Event64->u.CreateProcessInfo.nDebugInfoSize;
        Event->u.CreateProcessInfo.lpThreadLocalBase =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.lpThreadLocalBase);
        Event->u.CreateProcessInfo.lpStartAddress =
            (LPTHREAD_START_ROUTINE)(ULONG_PTR)(Event64->u.CreateProcessInfo.lpStartAddress);
        Event->u.CreateProcessInfo.lpImageName =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.lpImageName);
        Event->u.CreateProcessInfo.fUnicode =
            Event64->u.CreateProcessInfo.fUnicode;
        break;
        
    case EXIT_THREAD_DEBUG_EVENT:
        Event->u.ExitThread.dwExitCode =
            Event64->u.ExitThread.dwExitCode;
        break;
        
    case EXIT_PROCESS_DEBUG_EVENT:
        Event->u.ExitProcess.dwExitCode =
            Event64->u.ExitProcess.dwExitCode;
        break;
        
    case LOAD_DLL_DEBUG_EVENT:
        Event->u.LoadDll.hFile =
            (PVOID)(ULONG_PTR)(Event64->u.LoadDll.hFile);
        Event->u.LoadDll.lpBaseOfDll =
            (PVOID)(ULONG_PTR)(Event64->u.LoadDll.lpBaseOfDll);
        Event->u.LoadDll.dwDebugInfoFileOffset =
            Event64->u.LoadDll.dwDebugInfoFileOffset;
        Event->u.LoadDll.nDebugInfoSize =
            Event64->u.LoadDll.nDebugInfoSize;
        Event->u.LoadDll.lpImageName =
            (PVOID)(ULONG_PTR)(Event64->u.LoadDll.lpImageName);
        Event->u.LoadDll.fUnicode =
            Event64->u.LoadDll.fUnicode;
        break;
        
    case UNLOAD_DLL_DEBUG_EVENT:
        Event->u.UnloadDll.lpBaseOfDll =
            (PVOID)(ULONG_PTR)(Event64->u.UnloadDll.lpBaseOfDll);
        break;
        
    case OUTPUT_DEBUG_STRING_EVENT:
        Event->u.DebugString.lpDebugStringData =
            (LPSTR)(ULONG_PTR)(Event64->u.DebugString.lpDebugStringData);
        Event->u.DebugString.fUnicode =
            Event64->u.DebugString.fUnicode;
        Event->u.DebugString.nDebugStringLength =
            Event64->u.DebugString.nDebugStringLength;
        break;
        
    case RIP_EVENT:
        Event->u.RipInfo.dwError =
            Event64->u.RipInfo.dwError;
        Event->u.RipInfo.dwType =
            Event64->u.RipInfo.dwType;
        break;
    }
}

ULONG
VDMEvent(DEBUG_EVENT64* pDebugEvent)
/*

    returns - 0, if exception not handled
              STATUS_VDM_EVENT, if exception handled
              otherwise, the return value is the translated event status,
              for example STATUS_BREAKPOINT

 */
{
    LPSTR           Str;
    LPSTR           pFileName;
    BOOL            b;
    ULONG           lpNumberOfBytesRead;
    UINT_PTR        address;
    PULONG_PTR      lpdw;
    int             segslot;
    int             mode;
    BOOL            fData;
    WORD            selector;
    WORD            segment;
    WORD            newselect;
    BOOL            fStop;
    DWORD           ImgLen;
    ULONG           ulRet;
    BOOL            fNeedSegTableEdit;
    BOOL            fNeedInteractive;
    BOOL            fVerbose;
    CHAR            achInput[_MAX_PATH];
    BOOL            fProcess;
    SEGMENT_NOTE    se;
    IMAGE_NOTE      im;
    BOOL            bProtectMode;
    WORD            EventFlags;

    ulRet = VDMEVENT_HANDLED;

    if (!fVDMInitDone) {
        fVDMInitDone = TRUE;

        HINSTANCE hmodVDM = NULL;
		const char* c_szVDMFailed = NULL;

        fVDMActive = (
            (hmodVDM = LoadLibrary("VDMDBG.DLL")) &&
            (pfnVDMProcessException = (VDMPROCESSEXCEPTIONPROC)
                GetProcAddress(hmodVDM, c_szVDMFailed = "VDMProcessException")
            ) &&
            (pfnVDMGetPointer = (VDMGETPOINTERPROC)
                GetProcAddress(hmodVDM, c_szVDMFailed = "VDMGetPointer")
            ) &&
            (pfnVDMGetThreadSelectorEntry = (VDMGETTHREADSELECTORENTRYPROC)
                GetProcAddress(hmodVDM, c_szVDMFailed = "VDMGetThreadSelectorEntry")
            ) &&
            (pfnVDMGetContext = (VDMGETCONTEXTPROC)
                GetProcAddress(hmodVDM, c_szVDMFailed = "VDMGetContext")
            ) &&
            (pfnVDMSetContext = (VDMSETCONTEXTPROC)
                GetProcAddress( hmodVDM, c_szVDMFailed = "VDMSetContext")
            ) &&
            (pfnVDMGetSelectorModule = (VDMGETSELECTORMODULEPROC)
                GetProcAddress( hmodVDM, c_szVDMFailed = "VDMGetSelectorModule")
            )
        ); // fVDMActive

		if (!fVDMActive) {  // display error on first time...
			if (!hmodVDM) {
				dprintf("LoadLibrary(VDMDBG.DLL) failed\n");
			}
			else if (c_szVDMFailed && *c_szVDMFailed) { // is valid printable string
				dprintf("%s can not be found in VDMDBG.DLL\n", c_szVDMFailed);
			}
			else {
				dprintf("Unknown failure while initializing VDMDBG.DLL\n");
			} // iff
		} // if
    } // if

    if (!fVDMActive) return VDMEVENT_NOT_HANDLED;

    DEBUG_EVENT Event;
    DebugEvent64To(pDebugEvent, &Event);
    lpdw = &(Event.u.Exception.ExceptionRecord.ExceptionInformation[0]);
    
    fProcess = (*pfnVDMProcessException)(&Event);

    fNeedSegTableEdit = FALSE;
    fNeedInteractive = FALSE;
    fVerbose = FALSE;

    mode = LOWORD(lpdw[0]);
    EventFlags = HIWORD(lpdw[0]);

    bProtectMode = (BOOL) (EventFlags & VDMEVENT_PE);

    // Has the caller explicitly asked for interaction?
    if (EventFlags & VDMEVENT_NEEDS_INTERACTIVE) {
        fNeedInteractive = TRUE;
    }
    if (EventFlags & VDMEVENT_VERBOSE) {
        fVerbose = TRUE;
    }

    switch( mode ) {
        case DBG_SEGLOAD:
        case DBG_SEGMOVE:
        case DBG_SEGFREE:
        case DBG_MODLOAD:
        case DBG_MODFREE:
            address = lpdw[2];

            b = g_Target->ReadVirtual(g_Process, EXTEND64(address),
                                      &se, sizeof(se),
                                      &lpNumberOfBytesRead ) == S_OK;
            if ( !b || lpNumberOfBytesRead != sizeof(se) )
            {
                return( VDMEVENT_NOT_HANDLED );
            }
            break;
        case DBG_DLLSTART:
        case DBG_DLLSTOP:
        case DBG_TASKSTART:
        case DBG_TASKSTOP:
            address = lpdw[2];

            b = g_Target->ReadVirtual(g_Process, EXTEND64(address),
                                      &im, sizeof(im),
                                      &lpNumberOfBytesRead ) == S_OK;
            if ( !b || lpNumberOfBytesRead != sizeof(im) )
            {
                return( VDMEVENT_NOT_HANDLED );
            }
            break;
    }

    switch( mode ) {
        default:
            ulRet = VDMEVENT_NOT_HANDLED;
            break;

        case DBG_SEGLOAD:
            fNeedSegTableEdit = TRUE;

            selector = se.Selector1;
            segment  = se.Segment;
            fData    = (BOOL)se.Type;

            segslot = 0;
            while ( segslot < MAXSEGENTRY ) {
                if ( segtable[segslot].type != SEGTYPE_AVAILABLE ) {
                    if ( _stricmp(segtable[segslot].path_name, se.FileName) == 0 ) {
                        break;
                    }
                }
                segslot++;
            }

            if ( segslot == MAXSEGENTRY ) {
                if ( strlen(se.FileName) != 0 ) {
                    dprintf("Loading [%s]\n", se.FileName );
                }
            }

            if (fVerbose) {
                dprintf("VDM SegLoad: %s(%d) %s => %x\n",
                                        se.FileName,
                                        segment,
                                        fData ? "Data" : "Code",
                                        selector);
            }
            break;

        case DBG_SEGMOVE:
            fNeedSegTableEdit = TRUE;
            segment = se.Segment;
            selector  = se.Selector1;
            newselect = se.Selector2;
            if ( newselect == 0 ) {
                mode = DBG_SEGFREE;
            } else if (segment > 1) {
                //
                // real mode module is getting split up into different
                // segments, so create a new segtable entry
                //
                segslot = 0;
                while ( segslot < MAXSEGENTRY ) {
                    if (( segtable[segslot].type != SEGTYPE_AVAILABLE ) &&
                        ( segtable[segslot].selector == selector )) {
                        mode = DBG_MODLOAD;
                        segment--;          //make it zero-based
                        selector = newselect;
                        pFileName = segtable[segslot].path_name;
                        // Don't have the image length here so
                        // just choose one.
                        ImgLen = segtable[segslot].ImgLen;
                        break;
                    }
                    segslot++;
                }
            }

            if (fVerbose) {
                dprintf("VDM SegMove: (%d) %x => %x\n",
                                        segment, selector, newselect);
            }
            break;

        case DBG_SEGFREE:
            fNeedSegTableEdit = TRUE;
            selector = se.Selector1;
            if (fVerbose) {
                dprintf("VDM SegFree: %x\n",selector);
            }
            break;

        case DBG_MODFREE:
            fNeedSegTableEdit = TRUE;

            if ( strlen(se.FileName) != 0 ) {
                dprintf("Freeing [%s]\n", se.FileName );
            } else if (fVerbose) {
                dprintf("VDM ModFree: unknown module\n");
            }
            break;

        case DBG_MODLOAD:
            fNeedSegTableEdit = TRUE;
            selector = se.Selector1;
            ImgLen   = se.Length;
            segment = 0;
            pFileName = se.FileName;

            segslot = 0;
            while ( segslot < MAXSEGENTRY ) {
                if ( segtable[segslot].type != SEGTYPE_AVAILABLE ) {
                    if ( _stricmp(segtable[segslot].path_name, se.FileName) == 0 ) {
                        break;
                    }
                }
                segslot++;
            }
            if ( segslot == MAXSEGENTRY ) {
                if ( strlen(se.FileName) != 0 ) {
                    dprintf("Loading [%s]\n", se.FileName );
                }
            }
            if (fVerbose) {
                dprintf("VDM ModLoad: %s => %x, len=%x\n",
                                        se.FileName,
                                        selector,
                                        ImgLen);
            }
            break;

        case DBG_SINGLESTEP:
            if (g_Target->m_MachineType == IMAGE_FILE_MACHINE_I386)
            {
                fNeedInteractive = FALSE;
                ulRet = STATUS_SINGLE_STEP;
            }
            else
            {
                fNeedInteractive = TRUE;
            }
            break;

        case DBG_BREAK:
            if (g_Target->m_MachineType == IMAGE_FILE_MACHINE_I386)
            {
                fNeedInteractive = FALSE;
                ulRet = STATUS_BREAKPOINT;
            }
            else
            {
                fNeedInteractive = TRUE;
            }
            break;

        case DBG_GPFAULT:
            dprintf(" GP Fault in VDM\n");
            if (g_Target->m_MachineType == IMAGE_FILE_MACHINE_I386) {
                fNeedInteractive = FALSE;
                ulRet = STATUS_ACCESS_VIOLATION;
            } else {
                fNeedInteractive = TRUE;
            }
            break;
        case DBG_GPFAULT2:
            dprintf("GP Fault in VDM\n");
            dprintf("!!! second chance !!!\n");
            fNeedInteractive = TRUE;
            break;

        case DBG_INSTRFAULT:
            dprintf("invalid opcode fault in VDM\n");
            fNeedInteractive = TRUE;
            break;

        case DBG_DIVOVERFLOW:
            dprintf("divide overflow in VDM\n");
            fNeedInteractive = TRUE;
            break;

        case DBG_STACKFAULT:
            dprintf("stack fault in VDM\n");
            if (g_Target->m_MachineType == IMAGE_FILE_MACHINE_I386) {
                fNeedInteractive = FALSE;
                ulRet = STATUS_ACCESS_VIOLATION;
            } else {
                fNeedInteractive = TRUE;
            }
            break;
        case DBG_TASKSTART:
            if ( fNeedInteractive || fVerbose ) {
                dprintf("VDM Start Task <%s:%s>\n",
                        im.Module,
                        im.FileName );
            }
            break;
        case DBG_DLLSTART:
            if ( fNeedInteractive || fVerbose ) {
                dprintf("VDM Start Dll <%s:%s>\n", im.Module, im.FileName );
            }
            break;
        case DBG_TASKSTOP:
            fNeedInteractive = FALSE;
            break;
        case DBG_DLLSTOP:
            fNeedInteractive = FALSE;
            break;
    }

    /*
    ** Temporary code to emulate a 16-bit debugger.  Eventually I will make
    ** NTSD understand these events and call ProcessStateChange to allow
    ** real 16-bit debugging and other activities on the other 32-bit threads.
    ** -BobDay
    */
    if ( fNeedInteractive ) {
        char    text[MAX_DISASM_LEN];
        char    path[128];
        UINT    cSeg;
        ADDR    addr;
        X86_NT5_CONTEXT  vc;

        g_Target->m_Machines[MACHIDX_I386]->
            m_Context.X86Nt5Context.ContextFlags = VDMCONTEXT_FULL;

        (*pfnVDMGetContext)(OS_HANDLE(g_EventProcess->m_SysHandle),
                            OS_HANDLE(g_EventThread->m_Handle),
                            (LPVDMCONTEXT)&g_Target->
                            m_Machines[MACHIDX_I386]->m_Context);

        g_Target->m_Machines[MACHIDX_I386]->m_Context.X86Nt5Context.EFlags &= ~V86FLAGS_TRACE;
        vc = g_Target->m_Machines[MACHIDX_I386]->m_Context.X86Nt5Context;

        // Dump a simulated context
        g_Target->m_Machines[MACHIDX_I386]->OutputAll(g_Target->m_Machines[MACHIDX_I386]->m_AllMask,
                               DEBUG_OUTPUT_PROMPT_REGISTERS);
        b = (*pfnVDMGetSelectorModule)(OS_HANDLE(g_EventProcess->m_SysHandle),
                                       OS_HANDLE(g_EventThread->m_Handle),
                (WORD)g_Target->m_Machines[MACHIDX_I386]->m_Context.X86Nt5Context.SegCs, &cSeg, text, 128, path, 128 );

        if ( b ) {
            dprintf("%s:%d!%04x:\n", text, cSeg, (WORD)g_Target->m_Machines[MACHIDX_I386]->m_Context.X86Nt5Context.Eip );
        }
        addr.seg = (WORD)g_Target->m_Machines[MACHIDX_I386]->m_Context.X86Nt5Context.SegCs;
        addr.off = g_Target->m_Machines[MACHIDX_I386]->m_Context.X86Nt5Context.Eip;
        if ( !bProtectMode ) {
            addr.type = ADDR_V86 | FLAT_COMPUTED;
            addr.flat = (*pfnVDMGetPointer)(
                            OS_HANDLE(g_EventProcess->m_SysHandle),
                            OS_HANDLE(g_EventThread->m_Handle),
                            addr.seg,
                            (ULONG)addr.off,
                            FALSE
                            );
        } else {
            addr.type = ADDR_16 | FLAT_COMPUTED;
            addr.flat = (*pfnVDMGetPointer)(
                            OS_HANDLE(g_EventProcess->m_SysHandle),
                            OS_HANDLE(g_EventThread->m_Handle),
                            addr.seg,
                            (ULONG)addr.off,
                            TRUE
                            );
        }

        if ( Flat(addr) == 0 ) {
            dprintf("Unable to disassemble failing code\n");
        } else {
            g_Target->m_Machines[MACHIDX_I386]->
                Disassemble( g_Process, &addr, text, TRUE );
            dprintf("%s", text );
        }

        AddExtensionDll("vdmexts", TRUE, g_Target, NULL);

        while ( TRUE ) {
            GetInput("VDM>", achInput, sizeof(achInput),
                     GETIN_LOG_INPUT_LINE);

            if ( _stricmp(achInput,"gh") == 0 || _stricmp(achInput,"g") == 0 ) {
                ulRet = VDMEVENT_HANDLED;
                break;
            }
            if ( _stricmp(achInput,"gn") == 0 ) {
                ulRet = VDMEVENT_NOT_HANDLED;
                break;
            }
            if ( _stricmp(achInput, "t") == 0 ) {
                ulRet = VDMEVENT_HANDLED;
                vc.EFlags |= V86FLAGS_TRACE;
                break;
            }

            if ((achInput[0] == 'r') && (_stricmp(achInput, "r") != 0)) {
                VDMRegCmd(achInput, &vc);
                g_Target->m_Machines[MACHIDX_I386]->m_Context.X86Nt5Context = vc;
                continue;
            }

            if ( _stricmp(achInput,"?") == 0 ) {
                dprintf("\n---------- NTVDM Monitor Help ------------\n\n");
                dprintf("g            - Go\n");
                dprintf("gh           - Go : Exception handled\n");
                dprintf("gn           - Go : Exception not handled\n");
                dprintf("help         - Display extension help\n");
                dprintf("r<reg> <val> - reg=[eax|ebx|ecx|edx|eip|esp|ebp|efl]\n");
                dprintf("rp           - display pending register set\n");
                dprintf("t            - Trace 1 instruction\n");
                dprintf("!<cmd>       - Execute extension command\n");
                dprintf(".<cmd>       - Execute native NTSD command\n");
                dprintf("\nAnything else is interpreted as a VDMEXTS extension command\n\n");
                continue;
            }

            g_CurCmd = &achInput[1];
            g_CommandStart = g_CurCmd;
            ProcessCommandsAndCatch(NULL);
        }
        g_Target->m_Machines[MACHIDX_I386]->m_Context.X86Nt5Context = vc;
        (*pfnVDMSetContext)(OS_HANDLE(g_EventProcess->m_SysHandle),
                            OS_HANDLE(g_EventThread->m_Handle),
                            (LPVDMCONTEXT)&g_Target->m_Machines[MACHIDX_I386]->m_Context);
    }
    /*
    ** End of temporary code
    */

    if ( fNeedSegTableEdit ) {
        segslot = 0;
        fStop = FALSE;
        while ( segslot < MAXSEGENTRY ) {
            switch( mode ) {
                case DBG_SEGLOAD:
                    if ( segtable[segslot].type == SEGTYPE_AVAILABLE ) {
                        segtable[segslot].segment = segment;
                        segtable[segslot].selector = selector;
                        // This notification message is used only by wow in prot
                        // It could be determined from the current mode to be
                        // correct
                        segtable[segslot].type = SEGTYPE_PROT;
                        Str = (PSTR)calloc(1,strlen(se.FileName)+1);
                        if ( !Str ) {
                            return( VDMEVENT_NOT_HANDLED );
                        }
                        strcpy( Str, se.FileName );
                        segtable[segslot].path_name = Str;
                        segtable[segslot].ImgLen = 0;
                        fStop = TRUE;
                    }
                    break;
                case DBG_SEGMOVE:
                    if (( segtable[segslot].type != SEGTYPE_AVAILABLE ) &&
                        ( segtable[segslot].selector == selector )) {
                        segtable[segslot].selector = newselect;
                        fStop = TRUE;
                    }
                    break;
                case DBG_SEGFREE:
                    if ( segtable[segslot].selector == selector ) {
                        fStop = TRUE;
                        segtable[segslot].type = SEGTYPE_AVAILABLE;
                        free(segtable[segslot].path_name);
                        segtable[segslot].path_name = NULL;
                    }
                    break;
                case DBG_MODFREE:
                    if ( segtable[segslot].type != SEGTYPE_AVAILABLE ) {
                        if ( _stricmp(segtable[segslot].path_name,se.FileName) == 0 ) {
                            segtable[segslot].type = SEGTYPE_AVAILABLE;
                            free(segtable[segslot].path_name);
                            segtable[segslot].path_name = NULL;
                        }
                    }
                    break;
                case DBG_MODLOAD:
                    if ( segtable[segslot].type == SEGTYPE_AVAILABLE ) {
                        segtable[segslot].segment  = segment;
                        segtable[segslot].selector = selector;
                        // This notification message is used only by v86 dos
                        // It could be determined from the current mode to be
                        // correct
                        segtable[segslot].type = SEGTYPE_V86;
                        Str = (PSTR)calloc(1,strlen(pFileName)+1);
                        if ( !Str ) {
                            return( VDMEVENT_NOT_HANDLED );
                        }
                        strcpy( Str, pFileName );
                        segtable[segslot].path_name = Str;
                        segtable[segslot].ImgLen = ImgLen;
                        fStop = TRUE;
                    }
                    break;

            }
            if ( fStop ) {
                break;
            }
            segslot++;
        }
        if ( segslot == MAXSEGENTRY ) {
            if ( mode == DBG_SEGLOAD ) {
                dprintf("Warning - adding selector %04X for segment %d, segtable full\n",
                         selector, segment );
            }
        }
    }

    pDebugEvent->u.Exception.ExceptionRecord.ExceptionCode = ulRet;

    return( ulRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\util.h ===
//----------------------------------------------------------------------------
//
// General utility functions.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _UTIL_H_
#define _UTIL_H_

//  error codes

#define OVERFLOW        0x1000
#define SYNTAX          0x1001
#define BADRANGE        0x1002
#define VARDEF          0x1003
#define EXTRACHARS      0x1004
#define LISTSIZE        0x1005
#define STRINGSIZE      0x1006
#define MEMORY          0x1007
#define BADREG          0x1008
#define BADOPCODE       0x1009
#define SUFFIX          0x100a
#define OPERAND         0x100b
#define ALIGNMENT       0x100c
#define PREFIX          0x100d
#define DISPLACEMENT    0x100e
#define BPLISTFULL      0x100f
#define BPDUPLICATE     0x1010
#define BADTHREAD       0x1011
#define DIVIDE          0x1012
#define TOOFEW          0x1013
#define TOOMANY         0x1014
#define BADSIZE         0x1015
#define BADSEG          0x1016
#define RELOC           0x1017
#define BADPROCESS      0x1018
#define AMBIGUOUS       0x1019
#define FILEREAD        0x101a
#define LINENUMBER      0x101b
#define BADSEL          0x101c
#define SYMTOOSMALL     0x101d
#define BPIONOTSUP      0x101e
#define NOTFOUND        0x101f
#define SESSIONNOTSUP   0x1020
#define BADSYSTEM       0x1021
#define NOMEMORY        0x1022
#define TYPECONFLICT    0x1023
#define TYPEDATA        0x1024
#define NOTMEMBER       0x1025
#define IMPLERR         0x1026
#define ENGBUSY         0x1027
#define TARGETNOTSUP    0x1028
#define NORUNNABLE      0x1029
#define NOTSECURE       0x102a

#define UNIMPLEMENT     0x1099

extern PCSTR   g_DefaultLogFileName;
extern char    g_OpenLogFileName[];
extern BOOL    g_OpenLogFileAppended;
extern int     g_LogFile;
extern ULONG   g_DisableErrorPrint;
extern char    g_Blanks[];

ULONG CheckUserInterrupt(void);
BOOL PollUserInterrupt(BOOL AllowPendingBreak);

LONG MappingExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);

void RemoveDelChar(PSTR Buffer);

ULONG64 HexValue(ULONG Size);
void HexList(PUCHAR Buffer, ULONG BufferSize,
             ULONG EltSize, PULONG CountRet);
ULONG64 FloatValue(ULONG Size);
void FloatList(PUCHAR Buffer, ULONG BufferSize,
               ULONG EltSize, PULONG CountRet);
void AsciiList(PSTR Buffer, ULONG BufferSize,
               PULONG CountRet);

#define STRV_SPACE_IS_SEPARATOR          0x00000001
#define STRV_TRIM_TRAILING_SPACE         0x00000002
#define STRV_ALLOW_ESCAPED_CHARACTERS    0x00000004
#define STRV_COMPRESS_ESCAPED_CHARACTERS 0x00000008
#define STRV_ALLOW_EMPTY_STRING          0x00000010
#define STRV_NO_MODIFICATION             0x00000020

#define STRV_ESCAPED_CHARACTERS \
    (STRV_ALLOW_ESCAPED_CHARACTERS | STRV_COMPRESS_ESCAPED_CHARACTERS)

PSTR BufferStringValue(PSTR* Buf, ULONG Flags,
                       PULONG Len, PCHAR Save);
PSTR StringValue(ULONG Flags, PCHAR Save);
void CompressEscapes(PSTR Str);

PCSTR ErrorString(ULONG Code);
void DECLSPEC_NORETURN ReportError(ULONG Code, PCSTR* Desc);
inline void DECLSPEC_NORETURN ErrorDesc(ULONG Code, PCSTR Desc)
{
    ReportError(Code, &Desc);
}
#define error(Code) ReportError(Code, NULL)

void OpenLogFile(PCSTR File, BOOL Append);
void CloseLogFile(void);
void ParseLogOpen(BOOL Append);
void lprintf(PCSTR Str);

#define SYMADDR_FORCE  0x00000001
#define SYMADDR_LABEL  0x00000002
#define SYMADDR_SOURCE 0x00000004
#define SYMADDR_OFFSET 0x00000008

void OutputSymAddr(ULONG64 Offset,
                   ULONG Flags,
                   PCSTR Prefix);
BOOL OutputLineAddr(ULONG64 Offset,
                    PCSTR Format);

LPSTR FormatMachineAddr64(MachineInfo* Machine,
                          ULONG64 Addr);
#define FormatAddr64(Addr) \
    FormatMachineAddr64(g_Target ? g_Target->m_Machine : NULL, Addr)

LPSTR FormatDisp64(ULONG64 Addr);

//
// Output that can be displayed about the current register set.
//

void OutCurInfo(ULONG Flags, ULONG AllMask, ULONG RegMask);

// Items displayed if the flag is given.

// Display symbol nearest PC.
#define OCI_SYMBOL              0x00000001
// Display disassembly at PC.
#define OCI_DISASM              0x00000002

// Items which may be displayed if the flag is given.  Other global
// settings ultimately control whether information is displayed or not;
// these flags indicate whether such output is allowed or not.  Each
// of these flags also has a FORCE bit to force display regardless of
// the global settings.

// Allow registers to be displayed.
#define OCI_ALLOW_REG           0x00000004
// Allow display of source code and/or source line.
#define OCI_ALLOW_SOURCE        0x00000008
// Allow EA memory to be displayed during disasm.
#define OCI_ALLOW_EA            0x00000010

// Force all output to be shown regardless of global settings.
#define OCI_FORCE_ALL           0x80000000
// Force display of registers.
#define OCI_FORCE_REG           0x40000000
// Force source output.
#define OCI_FORCE_SOURCE        0x20000000
// Force display of EA memory during disasm.
#define OCI_FORCE_EA            0x10000000
// Don't check for running state.
#define OCI_IGNORE_STATE        0x08000000


BOOL
__inline
ConvertQwordsToDwords(
    PULONG64 Qwords,
    PULONG Dwords,
    ULONG Count
    )
{
    BOOL rval = TRUE;
    while (Count--) {
        rval = rval && (*Qwords >> 32) == 0;
        *Dwords++ = (ULONG)*Qwords++;
    }
    return rval;
}

DWORD
NetworkPathCheck(
    LPCSTR PathList
    );

#define ALL_ID_LIST 0xffffffff

ULONG GetIdList(BOOL AllowMulti);
void AppendComponentsToPath(PSTR Path, PCSTR Components,
                            BOOL Validate);
HRESULT ChangePath(PSTR* Path, PCSTR New, BOOL Append, ULONG SymNotify);
void CheckPath(PCSTR Path);
HRESULT ChangeString(PSTR* Str, PULONG StrLen, PCSTR New);

void
ExceptionRecordTo64(PEXCEPTION_RECORD Rec,
                    PEXCEPTION_RECORD64 Rec64);
void
ExceptionRecord64To(PEXCEPTION_RECORD64 Rec64,
                    PEXCEPTION_RECORD Rec);
void
MemoryBasicInformationTo64(PMEMORY_BASIC_INFORMATION Mbi,
                           PMEMORY_BASIC_INFORMATION64 Mbi64);
void
MemoryBasicInformation32To64(PMEMORY_BASIC_INFORMATION32 Mbi32,
                             PMEMORY_BASIC_INFORMATION64 Mbi64);
void
DebugEvent32To64(LPDEBUG_EVENT32 Event32,
                 LPDEBUG_EVENT64 Event64);
void
WaitStateChange32ToAny(IN PDBGKD_WAIT_STATE_CHANGE32 Ws32,
                       IN ULONG ControlReportSize,
                       OUT PDBGKD_ANY_WAIT_STATE_CHANGE WsAny);

PSTR TimeToStr(ULONG TimeDateStamp);
PSTR LONG64FileTimeToStr(LONG64 UTCFileTimeStamp);
PSTR FileTimeToStr(FILETIME UTCFileTime);
PSTR DurationToStr(ULONG64 Duration);

PCSTR PathTail(PCSTR Path);
PCWSTR PathTailW(PCWSTR Path);
BOOL MatchPathTails(PCSTR Path1, PCSTR Path2, BOOL Wild);

BOOL IsValidName(PSTR String);

BOOL MakeFileNameUnique(PSTR OriginalName,
                        PSTR Buffer, ULONG BufferChars,
                        BOOL AppendTime, ProcessInfo* Pid);

BOOL GetEngineDirectory(PSTR Buffer, ULONG BufferChars);
BOOL IsInternalPackage(void);

void TranslateNtPathName(PSTR Path);

class ShellProcess
{
public:
    ShellProcess(void);
    ~ShellProcess(void);

    DWORD ReaderThread(void);
    static DWORD WINAPI ReaderThreadCb(LPVOID Param);

    static BOOL CreateAsyncPipePair(OUT LPHANDLE ReadPipe,
                                    OUT LPHANDLE WritePipe,
                                    IN LPSECURITY_ATTRIBUTES SecAttr,
                                    IN DWORD Size,
                                    IN DWORD ReadMode,
                                    IN DWORD WriteMode);

    HRESULT Start(PCSTR CmdString,
                  PCSTR InFile,
                  PCSTR OutFile,
                  PCSTR ErrFile);

    void WaitForProcessExit(void);

    void Close(void);

    HANDLE m_IoIn, m_IoOut;
    HANDLE m_ProcIn, m_ProcOut, m_ProcErr;
    HANDLE m_IoSignal;
    HANDLE m_ProcThread, m_Process;
    HANDLE m_ReaderThread;
    ULONG m_DefaultTimeout;

    static ULONG s_PipeSerialNumber;
};

#endif // #ifndef _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\appcompr.cpp ===
// appcompr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f appcomprps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "appcompr.h"

#include "appcompr_i.c"
#include "AppReport.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AppReport, CAppReport)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_APPCOMPRLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\appcompr.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0359 */
/* Compiler settings for appcompr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __appcompr_h__
#define __appcompr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAppReport_FWD_DEFINED__
#define __IAppReport_FWD_DEFINED__
typedef interface IAppReport IAppReport;
#endif 	/* __IAppReport_FWD_DEFINED__ */


#ifndef __AppReport_FWD_DEFINED__
#define __AppReport_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppReport AppReport;
#else
typedef struct AppReport AppReport;
#endif /* __cplusplus */

#endif 	/* __AppReport_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IAppReport_INTERFACE_DEFINED__
#define __IAppReport_INTERFACE_DEFINED__

/* interface IAppReport */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAppReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CDCA6A6F-9C38-4828-A76C-05A6E490E574")
    IAppReport : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BrowseForExecutable( 
            /* [in] */ BSTR bstrWinTitle,
            /* [in] */ BSTR bstrPreviousPath,
            /* [retval][out] */ VARIANT *bstrExeName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetApplicationFromList( 
            /* [in] */ BSTR bstrTitle,
            /* [retval][out] */ VARIANT *bstrExeName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateReport( 
            /* [in] */ BSTR bstrTitle,
            /* [in] */ BSTR bstrProblemType,
            /* [in] */ BSTR bstrComment,
            /* [in] */ BSTR bstrACWResult,
            /* [in] */ BSTR bstrAppName,
            /* [retval][out] */ VARIANT *DwResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppReport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppReport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAppReport * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAppReport * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAppReport * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAppReport * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BrowseForExecutable )( 
            IAppReport * This,
            /* [in] */ BSTR bstrWinTitle,
            /* [in] */ BSTR bstrPreviousPath,
            /* [retval][out] */ VARIANT *bstrExeName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetApplicationFromList )( 
            IAppReport * This,
            /* [in] */ BSTR bstrTitle,
            /* [retval][out] */ VARIANT *bstrExeName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateReport )( 
            IAppReport * This,
            /* [in] */ BSTR bstrTitle,
            /* [in] */ BSTR bstrProblemType,
            /* [in] */ BSTR bstrComment,
            /* [in] */ BSTR bstrACWResult,
            /* [in] */ BSTR bstrAppName,
            /* [retval][out] */ VARIANT *DwResult);
        
        END_INTERFACE
    } IAppReportVtbl;

    interface IAppReport
    {
        CONST_VTBL struct IAppReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppReport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppReport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppReport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppReport_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAppReport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAppReport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAppReport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAppReport_BrowseForExecutable(This,bstrWinTitle,bstrPreviousPath,bstrExeName)	\
    (This)->lpVtbl -> BrowseForExecutable(This,bstrWinTitle,bstrPreviousPath,bstrExeName)

#define IAppReport_GetApplicationFromList(This,bstrTitle,bstrExeName)	\
    (This)->lpVtbl -> GetApplicationFromList(This,bstrTitle,bstrExeName)

#define IAppReport_CreateReport(This,bstrTitle,bstrProblemType,bstrComment,bstrACWResult,bstrAppName,DwResult)	\
    (This)->lpVtbl -> CreateReport(This,bstrTitle,bstrProblemType,bstrComment,bstrACWResult,bstrAppName,DwResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppReport_BrowseForExecutable_Proxy( 
    IAppReport * This,
    /* [in] */ BSTR bstrWinTitle,
    /* [in] */ BSTR bstrPreviousPath,
    /* [retval][out] */ VARIANT *bstrExeName);


void __RPC_STUB IAppReport_BrowseForExecutable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppReport_GetApplicationFromList_Proxy( 
    IAppReport * This,
    /* [in] */ BSTR bstrTitle,
    /* [retval][out] */ VARIANT *bstrExeName);


void __RPC_STUB IAppReport_GetApplicationFromList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppReport_CreateReport_Proxy( 
    IAppReport * This,
    /* [in] */ BSTR bstrTitle,
    /* [in] */ BSTR bstrProblemType,
    /* [in] */ BSTR bstrComment,
    /* [in] */ BSTR bstrACWResult,
    /* [in] */ BSTR bstrAppName,
    /* [retval][out] */ VARIANT *DwResult);


void __RPC_STUB IAppReport_CreateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppReport_INTERFACE_DEFINED__ */



#ifndef __APPCOMPRLib_LIBRARY_DEFINED__
#define __APPCOMPRLib_LIBRARY_DEFINED__

/* library APPCOMPRLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_APPCOMPRLib;

EXTERN_C const CLSID CLSID_AppReport;

#ifdef __cplusplus

class DECLSPEC_UUID("E065DE4B-6F0E-45FD-B30F-04ED81D5C258")
AppReport;
#endif
#endif /* __APPCOMPRLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\appcompr_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0359 */
/* Compiler settings for appcompr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAppReport,0xCDCA6A6F,0x9C38,0x4828,0xA7,0x6C,0x05,0xA6,0xE4,0x90,0xE5,0x74);


MIDL_DEFINE_GUID(IID, LIBID_APPCOMPRLib,0xEB71D940,0x2FD5,0x4FB3,0x99,0xF4,0xFC,0x0C,0xB9,0x21,0xA9,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_AppReport,0xE065DE4B,0x6F0E,0x45FD,0xB3,0x0F,0x04,0xED,0x81,0xD5,0xC2,0x58);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0359 */
/* Compiler settings for appcompr.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAppReport,0xCDCA6A6F,0x9C38,0x4828,0xA7,0x6C,0x05,0xA6,0xE4,0x90,0xE5,0x74);


MIDL_DEFINE_GUID(IID, LIBID_APPCOMPRLib,0xEB71D940,0x2FD5,0x4FB3,0x99,0xF4,0xFC,0x0C,0xB9,0x21,0xA9,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_AppReport,0xE065DE4B,0x6F0E,0x45FD,0xB3,0x0F,0x04,0xED,0x81,0xD5,0xC2,0x58);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\appcompr_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0359 */
/* Compiler settings for appcompr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "appcompr.h"

#define TYPE_FORMAT_STRING_SIZE   1053                              
#define PROC_FORMAT_STRING_SIZE   157                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IAppReport_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IAppReport_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure BrowseForExecutable */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 16 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x20 ),	/* 32 */
/* 20 */	NdrFcShort( 0x2 ),	/* 2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrWinTitle */

/* 24 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrPreviousPath */

/* 30 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrExeName */

/* 36 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 40 */	NdrFcShort( 0x412 ),	/* Type Offset=1042 */

	/* Return value */

/* 42 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 44 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 46 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetApplicationFromList */

/* 48 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 50 */	NdrFcLong( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x8 ),	/* 8 */
/* 62 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 64 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 66 */	NdrFcShort( 0x20 ),	/* 32 */
/* 68 */	NdrFcShort( 0x1 ),	/* 1 */
/* 70 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrTitle */

/* 72 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 74 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 76 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrExeName */

/* 78 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 80 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 82 */	NdrFcShort( 0x412 ),	/* Type Offset=1042 */

	/* Return value */

/* 84 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 86 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 88 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateReport */

/* 90 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 92 */	NdrFcLong( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x9 ),	/* 9 */
/* 98 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
/* 102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 104 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 106 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 108 */	NdrFcShort( 0x20 ),	/* 32 */
/* 110 */	NdrFcShort( 0x5 ),	/* 5 */
/* 112 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrTitle */

/* 114 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 116 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 118 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrProblemType */

/* 120 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 122 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 124 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrComment */

/* 126 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 128 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 130 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrACWResult */

/* 132 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 134 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 136 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrAppName */

/* 138 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 140 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 142 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter DwResult */

/* 144 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 146 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 148 */	NdrFcShort( 0x412 ),	/* Type Offset=1042 */

	/* Return value */

/* 150 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 152 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x4 ),	/* 4 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffde ),	/* Offset= -34 (2) */
/* 38 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 40 */	NdrFcShort( 0x3ea ),	/* Offset= 1002 (1042) */
/* 42 */	
			0x13, 0x0,	/* FC_OP */
/* 44 */	NdrFcShort( 0x3d2 ),	/* Offset= 978 (1022) */
/* 46 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 48 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 50 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 52 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 54 */	NdrFcShort( 0x2 ),	/* Offset= 2 (56) */
/* 56 */	NdrFcShort( 0x10 ),	/* 16 */
/* 58 */	NdrFcShort( 0x2f ),	/* 47 */
/* 60 */	NdrFcLong( 0x14 ),	/* 20 */
/* 64 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 66 */	NdrFcLong( 0x3 ),	/* 3 */
/* 70 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 72 */	NdrFcLong( 0x11 ),	/* 17 */
/* 76 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 78 */	NdrFcLong( 0x2 ),	/* 2 */
/* 82 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 84 */	NdrFcLong( 0x4 ),	/* 4 */
/* 88 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 90 */	NdrFcLong( 0x5 ),	/* 5 */
/* 94 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 96 */	NdrFcLong( 0xb ),	/* 11 */
/* 100 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 102 */	NdrFcLong( 0xa ),	/* 10 */
/* 106 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 108 */	NdrFcLong( 0x6 ),	/* 6 */
/* 112 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (344) */
/* 114 */	NdrFcLong( 0x7 ),	/* 7 */
/* 118 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 120 */	NdrFcLong( 0x8 ),	/* 8 */
/* 124 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (350) */
/* 126 */	NdrFcLong( 0xd ),	/* 13 */
/* 130 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (354) */
/* 132 */	NdrFcLong( 0x9 ),	/* 9 */
/* 136 */	NdrFcShort( 0xec ),	/* Offset= 236 (372) */
/* 138 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 142 */	NdrFcShort( 0xf8 ),	/* Offset= 248 (390) */
/* 144 */	NdrFcLong( 0x24 ),	/* 36 */
/* 148 */	NdrFcShort( 0x320 ),	/* Offset= 800 (948) */
/* 150 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 154 */	NdrFcShort( 0x31a ),	/* Offset= 794 (948) */
/* 156 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 160 */	NdrFcShort( 0x318 ),	/* Offset= 792 (952) */
/* 162 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 166 */	NdrFcShort( 0x316 ),	/* Offset= 790 (956) */
/* 168 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 172 */	NdrFcShort( 0x314 ),	/* Offset= 788 (960) */
/* 174 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 178 */	NdrFcShort( 0x312 ),	/* Offset= 786 (964) */
/* 180 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 184 */	NdrFcShort( 0x310 ),	/* Offset= 784 (968) */
/* 186 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 190 */	NdrFcShort( 0x30e ),	/* Offset= 782 (972) */
/* 192 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 196 */	NdrFcShort( 0x2f8 ),	/* Offset= 760 (956) */
/* 198 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 202 */	NdrFcShort( 0x2f6 ),	/* Offset= 758 (960) */
/* 204 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 208 */	NdrFcShort( 0x300 ),	/* Offset= 768 (976) */
/* 210 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 214 */	NdrFcShort( 0x2f6 ),	/* Offset= 758 (972) */
/* 216 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 220 */	NdrFcShort( 0x2f8 ),	/* Offset= 760 (980) */
/* 222 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 226 */	NdrFcShort( 0x2f6 ),	/* Offset= 758 (984) */
/* 228 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 232 */	NdrFcShort( 0x2f4 ),	/* Offset= 756 (988) */
/* 234 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 238 */	NdrFcShort( 0x2f2 ),	/* Offset= 754 (992) */
/* 240 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 244 */	NdrFcShort( 0x2f0 ),	/* Offset= 752 (996) */
/* 246 */	NdrFcLong( 0x10 ),	/* 16 */
/* 250 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 252 */	NdrFcLong( 0x12 ),	/* 18 */
/* 256 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 258 */	NdrFcLong( 0x13 ),	/* 19 */
/* 262 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 264 */	NdrFcLong( 0x15 ),	/* 21 */
/* 268 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 270 */	NdrFcLong( 0x16 ),	/* 22 */
/* 274 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 276 */	NdrFcLong( 0x17 ),	/* 23 */
/* 280 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 282 */	NdrFcLong( 0xe ),	/* 14 */
/* 286 */	NdrFcShort( 0x2ce ),	/* Offset= 718 (1004) */
/* 288 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 292 */	NdrFcShort( 0x2d2 ),	/* Offset= 722 (1014) */
/* 294 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 298 */	NdrFcShort( 0x2d0 ),	/* Offset= 720 (1018) */
/* 300 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 304 */	NdrFcShort( 0x28c ),	/* Offset= 652 (956) */
/* 306 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 310 */	NdrFcShort( 0x28a ),	/* Offset= 650 (960) */
/* 312 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 316 */	NdrFcShort( 0x288 ),	/* Offset= 648 (964) */
/* 318 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 322 */	NdrFcShort( 0x27e ),	/* Offset= 638 (960) */
/* 324 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 328 */	NdrFcShort( 0x278 ),	/* Offset= 632 (960) */
/* 330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* Offset= 0 (334) */
/* 336 */	NdrFcLong( 0x1 ),	/* 1 */
/* 340 */	NdrFcShort( 0x0 ),	/* Offset= 0 (340) */
/* 342 */	NdrFcShort( 0xffff ),	/* Offset= -1 (341) */
/* 344 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 348 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 350 */	
			0x13, 0x0,	/* FC_OP */
/* 352 */	NdrFcShort( 0xfeb2 ),	/* Offset= -334 (18) */
/* 354 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 356 */	NdrFcLong( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x0 ),	/* 0 */
/* 362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 364 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 366 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 368 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 370 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 372 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 374 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 382 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 384 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 386 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 388 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 390 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 392 */	NdrFcShort( 0x2 ),	/* Offset= 2 (394) */
/* 394 */	
			0x13, 0x0,	/* FC_OP */
/* 396 */	NdrFcShort( 0x216 ),	/* Offset= 534 (930) */
/* 398 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 400 */	NdrFcShort( 0x18 ),	/* 24 */
/* 402 */	NdrFcShort( 0xa ),	/* 10 */
/* 404 */	NdrFcLong( 0x8 ),	/* 8 */
/* 408 */	NdrFcShort( 0x5a ),	/* Offset= 90 (498) */
/* 410 */	NdrFcLong( 0xd ),	/* 13 */
/* 414 */	NdrFcShort( 0x7e ),	/* Offset= 126 (540) */
/* 416 */	NdrFcLong( 0x9 ),	/* 9 */
/* 420 */	NdrFcShort( 0x9e ),	/* Offset= 158 (578) */
/* 422 */	NdrFcLong( 0xc ),	/* 12 */
/* 426 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (626) */
/* 428 */	NdrFcLong( 0x24 ),	/* 36 */
/* 432 */	NdrFcShort( 0x124 ),	/* Offset= 292 (724) */
/* 434 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 438 */	NdrFcShort( 0x140 ),	/* Offset= 320 (758) */
/* 440 */	NdrFcLong( 0x10 ),	/* 16 */
/* 444 */	NdrFcShort( 0x15a ),	/* Offset= 346 (790) */
/* 446 */	NdrFcLong( 0x2 ),	/* 2 */
/* 450 */	NdrFcShort( 0x174 ),	/* Offset= 372 (822) */
/* 452 */	NdrFcLong( 0x3 ),	/* 3 */
/* 456 */	NdrFcShort( 0x18e ),	/* Offset= 398 (854) */
/* 458 */	NdrFcLong( 0x14 ),	/* 20 */
/* 462 */	NdrFcShort( 0x1a8 ),	/* Offset= 424 (886) */
/* 464 */	NdrFcShort( 0xffff ),	/* Offset= -1 (463) */
/* 466 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 468 */	NdrFcShort( 0x4 ),	/* 4 */
/* 470 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 476 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 478 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 480 */	NdrFcShort( 0x4 ),	/* 4 */
/* 482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 484 */	NdrFcShort( 0x1 ),	/* 1 */
/* 486 */	NdrFcShort( 0x0 ),	/* 0 */
/* 488 */	NdrFcShort( 0x0 ),	/* 0 */
/* 490 */	0x13, 0x0,	/* FC_OP */
/* 492 */	NdrFcShort( 0xfe26 ),	/* Offset= -474 (18) */
/* 494 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 496 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 498 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 500 */	NdrFcShort( 0x8 ),	/* 8 */
/* 502 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 504 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 506 */	NdrFcShort( 0x4 ),	/* 4 */
/* 508 */	NdrFcShort( 0x4 ),	/* 4 */
/* 510 */	0x11, 0x0,	/* FC_RP */
/* 512 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (466) */
/* 514 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 516 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 518 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 522 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 528 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 532 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xff4a ),	/* Offset= -182 (354) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 542 */	NdrFcShort( 0x8 ),	/* 8 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x6 ),	/* Offset= 6 (552) */
/* 548 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 550 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 552 */	
			0x11, 0x0,	/* FC_RP */
/* 554 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (518) */
/* 556 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 558 */	NdrFcShort( 0x0 ),	/* 0 */
/* 560 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 564 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 566 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 570 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 572 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 574 */	NdrFcShort( 0xff36 ),	/* Offset= -202 (372) */
/* 576 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 578 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 580 */	NdrFcShort( 0x8 ),	/* 8 */
/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 584 */	NdrFcShort( 0x6 ),	/* Offset= 6 (590) */
/* 586 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 588 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 590 */	
			0x11, 0x0,	/* FC_RP */
/* 592 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (556) */
/* 594 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 596 */	NdrFcShort( 0x4 ),	/* 4 */
/* 598 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 602 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 604 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 606 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 608 */	NdrFcShort( 0x4 ),	/* 4 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 612 */	NdrFcShort( 0x1 ),	/* 1 */
/* 614 */	NdrFcShort( 0x0 ),	/* 0 */
/* 616 */	NdrFcShort( 0x0 ),	/* 0 */
/* 618 */	0x13, 0x0,	/* FC_OP */
/* 620 */	NdrFcShort( 0x192 ),	/* Offset= 402 (1022) */
/* 622 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 624 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 626 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 628 */	NdrFcShort( 0x8 ),	/* 8 */
/* 630 */	NdrFcShort( 0x0 ),	/* 0 */
/* 632 */	NdrFcShort( 0x6 ),	/* Offset= 6 (638) */
/* 634 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 636 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 638 */	
			0x11, 0x0,	/* FC_RP */
/* 640 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (594) */
/* 642 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 644 */	NdrFcLong( 0x2f ),	/* 47 */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 650 */	NdrFcShort( 0x0 ),	/* 0 */
/* 652 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 654 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 656 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 658 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 660 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 662 */	NdrFcShort( 0x1 ),	/* 1 */
/* 664 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 666 */	NdrFcShort( 0x4 ),	/* 4 */
/* 668 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 670 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 672 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 674 */	NdrFcShort( 0x10 ),	/* 16 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */
/* 678 */	NdrFcShort( 0xa ),	/* Offset= 10 (688) */
/* 680 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 682 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 684 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (642) */
/* 686 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 688 */	
			0x13, 0x0,	/* FC_OP */
/* 690 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (660) */
/* 692 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 694 */	NdrFcShort( 0x4 ),	/* 4 */
/* 696 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 700 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 702 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 704 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 706 */	NdrFcShort( 0x4 ),	/* 4 */
/* 708 */	NdrFcShort( 0x0 ),	/* 0 */
/* 710 */	NdrFcShort( 0x1 ),	/* 1 */
/* 712 */	NdrFcShort( 0x0 ),	/* 0 */
/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 716 */	0x13, 0x0,	/* FC_OP */
/* 718 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (672) */
/* 720 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 722 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 724 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 726 */	NdrFcShort( 0x8 ),	/* 8 */
/* 728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 730 */	NdrFcShort( 0x6 ),	/* Offset= 6 (736) */
/* 732 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 734 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 736 */	
			0x11, 0x0,	/* FC_RP */
/* 738 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (692) */
/* 740 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 742 */	NdrFcShort( 0x8 ),	/* 8 */
/* 744 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 746 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 748 */	NdrFcShort( 0x10 ),	/* 16 */
/* 750 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 752 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 754 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (740) */
			0x5b,		/* FC_END */
/* 758 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 760 */	NdrFcShort( 0x18 ),	/* 24 */
/* 762 */	NdrFcShort( 0x0 ),	/* 0 */
/* 764 */	NdrFcShort( 0xa ),	/* Offset= 10 (774) */
/* 766 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 768 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 770 */	NdrFcShort( 0xffe8 ),	/* Offset= -24 (746) */
/* 772 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 774 */	
			0x11, 0x0,	/* FC_RP */
/* 776 */	NdrFcShort( 0xfefe ),	/* Offset= -258 (518) */
/* 778 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 780 */	NdrFcShort( 0x1 ),	/* 1 */
/* 782 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 786 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 788 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 790 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 792 */	NdrFcShort( 0x8 ),	/* 8 */
/* 794 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 796 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 798 */	NdrFcShort( 0x4 ),	/* 4 */
/* 800 */	NdrFcShort( 0x4 ),	/* 4 */
/* 802 */	0x13, 0x0,	/* FC_OP */
/* 804 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (778) */
/* 806 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 808 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 810 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 812 */	NdrFcShort( 0x2 ),	/* 2 */
/* 814 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 818 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 820 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 822 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 824 */	NdrFcShort( 0x8 ),	/* 8 */
/* 826 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 828 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 830 */	NdrFcShort( 0x4 ),	/* 4 */
/* 832 */	NdrFcShort( 0x4 ),	/* 4 */
/* 834 */	0x13, 0x0,	/* FC_OP */
/* 836 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (810) */
/* 838 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 840 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 842 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 844 */	NdrFcShort( 0x4 ),	/* 4 */
/* 846 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 848 */	NdrFcShort( 0x0 ),	/* 0 */
/* 850 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 852 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 854 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 856 */	NdrFcShort( 0x8 ),	/* 8 */
/* 858 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 860 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 862 */	NdrFcShort( 0x4 ),	/* 4 */
/* 864 */	NdrFcShort( 0x4 ),	/* 4 */
/* 866 */	0x13, 0x0,	/* FC_OP */
/* 868 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (842) */
/* 870 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 872 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 874 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 876 */	NdrFcShort( 0x8 ),	/* 8 */
/* 878 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 882 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 884 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 886 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 888 */	NdrFcShort( 0x8 ),	/* 8 */
/* 890 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 892 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 894 */	NdrFcShort( 0x4 ),	/* 4 */
/* 896 */	NdrFcShort( 0x4 ),	/* 4 */
/* 898 */	0x13, 0x0,	/* FC_OP */
/* 900 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (874) */
/* 902 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 904 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 906 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 908 */	NdrFcShort( 0x8 ),	/* 8 */
/* 910 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 912 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 914 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 916 */	NdrFcShort( 0x8 ),	/* 8 */
/* 918 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 920 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 922 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 924 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 926 */	NdrFcShort( 0xffec ),	/* Offset= -20 (906) */
/* 928 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 930 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 932 */	NdrFcShort( 0x28 ),	/* 40 */
/* 934 */	NdrFcShort( 0xffec ),	/* Offset= -20 (914) */
/* 936 */	NdrFcShort( 0x0 ),	/* Offset= 0 (936) */
/* 938 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 940 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 942 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 944 */	NdrFcShort( 0xfdde ),	/* Offset= -546 (398) */
/* 946 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 948 */	
			0x13, 0x0,	/* FC_OP */
/* 950 */	NdrFcShort( 0xfeea ),	/* Offset= -278 (672) */
/* 952 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 954 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 956 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 958 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 960 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 962 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 964 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 966 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 968 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 970 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 972 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 974 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 976 */	
			0x13, 0x0,	/* FC_OP */
/* 978 */	NdrFcShort( 0xfd86 ),	/* Offset= -634 (344) */
/* 980 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 982 */	NdrFcShort( 0xfd88 ),	/* Offset= -632 (350) */
/* 984 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 986 */	NdrFcShort( 0xfd88 ),	/* Offset= -632 (354) */
/* 988 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 990 */	NdrFcShort( 0xfd96 ),	/* Offset= -618 (372) */
/* 992 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 994 */	NdrFcShort( 0xfda4 ),	/* Offset= -604 (390) */
/* 996 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 998 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1000) */
/* 1000 */	
			0x13, 0x0,	/* FC_OP */
/* 1002 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1022) */
/* 1004 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 1006 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1008 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 1010 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 1012 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1014 */	
			0x13, 0x0,	/* FC_OP */
/* 1016 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (1004) */
/* 1018 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1020 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1022 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 1024 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1028 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1028) */
/* 1030 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1032 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1034 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1036 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1038 */	NdrFcShort( 0xfc20 ),	/* Offset= -992 (46) */
/* 1040 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1042 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1044 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1046 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1048 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1050 */	NdrFcShort( 0xfc10 ),	/* Offset= -1008 (42) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            VARIANT_UserSize
            ,VARIANT_UserMarshal
            ,VARIANT_UserUnmarshal
            ,VARIANT_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IAppReport, ver. 0.0,
   GUID={0xCDCA6A6F,0x9C38,0x4828,{0xA7,0x6C,0x05,0xA6,0xE4,0x90,0xE5,0x74}} */

#pragma code_seg(".orpc")
static const unsigned short IAppReport_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    48,
    90
    };

static const MIDL_STUBLESS_PROXY_INFO IAppReport_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IAppReport_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IAppReport_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IAppReport_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(10) _IAppReportProxyVtbl = 
{
    &IAppReport_ProxyInfo,
    &IID_IAppReport,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IAppReport::BrowseForExecutable */ ,
    (void *) (INT_PTR) -1 /* IAppReport::GetApplicationFromList */ ,
    (void *) (INT_PTR) -1 /* IAppReport::CreateReport */
};


static const PRPC_STUB_FUNCTION IAppReport_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IAppReportStubVtbl =
{
    &IID_IAppReport,
    &IAppReport_ServerInfo,
    10,
    &IAppReport_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000167, /* MIDL Version 6.0.359 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _appcompr_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IAppReportProxyVtbl,
    0
};

const CInterfaceStubVtbl * _appcompr_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IAppReportStubVtbl,
    0
};

PCInterfaceName const _appcompr_InterfaceNamesList[] = 
{
    "IAppReport",
    0
};

const IID *  _appcompr_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _appcompr_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _appcompr, pIID, n)

int __stdcall _appcompr_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_appcompr_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo appcompr_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _appcompr_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _appcompr_StubVtblList,
    (const PCInterfaceName * ) & _appcompr_InterfaceNamesList,
    (const IID ** ) & _appcompr_BaseIIDList,
    & _appcompr_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0359 */
/* Compiler settings for appcompr.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "appcompr.h"

#define TYPE_FORMAT_STRING_SIZE   1003                              
#define PROC_FORMAT_STRING_SIZE   163                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IAppReport_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IAppReport_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure BrowseForExecutable */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 16 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x20 ),	/* 32 */
/* 20 */	NdrFcShort( 0x2 ),	/* 2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrWinTitle */

/* 26 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrPreviousPath */

/* 32 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrExeName */

/* 38 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 42 */	NdrFcShort( 0x3e0 ),	/* Type Offset=992 */

	/* Return value */

/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 46 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetApplicationFromList */

/* 50 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x8 ),	/* 8 */
/* 58 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x8 ),	/* 8 */
/* 64 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 66 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 68 */	NdrFcShort( 0x20 ),	/* 32 */
/* 70 */	NdrFcShort( 0x1 ),	/* 1 */
/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrTitle */

/* 76 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 78 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 80 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrExeName */

/* 82 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 84 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 86 */	NdrFcShort( 0x3e0 ),	/* Type Offset=992 */

	/* Return value */

/* 88 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 90 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 92 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateReport */

/* 94 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 96 */	NdrFcLong( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x9 ),	/* 9 */
/* 102 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
/* 106 */	NdrFcShort( 0x8 ),	/* 8 */
/* 108 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 110 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 112 */	NdrFcShort( 0x20 ),	/* 32 */
/* 114 */	NdrFcShort( 0x5 ),	/* 5 */
/* 116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrTitle */

/* 120 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 122 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 124 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrProblemType */

/* 126 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 128 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 130 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrComment */

/* 132 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 134 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 136 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrACWResult */

/* 138 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 140 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 142 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrAppName */

/* 144 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 146 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 148 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter DwResult */

/* 150 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 152 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 154 */	NdrFcShort( 0x3e0 ),	/* Type Offset=992 */

	/* Return value */

/* 156 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 158 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x8 ),	/* 8 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffde ),	/* Offset= -34 (2) */
/* 38 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 40 */	NdrFcShort( 0x3b8 ),	/* Offset= 952 (992) */
/* 42 */	
			0x13, 0x0,	/* FC_OP */
/* 44 */	NdrFcShort( 0x3a0 ),	/* Offset= 928 (972) */
/* 46 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 48 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 50 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 52 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 54 */	NdrFcShort( 0x2 ),	/* Offset= 2 (56) */
/* 56 */	NdrFcShort( 0x10 ),	/* 16 */
/* 58 */	NdrFcShort( 0x2f ),	/* 47 */
/* 60 */	NdrFcLong( 0x14 ),	/* 20 */
/* 64 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 66 */	NdrFcLong( 0x3 ),	/* 3 */
/* 70 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 72 */	NdrFcLong( 0x11 ),	/* 17 */
/* 76 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 78 */	NdrFcLong( 0x2 ),	/* 2 */
/* 82 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 84 */	NdrFcLong( 0x4 ),	/* 4 */
/* 88 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 90 */	NdrFcLong( 0x5 ),	/* 5 */
/* 94 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 96 */	NdrFcLong( 0xb ),	/* 11 */
/* 100 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 102 */	NdrFcLong( 0xa ),	/* 10 */
/* 106 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 108 */	NdrFcLong( 0x6 ),	/* 6 */
/* 112 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (344) */
/* 114 */	NdrFcLong( 0x7 ),	/* 7 */
/* 118 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 120 */	NdrFcLong( 0x8 ),	/* 8 */
/* 124 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (350) */
/* 126 */	NdrFcLong( 0xd ),	/* 13 */
/* 130 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (354) */
/* 132 */	NdrFcLong( 0x9 ),	/* 9 */
/* 136 */	NdrFcShort( 0xec ),	/* Offset= 236 (372) */
/* 138 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 142 */	NdrFcShort( 0xf8 ),	/* Offset= 248 (390) */
/* 144 */	NdrFcLong( 0x24 ),	/* 36 */
/* 148 */	NdrFcShort( 0x2ee ),	/* Offset= 750 (898) */
/* 150 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 154 */	NdrFcShort( 0x2e8 ),	/* Offset= 744 (898) */
/* 156 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 160 */	NdrFcShort( 0x2e6 ),	/* Offset= 742 (902) */
/* 162 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 166 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (906) */
/* 168 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 172 */	NdrFcShort( 0x2e2 ),	/* Offset= 738 (910) */
/* 174 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 178 */	NdrFcShort( 0x2e0 ),	/* Offset= 736 (914) */
/* 180 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 184 */	NdrFcShort( 0x2de ),	/* Offset= 734 (918) */
/* 186 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 190 */	NdrFcShort( 0x2dc ),	/* Offset= 732 (922) */
/* 192 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 196 */	NdrFcShort( 0x2c6 ),	/* Offset= 710 (906) */
/* 198 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 202 */	NdrFcShort( 0x2c4 ),	/* Offset= 708 (910) */
/* 204 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 208 */	NdrFcShort( 0x2ce ),	/* Offset= 718 (926) */
/* 210 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 214 */	NdrFcShort( 0x2c4 ),	/* Offset= 708 (922) */
/* 216 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 220 */	NdrFcShort( 0x2c6 ),	/* Offset= 710 (930) */
/* 222 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 226 */	NdrFcShort( 0x2c4 ),	/* Offset= 708 (934) */
/* 228 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 232 */	NdrFcShort( 0x2c2 ),	/* Offset= 706 (938) */
/* 234 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 238 */	NdrFcShort( 0x2c0 ),	/* Offset= 704 (942) */
/* 240 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 244 */	NdrFcShort( 0x2be ),	/* Offset= 702 (946) */
/* 246 */	NdrFcLong( 0x10 ),	/* 16 */
/* 250 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 252 */	NdrFcLong( 0x12 ),	/* 18 */
/* 256 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 258 */	NdrFcLong( 0x13 ),	/* 19 */
/* 262 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 264 */	NdrFcLong( 0x15 ),	/* 21 */
/* 268 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 270 */	NdrFcLong( 0x16 ),	/* 22 */
/* 274 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 276 */	NdrFcLong( 0x17 ),	/* 23 */
/* 280 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 282 */	NdrFcLong( 0xe ),	/* 14 */
/* 286 */	NdrFcShort( 0x29c ),	/* Offset= 668 (954) */
/* 288 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 292 */	NdrFcShort( 0x2a0 ),	/* Offset= 672 (964) */
/* 294 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 298 */	NdrFcShort( 0x29e ),	/* Offset= 670 (968) */
/* 300 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 304 */	NdrFcShort( 0x25a ),	/* Offset= 602 (906) */
/* 306 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 310 */	NdrFcShort( 0x258 ),	/* Offset= 600 (910) */
/* 312 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 316 */	NdrFcShort( 0x256 ),	/* Offset= 598 (914) */
/* 318 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 322 */	NdrFcShort( 0x24c ),	/* Offset= 588 (910) */
/* 324 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 328 */	NdrFcShort( 0x246 ),	/* Offset= 582 (910) */
/* 330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* Offset= 0 (334) */
/* 336 */	NdrFcLong( 0x1 ),	/* 1 */
/* 340 */	NdrFcShort( 0x0 ),	/* Offset= 0 (340) */
/* 342 */	NdrFcShort( 0xffff ),	/* Offset= -1 (341) */
/* 344 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 348 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 350 */	
			0x13, 0x0,	/* FC_OP */
/* 352 */	NdrFcShort( 0xfeb2 ),	/* Offset= -334 (18) */
/* 354 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 356 */	NdrFcLong( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x0 ),	/* 0 */
/* 362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 364 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 366 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 368 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 370 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 372 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 374 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 382 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 384 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 386 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 388 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 390 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 392 */	NdrFcShort( 0x2 ),	/* Offset= 2 (394) */
/* 394 */	
			0x13, 0x0,	/* FC_OP */
/* 396 */	NdrFcShort( 0x1e4 ),	/* Offset= 484 (880) */
/* 398 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x89,		/* 137 */
/* 400 */	NdrFcShort( 0x20 ),	/* 32 */
/* 402 */	NdrFcShort( 0xa ),	/* 10 */
/* 404 */	NdrFcLong( 0x8 ),	/* 8 */
/* 408 */	NdrFcShort( 0x50 ),	/* Offset= 80 (488) */
/* 410 */	NdrFcLong( 0xd ),	/* 13 */
/* 414 */	NdrFcShort( 0x70 ),	/* Offset= 112 (526) */
/* 416 */	NdrFcLong( 0x9 ),	/* 9 */
/* 420 */	NdrFcShort( 0x90 ),	/* Offset= 144 (564) */
/* 422 */	NdrFcLong( 0xc ),	/* 12 */
/* 426 */	NdrFcShort( 0xb0 ),	/* Offset= 176 (602) */
/* 428 */	NdrFcLong( 0x24 ),	/* 36 */
/* 432 */	NdrFcShort( 0x102 ),	/* Offset= 258 (690) */
/* 434 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 438 */	NdrFcShort( 0x11e ),	/* Offset= 286 (724) */
/* 440 */	NdrFcLong( 0x10 ),	/* 16 */
/* 444 */	NdrFcShort( 0x138 ),	/* Offset= 312 (756) */
/* 446 */	NdrFcLong( 0x2 ),	/* 2 */
/* 450 */	NdrFcShort( 0x14e ),	/* Offset= 334 (784) */
/* 452 */	NdrFcLong( 0x3 ),	/* 3 */
/* 456 */	NdrFcShort( 0x164 ),	/* Offset= 356 (812) */
/* 458 */	NdrFcLong( 0x14 ),	/* 20 */
/* 462 */	NdrFcShort( 0x17a ),	/* Offset= 378 (840) */
/* 464 */	NdrFcShort( 0xffff ),	/* Offset= -1 (463) */
/* 466 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 470 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 476 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 480 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 482 */	
			0x13, 0x0,	/* FC_OP */
/* 484 */	NdrFcShort( 0xfe2e ),	/* Offset= -466 (18) */
/* 486 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 488 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 490 */	NdrFcShort( 0x10 ),	/* 16 */
/* 492 */	NdrFcShort( 0x0 ),	/* 0 */
/* 494 */	NdrFcShort( 0x6 ),	/* Offset= 6 (500) */
/* 496 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 498 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 500 */	
			0x11, 0x0,	/* FC_RP */
/* 502 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (466) */
/* 504 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 506 */	NdrFcShort( 0x0 ),	/* 0 */
/* 508 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 514 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 518 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 520 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 522 */	NdrFcShort( 0xff58 ),	/* Offset= -168 (354) */
/* 524 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 526 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 528 */	NdrFcShort( 0x10 ),	/* 16 */
/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 532 */	NdrFcShort( 0x6 ),	/* Offset= 6 (538) */
/* 534 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 536 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 538 */	
			0x11, 0x0,	/* FC_RP */
/* 540 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (504) */
/* 542 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 548 */	NdrFcShort( 0x0 ),	/* 0 */
/* 550 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 552 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 556 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 558 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 560 */	NdrFcShort( 0xff44 ),	/* Offset= -188 (372) */
/* 562 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 564 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 566 */	NdrFcShort( 0x10 ),	/* 16 */
/* 568 */	NdrFcShort( 0x0 ),	/* 0 */
/* 570 */	NdrFcShort( 0x6 ),	/* Offset= 6 (576) */
/* 572 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 574 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 576 */	
			0x11, 0x0,	/* FC_RP */
/* 578 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (542) */
/* 580 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 584 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 588 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 590 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 594 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 596 */	
			0x13, 0x0,	/* FC_OP */
/* 598 */	NdrFcShort( 0x176 ),	/* Offset= 374 (972) */
/* 600 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 602 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 604 */	NdrFcShort( 0x10 ),	/* 16 */
/* 606 */	NdrFcShort( 0x0 ),	/* 0 */
/* 608 */	NdrFcShort( 0x6 ),	/* Offset= 6 (614) */
/* 610 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 612 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 614 */	
			0x11, 0x0,	/* FC_RP */
/* 616 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (580) */
/* 618 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 620 */	NdrFcLong( 0x2f ),	/* 47 */
/* 624 */	NdrFcShort( 0x0 ),	/* 0 */
/* 626 */	NdrFcShort( 0x0 ),	/* 0 */
/* 628 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 630 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 632 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 634 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 636 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 638 */	NdrFcShort( 0x1 ),	/* 1 */
/* 640 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 642 */	NdrFcShort( 0x4 ),	/* 4 */
/* 644 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 646 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 648 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 650 */	NdrFcShort( 0x18 ),	/* 24 */
/* 652 */	NdrFcShort( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0xa ),	/* Offset= 10 (664) */
/* 656 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 658 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 660 */	NdrFcShort( 0xffd6 ),	/* Offset= -42 (618) */
/* 662 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 664 */	
			0x13, 0x0,	/* FC_OP */
/* 666 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (636) */
/* 668 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 670 */	NdrFcShort( 0x0 ),	/* 0 */
/* 672 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 678 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 682 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 684 */	
			0x13, 0x0,	/* FC_OP */
/* 686 */	NdrFcShort( 0xffda ),	/* Offset= -38 (648) */
/* 688 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 690 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 692 */	NdrFcShort( 0x10 ),	/* 16 */
/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 696 */	NdrFcShort( 0x6 ),	/* Offset= 6 (702) */
/* 698 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 700 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 702 */	
			0x11, 0x0,	/* FC_RP */
/* 704 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (668) */
/* 706 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 708 */	NdrFcShort( 0x8 ),	/* 8 */
/* 710 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 712 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 714 */	NdrFcShort( 0x10 ),	/* 16 */
/* 716 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 718 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 720 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (706) */
			0x5b,		/* FC_END */
/* 724 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 726 */	NdrFcShort( 0x20 ),	/* 32 */
/* 728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 730 */	NdrFcShort( 0xa ),	/* Offset= 10 (740) */
/* 732 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 734 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 736 */	0x0,		/* 0 */
			NdrFcShort( 0xffe7 ),	/* Offset= -25 (712) */
			0x5b,		/* FC_END */
/* 740 */	
			0x11, 0x0,	/* FC_RP */
/* 742 */	NdrFcShort( 0xff12 ),	/* Offset= -238 (504) */
/* 744 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 746 */	NdrFcShort( 0x1 ),	/* 1 */
/* 748 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 750 */	NdrFcShort( 0x0 ),	/* 0 */
/* 752 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 754 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 756 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 758 */	NdrFcShort( 0x10 ),	/* 16 */
/* 760 */	NdrFcShort( 0x0 ),	/* 0 */
/* 762 */	NdrFcShort( 0x6 ),	/* Offset= 6 (768) */
/* 764 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 766 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 768 */	
			0x13, 0x0,	/* FC_OP */
/* 770 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (744) */
/* 772 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 774 */	NdrFcShort( 0x2 ),	/* 2 */
/* 776 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 778 */	NdrFcShort( 0x0 ),	/* 0 */
/* 780 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 782 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 784 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 786 */	NdrFcShort( 0x10 ),	/* 16 */
/* 788 */	NdrFcShort( 0x0 ),	/* 0 */
/* 790 */	NdrFcShort( 0x6 ),	/* Offset= 6 (796) */
/* 792 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 794 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 796 */	
			0x13, 0x0,	/* FC_OP */
/* 798 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (772) */
/* 800 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 802 */	NdrFcShort( 0x4 ),	/* 4 */
/* 804 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 806 */	NdrFcShort( 0x0 ),	/* 0 */
/* 808 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 810 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 812 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 814 */	NdrFcShort( 0x10 ),	/* 16 */
/* 816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 818 */	NdrFcShort( 0x6 ),	/* Offset= 6 (824) */
/* 820 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 822 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 824 */	
			0x13, 0x0,	/* FC_OP */
/* 826 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (800) */
/* 828 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 830 */	NdrFcShort( 0x8 ),	/* 8 */
/* 832 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 834 */	NdrFcShort( 0x0 ),	/* 0 */
/* 836 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 838 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 840 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 842 */	NdrFcShort( 0x10 ),	/* 16 */
/* 844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 846 */	NdrFcShort( 0x6 ),	/* Offset= 6 (852) */
/* 848 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 850 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 852 */	
			0x13, 0x0,	/* FC_OP */
/* 854 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (828) */
/* 856 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 858 */	NdrFcShort( 0x8 ),	/* 8 */
/* 860 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 862 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 864 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 866 */	NdrFcShort( 0x8 ),	/* 8 */
/* 868 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 870 */	NdrFcShort( 0xffc8 ),	/* -56 */
/* 872 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 874 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 876 */	NdrFcShort( 0xffec ),	/* Offset= -20 (856) */
/* 878 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 880 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 882 */	NdrFcShort( 0x38 ),	/* 56 */
/* 884 */	NdrFcShort( 0xffec ),	/* Offset= -20 (864) */
/* 886 */	NdrFcShort( 0x0 ),	/* Offset= 0 (886) */
/* 888 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 890 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 892 */	0x40,		/* FC_STRUCTPAD4 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 894 */	0x0,		/* 0 */
			NdrFcShort( 0xfe0f ),	/* Offset= -497 (398) */
			0x5b,		/* FC_END */
/* 898 */	
			0x13, 0x0,	/* FC_OP */
/* 900 */	NdrFcShort( 0xff04 ),	/* Offset= -252 (648) */
/* 902 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 904 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 906 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 908 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 910 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 912 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 914 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 916 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 918 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 920 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 922 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 924 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 926 */	
			0x13, 0x0,	/* FC_OP */
/* 928 */	NdrFcShort( 0xfdb8 ),	/* Offset= -584 (344) */
/* 930 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 932 */	NdrFcShort( 0xfdba ),	/* Offset= -582 (350) */
/* 934 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 936 */	NdrFcShort( 0xfdba ),	/* Offset= -582 (354) */
/* 938 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 940 */	NdrFcShort( 0xfdc8 ),	/* Offset= -568 (372) */
/* 942 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 944 */	NdrFcShort( 0xfdd6 ),	/* Offset= -554 (390) */
/* 946 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 948 */	NdrFcShort( 0x2 ),	/* Offset= 2 (950) */
/* 950 */	
			0x13, 0x0,	/* FC_OP */
/* 952 */	NdrFcShort( 0x14 ),	/* Offset= 20 (972) */
/* 954 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 956 */	NdrFcShort( 0x10 ),	/* 16 */
/* 958 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 960 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 962 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 964 */	
			0x13, 0x0,	/* FC_OP */
/* 966 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (954) */
/* 968 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 970 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 972 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 974 */	NdrFcShort( 0x20 ),	/* 32 */
/* 976 */	NdrFcShort( 0x0 ),	/* 0 */
/* 978 */	NdrFcShort( 0x0 ),	/* Offset= 0 (978) */
/* 980 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 982 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 984 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 986 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 988 */	NdrFcShort( 0xfc52 ),	/* Offset= -942 (46) */
/* 990 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 992 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 994 */	NdrFcShort( 0x1 ),	/* 1 */
/* 996 */	NdrFcShort( 0x18 ),	/* 24 */
/* 998 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1000 */	NdrFcShort( 0xfc42 ),	/* Offset= -958 (42) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            VARIANT_UserSize
            ,VARIANT_UserMarshal
            ,VARIANT_UserUnmarshal
            ,VARIANT_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IAppReport, ver. 0.0,
   GUID={0xCDCA6A6F,0x9C38,0x4828,{0xA7,0x6C,0x05,0xA6,0xE4,0x90,0xE5,0x74}} */

#pragma code_seg(".orpc")
static const unsigned short IAppReport_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    50,
    94
    };

static const MIDL_STUBLESS_PROXY_INFO IAppReport_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IAppReport_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IAppReport_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IAppReport_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(10) _IAppReportProxyVtbl = 
{
    &IAppReport_ProxyInfo,
    &IID_IAppReport,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IAppReport::BrowseForExecutable */ ,
    (void *) (INT_PTR) -1 /* IAppReport::GetApplicationFromList */ ,
    (void *) (INT_PTR) -1 /* IAppReport::CreateReport */
};


static const PRPC_STUB_FUNCTION IAppReport_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IAppReportStubVtbl =
{
    &IID_IAppReport,
    &IAppReport_ServerInfo,
    10,
    &IAppReport_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000167, /* MIDL Version 6.0.359 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _appcompr_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IAppReportProxyVtbl,
    0
};

const CInterfaceStubVtbl * _appcompr_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IAppReportStubVtbl,
    0
};

PCInterfaceName const _appcompr_InterfaceNamesList[] = 
{
    "IAppReport",
    0
};

const IID *  _appcompr_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _appcompr_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _appcompr, pIID, n)

int __stdcall _appcompr_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_appcompr_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo appcompr_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _appcompr_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _appcompr_StubVtblList,
    (const PCInterfaceName * ) & _appcompr_InterfaceNamesList,
    (const IID ** ) & _appcompr_BaseIIDList,
    & _appcompr_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\appreport.cpp ===
// AppReport.cpp : Implementation of CAppReport

#include "stdafx.h"
#include "Appcompr.h"
#include "AppReport.h"
#include "progview.h"
#include "upload.h"

/////////////////////////////////////////////////////////////////////////////
// CAppReport


STDMETHODIMP CAppReport::BrowseForExecutable(
        BSTR bstrWinTitle,
        BSTR bstrPreviousPath,
        VARIANT *bstrExeName
        )
{
    WCHAR NameBuffer[MAX_PATH]={0};
    WCHAR Filter[MAX_PATH];
    OPENFILENAMEW FileToOpen;
    BOOL result;
    HWND hParent;
    BOOL bNT4   = FALSE;
    DWORD dwVersion = GetVersion();
    DWORD dwWindowsMajorVersion =  (DWORD)(LOBYTE(LOWORD(dwVersion)));
    CComBSTR WindowText = L"AppCompat Report Proto - Microsoft Internet Explorer";
    CComBSTR FileName = L"";


    if (dwWindowsMajorVersion < 5)
    {
        ::MessageBoxW(NULL,L"Invalid OS",NULL,MB_OK);
    }

    if (dwVersion < 0x80000000)
    {
        if (dwWindowsMajorVersion == 4)
            bNT4 = TRUE;
    }

    GetWindowHandle(WindowText, &hParent);

    if (bNT4)
    {
        FileToOpen.lStructSize = sizeof(OPENFILENAME);
    }
    else
    {
        FileToOpen.lStructSize = sizeof (OPENFILENAMEW);
    }

    FileToOpen.hwndOwner = hParent;
    FileToOpen.hInstance = NULL;

    StringCbCopyW(Filter, sizeof(Filter), L"Executable Files;*.exe");
    Filter[16] = L'\0'; Filter[23]=L'\0'; // make a multi-string
    FileToOpen.lpstrFilter = Filter;

    FileToOpen.lpstrCustomFilter = NULL;
    FileToOpen.nMaxCustFilter = 0;
    FileToOpen.nFilterIndex = 1;

    if (bstrPreviousPath == NULL)
    {
        bstrPreviousPath = L"";
    }
    StringCbCopyW(NameBuffer, sizeof(NameBuffer), bstrPreviousPath);
    FileToOpen.lpstrFile = NameBuffer;
    FileToOpen.nMaxFile = MAX_PATH;
    FileToOpen.lpstrFileTitle = NULL;
    FileToOpen.lpstrInitialDir = NULL;
    FileToOpen.lpstrTitle = L"Application Not Compatible";
    FileToOpen.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST ;
    FileToOpen.lpstrDefExt = NULL;
    FileToOpen.lCustData = 0L;
    FileToOpen.lpfnHook = NULL;

    result = GetOpenFileNameW(&FileToOpen);
    if (!result)
    {
        bstrExeName->vt = VT_BSTR;
        bstrExeName->bstrVal = FileName.Detach();
        return S_OK;
    }
    else
    {
        FileName = FileToOpen.lpstrFile;
        bstrExeName->vt = VT_BSTR;
        bstrExeName->bstrVal = FileName.Detach();
    }
    return S_OK;
}

STDMETHODIMP CAppReport::GetApplicationFromList(
    BSTR bstrTitle,
    VARIANT *bstrExeName
    )
{
    ULONG res;
    HWND hParent;
    WCHAR wszAppName[MAX_PATH];
    CComBSTR FileName = L"";

    GetWindowHandle(NULL, &hParent);
    wszAppName[0] = 0;
    res = (ULONG) DialogBoxParamW(::_Module.GetModuleInstance(),
                          MAKEINTRESOURCEW(IDD_PROGRAM_LIST_DIALOG),
                          hParent,
                          Dialog_GetProgFromList,
                          (LPARAM) wszAppName);

    if (res == IDOK)
    {
        FileName = wszAppName;
    }
    bstrExeName->vt = VT_BSTR;
    bstrExeName->bstrVal = FileName.Detach();
    return S_OK;
}

STDMETHODIMP CAppReport::CreateReport(BSTR bstrTitle, BSTR bstrProblemType, BSTR bstrComment, BSTR bstrACWResult,
                                      BSTR bstrAppName, VARIANT *DwResult)
{
    LPWSTR wszAppCompatText = NULL;
    HRESULT hr;
    OSVERSIONINFO OsVer = {0};

    DwResult->vt = VT_INT;
    DwResult->intVal = 0;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVer);

    if ((OsVer.dwMajorVersion < 5) ||
        (OsVer.dwMajorVersion == 5 && OsVer.dwMinorVersion == 0))
    {
        DwResult->intVal = ERROR_APPRPT_OS_NOT_SUPPORTED;
        return S_OK;
    }

    // Generate app compat text file using apphelp.dll
    __try {
        hr = GenerateAppCompatText(bstrAppName, &wszAppCompatText);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
          hr = E_FAIL;
    }
    if (hr != S_OK)
    {
        DwResult->intVal = ERROR_APPRPT_COMPAT_TEXT;
        return S_OK;
    }

    // Send error report using faultrep.dll
    hr = UploadAppProblem(bstrAppName, bstrProblemType, bstrComment,
                          bstrACWResult,
                          wszAppCompatText);


    if (FAILED(hr))
    {
        hr =  ERROR_APPRPT_UPLOADING;
    }
    DwResult->intVal = hr;
    return S_OK;
}


HRESULT
CAppReport::GetWindowHandle(
    LPWSTR wszWinTitle,
    HWND* phwnd
    )
{

    *phwnd = ::GetActiveWindow();

    if (*phwnd == NULL)
    {
        ::MessageBoxW(NULL, L"No active window", NULL, MB_OK);
    }
    *phwnd = ::GetForegroundWindow();

    return S_OK;

    WCHAR Title[MAX_PATH];
    ::GetWindowTextW(*phwnd, Title, sizeof(Title)/sizeof(WCHAR));
    ::MessageBoxW(NULL, Title, NULL, MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( appcompr )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( appcompr ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\progview.cpp ===
// ProgView.cpp : Implementation of CProgView
#include "stdafx.h"
#include <commctrl.h>
#include "ProgView.h"
#include <strsafe.h>

/////////////////////////////////////////////////////////////////////////////
// CProgView


LRESULT
CProgView::OnNotifyListView(
    int     idCtrl,
    LPNMHDR pnmh,
    BOOL&   bHandled
    )
{

    if (idCtrl != IDC_FILE_LIST) {
        bHandled = FALSE;
        return 0;
    }

    if (pnmh->code == NM_DBLCLK)
    {
        return OnDblclkListprograms(idCtrl, pnmh, bHandled);
    }
    // see that we get the notification to fill-in the details
    return NotifyProgramList(m_pProgramList, pnmh, bHandled);
}

LRESULT
CProgView::OnDblclkListprograms(
    int      idCtrl,
    LPNMHDR  pnmh,
    BOOL&    bHandled)
{
    LPNMITEMACTIVATE lpnmh;
    LRESULT SelFile;
    WCHAR FileName[MAX_PATH];

    if (idCtrl != IDC_FILE_LIST) {
        bHandled = FALSE;
        return 0;
    }

    lpnmh = (LPNMITEMACTIVATE) pnmh;

    // we have a double-click !

    SelFile = SendDlgItemMessage(m_hwnd, IDC_FILE_LIST,
                                 LVM_GETSELECTIONMARK,
                                 0, 0);
    if (SelFile >= 0)
    {
        GetSelectedItem();
        GetSelectionInformation(PROGLIST_EXENAME, FileName, sizeof(FileName));
        StringCchCopyW(m_wszRetFileName, MAX_PATH, FileName);
        

        if (lpnmh->iSubItem == 0 &&
            lpnmh->iItem == SelFile)
        {
            // A file is selected, we can end the dialog
            m_nCmdPopulate = CMD_EXIT;
            EndDialog(m_hwnd, IDOK);
            SetEvent(m_hEventCmd);
        }
    }
    bHandled = TRUE;
    return 0;
}



STDMETHODIMP CProgView::GetSelectedItem()
{

    GetProgramListSelection(m_pProgramList);
    return S_OK;
}

STDMETHODIMP CProgView::get_SelectionName(LPWSTR pBuffer, ULONG Size)
{
    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }


    GetProgramListSelectionDetails(m_pProgramList, 0, pBuffer, Size);

    return S_OK;
}


STDMETHODIMP CProgView::GetSelectionInformation(LONG lInformationClass, LPWSTR pBuffer, ULONG Size)
{
    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    GetProgramListSelectionDetails(m_pProgramList, lInformationClass, pBuffer, Size);
    return S_OK;
}

VOID
CProgView::ShowProgressWindows(BOOL bProgress)
{
    HDWP hDefer = ::BeginDeferWindowPos(4);
    DWORD dwProgressFlag = bProgress ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;
    DWORD dwListFlag     = bProgress ? SWP_HIDEWINDOW : SWP_SHOWWINDOW;

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(m_hwnd, IDC_ANIMATE), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwProgressFlag);

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(m_hwnd, IDC_SEARCH_STATUS), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwProgressFlag);

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(m_hwnd, IDC_SEARCH_STATUS2), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwProgressFlag);

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(m_hwnd, IDC_SEARCH_STATUS3), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwProgressFlag);

    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(m_hwnd, IDC_SEARCH_FINISHED), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwListFlag);
    hDefer = ::DeferWindowPos(hDefer, GetDlgItem(m_hwnd, IDC_FILE_LIST), NULL,
                            0, 0, 0, 0,
                            SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|dwListFlag);


    EndDeferWindowPos(hDefer);

}

STDMETHODIMP CProgView::PopulateList()
{
    HANDLE hThread;

    ResetEvent(m_hEventCancel);
    ResetEvent(m_hEventCmd);

//    if (!m_bInPlaceActive) {
//        InPlaceActivate(OLEIVERB_INPLACEACTIVATE);
//    }
    if (m_hThreadPopulate == NULL) {
        m_hThreadPopulate = CreateThread(NULL, 0, _PopulateThreadProc, (LPVOID)this, 0, NULL);
    }

    if (m_hThreadPopulate != NULL && !IsScanInProgress()) {
        m_nCmdPopulate = CMD_SCAN;
        SetEvent(m_hEventCmd);
    }

    return S_OK;
}

BOOL CProgView::PopulateListInternal()
{

    if (InterlockedCompareExchange(&m_PopulateInProgress, TRUE, FALSE) == TRUE) {
        //
        // populate in progress -- quit
        //
        return FALSE;
    }

    if (m_pProgramList != NULL) {
        CleanupProgramList(m_pProgramList);
        m_pProgramList = NULL;

    }

    ShowProgressWindows(TRUE);
    Animate_OpenEx(GetDlgItem(m_hwnd, IDC_ANIMATE), _Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_FINDANIM));
    Animate_Play(GetDlgItem(m_hwnd, IDC_ANIMATE), 0, -1, -1);

    PostMessage(m_hwnd, WM_VIEW_CHANGED, 0, 0);

    // FireViewChange();

//    if (m_bInPlaceActive) {
/*    HCURSOR hcWait = (HCURSOR)::LoadImage(NULL,
                                          MAKEINTRESOURCE(IDC_WAIT),
                                          IMAGE_CURSOR,
                                          0, 0,
                                          LR_DEFAULTSIZE|LR_SHARED);

//    HCURSOR hcWait = ::LoadCursor(_Module.GetResourceInstance(),
//                                 MAKEINTRESOURCE(IDC_WAIT));


    HCURSOR hcSave = SetCursor(hcWait);
*/

    //
    // malloc used on this thread should NOT be used on UI thread
    //

    InitializeProgramList(&m_pProgramList, GetDlgItem(m_hwnd, IDC_FILE_LIST));
    PopulateProgramList(m_pProgramList, this, m_hEventCancel);

//    SetCursor(hcSave);

    Animate_Stop(GetDlgItem(m_hwnd, IDC_ANIMATE));
    Animate_Close(GetDlgItem(m_hwnd, IDC_ANIMATE));
    ShowProgressWindows();

    InterlockedCompareExchange(&m_PopulateInProgress, FALSE, TRUE);

    PostMessage(m_hwnd, WM_VIEW_CHANGED, 0, 0);
    PostMessage(m_hwnd, WM_LIST_POPULATED, 0, 0); // we are done, signal to the main thread


//    FireViewChange();

//    } else {
//        m_bPendingPopulate = TRUE;
//    }


    return TRUE;
}

DWORD WINAPI
CProgView::_PopulateThreadProc(
    LPVOID lpvParam
    )
{
    CProgView* pProgView = (CProgView*)lpvParam;
    DWORD      dwWait;
    BOOL       bExit = FALSE;
    HRESULT hr = CoInitialize(NULL);
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    //
    // keep this thread alive, block it on a command event
    //
    while(!bExit) {
        dwWait = WaitForSingleObject(pProgView->m_hEventCmd, INFINITE);
        if (dwWait != WAIT_OBJECT_0) {
            break; // get out, we are being killed
        }
        //
        // get the command
        //
        switch(pProgView->m_nCmdPopulate) {
        case CMD_NONE:
            break;

        case CMD_EXIT:
            bExit = TRUE;
            //
            // intentional fall-through
            //

        case CMD_CLEANUP:
            if (pProgView->m_pProgramList) {
                CleanupProgramList(pProgView->m_pProgramList);
                pProgView->m_pProgramList = NULL;
            }
            break;

        case CMD_SCAN:
            pProgView->PopulateListInternal();
            break;
        }

        pProgView->m_nCmdPopulate = CMD_NONE;
    }
    CoUninitialize();
    return TRUE;
}

STDMETHODIMP
CProgView::UpdateListItem(
    BSTR pTarget,
    VARIANT *pKeys,
    BOOL *pResult
    )
{
    VARIANT vKeys;
    VariantInit(&vKeys);
    CComBSTR bstrKeys;
    HRESULT  hr;

    if (!m_pProgramList) {
        return S_OK;
    }

    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }


    if (pKeys->vt == VT_NULL || pKeys->vt == VT_EMPTY) {
        *pResult = UpdateProgramListItem(m_pProgramList, pTarget, NULL);
        return S_OK;
    }

    hr = VariantChangeType(&vKeys, pKeys, 0, VT_BSTR);
    if (SUCCEEDED(hr)) {
        bstrKeys = vKeys.bstrVal;

        if (bstrKeys.Length()) {
            *pResult = UpdateProgramListItem(m_pProgramList, pTarget, bstrKeys);
        } else {
            *pResult = FALSE;
        }
    }

    VariantClear(&vKeys);
    return S_OK;
}

STDMETHODIMP CProgView::CancelPopulateList()
{
    if (m_hEventCancel && InterlockedCompareExchange(&m_PopulateInProgress, TRUE, TRUE) == TRUE) {
        SetEvent(m_hEventCancel);
    }
    return S_OK;
}

STDMETHODIMP CProgView::get_ItemCount(VARIANT* pVal)
{
    if (!m_Safe) {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    pVal->vt = VT_I4;
    pVal->intVal = (int)ListView_GetItemCount(GetDlgItem(m_hwnd, IDC_FILE_LIST));

    return S_OK;
}


//
// expand env -- lives in util.cpp
// we have a bit differing implementation here
//

LPWSTR
ExpandEnvironmentVars(
    LPWSTR lpszCmd
    )
{
    DWORD   dwLength;
    LPTSTR  lpBuffer = NULL;
    BOOL    bExpanded = FALSE;
    LPWSTR  strCmd;
    TCHAR   szBuffer[MAX_PATH];

    if (_tcschr(lpszCmd, TEXT('%')) == NULL) {
        goto out;
    }

    dwLength = ExpandEnvironmentStrings(lpszCmd, NULL, 0);
    if (!dwLength) {
        goto out;
    }

    if (dwLength < CHARCOUNT(szBuffer)) {
        lpBuffer = szBuffer;
    } else {
        lpBuffer = new TCHAR[dwLength];
        if (NULL == lpBuffer) {
            goto out;
        }
    }

    dwLength = ExpandEnvironmentStrings(lpszCmd, lpBuffer, dwLength);
    if (!dwLength) {
        goto out;
    }

    strCmd = lpBuffer;
    bExpanded = TRUE;

 out:
    if (!bExpanded) {
        strCmd = lpszCmd;
    }
    if (lpBuffer && lpBuffer != szBuffer) {
        delete[] lpBuffer;
    }
    return strCmd;
}

#if 0
STDMETHODIMP CProgView::put_ExcludeFiles(BSTR newVal)
{
    // parse exclude files, put them into our blacklist
    wstring strFile;
    LPCWSTR pch = newVal;
    LPCWSTR pend;

    m_ExcludedFiles.clear();

    while (pch != NULL && *pch != TEXT('\0')) {

        pch += _tcsspn(pch, TEXT(" \t"));
        // begining
        // find the ;
        pend = _tcschr(pch, TEXT(';'));
        if (pend == NULL) {
            // from pch to the end
            strFile = pch;
            pch = NULL; // will bail out
        } else {
            strFile = wstring(pch, (wstring::size_type)(pend - pch));
            pch = pend + 1; // one past ;
        }

        // add
        if (strFile.length()) {
            strFile = ExpandEnvironmentVars(strFile.c_str());
            m_ExcludedFiles.insert(StrUpCase(strFile));
        }
    }

    return S_OK;
}

STDMETHODIMP CProgView::get_ExcludeFiles(BSTR* pVal)
{
    // parse exclude files, put them into our blacklist
    STRSET::iterator iter;
    CComBSTR bstrFiles;

    for (iter = m_ExcludedFiles.begin(); iter != m_ExcludedFiles.end(); ++iter) {
        if (bstrFiles.Length()) {
            bstrFiles += TEXT(';');
        }
        bstrFiles += (*iter).c_str();
    }

    *pVal = bstrFiles.Copy();

    return S_OK;
}

BOOL CProgView::IsFileExcluded(LPCTSTR pszFile)
{
    wstring strFile = pszFile;
    STRSET::iterator iter;

    iter = m_ExcludedFiles.find(StrUpCase(strFile));
    return iter != m_ExcludedFiles.end();
}
#endif // 0

LRESULT
CProgView::OnCommand(WPARAM wParam, LPARAM lParam)
{
    WORD wCode = HIWORD(wParam);
    WORD wId = LOWORD(wParam);
    LRESULT SelFile;
    WCHAR FileName[MAX_PATH];

    switch(wId)
    {

    case IDOK:
        SelFile = SendDlgItemMessage(m_hwnd, IDC_FILE_LIST,
                                     LVM_GETSELECTIONMARK,
                                     0, 0);
        if (SelFile >= 0)
        {
            GetSelectedItem();
            GetSelectionInformation(PROGLIST_EXENAME, FileName, sizeof(FileName));
            StringCchCopyW(m_wszRetFileName, MAX_PATH, FileName);
        }
        // Fall through
    case IDCANCEL:
        m_nCmdPopulate = CMD_EXIT;
        EndDialog(m_hwnd, wId);
        SetEvent(m_hEventCmd);
        return 0;

    default:
        return 1; // not handled

    }
    return 1; // not handled
}

LRESULT
CProgView::OnNotify(WPARAM wParam, LPARAM lParam)
{
    WORD wId = LOWORD(wParam);
    BOOL bVal;
    BOOL& bHandled = bVal;

    switch(wId)
    {
    default:
        break;
    case IDC_FILE_LIST:
        return OnNotifyListView((int) wParam, (LPNMHDR) lParam, bHandled);
        break;
    }
    return 1;
}

INT_PTR CALLBACK
Dialog_GetProgFromList(
    HWND hwnd,
    UINT Message,
    WPARAM wparam,
    LPARAM lparam
    )
{
    BOOL bHandled;
    CProgView* pProgWinData;

    pProgWinData = (CProgView *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (Message != WM_INITDIALOG && pProgWinData == NULL)
    {
        return FALSE;
    }
    switch (Message)
    {
    case WM_INITDIALOG:
//      Assert(pProgWinData == NULL);

        pProgWinData = new CProgView();
        if (!pProgWinData)
        {
            return -1;
        }
        pProgWinData->m_hwnd = hwnd;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pProgWinData);

        SetFocus(hwnd);
        pProgWinData->OnInitDialog(Message, wparam, lparam, &bHandled);
        break;

    case WM_COMMAND:
        if (pProgWinData->OnCommand(wparam, lparam) == 0)
        {
            return TRUE;
        }
        break;
    case WM_NOTIFY:
        if (pProgWinData->OnNotify(wparam, lparam) == 0)
        {
            return TRUE;
        }
        break;

    case WM_DESTROY:
        delete pProgWinData;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) NULL);
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\appreport.h ===
// AppReport.h : Declaration of the CAppReport

#ifndef __APPREPORT_H_
#define __APPREPORT_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <atlwin.h>
#include <strsafe.h>
#include <commdlg.h>
#include <shimdb.h>



/////////////////////////////////////////////////////////////////////////////
// CAppReport
class ATL_NO_VTABLE CAppReport :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IAppReport, &IID_IAppReport, &LIBID_APPCOMPRLib>,
    public CComControl<CAppReport>,
    public IPersistStreamInitImpl<CAppReport>,
    public IOleControlImpl<CAppReport>,
    public IOleObjectImpl<CAppReport>,
    public IOleInPlaceActiveObjectImpl<CAppReport>,
    public IViewObjectExImpl<CAppReport>,
    public IOleInPlaceObjectWindowlessImpl<CAppReport>,
    public IPersistStorageImpl<CAppReport>,
    public ISpecifyPropertyPagesImpl<CAppReport>,
    public IQuickActivateImpl<CAppReport>,
    public IDataObjectImpl<CAppReport>,
    public IProvideClassInfo2Impl<&CLSID_AppReport, NULL, &LIBID_APPCOMPRLib>,
    public CComCoClass<CAppReport, &CLSID_AppReport>,
    public IObjectSafetyImpl<CAppReport, INTERFACESAFE_FOR_UNTRUSTED_CALLER
                                      |INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
    CAppReport()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_APPREPORT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAppReport)
    COM_INTERFACE_ENTRY(IAppReport)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

BEGIN_PROP_MAP(CAppReport)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CAppReport)
    CHAIN_MSG_MAP(CComControl<CAppReport>)
    DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IAppReport
public:
    STDMETHOD(CreateReport)(/*[in]*/ BSTR bstrTitle, /*[in]*/ BSTR bstrProblemType, /*[in]*/ BSTR bstrComment, /*[in]*/ BSTR bstrACWResult, /*[in]*/ BSTR bstrAppName, /*[out, retval]*/ VARIANT* DwResult);
    STDMETHOD(GetApplicationFromList)(/*[in]*/ BSTR bstrTitle, /*[out, retval]*/ VARIANT *bstrExeName);
    STDMETHOD(BrowseForExecutable)(/*[IN]*/ BSTR bstrWinTitle, /*[IN]*/ BSTR bstrPreviousPath, /*[OUT]*/ VARIANT *bstrExeName);

    HRESULT OnDraw(ATL_DRAWINFO& di)
    {
        RECT& rc = *(RECT*)di.prcBounds;
        Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

        SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
        LPCTSTR pszText = _T("ATL 3.0 : AppReport");
        TextOut(di.hdcDraw,
            (rc.left + rc.right) / 2,
            (rc.top + rc.bottom) / 2,
            pszText,
            lstrlen(pszText));

        return S_OK;
    }
private:
    HRESULT GetWindowHandle(LPWSTR wszWinTitle, HWND* phwnd);
};

#endif //__APPREPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by appcompr.rc
//
#define IDS_PROJNAME                    100
#define IDB_APPREPORT                   101
#define IDR_APPREPORT                   102
#define IDS_DESKTOP                     104
#define IDS_COMMON_STARTMENU            105
#define IDS_STARTMENU                   106
#define IDS_COMMON_PROGRAMS             107
#define IDS_PROGRAMS                    108
#define IDS_PROGRAMNAME                 109
#define IDS_FOLDER                      110
#define IDS_SETTINGS                    111
#define IDD_PROGRAM_LIST_DIALOG         112
#define IDS_SENDINGINFO                 113
#define IDS_CLEANINGUP                  114
#define IDS_SENDINGCAPTION              115
#define IDC_SHOW_SEARCH                 201
#define IDC_FILE_LIST                   202
#define IDC_REFRESH                     203
#define IDC_SEARCH_STATUS               206
#define IDC_ANIMATE                     207
#define IDC_SEARCH_STATUS2              209
#define IDA_FINDANIM                    210
#define IDB_SORTDN                      211
#define IDB_SORTUP                      212
#define IDC_SEARCH_FINISHED             213
#define IDC_SEARCH_STATUS3              214

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         208
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\progview.h ===
// ProgView.h : Declaration of the CProgView

#ifndef __PROGVIEW_H_
#define __PROGVIEW_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <shlobj.h>

/////////////////// SHIMDB

extern "C" {
    #include "shimdb.h"
}

/////////////////// STL

class CProgramList;
class CProgView;

//
// Program list stuff
//

BOOL
GetProgramListSelection(
    CProgramList* pProgramList
    );


BOOL
InitializeProgramList(
    CProgramList** ppProgramList,
    HWND hwndListView
    );

BOOL
CleanupProgramList(
    CProgramList* pProgramList
    );

BOOL
PopulateProgramList(
    CProgramList* pProgramList,
    CProgView*    pProgView,
    HANDLE        hEventCancel
    );

BOOL
GetProgramListSelectionDetails(
    CProgramList* pProgramList,
    INT iInformationClass,
    LPWSTR pBuffer,
    ULONG Size
    );

LRESULT
NotifyProgramList(
    CProgramList* pProgramList,
    LPNMHDR       pnmhdr,
    BOOL&         bHandled
    );

BOOL
GetProgramListEnabled(
    CProgramList* pProgramList
    );

VOID
EnableProgramList(
    CProgramList* pProgramList,
    BOOL bEnable
    );

BOOL
UpdateProgramListItem(
    CProgramList* pProgramList,
    LPCWSTR pwszPath,
    LPCWSTR pwszKeys
    );

INT_PTR CALLBACK
Dialog_GetProgFromList(
    HWND hwnd,
    UINT Message,
    WPARAM wparam,
    LPARAM lparam
    );


#define WM_VIEW_CHANGED   (WM_USER+500)
#define WM_LIST_POPULATED (WM_USER+501)

//
// wait for the thread to cleanup
//

#define POPULATE_THREAD_TIMEOUT 1000

/////////////////////////////////////////////////////////////////////////////
// CProgView
class CProgView
{
public:
    typedef enum {
        CMD_EXIT,
        CMD_CLEANUP,
        CMD_SCAN,
        CMD_NONE
    } PopulateCmdType;


    CProgView() : m_Safe(TRUE)
    {
        m_pProgramList = NULL;
        m_bPendingPopulate = FALSE;
//        m_bRecomposeOnResize = TRUE;
        m_PopulateInProgress = FALSE;
        m_nCmdPopulate = CMD_NONE;

        m_hEventCancel = CreateEvent(NULL, TRUE, FALSE, NULL);
        //
        // handle error -- we are big time in trouble if this fails
        //
        m_hEventCmd    = CreateEvent(NULL, FALSE, FALSE, NULL);
        //
        // same
        //

        m_hThreadPopulate = NULL;

        m_pMallocUI = NULL;

        //
        // create accelerator
        //

        ACCEL rgAccel[] = { { FVIRTKEY, VK_F5, IDC_REFRESH } };
        m_hAccel = CreateAcceleratorTable(rgAccel, ARRAYSIZE(rgAccel));

    }

    ~CProgView() {
        if (m_hAccel) {
            DestroyAcceleratorTable(m_hAccel);
        }
        if (m_hEventCancel) {
            SetEvent(m_hEventCancel);
            CloseHandle(m_hEventCancel);
        }
        if (m_hEventCmd) {
            m_nCmdPopulate = CMD_EXIT;
            SetEvent(m_hEventCmd);
            CloseHandle(m_hEventCmd);
        }
        if (m_hThreadPopulate) {
            WaitForSingleObject(m_hThreadPopulate, POPULATE_THREAD_TIMEOUT);
            CloseHandle(m_hThreadPopulate);
        }
        if (m_pMallocUI) {
            m_pMallocUI->Release();
        }
    }

#if 0
BEGIN_MSG_MAP(CProgView)
    NOTIFY_ID_HANDLER(IDC_FILE_LIST,  OnNotifyListView)
    NOTIFY_HANDLER(IDC_FILE_LIST, NM_DBLCLK, OnDblclkListprograms)
    MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_VIEW_CHANGED, OnViewChanged)
    MESSAGE_HANDLER(WM_LIST_POPULATED, OnListPopulated)
    MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)

    //    COMMAND_ID_HANDLER(IDC_REFRESH, OnRefreshListCmd)

    CHAIN_MSG_MAP(CComCompositeControl<CProgView>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

BEGIN_SINK_MAP(CProgView)
    //Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

BEGIN_CONNECTION_POINT_MAP(CProgView)
CONNECTION_POINT_ENTRY(DIID__IProgViewEvents)
CONNECTION_POINT_ENTRY(DIID__ISelectFileEvents)
END_CONNECTION_POINT_MAP()

    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
    {
        if (dispid == DISPID_AMBIENT_BACKCOLOR)
        {
            SetBackgroundColorFromAmbient();
            FireViewChange();
        }

        return IOleControlImpl<CProgView>::OnAmbientPropertyChange(dispid);
    }

    HRESULT FireOnChanged(DISPID dispID) {
        if (dispID == DISPID_ENABLED) {
            HWND hwndList = GetDlgItem(IDC_FILE_LIST);
            if (::IsWindow(hwndList)) {
                ::EnableWindow(hwndList, m_bEnabled);
            }
        }
        return S_OK;
    }

    STDMETHOD(GetControlInfo)(CONTROLINFO* pCI) {
        if (NULL == pCI) {
            return E_POINTER;
        }
        pCI->cb      = sizeof(*pCI);
        pCI->hAccel  = m_hAccel;
        pCI->cAccel  = 1;
        pCI->dwFlags = 0;
        return S_OK;
    }

    STDMETHOD(OnMnemonic)(LPMSG pMsg) {
        if (pMsg->message == WM_COMMAND || pMsg->message == WM_SYSCOMMAND) {
            if (LOWORD(pMsg->wParam) == IDC_REFRESH) {
                PopulateList();
            }
        }
        return S_OK;
    }

    HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);
#endif // 0

    LRESULT OnNotifyListView(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDblclkListprograms(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnMouseActivate(UINT, WPARAM, LPARAM, BOOL&) {
        // Manually activate the control
//        InPlaceActivate(OLEIVERB_UIACTIVATE);
        return 0;
    }

#if 0

    STDMETHOD(InPlaceDeactivate)(VOID) {
        HRESULT hr = IOleInPlaceObjectWindowlessImpl<CProgView>::InPlaceDeactivate();
        //
        // make sure we cancel first if we are scanning
        //
        return hr;
    }

    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL* psizel) {


        if (IsWindow()) {
            HWND hlvPrograms = GetDlgItem(IDC_FILE_LIST);
            SIZEL sizePix;
            AtlHiMetricToPixel(psizel, &sizePix);
            ::SetWindowPos(hlvPrograms, NULL, 0, 0,
                           sizePix.cx, sizePix.cy,
                           SWP_NOZORDER|SWP_NOACTIVATE);
            /*
            ::SetWindowPos(hlvPrograms, NULL, 0, 0,
                           m_rcPos.right - m_rcPos.left,
                           m_rcPos.bottom - m_rcPos.top,
                           SWP_NOZORDER|SWP_NOACTIVATE);
            */

        }
        HRESULT hr = IOleObjectImpl<CProgView>::SetExtent(dwDrawAspect, psizel);

        return hr;
    }

#endif

    LRESULT OnGetDlgCode(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        // TODO : Add Code for message handler. Call DefWindowProc if necessary.
        if (lParam) {
            LPMSG pMsg = (LPMSG)lParam;
            if (pMsg->message == WM_SYSKEYDOWN || pMsg->message == WM_SYSCHAR) { // eat accel ?
                bHandled = TRUE;
                return DLGC_WANTMESSAGE;
            }
        }

        bHandled = TRUE;
        return DLGC_WANTTAB|DLGC_WANTARROWS|DLGC_WANTALLKEYS;
    }

#if 0
    STDMETHOD(SetObjectRects)(LPCRECT prcPos, LPCRECT prcClip) {
        HWND hlvPrograms = GetDlgItem(m_hwnd, IDC_FILE_LIST);
        IOleInPlaceObjectWindowlessImpl<CProgView>::SetObjectRects(prcPos, prcClip);
        ::SetWindowPos(hlvPrograms, NULL, 0, 0,
                       prcPos->right - prcPos->left,
                       prcPos->bottom - prcPos->top,
                       SWP_NOZORDER|SWP_NOACTIVATE);

        HWND hwnd;
        RECT rc;

        hwnd = GetDlgItem(IDC_SEARCH_STATUS);
        ::GetWindowRect(hwnd, &rc);

        //
        // we are happy with location, just set the width
        //
        ScreenToClient(m_hwnd, (LPPOINT)&rc);
        ScreenToClient(m_hwnd, ((LPPOINT)&rc) + 1);

        ::SetWindowPos(hwnd, NULL,
                       rc.left, rc.top,
                       prcPos->right - prcPos->left - rc.left,
                       rc.bottom - rc.top,
                       SWP_NOZORDER|SWP_NOACTIVATE);

        hwnd = GetDlgItem(m_hwnd, IDC_SEARCH_STATUS2);
        ::GetWindowRect(hwnd, &rc);

        //
        // we are happy with location, just set the width
        //
        ScreenToClient(m_hwnd, (LPPOINT)&rc);
        ScreenToClient(m_hwnd, ((LPPOINT)&rc) + 1);

        ::SetWindowPos(hwnd, NULL,
                       rc.left, rc.top,
                       prcPos->right - prcPos->left - rc.left,
                       rc.bottom - rc.top,
                       SWP_NOZORDER|SWP_NOACTIVATE);

        return S_OK;

    }
#endif //0

    BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hrRet);

#if 0

    static CWndClassInfo& GetWndClassInfo() {
        DebugBreak();
        static CWndClassInfo wc = CWindowImpl<CProgView>::GetWndClassInfo();
        wc.m_wc.style &= ~(CS_HREDRAW|CS_VREDRAW);
        return wc;
    }


    BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hrRet) {

        HWND hwndList  = GetDlgItem(IDC_FILE_LIST);
        HWND hwndFocus = GetFocus();

        if (hwndList != hwndFocus || !::IsWindowEnabled(hwndList)) {
            goto PropagateAccel;
        }

        if (pMsg->message == WM_KEYDOWN) {

            if (pMsg->wParam == VK_LEFT ||
                pMsg->wParam == VK_RIGHT ||
                pMsg->wParam == VK_UP ||
                pMsg->wParam == VK_DOWN) {

                SendDlgItemMessage(IDC_FILE_LIST, pMsg->message, pMsg->wParam, pMsg->lParam);
                hrRet = S_OK;
                return TRUE;
            }

            if (LOWORD(pMsg->wParam) == VK_RETURN || LOWORD(pMsg->wParam) == VK_EXECUTE) {

                if (ListView_GetNextItem(hwndList, -1, LVNI_SELECTED) >= 0) {
                    Fire_DblClk(0);
                    hrRet = S_OK;
                    return TRUE;
                }
            }

            if (LOWORD(pMsg->wParam) == VK_TAB) {
                goto PropagateAccel;
            }
        }

        if (IsDialogMessage(pMsg)) {
            hrRet = S_OK;
            return TRUE;
        }

        if (::TranslateAccelerator(m_hwnd, NULL, pMsg)) {
            hrRet = S_OK;
            return TRUE;
        }

        PropagateAccel:
        return FALSE;
    }
#endif





// IProgView
public:
#if 0
    STDMETHOD(get_ExcludeFiles)(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(put_ExcludeFiles)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ExternAccel)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ExternAccel)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_Accel)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Accel)(/*[in]*/ BSTR newVal);
#endif
    STDMETHOD(CancelPopulateList)();
    STDMETHOD(UpdateListItem)(/*[in]*/BSTR pTarget, /*[in]*/VARIANT* pKeys, /*[out, retval]*/ BOOL* pResult);
    STDMETHOD(PopulateList)();
    STDMETHOD(GetSelectionInformation)(LONG, LPWSTR pBuffer, ULONG Size);
    STDMETHOD(get_SelectionName)(LPWSTR pBuffer, ULONG Size);
    STDMETHOD(GetSelectedItem)();

#if 0
    STDMETHOD(ClearAccel)();
    STDMETHOD(ClearExternAccel)();
    STDMETHOD(get_AccelCmd)(/*[in]*/ LONG lCmd, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_AccelCmd)(/*[in]*/ LONG lCmd, /*[in]*/ BSTR newVal);
#endif
    STDMETHOD(get_ItemCount)(/*[out, retval]*/VARIANT* pItemCount);

    BOOL m_bEnabled;

    // Security - To be implemented
    BOOL m_Safe;     // set to true if we were able to verify the host

    BOOL m_bPendingPopulate;
    CProgramList* m_pProgramList;


    enum { IDD = IDD_PROGRAM_LIST_DIALOG };

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL* bHandled) {
/*
        DWORD dwStyle = (DWORD)GetClassLong(m_hWnd, GCL_STYLE);
        dwStyle &= ~(CS_HREDRAW | CS_VREDRAW);
        SetClassLong(m_hWnd, GCL_STYLE, dwStyle);
*/

        //
        // before we start messing around with this... obtain malloc for the UI thread
        //
        HRESULT hr = SHGetMalloc(&m_pMallocUI);
        if (!SUCCEEDED(hr)) {
            //
            // aww -- ui malloc will not be available -- we're pretty much hosed
            //
            m_pMallocUI = NULL;
        }

        m_wszRetFileName = (LPWSTR) lParam;
        PopulateList();

        return 0;

    }

    static DWORD WINAPI _PopulateThreadProc(LPVOID lpvParam);

    VOID UpdatePopulateStatus(LPCTSTR lpszName, LPCTSTR lpszPath) {
        SetDlgItemText(m_hwnd, IDC_SEARCH_STATUS2, lpszName);
        ::PathSetDlgItemPath(m_hwnd, IDC_SEARCH_STATUS3, lpszPath);
    }

    VOID ShowProgressWindows(BOOL bProgress = FALSE);

    LRESULT OnViewChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
//        FireViewChange();
        bHandled = TRUE;
        return 0;
    }

    LRESULT OnListPopulated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) {
//        Fire_ProgramListReady();
        bHandled = TRUE;
        return 0;
    }

    BOOL PopulateListInternal();

    HANDLE m_hEventCancel;
    LONG   m_PopulateInProgress;
    HANDLE m_hEventCmd;
    PopulateCmdType m_nCmdPopulate;
    HANDLE m_hThreadPopulate;

    IMalloc* m_pMallocUI;

    HACCEL m_hAccel;

    HWND   m_hwnd;
    LPWSTR m_wszRetFileName;
    BOOL IsScanInProgress(VOID) {
        return InterlockedCompareExchange(&m_PopulateInProgress, TRUE, TRUE) == TRUE;
    }

    /*
    LRESULT OnRefreshListCmd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled) {
        PopulateList();
        bHandled = TRUE;
        return 0;
    }
    */

    //
    // accelerators
    //
//    CAccelContainer m_Accel;       // my own accelerator
//    CAccelContainer m_ExternAccel; // external accels


    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
//        InPlaceActivate(OLEIVERB_UIACTIVATE);
        //
        // if we are scanning then we don't need to do anything, else - set the focus to listview
        //
        if (!IsScanInProgress()) {
            ::SetFocus(GetDlgItem(m_hwnd, IDC_FILE_LIST));
        }

        return 0;
//        return CComCompositeControl<CProgView>::OnSetFocus(uMsg, wParam, lParam, bHandled);
    }

    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);

    //
    // blacklisted files
    //
#if 0
    typedef set<wstring> STRSET;

    STRSET m_ExcludedFiles;

    //
    // check whether a file is excluded
    //
    BOOL IsFileExcluded(LPCTSTR pszFile);
#endif
};


typedef enum tagPROGRAMINFOCLASS {
    PROGLIST_DISPLAYNAME,
    PROGLIST_LOCATION,     //
    PROGLIST_EXENAME,      // cracked exe name
    PROGLIST_CMDLINE,      // complete exe name + parameters
    PROGLIST_EXECUTABLE,   // what we should execute (link or exe, not cracked)
    PROGLIST_ARGUMENTS     // just the args
};



#endif //__PROGVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A4CBABB7_3724_4067_A894_F4F66AE7577B__INCLUDED_)
#define AFX_STDAFX_H__A4CBABB7_3724_4067_A894_F4F66AE7577B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A4CBABB7_3724_4067_A894_F4F66AE7577B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\proglist.cpp ===
/*++

      Implements population of a listview control with the content from
      the start menu


--*/


#include "stdafx.h"
#include "resource.h"

#include <stdio.h>
#include <stdlib.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <commctrl.h>
#include <msi.h>
#include <sfc.h>
#include "progview.h"
extern "C" {
    #include <shimdb.h>
}

#pragma warning(disable:4786)
#include <string>
#include <xstring>
#include <map>
#include <algorithm>

using namespace std;

#ifdef _UNICODE
typedef wstring tstring;
#else
typedef string tstring;
#endif

    typedef
    INSTALLSTATE (WINAPI*PMsiGetComponentPath)(
      LPCTSTR szProduct,   // product code for client product
      LPCTSTR szComponent, // component ID
      LPTSTR lpPathBuf,    // returned path
      DWORD *pcchBuf       // buffer character count
    );

    typedef
    UINT (WINAPI* PMsiGetShortcutTarget)(
      LPCTSTR szShortcutTarget,     // path to shortcut link file
      LPTSTR szProductCode,        // fixed length buffer for product code
      LPTSTR szFeatureId,          // fixed length buffer for feature id
      LPTSTR szComponentCode       // fixed length buffer for component code
    );




class CException {
public:
    CException(LPCSTR lpszFile = NULL, DWORD nLocation = 0) {
        SetLocation(lpszFile, nLocation);
    }
    virtual ~CException() {}

    virtual VOID Delete() {
        delete this;
    }

    int __cdecl FormatV(LPCTSTR lpszFormat, va_list arg) {
        int nch = 0;

        if (lpszFormat) {
            nch = _vsntprintf(szDescription, CHARCOUNT(szDescription), lpszFormat, arg);
        } else {
            *szDescription = TEXT('\0');
        }
        return nch;
    }

    int __cdecl Format(LPCTSTR lpszFormat, ...) {
        va_list arg;
        int nch = 0;

        if (lpszFormat) {
            va_start(arg, lpszFormat);
            nch = _vsntprintf(szDescription, CHARCOUNT(szDescription), lpszFormat, arg);
            va_end(arg);
        } else {
            *szDescription = TEXT('\0');
        }
    }

    VOID SetLocation(LPCSTR lpszFile, DWORD nLocation) {
        if (lpszFile) {
            strcpy(szLocation, lpszFile);
        } else {
            *szLocation = TEXT('\0');
        }
        m_dwLocation = nLocation;
    }

    TCHAR   szDescription[MAX_PATH];
    CHAR    szLocation[MAX_PATH];
    DWORD   m_dwLocation;
};

class CMemoryException : public CException {
public:
    CMemoryException(LPCSTR lpszFile = NULL, DWORD nLocation = 0) :
      CException(lpszFile, nLocation) {}
    VOID Delete() {}
};

class CCancelException : public CException {
public:
    CCancelException(LPCSTR lpszFile = NULL, DWORD nLocation = 0) :
      CException(lpszFile, nLocation){}
};

static CMemoryException _MemoryExceptionStatic;

VOID __cdecl ThrowMemoryException(LPCSTR lpszFile, DWORD nLocation, LPCTSTR lpszFormat = NULL, ...) {
    va_list arg;
    CMemoryException* pMemoryException = &_MemoryExceptionStatic;

    va_start(arg, lpszFormat);
    pMemoryException->FormatV(lpszFormat, arg);
    va_end(arg);

    throw pMemoryException;
}

class CProgramList {
public:
    CProgramList(LPMALLOC pMalloc, HWND hwndListView, LPCTSTR szSystemDirectory) :
      m_pMalloc(pMalloc),
      m_hwndListView(hwndListView),
      m_hMSI(NULL),
      m_pSelectionInfo(NULL),
      m_hbmSort(NULL),
      m_pProgView(NULL),
      m_hEventCancel(NULL) {
        //
        // we are always initializing on populate thread
        //
        m_dwOwnerThreadID    = GetCurrentThreadId();
        m_strSystemDirectory = szSystemDirectory;
      }

      ~CProgramList();

    BOOL PopulateControl(CProgView* pProgView = NULL, HANDLE hEventCancel = NULL);

    LPMALLOC GetMalloc(VOID) {
        return GetCurrentThreadId() == m_dwOwnerThreadID ? m_pMalloc : m_pMallocUI;
    }

    BOOL CaptureSelection();

    BOOL GetSelectionDetails(INT iInformationClass, LPWSTR pBuffer, ULONG BufferSize);

    LRESULT LVNotifyDispInfo   (LPNMHDR pnmhdr, BOOL& bHandled);
    LRESULT LVNotifyColumnClick(LPNMHDR pnmhdr, BOOL& bHandled);
    LRESULT LVNotifyGetInfoTip (LPNMHDR pnmhdr, BOOL& bHandled);
    LRESULT LVNotifyRClick     (LPNMHDR pnmhdr, BOOL& bHandled);
    BOOL IsEnabled(VOID);

    VOID Enable(BOOL);

    BOOL UpdateListItem(LPCWSTR pwszPath, LPCWSTR pwszKey);

protected:
    BOOL ListFolder(LPCTSTR pszLocationParent, IShellFolder* pFolder, LPCITEMIDLIST pidlFull, LPCITEMIDLIST pidlFolder);
    BOOL ListLink(LPCTSTR pszLocationParent, LPCTSTR pszDisplayName, IShellFolder* pFolder, LPCITEMIDLIST pidlFull, LPCITEMIDLIST pidlLink);
    BOOL ListMsiLink(LPCTSTR pszLocationParent, LPCTSTR pszDisplayName, LPCTSTR pszMsiPath, IShellFolder* pFolder, LPCITEMIDLIST pidlFull);

    LPITEMIDLIST GetNextItemIDL(LPCITEMIDLIST pidl);
       UINT         GetSizeIDL    (LPCITEMIDLIST pidl);
      LPITEMIDLIST AppendIDL     (LPCITEMIDLIST pidlBase,
                                LPCITEMIDLIST pidlAdd);
    LPITEMIDLIST GetLastItemIDL(LPCITEMIDLIST pidl);

    BOOL GetDisplayName(IShellFolder* pFolder, LPCITEMIDLIST pidl, tstring& strDisplay);
    BOOL GetPathFromLink(IShellLink* pLink, WIN32_FIND_DATA* pfd, tstring& strPath);
    BOOL GetArgumentsFromLink(IShellLink* pLink, tstring& strArgs);

    BOOL AddItem(LPCTSTR pszLocation,
                 LPCTSTR pszDisplayName,
                 LPCTSTR pszPath,
                 LPCTSTR pszArguments,
                 IShellFolder* pFolder,
                 LPCITEMIDLIST pidlFull,
                 BOOL    bUsePath = FALSE); // true if we should use path for executable


    int GetIconFromLink(LPCITEMIDLIST pidlLinkFull, LPCTSTR lpszExePath);

    BOOL IsSFCItem(LPCTSTR lpszItem);
    BOOL IsItemInSystemDirectory(LPCTSTR pszPath);

private:
    LPMALLOC m_pMalloc;
    LPMALLOC m_pMallocUI;
    HWND     m_hwndListView; // list view control
    HBITMAP  m_hbmSort;
    typedef struct tagSHITEMINFO {

        tstring strDisplayName;     // descriptive name
        tstring strFolder;          // containing folder
        tstring strPath;            // actual exe, cracked
        tstring strPathExecute;     // link path (this is what we will execute)
        tstring strCmdLine;         // command line (cracked link)
        tstring strArgs;
        tstring strKeys;
        LPITEMIDLIST pidl;          // full pidl
    } SHITEMINFO, *PSHITEMINFO;
    static CALLBACK SHItemInfoCompareFunc(LPARAM lp1, LPARAM lp2, LPARAM lParamSort);

    typedef map< tstring, PSHITEMINFO, less<tstring> > MAPSTR2ITEM;
    typedef multimap< tstring, PSHITEMINFO > MULTIMAPSTR2ITEM;

    //
    // store key->item sequence, the keys are cmdlines (with args)
    //
    MAPSTR2ITEM m_mapItems;

    //
    // store key->item sequence, where the key is exe name (path)
    //
    MULTIMAPSTR2ITEM m_mmapExeItems;

    //
    // selected item
    //

    PSHITEMINFO m_pSelectionInfo;

    //
    // cached msi.dll handle
    //
    HMODULE     m_hMSI;


    PMsiGetComponentPath  m_pfnGetComponentPath;
    PMsiGetShortcutTarget m_pfnGetShortcutTarget;

    //
    // cached system directory
    //

    tstring m_strSystemDirectory;

    //
    // image list used to show icons
    //

    HIMAGELIST  m_hImageList;

    //
    // optional pointer to the parent view
    //
    CProgView* m_pProgView;


    //
    // event that we use to signal the end of scan
    //
    HANDLE m_hEventCancel;


    //
    // owner thread
    //
    DWORD m_dwOwnerThreadID;

    VOID CheckForCancel() {
        if (m_hEventCancel) {
            if (::WaitForSingleObject(m_hEventCancel, 0) != WAIT_TIMEOUT) {
                // cancelled!!!
                throw new CCancelException();
            }
        }
    }

};

//
// in upload.cpp
//

wstring StrUpCase(wstring& wstr);

//
// load the string from resources
//
wstring LoadResourceString(UINT nID)
{
    LPTSTR lpszBuffer = NULL;
    int cch;
    wstring str;

    cch = ::LoadString(_Module.GetModuleInstance(), nID, (LPTSTR)&lpszBuffer, 0);
    //
    // hack! this must work (I know it does)
    //
    if (cch && NULL != lpszBuffer) {
        str = wstring(lpszBuffer, cch);
    }

    return str;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//


BOOL
InitializeProgramList(
    CProgramList** ppProgramList,
    HWND hwndListView
    )
{
    HRESULT hr;
    BOOL bSuccess = FALSE;
    LPMALLOC pMalloc = NULL;
    TCHAR szSystemWindowsDirectory[MAX_PATH];
    CProgramList* pProgramList = NULL;
    UINT uSize;

    hr = SHGetMalloc(&pMalloc);
    if (!SUCCEEDED(hr)) {
        goto ErrHandle;
    }


    uSize = ::GetSystemWindowsDirectory(szSystemWindowsDirectory,
                                        CHARCOUNT(szSystemWindowsDirectory));
    if (uSize == 0 || uSize > CHARCOUNT(szSystemWindowsDirectory)) {
        goto ErrHandle;
    }

    pProgramList = new CProgramList(pMalloc, hwndListView, szSystemWindowsDirectory);
    if (NULL == pProgramList) {
        goto ErrHandle;
    }


    *ppProgramList = pProgramList;
    bSuccess = TRUE;

ErrHandle:

    if (!bSuccess) {

        if (NULL != pMalloc) {
            pMalloc->Release();
        }

        if (NULL != pProgramList) {
            delete pProgramList;
        }

    }

    return bSuccess;
}


BOOL
CleanupProgramList(
    CProgramList* pProgramList
    )
{
    LPMALLOC pMalloc;

    if (NULL == pProgramList) {
        return FALSE;
    }

    pMalloc = pProgramList->GetMalloc();

    delete pProgramList;

    if (NULL != pMalloc) {
        pMalloc->Release();
    }


    return TRUE;
}

BOOL
PopulateProgramList(
    CProgramList* pProgramList,
    CProgView*    pProgView,
    HANDLE        hEventCancel
    )
{
    return pProgramList->PopulateControl(pProgView, hEventCancel);
}


CProgramList::~CProgramList()
{
    //
    //
    //
    MAPSTR2ITEM::iterator iter;

    iter = m_mapItems.begin();
    while (iter != m_mapItems.end()) {
        PSHITEMINFO pInfo = (*iter).second;

        GetMalloc()->Free(pInfo->pidl); // nuke this please
        delete pInfo;

        ++iter;
    }

    if (NULL != m_hbmSort) {
        DeleteObject(m_hbmSort);
    }


//  Image list is destroyed automatically when the control is destroyed
//
//    if (NULL != m_hImageList) {
//        ImageList_Destroy(m_hImageList);
//    }

    if (NULL != m_hMSI && (HMODULE)-1 != m_hMSI) {
        FreeLibrary(m_hMSI);
    }
}

BOOL
CProgramList::GetDisplayName(
    IShellFolder* pFolder,
    LPCITEMIDLIST pidl,
    tstring&      strDisplayName
    )
{
    STRRET strName;
    HRESULT hr;
    LPTSTR pszName = NULL;


    hr = pFolder->GetDisplayNameOf(pidl, SHGDN_NORMAL, &strName);
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    hr = StrRetToStr(&strName, pidl, &pszName);
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    // if we have been successful, assign return result
    if (pszName != NULL) {
        strDisplayName = pszName;
        CoTaskMemFree(pszName);
    } else {
        strDisplayName.erase();
    }
    return TRUE;
}

BOOL
CProgramList::GetPathFromLink(
    IShellLink* pLink,
    WIN32_FIND_DATA* pfd,
    tstring& strPath
    )
{
    TCHAR  szPath[MAX_PATH];
    HRESULT hr;

    hr = pLink->GetPath(szPath, sizeof(szPath)/sizeof(szPath[0]), pfd, 0);
    if (hr == S_OK) {
        strPath = szPath;
    }

    return hr == S_OK;
}

BOOL
CProgramList::GetArgumentsFromLink(
    IShellLink* pLink,
    tstring& strArgs
    )
{
    TCHAR szArgs[INFOTIPSIZE];

    HRESULT hr = pLink->GetArguments(szArgs, sizeof(szArgs)/sizeof(szArgs[0]));
    if (SUCCEEDED(hr)) {
        strArgs = szArgs;
    }

    return SUCCEEDED(hr);

}



LPITEMIDLIST
CProgramList::GetNextItemIDL(
    LPCITEMIDLIST pidl
    )
{
   // Check for valid pidl.
    if (pidl == NULL) {
        return NULL;
    }

    // Get the size of the specified item identifier.
    int cb = pidl->mkid.cb;

    // If the size is zero, it is the end of the list.
    if (cb == 0) {
        return NULL;
    }

    // Add cb to pidl (casting to increment by bytes).
    pidl = (LPITEMIDLIST) (((LPBYTE) pidl) + cb);

    // Return NULL if it is null-terminating, or a pidl otherwise.
    return (pidl->mkid.cb == 0) ? NULL : (LPITEMIDLIST) pidl;
}

LPITEMIDLIST
CProgramList::GetLastItemIDL(
    LPCITEMIDLIST pidl
    )
{
    LPITEMIDLIST pidlLast = (LPITEMIDLIST)pidl;

    if (pidl == NULL) {
        return NULL;
    }

    int cb = pidl->mkid.cb;
    if (cb == 0) {
        return NULL;
    }

    do {
        pidl = GetNextItemIDL(pidlLast);
        if (pidl != NULL) {
            pidlLast = (LPITEMIDLIST)pidl;
        }
    } while (pidl != NULL);

    return pidlLast;
}


UINT
CProgramList::GetSizeIDL(
    LPCITEMIDLIST pidl
    )
{
    UINT cbTotal = 0;
    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);    // Null terminator
        while (NULL != pidl)
        {
            cbTotal += pidl->mkid.cb;
            pidl = GetNextItemIDL(pidl);
        }
    }
    return cbTotal;
}

LPITEMIDLIST
CProgramList::AppendIDL(
    LPCITEMIDLIST pidlBase,
    LPCITEMIDLIST pidlAdd
    )
{
    if (NULL == pidlBase && NULL == pidlAdd) {
        return NULL;
    }

    LPITEMIDLIST pidlNew, pidlAlloc;

    UINT cb1 = pidlBase ? GetSizeIDL(pidlBase)  : 0;
    UINT cb2 = pidlAdd  ? GetSizeIDL(pidlAdd) : 0;

    UINT size = cb1 + cb2;
    pidlAlloc =
    pidlNew = (LPITEMIDLIST)GetMalloc()->Alloc(size);
    if (pidlNew)
    {
        if (NULL != pidlBase) {
            cb1 = pidlAdd ? cb1 - sizeof(pidlBase->mkid.cb) : cb1;
            RtlMoveMemory(pidlNew, pidlBase, cb1);
            pidlNew = (LPITEMIDLIST)((PBYTE)pidlNew + cb1);
        }

        if (NULL != pidlAdd) {
            RtlMoveMemory(pidlNew, pidlAdd, cb2);
        }
    }

    return pidlAlloc;
}


BOOL
CProgramList::ListMsiLink(
    LPCTSTR pszLocationParent,
    LPCTSTR pszDisplayName,
    LPCTSTR pszMsiPath,
    IShellFolder* pFolder,
    LPCITEMIDLIST pidlFull
    )
{
    //
    // make sure we have msi module handle
    //

    if (NULL == m_hMSI) {
        m_hMSI = LoadLibrary(TEXT("msi.dll"));
        if (NULL == m_hMSI) {
            m_hMSI = (HMODULE)-1;
            return FALSE;
        }

#ifdef _UNICODE
        m_pfnGetComponentPath  = (PMsiGetComponentPath )GetProcAddress(m_hMSI, "MsiGetComponentPathW");
        m_pfnGetShortcutTarget = (PMsiGetShortcutTarget)GetProcAddress(m_hMSI, "MsiGetShortcutTargetW");

#else
        m_pfnGetComponentPath  = (PMsiGetComponentPath )GetProcAddress(m_hMSI, "MsiGetComponentPathA");
        m_pfnGetShortcutTarget = (PMsiGetShortcutTarget)GetProcAddress(m_hMSI, "MsiGetShortcutTargetA");
#endif

        if (m_pfnGetComponentPath == NULL || m_pfnGetShortcutTarget == NULL) {
            FreeLibrary(m_hMSI);
            m_hMSI = (HMODULE)-1;
            return FALSE;
        }

    } else if (m_hMSI == (HMODULE)-1) {
        return FALSE;
    }

    UINT  ErrCode;
    TCHAR szProduct[MAX_PATH];
    TCHAR szFeatureId[MAX_PATH];
    TCHAR szComponentCode[MAX_PATH];

    ErrCode = m_pfnGetShortcutTarget(pszMsiPath, szProduct, szFeatureId, szComponentCode);
    if (ERROR_SUCCESS != ErrCode) {
        return FALSE;
    }

    INSTALLSTATE is;
    TCHAR  szPath[MAX_PATH];
    DWORD  cchPath = sizeof(szPath)/sizeof(szPath[0]);
    *szPath = 0;

    is = m_pfnGetComponentPath(szProduct, szComponentCode, szPath, &cchPath);
    if (INSTALLSTATE_LOCAL == is) {
        //
        // add this item
        //
        return AddItem(pszLocationParent,
                       pszDisplayName,
                       szPath,
                       NULL,
                       pFolder,
                       pidlFull,
                       TRUE);
    }

    return FALSE;
}

int
CProgramList::GetIconFromLink(
    LPCITEMIDLIST pidlLinkFull,
    LPCTSTR       lpszExePath
    )
{

    HRESULT hr;
    IShellFolder* pFolder = NULL;
    IExtractIcon* pExtractIcon = NULL;
    INT iIconIndex = 0;
    UINT uFlags    = 0;
    LPCITEMIDLIST pidlLink = 0;
    HICON hIconLarge = NULL;
    HICON hIconSmall = NULL;
    UINT  nIconSize;
    int ImageIndex = -1;
    UINT uiErrorMode;
    DWORD dwAttributes;

    TCHAR szIconFile[MAX_PATH];
    *szIconFile = TEXT('\0');

    uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hr = SHBindToParent(pidlLinkFull, IID_IShellFolder, (PVOID*)&pFolder, &pidlLink);
    if (!SUCCEEDED(hr)) {
        goto trySysImage;
    }

    // get the ui please
    hr = pFolder->GetUIObjectOf(m_hwndListView, 1, (LPCITEMIDLIST*)&pidlLink, IID_IExtractIcon, NULL, (PVOID*)&pExtractIcon);

    if (!SUCCEEDED(hr)) {
        goto trySysImage;
    }


    hr = pExtractIcon->GetIconLocation(0,
                                       szIconFile,
                                       sizeof(szIconFile) / sizeof(szIconFile[0]),
                                       &iIconIndex,
                                       &uFlags);

    if (!SUCCEEDED(hr)) {
        goto trySysImage;
    }

    if (*szIconFile == TEXT('*')) { // this is batch or some such, don't bother
        goto trySysImage;
    }

    //
    // before doing an extract, check whether it's available
    //

    dwAttributes = GetFileAttributes(szIconFile);


    if (dwAttributes == (DWORD)-1) {
        goto trySysImage;
    }


    nIconSize = MAKELONG(0, ::GetSystemMetrics(SM_CXSMICON));

    //
    // this call is likely to produce a popup, beware of that
    //
    hr = pExtractIcon->Extract(szIconFile,
                               iIconIndex,
                               &hIconLarge,
                               &hIconSmall,
                               nIconSize);

    //
    // if hIconSmall was retrieved - we were successful
    //

trySysImage:

    if (hIconSmall == NULL) {
        //
        // woops -- we could not extract an icon -- what a bummer
        // use shell api then
        SHFILEINFO FileInfo;
        HIMAGELIST hImageSys;

        hImageSys = (HIMAGELIST)SHGetFileInfo(lpszExePath,
                                              0,
                                              &FileInfo, sizeof(FileInfo),
                                              SHGFI_ICON|SHGFI_SMALLICON|SHGFI_SYSICONINDEX);
        if (hImageSys) {
            hIconSmall = ImageList_GetIcon(hImageSys, FileInfo.iIcon, ILD_TRANSPARENT);
        }
    }

    //
    // now that we have an icon, we can add it to our image list ?
    //
    if (hIconSmall != NULL) {
        ImageIndex = ImageList_AddIcon(m_hImageList, hIconSmall);
    }

///////////////////////// cleanup ///////////////////////////////////////////
    SetErrorMode(uiErrorMode);

    if (hIconSmall) {
        DestroyIcon(hIconSmall);
    }

    if (hIconLarge) {
        DestroyIcon(hIconLarge);
    }

    if (pExtractIcon != NULL) {
        pExtractIcon->Release();
    }
    if (pFolder != NULL) {
        pFolder->Release();
    }


    return ImageIndex;
}



BOOL
CProgramList::ListLink(
    LPCTSTR pszLocationParent,
    LPCTSTR pszDisplayName,
    IShellFolder* pFolder,
    LPCITEMIDLIST pidlFull,
    LPCITEMIDLIST pidlLink
    )
{
    IShellLink* psl = NULL;
    WIN32_FIND_DATA wfd;
    HRESULT  hr;
    BOOL     bSuccess = FALSE;
    tstring  strPath;
    tstring  strArgs;
    CComBSTR bstr;
    LPCTSTR  pszArgs = NULL;

    IPersistFile* ipf = NULL;
    IShellLinkDataList* pdl;
    DWORD dwFlags;
    BOOL  bMsiLink = FALSE;

    //
    // check whether we need to cancel
    //

    CheckForCancel();

    hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                            IID_IShellLink, (LPVOID*)&psl);
    if (!SUCCEEDED(hr)) {
        return FALSE; // we can't create link object
    }

    hr = psl->SetIDList(pidlFull); // set the id list
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    //
    // now the shell link is ready to rumble
    //
    if (!GetPathFromLink(psl, &wfd, strPath)) {
        goto out;
    }


    // now let's see what is inside of this link -- shall we?


    hr = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ipf);
    if (!SUCCEEDED(hr)) {
        goto out;
    }

    bstr = strPath.c_str();

    hr = ipf->Load(bstr, STGM_READ);

    if (SUCCEEDED(hr)) {

        //
        // resolve the link for now
        //
        // hr = psl->Resolve(NULL, SLR_NO_UI|SLR_NOUPDATE);


        hr = psl->QueryInterface(IID_IShellLinkDataList, (LPVOID*)&pdl);
        if (SUCCEEDED(hr)) {
            hr = pdl->GetFlags(&dwFlags);

            bMsiLink = SUCCEEDED(hr) && (dwFlags & SLDF_HAS_DARWINID);

            pdl->Release();
        }

        if (bMsiLink) {

            bSuccess = ListMsiLink(pszLocationParent, pszDisplayName, strPath.c_str(), pFolder, pidlFull);

        } else {

            //
            // we now get the path from the link -- and that's that
            //
            if (GetPathFromLink(psl, &wfd, strPath)) {

                if (GetArgumentsFromLink(psl, strArgs)) {
                    pszArgs = strArgs.c_str();
                }

                //
                // add this to our list view
                //

                bSuccess = AddItem(pszLocationParent,
                                   pszDisplayName,
                                   strPath.c_str(),
                                   pszArgs,
                                   pFolder,
                                   pidlFull);

            }
        }

    }

    if (NULL != ipf) {
        ipf->Release();
    }


out:
    if (NULL != psl) {
        psl->Release();
    }

    return bSuccess;

}



BOOL
CProgramList::ListFolder(
    LPCTSTR       pszLocation, // ui string - where is this folder located?
    IShellFolder* pParent,     // parent folder
    LPCITEMIDLIST pidlFull,     // idl of the full path to the folder
    LPCITEMIDLIST pidlFolder    // idl of this folder relative to the pidlFull
    )
{
    LPENUMIDLIST penum = NULL;
    LPITEMIDLIST pidl  = NULL;
    HRESULT      hr;

    ULONG        celtFetched;
    ULONG        uAttr;
    tstring      strDisplayNameLocation;
    tstring      strDisplayName;

    IShellFolder* pFolder = NULL;
    BOOL bDesktop = FALSE;

    BOOL bCancel = FALSE;
    CCancelException* pCancelException = NULL;

    CheckForCancel();

    if (pParent == NULL) {
        hr = SHGetDesktopFolder(&pParent);
        bDesktop = TRUE;
    }

    hr = pParent->BindToObject(pidlFolder,
                                 NULL,
                               IID_IShellFolder,
                               (LPVOID *) &pFolder);

    if (NULL == pszLocation) {
        GetDisplayName(pParent, pidlFolder, strDisplayNameLocation);
    } else {
        strDisplayNameLocation = pszLocation;
    }

    if (bDesktop) {
        pParent->Release();
    }

    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    hr = pFolder->EnumObjects(NULL,SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum);
    if (!SUCCEEDED(hr)) {
        pFolder->Release(); // free the folder- - and go away
        return FALSE;
    }


    while( (hr = penum->Next(1,&pidl, &celtFetched)) == S_OK && celtFetched == 1 && !bCancel) {
        LPITEMIDLIST pidlCur;

        if (pidlFull == NULL) {
            pidlFull = pidlFolder;
        }

        pidlCur = AppendIDL(pidlFull, pidl);

        // get the display name of this item
        GetDisplayName(pFolder, pidl, strDisplayName);


        uAttr = SFGAO_FOLDER | SFGAO_LINK;
        hr = pFolder->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &uAttr);
        if (SUCCEEDED(hr)) {

            try {

                if (uAttr & SFGAO_FOLDER) {
                    //
                    // dump folder recursively
                    //
                    ListFolder(strDisplayName.c_str(), pFolder, pidlCur, pidl);

                } else if (uAttr & SFGAO_LINK) {

                    ListLink(strDisplayNameLocation.c_str(), strDisplayName.c_str(), pFolder, pidlCur, pidl);

                } else if (uAttr & SFGAO_FILESYSTEM) {
                    //
                    // this item is a file
                    //
                    AddItem(strDisplayNameLocation.c_str(),
                            strDisplayName.c_str(),
                            NULL,
                            NULL,
                            pFolder,
                            pidlCur,
                            TRUE);

                }

            } catch(CCancelException* pex) {
                //
                // we need to cancel -- we shall cleanup and do what we need, then re-throw
                //
                bCancel = TRUE;
                pCancelException = pex;
            }

        }
        GetMalloc()->Free(pidlCur);
        GetMalloc()->Free(pidl);

    }

    if (NULL != penum) {
        penum->Release();
    }

    if (NULL != pFolder) {
        pFolder->Release();
    }

    if (bCancel && pCancelException) {
        throw pCancelException;
    }

    return TRUE;
}


BOOL
CProgramList::IsSFCItem(
    LPCTSTR pszPath
    )
{

#ifndef _UNICODE
    WCHAR wszBuffer[1024];

    mbstowcs(wszBuffer, pszPath, sizeof(wszBuffer)/sizeof(wszBuffer[0]));
    return SfcIsFileProtected(NULL, wszBuffer);
#else

    return SfcIsFileProtected(NULL, pszPath);

#endif

}

BOOL
CProgramList::IsItemInSystemDirectory(
    LPCTSTR pszPath
    )
{
    TCHAR szCommonPath[MAX_PATH];
    int nch;
    string s;

    nch = PathCommonPrefix(m_strSystemDirectory.c_str(), pszPath, szCommonPath);
    return nch == m_strSystemDirectory.length();
}

BOOL
ValidateExecutableFile(
    LPCTSTR pszPath,
    BOOL    bValidateFileExists
    )
{
    LPTSTR rgExt[] = {
            TEXT("EXE"),
            TEXT("BAT"),
            TEXT("CMD"),
            TEXT("PIF"),
            TEXT("COM"),
            TEXT("LNK")
            };
    LPTSTR pExt;
    int i;
    BOOL bValidatedExt = FALSE;

    pExt = PathFindExtension(pszPath);
    if (pExt == NULL || *pExt == TEXT('\0')) {
        return FALSE;
    }
    ++pExt;

    for (i = 0; i < sizeof(rgExt)/sizeof(rgExt[0]) && !bValidatedExt; ++i) {
            bValidatedExt = !_tcsicmp(pExt, rgExt[i]);
    }

    if (!bValidatedExt) {
        return FALSE;
    }


    return bValidateFileExists ? PathFileExists(pszPath) : TRUE;
}


BOOL
CProgramList::AddItem(
    LPCTSTR pszLocation,
    LPCTSTR pszDisplayName,
    LPCTSTR pszPath,
    LPCTSTR pszArguments,
    IShellFolder* pFolder,
    LPCITEMIDLIST pidlFull,
    BOOL    bUsePath
    )
{
    //
    // first test -- is this one of the types we like?
    //
    LPTSTR  pchSlash;
    LPTSTR  pchDot;
    LPTSTR  rgExt[] = { TEXT("EXE"), TEXT("BAT"), TEXT("CMD"), TEXT("PIF"), TEXT("COM"), TEXT("LNK") };
    BOOL    bValidatedExt = FALSE;
    BOOL    bSuccess = FALSE;
    PSHITEMINFO pInfo = NULL;
    MAPSTR2ITEM::iterator Iter;
    TCHAR   szPathExecute[MAX_PATH];
    tstring strKey;
    tstring strKeyExe;
    DWORD   dwBinaryType = 0;

    LVITEM  lvi;
    int     ix;


    //
    // check for cancelling the search
    //
    CheckForCancel();

    if (NULL == pszPath) {
        pszPath = szPathExecute;

        if (!SHGetPathFromIDList(pidlFull, szPathExecute)) {
            goto out;
        }
    }

    if (pszDisplayName && m_pProgView) {
        m_pProgView->UpdatePopulateStatus(pszDisplayName, pszPath);
    }

    pchSlash = _tcsrchr(pszPath, TEXT('\\'));
    pchDot   = _tcsrchr(pszPath, TEXT('.'));

    if (NULL != pchSlash) {
        if ((ULONG_PTR)pchDot < (ULONG_PTR)pchSlash) {
            pchDot = NULL;
        }
    }

    if (NULL != pchDot) {
        ++pchDot;

        for (int i = 0; i < sizeof(rgExt)/sizeof(rgExt[0]) && !bValidatedExt; ++i) {
            bValidatedExt = !_tcsicmp(pchDot, rgExt[i]);
        }
    }

    if (!bValidatedExt) {
        goto out;
    }

    //
    // Checks whether the item is in system directory or SFC-protected
    //
#if 0
    if (IsItemInSystemDirectory(pszPath) || IsSFCItem(pszPath)) {
        goto out;
    }
#endif

    //
    // GetBinaryTypeW excludes exes on the basis of binary type
    //
    if (GetBinaryType(pszPath, &dwBinaryType) &&
        dwBinaryType == SCS_64BIT_BINARY) {
        goto out;
    }

    if (IsSFCItem(pszPath)) {
        goto out;
    }

    //
    // this is multimap key
    //
    strKeyExe = StrUpCase(wstring(pszPath));

    //
    // now compose the key string
    //
    strKey = strKeyExe;
    if (NULL != pszArguments) {
        strKey.append(TEXT(" "));
        strKey.append(pszArguments);
    }

    //
    // now check whether this item has already been listed
    //

    Iter = m_mapItems.find(strKey);
    if (Iter != m_mapItems.end()) { // found a duplicate
        goto out;
    }

    //
    // now please add this item to the list view
    //
    pInfo = new CProgramList::SHITEMINFO;
    if (pInfo == NULL) {
        ThrowMemoryException(__FILE__, __LINE__, TEXT("%s\n"), TEXT("Failed to allocate Item Information structure"));
    }

    pInfo->strDisplayName = pszDisplayName;
    pInfo->strFolder      = pszLocation;
    pInfo->strPath        = pszPath;
    pInfo->strCmdLine     = strKey;
    if (NULL != pszArguments) {
        pInfo->strArgs = pszArguments;
    }
    pInfo->pidl           = AppendIDL(NULL, pidlFull);

    if (bUsePath) {
        pInfo->strPathExecute = pszPath;
    } else {

        // finally, what are we going to launch ?
        if (SHGetPathFromIDList(pidlFull, szPathExecute)) {
            pInfo->strPathExecute = szPathExecute;
        }
    }


    m_mapItems[strKey] = pInfo;

    m_mmapExeItems.insert(MULTIMAPSTR2ITEM::value_type(strKeyExe, pInfo));

    ATLTRACE(TEXT("Adding item %s %s %s\n"), pszDisplayName, pszLocation, pszPath);

    lvi.mask = LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE;
    lvi.iItem = ListView_GetItemCount(m_hwndListView); // append at the end please
    lvi.iSubItem = 0;
    lvi.pszText = LPSTR_TEXTCALLBACK;
    lvi.iImage  = I_IMAGECALLBACK;
    lvi.lParam  = (LPARAM)pInfo;
    ix = ListView_InsertItem(m_hwndListView, &lvi);

    lvi.mask = LVIF_TEXT;
    lvi.iItem = ix;
    lvi.iSubItem = 1;
    lvi.pszText = LPSTR_TEXTCALLBACK;
    ListView_SetItem(m_hwndListView, &lvi);

    bSuccess = TRUE;

out:

    return bSuccess;
}

BOOL
CProgramList::PopulateControl(
    CProgView* pProgView,
    HANDLE     hevtCancel
    )
{
    int i;
    HRESULT hr;
    LPITEMIDLIST pidl;
    BOOL bCancel = FALSE;
    struct {
        INT csidl;
        UINT nIDDescription;
    } rgFolders[] = {
        { CSIDL_DESKTOPDIRECTORY, IDS_DESKTOP             },
        { CSIDL_COMMON_STARTMENU, IDS_COMMON_STARTMENU    },
        { CSIDL_STARTMENU,        IDS_STARTMENU           },
        { CSIDL_COMMON_PROGRAMS,  IDS_COMMON_PROGRAMS     },
        { CSIDL_PROGRAMS,         IDS_PROGRAMS            }
    };


    //
    // set the progview object pointer so we could update the status
    //
    m_pProgView = pProgView;

    m_pMallocUI = pProgView->m_pMallocUI;

    //
    // set the event so that we could cancel the scan
    //
    m_hEventCancel = hevtCancel;


    //
    // set extended style
    //

    ListView_SetExtendedListViewStyleEx(m_hwndListView,
                                        LVS_EX_INFOTIP|LVS_EX_LABELTIP,
                                        LVS_EX_INFOTIP|LVS_EX_LABELTIP);

    //
    //  fix columns
    //


    LVCOLUMN lvc;
    RECT     rc;
    SIZE_T   cxProgName;
    SIZE_T   cx;
    wstring  strCaption;

    lvc.mask = LVCF_WIDTH;
    if (!ListView_GetColumn(m_hwndListView, 2, &lvc)) {

        ::GetClientRect(m_hwndListView, &rc);
        cx = rc.right - rc.left -
                ::GetSystemMetrics(SM_CXVSCROLL) -
                ::GetSystemMetrics(SM_CXEDGE) -
                ::GetSystemMetrics(SM_CXSIZEFRAME);


        cxProgName = cx * 3 / 5;
        strCaption = LoadResourceString(IDS_PROGRAMNAME);

        lvc.mask    = LVCF_FMT|LVCF_WIDTH|LVCF_TEXT;
        lvc.pszText = (LPTSTR)strCaption.c_str();
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = cxProgName;
        lvc.iSubItem= 0;
        ListView_InsertColumn(m_hwndListView, 0, &lvc);

        cx -= cxProgName;

        cxProgName = cx / 2;
        strCaption = LoadResourceString(IDS_FOLDER);

        lvc.mask    = LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM;
        lvc.pszText = (LPTSTR)strCaption.c_str();
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = cxProgName;
        lvc.iSubItem= 1;
        ListView_InsertColumn(m_hwndListView, 1, &lvc);

        strCaption = LoadResourceString(IDS_SETTINGS);

        lvc.mask    = LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM;
        lvc.pszText = (LPTSTR)strCaption.c_str();
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = cx - cxProgName;
        lvc.iSubItem= 2;
        ListView_InsertColumn(m_hwndListView, 2, &lvc);

    }

    HDC hDC = GetDC(m_hwndListView);
    int nBitsPixel = ::GetDeviceCaps(hDC, BITSPIXEL);
    int nPlanes    = ::GetDeviceCaps(hDC, PLANES);
    UINT flags;

    nBitsPixel *= nPlanes;
    if (nBitsPixel < 4) {
        flags = ILC_COLOR;
    } else if (nBitsPixel < 8) {
        flags = ILC_COLOR4;
    } else if (nBitsPixel < 16) {
        flags = ILC_COLOR8;
    } else if (nBitsPixel < 24) {
        flags = ILC_COLOR16;
    } else if (nBitsPixel < 32) {
        flags = ILC_COLOR24;
    } else if (nBitsPixel == 32) {
        flags = ILC_COLOR32;
    } else {
        flags = ILC_COLORDDB;
    }

    flags |= ILC_MASK;

    ReleaseDC(m_hwndListView, hDC);

    m_hImageList = ImageList_Create(::GetSystemMetrics(SM_CXSMICON),
                                    ::GetSystemMetrics(SM_CYSMICON),
                                    flags,
                                    10,
                                    25);
    if (m_hImageList == NULL) {
        ATLTRACE(TEXT("Image List creation failure, error 0x%lx\n"), GetLastError());
    }

    ImageList_SetBkColor(m_hImageList, CLR_NONE);

    ListView_SetImageList(m_hwndListView, m_hImageList, LVSIL_SMALL);

    ::SendMessage(m_hwndListView, WM_SETREDRAW, FALSE, 0);

    ListView_DeleteAllItems(m_hwndListView);

    //
    // AtlTrace(TEXT("Callback Mask: 0x%lx\n"), ListView_GetCallbackMask(m_hwndListView));
    //

    for (i = 0; i < sizeof(rgFolders)/sizeof(rgFolders[0]) && !bCancel; ++i) {
        wstring strDescription = LoadResourceString(rgFolders[i].nIDDescription);

        hr = SHGetFolderLocation(NULL, rgFolders[i].csidl, NULL, 0, &pidl);
        if (SUCCEEDED(hr)) {
            try {
                ListFolder(strDescription.c_str(), NULL, NULL, pidl);
            } catch(CCancelException* pex) {
                bCancel = TRUE;
                pex->Delete();
            } catch(CException* pex) {
                bCancel = TRUE;
                pex->Delete();
            }
            GetMalloc()->Free(pidl);
        }
    }

    ::SendMessage(m_hwndListView, WM_SETREDRAW, TRUE, 0);

    return TRUE;

}

BOOL
CProgramList::CaptureSelection(
    VOID
    )
{
    INT iSelected;
    LVITEM lvi;

    m_pSelectionInfo = NULL;

    iSelected = ListView_GetNextItem(m_hwndListView, -1, LVNI_SELECTED);

    if (iSelected == -1) {
        return FALSE;
    }

    lvi.iItem = iSelected;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;
    if (ListView_GetItem(m_hwndListView, &lvi)) {
        m_pSelectionInfo = (PSHITEMINFO)lvi.lParam;
    }

    return m_pSelectionInfo != NULL;

}

BOOL
CProgramList::GetSelectionDetails(
    INT iInformationClass,
    LPWSTR pBuffer,
    ULONG BufferSize
    )
{
    LPCWSTR wstr;

    if (m_pSelectionInfo == NULL) {
        *pBuffer = 0;
        return TRUE;
    }

    switch(iInformationClass) {
    case PROGLIST_DISPLAYNAME:
        wstr = m_pSelectionInfo->strDisplayName.c_str();
        break;

    case PROGLIST_LOCATION:     //
        wstr = m_pSelectionInfo->strFolder.c_str();
        break;

    case PROGLIST_EXENAME:      // cracked exe name
        wstr = m_pSelectionInfo->strPath.c_str(); //
        break;

    case PROGLIST_CMDLINE:      // complete exe name + parameters
        wstr = m_pSelectionInfo->strCmdLine.c_str();
        break;

    case PROGLIST_EXECUTABLE:    // what we should execute (link or exe, not cracked)
        wstr = m_pSelectionInfo->strPathExecute.c_str();
        break;

    case PROGLIST_ARGUMENTS:
        wstr = m_pSelectionInfo->strArgs.c_str();
        break;

    default:
        *pBuffer = 0;
        return TRUE;
        break;
    }


    if (wcslen(wstr) < BufferSize/sizeof(WCHAR))
    {
        wcscpy(pBuffer, wstr);
    }

    return TRUE;
}

#define PROGLIST_SORT_NONE 0
#define PROGLIST_SORT_ASC  1
#define PROGLIST_SORT_DSC  2


int CALLBACK
CProgramList::SHItemInfoCompareFunc(
    LPARAM lp1,
    LPARAM lp2,
    LPARAM lParamSort
    )
{
    PSHITEMINFO pInfo1 = (PSHITEMINFO)lp1;
    PSHITEMINFO pInfo2 = (PSHITEMINFO)lp2;
    BOOL bEmpty1, bEmpty2;
    int nColSort   = (int)LOWORD(lParamSort);
    int nSortOrder = (int)HIWORD(lParamSort);
    int iRet = 0;

    switch(nColSort) {
    case 0: // SORT_APPNAME:
        iRet = _tcsicmp(pInfo1->strDisplayName.c_str(),
                        pInfo2->strDisplayName.c_str());
        break;

    case 1: // SORT_APPLOCATION:
        iRet = _tcsicmp(pInfo1->strFolder.c_str(),
                        pInfo2->strFolder.c_str());
        break;

    case 2: // SORT_LAYERS:
        bEmpty1 = pInfo1->strKeys.empty();
        bEmpty2 = pInfo2->strKeys.empty();
        if (bEmpty1 || bEmpty2) {
            if (bEmpty1) {
                iRet = bEmpty2 ? 0 : 1;
            } else {
                iRet = bEmpty1 ? 0 : -1;
            }
        } else {

            iRet = _tcsicmp(pInfo1->strKeys.c_str(),
                            pInfo2->strKeys.c_str());
        }

        break;
    }

    if (nSortOrder == PROGLIST_SORT_DSC) {
        iRet = -iRet;
    }

    return iRet;
}



LRESULT
CProgramList::LVNotifyColumnClick(
    LPNMHDR pnmhdr,
    BOOL&   bHandled
    )
{
    LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW)pnmhdr;

    // lpnmlv->iSubItem - this is what we have to sort on
    // check whether we already have something there

    HWND hwndHeader = ListView_GetHeader(m_hwndListView);
    INT  nCols;
    INT  i;
    INT  nColSort = lpnmlv->iSubItem;
    LPARAM lSortParam; // leave high word blank for now
    LPARAM lSortOrder = PROGLIST_SORT_ASC;
    HDITEM hdi;
    //
    // reset current image - wherever that is
    //
    nCols = Header_GetItemCount(hwndHeader);

    for (i = 0; i < nCols; ++i) {
        hdi.mask = HDI_BITMAP|HDI_LPARAM|HDI_FORMAT;
        if (!Header_GetItem(hwndHeader, i, &hdi)) {
            continue;
        }

        if (i == nColSort && (hdi.mask & HDI_LPARAM)) {
            switch(hdi.lParam) {
            case PROGLIST_SORT_NONE:
            case PROGLIST_SORT_DSC:
                lSortOrder = PROGLIST_SORT_ASC;
                break;
            case PROGLIST_SORT_ASC:
                lSortOrder = PROGLIST_SORT_DSC;
                break;
            }
        }

        if (hdi.mask & HDI_BITMAP) {
            DeleteObject((HGDIOBJ)hdi.hbm);
        }

        hdi.lParam = PROGLIST_SORT_NONE;
        hdi.fmt &= ~(HDF_BITMAP|HDF_BITMAP_ON_RIGHT);
        hdi.mask |= HDI_BITMAP|HDI_LPARAM|HDI_FORMAT;
        hdi.hbm = NULL;
        Header_SetItem(hwndHeader, i, &hdi);
    }

    lSortParam = MAKELONG(nColSort, lSortOrder);
    ListView_SortItems(m_hwndListView, (PFNLVCOMPARE)SHItemInfoCompareFunc, lSortParam);

    // now, load the image please
    m_hbmSort = (HBITMAP)::LoadImage(_Module.GetResourceInstance(),
                                     MAKEINTRESOURCE(lSortOrder == PROGLIST_SORT_ASC? IDB_SORTUP : IDB_SORTDN),
                                     IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
    hdi.mask = HDI_BITMAP|HDI_LPARAM|HDI_FORMAT;
    Header_GetItem(hwndHeader, nColSort,  &hdi);
    hdi.mask   |= HDI_BITMAP|HDI_FORMAT|HDI_LPARAM;
    hdi.hbm    = m_hbmSort;
    hdi.fmt    |= HDF_BITMAP|HDF_BITMAP_ON_RIGHT;
    hdi.lParam = lSortOrder;
    Header_SetItem(hwndHeader, nColSort, &hdi);


    bHandled = TRUE;
    return 0;
}

LRESULT
CProgramList::LVNotifyDispInfo(
    LPNMHDR pnmhdr,
    BOOL& bHandled
    )
{

    WCHAR wszPermKeys[MAX_PATH];
    DWORD cbSize;

    LV_ITEM &lvItem = reinterpret_cast<LV_DISPINFO*>(pnmhdr)->item;

    LV_ITEM lvi;
    PSHITEMINFO pInfo;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = lvItem.iItem;
    lvi.iSubItem = 0;

    if (!ListView_GetItem(m_hwndListView, &lvi)) {
        // bummer, we can't retrieve an item -- if we let it go, things will be worse
        lvItem.mask &= ~(LVIF_TEXT|LVIF_IMAGE);
        lvItem.mask |= LVIF_DI_SETITEM;
        bHandled = TRUE;
        return 0;
    }

    pInfo = reinterpret_cast<PSHITEMINFO> (lvi.lParam);

    if (lvItem.mask & LVIF_TEXT) {
        switch (lvItem.iSubItem) {
        case 0:
            lvItem.pszText = (LPTSTR)pInfo->strDisplayName.c_str();
            break;
        case 1:
            lvItem.pszText = (LPTSTR)pInfo->strFolder.c_str();
            break;
        case 2:
            // check with SDB
            cbSize = sizeof(wszPermKeys);
            if (pInfo->strKeys.empty()) {

                if (SdbGetPermLayerKeys(pInfo->strPath.c_str(), wszPermKeys, &cbSize, GPLK_ALL)) {
                    pInfo->strKeys = wszPermKeys;
                }

            }

            if (!pInfo->strKeys.empty()) {
                lvItem.pszText = (LPTSTR)pInfo->strKeys.c_str();
            }

            break;

        default:
            break;
        }
    }


    if (lvItem.mask & LVIF_IMAGE) {
        lvItem.iImage = GetIconFromLink(pInfo->pidl, pInfo->strPathExecute.c_str());
    }

    lvItem.mask |= LVIF_DI_SETITEM;
    bHandled = TRUE;
    return 0;

}

LRESULT
CProgramList::LVNotifyGetInfoTip(
    LPNMHDR pnmhdr,
    BOOL& bHandled
    )
{
    DWORD cbSize;
    LPNMLVGETINFOTIP pGetInfoTip = (LPNMLVGETINFOTIP)pnmhdr;
    LV_ITEM lvi;
    PSHITEMINFO pInfo;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = pGetInfoTip->iItem;
    lvi.iSubItem = 0;

    if (!ListView_GetItem(m_hwndListView, &lvi)) {
        // bupkas
        bHandled = FALSE;
        return 0;
    }

    pInfo = reinterpret_cast<PSHITEMINFO> (lvi.lParam);

    //
    // now we can fiddle
    //

    _tcsncpy(pGetInfoTip->pszText, pInfo->strCmdLine.c_str(), pGetInfoTip->cchTextMax);
    *(pGetInfoTip->pszText + pGetInfoTip->cchTextMax - 1) = TEXT('\0');

    bHandled = TRUE;
    return 0;

}

LRESULT
CProgramList::LVNotifyRClick(
    LPNMHDR pnmhdr,
    BOOL& bHandled
    )
{

    DWORD dwPos = ::GetMessagePos();
    LVHITTESTINFO hti;
    LV_ITEM lvi;
    PSHITEMINFO pInfo;
    HRESULT hr;
    LPITEMIDLIST  pidlItem = NULL;
    IShellFolder* pFolder  = NULL;
    IContextMenu* pContextMenu = NULL;
    CMINVOKECOMMANDINFO ici;
    int nCmd;
    HMENU hMenu = NULL;
    UINT  idMin, idMax, idCmd;
    WCHAR szCmdVerb[MAX_PATH];
    int nLastSep, i, nLastItem;

    hti.pt.x = (int) LOWORD (dwPos);
    hti.pt.y = (int) HIWORD (dwPos);
    ScreenToClient (m_hwndListView, &hti.pt);

    ListView_HitTest (m_hwndListView, &hti);

    if (!(hti.flags & LVHT_ONITEM)) {
        bHandled = FALSE;
        return 0;
    }

    lvi.mask  = LVIF_PARAM;
    lvi.iItem = hti.iItem;
    lvi.iSubItem = 0;

    if (!ListView_GetItem(m_hwndListView, &lvi)) {
        // bupkas
        bHandled = FALSE;
        return 0;
    }

    pInfo = reinterpret_cast<PSHITEMINFO> (lvi.lParam);

    //
    // we have an item, show it's context menu then
    //

    hr = SHBindToParent(pInfo-> pidl, IID_IShellFolder, (PVOID*)&pFolder, (LPCITEMIDLIST*)&pidlItem);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    // get the ui please
    hr = pFolder->GetUIObjectOf(m_hwndListView, 1, (LPCITEMIDLIST*)&pidlItem, IID_IContextMenu, NULL, (PVOID*)&pContextMenu);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }

    hMenu = CreatePopupMenu();
    if (hMenu == NULL) {
        goto cleanup;
    }

    hr = pContextMenu->QueryContextMenu(hMenu,
                                        0,
                                        1,
                                        0x7FFF,
                                        CMF_EXPLORE);
    if (!SUCCEEDED(hr)) {
        goto cleanup;
    }



    //
    // sanitize
    //
    idMin = 1;
    idMax = HRESULT_CODE(hr);

    for (idCmd = 0; idCmd < idMax; ++idCmd) {
        hr = pContextMenu->GetCommandString(idCmd, GCS_VERBW, NULL, (LPSTR)szCmdVerb, CHARCOUNT(szCmdVerb));
        if (SUCCEEDED(hr)) {
            if (!_wcsicmp(szCmdVerb, TEXT("cut"))    ||
                !_wcsicmp(szCmdVerb, TEXT("delete")) ||
                !_wcsicmp(szCmdVerb, TEXT("rename")) ||
                !_wcsicmp(szCmdVerb, TEXT("link"))) {
                //
                // not allowed
                //
                DeleteMenu(hMenu, idCmd + idMin, MF_BYCOMMAND);
            }
        }
    }

    //
    // after doing some basic sanitization against the destructive tendencies --
    // nuke double-separators
    //

    nLastItem = ::GetMenuItemCount(hMenu) - 1;
    nLastSep = nLastItem + 1;
    for (i = nLastItem; i >= 0; --i) {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_FTYPE;
        if (GetMenuItemInfo(hMenu, i, TRUE, &mii)) {
            if (mii.fType & MFT_SEPARATOR) {
                if (nLastSep == i + 1 || i == 0) {
                    // this sep is dead
                    DeleteMenu(hMenu, i, MF_BYPOSITION);
                }
                nLastSep = i;
            }
        }
    }



    ClientToScreen(m_hwndListView, &hti.pt);
    nCmd = TrackPopupMenu(hMenu,
                          TPM_LEFTALIGN |
                            TPM_LEFTBUTTON |
                            TPM_RIGHTBUTTON |
                            TPM_RETURNCMD,
                          hti.pt.x, hti.pt.y,
                          0,
                          m_hwndListView,
                          NULL);

    //
    // execute command
    //
    if (nCmd) {
        ici.cbSize          = sizeof (CMINVOKECOMMANDINFO);
        ici.fMask           = 0;
        ici.hwnd            = m_hwndListView;
        ici.lpVerb          = MAKEINTRESOURCEA(nCmd - 1);
        ici.lpParameters    = NULL;
        ici.lpDirectory     = NULL;
        ici.nShow           = SW_SHOWNORMAL;
        ici.dwHotKey        = 0;
        ici.hIcon           = NULL;
        hr = pContextMenu->InvokeCommand(&ici);

        //
        // requery perm layer keys -- useless here btw
        //
        /* // this code will not work since the call above is always asynchronous
           //
        if (SUCCEEDED(hr)) {
            DWORD cbSize;
            WCHAR wszPermKeys[MAX_PATH];

            cbSize = sizeof(wszPermKeys);
            if (SdbGetPermLayerKeys(pInfo->strPath.c_str(), wszPermKeys, &cbSize)) {
                pInfo->strKeys = wszPermKeys;
            } else {
                pInfo->strKeys.erase();
            }

            //
            // set the info into the list box
            //
            ListView_SetItemText(m_hwndListView, lvi.iItem, 2, (LPWSTR)pInfo->strKeys.c_str());

        }
        */


    }

cleanup:

    if (hMenu) {
        DestroyMenu(hMenu);
    }
    if (pContextMenu) {
        pContextMenu->Release();
    }
    if (pFolder) {
        pFolder->Release();
    }

    bHandled = TRUE;
    return 0;
}



BOOL
CProgramList::UpdateListItem(
    LPCWSTR pwszPath,
    LPCWSTR pwszKey
    )
{

    // find the item first

    MAPSTR2ITEM::iterator iter;
    MULTIMAPSTR2ITEM::iterator iterExe;
    MULTIMAPSTR2ITEM::iterator iterFirstExe, iterLastExe;

    tstring     strKey = pwszPath;
    tstring     strExeKey;
    PSHITEMINFO pInfo = NULL;
    PSHITEMINFO pInfoExe = NULL;

    //
    // we need to iterate through all the persisted items
    //
    StrUpCase(strKey);

    iter = m_mapItems.find(strKey);
    if (iter != m_mapItems.end()) {
        pInfo = (*iter).second;
    }

    if (pInfo == NULL) {
        return FALSE;
    }

    //
    // once we have found this single item, get the command and
    // show info for all the other affected items
    //
    strExeKey = pInfo->strPath;
    StrUpCase(strExeKey);

    iterFirstExe = m_mmapExeItems.lower_bound(strExeKey);
    iterLastExe  = m_mmapExeItems.upper_bound(strExeKey);

    for (iterExe = iterFirstExe; iterExe != m_mmapExeItems.end() && iterExe != iterLastExe; ++iterExe) {
        pInfoExe = (*iterExe).second;


        // find this item in a listview

        LVFINDINFO lvf;
        INT index;

        lvf.flags = LVFI_PARAM;
        lvf.lParam = (LPARAM)pInfoExe;

        index = ListView_FindItem(m_hwndListView, -1, &lvf);
        if (index < 0) {
            return FALSE; // inconsistent
        }

        // else we have both the item and the keys
        if (pwszKey == NULL) {
            pInfoExe->strKeys.erase();
        } else {
            pInfoExe->strKeys = pwszKey;
        }

        ListView_SetItemText(m_hwndListView, index, 2, (LPWSTR)pInfoExe->strKeys.c_str());
    }

    return TRUE;
}



BOOL
CProgramList::IsEnabled(
    VOID
    )
{

    if (::IsWindow(m_hwndListView)) {
        return ::IsWindowEnabled(m_hwndListView);
    }

    return FALSE;
}


VOID
CProgramList::Enable(
    BOOL bEnable
    )
{
    if (::IsWindow(m_hwndListView)) {

        ::EnableWindow(m_hwndListView, bEnable);
    }

}

BOOL
GetProgramListSelection(
    CProgramList* pProgramList
    )
{
    return pProgramList->CaptureSelection();
}


BOOL
GetProgramListSelectionDetails(
    CProgramList* pProgramList,
    INT iInformationClass,
    LPWSTR pBuffer,
    ULONG Size
    )
{

    return  pProgramList->GetSelectionDetails(iInformationClass, pBuffer, Size);
}

LRESULT
NotifyProgramList(
    CProgramList* pProgramList,
    LPNMHDR       pnmhdr,
    BOOL&         bHandled
    )
{
    LRESULT lRet = 0;

    switch (pnmhdr->code) {
    case LVN_GETDISPINFO:
        lRet = pProgramList->LVNotifyDispInfo(pnmhdr, bHandled);
        break;

    case LVN_COLUMNCLICK:
        lRet = pProgramList->LVNotifyColumnClick(pnmhdr, bHandled);
        break;

    case LVN_GETINFOTIP:
        lRet = pProgramList->LVNotifyGetInfoTip(pnmhdr, bHandled);
        break;

    case NM_RCLICK:
        lRet = pProgramList->LVNotifyRClick(pnmhdr, bHandled);
        break;

    default:
        bHandled = FALSE;
        break;
    }

    return lRet;
}

BOOL
GetProgramListEnabled(
    CProgramList* pProgramList
    )
{
    return pProgramList->IsEnabled();
}

VOID
EnableProgramList(
    CProgramList* pProgramList,
    BOOL bEnable
    )
{
    pProgramList->Enable(bEnable);
}

BOOL
UpdateProgramListItem(
    CProgramList* pProgramList,
    LPCWSTR pwszPath,
    LPCWSTR pwszKeys
    )
{
    return pProgramList->UpdateListItem(pwszPath, pwszKeys);

}

wstring StrUpCase(wstring& wstr)
{
    ctype<wchar_t> _ct;
    wstring::iterator iter;

    for (iter = wstr.begin(); iter != wstr.end(); ++iter) {
        (*iter) = _ct.toupper(*iter);
    }

    return wstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\upload.cpp ===
/*******************************************************************
*
*    DESCRIPTION: Upload.cpp : Generates and sends out AppCompat report
*
*    DATE:6/13/2002
*
*******************************************************************/
#include <wtypes.h>
#include <malloc.h>
#include <strsafe.h>
#include <commdlg.h>
#include <shimdb.h>
#include <faultrep.h>
#include "upload.h"
#include <wchar.h>


// These values are directly fron the web page and it must be in
// sync with it in order for report to work properly
LPCWSTR g_ProblemTypeDescs[] = {
    L"Uninitialized",
    L"Install_Fail",
    L"System_Slow",
    L"App_Faulting",
    L"App_ErrorOSVer",
    L"App_HWDevice",
    L"App_OSUpgrade",
    L"Uninstall_Fail",
    L"App_CDError",
    L"App_UserError",
    L"App_Internet",
    L"App_Print",
    L"App_PartlyWork",
    NULL
};


ULONG
GetProblemTypeId(
    LPWSTR wszProblemType
    )
{
    ULONG len;

    len = wcslen(wszProblemType);

    while (len && isdigit(wszProblemType[len-1]))
    {
        --len;
    }
    if (wszProblemType[len])
    {
        return _wtoi(wszProblemType+len);
    }
    return 0;
}
// ***************************************************************************
DWORD GetAppCompatFlag(LPCWSTR wszPath)
{
    LPWSTR  pwszFile, wszSysDirLocal = NULL, pwszDir = NULL;
    DWORD   dwOpt = 0;
    DWORD   cchPath, cch;
    UINT    uiDrive;
    WCHAR   wszSysDir[MAX_PATH+2];
    LPWSTR  wszBuffer = NULL;
    DWORD   BufferChCount;

    if (wszPath == NULL)
    {
        goto exitGetACF;
    }

    // can't be a valid path if it's less than 3 characters long
    cchPath = wcslen(wszPath);
    if (cchPath < 3)
    {
        goto exitGetACF;
    }

    if (!GetSystemDirectoryW(wszSysDir, MAX_PATH+1))
    {
        goto exitGetACF;
    }

    // do we have a UNC path?
    if (wszPath[0] == L'\\' && wszPath[1] == L'\\')
    {
        dwOpt = GRABMI_FILTER_THISFILEONLY;
        goto exitGetACF;
    }

    BufferChCount = cchPath+1;
    wszBuffer = (LPWSTR) malloc(BufferChCount * sizeof(WCHAR));
    if (!wszBuffer)
    {
        goto exitGetACF;
    }

    // ok, maybe a remote mapped path or system32?
    StringCchCopyW(wszBuffer, BufferChCount, wszPath);
    for(pwszFile = wszBuffer + cchPath;
        *pwszFile != L'\\' && pwszFile > wszBuffer;
        pwszFile--);
    if (*pwszFile == L'\\')
        *pwszFile = L'\0';
    else
        goto exitGetACF;

    cch = wcslen(wszSysDir) + 1;

    // see if it's in system32 or in any parent folder of it.
    pwszDir = wszSysDir + cch;
    do
    {
        if (_wcsicmp(wszBuffer, wszSysDir) == 0)
        {
            dwOpt = GRABMI_FILTER_SYSTEM;
            goto exitGetACF;
        }

        for(;
            *pwszDir != L'\\' && pwszDir > wszSysDir;
            pwszDir--);
        if (*pwszDir == L'\\')
            *pwszDir = L'\0';

    }
    while (pwszDir > wszSysDir);

    // is the file sitting in the root of a drive?
    if (pwszFile <= &wszBuffer[3])
    {
        dwOpt = GRABMI_FILTER_THISFILEONLY;
        goto exitGetACF;
    }


    // well, if we've gotten this far, then the path is in the form of
    //  X:\<something>, so cut off the <something> and find out if we're on
    //  a mapped drive or not
    *pwszFile    = L'\\';
    wszBuffer[3] = L'\0';
    switch(GetDriveTypeW(wszBuffer))
    {
        case DRIVE_UNKNOWN:
        case DRIVE_NO_ROOT_DIR:
            goto exitGetACF;

        case DRIVE_REMOTE:
            dwOpt = GRABMI_FILTER_THISFILEONLY;
            goto exitGetACF;
    }

    dwOpt = GRABMI_FILTER_PRIVACY;

exitGetACF:
    if (wszBuffer)
    {
        free (wszBuffer);
    }
    return dwOpt;
}

//
// Check if the registry settings allow for user to send the error report
//
BOOL
RegSettingsAllowSend()
{
    HKEY hkey, hkeyDoRpt;
    BOOL fDoReport = FALSE;
    DWORD dw, cb;

    cb = sizeof(fDoReport);

    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRegErrRpt, 0,
                      KEY_READ | KEY_WOW64_64KEY, &hkey) == ERROR_SUCCESS)
    {

        if (RegQueryValueEx(hkey, L"DoReport", NULL, NULL, (PBYTE)&fDoReport,
                            &cb) != ERROR_SUCCESS)
        {
            fDoReport = TRUE;
        }
        RegCloseKey(hkey);
        if (!fDoReport)
        {
            return FALSE;
        }
    }

    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, c_wszRegDWPolicy, 0,
                      KEY_READ | KEY_WOW64_64KEY, &hkey) == ERROR_SUCCESS)
    {
        ULONG TreeRpt=0, NeverUpload=0;

        if (RegQueryValueEx(hkey, L"DWFileTreeReport", NULL, NULL, (PBYTE)&TreeRpt,
                            &cb) != ERROR_SUCCESS)
        {
            TreeRpt = TRUE;
        }
        if (RegQueryValueEx(hkey, L"NeverUpload", NULL, NULL, (PBYTE)&NeverUpload,
                            &cb) != ERROR_SUCCESS)
        {
            NeverUpload = FALSE;
        }
        RegCloseKey(hkey);
        if (NeverUpload || !TreeRpt)
        {
            return FALSE;
        }
    }


    // If registry key did not exist we still want to report
    return TRUE;
}

//
// Retrive filevesion
//
HRESULT
GetAppFileVersion(
    LPWSTR wszAppName,
    PULONG pVersion           // Should be ULONG[4]
    )
{
    PVOID pVerBuf;
    ULONG dwSize;
    HRESULT Hr = S_OK;

    dwSize = GetFileVersionInfoSizeW(wszAppName, 0);

    pVerBuf = malloc(dwSize);
    if (!pVerBuf)
    {
        return E_OUTOFMEMORY;
    }

    if (GetFileVersionInfoW(wszAppName, 0, dwSize, pVerBuf))
    {
        VS_FIXEDFILEINFO *verinfo;
        UINT dwVerLen;

        if (VerQueryValueW(pVerBuf, L"\\", (LPVOID *)&verinfo, &dwVerLen))
        {
            pVersion[0] = verinfo->dwFileVersionMS >> 16;
            pVersion[1] = verinfo->dwFileVersionMS & 0xFFFF;
            pVersion[2] = verinfo->dwFileVersionLS >> 16;
            pVersion[3] = verinfo->dwFileVersionLS & 0xFFFF;

        } else
        {
            Hr = E_FAIL;
        }
    } else
    {
//        Hr = E_FAIL;
    }
    free ( pVerBuf );
    return Hr;
}

//
// Create a temp dir and return full path name of file
//
HRESULT
GetTempFileFullPath(
    LPWSTR wszFileName,
    LPWSTR *pwszFullPath
    )
{
    ULONG cch, cchFile, cchDir;
    ULONG Suffix;
    LPWSTR wszTempFile;

    if (pwszFullPath == NULL || wszFileName == NULL)
    {
        return E_INVALIDARG;
    }

    cchFile = wcslen(wszFileName);
    if (cchFile == 0)
    {
        return E_INVALIDARG;
    }

    cch = GetTempPathW(0, NULL);
    if (cch == 0)
    {
        return E_FAIL;
    }

    cch += cchFile+2+10;
    wszTempFile = (LPWSTR) malloc(cch * sizeof(WCHAR));
    if (wszTempFile == NULL)
    {
        return E_OUTOFMEMORY;
    }
    if (GetTempPathW(cch, wszTempFile) == 0 ||
        StringCchCatW(wszTempFile, cch, L"ACW.00") != S_OK)
    {
        free (wszTempFile);
        return E_FAIL;
    }
    cchDir = wcslen(wszTempFile);
    Suffix = 0;
    // Create temp dir for our files
    do
    {
        BOOL fRet;
        fRet = CreateDirectoryW(wszTempFile, NULL);
        if (fRet)
            break;

        wszTempFile[cchDir-2]     = L'0' + (WCHAR)(Suffix / 10);
        wszTempFile[cchDir-1]     = L'0' + (WCHAR)(Suffix % 10);
        Suffix++;
    }
    while (Suffix <= 100);

    if (Suffix > 100 ||
        StringCchCatW(wszTempFile, cch, L"\\") != S_OK ||
        StringCchCatW(wszTempFile, cch, wszFileName) != S_OK)
    {
        free (wszTempFile);
        return E_FAIL;
    }
    *pwszFullPath = wszTempFile;
    return S_OK;
}

typedef BOOL (APIENTRY *pfn_SDBGRABMATCHINGINFOW)(LPCWSTR, DWORD, LPCWSTR);
//////////////////////////////////////////////////////////////////////////
// GenerateAppCompatText
//         Generates application compatibility report in a temporary file
//         File is created un user temp directory
//////////////////////////////////////////////////////////////////////////
HRESULT
GenerateAppCompatText(
    LPWSTR wszAppName,
    LPWSTR *pwszAppCompatReport
    )
{
    HRESULT Hr;
    LPWSTR wszFile = NULL;
    HMODULE hMod = NULL;
    pfn_SDBGRABMATCHINGINFOW pSdbGrabMatchingInfo;

    if (pwszAppCompatReport == NULL)
    {
        return E_INVALIDARG;
    }

    hMod = LoadLibraryW(L"apphelp.dll");
    if (hMod == NULL)
    {
        return E_FAIL;
    } else
    {
        pSdbGrabMatchingInfo = (pfn_SDBGRABMATCHINGINFOW) GetProcAddress(hMod, "SdbGrabMatchingInfo");
        if (pSdbGrabMatchingInfo != NULL)
        {
            Hr = GetTempFileFullPath(L"appcompat.txt", &wszFile);
            if (SUCCEEDED(Hr))
            {
                if ((*pSdbGrabMatchingInfo)(wszAppName,
                                            GetAppCompatFlag(wszAppName),
                                            wszFile))
                {
                    *pwszAppCompatReport = wszFile;
                    FreeLibrary(hMod);
                    return S_OK;
                } else
                {
                    Hr = E_FAIL;
                }
                free (wszFile);
            }
        } else
        {
            Hr = E_FAIL;
        }
        FreeLibrary(hMod);
    }

    return E_FAIL;
}

//
// This allocates returns full file-path for wszFileName in same directory as wszDirFile
//
LPWSTR
GenerateFilePath(
    LPCWSTR wszDirFile,
    LPCWSTR wszFileName
    )
{
    ULONG cch;
    LPWSTR wszFile;

    if (!wszFileName || !wszDirFile)
    {
        return NULL;
    }

    // Build the filename
    cch = wcslen(wszDirFile) + 1;
    cch+= wcslen(wszFileName);

    wszFile = (LPWSTR) malloc(cch * sizeof(WCHAR));
    if (!wszFile)
    {
        return NULL;
    }
    StringCchCopyW(wszFile, cch, wszDirFile);
    LPWSTR wszTemp = wcsrchr(wszFile, L'\\');
    if (!wszTemp)
    {
        free (wszFile);
        return NULL;
    }
    wszTemp++;   *wszTemp = L'\0';
    StringCchCatW(wszFile, cch, wszFileName);
    return wszFile;
}

//
// Creates usrrpt.txt file and puts this data in it
//
HRESULT
BuildUserReport(
    LPWSTR wszProblemType,
    LPWSTR wszComment,
    LPWSTR wszAppComWiz,
    LPWSTR wszAppCompatFile,
    LPWSTR *pwszUserReport
    )
{

#define BYTE_ORDER_MARK           0xFEFF
    enum REPORT_TYPE {
        LT_ANSI,
        LT_UNICODE
    };
    LPWSTR wszFile, wszTemp;
    DWORD dwRptType = LT_UNICODE;
    static WCHAR wchBOM = BYTE_ORDER_MARK;
    ULONG cch;

    if (wszProblemType == NULL || wszComment == NULL || wszAppComWiz == NULL ||
        wszAppCompatFile == NULL || pwszUserReport == NULL)
    {
        return E_INVALIDARG;
    }


    // Build the filename
    wszFile = GenerateFilePath(wszAppCompatFile, L"usrrpt.txt");
    if (wszFile == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Now write data to the file
    //
    HANDLE hFile;
    hFile = CreateFileW(wszFile, GENERIC_READ | GENERIC_WRITE,
                        0, NULL,
                        CREATE_ALWAYS, 0, NULL);
    if (hFile == NULL ||
        hFile == INVALID_HANDLE_VALUE)
    {
        free (wszFile);
        return E_FAIL;
    }
#define ByteCount(wsz) wcslen(wsz)*sizeof(WCHAR)
    ULONG bw;
    if (!WriteFile(hFile, &wchBOM, sizeof(WCHAR), &bw, NULL ) ||
        !WriteFile(hFile, c_wszLblType, sizeof(c_wszLblType), &bw, NULL) ||
        !WriteFile(hFile, wszProblemType, ByteCount(wszProblemType), &bw, NULL) ||
        !WriteFile(hFile, c_wszLblACW, sizeof(c_wszLblACW), &bw, NULL) ||
        !WriteFile(hFile, wszAppComWiz, ByteCount(wszAppComWiz), &bw, NULL) ||
        !WriteFile(hFile, c_wszLblComment, sizeof(c_wszLblComment), &bw, NULL) ||
        !WriteFile(hFile, wszComment, min(ByteCount(wszComment), 2000*sizeof(WCHAR)), &bw, NULL))
    {
        CloseHandle(hFile);
        free (wszFile);
        return E_FAIL;
    }
    CloseHandle(hFile);
    *pwszUserReport = wszFile;
    return S_OK;
}

HRESULT
MyReportEREventDW(
    EEventType eet,
    LPCWSTR wszDump,
    SEventInfoW *pei
    )
{
    HMODULE hMod = NULL;
    pfn_REPORTEREVENTDW pReportEREventDW;
    HRESULT Hr = E_FAIL;

    hMod = LoadLibraryW(L"faultrep.dll"); //"H:\\binaries.x86chk\\"
    if (hMod == NULL)
    {
        return E_FAIL;
    } else
    {
        pReportEREventDW = (pfn_REPORTEREVENTDW) GetProcAddress(hMod, "ReportEREventDW");
        if (pReportEREventDW != NULL)
        {
            Hr = (HRESULT) (*pReportEREventDW)(eet, wszDump, pei);
        }
        FreeLibrary(hMod);
    }
    return Hr;
}

LPWSTR
GetDefaultServer( void )
{
    return (LPWSTR) c_wszServer;
}
HRESULT
ReportDwManifest(
    LPWSTR wszAppCompatFile,
    SEventInfoW *pei
    )
{
    LPWSTR  wszManifest;
    WCHAR   wszBuffer[500], wszBufferApp[MAX_PATH], wszDir[100];
    HANDLE  hManifest;
    HRESULT Hr;
    DWORD   dw, dwFlags, cbToWrite;
    LPWSTR  pwszServer, pwszBrand, pwszUiLcid;
    STARTUPINFOW        si;
    PROCESS_INFORMATION pi;

    wszManifest = GenerateFilePath(wszAppCompatFile, L"manifest.txt");

    if (!wszManifest)
    {
        return E_OUTOFMEMORY;
    }
    hManifest = CreateFileW(wszManifest, GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL);
    if (hManifest == INVALID_HANDLE_VALUE)
    {
        Hr = E_FAIL;
        goto exitReportDwManifest;
    }

    // write the leading 0xFFFE out to the file
    wszBuffer[0] = 0xFEFF;
    if (!WriteFile(hManifest, wszBuffer, sizeof(wszBuffer[0]), &dw,
             NULL))
    {
        Hr = E_FAIL;
        goto exitReportDwManifest;
    }



    // write out the server, LCID, Brand, Flags, & title
    //  Server=<server>
    //  UI LCID=GetSystemDefaultLCID()
    //  Flags=fDWWhister + fDWUserHKLM + headless if necessary
    //  Brand=<Brand>  ("WINDOWS" by default)
    //  TitleName=<title>

    pwszBrand = (LPWSTR) c_wszBrand;

    // determine what server we're going to send the data to.
    pwszServer = GetDefaultServer();

    dwFlags = fDwWhistler | fDwUseHKLM | fDwAllowSuspend | fDwMiniDumpWithUnloadedModules;

    dwFlags |= fDwUseLitePlea ;

    Hr = StringCbPrintfW(wszBuffer, sizeof(wszBuffer), c_wszManHdr,
                         pwszServer, GetUserDefaultUILanguage(), dwFlags, c_wszBrand);
    if (FAILED(Hr))
        goto exitReportDwManifest;
    cbToWrite = wcslen(wszBuffer);
    cbToWrite *= sizeof(WCHAR);
    Hr = WriteFile(hManifest, wszBuffer, cbToWrite, &dw, NULL) ? S_OK : E_FAIL;
    if (FAILED(Hr))
        goto exitReportDwManifest;

    // write out the title text
    if (pei->wszTitle != NULL)
    {
        LPCWSTR  wszOut;

        wszOut    = pei->wszTitle;
        cbToWrite = wcslen(wszOut);
        cbToWrite *= sizeof(WCHAR);

        Hr = WriteFile(hManifest, wszOut, cbToWrite, &dw, NULL) ? S_OK : E_FAIL;
        if (FAILED(Hr))
            goto exitReportDwManifest;
    }

    // write out dig PID path
    //  DigPidRegPath=HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\DigitalProductId

    if (!WriteFile(hManifest, c_wszManPID,
                   sizeof(c_wszManPID) - sizeof(WCHAR), &dw,
                   NULL))
    {
        Hr = E_FAIL;
        goto exitReportDwManifest;
    }

    // write out the registry subpath for policy info
    //  RegSubPath==Microsoft\\PCHealth\\ErrorReporting\\DW

    if (!WriteFile(hManifest, c_wszManSubPath,
                   sizeof(c_wszManSubPath) - sizeof(WCHAR), &dw,
                   NULL))
    {
        Hr = E_FAIL;
        goto exitReportDwManifest;
    }


    // write out the error message if we have one
    //  ErrorText=<error text read from resource>

    if (pei->wszErrMsg != NULL)
    {
        LPCWSTR wszOut;

        if (!WriteFile(hManifest, c_wszManErrText,
                       sizeof(c_wszManErrText) - sizeof(WCHAR), &dw,
                       NULL))
        {
            Hr = E_FAIL;
            goto exitReportDwManifest;
        }
        wszOut    = pei->wszErrMsg;
        cbToWrite = wcslen(wszOut);
        cbToWrite *= sizeof(WCHAR);

        if (!WriteFile(hManifest, wszOut, cbToWrite, &dw, NULL))
        {
            Hr = E_FAIL;
            goto exitReportDwManifest;
        }
    }

    // write out the header text if we have one
    //  HeaderText=<header text read from resource>

    if (pei->wszHdr != NULL)
    {
        LPCWSTR  wszOut;

        wszOut    = pei->wszHdr;
        cbToWrite = wcslen(wszOut);
        cbToWrite *= sizeof(WCHAR);

        if (!WriteFile(hManifest, c_wszManHdrText,
                       sizeof(c_wszManHdrText) - sizeof(WCHAR), &dw,
                       NULL) ||
            !WriteFile(hManifest, wszOut, cbToWrite, &dw, NULL))
        {
            Hr = E_FAIL;
            goto exitReportDwManifest;
        }
    }


    // write out the plea text if we have one
    //  Plea=<plea text>

    if (pei->wszPlea != NULL)
    {
        cbToWrite = wcslen(pei->wszPlea) * sizeof(WCHAR);
        if (!WriteFile(hManifest, c_wszManPleaText,
                       sizeof(c_wszManPleaText) - sizeof(WCHAR), &dw,
                       NULL) ||
            !WriteFile(hManifest, pei->wszPlea, cbToWrite, &dw, NULL))
        {
            Hr = E_FAIL;
            goto exitReportDwManifest;

        }
    }


    // write out the ReportButton text if we have one
    //  ReportButton=<button text>

    if (pei->wszSendBtn != NULL)
    {
        cbToWrite = wcslen(pei->wszSendBtn) * sizeof(WCHAR);
        if (!WriteFile(hManifest, c_wszManSendText,
                       sizeof(c_wszManSendText) - sizeof(WCHAR), &dw,
                       NULL) ||
            !WriteFile(hManifest, pei->wszSendBtn, cbToWrite, &dw, NULL))
        {
            Hr = E_FAIL;
            goto exitReportDwManifest;
        }
    }

    // write out the NoReportButton text if we have one
    //  NoReportButton=<button text>

    if (pei->wszNoSendBtn != NULL)
    {
        cbToWrite = wcslen(pei->wszNoSendBtn) * sizeof(WCHAR);
        if (!WriteFile(hManifest, c_wszManNSendText,
                               sizeof(c_wszManNSendText) - sizeof(WCHAR), &dw,
                               NULL) ||
            !WriteFile(hManifest, pei->wszNoSendBtn, cbToWrite, &dw, NULL))
        {
            Hr = E_FAIL;
            goto exitReportDwManifest;
        }
    }

    // write out the EventLog text if we have one
    //  EventLogSource=<button text>

    if (pei->wszEventSrc != NULL)
    {
        cbToWrite = wcslen(pei->wszEventSrc) * sizeof(WCHAR);
        if (!WriteFile(hManifest, c_wszManEventSrc,
                       sizeof(c_wszManEventSrc) - sizeof(WCHAR), &dw,
                       NULL) ||
            !WriteFile(hManifest, pei->wszEventSrc, cbToWrite, &dw, NULL))
        {
            Hr = E_FAIL;
            goto exitReportDwManifest;
        }
    }


    // write out the stage 1 URL if there is one
    //  Stage1URL=<stage 1 URL>

    if (pei->wszStage1 != NULL)
    {
        cbToWrite = wcslen(pei->wszStage1) * sizeof(WCHAR);
        if (!WriteFile(hManifest, pei->wszStage1, cbToWrite, &dw, NULL))
        {
            Hr = E_FAIL;
            goto exitReportDwManifest;
        }
    }


    // write out the stage 2 URL
    //  Stage2URL=<stage 2 URL>
    if (pei->wszStage2 != NULL)
    {
        cbToWrite = wcslen(pei->wszStage2) * sizeof(WCHAR);
        if (!WriteFile(hManifest, pei->wszStage2, cbToWrite, &dw, NULL))
        {
            Hr = E_FAIL;
            goto exitReportDwManifest;
        }
    }

    // write out files to collect if we have any
    //  DataFiles=<list of files to include in cab>

    if (pei->wszFileList != NULL)
    {
        cbToWrite = wcslen(pei->wszFileList) * sizeof(WCHAR);
        if (!WriteFile(hManifest, c_wszManFiles,
                       sizeof(c_wszManFiles) - sizeof(WCHAR), &dw,
                       NULL) ||
            !WriteFile(hManifest, pei->wszFileList, cbToWrite, &dw, NULL))
        {
            Hr = E_FAIL;
            goto exitReportDwManifest;
        }
    }

    // write out the final "\r\n"

    wszBuffer[0] = L'\r';
    wszBuffer[1] = L'\n';
    if (!WriteFile(hManifest, wszBuffer, 2 * sizeof(wszBuffer[0]), &dw,
                   NULL))
    {
        Hr = E_FAIL;
        goto exitReportDwManifest;
    }

    CloseHandle(hManifest);
    hManifest = INVALID_HANDLE_VALUE;

    // create the process
    GetSystemDirectoryW(wszDir, sizeof(wszDir)/sizeof(WCHAR));
    StringCbPrintfW(wszBufferApp, sizeof(wszBufferApp), c_wszDWExe, wszDir);
    StringCbPrintfW(wszBuffer, sizeof(wszBuffer), c_wszDWCmdLine, wszManifest);

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    si.cb = sizeof(si);

    // check and see if the system is shutting down.  If so, CreateProcess is
    //  gonna pop up some annoying UI that we can't get rid of, so we don't
    //  want to call it if we know it's gonna happen.
    if (GetSystemMetrics(SM_SHUTTINGDOWN))
    {
        Hr = E_FAIL;
        goto exitReportDwManifest;
    }

    // we're creating the process in the same user context that we're in
    si.lpDesktop = L"Winsta0\\Default";
    if (!CreateProcessW(wszBufferApp, wszBuffer, NULL, NULL, TRUE,
                        CREATE_DEFAULT_ERROR_MODE |
                        NORMAL_PRIORITY_CLASS,
                        NULL, wszDir, &si, &pi))
    {
        Hr = ERROR_APPRPT_DW_LAUNCH;
        goto exitReportDwManifest;
    }

    // don't need the thread handle & we gotta close it, so close it now
    CloseHandle(pi.hThread);
    pi.hThread = NULL;

    // wait 5 minutes for DW to close.  If it doesn't close by then, just
    //  return.
    dw = WaitForSingleObject(pi.hProcess, 5*60*1000);

    if (dw == WAIT_TIMEOUT)
    {
        CloseHandle(pi.hProcess);
        Hr = ERROR_APPRPT_DW_TIMEOUT;
        goto exitReportDwManifest;
    }
    else if (dw == WAIT_FAILED)
    {
        CloseHandle(pi.hProcess);
        goto exitReportDwManifest;
    }
    CloseHandle(pi.hProcess);

    GetExitCodeProcess(pi.hProcess, &dw);
    if (dw == STILL_ACTIVE)
    {
        // "DW process still active!"
        // Kill dw and let user know dw timed out
        TerminateProcess(pi.hProcess, 1);
        Hr = ERROR_APPRPT_DW_TIMEOUT;

    } else if (dw == 0)
    {
        Hr = S_OK;
    }
    else
    {
        Hr = E_FAIL;
    }

    pi.hProcess = NULL;



exitReportDwManifest:

    // Note again that we assume there was no previous impersonation token
    //  on the the thread before we did the impersonation above.

    if (hManifest != INVALID_HANDLE_VALUE)
        CloseHandle(hManifest);

    if (FAILED(Hr) || wszManifest != NULL)
    {
        DeleteFileW(wszManifest);
        free (wszManifest);
    }

    return Hr;

}

//
// Calls up faultrep.dll to launch DwWin for uploading the error report
//
HRESULT
UploadAppProblem(
    LPWSTR wszAppName,
    LPWSTR wszProblemType,
    LPWSTR wszUserComment,
    LPWSTR wszMiscData,
    LPWSTR wszAppCompatText
    )
{
    EEventType eet;
    SEventInfoW ei = {0};
    LPWSTR wszUerRpt = NULL;
    HRESULT Hr;
    LPWSTR wszFileList  = NULL;
    LPWSTR wszStage1URL = NULL;
    LPWSTR wszStage2URL = NULL;
    LPWSTR wszBaseName;
    ULONG cch;
    ULONG VerInfo[4];
    ULONG OffsetFromProbType;

    if ((wszAppName == NULL) || (wszProblemType == NULL) ||
        (wszMiscData == NULL) || (wszAppCompatText == NULL))
    {
        goto exitUpload;
    }

    if (wszUserComment == NULL)
    {
        wszUserComment = L"";
    }

    if (!RegSettingsAllowSend())
    {
        Hr = E_FAIL;
        goto exitUpload;
    }
    if ((Hr = GetAppFileVersion(wszAppName, &VerInfo[0])) != S_OK)
    {
        goto exitUpload;
    }

    if ((Hr = BuildUserReport(wszProblemType, wszUserComment, wszMiscData,
                              wszAppCompatText, &wszUerRpt)) != S_OK)
    {
        goto exitUpload;
    }

    OffsetFromProbType = GetProblemTypeId(wszProblemType);
    wszFileList = (LPWSTR) malloc((cch = (wcslen(wszAppCompatText) + wcslen(wszUerRpt) + 2)) * sizeof(WCHAR));
    if (!wszFileList)
    {
        Hr = E_OUTOFMEMORY;
        goto exitUpload;
    }
    StringCchPrintfW(wszFileList, cch, L"%ws|%ws", wszAppCompatText, wszUerRpt);

    wszBaseName = wcsrchr(wszAppName, L'\\');
    if (wszBaseName == NULL)
    {
        Hr = E_INVALIDARG;
        goto exitUpload;
    }
    wszBaseName++;
    cch = wcslen(wszBaseName) + sizeof(c_wszStage1)/sizeof(WCHAR) + 4*5 + 2;
    wszStage1URL = (LPWSTR) malloc( cch * sizeof (WCHAR));
    if (!wszStage1URL)
    {
        Hr = E_OUTOFMEMORY;
        goto exitUpload;
    }
    Hr = StringCchPrintfW(wszStage1URL, cch, c_wszStage1, wszBaseName,
                          VerInfo[0], VerInfo[1], VerInfo[2], VerInfo[3],
                          OffsetFromProbType);
    if (FAILED(Hr))
    {
        goto exitUpload;
    }

    cch = wcslen(wszBaseName) + sizeof(c_wszStage2)/sizeof(WCHAR) + 4*5 + 2;
    wszStage2URL = (LPWSTR) malloc( cch * sizeof (WCHAR));
    if (!wszStage2URL)
    {
        Hr = E_OUTOFMEMORY;
        goto exitUpload;
    }
    Hr = StringCchPrintfW(wszStage2URL, cch, c_wszStage2, wszBaseName,
                          VerInfo[0], VerInfo[1], VerInfo[2], VerInfo[3],
                          OffsetFromProbType);
    if (FAILED(Hr))
    {
        goto exitUpload;
    }

    eet = eetUseEventInfo;
    ei.cbSEI = sizeof(ei);
    ei.wszTitle  = L"Microsoft Windows";
    ei.wszErrMsg = L"Thank-you for creating an application compatibility report.";
    ei.wszHdr    = L"Report an Application Compatibility Issue";
    ei.wszPlea   = L"We have created an error report that you can send to help us improve "
        L"Microsoft Windows. We will treat this report as confidential and anonymous.";
    ei.wszEventName = L"User initiated report";
    ei.fUseLitePlea = FALSE;
    ei.wszStage1    = wszStage1URL;
    ei.wszStage2    = wszStage2URL;
    ei.wszCorpPath  = NULL;
    ei.wszSendBtn   = L"&Send Error Report";
    ei.wszNoSendBtn = L"&Don't Send";
    ei.wszFileList  = wszFileList;

    if ((Hr = ReportDwManifest(wszAppCompatText, &ei)) != S_OK)
//    if ((Hr = MyReportEREventDW(eet, NULL, &ei)) != S_OK)
    {
        // we failed
    }

exitUpload:

    if (wszFileList != NULL) free( wszFileList );
    if (wszStage1URL != NULL) free( wszStage1URL );
    if (wszStage2URL != NULL) free( wszStage2URL );

    // Delete all temporary files
    if (wszUerRpt != NULL)
    {
        DeleteFileW(wszUerRpt);
        free (wszUerRpt );
    }
    if (wszAppCompatText != NULL)
    {
        DeleteFileW(wszAppCompatText);
        wszBaseName = wcsrchr(wszAppCompatText, L'\\');
        if (wszBaseName)
        {
            *wszBaseName = L'\0';
            RemoveDirectoryW(wszAppCompatText);
            *wszBaseName = L'\\';
        }
    }
    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\cerclient.h ===
// CerClient.h : Declaration of the CCerClient

#ifndef __CERCLIENT_H_
#define __CERCLIENT_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <stdio.h>
#include <Wininet.h>
#include <exdisp.h>
#include <shlguid.h>



#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
/////////////////////////////////////////////////////////////////////////////
// CCerClient
class ATL_NO_VTABLE CCerClient : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ICerClient, &IID_ICerClient, &LIBID_CERUPLOADLib>,
	public CComControl<CCerClient>,
	public IPersistStreamInitImpl<CCerClient>,
	public IOleControlImpl<CCerClient>,
	public IOleObjectImpl<CCerClient>,
	public IOleInPlaceActiveObjectImpl<CCerClient>,
	public IViewObjectExImpl<CCerClient>,
	public IOleInPlaceObjectWindowlessImpl<CCerClient>,
	public IPersistStorageImpl<CCerClient>,
	public ISpecifyPropertyPagesImpl<CCerClient>,
	public IQuickActivateImpl<CCerClient>,
	public IDataObjectImpl<CCerClient>,
	public IProvideClassInfo2Impl<&CLSID_CerClient, NULL, &LIBID_CERUPLOADLib>,
	public CComCoClass<CCerClient, &CLSID_CerClient>,
	public IObjectSafetyImpl<CCerClient, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA >

{
public:
	CCerClient()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CERCLIENT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCerClient)
	COM_INTERFACE_ENTRY(ICerClient)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

BEGIN_PROP_MAP(CCerClient)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CCerClient)
	CHAIN_MSG_MAP(CComControl<CCerClient>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// ICerClient
public:
	STDMETHOD(GetSuccessCount)(/*[in]*/BSTR *Path, /*[in]*/BSTR *TransID, /*[out,retval]*/ VARIANT *RetVal);
	STDMETHOD(Upload1)(/*[in]*/BSTR *Path, /*[in]*/BSTR *TransID, /*[in]*/BSTR *FileName, /*[in]*/BSTR *IncidentID, /*[in]*/BSTR *RedirParam, /*[in]*/BSTR *Type, /*[out,retval]*/ VARIANT *RetCode);
	STDMETHOD(EndTransaction)(/*[in]*/BSTR *SharePath,/*[in]*/BSTR *TransID, /*[out,retval]*/ VARIANT *RetCode);
	STDMETHOD(RetryFile1)(/*[in]*/BSTR *Path,/*[in]*/BSTR *TransID,/*[in]*/BSTR *FileName,/*[in]*/BSTR *IncidentID, /*[in]*/BSTR *RedirParam,/*[out,retval]*/ VARIANT *RetCode);
	STDMETHOD(GetAllComputerNames)(/*[in]*/BSTR *Path, /*[in]*/BSTR *TransID, /*[in]*/ BSTR* FileList, /*[out,retval]*/ VARIANT *ReturnList);
	STDMETHOD(GetCompuerNames)(/*[in]*/BSTR *Path, /*[in]*/BSTR *TransID,/*[in]*/BSTR *FileList,/*[out,retval]*/VARIANT *RetFileList);
	STDMETHOD(Browse)(/*[in]*/BSTR *WindowTitle, /*[out,retval]*/ VARIANT *Path);
	STDMETHOD(GetFileNames)(/*[in]*/BSTR *Path, /*[in]*/BSTR *TransID, /*[in]*/ VARIANT *Count, /*[out,retval]*/ VARIANT *FileList);
	STDMETHOD(RetryFile)(/*[in]*/ BSTR *Path, /*[in]*/ BSTR *TransID, /*[in]*/ BSTR FileName, /*[out,retval]*/ VARIANT * RetCode);
	STDMETHOD(RetryTransaction)(/*[in]*/ BSTR *Path, /*[in]*/BSTR *TransID, /*[in]*/ BSTR *FileName, /*[out,retval]*/ VARIANT * RetVal);
	STDMETHOD(Upload)(/*[in]*/ BSTR *Path, /*[in]*/ BSTR *TransID, /*[in]*/BSTR *FileName, /*[in]*/ BSTR*IncidentID, /*[in]*/ BSTR *RedirParam, /*[out,retval]*/ VARIANT *RetCode);
	STDMETHOD(GetFileCount)(/*[in]*/ BSTR *bstrSharePath, /*[in]*/ BSTR *bstrTransactID, /*[in]*/ VARIANT *iMaxCount, /*[out,retval]*/ VARIANT *RetVal);

	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

		SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		LPCTSTR pszText = _T("ATL 3.0 : CerClient");
		TextOut(di.hdcDraw, 
			(rc.left + rc.right) / 2, 
			(rc.top + rc.bottom) / 2, 
			pszText, 
			lstrlen(pszText));

		return S_OK;
	}

		STDMETHODIMP SetClientSite (IOleClientSite *pClientSite)
	{
		_spUnkSite = pClientSite;
		return S_OK;
	}

	STDMETHODIMP GetSite (REFIID riid, LPVOID* ppvSite)
	{
	
		return _spUnkSite->QueryInterface(riid,ppvSite);
	}

	bool InApprovedDomain()
	{
		char ourUrl[INTERNET_MAX_URL_LENGTH];
		if (!GetOurUrl(ourUrl, sizeof ourUrl))
				return false;
		return IsApprovedDomain(ourUrl);
	}

     bool GetOurUrl(char* pszURL, int cbBuf)
	 {
        HRESULT hr;
        CComPtr<IServiceProvider> spSrvProv;
        CComPtr<IWebBrowser2> spWebBrowser;

		if (_spUnkSite == NULL)
			return false;
        hr = GetSite(IID_IServiceProvider, (void**)&spSrvProv);
        if (FAILED(hr))
           return false;

        hr = spSrvProv->QueryService(SID_SWebBrowserApp,
                                     IID_IWebBrowser2,
                                     (void**)&spWebBrowser);
        if (FAILED(hr))
           return false;

        CComBSTR bstrURL;
        if (FAILED(spWebBrowser->get_LocationURL(&bstrURL)))
           return false;

        WideCharToMultiByte(CP_ACP, 0, bstrURL, -1, pszURL, cbBuf,
                            NULL, NULL);

        return true;
     }

     bool IsApprovedDomain(char* ourUrl)
     {
        // Only allow http access.
        // You can change this to allow file:// access.
        // 
        if (GetScheme(ourUrl) != INTERNET_SCHEME_HTTPS)
           return false;

        char ourDomain[256];
        if (!GetDomain(ourUrl, ourDomain, sizeof(ourDomain)))
           return false;

        for (int i = 0; i < ARRAYSIZE(_approvedDomains); i++)
        {
           if (MatchDomains(const_cast<char*>(_approvedDomains[i]),
                            ourDomain))
           {
              return true;
           }
        }

        return false;
     }

     INTERNET_SCHEME GetScheme(char* url)
     {
        char buf[32];
        URL_COMPONENTS uc;
        ZeroMemory(&uc, sizeof uc);

        uc.dwStructSize = sizeof uc;
        uc.lpszScheme = buf;
        uc.dwSchemeLength = sizeof buf;

        if (InternetCrackUrl(url, lstrlen(url), ICU_DECODE, &uc))
           return uc.nScheme;
        else
           return INTERNET_SCHEME_UNKNOWN;
     }

     bool GetDomain(char* url, char* buf, int cbBuf)
     {
        URL_COMPONENTS uc;
        ZeroMemory(&uc, sizeof uc);

        uc.dwStructSize = sizeof uc;
        uc.lpszHostName = buf;
        uc.dwHostNameLength = cbBuf;

        return (InternetCrackUrl(url, lstrlen(url), ICU_DECODE, &uc)
                != FALSE);
     }

     // Return if ourDomain is within approvedDomain.
     // approvedDomain must either match ourDomain
     // or be a suffix preceded by a dot.
     // 
     bool MatchDomains(char* approvedDomain, char* ourDomain)
     {
        int apDomLen  = lstrlen(approvedDomain);
        int ourDomLen = lstrlen(ourDomain);

        if (apDomLen > ourDomLen)
           return false;

        if (lstrcmpi(ourDomain+ourDomLen-apDomLen, approvedDomain)
            != 0)
           return false;

        if (apDomLen == ourDomLen)
           return true;

        if (ourDomain[ourDomLen - apDomLen - 1] == '.')
           return true;

        return false;
     }

     private:
		 static char* _approvedDomains[6];
private:
	IOleClientSite *_spUnkSite;
	DWORD GetComputerNameFromCSV(wchar_t *CsvFileName, 
								 wchar_t *FileName,
								 wchar_t *ComputerName
							    );
	int   GetUploadServerName (wchar_t *RedirectorParam, 
							   wchar_t *Language,
							   wchar_t *ServerName
							);
	DWORD GetMachineName(wchar_t *Path, wchar_t *FileName, wchar_t *MachineName);
	int GetNewFileNameFromCSV(wchar_t *Path, wchar_t *transid, wchar_t *FileName,wchar_t *NewFileName);
};

#endif //__CERCLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\cerclient.cpp ===
// CerClient.cpp : Implementation of CCerClient

#include "stdafx.h"
#include "CERUpload.h"
#include "CerClient.h"
#include "ErrorCodes.h"
#include "Utilities.h"
#include <Wininet.h>
#include <shlobj.h>
#include <string.h>
#include <stdio.h>

char * CCerClient::_approvedDomains[] = { "ocatest",
											"oca.microsoft.com",
											"oca.microsoft.de",
											"oca.microsoft.fr",
											"ocadeviis",
											"ocajapan.rte.microsoft.com"};

// Utility Functions
DWORD CCerClient::GetMachineName(wchar_t*Path, wchar_t*FileName, wchar_t*MachineName)
{
	FILE		*hMappingFile = NULL;
	wchar_t		*Buffer		= NULL;
	int			ErrorCode		= 0;
	wchar_t		TempMachineName[512];
	wchar_t		*pSource;
	wchar_t		*pDest;
	wchar_t		FilePath[512];
	int			TabCount;
	wchar_t*	Currpos = NULL;

	
	ZeroMemory(TempMachineName, sizeof(TempMachineName));
	if (Path)
	{		
		if (sizeof Path < sizeof FilePath)
		{
			wcscpy (FilePath, Path);
			wcscat(FilePath,L"\\hits.log");
		}
		else
		{
			ErrorCode = FILE_DOES_NOT_EXIST;
			goto Done;
		}
	}
	else
	{
		ErrorCode = FILE_DOES_NOT_EXIST;
			goto Done;
	}
		

	if (!PathFileExistsW(FilePath))
	{
		wcscpy(MachineName,L"\0");
		ErrorCode = FILE_DOES_NOT_EXIST;
	}
	else
	{
		hMappingFile = _wfopen(FilePath, L"r");

		Buffer = (wchar_t *) malloc(1024 *sizeof(wchar_t));
		if (!Buffer)
		{
			ErrorCode = 2;

		}
		else
		{
			if (hMappingFile == NULL)
			{
				ErrorCode = 1;
			}
			else
			{
				// Search the file for the last occurence of FileName and
				// Retrieve the Computer Name
				// We want the last occurence of the filename since there may 
				// be duplicates.
				ZeroMemory(Buffer,1024 *sizeof(wchar_t));
				while (fgetws(Buffer,1024,hMappingFile) != NULL)
				{
					if (wcscmp(Buffer,L"\0"))
					{
						// locate the file name.
						TabCount = 0;
						Currpos = Buffer;
						while (TabCount < 3)
						{
							++Currpos;
							if (*Currpos == L'\t')
								++TabCount;
						}
						// Skip the tab
						++Currpos;
						Buffer[ wcslen(Buffer) - 1] = L'\0';
						if (! wcscmp(FileName,Currpos))
						{

							
							// copy the machine name into a temp variable
							// The file is tab formatted and the machine name is in the second position
							pSource = Buffer;
							pDest	= TempMachineName;
							while (*pSource != L'\t')
								++pSource;
							++pSource; // Skip the tab
							while ( (*pSource != L'\t') && (*pSource != L'\0') && (*pSource != L' ') )
							{
								*pDest = *pSource;
								++pSource;
								++pDest;
							}
							// Null Terminate the Machine Name
							*pDest = L'\0';

							
						}
					}
					// Clear the buffer
					ZeroMemory(Buffer, sizeof (Buffer));
				}
			}

			
			if (Buffer)
			{
				free (Buffer);
				Buffer = NULL;
			}

			// If we found a machine name convert it to unicode.
			// and return it.
			if (TempMachineName[0] == L'\0')
			{
				wcscpy(MachineName,L"\0");
				ErrorCode = 3; // No Machine Name Found
			}
			else
			{
				ErrorCode = 0;
				wcscpy (MachineName,TempMachineName);
			}
			
		
		}
	}
	// Close the File
	if (Buffer != NULL)
		free(Buffer);
	if (hMappingFile != NULL)
		fclose(hMappingFile);
Done:
	return ErrorCode;
}

/////////////////////////////////////////////////////////////////////////////
// CCerClient


STDMETHODIMP 
CCerClient::GetFileCount(
		  BSTR *bstrSharePath, 
		  BSTR *bstrTransactID, 
		  VARIANT *iMaxCount, 
		  VARIANT *RetVal)
{
	// TODO: Add your implementation code here
	wchar_t				*TranslogName = NULL;			// Name of temperary transaction file
	DWORD				TranslogNameLength = 0;
	int					ErrorCode = 3000;
	HANDLE				hTransactLog = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATAW	FindFile;
	int					FileCount = 0;
	HANDLE				hFindFile;
	CComBSTR			FileList = L"";
	DWORD				dwWritten;
	wchar_t				Msg[255];
	WORD				ByteOrderMark = 0xFEFF;
	RetVal->vt = VT_INT;
	int					MaxCount = 0;
//	ZeroMemory(FileList,sizeof (FileList));



	switch(iMaxCount->vt)
	{
	case VT_INT:
		MaxCount = iMaxCount->intVal;
		break;
	case VT_I2:
		MaxCount = iMaxCount->iVal;
		break;
	default:
		MaxCount = iMaxCount->iVal;
	}
	
	wsprintfW(Msg, L"MaxCount = %d",MaxCount);
	if ( (MaxCount <= 0) || (MaxCount > 60000) ) 
	{
		ErrorCode = BAD_COUNT_VALUE;
	}
	else
	{
		//::MessageBoxW(NULL,Msg,L"MaxCount",MB_OK);	
		//::MessageBoxW(NULL,*bstrSharePath, L"Share Path",MB_OK);

		if ( ( *bstrSharePath == NULL) || (!wcscmp ( *bstrSharePath, L"\0")) )
		{
			ErrorCode = NO_SHARE_PATH;
		}
		else
		{
			if (!PathIsDirectoryW(*bstrSharePath))
			{
				ErrorCode = NO_SHARE_PATH;
			}

			else
			{
				// Did we get a transaction id 
				if ( ( *bstrTransactID == NULL) || (!wcscmp ( *bstrTransactID, L"\0")) )
				{
					ErrorCode = NO_TRANS_ID;
				}

				else
				{
					DWORD transid = 0;
					wchar_t *terminator = NULL;
					
					

					
						TranslogNameLength = (wcslen (*bstrSharePath) +
											  wcslen(*bstrTransactID) + 
											  17) 
											  * sizeof (wchar_t);
						
						TranslogName = (wchar_t *) malloc(TranslogNameLength);
						if (TranslogName == NULL)
						{
							ErrorCode = OUT_OF_MEMORY;
						}
						else
						{
							// Create our transaction log file if it does not exist
							wsprintfW(TranslogName, L"%s\\%s.txt", 
									  *bstrSharePath, 
									  *bstrTransactID);
							
			//				::MessageBoxW(NULL, L"Createing Transaction log", L"TranslogName",MB_OK);
							hTransactLog = CreateFileW(TranslogName,
													  GENERIC_WRITE,
													  NULL,
													  NULL,
													  CREATE_ALWAYS,
													  FILE_ATTRIBUTE_NORMAL,
													  NULL);
							if (hTransactLog == INVALID_HANDLE_VALUE)
							{
								ErrorCode = FILE_CREATE_FAILED;
							}
							else
							{
								// Now we have the file open see if any entries already exist
												
								// If yes how many more can we add
							
								// Now add up to MaxCount cab files to the transaction log.

								wchar_t SearchPath[MAX_PATH];
								wsprintfW(SearchPath,L"%s\\*.cab",*bstrSharePath);
								hFindFile = FindFirstFileW(SearchPath,&FindFile);
								if (hFindFile != INVALID_HANDLE_VALUE)
								{
									do
									{
										if (! (FindFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
										{
											// Check to see if the file has an extension like
											// Cabbage etc..

											if (FindFile.cFileName[wcslen(FindFile.cFileName) - 4] == L'.')
											{
												// we are ok keep going
												++ FileCount;
												FileList += FindFile.cFileName;
												//wcscat(FileList,FindFile.cFileName);
												FileList += L"\r\n";
											}

										}


									}
									while ( (FindNextFileW(hFindFile, &FindFile)) && (FileCount < (MaxCount) ));
									
								
									// Write the file list to the transaction log
									WriteFile(hTransactLog, &ByteOrderMark,2,&dwWritten,NULL);
									WriteFile(hTransactLog,
											  FileList,
											  wcslen(FileList) * sizeof(wchar_t),
											  &dwWritten,
											  NULL);
									
									CloseHandle(hTransactLog);
									hTransactLog = INVALID_HANDLE_VALUE;
									FindClose(hFindFile);
									// return the count of added files.
									
									ErrorCode = FileCount;
									
								}
								else
								{
									ErrorCode = 0;
								}
							}
						}
					
				}
			}
		}
	}

	RetVal->intVal = ErrorCode;
	if (hTransactLog != INVALID_HANDLE_VALUE)
		CloseHandle(hTransactLog);
	if (TranslogName != NULL)
		free (TranslogName);
	return S_OK;
}


/* 
	Purpose: Upload a file that is part of a transaction via 
			 The microsoft redirector through HTTP
*/
STDMETHODIMP 
CCerClient::Upload(
	BSTR *Path, 
	BSTR *TransID, 
	BSTR *FileName, 
	BSTR *IncidentID, 
	BSTR *RedirParam, 
	VARIANT *RetCode
	)
{
	return E_NOINTERFACE ;

}

STDMETHODIMP 
CCerClient::RetryTransaction(
	BSTR *Path, 
	BSTR *TransID, 
	BSTR *FileName, 
	VARIANT *RetVal
	)
{
	// TODO: Add your implementation code here
	
	return E_NOINTERFACE ;
}

STDMETHODIMP 
CCerClient::RetryFile(
	BSTR *Path, 
	BSTR *TransID, 
	BSTR FileName, 
	VARIANT *RetCode
	)
{


	return E_NOINTERFACE ;
}

// Get Upload Server Name
int
CCerClient::
GetUploadServerName (
	wchar_t*	RedirectorParam, 
	wchar_t*	Language,
	wchar_t*	ServerName
	)
{

	DWORD				ErrorCode				= 0;
	HINTERNET			hRedirUrl				= NULL;
	wchar_t*			pUploadUrl				= NULL;
	HINTERNET			hSession;
	BOOL				bRet					= TRUE;
	DWORD				dwLastError				= FALSE;
	URL_COMPONENTSW		urlComponents;
	DWORD				dwUrlLength				= 0;
	wchar_t				ConnectString [255];


	if (Language )
	{
		wsprintfW(ConnectString,L"http://go.microsoft.com/fwlink/?linkid=%s",RedirectorParam);

	}
	else
	{
		wsprintfW(ConnectString,L"http://go.microsoft.com/fwlink/?linkid=%s",RedirectorParam);
	
	}

	hSession = InternetOpenW(L"CerClient Control",
							   INTERNET_OPEN_TYPE_PRECONFIG,
                               NULL,
							   NULL,
							   0);

	if (!hSession)
	{
		ErrorCode = GetLastError();
		return ErrorCode;
	}

	hRedirUrl = InternetOpenUrlW(hSession, ConnectString, NULL, 0, 0, 0);
	if(!hRedirUrl)
	{
		ErrorCode = GetLastError();
		InternetCloseHandle(hSession);
		return ErrorCode;
	}

	// Get the URL returned from the MS Corporate IIS redir.dll isapi URL redirector

	dwUrlLength = 512;

	pUploadUrl = (wchar_t*)malloc(dwUrlLength);

	if(!pUploadUrl)
	{
		//ReturnCode->intVal = GetLastError();
		ErrorCode = GetLastError();
		InternetCloseHandle(hSession);
		InternetCloseHandle(hRedirUrl);
		return ErrorCode;
	
	}
	do
	{
		ZeroMemory(pUploadUrl, dwUrlLength);
		bRet = InternetQueryOptionW(hRedirUrl, INTERNET_OPTION_URL, pUploadUrl, &dwUrlLength);
		if(!bRet)
		{
			dwLastError = GetLastError();
			// If last error was due to insufficient buffer size, create a new one the correct size.
			if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
			{
				free(pUploadUrl);
				pUploadUrl = (wchar_t*)malloc(dwUrlLength);
				if(!pUploadUrl)
				{
					ErrorCode = GetLastError();
					InternetCloseHandle(hSession);
					InternetCloseHandle(hRedirUrl);
					if (pUploadUrl)
						free (pUploadUrl);
					return ErrorCode;
				}
			}
			else
			{
				ErrorCode = GetLastError();
				InternetCloseHandle(hSession);
				InternetCloseHandle(hRedirUrl);
				if (pUploadUrl)
					free (pUploadUrl);
				return ErrorCode;
			}
		}
	}while(!bRet);

	
	// Strip out the host name from the URL
	ZeroMemory(&urlComponents, sizeof(URL_COMPONENTSW));
	urlComponents.dwStructSize = sizeof(URL_COMPONENTSW);
	urlComponents.lpszHostName = NULL;
	urlComponents.dwHostNameLength = 512;
	
	urlComponents.lpszHostName = (wchar_t*)malloc(urlComponents.dwHostNameLength );
	if(!urlComponents.lpszHostName)
	{
		ErrorCode = GetLastError();
		InternetCloseHandle(hSession);
		InternetCloseHandle(hRedirUrl);
		if (pUploadUrl)
			free (pUploadUrl);
		return ErrorCode;
	}
		
	do
	{
			
		ZeroMemory(urlComponents.lpszHostName, urlComponents.dwHostNameLength);
		bRet = InternetCrackUrlW(pUploadUrl, dwUrlLength, 0, &urlComponents);
		if(!bRet)
		{
			dwLastError = GetLastError();
			// If last error was due to insufficient buffer size, create a new one the correct size.
			if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
			{
				if (urlComponents.lpszHostName != NULL)
					free(urlComponents.lpszHostName);
				if ( (urlComponents.lpszHostName = (wchar_t*)malloc(urlComponents.dwHostNameLength) )!= NULL)
				{
					ZeroMemory(urlComponents.lpszHostName,urlComponents.dwHostNameLength);
				}
				else
				{
					ErrorCode = GetLastError();
					InternetCloseHandle(hSession);
					InternetCloseHandle(hRedirUrl);
					if (pUploadUrl)
						free (pUploadUrl);
					return ErrorCode;
				
				}
			}
			else
			{
				ErrorCode = GetLastError();
				InternetCloseHandle(hSession);
				InternetCloseHandle(hRedirUrl);
				if (pUploadUrl)
					free (pUploadUrl);
				return ErrorCode;
			}
		}
		
	}while(!bRet);

	if (hRedirUrl) 
		InternetCloseHandle(hRedirUrl);
	if (hSession)
		InternetCloseHandle(hSession);
	if (pUploadUrl)
		free (pUploadUrl);

	wcscpy (ServerName, (wchar_t *)urlComponents.lpszHostName);
	
	if (urlComponents.lpszHostName) 
		free (urlComponents.lpszHostName);
	return 0;
	
}
STDMETHODIMP 
CCerClient::GetFileNames(
	BSTR *Path, 
	BSTR *TransID, 
	VARIANT *Count, 
	VARIANT *FileList
	)
{
	wchar_t *OldFileList= NULL;					// Files contained in Transid.Queue.log
	wchar_t *NewFileList= NULL;					// Files to be re-written to Transid.Queue.log
	CComBSTR RetFileList = L"";				// List of files to return.
	HANDLE hTransIDLog	= INVALID_HANDLE_VALUE;					// Handle to original Transid.Queue.Log file
	wchar_t LogFilePath[MAX_PATH];		// Path to Transid.queue.log file
	wchar_t *Temp;

	DWORD dwFileSize;
	DWORD dwBytesRead;
	DWORD dwBytesWritten;
	int	  ErrorCode = 0;
	WORD  ByteOrderMark = 0xFEFF;

	int   MaxCount;
	
	
	switch (Count->vt)
	{
	case VT_INT:
		MaxCount = Count->intVal;
		break;
	case VT_I2:
		MaxCount = Count->iVal;
		break;
	default:
		MaxCount = Count->iVal;
	}

//	WCHAR Msg[255];




//	wsprintfW(Msg,L"Path: %s, TransID: %s, Count: %d, MaxCount: %d",*Path, *TransID, Count->iVal, MaxCount);
//	::MessageBoxW(NULL,Msg,L"Getting File Names",MB_OK);
	if ( ( *Path == NULL) || (!wcscmp ( *Path, L"\0")) )
	{
		ErrorCode = NO_SHARE_PATH;
	}
	else
	{
		// Build path to original TransID.queue.log file.
		wsprintfW (LogFilePath,L"%s\\%s.txt",*Path, *TransID);
	
		// Open the List of queued files. 
		hTransIDLog = CreateFileW(LogFilePath,
								 GENERIC_READ,
								 NULL,
								 NULL,
								 OPEN_EXISTING,
								 FILE_ATTRIBUTE_NORMAL,
								 NULL);

		// Find out where we left off.

		if (hTransIDLog == (INVALID_HANDLE_VALUE))
		{
			ErrorCode = FILE_OPEN_FAILED;
		}
		else
		{
			dwFileSize = GetFileSize(hTransIDLog,NULL);
			OldFileList = (wchar_t*) malloc (dwFileSize * 3);
			NewFileList = (wchar_t*) malloc (dwFileSize * 3);

			
			
			if ( (!OldFileList)  || (!NewFileList))
			{

				ErrorCode = OUT_OF_MEMORY;

				if (NewFileList)	free (NewFileList);
				if (OldFileList)	free (OldFileList);
			}
			else
			{
				ZeroMemory (OldFileList, dwFileSize * 2);
				ZeroMemory (NewFileList, dwFileSize * 2);
				if (!
				ReadFile(hTransIDLog, OldFileList,
						 dwFileSize,&dwBytesRead,NULL))
				{
					
					CloseHandle(hTransIDLog);
					goto Done;
				}
				CloseHandle (hTransIDLog);
				hTransIDLog = INVALID_HANDLE_VALUE;
				if (dwBytesRead == 0)
				{
					ErrorCode = FILE_READ_FAILED;
				}
				else
				{
					// read through the file buffer until we find a filename that 
					// does not start with a -

					Temp =		OldFileList;
					wchar_t*	pNewFileList=NULL;
					wchar_t		FileName[MAX_PATH];
					DWORD		CharCount = dwFileSize;
					

				
						++Temp;
						--CharCount;
						
					
					pNewFileList = NewFileList;

					if (*Temp == L'-')
					{
						BOOL Done = FALSE;
						// Lets find our starting position
						do 
						{
							while( (*Temp != L'\n') && ((CharCount > 0)  && (CharCount <= dwFileSize) ))
							{
								
								*pNewFileList = *Temp;
								++Temp;
								--CharCount;
								++pNewFileList;
							}
							*pNewFileList = *Temp;
							++pNewFileList;
							++Temp;	// Skip over the newline
							--CharCount;
							if (*Temp != L'-')
								Done = TRUE;

							*pNewFileList = L'\0';

						} while ( (!Done) && ( (CharCount > 0)  && (CharCount <= dwFileSize) ));

					}
					if ( (CharCount > 0) && (CharCount <= dwFileSize) )
					{
						// Now build the lists....
						int dwFileCount = 0;
						wchar_t	*NewFL;

					//	wsprintfW(Msg, L"MaxCount = %d", MaxCount);
					//	::MessageBoxW(NULL,Msg,L"MAX_COUNT",MB_OK);
						while ( (dwFileCount < MaxCount) &&
							    (CharCount > 0) && (CharCount < dwFileSize) )
						{
						
							ZeroMemory (FileName, sizeof(FileName));
							NewFL = FileName;
							*NewFL = *Temp;

							++NewFL;
							++Temp;
							-- CharCount;

							// Copy characters until we hit a carriage return
							while ( (*Temp != L'\r') && ( (CharCount > 0)  && (CharCount <= dwFileSize) ))
							{
								*NewFL = *Temp;
								++ NewFL;
								++ Temp;
								-- CharCount;
								*NewFL = L'\0';
							}
							
							// Add the new file name to the Return File List string
						
							if (wcslen (FileName) > 0)
							{

								
								RetFileList += FileName;
								RetFileList += L";";

							
								dwFileCount++;
								// only add the cr and lf codes to the NewFileList string.
								*NewFL = *Temp;
								
								++NewFL;
								++Temp;
								--CharCount;

								
								*NewFL = *Temp;
								++ Temp;
								--CharCount;
								
								
								wcscat(NewFileList,L"-");
								wcscat(NewFileList,FileName);
							}
							
						}
					
						// Delete the Current transaction queue file
					
							if (!DeleteFileW(LogFilePath) )
							{
								//::MessageBoxW(NULL,L"Failed to delete .txt file",NULL,MB_OK);
								;
							}

							hTransIDLog = CreateFileW( LogFilePath,
													  GENERIC_WRITE,
													  NULL,
													  NULL,
													  CREATE_ALWAYS,
													  FILE_ATTRIBUTE_NORMAL,
													  NULL);

							if (hTransIDLog != INVALID_HANDLE_VALUE)
							{
								WriteFile(hTransIDLog, &ByteOrderMark,2,&dwBytesWritten,NULL);
							
								WriteFile(hTransIDLog,
										  NewFileList,
										  wcslen(NewFileList) * sizeof(wchar_t),
										  &dwBytesWritten,
										  NULL);
								WriteFile(hTransIDLog,
										  Temp,
										  wcslen(Temp) * sizeof(wchar_t),
										  &dwBytesWritten,
										  NULL);
								CloseHandle(hTransIDLog);
								hTransIDLog = INVALID_HANDLE_VALUE;
							}
					
					}
					if (NewFileList)
						free (NewFileList);
					if (OldFileList)
						free (OldFileList);
																
				}

			}

		}
		
		
	}
	if (hTransIDLog != INVALID_HANDLE_VALUE)
		CloseHandle(hTransIDLog);

//	::MessageBoxW(NULL,RetFileList,L"Returning these files after Write",MB_OK);
	
//	wsprintfW(Msg, L"Error code = %d", ErrorCode);
//	::MessageBoxW(NULL,Msg,L"Current Error Status",MB_OK);

Done:
	FileList->vt = VT_BSTR;
	FileList->bstrVal = RetFileList.Detach();

	if(NewFileList)
		free(NewFileList);
	if(OldFileList)
		free(OldFileList);
	
	return S_OK;
}

STDMETHODIMP CCerClient::Browse(BSTR *WindowTitle, VARIANT *Path)
{
	BROWSEINFOW BrowseInfo;
	CComBSTR    SharePath = L"";
	LPMALLOC	lpMalloc;
	HWND		hParent;
	LPITEMIDLIST pidlSelected = NULL;
	wchar_t		TempPath[MAX_PATH];

	CComBSTR	WindowText = *WindowTitle;
	WindowText	 += L" - Microsoft Internet Explorer";

	hParent = FindWindowExW(NULL,NULL,L"IEFrame",WindowText);


	ZeroMemory (&BrowseInfo,sizeof(BROWSEINFO));
	BrowseInfo.hwndOwner = hParent;
	BrowseInfo.ulFlags   = BIF_USENEWUI | BIF_EDITBOX;


	if(::SHGetMalloc(&lpMalloc) == NOERROR)
	{
		pidlSelected = SHBrowseForFolderW(&BrowseInfo);
	
		if (::SHGetPathFromIDListW(pidlSelected, TempPath))
	
		lpMalloc->Release();  
		SharePath+=TempPath;

	}
	Path->vt = VT_BSTR;
	Path->bstrVal = SharePath.Detach();

	return S_OK;
}


DWORD 
CCerClient::GetComputerNameFromCSV(
									wchar_t* CsvFileName,
									wchar_t* FileName,
									wchar_t* ComputerName
								  )
{
	wchar_t	*Buffer = NULL;
	BOOL	Done = FALSE;
	HANDLE   hCsv = INVALID_HANDLE_VALUE;
	wchar_t  TempFileName[MAX_PATH];
	wchar_t  *Source = NULL;
	wchar_t  *Dest   = NULL;
	DWORD    FileSize = 0;
	DWORD    dwBytesRead = 0;
	// Move to the beginning of the file.
	//::MessageBoxW(NULL,L"Getting the ComputerName from the CSV file",NULL,MB_OK);
	hCsv = CreateFileW(CsvFileName,
					  GENERIC_READ,
					  NULL,
					  NULL,
					  OPEN_EXISTING,
					  FILE_ATTRIBUTE_NORMAL,
					  NULL);

	if (hCsv != INVALID_HANDLE_VALUE)
	{
		FileSize = GetFileSize(hCsv,NULL);

		if (FileSize > 0)
		{
			if ((Buffer = ( (wchar_t *) malloc (FileSize * 2))) == NULL)
			{
				CloseHandle(hCsv);
				return 0;
			}
		}
		else
		{
			CloseHandle(hCsv);
			return 0;
		}
		// Now look for the Filename 
		ZeroMemory(TempFileName,MAX_PATH * sizeof(wchar_t));
		ZeroMemory(Buffer,FileSize * 2);
	if (!ReadFile(hCsv,
				 Buffer,
				 FileSize * 2,
				 &dwBytesRead,
				 NULL))
	{
		CloseHandle (hCsv);
		goto Done;
	}

		Source = Buffer;
		int Testing = IS_TEXT_UNICODE_SIGNATURE;
			// If the unicode header bytes appear remove skip past them
		if (IsTextUnicode(Buffer,FileSize * 2,&Testing))
		{
			++Source;		
		}
		while (! Done)
		{
		
			
			
			Dest   = TempFileName;
			while  ( (*Source != L'\r') && 
					 (*Source != L'\0') && 
					 (*Source != L',')  )
			{
				*Dest = *Source;
				++Source;
				++Dest;
			}
			// Null Terminate the destination string.
			*Dest = L'\0';

			if (!wcscmp(TempFileName, FileName))
			{
				++Source; // Skip the Comma
				// Now copy the computer name into ComputerName
				Dest = ComputerName;
				while ( *Source != L',' ) 
				{
					*Dest = *Source;
					++Dest;
					++Source;
				}
				// Null Terminate the ComputerName
				*Dest = L'\0';
				Done = TRUE;
			}
			else
			{
				ZeroMemory(TempFileName,MAX_PATH * sizeof(wchar_t));
				while ((*Source != L'\n') && (*Source != L'\0'))
					++ Source;
				if (*Source != L'\0')
					++Source; // skip the newline
				else
					Done = TRUE;
				
			}
		
		}
		CloseHandle(hCsv);
	}
Done:
	if (Buffer)
		free (Buffer);

	return 1;
}

// Purpose: Given a list of comma seperated file names 
//			Return the list as filename,computername; etc...



STDMETHODIMP CCerClient::GetCompuerNames(BSTR *Path, BSTR *TransID, BSTR *FileList, VARIANT *RetFileList)
{
	return E_NOINTERFACE ;
}

STDMETHODIMP CCerClient::GetAllComputerNames(BSTR *Path, BSTR *TransID, BSTR *FileList, VARIANT *ReturnList)
{
		wchar_t		CsvFileName[MAX_PATH];
//	BOOL		Done					= FALSE;
	CComBSTR	FinalList				= L"";
//	FILE		*hCsv					= NULL;
	wchar_t		FileName[MAX_PATH];
	wchar_t		*Source					= NULL;
	wchar_t		*Dest					= NULL;
	wchar_t		ComputerName[MAX_PATH];
	BOOL		Done2					= FALSE;
	
	//::MessageBoxW(NULL,*Path,L"Path to files",MB_OK);
	//::MessageBoxW(NULL,*TransID,L"TransID",MB_OK);
	//::MessageBoxW(NULL,*FileList,L"File List",MB_OK);
	ZeroMemory (ComputerName, MAX_PATH *sizeof(wchar_t));
	if (PathIsDirectoryW(*Path)) 
	{
		// Build csv file name
		wsprintfW(CsvFileName, L"%s\\%s.csv",*Path,*TransID);
		//::MessageBoxW(NULL,CsvFileName,L"Looking for CSV File: ",MB_OK);
		if (PathFileExistsW(CsvFileName))
		{
		 	// now go through the file list and get the machine names
				
			Source = *FileList;
			while(!Done2)
			{
				//::MessageBoxW(NULL,L"Inside the while loop",NULL,MB_OK);
				ZeroMemory(FileName, MAX_PATH );
				Dest   = FileName;
				while  ((*Source != L'\r') && 
				     (*Source != L'\0') && (*Source != L',') )
				{
					*Dest = *Source;
					++Source;
					++Dest;
				}
				
				// Null Terminate the destination string.
				*Dest = L'\0';
				Dest = FileName;
				if (!wcscmp(Dest, L"\0"))
				    Done2 = TRUE;
				else
				{
					// Get the ComputerName;
					//::MessageBoxW(NULL,FileName, L"Getting computer name for file: ",MB_OK);

					if (GetComputerNameFromCSV(CsvFileName, FileName, ComputerName))
					{
						//::MessageBoxW(NULL,ComputerName,L"Computer Name Found: ",MB_OK);
						// add the file Name and computer name to the return list
						FinalList+= FileName;
						FinalList += L",";
						FinalList += ComputerName;
						FinalList += L";";
					}
				}
				if (*Source == L'\0')
				   Done2 = TRUE;
				else
				   ++Source;
			}
			
		}
		else
		{
			//MessageBoxW(NULL,L"Failed to locate CSV File",CsvFileName,MB_OK)
			ReturnList->vt = VT_INT;
			ReturnList->intVal = FILE_DOES_NOT_EXIST;
			return S_OK;
		}
	}

	ReturnList->vt = VT_BSTR;
	ReturnList->bstrVal = FinalList.Detach();
	return S_OK;
}

int 
CCerClient::GetNewFileNameFromCSV(wchar_t *Path, wchar_t *transid, wchar_t *FileName,wchar_t *NewFileName)
{
	wchar_t		CsvFileName[MAX_PATH];
	wchar_t		*Buffer = NULL;
	BOOL		Done = FALSE;
	HANDLE		hCsv = INVALID_HANDLE_VALUE;
	wchar_t		TempFileName[MAX_PATH];
	wchar_t		*Source = NULL;
	wchar_t		*Dest   = NULL;
	DWORD		FileSize = 0;
	DWORD		dwBytesRead = 0;
	// Move to the beginning of the file.
	wsprintfW(CsvFileName,L"%s\\%s.csv",Path,transid);
	wcscpy (NewFileName,L"\0");
	hCsv = CreateFileW(CsvFileName,
					  GENERIC_READ,
					  NULL,
					  NULL,
					  OPEN_EXISTING,
					  FILE_ATTRIBUTE_NORMAL,
					  NULL);

	if (hCsv != INVALID_HANDLE_VALUE)
	{
		FileSize = GetFileSize(hCsv,NULL);
		if (FileSize > 0)
		{
			if ( (Buffer = (wchar_t *) malloc (FileSize * 2)) ==NULL)
			{
				CloseHandle(hCsv);
				return 0;
			}
		}
		else
		{
			CloseHandle(hCsv);
			return 0;
		}
		// Now look for the Filename 
		ZeroMemory(TempFileName,MAX_PATH * sizeof(wchar_t));
		ZeroMemory(Buffer,FileSize * 2);
	if (!ReadFile(hCsv,
				 Buffer,
				 FileSize * 2,
				 &dwBytesRead,
				 NULL))
	{
		CloseHandle(hCsv);
		goto Done;
	}

		Source = Buffer;
		int Testing = IS_TEXT_UNICODE_SIGNATURE;
			// If the unicode header bytes appear remove skip past them
		if (IsTextUnicode(Buffer,FileSize * 2,&Testing))
		{
			++Source;		
		}
		while (! Done)
		{
		
			
			
			Dest   = TempFileName;
			while  ( (*Source != L'\r') && 
					 (*Source != L'\0') && 
					 (*Source != L',')  )
			{
				*Dest = *Source;
				++Source;
				++Dest;
			}
			// Null Terminate the destination string.
			*Dest = L'\0';

			if (!wcscmp(TempFileName, FileName))
			{

				// We found the original file name now retrieve the new file name

				++Source; // Skip the Comma

				while (*Source != L',') // The new file name is in field 3
					++Source;
				++Source; // Skip the comma
				// Now copy the computer name into ComputerName
				Dest = NewFileName;
				while ( (*Source != L'\r') && 
						(*Source != L'\0') )
				{
					*Dest = *Source;
					++Dest;
					++Source;
				}
				// Null Terminate the ComputerName
				*Dest = L'\0';
				Done = TRUE;
			}
			else
			{
				ZeroMemory(TempFileName,MAX_PATH * sizeof(wchar_t));
				while (*Source != L'\n')
					++ Source;
				++Source; // skip the newline
			}
		
		}
		CloseHandle(hCsv);
	}
Done:
	if (Buffer)
		free (Buffer);

	if (wcscmp(NewFileName,L"\0"))
		return 1;
	else
		return 0;

}

STDMETHODIMP CCerClient::RetryFile1(BSTR *Path, BSTR *TransID, BSTR *FileName, BSTR *IncidentID, BSTR *RedirParam, VARIANT *RetCode)
{
	// Get the Name we renamed the file to

	// Build the source path to the renamed file
		wchar_t				DestFileName[MAX_PATH];
	wchar_t				SourceFileName[MAX_PATH];
	wchar_t				ServerName[MAX_PATH];
	int					ErrorCode		= 0;
	HINTERNET			hSession		= NULL;
	HINTERNET			hRequest		= NULL;
	HINTERNET			hConnect		= NULL;
	INTERNET_BUFFERS	BufferIn		= {0};
	DWORD				ResponseCode	= 0;
	BOOL				UploadSuccess	= FALSE;
	DWORD				NumRetries		= 0;
	HANDLE				hSourceFile		= INVALID_HANDLE_VALUE;
	BYTE				*pSourceBuffer	= NULL;
	DWORD				dwBytesRead		= 0;
	DWORD				dwBytesWritten	= 0;
	BOOL				bRet			= FALSE;
	DWORD				ResLength		= 255;
	DWORD				index			= 0;
	DWORD				MaxRetries		= 5;
//	wchar_t				MachineName[512];
//	wchar_t				CSVBuffer[512];
//	HANDLE				hCsvFile		= INVALID_HANDLE_VALUE;
	wchar_t				CSVFileName[255];
//	WORD				ByteOrderMark = 0xFEFF;
	wchar_t				NewFileName[MAX_PATH];
	static const		wchar_t *pszAccept[]	= {L"*.*", 0};

	// Build the destination FileName 
	if (!GetNewFileNameFromCSV(*Path,*TransID,*FileName,NewFileName))
	{
		RetCode->vt = VT_INT;
		RetCode->intVal = -10;
	}
	// Build Source File Name
	wsprintfW(SourceFileName, L"%s\\%s", *Path, NewFileName);

	// Get the ServerName from the redirector
	ErrorCode = GetUploadServerName(*RedirParam,NULL,ServerName);
	wsprintfW(CSVFileName,L"%s\\%s.csv",*Path,*TransID);
	
	
	if (!PathFileExistsW(SourceFileName))
		ErrorCode = FILE_DOES_NOT_EXIST;

	if ( (!wcscmp(*TransID,L"")) || ((*TransID)[0] == L' ') )
		ErrorCode =  NO_TRANS_ID;

	wsprintfW(DestFileName, L"CerInqueue\\U_%s.%s.%s",*TransID,*IncidentID,*FileName);

	
	if ( (pSourceBuffer = (BYTE *) malloc (10000)) == NULL)
	{
		ErrorCode =  GetLastError();
		goto Done;
	}
	

	if (!ErrorCode)
	{
		// Open the internet session
		
		while ((NumRetries < MaxRetries) && (!UploadSuccess))
		{
		//	::MessageBoxW(NULL,L"Opening the session",NULL,MB_OK);
			hSession = InternetOpenW(L"CerClientControl",
									INTERNET_OPEN_TYPE_PRECONFIG,
									NULL,
									NULL,
									0);
			if (!hSession)
			{
				free (pSourceBuffer);
				ErrorCode = GetLastError();
				return ErrorCode;
			}
		//	::MessageBoxW(NULL,L"We have a session",NULL,MB_OK);
			hConnect = InternetConnectW(hSession, 
									   ServerName,
									   INTERNET_DEFAULT_HTTP_PORT,
									   NULL,
									   NULL,
									   INTERNET_SERVICE_HTTP,
									   0,
									   NULL);
			
			if (hConnect)
			{
			//	::MessageBoxW(NULL,L"We have a connection",NULL,MB_OK);
				hRequest = HttpOpenRequestW (hConnect,
											L"PUT",
											DestFileName,
											NULL,
											NULL,
											pszAccept,
											INTERNET_FLAG_NEED_FILE|INTERNET_FLAG_NO_CACHE_WRITE,
											0);
				if (hRequest)
				{
					hSourceFile = CreateFileW( SourceFileName,
											  GENERIC_READ,
											  FILE_SHARE_READ,
											  NULL,
											  OPEN_EXISTING,
											  FILE_ATTRIBUTE_NORMAL,
											  NULL);
				
					//::MessageBoxW(NULL,L"Request has been opened",NULL,MB_OK);
					if (hSourceFile != INVALID_HANDLE_VALUE)
					{
						
						// Clear the buffer
						
						BufferIn.dwStructSize = sizeof( INTERNET_BUFFERSW );
						BufferIn.Next = NULL; 
						BufferIn.lpcszHeader = NULL;
						BufferIn.dwHeadersLength = 0;
						BufferIn.dwHeadersTotal = 0;
						BufferIn.lpvBuffer = NULL;                
						BufferIn.dwBufferLength = 0;
						BufferIn.dwOffsetLow = 0;
						BufferIn.dwOffsetHigh = 0;
						BufferIn.dwBufferTotal = GetFileSize (hSourceFile, NULL);

						ZeroMemory(pSourceBuffer, 10000); // Fill buffer with data
						if(HttpSendRequestEx( hRequest, &BufferIn, NULL, HSR_INITIATE, 0))
						{
						//	::MessageBoxW(NULL,L"Sending Request",NULL,MB_OK);
							do
							{
								dwBytesRead = 0;
								if(! ReadFile(hSourceFile, pSourceBuffer, 10000, &dwBytesRead, NULL) )
								{
									ErrorCode = GetLastError();
								}
								else
								{
									bRet = InternetWriteFile(hRequest, pSourceBuffer, dwBytesRead, &dwBytesWritten);
									if ( (!bRet) || (dwBytesWritten==0) )
									{
										ErrorCode = GetLastError();
									}

									
								}
							} while ((dwBytesRead == 10000) && (!ErrorCode) );

							if (!ErrorCode)
							{
								bRet = HttpEndRequest(hRequest, NULL, 0, 0);
								if (!bRet)
								{
									ErrorCode = GetLastError();
								}
								else
								{
								//	::MessageBoxW(NULL,L"Ending Request",NULL,MB_OK);
					
									ResponseCode = 0;
									HttpQueryInfo(hRequest,
												  HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER ,
												  &ResponseCode,
												  &ResLength,
												  &index);
								
									if ( (ResponseCode == 200) || (ResponseCode == 201))
									{
										ErrorCode = 0;
										UploadSuccess = TRUE;
									//	::MessageBoxW(NULL,L"Upload was successfull",NULL,MB_OK);
									}
									else
									{
										ErrorCode= ResponseCode;
										++NumRetries;
									}

								}
							}
						}
					}
				}
			}
		//	::MessageBoxW(NULL,L"Cleaning Up",NULL,MB_OK);
			if (!UploadSuccess)
			{
				++NumRetries;
			}
		
			if (hSourceFile != INVALID_HANDLE_VALUE)
				CloseHandle (hSourceFile);
			if (hRequest)
				InternetCloseHandle(hRequest);
			if (hConnect)
				InternetCloseHandle(hConnect);  
			if (hSession)
				InternetCloseHandle(hSession);   
		
		}
	//	::MessageBoxW(NULL,L"freeing source buffer",NULL,MB_OK);
		if (pSourceBuffer)
		{
			free (pSourceBuffer);
			pSourceBuffer = NULL;
		}
	}



Done:
	if (pSourceBuffer)
		free(pSourceBuffer);

	RetCode->vt = VT_INT;
	RetCode->intVal = ErrorCode;

	return S_OK;
}

STDMETHODIMP CCerClient::EndTransaction(BSTR *SharePath, BSTR *TransID, VARIANT *RetCode)
{
	wchar_t TransfileName[MAX_PATH];

	RetCode->vt = VT_INT;
	RetCode->intVal = 0;
	wsprintfW(TransfileName,L"%s\\%s.txt",*SharePath,*TransID);
	if (PathFileExistsW(TransfileName))
		DeleteFileW(TransfileName);
	else
	{
		RetCode->intVal = 1;
	}


	return S_OK;
}

STDMETHODIMP CCerClient::Upload1(BSTR *Path, BSTR *TransID, BSTR *FileName, BSTR *IncidentID, BSTR *RedirParam, BSTR *Type, VARIANT *RetCode)
{
	// TODO: Add your implementation code here
	wchar_t				DestFileName[MAX_PATH];
	wchar_t				SourceFileName[MAX_PATH];
	wchar_t				ServerName[MAX_PATH];
	int					ErrorCode		= 0;
	HINTERNET			hSession		= NULL;
	HINTERNET			hRequest		= NULL;
	HINTERNET			hConnect		= NULL;
	INTERNET_BUFFERS	BufferIn		= {0};
	DWORD				ResponseCode	= 0;
	BOOL				UploadSuccess	= FALSE;
	DWORD				NumRetries		= 0;
	HANDLE				hSourceFile		= INVALID_HANDLE_VALUE;
	BYTE				*pSourceBuffer	= NULL;
	DWORD				dwBytesRead		= 0;
	DWORD				dwBytesWritten	= 0;
	BOOL				bRet			= FALSE;
	DWORD				ResLength		= 255;
	DWORD				index			= 0;
	DWORD				MaxRetries		= 5;
	wchar_t				MachineName[512];
	wchar_t				CSVBuffer[512];
	HANDLE				hCsvFile		= INVALID_HANDLE_VALUE;
	wchar_t				CSVFileName[255];
	WORD				ByteOrderMark = 0xFEFF;
	static const		wchar_t *pszAccept[]	= {L"*.*", 0};

	
	
	if ((!Path) || (!TransID) ||(!FileName) || (!IncidentID) || (!RedirParam) || (!Type))
	{
		RetCode->vt = VT_INT;
		RetCode->intVal = -1;
	
		return S_OK;
	}

	// Build Source File Name
	if (!wcscmp(*FileName,L"\0")) 
	{
		RetCode->vt = VT_INT;
		RetCode->intVal = -1;
		return S_OK;
	}

	wsprintfW(SourceFileName, L"%s\\%s", *Path, *FileName);

	// Get the ServerName from the redirector
	ErrorCode = GetUploadServerName(*RedirParam,NULL,ServerName);
	if (!ErrorCode)
	{
		wsprintfW(CSVFileName,L"%s\\%s.csv",*Path,*TransID);
		
		
		if ( (!PathFileExistsW(SourceFileName) ) || (wcslen(*FileName) < 4 ))
			ErrorCode = FILE_DOES_NOT_EXIST;

		if ( (!wcscmp(*TransID,L"")) || ((*TransID)[0] == L' ') )
			ErrorCode =  NO_TRANS_ID;

		// Build the destination FileName 

		// First see which Virtual directory to use.
		if ( !_wcsicmp(*Type,L"bluescreen"))
		{
			wsprintfW(DestFileName, L"CerBluescreen\\U_%s.%s.%s",*IncidentID,*TransID,*FileName);
		}
		else
		{
			if (!_wcsicmp(*Type,L"appcompat"))
			{
				wsprintfW(DestFileName, L"CerAppCompat\\U_%s.%s.%s",*IncidentID,*TransID,*FileName);
			}
			else
			{
				if (!_wcsicmp(*Type,L"shutdown"))
				{
					wsprintfW(DestFileName, L"CerShutdown\\U_%s.%s.%s",*IncidentID,*TransID,*FileName);
				}
				else
				{
					ErrorCode = UNKNOWN_UPLOAD_TYPE;
				}
			}
		}
	}
	if (!ErrorCode)
	{
	
		pSourceBuffer = (BYTE *) malloc (10000);
		if (!pSourceBuffer)
		{
			if (! pSourceBuffer)
			{
				ErrorCode =  GetLastError();
			}
		}
	}
		

	if (!ErrorCode)
	{
		// Open the internet session
		
		while ((NumRetries < MaxRetries) && (!UploadSuccess))
		{
		//	::MessageBoxW(NULL,L"Opening the session",NULL,MB_OK);
			hSession = InternetOpenW(L"CerClientControl",
									INTERNET_OPEN_TYPE_PRECONFIG,
									NULL,
									NULL,
									0);
			if (!hSession)
			{
				free (pSourceBuffer);
				ErrorCode = GetLastError();
				return ErrorCode;
			}
		//	::MessageBoxW(NULL,L"We have a session",NULL,MB_OK);
			hConnect = InternetConnectW(hSession, 
									   ServerName,
									   INTERNET_DEFAULT_HTTP_PORT,
									   NULL,
									   NULL,
									   INTERNET_SERVICE_HTTP,
									   0,
									   NULL);
			
			if (hConnect)
			{
			//	::MessageBoxW(NULL,L"We have a connection",NULL,MB_OK);
				hRequest = HttpOpenRequestW (hConnect,
											L"PUT",
											DestFileName,
											NULL,
											NULL,
											pszAccept,
											INTERNET_FLAG_NEED_FILE|INTERNET_FLAG_NO_CACHE_WRITE,
											0);
				if (hRequest)
				{
					hSourceFile = CreateFileW( SourceFileName,
											  GENERIC_READ,
											  FILE_SHARE_READ,
											  NULL,
											  OPEN_EXISTING,
											  FILE_ATTRIBUTE_NORMAL,
											  NULL);
				
					//::MessageBoxW(NULL,L"Request has been opened",NULL,MB_OK);
					if (hSourceFile != INVALID_HANDLE_VALUE)
					{
						
						// Clear the buffer
						
						BufferIn.dwStructSize = sizeof( INTERNET_BUFFERSW );
						BufferIn.Next = NULL; 
						BufferIn.lpcszHeader = NULL;
						BufferIn.dwHeadersLength = 0;
						BufferIn.dwHeadersTotal = 0;
						BufferIn.lpvBuffer = NULL;                
						BufferIn.dwBufferLength = 0;
						BufferIn.dwOffsetLow = 0;
						BufferIn.dwOffsetHigh = 0;
						BufferIn.dwBufferTotal = GetFileSize (hSourceFile, NULL);

						ZeroMemory(pSourceBuffer, 10000); // Fill buffer with data
						if(HttpSendRequestEx( hRequest, &BufferIn, NULL, HSR_INITIATE, 0))
						{
						//	::MessageBoxW(NULL,L"Sending Request",NULL,MB_OK);
							do
							{
								dwBytesRead = 0;
								if(! ReadFile(hSourceFile, pSourceBuffer, 10000, &dwBytesRead, NULL) )
								{
									ErrorCode = GetLastError();
								}
								else
								{
									bRet = InternetWriteFile(hRequest, pSourceBuffer, dwBytesRead, &dwBytesWritten);
									if ( (!bRet) || (dwBytesWritten==0) )
									{
										ErrorCode = GetLastError();
									}

									
								}
							} while ((dwBytesRead == 10000) && (!ErrorCode) );

							if (!ErrorCode)
							{
								bRet = HttpEndRequest(hRequest, NULL, 0, 0);
								if (!bRet)
								{
									ErrorCode = GetLastError();
								}
								else
								{
								//	::MessageBoxW(NULL,L"Ending Request",NULL,MB_OK);
					
									ResponseCode = 0;
									HttpQueryInfo(hRequest,
												  HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER ,
												  &ResponseCode,
												  &ResLength,
												  &index);
								
									if ( (ResponseCode == 200) || (ResponseCode == 201))
									{
										ErrorCode = 0;
										UploadSuccess = TRUE;
									//	::MessageBoxW(NULL,L"Upload was successfull",NULL,MB_OK);
									}
									else
									{
										ErrorCode= ResponseCode;
										++NumRetries;
									}

								}
							}
						}
					}
				}
			}
		//	::MessageBoxW(NULL,L"Cleaning Up",NULL,MB_OK);
			if (!UploadSuccess)
			{
				++NumRetries;
			}
		
			if (hSourceFile != INVALID_HANDLE_VALUE)
				CloseHandle (hSourceFile);
			if (hRequest)
				InternetCloseHandle(hRequest);
			if (hConnect)
				InternetCloseHandle(hConnect);  
			if (hSession)
				InternetCloseHandle(hSession);   
		
		}
		if (pSourceBuffer)
		{
			free (pSourceBuffer);
			pSourceBuffer = NULL;
		}
	}

	if ( !ErrorCode) 
	{
	
		// Get the Computer Name
	
		// if there are no errors rename the file just uploaded.
		wchar_t NewFileName[MAX_PATH];
		wchar_t FullPath[MAX_PATH];
		wcscpy (NewFileName, *FileName);
	
		int x = 0;
		BOOL DONE = FALSE;
		
		NewFileName[wcslen(NewFileName)] = L'\0';
		// First try just .old
		DWORD NameLength = 0;
		NameLength = wcslen(FullPath)+ wcslen(L"\\.old");

		if (NameLength > MAX_PATH) // nope it won't fit. Reduce the file name length by the difference.
		{
			NewFileName[wcslen(NewFileName) - (MAX_PATH - NameLength)] = L'\0';
	
		}
		wsprintfW(FullPath,L"%s\\%s.old",*Path,NewFileName);


		if (!PathFileExistsW(FullPath))
		{
		
			MoveFileW(SourceFileName, FullPath);
			DONE = TRUE;
		}
		else
		{	// if that fails then we have to try another method.
		
			while (!DONE)
			{
				wcscpy (NewFileName, *FileName);
				NewFileName[wcslen(NewFileName)] = L'\0';


				wsprintfW(NewFileName, L"%s.old%d",*FileName,x);
				if ( (wcslen(*Path) + wcslen(L"\\") + wcslen(NewFileName)) > MAX_PATH)
				{
					// Reduce file name by Diff of MAX_PATH and Total name Length
					NameLength = wcslen(*Path) + wcslen(L"\\") + wcslen(NewFileName);
					wcscpy(NewFileName,*FileName);
					NewFileName[wcslen(NewFileName - NameLength)]=L'\0';
					wsprintfW(FullPath, L"%s\\%s.old%d", *Path, NewFileName, x);
				}
				else
				{

					wsprintfW(FullPath,L"%s\\%s.old%d",*Path,NewFileName,x);
				}

				if (!PathFileExistsW(FullPath))
				{
					MoveFileW(SourceFileName, FullPath);
					DONE = TRUE;
				}
				else
					++x;

			}
		}


		// Update the Upload CSV File
		if (!ErrorCode)
		{
		//	::MessageBoxW(NULL,L"Updateing the csv",NULL,MB_OK);
			wcscpy(MachineName,L"\0");
			GetMachineName(*Path, *FileName, MachineName);
		
			ZeroMemory(CSVBuffer, 512);
			if (!wcscmp(MachineName,L"\0"))
			{
				wsprintfW(CSVBuffer, L"%s,,%s\r\n",*FileName,PathFindFileNameW(FullPath));
			}
			else
			{
				wsprintfW(CSVBuffer, L"%s,%s,%s\r\n", *FileName,MachineName,PathFindFileNameW(FullPath));
			}
			hCsvFile = CreateFileW(CSVFileName, 
								  GENERIC_WRITE | GENERIC_READ,
								  FILE_SHARE_READ,
								  NULL,
								  OPEN_EXISTING,
								  FILE_ATTRIBUTE_NORMAL,
								  NULL);
			if (hCsvFile == INVALID_HANDLE_VALUE)
			{
				// Ok We Need to create a new one. Don't forget the Unicode Signature.
				hCsvFile = CreateFileW(CSVFileName, 
								  GENERIC_WRITE | GENERIC_READ,
								  FILE_SHARE_READ,
								  NULL,
								  CREATE_ALWAYS,
								  FILE_ATTRIBUTE_NORMAL,
								  NULL);
			
				// Write the Unicode Signature
				if (hCsvFile != INVALID_HANDLE_VALUE)
				{
						WriteFile(hCsvFile, &ByteOrderMark,2,&dwBytesWritten,NULL);
				}
			}

			if (hCsvFile != INVALID_HANDLE_VALUE)
			{
				// continue as if the file was created before
				wchar_t* TempBuffer = (wchar_t*) malloc (10000);
				if (TempBuffer != NULL)
				{
					do 
					{
						if (!ReadFile(hCsvFile,TempBuffer,10000,&dwBytesRead,NULL))
						{
							; // we catch this below.
						}

					}
					while(dwBytesRead == 10000);
					free (TempBuffer);

					WriteFile( hCsvFile, CSVBuffer,wcslen(CSVBuffer) *sizeof(wchar_t), &dwBytesWritten,NULL);
					CloseHandle(hCsvFile);
				}
			}
			else
				ErrorCode = FAILED_TO_UPDATE_CSV;
		}
	
		
			
		
	}

	// Return Upload Status
//	::MessageBoxW(NULL,L"Returning from the upload function",NULL,MB_OK);
	RetCode->vt = VT_INT;
	RetCode->intVal = ErrorCode;
	return S_OK;

}

STDMETHODIMP CCerClient::GetSuccessCount(BSTR *Path, BSTR *TransID, VARIANT *RetVal)
{
	
	wchar_t		CsvFileName[MAX_PATH];
	DWORD       FileCount = 0;
	FILE		*hFile;
	wchar_t		*Buffer = NULL;
	BOOL		Done = FALSE;
	HANDLE		hCsv = INVALID_HANDLE_VALUE;
	wchar_t		TempFileName[MAX_PATH];
	wchar_t		*Source = NULL;
	wchar_t		*Dest   = NULL;
	DWORD		FileSize = 0;
	DWORD		dwBytesRead = 0;

	RetVal->vt = VT_INT;
	// Move to the beginning of the file.
	//::MessageBoxW(NULL,L"Getting the ComputerName from the CSV file",NULL,MB_OK);

	wsprintfW(CsvFileName,L"%s\\%s.csv",*Path,*TransID);
	hCsv = CreateFileW(CsvFileName,
					  GENERIC_READ,
					  NULL,
					  NULL,
					  OPEN_EXISTING,
					  FILE_ATTRIBUTE_NORMAL,
					  NULL);

	if (hCsv != INVALID_HANDLE_VALUE)
	{
		FileSize = GetFileSize(hCsv,NULL);

		if (FileSize > 0)
		{
			if ( (Buffer = (wchar_t *) malloc (FileSize * 2)) == NULL)
			{
				RetVal->intVal = -4;
				CloseHandle(hCsv);
				return S_OK;
			}
		}
		else
		{
			RetVal->intVal = -4;
			CloseHandle(hCsv);
			return S_OK;
		}
		// Now look for the Filename 
		ZeroMemory(TempFileName,MAX_PATH * sizeof(wchar_t));
		ZeroMemory(Buffer,FileSize * 2);
		if (!ReadFile(hCsv,
				 Buffer,
				 FileSize * 2,
				 &dwBytesRead,
				 NULL))
		{
			RetVal->intVal = -4;
			CloseHandle(hCsv);
			if (Buffer)
				free(Buffer);
			return S_OK;
		}

		Source = Buffer;
		int Testing = IS_TEXT_UNICODE_SIGNATURE;
			// If the unicode header bytes appear remove skip past them
		if (IsTextUnicode(Buffer,FileSize * 2,&Testing))
		{
			++Source;		
		}
		while (! Done)
		{
			Dest   = TempFileName;
			while  ( (*Source != L'\r') && 
					 (*Source != L'\0') && 
					 (*Source != L',')  )
			{
				*Dest = *Source;
				++Source;
				++Dest;
			}
			// Null Terminate the destination string.
			*Dest = L'\0';
			if (wcscmp(TempFileName, L"\0"))
			{
			//	::MessageBoxW(NULL,TempFileName,L"Read file name from CSV",MB_OK);
				++FileCount;
			}
			ZeroMemory(TempFileName,sizeof(TempFileName));

			// Move to the next line
			while ( (*Source != L'\r') && (*Source != L'\0'))
			{
				++Source;
			}
			if (*Source == L'\r')
			{
				++Source;
				++Source;
			}
			if (*Source == L'\0')
				Done = TRUE;
		}

		if (FileCount > 0)
		{
			RetVal->intVal = FileCount;
		}
		else
		{
			RetVal->intVal = 0;
		}
		CloseHandle(hCsv);
	}
	else
	{
		RetVal->intVal = -4;
	}
	if (Buffer)
		free (Buffer);



	
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\appcompr\upload.h ===
/*******************************************************************
*
*    DESCRIPTION: Upload.h : Generates and sends out AppCompat report
*
*    DATE:6/13/2002
*
*******************************************************************/

#if !defined(_UPLOAD_H_)
#define _UPLOAD_H_

enum  // EDwBehaviorFlags
{
    fDwOfficeApp            = 0x00000001,
    fDwNoReporting          = 0x00000002,   // don't report
    fDwCheckSig             = 0x00000004,   // checks the signatures of the App/Mod list
    fDwGiveAppResponse      = 0x00000008,   // hands szResponse to app on command line
    fDwWhistler             = 0x00000010,   // Whistler's exception handler i