grateSystemNT,GB, ConvertChsImeData OK !\r\n"));
        } else {
            DebugMsg(("MigrateSystemNT,GB, ConvertChsImeData OK !\r\n"));
        }

        MovePerUserIMEData();

        if (CHSBackupWinABCUserDict(ImeDataDirectory)) {
            DebugMsg(("MigrateSystemNT,GB, CHSBackupWinABCUserDict OK !\r\n"));
        } else {
            DebugMsg(("MigrateSystemNT,GB, CHSBackupWinABCUserDict OK !\r\n"));
        }

        if (CHSDeleteGBKKbdLayout()) {
            DebugMsg(("MigrateSystemNT,GB, CHSDeleteGBKKbdLayout OK !\r\n"));
        } else {
            DebugMsg(("MigrateSystemNT,GB, CHSDeleteGBKKbdLayout OK !\r\n"));
        }

        break;

    case CP_CHINESE_BIG5: // Traditional Chinese
        if (ConvertChtImeData()) {
            DebugMsg(("MigrateSystemNT,BIG5, ConvertChtImeData OK !\r\n"));
        } else {
            DebugMsg(("MigrateSystemNT,BIG5, ConvertChtImeData OK !\r\n"));
        }
        MovePerUserIMEData();

        break;

    default:
        returnCode = ERROR_NOT_INSTALLED;
    }

    return returnCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\chimemig\poolmem.c ===
#include "pch.h"
 
// Tree Memory Allocation structure.


typedef struct _POOLMEMORYBLOCK POOLMEMORYBLOCK, *PPOOLMEMORYBLOCK;

struct _POOLMEMORYBLOCK {
    DWORD                 Index;
    DWORD                 Size;
    PPOOLMEMORYBLOCK      NextBlock;
    PPOOLMEMORYBLOCK      PrevBlock;
    PBYTE                 RawMemory;  
};

typedef struct _POOLHEADER {
    PPOOLMEMORYBLOCK PoolHead;
    HANDLE           Heap;
} POOLHEADER, *PPOOLHEADER;


BOOL
PoolMemAddMemory (
    IN  POOLHANDLE  Handle,
    IN  DWORD       Size
    )
{
    PBYTE               allocedMemory;
    PPOOLMEMORYBLOCK    newBlock;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;
    DWORD               sizeNeeded;

    assert(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(POOLMEMORYBLOCK) > POOLMEMORYBLOCKSIZE) {
        sizeNeeded = Size + sizeof(POOLMEMORYBLOCK);
    }
    else {
        sizeNeeded = POOLMEMORYBLOCKSIZE;
    }

    allocedMemory = HeapAlloc(poolHeader -> Heap,0,sizeNeeded);

    if (allocedMemory) {

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock                = (PPOOLMEMORYBLOCK) allocedMemory;
        newBlock -> Size        = sizeNeeded - sizeof(POOLMEMORYBLOCK);
        newBlock -> RawMemory   = allocedMemory + sizeof(POOLMEMORYBLOCK);
        newBlock -> Index       = 0;
    
        //
        // Link the block into the list.
        //
        if (poolHeader -> PoolHead) {
            poolHeader -> PoolHead -> PrevBlock = newBlock;
        }
        newBlock   -> NextBlock   = poolHeader -> PoolHead;
        newBlock   -> PrevBlock   = NULL;
        poolHeader -> PoolHead    = newBlock;


    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;
}


POOLHANDLE
WINAPI
PoolMemInitPool (
    )
{
    BOOL        ableToAddMemory;
    PPOOLHEADER header = NULL;
    HANDLE      procHeap;


    procHeap = GetProcessHeap();
    //
    // Allocate the header of this pool.
    //
    header = HeapAlloc(procHeap,0,sizeof(POOLHEADER));

    if (header) {

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header -> PoolHead = NULL;
        header -> Heap = procHeap;

        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = PoolMemAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            HeapFree(header -> Heap,0,header);
            header = NULL;
        }

    }
    return (POOLHANDLE) header;
}


VOID
WINAPI
PoolMemDestroyPool (
    POOLHANDLE Handle
    )
{
    PPOOLMEMORYBLOCK nextBlock;
    PPOOLMEMORYBLOCK blockToFree; 
    PPOOLHEADER      poolHeader;

    assert(Handle != NULL);

    poolHeader = (PPOOLHEADER) Handle;

    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader ->  PoolHead;

    while (blockToFree != NULL) {
    
        nextBlock = blockToFree->NextBlock;
        HeapFree(poolHeader -> Heap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //
    HeapFree(poolHeader -> Heap,0,poolHeader);

}

PVOID
WINAPI
PoolMemGetAlignedMemory (
    IN POOLHANDLE Handle,
    IN DWORD      Size,
    IN DWORD      AlignSize
    )

{
    BOOL                haveEnoughMemory = TRUE;
    PVOID               rMemory          = NULL;
    PPOOLHEADER         poolHeader       = (PPOOLHEADER) Handle;
    PPOOLMEMORYBLOCK    currentBlock;
    DWORD               sizeNeeded;
    DWORD               padLength;

    assert(poolHeader != NULL);

    currentBlock = poolHeader -> PoolHead;

    // Determine if more memory is needed, attempt to add if needed.
    sizeNeeded = Size;

    if (currentBlock -> Size - currentBlock -> Index < sizeNeeded + AlignSize) {

        haveEnoughMemory = PoolMemAddMemory(poolHeader,sizeNeeded + AlignSize);
        currentBlock = poolHeader -> PoolHead;
    }

    // If there is enough memory available, return it.
    if (haveEnoughMemory) {
        if (AlignSize) {

            padLength = (DWORD) currentBlock + sizeof(POOLMEMORYBLOCK) 
                + currentBlock -> Index;
            currentBlock -> Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

        }
      
         
        //Now, get the address of the memory to return.
        rMemory = (PVOID) 
            &(currentBlock->RawMemory[currentBlock -> Index]);
 
        currentBlock->Index += sizeNeeded;
    }

    return rMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\chimemig\miginf.c ===
#include "pch.h"

#define MIGRATEINF              ".\\migrate.inf"
#define INITIALBUFFERSIZE       1024
#define MIGINF_NOCREATE         FALSE
#define MIGINF_CREATE           TRUE


typedef struct tagMIGOBJECT MIGOBJECT, *PMIGOBJECT;
struct tagMIGOBJECT {

    PSTR        Key;
    PSTR        Value;
    
    PMIGOBJECT  Next;
};

typedef struct tagMIGSECTION MIGSECTION, * PMIGSECTION;
struct tagMIGSECTION {

    PSTR        Name;
    PMIGOBJECT  Items;

    PMIGSECTION Next;
};

PMIGSECTION g_MigrationInf;
POOLHANDLE  g_Pool = NULL;


static
PCSTR
pGetTypeAsString (
    IN MIGTYPE Type
    )
{
    //
    // Note: Strings must be in the same order as the 
    // corresponding types in the MIGTYPE enumeration above.
    //
    static PCHAR typeStrings[] = {
            "FIRST - Invalid",
            "File",
            "Path",
            "Registry",
            "Message - Invalid",
            "LAST - Invalid"
        };

    assert(Type > MIG_FIRSTTYPE && Type < MIG_LASTTYPE);

    return typeStrings[Type];
}

static
PMIGSECTION 
pFindSection (
    IN PCSTR SectionString,
    IN BOOL  CreateIfNotExist
    )
{
    PMIGSECTION rSection;

    //
    // We assume that SectionString is not null.
    //
    assert(SectionString);

    rSection = g_MigrationInf;

    while (rSection && (_mbsicmp(rSection -> Name,SectionString) != 0)) {

        //
        // Continue looking.
        //
        rSection = rSection -> Next;
    }
        
    if (!rSection && CreateIfNotExist) {
        //
        // No section was found matching this name. Make a new section and add it 
        // to the list.
        //
        rSection = PoolMemGetMemory(g_Pool,sizeof(MIGSECTION));
        if (rSection) {

            ZeroMemory(rSection,sizeof(MIGSECTION));
            rSection -> Name  = PoolMemDuplicateStringA(g_Pool,SectionString);
            rSection -> Next  = g_MigrationInf;
            g_MigrationInf    = rSection;

            if (!rSection -> Name) {
                //
                // Something went wrong when we tried to duplicate the SectionString.
                // NULL out the rSection so that the caller doesn't get back a 
                // malformed section object.
                //
                rSection = NULL;
            }
        }
    }

    return rSection;
}

static
BOOL
pPathIsInPath(
    IN PCSTR    SubPath,
    IN PCSTR    ParentPath
    )
{
    DWORD parentLength;
    BOOL  rInPath;

    //
    // This function assumes both parameters are non-NULL.
    //
    assert(SubPath);
    assert(ParentPath);
    
    parentLength = _mbslen(ParentPath);

    //
    // A path is considered "in" another path if the path is in the ParentPath
    // or a subdirectory of it.
    //
    rInPath = !_mbsnicmp(SubPath,ParentPath,parentLength);

    if (rInPath) {
        rInPath = SubPath[parentLength] == 0 || SubPath[parentLength] == '\\';
    }

    return rInPath;

}

static
DWORD
pGetMbsSize (
    IN  LPCSTR  String
    )
{
    DWORD rLength;
    
    rLength = (DWORD) _mbschr(String,0) - (DWORD) String + 1;

    return rLength;

}


static
LPSTR 
pEscapeString (
    IN  MIGTYPE Type,
    OUT LPSTR   EscapedString, 
    IN  LPCSTR  String
    )

{
    LPSTR   stringStart;
    static  CHAR exclusions[] = "[]~,;%\"";
    INT     currentChar;

    //
    // We assume that all parameters are valid.
    //
    assert(EscapedString && String);

    stringStart = EscapedString;

    while (*String)  {
        currentChar = _mbsnextc (String);
        
        if (Type == MIG_REGKEY) {
            
            //
            // Registry keys require more complex escaping than do normal INF strings.
            //
            if (!_ismbcprint (currentChar) || _mbschr (exclusions, currentChar)) {
                
                //
                // Escape unprintable or excluded character
                //
                wsprintfA (EscapedString, "~%X~", currentChar);
                EscapedString = _mbschr (EscapedString, 0);
                String = _mbsinc (String);
            }
            else {
                //
                // Copy multibyte character
                //
                if (IsDBCSLeadByte (*String)) {
                    *EscapedString = *String;
                    EscapedString++;
                    String++;
                }
                
                *EscapedString = *String;
                EscapedString++;
                String++;
            }
        }
        else {

            //
            // Escaping is pretty simple for non-registry keys. All we do is double up
            // quotes and percents.
            //
            if (*String == '\"' || *String == '%') {

                *EscapedString = *String;
                EscapedString++;
            }
            
            //
            // Copy multibyte character
            //
            if (IsDBCSLeadByte (*String)) {
                *EscapedString = *String;
                EscapedString++;
                String++;
            }
            
            *EscapedString = *String;
            EscapedString++;
            String++;
        }
    }

    //
    // Ensure that returned string is NULL terminated.
    //
    *EscapedString = 0;

    return stringStart;
}


static
PSTR
pGetValueString (
    IN MIGTYPE    ObjectType,
    IN LPCSTR     StringOne,
    IN LPCSTR     StringTwo
    )
{
    static PSTR     buffer;
    static DWORD    bufferSize;
    DWORD           maxLength;
    PSTR            bufferEnd;
    
    //
    // This function assumes that StringOne exists.
    //
    assert(StringOne);

    if (ObjectType == MIG_REGKEY) {
        //
        // Size: size of both strings, plus the size of the quotes, plus the size of the brackets 
        // for the value, * 6. This is the maximum size one of these could grow to, if every 
        // character had to be escaped out.
        //
        maxLength = (pGetMbsSize(StringOne) + (StringTwo ? pGetMbsSize(StringTwo) + 2 : 0)) * 6 + 2;
    }
    else {
        //
        // Size: size of the string * 2 (The max size if every char was a '%' or '"' plus the quotes.
        //
        maxLength = pGetMbsSize(StringOne) * 2 + 2;
    }

    if (maxLength > bufferSize) {

        //
        // Initialize our buffer, or create a larger one.
        //
        bufferSize = (maxLength > INITIALBUFFERSIZE) ? maxLength : INITIALBUFFERSIZE;
        buffer = PoolMemCreateStringA(g_Pool,bufferSize);
    }

    if (buffer != NULL) {
        
        //
        // Insert initial quote.
        //
        *buffer = '"';
 
        //
        // Massage the string to ensure it is a valid INF file string.
        //
        pEscapeString(ObjectType,_mbsinc(buffer),StringOne);

        //
        // If this is a REGISTRY entry, then we also need to add the value part of the string, 
        // if one was specified (In StringTwo)
        //

        if (ObjectType == MIG_REGKEY && StringTwo) {

            //
            // Add the opening bracket.
            //
            bufferEnd = _mbschr(buffer,0);
            *bufferEnd = '[';
            
            //
            // Add the value string in, again making sure the string is valid for an INF file.
            //
            pEscapeString(ObjectType,_mbsinc(bufferEnd),StringTwo);

            //
            // Now, add the closing braket.
            //
            bufferEnd = _mbschr(buffer,0);
            *bufferEnd = ']';

            //
            // Terminate the string.
            //
            bufferEnd = _mbsinc(bufferEnd);
            *bufferEnd = 0;
        }

        //
        // Add the final quote.
        //
        bufferEnd = _mbschr(buffer,0);
        *bufferEnd = '"';
        bufferEnd = _mbsinc(bufferEnd);
        *bufferEnd = 0;
    }
    
    return buffer;
}

static
BOOL
pCreateMigObject (
    IN MIGTYPE          ObjectType,
    IN PCSTR            ParamOne,
    IN PCSTR            ParamTwo,
    IN PMIGSECTION      Section
    )
{
    BOOL            rSuccess;
    PMIGOBJECT      newObject = NULL;

    //
    // pCreateMigObject uses a set of hueristics to correctly assemble an object. 
    // These hueristics are based on the ObjectType and the contents of ParamTwo.
    // 
    // ObjectType       ParamTwo      Key                   Value
    // -------------------------------------------------------------------------
    // MIG_REGKEY       <any>         ParamOne[ParamTwo]    Registry
    // <other>          NULL          ParamOne              <ObjectType As String>
    // <other>          non-NULL      ParamOne              ParamTwo
    //
    //


    if (Section) {

        //
        // First, create an object...
        //
        newObject = PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT));

        if (newObject) {

            if (ObjectType == MIG_REGKEY) {

                newObject -> Key = 
                    PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamOne,ParamTwo));

                newObject -> Value = PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType));
            }
            else {
                
                newObject -> Key = 
                    PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamOne,NULL));

                if (ParamTwo) {
                    newObject -> Value =
                        PoolMemDuplicateStringA(g_Pool,pGetValueString(ObjectType,ParamTwo,NULL));
                }
                else {

                    newObject -> Value = 
                        PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType));
                }
            }
        }
    }


    if (newObject && newObject -> Key && newObject -> Value) {

        //
        // The object has been successfully created. Link it into the section.
        //
        newObject -> Next = Section -> Items;
        Section -> Items = newObject;
        rSuccess = TRUE;
    }
    else {
        rSuccess = FALSE;
    }

    return newObject && newObject -> Key && newObject -> Value;
}


static
BOOL
pWriteInfSectionToDisk (
    IN PMIGSECTION Section
    )
{
    PMIGOBJECT curObject;
    BOOL       rSuccess = TRUE;

    if (Section) {

        curObject = Section -> Items;

        while (curObject && rSuccess) {

            if (Section -> Name && curObject -> Key && curObject -> Value) {
            
                rSuccess = WritePrivateProfileString(
                    Section   -> Name,
                    curObject -> Key, 
                    curObject -> Value,
                    MIGRATEINF
                    );
            }

            curObject = curObject -> Next;
        }
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}


static
BOOL
pBuildListFromSection (
    IN PCSTR    SectionString
    )
{
    HINF            infHandle;
    PMIGSECTION     section;
    PMIGOBJECT      currentObject;
    INFCONTEXT      ic;
    DWORD           size;
    BOOL            rSuccess = TRUE;

    //
    // This function assumes that Section is non-NULL.
    //
    assert(SectionString);

    currentObject = NULL;
    
    //
    // First find the section specified.
    //
    section = pFindSection(SectionString,MIGINF_CREATE);

    if (section) {
        
        infHandle = SetupOpenInfFileA(MIGRATEINF,NULL,INF_STYLE_WIN4,NULL);
        
        if (infHandle != INVALID_HANDLE_VALUE) {
            
            if (SetupFindFirstLine(infHandle,SectionString,NULL,&ic)) {
                
                do {

                    //
                    // Create the object.
                    //
                    currentObject = (PMIGOBJECT) PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT));
                    
                    if (!currentObject) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Get the size of the string.
                    //
                    if (!SetupGetLineTextA(&ic,NULL,NULL,NULL,NULL,0,&size)) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Create a string large enough.
                    //
                    currentObject -> Key = PoolMemCreateStringA(g_Pool,size);
                    
                    if (!currentObject -> Key) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Get the string.
                    //
                    if (!SetupGetLineTextA(&ic,NULL,NULL,NULL,currentObject -> Key,size,NULL)) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Successfully retrieved the line.
                    //
                    currentObject -> Value  = (PSTR) pGetTypeAsString(MIG_FILE);
                    currentObject -> Next   = section -> Items;
                    section -> Items        = currentObject;
                    
                } while(SetupFindNextLine(&ic,&ic));
                
            }
            
            SetupCloseInfFile(infHandle);
        }
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}


BOOL
WINAPI
MigInf_Initialize(
    VOID
    )
{

    //
    // First, initialize our pool and Zero out the structure.
    //
    g_Pool = PoolMemInitPool();


    if (g_Pool) {
        
        //
        // Now, read in the migration paths and excluded paths sections.
        //
        if (!pBuildListFromSection(SECTION_MIGRATIONPATHS) ||
            !pBuildListFromSection(SECTION_EXCLUDEDPATHS)) {
            //
            // Something went wrong (i.e. out of memory. Destroy and NULL our pool.
            //
            PoolMemDestroyPool(g_Pool);
            g_Pool = NULL;
        }
    }

    //
    // If our memory pool initialized successfully, return TRUE.
    //
    return (g_Pool != NULL);

}


VOID
WINAPI
MigInf_CleanUp (
    VOID
    )
{
    //
    // Only thing we need to do is clean out pool mem. We'll NULL out the list header to make
    // sure it isn't usable.
    //
    if (g_Pool) {
        PoolMemDestroyPool(g_Pool);
        g_Pool = NULL;
    }
    
    g_MigrationInf = NULL;

}


BOOL
WINAPI
MigInf_AddObject (
    IN MIGTYPE  ObjectType,
    IN PCSTR    SectionString,
    IN PCSTR    ParamOne,
    IN PCSTR    ParamTwo
    )
{

    return pCreateMigObject(
        ObjectType,
        ParamOne,
        ParamTwo,
        pFindSection(SectionString,MIGINF_CREATE)
        );
}

BOOL 
WINAPI 
MigInf_FirstInSection(
    IN PCSTR SectionName, 
    OUT PMIGINFSECTIONENUM Enum
    )
{
    PMIGSECTION section;

    //
    // We assume that Enum is valid.
    //
    assert(Enum);

    section = pFindSection(SectionName,MIGINF_NOCREATE);

    if (section) {
        Enum -> EnumKey = (PVOID) section -> Items;
    }

    return MigInf_NextInSection(Enum);
}

BOOL 
WINAPI 
MigInf_NextInSection(
    IN OUT PMIGINFSECTIONENUM Enum
    )
{


    BOOL            rSuccess = FALSE;

    //
    // We assume that the Enum is valid.
    //
    assert(Enum);

    if (Enum -> EnumKey) {

        Enum -> Key     = ((PMIGOBJECT) (Enum -> EnumKey)) -> Key;
        Enum -> Value   = ((PMIGOBJECT) (Enum -> EnumKey)) -> Value;
        Enum -> EnumKey = ((PVOID) ((PMIGOBJECT) (Enum -> EnumKey)) -> Next);
        rSuccess = TRUE;
    }

    return rSuccess;
}


BOOL
WINAPI
MigInf_WriteInfToDisk (
    VOID
    )
{

    BOOL        rSuccess = TRUE;
    PMIGSECTION curSection;
    
    //
    // Simply loop through all of the sections, writing each of them to disk.
    // As long as WriteSectionToDisk works, we work.
    //
    curSection = g_MigrationInf;

    while (curSection && rSuccess) {

        //
        // We skip the [Excluded Paths] and [Migration Paths] sections.
        //
        if (_mbsicmp(curSection -> Name,SECTION_EXCLUDEDPATHS) &&
            _mbsicmp(curSection -> Name,SECTION_MIGRATIONPATHS)) {
            
            rSuccess = pWriteInfSectionToDisk(curSection);
        } 

        curSection = curSection -> Next;
        
    }

    return rSuccess;
}

BOOL
WINAPI
MigInf_PathIsExcluded (
    IN PCSTR    Path
    )
{
    PMIGOBJECT  curExcluded;
    PMIGSECTION section;
    BOOL        rIsExcluded = FALSE;

    //
    // We assume Path is valid.
    //
    assert(Path);
    
    section = pFindSection(SECTION_EXCLUDEDPATHS,MIGINF_NOCREATE);

    if (section) {

        curExcluded = section -> Items;
        
        while (curExcluded && !rIsExcluded) {
            
            rIsExcluded = pPathIsInPath(Path,curExcluded -> Key);
            curExcluded = curExcluded -> Next;
        }
    }
    
    return rIsExcluded;
}



PCSTR
WINAPI
MigInf_GetNewSectionName (
    VOID
    )
{

    static CHAR     sectionName[20];
    static DWORD    seedNum=0;


    sprintf(sectionName,"msg%0.7u",seedNum++);

    return sectionName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\chimemig\poolmem.h ===
#ifndef POOLMEM_H
#define POOLMEM_H

typedef LPVOID POOLHANDLE;


#define POOLMEMORYBLOCKSIZE 8192



POOLHANDLE WINAPI PoolMemInitPool ();
VOID       WINAPI PoolMemDestroyPool (IN POOLHANDLE Handle);
LPVOID     WINAPI PoolMemGetAlignedMemory(IN POOLHANDLE Handle, IN DWORD Size, IN DWORD AlignSize);


#define PoolMemCreateString(h,x)        ((LPTSTR) PoolMemGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PoolMemCreateDword(h)           ((PDWORD) PoolMemGetMemory((h),sizeof(DWORD)))


__inline
LPVOID 
PoolMemGetMemory (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{

    return PoolMemGetAlignedMemory(Handle,Size,0);

}

__inline
LPTSTR 
PoolMemCreateStringA ( 
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{
    return (LPSTR) PoolMemGetAlignedMemory(Handle,Size * sizeof(CHAR),sizeof(CHAR));
}

__inline
LPWSTR 
PoolMemCreateStringW (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{
    return (LPWSTR) PoolMemGetAlignedMemory(Handle,Size * sizeof(WCHAR),sizeof(WCHAR));
}


__inline
PTSTR 
PoolMemDuplicateStringA (
    IN POOLHANDLE    Handle,
    IN LPCSTR       StringToCopy
    )

{

    
    DWORD   stringLength;
    PSTR    rString;

    assert(StringToCopy);

    stringLength = (DWORD) _mbschr(StringToCopy,0) - (DWORD) StringToCopy + 1;
    rString      = PoolMemGetAlignedMemory(Handle,stringLength,sizeof(CHAR));

    if (rString) {

        _mbscpy(rString,StringToCopy);
    }

    return rString;
}


__inline
PWSTR 
PoolMemDuplicateStringW (
    IN POOLHANDLE    Handle,
    IN LPCWSTR       StringToCopy
    )

{

    
    DWORD    stringLength;
    PWSTR    rString;

    assert(StringToCopy);

    stringLength = ((wcslen(StringToCopy)+1)*sizeof(WCHAR));
    rString      = PoolMemGetAlignedMemory(Handle,stringLength,sizeof(WCHAR));

    if (rString) {

        wcscpy(rString,StringToCopy);
    }

    return rString;
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\chimemig\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by test.rc
//
#include "msg.h"

#define IDS_CHS_IME_DATA                100
#define IDS_CHT_IME_DATA                101
#define IDS_PRODUCTID                   102
#define IDS_COMPANYNAME                 103
#define IDS_SUPPORTNUMBER               104
#define IDS_SUPPORTUR                   105
#define IDS_INSTRUCTIONSTOUSER          106

#define IDS_CHT_TABLE1  1000
#define IDS_CHT_TABLE2  1001
#define IDS_CHT_TABLE3  1002
#define IDS_CHT_TABLE4  1003
#define IDS_CHT_TABLE5  1004
#define NUM_OF_CHT_TABLE 5
#define IDS_CHS_TABLE1  2001
#define IDS_CHS_TABLE2  2002
#define IDS_CHS_TABLE3  2003
#define IDS_CHS_TABLE4  2004
#define IDS_CHS_TABLE5  2005
#define IDS_CHS_TABLE6  2006
#define IDS_CHS_TABLE7  2007
#define IDS_CHS_TABLE8  2008
#define IDS_CHS_ENG_TABLE1  3001
#define IDS_CHS_ENG_TABLE2  3002
#define IDS_CHS_ENG_TABLE3  3003
#define NUM_OF_CHS_TABLE 8

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\femgrate\chs.c ===
/****************************** Module Header ******************************\
* Module Name: chs.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* FEMGRATE, CHS speciific functions
*
\***************************************************************************/
#include "femgrate.h"
#include "resource.h"


/******************************Public*Routine******************************\
* ImeDataConvertChs
*
*   Convert Windows NT 351 IME phrase data to Windows NT 5.0.
*
* Arguments:
*
*   HANDLE  hSource - source file handle.
*   HANDLE  hTarget - target file handle.
*
* Return Value:
*   
*   BOOL: TRUE-Success, FALSE-FAIL.
*
* History:
*
\**************************************************************************/

#define MAXWORDLENTH    40
#define MAXCODELENTH    12
#define MAXNUMBER_EMB   1000
#define IMENUM          3
#define MAXIMENAME      15

typedef struct PHRASERECNT{
   WCHAR CODE[MAXCODELENTH];
   WCHAR PHRASE[MAXWORDLENTH];
} RECNT;

 typedef struct PHRASEREC95{
    BYTE  CODE[MAXCODELENTH];
    BYTE  PHRASE[MAXWORDLENTH];
 } REC95;

BOOL IsSizeReasonable(DWORD dwSize)
{
    DWORD dwTemp = (dwSize - sizeof(WORD)) / sizeof(REC95);

    if (((dwSize - sizeof(WORD)) - (dwTemp * sizeof(REC95))) == 0) {
        return TRUE;
    } else {
        return FALSE;
    }

}
BOOL  ImeDataConvertChs(HANDLE  hSource, HANDLE hTarget)
{
    HANDLE hPhrase95, hPhraseNT;
    BYTE *szPhrase95;
    WCHAR *szPhraseNT;
    BOOL bReturn = TRUE;
    int i;
    WORD WordCount;
    DWORD dwSizeofRead;

    hPhrase95 = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, 
                            sizeof(REC95)*MAXNUMBER_EMB+sizeof(WORD));

    hPhraseNT = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, 
                            sizeof(RECNT)*MAXNUMBER_EMB+sizeof(WORD));

    if (!hPhraseNT || !hPhrase95 ) {
        bReturn = FALSE;
        goto Convert_Finish;
    }

    szPhrase95 = GlobalLock(hPhrase95);
    szPhraseNT = GlobalLock(hPhraseNT);

    bReturn = ReadFile(hSource,
                     szPhrase95,
                     sizeof(REC95)*MAXNUMBER_EMB+sizeof(WORD),
                     &dwSizeofRead,
                     NULL);

    if (! bReturn) {
        return FALSE;
    }

    //phrase count
    WordCount = *( (WORD*) szPhrase95);

    *( (WORD*)szPhraseNT) = *((WORD*)szPhrase95);

    DebugMsg((DM_VERBOSE,TEXT("[0]  %d !\n"),WordCount));

    if (dwSizeofRead != *((WORD*)&szPhrase95[0])*sizeof(REC95)+2)
    {

        if (IsSizeReasonable(dwSizeofRead)) {
            *((WORD *) szPhrase95) = (WORD)((dwSizeofRead - sizeof(WORD)) / sizeof(REC95));
        } else {                        
            bReturn = FALSE;
            goto Convert_Finish;
        }
    }



    for (i = 0; i < WordCount; i++)
    {
        MultiByteToWideChar(936, 
                            MB_PRECOMPOSED, 
                            (LPCSTR)(szPhrase95+sizeof(WORD)+i*sizeof(REC95)), 
                            sizeof(REC95),
                            (LPWSTR)((LPBYTE)szPhraseNT+ sizeof(WORD) + i*sizeof(RECNT)), 
                            sizeof(RECNT));
    }

    bReturn = WriteFile((HANDLE)hTarget, 
                        (LPBYTE) szPhraseNT, 
                        sizeof(RECNT)*MAXNUMBER_EMB+sizeof(WORD), 
                        &dwSizeofRead, 
                        NULL);
Convert_Finish:
    if (hPhrase95) {
        GlobalUnlock(hPhrase95);
        GlobalFree(hPhrase95);
    }
    if (hPhraseNT) {
        GlobalUnlock(hPhraseNT);
        GlobalFree(hPhraseNT);
    }
    return bReturn;
}

BOOL ConvertChsANSIImeDataWorker(LPCTSTR EMBFile)
{
    HANDLE  hs, ht;
    TCHAR   szSrcFile[MAX_PATH];
    TCHAR   szDstFile[MAX_PATH];
    BOOL Result;

    //
    // Get Winnt System 32 directory
    //
    GetSystemDirectory(szSrcFile, MAX_PATH);

    ConcatenatePaths(szSrcFile,EMBFile,MAX_PATH);

    lstrcat(szSrcFile,TEXT(".emb"));

    lstrcpy(szDstFile,szSrcFile);
    lstrcat(szDstFile,TEXT(".351"));

    DebugMsg((DM_VERBOSE,TEXT("[ConvertChsANSIImeDataWorker] Src %s Dst %s !\n"),szSrcFile,szDstFile));

    hs = CreateFile(szSrcFile, 
                    GENERIC_READ,
                    0, 
                    NULL,
                    OPEN_EXISTING,
                    0, NULL);

    if (hs == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    ht = CreateFile(szDstFile, 
                    GENERIC_WRITE,
                    0, 
                    NULL,
                    CREATE_ALWAYS,
                    0, NULL);

    if (ht == INVALID_HANDLE_VALUE) {

        CloseHandle(hs);

        return FALSE;
    }



    Result = ImeDataConvertChs(hs, ht);

    CloseHandle(hs);
    CloseHandle(ht);

    return Result;
}


BOOL ConvertChsANSIImeData()
{
    int i;

    TABLELIST IMETableListENG[] = {
        {IDS_ENG_TABLE1,TEXT("")},
        {IDS_ENG_TABLE2,TEXT("")},
        {IDS_ENG_TABLE3,TEXT("")},
        {IDS_ENG_TABLE4,TEXT("")}
    };

    for (i=0; i< sizeof(IMETableListENG) / sizeof(TABLELIST); i++) {

        if (!LoadString(ghInst,IMETableListENG[i].nResID,IMETableListENG[i].szIMEName,MAX_PATH)) {
            continue;
        }

        ConvertChsANSIImeDataWorker(IMETableListENG[i].szIMEName);
        DebugMsg((DM_VERBOSE,TEXT("[ConvertChsANSIImeData] converting ANSI EMB %s !\n"),IMETableListENG[i].szIMEName));

    }
    return TRUE;
}

BOOL CopyCHSIMETable(
    LPCTSTR lpszIMEName,
    LPCTSTR lpszClassPath)
{
    TCHAR szNewPath[MAX_PATH];
    TCHAR szOrgSrcPath[MAX_PATH];
    TCHAR szAltSrcPath[MAX_PATH];
    TCHAR sz351EMB[MAX_PATH];

    BOOL bRet = FALSE;

    DebugMsg((DM_VERBOSE,TEXT("[CopyCHSIMETable] lpszIMEName   = %s !\n"),lpszIMEName));
    DebugMsg((DM_VERBOSE,TEXT("[CopyCHSIMETable] lpszClassPath = %s !\n"),lpszClassPath));

    ExpandEnvironmentStrings(TEXT("%systemroot%"),szOrgSrcPath,sizeof(szOrgSrcPath)/sizeof(szOrgSrcPath[0]));
    ConcatenatePaths(szOrgSrcPath,TEXT("system32"),MAX_PATH); 
    ConcatenatePaths(szOrgSrcPath,lpszIMEName,MAX_PATH); 
    DebugMsg((DM_VERBOSE,TEXT("[UpgradeCHSPerUserIMEData] Old IME %s !\n"),szOrgSrcPath));

    lstrcpy(sz351EMB,szOrgSrcPath);
    lstrcpy(szAltSrcPath,szOrgSrcPath);

    lstrcat(sz351EMB,TEXT(".351"));
    if (IsFileExisting(sz351EMB)) {
        lstrcpy(szAltSrcPath,sz351EMB);
    }

    if (IsFileExisting(szAltSrcPath)) {
        if (GetNewPath(szNewPath,szOrgSrcPath,lpszClassPath)) {
            if (! CopyFile(szAltSrcPath,szNewPath,FALSE)) {
                DebugMsg((DM_VERBOSE,TEXT("[UpgradeCHSPerUserIMEData] Copy %s to %s failed ! %d\n"),szAltSrcPath,szNewPath,GetLastError()));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] Copy %s to %s OK !\n"),szAltSrcPath,szNewPath));
                bRet = TRUE;
            }
        }
    }

    return bRet;
}

BOOL UpgradeCHSPerUserIMEData()
{
    TABLELIST IMETableListCHS[] = {
        {IDS_CHS_TABLE1,TEXT("")},
        {IDS_CHS_TABLE2,TEXT("")},
        {IDS_CHS_TABLE3,TEXT("")},
        {IDS_CHS_TABLE4,TEXT("")}
    };

    TABLELIST IMETableListENG[] = {
        {IDS_ENG_TABLE1,TEXT("")},
        {IDS_ENG_TABLE2,TEXT("")},
        {IDS_ENG_TABLE3,TEXT("")},
        {IDS_ENG_TABLE4,TEXT("")}
    };

    TCHAR szRegPath[MAX_PATH];
    TCHAR szClassPath[MAX_PATH];
    TCHAR szIMEName[MAX_PATH];
    int i;

    LPTSTR lpszRegPathPtr,lpszClassPtr;

    for (i=0; i<sizeof(IMETableListCHS) / sizeof(TABLELIST); i++) {
        if (!LoadString(ghInst,IMETableListCHS[i].nResID,IMETableListCHS[i].szIMEName,MAX_PATH)) {
            DebugMsg((DM_VERBOSE,TEXT("UpgradeCHSPerUserIMEData, load string  failed!\r\n")));
            return FALSE;
        }
        else {
            DebugMsg((DM_VERBOSE,TEXT("UpgradeCHSPerUserIMEData, load string [%s] !\r\n"),IMETableListCHS[i].szIMEName));
        }
    }

    for (i=0; i<sizeof(IMETableListENG) / sizeof(TABLELIST); i++) {
        if (!LoadString(ghInst,IMETableListENG[i].nResID,IMETableListENG[i].szIMEName,MAX_PATH)) {
            DebugMsg((DM_VERBOSE,TEXT("UpgradeCHSPerUserIMEData, load string  failed!\r\n")));
            return FALSE;
        }
        else {
            DebugMsg((DM_VERBOSE,TEXT("UpgradeCHSPerUserIMEData, load string [%s] !\r\n"),IMETableListENG[i].szIMEName));
        }
    }
 
    lstrcpy(szRegPath,TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\"));
    lpszRegPathPtr = szRegPath+lstrlen(szRegPath);

    lstrcpy(szClassPath,TEXT("Microsoft\\IME\\"));
    lpszClassPtr = szClassPath+lstrlen(szClassPath);

    for (i=0; i<sizeof(IMETableListCHS) / sizeof(TABLELIST); i++) {

        lstrcat(szRegPath,IMETableListCHS[i].szIMEName);
        lstrcat(szClassPath,IMETableListENG[i].szIMEName);
        if (!MovePerUserIMEData(HKEY_CURRENT_USER,szRegPath,TEXT("EUDCDictName"),szClassPath,IMETableListENG[i].szIMEName,FALSE)) {
            DebugMsg((DM_VERBOSE,TEXT("[UpgradeCHSPerUserIMEData] MovePerUserIMEData failed ! %s ,%s !\n"),szRegPath,szClassPath));
        }

        lstrcpy(szIMEName,IMETableListENG[i].szIMEName);
        lstrcat(szIMEName,TEXT(".emb"));

        DebugMsg((DM_VERBOSE,TEXT("[UpgradeCHSPerUserIMEData] IME name %s !\n"),szIMEName));

        CopyCHSIMETable(szIMEName,szClassPath);

        *lpszRegPathPtr = TEXT('\0');
        *lpszClassPtr   = TEXT('\0');
    }    

    //
    // special case for winabc
    // 
    lstrcpy(szClassPath,TEXT("Microsoft\\IME\\winabc"));

    CopyCHSIMETable(TEXT("tmmr.rem"),szClassPath);

    CopyCHSIMETable(TEXT("user.rem"),szClassPath);

    return TRUE;
}

int WINAPI WinMainCHS(
    int nCmd,
    HINF hMigrateInf)
{
    const UINT nLocale = LOCALE_CHS;

    switch(nCmd) {
        case FUNC_PatchFEUIFont:
            if (FixSchemeProblem(FALSE,hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSchemeProblem OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixSchemeProblem Fail ! \n")));
            }
            break;
        case FUNC_PatchInSetup:
            if (FixTimeZone(nLocale)) {
                DebugMsg((DM_VERBOSE,TEXT("FixTimeZone OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixTimeZone failed ! \n")));
            }
            break;

        case FUNC_PatchPreload:
            if (PatchPreloadKeyboard(TRUE)) {
                DebugMsg((DM_VERBOSE,TEXT("PatchPreloadKeyboard OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("PatchPreloadKeyboard Failed ! \n")));
            }
            break;
        case FUNC_PatchInLogon:
            if (UpgradeCHSPerUserIMEData()) {
                DebugMsg((DM_VERBOSE,TEXT("PatchPreloadKeyboard OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("PatchPreloadKeyboard Failed ! \n")));
            }
            if (RenameRegValueName(hMigrateInf,TRUE)) {
                DebugMsg((DM_VERBOSE,TEXT("RenameRegValueName OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("RenameRegValueName failed ! \n")));
            }
            break;

        case FUNC_PatchCHSAnsiEMB:

            if (ConvertChsANSIImeData()){
                DebugMsg((DM_VERBOSE,TEXT("ConvertChsANSIImeData OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("ConvertChsANSIImeData failed ! \n")));
            }

    
        case FUNC_PatchTest:
            break;
        default:
            DebugMsg((DM_VERBOSE,TEXT("No such function\n")));
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\femgrate\cht.c ===
/****************************** Module Header ******************************\
* Module Name: cht.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* FEMGRATE, CHT speciific functions
*
\***************************************************************************/
#include "femgrate.h"
#include "resource.h"


BOOL UpgradeCHTPerUserIMEData()
{
    TABLELIST IMETableListCHT[] = {
        {IDS_CHT_TABLE1,TEXT("")},
        {IDS_CHT_TABLE2,TEXT("")},
        {IDS_CHT_TABLE3,TEXT("")},
        {IDS_CHT_TABLE4,TEXT("")},
        {IDS_CHT_TABLE5,TEXT("")}
    };


    TCHAR   szRegPath[MAX_PATH];
    TCHAR   szClassPath[MAX_PATH];
    int i;

    LPTSTR lpszRegPathPtr,lpszClassPtr;

    for (i=0; i<sizeof(IMETableListCHT) / sizeof(TABLELIST); i++) {
        if (!LoadString(ghInst,IMETableListCHT[i].nResID,IMETableListCHT[i].szIMEName,MAX_PATH)) {
            DebugMsg((DM_VERBOSE,TEXT("UpgradeCHTPerUserIMEData, load string  failed!\r\n")));
            return FALSE;
        }
        else {
            DebugMsg((DM_VERBOSE,TEXT("UpgradeCHTPerUserIMEData, MigrateImeEUDCTables, load string [%s] !\r\n"),IMETableListCHT[i].szIMEName));
        }
    }
 

    lstrcpy(szRegPath,TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\"));
    lpszRegPathPtr = szRegPath+lstrlen(szRegPath);

    lstrcpy(szClassPath,TEXT("Microsoft\\IME\\"));
    lpszClassPtr = szClassPath+lstrlen(szClassPath);

    for (i=0; i<sizeof(IMETableListCHT) / sizeof(TABLELIST); i++) {
        lstrcat (szRegPath,IMETableListCHT[i].szIMEName);
        lstrcat (szClassPath,IMETableListCHT[i].szIMEName);
        if (!MovePerUserIMEData(HKEY_CURRENT_USER,szRegPath,TEXT("User Dictionary"),szClassPath,TEXT(""),TRUE)) {
            DebugMsg((DM_VERBOSE,TEXT("[UpgradeCHTPerUserIMEData] MovePerUserIMEData failed ! %s ,%s !\n"),szRegPath,szClassPath));
        }
        *lpszRegPathPtr = TEXT('\0');
        *lpszClassPtr   = TEXT('\0');
    }

    lstrcpy(szRegPath,TEXT("Control Panel\\Input Method"));
    lstrcpy(szClassPath,TEXT("Microsoft\\Lctool"));

    if (!MovePerUserIMEData(HKEY_CURRENT_USER,szRegPath,TEXT("Phrase Prediction Dictionary"),szClassPath,TEXT(""),TRUE)) {
        DebugMsg((DM_VERBOSE,TEXT("[UpgradeCHTPerUserIMEData] MovePerUserIMEData failed ! %s ,%s !\n"),szRegPath,szClassPath));
    }

    if (!MovePerUserIMEData(HKEY_CURRENT_USER,szRegPath,TEXT("Phrase Prediction Pointer"),szClassPath,TEXT(""),TRUE)) {
        DebugMsg((DM_VERBOSE,TEXT("[UpgradeCHTPerUserIMEData] MovePerUserIMEData failed ! %s ,%s !\n"),szRegPath,szClassPath));
    }

    return TRUE;
}

int WINAPI WinMainCHT(
    int nCmd,
    HINF hMigrateInf)
{
    const UINT nLocale = LOCALE_CHT;

    switch(nCmd) {
        case FUNC_PatchFEUIFont:
            if (FixSchemeProblem(FALSE,hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSchemeProblem OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixSchemeProblem Fail ! \n")));
            }
            break;

        case FUNC_PatchInSetup:
            if (FixTimeZone(nLocale)) {
                DebugMsg((DM_VERBOSE,TEXT("FixTimeZone OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixTimeZone failed ! \n")));
            }
            break;

        case FUNC_PatchPreload:
            if (PatchPreloadKeyboard(TRUE)) {
                DebugMsg((DM_VERBOSE,TEXT("PatchPreloadKeyboard OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("PatchPreloadKeyboard Failed ! \n")));
            }
            break;
        case FUNC_PatchInLogon:
            if (UpgradeCHTPerUserIMEData()) {
                DebugMsg((DM_VERBOSE,TEXT("UpgradeCHTPerUserIMEData OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("UpgradeCHTPerUserIMEData Failed ! \n")));
            }
            if (RenameRegValueName(hMigrateInf,TRUE)) {
                DebugMsg((DM_VERBOSE,TEXT("RenameRegValueName OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("RenameRegValueName failed ! \n")));
            }
            
            break;
    
        case FUNC_PatchTest:
            break;
        default:
            DebugMsg((DM_VERBOSE,TEXT("No such function\n")));
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\femgrate\femgrate.h ===
/****************************** Module Header ******************************\
* Module Name: femgrate.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* FEMGRATE, main header file
*
\***************************************************************************/
#ifndef FEMGRATE_H
#define FEMGRATE_H

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <userenv.h>
#include <userenvp.h>
#include <setupapi.h>
#include <spapip.h>
#include <regstr.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <string.h>

#define NO_FUNCTION 0xFF
#define DM_VERBOSE  2

#ifdef UNICODE
#define A2I _wtoi
#else
#define A2I atoi
#endif
#define ARRAYSIZE(s)    (sizeof(s) / (sizeof(s[0])))

#define LOCALE_JPN 0x411
#define LOCALE_KOR 0x412
#define LOCALE_CHT 0x404
#define LOCALE_CHS 0x804

enum FunctionType  {
    FUNC_PatchInLogon,
    FUNC_PatchInSetup,
    FUNC_PatchFEUIFont,
    FUNC_PatchPreload,
    FUNC_PatchCHSAnsiEMB,
    FUNC_PatchTest,
    FUNC_NumofFunctions
};

typedef struct _FUNC_DIR {
    char cFunc;
    int  nID;
} FUNC_DIR;

typedef struct _STRING_TO_DATA {
    TCHAR  String[50];
    UINT   Data;
} STRING_TO_DATA, *PSTRING_TO_DATA;

typedef struct tagTABLIST {
   UINT  nResID;
   TCHAR szIMEName[MAX_PATH];
} TABLELIST,*LPTABLELIST;

#ifdef __cplusplus
extern "C" {
#endif

extern HINSTANCE ghInst;

#define USER_SHELL_FOLDER         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define c_szDot                   TEXT(".")
#define c_szDotDot                TEXT("..")
#define c_szStarDotStar           TEXT("*.*")

//
// utils.c
//
extern STRING_TO_DATA InfRegSpecTohKey[] ;

//#define MYDBG
//#define DEBUGLOG

#ifdef MYDBG
#define DebugMsg(_parameter) Print _parameter

#define DBGTITLE TEXT("FEMGRATE :")

void Print(UINT mask,LPCTSTR pszFormat,...);
#else
#define DebugMsg(_parameter)
#endif

ConcatenatePaths(
    LPTSTR  Target,
    LPCTSTR Path,
    UINT    TargetBufferSize
    );

LPTSTR CheckSlash (LPTSTR lpDir);

void IntToString( DWORD i, LPTSTR sz);

BOOL DoInstallationFromSection(HINF hInf,LPCTSTR lpszSectionName);

BOOL IsInSetupUpgradeMode();

UINT StrToUInt(LPTSTR lpszNum);

UINT GetInstallLocale();

BOOL RegReplaceIfExisting(
    HKEY hKey,
    LPCTSTR pszOldValName,
    LPCTSTR pszNewValName);

BOOL ReplaceString(
    LPCTSTR lpszOldStr,
    LPCTSTR lpszReplaceStr,
    LPCTSTR lpszReplacedWithStr,
    LPTSTR lpszOutputStr);

BOOL Delnode (LPTSTR lpDir);

BOOL GetProgramsDirectory (BOOL bCommonGroup, LPTSTR lpDirectory);

BOOL GetGenericUserFolderDirectory (LPCTSTR lpszFolder, LPTSTR lpDirectory);

 BOOL LookUpStringInTable(
     IN  PSTRING_TO_DATA Table,
     IN  LPCTSTR         String,
     OUT PUINT           Data
     );

BOOL INIFile_ChangeSectionName(
    LPCTSTR szIniFileName,
    LPCTSTR szIniOldSectionName,
    LPCTSTR szIniNewSectionName);

BOOL INIFile_ChangeKeyName(
    LPCTSTR szIniFileName,
    LPCTSTR szIniOldSectionName,
    LPCTSTR szIniOldKeyName,
    LPCTSTR szIniNewKeyName);

UINT CreateNestedDirectory(
    LPCTSTR lpDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes);

BOOL GetApplicationFolderPath(
    LPTSTR lpszFolder,
    UINT nLen);

BOOL GetNewPath(
    LPTSTR  lpszNewPath,
    LPCTSTR lpszFileName,
    LPCTSTR lpszClass);

BOOL MovePerUserIMEData(
    HKEY    hCurrentKey,
    LPCTSTR szRegPath,
    LPCTSTR szRegVal,
    LPCTSTR szUserClass,
    LPCTSTR szIMEName,
    BOOL bCHT);

BOOL CreateSecurityDirectory(
    LPCTSTR pszOldDir,
    LPCTSTR pszNewDir);

BOOL IsDirExisting(
    LPTSTR Dir);

BOOL IsFileExisting(
    LPTSTR File);

BOOL RenameDirectory(
    LPTSTR OldDir,
    LPTSTR NewDir);

BOOL RenameFile(
    LPTSTR OldFile,
    LPTSTR NewFile);

BOOL RenameSectionFiles(
    HINF hInf,
    LPCTSTR SectionName,
    LPCTSTR SourceDirectory,
    LPCTSTR TargetDirectory);

BOOL RenameSectionRegSZ(
    HINF hInf,
    LPCTSTR SectionName,
    HKEY hRootKey,
    LPCTSTR RegPath);


///////////////////////////////////////////////
//
// femgrate.c
//
///////////////////////////////////////////////
BOOL FixTimeZone(UINT nLocale);

BOOL FixSchemeProblem(BOOL bJapan,HINF hInf);

BOOL PatchPreloadKeyboard(BOOL bReplaceDefaultLCID); //if TRUE will replace 409 with default LCID

void FixCurrentSchemeName(HINF hInf);

BOOL RenameRegValueName(HINF hInf, BOOL PerUser);

///////////////////////////////////////////////
//
// jpn.c
//
///////////////////////////////////////////////
int WINAPI WinMainJPN(int nCmd,HINF hInf);

///////////////////////////////////////////////
//
// kor.c
//
///////////////////////////////////////////////
int WINAPI WinMainKOR(int nCmd,HINF hInf);

///////////////////////////////////////////////
//
// cht.c
//
///////////////////////////////////////////////
int WINAPI WinMainCHT(int nCmd,HINF hInf);

///////////////////////////////////////////////
//
// chs.c
//
///////////////////////////////////////////////
int WINAPI WinMainCHS(int nCmd,HINF hInf);

///////////////////////////////////////////////
//
// utils2.cpp
//
///////////////////////////////////////////////

HRESULT FixPathInLink(LPCTSTR pszShortcutFile, LPCTSTR lpszOldStr,LPCTSTR lpszNewStr);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\femgrate\jpn.c ===
/****************************** Module Header ******************************\
* Module Name: jpn.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* FEMGRATE, JPN speciific functions
*
\***************************************************************************/
#include "femgrate.h"
#include <tchar.h>

BOOL FixSpecificFolder(HINF hInf)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("Folder.SpecificObjectToRename");
    LPCTSTR  RegName;
    LPCTSTR  NT4Name;
    LPCTSTR  NT5Name;
    LPCTSTR  MoveIt;

    TCHAR   szUSFRegKey[MAX_PATH];
    TCHAR   szNTUSF[MAX_PATH];
    TCHAR   szExpNT4USF[MAX_PATH];
    TCHAR   szExpNT5USF[MAX_PATH];
    DWORD   dwSize, dwType;
    LONG    lResult;
    UINT    uiCount;
    HKEY    hKey;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSpecificFolder] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSpecificFolder] line count == 0 !\n")));
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (RegName = pSetupGetField(&InfContext,1))
             && (NT4Name = pSetupGetField(&InfContext,2))
             && (NT5Name = pSetupGetField(&InfContext,3))) {

            DebugMsg((DM_VERBOSE,TEXT("FixSpecificFolder: RegName = %s !\n"),RegName));
            DebugMsg((DM_VERBOSE,TEXT("FixSpecificFolder: NT4Name = %s !\n"),NT4Name));
            DebugMsg((DM_VERBOSE,TEXT("FixSpecificFolder: NT5Name = %s !\n"),NT5Name));

            //
            // Query for the user's current "Folder" location.
            //
            DebugMsg((DM_VERBOSE,TEXT("[FixSpecificFolder] FixUserFolder, [%d] !\n"),LineNo));

            lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                                    USER_SHELL_FOLDER,
                                    0,
                                    KEY_READ,
                                    &hKey);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixSpecificFolder] , Open User Shell Folders failed!\n")));
                continue;
            }

            lstrcpy(szUSFRegKey,RegName);

            dwSize = sizeof(szNTUSF);
            lResult = RegQueryValueEx (hKey,
                                       szUSFRegKey,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) szNTUSF,
                                       &dwSize);

            DebugMsg((DM_VERBOSE,TEXT("FixSpecificFolder: Current Value (%s) = %s !\n"),szUSFRegKey,szNTUSF));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] Query User Shell Folders failed!\n")));
                RegCloseKey (hKey);
                continue;
            }


            ExpandEnvironmentStrings (szNTUSF, szExpNT4USF, MAX_PATH);
            ExpandEnvironmentStrings (szNTUSF, szExpNT5USF, MAX_PATH);

            ConcatenatePaths(szExpNT4USF,NT4Name,MAX_PATH);
            ConcatenatePaths(szExpNT5USF,NT5Name,MAX_PATH);


            lResult = GetFileAttributes(szExpNT4USF);

            if (lResult == 0xFFFFFFFF) {
                //
                // Directory does not exist.
                //
                DebugMsg((DM_VERBOSE, TEXT("[FixSpecificFolder] -  File is not existed [%s] !\n"),szExpNT4USF));
            } else if ((lResult & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY) {
               //
               // this isn't a directory
               //
               DebugMsg((DM_VERBOSE, TEXT("[FixSpecificFolder] This is a directory [%s] !\n"),szExpNT4USF));
            } else if (MoveFile(szExpNT4USF, szExpNT5USF)) {
               DebugMsg((DM_VERBOSE, TEXT("[FixSpecificFolder] Move %s to %s OK !\n"),szExpNT4USF, szExpNT5USF));
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("[FixSpecificFolder] Failed to change folder name:\n%s\n%s"),szExpNT4USF,szExpNT5USF));
            }

            RegCloseKey (hKey);
        }

    }

    bRet = TRUE;

err1:
    return bRet;

}


BOOL FixUserFolders(HINF hInf)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("Folder.ObjectToRename");
    LPCTSTR  RegName;
    LPCTSTR  NT4Name;
    LPCTSTR  NT5Name;
    LPCTSTR  MoveIt;

    TCHAR   szUSFRegKey[MAX_PATH];
    TCHAR   szNT4USF[MAX_PATH];
    TCHAR   szExpNT4USF[MAX_PATH];
    TCHAR   szExpNT5USF[MAX_PATH];
    DWORD   dwSize, dwType;
    LONG    lResult;
    UINT    uiCount;
    HKEY    hKey;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] line count == 0 !\n")));
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (RegName = pSetupGetField(&InfContext,1))
             && (NT4Name = pSetupGetField(&InfContext,2))
             && (NT5Name = pSetupGetField(&InfContext,3))
             && (MoveIt  = pSetupGetField(&InfContext,4))) {

            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: RegName = %s !\n"),RegName));
            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: NT4Name = %s !\n"),NT4Name));
            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: NT5Name = %s !\n"),NT5Name));
            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: MoveIt  = %s !\n"),MoveIt));

            //
            // Query for the user's current "Folder" location.
            //
            DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] FixUserFolder, [%d] !\n"),LineNo));

            lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                                    USER_SHELL_FOLDER,
                                    0,
                                    KEY_READ | KEY_WRITE,
                                    &hKey);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] , Open User Shell Folders failed!\n")));
                continue;
            }

            lstrcpy(szUSFRegKey,RegName);

            dwSize = sizeof(szNT4USF);
            lResult = RegQueryValueEx (hKey,
                                       szUSFRegKey,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) szNT4USF,
                                       &dwSize);

            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: Current Value (%s) = %s !\n"),szUSFRegKey,szNT4USF));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] Query User Shell Folders failed!\n")));
                RegCloseKey (hKey);
                continue;
            }


            if (lstrcmpi(NT4Name, szNT4USF) != 0) {
                DebugMsg((DM_VERBOSE, TEXT("[FixUserFolders] NT4Name <> szFolder :\n%s\n"),szExpNT4USF));
                RegCloseKey (hKey);
                continue;
            }
            //
            // MoveIt == 1, we want move it to new folder
            // else, we just update registry
            //
            if (lstrcmp(MoveIt,TEXT("1")) == 0) {

                ExpandEnvironmentStrings (NT4Name, szExpNT4USF, MAX_PATH);
                ExpandEnvironmentStrings (NT5Name, szExpNT5USF, MAX_PATH);
                if (CopyProfileDirectory (szExpNT4USF, szExpNT5USF, CPD_IGNOREHIVE)) {
                    DebugMsg((DM_VERBOSE, TEXT("Fix Folder:  Successfully changed folder name:\n%s\n%s"),szExpNT4USF,szExpNT5USF));
                    if (Delnode (szExpNT4USF)) {
                        DebugMsg((DM_VERBOSE, TEXT("[FixUserFolders] Successfully remove folder:\n%s\n"),szExpNT4USF));
                    }
                    else {
                        DebugMsg((DM_VERBOSE, TEXT("[FixUserFolders] Failed remove folder:\n%s\n"),szExpNT4USF));
                    }
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("[FixUserFolders] Failed to change folder name:\n%s\n%s"),szExpNT4USF,szExpNT5USF));
                }
            }

            //
            // Set CSIDL_PERSONAL to point to this directory.
            //

            lResult = RegSetValueEx (hKey, szUSFRegKey, 0, REG_EXPAND_SZ,
                                    (LPBYTE) NT5Name, (lstrlen(NT5Name) + 1) * sizeof(TCHAR));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE, TEXT("[FixUserFolders] Set Registry faile, %s,%s\n"),szUSFRegKey,NT5Name));
            }

            RegCloseKey (hKey);
        }

    }

    bRet = TRUE;

err1:
    return bRet;

}


BOOL FixFoldersInSetup(HINF hInf,BOOL bCommonGroup)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("Folder.ObjectToRenameInSetup");

    LPCTSTR  RegName;
    LPCTSTR  NT4Name;
    LPCTSTR  NT5Name;

    TCHAR   szUSFRegKey[MAX_PATH];

    TCHAR   szNT5USF[MAX_PATH];
    TCHAR   szNT4USF[MAX_PATH];
    TCHAR   szExpNT4USF[MAX_PATH];
    TCHAR   szExpNT5USF[MAX_PATH];

    DWORD   dwSize, dwType;
    LONG    lResult;
    HKEY    hKey;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] line count == 0 !\n")));
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (RegName = pSetupGetField(&InfContext,1))
             && (NT4Name = pSetupGetField(&InfContext,2))
             && (NT5Name = pSetupGetField(&InfContext,3))) {

            DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] Line# [%d] !\n"),LineNo));
            DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] RegName = %s !\n"),RegName));
            DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] NT4Name = %s !\n"),NT4Name));
            DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] NT5Name = %s !\n"),NT5Name));

            //
            // Query for the user's current "Folder" location.
            //

            lResult = RegOpenKeyEx ((bCommonGroup ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER),
                                    USER_SHELL_FOLDER, 0, KEY_READ | KEY_WRITE, &hKey);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] FixSpecialFolder, Open User Shell Folders failed!\n")));
                continue;
            }


            if (bCommonGroup) {
                lstrcpy (szUSFRegKey,TEXT("Common "));
                lstrcat (szUSFRegKey,RegName);
            } else {
                lstrcpy (szUSFRegKey,RegName);
            }

            dwSize = sizeof(szNT5USF);
            lResult = RegQueryValueEx (hKey,
                                       szUSFRegKey,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) szNT5USF,
                                       &dwSize);

            DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] Current Registry Value (%s) = %s !\n"),szUSFRegKey,szNT5USF));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] Query User Shell Folders failed!\n")));
                RegCloseKey(hKey);
                continue;
            }


            if (_tcsstr(szNT5USF,NT4Name)) {
                //
                // it means the value is still in SB
                //
                lstrcpy(szNT4USF,szNT5USF);

                if (ReplaceString(szNT4USF,NT4Name,NT5Name,szNT5USF)) {
                    ExpandEnvironmentStrings (szNT4USF, szExpNT4USF, MAX_PATH);
                    ExpandEnvironmentStrings (szNT5USF, szExpNT5USF, MAX_PATH);
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] szExpNT4USF = %s\n"),szExpNT4USF));
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] case 1 szExpNT5USF = %s\n"),szExpNT5USF));
                } else {
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] case 1 The replace string got error \n")));
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup]  %s\n %s\n %s\n%s\n"),szNT5USF,NT5Name,NT4Name,szNT4USF));
                }

                lResult = RegSetValueEx (hKey,
                         szUSFRegKey,
                         0,
                         REG_SZ,
                         (LPBYTE) szNT5USF,
                         (lstrlen(szNT5USF)+1)*sizeof(TCHAR));

                if (lResult == ERROR_SUCCESS) {
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup]  set registry value %s = %s \n"),szUSFRegKey,szNT5USF));
                } else {
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup]  failed set registry value %s = %s \n"),szUSFRegKey,szNT5USF));
                }
            } else {
                //
                // it means the value has been changed to DB
                //
                if (ReplaceString(szNT5USF,NT5Name,NT4Name,szNT4USF)) {
                    ExpandEnvironmentStrings (szNT4USF, szExpNT4USF, MAX_PATH);
                    ExpandEnvironmentStrings (szNT5USF, szExpNT5USF, MAX_PATH);
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] case 2 szExpNT4USF = %s\n"),szExpNT4USF));
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] case 2 szExpNT5USF = %s\n"),szExpNT5USF));
                } else {
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] The replace string got error \n")));
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup]  %s\n %s\n %s\n%s\n"),szNT5USF,NT5Name,NT4Name,szNT4USF));
                }

            }

            //
            // here is a bug in build before 2072 that the ACLS of "all users" has no read access to "everyone"
            //
            // The new created directory will inherit this attributes, and it caused access denied.
            //
            // so we apply old directory's ACL to new one
            //
            // this is compatibile with US version
            //
            if (bCommonGroup) {
                if (CreateSecurityDirectory(szExpNT4USF, szExpNT5USF)) {
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] CreateSecurityDirectory %s %s OK \n"),szExpNT4USF, szExpNT5USF)); 
                } else {
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] CreateSecurityDirectory %s %s Failed \n"),szExpNT4USF, szExpNT5USF)); 
                }
            }

            if (CopyProfileDirectory (szExpNT4USF, szExpNT5USF, CPD_IGNOREHIVE)) {
                DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] Successfully copied folder\nFrom:%s\nTo  :%s\n"),szExpNT4USF,szExpNT5USF));
                if (Delnode (szExpNT4USF)) {
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] Successfully removed folder:%s\n"),szExpNT4USF));
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("Fix Folder:  Failed remove folder:\n%s\n"),szExpNT4USF));
                }
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("Fix Folder:  Failed to change folder name:\n%s\n%s"),szExpNT4USF,szExpNT5USF));
            }
            RegCloseKey (hKey);

        }

    }

    bRet = TRUE;

err1:
    return bRet;

}


BOOL FixCommon(HINF hInf)
{

    TCHAR szCommon[MAX_PATH];
    TCHAR szProgramFolderPath[MAX_PATH];
    TCHAR szExpProgramFolderPath[MAX_PATH];

    BOOL bRet = FALSE;
    HANDLE hFile;

    DWORD RequiredSize;
    WIN32_FIND_DATA fd;
    UINT nCommon, nFileName;
    LPTSTR lpTag, lpEnd, lpEnd2;

    szExpProgramFolderPath[0] = 0;
    //
    //  Loop through all the program groups in the All Users profile
    //  and remove the " (Common)" tag.
    //
    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixCommon] Open femgrate.inf failed !\n")));
        return FALSE;
    }
    if (! SetupGetLineText(NULL,
                           hInf,
                           TEXT("Misc"),
                           TEXT("Common"),
                           szCommon,
                           sizeof(szCommon),
                           &RequiredSize)) {
        goto err1;
    }

    nCommon = lstrlen(szCommon);
    GetProgramsDirectory(TRUE,szProgramFolderPath);
    ExpandEnvironmentStrings (szProgramFolderPath, szExpProgramFolderPath, MAX_PATH);
    
    lstrcpy(szProgramFolderPath,szExpProgramFolderPath);

    //
    // From here, szProgramFolderPath used for Folder name without "Common"
    //
    lpEnd  = CheckSlash (szExpProgramFolderPath);
    lpEnd2 = CheckSlash (szProgramFolderPath);

    lstrcpy (lpEnd, c_szStarDotStar);

    hFile = FindFirstFile (szExpProgramFolderPath, &fd);
    DebugMsg((DM_VERBOSE, TEXT("[FixCommon] Find %s\n"),szExpProgramFolderPath));

    if (hFile != INVALID_HANDLE_VALUE) {

        do  {

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                nFileName = lstrlen (fd.cFileName);
                DebugMsg((DM_VERBOSE, TEXT("Find %s\n"),fd.cFileName));

                if (nFileName > nCommon) {
                    lpTag = fd.cFileName + nFileName - nCommon;

                    DebugMsg((DM_VERBOSE, TEXT("[FixCommon] lpTag=%s szCommon=%s\n"),lpTag, szCommon));
                    if (!lstrcmpi(lpTag, szCommon)) {

                        lstrcpy (lpEnd, fd.cFileName);
                        *lpTag = TEXT('\0');
                        lstrcpy (lpEnd2, fd.cFileName);

                        if (CopyProfileDirectory (szExpProgramFolderPath, szProgramFolderPath, CPD_IGNOREHIVE)) {

                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :  Successfully changed group name:\n")));
                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :      Orginial:  %s\n"), szExpProgramFolderPath));
                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :      New:       %s\n"), szProgramFolderPath));
                            if (Delnode (szExpProgramFolderPath)) {
                                DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :  Successfully remove folder:\n%s\n"),szExpProgramFolderPath));
                            }
                            else {
                                DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :  Failed remove folder:\n%s\n"),szExpProgramFolderPath));
                            }


                        } else {
                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :  Failed to change group name with error %d.\n"), GetLastError()));
                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :      Orginial:  %s\n"), szExpProgramFolderPath));
                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :      New:       %s\n"), szProgramFolderPath));
                        }
                    }
                }
            }

        } while (FindNextFile(hFile, &fd));

        FindClose (hFile);
    }

    bRet = TRUE;
err1:

    return bRet;

}

BOOL RenameLink(
    BOOL bCommonGroup,
    LPCTSTR ObjSrcName,
    LPCTSTR ObjDstName,
    LPCTSTR ObjPath)
{
    TCHAR szSrcPath[MAX_PATH];
    TCHAR szDstPath[MAX_PATH];
    LONG  lResult;
    BOOL  bRet=FALSE;


    DebugMsg((DM_VERBOSE,TEXT("[RenameLink] \nOld = %s\nNew = %s\nPath = %s\n"),ObjSrcName,ObjDstName,ObjPath));

    if (!GetProgramsDirectory(bCommonGroup,szSrcPath))
        return bRet;

    if ( !GetProgramsDirectory(bCommonGroup,szDstPath))
        return bRet;

    if (ObjPath && *ObjPath) {
        ConcatenatePaths(szSrcPath,ObjPath,MAX_PATH);
        ConcatenatePaths(szDstPath,ObjPath,MAX_PATH);
    }

    ConcatenatePaths(szSrcPath,ObjSrcName,MAX_PATH);
    ConcatenatePaths(szDstPath,ObjDstName,MAX_PATH);

    lstrcat(szSrcPath,TEXT(".lnk"));
    lstrcat(szDstPath,TEXT(".lnk"));


    lResult = GetFileAttributes(szSrcPath);

    if (lResult == 0xFFFFFFFF) {
        //
        // Directory does not exist.
        //
        DebugMsg((DM_VERBOSE, TEXT("[RenameLink] File is not existed [%s] !\n"),szSrcPath));
        goto err1;
    }

    if (lResult & FILE_ATTRIBUTE_DIRECTORY) {
        //
        // this is a directory, but we want a file.
        //
        DebugMsg((DM_VERBOSE, TEXT("[RenameLink] This is a directory [%s] !\n"),szSrcPath));
        goto err1;
    }

    //
    // if destination file existed, it's not good !
    //
    lResult = GetFileAttributes(szDstPath);

    if (lResult == 0xFFFFFFFF) {

        if (MoveFile (szSrcPath, szDstPath)) {
            DebugMsg((DM_VERBOSE, TEXT("[RenameLink]  Successfully changed link name:\n%s\n%s\n"),szSrcPath,szDstPath));
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("[RenameLink]  Failed to change link name with error %d.\n%s\n%s\n"), GetLastError(),szSrcPath,szDstPath));
            goto err1;
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("[RenameLink]  Destination file existed, maybe we don't want to overwrite ,%s\n"),szDstPath));
        goto err1;
    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL RenameFolder(
    BOOL bCommonGroup,
    LPCTSTR ObjSrcName,
    LPCTSTR ObjDstName)
{
    TCHAR szSrcPath[MAX_PATH];
    TCHAR szDstPath[MAX_PATH];
    LONG  lResult;
    BOOL  bRet=FALSE;

    DebugMsg((DM_VERBOSE,TEXT("[RenameFolder]\nOld = %s\nNew = %s\n"),ObjSrcName,ObjDstName));

    GetProgramsDirectory(bCommonGroup,szSrcPath);
    GetProgramsDirectory(bCommonGroup,szDstPath);

    ConcatenatePaths(szSrcPath,ObjSrcName,MAX_PATH);
    ConcatenatePaths(szDstPath,ObjDstName,MAX_PATH);

    lResult = GetFileAttributes(szSrcPath);

    if (lResult == 0xFFFFFFFF) {
        //
        // Directory does not exist.
        //
        DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] Directory is not existed [%s] !\n"),szSrcPath));
        goto err1;
    }

    if (!(lResult & FILE_ATTRIBUTE_DIRECTORY)) {
        //
        // this is not a directory.
        //
        DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] This is not a directory [%s] !\n"),szSrcPath));
        goto err1;
    }

    if (CopyProfileDirectory (szSrcPath, szDstPath, CPD_IGNOREHIVE)) {
        DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] Successfully changed folder name:\n%s\n%s"),szSrcPath,szDstPath));
        if (! Delnode(szSrcPath)) {
            DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] Delete old folder (%s) failed !"), szSrcPath));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] Delete old folder (%s) successfully !"), szSrcPath));
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] Convert Folder:  Failed to change group name with error %d\n.%s\n%s\n"), GetLastError(),szSrcPath,szDstPath));
        goto err1;
    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL RenameProgramFolderOrLink(HINF hInf,BOOL bCommon)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("StartMenu.ObjectToRename");
    LPCTSTR  ObjectType;
    LPCTSTR  ObjectSrcName;
    LPCTSTR  ObjectDstName;
    LPCTSTR  ObjectPath;
    LPCTSTR  GroupAttribute;
    BOOL    CommonGroup;
    BOOL    IsMenuItem;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if(SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
           && (ObjectType = pSetupGetField(&InfContext,1))
           && (ObjectSrcName = pSetupGetField(&InfContext,2))
           && (ObjectDstName = pSetupGetField(&InfContext,3))
           && (GroupAttribute = pSetupGetField(&InfContext,5))) {

            ObjectPath = pSetupGetField(&InfContext,4);

            IsMenuItem  = A2I(ObjectType);
            CommonGroup = A2I(GroupAttribute);


            if ((bCommon && (CommonGroup == 0)) ||
                 (!bCommon && (CommonGroup == 1))) {

//            DebugMsg((DM_VERBOSE,TEXT("Eject this line(%d) .....................................\n"),LineNo));
//            DebugMsg((DM_VERBOSE,TEXT("ObjectType    = %s\n"),ObjectType));
//            DebugMsg((DM_VERBOSE,TEXT("ObjectSrcName = %s\n"),ObjectSrcName));
//            DebugMsg((DM_VERBOSE,TEXT("ObjectDstName = %s\n"),ObjectDstName));
//            DebugMsg((DM_VERBOSE,TEXT("GroupAttribute= %s\n"),GroupAttribute));
//            DebugMsg((DM_VERBOSE,TEXT("bCommon = %d\n"),bCommon));
                continue;
            }

            if (IsMenuItem) {
//                DebugMsg((DM_VERBOSE,TEXT("RenameLink (%d).....................................\n"),LineNo));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectType    = %s\n"),ObjectType));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectSrcName = %s\n"),ObjectSrcName));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectDstName = %s\n"),ObjectDstName));
//                DebugMsg((DM_VERBOSE,TEXT("GroupAttribute= %s\n"),GroupAttribute));
//                DebugMsg((DM_VERBOSE,TEXT("bCommon = %d\n"),bCommon));

                RenameLink(bCommon,ObjectSrcName,ObjectDstName,ObjectPath);

            }
            else {
//                DebugMsg((DM_VERBOSE,TEXT("RenameFolder (%d) .....................................\n"),LineNo));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectType    = %s\n"),ObjectType));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectSrcName = %s\n"),ObjectSrcName));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectDstName = %s\n"),ObjectDstName));
//                DebugMsg((DM_VERBOSE,TEXT("GroupAttribute= %s\n"),GroupAttribute));
//                DebugMsg((DM_VERBOSE,TEXT("bCommon = %d\n"),bCommon));
                RenameFolder(bCommon,ObjectSrcName,ObjectDstName);

            }

        }
    }

    bRet = TRUE;
err1:
    return bRet;

}

//
// Fix Sound scheme that originally is SB katana
//
BOOL MapSBtoDBKana(HINF hInf,LPCTSTR lpszSectionName,LPTSTR lpszSoundName)
{
    LPCTSTR szSBKana,szDBKana;

    LONG LineCount,LineNo;
    DWORD dwSize,dwType;
    INFCONTEXT InfContext;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[MapSBtoDBKana] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,lpszSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[MapSBtoDBKana] line count == 0 !\n")));
        return FALSE;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,lpszSectionName,LineNo,&InfContext)
             && (szSBKana = pSetupGetField(&InfContext,1))) {

            if (lstrcmpi(szSBKana,lpszSoundName) == 0) {
                if (szDBKana = pSetupGetField(&InfContext,2)) {
                    lstrcpy(lpszSoundName,szDBKana);
                    return TRUE;
                }
                else {
                    //
                    // inf error, no second data
                    //
                    return FALSE;
                }
            }

        }
    }
    return FALSE;
}

BOOL NameSubstitution(HINF hInf,LPTSTR lpszOrgName,LPTSTR lpszDir,LPTSTR lpszSection)
{
    TCHAR szExpDir[MAX_PATH];
    LPTSTR lpszAnchor;
    TCHAR szOnlyName[MAX_PATH];

    if (_tcsstr(lpszOrgName,TEXT("\\"))) {
        if (ExpandEnvironmentStrings(lpszDir,szExpDir,MAX_PATH) == 0) {
            return FALSE;
        }

        _tcsupr(lpszOrgName);
        _tcsupr(szExpDir);
        lpszAnchor = _tcsstr(lpszOrgName,szExpDir);
        if ((lpszAnchor == NULL ) || (lpszAnchor != lpszOrgName)) {
            return FALSE;
        }

        lstrcpy(szOnlyName,lpszAnchor+lstrlen(szExpDir));
        DebugMsg((DM_VERBOSE,TEXT("We want to find %s !\n"),szOnlyName));

        if (MapSBtoDBKana(hInf,lpszSection,szOnlyName)) {
            lstrcpy(lpszAnchor+lstrlen(szExpDir),szOnlyName);
            return TRUE;
        }
    }
    else {
        if (MapSBtoDBKana(hInf,lpszSection,lpszOrgName)) {
            return TRUE;
        }

    }
    return FALSE;

}

BOOL EnumSoundSchemeApps(HKEY hKey,HINF hInf)
{
    HKEY hSubKey;
    DWORD dwIndex;
    DWORD dwKeyNameSize;
    TCHAR szKeyName[MAX_PATH];
    DWORD dwSoundValue;
    TCHAR szSoundValue[MAX_PATH];
    LONG lResult;

    dwKeyNameSize = sizeof(szKeyName)/sizeof(szKeyName[0]);
    for (dwIndex = 0;
         RegEnumKey(hKey, dwIndex, szKeyName, dwKeyNameSize) == ERROR_SUCCESS;
         dwIndex++) {
         lResult = RegOpenKey(hKey,
                              szKeyName,
                              &hSubKey);
         if (lResult == ERROR_SUCCESS) {
             EnumSoundSchemeApps(hSubKey,hInf);
             RegCloseKey(hSubKey);
         }
    }

    //
    // no sub-key, then just get the value
    //

    if (dwIndex == 0) {
        dwSoundValue = sizeof(szSoundValue);
        lResult = RegQueryValue(hKey,
                                NULL,
                                szSoundValue,
                                &dwSoundValue);

        if (lResult == ERROR_SUCCESS) {
            if (szSoundValue[0]) {
                if (NameSubstitution(hInf,szSoundValue,TEXT("%SystemRoot%\\Media\\"),TEXT("Sound.Files"))) {
                    RegSetValue(hKey,
                                NULL,
                                REG_SZ,
                                szSoundValue,
                                (lstrlen(szSoundValue)+1)*sizeof(TCHAR));
                }
            }
        }
    }
    return TRUE;
}

BOOL FixSoundRegValue(HINF hInf)
{
    LONG lResult;
    BOOL bRet=FALSE;
    HKEY hKey;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSoundRegValue] Open femgrate.inf failed !\n")));
        goto Err0;
    }

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            REGSTR_PATH_APPS,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Open REGSTR_PATH_APPEARANCE failed !\n")));
        goto Err0;
    }

    EnumSoundSchemeApps(hKey,hInf);

    if (! DoInstallationFromSection(hInf, TEXT("Sound.Reg.Update"))) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSoundRegValue]  DoInstallationFromSection failed !\n")));
        goto Err1;
    }

    bRet = TRUE;
Err1:
    RegCloseKey(hKey);
Err0:
    return bRet;
}

//
// Search the registry and find SB value then replace with DB value
//
BOOL FixSBKanaRegValue(HINF hInf)
{
    LPCTSTR szRegRoot,szRegPath;
    LPCTSTR szRegSBVal,szRegDBVal;
    LPCTSTR szRegSBData,szRegDBData;

    LONG LineCount,LineNo;
    DWORD dwSize,dwType;
    INFCONTEXT InfContext;
    HKEY hKey,hKeyRoot;
    BOOL bOK;
    TCHAR szRegCurData[MAX_PATH];
    LONG lResult;

    LPCTSTR lpszSectionName = TEXT("Reg.UpdateIfExsit");

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSBKanaRegValue] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,lpszSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSBKanaRegValue] line count == 0 !\n")));
        return FALSE;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,lpszSectionName,LineNo,&InfContext)
             && (szRegRoot   = pSetupGetField(&InfContext,1))
             && (szRegPath   = pSetupGetField(&InfContext,2))
             && (szRegSBData = pSetupGetField(&InfContext,4))
             && (szRegDBData = pSetupGetField(&InfContext,6))) {

            szRegSBVal  = pSetupGetField(&InfContext,3);
            szRegDBVal  = pSetupGetField(&InfContext,5);

            if (!LookUpStringInTable(InfRegSpecTohKey,szRegRoot,(PUINT)&hKeyRoot)) {
                continue;
            }

            lResult = RegOpenKeyEx( hKeyRoot,
                                    szRegPath,
                                    0,
                                    KEY_READ | KEY_WRITE,
                                    &hKey);
            if (lResult != ERROR_SUCCESS) {
                continue;
            }

            dwSize = sizeof(szRegCurData);
            lResult = RegQueryValueEx (hKey, 
                                       szRegSBVal,
                                       NULL, 
                                       &dwType, 
                                       (LPBYTE) szRegCurData, 
                                       &dwSize);

            if (lResult != ERROR_SUCCESS) {
                goto Err1;
            }

            if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) {
                goto Err1;
            }

            DebugMsg((DM_VERBOSE,TEXT("[FixSBKanaRegValue] szRegPath = %s, old data = %s, SB data = %s!\n"),szRegPath,szRegCurData,szRegSBData));
            if (lstrcmp(szRegCurData,szRegSBData ) == 0) {
#if 1
                lResult = RegSetValueEx (hKey, 
                                          szRegSBVal,
                                          0, 
                                          dwType, 
                                          (LPBYTE) szRegDBData, 
                                          (lstrlen(szRegDBData)+1) * sizeof (TCHAR));
#endif
                DebugMsg((DM_VERBOSE,TEXT("[FixSBKanaRegValue] Set reg value %s,%s,%s!\n"),szRegPath,szRegSBVal,szRegDBData));

                if (lResult != ERROR_SUCCESS) {
                    DebugMsg((DM_VERBOSE,TEXT("[FixSBKanaRegValue] Set reg value error %s,%s == 0 !\n"),szRegSBVal,szRegDBData));
                }
            } else {
                DebugMsg((DM_VERBOSE,TEXT("[FixSBKanaRegValue] szRegPath = %s, old data = %s, SB data = %s , comparing result is different !\n"),szRegPath,szRegCurData,szRegSBData));
            }
Err1:
            RegCloseKey(hKey);

        }
    }
    return TRUE;
}


//
// Fix Patterns
//
BOOL FixPatterns(HINF hInf)
{
    LONG lResult;
    BOOL bRet=FALSE;
    HKEY hKey;
    LONG LineNo,LineCount;
    LPCTSTR pszOldValName;
    LPCTSTR pszNewValName;
    LPCTSTR  szSectionName = TEXT("Patterns");
    INFCONTEXT InfContext;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixPatterns] Open femgrate.inf failed !\n")));
        goto Err0;
    }

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            TEXT("Control Panel\\Patterns"),
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixPatterns] Open Control Panel\\Patterns failed !\n")));
        goto Err0;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        goto Err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (pszOldValName = pSetupGetField(&InfContext,1))
             && (pszNewValName  = pSetupGetField(&InfContext,2))) {

            if (RegReplaceIfExisting(hKey,pszOldValName,pszNewValName)) {
                DebugMsg((DM_VERBOSE,TEXT("[FixPatterns] Replace pattern %s with %s OK !\n"),pszOldValName,pszNewValName));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("[FixPatterns] Replace pattern %s with %s Failed !\n"),pszOldValName,pszNewValName));
            }
        }
    }
    bRet = TRUE;
Err1:
    RegCloseKey(hKey);
Err0:
    return bRet;

}

//
// FixCurrentWallPaperInDeskTop
//

BOOL FixCurrentWallPaperInDeskTop(HINF hInf)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwType,dwSize;
    TCHAR szData[MAX_PATH];
    BOOL bRet = FALSE;


    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            TEXT("Control Panel\\Desktop"),
                            0,
                            KEY_READ | KEY_WRITE,
                            &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixCurrentWallPaperInDeskTop] , Open Control Panel\\Desktop failed!\n")));
        goto Err0;
    }

    dwSize = sizeof(szData);
    lResult = RegQueryValueEx (hKey,
                               TEXT("Wallpaper"),
                               NULL,
                               &dwType,
                               (LPBYTE) szData,
                               &dwSize);

    DebugMsg((DM_VERBOSE,TEXT("FixCurrentWallPaperInDeskTop: Current WallPaperValue is %s !\n"),szData));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixCurrentWallPaperInDeskTop] Query Current WallPaperValue failed!\n")));
        goto Err1;
    }

    if (NameSubstitution(hInf,szData,TEXT("%systemroot%\\"),TEXT("WallPaper.Reg"))) {
        lResult = RegSetValueEx(hKey, 
                                TEXT("Wallpaper"),
                                0, 
                                REG_SZ,
                                (LPBYTE) szData, 
                                (lstrlen(szData) + 1) * sizeof(TCHAR));

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE,TEXT("[FixCurrentWallPaperInDeskTop] RegSetValue WallPaperValue failed!\n")));
            goto Err1;
        }
    }
    DebugMsg((DM_VERBOSE,TEXT("[FixCurrentWallPaperInDeskTop] Current WallPaper has been changed to %s!\n"),szData));
    bRet = TRUE;
Err1:
    RegCloseKey(hKey);
Err0:
    return bRet;
}


//
//  FixAppearanceScheme
//
BOOL FixAppearanceScheme(HINF hInf)
{
    HKEY hAppearanceKey,hSchemeKey;
    LONG lResult;
    LPCTSTR szSectionName = TEXT("Apperance Scheme");
    TCHAR szCurrentScheme[MAX_PATH];
    LPCTSTR NT4SchemeName;
    LPCTSTR NT5SchemeName;
    LONG LineCount,LineNo;
    DWORD dwSize,dwType;
    INFCONTEXT InfContext;

    BOOL bRet = FALSE;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Open femgrate.inf failed !\n")));
        goto Err0;
    }

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            REGSTR_PATH_APPEARANCE,
                            0,
                            KEY_ALL_ACCESS,
                            &hAppearanceKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Open REGSTR_PATH_APPEARANCE failed !\n")));
        goto Err0;
    }

    //
    // Now query for the programs directory
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    szCurrentScheme[0] = TEXT('\0');


    lResult = RegQueryValueEx (hAppearanceKey,
                               TEXT("Current"),
                               NULL,
                               &dwType,
                               (LPBYTE) szCurrentScheme,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        //
        // this case is fine
        //
        szCurrentScheme[0] = TEXT('\0');
    }


    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            REGSTR_PATH_LOOKSCHEMES,
                            0,
                            KEY_ALL_ACCESS,
                            &hSchemeKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Open REGSTR_PATH_APPEARANCE failed !\n")));
        goto Err1;
    }


    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] line count == 0 !\n")));
        goto Err2;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (NT4SchemeName = pSetupGetField(&InfContext,1))) {

            if (szCurrentScheme[0] != '\0') {
                if (lstrcmp(szCurrentScheme,NT4SchemeName) == 0) {
                    if (NT5SchemeName = pSetupGetField(&InfContext,2)) {
                        lResult = RegSetValueEx(hAppearanceKey,
                                                TEXT("Current"),
                                                0,
                                                REG_SZ,
                                                (LPBYTE) NT5SchemeName,
                                                (lstrlen(NT5SchemeName)+1)*sizeof(TCHAR));
                        if (lResult != ERROR_SUCCESS) {
                            DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Set Appearance current scheme fail ! \n")));
                        }

                    }
                    else {
                        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] NT5's scheme missed!\n")));
                    }
                }

            }
            lResult = RegDeleteValue(hSchemeKey,
                                     NT4SchemeName);
            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] ----------------------- Delete scheme [%d], %s failed !\n"),LineNo,NT4SchemeName));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] ----------------------- Delete scheme [%d], %s OK !\n"),LineNo,NT4SchemeName));
            }
        }
    }

    bRet = TRUE;

Err2:
    RegCloseKey(hSchemeKey);
Err1:
    RegCloseKey(hAppearanceKey);
Err0:
    return bRet;

}

//
//ntbug#113976,#113007
//
// SB section in win.ini and entpack.ini
//
// replace SB section name with DB section name
//
BOOL FixSBIniSectionWithDBIniSection(HINF hInf)
{
    LONG lResult;
    LPCTSTR szSectionName = TEXT("INISectionRename");
    LONG LineCount,LineNo;
    DWORD dwSize,dwType;
    INFCONTEXT InfContext;
    LPCTSTR   pszIniFile,pszSBName,pszDBName;
    BOOL bRet = FALSE;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSBIniSectionWithDBIniSection] Open femgrate.inf failed !\n")));
        goto Err0;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSBIniSectionWithDBIniSection] line count == 0 !\n")));
        goto Err0;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext) &&
            (pszIniFile = pSetupGetField(&InfContext,1))               && 
            (pszSBName  = pSetupGetField(&InfContext,2))               &&
            (pszDBName  = pSetupGetField(&InfContext,3))) {

            if (INIFile_ChangeSectionName (pszIniFile,pszSBName,pszDBName)) {
                DebugMsg((DM_VERBOSE,TEXT("[FixSBIniSectionWithDBIniSection] INIFile_ChangeSectionName %s,%s,%s OK !\n"),
                          pszIniFile,pszSBName,pszDBName));

            } else {
                DebugMsg((DM_VERBOSE,TEXT("[FixSBIniSectionWithDBIniSection] INIFile_ChangeSectionName %s,%s,%s Failed !\n"),
                          pszIniFile,pszSBName,pszDBName));
            }

        }
    }

    bRet = TRUE;

Err0:
    return bRet;

}

BOOL FixSBIniKeyWithDBIniKey(HINF hInf)
{
    LONG lResult;
    LPCTSTR szSectionName = TEXT("INIKeyRename");
    LONG LineCount,LineNo;
    DWORD dwSize,dwType;
    INFCONTEXT InfContext;
    LPCTSTR   pszIniFile,pszSection,pszSBName,pszDBName;
    BOOL bRet = FALSE;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSBIniKeyWithDBIniKey] Open femgrate.inf failed !\n")));
        goto Err0;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSBIniKeyWithDBIniKey] line count == 0 !\n")));
        goto Err0;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext) &&
            (pszIniFile = pSetupGetField(&InfContext,1))               && 
            (pszSection = pSetupGetField(&InfContext,2))               && 
            (pszSBName  = pSetupGetField(&InfContext,3))               &&
            (pszDBName  = pSetupGetField(&InfContext,4))) {

            if (INIFile_ChangeKeyName (pszIniFile,pszSection,pszSBName,pszDBName)) {
                DebugMsg((DM_VERBOSE,TEXT("[FixSBIniKeyWithDBIniKey] INIFile_ChangeSectionName %s,%s,%s OK !\n"),
                          pszIniFile,pszSBName,pszDBName));

            } else {
                DebugMsg((DM_VERBOSE,TEXT("[FixSBIniKeyWithDBIniKey] INIFile_ChangeSectionName %s,%s,%s Failed !\n"),
                          pszIniFile,pszSBName,pszDBName));
            }

        }
    }

    bRet = TRUE;

Err0:
    return bRet;

}

//
// this is a dup of RenameLink, should unify them later
//
BOOL RenameGenericLink(
    LPCTSTR FolderName,
    LPCTSTR ObjSrcName,
    LPCTSTR ObjDstName)
{
    TCHAR szSrcPath[MAX_PATH];
    TCHAR szDstPath[MAX_PATH];
    LONG  lResult;
    BOOL  bRet=FALSE;

    DebugMsg((DM_VERBOSE,TEXT("[RenameGenericLink] Folder = %s\n \nOld = %s\nSrc = %s\n"),FolderName,ObjSrcName,ObjDstName));

    GetGenericUserFolderDirectory(FolderName,szSrcPath);
    GetGenericUserFolderDirectory(FolderName,szDstPath);

    ConcatenatePaths(szSrcPath,ObjSrcName,MAX_PATH);
    ConcatenatePaths(szDstPath,ObjDstName,MAX_PATH);

    lResult = GetFileAttributes(szSrcPath);

    if (lResult == 0xFFFFFFFF) {
        //
        // Directory does not exist.
        //
        DebugMsg((DM_VERBOSE, TEXT("[RenameLink] File is not existed [%s] !\n"),szSrcPath));
        goto err1;
    }

    if (lResult & FILE_ATTRIBUTE_DIRECTORY) {
        //
        // this is a directory, but we want a file.
        //
        DebugMsg((DM_VERBOSE, TEXT("[RenameLink] This is a directory [%s] !\n"),szSrcPath));
        goto err1;
    }

    if (RenameFile(szSrcPath, szDstPath))
        DebugMsg((DM_VERBOSE, TEXT("[RenameLink]  Successfully changed link name:\n%s\n%s\n"),szSrcPath,szDstPath));
    
    else {
        DebugMsg((DM_VERBOSE, TEXT("[RenameLink]  Failed changed link name:\n%s\n%s\n"),szSrcPath,szDstPath));
        goto err1;
    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL FixGenericLink(HINF hInf)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("Generic.LinkToRename");
    LPCTSTR  FolderName;
    LPCTSTR  NT4Name;
    LPCTSTR  NT5Name;
    LPCTSTR  MoveIt;

    TCHAR   szUSFRegKey[MAX_PATH];
    TCHAR   szNTUSF[MAX_PATH];
    TCHAR   szExpNT4USF[MAX_PATH];
    TCHAR   szExpNT5USF[MAX_PATH];
    DWORD   dwSize, dwType;
    LONG    lResult;
    UINT    uiCount;
    HKEY    hKey;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixGenericLink] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixGenericLink] line count == 0 !\n")));
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (FolderName = pSetupGetField(&InfContext,1))
             && (NT4Name = pSetupGetField(&InfContext,2))
             && (NT5Name = pSetupGetField(&InfContext,3))) {

            DebugMsg((DM_VERBOSE,TEXT("FixGenericLink: RegName = %s !\n"),FolderName));
            DebugMsg((DM_VERBOSE,TEXT("FixGenericLink: NT4Name = %s !\n"),NT4Name));
            DebugMsg((DM_VERBOSE,TEXT("FixGenericLink: NT5Name = %s !\n"),NT5Name));

            RenameGenericLink(FolderName,NT4Name,NT5Name);
        }
    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL FixPathInProfileLink(HINF hInf)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("RenamePathInProfileLink");
    LPCTSTR  FolderName;
    LPCTSTR  LinkFileName;
    LPCTSTR  NT4SubStr;
    LPCTSTR  NT5SubStr;

    LPCTSTR  MoveIt;

    TCHAR   szSrcPath[MAX_PATH];
    TCHAR   szNTUSF[MAX_PATH];
    TCHAR   szExpNT4USF[MAX_PATH];
    TCHAR   szExpNT5USF[MAX_PATH];
    DWORD   dwSize, dwType;
    LONG    lResult;
    UINT    uiCount;
    HKEY    hKey;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixPathInProfileLink] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixPathInProfileLink] line count == 0 !\n")));
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (FolderName = pSetupGetField(&InfContext,1))
             && (LinkFileName = pSetupGetField(&InfContext,2))
             && (NT4SubStr = pSetupGetField(&InfContext,3))
             && (NT5SubStr = pSetupGetField(&InfContext,4))) {

            DebugMsg((DM_VERBOSE,TEXT("FixPathInProfileLink: FolderName = %s !\n")  ,FolderName));
            DebugMsg((DM_VERBOSE,TEXT("FixPathInProfileLink: LinkFileName = %s !\n"),LinkFileName));
            DebugMsg((DM_VERBOSE,TEXT("FixPathInProfileLink: NT4SubStr = %s !\n")   ,NT4SubStr));
            DebugMsg((DM_VERBOSE,TEXT("FixPathInProfileLink: NT5SubStr = %s !\n")   ,NT5SubStr));

            if ( !GetGenericUserFolderDirectory(FolderName,szSrcPath))
                goto err1;

            ConcatenatePaths(szSrcPath,LinkFileName,MAX_PATH);

            if (SUCCEEDED (FixPathInLink(szSrcPath,NT4SubStr,NT5SubStr))) {
                DebugMsg((DM_VERBOSE,TEXT("FixPathInProfileLink: FixPathInLink OK ! %s,%s,%s!\n")   ,szSrcPath,NT4SubStr,NT5SubStr));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixPathInProfileLink: FixPathInLink Failed !%s,%s,%s!\n")   ,szSrcPath,NT4SubStr,NT5SubStr));

            }
        }
    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL FixGenericDirectory(HINF hInf)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  SectionName = TEXT("DirectoryToRename");

    LPCTSTR  SrcName;
    LPCTSTR  DstName;

    TCHAR   ExpSrcName[MAX_PATH];
    TCHAR   ExpDstName[MAX_PATH];

    DWORD   dwSize, dwType;
    LONG    lResult;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,SectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] line count == 0 !\n")));
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,SectionName,LineNo,&InfContext)
             && (SrcName = pSetupGetField(&InfContext,1))
             && (DstName = pSetupGetField(&InfContext,2))) {

            DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] Line# [%d] !\n"),LineNo));
            DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] SrcName = %s !\n"),SrcName));
            DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] DstName = %s !\n"),DstName));

            ExpandEnvironmentStrings (SrcName, ExpSrcName, MAX_PATH);
            ExpandEnvironmentStrings (DstName, ExpDstName, MAX_PATH);

            DebugMsg((DM_VERBOSE, TEXT("[FixGenericDirectory] szExpSrcName = %s\n"),ExpSrcName));
            DebugMsg((DM_VERBOSE, TEXT("[FixGenericDirectory] szExpDstName = %s\n"),ExpDstName));

            if (! IsDirExisting(ExpSrcName)) {

                DebugMsg((DM_VERBOSE, TEXT("[FixGenericDirectory] szExpSrcName doesn't exist, do nothing ! %s\n"),ExpSrcName));

                continue;

            }

            if (RenameDirectory(ExpSrcName,ExpDstName)) {
                DebugMsg((DM_VERBOSE, TEXT("[FixGenericDirectory] Rename %s to %s OK !\n"),ExpSrcName,ExpDstName));
            } else {
                DebugMsg((DM_VERBOSE, TEXT("[FixGenericDirectory] Rename %s to %s FAIL!\n"),ExpSrcName,ExpDstName));
            }

        }

    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL FixPartialFileName(HINF hInf)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  SectionName = TEXT("Generic.PartialRename");

    LPCTSTR  DirName;
    LPCTSTR  SrcName;
    LPCTSTR  DstName;
    LPCTSTR  ExtName;

    TCHAR   SrcPathName[MAX_PATH];
    TCHAR   CurPathName[MAX_PATH];
    TCHAR   DstPathName[MAX_PATH];

    DWORD   dwSize, dwType;
    LONG    lResult;

    HANDLE hFile;
    WIN32_FIND_DATA fd;
    LPTSTR SrcDirEnd;
    LPTSTR DstDirEnd;
    LPTSTR CurDirEnd;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,SectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] line count == 0 !\n")));
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,SectionName,LineNo,&InfContext)
             && (DirName = pSetupGetField(&InfContext,1))
             && (SrcName = pSetupGetField(&InfContext,2))
             && (DstName = pSetupGetField(&InfContext,3))) {

            ExtName = pSetupGetField(&InfContext,4);

            DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] Line# [%d] !\n"),LineNo));
            DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] DirName = %s !\n"),DirName));
            DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] SrcName = %s !\n"),SrcName));
            DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] DstName = %s !\n"),DstName));
            DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] ExtName = %s !\n"),ExtName));

            ExpandEnvironmentStrings (DirName, SrcPathName, MAX_PATH);
            ExpandEnvironmentStrings (DirName, CurPathName, MAX_PATH);
            ExpandEnvironmentStrings (DirName, DstPathName, MAX_PATH);

            SrcDirEnd  = CheckSlash (SrcPathName);
            DstDirEnd  = CheckSlash (DstPathName);
            CurDirEnd  = CheckSlash (CurPathName);

            lstrcat(SrcPathName,SrcName);
            lstrcat(SrcPathName,TEXT("*"));
            lstrcat(SrcPathName,ExtName);
            DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] Source = %s !\n"),SrcPathName));

            hFile = FindFirstFile (SrcPathName, &fd);
        
            if (hFile != INVALID_HANDLE_VALUE) {
        
                do  {
        
                    LPCTSTR ExtraPtr = fd.cFileName+lstrlen(SrcName);

                    DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] fd.cFileName = %s !\n"),fd.cFileName));
                    DebugMsg((DM_VERBOSE,TEXT("[FixGenericDirectory] ExtraPtr = %s !\n"),ExtraPtr));

                    lstrcat(DstDirEnd,DstName);
                    lstrcat(DstDirEnd,ExtraPtr);
                    lstrcat(CurDirEnd,fd.cFileName);

                    DebugMsg((DM_VERBOSE, TEXT("%s %s\n"),SrcPathName,DstPathName));
                    RenameFile(CurPathName,DstPathName);
        
                } while (FindNextFile(hFile, &fd));
        
                FindClose (hFile);
            }
        }

    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL RenameSBKANAFiles(
    HINF hInf)
/*
    [WallPaper.Files]
        BMP files
        
    [Sound.Files]
        Sound Files
*/

{
    BOOL bResult;

    TCHAR WinDir[MAX_PATH];
    TCHAR Directory[MAX_PATH];

    GetWindowsDirectory(WinDir,sizeof(WinDir)/sizeof(WinDir[0]));
    
    bResult = RenameSectionFiles(hInf,
                                 TEXT("WallPaper.Files"),
                                 WinDir,
                                 WinDir);

    DebugMsg((DM_VERBOSE, TEXT("[RenameAllFiles] Rename [WallPaper.Files]  %s !\n"),bResult ? TEXT("OK") : TEXT("FAIL")));

    lstrcpy(Directory,WinDir);

    ConcatenatePaths(Directory,TEXT("Media"),MAX_PATH);
    bResult = RenameSectionFiles(hInf,
                                 TEXT("Sound.Files"),
                                 Directory,
                                 Directory);

    DebugMsg((DM_VERBOSE, TEXT("[RenameAllFiles] Rename [Sound.Files]  %s !\n"),bResult ? TEXT("OK") : TEXT("FAIL")));

    return TRUE;
    
}

BOOL RenameSBKANARegSZ(
    HINF hInf)
/*
    [WallPaper.Files]
        BMP files
        
    [Sound.Files]
        Sound Files
*/

{
    BOOL bResult;

    TCHAR WinDir[MAX_PATH];
    TCHAR Directory[MAX_PATH];

    
    bResult = RenameSectionRegSZ(hInf,
                                 TEXT("Cursor_Scheme_Reg"),
                                 HKEY_CURRENT_USER,
                                 TEXT("Control Panel\\Cursors\\Schemes"));

    DebugMsg((DM_VERBOSE, TEXT("[RenameSBKANARegSZ] Rename [Cursor_Scheme_Reg]  %s !\n"),bResult ? TEXT("OK") : TEXT("FAIL")));


    return TRUE;
    
}


int WINAPI WinMainJPN(
    int nCmd,
    HINF hMigrateInf)
{
    const UINT nLocale = LOCALE_JPN;

    switch(nCmd) {
        case FUNC_PatchInSetup:
       
            if (IsInSetupUpgradeMode() == FALSE) {
                DebugMsg((DM_VERBOSE,TEXT("This is NOT upgrade \n")));
                break;
            }
       
            DebugMsg((DM_VERBOSE,TEXT("..................This is upgrade \n")));
       
            if (FixFoldersInSetup(hMigrateInf,TRUE)) {
                if (FixCommon(hMigrateInf)) {
                    if (RenameProgramFolderOrLink(hMigrateInf,TRUE)) {
                        DebugMsg((DM_VERBOSE,TEXT("All Users, RenameProgramFolderOrLink() ok ! \n")));
                    }
                    else {
                        DebugMsg((DM_VERBOSE,TEXT("All Users, RenameProgramFolderOrLink() failed ! \n")));
                    }
                }
                else {
                    DebugMsg((DM_VERBOSE,TEXT("All Users, FixCommon() failed ! \n")));
                }
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("All Users, FixFoldersInSetup() failed ! \n")));
            }
       
            if (FixFoldersInSetup(hMigrateInf,FALSE)) {
                if (RenameProgramFolderOrLink(hMigrateInf,FALSE)) {
                    DebugMsg((DM_VERBOSE,TEXT("Default User, RenameProgramFolderOrLink() ok ! \n")));
                }
                else {
                    DebugMsg((DM_VERBOSE,TEXT("Default User, RenameProgramFolderOrLink() failed ! \n")));
                }
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("Default User, FixFoldersInSetup() failed ! \n")));
            }
       
            if (RenameSBKANAFiles(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("Fix Sound Settings OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("Fix Sound Settings failed ! \n")));
            }
       
            if (FixSoundRegValue(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSoundRegValue OK ! \n")));
       
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixSoundRegValue failed ! \n")));
            }
       
            if (FixTimeZone(nLocale)) {
                DebugMsg((DM_VERBOSE,TEXT("FixTimeZone OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixTimeZone failed ! \n")));
            }
       
            if (FixSBKanaRegValue(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSBKanaRegValue OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixSBKanaRegValue Failed ! \n")));
            }

            //
            // FixSBIniSectionWithDBIniSection first and then FixSBIniKeyWithDBIniKey
            //
            if (FixSBIniSectionWithDBIniSection(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSBSectionWithDBSection OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixSBSectionWithDBSection failed ! \n")));
            }

            if (FixSBIniKeyWithDBIniKey(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSBSectionWithDBSection OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixSBSectionWithDBSection failed ! \n")));
            }

            if (FixGenericDirectory(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixGenericDirectory OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixGenericDirectory failed ! \n")));
            }

            if (FixGenericLink(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixGenericLink OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixGenericLink failed ! \n")));
            }
            
            if (FixPartialFileName(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixGenericLink OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixGenericLink failed ! \n")));
            }

            if (RenameSBKANARegSZ(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("RenameSBKANARegSZ OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("RenameSBKANARegSZ failed ! \n")));
            }

            break;
       
        case FUNC_PatchInLogon:
            if (FixUserFolders(hMigrateInf)) {
                if (RenameProgramFolderOrLink(hMigrateInf,FALSE)) {
                    DebugMsg((DM_VERBOSE,TEXT("Current User, RenameProgramFolderOrLink() ok ! \n")));
                }
                else {
                    DebugMsg((DM_VERBOSE,TEXT("Current User, RenameProgramFolderOrLink() failed ! \n")));
                }
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("Current User, FixFoldersInSetup() failed ! \n")));
            }
            if (FixSpecificFolder(hMigrateInf)) {
               DebugMsg((DM_VERBOSE,TEXT("Current User, FixSpecificFolder() ok ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("Current User, FixSpecificFolder() failed ! \n")));
            }
            if (FixAppearanceScheme(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixAppearanceScheme OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixAppearanceScheme Failed ! \n")));
            }
            if (FixSchemeProblem(TRUE,hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSchemeProblem OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixSchemeProblem Fail ! \n")));
            }
            if (FixSoundRegValue(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSoundRegValue OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixSoundRegValue failed ! \n")));
            }
       
            if (FixPatterns(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixPatterns OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixPatterns failed ! \n")));
            }
            if (FixCurrentWallPaperInDeskTop(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixCurrentWallPaperInDeskTop OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixCurrentWallPaperInDeskTop failed ! \n")));
            }
            if (FixGenericLink(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixGenericLink OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixGenericLink failed ! \n")));
            }
            if (FixPartialFileName(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixGenericLink OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixGenericLink failed ! \n")));
            }
            if (FixPathInProfileLink(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixPathInProfileLink OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("FixPathInProfileLink failed ! \n")));
            }
            if (RenameSBKANARegSZ(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("RenameSBKANARegSZ OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("RenameSBKANARegSZ failed ! \n")));
            }

            if (RenameRegValueName(hMigrateInf,TRUE)) {
                DebugMsg((DM_VERBOSE,TEXT("RenameRegValueName OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("RenameRegValueName failed ! \n")));
            }
            break;

        case FUNC_PatchPreload:
            if (PatchPreloadKeyboard(FALSE)) {
                DebugMsg((DM_VERBOSE,TEXT("PatchPreloadKeyboard OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("PatchPreloadKeyboard Failed ! \n")));
            }
            break;
        case FUNC_PatchTest:
            break;

         default:
             DebugMsg((DM_VERBOSE,TEXT("No such function\n")));
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\femgrate\femgrate.c ===
/****************************** Module Header ******************************\
* Module Name: femgrate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* FEMGRATE, main functions
*
\***************************************************************************/
#include "femgrate.h"
#include <tchar.h>

FUNC_DIR FuncDir[FUNC_NumofFunctions] = {
    {'l',FUNC_PatchInLogon},
    {'s',FUNC_PatchInSetup},
    {'u',FUNC_PatchFEUIFont},
    {'p',FUNC_PatchPreload},
    {'t',FUNC_PatchTest},
    {'c',FUNC_PatchCHSAnsiEMB}
};

HINSTANCE ghInst=NULL;
//
// Function Declaration
//

//
// Max size of a value's data
//

//
// Max number of Functions NO_FUNCTION - 1
//

UINT GetFunctions(
    int *pCmdList,
    int nNum)
{
    int i,j;
    int nMaxNum;
    int nCommands;

    if ((__argc <=1) || nNum < 2)
        return 0;

    //
    // reserved one cell for terminiator
    //
    nMaxNum =  (__argc-1 > nNum-1) ? nNum-1 : __argc-1;

    for (nCommands = 0,i=1; i <= nMaxNum; i++) {

        if (__argv[i][0] != '-') {
            continue;
        }

        for (j=0; j<FUNC_NumofFunctions ;  j++) {
            if (FuncDir[j].cFunc == __argv[i][1]) {
                pCmdList[nCommands++] = FuncDir[j].nID;
            }
        }
    }
    pCmdList[nCommands] = NO_FUNCTION;
    return nCommands;
}

//
// In 3.51/4.0, the time zone name displaying on date/time applets was in English
//
// we want to change it back to localization string
//
BOOL FixTimeZone(UINT nLocale)
{
    DWORD dwErr,dwType,dwSize;
    HKEY hSysKey,hSftKey;
    BOOL bOK = FALSE;
    TCHAR szStdName[MAX_PATH];
    TCHAR szTimeZoneLookup[MAX_PATH];


    dwErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("System\\CurrentControlSet\\Control\\TimeZoneInformation"),
                          0,
                          KEY_READ | KEY_WRITE,
                          &hSysKey );

    if (dwErr != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixTimeZone] Open System\\CurrentControlSet\\Control\\TimeZoneInformation failed !\n")));
        goto Err0;
    }

    dwSize = sizeof(szStdName);
    dwErr = RegQueryValueEx(hSysKey,
                            TEXT("StandardName"),
                            NULL,
                            &dwType,
                            (LPBYTE) szStdName,
                            &dwSize);

    if (dwErr != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixTimeZone] StandardName doesn't exist !\n")));
        bOK = TRUE;
        goto Err1;
    }

    //
    // KOR 3.51 used "Japanese Standard Time". It is necessary to change it to "Seul Standard time"
    // 
    // check if system locale is KOR and the length of szStdName is non-zero
    //
    DebugMsg((DM_VERBOSE,TEXT("[FixTimeZone] locale = %X, dwSize = %d  !\n"),nLocale,dwSize));
    if ((nLocale == LOCALE_KOR) && dwSize) {
        if (lstrcmpi(szStdName,TEXT("Tokyo Standard Time"))== 0) {
            lstrcpy(szStdName,TEXT("Korea Standard Time"));
        }
    }
    wsprintf(szTimeZoneLookup,TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\%s"),szStdName);
    DebugMsg((DM_VERBOSE,TEXT("[FixTimeZone] Open %s  !\n"),szTimeZoneLookup));
    dwErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szTimeZoneLookup,
                          0,
                          KEY_READ,
                          &hSftKey );


    if (dwErr != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixTimeZone] %s doesn't exist !\n"),szTimeZoneLookup));
        bOK = TRUE;
        goto Err1;
    }

    dwSize = sizeof(szStdName);
    dwErr = RegQueryValueEx(hSftKey,
                            TEXT("Std"),
                            NULL,
                            &dwType,
                            (LPBYTE) szStdName,
                            &dwSize);

    if (dwErr != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixTimeZone] Query Std failed, abornomal !\n")));
        goto Err2;
    }

    dwErr = RegSetValueEx(hSysKey,
                          TEXT("StandardName"),
                          0,
                          REG_SZ,
                          (LPBYTE) szStdName,
                          (lstrlen(szStdName)+1)*sizeof(TCHAR));


    if (dwErr != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixTimeZone] Set Standardname failed !\n")));
        goto Err2;
    }

    dwSize = sizeof(szStdName);
    dwErr = RegQueryValueEx(hSftKey,
                            TEXT("Dlt"),
                            NULL,
                            &dwType,
                            (LPBYTE) szStdName,
                            &dwSize);

    if (dwErr != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixTimeZone] Query Dlt failed, abornomal !\n")));
        bOK = TRUE;
        goto Err2;
    }

    dwErr = RegSetValueEx(hSysKey,
                          TEXT("DaylightName"),
                          0,
                          REG_SZ,
                          (LPBYTE) szStdName,
                          (lstrlen(szStdName)+1)*sizeof(TCHAR));


    if (dwErr != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixTimeZone] Set DaylightName failed !\n")));
        goto Err2;
    }

    bOK = TRUE;

Err2:
    RegCloseKey(hSftKey);
Err1:
    RegCloseKey(hSysKey);

Err0:
    return bOK;

}

//
// Patch CHT/CHS 3.51 bug
//     1. length of Preload Values is 8, patch to 9
//     2. replace 00000409 with default lang ID
//     3. if default lang ID existed, we don't replace anything
//
BOOL PatchPreloadKeyboard(
    BOOL bReplaceDefaultLCID) //if TRUE will replace 409 with default LCID
{
    HKEY  hkLayoutPreload;
    LONG  lResult; 
    int   i;
    BOOL  bFoundDefaultLocale = FALSE;
    int   nFound0409 = -1;
    TCHAR szDefaultLocaleID[KL_NAMELENGTH];
    TCHAR szPreloadID[4*sizeof(TCHAR)]; // 3 digits + NULL
    TCHAR szLayoutID[KL_NAMELENGTH];    // 9
    DWORD dwValueSize;


    wsprintf(szDefaultLocaleID,TEXT("%08X"),GetSystemDefaultLCID());
    
    lResult = RegOpenKeyEx(HKEY_CURRENT_USER,               
                           TEXT("keyboard layout\\preload"),
                           0,
                           KEY_READ | KEY_WRITE,
                           &hkLayoutPreload);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }

    
    for (i=1; i<=999;i++) { // size allows up to 999 preloaded!!!!!

        wsprintf(szPreloadID,TEXT("%d"),i);

        dwValueSize = 0;
        RegQueryValueEx(hkLayoutPreload,
                       szPreloadID,
                       NULL,
                       NULL,
                       NULL,
                       &dwValueSize);

        if (dwValueSize == 0)
            break;

        lResult = RegQueryValueEx(hkLayoutPreload,
                       szPreloadID,
                       NULL,
                       NULL,
                       (LPBYTE) szLayoutID,
                       &dwValueSize);
        //
        // First, fix missing NULL terminator 
        //
        if (dwValueSize == (KL_NAMELENGTH - 1)* sizeof(TCHAR)) {
            //
            // this case is what we want to fix
            //
            szLayoutID[KL_NAMELENGTH-1] = (TCHAR) 0;


            lResult = RegSetValueEx(hkLayoutPreload,
                                    szPreloadID,
                                    0,
                                    REG_SZ,
                                    (LPBYTE) szLayoutID,
                                    sizeof(TCHAR) * KL_NAMELENGTH);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("IMECONV: Failed to set %s = %s \n"),szPreloadID,szLayoutID));
            }
        }

        //
        // FOR CHS/CHT, we need check and replace
        //
        if (bReplaceDefaultLCID) {
            //
            // Second, fix wrong locale,  rule:
            //   if Default Locale existed (e.q. 00000404 for CHT), do nothing
            //   else found 00000409,  replace it with Default Locale
            //
             if ((dwValueSize < (KL_NAMELENGTH - 1) * sizeof(TCHAR)) ||
                 (dwValueSize > (KL_NAMELENGTH)     * sizeof(TCHAR))) {
                 //
                 // wrong data, ignore it
                 //
                 continue;
             }

             if (bFoundDefaultLocale) {
                 continue;
             }

//             if (_tcsncmp(szDefaultLocaleID,szLayoutID,KL_NAMELENGTH-1)==0) {
             if (_tcsncmp(L"123",L"123",KL_NAMELENGTH-1)==0) {
                 bFoundDefaultLocale = TRUE;
                 continue;
             }

             if (_tcsncmp(szLayoutID,TEXT("00000409"),KL_NAMELENGTH-1)==0) {
                 nFound0409 = i;
             }
        }

    }

    if (bReplaceDefaultLCID) {
        if (!bFoundDefaultLocale) {
            if (nFound0409 != -1 ) {
                wsprintf(szPreloadID,TEXT("%d"),nFound0409);
                lResult = RegSetValueEx(hkLayoutPreload,
                                        szPreloadID,
                                        0,
                                        REG_SZ,
                                        (LPBYTE) szDefaultLocaleID,
                                        sizeof(TCHAR) * KL_NAMELENGTH);

                if (lResult != ERROR_SUCCESS) {
                    DebugMsg((DM_VERBOSE,TEXT("IMECONV: Failed to set %s = %s \n"),szPreloadID,szLayoutID));
                }
            }
        }
    }

    RegCloseKey (hkLayoutPreload);

    if (i > 999)
        return FALSE;
    else
        return TRUE;
}

const TCHAR g_szCaptionFont[]   = TEXT("CaptionFont");
const TCHAR g_szSmCaptionFont[] = TEXT("SmCaptionFont");
const TCHAR g_szMenuFont[]      = TEXT("MenuFont");
const TCHAR g_szStatusFont[]    = TEXT("StatusFont");
const TCHAR g_szMessageFont[]   = TEXT("MessageFont");
const TCHAR g_szIconFont[]      = TEXT("IconFont");

const LPCTSTR g_rgpszFontMetrics[] = { g_szCaptionFont,
                                       g_szSmCaptionFont,
                                       g_szMenuFont,
                                       g_szStatusFont,
                                       g_szMessageFont,
                                       g_szIconFont};
                                     
BOOL FixIncorrectCharSet(LOGFONT *plf)
{
    struct NameCharSet {
        char szFaceName[LF_FACESIZE*2];
        BYTE  bCharSet;
    } Pairs[] = {
        {"\x74\xad\xbc\xb9\x00\x00",0x81},
        {"\xb0\x65\x30\x7d\x0e\x66\xd4\x9a\x00\x00",0x88},
        {"\x8b\x5b\x53\x4f\x00\x00",0x86}

    };

    int i;

    for (i=0; i<ARRAYSIZE(Pairs); i++) {
        if (lstrcmp(plf->lfFaceName,(LPTSTR)(Pairs[i].szFaceName)) == 0) {
            if (plf->lfCharSet != Pairs[i].bCharSet) {
                plf->lfCharSet = Pairs[i].bCharSet;
                DebugMsg((DM_VERBOSE,TEXT("FixIncorrectCharSet, we found and we fixed. [%X]\n"),Pairs[i].bCharSet));
                return TRUE;
            }
        }
    }
    DebugMsg((DM_VERBOSE,TEXT("FixIncorrectCharSet, Input %s, %d, no fix needed !\n"),plf->lfFaceName,plf->lfCharSet));

    return TRUE;
    
}

BOOL FixMSPGothic(LOGFONT *plf)
{
    int i;

    char szMSPGothic[LF_FACESIZE*2] = "\x2D\xFF\x33\xFF\x20\x00\x30\xFF\xB4\x30\xB7\x30\xC3\x30\xAF\x30\x00\x00";

    DebugMsg((DM_VERBOSE,TEXT("FixMSPGothic, [%s] == [%s] ?\n"),plf->lfFaceName,szMSPGothic));
    if (lstrcmp(plf->lfFaceName,(LPTSTR)szMSPGothic) == 0) {
            lstrcpy(plf->lfFaceName,TEXT("MS UI Gothic"));
            DebugMsg((DM_VERBOSE,TEXT("FixMSPGothic, we found and we fixed. [%s]\n"),plf->lfFaceName));
            return TRUE;
    }
    return TRUE;
}

    
BOOL
UpdateUIFont(
    BOOL bJapan,
    HKEY hkeyMetrics, 
    LPCTSTR pszValueName,
    LOGFONT *plf
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    LOGFONT lfCopy;
    BOOL bOkToUpdate = FALSE;
    DebugMsg((DM_VERBOSE,TEXT("UpdateUIFont, Starting ...\n"))); 
    //
    // First see if this face name should be updated.
    //

    if (bJapan) {
        bOkToUpdate = FixMSPGothic(plf);
    } else {
        bOkToUpdate = FixIncorrectCharSet(plf);
    }
    
    if (bOkToUpdate) {
        //
        // Yep.  Update the face name string in the logfont.  
        // Also make sure that the point size is 8 or greater
        // if we're updating the icon font.
        //
        DebugMsg((DM_VERBOSE,TEXT("UpdateUIFont, update %s 's charset %X\n"), 
               plf->lfFaceName, plf->lfCharSet));

        dwResult = RegSetValueEx(hkeyMetrics,
                                 pszValueName,
                                 0,
                                 REG_BINARY,
                                 (const LPBYTE)plf,
                                 sizeof(*plf));

        if (ERROR_SUCCESS != dwResult) {
            DebugMsg((DM_VERBOSE,TEXT("Error %d setting NC font data for \"%s\"\n"), 
                   dwResult, pszValueName));
            return FALSE;
        }
    }
    return TRUE;
}


void FixCurrentSchemeName(HINF hInf)
{
    HKEY hkeyAppearance;
    TCHAR szCurrentSchemeName[MAX_PATH];
    DWORD cbValue;
    DWORD dwType;
    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("CurrentScheme");
    LPCTSTR  pszStandard;
    LPCTSTR  pszClassic;
    DWORD dwResult = ERROR_SUCCESS;
 
    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixCurrentSchemeName] Open femgrate.inf failed !\n")));
        goto Exit1;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixCurrentSchemeName] line count == 0 !\n")));
        goto Exit1;
    }

    dwResult = RegOpenKeyEx(HKEY_CURRENT_USER,
                            TEXT("Control Panel\\Appearance"),
                            0,
                            KEY_ALL_ACCESS,
                            &hkeyAppearance);

    if (ERROR_SUCCESS != dwResult ) {
        DebugMsg((DM_VERBOSE,TEXT("[FixCurrentSchemeName] Key Control Panel\\Appearance doesn't exist\r\n"))); 
        goto Exit1;
    }

    cbValue = sizeof(szCurrentSchemeName);
    dwResult = RegQueryValueEx(hkeyAppearance,
                               TEXT("Current"),
                               NULL,
                               &dwType,
                               (LPBYTE)szCurrentSchemeName,
                               &cbValue);

    if (ERROR_SUCCESS != dwResult) {
        DebugMsg((DM_VERBOSE,TEXT("[FixCurrentSchemeName] No Current value, not an error !\r\n"))); 
        goto Exit2;
    }


    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (pszStandard = pSetupGetField(&InfContext,1))
             && (pszClassic  = pSetupGetField(&InfContext,2))) {

            if (lstrcmp(pszStandard,szCurrentSchemeName) == 0) {
                lstrcpy(szCurrentSchemeName,pszClassic);
                break;
            }
        }
    }

    dwResult = RegSetValueEx(hkeyAppearance,
                             TEXT("Current"),
                             0,
                             REG_SZ,
                             (LPBYTE)szCurrentSchemeName,
                             (lstrlen(szCurrentSchemeName)+1) * sizeof(TCHAR));

Exit2:
    RegCloseKey(hkeyAppearance);

Exit1:
    return;
}

BOOL FixCurrentSchemeData(BOOL bJapan)
{
    DWORD dwResult = ERROR_SUCCESS;
    HKEY hkeyMetrics;

    DebugMsg((DM_VERBOSE,TEXT("DoPatchUIFont, Starting ... \n")));

    dwResult = RegOpenKeyEx(HKEY_CURRENT_USER,
                            TEXT("Control Panel\\Desktop\\WindowMetrics"),
                            0,
                            KEY_ALL_ACCESS,
                            &hkeyMetrics);

    if (ERROR_SUCCESS == dwResult)
    {
        DWORD cbValue;
        DWORD dwType;
        LOGFONT lf;
        int i;

        for (i = 0; i < ARRAYSIZE(g_rgpszFontMetrics); i++)
        {
            LPCTSTR pszValueName = g_rgpszFontMetrics[i];
            //
            LOGFONT *plf = NULL;

            cbValue = sizeof(lf);
            dwResult = RegQueryValueEx(hkeyMetrics,
                                       pszValueName,
                                       NULL,
                                       &dwType,
                                       (LPBYTE)&lf,
                                       &cbValue);

            if (ERROR_SUCCESS == dwResult)
            {
                if (REG_BINARY == dwType)
                {
                    plf = &lf;
                    if (!UpdateUIFont(bJapan,hkeyMetrics, pszValueName, plf)) {
                        DebugMsg((DM_VERBOSE,TEXT("DoPatchUIFont,UpdateUIFont failed \n")));
                    }
                } else {
                    DebugMsg((DM_VERBOSE,TEXT("DoPatchUIFont,not binary format \n")));
                }
            }
        }
        DebugMsg((DM_VERBOSE,TEXT("DoPatchUIFont, colsing ... \n")));

        RegCloseKey(hkeyMetrics);
    }
    else if (ERROR_FILE_NOT_FOUND == dwResult)
    {
        //
        // Some keys under HKEY_USERS don't have WindowMetric information.
        // Such cases are not processed but are still considered successful.
        //
        DebugMsg((DM_VERBOSE,TEXT("DoPatchUIFont,Some keys under HKEY_USERS don't have WindowMetric information \n")));
        dwResult = ERROR_SUCCESS;
    }
    else
    {
        DebugMsg((DM_VERBOSE,TEXT("DoPatchUIFont,Error %d opening key \n"), dwResult));
    }

    return (TRUE);
}

BOOL FixSchemeProblem(BOOL bJapan, HINF hInf)
{

    FixCurrentSchemeData(bJapan);

    FixCurrentSchemeName(hInf);

    return TRUE;
}

BOOL RenameRegValueName(HINF hInf, BOOL PerUser)
{
    LPCTSTR RegRoot,RegPath;
    LPCTSTR RegOldVal,RegNewVal;

    LONG LineCount,LineNo;
    DWORD dwSize,dwType;
    INFCONTEXT InfContext;
    HKEY Key,KeyRoot;
    BOOL bOK;
    LPBYTE RegData;
    LONG lResult;

    TCHAR SectionName[MAX_PATH];

    if (PerUser) {
        lstrcpy(SectionName,TEXT("RenameRegValueName.PerUser"));
    } else {
        lstrcpy(SectionName,TEXT("RenameRegValueName.PerSystem"));
    }

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[ReplaceRegValueName] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,SectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[ReplaceRegValueName] line count == 0 !\n")));
        return FALSE;
    }

    for(LineNo = 0; LineNo < LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,SectionName,LineNo,&InfContext)
             && (RegRoot   = pSetupGetField(&InfContext,1))
             && (RegPath   = pSetupGetField(&InfContext,2))
             && (RegOldVal = pSetupGetField(&InfContext,3))
             && (RegNewVal = pSetupGetField(&InfContext,4))) {

            if (!LookUpStringInTable(InfRegSpecTohKey,RegRoot,(PUINT)&KeyRoot)) {
                continue;
            }

            lResult = RegOpenKeyEx( KeyRoot,
                                    RegPath,
                                    0,
                                    KEY_READ | KEY_WRITE,
                                    &Key);

            if (lResult != ERROR_SUCCESS) {
                continue;
            }

            dwSize = 0;
            lResult = RegQueryValueEx (Key, 
                                       RegOldVal,
                                       NULL, 
                                       &dwType, 
                                       NULL, 
                                       &dwSize);

            if (lResult != ERROR_SUCCESS) {
                goto Err1;
            }

            RegData = (BYTE *) malloc(dwSize+1);

            if (!RegData) {
                goto Err1;
            }

            lResult = RegQueryValueEx (Key, 
                                       RegOldVal,
                                       NULL, 
                                       &dwType, 
                                       RegData, 
                                       &dwSize);

            lResult = RegSetValueEx (Key, 
                                     RegNewVal,
                                     0, 
                                     dwType, 
                                     RegData, 
                                     dwSize);
            if (lResult != ERROR_SUCCESS) {
                goto Err2;
            }

            RegDeleteValue(Key,
                           RegOldVal); 

Err2:
            free(RegData);

Err1:
            RegCloseKey(Key);

        }
    }
    return TRUE;

}

int WINAPI WinMainFE(
    LPSTR     lpCmdLine,
    UINT      uLocale)
{
    int Cmds[FUNC_NumofFunctions + 1];
    int i;
    HINF hMigrateInf;

#ifdef DEBUGLOG
    SetupOpenLog (FALSE);
#endif
    if (GetFunctions(Cmds,FUNC_NumofFunctions+1) == 0) {
        DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: There are no valid commands. \n")));
        return (1);
    }

    hMigrateInf = SetupOpenInfFile(
                      TEXT("femgrate.inf"),
                      NULL,
                      INF_STYLE_WIN4,
                      NULL);
   
    if(hMigrateInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixCommon] Open femgrate.inf failed !\n")));
        return 0;
    }

    for (i=0; Cmds[i] != NO_FUNCTION && i < FUNC_NumofFunctions+1; i++) {

        switch (uLocale) {
            case 0x404:
                WinMainCHT(Cmds[i],hMigrateInf);
                break;
            case 0x411:
                WinMainJPN(Cmds[i],hMigrateInf);
                break;
            case 0x412:
                WinMainKOR(Cmds[i],hMigrateInf);
                break;
            case 0x804:
                WinMainCHS(Cmds[i],hMigrateInf);
                break;
            default:
                break;
        }

    }

    SetupCloseInfFile(hMigrateInf);
#ifdef DEBUGLOG
    SetupCloseLog();
#endif
    return (0);
}


int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: Start Executing....\n")));

    ghInst = hInstance;
    //
    // In order to share the code for CHT/CHS/KOR, fork here
    //
    if ((GetInstallLocale() == 0x0412) || 
        (GetInstallLocale() == 0x0404) ||
        (GetInstallLocale() == 0x0804) ||
        (GetInstallLocale() == 0x0411)) {
            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: calling WinMainFE %X....\n"),GetInstallLocale()));
        return (WinMainFE(lpCmdLine,GetInstallLocale()));
    } else {
        DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: Not valid locale....\n")));
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\femgrate\utils2.cpp ===
#include "femgrate.h"
#include <objbase.h>
#include <shellapi.h>
#include <shlguid.h>
#include <comdef.h>

HRESULT FixPathInLink(LPCTSTR pszShortcutFile, LPCTSTR lpszOldSubStr,LPCTSTR lpszNewSubStr)
{
    HRESULT         hres;
    IShellLink      *psl;
    TCHAR           szGotPath [MAX_PATH];
    TCHAR           szNewPath [MAX_PATH];
    WIN32_FIND_DATA wfd;

    CoInitialize(NULL);
    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance (CLSID_ShellLink,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IShellLink,
                             (void **)&psl);

    if (SUCCEEDED (hres)) {
        IPersistFile *ppf;

        // Get a pointer to the IPersistFile interface.
        hres = psl->QueryInterface (IID_IPersistFile, (void **)&ppf);

        if (SUCCEEDED (hres)) {
            // Load the shortcut.
            hres = ppf->Load (pszShortcutFile, STGM_READWRITE );


            if (SUCCEEDED (hres)) {
                // Resolve the shortcut.
                hres = psl->Resolve (NULL, SLR_NO_UI | SLR_UPDATE);

                if (SUCCEEDED (hres)) {
                    lstrcpy (szGotPath, pszShortcutFile);
                    // Get the path to the shortcut target.
                    hres = psl->GetPath (szGotPath,
                                         MAX_PATH,
                                         (WIN32_FIND_DATA *)&wfd,
                                         SLGP_SHORTPATH);

                    if (! SUCCEEDED (hres)) {
                        DebugMsg((DM_VERBOSE, TEXT("FixPathInLink:  GetPath %s Error = %d\n"), szGotPath,hres));

                    } else {
                        DebugMsg((DM_VERBOSE, TEXT("FixPathInLink:  GetPath %s OK \n"), szGotPath));

                    }

                    if (ReplaceString(szGotPath,lpszOldSubStr, lpszNewSubStr, szNewPath)) {
                        hres = psl->SetPath (szNewPath);
                        if (! SUCCEEDED (hres)) {

                            DebugMsg((DM_VERBOSE, TEXT("FixPathInLink:  SetPath %s Error = %d\n"), szGotPath,hres));

                        } else {
                            hres = ppf->Save (pszShortcutFile,TRUE);
                            if (! SUCCEEDED (hres)) {
                                DebugMsg((DM_VERBOSE, TEXT("FixPathInLink:  Save %s Error = %d\n"), pszShortcutFile,hres));
                            } else {
                                DebugMsg((DM_VERBOSE, TEXT("FixPathInLink:  Save %s OK = %d\n"), pszShortcutFile,hres));
                            }
                        }

                    } else {
                        DebugMsg((DM_VERBOSE, TEXT("FixPathInLink: No match !  %s , %s, %s = %d\n"), szGotPath,lpszOldSubStr, lpszNewSubStr));
                    }
                }
            } else {

                DebugMsg((DM_VERBOSE, TEXT("FixPathInLink:  Load %s Error = %d\n"), pszShortcutFile,hres));
            }
            // Release the pointer to IPersistFile.

            ppf->Release ();
        }
        // Release the pointer to IShellLink.

        psl->Release ();
    }

    CoUninitialize();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\femgrate\resource.h ===
/****************************** Module Header ******************************\
* Module Name: resource.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* FEMGRATE, resource header file
*
\***************************************************************************/
#define IDS_CHT_TABLE1  1000
#define IDS_CHT_TABLE2  1001
#define IDS_CHT_TABLE3  1002
#define IDS_CHT_TABLE4  1003
#define IDS_CHT_TABLE5  1004
#define NUM_OF_CHT_TABLE 5
#define IDS_CHS_TABLE1  2001
#define IDS_CHS_TABLE2  2002
#define IDS_CHS_TABLE3  2003
#define IDS_CHS_TABLE4  2004
#define IDS_ENG_TABLE1  3001
#define IDS_ENG_TABLE2  3002
#define IDS_ENG_TABLE3  3003
#define IDS_ENG_TABLE4  3004
#define NUM_OF_CHS_TABLE 6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\femgrate\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl


!ENDIF

BINPLACE_PLACEFILE=..\placefil.txt
BINPLACE_FLAGS=-x -a

MAJORCOMP=shell
MINORCOMP=femgrate

INCLUDES=$(SDK_INC_PATH);$(BASE_INC_PATH);$(DS_INC_PATH)

C_DEFINES=-DWIN32 -DWINNT -DW3 -DUNICODE -D_UNICODE -DWINVER=0x0400

TARGETNAME=femgrate
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=PROGRAM

TARGETLIBS= \
        $(SDK_LIB_PATH)\user32.lib    \
        $(BASE_LIB_PATH)\spapip.lib  \
        $(SDK_LIB_PATH)\shell32.lib   \
        $(SDK_LIB_PATH)\userenv.lib   \
        $(SDK_LIB_PATH)\uuid.lib      \
        $(SDK_LIB_PATH)\ole32.lib


SOURCES=..\femgrate.c  \
        ..\utils.c     \
        ..\jpn.c       \
        ..\kor.c       \
        ..\cht.c       \
        ..\chs.c       \
        ..\utils2.cpp  \
        ..\res.rc

USE_MSVCRT=1

UMENTRY=winmain
UMTYPE=windows

MSC_WARNING_LEVEL=/W3 /WX

MISCFILES = femgrate.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\cmd.cpp ===
#include "stdafx.h"
#include "cmd.h"

CCmd::CCmd()
{
    m_argc = 0;
    m_argv = NULL;
}

CCmd::~CCmd()
{
}

CCmd::bInit(int argc, LPSTR argv[])
{
    m_argc = argc;
    m_argv = argv;

    return ParseCmdLine();
}

BOOL CCmd::ParseCmdLine()
{
    int argc;
    LPTSTR *argv;

    argc = m_argc;
    argv = m_argv;

    if (argc > 1) {
        argc--;
        argv++;
    } else {
        return FALSE;
    }

    while(argc) {
        if (ProcessToken(*argv)) {
            argc--;
            argv++;
        } else {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\femgrate\kor.c ===
/****************************** Module Header ******************************\
* Module Name: kor.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* FEMGRATE, KOR speciific functions
*
\***************************************************************************/
#include "femgrate.h"

int WINAPI WinMainKOR(
    int     nCmd,
    HINF hMigrateInf)
{
    const UINT nLocale = LOCALE_KOR;

    switch(nCmd) {
        case FUNC_PatchFEUIFont:
            if (FixSchemeProblem(FALSE,hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSchemeProblem OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixSchemeProblem Fail ! \n")));
            }
            break;

        case FUNC_PatchInSetup:
            if (FixTimeZone(nLocale)) {
                DebugMsg((DM_VERBOSE,TEXT("FixTimeZone OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixTimeZone failed ! \n")));
            }
            break;

        case FUNC_PatchPreload:
            if (PatchPreloadKeyboard(TRUE)) {
                DebugMsg((DM_VERBOSE,TEXT("PatchPreloadKeyboard OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("PatchPreloadKeyboard Failed ! \n")));
            }
            break;

        case FUNC_PatchInLogon:

            if (RenameRegValueName(hMigrateInf,TRUE)) {
                DebugMsg((DM_VERBOSE,TEXT("RenameRegValueName OK ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("RenameRegValueName failed ! \n")));
            }
            break;
    
        case FUNC_PatchTest:
            break;
        default:
            DebugMsg((DM_VERBOSE,TEXT("No such function\n")));
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\femgrate\utils.c ===
/****************************** Module Header ******************************\
* Module Name: utils.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* FEMGRATE utility functions
*
\***************************************************************************/

#include "femgrate.h"
#include <tchar.h>

#ifdef MYDBG
void Print(UINT mask,LPCTSTR pszFormat,...)
{

    TCHAR szBuf[512];
    va_list arglist;

    va_start(arglist,pszFormat);

    wvsprintf(szBuf,pszFormat,arglist);
#ifdef DEBUGLOG
    lstrcat (szBuf,TEXT("\r\n"));
    SetupLogError(DBGTITLE,LogSevInformation);
    SetupLogError(szBuf,LogSevInformation);
#else
    OutputDebugString(DBGTITLE);
    OutputDebugString(szBuf);
#endif
    va_end(arglist);
}
#endif

BOOL
ConcatenatePaths(
    LPTSTR  Target,
    LPCTSTR Path,
    UINT    TargetBufferSize
    )

{
    UINT TargetLength,PathLength;
    BOOL TrailingBackslash,LeadingBackslash;
    UINT EndingLength;

    TargetLength = lstrlen(Target);
    PathLength = lstrlen(Path);

    //
    // See whether the target has a trailing backslash.
    //
    if(TargetLength && (Target[TargetLength-1] == TEXT('\\'))) {
        TrailingBackslash = TRUE;
         TargetLength--;
     } else {
         TrailingBackslash = FALSE;
     }

     //
     // See whether the path has a leading backshash.
     //
     if(Path[0] == TEXT('\\')) {
         LeadingBackslash = TRUE;
         PathLength--;
     } else {
         LeadingBackslash = FALSE;
     }

     //
     // Calculate the ending length, which is equal to the sum of
     // the length of the two strings modulo leading/trailing
     // backslashes, plus one path separator, plus a nul.
     //
     EndingLength = TargetLength + PathLength + 2;

     if(!LeadingBackslash && (TargetLength < TargetBufferSize)) {
         Target[TargetLength++] = TEXT('\\');
     }

     if(TargetBufferSize > TargetLength) {
         lstrcpyn(Target+TargetLength,Path,TargetBufferSize-TargetLength);
     }

     //
     // Make sure the buffer is nul terminated in all cases.
     //
     if (TargetBufferSize) {
         Target[TargetBufferSize-1] = 0;
     }

     return(EndingLength <= TargetBufferSize);
 }

LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

void IntToString( DWORD i, LPTSTR sz)
{
#define CCH_MAX_DEC 12         // Number of chars needed to hold 2^32

    TCHAR szTemp[CCH_MAX_DEC];
    int iChr;


    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(i % 10);
        i = i / 10;
    } while (i != 0);

    do {
        iChr--;
        *sz++ = szTemp[iChr];
    } while (iChr != 0);

    *sz++ = TEXT('\0');
}

BOOL DoInstallationFromSection(HINF hInf,LPCTSTR lpszSectionName)
{
    HSPFILEQ FileQueue;
    PVOID QContext = NULL;
    BOOL bRet=FALSE;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] Open femgrate.inf failed !\n")));
        goto Err0;
    }

    if ((FileQueue = SetupOpenFileQueue()) == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] SetupOpenFileQueue failed !\n")));
        goto Err0;
    }

    bRet = SetupInstallFilesFromInfSection(hInf,
                                           NULL,
                                           FileQueue,
                                           lpszSectionName,
                                           NULL,
                                           SP_COPY_NEWER );
    if (!bRet) {
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] SetupInstallFilesFromInfSection failed !\n")));
        goto Err1;
    }

    if (!(QContext = SetupInitDefaultQueueCallback(NULL))) {
        bRet = FALSE;
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] SetupInitDefaultQueueCallback failed !\n")));
        goto Err1;
    }


    bRet = SetupCommitFileQueue(NULL,
                                FileQueue,
                                SetupDefaultQueueCallback,
                                QContext );
    if (!bRet) {
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] SetupCommitFileQueue failed !\n")));
        goto Err1;
    }

    bRet = SetupInstallFromInfSection( NULL,
                                       hInf,
                                       lpszSectionName,
                                       SPINST_ALL & ~SPINST_FILES,
                                       NULL,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL );
    if (!bRet) {
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] SetupInstallFromInfSection failed !\n")));
        goto Err1;
    }

    bRet = TRUE;
Err1:
    if ( QContext != NULL)
        SetupTermDefaultQueueCallback(QContext);
    SetupCloseFileQueue(FileQueue);
Err0:
    return bRet;

}


BOOL IsInSetupUpgradeMode()
{
   LPCTSTR szKeyName = TEXT("SYSTEM\\Setup");
   DWORD dwType, dwSize;
   HKEY hKeySetup;
   DWORD dwSystemSetupInProgress,dwUpgradeInProcess;
   LONG lResult;

   if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKeyName, 0,
                     KEY_READ, &hKeySetup) == ERROR_SUCCESS) {

       dwSize = sizeof(DWORD);
       lResult = RegQueryValueEx (hKeySetup, TEXT("SystemSetupInProgress"), NULL,
                                  &dwType, (LPBYTE) &dwSystemSetupInProgress, &dwSize);
       if (lResult == ERROR_SUCCESS) {
           dwSize = sizeof(DWORD);
           lResult = RegQueryValueEx (hKeySetup, TEXT("UpgradeInProgress"), NULL,
                                      &dwType, (LPBYTE) &dwUpgradeInProcess, &dwSize);
           if (lResult == ERROR_SUCCESS) {
               DebugMsg((DM_VERBOSE,TEXT("[IsInSetupUpgradeMode] dwSystemSetupInProgress =%, dwUpgradeInProcess=%d !\n"),dwSystemSetupInProgress,dwUpgradeInProcess));

               if ((dwSystemSetupInProgress != 0) && (dwUpgradeInProcess != 0)) {
                   return TRUE;
               }
           }
           else {
              DebugMsg((DM_VERBOSE,TEXT("[IsInSetupUpgradeMode] RegQueryValueEx UpgradeInProcess failed !\n")));

           }

       }
       else {
          DebugMsg((DM_VERBOSE,TEXT("[IsInSetupUpgradeMode] RegQueryValueEx SystemSetupInProgress failed !\n")));
       }
       RegCloseKey (hKeySetup);
   }
   else {
      DebugMsg((DM_VERBOSE,TEXT("[IsInSetupUpgradeMode] RegOpenKeyEx failed !\n")));

   }
   return FALSE ;
}

UINT StrToUInt(
    LPTSTR lpszNum)
{
    LPTSTR lpszStop;

#ifdef UNICODE
    return (wcstoul(lpszNum, &lpszStop, 16));
#else
    return (strtoul(lpszNum, &lpszStop, 16));
#endif
}

UINT GetInstallLocale()
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    TCHAR           buffer[512];
    LANGID          rcLang;
    UINT            p;

    p = 0;
    dwErr = RegOpenKeyEx( HKEY_USERS,
                          TEXT(".DEFAULT\\Control Panel\\International"),
                          0,
                          KEY_READ,
                          &hkey );

    if( dwErr == ERROR_SUCCESS ) {

        dwSize = sizeof(buffer);
        dwErr = RegQueryValueEx(hkey,
                                TEXT("Locale"),
                                NULL,  //reserved
                                NULL,  //type
                                (LPBYTE) buffer,
                                &dwSize );

        if(dwErr == ERROR_SUCCESS) {
            p = StrToUInt(buffer);
        }
    }
    return( p );
}

BOOL RegReplaceIfExisting(
    HKEY hKey,
    LPCTSTR pszOldValName,
    LPCTSTR pszNewValName)
/*++
    Rename old value name to new value name.
--*/
{
    LONG lResult;

    DWORD dwType;
    DWORD dwSize;
    TCHAR szData[MAX_PATH];

    dwSize = sizeof(szData);
    lResult = RegQueryValueEx (hKey,
                               pszOldValName,
                               0,
                               &dwType,
                               (LPBYTE) szData,
                               &dwSize);
    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("RegReplaceIfExisting: RegQueryValue %s failed. \n"),pszOldValName));
        return FALSE;
    }

    lResult = RegSetValueEx (hKey,
                             pszNewValName,
                             0,
                             REG_SZ,
                             (LPBYTE) szData,
                             (lstrlen(szData) + 1) * sizeof(TCHAR));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("RegReplaceIfExisting: RegSetValueEx %s failed. \n"),pszNewValName));
        return FALSE;
    }

    lResult = RegDeleteValue(hKey,
                             pszOldValName);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("RegReplaceIfExisting: RegDelValue %s failed. \n"),pszOldValName));
        return FALSE;
    }

    return TRUE;
}

BOOL ReplaceString(
    LPCTSTR lpszOldStr,
    LPCTSTR lpszReplaceStr,
    LPCTSTR lpszReplacedWithStr,
    LPTSTR lpszOutputStr)
{
    LPTSTR pszAnchor = NULL;

    lstrcpy(lpszOutputStr,lpszOldStr);
    pszAnchor = _tcsstr(lpszOutputStr,lpszReplaceStr);

    if (!pszAnchor) {
        return FALSE;
    }

    if (lstrcmp(pszAnchor,lpszReplaceStr) != 0) {
        return FALSE;
    }

    lstrcpy(pszAnchor,lpszReplacedWithStr);
    return TRUE;
}


BOOL Delnode_Recurse (LPTSTR lpDir)
{
    WIN32_FIND_DATA fd;
    HANDLE hFile;

    //
    // Verbose output
    //

    //DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Entering, lpDir = <%s>\n"), lpDir));


    //
    // Setup the current working dir
    //

    if (!SetCurrentDirectory (lpDir)) {
        //DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse:  Failed to set current working directory.  Error = %d\n"), GetLastError()));
        return FALSE;
    }


    //
    // Find the first file
    //

    hFile = FindFirstFile(c_szStarDotStar, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        } else {
            //DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: FindFirstFile failed.  Error = %d\n"),
            //         GetLastError()));
            return FALSE;
        }
    }


    do {
        //
        //  Verbose output
        //

        //DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: FindFile found:  <%s>\n"),
        //         fd.cFileName));

        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(fd.cFileName, c_szDot)) {
            continue;
        }

        if (!lstrcmpi(fd.cFileName, c_szDotDot)) {
            continue;
        }


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Found a directory.
            //

            if (!Delnode_Recurse(fd.cFileName)) {
                FindClose(hFile);
                return FALSE;
            }

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                fd.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes (fd.cFileName, fd.dwFileAttributes);
            }


            if (!RemoveDirectory (fd.cFileName)) {
            //    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Failed to delete directory <%s>.  Error = %d\n"),
            //            fd.cFileName, GetLastError()));
            } else {
            //    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Successfully delete directory <%s>.\n"),
            //            fd.cFileName));
            }

        } else {

            //
            // We found a file.  Set the file attributes,
            // and try to delete it.
            //

            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
                SetFileAttributes (fd.cFileName, FILE_ATTRIBUTE_NORMAL);
            }

            if (!DeleteFile (fd.cFileName)) {
            //    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Failed to delete <%s>.  Error = %d\n"),
            //            fd.cFileName, GetLastError()));
            }
            else {
            //    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Successful delete <%s>.\n"),
            //            fd.cFileName));
            }

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


    //
    // Close the search handle
    //

    FindClose(hFile);


    //
    // Reset the working directory
    //

    if (!SetCurrentDirectory (c_szDotDot)) {
        DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse:  Failed to reset current working directory.  Error = %d\n"), GetLastError()));
        return FALSE;
    }


    //
    // Success.
    //

    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Leaving <%s>\n"), lpDir));

    return TRUE;
}


BOOL Delnode (LPTSTR lpDir)
{
    TCHAR szCurWorkingDir[MAX_PATH];

    if (GetCurrentDirectory(MAX_PATH, szCurWorkingDir)) {

        Delnode_Recurse (lpDir);

        SetCurrentDirectory (szCurWorkingDir);

        if (!RemoveDirectory (lpDir)) {
            DebugMsg((DM_VERBOSE, TEXT("Delnode: Failed to delete directory <%s>.  Error = %d\n"),
                    lpDir, GetLastError()));
            return FALSE;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("Delnode: RemoveDirectory OK <%s>.\n"),lpDir));
        }


    } else {

        DebugMsg((DM_VERBOSE, TEXT("Delnode:  Failed to get current working directory.  Error = %d\n"), GetLastError()));
        return FALSE;
    }

    return TRUE;

}

BOOL GetProgramsDirectory (BOOL bCommonGroup, LPTSTR lpDirectory)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;
    TCHAR szDirectory[MAX_PATH];
    UINT uID;
    BOOL bRetVal = FALSE;


    //
    // Open the User Shell Folders in the registry
    //


    lResult = RegOpenKeyEx ((bCommonGroup ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER),
                            USER_SHELL_FOLDER, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        goto Exit;
    }


    //
    // Now query for the programs directory
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    szDirectory[0] = TEXT('\0');

    if (bCommonGroup) {

        lResult = RegQueryValueEx (hKey, TEXT("Common Programs"),
                                   NULL, &dwType, (LPBYTE) szDirectory, &dwSize);
    } else {

        lResult = RegQueryValueEx (hKey, TEXT("Programs"),
                                   NULL, &dwType, (LPBYTE) szDirectory, &dwSize);
    }


    RegCloseKey(hKey);


    if (lResult != ERROR_SUCCESS) {
        goto Exit;
    }


    //
    // Did we find anything?
    //

    if (szDirectory[0] == TEXT('\0')) {
        goto Exit;
    }


    //
    // Save the result
    //


    if (ExpandEnvironmentStrings(szDirectory, lpDirectory, MAX_PATH)) {
        bRetVal = TRUE;
    }


Exit:
    return bRetVal;

}

BOOL GetGenericUserFolderDirectory (LPCTSTR lpszFolder, LPTSTR lpDirectory)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;
    TCHAR szDirectory[MAX_PATH];
    UINT uID;
    BOOL bRetVal = FALSE;


    //
    // Open the User Shell Folders in the registry
    //


    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            USER_SHELL_FOLDER, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        goto Exit;
    }

    //
    // Now query for the programs directory
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    szDirectory[0] = TEXT('\0');

    lResult = RegQueryValueEx (hKey, lpszFolder,
                               NULL, &dwType, (LPBYTE) szDirectory, &dwSize);

    RegCloseKey(hKey);


    if (lResult != ERROR_SUCCESS) {
        goto Exit;
    }


    //
    // Did we find anything?
    //

    if (szDirectory[0] == TEXT('\0')) {
        goto Exit;
    }


    //
    // Save the result
    //


    if (ExpandEnvironmentStrings(szDirectory, lpDirectory, MAX_PATH)) {
        bRetVal = TRUE;
    }


Exit:
    return bRetVal;

}

STRING_TO_DATA InfRegSpecTohKey[] = {
    TEXT("HKEY_LOCAL_MACHINE"), (UINT)((UINT_PTR)HKEY_LOCAL_MACHINE),
    TEXT("HKLM")              , (UINT)((UINT_PTR)HKEY_LOCAL_MACHINE),
    TEXT("HKEY_CLASSES_ROOT") , (UINT)((UINT_PTR)HKEY_CLASSES_ROOT),
    TEXT("HKCR")              , (UINT)((UINT_PTR)HKEY_CLASSES_ROOT),
    TEXT("HKR")               , (UINT)((UINT_PTR)NULL),
    TEXT("HKEY_CURRENT_USER") , (UINT)((UINT_PTR)HKEY_CURRENT_USER),
    TEXT("HKCU")              , (UINT)((UINT_PTR)HKEY_CURRENT_USER),
    TEXT("HKEY_USERS")        , (UINT)((UINT_PTR)HKEY_USERS),
    TEXT("HKU")               , (UINT)((UINT_PTR)HKEY_USERS),
    TEXT("")                  , (UINT)((UINT_PTR)NULL)
};

 BOOL
 LookUpStringInTable(
     IN  PSTRING_TO_DATA Table,
     IN  LPCTSTR         String,
     OUT PUINT           Data
     )
 {
     UINT i;

     for(i=0; Table[i].String; i++) {
         if(!lstrcmpi(Table[i].String,String)) {
             *Data = Table[i].Data;
             return(TRUE);
         }
     }

     return(FALSE);
 }


BOOL INIFile_ChangeSectionName(
    LPCTSTR szIniFileName,
    LPCTSTR szIniOldSectionName,
    LPCTSTR szIniNewSectionName)
{
#define MAX_SIZE 0x7FFFE

    LPTSTR pBuf = NULL;
    BOOL  bRetVal = FALSE;
    DWORD dwSizeofBuf;

    DebugMsg((DM_VERBOSE,TEXT("[INIFile_ChangeSectionName] Calling ,%s,%s,%s ! \n"),
              szIniFileName,szIniOldSectionName,szIniNewSectionName));
    //
    // allocate max size of buffer
    //
    pBuf = (LPTSTR) malloc(MAX_SIZE);

    if (! pBuf) {
        DebugMsg((DM_VERBOSE,TEXT("[INIFile_ChangeSectionName] memory allocate error ! \n")));
        goto Exit1;
    }

    dwSizeofBuf = GetPrivateProfileSection(
                      szIniOldSectionName,
                      pBuf,
                      MAX_SIZE/sizeof(TCHAR),
                      szIniFileName);
    if (! dwSizeofBuf) {
        //
        // this section is not in INI file
        //
        // do nothing
        //
        DebugMsg((DM_VERBOSE,TEXT("[INIFile_ChangeSectionName] No %s section in %s ! \n"),szIniOldSectionName));
        bRetVal = TRUE;
        goto Exit2;
    }

    if (dwSizeofBuf == (MAX_SIZE/sizeof(TCHAR)) - 2) {
        //
        // buffer too small
        //
        bRetVal = FALSE;
        DebugMsg((DM_VERBOSE,TEXT("[INIFile_ChangeSectionName] memory not enough ! \n"),szIniOldSectionName,szIniFileName));
        goto Exit2;
    }

    bRetVal =  WritePrivateProfileSection(
                   szIniNewSectionName,
                   pBuf,
                   szIniFileName);
    if (! bRetVal) {
        //
        // write failure
        //
        DebugMsg((DM_VERBOSE,TEXT("[INIFile_ChangeSectionName] WritePrivateProfileSection ! \n")));
        goto Exit2;
    }

    WritePrivateProfileSection(
        szIniOldSectionName,
        NULL,
        szIniFileName);

    //
    // at this step, even old section is not deleted, it's still OK
    //
    bRetVal = TRUE;

Exit2:

    if (pBuf) {
        free(pBuf);
    }

Exit1:
    return bRetVal;
}

BOOL INIFile_ChangeKeyName(
    LPCTSTR szIniFileName,
    LPCTSTR szIniOldSectionName,
    LPCTSTR szIniOldKeyName,
    LPCTSTR szIniNewKeyName)
{
#define MAX_SIZE 0x7FFFE

    LPTSTR pBuf = NULL;
    BOOL  bRetVal = FALSE;
    DWORD dwSizeofBuf;

//    DebugMsg((DM_VERBOSE,TEXT("[INIFile_ChangeKeyName] Calling ,%s,%s,%s %s! \n"),
//            szIniFileName,szIniNewSectionName,szIniOldKeyName,szIniNewKeyName));
    //
    // allocate max size of buffer
    //
    pBuf = (LPTSTR) malloc(MAX_SIZE);

    if (! pBuf) {
//        DebugMsg((DM_VERBOSE,TEXT("[INIFile_ChangeSectionName] memory allocate error ! \n")));
        goto Exit1;
    }

    dwSizeofBuf = GetPrivateProfileString(
                      szIniOldSectionName,
                      szIniOldKeyName,
                      TEXT(""),
                      pBuf,
                      MAX_SIZE/sizeof(TCHAR),
                      szIniFileName);
    if (! dwSizeofBuf) {
        //
        // this section is not in INI file
        //
        // do nothing
        //
//        DebugMsg((DM_VERBOSE,TEXT("[INIFile_ChangeSectionName] No %s section in %s ! \n"),));
        bRetVal = TRUE;
        goto Exit2;
    }

    if (dwSizeofBuf == (MAX_SIZE/sizeof(TCHAR)) - 1) {
        //
        // buffer too small
        //
        bRetVal = FALSE;
//        DebugMsg((DM_VERBOSE,TEXT("[INIFile_ChangeSectionName] memory not enough ! \n"),szIniOldSectionName,szIniFileName));
        goto Exit2;
    }

    bRetVal =  WritePrivateProfileString(
                   szIniOldSectionName,
                   szIniNewKeyName,
                   pBuf,
                   szIniFileName);

    if (! bRetVal) {
        //
        // write failure
        //
//        DebugMsg((DM_VERBOSE,TEXT("[INIFile_ChangeSectionName] WritePrivateProfileSection ! \n")));
        goto Exit2;
    }

    WritePrivateProfileString(
        szIniOldSectionName,
        szIniOldKeyName,
        NULL,
        szIniFileName);

    //
    // at this step, even old section is not deleted, it's still OK
    //
    bRetVal = TRUE;

Exit2:

    if (pBuf) {
        free(pBuf);
    }

Exit1:
    return bRetVal;
}


UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[2*MAX_PATH];
    LPTSTR lpEnd;

    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    lstrcpy (szDirectory, lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        lpEnd += 2;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        lpEnd++;

    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    DebugMsg((DM_VERBOSE, TEXT("CreateNestedDirectory:  CreateDirectory failed with %d."), GetLastError()));
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    DebugMsg((DM_VERBOSE, TEXT("CreateNestedDirectory:  Failed to create the directory with error %d."), GetLastError()));

    return 0;

}

BOOL (* MYSHGetSpecialFolderPathW) (HWND , LPTSTR , int , BOOL );

BOOL GetApplicationFolderPath(LPTSTR lpszFolder,UINT nLen)
{
    HINSTANCE hDll;
    BOOL bGotPath = FALSE;

    hDll = LoadLibrary(TEXT("shell32.dll"));
    if (hDll) {
        (FARPROC) MYSHGetSpecialFolderPathW = GetProcAddress(hDll,"SHGetSpecialFolderPathW");
        if (MYSHGetSpecialFolderPathW) {
            if (MYSHGetSpecialFolderPathW(NULL, lpszFolder, CSIDL_APPDATA , FALSE)){
                DebugMsg((DM_VERBOSE,TEXT("[GetApplicationFolder] SHGetSpecialFolderPath %s !\n"),lpszFolder));
                bGotPath = TRUE;
            } else {
                DebugMsg((DM_VERBOSE,TEXT("[GetApplicationFolder] SHGetSpecialFolderPath failed !\n")));
            }
        } else {
            DebugMsg((DM_VERBOSE,TEXT("[GetApplicationFolder] GetProc of SHGetSpecialFolderPath failed !\n")));
        }
        FreeLibrary(hDll);
    } else {
        DebugMsg((DM_VERBOSE,TEXT("[GetApplicationFolder] Load shell32.dll failed ! %d\n"),GetLastError()));
    }

    if (! bGotPath) {
        ExpandEnvironmentStrings(TEXT("%userprofile%"),lpszFolder,nLen);
        lstrcat(lpszFolder,TEXT("\\Application data"));
    }
    return TRUE;
}

BOOL GetNewPath(
    LPTSTR  lpszNewPath,
    LPCTSTR lpszFileName,
    LPCTSTR lpszClass)
{
    BOOL bRet = FALSE;
    LPTSTR lpszBaseName;

    GetApplicationFolderPath(lpszNewPath,MAX_PATH);

    ConcatenatePaths(lpszNewPath, lpszClass,MAX_PATH);

    if (! CreateNestedDirectory(lpszNewPath,NULL)) {
        DebugMsg((DM_VERBOSE,TEXT("[GetNewPath] CreateDirectory %s ! %X\n"),lpszNewPath,GetLastError()));
    }
    if ((lpszBaseName = _tcsrchr(lpszFileName,TEXT('\\'))) != NULL) {
        ConcatenatePaths(lpszNewPath,lpszBaseName,MAX_PATH);
    } else {
        ConcatenatePaths(lpszNewPath,lpszFileName,MAX_PATH);
        DebugMsg((DM_VERBOSE,TEXT("[GetNewPath] can't find \\ in %s !\n"),lpszFileName));
    }

    DebugMsg((DM_VERBOSE,TEXT("[GetNewPath] return %s !\n"),lpszNewPath));

    bRet = TRUE;

    return bRet;

}

BOOL MovePerUserIMEData(
    HKEY    hCurrentKey,
    LPCTSTR szRegPath,
    LPCTSTR szRegVal,
    LPCTSTR szUserClass,
    LPCTSTR szIMEName,
    BOOL bCHT)
{
    HKEY hKey;
    DWORD dwErr,dwSize,dwType;
    BOOL bRet;
    TCHAR szPath[MAX_PATH],szNewPath[MAX_PATH];

    bRet = FALSE;

    DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] szRegPath   = %s !\n"),szRegPath));
    DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] szRegVal    = %s !\n"),szRegVal));
    DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] szUserClass = %s !\n"),szUserClass));

    dwErr = RegOpenKeyEx( hCurrentKey,
                          szRegPath,
                          0,
                          KEY_READ | KEY_WRITE,
                          &hKey );

    if (dwErr != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] Open key failed %X!\n"),GetLastError()));
        bRet = TRUE;
        goto Exit1;
    }

    dwSize = sizeof(szPath);
    dwErr = RegQueryValueEx(hKey,
                            szRegVal,
                            NULL,
                            &dwType,
                            (LPBYTE) szPath,
                            &dwSize);

     if (dwErr != ERROR_SUCCESS) {
         DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] Value %s doesn't exist !\n"),szRegVal));
         bRet = TRUE;
         goto Exit2;
     }

     if (bCHT) {
         if (GetFileAttributes(szPath) == 0xFFFFFFFF) {
             DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] File %s doesn't exist !\n"),szPath));
             goto Exit2;
         }
         DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] File %s existing !\n"),szPath));

         if (! GetNewPath(szNewPath,szPath,szUserClass)) {
             DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] Get new path name failed !\n")));
             goto Exit2;
         }

         DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] Get new path name OK,%s !\n"),szNewPath));


         if (! CopyFile(szPath,szNewPath,FALSE)) {
             DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] Copy %s to %s failed ! %d\n"),szPath,szNewPath,GetLastError()));
             goto Exit2;
         }
         DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] Copy %s to %s OK !\n"),szPath,szNewPath));

     } else { // in CHS case
         lstrcpy(szPath,szIMEName);
         lstrcat(szPath,TEXT(".emb"));
         if (! GetNewPath(szNewPath,szPath,szUserClass)) {
             DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] Get new path name failed !\n")));
             goto Exit2;
         }

         DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] Get new path name OK,%s !\n"),szNewPath));
     }

#if 1
     dwErr = RegSetValueEx(hKey,
                           szRegVal,
                           0,
                           REG_SZ,
                           (LPBYTE) szNewPath,
                           (lstrlen(szNewPath)+1) * sizeof(TCHAR));

     if (dwErr != ERROR_SUCCESS) {
         DebugMsg((DM_VERBOSE,TEXT("[MovePerUserIMEData] Set Value %s = %s failed !\n"),szRegVal,szNewPath));
         goto Exit2;
     }
#endif
     bRet = TRUE;
Exit2:
    RegCloseKey(hKey);
Exit1:
    return bRet;
}

BOOL CreateSecurityDirectory(
    LPCTSTR pszOldDir,
    LPCTSTR pszNewDir)
{
    DWORD dwLength,dwLengthNeeded;
    PSECURITY_DESCRIPTOR pSD;
    BOOL bRet = FALSE;

    if (CreateNestedDirectory(pszNewDir,NULL)) {
        //
        // Copy the ACLs from the old location to the new
        //

        dwLength = 1024;
        pSD = (PSECURITY_DESCRIPTOR)LocalAlloc (LPTR, dwLength);

        if (pSD) {

            if (GetFileSecurity (pszOldDir,
                                 DACL_SECURITY_INFORMATION,
                                 pSD, dwLength, &dwLengthNeeded)) {

                SetFileSecurity (pszNewDir,
                                 DACL_SECURITY_INFORMATION, pSD);
                bRet = TRUE;
            } else {
                DebugMsg((DM_VERBOSE, TEXT("CreateSecurityDirectory:  Failed to allocate get security descriptor with %d.  dwLengthNeeded = %d"),
                         GetLastError(), dwLengthNeeded));
            }

            LocalFree (pSD);

        } else {
            DebugMsg((DM_VERBOSE, TEXT("CreateSecurityDirectory:  Failed to allocate memory for SD with %d."),
                     GetLastError()));
        }


    } else {
        DebugMsg((DM_VERBOSE,TEXT("CreateSecurityDirectory %s ! %X\n"),pszNewDir,GetLastError()));
    }

    return bRet;
}

BOOL IsDirExisting(
    LPTSTR Dir)
{
    LONG lResult = GetFileAttributes(Dir);

    DebugMsg((DM_VERBOSE, TEXT("[IsDirExisting]  %s  lResult:%X\n"),Dir,lResult));

    if ((lResult == 0xFFFFFFFF) ||
        (!(lResult & FILE_ATTRIBUTE_DIRECTORY))) { 
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL IsFileExisting(
    LPTSTR File)
{
    LONG lResult = GetFileAttributes(File);

    DebugMsg((DM_VERBOSE, TEXT("[IsFileExisting]  %s  lResult:%X\n"),File,lResult));

    if ((lResult == 0xFFFFFFFF) ||
        ((lResult & FILE_ATTRIBUTE_DIRECTORY))) { 
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL RenameDirectory(
    LPTSTR OldDir,
    LPTSTR NewDir)
{
    BOOL bRet=TRUE;

    if (!IsDirExisting(OldDir)) {
        return FALSE;
    }

    if (IsDirExisting(NewDir)) {
        //
        // iF Target directory is already created, then copy files from source to dest dir 
        //
        if (CopyProfileDirectory (OldDir, NewDir, CPD_IGNOREHIVE)) {
            DebugMsg((DM_VERBOSE, TEXT("[RenameDirectory] Successfully CopyProfileDirectory \nFrom:%s\nTo  :%s\n"),OldDir, NewDir));
            if (Delnode (OldDir)) {
                DebugMsg((DM_VERBOSE, TEXT("[RenameDirectory] Successfully removed folder:%s\n"),OldDir));
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("[RenameDirectory]  Failed remove folder:\n%s\n"),OldDir));
            }
        } else {
            bRet = FALSE;
            DebugMsg((DM_VERBOSE, TEXT("RenameDirectory:  Failed to change folder name:\n%s\n%s"),OldDir, NewDir));
        }
    } else {
        //
        // iF Target has not been created, then just move source dir to dest dir 
        //
        if (MoveFile(OldDir, NewDir)) {
            DebugMsg((DM_VERBOSE, TEXT("[RenameDirectory] Move %s to %s OK !\n"),OldDir, NewDir));
        } else {
            bRet = FALSE;
            DebugMsg((DM_VERBOSE, TEXT("[RenameDirectory] Failed to change folder name:\n%s\n%s\n"),OldDir, NewDir));
        }
    }
    return TRUE;
}

BOOL RenameFile(
    LPTSTR OldFile,
    LPTSTR NewFile)
{
    BOOL bRet=TRUE;

    if (!IsFileExisting(OldFile)) {
        return FALSE;
    }

    if (IsFileExisting(NewFile)) {
        if (DeleteFile (OldFile)) {
            DebugMsg((DM_VERBOSE, TEXT("[RenameFile] Successfully delete %s\n"),OldFile));
        } else {
            bRet = FALSE;
            DebugMsg((DM_VERBOSE, TEXT("[RenameFile] Failed to delete file %s\n"),OldFile));
        }
    } else {
        //
        // iF Target has not been created, then just move source dir to dest dir 
        //
        if (MoveFile(OldFile, NewFile)) {
            DebugMsg((DM_VERBOSE, TEXT("[RenameFile] Move %s to %s OK !\n"),OldFile, NewFile));
        } else {
            bRet = FALSE;
            DebugMsg((DM_VERBOSE, TEXT("[RenameFile] Failed to change File name:%s  to %s\n"),OldFile, NewFile));
        }
    }
    return bRet;
}

BOOL RenameSectionFiles(
    HINF hInf,
    LPCTSTR SectionName,
    LPCTSTR SourceDirectory,
    LPCTSTR TargetDirectory)
{
    LONG LineCount,LineNo;
    INFCONTEXT InfContext;
    LPCTSTR pszSrcFile,pszDstFile;
    TCHAR szMediaPath[MAX_PATH];

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[RenameSectionFiles] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,SectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[RenameSectionFiles] line count == 0 !\n")));
        return FALSE;
    }

 
    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if ( SetupGetLineByIndex(hInf,SectionName,LineNo,&InfContext)
             && (pszSrcFile = pSetupGetField(&InfContext,1))
             && (pszDstFile = pSetupGetField(&InfContext,2))
           ) {

            TCHAR SourceFile[MAX_PATH];
            TCHAR TargetFile[MAX_PATH];
        

            lstrcpy(SourceFile,SourceDirectory);
            lstrcpy(TargetFile,TargetDirectory);
        

            ConcatenatePaths(SourceFile,pszSrcFile,MAX_PATH);
            ConcatenatePaths(TargetFile,pszDstFile,MAX_PATH);

            if (RenameFile(SourceFile, TargetFile)) {
                DebugMsg((DM_VERBOSE, TEXT("[RenameSectionFiles] Rename %s to %s OK !\n"),SourceFile, TargetFile));
            } else {
               DebugMsg((DM_VERBOSE, TEXT("[RenameSectionFiles] Rename %s to %s Failed !\n"),SourceFile, TargetFile));
            }
        }
    }
    return TRUE;
}

BOOL RenameSectionRegSZ(
    HINF hInf,
    LPCTSTR SectionName,
    HKEY hRootKey,
    LPCTSTR RegPath)
{
    LONG LineCount,LineNo;
    INFCONTEXT InfContext;
    LPCTSTR pszSrc,pszDst;
    TCHAR szMediaPath[MAX_PATH];

    HKEY hKey;
    DWORD dwErr;
    DWORD dwType;
    DWORD dwSize;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[RenameSectionRegSZ] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,SectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[RenameSectionRegSZ] line count == 0 !\n")));
        return FALSE;
    }

 
    dwErr = RegOpenKeyEx( hRootKey,
                          RegPath,
                          0,
                          KEY_READ | KEY_WRITE,
                          &hKey );

    if (dwErr != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[RenameSectionRegSZ] Failed RegOpenKeyEx !\n")));
        return FALSE;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if ( SetupGetLineByIndex(hInf,SectionName,LineNo,&InfContext)
             && (pszSrc = pSetupGetField(&InfContext,1))
             && (pszDst = pSetupGetField(&InfContext,2))
           ) {

            BYTE Data[5000];

            dwSize = sizeof(Data);

            dwErr = RegQueryValueEx(hKey,
                                    pszSrc,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) Data,
                                    &dwSize);

            if (dwErr != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[RenameSectionRegSZ] Failed RegQueryValueEx %s [%X] !\n"), pszSrc,dwErr));
                continue;
            }

            dwErr = RegSetValueEx(hKey,
                                  pszDst,
                                  0,
                                  dwType,
                                  (LPBYTE) Data,
                                  dwSize);

            if (dwErr != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[RenameSectionRegSZ] Failed RegSetValueEx %s [%X] !\n"), pszDst,dwErr));
                continue;
            }

            dwErr = RegDeleteValue(hKey,pszSrc);
            if (dwErr != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[RenameSectionRegSZ] Failed RegDeleteValue %s [%X] !\n"), pszSrc,dwErr));
                continue;
            }   
        }
    }

    RegCloseKey(hKey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\cmd.h ===
#ifndef __CMD_H__
#define __CMD_H__

class CCmd : public CObject {
public:
    CCmd();
    ~CCmd();

    BOOL bInit();
    BOOL bInit(int argc, char* argv[]);

    virtual BOOL ProcessToken(LPSTR lpszStr)=0;
private:
    //
        // member function
        //
    BOOL ParseCmdLine();
        //
        // member data
        //
    int m_argc;
    char** m_argv;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\infcat.h ===
#if !defined(AFX_INFCAT_H__0EE1A980_80C3_11D2_9ED0_00A0241A68BE__INCLUDED_)
#define AFX_INFCAT_H__0EE1A980_80C3_11D2_9ED0_00A0241A68BE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_INFCAT_H__0EE1A980_80C3_11D2_9ED0_00A0241A68BE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\mycmd.h ===
#ifndef __MYCMD_H__
#define __MYCMD_H__

#include "cmd.h"

class CMyCmd : public CCmd {
public:

    CMyCmd();
    ~CMyCmd();
    virtual BOOL ProcessToken(LPTSTR lpszToken);
    BOOL GetParam(INT i,LPCTSTR& Locale, LPCTSTR& FileName);
    INT GetSize() {return (INT)m_LocaleList.GetSize();}
    BOOL Do();
    void Help();
private:
    CStringArray m_LocaleList;
    CStringArray m_FileNameList;
    CString m_TargetFile;
    CString m_SourceFile;
    CString m_SourceLocale;

};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\infcat.cpp ===
#include "stdafx.h"
#include "infcat.h"
#include "mycmd.h"

__cdecl main(int argc, char* argv[])
{
    int nRetCode = 0;

    CMyCmd MyCmd;

    if (MyCmd.bInit(argc,argv)) {
        MyCmd.Do();
    } else {
        MyCmd.Help();
    }


    return nRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\filemap.h ===
#ifndef __FILEMAP_H__
#define __FILEMAP_H__

class CFileMap : public CObject {
public:
    CFileMap();
    ~CFileMap();
    BOOL     bOpen(LPCTSTR FileName,BOOL ReadOnly=TRUE);
    BOOL     bClose();
    LPBYTE   GetMemPtr() {return m_Memory;}
    DWORD    GetFileSize() {return m_FileSize;}
    UINT_PTR GetOffset(LPBYTE Tag) {return Tag - m_Memory;}
protected:
    LPBYTE  m_Memory;
    HANDLE  m_FileMapping;
    HANDLE  m_FileHandle;
    DWORD   m_FileSize;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\myinf.cpp ===
#include "stdafx.h"
#include "filemap.h"
#include "mymfile.h"
#include "myinf.h"

CMyInf::CMyInf()
{
    m_SectionStart = NULL;
    m_SectionEnd   = NULL;
    m_Locale[0]    = L'\0';
}

CMyInf::~CMyInf()
{
}

BOOL CMyInf::bOpen(LPCSTR FileName, LPCTSTR Locale)
{
    if (! CFileMap::bOpen(FileName)) {
        return FALSE;
    }

    if (! FindStringSection()) {
        fprintf(stderr,"No string section inside this file !\n");
        return FALSE;
    }

    if (! _GenerateStringName(Locale)) {
        fprintf(stderr,"No string section inside this file !\n");
        return FALSE;
    }

    return TRUE;
}

BOOL CMyInf::FindStringSection()
{
    BOOL bInSection = FALSE;

    for (DWORD i=0; i<m_FileSize; i += sizeof(WCHAR)) {

        if (*(WCHAR *) (m_Memory +i) == TEXT('[')) {

            if (i+8 >= m_FileSize) {
                //
                // over boundary, not a candinate
                //
                return FALSE;
            }

            WCHAR * TmpBuf = (WCHAR *) (m_Memory +i);

            if ( ((TmpBuf[1] == TEXT('s')) || (TmpBuf[1] == TEXT('S'))) &&
                 ((TmpBuf[2] == TEXT('t')) || (TmpBuf[2] == TEXT('T'))) &&
                 ((TmpBuf[3] == TEXT('r')) || (TmpBuf[3] == TEXT('R'))) &&
                 ((TmpBuf[4] == TEXT('i')) || (TmpBuf[4] == TEXT('I'))) &&
                 ((TmpBuf[5] == TEXT('n')) || (TmpBuf[5] == TEXT('N'))) &&
                 ((TmpBuf[6] == TEXT('g')) || (TmpBuf[6] == TEXT('G'))) &&
                 ((TmpBuf[7] == TEXT('s')) || (TmpBuf[7] == TEXT('S'))) &&
                 (TmpBuf[8] == TEXT(']') ) )  {

                bInSection = TRUE;
                m_SectionStart = m_Memory+i;
                continue;
            }

            if (bInSection && (*(WCHAR *) (m_Memory +i) == TEXT('['))) {
                break;
            }
        }
    }

    if (bInSection) {
        m_SectionEnd = m_Memory +i;
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL CMyInf::AppendNonStringSectionPart(CMemFile& MemFile)
{
    MemFile.Write(m_Memory, (UINT)GetOffset(m_SectionStart));
    return TRUE;
}

BOOL CMyInf::AppendStringSectionPart(CMemFile& MemFile)
{
    MemFile.Write(m_Locale,lstrlenW(m_Locale)*sizeof(WCHAR));
    MemFile.Write(m_SectionStart+lstrlenW(L"[Strings]")*sizeof(WCHAR), (UINT)(m_SectionEnd - m_SectionStart - lstrlenW(L"[Strings]")*sizeof(WCHAR)));
    return TRUE;
}

BOOL CMyInf::Duplicate(CMemFile& MemFile)
{
    MemFile.Write(m_Memory,m_FileSize);
    return TRUE;
}

BOOL CMyInf::_GenerateStringName(LPCSTR Locale)
{
    WCHAR szTmpBuf[MAX_PATH];

    if (lstrlen(Locale) == 0) {
        lstrcpyW(m_Locale,L"[Strings]");
        return TRUE;
    }

    if (lstrlen(Locale)*2+10 > sizeof(m_Locale)) {
        return FALSE;
    }
    //
    // this string contains number only, so it's safe to use ACP
    //
    MultiByteToWideChar(CP_ACP,
                        0,
                        Locale,
                        -1,
                        szTmpBuf,
                        MAX_PATH);

    lstrcpyW(m_Locale,L"[Strings");

    lstrcatW(m_Locale,L".");
    lstrcatW(m_Locale,szTmpBuf);

    lstrcatW(m_Locale,L"]");

    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\filemap.cpp ===
#include "stdafx.h"
#include "filemap.h"

CFileMap::CFileMap()
{
    m_Memory      = NULL;
    m_FileMapping = NULL;
    m_FileHandle  = NULL;
    m_FileSize    = 0;
}

CFileMap::~CFileMap()
{
    bClose();
}

BOOL CFileMap::bOpen(LPCTSTR FileName,BOOL ReadOnly)
{
    BOOL   bRet = FALSE;

    m_FileHandle = CreateFile(
                       FileName,
                       GENERIC_READ,
                       (ReadOnly) ? FILE_SHARE_READ : FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if(m_FileHandle == INVALID_HANDLE_VALUE) {
        fprintf(stderr,"Open file error ! %X\n", GetLastError());
        goto Error;
    }

    m_FileSize = ::GetFileSize(m_FileHandle,NULL);

    if(m_FileSize == -1) {
        fprintf(stderr,"Get file size error ! %X\n", GetLastError());
        goto Error;
    }

    if(!m_FileSize) {
        fprintf(stderr,"File size is 0 !\n");
        goto Error;
    }

    m_FileMapping= CreateFileMapping(
                        m_FileHandle,
                        NULL,
                        (ReadOnly) ? PAGE_READONLY : PAGE_READWRITE,
                        0,
                        0 ,
                        NULL);

    if(m_FileMapping == NULL) {
        fprintf(stderr,"Unable to map file ! %X\n", GetLastError());
        goto Error;
    }

    m_Memory = (LPBYTE) MapViewOfFile(
                            m_FileMapping,
                            (ReadOnly) ? FILE_MAP_READ : FILE_MAP_READ | FILE_MAP_WRITE,
                            0,0,
                            0);

    if(m_Memory  == NULL) {
        fprintf(stderr,"Map view failed ! %X\n", GetLastError());
        goto Error;
    }

    if (*(WCHAR *) m_Memory != 0xFEFF) {
        fprintf(stderr,"This is not unicode text file !\n");
        goto Error;
    }

    m_Memory+=sizeof(WCHAR);
    m_FileSize -= sizeof(WCHAR);
    return TRUE;
    
Error:
    bClose();
    return FALSE;
}

BOOL CFileMap::bClose()
{
    if (m_Memory) {
        UnmapViewOfFile(m_Memory);
        m_Memory = NULL;
    }

    if (m_FileMapping) {
        CloseHandle(m_FileMapping);
        m_FileMapping = NULL;
    }

    if (m_FileHandle) {
        CloseHandle(m_FileHandle);
        m_FileHandle = NULL;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\mymfile.cpp ===
#include "stdafx.h"
#include "mymfile.h"

CMyMemFile::CMyMemFile()
{
}

CMyMemFile::~CMyMemFile()
{
        Close();
}

BOOL CMyMemFile::bOpen(LPCTSTR FileName)
{
    BOOL bRet = FALSE;
    const WORD UnicodePrefix=0xFEFF;

    if (! Open(FileName,CFile::modeCreate | CFile::modeReadWrite)) {
        fprintf(stderr,"Open target file failed ! %d\n",GetLastError());
        goto Exit1;
    }

    Write(&UnicodePrefix,sizeof(WORD));

    bRet = TRUE;
Exit1:
    return bRet;
}

void CMyMemFile::bClose()
{
    if (m_lpBuffer) {
        CFile::Write(m_lpBuffer,m_nFileSize);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\mycmd.cpp ===
#include "stdafx.h"
#include "mymfile.h"
#include "myinf.h"
#include "mycmd.h"

CMyCmd::CMyCmd()
{
}

CMyCmd::~CMyCmd()
{
}


BOOL CMyCmd::ProcessToken(LPTSTR lpszStr)
{
    LPTSTR pszPair1,pszPair2;

    if (lpszStr && (*lpszStr == TEXT('-') || *lpszStr == TEXT('/'))) {

        lpszStr++;

        pszPair1 = pszPair2 = NULL;
        if (*(lpszStr+1)) {
            pszPair1 = lpszStr+1;
            pszPair2 = _tcsstr(lpszStr+1,TEXT(","));

            if (pszPair2) {
                *pszPair2 = TEXT('\0');
                pszPair2++;
            }
        }

        switch(*lpszStr) {
            case TEXT('t'):
            case TEXT('T'):
                if (pszPair1) {
                    m_TargetFile = CString(pszPair1);
                }
            break;

            case TEXT('s'):
            case TEXT('S'):
                if (!pszPair1 || GetFileAttributes(pszPair1) == 0xFFFFFFFF) {
                    fprintf(stderr,"Source file doesn't exist %s!\n",pszPair1);
                    return FALSE;
                }
                m_SourceFile   = CString(pszPair1);
                m_SourceLocale = CString(pszPair2);
            break;

            case TEXT('a'):
            case TEXT('A'):
                if (!pszPair1 || GetFileAttributes(pszPair1) == 0xFFFFFFFF) {
                    fprintf(stderr,"Appended file doesn't exist !\n");
                    return FALSE;
                }
                 m_FileNameList.Add(pszPair1);
                 m_LocaleList.Add(pszPair2);
            break;
            default:
                return FALSE;
        }
        return TRUE;
    } else {
        return FALSE;
    }

}

BOOL CMyCmd::GetParam(INT i,LPCTSTR& Locale, LPCTSTR& FileName)
{
    if (i > m_LocaleList.GetSize()) {
        return FALSE;
    }

    Locale   = (LPCTSTR) m_LocaleList[i];
    FileName = (LPCTSTR) m_FileNameList[i];
    return TRUE;
}

BOOL CMyCmd::Do()
{
    CMyMemFile Target;
    CMyInf Source;
    CMyInf* AppendedSource;
    BOOL bRet = FALSE;
    int i;
    
    if (! Target.bOpen(m_TargetFile)) {
        goto Exit1;
    }

    if (! Source.bOpen(m_SourceFile,m_SourceLocale)) {
        goto Exit2;
    }

    Source.AppendNonStringSectionPart(Target);
    Source.AppendStringSectionPart(Target);
    Source.bClose();

    Target.Write(L"\r\n",4);

    for (i=0; i< m_LocaleList.GetSize(); i++) {

        AppendedSource = (CMyInf *) new CMyInf;

        if (AppendedSource ) {
            if (AppendedSource->bOpen(m_FileNameList[i],m_LocaleList[i])) {
                AppendedSource->AppendStringSectionPart(Target);
                AppendedSource->bClose();
            }
            delete AppendedSource;
        } else {
            goto Exit2;
        }
    }
    bRet = TRUE;

Exit2:
    Target.bClose();
Exit1:
    return bRet;
}

void CMyCmd::Help()
{
    printf("infcat : localization tool for International team.\n\n");
    printf("infcat.exe -t[Dst] -s[Src|,Loc] -a[Src1|,Loc] -a[Src|,Loc] ...\n\n");
    printf("    -t - specify target file\n");
    printf("    -s - specify source file\n");
    printf("    -a - specify appended files\n");
    printf("   Dst - destination file name\n");
    printf("   Src - source file name\n");
    printf("   Loc - locale ID\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\myinf.h ===
#ifndef __MYINF_H__
#define __MYINF_H__

#include "filemap.h"

class CMyInf : public CFileMap {
public:
        CMyInf();
        ~CMyInf();
        BOOL FindStringSection();
        BOOL bOpen(LPCSTR FileName,LPCTSTR Locale);
        BOOL AppendNonStringSectionPart(CMemFile& MemFile);
        BOOL AppendStringSectionPart(CMemFile& MemFile);
        BOOL Duplicate(CMemFile& MemFile);

private:
        BOOL _GenerateStringName(LPCSTR Locale);

        LPBYTE  m_SectionStart;
        LPBYTE  m_SectionEnd;
        WCHAR   m_Locale[20];
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\mymfile.h ===
#ifndef __MYMFILE_H__
#define __MYMFILE_H__

class CMyMemFile : public CMemFile {
public:
    CMyMemFile();
    ~CMyMemFile();

    BOOL bOpen(LPCTSTR FileName);
    void bClose();

private:
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by infcat.rc
//
#define IDS_HELLO                       1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	infcat.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\ciccs.h ===
//
// ciccs.h
//


#ifndef CICCS_H
#define CICCS_H



class CCicCriticalSectionStatic
{
public:
    BOOL Init()
    {
        m_fInit = FALSE;
        if (InitializeCriticalSectionAndSpinCount(&m_cs, 0))
        {
            m_fInit = TRUE;
        }

        return m_fInit;
    }

    void Delete()
    {
        if (m_fInit)
        {
            DeleteCriticalSection(&m_cs);
            m_fInit = FALSE;
        }
    }

    operator CRITICAL_SECTION*()
    {
        return &m_cs;
    }

private:
    CRITICAL_SECTION m_cs;
    BOOL m_fInit;
};

#endif CICCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\cleanup.h ===
//
// cleanup.h
//

#ifndef CLEANUP_H
#define CLEANUP_H

struct ICleanupContextsClient : public IUnknown
{
    virtual HRESULT IsInterestedInContext(ITfContext *pic, BOOL *pfInterested) = 0;

    virtual HRESULT CleanupContext(TfEditCookie ecWrite, ITfContext *pic) = 0;
};

typedef void (*CLEANUP_COMPOSITIONS_CALLBACK)(TfEditCookie ecWrite, ITfRange *rangeComposition, void *pvPrivate);

BOOL CleanupAllCompositions(TfEditCookie ecWrite, ITfContext *pic, REFCLSID clsidOwner, CLEANUP_COMPOSITIONS_CALLBACK pfnCleanupCompositons, void *pvPrivate);

BOOL CleanupAllContexts(ITfThreadMgr *tim, TfClientId tid, ICleanupContextsClient *pClient);

#endif // CLEANUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\fe\infcat\stdafx.h ===
#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\computil.h ===
//
// computil.h
//


#ifndef COMPUTIL_H
#define COMPUTIL_H

#include "private.h"
#include "strary.h"
#include "immxutil.h"

HRESULT GetCompartment(IUnknown *punk, REFGUID rguidComp, ITfCompartment **ppComp, BOOL fGlobal);
HRESULT SetCompartmentDWORD(TfClientId tid, IUnknown *punk, REFGUID rguidComp, DWORD dw, BOOL fGlobal);
HRESULT GetCompartmentDWORD(IUnknown *punk, REFGUID rguidComp, DWORD *pdw, BOOL fGlobal);
HRESULT ToggleCompartmentDWORD(TfClientId tid, IUnknown *punk, REFGUID rguidComp, BOOL fGlobal);
HRESULT SetCompartmentGUIDATOM(TfClientId tid, IUnknown *punk, REFGUID rguidComp, TfClientId ga, BOOL fGlobal);
HRESULT GetCompartmentGUIDATOM(IUnknown *punk, REFGUID rguidComp, TfClientId *pga, BOOL fGlobal);
HRESULT SetCompartmentGUID(LIBTHREAD *plt, TfClientId tid, IUnknown *punk, REFGUID rguidComp, REFGUID rguid, BOOL fGlobal);
HRESULT GetCompartmentGUID(LIBTHREAD *plt, IUnknown *punk, REFGUID rguidComp, GUID *pguid, BOOL fGlobal);
HRESULT SetCompartmentUnknown(TfClientId tid, IUnknown *punk, REFGUID rguidComp, IUnknown *punkPriv);
HRESULT GetCompartmentUnknown(IUnknown *punk, REFGUID rguidComp, IUnknown **ppunkPriv);
HRESULT ClearCompartment(TfClientId tid, IUnknown *punk, REFGUID rguidComp, BOOL fGlobal);

typedef struct tag_CESMAP {
    ITfCompartment *pComp;
    DWORD dwCookie;
} CESMAP;

#define CES_INVALID_COOKIE  ((DWORD)(-1))

typedef HRESULT (*CESCALLBACK)(void *pv, REFGUID rguid);

class CCompartmentEventSink : public ITfCompartmentEventSink
{
public:
    CCompartmentEventSink(CESCALLBACK pfnCallback, void *pv);
    virtual ~CCompartmentEventSink() {};

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfCompartmentEventSink
    //
    STDMETHODIMP OnChange(REFGUID rguid);

    HRESULT _Advise(IUnknown *punk, REFGUID rguidComp, BOOL fGlobal);
    HRESULT _Unadvise();

protected:
    void SetCallbackPV(void* pv)
    {
        if (_pv == NULL)
            _pv = pv;
    };

private:
    CStructArray<CESMAP> _rgcesmap;

    long _cRef;
    CESCALLBACK _pfnCallback;
    void *_pv;
};

#endif //COMPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\catutil.h ===
//
// catutil.h
//

#ifndef CATUTIL_H
#define CATUTIL_H

#include "private.h"
#include "immxutil.h"

BOOL IsEqualTFGUIDATOM(LIBTHREAD *plt, TfGuidAtom guidatom, REFGUID rguid);
BOOL GetGUIDFromGUIDATOM(LIBTHREAD *plt, TfGuidAtom guidatom, GUID *pguid);
BOOL GetGUIDATOMFromGUID(LIBTHREAD *plt, REFGUID rguid, TfGuidAtom *pguidatom);
HRESULT LibEnumCategoriesInItem(LIBTHREAD *plt, REFGUID rguid, IEnumGUID **ppEnum);
HRESULT LibEnumItemsInCategory(LIBTHREAD *plt, REFGUID rcatid, IEnumGUID **ppEnum);

HRESULT RegisterGUIDDescription(REFCLSID rclsid, REFGUID rcatid, WCHAR *pszDesc);
HRESULT UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rcatid);
HRESULT GetGUIDDescription(LIBTHREAD *plt, REFCLSID rclsid, BSTR *pbstr);
HRESULT RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rcatid, DWORD dw);
HRESULT UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rcatid);
HRESULT GetGUIDDWORD(LIBTHREAD *plt, REFCLSID rclsid, DWORD*pdw);
HRESULT RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);
HRESULT UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);



typedef struct tagREGISTERCAT {
    const GUID *pcatid;
    const GUID *pguid;
} REGISTERCAT;

HRESULT RegisterCategories(REFCLSID rclsid, const REGISTERCAT *pregcat);
HRESULT UnregisterCategories(REFCLSID rclsid, const REGISTERCAT *pregcat);
HRESULT GetKnownModeBias(LIBTHREAD *plt, TfGuidAtom guidatom, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\cmydc.h ===
//
// cmydc.h
//


#ifndef CMYDC_H
#define CMYDC_H

class CSolidBrush
{
public:
    CSolidBrush(int r, int g, int b)
    {
        _hbr = CreateSolidBrush(RGB(r, g, b));
    }

    CSolidBrush(COLORREF rgb)
    {
        _hbr = CreateSolidBrush(rgb);
    }

    CSolidBrush()
    {
        _hbr = NULL;
    }

    BOOL Init(int r, int g, int b)
    {
        Assert(!_hbr);
        _hbr = CreateSolidBrush(RGB(r, g, b));
        return _hbr != NULL;
    }

    BOOL Init(COLORREF rgb)
    {
        Assert(!_hbr);
        _hbr = CreateSolidBrush(rgb);
        return _hbr != NULL;
    }

    ~CSolidBrush()
    {
        if (_hbr)
           DeleteObject(_hbr);
    }

    operator HBRUSH()
    {
        return _hbr;
    }

private:
    HBRUSH _hbr;
};

class CSolidPen
{
public:
    CSolidPen()
    {
        _hpen = NULL;
    }

    BOOL Init(int r, int g, int b)
    {
        Assert(!_hpen);
        _hpen = CreatePen(PS_SOLID, 0, RGB(r, g, b));
        return _hpen != NULL;
    }

    BOOL Init(COLORREF rgb)
    {
        Assert(!_hpen);
        _hpen = CreatePen(PS_SOLID, 0, rgb);
        return _hpen != NULL;
    }

    ~CSolidPen()
    {
        if (_hpen)
           DeleteObject(_hpen);
    }

    operator HPEN()
    {
        return _hpen;
    }

private:
    HPEN _hpen;
};

class CPatternBrush
{
public:
    CPatternBrush(HBITMAP hbmp)
    {
        _hbr = CreatePatternBrush(hbmp);
    }

    ~CPatternBrush()
    {
        if (_hbr)
            DeleteObject(_hbr);
    }

    operator HBRUSH()
    {
        return _hbr;
    }

private:
    HBRUSH _hbr;
};

class CBitmapDC
{
public:
    CBitmapDC(BOOL fCompat = FALSE)
    {
        _hbmp = NULL;
        _hbmpOld = NULL;
        _hbrOld = NULL;

        if (!fCompat)
            _hdc = CreateDC("DISPLAY", NULL, NULL, NULL);
        else
        {
            _hdc = CreateCompatibleDC(NULL);
        }

        Assert(HandleToULong(_hdc));
    }

    ~CBitmapDC()
    {
        Uninit();
        DeleteDC(_hdc);

    }

    void Uninit(BOOL fKeep = FALSE)
    {
        if (_hbmpOld)
        {
            SelectObject(_hdc, _hbmpOld);
            _hbmpOld = NULL;
        }

        if (_hbrOld)
        {
            SelectObject(_hdc, _hbrOld);
            _hbrOld = NULL;
        }

        if (!fKeep && _hbmp != NULL)
        {
            DeleteObject(_hbmp);
            _hbmp = NULL;
        }
    }

    BOOL SetCompatibleBitmap(int x, int y)
    {
        Assert(!_hbmp);
        Assert(!_hbmpOld);

        HDC hdc  = GetDC(NULL);
        _hbmp = CreateCompatibleBitmap(hdc, x, y);
        ReleaseDC(NULL, hdc);
        Assert(HandleToULong(_hbmp));
        _hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
        Assert(HandleToULong(_hbmpOld));
        return TRUE;
    }

    BOOL SetDIB(int cx, int cy, WORD iPlanes = 1, WORD iBitCount = 32)
    {
        BITMAPINFO bi = {0};
        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = cx;
        bi.bmiHeader.biHeight = cy;
        bi.bmiHeader.biPlanes = iPlanes;
        bi.bmiHeader.biBitCount = iBitCount;
        bi.bmiHeader.biCompression = BI_RGB;

        _hbmp = CreateDIBSection(_hdc, &bi, DIB_RGB_COLORS, NULL, NULL, 0);
        Assert(HandleToULong(_hbmp));
        _hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
        Assert(HandleToULong(_hbmpOld));
        return TRUE;
    }


    BOOL SetBitmap(int x, int y, int cPlanes, int cBitPerPixel)
    {
        Assert(!_hbmp);
        Assert(!_hbmpOld);

        _hbmp = CreateBitmap(x, y, cPlanes, cBitPerPixel, NULL);
        Assert(HandleToULong(_hbmp));
        _hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
        Assert(HandleToULong(_hbmpOld));
        return TRUE;
    }

    BOOL SetBitmap(HBITMAP hbmp)
    {
        if (_hdc)
        {
           Assert(!_hbmpOld);

           _hbmpOld = (HBITMAP)SelectObject(_hdc, hbmp);
           Assert(HandleToULong(_hbmpOld));
        }
        return TRUE;
    }

    BOOL SetBitmapFromRes(HINSTANCE hInst, LPCSTR lp)
    {
        Assert(!_hbmp);
        Assert(!_hbmpOld);

        _hbmp = LoadBitmap(hInst, lp);
        Assert(HandleToULong(_hbmp));
        _hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
        Assert(HandleToULong(_hbmpOld));
        return TRUE;
    }

    BOOL SetBrush(HBRUSH hbr)
    {
        if (hbr)
        {
            _hbrOld = (HBRUSH)SelectObject(_hdc, hbr);
            Assert(HandleToULong(_hbrOld));
        }
        else
        {
            SelectObject(_hdc, _hbrOld);
            _hbrOld =  NULL;
        }
        return TRUE;
    }

    operator HDC()
    {
        return _hdc;
    }

    HBITMAP GetBitmapAndKeep()
    {
        HBITMAP hbmp = _hbmp;

        // don't delet _hbmp;
        _hbmp = NULL;
        return hbmp;
    }
    HBITMAP GetBitmap()
    {
        return _hbmp;
    }

private:
    HBITMAP _hbmp;
    HBITMAP _hbmpOld;
    HBRUSH _hbrOld;
    HDC _hdc;
};

__inline HBITMAP StretchBitmap(HBITMAP hbmp, int cx, int cy)
{
    BITMAP bmp;
    CBitmapDC hdcSrc(TRUE);
    CBitmapDC hdcDst(TRUE);

    GetObject( hbmp, sizeof(bmp), &bmp );

    hdcSrc.SetBitmap(hbmp);
    hdcDst.SetCompatibleBitmap(cx, cy);
    StretchBlt(hdcDst, 0, 0, cx, cy, 
               hdcSrc, 0, 0, bmp.bmWidth, bmp.bmHeight, SRCCOPY);

    return hdcDst.GetBitmapAndKeep();
}

_inline UINT GetPhysicalFontHeight(LOGFONT &lf)
{
    HDC hdc = GetDC(NULL);
    HFONT hfont;
    UINT nRet = 0;

    if((hfont = CreateFontIndirect(&lf)))
    {
        TEXTMETRIC tm;
        HFONT hfontOld;
        hfontOld = (HFONT)SelectObject( hdc, hfont);

        GetTextMetrics(hdc, &tm);
        nRet = tm.tmHeight + tm.tmExternalLeading;

        if (hfontOld)
            SelectObject(hdc, hfontOld);

        DeleteObject(hfont);
    }
    ReleaseDC(NULL, hdc);

    return nRet;
}

#endif // CMYDC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\dispattr.h ===
//
// dispattr.h
//

#ifndef DISPATTR_H
#define DISPATTR_H

#include "strary.h"
#include "ctffunc.h"

typedef struct tagDISPATTRPROP {
    GUID guid;
} DISPATTRPROP;

class CDispAttrPropCache
{
public:
    CDispAttrPropCache() {}

    void Add(REFGUID rguid)
    {
        if (!FindGuid(rguid))
        {
            int i = Count();
            if (_rgDispAttrProp.Insert(i, 1))
            {
                DISPATTRPROP *pProp = _rgDispAttrProp.GetPtr(i);
                pProp->guid = rguid;
            }
        }
        
    }

    void Remove(REFGUID rguid)
    {
        int nCnt = _rgDispAttrProp.Count();
        int i;
        for (i = 0; i < nCnt; i++)
        {
            DISPATTRPROP *pProp = _rgDispAttrProp.GetPtr(i);
            if (IsEqualGUID(pProp->guid, rguid))
            {
                _rgDispAttrProp.Remove(i, 1);
                return;
            }
        }
    }

    BOOL FindGuid(REFGUID rguid)
    {
        int nCnt = _rgDispAttrProp.Count();
        int i;
        for (i = 0; i < nCnt; i++)
        {
            DISPATTRPROP *pProp = _rgDispAttrProp.GetPtr(i);
            if (IsEqualGUID(pProp->guid, rguid))
            {
                return TRUE;
            }
        }
        return FALSE;
    }

    int Count()
    {
        return _rgDispAttrProp.Count();
    }

    GUID *GetPropTable()
    {
        return (GUID *)_rgDispAttrProp.GetPtr(0);
    }

    CStructArray<DISPATTRPROP> _rgDispAttrProp;
};


ITfDisplayAttributeMgr *GetDAMLib(LIBTHREAD *plt);
HRESULT InitDisplayAttrbuteLib(LIBTHREAD *plt);
HRESULT UninitDisplayAttrbuteLib(LIBTHREAD *plt);
HRESULT GetDisplayAttributeTrackPropertyRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfReadOnlyProperty **ppProp, IEnumTfRanges **ppEnum, ULONG *pulNumProp);
HRESULT GetDisplayAttributeData(LIBTHREAD *plt, TfEditCookie ec, ITfReadOnlyProperty *pProp, ITfRange *pRange, TF_DISPLAYATTRIBUTE *pda, TfClientId *pguid, ULONG  ulNumProp);

HRESULT GetReconversionFromDisplayAttribute(LIBTHREAD *plt, TfEditCookie ec, ITfThreadMgr *ptim, ITfContext *pic, ITfRange *pRange, ITfFnReconversion **ppReconv, ITfDisplayAttributeMgr *pDAM);

HRESULT GetAttributeColor(TF_DA_COLOR *pdac, COLORREF *pcr);
HRESULT SetAttributeColor(TF_DA_COLOR *pdac, COLORREF cr);
HRESULT SetAttributeSysColor(TF_DA_COLOR *pdac, int nIndex);
HRESULT ClearAttributeColor(TF_DA_COLOR *pdac);

#endif // DISPATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\ccstock.h ===
//
// CCSHELL stock definition and declaration header
//


#ifndef __CCSTOCK_H__
#define __CCSTOCK_H__

#ifndef RC_INVOKED

// NT and Win95 environments set warnings differently.  This makes
// our project consistent across environments.

#pragma warning(3:4101)   // Unreferenced local variable

//
// Sugar-coating
//

#define PUBLIC
#define PRIVATE
#define IN
#define OUT
#define BLOCK

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

#ifndef DECLARE_STANDARD_TYPES_U

/*
 * For a type "FOO", define the standard derived UNALIGNED types PFOO, CFOO, and PCFOO.
 *  WINNT: RISC boxes care about ALIGNED, intel does not.
 */

#define DECLARE_STANDARD_TYPES_U(type)    typedef UNALIGNED type *P##type; \
                                          typedef UNALIGNED const type C##type; \
                                          typedef UNALIGNED const type *PC##type;

#endif

// For string constants that are always wide
#define __TEXTW(x)    L##x
#define TEXTW(x)      __TEXTW(x)

//
// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE

//
// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))

//
// String macros
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#define lstrnicmpA(sz1, sz2, cch)           StrCmpNIA(sz1, sz2, cch)
#define lstrnicmpW(sz1, sz2, cch)           StrCmpNIW(sz1, sz2, cch)
#define lstrncmpA(sz1, sz2, cch)            StrCmpNA(sz1, sz2, cch)
#define lstrncmpW(sz1, sz2, cch)            StrCmpNW(sz1, sz2, cch)

//
// lstrcatnA and lstrcatnW are #defined here to StrCatBuff which is implemented
// in shlwapi. We do this here (and not in shlwapi.h or shlwapip.h) in case the
// kernel guys ever decided to implement this.
//
#define lstrcatnA(sz1, sz2, cchBuffSize)    StrCatBuffA(sz1, sz2, cchBuffSize)
#define lstrcatnW(sz1, sz2, cchBuffSize)    StrCatBuffW(sz1, sz2, cchBuffSize)
#ifdef UNICODE
#define lstrcatn lstrcatnW
#else
#define lstrcatn lstrcatnA
#endif // UNICODE

#ifdef UNICODE
#define lstrnicmp       lstrnicmpW
#define lstrncmp        lstrncmpW
#else
#define lstrnicmp       lstrnicmpA
#define lstrncmp        lstrncmpA
#endif

#ifndef SIZEOF
#define SIZEOF(a)                   sizeof(a)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif
#define SIZECHARS(sz)               (sizeof(sz)/sizeof(sz[0]))

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))
#define IsInRange                   InRange

#define ZeroInit(pv, cb)            (memset((pv), 0, (cb)))

// ATOMICRELEASE
//
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#define ATOMICRELEASE(p) IUnknown_AtomicRelease((void **)&p)
#endif
#endif //ATOMICRELEASE

//
//  Helper macro for managing weak pointers to inner interfaces.
//  (It's the weak version of ATOMICRELEASE.)
//
//  The extra cast to (void **) is to keep C++ from doing strange
//  inheritance games when all I want to do is change the type.
//
#ifndef RELEASEINNERINTERFACE
#define RELEASEINNERINTERFACE(pOuter, p) \
        SHReleaseInnerInterface(pOuter, (IUnknown**)(void **)&(p))
#endif // RELEASEINNERINTERFACE

// For checking window charsets
#ifdef UNICODE
#define IsWindowTchar               IsWindowUnicode
#else  // !UNICODE
#define IsWindowTchar               !IsWindowUnicode
#endif // UNICODE

#ifdef DEBUG
// This macro is especially useful for cleaner looking code in
// declarations or for single lines.  For example, instead of:
//
//   {
//       DWORD dwRet;
//   #ifdef DEBUG
//       DWORD dwDebugOnlyVariable;
//   #endif
//
//       ....
//   }
//
// You can type:
//
//   {
//       DWORD dwRet;
//       DEBUG_CODE( DWORD dwDebugOnlyVariable; )
//
//       ....
//   }

#define DEBUG_CODE(x)               x
#else
#define DEBUG_CODE(x)

#endif  // DEBUG


//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


//
// Bitfields don't get along too well with bools,
// so here's an easy way to convert them:
//
#define BOOLIFY(expr)           (!!(expr))


// Issue (scotth): we should probably make this a 'bool', but be careful
// because the Alpha compiler might not recognize it yet.  Talk to AndyP.

// This isn't a BOOL because BOOL is signed and the compiler produces 
// sloppy code when testing for a single bit.

typedef DWORD   BITBOOL;


// STOCKLIB util functions

// IsOS(): returns TRUE/FALSE if the platform is the indicated OS.

#ifndef OS_WINDOWS
#define OS_WINDOWS      0           // windows vs. NT
#define OS_NT           1           // windows vs. NT
#define OS_WIN95        2           // Win95 or greater
#define OS_NT4          3           // NT4 or greater
#define OS_NT5          4           // NT5 or greater
#define OS_MEMPHIS      5           // Win98 or greater
#define OS_MEMPHIS_GOLD 6           // Win98 Gold
#endif

STDAPI_(BOOL) staticIsOS(DWORD dwOS);

#include <pshpack2.h>
typedef struct tagDLGTEMPLATEEX
{
    WORD    wDlgVer;
    WORD    wSignature;
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    WORD    cDlgItems;
    short   x;
    short   y;
    short   cx;
    short   cy;
}   DLGTEMPLATEEX, *LPDLGTEMPLATEEX;
#include <poppack.h>

//
// round macro that rounds a to the next multiple of b.
//
#ifndef ROUNDUP
#define ROUNDUP(a,b)    ((((a)+(b)-1)/(b))*(b))
#endif

#define ROUND_TO_CLUSTER ROUNDUP

//
// macro that sees if a give char is an number
//
#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

//
// inline that does PathIsDotOrDotDot
//
__inline BOOL PathIsDotOrDotDotW(LPCWSTR pszPath)
{
    return ((pszPath[0] == L'.') && 
            ((pszPath[1] == L'\0') || ((pszPath[1] == L'.') && (pszPath[2] == L'\0'))));
}

__inline BOOL PathIsDotOrDotDotA(LPCSTR pszPath)
{
    return ((pszPath[0] == '.') && 
            ((pszPath[1] == '\0') || ((pszPath[1] == '.') && (pszPath[2] == '\0'))));
}

#ifdef UNICODE
#define PathIsDotOrDotDot PathIsDotOrDotDotW
#else
#define PathIsDotOrDotDot PathIsDotOrDotDotA
#endif


//
//  WindowLong accessor macros and other Win64 niceness
//

__inline void * GetWindowPtr(HWND hWnd, int nIndex) {
    return (void *)GetWindowLongPtr(hWnd, nIndex);
}

__inline void * SetWindowPtr(HWND hWnd, int nIndex, void * p) {
    return (void *)SetWindowLongPtr(hWnd, nIndex, (LONG_PTR)p);
}

//***   GetWindowLong0 -- 'fast' GetWindowLong (and GetWindowLongPtr)
// DESCRIPTION
//  what's up w/ this?  it's all about perf.  GetWindowLong has 'A' and 'W'
//  versions.  however 99% of the time they do the same thing (the other
//  0.1% has to do w/ setting the WndProc and having to go thru a thunk).
//  but we still need wrappers for the general case.  but most of the time
//  we're just doing a GWL(0), e.g. on entry to a wndproc to get our private
//  data.  so by having a special version of that, we save going thru the
//  wrapper (which was costing us 1-3% of our profile).
// NOTES
//  note that we call the 'A' version since that's guaranteed to exist on
// all platforms.
__inline LONG GetWindowLong0(HWND hWnd) {
    return GetWindowLongA(hWnd, 0);
}
__inline LONG SetWindowLong0(HWND hWnd, LONG l) {
    return SetWindowLongA(hWnd, 0, l);
}
__inline void * GetWindowPtr0(HWND hWnd) {
    return (void *)GetWindowLongPtrA(hWnd, 0);
}
__inline void * SetWindowPtr0(HWND hWnd, void * p) {
    return (void *)SetWindowLongPtrA(hWnd, 0, (LONG_PTR)p);
}


#define IS_WM_CONTEXTMENU_KEYBOARD(lParam) ((DWORD)(lParam) == 0xFFFFFFFF)

//
//  CharUpperChar - Convert a single character to uppercase
//
__inline WCHAR CharUpperCharW(WCHAR c)
{
    return (WCHAR)(DWORD_PTR)CharUpperW((LPWSTR)(DWORD_PTR)(c));
}

__inline CHAR CharUpperCharA(CHAR c)
{
    return (CHAR)(DWORD_PTR)CharUpperA((LPSTR)(DWORD_PTR)(c));
}

#ifdef UNICODE
#define CharUpperChar       CharUpperCharW
#else
#define CharUpperChar       CharUpperCharA
#endif

//
//  ShrinkProcessWorkingSet - Use this to stay Sundown-happy.
//
#define ShrinkWorkingSet() \
        SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T) -1, (SIZE_T) -1)

//
//  COM Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHCoInitialize();
//      ... do COM stuff ...
//      SHCoUninitialize(hrInit);
//
//  Notice:  Continue doing COM stuff even if SHCoInitialize fails.
//  It might fail if somebody else already CoInit'd with different
//  flags, but we don't want to barf under those conditions.
//

STDAPI SHCoInitialize(void);
#define SHCoUninitialize(hr) if (SUCCEEDED(hr)) CoUninitialize()


//
//  OLE Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHOleInitialize(pMalloc);
//      ... do COM stuff ...
//      SHOleUninitialize(hrInit);
//

#define SHOleInitialize(pMalloc) OleInitialize(pMalloc)

#define SHOleUninitialize(hr)   if (SUCCEEDED(hr))  OleUninitialize()

//
//  MACRO HACK - Since not all clients of ccstock.h include shlobj.h first,
//  we need to use the long form of LP[C]ITEMIDLIST.  Since nobody remembers
//  this little quirk, to avoid future build breaks, redefine the symbols
//  to their long forms.
//
#define LPCITEMIDLIST const UNALIGNED struct _ITEMIDLIST *
#define  LPITEMIDLIST       UNALIGNED struct _ITEMIDLIST *

//
//  Name Parsing generic across the shell
//  
//  Usage:
// 
//      HRESULT SHGetNameAndFlags()
//          wrapper to bind to the folder and do a GetDisplayName()
//
STDAPI SHGetNameAndFlagsA(LPCITEMIDLIST pidl, DWORD dwFlags, LPSTR pszName, UINT cchName, DWORD *pdwAttribs);
STDAPI SHGetNameAndFlagsW(LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR pszName, UINT cchName, DWORD *pdwAttribs);
STDAPI SHGetNameAndFlags2A(struct IShellFolder *psfRoot, LPCITEMIDLIST pidl, DWORD dwFlags, LPSTR pszName, UINT cchName, DWORD *pdwAttribs);
STDAPI SHGetNameAndFlags2W(struct IShellFolder *psfRoot, LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR pszName, UINT cchName, DWORD *pdwAttribs);

//
//  Special values for SHGetNameAndFlags2::psfRoot
//
#define NAF2_SHELLDESKTOP   ((IShellFolder *)0)    // relative to shell desktop
#define NAF2_CURRENTROOT    ((IShellFolder *)-1)   // relative to current root

STDAPI SHBindToObject(struct IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut);
#define SHGetAttributesOf(pidl, prgfInOut) SHGetNameAndFlags(pidl, 0, NULL, 0, prgfInOut)

STDAPI_(DWORD) GetUrlSchemeW(LPCWSTR pszUrl);
STDAPI_(DWORD) GetUrlSchemeA(LPCSTR pszUrl);

#ifdef UNICODE
#define SHGetNameAndFlags       SHGetNameAndFlagsW
#define SHGetNameAndFlags2      SHGetNameAndFlags2W
#define GetUrlScheme            GetUrlSchemeW
#else
#define SHGetNameAndFlags       SHGetNameAndFlagsA
#define SHGetNameAndFlags2      SHGetNameAndFlags2A
#define GetUrlScheme            GetUrlSchemeA
#endif

// SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
//
// Given a pidl, you can get an interface pointer (as specified by riid) of the pidl's parent folder (in ppv)
// If ppidlLast is non-NULL, you can also get the pidl of the last item.
//
STDAPI SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);

//
// SHBindToFolderIDListParent
//
//  Same as SHBindToIDListParent, except you also specify which root to use.
//
STDAPI SHBindToFolderIDListParent(struct IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);

STDAPI_(void) SHRemoveURLTurd(LPTSTR pszUrl);

//  clones the parent of the pidl
STDAPI_(LPITEMIDLIST) ILCloneParent(LPCITEMIDLIST pidl);

//
//  END OF MACRO HACK
//
#undef LPITEMIDLIST
#undef LPCITEMIDLIST

//
// Mirroring-Support APIs (astracted in \shell\lib\stock5\rtlmir.cpp)
//
#ifdef __cplusplus
extern "C" {
#endif

extern BOOL g_bMirroredOS;

WORD  GetDefaultLang(BOOL bForceEnglish);
WORD  GetWindowLang (HWND hWndOwner);
BOOL  UseProperDlgTemplate(HINSTANCE hInst, HGLOBAL *phDlgTemplate, HRSRC *phResInfo, LPCSTR lpName, 
                           HWND hWndOwner, LPWORD lpwLangID, BOOL bForceEnglish);

#ifdef USE_MIRRORING

BOOL  IsBiDiLocalizedSystem( void );
BOOL  Mirror_IsEnabledOS( void );
LANGID Mirror_GetUserDefaultUILanguage( void );
BOOL  Mirror_IsWindowMirroredRTL( HWND hWnd );
DWORD Mirror_IsDCMirroredRTL( HDC hdc );
DWORD Mirror_MirrorDC( HDC hdc );
BOOL  Mirror_MirrorProcessRTL( void );
DWORD Mirror_GetLayout( HDC hdc );
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout );
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout );
BOOL Mirror_IsProcessRTL( void );
extern const DWORD dwNoMirrorBitmap;
extern const DWORD dwExStyleRTLMirrorWnd;
extern const DWORD dwExStyleNoInheritLayout;
extern const DWORD dwPreserveBitmap;
//
// 'g_bMirroredOS' is defined in each component which will use the
//  mirroring APIs. I decided to put it here, in order to make sure
//  each component has validated that the OS supports the mirroring
//  APIs before calling them.
//

#define IS_BIDI_LOCALIZED_SYSTEM()      IsBiDiLocalizedSystem()
#define IS_MIRRORING_ENABLED()          Mirror_IsEnabledOS()
#define IS_WINDOW_RTL_MIRRORED(hwnd)    (g_bMirroredOS && Mirror_IsWindowMirroredRTL(hwnd))
#define IS_DC_RTL_MIRRORED(hdc)         (g_bMirroredOS && Mirror_IsDCMirroredRTL(hdc))
#define GET_PROCESS_DEF_LAYOUT(pdwl)    (g_bMirroredOS && Mirror_GetProcessDefaultLayout(pdwl))
#define IS_PROCESS_RTL_MIRRORED()       (g_bMirroredOS && Mirror_IsProcessRTL())
#define SET_DC_RTL_MIRRORED(hdc)        Mirror_MirrorDC(hdc)
#define SET_DC_LAYOUT(hdc,dwl)          Mirror_SetLayout(hdc,dwl)
#define SET_PROCESS_RTL_LAYOUT()        Mirror_MirrorProcessRTL()
#define GET_DC_LAYOUT(hdc)              Mirror_GetLayout(hdc) 
#define DONTMIRRORBITMAP                dwNoMirrorBitmap
#define RTL_MIRRORED_WINDOW             dwExStyleRTLMirrorWnd
#define RTL_NOINHERITLAYOUT             dwExStyleNoInheritLayout
#define LAYOUT_PRESERVEBITMAP           dwPreserveBitmap

#else

#define IS_BIDI_LOCALIZED_SYSTEM()      FALSE
#define IS_MIRRORING_ENABLED()          FALSE
#define IS_WINDOW_RTL_MIRRORED(hwnd)    FALSE
#define IS_DC_RTL_MIRRORED(hdc)         FALSE
#define GET_PROCESS_DEF_LAYOUT(pdwl)    FALSE
#define IS_PROCESS_RTL_MIRRORED()       FALSE
#define SET_DC_RTL_MIRRORED(hdc)        
#define SET_DC_LAYOUT(hdc,dwl)
#define SET_PROCESS_DEFAULT_LAYOUT() 
#define GET_DC_LAYOUT(hdc)              0L

#define DONTMIRRORBITMAP                0L
#define RTL_MIRRORED_WINDOW             0L
#define LAYOUT_PRESERVEBITMAP           0L

#endif  // USE_MIRRROING

BOOL IsBiDiLocalizedWin95( BOOL bArabicOnly );


//
//====== Dynamic array functions  ================================================
//

//------------------------------------------------------------------------
// Dynamic key array
//
typedef struct _DKA * HDKA;     // hdka

HDKA   DKA_CreateA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszFirst, LPCSTR pszDefOrder, BOOL fDefault);
HDKA   DKA_CreateW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszFirst, LPCWSTR pszDefOrder, BOOL fDefault);

int    DKA_GetItemCount(HDKA hdka);

LPCSTR  DKA_GetKeyA(HDKA hdka, int iItem);
LPCWSTR DKA_GetKeyW(HDKA hdka, int iItem);

LONG   DKA_QueryValueA(HDKA hdka, int iItem, LPSTR szValue, LONG  * pcb);
LONG   DKA_QueryValueW(HDKA hdka, int iItem, LPWSTR szValue, LONG  * pcb);

DWORD  DKA_QueryOtherValueA(HDKA pdka, int iItem, LPCSTR pszName, LPSTR pszValue, LONG * pcb);
DWORD  DKA_QueryOtherValueW(HDKA pdka, int iItem, LPCWSTR pszName, LPWSTR pszValue, LONG * pcb);

void   DKA_Destroy(HDKA hdka);

#ifdef UNICODE
#define DKA_Create          DKA_CreateW
#define DKA_GetKey          DKA_GetKeyW
#define DKA_QueryValue      DKA_QueryValueW
#define DKA_QueryOtherValue DKA_QueryOtherValueW
#else
#define DKA_Create          DKA_CreateA
#define DKA_GetKey          DKA_GetKeyA
#define DKA_QueryValue      DKA_QueryValueA
#define DKA_QueryOtherValue DKA_QueryOtherValueA
#endif

//------------------------------------------------------------------------
// Dynamic class array
//
typedef struct _DCA * HDCA;     // hdca

HDCA DCA_Create();
void DCA_Destroy(HDCA hdca);
int  DCA_GetItemCount(HDCA hdca);
BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid);
const CLSID * DCA_GetItem(HDCA hdca, int i);

void DCA_AddItemsFromKeyA(HDCA hdca, HKEY hkey, LPCSTR pszSubKey);
void DCA_AddItemsFromKeyW(HDCA hdca, HKEY hkey, LPCWSTR pszSubKey);

#ifdef UNICODE
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyW
#else
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyA
#endif 

STDAPI DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, void ** ppv);


#ifdef __cplusplus
};
#endif

#endif // RC_INVOKED

//------------------------------------------------------------------------
// Random helpful functions
//------------------------------------------------------------------------
//
STDAPI_(BOOL) _SHIsButtonObscured(HWND hwnd, PRECT prc, INT_PTR i);
STDAPI_(void) _SHPrettyMenu(HMENU hm);
STDAPI_(BOOL) _SHIsMenuSeparator(HMENU hm, int i);
STDAPI_(BOOL) _SHIsMenuSeparator2(HMENU hm, int i, BOOL *pbIsNamed);
STDAPI_(BYTE) SHBtnStateFromRestriction(DWORD dwRest, BYTE fsState);
STDAPI_(BOOL) SHIsDisplayable(LPCWSTR pwszName, BOOL fRunOnFE, BOOL fRunOnNT5);

STDAPI_(void) EnableOKButtonFromString(HWND hDlg, LPTSTR pszText);
STDAPI_(void) EnableOKButtonFromID(HWND hDlg, int id);

//------------------------------------------------------------------------

////////////////
//
//  Critical section stuff
//
//  Helper macros that give nice debug support
//
EXTERN_C CRITICAL_SECTION g_csDll;
#ifdef DEBUG
EXTERN_C UINT g_CriticalSectionCount;
EXTERN_C DWORD g_CriticalSectionOwner;
EXTERN_C void Dll_EnterCriticalSection(CRITICAL_SECTION*);
EXTERN_C void Dll_LeaveCriticalSection(CRITICAL_SECTION*);
#if defined(__cplusplus) && defined(AssertMsg)
class DEBUGCRITICAL {
protected:
    BOOL fClosed;
public:
    DEBUGCRITICAL() {fClosed = FALSE;};
    void Leave() {fClosed = TRUE;};
    ~DEBUGCRITICAL() 
    {
        AssertMsg(fClosed, TEXT("you left scope while holding the critical section"));
    }
};
#define ENTERCRITICAL DEBUGCRITICAL debug_crit; Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL debug_crit.Leave(); Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#else // __cplusplus
#define ENTERCRITICAL Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#endif // __cplusplus
#define ASSERTCRITICAL ASSERT(g_CriticalSectionCount > 0 && GetCurrentThreadId() == g_CriticalSectionOwner)
#define ASSERTNONCRITICAL ASSERT(GetCurrentThreadId() != g_CriticalSectionOwner)
#else // DEBUG
#define ENTERCRITICAL EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT LeaveCriticalSection(&g_csDll)
#define ASSERTCRITICAL 
#define ASSERTNONCRITICAL
#endif // DEBUG

#endif // __CCSTOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\jpn\migrate\femgrate.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <userenv.h>
#include <userenvp.h>
#include <setupapi.h>
#include <regstr.h>
#include <shlwapi.h>

#define NO_FUNCTION 0xFF
#define DM_VERBOSE  2

#ifndef UNICODE
#define A2I atoi
#define STRSTR strstr
#else
#define A2I _wtoi
#define STRSTR wcsstr
#endif

enum FunctionType  {
    FUNC_PatchInLogon,
    FUNC_PatchInSetup,
    FUNC_PatchTest,
    FUNC_NumofFunctions
};

typedef struct _FUNC_DIR {
    char cFunc;
    int  nID;
} FUNC_DIR;

FUNC_DIR FuncDir[FUNC_NumofFunctions] = {
    {'l',FUNC_PatchInLogon},
    {'s',FUNC_PatchInSetup},
    {'t',FUNC_PatchTest},


};

HINSTANCE ghInst=NULL;
//
// Function Declaration
//
//#define MYDBG
#ifdef MYDBG
#define DebugMsg(_parameter) Print _parameter

#define DBGTITLE TEXT("FEMGRATE :")

void Print(UINT mask,LPCTSTR pszFormat,...)
{

    TCHAR szBuf[255];
    va_list arglist;

    va_start(arglist,pszFormat);

    wvsprintf(szBuf,pszFormat,arglist);

    OutputDebugString(DBGTITLE);

    OutputDebugString(szBuf);
    va_end(arglist);
}
#else
#define DebugMsg(_parameter)
#endif

BOOL
ConcatenatePaths(
    IN OUT LPTSTR  Target,
    IN     LPCTSTR Path,
    IN     UINT    TargetBufferSize
    )

{
    UINT TargetLength,PathLength;
    BOOL TrailingBackslash,LeadingBackslash;
    UINT EndingLength;

    TargetLength = lstrlen(Target);
    PathLength = lstrlen(Path);

    //
    // See whether the target has a trailing backslash.
    //
    if(TargetLength && (Target[TargetLength-1] == TEXT('\\'))) {
        TrailingBackslash = TRUE;
         TargetLength--;
     } else {
         TrailingBackslash = FALSE;
     }

     //
     // See whether the path has a leading backshash.
     //
     if(Path[0] == TEXT('\\')) {
         LeadingBackslash = TRUE;
         PathLength--;
     } else {
         LeadingBackslash = FALSE;
     }

     //
     // Calculate the ending length, which is equal to the sum of
     // the length of the two strings modulo leading/trailing
     // backslashes, plus one path separator, plus a nul.
     //
     EndingLength = TargetLength + PathLength + 2;

     if(!LeadingBackslash && (TargetLength < TargetBufferSize)) {
         Target[TargetLength++] = TEXT('\\');
     }

     if(TargetBufferSize > TargetLength) {
         lstrcpyn(Target+TargetLength,Path,TargetBufferSize-TargetLength);
     }

     //
     // Make sure the buffer is nul terminated in all cases.
     //
     if (TargetBufferSize) {
         Target[TargetBufferSize-1] = 0;
     }

     return(EndingLength <= TargetBufferSize);
 }

//
// Max size of a value's data
//

//
// Max number of Functions NO_FUNCTION - 1
//

UINT GetFunctions(
    int *pCmdList,
    int nNum)
{
    int i,j;
    int nMaxNum;
    int nCommands;

    if ((__argc <=1) || nNum < 2)
        return 0;

    //
    // reserved one cell for terminiator
    //
    nMaxNum =  (__argc-1 > nNum-1) ? nNum-1 : __argc-1;

    for (nCommands = 0,i=1; i <= nMaxNum; i++) {

        if (__argv[i][0] != '-') {
            continue;
        }

        for (j=0; j<FUNC_NumofFunctions ;  j++) {
            if (FuncDir[j].cFunc == __argv[i][1]) {
                pCmdList[nCommands++] = FuncDir[j].nID;
            }
        }
    }
    pCmdList[nCommands] = NO_FUNCTION;
    return nCommands;
}


LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

#define CCH_MAX_DEC 12         // Number of chars needed to hold 2^32

void IntToString( DWORD i, LPTSTR sz) {
    TCHAR szTemp[CCH_MAX_DEC];
    int iChr;


    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(i % 10);
        i = i / 10;
    } while (i != 0);

    do {
        iChr--;
        *sz++ = szTemp[iChr];
    } while (iChr != 0);

    *sz++ = TEXT('\0');
}

#define USER_SHELL_FOLDER         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")

BOOL GetProgramsDirectory (BOOL bCommonGroup, LPTSTR lpDirectory)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;
    TCHAR szDirectory[MAX_PATH];
    UINT uID;
    BOOL bRetVal = FALSE;


    //
    // Open the User Shell Folders in the registry
    //


    lResult = RegOpenKeyEx ((bCommonGroup ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER),
                            USER_SHELL_FOLDER, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        goto Exit;
    }


    //
    // Now query for the programs directory
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    szDirectory[0] = TEXT('\0');

    if (bCommonGroup) {

        lResult = RegQueryValueEx (hKey, TEXT("Common Programs"),
                                   NULL, &dwType, (LPBYTE) szDirectory, &dwSize);
    } else {

        lResult = RegQueryValueEx (hKey, TEXT("Programs"),
                                   NULL, &dwType, (LPBYTE) szDirectory, &dwSize);
    }


    RegCloseKey(hKey);


    if (lResult != ERROR_SUCCESS) {
        goto Exit;
    }


    //
    // Did we find anything?
    //

    if (szDirectory[0] == TEXT('\0')) {
        goto Exit;
    }


    //
    // Save the result
    //


    if (ExpandEnvironmentStrings(szDirectory, lpDirectory, MAX_PATH)) {
        bRetVal = TRUE;
    }


Exit:
    return bRetVal;

}


const TCHAR c_szDot[] = TEXT(".");
const TCHAR c_szDotDot[] = TEXT("..");
const TCHAR c_szStarDotStar[] =TEXT("*.*");

BOOL Delnode_Recurse (LPTSTR lpDir)
{
    WIN32_FIND_DATA fd;
    HANDLE hFile;

    //
    // Verbose output
    //

    //DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Entering, lpDir = <%s>\n"), lpDir));


    //
    // Setup the current working dir
    //

    if (!SetCurrentDirectory (lpDir)) {
        //DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse:  Failed to set current working directory.  Error = %d\n"), GetLastError()));
        return FALSE;
    }


    //
    // Find the first file
    //

    hFile = FindFirstFile(c_szStarDotStar, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        } else {
            //DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: FindFirstFile failed.  Error = %d\n"),
            //         GetLastError()));
            return FALSE;
        }
    }


    do {
        //
        //  Verbose output
        //

        //DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: FindFile found:  <%s>\n"),
        //         fd.cFileName));

        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(fd.cFileName, c_szDot)) {
            continue;
        }

        if (!lstrcmpi(fd.cFileName, c_szDotDot)) {
            continue;
        }


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Found a directory.
            //

            if (!Delnode_Recurse(fd.cFileName)) {
                FindClose(hFile);
                return FALSE;
            }

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                fd.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes (fd.cFileName, fd.dwFileAttributes);
            }


            if (!RemoveDirectory (fd.cFileName)) {
            //    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Failed to delete directory <%s>.  Error = %d\n"),
            //            fd.cFileName, GetLastError()));
            } else {
            //    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Successfully delete directory <%s>.\n"),
            //            fd.cFileName));
            }

        } else {

            //
            // We found a file.  Set the file attributes,
            // and try to delete it.
            //

            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
                SetFileAttributes (fd.cFileName, FILE_ATTRIBUTE_NORMAL);
            }

            if (!DeleteFile (fd.cFileName)) {
            //    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Failed to delete <%s>.  Error = %d\n"),
            //            fd.cFileName, GetLastError()));
            }
            else {
            //    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Successful delete <%s>.\n"),
            //            fd.cFileName));
            }

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


    //
    // Close the search handle
    //

    FindClose(hFile);


    //
    // Reset the working directory
    //

    if (!SetCurrentDirectory (c_szDotDot)) {
        DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse:  Failed to reset current working directory.  Error = %d\n"), GetLastError()));
        return FALSE;
    }


    //
    // Success.
    //

    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Leaving <%s>"), lpDir));

    return TRUE;
}


BOOL Delnode (LPTSTR lpDir)
{
    TCHAR szCurWorkingDir[MAX_PATH];

    if (GetCurrentDirectory(MAX_PATH, szCurWorkingDir)) {

        Delnode_Recurse (lpDir);

        SetCurrentDirectory (szCurWorkingDir);

        if (!RemoveDirectory (lpDir)) {
            DebugMsg((DM_VERBOSE, TEXT("Delnode: Failed to delete directory <%s>.  Error = %d\n"),
                    lpDir, GetLastError()));
            return FALSE;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("Delnode: RemoveDirectory OK <%s>.  retcode = %d\n"),
                    lpDir, GetLastError()));
        }


    } else {

        DebugMsg((DM_VERBOSE, TEXT("Delnode:  Failed to get current working directory.  Error = %d\n"), GetLastError()));
        return FALSE;
    }

    return TRUE;

}

LPCTSTR pSetupGetField(PINFCONTEXT Context,DWORD FieldIndex);

BOOL RenameFolder(
    BOOL bCommonGroup,
    LPCTSTR ObjSrcName,
    LPCTSTR ObjDstName)
{
    TCHAR szSrcPath[MAX_PATH];
    TCHAR szDstPath[MAX_PATH];
    LONG  lResult;
    BOOL  bRet=FALSE;

    DebugMsg((DM_VERBOSE,TEXT("[RenameFolder]\nOld = %s\nNew = %s\n"),ObjSrcName,ObjDstName));

    GetProgramsDirectory(bCommonGroup,szSrcPath);
    GetProgramsDirectory(bCommonGroup,szDstPath);

    ConcatenatePaths(szSrcPath,ObjSrcName,MAX_PATH);
    ConcatenatePaths(szDstPath,ObjDstName,MAX_PATH);

    lResult = GetFileAttributes(szSrcPath);

    if (lResult == 0xFFFFFFFF) {
        //
        // Directory does not exist.
        //
        DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] Directory is not existed [%s] !\n"),szSrcPath));
        goto err1;
    }

    if (!(lResult & FILE_ATTRIBUTE_DIRECTORY)) {
        //
        // this is not a directory.
        //
        DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] This is not a directory [%s] !\n"),szSrcPath));
        goto err1;
    }


    if (CopyProfileDirectory (szSrcPath, szDstPath, CPD_IGNOREHIVE)) {
        DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] Successfully changed folder name:\n%s\n%s"),szSrcPath,szDstPath));
        if (! DeleteGroup(ObjSrcName,bCommonGroup)) {
            DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] Delete old folder (%s) failed !"), ObjSrcName));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] Delete old folder (%s) successfully !"), ObjSrcName));
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("[RenameFolder] Convert Folder:  Failed to change group name with error %d\n.%s\n%s\n"), GetLastError(),szSrcPath,szDstPath));
        goto err1;
    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL RenameLink(
    BOOL bCommonGroup,
    LPCTSTR ObjSrcName,
    LPCTSTR ObjDstName,
    LPCTSTR ObjPath)
{
    TCHAR szSrcPath[MAX_PATH];
    TCHAR szDstPath[MAX_PATH];
    LONG  lResult;
    BOOL  bRet=FALSE;

    DebugMsg((DM_VERBOSE,TEXT("[RenameFolder] \nOld = %s\nNew = %s\nPath = %s\n"),ObjSrcName,ObjDstName,ObjPath));

    GetProgramsDirectory(bCommonGroup,szSrcPath);
    GetProgramsDirectory(bCommonGroup,szDstPath);

    if (ObjPath && *ObjPath) {
        ConcatenatePaths(szSrcPath,ObjPath,MAX_PATH);
        ConcatenatePaths(szDstPath,ObjPath,MAX_PATH);
    }

    ConcatenatePaths(szSrcPath,ObjSrcName,MAX_PATH);
    ConcatenatePaths(szDstPath,ObjDstName,MAX_PATH);

    lstrcat(szSrcPath,TEXT(".lnk"));
    lstrcat(szDstPath,TEXT(".lnk"));


    lResult = GetFileAttributes(szSrcPath);

    if (lResult == 0xFFFFFFFF) {
        //
        // Directory does not exist.
        //
        DebugMsg((DM_VERBOSE, TEXT("[RenameLink] File is not existed [%s] !\n"),szSrcPath));
        goto err1;
    }

    if (lResult & FILE_ATTRIBUTE_DIRECTORY) {
        //
        // this is a directory, but we want a file.
        //
        DebugMsg((DM_VERBOSE, TEXT("[RenameLink] This is a directory [%s] !\n"),szSrcPath));
        goto err1;
    }

    //
    // if destination file existed, it's not good !
    //
    lResult = GetFileAttributes(szDstPath);

    if (lResult == 0xFFFFFFFF) {

        if (MoveFile (szSrcPath, szDstPath)) {
            DebugMsg((DM_VERBOSE, TEXT("[RenameLink]  Successfully changed link name:\n%s\n%s\n"),szSrcPath,szDstPath));
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("[RenameLink]  Failed to change link name with error %d.\n%s\n%s\n"), GetLastError(),szSrcPath,szDstPath));
            goto err1;
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("[RenameLink]  Destination file existed, maybe we don't want to overwrite ,%s\n"),szDstPath));
        goto err1;
    }

    bRet = TRUE;

err1:
    return bRet;

}


BOOL RenameProgramFolderOrLink(HINF hInf,BOOL bCommon)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("StartMenu.ObjectToRename");
    LPCTSTR  ObjectType;
    LPCTSTR  ObjectSrcName;
    LPCTSTR  ObjectDstName;
    LPCTSTR  ObjectPath;
    LPCTSTR  GroupAttribute;
    BOOL    CommonGroup;
    BOOL    IsMenuItem;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if(SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
           && (ObjectType = pSetupGetField(&InfContext,1))
           && (ObjectSrcName = pSetupGetField(&InfContext,2))
           && (ObjectDstName = pSetupGetField(&InfContext,3))
           && (GroupAttribute = pSetupGetField(&InfContext,5))) {

            ObjectPath = pSetupGetField(&InfContext,4);

            IsMenuItem  = A2I(ObjectType);
            CommonGroup = A2I(GroupAttribute);


            if ((bCommon && (CommonGroup == 0)) ||
                 (!bCommon && (CommonGroup == 1))) {

//            DebugMsg((DM_VERBOSE,TEXT("Eject this line(%d) .....................................\n"),LineNo));
//            DebugMsg((DM_VERBOSE,TEXT("ObjectType    = %s\n"),ObjectType));
//            DebugMsg((DM_VERBOSE,TEXT("ObjectSrcName = %s\n"),ObjectSrcName));
//            DebugMsg((DM_VERBOSE,TEXT("ObjectDstName = %s\n"),ObjectDstName));
//            DebugMsg((DM_VERBOSE,TEXT("GroupAttribute= %s\n"),GroupAttribute));
//            DebugMsg((DM_VERBOSE,TEXT("bCommon = %d\n"),bCommon));
                continue;
            }

            if (IsMenuItem) {
//                DebugMsg((DM_VERBOSE,TEXT("RenameLink (%d).....................................\n"),LineNo));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectType    = %s\n"),ObjectType));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectSrcName = %s\n"),ObjectSrcName));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectDstName = %s\n"),ObjectDstName));
//                DebugMsg((DM_VERBOSE,TEXT("GroupAttribute= %s\n"),GroupAttribute));
//                DebugMsg((DM_VERBOSE,TEXT("bCommon = %d\n"),bCommon));

                RenameLink(bCommon,ObjectSrcName,ObjectDstName,ObjectPath);

            }
            else {
//                DebugMsg((DM_VERBOSE,TEXT("RenameFolder (%d) .....................................\n"),LineNo));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectType    = %s\n"),ObjectType));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectSrcName = %s\n"),ObjectSrcName));
//                DebugMsg((DM_VERBOSE,TEXT("ObjectDstName = %s\n"),ObjectDstName));
//                DebugMsg((DM_VERBOSE,TEXT("GroupAttribute= %s\n"),GroupAttribute));
//                DebugMsg((DM_VERBOSE,TEXT("bCommon = %d\n"),bCommon));
                RenameFolder(bCommon,ObjectSrcName,ObjectDstName);

            }

        }
    }

    bRet = TRUE;
err1:
    return bRet;

}

BOOL ReplaceString(
    LPCTSTR lpszOldStr,
    LPCTSTR lpszReplaceStr,
    LPCTSTR lpszReplacedWithStr,
    LPTSTR lpszOutputStr)
{
    LPTSTR pszAnchor = NULL;

    lstrcpy(lpszOutputStr,lpszOldStr);
    pszAnchor = STRSTR(lpszOutputStr,lpszReplaceStr);

    if (!pszAnchor) {
        return FALSE;
    }

    if (lstrcmp(pszAnchor,lpszReplaceStr) != 0) {
        return FALSE;
    }

    lstrcpy(pszAnchor,lpszReplacedWithStr);
    return TRUE;
}

BOOL FixUserFolders(HINF hInf)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("Folder.ObjectToRename");
    LPCTSTR  RegName;
    LPCTSTR  NT4Name;
    LPCTSTR  NT5Name;
    LPCTSTR  MoveIt;

    TCHAR   szUSFRegKey[MAX_PATH];
    TCHAR   szNT4USF[MAX_PATH];
    TCHAR   szExpNT4USF[MAX_PATH];
    TCHAR   szExpNT5USF[MAX_PATH];
    DWORD   dwSize, dwType;
    LONG    lResult;
    UINT    uiCount;
    HKEY    hKey;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] line count == 0 !\n")));
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (RegName = pSetupGetField(&InfContext,1))
             && (NT4Name = pSetupGetField(&InfContext,2))
             && (NT5Name = pSetupGetField(&InfContext,3))
             && (MoveIt  = pSetupGetField(&InfContext,4))) {

            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: RegName = %s !\n"),RegName));
            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: NT4Name = %s !\n"),NT4Name));
            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: NT5Name = %s !\n"),NT5Name));
            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: MoveIt  = %s !\n"),MoveIt));

            //
            // Query for the user's current "Folder" location.
            //
            DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] FixUserFolder, [%d] !\n"),LineNo));

            lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                                    USER_SHELL_FOLDER,
                                    0,
                                    KEY_READ | KEY_WRITE,
                                    &hKey);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] , Open User Shell Folders failed!\n")));
                continue;
            }

            lstrcpy(szUSFRegKey,RegName);

            dwSize = sizeof(szNT4USF);
            lResult = RegQueryValueEx (hKey,
                                       szUSFRegKey,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) szNT4USF,
                                       &dwSize);

            DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: Current Value (%s) = %s !\n"),szUSFRegKey,szNT4USF));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] Query User Shell Folders failed!\n")));
                RegCloseKey (hKey);
                continue;
            }


            if (lstrcmpi(NT4Name, szNT4USF) != 0) {
                DebugMsg((DM_VERBOSE, TEXT("[FixUserFolders] NT4Name <> szFolder :\n%s\n"),szExpNT4USF));
                RegCloseKey (hKey);
                continue;
            }
            //
            // MoveIt == 1, we want move it to new folder
            // else, we just update registry
            //
            if (lstrcmp(MoveIt,TEXT("1")) == 0) {

                ExpandEnvironmentStrings (NT4Name, szExpNT4USF, MAX_PATH);
                ExpandEnvironmentStrings (NT5Name, szExpNT5USF, MAX_PATH);


                if (CopyProfileDirectory (szExpNT4USF, szExpNT5USF, CPD_IGNOREHIVE)) {
                    DebugMsg((DM_VERBOSE, TEXT("Fix Folder:  Successfully changed folder name:\n%s\n%s"),szExpNT4USF,szExpNT5USF));
                    if (Delnode (szExpNT4USF)) {
                        DebugMsg((DM_VERBOSE, TEXT("[FixUserFolders] Successfully remove folder:\n%s\n"),szExpNT4USF));
                    }
                    else {
                        DebugMsg((DM_VERBOSE, TEXT("[FixUserFolders] Failed remove folder:\n%s\n"),szExpNT4USF));
                    }
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("[FixUserFolders] Failed to change folder name:\n%s\n%s"),szExpNT4USF,szExpNT5USF));
                }
            }

            //
            // Set CSIDL_PERSONAL to point to this directory.
            //

            lResult = RegSetValueEx (hKey, szUSFRegKey, 0, REG_EXPAND_SZ,
                                    (LPBYTE) NT5Name, (lstrlen(NT5Name) + 1) * sizeof(TCHAR));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE, TEXT("[FixUserFolders] Set Registry faile, %s,%s\n"),szUSFRegKey,NT5Name));
            }

            RegCloseKey (hKey);
        }

    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL FixSpecificFolder(HINF hInf)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("Folder.SpecificObjectToRename");
    LPCTSTR  RegName;
    LPCTSTR  NT4Name;
    LPCTSTR  NT5Name;
    LPCTSTR  MoveIt;

    TCHAR   szUSFRegKey[MAX_PATH];
    TCHAR   szNTUSF[MAX_PATH];
    TCHAR   szExpNT4USF[MAX_PATH];
    TCHAR   szExpNT5USF[MAX_PATH];
    DWORD   dwSize, dwType;
    LONG    lResult;
    UINT    uiCount;
    HKEY    hKey;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSpecificFolder] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSpecificFolder] line count == 0 !\n")));
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (RegName = pSetupGetField(&InfContext,1))
             && (NT4Name = pSetupGetField(&InfContext,2))
             && (NT5Name = pSetupGetField(&InfContext,3))) {

            DebugMsg((DM_VERBOSE,TEXT("FixSpecificFolder: RegName = %s !\n"),RegName));
            DebugMsg((DM_VERBOSE,TEXT("FixSpecificFolder: NT4Name = %s !\n"),NT4Name));
            DebugMsg((DM_VERBOSE,TEXT("FixSpecificFolder: NT5Name = %s !\n"),NT5Name));

            //
            // Query for the user's current "Folder" location.
            //
            DebugMsg((DM_VERBOSE,TEXT("[FixSpecificFolder] FixUserFolder, [%d] !\n"),LineNo));

            lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                                    USER_SHELL_FOLDER,
                                    0,
                                    KEY_READ,
                                    &hKey);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixSpecificFolder] , Open User Shell Folders failed!\n")));
                continue;
            }

            lstrcpy(szUSFRegKey,RegName);

            dwSize = sizeof(szNTUSF);
            lResult = RegQueryValueEx (hKey,
                                       szUSFRegKey,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) szNTUSF,
                                       &dwSize);

            DebugMsg((DM_VERBOSE,TEXT("FixSpecificFolder: Current Value (%s) = %s !\n"),szUSFRegKey,szNTUSF));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixUserFolders] Query User Shell Folders failed!\n")));
                RegCloseKey (hKey);
                continue;
            }


            ExpandEnvironmentStrings (szNTUSF, szExpNT4USF, MAX_PATH);
            ExpandEnvironmentStrings (szNTUSF, szExpNT5USF, MAX_PATH);

            ConcatenatePaths(szExpNT4USF,NT4Name,MAX_PATH);
            ConcatenatePaths(szExpNT5USF,NT5Name,MAX_PATH);


            lResult = GetFileAttributes(szExpNT4USF);

            if (lResult == 0xFFFFFFFF) {
                //
                // Directory does not exist.
                //
                DebugMsg((DM_VERBOSE, TEXT("[FixSpecificFolder] -  File is not existed [%s] !\n"),szExpNT4USF));
            } else if ((lResult & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY) {
               //
               // this isn't a directory
               //
               DebugMsg((DM_VERBOSE, TEXT("[FixSpecificFolder] This is a directory [%s] !\n"),szExpNT4USF));
            } else if (MoveFile(szExpNT4USF, szExpNT5USF)) {
               DebugMsg((DM_VERBOSE, TEXT("[FixSpecificFolder] Move %s to %s OK !\n"),szExpNT4USF, szExpNT5USF));
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("[FixSpecificFolder] Failed to change folder name:\n%s\n%s"),szExpNT4USF,szExpNT5USF));
            }

            RegCloseKey (hKey);
        }

    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL FixFoldersInSetup(HINF hInf,BOOL bCommonGroup)
{
    BOOL bRet = FALSE;

    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    LPCTSTR  szSectionName = TEXT("Folder.ObjectToRenameInSetup");

    LPCTSTR  RegName;
    LPCTSTR  NT4Name;
    LPCTSTR  NT5Name;

    TCHAR   szUSFRegKey[MAX_PATH];

    TCHAR   szNT5USF[MAX_PATH];
    TCHAR   szNT4USF[MAX_PATH];
    TCHAR   szExpNT4USF[MAX_PATH];
    TCHAR   szExpNT5USF[MAX_PATH];

    DWORD   dwSize, dwType;
    LONG    lResult;
    HKEY    hKey;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] line count == 0 !\n")));
        goto err1;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (RegName = pSetupGetField(&InfContext,1))
             && (NT4Name = pSetupGetField(&InfContext,2))
             && (NT5Name = pSetupGetField(&InfContext,3))) {

            DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] Line# [%d] !\n"),LineNo));
            DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] RegName = %s !\n"),RegName));
            DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] NT4Name = %s !\n"),NT4Name));
            DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] NT5Name = %s !\n"),NT5Name));

            //
            // Query for the user's current "Folder" location.
            //

            lResult = RegOpenKeyEx ((bCommonGroup ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER),
                                    USER_SHELL_FOLDER, 0, KEY_READ | KEY_WRITE, &hKey);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] FixSpecialFolder, Open User Shell Folders failed!\n")));
                continue;
            }


            if (bCommonGroup) {
                lstrcpy (szUSFRegKey,TEXT("Common "));
                lstrcat (szUSFRegKey,RegName);
            } else {
                lstrcpy (szUSFRegKey,RegName);
            }

            dwSize = sizeof(szNT5USF);
            lResult = RegQueryValueEx (hKey,
                                       szUSFRegKey,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) szNT5USF,
                                       &dwSize);

            DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] Current Registry Value (%s) = %s !\n"),szUSFRegKey,szNT5USF));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixFoldersInSetup] Query User Shell Folders failed!\n")));
                RegCloseKey(hKey);
                continue;
            }


            if (ReplaceString(szNT5USF,NT5Name,NT4Name,szNT4USF)) {
                ExpandEnvironmentStrings (szNT4USF, szExpNT4USF, MAX_PATH);
                ExpandEnvironmentStrings (szNT5USF, szExpNT5USF, MAX_PATH);
                DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] szExpNT4USF = %s\n"),szExpNT4USF));
                DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] szExpNT5USF = %s\n"),szExpNT5USF));
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] The replace string got error \n")));
                DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup]  %s\n %s\n %s\n%s\n"),szNT5USF,NT5Name,NT4Name,szNT4USF));
            }

            if (CopyProfileDirectory (szExpNT4USF, szExpNT5USF, CPD_IGNOREHIVE)) {
                DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] Successfully copied folder\nFrom:%s\nTo  :%s\n"),szExpNT4USF,szExpNT5USF));
                if (Delnode (szExpNT4USF)) {
                    DebugMsg((DM_VERBOSE, TEXT("[FixFoldersInSetup] Successfully removed folder:%s\n"),szExpNT4USF));
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("Fix Folder:  Failed remove folder:\n%s\n"),szExpNT4USF));
                }
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("Fix Folder:  Failed to change folder name:\n%s\n%s"),szExpNT4USF,szExpNT5USF));
            }

            RegCloseKey (hKey);

        }

    }

    bRet = TRUE;

err1:
    return bRet;

}

BOOL FixCommon(HINF hInf)
{

    TCHAR szCommon[MAX_PATH];
    TCHAR szProgramFolderPath[MAX_PATH];
    TCHAR szExpProgramFolderPath[MAX_PATH];

    BOOL bRet = FALSE;
    HANDLE hFile;

    DWORD RequiredSize;
    WIN32_FIND_DATA fd;
    UINT nCommon, nFileName;
    LPTSTR lpTag, lpEnd, lpEnd2;

    //
    //  Loop through all the program groups in the All Users profile
    //  and remove the " (Common)" tag.
    //
    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixCommon] Open femgrate.inf failed !\n")));
        return FALSE;
    }
    if (! SetupGetLineText(NULL,
                           hInf,
                           TEXT("Misc"),
                           TEXT("Common"),
                           szCommon,
                           sizeof(szCommon),
                           &RequiredSize)) {
        goto err1;
    }

    nCommon = lstrlen(szCommon);
    GetProgramsDirectory(TRUE,szProgramFolderPath);
    ExpandEnvironmentStrings (szProgramFolderPath, szExpProgramFolderPath, MAX_PATH);
    lstrcpy(szProgramFolderPath,szExpProgramFolderPath);

    //
    // From here, szProgramFolderPath used for Folder name without "Common"
    //
    lpEnd  = CheckSlash (szExpProgramFolderPath);
    lpEnd2 = CheckSlash (szProgramFolderPath);

    lstrcpy (lpEnd, c_szStarDotStar);

    hFile = FindFirstFile (szExpProgramFolderPath, &fd);
    DebugMsg((DM_VERBOSE, TEXT("[FixCommon] Find %s\n"),szExpProgramFolderPath));

    if (hFile != INVALID_HANDLE_VALUE) {

        do  {

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                nFileName = lstrlen (fd.cFileName);
                DebugMsg((DM_VERBOSE, TEXT("Find %s\n"),fd.cFileName));

                if (nFileName > nCommon) {
                    lpTag = fd.cFileName + nFileName - nCommon;

                    DebugMsg((DM_VERBOSE, TEXT("[FixCommon] lpTag=%s szCommon=%s\n"),lpTag, szCommon));
                    if (!lstrcmpi(lpTag, szCommon)) {

                        lstrcpy (lpEnd, fd.cFileName);
                        *lpTag = TEXT('\0');
                        lstrcpy (lpEnd2, fd.cFileName);

                        if (CopyProfileDirectory (szExpProgramFolderPath, szProgramFolderPath, CPD_IGNOREHIVE)) {

                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :  Successfully changed group name:\n")));
                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :      Orginial:  %s\n"), szExpProgramFolderPath));
                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :      New:       %s\n"), szProgramFolderPath));
                            if (Delnode (szExpProgramFolderPath)) {
                                DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :  Successfully remove folder:\n%s\n"),szExpProgramFolderPath));
                            }
                            else {
                                DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :  Failed remove folder:\n%s\n"),szExpProgramFolderPath));
                            }


                        } else {
                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :  Failed to change group name with error %d.\n"), GetLastError()));
                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :      Orginial:  %s\n"), szExpProgramFolderPath));
                            DebugMsg((DM_VERBOSE, TEXT("[FixCommon] :      New:       %s\n"), szProgramFolderPath));
                        }
                    }
                }
            }

        } while (FindNextFile(hFile, &fd));

        FindClose (hFile);
    }

    bRet = TRUE;
err1:

    return bRet;

}


BOOL FixAppearanceScheme(HINF hInf)
{
    HKEY hAppearanceKey,hSchemeKey;
    LONG lResult;
    LPCTSTR szSectionName = TEXT("Apperance Scheme");
    TCHAR szCurrentScheme[MAX_PATH];
    LPCTSTR NT4SchemeName;
    LPCTSTR NT5SchemeName;
    LONG LineCount,LineNo;
    DWORD dwSize,dwType;
    INFCONTEXT InfContext;

    BOOL bRet = FALSE;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Open femgrate.inf failed !\n")));
        goto Err0;
    }

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            REGSTR_PATH_APPEARANCE,
                            0,
                            KEY_ALL_ACCESS,
                            &hAppearanceKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Open REGSTR_PATH_APPEARANCE failed !\n")));
        goto Err0;
    }

    //
    // Now query for the programs directory
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    szCurrentScheme[0] = TEXT('\0');


    lResult = RegQueryValueEx (hAppearanceKey,
                               TEXT("Current"),
                               NULL,
                               &dwType,
                               (LPBYTE) szCurrentScheme,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        //
        // this case is fine
        //
        szCurrentScheme[0] = TEXT('\0');
    }


    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            REGSTR_PATH_LOOKSCHEMES,
                            0,
                            KEY_ALL_ACCESS,
                            &hSchemeKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Open REGSTR_PATH_APPEARANCE failed !\n")));
        goto Err1;
    }


    LineCount = (UINT)SetupGetLineCount(hInf,szSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] line count == 0 !\n")));
        goto Err2;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,szSectionName,LineNo,&InfContext)
             && (NT4SchemeName = pSetupGetField(&InfContext,1))) {

            if (szCurrentScheme[0] != '\0') {
                if (lstrcmp(szCurrentScheme,NT4SchemeName) == 0) {
                    if (NT5SchemeName = pSetupGetField(&InfContext,2)) {
                        lResult = RegSetValueEx(hAppearanceKey,
                                                TEXT("Current"),
                                                0,
                                                REG_SZ,
                                                (LPBYTE) NT5SchemeName,
                                                (lstrlen(NT5SchemeName)+1)*sizeof(TCHAR));
                        if (lResult != ERROR_SUCCESS) {
                            DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Set Appearance current scheme fail ! \n")));
                        }

                    }
                    else {
                        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] NT5's scheme missed!\n")));
                    }
                }

            }
            lResult = RegDeleteValue(hSchemeKey,
                                     NT4SchemeName);
            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Delete scheme %s failed !\n"),NT4SchemeName));
            }
        }
    }

    bRet = TRUE;

Err2:
    RegCloseKey(hSchemeKey);
Err1:
    RegCloseKey(hAppearanceKey);
Err0:
    return bRet;

}

BOOL DoInstallationFromSection(HINF hInf,LPCTSTR lpszSectionName)
{
    HSPFILEQ FileQueue;
    PVOID QContext;
    BOOL bRet=FALSE;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] Open femgrate.inf failed !\n")));
        goto Err0;
    }

    if ((FileQueue = SetupOpenFileQueue()) == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] SetupOpenFileQueue failed !\n")));
        goto Err0;
    }

    bRet = SetupInstallFilesFromInfSection(hInf,
                                           NULL,
                                           FileQueue,
                                           lpszSectionName,
                                           NULL,
                                           SP_COPY_NEWER );
    if (!bRet) {
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] SetupInstallFilesFromInfSection failed !\n")));
        goto Err1;
    }

    if (!(QContext = SetupInitDefaultQueueCallback(NULL))) {
        bRet = FALSE;
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] SetupInitDefaultQueueCallback failed !\n")));
        goto Err1;
    }


    bRet = SetupCommitFileQueue(NULL,
                                FileQueue,
                                SetupDefaultQueueCallback,
                                QContext );
    if (!bRet) {
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] SetupCommitFileQueue failed !\n")));
        goto Err1;
    }

    bRet = SetupInstallFromInfSection( NULL,
                                       hInf,
                                       lpszSectionName,
                                       SPINST_ALL & ~SPINST_FILES,
                                       NULL,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL );
    if (!bRet) {
        DebugMsg((DM_VERBOSE,TEXT("[DoInstallationFromSection] SetupInstallFromInfSection failed !\n")));
        goto Err1;
    }

    bRet = TRUE;
Err1:
    SetupTermDefaultQueueCallback(QContext);
    SetupCloseFileQueue(FileQueue);
Err0:
    return bRet;

}


TCHAR szBuf[300];

BOOL SoundMapSBtoDBKana(HINF hInf,LPCTSTR lpszSectionName,LPTSTR lpszSoundName)
{
    LPCTSTR szSBKana,szDBKana;

    LONG LineCount,LineNo;
    DWORD dwSize,dwType;
    INFCONTEXT InfContext;


    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[IsInSoundSBKanaList] Open femgrate.inf failed !\n")));
        return FALSE;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,lpszSectionName);

    if((LONG)LineCount <= 0) {
        DebugMsg((DM_VERBOSE,TEXT("[SoundMapSBtoDBKana] line count == 0 !\n")));
        return FALSE;
    }

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if (SetupGetLineByIndex(hInf,lpszSectionName,LineNo,&InfContext)
             && (szSBKana = pSetupGetField(&InfContext,1))) {

            if (lstrcmpi(szSBKana,lpszSoundName) == 0) {
                if (szDBKana = pSetupGetField(&InfContext,2)) {
                    lstrcpy(lpszSoundName,szDBKana);
                    return TRUE;
                }
                else {
                    //
                    // inf error, no second data
                    //
                    return FALSE;
                }
            }

        }
    }
    return FALSE;
}

BOOL SoundDoAppsNameSubstitution(HINF hInf,LPTSTR lpszOrgSoundName)
{
    TCHAR szMediaDir[] = TEXT("%SystemRoot%\\Media\\");
    TCHAR szExpMediaDir[MAX_PATH];
    LPTSTR lpszAnchor;
    TCHAR szOnlySoundName[MAX_PATH];

    if (StrStrI(lpszOrgSoundName,TEXT("\\"))) {
        if (ExpandEnvironmentStrings(szMediaDir,szExpMediaDir,MAX_PATH) == 0) {
            return FALSE;
        }

        lpszAnchor = StrStrI(lpszOrgSoundName,szExpMediaDir);
        if ((lpszAnchor == NULL ) || (lpszAnchor != lpszOrgSoundName)) {
            return FALSE;
        }

        lstrcpy(szOnlySoundName,lpszAnchor+lstrlen(szExpMediaDir));
        DebugMsg((DM_VERBOSE,TEXT("We want to find %s !\n"),szOnlySoundName));

        if (SoundMapSBtoDBKana(hInf,TEXT("Sound.Files"),szOnlySoundName)) {
            lstrcpy(lpszAnchor+lstrlen(szExpMediaDir),szOnlySoundName);
            return TRUE;
        }
    }
    else {
        if (SoundMapSBtoDBKana(hInf,TEXT("Sound.Files"),lpszOrgSoundName)) {
            return TRUE;
        }

    }
    return FALSE;

}

BOOL EnumSoundSchemeApps(HKEY hKey,HINF hInf)
{
    HKEY hSubKey;
    DWORD dwIndex;
    DWORD dwKeyNameSize;
    TCHAR szKeyName[MAX_PATH];
    DWORD dwSoundValue;
    TCHAR szSoundValue[MAX_PATH];
    LONG lResult;

    dwKeyNameSize = sizeof(szKeyName);
    for (dwIndex = 0;
         RegEnumKey(hKey, dwIndex, szKeyName, dwKeyNameSize) == ERROR_SUCCESS;
         dwIndex++) {
         lResult = RegOpenKey(hKey,
                              szKeyName,
                              &hSubKey);
         if (lResult == ERROR_SUCCESS) {
             EnumSoundSchemeApps(hSubKey,hInf);
             RegCloseKey(hSubKey);
         }
    }

    //
    // no sub-key, then just get the value
    //

    if (dwIndex == 0) {
        dwSoundValue = sizeof(szSoundValue);
        lResult = RegQueryValue(hKey,
                                NULL,
                                szSoundValue,
                                &dwSoundValue);

        if (lResult == ERROR_SUCCESS) {
            if (szSoundValue[0]) {
                if (SoundDoAppsNameSubstitution(hInf,szSoundValue)) {
                    RegSetValue(hKey,
                                NULL,
                                REG_SZ,
                                szSoundValue,
                                (lstrlen(szSoundValue)+1)*sizeof(TCHAR));
                }
            }
        }
    }
    return TRUE;
}


BOOL FixSoundRegValue(HINF hInf)
{
    LONG lResult;
    BOOL bRet=FALSE;
    HKEY hKey;

    if(hInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSoundRegValue] Open femgrate.inf failed !\n")));
        goto Err0;
    }

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            REGSTR_PATH_APPS,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE,TEXT("[FixAppearanceScheme] Open REGSTR_PATH_APPEARANCE failed !\n")));
        goto Err0;
    }

    EnumSoundSchemeApps(hKey,hInf);

    if (! DoInstallationFromSection(hInf, TEXT("Sound.Reg.Update"))) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSoundRegValue]  DoInstallationFromSection failed !\n")));
        goto Err1;
    }

    bRet = TRUE;
Err1:
    RegCloseKey(hKey);
Err0:
    return bRet;
}

BOOL FixSoundFiles(HINF hInf)
{
    if (! DoInstallationFromSection(hInf, TEXT("Sound.Files.Delete"))) {
        DebugMsg((DM_VERBOSE,TEXT("[FixSoundFiles]  DeleteSBKanaSoundFiles failed !\n")));
    }

    return TRUE;
}

BOOL IsInSetupUpgradeMode()

{
   LPCTSTR szKeyName = TEXT("SYSTEM\\Setup");
   DWORD dwType, dwSize;
   HKEY hKeySetup;
   DWORD dwSystemSetupInProgress,dwUpgradeInProcess;
   LONG lResult;

   if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKeyName, 0,
                     KEY_READ, &hKeySetup) == ERROR_SUCCESS) {

       dwSize = sizeof(DWORD);
       lResult = RegQueryValueEx (hKeySetup, TEXT("SystemSetupInProgress"), NULL,
                                  &dwType, (LPBYTE) &dwSystemSetupInProgress, &dwSize);
       if (lResult == ERROR_SUCCESS) {
           lResult = RegQueryValueEx (hKeySetup, TEXT("UpgradeInProgress"), NULL,
                                      &dwType, (LPBYTE) &dwUpgradeInProcess, &dwSize);
           if (lResult == ERROR_SUCCESS) {
               DebugMsg((DM_VERBOSE,TEXT("[IsInSetupUpgradeMode] dwSystemSetupInProgress =%, dwUpgradeInProcess=%d !\n"),dwSystemSetupInProgress,dwUpgradeInProcess));

               if ((dwSystemSetupInProgress != 0) && (dwUpgradeInProcess != 0)) {
                   return TRUE;
               }
           }
           else {
              DebugMsg((DM_VERBOSE,TEXT("[IsInSetupUpgradeMode] RegQueryValueEx UpgradeInProcess failed !\n")));

           }

       }
       else {
          DebugMsg((DM_VERBOSE,TEXT("[IsInSetupUpgradeMode] RegQueryValueEx SystemSetupInProgress failed !\n")));
       }
       RegCloseKey (hKeySetup);
   }
   else {
      DebugMsg((DM_VERBOSE,TEXT("[IsInSetupUpgradeMode] RegOpenKeyEx failed !\n")));

   }
   return FALSE ;
}


int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    int Cmds[FUNC_NumofFunctions + 1];
    int i;
    HINF hMigrateInf;

    DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: Start Executing....\n")));

    ghInst = hInstance;
    if (GetFunctions(Cmds,FUNC_NumofFunctions+1) == 0) {
        DebugMsg((DM_VERBOSE,TEXT("FEGRPCV: There are no valid commands. \n")));
        return (1);
    }

    //
    // Open INF file first !
    //
    hMigrateInf = SetupOpenInfFile(
                      TEXT("femgrate.inf"),
                      NULL,
                      INF_STYLE_WIN4,
                      NULL);

    if(hMigrateInf == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE,TEXT("[FixCommon] Open femgrate.inf failed !\n")));
        return 0;
    }

    for (i=0; Cmds[i] != NO_FUNCTION && i < FUNC_NumofFunctions+1; i++) {

        switch(Cmds[i]) {
        case FUNC_PatchInSetup:

            if (IsInSetupUpgradeMode() == FALSE) {
                DebugMsg((DM_VERBOSE,TEXT("This is NOT upgrade \n")));
                break;
            }

            DebugMsg((DM_VERBOSE,TEXT("..................This is upgrade \n")));

            if (FixFoldersInSetup(hMigrateInf,TRUE)) {
                if (FixCommon(hMigrateInf)) {
                    if (RenameProgramFolderOrLink(hMigrateInf,TRUE)) {
                        DebugMsg((DM_VERBOSE,TEXT("All Users, RenameProgramFolderOrLink() ok ! \n")));
                    }
                    else {
                        DebugMsg((DM_VERBOSE,TEXT("All Users, RenameProgramFolderOrLink() failed ! \n")));
                    }
                }
                else {
                    DebugMsg((DM_VERBOSE,TEXT("All Users, FixCommon() failed ! \n")));
                }
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("All Users, FixFoldersInSetup() failed ! \n")));
            }

            if (FixFoldersInSetup(hMigrateInf,FALSE)) {
                if (RenameProgramFolderOrLink(hMigrateInf,FALSE)) {
                    DebugMsg((DM_VERBOSE,TEXT("Default User, RenameProgramFolderOrLink() ok ! \n")));
                }
                else {
                    DebugMsg((DM_VERBOSE,TEXT("Default User, RenameProgramFolderOrLink() failed ! \n")));
                }
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("Default User, FixFoldersInSetup() failed ! \n")));
            }

            if (FixSoundFiles(hMigrateInf) && FixSoundRegValue(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("Fix Sound Settings OK ! \n")));
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("Fix Sound Settings failed ! \n")));
            }

            if (FixSoundRegValue(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSoundRegValue OK ! \n")));

            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixSoundRegValue failed ! \n")));
            }
            break;

        case FUNC_PatchInLogon:
            if (FixUserFolders(hMigrateInf)) {
                if (RenameProgramFolderOrLink(hMigrateInf,FALSE)) {
                    DebugMsg((DM_VERBOSE,TEXT("Current User, RenameProgramFolderOrLink() ok ! \n")));
                }
                else {
                    DebugMsg((DM_VERBOSE,TEXT("Current User, RenameProgramFolderOrLink() failed ! \n")));
                }
            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("Current User, FixFoldersInSetup() failed ! \n")));
            }
            if (FixSpecificFolder(hMigrateInf)) {
               DebugMsg((DM_VERBOSE,TEXT("Current User, FixSpecificFolder() ok ! \n")));
            } else {
                DebugMsg((DM_VERBOSE,TEXT("Current User, FixSpecificFolder() failed ! \n")));
            }

            if (FixSoundRegValue(hMigrateInf)) {
                DebugMsg((DM_VERBOSE,TEXT("FixSoundRegValue OK ! \n")));

            }
            else {
                DebugMsg((DM_VERBOSE,TEXT("FixSoundRegValue failed ! \n")));
            }
            break;

        case FUNC_PatchTest:
//                if (FixUserFolders()) {
//                    if (RenameProgramFolderOrLink(hMigrateInf,FALSE)) {
//                    }
//                    else {
//                        DebugMsg((DM_VERBOSE,TEXT("Current User, RenameProgramFolderOrLink() failed ! \n")));
//                    }
//                }
//                else {
//                    DebugMsg((DM_VERBOSE,TEXT("Current User, FixFoldersInSetup() failed ! \n")));
//                }
//                FixAppearanceScheme(hMigrateInf);
//                FixSoundFiles(hMigrateInf);
//                FixSoundRegValue(hMigrateInf);
//                FixSpecificFolder(hMigrateInf);
                break;

            default:
                DebugMsg((DM_VERBOSE,TEXT("No such function\n")));
        }

    }

    SetupCloseInfFile(hMigrateInf);
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\fnprbase.h ===
//
// funcprv.h
//

#ifndef FNPRBASE_H
#define FNPRBASE_H

#include "private.h"

class __declspec(novtable) CFunctionProviderBase : public ITfFunctionProvider
{
public:
    CFunctionProviderBase(TfClientId tid);
    virtual ~CFunctionProviderBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunctionProvider
    //
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDescription(BSTR *pbstrDesc);
    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

    BOOL Init(REFGUID guidType, WCHAR *pszDesc);
    HRESULT _Advise(ITfThreadMgr *ptim);
    HRESULT _Unadvise(ITfThreadMgr *ptim);

private:
    TfClientId _tid;
    GUID _guidType;
    BSTR _bstrDesc;
    long _cRef;
};

#endif // FNPRBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\cuilib.h ===
//
// cuilib.h
//

#ifndef CUILIB_H
#define CUILIB_H

#include "cuiobj.h"
#include "cuiwnd.h"
#include "cuitb.h"
#include "cuimenu.h"
#include "cuitip.h"
#include "cuibln.h"
#include "cuisys.h"
#include "cuischem.h"
#include "cuiutil.h"

extern void InitUIFLib( void );
extern void DoneUIFLib( void );

#endif /* CUILIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\common.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Korean IME 2000 common include file by cslim
#   Copyright (C) Microsoft Corporation 2000
#   All Rights Reserved.
#
##########################################################################

#
# Common include file 'sources' files in the Korean IME 2K project.
#
#
# These definitions are required in your sources file:
#
#     FREEBUILD
#        Set by makefile.def file for you.  One of the following:
#          0      - build debug
#          1      - build retail
#
#
# Definitions used if defined:
#
#
# Environment Variables and their meanings
#
#     USE_LEGO
#        Define lego macros
#

#
# Set private paths
#
INCLUDES        = \
    ..;\
    $(WINDOWS_INC_PATH); \
    $(SDK_INC_PATH);     \
    $(BASE_INC_PATH);    \
    $(INCLUDES)

# Use objd folder for chk build.
CHECKED_ALT_DIR       = 1

IME_DIR               = $(PROJECT_ROOT)\feime\kor\Ime2K
INCLUDES              = $(IME_DIR)\inc;           \
                        $(INCLUDES)

# Bug 523350: We should build separate binary for downlevel OS
# Do this to assure that we run on NT 4.0 and Win95, even with
# NT5/Memphis headers.
#!if !defined(WIN32_WINNT_VERSION)
#WIN32_WINNT_VERSION=0x0400
#!endif
#!if !defined(WIN32_WIN95_VERSION)
#WIN32_WIN95_VERSION=0x0400
#!endif
#!if !defined(WIN32_IE_VERSION)
#WIN32_IE_VERSION=0x0501
#!endif
#
# Override NT5 settings
#SUBSYSTEM_VERSION=4.00

# Defining this allows windows.h to include other headers
# NOT_LEAN_AND_MEAN= 1

# Don't link to NTDLL if this runs on both platforms
NO_NTDLL=1

#
# Lego options
#
!if defined(USE_LEGO)
NTBBT           = 1
NTPROFILEINPUT  = 1
!endif

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) -DPRODUCT_PROF
!endif


# ------ Debug Only Defines --------
!IF "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DDEBUG -D_DEBUG
LINKER_NOICF      = 1           # ICF is s-l-o-w
!ENDIF
# ------ End Debug Only Defines --------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\dbgid.h ===
//
// dbgid.h
//
// debug macros
//

#ifndef DBGID_H
#define DBGID_H

#ifdef __cplusplus // "C" files can't handle "inline"

#include "ciccs.h"

extern CCicCriticalSectionStatic g_cs;

//extern "C" BOOL Dbg_MemSetNameID(void *pv, const TCHAR *pszName, DWORD dwID);

#ifdef DEBUG

#define DBG_ID_DECLARE                  \
    static DWORD _s_Dbg_dwID;           \
    DWORD _Dbg_dwID;

#define DBG_ID_INSTANCE(_class_)        \
    DWORD _class_::_s_Dbg_dwID = 0;

#define Dbg_MemSetThisNameID(pszName)   \
    EnterCriticalSection(g_cs);        \
    _Dbg_dwID = ++_s_Dbg_dwID;          \
    LeaveCriticalSection(g_cs);        \
    Dbg_MemSetNameID(this, pszName, _Dbg_dwID)

#define Dbg_MemSetThisNameIDCounter(pszName, iCounter)   \
    EnterCriticalSection(g_cs);        \
    _Dbg_dwID = ++_s_Dbg_dwID;          \
    LeaveCriticalSection(g_cs);        \
    Dbg_MemSetNameIDCounter(this, pszName, _Dbg_dwID, iCounter)

#else

#define DBG_ID_DECLARE
#define DBG_ID_INSTANCE(_class_)
#define Dbg_MemSetNameIDCounter(pv, pszName, dwID, iCounter)
#define Dbg_MemSetThisNameIDCounter(pszName, iCounter)
#define Dbg_MemSetThisNameID(pszName)

#endif // DEBUG

#endif // __cplusplus // "C" files can't handle "inline"

#endif // DBGID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\iconlib.h ===
//
// iconlib.h
//

#ifndef ICONLIB_H
#define ICONLIB_H

BOOL GetIconSize( HICON hIcon, SIZE *psize );
BOOL GetIconBitmaps(HICON hIcon, HBITMAP *phbmp, HBITMAP *phbmpMask, SIZE *psize);
int GetMenuIconHeight(int *pnMenuFontHeghti);

#endif // ICONLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\dap.h ===
//+---------------------------------------------------------------------------
//
//  File:       imx.h
//
//  Contents:   CIMX
//
//----------------------------------------------------------------------------

#ifndef DAP_H
#define DAP_H

#include "private.h"

class CDisplayAttributeInfo;

//+---------------------------------------------------------------------------
//
// CDisplayAttributeProvider
//
//----------------------------------------------------------------------------

class __declspec(novtable) CDisplayAttributeProvider : public ITfDisplayAttributeProvider
{
public:
    CDisplayAttributeProvider();
    virtual ~CDisplayAttributeProvider();

    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj) = 0;
    virtual STDMETHODIMP_(ULONG) AddRef(void)  = 0;
    virtual STDMETHODIMP_(ULONG) Release(void)  = 0;

    STDMETHODIMP EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum);
    STDMETHODIMP GetDisplayAttributeInfo(REFGUID guid, ITfDisplayAttributeInfo **ppInfo);

    CDisplayAttributeInfo *_pList;

    static WCHAR szProviderName[80];

protected:
    void Add(GUID guid, WCHAR *pszDesc, TF_DISPLAYATTRIBUTE *pda);
};

//+---------------------------------------------------------------------------
//
// CDisplayAttributeInfo
//
//----------------------------------------------------------------------------

class CDisplayAttributeInfo : public ITfDisplayAttributeInfo
{
public:
    CDisplayAttributeInfo(GUID guid, WCHAR *pszDesc, TF_DISPLAYATTRIBUTE *pda);
    ~CDisplayAttributeInfo();

    //
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP GetGUID(GUID *pguid);
    STDMETHODIMP GetDescription(BSTR *pbstr);

    STDMETHODIMP GetAttributeInfo(TF_DISPLAYATTRIBUTE *pda);
    STDMETHODIMP SetAttributeInfo(const TF_DISPLAYATTRIBUTE *pda);
    STDMETHODIMP Reset();

    CDisplayAttributeInfo *_pNext;

    HRESULT _SaveAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid, TF_DISPLAYATTRIBUTE *pda);
    HRESULT _OpenAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid, TF_DISPLAYATTRIBUTE *pda);
    HRESULT _DeleteAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid);

    GUID _guid;
    WCHAR _szDesc[MAX_PATH];
    TF_DISPLAYATTRIBUTE _da;
    TF_DISPLAYATTRIBUTE _daDefault;
    int _cRef;
};

//+---------------------------------------------------------------------------
//
// CEnumDisplayAttributeInfo
//
//----------------------------------------------------------------------------

class CEnumDisplayAttributeInfo : public IEnumTfDisplayAttributeInfo
{
public:
    CEnumDisplayAttributeInfo(CDisplayAttributeProvider *pProvider);
    ~CEnumDisplayAttributeInfo();

    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    //
    // IEnumTfDisplayAttributeInfo
    //
    STDMETHODIMP Clone(IEnumTfDisplayAttributeInfo **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfDisplayAttributeInfo **ppInfo, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    CDisplayAttributeInfo *_pCur;
    int _cRef;
    CDisplayAttributeProvider *_pProvider;
};


#endif // DAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\editcb.h ===
//
// editcb.h
//
// CEditSession
//

#ifndef EDITCB_H
#define EDITCB_H

#include "private.h"

class CEditSession;

typedef HRESULT (*ESCALLBACK)(TfEditCookie ec, CEditSession *);

class CEditSession : public ITfEditSession
{
public:
    CEditSession(ESCALLBACK pfnCallback);
    virtual ~CEditSession() {};

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfEditCallback
    //
    STDMETHODIMP DoEditSession(TfEditCookie ec);

    // data for use by owner
    struct
    {
        void *pv;
        UINT_PTR u;
        HWND hwnd;
        WPARAM wParam;
        LPARAM lParam;
        void *pv1;
        void *pv2;
        ITfContext *pic; // Issue: use pv1, pv2
        ITfRange *pRange; // Issue: use pv1, pv2
        BOOL fBool;
    } _state;

private:
    ESCALLBACK _pfnCallback;
    int _cRef;
};

#endif // EDIT_CB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\debug.h ===
//====== Assertion/Debug output APIs =================================

#include <platform.h> // for __endexcept

#if defined(DECLARE_DEBUG) && defined(DEBUG)

//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// For string constants that are always wide
#define __TEXTW(x)    L##x
#define TEXTW(x)      __TEXTW(x)

// (These are deliberately CHAR)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

#if 0
EXTERN_C const WCHAR FAR c_wszTrace[]      = L"trc " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszErrorDbg[]   = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszWarningDbg[] = L"wrn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszGeneralDbg[] = L"gen " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszFuncDbg[]    = L"fnc " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszMemLeakDbg[] = L"mem " TEXTW(SZ_MODULE) L"  ";
#else
EXTERN_C const WCHAR FAR c_wszTrace[]      = TEXTW(SZ_MODULE) L"-[Trc] ";
EXTERN_C const WCHAR FAR c_wszErrorDbg[]   = TEXTW(SZ_MODULE) L"-[Err] ";
EXTERN_C const WCHAR FAR c_wszWarningDbg[] = TEXTW(SZ_MODULE) L"-[Wrn] ";
EXTERN_C const WCHAR FAR c_wszGeneralDbg[] = TEXTW(SZ_MODULE) L"-[Gen] ";
EXTERN_C const WCHAR FAR c_wszFuncDbg[]    = TEXTW(SZ_MODULE) L"-[Fnc] ";
EXTERN_C const WCHAR FAR c_wszMemLeakDbg[] = TEXTW(SZ_MODULE) L"-[Mem] ";
#endif
EXTERN_C const WCHAR FAR c_wszAssertMsg[]    = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR FAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";
EXTERN_C const WCHAR FAR c_wszRip[]     = TEXTW(SZ_MODULE) L"  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR FAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
#if 0
EXTERN_C const CHAR  FAR c_szTrace[]      = "trc " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szErrorDbg[]   = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szWarningDbg[] = "wrn " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szGeneralDbg[] = "gen " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szFuncDbg[]    = "fnc " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szMemLeakDbg[] = "mem " SZ_MODULE "  ";
#else
EXTERN_C const CHAR  FAR c_szTrace[]      = SZ_MODULE "-[Trc] ";
EXTERN_C const CHAR  FAR c_szErrorDbg[]   = SZ_MODULE "-[Err] ";
EXTERN_C const CHAR  FAR c_szWarningDbg[] = SZ_MODULE "-[Wrn] ";
EXTERN_C const CHAR  FAR c_szGeneralDbg[] = SZ_MODULE "-[Gen] ";
EXTERN_C const CHAR  FAR c_szFuncDbg[]    = SZ_MODULE "-[Fnc] ";
EXTERN_C const CHAR  FAR c_szMemLeakDbg[] = SZ_MODULE "-[Mem] ";
#endif
EXTERN_C const CHAR  FAR c_szAssertMsg[]    = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  FAR c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRip[] = SZ_MODULE     "  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

// Undefine the macros that we define in case some other header
// might have tried defining these commonly-named macros.
#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef ASSERT
#undef EVAL
#undef ASSERTMSG            // catch people's typos
#undef DBEXEC

#ifdef _ATL_NO_DEBUG_CRT
#undef _ASSERTE             // we substitute this ATL macro
#endif

// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_dwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern DWORD g_dwTraceFlags;
#ifdef DEBUG
extern DWORD g_dwPrototype;
#else
#define g_dwPrototype   0
#endif
extern DWORD g_dwFuncTraceFlags;

#if defined(DEBUG) || defined(PRODUCT_PROF)
BOOL CcshellGetDebugFlags(void);
#else
#define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
#define BF_ASSERT           0x00000001      // Break on assertions
#define BF_ONAPIENTER       0x00000002      // Break on entering an API
#define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
#define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING
#define BF_THR              0x00000100      // Break when THR() receives a failure
#define BF_RIP              0x00000200      // Break on RIPs
#define BF_ASSERTPOPUP      0x00000400      // Break on RIPs

// Trace flags for g_dwTraceFlags
#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
#define TF_ATL              0x00000008      // Since TF_FUNC is so-little used, I'm overloading this bit
#define TF_EVENT            0x00000010
#define TF_MEMORY_LEAK      0x00000020
// (Upper 28 bits reserved for custom use per-module)

// Old, archaic debug flags.  
// Issue (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg


#ifndef NOSHELLDEBUG    // Others have own versions of these.

#ifdef DEBUG

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK        do { _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} __endexcept } while (0)
#endif

BOOL AttachDebugger(DWORD pid);

// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

void CDECL CcshellFuncMsgW(DWORD mask, LPCSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(DWORD mask, LPCSTR pszMsg, ...);

void CDECL _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
void CDECL _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);

void _AssertStrLenA(LPCSTR pszStr, int iLen);
void _AssertStrLenW(LPCWSTR pwzStr, int iLen);

#ifdef UNICODE
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
#define _AssertStrLen           _AssertStrLenW
#else
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
#define _AssertStrLen           _AssertStrLenA
#endif

#endif // DEBUG



// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//
//   Use ASSERT() to check for logic invariance.  These are typically considered
//   fatal problems, and falls into the 'this should never ever happen' 
//   category.
//
//   Do *not* use ASSERT() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

BOOL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreakInside, BOOL bAssertPopup);
BOOL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreakInside, BOOL bAssertPopup);
#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#endif

#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE, TRUE)) \
            DEBUG_BREAK;       \
    }

#define ASSERTPRIVATE(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE, FALSE)) \
            DEBUG_BREAK;       \
    }

// The old Win95 code used to use "Assert()".  We discourage the use
// of this macro now because it is not msdev-friendly.
#ifdef DISALLOW_Assert
#define Assert(f)           Dont_use_Assert___Use_ASSERT
#define AssertPrivate(f)    Dont_use_AssertPrivate___Use_ASSERT
#else
#define Assert(f)           ASSERT(f)
#define AssertPrivate(f)    ASSERTPRIVATE(f)
#endif

#else  // DEBUG

#define ASSERT(f)
#define ASSERTPRIVATE(f)
#define Assert(f)
#define AssertPrivate(f)

#endif // DEBUG



// ASSERTMSG(f, szFmt, args...)
//
//   Behaves like ASSERT, except it prints the wsprintf-formatted message
//   instead of the file and line number.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

void CDECL CcshellAssertMsgW(BOOL bAssert, LPCSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR pszMsg, ...);
#ifdef UNICODE
#define CcshellAssertMsg        CcshellAssertMsgW
#else
#define CcshellAssertMsg        CcshellAssertMsgA
#endif

#define ASSERTMSG           CcshellAssertMsg

#else  // DEBUG

#define ASSERTMSG       1 ? (void)0 : (void)

#endif // DEBUG



// EVAL(f)
//
//   Behaves like ASSERT().  Evaluates the expression (f).  The expression 
//   is always evaluated, even in retail builds.  But the macro only asserts 
//   in the debug build.  This macro may be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
//   Do *not* use EVAL() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(TEXT(__FILE__), __LINE__, TEXT(#exp), TRUE, FALSE), 0))

#else  // DEBUG

#define EVAL(exp)       ((exp) != 0)

#endif // DEBUG



// RIP(f)
// 
//   Generates a "RIP at file.c, line x (eval)" message if f is NOT true.
//   
//   Use RIP() to perform parameter validation, especially when you
//   know the function or method may be called by a 3rd party app.
//   Typically, RIPs are used to indicate the caller passed in an invalid 
//   parameter, so the problem is really not in the code itself.
//
//   Do *not* use RIP() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   RIP performs a debugbreak only in the following processes:
//
//      explore.exe
//      iexplore.exe
//      rundll32.exe
//      welcome.exe
//
//   In any other process, this just spews the debug message, but doesn't stop.
//   
//   Setting the BF_RIP bit in g_dwBreakFlags will cause the macro to perform 
//   a DebugBreak() even in non-shell processes.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew (other processes), spew and break (shell processes)
//      Full debug builds:  spew (other processes), spew and break (shell processes)
//
#ifdef DEBUG

BOOL CcshellRipA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellRipW(LPCWSTR pszFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
#ifdef UNICODE
#define CcshellRip      CcshellRipW
#else
#define CcshellRip      CcshellRipA
#endif

#define RIP(f)                                                                                              \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#f), FALSE))                                          \
        {                                                                                                   \
            DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \

#define RIPMSG(f, msg)                                                                                      \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#msg), FALSE))                                        \
        {                                                                                                   \
            DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \


#else  // DEBUG

#define RIP(f)
#define RIPMSG(f, msg)

#endif // DEBUG



// TraceMsg(dwMask, sz, args...) 
//
//   Generate wsprintf-formatted message using the specified trace dwMask.
//   dwMask may be one of the predefined bits:
//
//      TF_ERROR    - display "err <MODULE>  <string>"
//      TF_WARNING  - display "wn  <MODULE>  <string>"
//      TF_GENERAL  - display "t   <MODULE>  <string>"
//      TF_ALWAYS   - display "t   <MODULE>  <string>" regardless of g_dwTraceFlags.
//
//   or it may be a custom bit (any of the upper 28 bits).
//
//   The g_dwTraceFlags global governs whether the message is displayed (based
//   upon the dwMask parameter).
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   In addition to squirting the trace message, you may optionally cause
//   the trace message to stop if you need to trace down the source of
//   an error.  The BF_ONERRORMSG and BF_ONWARNMSG bits may be set in
//   g_dwBreakFlags to make TraceMsg stop when a TF_ERROR or TF_WARNING
//   message is displayed.  But typically these bits are disabled.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       only TF_ALWAYS and TF_ERROR messages spew
//      Full debug builds:  spew
//
#ifdef DEBUG

void CDECL CcshellDebugMsgW(DWORD mask, LPCSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(DWORD mask, LPCSTR pszMsg, ...);
void CDECL _DebugMsgA(DWORD flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(DWORD flag, LPCWSTR psz, ...);
#ifdef UNICODE
#define CcshellDebugMsg         CcshellDebugMsgW
#define _DebugMsg               _DebugMsgW
#else
#define CcshellDebugMsg         CcshellDebugMsgA
#define _DebugMsg               _DebugMsgA
#endif

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#ifdef DISALLOW_DebugMsg
#define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
#define DebugMsg            _DebugMsg
#endif

#else  // DEBUG

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#define TraceMsg        1 ? (void)0 : (void)
#define DebugMsg        1 ? (void)0 : (void)

#endif // DEBUG



// THR(pfn)
// TBOOL(pfn)
// TINT(pfn)
// TPTR(pfn)
// TW32(pfn)
// 
//   These macros are useful to trace failed calls to functions that return
//   HRESULTs, BOOLs, ints, or pointers.  An example use of this is:
//
//   {
//       ...
//       hres = THR(CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, 
//                                   IID_IBar, (LPVOID*)&pbar));
//       if (SUCCEEDED(hres))
//       ...
//   }
//
//   If CoCreateInstance failed, you would see spew similar to:
//
//    err MODULE  THR: Failure of "CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, IID_IBar, (LPVOID*)&pbar)" at foo.cpp, line 100  (0x80004005)
//
//   THR keys off of the failure code of the hresult.
//   TBOOL considers FALSE to be a failure case.
//   TINT considers -1 to be a failure case.
//   TPTR considers NULL to be a failure case.
//   TW32 keys off the failure code of the Win32 error code.
//
//   Set the BF_THR bit in g_dwBreakFlags to stop when these macros see a failure.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       nothing
//      Full debug builds:  spew on error
//
#ifdef DEBUG

EXTERN_C HRESULT TraceHR(HRESULT hrTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C BOOL    TraceBool(BOOL bTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C int     TraceInt(int iTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C LPVOID  TracePtr(LPVOID pvTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C DWORD   TraceWin32(DWORD dwTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);

#define THR(x)      (TraceHR((x), #x, __FILE__, __LINE__))
#define TBOOL(x)    (TraceBool((x), #x, __FILE__, __LINE__))
#define TINT(x)     (TraceInt((x), #x, __FILE__, __LINE__))
#define TPTR(x)     (TracePtr((x), #x, __FILE__, __LINE__))
#define TW32(x)     (TraceWin32((x), #x, __FILE__, __LINE__))

#else  // DEBUG

#define THR(x)          (x)
#define TBOOL(x)        (x)
#define TINT(x)         (x)
#define TPTR(x)         (x)
#define TW32(x)         (x)

#endif // DEBUG



// DBEXEC(flg, expr)
//
//   under DEBUG, does "if (flg) expr;" (w/ the usual safe syntax)
//   under !DEBUG, does nothing (and does not evaluate either of its args)
//
#ifdef DEBUG

#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)

#else  // DEBUG

#define DBEXEC(flg, expr)   /*NOTHING*/

#endif // DEBUG


// string and buffer whacking functions
//
#ifdef DEBUG

EXTERN_C void DEBUGWhackPathBufferA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringW(LPWSTR psz, UINT cch);

#ifdef UNICODE
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferW
#define DEBUGWhackPathString DEBUGWhackPathStringW
#else
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferA
#define DEBUGWhackPathString DEBUGWhackPathStringA
#endif

#else // DEBUG

#define DEBUGWhackPathBuffer(psz, cch)
#define DEBUGWhackPathString(psz, cch)

#endif // DEBUG


// Some trickery to map ATL debug macros to ours, so ATL code that stops
// or spews in our code will look like the rest of our squirties.

#ifdef DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)         ASSERT(f)

// We map ATLTRACE macros to our functions
void _cdecl ShellAtlTraceA(LPCSTR lpszFormat, ...);
void _cdecl ShellAtlTraceW(LPCWSTR lpszFormat, ...);
#ifdef UNICODE
#define ShellAtlTrace   ShellAtlTraceW
#else
#define ShellAtlTrace   ShellAtlTraceA
#endif
#define ATLTRACE            ShellAtlTrace
#endif

#else  // DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)

// We map ATLTRACE macros to our functions
#define ATLTRACE            1 ? (void)0 : (void)
#endif

#endif // DEBUG


// ------ Stay away from these macros below ----------
// Issue (scotth):  remove these by 8/15/98.  They should not be used anymore. 
#ifdef DEBUG

#define AssertE(f)          ASSERT(f)
#define AssertMsg           _AssertMsg
#define AssertStrLen        _AssertStrLen
#define AssertStrLenA       _AssertStrLenA
#define AssertStrLenW       _AssertStrLenW

#ifdef FULL_DEBUG
#define FullDebugMsg        _DebugMsg
#else
#define FullDebugMsg        1 ? (void)0 : (void)
#endif

#define ASSERT_MSGW         CcshellAssertMsgW
#define ASSERT_MSGA         CcshellAssertMsgA
#define ASSERT_MSG          CcshellAssertMsg
#else  // DEBUG

#define AssertE(f)      (f)
#define AssertMsg       1 ? (void)0 : (void)
#define AssertStrLen(lpStr, iLen)
#define FullDebugMsg    1 ? (void)0 : (void)
#define ASSERT_MSGA     1 ? (void)0 : (void)
#define ASSERT_MSGW     1 ? (void)0 : (void)
#define ASSERT_MSG      1 ? (void)0 : (void)

#endif // DEBUG
// ------ Stay away from these macros above ----------



// It's necessary to find when classes that were designed to be single threaded are used
// across threads so they can be fixed to be multithreaded.  These asserts will point
// out such cases.
#ifdef DEBUG
#define ASSERT_SINGLE_THREADED              AssertMsg(_dwThreadIDForSingleThreadedAssert == GetCurrentThreadId(), TEXT("MULTI-THREADED BUG: This class is being used by more than one thread, but it's not thread safe."))
#define INIT_SINGLE_THREADED_ASSERT         _dwThreadIDForSingleThreadedAssert = GetCurrentThreadId();
#define SINGLE_THREADED_MEMBER_VARIABLE     DWORD _dwThreadIDForSingleThreadedAssert;
#else // DEBUG
#define ASSERT_SINGLE_THREADED              NULL;
#define INIT_SINGLE_THREADED_ASSERT         NULL;
#define SINGLE_THREADED_MEMBER_VARIABLE     
#endif // DEBUG



#ifdef DEBUG

#define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#ifdef UNICODE
#define Dbg_SafeStr         Dbg_SafeStrW
#else
#define Dbg_SafeStr         Dbg_SafeStrA
#endif

#define FUNC_MSG            CcshellFuncMsg


// Helpful macro for mapping manifest constants to strings.  Assumes
// return string is pcsz.  You can use this macro in this fashion:
//
// LPCSTR Dbg_GetFoo(FOO foo)
// {
//    LPCTSTR pcsz = TEXT("Unknown <foo>");
//    switch (foo)
//    {
//    STRING_CASE(FOOVALUE1);
//    STRING_CASE(FOOVALUE2);
//    ...
//    }
//    return pcsz;
// }
//
#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
#define DBG_ENTER(flagFTF, fn)                  \
        (FUNC_MSG(flagFTF, " > " #fn "()"), \
         CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
         CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
        (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
         CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
#define DBG_EXIT(flagFTF, fn)                              \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(flagFTF, fn, n)                       \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#ifdef _WIN64
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#016I64x", (ULONG_PTR)(ul)))
#else
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))
#endif // _WIN64

#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DEBUG


#define Dbg_SafeStr     1 ? (void)0 : (void)

#define FUNC_MSG        1 ? (void)0 : (void)


#define DBG_ENTER(flagFTF, fn)
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
#define DBG_ENTER_SZ(flagFTF, fn, sz)
#define DBG_EXIT(flagFTF, fn)
#define DBG_EXIT_INT(flagFTF, fn, n)
#define DBG_EXIT_BOOL(flagFTF, fn, b)
#define DBG_EXIT_UL(flagFTF, fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
#define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DEBUG



// COMPILETIME_ASSERT(f)
//
//  Generates a build break at compile time if the constant expression
//  is not true.  Unlike the "#if" compile-time directive, the expression
//  in COMPILETIME_ASSERT() is allowed to use "sizeof".
//
//  Compiler magic!  If the expression "f" is FALSE, then you get the
//  compiler error "Duplicate case expression in switch statement".
//
#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:


#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

#define Dbg_GetCFName(ucf)          (void)0
#define Dbg_GetHRESULTName(hr)      (void)0
#define Dbg_GetREFIIDName(riid)     (void)0
#define Dbg_GetVTName(vt)           (void)0

#endif // DEBUG

// I'm a lazy typist...
#define Dbg_GetHRESULT              Dbg_GetHRESULTName

// Parameter validation macros
#include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling
int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
void __stdcall MarkCAP(long lMark);  // write mark to MEA
extern DWORD g_dwProfileCAP;
#else
#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0
#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0
#define MarkCAP(n)      0

#define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\helpers.h ===
//
// helpers.h
//

#ifndef HELPERS_H
#define HELPERS_H


#ifdef __cplusplus

//
// generic COM stuff
//

#define SafeRelease(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}                   

#define SafeReleaseClear(punk)  \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        (punk) = NULL;          \
    }                           \
}                   

// COM identity compare
inline BOOL IdentityCompare(IUnknown *p1, IUnknown *p2)
{
    IUnknown *punk1 = NULL;
    IUnknown *punk2 = NULL;
    BOOL fRet = FALSE;

    if (p1->QueryInterface(IID_IUnknown, (void **)&punk1) != S_OK)
        goto Exit;

    if (p2->QueryInterface(IID_IUnknown, (void **)&punk2) != S_OK)
        goto Exit;

    fRet = (punk1 == punk2);

Exit:
    SafeRelease(punk1);
    SafeRelease(punk2);
    return fRet;
}

// inline VariantInit
inline void QuickVariantInit(VARIANT *pvar)
{
    pvar->vt = VT_EMPTY;
}

#endif // __cplusplus

// convert a boolean to S_OK or S_FALSE
#define HRBOOL(e) ( (e) ? S_OK : S_FALSE )

#endif // HELPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "private.h"
#include "immxutil.h"

extern CRITICAL_SECTION g_csIMLib;

//extern HINSTANCE g_hMlang;
extern HRESULT (*g_pfnGetGlobalFontLinkObject)(IMLangFontLink **);
extern BOOL g_bComplexPlatform;
extern UINT g_uiACP;

class CDispAttrPropCache;
extern CDispAttrPropCache *g_pPropCache;

extern PFNCOCREATE g_pfnCoCreate;

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\immxutil.h ===
//
// immxutil.h
//


#ifndef TFMXUTIL_H
#define TFMXUTIL_H

typedef struct tag_LIBTHREAD
{
    ITfCategoryMgr *_pcat;
    ITfDisplayAttributeMgr *_pDAM;
} LIBTHREAD;

BOOL TFInitLib(void);
void TFUninitLib(void);

//
// TFUninitThread should not be called in DllMain(THREAD_DETACH).
// Because this calls COM.
//
void TFUninitLib_Thread(LIBTHREAD *plt);

DWORD AsciiToNum( char *pszAscii);
BOOL AsciiToNumDec(char *pszAscii, DWORD *pdw);
DWORD WToNum( WCHAR *psz);
void NumToW(DWORD dw, WCHAR *psz);
void NumToA(DWORD dw, char *psz);
BOOL GetTopIC(ITfDocumentMgr *pdim, ITfContext **ppic);
int CompareGUIDs(REFGUID guid1, REFGUID guid2);
BOOL IsDisabledTextServices(void);
BOOL NoTipsInstalled(BOOL *pfOnlyTranslationRunning);
BOOL RunningOnWow64();
HKL GetSystemDefaultHKL();
BOOL IsDisabledCUAS();
void SetDisableCUAS(BOOL bDisableCUAS);
void RebootTheSystem();
BOOL IsAdminPrivilege();
BOOL IsInteractiveUserLogon();
BOOL FullPathExec( LPCSTR pszAppName, LPCSTR pszCmdLine, WORD wShowWindow, BOOL fWinDir);
BOOL RunCPLSetting(LPTSTR pCmdLine);

#define CR_ERROR        0xffffffff
#define CR_EQUAL        0x00000000
#define CR_RIGHTMEET    0x00000001
#define CR_RIGHT        0x00010001
#define CR_LEFTMEET     0x00000002
#define CR_LEFT         0x00010002
#define CR_PARTIAL      0x00000003
#define CR_INCLUSION    0x00000004

inline ITfContextView *GetActiveView(ITfDocumentMgr *dim)
{
    ITfContext *pic;
    ITfContextView *pView = NULL;

    if (dim->GetTop(&pic) == S_OK)
    {
        pic->GetActiveView(&pView);
        pic->Release();
    }

    return pView;
}

BOOL IsActiveView(ITfContext *pic, ITfContextView *pView);

HRESULT GetTextExtInActiveView(TfEditCookie ec, ITfRange *pRange, RECT *prc, BOOL *pfClipped);

int CompareRanges(TfEditCookie ec, ITfRange *pRangeSrc, ITfRange *pRangeCmp);

LONG AdjustAnchor(LONG ichAdjStart, LONG ichAdjEnd, LONG cchNew, LONG ichAnchor, BOOL fGravityRight);

#ifdef __cplusplus // "C" files can't handle "inline"

inline LONG CompareAnchors(IAnchor *pa1, IAnchor *pa2)
{
    LONG l;

    return FAILED(pa1->Compare(pa2, &l)) ? 0 : l;
}

inline BOOL IsEqualAnchor(IAnchor *pa1, IAnchor *pa2)
{
    BOOL fEqual;

    if (pa1->IsEqual(pa2, &fEqual) != S_OK)
    {
        Assert(0);
        // arbitrary: failure == not equal
        fEqual = FALSE;
    }

    return fEqual;
}

BOOL ShiftToOrClone(IAnchor **ppaDst, IAnchor *paSrc);

inline HRESULT GetService(IUnknown *punkProvider, REFIID refiid, IUnknown **ppunk)
{
    return punkProvider->QueryInterface(refiid, (void **)ppunk);
}

//
// GetSelectionSimple
//
// wrapper for GetSelection that throws out all style info, and ignores disjoint selections
//
inline HRESULT GetSelectionSimple(TfEditCookie ec, ITfContext *pic, ITfRange **ppSel)
{
    TF_SELECTION sel;
    ULONG cFetched;
    HRESULT hr;

    Assert(pic != NULL);
    Assert(ppSel != NULL);

    hr = pic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &sel, &cFetched);

    Assert(hr != S_OK || sel.range != NULL);

    *ppSel = NULL;
    if (hr == S_OK && cFetched > 0)
    {
        *ppSel = sel.range; // caller must Release
    }

    return hr;
}

//
// SetSelectionSimple
//
// Wrapper for SetSelection that takes only a single range and sets default style values.
//
inline HRESULT SetSelectionSimple(TfEditCookie ec, ITfContext *pic, ITfRange *range)
{
    TF_SELECTION sel;

    sel.range = range;
    sel.style.ase = TF_AE_NONE;
    sel.style.fInterimChar = FALSE;

    return pic->SetSelection(ec, 1, &sel);
}

inline BOOL GetCurrentPos(IStream *pStream, LARGE_INTEGER *pli)
{
    LARGE_INTEGER li;

    li.QuadPart = 0;

    return pStream->Seek(li, STREAM_SEEK_CUR, (ULARGE_INTEGER *)pli) == S_OK;
}

#endif // __cplusplus

HRESULT GetRangeForWholeDoc(TfEditCookie ec, ITfContext *pic, ITfRange **pprange);

#include "proputil.h"

#define LoadSmIcon(hinst, psz) (HICON)LoadImage(hinst, psz, IMAGE_ICON, 16,16, 0)

// NB: this is going away once we cleanup/separate the private/public libs
typedef HRESULT (STDAPICALLTYPE * PFNCOCREATE)(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv);
BOOL TFInitLib_PrivateForCiceroOnly(PFNCOCREATE pfnCoCreate);


HMODULE GetSystemModuleHandle(LPCSTR lpModuleName);
HMODULE LoadSystemLibrary(LPCSTR lpModuleName);
HMODULE LoadSystemLibraryEx(LPCSTR lpModuleName, HANDLE hFile, DWORD dwFlags);
HMODULE GetSystemModuleHandleW(LPCWSTR lpModuleName);
HMODULE LoadSystemLibraryW(LPCWSTR lpModuleName);
HMODULE LoadSystemLibraryExW(LPCWSTR lpModuleName, HANDLE hFile, DWORD dwFlags);


#ifndef ARRAYSIZE
#define ARRAYSIZE(x)                (sizeof(x)/sizeof((x)[0]))
#endif

//+---------------------------------------------------------------------------
//
// CicSystemModulePath
//
//----------------------------------------------------------------------------

class CicSystemModulePath
{
public:
    CicSystemModulePath()
    {
        m_szPath[0] = '\0';
        m_uRet = 0;
    }

    UINT Init(LPCSTR lpModuleName, BOOL fWinDir = FALSE)
    {
        if (fWinDir)
            m_uRet = GetSystemWindowsDirectoryA(m_szPath, ARRAYSIZE(m_szPath));
        else
            m_uRet = GetSystemDirectoryA(m_szPath, ARRAYSIZE(m_szPath));

        if (m_uRet >= ARRAYSIZE(m_szPath))
        {
            m_uRet = 0;
            m_szPath[0] = '\0';
        }
        else if (m_uRet)
        {
            if (m_szPath[m_uRet - 1] != '\\')
            {
                m_szPath[m_uRet] = '\\';
                m_uRet++;
            }

            UINT uLength = lstrlenA(lpModuleName);
            if (ARRAYSIZE(m_szPath) - m_uRet > uLength)
            {
                lstrcpynA(&m_szPath[m_uRet], 
                         lpModuleName, 
                         ARRAYSIZE(m_szPath) - m_uRet);
                m_uRet += uLength;
            }
            else
            {
                m_uRet = 0;
                m_szPath[0] = '\0';
            }
        }
        return m_uRet;
    }

    LPSTR GetPath()
    {
        return m_szPath;
    }

    UINT GetLength()
    {
        return m_uRet;
    }

private:
    char m_szPath[MAX_PATH + 1];
    UINT m_uRet;
};

//+---------------------------------------------------------------------------
//
// CicSystemModulePathW
//
//----------------------------------------------------------------------------

class CicSystemModulePathW
{
public:
    CicSystemModulePathW()
    {
        m_szPath[0] = L'\0';
        m_uRet = 0;
    }

    UINT Init(LPCWSTR lpModuleName, BOOL fWinDir = FALSE)
    {
        if (fWinDir)
            m_uRet = GetSystemWindowsDirectoryW(m_szPath, ARRAYSIZE(m_szPath));
        else
            m_uRet = GetSystemDirectoryW(m_szPath, ARRAYSIZE(m_szPath));

        if (m_uRet >= ARRAYSIZE(m_szPath))
        {
            m_uRet = 0;
            m_szPath[0] = L'\0';
        }
        else if (m_uRet)
        {
            if (m_szPath[m_uRet - 1] != L'\\')
            {
                m_szPath[m_uRet] = L'\\';
                m_uRet++;
            }

            UINT uLength = lstrlenW(lpModuleName);
            if (ARRAYSIZE(m_szPath) - m_uRet > uLength)
            {
                wcsncpy(&m_szPath[m_uRet], 
                        lpModuleName, 
                        ARRAYSIZE(m_szPath) - m_uRet);
                m_uRet += uLength;
            }
            else
            {
                m_uRet = 0;
                m_szPath[0] = L'\0';
            }
        }
        return m_uRet;
    }

    LPWSTR GetPath()
    {
        return m_szPath;
    }

    UINT GetLength()
    {
        return m_uRet;
    }

private:
    WCHAR m_szPath[MAX_PATH + 1];
    UINT m_uRet;
};

#endif // TFMXUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\mes.h ===
//
// mes.h
//

#ifndef MES_H
#define MES_H

#include "private.h"

typedef HRESULT (*MOUSECALLBACK)(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten, void *pv);

class CMouseSink : public ITfMouseSink
{
public:
    CMouseSink(MOUSECALLBACK pfnCallback, void *pv);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfMouseSink
    //
    STDMETHODIMP OnMouseEvent(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten);

    HRESULT _Advise(ITfRange *range, ITfContext *pic);
    HRESULT _Unadvise();

private:

    long _cRef;
    ITfContext *_pic;
    DWORD _dwCookie;
    MOUSECALLBACK _pfnCallback;
    void *_pv;
};

#endif // MES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\kes.h ===
//
// kes.h
//

#ifndef KES_H
#define KES_H

#include "private.h"

typedef HRESULT (*KESCALLBACK)(UINT uCode, ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, void *pv);
typedef HRESULT (*KESPREKEYCALLBACK)(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv);


#define KES_CODE_FOCUS          0x00000000
#define KES_CODE_KEYUP          0x00000001
#define KES_CODE_KEYDOWN        0x00000002
#define KES_CODE_TEST           0x80000000


typedef struct tag_KESPRESERVEDKEY {
    const GUID     *pguid;
    TF_PRESERVEDKEY tfpk;
    const WCHAR    *psz;
} KESPRESERVEDKEY;
    
class CKeyEventSink : public ITfKeyEventSink
{
public:
    CKeyEventSink(KESCALLBACK pfnCallback, void *pv);
    CKeyEventSink(KESCALLBACK pfnCallback, KESPREKEYCALLBACK pfnPrekeyCallback, void *pv);
    ~CKeyEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfWin32KeyEventSink
    //
    STDMETHODIMP OnSetFocus(BOOL fForeground);
    STDMETHODIMP OnTestKeyDown(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyDown(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnTestKeyUp(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyUp(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnPreservedKey(ITfContext *pic, REFGUID rguid, BOOL *pfEaten);

    HRESULT _Register(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey);
    HRESULT _Unregister(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey);

private:
    KESCALLBACK _pfnCallback;
    KESPREKEYCALLBACK _pfnPreKeyCallback;
    void *_pv;
    DWORD _dwCookiePreservedKey;
    int _cRef;
};

#endif // KES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\osver.h ===
//
// osver.h
//

#include <windows.h>


#ifndef OSVER_H
#define OSVER_H

#define OSVER_ONNT     0x0001
#define OSVER_ONNT5    0x0002
#define OSVER_ON95     0x0004
#define OSVER_ON98     0x0008
#define OSVER_ONFE     0x0010
#define OSVER_ONIMM    0x0020
#define OSVER_ONDBCS   0x0040
#define OSVER_ONNT51   0x0080

#define DECLARE_OSVER()                 \
                DWORD g_dwOsVer; \
                UINT  g_uACP;

#ifdef __cplusplus
extern "C" {
#endif
extern DWORD g_dwOsVer;
extern UINT  g_uACP;
#ifdef __cplusplus
}
#endif

#define IsOnNT()       (g_dwOsVer & OSVER_ONNT)
#define IsOnNT5()      (g_dwOsVer & OSVER_ONNT5)
#define IsOn95()       (g_dwOsVer & OSVER_ON95)
#define IsOn98()       (g_dwOsVer & OSVER_ON98)
#define IsOn98orNT5()  (g_dwOsVer & (OSVER_ON98 | OSVER_ONNT5))
#define IsOnFE()       (g_dwOsVer & OSVER_ONFE)
#define IsOnImm()      (g_dwOsVer & OSVER_ONIMM)
#define IsOnDBCS()     (g_dwOsVer & OSVER_ONDBCS)
#define IsOnNT51()     (g_dwOsVer & OSVER_ONNT51)

#ifdef __cplusplus
inline void InitOSVer()
{
    OSVERSIONINFO osvi;
    g_uACP = GetACP();

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);
    g_dwOsVer = 0;
    g_dwOsVer |= (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId) ? OSVER_ONNT : 0;
    g_dwOsVer |= (IsOnNT() && (osvi.dwMajorVersion >= 0x00000005)) ? OSVER_ONNT5 : 0;
    g_dwOsVer |= (IsOnNT5() && (osvi.dwMinorVersion >= 0x00000001)) ? OSVER_ONNT51 : 0;
    g_dwOsVer |= (!IsOnNT() && (osvi.dwMinorVersion >= 0x0000000A)) ? OSVER_ON98 : 0;
    g_dwOsVer |= (!IsOnNT() && !IsOn98()) ? OSVER_ON95 : 0;

    switch (g_uACP)
    {
        case 932:
        case 936:
        case 949:
        case 950:
            g_dwOsVer |= OSVER_ONFE;
            break;
    }

    if (IsOnNT5()) {
#if(_WIN32_WINNT >= 0x0500)
        /*
         * Only NT5 or later suppoert SM_IMMENABLED
         */
        if (GetSystemMetrics(SM_IMMENABLED)) {
            g_dwOsVer |= OSVER_ONIMM;
        }
#endif
    }
    if (GetSystemMetrics(SM_DBCSENABLED)) {
        if (!IsOnNT5()) 
            g_dwOsVer |= OSVER_ONIMM;
         g_dwOsVer |= OSVER_ONDBCS;
    }
}
#endif // __cplusplus


#endif // OSVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\proj.h ===
//
// proj.h:      Main header
//
//


#ifndef __PROJ_H__
#define __PROJ_H__

#ifndef STRICT
#define STRICT
#endif

#if defined(WINNT) || defined(WINNT_ENV)

//
// NT uses DBG=1 for its debug builds, but the Win95 shell uses
// DEBUG.  Do the appropriate mapping here.
//
#if DBG
#define DEBUG 1
#endif

#endif  // WINNT

#include <windows.h>
#include <commctrl.h>
#include <shlobj.h>
#include <debug.h>
//#include <port32.h>
#include <ccstock.h>

//#include <shsemip.h>        // for _ILNext


// Some files are compiled twice: once for unicode and once for ansi.
// There are some functions which do not want to be declared twice
// (the ones which don't use string parameters).  Otherwise we'd get
// duplicate redefinitions.
//
// These are wrapped with #ifdef DECLARE_ONCE.
#ifdef UNICODE
#define DECLARE_ONCE
#else
#undef DECLARE_ONCE
#endif


// Note that CharNext is not supported on win95.  Normally we would
// include w95wraps.h, but comctl does not link to shlwapi and
// we don't want to add this dependency.
#ifdef UNICODE
// Note that this will still break if we ever go back to non-unicode
__inline LPWSTR CharNextWrapW_(LPWSTR psz) {return ++psz;}
#undef CharNext
#define CharNext CharNextWrapW_
#endif


#endif // __PROJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\icrtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//


#if defined(__cplusplus) && defined(CPP_FUNCTIONS)

#include "mem.h"
#undef new

void *  __cdecl operator new(size_t nSize)
{
    return cicMemAllocClear((UINT)nSize);
}

void  __cdecl operator delete(void *pv)
{
    cicMemFree(pv);
}

void __cdecl operator delete[]( void * p )
{
    operator delete(p);
}

void * __cdecl operator new[]( size_t cb )
{
    return operator new(cb);
}

extern "C" int __cdecl _purecall(void) {return 0;}

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\insert.h ===
//
// insert.h
//

#ifndef INSERT_H
#define INSERT_H

#include "private.h"
#include "dbgid.h"

class COvertypeStore;

// max number of overtyped chars that IH will backup
#define DEF_MAX_OVERTYPE_CCH    32

// tips need to register this GUID with the category manager before using the library!
extern const GUID GUID_PROP_OVERTYPE;

class CCompositionInsertHelper
{
public:
    CCompositionInsertHelper();

    ULONG AddRef();
    ULONG Release();

    HRESULT Configure(ULONG cchMaxOvertype);

    HRESULT InsertAtSelection(TfEditCookie ecWrite, ITfContext *pic, const WCHAR *pchText, ULONG cchText, ITfRange **ppCompRange);

    HRESULT QueryPreInsert(TfEditCookie ecWrite, ITfRange *rangeToAdjust,
                           ULONG cchCurrent /* must be zero for first insert! */, ULONG cchInsert,
                           BOOL *pfInsertOk);

    HRESULT PreInsert(TfEditCookie ecWrite, ITfRange *rangeToAdjust,
                      ULONG cchCurrent /* must be zero for first insert! */, ULONG cchInsert,
                      BOOL *pfInsertOk);

    HRESULT PostInsert();

    HRESULT ReleaseBlobs(TfEditCookie ecWrite, ITfContext *pic, ITfRange *range);

private:
    ~CCompositionInsertHelper() {} // clients should use Release

    HRESULT _PreInsert(TfEditCookie ecWrite, ITfRange *rangeToAdjust,
                       ULONG cchCurrent /* must be zero for first insert! */, ULONG cchInsert,
                       BOOL *pfInsertOk, BOOL fQuery);

    friend COvertypeStore;

    BOOL _AcceptTextUpdated()
    {
        return _fAcceptTextUpdated;
    }

    void _IncOvertypeStoreRef()
    {
        _cRefOvertypeStore++;
    }

    void _DecOvertypeStoreRef()
    {
        Assert(_cRefOvertypeStore > 0);
        _cRefOvertypeStore--;
    }

    HRESULT _PreInsertGrow(TfEditCookie ec, ITfRange *rangeToAdjust, ULONG cchCurrent, ULONG cchInsert, BOOL fQuery);
    HRESULT _PreInsertShrink(TfEditCookie ec, ITfRange *rangeToAdjust, ULONG cchCurrent, ULONG cchInsert, BOOL fQuery);

    BOOL _fAcceptTextUpdated;
    ULONG _cchMaxOvertype;
    LONG _cRefOvertypeStore;
    LONG _cRef;

    DBG_ID_DECLARE;
};

#endif // INSERT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\sdo.h ===
//
// sdo.h
//
// Generic simple IDataObject object
//

#ifndef SDO_H
#define SDO_H

#include "private.h"

class CDataObject : public IDataObject
{
public:
    CDataObject();
    ~CDataObject();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IDataObject
    //
    STDMETHODIMP GetData(FORMATETC *pfe, STGMEDIUM *psm);
    STDMETHODIMP GetDataHere(FORMATETC *pfe, STGMEDIUM *psm);
    STDMETHODIMP QueryGetData(FORMATETC *pfe);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfeIn, FORMATETC *pfeOut);
    STDMETHODIMP SetData(FORMATETC *pfe, STGMEDIUM *psm, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDir, IEnumFORMATETC **ppefe);
    STDMETHODIMP DAdvise(FORMATETC *pfe, DWORD advf, IAdviseSink *pas, DWORD *pdwCookie);
    STDMETHODIMP DUnadvise(DWORD dwCookie);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppesd);

    HRESULT _SetData(const WCHAR *pch, ULONG cch);

private:
    FORMATETC _fe;
    STGMEDIUM _sm;
    BOOL _fReleaseSM;
    long _cRef;
};

#endif // SDO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\slbarid.h ===
//
// slbarid.h
//

#ifndef SLBARID_H
#define SLBARID_H

//
// System lang bar items use these clsid to be located at proper place
// in the lang bar.
//

#define CICPADBTN_ORDER (-40)
#define HELPBTN_ORDER   (-30)
#define KANAINDIC_ORDER (-20)
#define WIN32IME_ORDER  (-10)

//
// Top sort order clsid
//
DEFINE_GUID(CLSID_SYSTEMLANGBARITEM, 0xbebacc94, 0x5cd3, 0x4662, 0xa1, 0xe0, 0xf3, 0x31, 0x99, 0x49, 0x36, 0x69);

//
// Last sort order clsid
//
DEFINE_GUID(CLSID_SYSTEMLANGBARITEM2, 0x5d997390, 0x8320, 0x400a, 0x88, 0xe5, 0x35, 0xb0, 0xc1, 0x20, 0xf9, 0x0b);

//
// Keyboard type sort order clsid
//
DEFINE_GUID(CLSID_SYSTEMLANGBARITEM_KEYBOARD, 0x77b34286, 0xed57, 0x45e2, 0x97, 0x66, 0xd8, 0xc5, 0xfe, 0x3d, 0xfb, 0x2c);

//
// Speech type sort order clsid
//
DEFINE_GUID(CLSID_SYSTEMLANGBARITEM_SPEECH,  0x7d1c98fb, 0xa873, 0x42b6, 0x88, 0x82, 0xb2, 0x97, 0x38, 0xb9, 0x30, 0xb2);

//
// HandWriting type sort order clsid
//
DEFINE_GUID(CLSID_SYSTEMLANGBARITEM_HANDWRITING, 0xa0810b6e, 0x1726, 0x4636, 0xb6, 0x51, 0xcd, 0xec, 0xd8, 0x22, 0xf0, 0x33);



/* 58c99d96-2f9b-42ce-91be-37ef1860f882 */
DEFINE_GUID(GUID_LBI_CTRL, 0x58c99d96, 0x2f9b, 0x42ce, 0x91, 0xbe, 0x37, 0xef, 0x18, 0x60, 0xf8, 0x82);

/* ed9d5450-ebe6-4255-8289-f8a31e687228 */
DEFINE_GUID(GUID_LBI_HELP, 0xed9d5450, 0xebe6, 0x4255, 0x82, 0x89, 0xf8, 0xa3, 0x1e, 0x68, 0x72, 0x28);

/* bb5bc72f-81df-4231-9668-c8dfd20fdb6f */
DEFINE_GUID(GUID_LBI_KANACAPS, 0xbb5bc72f, 0x81df, 0x4231, 0x96, 0x68, 0xc8, 0xdf, 0xd2, 0x0f, 0xdb, 0x6f);

/* 133901f4-2311-4bda-8c1e-57451a920d99 */
DEFINE_GUID(GUID_LBI_WIN32IME, 0x133901f4, 0x2311, 0x4bda, 0x8c, 0x1e, 0x57, 0x45, 0x1a, 0x92, 0x0d, 0x99);

/* 190f67a2-024f-40d9-aaba-439f5c808f67 */
DEFINE_GUID(GUID_LBI_RECONV, 0x190f67a2, 0x024f, 0x40d9, 0xaa, 0xba, 0x43, 0x9f, 0x5c, 0x80, 0x8f, 0x67);

#endif // SLBARID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\mem.h ===
//
// mem.h
//

#ifndef MEM_H
#define MEM_H

#include "private.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DEBUG

void *cicMemAlloc(UINT uCount);
void *cicMemAllocClear(UINT uCount);
void cicMemFree(void *pv);
void *cicMemReAlloc(void *pv, UINT uCount);
UINT cicMemSize(void *pv);

// placeholders for the debug funcs
#define Dbg_MemInit(pszName, rgCounters)
#define Dbg_MemUninit()
#define Dbg_MemDumpStats()
#define Dbg_MemSetName(pv, pszName)
#define Dbg_MemGetName(pv, pch, ccBuffer)
#define Dbg_MemSetThisName(pszName)

#else // DEBUG

typedef struct _DBG_MEM_COUNTER
{
    const TCHAR *pszDesc;
    ULONG uCount;
} DBG_MEM_COUNTER;

typedef struct _DBG_MEMALLOC
{
    void *pvAlloc;          // the allocated memory
    UINT uCount;            // size of allocated mem
    TCHAR *pszName;         // debug string
    const TCHAR *pszFile;   // file in which alloc occurred
    int iLine;              // line num of alloc file
    DWORD dwThreadID;       // Thread ID
    DWORD dwID;             // unique id (by object type)
    struct _DBG_MEMALLOC *next;
} DBG_MEMALLOC;

typedef struct
{
    UINT uTotalAlloc;
    UINT uTotalFree;
    long uTotalMemAllocCalls;
    long uTotalMemAllocClearCalls;
    long uTotalMemReAllocCalls;
    long uTotalMemFreeCalls;
    DBG_MEMALLOC *pMemAllocList;
    TCHAR *pszName;
} DBG_MEMSTATS;

BOOL Dbg_MemInit(const TCHAR *pszName, DBG_MEM_COUNTER *rgCounters);
BOOL Dbg_MemUninit();
void Dbg_MemDumpStats();

void *Dbg_MemAlloc(UINT uCount, const TCHAR *pszFile, int iLine);
void *Dbg_MemAllocClear(UINT uCount, const TCHAR *pszFile, int iLine);
void Dbg_MemFree(void *pv);
void *Dbg_MemReAlloc(void *pv, UINT uCount, const TCHAR *pszFile, int iLine);
UINT Dbg_MemSize(void *pv);

BOOL Dbg_MemSetName(void *pv, const TCHAR *pszName);
BOOL Dbg_MemSetNameID(void *pv, const TCHAR *pszName, DWORD dwID);
BOOL Dbg_MemSetNameIDCounter(void *pv, const TCHAR *pszName, DWORD dwID, ULONG iCounter);
int Dbg_MemGetName(void *pv, TCHAR *pch, int ccBuffer);

#define cicMemAlloc(uCount)        Dbg_MemAlloc(uCount, TEXT(__FILE__), __LINE__)
#define cicMemAllocClear(uCount)   Dbg_MemAllocClear(uCount, TEXT(__FILE__), __LINE__)
#define cicMemFree(pv)             Dbg_MemFree(pv)
#define cicMemReAlloc(pv, uCount)  Dbg_MemReAlloc(pv, uCount, TEXT(__FILE__), __LINE__)
#define cicMemSize(pv)             Dbg_MemSize(pv)

// helpers
#define Dbg_MemSetThisName(pszName) Dbg_MemSetNameID(this, pszName, (DWORD)-1)

#endif // DEBUG

#ifdef __cplusplus
} // extern "C"
#endif

#ifdef __cplusplus
#ifdef DEBUG

inline void *  __cdecl operator new(size_t nSize, const TCHAR *pszFile, int iLine)
{
    return Dbg_MemAllocClear(nSize, pszFile, iLine);
}

#define new new(TEXT(__FILE__), __LINE__)

#endif // DEBUG
#endif // __cplusplus

#endif // MEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\regimx.h ===
//
// regimx.h
//

#ifndef REGIMX_H
#define REGIMX_H

typedef struct tag_REGTIPLANGPROFILE {
    //
    // langid
    //
    //   The langid value cane be one of followings.
    //
    //   1. complete lang id.
    //     the combination of SUBLANGID and MAINLANGID.
    //
    //   2. just main lang id.
    //     Just MAINLANGID and set SUBLANGID as 0.
    //     Then this profile is avaible for all langids that match with
    //     main langid.
    //
    //   3. -1
    //     This profile is avaible on any language.
    //
    LANGID langid;
    const GUID *pguidProfile;
    WCHAR szProfile[128];
    WCHAR szIconFile[32];
    ULONG uIconIndex;
    ULONG uDisplayDescResIndex;
} REGTIPLANGPROFILE;

BOOL RegisterTIP(HINSTANCE hInst, REFCLSID clsid, WCHAR *pwszDesc, const REGTIPLANGPROFILE *plp);
BOOL UnregisterTIP(REFCLSID rclsid);


#endif // REGIMX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\ptrary.h ===
//
// ptrary.h
//
// CPtrArray -- growable pointer array
//

#ifndef PTRARY_H
#define PTRARY_H

#include "private.h"

class CVoidPtrArray
{
public:
    CVoidPtrArray() 
    {
        _cElems = 0;
        _rgpv = NULL;
        _iSize = 0;
    }
    virtual ~CVoidPtrArray() { cicMemFree(_rgpv); }

    inline void Set(int iIndex, void *pv)
    {
        Assert(iIndex >= 0);
        Assert(iIndex < _cElems);

        _rgpv[iIndex] = pv;
    }

    inline void *Get(int iIndex) { return *GetPtr(iIndex); }

    inline void **GetPtr(int iIndex)
    {
        Assert(iIndex >= 0);
        Assert(iIndex <= _cElems); // there's code that uses the first invalid offset for loop termination

        return &_rgpv[iIndex];
    }

    BOOL Insert(int iIndex, int cElems);
    void Remove(int iIndex, int cElems);
    int Move(int iIndexNew, int iIndexOld);
    void **Append(int cElems)
    {
        return Insert(Count(), cElems) ? GetPtr(Count()-cElems) : NULL;
    }

    void SetCount(int cElems)
    {
        Assert(cElems >= 0);
        Assert(cElems <= _iSize);
        _cElems = cElems;
    }
    int Count() { return _cElems; }

    void Clear() { cicMemFree(_rgpv); _rgpv = NULL; _cElems = _iSize = 0; }

    void CompactSize(int iSizeNew)
    {
        void **ppv;

        Assert(iSizeNew <= _iSize);
        Assert(_cElems <= iSizeNew);

        if (iSizeNew == _iSize) // MemReAlloc will actually re-alloc!  Don't let it.
            return;

        if ((ppv = (void **)cicMemReAlloc(_rgpv, iSizeNew*sizeof(void *))) != NULL)
        {
            _rgpv = ppv;
            _iSize = iSizeNew;
        }
    }

    void CompactSize() { CompactSize(_cElems); }

private:
    void **_rgpv;   // the array
    int _cElems;    // num eles in the array
    int _iSize;     // actual size (in void *'s) of the array
};



//
// typesafe version
//
template<class T>
class CPtrArray : public CVoidPtrArray
{
public:
    CPtrArray() {}

    void Set(int iIndex, T *pT) { CVoidPtrArray::Set(iIndex, pT); }
    T *Get(int iIndex) { return (T *)CVoidPtrArray::Get(iIndex); }
    T **GetPtr(int iIndex) { return (T **)CVoidPtrArray::GetPtr(iIndex); }
    T **Append(int cElems) { return (T **)CVoidPtrArray::Append(cElems); }
};


#endif // PTRARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\regsvr.h ===
//
// imeutil.h
//

#ifndef REGSVR_H
#define REGSVR_H

#include <windows.h>
#include <advpub.h>

// bugbug: calling convention

#define CLSID_STRLEN 38  // strlen("{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx}")
BOOL CLSIDToStringA(REFGUID refGUID, char *pchA);
BOOL StringAToCLSID(char *pchA, GUID *pGUID);

BOOL RegisterServer(REFCLSID clsid, LPCTSTR pszDesc, LPCTSTR pszPath, LPCTSTR pszModel, LPCTSTR pszSoftwareKey);

#endif // REGSVR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\proputil.h ===
//
// proputil.h
//


#ifndef PROPUTIL_H
#define PROPUTIL_H

#include "private.h"
#include "catutil.h"


HRESULT HrVariantToBlob(VARIANT *pv, void *value, ULONG *cbvalue, VARTYPE vt);
HRESULT HrBlobToVariant(const void *value, ULONG cbvalue, VARIANT *pv, VARTYPE vt);
HRESULT GetGUIDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, TfGuidAtom *pguidatom);
HRESULT SetGUIDPropertyData(LIBTHREAD *plt, TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, REFGUID rguid);
HRESULT GetDWORDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, DWORD *pdw);
HRESULT SetDWORDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, DWORD dw);
HRESULT GetReadingStrPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR *pbtr);
HRESULT GetBSTRPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR *pbstr);
HRESULT SetBSTRPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR bstr);
HRESULT GetUnknownPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, IUnknown **ppunk);
HRESULT SetUnknownPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, IUnknown *punk);

#define GetLangIdPropertyData(ec, pProp, pPropRange, plangid)  {DWORD dw = 0; GetDWORDPropertyData(ec, pProp, pPropRange, &dw); *plangid = (WORD)dw;}
#define SetLangIdPropertyData(ec, pProp, pPropRange, langid) SetDWORDPropertyData(ec, pProp, pPropRange, (WORD)langid)
#define GetAttrPropertyData GetGUIDPropertyData
#define SetAttrPropertyData SetGUIDPropertyData

inline HRESULT HrVariantToGUID(VARIANT *pv, GUID *pguid)
{
    ULONG cb = sizeof(GUID);
    HRESULT hr =  HrVariantToBlob(pv, (void *)pguid, &cb, VT_I4);
    Assert(FAILED(hr) || (cb == sizeof(GUID) / 4));
    return hr;
}
inline HRESULT HrGUIDToVariant(REFGUID rguid, VARIANT *pv)
{
    return HrBlobToVariant((const void *)&rguid, sizeof(GUID) / 4, pv, VT_I4);
}

void SetIntAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, int nData);
void SetCharAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, WCHAR *pszData);
HRESULT GetIntAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, int *pnRet);
HRESULT GetCharAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, WCHAR *pszData, int nSize);

HRESULT SetTextAndProperty(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, const WCHAR *pchText, LONG cchText, LANGID langid, const GUID *pattr);
HRESULT SetTextAndReading(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, const WCHAR *pchText, LONG cchText, LANGID langid, const WCHAR *pszRead);

BOOL IsOwnerAndFocus(LIBTHREAD *plt, TfEditCookie ec, REFCLSID rclsid, ITfReadOnlyProperty *pProp, ITfRange *pRange);
HRESULT EnumTrackTextAndFocus(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfReadOnlyProperty **ppProp, IEnumTfRanges **ppEnumTrack);
BOOL IsGUIDProp(LIBTHREAD *plt, TfEditCookie ec, REFGUID rclsid, ITfProperty *pProp, ITfRange *pRange);
HRESULT AdjustRangeByTextOwner(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRange, REFGUID rguid);
HRESULT AdjustRangeByAttribute(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRange, const GUID *rgRGuid, int cGuid);


#endif // PROPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\tes.h ===
//
// tes.h
//
// Generic ITfTextEventSink object
//

#ifndef TES_H
#define TES_H

#include "private.h"

#define TES_INVALID_COOKIE  ((DWORD)(-1))

#define ICF_TEXTDELTA           1
#define ICF_LAYOUTDELTA         2
#define ICF_LAYOUTDELTA_CREATE  3
#define ICF_LAYOUTDELTA_DESTROY 4

typedef struct
{
    TfEditCookie ecReadOnly;
    ITfEditRecord *pEditRecord;
    ITfContext *pic;
} TESENDEDIT;

typedef HRESULT (*TESCALLBACK)(UINT uCode, void *pv, void *pvData);

class CTextEventSink : public ITfTextEditSink,
                       public ITfTextLayoutSink
{
public:
    CTextEventSink(TESCALLBACK pfnCallback, void *pv);
    virtual ~CTextEventSink() {};

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfTextEventSink
    //
    STDMETHODIMP OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    STDMETHODIMP OnLayoutChange(ITfContext *pic, TfLayoutCode lcode, ITfContextView *pView);

    HRESULT _Advise(ITfContext *pic, DWORD dwFlags);
    HRESULT _Unadvise();

protected:
    void SetCallbackPV(void* pv)
    {
        if (_pv == NULL)
            _pv = pv;
    };

private:

    long _cRef;
    ITfContext *_pic;
    DWORD _dwEditCookie;
    DWORD _dwLayoutCookie;
    DWORD _dwFlags;
    TESCALLBACK _pfnCallback;
    void *_pv;
};

#endif // TES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\nuibase.h ===
//
// nuibase.h
//
// Generic ITfTextEventSink object
//

#ifndef NUIBASE_H
#define NUIBASE_H

#include "ctfutb.h"
#include "iconlib.h"
inline HRESULT LangBarInsertMenu(ITfMenu *pMenu, UINT uId, WCHAR *psz, BOOL bChecked = FALSE, BOOL bRadioChecked = FALSE)
{
    DWORD dwFlags = 0;

    if (bChecked)
        dwFlags |= TF_LBMENUF_CHECKED;
    if (bRadioChecked)
        dwFlags |= TF_LBMENUF_RADIOCHECKED;

    return pMenu->AddMenuItem(uId, 
                              dwFlags,
                              NULL,
                              NULL,
                              psz,
                              wcslen(psz),
                              NULL);
}

inline HRESULT LangBarInsertGrayedMenu(ITfMenu *pMenu, WCHAR *psz)
{
    return pMenu->AddMenuItem((UINT)-1, 
                              TF_LBMENUF_GRAYED,
                              NULL,
                              NULL,
                              psz,
                              wcslen(psz),
                              NULL);
}

inline HRESULT LangBarInsertMenu(ITfMenu *pMenu, UINT uId, WCHAR *psz, HBITMAP hbmp, HBITMAP hbmpMask)
{
    return pMenu->AddMenuItem(uId, 
                              0,
                              hbmp,
                              hbmpMask,
                              psz,
                              wcslen(psz),
                              NULL);
}

inline HRESULT LangBarInsertMenu(ITfMenu *pMenu, UINT uId, WCHAR *psz, BOOL bChecked, HICON hIcon)
{
    HBITMAP hbmp = NULL;
    HBITMAP hbmpMask = NULL;
    if (hIcon)
    {
        HICON hSmIcon = (HICON)CopyImage(hIcon, 
                                         IMAGE_ICON, 
                                         16,
                                         16,
                                         LR_COPYFROMRESOURCE);
        SIZE size = {16, 16};

        if (!GetIconBitmaps(hSmIcon ? hSmIcon : hIcon, &hbmp, &hbmpMask, &size))
            return E_FAIL;

        if (hSmIcon)
            DestroyIcon(hSmIcon);

        if (hIcon)
            DestroyIcon(hIcon);
    }

    return pMenu->AddMenuItem(uId, 
                              bChecked ? TF_LBMENUF_CHECKED : 0,
                              hbmp,
                              hbmpMask,
                              psz,
                              wcslen(psz),
                              NULL);
}

inline HRESULT LangBarInsertGrayedMenu(ITfMenu *pMenu, WCHAR *psz, HICON hIcon)
{
    HBITMAP hbmp = NULL;
    HBITMAP hbmpMask = NULL;
    if (hIcon)
    {
        HICON hSmIcon = (HICON)CopyImage(hIcon, 
                                         IMAGE_ICON, 
                                         16,
                                         16,
                                         LR_COPYFROMRESOURCE);
        SIZE size = {16, 16};

        if (!GetIconBitmaps(hSmIcon ? hSmIcon : hIcon, &hbmp, &hbmpMask, &size))
            return E_FAIL;

        if (hSmIcon)
            DestroyIcon(hSmIcon);

        if (hIcon)
            DestroyIcon(hIcon);
    }

    return pMenu->AddMenuItem((UINT)-1, 
                              TF_LBMENUF_GRAYED,
                              hbmp,
                              hbmpMask,
                              psz,
                              wcslen(psz),
                              NULL);
}

inline HRESULT LangBarInsertSubMenu(ITfMenu *pMenu, WCHAR *psz, ITfMenu **ppSubMenu)
{
    return pMenu->AddMenuItem(UINT(-1), 
                              TF_LBMENUF_SUBMENU,
                              NULL,
                              NULL,
                              psz,
                              wcslen(psz),
                              ppSubMenu);
}

inline HRESULT LangBarInsertSeparator(ITfMenu *pMenu)
{
    return pMenu->AddMenuItem((UINT)(-1),
                              TF_LBMENUF_SEPARATOR,
                              NULL,
                              NULL,
                              NULL,
                              0,
                              NULL);
}

#define NUIBASE_TOOLTIP_MAX 256
#define NUIBASE_TEXT_MAX    256

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemBase
{
public:
    CLBarItemBase();
    virtual ~CLBarItemBase();

    void InitNuiInfo(REFCLSID clsid, REFGUID rguid, DWORD dwStyle, ULONG ulSort, WCHAR *pszDesc);
    virtual STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    virtual STDMETHODIMP GetStatus(DWORD *pdwStatus);
    virtual STDMETHODIMP Show(BOOL fShow);
    virtual STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    virtual STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    virtual STDMETHODIMP UnadviseSink(DWORD dwCookie);

    DWORD GetStyle() {return _lbiInfo.dwStyle;}
    void SetStyle(DWORD dwStyle) {_lbiInfo.dwStyle = dwStyle;}

    GUID* GetGuidItem() {return &_lbiInfo.guidItem;}

    DWORD GetStatusInternal() {return _dwStatus;}
    void SetStatusInternal(DWORD dw) {_dwStatus = dw;}
    HRESULT ShowInternal(BOOL fShow, BOOL fNotify);

    void SetOrClearStatus(DWORD dw, BOOL fSet)
    {
        if (fSet)
            _dwStatus |= dw;
        else
            _dwStatus &= ~dw;
    }

    void SetToolTip(WCHAR *psz, UINT cch = (UINT)(-1))
    {
        if (cch == (UINT)(-1))
            StringCchCopyW(_szToolTip, ARRAYSIZE(_szToolTip), psz);
        else
        {
            UINT cchTemp = (UINT)min(ARRAYSIZE(_szToolTip) - 1, cch);
            memcpy(_szToolTip, psz, cchTemp * sizeof(WCHAR));
            _szToolTip[cchTemp] = L'\0';
        }
    }

    virtual HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    virtual HRESULT OnRButtonUp(const POINT pt, const RECT *prcArea);

    ITfLangBarItemSink *GetSink() {return _plbiSink;}

protected:
    DWORD _dwStatus;
    TF_LANGBARITEMINFO _lbiInfo;
    WCHAR _szToolTip[NUIBASE_TOOLTIP_MAX];
    long _cRef;
    ITfLangBarItemSink *_plbiSink;

private:
    DWORD _dwCookie;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemButtonBase : public CLBarItemBase,
                                                 public ITfSource,
                                                 public ITfLangBarItemButton
{
public:
    CLBarItemButtonBase();
    virtual ~CLBarItemButtonBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    //
    // ITfLangBarItemButton
    //
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP GetText(BSTR *pbstrText);

    void SetIcon(HICON hIcon)   {_hIcon = hIcon;}
    HICON GetIcon()   {return _hIcon;}
    void SetText(WCHAR *psz)  
    {
        StringCchCopyW(_szText, ARRAYSIZE(_szText), psz);
    }

private:
    HICON _hIcon;
    WCHAR _szText[NUIBASE_TEXT_MAX];

};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBitmapButtonBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemBitmapButtonBase : public CLBarItemBase,
                                                       public ITfSource,
                                                       public ITfLangBarItemBitmapButton
{
public:
    CLBarItemBitmapButtonBase();
    virtual ~CLBarItemBitmapButtonBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    //
    // ITfLangBarItemBitmapButton
    //
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault, SIZE *psize);
    STDMETHODIMP DrawBitmap(LONG x, LONG y, DWORD dwFlags,  HBITMAP *phbmp, HBITMAP *phbmpMask) = 0;
    STDMETHODIMP GetText(BSTR *pbstrText);


    void SetText(WCHAR *psz)  
    {
        StringCchCopyW(_szText, ARRAYSIZE(_szText), psz);
    }

    void SetPreferedSize(SIZE *psize) {_sizePrefered = *psize;}
private:
    SIZE _sizePrefered;
    WCHAR _szText[NUIBASE_TEXT_MAX];

};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBitmapBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemBitmapBase : public CLBarItemBase,
                                                 public ITfSource,
                                                 public ITfLangBarItemBitmap
{
public:
    CLBarItemBitmapBase();
    virtual ~CLBarItemBitmapBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    //
    // ITfLangBarItemBitmap
    //
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault, SIZE *psize);
    STDMETHODIMP DrawBitmap(LONG x, LONG y, DWORD dwFlags, HBITMAP *phbmp, HBITMAP *phbmpMask) = 0;

    void SetPreferedSize(SIZE *psize) {_sizePrefered = *psize;}
private:
    SIZE _sizePrefered;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBalloonBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemBalloonBase : public CLBarItemBase,
                                                 public ITfSource,
                                                 public ITfLangBarItemBalloon
{
public:
    CLBarItemBalloonBase();
    virtual ~CLBarItemBalloonBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    //
    // ITfLangBarItemBalloon
    //
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault, SIZE *psize);
    STDMETHODIMP GetBalloonInfo(TF_LBBALLOONINFO *pInfo) = 0;

    void SetPreferedSize(SIZE *psize) {_sizePrefered = *psize;}
private:
    SIZE _sizePrefered;
};

#endif // NUIBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\timsink.h ===
//
// timsink.h
//

#ifndef TIMSINK_H
#define TIMSINK_H

#include "private.h"

typedef HRESULT (*DIMCALLBACK)(UINT uCode, ITfDocumentMgr *dim, ITfDocumentMgr *dimPrev, void *pv);
typedef HRESULT (*ICCALLBACK)(UINT uCode, ITfContext *pic, void *pv);

#define TIM_CODE_INITDIM       0
#define TIM_CODE_UNINITDIM     1
#define TIM_CODE_SETFOCUS      2
#define TIM_CODE_INITIC        3
#define TIM_CODE_UNINITIC      4

class CThreadMgrEventSink : public ITfThreadMgrEventSink
{
public:
    CThreadMgrEventSink(DIMCALLBACK pfnDIMCallback, ICCALLBACK pfnICCallback, void *pv);
    ~CThreadMgrEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfThreadMgrEventSink
    //
    STDMETHODIMP OnInitDocumentMgr(ITfDocumentMgr *dim);
    STDMETHODIMP OnUninitDocumentMgr(ITfDocumentMgr *dim);
    STDMETHODIMP OnSetFocus(ITfDocumentMgr *dimFocus, ITfDocumentMgr *dimPrevFocus);
    STDMETHODIMP OnPushContext(ITfContext *pic);
    STDMETHODIMP OnPopContext(ITfContext *pic);

    HRESULT _Advise(ITfThreadMgr *tim);
    HRESULT _Unadvise();
    HRESULT _InitDIMs(BOOL fInit);

protected:
    void SetCallbackPV(void* pv)
    {
        if (_pv == NULL)
            _pv = pv;
    };

private:
    ITfThreadMgr *_tim;
    DWORD _dwCookie;
    DIMCALLBACK _pfnDIMCallback;
    ICCALLBACK _pfnICCallback;
    TfClientId _tid;
    void *_pv;
    int _cRef;
};

#endif // TIMSINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\cleanup.cpp ===
//
// cleanup.cpp
//

#include "private.h"
#include "cleanup.h"

class CCleanupContextsEditSession : public ITfEditSession
{
public:
    CCleanupContextsEditSession(ITfContext *pic, ICleanupContextsClient *pClient);
    ~CCleanupContextsEditSession();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfEditCallback
    //
    STDMETHODIMP DoEditSession(TfEditCookie ec);

private:
    ITfContext *_pic;
    ICleanupContextsClient *_pClient;

    LONG _cRef;
};

//+---------------------------------------------------------------------------
//
// CleanupAllCompositions
//
//----------------------------------------------------------------------------

BOOL CleanupAllCompositions(TfEditCookie ecWrite, ITfContext *pic,
                            REFCLSID clsidOwner,
                            CLEANUP_COMPOSITIONS_CALLBACK pfnCleanupCompositons,
                            void *pvPrivate)
{
    IEnumITfCompositionView *pEnum;
    ITfCompositionView *pCompositionView;
    ITfContextComposition *picc;
    ITfComposition *pComposition;
    ITfRange *range;
    CLSID clsid;
    HRESULT hr;
    BOOL fRet;

    // find all the compositions with our _tid, in _pic
    if (pic->QueryInterface(IID_ITfContextComposition, (void **)&picc) != S_OK)
        return FALSE;

    fRet = FALSE;

    if (picc->EnumCompositions(&pEnum) != S_OK)
        goto Exit;

    while (pEnum->Next(1, &pCompositionView, NULL) == S_OK)
    {
        pCompositionView->GetOwnerClsid(&clsid);

        // make sure we ignore other TIPs' compositions!
        if (!IsEqualCLSID(clsid, clsidOwner))
            goto NextComposition;

        if (pCompositionView->QueryInterface(IID_ITfComposition, (void **)&pComposition) != S_OK)
            goto NextComposition;

        hr = pComposition->GetRange(&range);

        // notify cicero, app
        pComposition->EndComposition(ecWrite);

        if (hr == S_OK)
        {
            // notify tip
            pfnCleanupCompositons(ecWrite, range, pvPrivate);
            range->Release();
        }

        pComposition->Release();

NextComposition:
        pCompositionView->Release();
    }

    pEnum->Release();

    fRet = TRUE;

Exit:
    picc->Release();

    return fRet;
}

//+---------------------------------------------------------------------------
//
// CleanupAllContexts
//
//----------------------------------------------------------------------------

BOOL CleanupAllContexts(ITfThreadMgr *tim, TfClientId tid, ICleanupContextsClient *pClient)
{
    IEnumTfDocumentMgrs *pEnumDm;
    ITfDocumentMgr *pDm;
    IEnumTfContexts *pEnumCtxt;
    ITfContext *pic;
    CCleanupContextsEditSession *pes;
    BOOL fInterested;
    HRESULT hr;

    if (tim->EnumDocumentMgrs(&pEnumDm) != S_OK)
        return FALSE;

    while (pEnumDm->Next(1, &pDm, NULL) == S_OK)
    {
        if (pDm->EnumContexts(&pEnumCtxt) != S_OK)
            goto NextDm;

        while (pEnumCtxt->Next(1, &pic, NULL) == S_OK)
        {
            if (pClient->IsInterestedInContext(pic, &fInterested) != S_OK || !fInterested)
                goto NextIC;

            if ((pes = new CCleanupContextsEditSession(pic, pClient)) == NULL)
                goto NextIC;

            pic->RequestEditSession(tid, pes, TF_ES_READWRITE, &hr);
            Assert(SUCCEEDED(hr));
            pes->Release();

NextIC:
            pic->Release();
        }

        pEnumCtxt->Release();

NextDm:
        pDm->Release();
    }

    pEnumDm->Release();

    return TRUE;
}



//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCleanupContextsEditSession::CCleanupContextsEditSession(ITfContext *pic, ICleanupContextsClient *pClient)
{
    _pic = pic;
    _pic->AddRef();

    _pClient = pClient;
    _pClient->AddRef();

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCleanupContextsEditSession::~CCleanupContextsEditSession()
{
    _pic->Release();
    _pClient->Release();
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCleanupContextsEditSession::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfEditSession))
    {
        *ppvObj = SAFECAST(this, CCleanupContextsEditSession *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CCleanupContextsEditSession::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CCleanupContextsEditSession::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CCleanupContextsEditSession::DoEditSession(TfEditCookie ec)
{
    _pClient->CleanupContext(ec, _pic);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\statsink.h ===
//
// statsink.h
//
// Generic ITfStatusSink object
//

#ifndef STATSINK_H
#define STATSINK_H

#include "private.h"

#define SES_INVALID_COOKIE  ((DWORD)(-1))

typedef HRESULT (*SESCALLBACK)(void *pv, DWORD dwFlags);

class CStatusSink : public ITfStatusSink
{
public:
    CStatusSink(SESCALLBACK pfnCallback, void *pv);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfStatusSink
    //
    STDMETHODIMP OnStatusChange(ITfContext *pic, DWORD dwFlags);

    HRESULT _Advise(ITfContext *pic);
    HRESULT _Unadvise();

private:

    long _cRef;
    ITfContext *_pic;
    DWORD _dwCookie;
    SESCALLBACK _pfnCallback;
    void *_pv;
};

#endif // STATSINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\softkbd.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for softkbd.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __softkbd_h__
#define __softkbd_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISoftKbd_FWD_DEFINED__
#define __ISoftKbd_FWD_DEFINED__
typedef interface ISoftKbd ISoftKbd;
#endif 	/* __ISoftKbd_FWD_DEFINED__ */


#ifndef __ISoftKeyboardEventSink_FWD_DEFINED__
#define __ISoftKeyboardEventSink_FWD_DEFINED__
typedef interface ISoftKeyboardEventSink ISoftKeyboardEventSink;
#endif 	/* __ISoftKeyboardEventSink_FWD_DEFINED__ */


#ifndef __ISoftKbdWindowEventSink_FWD_DEFINED__
#define __ISoftKbdWindowEventSink_FWD_DEFINED__
typedef interface ISoftKbdWindowEventSink ISoftKbdWindowEventSink;
#endif 	/* __ISoftKbdWindowEventSink_FWD_DEFINED__ */


#ifndef __ITfFnSoftKbd_FWD_DEFINED__
#define __ITfFnSoftKbd_FWD_DEFINED__
typedef interface ITfFnSoftKbd ITfFnSoftKbd;
#endif 	/* __ITfFnSoftKbd_FWD_DEFINED__ */


#ifndef __ITfSoftKbdRegistry_FWD_DEFINED__
#define __ITfSoftKbdRegistry_FWD_DEFINED__
typedef interface ITfSoftKbdRegistry ITfSoftKbdRegistry;
#endif 	/* __ITfSoftKbdRegistry_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_softkbd_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// softkbd.h


// ISoftKbd declarations.

//=--------------------------------------------------------------------------=
// (C) Copyright 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR TFPLIED, INCLUDING BUT NOT LIMITED TO
// THE TFPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#ifndef SOFTKBD_DEFINED
#define SOFTKBD_DEFINED

#include <windows.h>

#define   SOFTKBD_US_STANDARD    1
#define   SOFTKBD_US_ENHANCE     2
#define   SOFTKBD_EURO_STANDARD  3
#define   SOFTKBD_EURO_ENHANCE   4
#define   SOFTKBD_JPN_STANDARD   5
#define   SOFTKBD_JPN_ENHANCE    6

#define   SOFTKBD_CUSTOMIZE_BEGIN  100

#define   SOFTKBD_NO_MORE        0

#define   SOFTKBD_SHOW                    0x00000001
#define   SOFTKBD_DONT_SHOW_ALPHA_BLEND   0x80000000

#ifndef _WINGDI_
typedef /* [uuid] */  DECLSPEC_UUID("8849aa7d-f739-4dc0-bc61-ac48908af060") struct LOGFONTA
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef /* [uuid] */  DECLSPEC_UUID("f8c6fe8a-b112-433a-be87-eb970266ec4b") struct LOGFONTW
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef LOGFONTA LOGFONT;

#endif

#if 0
typedef /* [uuid] */  DECLSPEC_UUID("f0a544c0-1281-4e32-8bf7-a6e012e980d4") UINT_PTR HKL;

#endif


typedef /* [uuid] */  DECLSPEC_UUID("432ec152-51bf-43ca-8f86-50a7e230a069") DWORD KEYID;

typedef /* [public][public][public][public][public][uuid] */  DECLSPEC_UUID("5f46a703-f012-46db-8cda-294e994786e8") 
enum __MIDL___MIDL_itf_softkbd_0000_0001
    {	bkcolor	= 0,
	UnSelForeColor	= 1,
	UnSelTextColor	= 2,
	SelForeColor	= 3,
	SelTextColor	= 4,
	Max_color_Type	= 5
    } 	COLORTYPE;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("711c6200-587a-46ef-9647-5a83638bac00") 
enum __MIDL___MIDL_itf_softkbd_0000_0002
    {	ClickMouse	= 0,
	Hover	= 1,
	Scanning	= 2
    } 	TYPEMODE;

typedef /* [public][public][uuid] */  DECLSPEC_UUID("10b50da7-ce0b-4b83-827f-30c50c9bc5b9") 
enum __MIDL___MIDL_itf_softkbd_0000_0003
    {	TITLEBAR_NONE	= 0,
	TITLEBAR_GRIPPER_HORIZ_ONLY	= 1,
	TITLEBAR_GRIPPER_VERTI_ONLY	= 2,
	TITLEBAR_GRIPPER_BUTTON	= 3
    } 	TITLEBAR_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_softkbd_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_softkbd_0000_v0_0_s_ifspec;

#ifndef __ISoftKbd_INTERFACE_DEFINED__
#define __ISoftKbd_INTERFACE_DEFINED__

/* interface ISoftKbd */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISoftKbd;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3CB00755-7536-4B0A-A213-572EFCAF93CD")
    ISoftKbd : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumSoftKeyBoard( 
            /* [in] */ LANGID langid,
            /* [out] */ DWORD *lpdwKeyboard) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectSoftKeyboard( 
            /* [in] */ DWORD dwKeyboardId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateSoftKeyboardLayoutFromXMLFile( 
            /* [string][in] */ WCHAR *lpszKeyboardDesFile,
            /* [in] */ INT szFileStrLen,
            /* [out] */ DWORD *pdwLayoutCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateSoftKeyboardLayoutFromResource( 
            /* [string][in] */ WCHAR *lpszResFile,
            /* [string][in] */ WCHAR *lpszResType,
            /* [string][in] */ WCHAR *lpszXMLResString,
            /* [out] */ DWORD *lpdwLayoutCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowSoftKeyboard( 
            /* [in] */ INT iShow) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetKeyboardLabelText( 
            /* [in] */ HKL hKl) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetKeyboardLabelTextCombination( 
            /* [in] */ DWORD nModifierCombination) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateSoftKeyboardWindow( 
            /* [in] */ HWND hOwner,
            /* [in] */ TITLEBAR_TYPE Titlebar_type,
            /* [in] */ INT xPos,
            /* [in] */ INT yPos,
            /* [in] */ INT width,
            /* [in] */ INT height) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DestroySoftKeyboardWindow( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSoftKeyboardPosSize( 
            /* [out] */ POINT *lpStartPoint,
            /* [out] */ WORD *lpwidth,
            /* [out] */ WORD *lpheight) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSoftKeyboardColors( 
            /* [in] */ COLORTYPE colorType,
            /* [out] */ COLORREF *lpColor) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSoftKeyboardTypeMode( 
            /* [out] */ TYPEMODE *lpTypeMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSoftKeyboardTextFont( 
            /* [out] */ LOGFONTW *pLogFont) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSoftKeyboardPosSize( 
            /* [in] */ POINT StartPoint,
            /* [in] */ WORD width,
            /* [in] */ WORD height) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSoftKeyboardColors( 
            /* [in] */ COLORTYPE colorType,
            /* [in] */ COLORREF Color) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSoftKeyboardTypeMode( 
            /* [in] */ TYPEMODE TypeMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSoftKeyboardTextFont( 
            /* [in] */ LOGFONTW *pLogFont) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowKeysForKeyScanMode( 
            /* [in] */ KEYID *lpKeyID,
            /* [in] */ INT iKeyNum,
            /* [in] */ BOOL fHighL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AdviseSoftKeyboardEventSink( 
            /* [in] */ DWORD dwKeyboardId,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnadviseSoftKeyboardEventSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftKbdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftKbd * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftKbd * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftKbd * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISoftKbd * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumSoftKeyBoard )( 
            ISoftKbd * This,
            /* [in] */ LANGID langid,
            /* [out] */ DWORD *lpdwKeyboard);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SelectSoftKeyboard )( 
            ISoftKbd * This,
            /* [in] */ DWORD dwKeyboardId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateSoftKeyboardLayoutFromXMLFile )( 
            ISoftKbd * This,
            /* [string][in] */ WCHAR *lpszKeyboardDesFile,
            /* [in] */ INT szFileStrLen,
            /* [out] */ DWORD *pdwLayoutCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateSoftKeyboardLayoutFromResource )( 
            ISoftKbd * This,
            /* [string][in] */ WCHAR *lpszResFile,
            /* [string][in] */ WCHAR *lpszResType,
            /* [string][in] */ WCHAR *lpszXMLResString,
            /* [out] */ DWORD *lpdwLayoutCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShowSoftKeyboard )( 
            ISoftKbd * This,
            /* [in] */ INT iShow);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetKeyboardLabelText )( 
            ISoftKbd * This,
            /* [in] */ HKL hKl);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetKeyboardLabelTextCombination )( 
            ISoftKbd * This,
            /* [in] */ DWORD nModifierCombination);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateSoftKeyboardWindow )( 
            ISoftKbd * This,
            /* [in] */ HWND hOwner,
            /* [in] */ TITLEBAR_TYPE Titlebar_type,
            /* [in] */ INT xPos,
            /* [in] */ INT yPos,
            /* [in] */ INT width,
            /* [in] */ INT height);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DestroySoftKeyboardWindow )( 
            ISoftKbd * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSoftKeyboardPosSize )( 
            ISoftKbd * This,
            /* [out] */ POINT *lpStartPoint,
            /* [out] */ WORD *lpwidth,
            /* [out] */ WORD *lpheight);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSoftKeyboardColors )( 
            ISoftKbd * This,
            /* [in] */ COLORTYPE colorType,
            /* [out] */ COLORREF *lpColor);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSoftKeyboardTypeMode )( 
            ISoftKbd * This,
            /* [out] */ TYPEMODE *lpTypeMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSoftKeyboardTextFont )( 
            ISoftKbd * This,
            /* [out] */ LOGFONTW *pLogFont);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSoftKeyboardPosSize )( 
            ISoftKbd * This,
            /* [in] */ POINT StartPoint,
            /* [in] */ WORD width,
            /* [in] */ WORD height);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSoftKeyboardColors )( 
            ISoftKbd * This,
            /* [in] */ COLORTYPE colorType,
            /* [in] */ COLORREF Color);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSoftKeyboardTypeMode )( 
            ISoftKbd * This,
            /* [in] */ TYPEMODE TypeMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSoftKeyboardTextFont )( 
            ISoftKbd * This,
            /* [in] */ LOGFONTW *pLogFont);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ShowKeysForKeyScanMode )( 
            ISoftKbd * This,
            /* [in] */ KEYID *lpKeyID,
            /* [in] */ INT iKeyNum,
            /* [in] */ BOOL fHighL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AdviseSoftKeyboardEventSink )( 
            ISoftKbd * This,
            /* [in] */ DWORD dwKeyboardId,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk,
            /* [out] */ DWORD *pdwCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnadviseSoftKeyboardEventSink )( 
            ISoftKbd * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ISoftKbdVtbl;

    interface ISoftKbd
    {
        CONST_VTBL struct ISoftKbdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftKbd_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISoftKbd_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISoftKbd_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISoftKbd_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define ISoftKbd_EnumSoftKeyBoard(This,langid,lpdwKeyboard)	\
    (This)->lpVtbl -> EnumSoftKeyBoard(This,langid,lpdwKeyboard)

#define ISoftKbd_SelectSoftKeyboard(This,dwKeyboardId)	\
    (This)->lpVtbl -> SelectSoftKeyboard(This,dwKeyboardId)

#define ISoftKbd_CreateSoftKeyboardLayoutFromXMLFile(This,lpszKeyboardDesFile,szFileStrLen,pdwLayoutCookie)	\
    (This)->lpVtbl -> CreateSoftKeyboardLayoutFromXMLFile(This,lpszKeyboardDesFile,szFileStrLen,pdwLayoutCookie)

#define ISoftKbd_CreateSoftKeyboardLayoutFromResource(This,lpszResFile,lpszResType,lpszXMLResString,lpdwLayoutCookie)	\
    (This)->lpVtbl -> CreateSoftKeyboardLayoutFromResource(This,lpszResFile,lpszResType,lpszXMLResString,lpdwLayoutCookie)

#define ISoftKbd_ShowSoftKeyboard(This,iShow)	\
    (This)->lpVtbl -> ShowSoftKeyboard(This,iShow)

#define ISoftKbd_SetKeyboardLabelText(This,hKl)	\
    (This)->lpVtbl -> SetKeyboardLabelText(This,hKl)

#define ISoftKbd_SetKeyboardLabelTextCombination(This,nModifierCombination)	\
    (This)->lpVtbl -> SetKeyboardLabelTextCombination(This,nModifierCombination)

#define ISoftKbd_CreateSoftKeyboardWindow(This,hOwner,Titlebar_type,xPos,yPos,width,height)	\
    (This)->lpVtbl -> CreateSoftKeyboardWindow(This,hOwner,Titlebar_type,xPos,yPos,width,height)

#define ISoftKbd_DestroySoftKeyboardWindow(This)	\
    (This)->lpVtbl -> DestroySoftKeyboardWindow(This)

#define ISoftKbd_GetSoftKeyboardPosSize(This,lpStartPoint,lpwidth,lpheight)	\
    (This)->lpVtbl -> GetSoftKeyboardPosSize(This,lpStartPoint,lpwidth,lpheight)

#define ISoftKbd_GetSoftKeyboardColors(This,colorType,lpColor)	\
    (This)->lpVtbl -> GetSoftKeyboardColors(This,colorType,lpColor)

#define ISoftKbd_GetSoftKeyboardTypeMode(This,lpTypeMode)	\
    (This)->lpVtbl -> GetSoftKeyboardTypeMode(This,lpTypeMode)

#define ISoftKbd_GetSoftKeyboardTextFont(This,pLogFont)	\
    (This)->lpVtbl -> GetSoftKeyboardTextFont(This,pLogFont)

#define ISoftKbd_SetSoftKeyboardPosSize(This,StartPoint,width,height)	\
    (This)->lpVtbl -> SetSoftKeyboardPosSize(This,StartPoint,width,height)

#define ISoftKbd_SetSoftKeyboardColors(This,colorType,Color)	\
    (This)->lpVtbl -> SetSoftKeyboardColors(This,colorType,Color)

#define ISoftKbd_SetSoftKeyboardTypeMode(This,TypeMode)	\
    (This)->lpVtbl -> SetSoftKeyboardTypeMode(This,TypeMode)

#define ISoftKbd_SetSoftKeyboardTextFont(This,pLogFont)	\
    (This)->lpVtbl -> SetSoftKeyboardTextFont(This,pLogFont)

#define ISoftKbd_ShowKeysForKeyScanMode(This,lpKeyID,iKeyNum,fHighL)	\
    (This)->lpVtbl -> ShowKeysForKeyScanMode(This,lpKeyID,iKeyNum,fHighL)

#define ISoftKbd_AdviseSoftKeyboardEventSink(This,dwKeyboardId,riid,punk,pdwCookie)	\
    (This)->lpVtbl -> AdviseSoftKeyboardEventSink(This,dwKeyboardId,riid,punk,pdwCookie)

#define ISoftKbd_UnadviseSoftKeyboardEventSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseSoftKeyboardEventSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_Initialize_Proxy( 
    ISoftKbd * This);


void __RPC_STUB ISoftKbd_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_EnumSoftKeyBoard_Proxy( 
    ISoftKbd * This,
    /* [in] */ LANGID langid,
    /* [out] */ DWORD *lpdwKeyboard);


void __RPC_STUB ISoftKbd_EnumSoftKeyBoard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_SelectSoftKeyboard_Proxy( 
    ISoftKbd * This,
    /* [in] */ DWORD dwKeyboardId);


void __RPC_STUB ISoftKbd_SelectSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_CreateSoftKeyboardLayoutFromXMLFile_Proxy( 
    ISoftKbd * This,
    /* [string][in] */ WCHAR *lpszKeyboardDesFile,
    /* [in] */ INT szFileStrLen,
    /* [out] */ DWORD *pdwLayoutCookie);


void __RPC_STUB ISoftKbd_CreateSoftKeyboardLayoutFromXMLFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_CreateSoftKeyboardLayoutFromResource_Proxy( 
    ISoftKbd * This,
    /* [string][in] */ WCHAR *lpszResFile,
    /* [string][in] */ WCHAR *lpszResType,
    /* [string][in] */ WCHAR *lpszXMLResString,
    /* [out] */ DWORD *lpdwLayoutCookie);


void __RPC_STUB ISoftKbd_CreateSoftKeyboardLayoutFromResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_ShowSoftKeyboard_Proxy( 
    ISoftKbd * This,
    /* [in] */ INT iShow);


void __RPC_STUB ISoftKbd_ShowSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_SetKeyboardLabelText_Proxy( 
    ISoftKbd * This,
    /* [in] */ HKL hKl);


void __RPC_STUB ISoftKbd_SetKeyboardLabelText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_SetKeyboardLabelTextCombination_Proxy( 
    ISoftKbd * This,
    /* [in] */ DWORD nModifierCombination);


void __RPC_STUB ISoftKbd_SetKeyboardLabelTextCombination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_CreateSoftKeyboardWindow_Proxy( 
    ISoftKbd * This,
    /* [in] */ HWND hOwner,
    /* [in] */ TITLEBAR_TYPE Titlebar_type,
    /* [in] */ INT xPos,
    /* [in] */ INT yPos,
    /* [in] */ INT width,
    /* [in] */ INT height);


void __RPC_STUB ISoftKbd_CreateSoftKeyboardWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_DestroySoftKeyboardWindow_Proxy( 
    ISoftKbd * This);


void __RPC_STUB ISoftKbd_DestroySoftKeyboardWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_GetSoftKeyboardPosSize_Proxy( 
    ISoftKbd * This,
    /* [out] */ POINT *lpStartPoint,
    /* [out] */ WORD *lpwidth,
    /* [out] */ WORD *lpheight);


void __RPC_STUB ISoftKbd_GetSoftKeyboardPosSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_GetSoftKeyboardColors_Proxy( 
    ISoftKbd * This,
    /* [in] */ COLORTYPE colorType,
    /* [out] */ COLORREF *lpColor);


void __RPC_STUB ISoftKbd_GetSoftKeyboardColors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_GetSoftKeyboardTypeMode_Proxy( 
    ISoftKbd * This,
    /* [out] */ TYPEMODE *lpTypeMode);


void __RPC_STUB ISoftKbd_GetSoftKeyboardTypeMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_GetSoftKeyboardTextFont_Proxy( 
    ISoftKbd * This,
    /* [out] */ LOGFONTW *pLogFont);


void __RPC_STUB ISoftKbd_GetSoftKeyboardTextFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_SetSoftKeyboardPosSize_Proxy( 
    ISoftKbd * This,
    /* [in] */ POINT StartPoint,
    /* [in] */ WORD width,
    /* [in] */ WORD height);


void __RPC_STUB ISoftKbd_SetSoftKeyboardPosSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_SetSoftKeyboardColors_Proxy( 
    ISoftKbd * This,
    /* [in] */ COLORTYPE colorType,
    /* [in] */ COLORREF Color);


void __RPC_STUB ISoftKbd_SetSoftKeyboardColors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_SetSoftKeyboardTypeMode_Proxy( 
    ISoftKbd * This,
    /* [in] */ TYPEMODE TypeMode);


void __RPC_STUB ISoftKbd_SetSoftKeyboardTypeMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_SetSoftKeyboardTextFont_Proxy( 
    ISoftKbd * This,
    /* [in] */ LOGFONTW *pLogFont);


void __RPC_STUB ISoftKbd_SetSoftKeyboardTextFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_ShowKeysForKeyScanMode_Proxy( 
    ISoftKbd * This,
    /* [in] */ KEYID *lpKeyID,
    /* [in] */ INT iKeyNum,
    /* [in] */ BOOL fHighL);


void __RPC_STUB ISoftKbd_ShowKeysForKeyScanMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_AdviseSoftKeyboardEventSink_Proxy( 
    ISoftKbd * This,
    /* [in] */ DWORD dwKeyboardId,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ IUnknown *punk,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ISoftKbd_AdviseSoftKeyboardEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbd_UnadviseSoftKeyboardEventSink_Proxy( 
    ISoftKbd * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ISoftKbd_UnadviseSoftKeyboardEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISoftKbd_INTERFACE_DEFINED__ */


#ifndef __ISoftKeyboardEventSink_INTERFACE_DEFINED__
#define __ISoftKeyboardEventSink_INTERFACE_DEFINED__

/* interface ISoftKeyboardEventSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISoftKeyboardEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3ea2bb1d-66e7-47f7-8795-cc03d388f887")
    ISoftKeyboardEventSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnKeySelection( 
            /* [in] */ KEYID KeySelected,
            /* [string][in] */ WCHAR *lpwszLabel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftKeyboardEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftKeyboardEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftKeyboardEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftKeyboardEventSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnKeySelection )( 
            ISoftKeyboardEventSink * This,
            /* [in] */ KEYID KeySelected,
            /* [string][in] */ WCHAR *lpwszLabel);
        
        END_INTERFACE
    } ISoftKeyboardEventSinkVtbl;

    interface ISoftKeyboardEventSink
    {
        CONST_VTBL struct ISoftKeyboardEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftKeyboardEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISoftKeyboardEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISoftKeyboardEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISoftKeyboardEventSink_OnKeySelection(This,KeySelected,lpwszLabel)	\
    (This)->lpVtbl -> OnKeySelection(This,KeySelected,lpwszLabel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKeyboardEventSink_OnKeySelection_Proxy( 
    ISoftKeyboardEventSink * This,
    /* [in] */ KEYID KeySelected,
    /* [string][in] */ WCHAR *lpwszLabel);


void __RPC_STUB ISoftKeyboardEventSink_OnKeySelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISoftKeyboardEventSink_INTERFACE_DEFINED__ */


#ifndef __ISoftKbdWindowEventSink_INTERFACE_DEFINED__
#define __ISoftKbdWindowEventSink_INTERFACE_DEFINED__

/* interface ISoftKbdWindowEventSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISoftKbdWindowEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e4283da5-d425-4f97-8b6a-061a03556e95")
    ISoftKbdWindowEventSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnWindowClose( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnWindowMove( 
            /* [in] */ int xWnd,
            /* [in] */ int yWnd,
            /* [in] */ int width,
            /* [in] */ int height) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftKbdWindowEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftKbdWindowEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftKbdWindowEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftKbdWindowEventSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnWindowClose )( 
            ISoftKbdWindowEventSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnWindowMove )( 
            ISoftKbdWindowEventSink * This,
            /* [in] */ int xWnd,
            /* [in] */ int yWnd,
            /* [in] */ int width,
            /* [in] */ int height);
        
        END_INTERFACE
    } ISoftKbdWindowEventSinkVtbl;

    interface ISoftKbdWindowEventSink
    {
        CONST_VTBL struct ISoftKbdWindowEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftKbdWindowEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISoftKbdWindowEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISoftKbdWindowEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISoftKbdWindowEventSink_OnWindowClose(This)	\
    (This)->lpVtbl -> OnWindowClose(This)

#define ISoftKbdWindowEventSink_OnWindowMove(This,xWnd,yWnd,width,height)	\
    (This)->lpVtbl -> OnWindowMove(This,xWnd,yWnd,width,height)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbdWindowEventSink_OnWindowClose_Proxy( 
    ISoftKbdWindowEventSink * This);


void __RPC_STUB ISoftKbdWindowEventSink_OnWindowClose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISoftKbdWindowEventSink_OnWindowMove_Proxy( 
    ISoftKbdWindowEventSink * This,
    /* [in] */ int xWnd,
    /* [in] */ int yWnd,
    /* [in] */ int width,
    /* [in] */ int height);


void __RPC_STUB ISoftKbdWindowEventSink_OnWindowMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISoftKbdWindowEventSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_softkbd_0358 */
/* [local] */ 

#define   SOFTKBD_TYPE_US_STANDARD    1
#define   SOFTKBD_TYPE_US_SYMBOL      10


extern RPC_IF_HANDLE __MIDL_itf_softkbd_0358_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_softkbd_0358_v0_0_s_ifspec;

#ifndef __ITfFnSoftKbd_INTERFACE_DEFINED__
#define __ITfFnSoftKbd_INTERFACE_DEFINED__

/* interface ITfFnSoftKbd */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnSoftKbd;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e7342d48-573f-4f22-9181-41938b2529c2")
    ITfFnSoftKbd : public ITfFunction
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSoftKbdLayoutId( 
            /* [in] */ DWORD dwLayoutType,
            /* [out] */ DWORD *lpdwLayoutId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetActiveLayoutId( 
            /* [in] */ DWORD dwLayoutId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSoftKbdOnOff( 
            /* [in] */ BOOL fOn) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSoftKbdPosSize( 
            /* [in] */ POINT StartPoint,
            /* [in] */ WORD width,
            /* [in] */ WORD height) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSoftKbdColors( 
            /* [in] */ COLORTYPE colorType,
            /* [in] */ COLORREF Color) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetActiveLayoutId( 
            /* [out] */ DWORD *lpdwLayoutId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSoftKbdOnOff( 
            /* [out] */ BOOL *lpfOn) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSoftKbdPosSize( 
            /* [out] */ POINT *lpStartPoint,
            /* [out] */ WORD *lpwidth,
            /* [out] */ WORD *lpheight) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSoftKbdColors( 
            /* [in] */ COLORTYPE colorType,
            /* [out] */ COLORREF *lpColor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnSoftKbdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnSoftKbd * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnSoftKbd * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnSoftKbd * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnSoftKbd * This,
            /* [out] */ BSTR *pbstrName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSoftKbdLayoutId )( 
            ITfFnSoftKbd * This,
            /* [in] */ DWORD dwLayoutType,
            /* [out] */ DWORD *lpdwLayoutId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetActiveLayoutId )( 
            ITfFnSoftKbd * This,
            /* [in] */ DWORD dwLayoutId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSoftKbdOnOff )( 
            ITfFnSoftKbd * This,
            /* [in] */ BOOL fOn);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSoftKbdPosSize )( 
            ITfFnSoftKbd * This,
            /* [in] */ POINT StartPoint,
            /* [in] */ WORD width,
            /* [in] */ WORD height);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSoftKbdColors )( 
            ITfFnSoftKbd * This,
            /* [in] */ COLORTYPE colorType,
            /* [in] */ COLORREF Color);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetActiveLayoutId )( 
            ITfFnSoftKbd * This,
            /* [out] */ DWORD *lpdwLayoutId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSoftKbdOnOff )( 
            ITfFnSoftKbd * This,
            /* [out] */ BOOL *lpfOn);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSoftKbdPosSize )( 
            ITfFnSoftKbd * This,
            /* [out] */ POINT *lpStartPoint,
            /* [out] */ WORD *lpwidth,
            /* [out] */ WORD *lpheight);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSoftKbdColors )( 
            ITfFnSoftKbd * This,
            /* [in] */ COLORTYPE colorType,
            /* [out] */ COLORREF *lpColor);
        
        END_INTERFACE
    } ITfFnSoftKbdVtbl;

    interface ITfFnSoftKbd
    {
        CONST_VTBL struct ITfFnSoftKbdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnSoftKbd_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnSoftKbd_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnSoftKbd_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnSoftKbd_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnSoftKbd_GetSoftKbdLayoutId(This,dwLayoutType,lpdwLayoutId)	\
    (This)->lpVtbl -> GetSoftKbdLayoutId(This,dwLayoutType,lpdwLayoutId)

#define ITfFnSoftKbd_SetActiveLayoutId(This,dwLayoutId)	\
    (This)->lpVtbl -> SetActiveLayoutId(This,dwLayoutId)

#define ITfFnSoftKbd_SetSoftKbdOnOff(This,fOn)	\
    (This)->lpVtbl -> SetSoftKbdOnOff(This,fOn)

#define ITfFnSoftKbd_SetSoftKbdPosSize(This,StartPoint,width,height)	\
    (This)->lpVtbl -> SetSoftKbdPosSize(This,StartPoint,width,height)

#define ITfFnSoftKbd_SetSoftKbdColors(This,colorType,Color)	\
    (This)->lpVtbl -> SetSoftKbdColors(This,colorType,Color)

#define ITfFnSoftKbd_GetActiveLayoutId(This,lpdwLayoutId)	\
    (This)->lpVtbl -> GetActiveLayoutId(This,lpdwLayoutId)

#define ITfFnSoftKbd_GetSoftKbdOnOff(This,lpfOn)	\
    (This)->lpVtbl -> GetSoftKbdOnOff(This,lpfOn)

#define ITfFnSoftKbd_GetSoftKbdPosSize(This,lpStartPoint,lpwidth,lpheight)	\
    (This)->lpVtbl -> GetSoftKbdPosSize(This,lpStartPoint,lpwidth,lpheight)

#define ITfFnSoftKbd_GetSoftKbdColors(This,colorType,lpColor)	\
    (This)->lpVtbl -> GetSoftKbdColors(This,colorType,lpColor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfFnSoftKbd_GetSoftKbdLayoutId_Proxy( 
    ITfFnSoftKbd * This,
    /* [in] */ DWORD dwLayoutType,
    /* [out] */ DWORD *lpdwLayoutId);


void __RPC_STUB ITfFnSoftKbd_GetSoftKbdLayoutId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfFnSoftKbd_SetActiveLayoutId_Proxy( 
    ITfFnSoftKbd * This,
    /* [in] */ DWORD dwLayoutId);


void __RPC_STUB ITfFnSoftKbd_SetActiveLayoutId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfFnSoftKbd_SetSoftKbdOnOff_Proxy( 
    ITfFnSoftKbd * This,
    /* [in] */ BOOL fOn);


void __RPC_STUB ITfFnSoftKbd_SetSoftKbdOnOff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfFnSoftKbd_SetSoftKbdPosSize_Proxy( 
    ITfFnSoftKbd * This,
    /* [in] */ POINT StartPoint,
    /* [in] */ WORD width,
    /* [in] */ WORD height);


void __RPC_STUB ITfFnSoftKbd_SetSoftKbdPosSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfFnSoftKbd_SetSoftKbdColors_Proxy( 
    ITfFnSoftKbd * This,
    /* [in] */ COLORTYPE colorType,
    /* [in] */ COLORREF Color);


void __RPC_STUB ITfFnSoftKbd_SetSoftKbdColors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfFnSoftKbd_GetActiveLayoutId_Proxy( 
    ITfFnSoftKbd * This,
    /* [out] */ DWORD *lpdwLayoutId);


void __RPC_STUB ITfFnSoftKbd_GetActiveLayoutId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfFnSoftKbd_GetSoftKbdOnOff_Proxy( 
    ITfFnSoftKbd * This,
    /* [out] */ BOOL *lpfOn);


void __RPC_STUB ITfFnSoftKbd_GetSoftKbdOnOff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfFnSoftKbd_GetSoftKbdPosSize_Proxy( 
    ITfFnSoftKbd * This,
    /* [out] */ POINT *lpStartPoint,
    /* [out] */ WORD *lpwidth,
    /* [out] */ WORD *lpheight);


void __RPC_STUB ITfFnSoftKbd_GetSoftKbdPosSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfFnSoftKbd_GetSoftKbdColors_Proxy( 
    ITfFnSoftKbd * This,
    /* [in] */ COLORTYPE colorType,
    /* [out] */ COLORREF *lpColor);


void __RPC_STUB ITfFnSoftKbd_GetSoftKbdColors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnSoftKbd_INTERFACE_DEFINED__ */


#ifndef __ITfSoftKbdRegistry_INTERFACE_DEFINED__
#define __ITfSoftKbdRegistry_INTERFACE_DEFINED__

/* interface ITfSoftKbdRegistry */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSoftKbdRegistry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f5f31f14-fdf0-4d29-835a-46adfe743b78")
    ITfSoftKbdRegistry : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableSoftkbd( 
            LANGID langid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisableSoftkbd( 
            LANGID langid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSoftKbdRegistryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSoftKbdRegistry * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSoftKbdRegistry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSoftKbdRegistry * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnableSoftkbd )( 
            ITfSoftKbdRegistry * This,
            LANGID langid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DisableSoftkbd )( 
            ITfSoftKbdRegistry * This,
            LANGID langid);
        
        END_INTERFACE
    } ITfSoftKbdRegistryVtbl;

    interface ITfSoftKbdRegistry
    {
        CONST_VTBL struct ITfSoftKbdRegistryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSoftKbdRegistry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSoftKbdRegistry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSoftKbdRegistry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSoftKbdRegistry_EnableSoftkbd(This,langid)	\
    (This)->lpVtbl -> EnableSoftkbd(This,langid)

#define ITfSoftKbdRegistry_DisableSoftkbd(This,langid)	\
    (This)->lpVtbl -> DisableSoftkbd(This,langid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfSoftKbdRegistry_EnableSoftkbd_Proxy( 
    ITfSoftKbdRegistry * This,
    LANGID langid);


void __RPC_STUB ITfSoftKbdRegistry_EnableSoftkbd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITfSoftKbdRegistry_DisableSoftkbd_Proxy( 
    ITfSoftKbdRegistry * This,
    LANGID langid);


void __RPC_STUB ITfSoftKbdRegistry_DisableSoftkbd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSoftKbdRegistry_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_softkbd_0360 */
/* [local] */ 


DEFINE_GUID( IID_ISoftKbd, 0x3CB00755, 0x7536, 0x4B0A, 0xA2, 0x13, 0x57, 0x2E, 0xFC, 0xAF, 0x93, 0xCD );
DEFINE_GUID( IID_ISoftKeyboardEventSink,0x3ea2bb1d, 0x66e7, 0x47f7, 0x87, 0x95, 0xcc, 0x03, 0xd3, 0x88, 0xf8, 0x87 );
DEFINE_GUID( IID_ITfFnSoftKbd, 0xe7342d48, 0x573f, 0x4f22, 0x91, 0x81, 0x41, 0x93, 0x8b, 0x25, 0x29, 0xc2);
DEFINE_GUID( IID_ISoftKbdWindowEventSink, 0xe4283da5,0xd425,0x4f97,0x8b, 0x6a,0x06, 0x1a, 0x03, 0x55, 0x6e, 0x95);
DEFINE_GUID( IID_ITfSoftKbdRegistry, 0xf5f31f14, 0xfdf0, 0x4d29, 0x83, 0x5a, 0x46, 0xad, 0xfe, 0x74, 0x3b, 0x78);
DEFINE_GUID( CLSID_SoftKbd,0x1B1A897E, 0xFBEE, 0x41CF, 0x8C, 0x48,0x9B, 0xF7, 0x64, 0xF6, 0x2B, 0x8B);

DEFINE_GUID( CLSID_SoftkbdIMX, 0xf89e9e58, 0xbd2f, 0x4008, 0x9a, 0xc2, 0x0f, 0x81, 0x6c, 0x09, 0xf4, 0xee);

DEFINE_GUID( CLSID_SoftkbdRegistry, 0x6a49950e, 0xce8a, 0x4ef7, 0x88, 0xb4, 0x9d, 0x11, 0x23, 0x66, 0x51, 0x1c );

#endif // SOFTKBD_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_softkbd_0360_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_softkbd_0360_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\computil.cpp ===
//
// computil.cpp
//

#include "private.h"
#include "computil.h"
#include "catutil.h"
#include "helpers.h"

ITfCategoryMgr *GetUIMCat();

//+---------------------------------------------------------------------------
//
//  GetCompartment
//
//----------------------------------------------------------------------------

HRESULT GetCompartment(IUnknown *punk, REFGUID rguidComp, ITfCompartment **ppComp, BOOL fGlobal)
{
    HRESULT hr = E_FAIL;
    ITfCompartmentMgr *pCompMgr = NULL;
    ITfThreadMgr *ptim = NULL;

    Assert(ppComp);
    *ppComp = NULL;

    if (fGlobal)
    {
        if (FAILED(hr = punk->QueryInterface(IID_ITfThreadMgr,
                                                (void **)&ptim)))
             goto Exit;

        if (FAILED(hr = ptim->GetGlobalCompartment(&pCompMgr)))
             goto Exit;
        
    }
    else
    {
        if (FAILED(hr = punk->QueryInterface(IID_ITfCompartmentMgr,
                                                (void **)&pCompMgr)))
             goto Exit;
    }

    if (SUCCEEDED(hr) && pCompMgr)
    {
        hr = pCompMgr->GetCompartment(rguidComp, ppComp);
        pCompMgr->Release();
    }
    else
        hr = E_FAIL;

Exit:
    if (ptim)
       ptim->Release();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  SetCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT SetCompartmentDWORD(TfClientId tid, IUnknown *punk, REFGUID rguidComp, DWORD dw, BOOL fGlobal)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, fGlobal)))
    {
        var.vt = VT_I4;
        var.lVal = dw;
        hr = pComp->SetValue(tid, &var);
        pComp->Release();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  GetCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT GetCompartmentDWORD(IUnknown *punk, REFGUID rguidComp, DWORD *pdw, BOOL fGlobal)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    *pdw = 0;
    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, fGlobal)))
    {
        if ((hr = pComp->GetValue(&var)) == S_OK)
        {
            Assert(var.vt == VT_I4);
            *pdw = var.lVal;
        }
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  ToggleCompartmentDWORD
//
//  Toggle DWORD value between 0 and 1.
//
//----------------------------------------------------------------------------

HRESULT ToggleCompartmentDWORD(TfClientId tid, IUnknown *punk, REFGUID rguidComp, BOOL fGlobal)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, fGlobal)))
    {
        if ((hr = pComp->GetValue(&var)) == S_OK)
        {
            Assert(var.vt == VT_I4);
            var.lVal = !var.lVal;
            hr = pComp->SetValue(tid, &var);
        }
        else
        {
            var.vt = VT_I4;
            var.lVal = 0x01;
            hr = pComp->SetValue(tid, &var);
        }
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  SetCompartmentGUIDATOM
//
//----------------------------------------------------------------------------

HRESULT SetCompartmentGUIDATOM(TfClientId tid, IUnknown *punk, REFGUID rguidComp, TfGuidAtom guidatom, BOOL fGlobal)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, fGlobal)))
    {
        var.vt = VT_I4;
        var.lVal = guidatom;
        hr = pComp->SetValue(tid, &var);
        pComp->Release();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  GetCompartmentGUIDATOM
//
//----------------------------------------------------------------------------

HRESULT GetCompartmentGUIDATOM(IUnknown *punk, REFGUID rguidComp, TfGuidAtom *pga, BOOL fGlobal)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    *pga = 0;
    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, fGlobal)))
    {
        if ((hr = pComp->GetValue(&var)) == S_OK)
        {
            Assert(var.vt == VT_I4);
            *pga = (TfGuidAtom)var.lVal;;
        }
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  SetCompartmentGUID
//
//----------------------------------------------------------------------------

HRESULT SetCompartmentGUID(LIBTHREAD *plt, TfClientId tid, IUnknown *punk, REFGUID rguidComp, REFGUID rguid, BOOL fGlobal)
{
    TfGuidAtom ga;

    if (!GetGUIDATOMFromGUID(plt, rguid, &ga))
        return E_FAIL;

    if (FAILED(SetCompartmentGUIDATOM(tid, punk, rguidComp, ga, fGlobal)))
        return E_FAIL;
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  GetCompartmentGUID
//
//----------------------------------------------------------------------------

HRESULT GetCompartmentGUID(LIBTHREAD *plt, IUnknown *punk, REFGUID rguidComp, GUID *pguid, BOOL fGlobal)
{
    TfGuidAtom ga;
    if (FAILED(GetCompartmentGUIDATOM(punk, rguidComp, &ga, fGlobal)))
        return E_FAIL;
    
    if (GetGUIDFromGUIDATOM(plt, ga, pguid))
        return S_OK;

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  GetCompartmentUnknown
//
//----------------------------------------------------------------------------

HRESULT GetCompartmentUnknown(IUnknown *punk, REFGUID rguidComp, IUnknown **ppunk)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    *ppunk = NULL;
    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, FALSE)))
    {
        if ((hr = pComp->GetValue(&var)) == S_OK)
        {
            Assert(var.vt == VT_UNKNOWN);
            *ppunk = var.punkVal;
        }
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  SetCompartmentUnknown
//
//----------------------------------------------------------------------------

HRESULT SetCompartmentUnknown(TfClientId tid, IUnknown *punk, REFGUID rguidComp, IUnknown *punkPriv)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetCompartment(punk, rguidComp, &pComp, FALSE)))
    {
        var.vt = VT_UNKNOWN;
        var.punkVal = punkPriv;
        hr = pComp->SetValue(tid, &var);
        pComp->Release();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  ClearCompartment
//
//----------------------------------------------------------------------------

HRESULT ClearCompartment(TfClientId tid, IUnknown *punk, REFGUID rguidComp, BOOL fGlobal)
{
    HRESULT hr = E_FAIL;
    ITfCompartmentMgr *pCompMgr = NULL;
    ITfThreadMgr *ptim = NULL;

    if (fGlobal)
    {
        if (FAILED(hr = punk->QueryInterface(IID_ITfThreadMgr,
                                                (void **)&ptim)))
             goto Exit;

        if (FAILED(hr = ptim->GetGlobalCompartment(&pCompMgr)))
             goto Exit;
        
    }
    else
    {
        if (FAILED(hr = punk->QueryInterface(IID_ITfCompartmentMgr,
                                                (void **)&pCompMgr)))
             goto Exit;
    }

    if (SUCCEEDED(hr) && pCompMgr)
    {
        hr = pCompMgr->ClearCompartment(tid, rguidComp);
        pCompMgr->Release();
    }
    else
        hr = E_FAIL;

Exit:
    if (ptim)
       ptim->Release();

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CCompartmentEventSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCompartmentEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCompartmentEventSink))
    {
        *ppvObj = SAFECAST(this, ITfCompartmentEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CCompartmentEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CCompartmentEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCompartmentEventSink::CCompartmentEventSink(CESCALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CCompartmentEventSink"));

    _cRef = 1;

    _pfnCallback = pfnCallback;
    _pv = pv;
}

//+---------------------------------------------------------------------------
//
// OnChange
//
//----------------------------------------------------------------------------

STDAPI CCompartmentEventSink::OnChange(REFGUID rguid)
{
    return _pfnCallback(_pv, rguid);
}

//+---------------------------------------------------------------------------
//
// CCompartmentEventSink::Advise
//
//----------------------------------------------------------------------------

HRESULT CCompartmentEventSink::_Advise(IUnknown *punk, REFGUID rguidComp, BOOL fGlobal)
{
    HRESULT hr;
    ITfSource *pSource = NULL;
    CESMAP *pcesmap;
    pcesmap = _rgcesmap.Append(1);
    if (!pcesmap)
        return E_OUTOFMEMORY;

    hr = E_FAIL;

    if (FAILED(hr = GetCompartment(punk, rguidComp, &pcesmap->pComp, fGlobal)))
        goto Exit;

    if (FAILED(hr = pcesmap->pComp->QueryInterface(IID_ITfSource, (void **)&pSource)))
        goto Exit;

    if (FAILED(hr = pSource->AdviseSink(IID_ITfCompartmentEventSink, (ITfCompartmentEventSink *)this, &pcesmap->dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    if (FAILED(hr))
    {
        int nCnt;
        SafeReleaseClear(pcesmap->pComp);
        nCnt = _rgcesmap.Count();
        _rgcesmap.Remove(nCnt - 1, 1);
    }

    SafeRelease(pSource);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CCompartmentEventSink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CCompartmentEventSink::_Unadvise()
{
    HRESULT hr;
    int nCnt;
    CESMAP *pcesmap;

    hr = E_FAIL;


    nCnt = _rgcesmap.Count();
    pcesmap = _rgcesmap.GetPtr(0);

    while (nCnt)
    {
        ITfSource *pSource = NULL;
        if (FAILED(pcesmap->pComp->QueryInterface(IID_ITfSource, (void **)&pSource)))
            goto Next;

        if (FAILED(pSource->UnadviseSink(pcesmap->dwCookie)))
            goto Next;

Next:
        SafeReleaseClear(pcesmap->pComp);
        SafeRelease(pSource);
        nCnt--;
        pcesmap++;
    }

    hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\strary.h ===
//
// strary.h
//
// CStructArray -- growable struct array
//

#ifndef STRARY_H
#define STRARY_H

#include "private.h"
#include "mem.h"

class CVoidStructArray
{
public:
    CVoidStructArray(int iElemSize)
    {         
        _iElemSize = iElemSize; // Issue: iElemSize should be const in template
        _pb = NULL;
        _cElems = 0;
        _iSize = 0;
    } 
    virtual ~CVoidStructArray() { cicMemFree(_pb); }

    inline void *GetPtr(int iIndex)
    {
        Assert(iIndex >= 0);
        Assert(iIndex <= _cElems); // there's code that uses the first invalid offset for loop termination

        return _pb + (iIndex * _iElemSize);
    }

    BOOL Insert(int iIndex, int cElems);
    void Remove(int iIndex, int cElems);
    void *Append(int cElems)
    {
        return Insert(Count(), cElems) ? GetPtr(Count()-cElems) : NULL;
    }

    int Count()
    { 
        return _cElems; 
    }

    void Clear()
    { 
        cicMemFree(_pb);
        _pb = NULL;
        _cElems = _iSize = 0;
    }

    void Reset(int iMaxSize)
    {
        BYTE *pb;

        _cElems = 0;        

        if (_iSize <= iMaxSize)
            return;
        Assert(_pb != NULL); // _iSize should be zero in this case

        if ((pb = (BYTE *)cicMemReAlloc(_pb, iMaxSize*_iElemSize))
            == NULL)
        {
            return;
        }

        _pb = pb;
        _iSize = iMaxSize;
    }

protected:
    BYTE *_pb;   // the array
    int _cElems;    // num eles in the array
    int _iElemSize;    // num eles in the array
    int _iSize;     // actual size (in void *'s) of the array
};



//
// typesafe version
//
template<class T>
class CStructArray : public CVoidStructArray
{
public:
    CStructArray():CVoidStructArray(sizeof(T)) {}

    T *GetPtr(int iIndex) { return (T *)CVoidStructArray::GetPtr(iIndex); }
    T *Append(int cElems) { return (T *)CVoidStructArray::Append(cElems); }
};

//
// GUID version
//
class CGUIDArray : private CVoidStructArray
{
public:
    CGUIDArray():CVoidStructArray(sizeof(GUID)) {}

    int Count() { return _cElems; }

    GUID *GetPtr(int iIndex) { return (GUID *)CVoidStructArray::GetPtr(iIndex); }
    GUID *Append(int cElems) { return (GUID *)CVoidStructArray::Append(cElems); }

    int InsertGuid(const GUID *pguid)
    {
        int nIndex;
        Find(pguid, &nIndex);
        nIndex++;

        Insert(nIndex, 1);
        *(((GUID *)_pb) + nIndex) = *pguid;
     
        return nIndex;
    }

    int RemoveGuid(const GUID *pguid)
    {
        int nIndex = Find(pguid, NULL);
        if (nIndex == -1)
            return -1;

        Remove(nIndex, 1);

        return nIndex;
    }

    int Find(const GUID *pguid, int *piOut) 
    {
        int iMatch = -1;
        int iMid = -1;
        int iMin = 0;
        int iMax = _cElems;
        LONG l;

        while(iMin < iMax)
        {
            iMid = (iMin + iMax) / 2;
            l = memcmp(pguid, ((GUID *)_pb) + iMid, sizeof(GUID));

            if (l < 0)
            {
                iMax = iMid;
            }
            else if (l > 0)
            {
                iMin = iMid + 1;
            }
            else 
            {
                iMatch = iMid;
                break;
            }
        }

        if (piOut)
        {
            if ((iMatch == -1) && (iMid >= 0))
            {
                if (memcmp(pguid, ((GUID *)_pb) + iMid, sizeof(GUID)) < 0)
                    iMid--;
            }
            *piOut = iMid;
        }
        return iMatch;
    }
};

//
// Ref-counted version.
//
// Note: this is limited, because there's no dtor for struct elements.
//
template<class T>
class CSharedStructArray : public CStructArray<T>
{
public:
    CSharedStructArray() : CStructArray<T>()
    {
        _cRef = 1;
    }

    void _AddRef()
    { 
        _cRef++;
    }

    void _Release()
    {   
        Assert(_cRef > 0);

        if (--_cRef == 0)
        {
            delete this;
        }
    }

private:
    LONG _cRef;
};

#endif // STRARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\dap.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       dap.cpp
//
//  Contents:   CDisplayAttributeProvider
//
//----------------------------------------------------------------------------

#include "private.h"
#include "dap.h"
#include "regsvr.h" // for CLSID_STRLEN 

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

void DllAddRef(void);
void DllRelease(void);

const TCHAR c_szKey[] = TEXT("SOFTWARE\\Microsoft\\");
WCHAR CDisplayAttributeProvider::szProviderName[80] = L"DisplayAttribute";


//+---------------------------------------------------------------------------
//
// CDisplayAttributeProvider
//
//----------------------------------------------------------------------------

CDisplayAttributeProvider::CDisplayAttributeProvider()
{
    _pList = NULL;
}

CDisplayAttributeProvider::~CDisplayAttributeProvider()
{
    CDisplayAttributeInfo *pInfo = _pList;

    while (pInfo)
    {
        CDisplayAttributeInfo *pNext = pInfo->_pNext;
        pInfo->Release();
        pInfo = pNext;
    }
}


//+---------------------------------------------------------------------------
//
// EnumDisplayAttributeInfo
//
//----------------------------------------------------------------------------

STDMETHODIMP CDisplayAttributeProvider::EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum)
{
    HRESULT hr = S_OK;

    if (!(*ppEnum = new CEnumDisplayAttributeInfo(this)))
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//----------------------------------------------------------------------------
//
// GetDisplayAttributeInfo
//
//----------------------------------------------------------------------------

STDMETHODIMP CDisplayAttributeProvider::GetDisplayAttributeInfo(REFGUID guid, ITfDisplayAttributeInfo **ppInfo)
{
    HRESULT hr = E_FAIL;
    CDisplayAttributeInfo *pInfo = _pList;

    while (pInfo)
    {
        if (IsEqualGUID(pInfo->_guid, guid))
        {
            if (SUCCEEDED(hr = pInfo->QueryInterface(IID_ITfDisplayAttributeInfo, (void **)ppInfo)))
            {
                return hr;
            }
        }
        pInfo = pInfo->_pNext;
    }
    return hr;
}

//----------------------------------------------------------------------------
//
// Add
//
//----------------------------------------------------------------------------

void CDisplayAttributeProvider::Add(GUID guid, WCHAR *pszDesc, TF_DISPLAYATTRIBUTE *pda)
{
    CDisplayAttributeInfo *pInfo;

    pInfo = new CDisplayAttributeInfo(guid, pszDesc, pda);
    if (pInfo)
    {
        pInfo->_pNext = _pList;
        _pList = pInfo;
    }
}

//+---------------------------------------------------------------------------
//
// CDisplayAttributeInfo
//
//----------------------------------------------------------------------------

CDisplayAttributeInfo::CDisplayAttributeInfo(GUID guid, WCHAR *pszDesc, TF_DISPLAYATTRIBUTE *pda)
{
    DllAddRef();

    _guid = guid;
    StringCchCopyW(_szDesc, ARRAYSIZE(_szDesc), pszDesc);

    if (FAILED(_OpenAttribute(c_szKey, 
                              CDisplayAttributeProvider::szProviderName, 
                              &guid, &_da)))
        _da = *pda;

    _daDefault = *pda;
    _pNext = NULL;

    _cRef = 1;
}

CDisplayAttributeInfo::~CDisplayAttributeInfo()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfDisplayAttributeInfo))
    {
        *ppvObj = SAFECAST(this, ITfDisplayAttributeInfo *);
    }

    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CDisplayAttributeInfo::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CDisplayAttributeInfo::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

//+---------------------------------------------------------------------------
//
// GetGUID
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::GetGUID(GUID *pguid)
{
    *pguid = _guid;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDescription
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::GetDescription(BSTR *pbstr)
{
    *pbstr = SysAllocString(_szDesc);

    if (*pbstr)
        return S_OK;
    else
        return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetAttributeInfo
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::GetAttributeInfo(TF_DISPLAYATTRIBUTE *pda)
{
    *pda = _da;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetAttributeInfo
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::SetAttributeInfo(const TF_DISPLAYATTRIBUTE *pda)
{
    _da = *pda;
    _SaveAttribute(c_szKey, CDisplayAttributeProvider::szProviderName, 
                   &_guid, &_da);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Reset()
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::Reset()
{
    _da = _daDefault;
    _DeleteAttribute(c_szKey, CDisplayAttributeProvider::szProviderName, &_guid);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SaveAttribute
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::_SaveAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid, TF_DISPLAYATTRIBUTE *pda)

{
    DWORD dw;
    HKEY hKeyDAM;
    HKEY hKeyItem;
    TCHAR achGuid[CLSID_STRLEN+1];

    if (RegCreateKeyEx(HKEY_CURRENT_USER, pszKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    CLSIDToStringA(*pguid, achGuid);
    int cchDescA = wcslen(pszDesc)  * sizeof(WCHAR) + 1;
    char *pszDescA = new char[cchDescA];
    if (pszDescA)
    {
        cchDescA = WideCharToMultiByte(CP_ACP, 0, 
                                       pszDesc, wcslen(pszDesc), 
                                       pszDescA, cchDescA, 
                                       NULL, NULL);
        *(pszDescA + cchDescA) = L'\0';

        if (RegCreateKeyEx(hKeyDAM, pszDescA, 0, NULL, 
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS, 
                           NULL, 
                           &hKeyItem, 
                           &dw) == ERROR_SUCCESS)
        {

            RegSetValueEx(hKeyItem, achGuid, 0, REG_BINARY, 
                              (CONST BYTE *)pda, sizeof(TF_DISPLAYATTRIBUTE));

            RegCloseKey(hKeyItem);
        }

        delete pszDescA;
    }
    RegCloseKey(hKeyDAM);


    return S_OK;
}

//----------------------------------------------------------------------------
//
// OpenAttribute
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::_OpenAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid, TF_DISPLAYATTRIBUTE *pda)

{
    DWORD dw;
    HKEY hKeyDAM;
    HKEY hKeyItem;
    TCHAR achGuid[CLSID_STRLEN+1];
    LONG lret = ERROR_SUCCESS;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, pszKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    CLSIDToStringA(*pguid, achGuid);
    int cchDescA = wcslen(pszDesc)  * sizeof(WCHAR) + 1;
    char *pszDescA = new char[cchDescA];
    if (pszDescA)
    {
        cchDescA = WideCharToMultiByte(CP_ACP, 0, 
                                       pszDesc, wcslen(pszDesc), 
                                       pszDescA, cchDescA, 
                                       NULL, NULL);
        *(pszDescA + cchDescA) = L'\0';

        if (RegCreateKeyEx(hKeyDAM, pszDescA, 0, NULL, 
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS, 
                           NULL, 
                           &hKeyItem, 
                           &dw) == ERROR_SUCCESS)
        {

            DWORD dwType = REG_BINARY;
            DWORD dwSize = sizeof(TF_DISPLAYATTRIBUTE);
            lret = RegQueryValueEx(hKeyItem, achGuid, 0, &dwType, 
                            (BYTE *)pda, &dwSize);

            RegCloseKey(hKeyItem);
        }

        delete pszDescA;
    }
    RegCloseKey(hKeyDAM);

    return (lret == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

//----------------------------------------------------------------------------
//
// DeleteAttribute
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeInfo::_DeleteAttribute(const TCHAR *pszKey, WCHAR *pszDesc, const GUID *pguid)

{
    DWORD dw;
    HKEY hKeyDAM;
    HKEY hKeyItem;
    TCHAR achGuid[CLSID_STRLEN+1];

    if (RegCreateKeyEx(HKEY_CURRENT_USER, pszKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    CLSIDToStringA(*pguid, achGuid);
    int cchDescA = wcslen(pszDesc)  * sizeof(WCHAR) + 1;
    char *pszDescA = new char[cchDescA];
    if (pszDescA)
    {
        cchDescA = WideCharToMultiByte(CP_ACP, 0, 
                                       pszDesc, wcslen(pszDesc), 
                                       pszDescA, cchDescA, 
                                       NULL, NULL);
        *(pszDescA + cchDescA) = L'\0';

        if (RegCreateKeyEx(hKeyDAM, pszDescA, 0, NULL, 
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS, 
                           NULL, 
                           &hKeyItem, 
                           &dw) == ERROR_SUCCESS)
        {
            RegDeleteValue(hKeyItem, achGuid);
            RegCloseKey(hKeyItem);
        }

        delete pszDescA;
    }
    RegCloseKey(hKeyDAM);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
// CEnumDisplayAttributeInfo
//
//----------------------------------------------------------------------------

CEnumDisplayAttributeInfo::CEnumDisplayAttributeInfo(CDisplayAttributeProvider *pProvider)
{
    DllAddRef();

    _pProvider = pProvider;
    _pProvider->AddRef();
    _pCur = _pProvider->_pList;

    _cRef = 1;
}

CEnumDisplayAttributeInfo::~CEnumDisplayAttributeInfo()
{
    _pProvider->Release();
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumTfDisplayAttributeInfo))
    {
        *ppvObj = SAFECAST(this, IEnumTfDisplayAttributeInfo *);
    }

    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CEnumDisplayAttributeInfo::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CEnumDisplayAttributeInfo::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

HRESULT CEnumDisplayAttributeInfo::Clone(IEnumTfDisplayAttributeInfo **ppEnum)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

HRESULT CEnumDisplayAttributeInfo::Next(ULONG ulCount, ITfDisplayAttributeInfo **ppInfo, ULONG *pcFetched)
{
    ULONG cFetched = 0;

    while (cFetched < ulCount)
    {
        if (!_pCur)
            break;

        if (FAILED(_pCur->QueryInterface(IID_ITfDisplayAttributeInfo, (void **)ppInfo)))
            break;

        _pCur= _pCur->_pNext;
        ppInfo++;
        cFetched++;
    }

    if (pcFetched)
        *pcFetched = cFetched;

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

HRESULT CEnumDisplayAttributeInfo::Reset()
{
    _pCur = _pProvider->_pList;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

HRESULT CEnumDisplayAttributeInfo::Skip(ULONG ulCount)
{
    while (ulCount)
    {
        if (!_pCur)
            break;

        _pCur = _pCur->_pNext;
        ulCount--;
    }

    return ulCount ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\validate.h ===
#ifndef _validate_h_
#define _validate_h_

#ifdef __cplusplus
extern "C" {
#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bOK = IS_VALID_READ_PTR(pfoo, CFOO);
 *
 * bOK = IS_VALID_HANDLE(hfoo, FOO);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtrA((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtrW((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPWSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs code pointer - %#08lx", (LPCSTR)#type, (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (IsBadReadPtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (IsBadWritePtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (TraceMsgA(TF_ERROR, "invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags)))), FALSE) : \
    TRUE)

#define IS_VALID_PIDL(ptr) \
   ( !IsValidPIDL(ptr) ? \
    (TraceMsgA(TF_ERROR, "invalid PIDL pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) != (cbExpected) ? \
    (TraceMsgA(TF_ERROR, "invalid size - is %#08lx, expected %#08lx", (cb), (cbExpected)), FALSE) : \
    TRUE)


#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTRA(ptr, cch) \
   (! IsBadStringPtrA((ptr), (UINT_PTR)(cch)))

#define IS_VALID_STRING_PTRW(ptr, cch) \
   (! IsBadStringPtrW((ptr), (UINT_PTR)(cch)))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (! IsBadReadPtr((ptr), sizeof(type)*(len)))

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (! IsBadWritePtr((ptr), sizeof(type)*(len)))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#define IS_VALID_PIDL(ptr) \
   (IsValidPIDL(ptr))

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) == (cbExpected))

#endif

#ifdef UNICODE
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRW
#else
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRA
#endif


/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid H" #type " - %#08lx", (hnd)), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

// Define VSTF if you want to validate the fields in structures.  This
// requires a handler function (of the form IsValid*()) that knows how
// to validate the specific structure type.

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif  // VSTF

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, ##iface)


#if !defined(NO_SHELL_VALIDATION)

BOOL IsValidPathA(LPCSTR pcszPath);
BOOL IsValidPathW(LPCWSTR pcszPath);

BOOL IsValidPathResultA(HRESULT hr, LPCSTR pcszPath, UINT cchPathBufLen);
BOOL IsValidPathResultW(HRESULT hr, LPCWSTR pcszPath, UINT cchPathBufLen);

BOOL IsValidExtensionA(LPCSTR pcszExt);
BOOL IsValidExtensionW(LPCWSTR pcszExt);

BOOL IsValidIconIndexA(HRESULT hr, LPCSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);
BOOL IsValidIconIndexW(HRESULT hr, LPCWSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);

BOOL IsFullPathA(LPCSTR pcszPath);
BOOL IsFullPathW(LPCWSTR pcszPath);

BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix);
BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix);

#ifdef UNICODE
#define IsValidPath         IsValidPathW
#define IsValidPathResult   IsValidPathResultW
#define IsValidExtension    IsValidExtensionW
#define IsValidIconIndex    IsValidIconIndexW
#define IsFullPath          IsFullPathW
#define IsStringContained   IsStringContainedW
#else
#define IsValidPath         IsValidPathA
#define IsValidPathResult   IsValidPathResultA
#define IsValidExtension    IsValidExtensionA
#define IsValidIconIndex    IsValidIconIndexA
#define IsFullPath          IsFullPathA
#define IsStringContained   IsStringContainedA
#endif

BOOL IsValidHANDLE(HANDLE hnd);         // Compares with NULL and INVALID_HANDLE_VALUE
BOOL IsValidHANDLE2(HANDLE hnd);        // Compares with INVALID_HANDLE_VALUE

#define IsValidHEVENT       IsValidHANDLE
#define IsValidHGLOBAL      IsValidHANDLE
#define IsValidHFILE        IsValidHANDLE
#define IsValidHINSTANCE    IsValidHANDLE
#define IsValidHICON        IsValidHANDLE
#define IsValidHKEY         IsValidHANDLE
#define IsValidHMODULE      IsValidHANDLE
#define IsValidHPROCESS     IsValidHANDLE

BOOL
IsValidHWND(
    HWND hwnd);

BOOL
IsValidHMENU(
    HMENU hmenu);

BOOL
IsValidShowCmd(
    int nShow);

// The next few functions must declare the structure types explicitly
// so we don't need to worry about whether <shlobj.h> and/or <comctrlp.h>
// was included before or after us.

BOOL
IsValidPIDL(
    const UNALIGNED struct _ITEMIDLIST *pidl);

BOOL
IsValidHDPA(
    struct _DPA *hdpa);

BOOL
IsValidHDSA(
    struct _DSA *hdsa);

#endif // NO_SHELL_VALIDATION

#ifdef __cplusplus
};
#endif

#endif // _validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\catutil.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       catutil.cpp
//
//
//----------------------------------------------------------------------------

#include "private.h"
#include "globals.h"
#include "catutil.h"

//+---------------------------------------------------------------------------
//
//  GetUIMCat
//
//----------------------------------------------------------------------------
ITfCategoryMgr *GetUIMCat(LIBTHREAD *plt) 
{
    if (!plt)
       return NULL;

    if (plt->_pcat)
       return plt->_pcat;
   
    if (SUCCEEDED(g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&plt->_pcat)))
       return plt->_pcat;

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  IsEqualTFGUIDATOM
//
//----------------------------------------------------------------------------
BOOL IsEqualTFGUIDATOM(LIBTHREAD *plt, TfGuidAtom guidatom, REFGUID rguid)
{
    BOOL fEqual = FALSE;
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (pcat != NULL)
    {
        pcat->IsEqualTfGuidAtom(guidatom, rguid, &fEqual);
    }

    return fEqual;
}

//+---------------------------------------------------------------------------
//
//  GetGUIDFromGUIDATOM
//
//----------------------------------------------------------------------------
BOOL GetGUIDFromGUIDATOM(LIBTHREAD *plt, TfGuidAtom guidatom, GUID *pguid)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (pcat == NULL)
        return FALSE;

    return (pcat->GetGUID(guidatom, pguid) == S_OK);
}

//+---------------------------------------------------------------------------
//
//  GetGUIDATOMFromGUID
//
//----------------------------------------------------------------------------
BOOL GetGUIDATOMFromGUID(LIBTHREAD *plt, REFGUID rguid, TfGuidAtom *pguidatom)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (pcat == NULL)
        return FALSE;

    return (pcat->RegisterGUID(rguid, pguidatom) == S_OK);
}

//+---------------------------------------------------------------------------
//
//  LibEnumCategoriesInItem
//
//----------------------------------------------------------------------------

HRESULT LibEnumCategoriesInItem(LIBTHREAD *plt, REFGUID rguid, IEnumGUID **ppEnum)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (pcat == NULL)
        return E_FAIL;

    return pcat->EnumCategoriesInItem(rguid, ppEnum);
}

//+---------------------------------------------------------------------------
//
//  LibEnumCategoriesInItem 
//
//----------------------------------------------------------------------------

HRESULT LibEnumItemsInCategory(LIBTHREAD *plt, REFGUID rcatid, IEnumGUID **ppEnum)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (pcat == NULL)
        return E_FAIL;

    return pcat->EnumItemsInCategory(rcatid, ppEnum);
}


//+---------------------------------------------------------------------------
//
// RegisterGUIDDescription
//
//----------------------------------------------------------------------------

HRESULT RegisterGUIDDescription(REFCLSID rclsid, REFGUID rcatid, WCHAR *pszDesc)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->RegisterGUIDDescription(rclsid, rcatid, pszDesc, wcslen(pszDesc));
        pcat->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnregisterGUIDDescription
//
//----------------------------------------------------------------------------

HRESULT UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rcatid)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->UnregisterGUIDDescription(rclsid, rcatid);
        pcat->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetGUIDDescription
//
//----------------------------------------------------------------------------

HRESULT GetGUIDDescription(LIBTHREAD *plt, REFCLSID rclsid, BSTR *pbstr)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);
    HRESULT hr = E_FAIL;

    Assert(pcat);

    if (pcat)
        hr = pcat->GetGUIDDescription(rclsid, pbstr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// RegisterGUIDDWORD
//
//----------------------------------------------------------------------------

HRESULT RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rcatid, DWORD dw)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->RegisterGUIDDWORD(rclsid, rcatid, dw);
        pcat->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnregisterGUIDDWORD
//
//----------------------------------------------------------------------------

HRESULT UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rcatid)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->UnregisterGUIDDWORD(rclsid, rcatid);
        pcat->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetGUIDDWORD
//
//----------------------------------------------------------------------------

HRESULT GetGUIDDWORD(LIBTHREAD *plt, REFCLSID rclsid, DWORD *pdw)
{
    ITfCategoryMgr *pcat = GetUIMCat(plt);
    HRESULT hr = E_FAIL;

    Assert(pcat);

    if (pcat)
        hr = pcat->GetGUIDDWORD(rclsid, pdw);

    return hr;
}

//+---------------------------------------------------------------------------
//
// RegisterCategory
//
//----------------------------------------------------------------------------

HRESULT RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->RegisterCategory(rclsid, rcatid, rguid);
        pcat->Release();
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// UnregisterCategory
//
//----------------------------------------------------------------------------

HRESULT UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    ITfCategoryMgr *pcat;
    HRESULT hr;

    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfCategoryMgr, 
                                   (void**)&pcat)))
    {
        hr = pcat->UnregisterCategory(rclsid, rcatid, rguid);
        pcat->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnregisterCategory
//
//----------------------------------------------------------------------------

HRESULT RegisterCategories(REFCLSID rclsid, const REGISTERCAT *pregcat)
{
    while (pregcat->pcatid)
    {
        if (FAILED(RegisterCategory(rclsid, *pregcat->pcatid, *pregcat->pguid)))
            return E_FAIL;
        pregcat++;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnregisterCategory
//
//----------------------------------------------------------------------------

HRESULT UnregisterCategories(REFCLSID rclsid, const REGISTERCAT *pregcat)
{
    while (pregcat->pcatid)
    {
        if (FAILED(UnregisterCategory(rclsid, *pregcat->pcatid, *pregcat->pguid)))
            return E_FAIL;
        pregcat++;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  GetKnownModeBias
//
//----------------------------------------------------------------------------

HRESULT GetKnownModeBias(LIBTHREAD *plt, TfGuidAtom guidatom, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount)
{
    *pcatid = GUID_MODEBIAS_NONE;

    GUID guid;
    ITfCategoryMgr *pcat = GetUIMCat(plt);

    if (!pcat)
        return E_FAIL;

    if (FAILED(pcat->GetGUID(guidatom, &guid)))
        return E_FAIL;

    return pcat->FindClosestCategory(guid, pcatid, ppcatidList, ulCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\inc\xstring.h ===
//
// xstring.h
//
// Unicode/ansi conversion.
//

#ifndef XSTRING_H
#define XSTRING_H

char *UnicodeToAnsi(UINT uCodePage, const WCHAR *pchW, UINT uLenW, char *pchAIn, UINT uSizeA);
WCHAR *AnsiToUnicode(UINT uCodePage, const char *pchA, UINT uLenA, WCHAR *pchWIn, UINT uSizeW);
void BufferAllocFree(void *pBuffer, void *pAllocMem);

#ifdef __cplusplus
class WtoA {
public:
    WtoA(const WCHAR* str)
    {
        int cch = WideCharToMultiByte(CP_ACP, 0, str, -1, NULL, 0, NULL, NULL);
        _pch = new char[cch + 1];
        if (_pch)
            WideCharToMultiByte(CP_ACP, 0, str, -1, _pch, cch, NULL, NULL);
    }

    WtoA(const WCHAR* str, ULONG cch)
    {
        int cchA = WideCharToMultiByte(CP_ACP, 0, str, cch, NULL, 0, NULL, NULL);
        _pch = new char[cchA + 1];
        if (_pch)
            WideCharToMultiByte(CP_ACP, 0, str, cch, _pch, cchA, NULL, NULL);
    }
    ~WtoA()
    {
        delete _pch;
    }

    operator char*()
    {
        if (_pch)
            return _pch;

        Assert(0);
        return "\0";
    }

protected:
    char* _pch;
};

class AtoW {
public:
    AtoW(const char* str)
    {
        int cch = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
        _pch = new WCHAR[cch + 1];
        if (_pch)
            MultiByteToWideChar(CP_ACP, 0, str, -1, _pch, cch);
    }

    AtoW(const char* str, ULONG cch)
    {
        int cchW = MultiByteToWideChar(CP_ACP, 0, str, cch, NULL, 0);
        _pch = new WCHAR[cchW + 1];
        if (_pch)
            MultiByteToWideChar(CP_ACP, 0, str, cch, _pch, cchW);
    }

    ~AtoW()
    {
        delete _pch;
    }

    operator WCHAR*()
    {
        if (_pch)
            return _pch;

        Assert(0);
        return L"\0";
    }

protected:
    WCHAR* _pch;
};

class WCHtoWSZ {
public:
    WCHtoWSZ (const WCHAR *pch, ULONG cch)
    {
        Assert(pch || !cch);

        if (cch == (ULONG)(-1))
            cch = wcslen(pch);

        _pch = new WCHAR[cch + 1];
        if (_pch)
        {
            if (pch && cch)
                memcpy(_pch, pch, cch * sizeof(WCHAR));

            _pch[cch] = L'\0';
        }
    }

    ~WCHtoWSZ ()
    {
        delete _pch;
    }

    operator WCHAR*()
    {
        if (_pch)
            return _pch;

        Assert(0);
        return L"\0";
    }
protected:
    WCHAR* _pch;
};
#endif // __cplusplus

#endif // XSTRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\debug.c ===
//
// Debug squirty functions
//

#ifdef UNIX
// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shellib"
#define SZ_MODULE           "SHELLIB"
#endif

#include "proj.h"
#include "assert.h"
#pragma  hdrstop

#include <platform.h> // LINE_SEPARATOR_STR and friends
#include <winbase.h> // for GetModuleFileNameA

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#define DM_DEBUG              0

#define WINCAPI __cdecl
#define DATASEG_READONLY    ".text"	        // don't use this, compiler does this for you


// Flags for StrToIntEx
#define STIF_DEFAULT        0x00000000L
#define STIF_SUPPORT_HEX    0x00000001L


#if defined(DEBUG) || defined(PRODUCT_PROF)
// (c_szCcshellIniFile and c_szCcshellIniSecDebug are declared in debug.h)
extern CHAR const FAR c_szCcshellIniFile[];
extern CHAR const FAR c_szCcshellIniSecDebug[];
HANDLE g_hDebugOutputFile = INVALID_HANDLE_VALUE;


void ShellDebugAppendToDebugFileA(LPCSTR pszOutputString)
{
    if (g_hDebugOutputFile != INVALID_HANDLE_VALUE)
    {
        DWORD cbWrite = lstrlenA(pszOutputString);
        WriteFile(g_hDebugOutputFile, pszOutputString, cbWrite, &cbWrite, NULL);
    }
}

void ShellDebugAppendToDebugFileW(LPCWSTR pszOutputString)
{
    if (g_hDebugOutputFile != INVALID_HANDLE_VALUE)
    {
        char szBuf[500];

        DWORD cbWrite = WideCharToMultiByte(CP_ACP, 0, pszOutputString, -1, szBuf, ARRAYSIZE(szBuf), NULL, NULL);

        WriteFile(g_hDebugOutputFile, szBuf, cbWrite, &cbWrite, NULL);
    }
}

#if 1 // Looking at the assertW stuff, it delegates already to assertA -- I'm not sure
      // why I really need these wrappers!  (What was broken on my build?  I don't know,
      // but obviously the stuff below was half baked -- there are still problems.)
      // So I'm removing this for now so as to not bother anyone else...  [mikesh]
      //
      // Fixed a few problems and it worked for me. (edwardp)
      //
//
// We cannot link to shlwapi, because comctl32 cannot link to shlwapi.
// Duplicate some functions here so unicode stuff can run on Win95 platforms.
//
VOID MyOutputDebugStringWrapW(LPCWSTR lpOutputString)
{
    if (staticIsOS(OS_NT))
    {
        OutputDebugStringW(lpOutputString);
        ShellDebugAppendToDebugFileW(lpOutputString);
    }
    else
    {
        char szBuf[500];

        WideCharToMultiByte(CP_ACP, 0, lpOutputString, -1, szBuf, ARRAYSIZE(szBuf), NULL, NULL);

        OutputDebugStringA(szBuf);
        ShellDebugAppendToDebugFileA(szBuf);
    }
}
#define OutputDebugStringW MyOutputDebugStringWrapW

VOID MyOutputDebugStringWrapA(LPCSTR lpOutputString)
{
    OutputDebugStringA(lpOutputString);
    ShellDebugAppendToDebugFileA(lpOutputString);
}

#define OutputDebugStringA MyOutputDebugStringWrapA

LPWSTR MyCharPrevWrapW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
{
    if (lpszCurrent == lpszStart)
    {
        return (LPWSTR) lpszStart;
    }
    else
    {
        return (LPWSTR) lpszCurrent - 1;
    }
}
#define CharPrevW MyCharPrevWrapW

int MywvsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, va_list arglist)
{
    if (staticIsOS(OS_NT))
    {
        return wvsprintfW(pwszOut, pwszFormat, arglist);
    }
    else
    {
        char szFormat[500];
        char szOut[1024+40]; // this is how big our ach buffers are
        int iRet;

        WideCharToMultiByte(CP_ACP, 0, pwszFormat, -1, szFormat, ARRAYSIZE(szFormat), NULL, NULL);

        iRet = wvsprintfA(szOut, szFormat, arglist);

        MultiByteToWideChar(CP_ACP, 0, szOut, -1, pwszOut, 1024+40);

        return iRet;
    }
}

#define wvsprintfW MywvsprintfWrapW

int MywsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
    int iRet;
    
    va_list ArgList;
    va_start(ArgList, pwszFormat);

    iRet = MywvsprintfWrapW(pwszOut, pwszFormat, ArgList);

    va_end(ArgList);

    return iRet;
}
#define wsprintfW MywsprintfWrapW

LPWSTR lstrcpyWrapW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    while((*pszDst++ = *pszSrc++));

    return pszDst;
}
#define lstrcpyW lstrcpyWrapW

LPWSTR lstrcatWrapW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    return lstrcpyWrapW(pszDst + lstrlenW(pszDst), pszSrc);
}
#define lstrcatW lstrcatWrapW

#endif 


/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

Cond:    --
*/
static
BOOL
MyStrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    BOOL bRet;
    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = CharNextA(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
        }

    // Or is this hexadecimal?
    //
    pszAdj = CharNextA(psz);
    if ((STIF_SUPPORT_HEX & dwFlags) &&
        *psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;
        psz = CharNextA(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = CharNextA(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }
    else
        {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGIT(*psz); psz = CharNextA(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }

    *piRet = bNeg ? -n : n;

    return bRet;
    }

#endif

#ifdef DEBUG

EXTERN_C g_bUseNewLeakDetection = FALSE;

DWORD g_dwDumpFlags     = 0;        // DF_*

#ifdef FULL_DEBUG
DWORD g_dwTraceFlags    = TF_ERROR | TF_WARNING;     // TF_*
#ifndef BREAK_ON_ASSERTS
#define BREAK_ON_ASSERTS
#endif
#else
DWORD g_dwTraceFlags    = TF_ERROR;  // TF_*
#endif

#ifdef BREAK_ON_ASSERTS
DWORD g_dwBreakFlags    = BF_ASSERT;// BF_*
#else
DWORD g_dwBreakFlags    = 0;        // BF_*
#endif

DWORD g_dwPrototype     = 0;        
DWORD g_dwFuncTraceFlags = 0;       // FTF_*

// TLS slot used to store depth for CcshellFuncMsg indentation

static DWORD g_tlsStackDepth = TLS_OUT_OF_INDEXES;

// Hack stack depth counter used when g_tlsStackDepth is not available

static DWORD g_dwHackStackDepth = 0;

static char g_szIndentLeader[] = "                                                                                ";

static WCHAR g_wszIndentLeader[] = L"                                                                                ";


static CHAR const FAR c_szNewline[] = LINE_SEPARATOR_STR;   // (Deliberately CHAR)
static WCHAR const FAR c_wszNewline[] = TEXTW(LINE_SEPARATOR_STR);

extern CHAR const FAR c_szTrace[];              // (Deliberately CHAR)
extern CHAR const FAR c_szErrorDbg[];           // (Deliberately CHAR)
extern CHAR const FAR c_szWarningDbg[];         // (Deliberately CHAR)
extern WCHAR const FAR c_wszTrace[];
extern WCHAR const FAR c_wszErrorDbg[]; 
extern WCHAR const FAR c_wszWarningDbg[];

extern const CHAR  FAR c_szAssertMsg[];
extern CHAR const FAR c_szAssertFailed[];
extern const WCHAR  FAR c_wszAssertMsg[];
extern WCHAR const FAR c_wszAssertFailed[];

extern CHAR const FAR c_szRip[];
extern CHAR const FAR c_szRipNoFn[];
extern WCHAR const FAR c_wszRip[];
extern WCHAR const FAR c_wszRipNoFn[];


/*-------------------------------------------------------------------------
Purpose: Adds one of the following prefix strings to pszBuf:
           "t   MODULE  "
           "err MODULE  "
           "wrn MODULE  "

         Returns the count of characters written.
*/
int
SetPrefixStringA(
    OUT LPSTR pszBuf,
    IN  DWORD dwFlags)
{
    if (TF_ALWAYS == dwFlags)
        lstrcpyA(pszBuf, c_szTrace);
    else if (IsFlagSet(dwFlags, TF_WARNING))
        lstrcpyA(pszBuf, c_szWarningDbg);
    else if (IsFlagSet(dwFlags, TF_ERROR))
        lstrcpyA(pszBuf, c_szErrorDbg);
    else
        lstrcpyA(pszBuf, c_szTrace);
    return lstrlenA(pszBuf);
}


int
SetPrefixStringW(
    OUT LPWSTR pszBuf,
    IN  DWORD  dwFlags)
{
    if (TF_ALWAYS == dwFlags)
        lstrcpyW(pszBuf, c_wszTrace);
    else if (IsFlagSet(dwFlags, TF_WARNING))
        lstrcpyW(pszBuf, c_wszWarningDbg);
    else if (IsFlagSet(dwFlags, TF_ERROR))
        lstrcpyW(pszBuf, c_wszErrorDbg);
    else
        lstrcpyW(pszBuf, c_wszTrace);
    return lstrlenW(pszBuf);
}


static
LPCSTR
_PathFindFileNameA(
    LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


static
LPCWSTR
_PathFindFileNameW(
    LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}



// BUGBUG (scotth): Use the Ccshell functions.  _AssertMsg and
// _DebugMsg are obsolete.  They will be removed once all the 
// components don't have TEXT() wrapping their debug strings anymore.


void 
WINCAPI 
_AssertMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);

        wvsprintfA(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
WINCAPI 
_AssertMsgW(
    BOOL f, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);

        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
_AssertStrLenW(
    LPCWSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenW(pszStr))
    {                                           
        // MSDEV USERS:  This is not the real assert.  Hit 
        //               Shift-F11 to jump back to the caller.
        DEBUG_BREAK;                                                            // ASSERT
    }
}

void 
_AssertStrLenA(
    LPCSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenA(pszStr))
    {                                           
        // MSDEV USERS:  This is not the real assert.  Hit 
        //               Shift-F11 to jump back to the caller.
        DEBUG_BREAK;                                                            // ASSERT
    }
}

void 
WINCAPI 
_DebugMsgA(
    DWORD flag, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        cch = SetPrefixStringA(ach, flag);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfA(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringA(pszMsg);
        }
        __endexcept

        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
WINCAPI 
_DebugMsgW(
    DWORD flag, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfW(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringW(pszMsg);
        }
        __endexcept

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                        // ASSERT
        }
    }
}


//
//  Smart debug functions
//



/*----------------------------------------------------------
Purpose: Displays assertion string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellAssertFailedA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside,
    BOOL bPopupAssert)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    psz = _PathFindFileNameA(pszFile);
    wsprintfA(ach, c_szAssertFailed, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
    {
        if (bBreakInside)
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays assertion string.

*/
BOOL
CcshellAssertFailedW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside,
    BOOL bPopupAssert)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[1024];    // Some callers use more than 256

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  We can get this
    // if we get an assert in some of the W functions in shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellAssertFailedA(szFile, line, szEval, bBreakInside, bPopupAssert);
    }

    wsprintfW(ach, c_wszAssertFailed, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
    {
        if (bBreakInside)
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for function call trace
         messages.

*/
void
CcshellStackEnter(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));

        TlsSetValue(g_tlsStackDepth, (LPVOID)(ULONG_PTR)(dwDepth + 1));
        }
    else
        {
        g_dwHackStackDepth++;
        }
    }


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for functionc all trace
         messages.

*/
void
CcshellStackLeave(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));

        if (EVAL(0 < dwDepth))
            {
            EVAL(TlsSetValue(g_tlsStackDepth, (LPVOID)(ULONG_PTR)(dwDepth - 1)));
            }
        }
    else
        {
        if (EVAL(0 < g_dwHackStackDepth))
            {
            g_dwHackStackDepth--;
            }
        }
    }


/*----------------------------------------------------------
Purpose: Return the stack depth.

*/
static
DWORD
CcshellGetStackDepth(void)
    {
    DWORD dwDepth;

    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));
        }
    else
        {
        dwDepth = g_dwHackStackDepth;
        }

    return dwDepth;
    }


/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
BOOL
UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
        {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            pwsz = pwszBuf;
            }

        if (pwsz)
            {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppwszWide = pwsz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppwszWide);
            *ppwszWide = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellAssertMsgA
*/
void
CDECL
CcshellAssertMsgW(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
        {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellDebugMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

*/
void
CDECL
CcshellDebugMsgW(
    DWORD flag,
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
        {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT
        }
    }
}


/*-------------------------------------------------------------------------
Purpose: Since the ATL code does not pass in a flag parameter,
         we'll hardcode and check for TF_ATL.
*/
void CDECL ShellAtlTraceW(LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (g_dwTraceFlags & TF_ATL)
    {
        int cch;

        SetPrefixStringW(ach, TF_ATL);
        lstrcatW(ach, L"(ATL) ");
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);
        wvsprintfW(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringW(ach);
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellFuncMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

*/
void
CDECL
CcshellFuncMsgW(
    DWORD flag,
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
    {
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_dwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
        DWORD dwStackDepth;
        LPWSTR pszLeaderEnd;
        WCHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < SIZECHARS(g_szIndentLeader))
            {
            pszLeaderEnd = &g_wszIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_wszIndentLeader[SIZECHARS(g_wszIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfW(ach, L"%s %s", c_wszTrace, g_wszIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Assert failed message only
*/
void
CDECL
CcshellAssertMsgA(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
    }
}


/*----------------------------------------------------------
Purpose: Debug spew
*/
void
CDECL
CcshellDebugMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        cch = SetPrefixStringA(ach, flag);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT
        }
    }
}


/*-------------------------------------------------------------------------
Purpose: Since the ATL code does not pass in a flag parameter,
         we'll hardcode and check for TF_ATL.
*/
void CDECL ShellAtlTraceA(LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (g_dwTraceFlags & TF_ATL)
    {
        int cch;

        SetPrefixStringA(ach, TF_ATL);
        lstrcatA(ach, "(ATL) ");
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
    }
}


/*----------------------------------------------------------
Purpose: Debug spew for function trace calls
*/
void
CDECL
CcshellFuncMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
    {
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_dwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        DWORD dwStackDepth;
        LPSTR pszLeaderEnd;
        CHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < sizeof(g_szIndentLeader))
            {
            pszLeaderEnd = &g_szIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_szIndentLeader[sizeof(g_szIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfA(ach, "%s %s", c_szTrace, g_szIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);
        }
    }


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if hrTest is a failure code.
*/
HRESULT 
TraceHR(
    HRESULT hrTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING &&
        FAILED(hrTest))
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "THR: Failure of \"%s\" at %s, line %d (%#08lx)", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine, hrTest);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  THR  !!!!  THR  !!!!  THR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  THR  !!!!  THR  !!!!  THR !!!
        }
    }
    return hrTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if bTest is false.
*/
BOOL 
TraceBool(
    BOOL bTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING && !bTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TBOOL: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TBOOL  !!!!  TBOOL  !!!!  TBOOL !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TBOOL  !!!!  TBOOL  !!!!  TBOOL !!!
        }
    }
    return bTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if iTest is -1.
*/
int 
TraceInt(
    int iTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING && -1 == iTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TINT: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TINT  !!!!  TINT  !!!!  TINT !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TINT  !!!!  TINT  !!!!  TINT !!!
        }
    }
    return iTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if pvTest is NULL.
*/
LPVOID 
TracePtr(
    LPVOID pvTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING && NULL == pvTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TPTR: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TPTR  !!!!  TPTR  !!!!  TPTR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TPTR  !!!!  TPTR  !!!!  TPTR !!!
        }
    }
    return pvTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if dwTest is a Win32 failure code.
*/
DWORD  
TraceWin32(
    DWORD dwTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING &&
        ERROR_SUCCESS != dwTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TW32: Failure of \"%s\" at %s, line %d (%#08lx)", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine, dwTest);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  THR  !!!!  THR  !!!!  THR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  THR  !!!!  THR  !!!!  THR !!!
        }
    }
    return dwTest;
}



//
//  Debug .ini functions
//


#pragma data_seg(DATASEG_READONLY)

// (These are deliberately CHAR)
CHAR const FAR c_szNull[] = "";
CHAR const FAR c_szZero[] = "0";
CHAR const FAR c_szIniKeyBreakFlags[] = "BreakFlags";
CHAR const FAR c_szIniKeyTraceFlags[] = "TraceFlags";
CHAR const FAR c_szIniKeyFuncTraceFlags[] = "FuncTraceFlags";
CHAR const FAR c_szIniKeyDumpFlags[] = "DumpFlags";
CHAR const FAR c_szIniKeyProtoFlags[] = "Prototype";

#pragma data_seg()


// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCTSTR pszSectionName;
    LPCTSTR pszKeyName;
    LPCTSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    } INTINIKEY;


#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {CHAR sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


#ifdef BOOL_INI_VALUES
/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszTrue[] =
    {
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszFalse[] =
    {
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
    };
#endif


#ifdef BOOL_INI_VALUES
/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
*/
BOOL
PRIVATE
IsIniYes(
    LPCTSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    Assert(psz);

    /* Is the value TRUE? */

    for (i = 0; i < ARRAYSIZE(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAYSIZE(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            TraceMsg(TF_WARNING, "IsIniYes() called on unknown Boolean RHS '%s'.", psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
*/
void
PRIVATE
ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAX_BUF];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, TEXT(""), szRHS,
                                   SIZECHARS(szRHS), c_szCcshellIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s set in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s cleared in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }
#endif



/*----------------------------------------------------------
Purpose: This function converts a wide-char string to a multi-byte
         string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszAnsi will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszWide is NULL, then *ppszAnsi will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
static
BOOL
MyAnsiFromUnicode(
    LPSTR * ppszAnsi,
    LPCWSTR pwszWide,        // NULL to clean up
    LPSTR pszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
        {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)LocalAlloc(LPTR, CbFromCchA(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            Assert(pszBuf);
            psz = pszBuf;
            }

        if (psz)
            {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppszAnsi = psz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppszAnsi);
            *ppszAnsi = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


#ifdef UNICODE

/*----------------------------------------------------------
Purpose: Wide-char wrapper for StrToIntExA.

Returns: see StrToIntExA
*/
static
BOOL
MyStrToIntExW(
    LPCWSTR   pwszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
    {
    // Most strings will simply use this temporary buffer, but AnsiFromUnicode
    // will allocate a buffer if the supplied string is bigger.
    CHAR szBuf[MAX_PATH];

    LPSTR pszString;
    BOOL bRet = MyAnsiFromUnicode(&pszString, pwszString, szBuf, SIZECHARS(szBuf));

    if (bRet)
        {
        bRet = MyStrToIntExA(pszString, dwFlags, piRet);
        MyAnsiFromUnicode(&pszString, NULL, szBuf, 0);
        }
    return bRet;
    }
#endif // UNICODE


#ifdef UNICODE
#define MyStrToIntEx        MyStrToIntExW
#else
#define MyStrToIntEx        MyStrToIntExA
#endif


const TCHAR c_szDimmWrpKey[] = TEXT("SOFTWARE\\Microsoft\\Cicero\\DebugFlag\\");

DWORD GetGlobalDebugFlag(const char *p)
{
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;
    DWORD dw = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szDimmWrpKey, 0,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return dw;
    }


    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);

    if (RegQueryValueEx(hKey, p, 0, &dwType,
                        (LPBYTE)&dw, &dwSize) != ERROR_SUCCESS)
        dw = 0;

    RegCloseKey(hKey);
    return dw;
}


/*----------------------------------------------------------
Purpose: This function reads a .ini file to determine the debug
         flags to set.  The .ini file and section are specified
         by the following manifest constants:

                SZ_DEBUGINI
                SZ_DEBUGSECTION

         The debug variables that are set by this function are
         g_dwDumpFlags, g_dwTraceFlags, g_dwBreakFlags, and
         g_dwFuncTraceFlags, g_dwPrototype.

Returns: TRUE if initialization is successful
*/
BOOL
PUBLIC
CcshellGetDebugFlags(void)
    {
    CHAR szRHS[MAX_PATH];
    int val;

    // BUGBUG (scotth): Yes, COMCTL32 exports StrToIntEx, but I
    //  don't want to cause a dependency delta and force everyone
    //  to get a new comctl32 just because they built debug.
    //  So use a local version of StrToIntEx.

    // Trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwTraceFlags = (DWORD)val;
#ifdef FULL_DEBUG
    else
        g_dwTraceFlags = 3; // default to TF_ERROR and TF_WARNING trace messages
#endif

    g_dwTraceFlags |= GetGlobalDebugFlag(c_szIniKeyTraceFlags);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyTraceFlags, g_dwTraceFlags);

    // Function trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyFuncTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwFuncTraceFlags = (DWORD)val;

    g_dwFuncTraceFlags |= GetGlobalDebugFlag(c_szIniKeyFuncTraceFlags);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyFuncTraceFlags, g_dwFuncTraceFlags);

    // Dump Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyDumpFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwDumpFlags = (DWORD)val;

    g_dwDumpFlags |= GetGlobalDebugFlag(c_szIniKeyDumpFlags);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyDumpFlags, g_dwDumpFlags);

    // Break Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyBreakFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwBreakFlags = (DWORD)val;
#ifdef FULL_DEBUG
    else
        g_dwBreakFlags = 5; // default to break on ASSERT and TF_ERROR
#endif

    g_dwBreakFlags |= GetGlobalDebugFlag(c_szIniKeyBreakFlags);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyBreakFlags, g_dwBreakFlags);

    // Prototype Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyProtoFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwPrototype = (DWORD)val;

    // Are we using the new leak detection from shelldbg.dll?
    GetPrivateProfileStringA("ShellDbg",
                            "NewLeakDetection",
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_bUseNewLeakDetection = BOOLIFY(val);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyProtoFlags, g_dwPrototype);

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "DebugOutputFile",
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);
    if (szRHS != TEXT('\0'))
    {
        g_hDebugOutputFile = CreateFileA(szRHS, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    return TRUE;
    }

#endif // DEBUG

#ifdef PRODUCT_PROF

DWORD g_dwProfileCAP = 0;        

BOOL PUBLIC CcshellGetDebugFlags(void)
{
    CHAR szRHS[MAX_PATH];
    int val;

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "Profile",
                            "",
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwProfileCAP = (DWORD)val;

    return TRUE;
}
#endif // PRODUCT_PROF 


static BOOL g_fWhackPathBuffers = FALSE;
void DEBUGWhackPathBufferA(LPSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, char, cch))
        {
            ZeroMemory(psz, cch*sizeof(char));
        }
    }
}
void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, WCHAR, cch))
        {
            ZeroMemory(psz, cch*sizeof(WCHAR));
        }
    }
}
void DEBUGWhackPathStringA(LPSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, char, cch) && IS_VALID_STRING_PTRA(psz, -1))
        {
            UINT len = lstrlenA(psz);

            if (len >= cch)
            {
                TraceMsg(TF_WARNING, "DEBUGWhackPathStringA: caller of caller passed strange Path string (>MAX_PATH)");
            }
            else
            {
                ZeroMemory(psz+len, (cch-len)*sizeof(char));
            }
        }
    }
}
void DEBUGWhackPathStringW(LPWSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, WCHAR, cch) && IS_VALID_STRING_PTRW(psz, -1))
        {
            UINT len = lstrlenW(psz);

            if (len >= cch)
            {
                TraceMsg(TF_WARNING, "DEBUGWhackPathStringW: caller of caller passed strange Path string (>MAX_PATH)");
            }
            else
            {
                ZeroMemory(psz+len, (cch-len)*sizeof(WCHAR));
            }
        }
    }
}


BOOL GetDebuggerCmd(char *psz)
{
    HKEY hkDebug;
    BOOL bRet = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug"),
                                      0, KEY_READ, &hkDebug))
    {
        TCHAR szDebugger[MAX_PATH * 2];
        DWORD cbString = sizeof(szDebugger);

        if (ERROR_SUCCESS == RegQueryValueEx(hkDebug, TEXT("Debugger"), NULL,
                                 NULL, (LPBYTE) szDebugger, &cbString))
        {
            // Find the first token (which is the debugger exe name/path)

            LPTSTR pszCmdLine = szDebugger;

            if ( *pszCmdLine == TEXT('\"') )
            {
                //
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                //

                while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')) )
                {
                    NULL;
                }

                //
                // If we stopped on a double-quote (usual case), skip
                // over it.
                //

                if ( *pszCmdLine == TEXT('\"') )
                {
                    pszCmdLine++;
                }

            }
            else 
            {
                while (*pszCmdLine > TEXT(' '))
                {
                    pszCmdLine++;
                }
            }

            // Don't need the rest of the args, etc
            *pszCmdLine = TEXT('\0');   

            // If the doctor is in, we don't allow the Debug action

            if (lstrlen(szDebugger) && 
                lstrcmpi(szDebugger, TEXT("drwtsn32")) &&
                lstrcmpi(szDebugger, TEXT("drwtsn32.exe")))
            {
                StringCchCopy(psz, MAX_PATH, szDebugger);
                bRet = TRUE;
            }
        }

    }
    return bRet;
}

typedef BOOL (*ISDEBUGGERPRESENT)(void);
BOOL MyIsDebuggerPresent()
{
    HINSTANCE hInstKernel = GetModuleHandle(TEXT("kernel32"));
    ISDEBUGGERPRESENT pfn;
    pfn = (ISDEBUGGERPRESENT)GetProcAddress(hInstKernel, TEXT("IsDebuggerPresent"));
    if (!pfn)
        return TRUE;

    return (pfn)();
}

BOOL AttachDebugger(DWORD pid)
{
    DWORD dwError = ERROR_SUCCESS;
    TCHAR szCmdline[MAX_PATH * 2];
    TCHAR szDebugger[MAX_PATH * 2];

    STARTUPINFO sinfo =
    {
        sizeof(STARTUPINFO),
    };
    PROCESS_INFORMATION pinfo;

    if (MyIsDebuggerPresent())
         return TRUE;

    if (!GetDebuggerCmd(szDebugger))
        return FALSE;

    wsprintf(szCmdline, TEXT("%s -p %ld"), szDebugger, pid);
 

    if (FALSE == CreateProcess(NULL, //m_pszDebugger,
                               szCmdline,
                               NULL,
                               NULL,
                               FALSE,
                               CREATE_NEW_CONSOLE,
                               NULL,
                               NULL,
                               &sinfo,
                               &pinfo))
    {
        dwError = GetLastError();
    }
    else
    {
        WaitForInputIdle(pinfo.hProcess, 30000);
        CloseHandle(pinfo.hThread);
        CloseHandle(pinfo.hProcess);
    }


    return (ERROR_SUCCESS != dwError) ? FALSE : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\fnprbase.cpp ===
//
// funcprv.cpp
//

#include "private.h"
#include "helpers.h"
#include "fnprbase.h"


//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProviderBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFunctionProviderBase::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFunctionProvider))
    {
        *ppvObj = SAFECAST(this, CFunctionProviderBase *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFunctionProviderBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFunctionProviderBase::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunctionProviderBase::CFunctionProviderBase(TfClientId tid)
{
    _tid = tid;
    _cRef = 1;
    _bstrDesc = NULL;
    _guidType = GUID_NULL;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFunctionProviderBase::~CFunctionProviderBase()
{
    SysFreeString(_bstrDesc);
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CFunctionProviderBase::Init(REFGUID guidType, WCHAR *pszDesc)
{
    _bstrDesc = SysAllocString(pszDesc);
    _guidType = guidType;

    if (_bstrDesc)
        return TRUE;
    else
        return FALSE;
}


//+---------------------------------------------------------------------------
//
// CFunctionProviderBase::Advise
//
//----------------------------------------------------------------------------

HRESULT CFunctionProviderBase::_Advise(ITfThreadMgr *ptim)
{
    HRESULT hr;
    ITfSourceSingle *source = NULL;

    hr = E_FAIL;

    if (FAILED(ptim->QueryInterface(IID_ITfSourceSingle, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSingleSink(_tid, IID_ITfFunctionProvider, this)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFunctionProviderBase::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CFunctionProviderBase::_Unadvise(ITfThreadMgr *ptim)
{
    HRESULT hr;
    ITfSourceSingle *source = NULL;

    hr = E_FAIL;

    if (FAILED(ptim->QueryInterface(IID_ITfSourceSingle, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSingleSink(_tid, IID_ITfFunctionProvider)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CFunctionProviderBase::GetType(GUID *pguid)
{
    *pguid = _guidType;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDescription
//
//----------------------------------------------------------------------------

STDAPI CFunctionProviderBase::GetDescription(BSTR *pbstrDesc)
{
    *pbstrDesc = SysAllocString(_bstrDesc);

    if (*pbstrDesc)
        return S_OK;
    else
        return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetFunction
//
//----------------------------------------------------------------------------

STDAPI CFunctionProviderBase::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    *ppunk = NULL;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "globals.h"

#if 0
HINSTANCE g_hMlang = 0;
HRESULT (*g_pfnGetGlobalFontLinkObject)(IMLangFontLink **) = NULL;
#endif
BOOL g_bComplexPlatform = FALSE;
UINT g_uiACP = CP_ACP;

PFNCOCREATE g_pfnCoCreate = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\dllload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#include "private.h"
// #include <winsock.h>

#ifdef DEBUG
extern DWORD g_dwThreadDllMain;
#endif

#pragma warning(disable:4229)  // No warnings when modifiers used on data

//----------------------------------------------------------------------------
// Delay loading mechanism.  [Stolen from shdocvw.]
//
// This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
//----------------------------------------------------------------------------

#define ENSURE_LOADED(_hinst, _dll, pszfn)   (_hinst ? _hinst : (_hinst = LoadLibrary(#_dll)))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
_ret __stdcall _fn _args                \
{                                       \
    Assert(g_dwThreadDllMain != GetCurrentThreadId());  \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst != NULL, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg(_pfn##_fn != NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    Assert(g_dwThreadDllMain != GetCurrentThreadId());  \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst != NULL, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg(_pfn##_fn != NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UCHAR(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, unsigned char *, _fn, _args, _nargs, 0)
#define DELAY_LOAD_ULONG(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, ULONG, _fn, _args, _nargs, 0)

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    Assert(g_dwThreadDllMain != GetCurrentThreadId());  \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    Assert(g_dwThreadDllMain != GetCurrentThreadId());  \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)

//
// And now the DLLs which are delay loaded
//

// --------- OLEAUT32.DLL ---------------


HINSTANCE g_hinstOLEAUT32 = NULL;

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, RegisterTypeLib,
    (ITypeLib *ptlib, OLECHAR *szFullPath, OLECHAR *szHelpDir),
    (ptlib, szFullPath, szHelpDir));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, LoadTypeLib,
    (const OLECHAR *szFile, ITypeLib **pptlib), (szFile, pptlib));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SetErrorInfo,
   (unsigned long dwReserved, IErrorInfo*perrinfo), (dwReserved, perrinfo));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, LoadRegTypeLib,
    (REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib **pptlib),
    (rguid, wVerMajor, wVerMinor, lcid, pptlib));

#undef VariantClear
#undef VariantCopy

// Use QuickVariantInit instead!
//DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, VariantInit, 
//    (VARIANTARG *pvarg), (pvarg));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantClear,
    (VARIANTARG *pvarg), (pvarg));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantCopy,
    (VARIANTARG *pvargDest, VARIANTARG *pvargSrc), (pvargDest, pvargSrc));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantCopyInd,
    (VARIANT * pvarDest, VARIANTARG * pvargSrc), (pvarDest, pvargSrc));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantChangeType,
    (VARIANTARG *pvargDest, VARIANTARG *pvarSrc, unsigned short wFlags, VARTYPE vt),
    (pvargDest, pvarSrc, wFlags, vt));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocStringLen,
    (const OLECHAR*pch, unsigned int i), (pch, i));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocString,
    (const OLECHAR*pch), (pch));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocStringByteLen,
     (LPCSTR psz, UINT i), (psz, i));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SysStringByteLen,
     (BSTR bstr), (bstr));

DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, SysFreeString, (BSTR bs), (bs));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, DispGetIDsOfNames,
    (ITypeInfo*ptinfo, OLECHAR **rgszNames, UINT cNames, DISPID*rgdispid),
    (ptinfo, rgszNames, cNames, rgdispid));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, CreateErrorInfo,
    (ICreateErrorInfo **pperrinfo), (pperrinfo));

DELAY_LOAD_SAFEARRAY(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayCreateVector,
    (VARTYPE vt, long iBound, ULONG cElements), (vt, iBound, cElements) );

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayAccessData,
    (SAFEARRAY * psa, void HUGEP** ppvData), (psa, ppvData));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayUnaccessData,
    (SAFEARRAY * psa), (psa) );

DELAY_LOAD_SAFEARRAY(g_hinstOLEAUT32, OLEAUT32, SafeArrayCreate,
    (VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound), (vt, cDims, rgsabound));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32, SafeArrayPutElement,
     (SAFEARRAY * psa, LONG * rgIndices, void * pv), (psa, rgIndices, pv));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayGetElemsize,
    (SAFEARRAY * psa), (psa) );

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayGetLBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plLBound),
    (psa,nDim,plLBound));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayGetUBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plUBound),
    (psa,nDim,plUBound));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayGetElement,
    (SAFEARRAY * psa, LONG * rgIndices, void * pv), (psa, rgIndices, pv));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayGetDim,
    (SAFEARRAY * psa), (psa));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayLock,
    (SAFEARRAY * psa), (psa));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayUnlock,
    (SAFEARRAY * psa), (psa));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SysStringLen,
    (BSTR bstr), (bstr));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayDestroy,
    (SAFEARRAY * psa), (psa));

DELAY_LOAD_INT(g_hinstOLEAUT32, OLEAUT32.DLL, DosDateTimeToVariantTime,
    (USHORT wDosDate, USHORT wDosTime, DOUBLE * pvtime), (wDosDate, wDosTime, pvtime));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VarI4FromStr,
    (OLECHAR FAR * strIn, LCID lcid, DWORD dwFlags, LONG * plOut), (strIn, lcid, dwFlags, plOut));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VarUI4FromStr,
    (OLECHAR FAR * strIn, LCID lcid, DWORD dwFlags, ULONG * pulOut), (strIn, lcid, dwFlags, pulOut));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VarR8FromDec,
    (DECIMAL *pdecIn, double *pdbOut), (pdecIn, pdbOut));



#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\iconlib.cpp ===
//
// iconlib.cpp
//

#include "private.h"
#include "cmydc.h"
#include "iconlib.h"

/*   G E T  I C O N  S I Z E   */
/*------------------------------------------------------------------------------

    get icon size

------------------------------------------------------------------------------*/
BOOL GetIconSize( HICON hIcon, SIZE *psize )
{
    ICONINFO IconInfo;
    BITMAP   bmp;
    
    Assert( hIcon != NULL );

    if (!GetIconInfo( hIcon, &IconInfo ))
        return FALSE;

    GetObject( IconInfo.hbmColor, sizeof(bmp), &bmp );
    DeleteObject( IconInfo.hbmColor );
    DeleteObject( IconInfo.hbmMask );

    psize->cx = bmp.bmWidth;
    psize->cy = bmp.bmHeight;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetIconBitmaps
//
//----------------------------------------------------------------------------

BOOL GetIconBitmaps(HICON hIcon, HBITMAP *phbmp, HBITMAP *phbmpMask, SIZE *psize)
{
    CBitmapDC hdcSrc(TRUE);
    CBitmapDC hdcMask(TRUE);
    SIZE size;

    if (psize)
        size = *psize;
    else if (!GetIconSize( hIcon, &size))
        return FALSE;

    hdcSrc.SetCompatibleBitmap(size.cx, size.cy);
    // hdcMask.SetCompatibleBitmap(size.cx, size.cy);
    hdcMask.SetBitmap(size.cx, size.cy, 1, 1);
    RECT rc = {0, 0, size.cx, size.cy};
    FillRect(hdcSrc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
    DrawIconEx(hdcSrc, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);
    DrawIconEx(hdcMask, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_MASK);
    *phbmp = hdcSrc.GetBitmapAndKeep();
    *phbmpMask = hdcMask.GetBitmapAndKeep();
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetIconDIBitmaps
//
//----------------------------------------------------------------------------

BOOL GetIconDIBitmaps(HICON hIcon, HBITMAP *phbmp, HBITMAP *phbmpMask, SIZE *psize)
{
    CBitmapDC hdcSrc(TRUE);
    CBitmapDC hdcMask(TRUE);
    SIZE size;

    if (psize)
        size = *psize;
    else if (!GetIconSize( hIcon, &size))
        return FALSE;

    hdcSrc.SetDIB(size.cx, size.cy);
    // hdcMask.SetCompatibleBitmap(size.cx, size.cy);
    hdcMask.SetBitmap(size.cx, size.cy, 1, 1);
    RECT rc = {0, 0, size.cx, size.cy};
    FillRect(hdcSrc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
    DrawIconEx(hdcSrc, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);
    DrawIconEx(hdcMask, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_MASK);
    *phbmp = hdcSrc.GetBitmapAndKeep();
    *phbmpMask = hdcMask.GetBitmapAndKeep();
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetMenuIconHeight
//
//----------------------------------------------------------------------------

int GetMenuIconHeight(int *pnMenuFontHeghti)
{
    int nMenuFontHeight;
    int cxSmIcon = GetSystemMetrics( SM_CXSMICON );
    NONCLIENTMETRICS ncm;

    int cyMenu = GetSystemMetrics(SM_CYMENU);

    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE);

    nMenuFontHeight = (ncm.lfMenuFont.lfHeight > 0) ?
            ncm.lfMenuFont.lfHeight :
            -ncm.lfMenuFont.lfHeight;

    if (pnMenuFontHeghti)
        *pnMenuFontHeghti = nMenuFontHeight;

    //
    // CUIMENU.CPP uses 8 as TextMargin of dropdown menu.
    //

    if ((nMenuFontHeight + 8 >= cxSmIcon) && (nMenuFontHeight <= cxSmIcon))
        return cxSmIcon;

    return nMenuFontHeight + 4;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\isos.cpp ===
#include "private.h"
#include "proj.h"

/*----------------------------------------------------------
Purpose: Returns TRUE/FALSE if the platform is the given OS_ value.

*/
STDAPI_(BOOL) staticIsOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOA s_osvi;
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;

        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        GetVersionExA(&s_osvi);
    }

    switch (dwOS)
    {
    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
#ifndef UNIX
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
#else
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId) ||
                (VER_PLATFORM_WIN32_UNIX == s_osvi.dwPlatformId));
#endif
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_MEMPHIS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;

    case OS_MEMPHIS_GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 10 &&
                LOWORD(s_osvi.dwBuildNumber) == 1998);
        break;

    case OS_NT4:
#ifndef UNIX
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
#else
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId ||
                (VER_PLATFORM_WIN32_UNIX == s_osvi.dwPlatformId)) &&
#endif
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_NT5:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\dispattr.cpp ===
#include "private.h"
#include "globals.h"
#include "dispattr.h"
#include "proputil.h"
#include "catutil.h"
#include "ctffunc.h"
#include "helpers.h"

CDispAttrPropCache *g_pPropCache = NULL;

//+---------------------------------------------------------------------------
//
//  GetDAMLib
//
//----------------------------------------------------------------------------

ITfDisplayAttributeMgr *GetDAMLib(LIBTHREAD *plt) 
{
   return plt->_pDAM;
}

//+---------------------------------------------------------------------------
//
//  InitDisplayAttributeLib
//
//----------------------------------------------------------------------------

HRESULT InitDisplayAttrbuteLib(LIBTHREAD *plt)
{
    IEnumGUID *pEnumProp = NULL;

    if ( plt == NULL )
        return E_FAIL;

    if (plt->_pDAM)
        plt->_pDAM->Release();

    plt->_pDAM = NULL;

    if (FAILED(g_pfnCoCreate(CLSID_TF_DisplayAttributeMgr,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfDisplayAttributeMgr, 
                                   (void**)&plt->_pDAM)))
    {
        return E_FAIL;
    }

    LibEnumItemsInCategory(plt, GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY, &pEnumProp);

    HRESULT hr;

    //
    // make a database for Display Attribute Properties.
    //
    if (pEnumProp && !g_pPropCache)
    {
         GUID guidProp;
         g_pPropCache = new CDispAttrPropCache;

         if (!g_pPropCache)
         {
              hr = E_OUTOFMEMORY;
              goto Exit;
         }

         //
         // add System Display Attribute first.
         // so no other Display Attribute property overwrite it.
         //
         g_pPropCache->Add(GUID_PROP_ATTRIBUTE);
         while(pEnumProp->Next(1, &guidProp, NULL) == S_OK)
         {
             if (!IsEqualGUID(guidProp, GUID_PROP_ATTRIBUTE))
                 g_pPropCache->Add(guidProp);
         }
    }

    hr = S_OK;

Exit:
    SafeRelease(pEnumProp);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  UninitDisplayAttributeLib
//
//----------------------------------------------------------------------------

HRESULT UninitDisplayAttrbuteLib(LIBTHREAD *plt)
{
    Assert(plt);
    if ( plt == NULL )
        return E_FAIL;

    if (plt->_pDAM)
        plt->_pDAM->Release();

    plt->_pDAM = NULL;

    // if (plt->_fDAMCoInit)
    //     CoUninitialize();
    // 
    // plt->_fDAMCoInit = FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  GetDisplayAttributeTrackPropertyRange
//
//----------------------------------------------------------------------------

HRESULT GetDisplayAttributeTrackPropertyRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfReadOnlyProperty **ppProp, IEnumTfRanges **ppEnum, ULONG *pulNumProp)

{
    ITfReadOnlyProperty *pProp = NULL;
    HRESULT hr = E_FAIL;
    GUID  *pguidProp = NULL;
    const GUID **ppguidProp;
    ULONG ulNumProp = 0;
    ULONG i;

    if (!g_pPropCache)
         goto Exit;
 
    pguidProp = g_pPropCache->GetPropTable();
    if (!pguidProp)
         goto Exit;

    ulNumProp = g_pPropCache->Count();
    if (!ulNumProp)
         goto Exit;

    // TrackProperties wants an array of GUID *'s
    if ((ppguidProp = (const GUID **)cicMemAlloc(sizeof(GUID *)*ulNumProp)) == NULL)
        return E_OUTOFMEMORY;

    for (i=0; i<ulNumProp; i++)
    {
        ppguidProp[i] = pguidProp++;
    }
    
    if (SUCCEEDED(hr = pic->TrackProperties(ppguidProp, 
                                            ulNumProp,
                                            0,
                                            NULL,
                                            &pProp)))
    {
        hr = pProp->EnumRanges(ec, ppEnum, pRange);
        if (SUCCEEDED(hr))
        {
            *ppProp = pProp;
            pProp->AddRef();
        }
        pProp->Release();
    }

    cicMemFree(ppguidProp);

    if (SUCCEEDED(hr))
        *pulNumProp = ulNumProp;
    
Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  GetDisplayAttributeData
//
//----------------------------------------------------------------------------

HRESULT GetDisplayAttributeData(LIBTHREAD *plt, TfEditCookie ec, ITfReadOnlyProperty *pProp, ITfRange *pRange, TF_DISPLAYATTRIBUTE *pda, TfGuidAtom *pguid, ULONG  ulNumProp)
{
    VARIANT var;
    IEnumTfPropertyValue *pEnumPropertyVal;
    TF_PROPERTYVAL tfPropVal;
    GUID guid;
    TfGuidAtom gaVal;
    ITfDisplayAttributeInfo *pDAI;

    HRESULT hr = E_FAIL;

    if (SUCCEEDED(pProp->GetValue(ec, pRange, &var)))
    {
        Assert(var.vt == VT_UNKNOWN);

        if (SUCCEEDED(var.punkVal->QueryInterface(IID_IEnumTfPropertyValue, 
                                                  (void **)&pEnumPropertyVal)))
        {
            while (pEnumPropertyVal->Next(1, &tfPropVal, NULL) == S_OK)
            {
                if (tfPropVal.varValue.vt == VT_EMPTY)
                    continue; // prop has no value over this span

                Assert(tfPropVal.varValue.vt == VT_I4); // expecting GUIDATOMs

                gaVal = (TfGuidAtom)tfPropVal.varValue.lVal;

                GetGUIDFromGUIDATOM(plt, gaVal, &guid);

                if ((plt != NULL) && SUCCEEDED(plt->_pDAM->GetDisplayAttributeInfo(guid, &pDAI, NULL)))
                {
                    //
                    // Issue: for simple apps.
                    // 
                    // Small apps can not show multi underline. So
                    // this helper function returns only one 
                    // DISPLAYATTRIBUTE structure.
                    //
                    if (pda)
                    {
                        pDAI->GetAttributeInfo(pda);
                    }

                    if (pguid)
                    {
                        *pguid = gaVal;
                    }

                    pDAI->Release();
                    hr = S_OK;
                    break;
                    }
            }
            pEnumPropertyVal->Release();
        }
        VariantClear(&var);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  GetAttributeColor
//
//----------------------------------------------------------------------------

HRESULT GetAttributeColor(TF_DA_COLOR *pdac, COLORREF *pcr)
{
    switch (pdac->type)
    {
        case TF_CT_NONE:
            return S_FALSE;

        case TF_CT_SYSCOLOR:
            *pcr = GetSysColor(pdac->nIndex);
            break;

        case TF_CT_COLORREF:
            *pcr = pdac->cr;
            break;
    }
    return S_OK;
    
}

//+---------------------------------------------------------------------------
//
//  SetAttributeColor
//
//----------------------------------------------------------------------------

HRESULT SetAttributeColor(TF_DA_COLOR *pdac, COLORREF cr)
{
    pdac->type = TF_CT_COLORREF;
    pdac->cr = cr;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  SetAttributeSysColor
//
//----------------------------------------------------------------------------

HRESULT SetAttributeSysColor(TF_DA_COLOR *pdac, int nIndex)
{
    pdac->type = TF_CT_SYSCOLOR;
    pdac->nIndex = nIndex;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  ClearAttributeColor
//
//----------------------------------------------------------------------------

HRESULT ClearAttributeColor(TF_DA_COLOR *pdac)
{
    pdac->type = TF_CT_NONE;
    pdac->nIndex = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  GetReconversionFromDisplayAttribute
//
//----------------------------------------------------------------------------

HRESULT GetReconversionFromDisplayAttribute(LIBTHREAD *plt, TfEditCookie ec, ITfThreadMgr *ptim, ITfContext *pic, ITfRange *pRange, ITfFnReconversion **ppReconv, ITfDisplayAttributeMgr *pDAM)
{
    IEnumTfRanges *epr = NULL;
    ITfReadOnlyProperty *pProp;
    ITfRange *proprange;
    ULONG ulNumProp;
    HRESULT hr = E_FAIL;

    //
    // get an enumorator
    //
    if (FAILED(GetDisplayAttributeTrackPropertyRange(ec, pic, pRange, &pProp, &epr, &ulNumProp)))
        goto Exit;


    //
    // Get display attribute of the first proprange.
    //
    if (epr->Next(1, &proprange, NULL) == S_OK)
    {
        ITfRange *rangeTmp = NULL;
        TfGuidAtom guidatom;
        if (SUCCEEDED(GetDisplayAttributeData(plt, ec, pProp, proprange, NULL, &guidatom, ulNumProp)))
        {
            CLSID clsid;
            GUID guid;
            if (GetGUIDFromGUIDATOM(plt, guidatom, &guid) &&
                SUCCEEDED(pDAM->GetDisplayAttributeInfo(guid, NULL, &clsid)))
            {
                ITfFunctionProvider *pFuncPrv;
                if (SUCCEEDED(ptim->GetFunctionProvider(clsid, &pFuncPrv)))
                {
                    hr = pFuncPrv->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)ppReconv);
                    pFuncPrv->Release();
                }
            }
        }
        proprange->Release();
    }
    epr->Release();

    pProp->Release();

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\kes.cpp ===
//
// kes.cpp
//

#include "private.h"
#include "helpers.h"
#include "kes.h"

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfKeyEventSink))
    {
        *ppvObj = this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CKeyEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CKeyEventSink::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CKeyEventSink::CKeyEventSink(KESCALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CKeyEventSink"));

    _pfnPreKeyCallback = NULL;
    _pfnCallback = pfnCallback;
    _pv = pv;
    _cRef = 1;
}

CKeyEventSink::CKeyEventSink(KESCALLBACK pfnCallback, KESPREKEYCALLBACK pfnPreKeyCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CKeyEventSink"));

    _pfnCallback = pfnCallback;
    _pfnPreKeyCallback = pfnPreKeyCallback;
    _pv = pv;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CKeyEventSink::~CKeyEventSink()
{
}

//+---------------------------------------------------------------------------
//
// OnTestKeyDown
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnTestKeyDown(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    return _pfnCallback(KES_CODE_KEYDOWN | KES_CODE_TEST, pic, wParam, lParam, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// OnKeyDown
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnKeyDown(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    return _pfnCallback(KES_CODE_KEYDOWN, pic, wParam, lParam, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// OnTestKeyUp
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnTestKeyUp(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    return _pfnCallback(KES_CODE_KEYUP | KES_CODE_TEST, pic, wParam, lParam, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// OnKeyUp
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnKeyUp(ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    return _pfnCallback(KES_CODE_KEYUP, pic, wParam, lParam, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// SetFocus
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnSetFocus(BOOL fForeground)
{
    return _pfnCallback(KES_CODE_FOCUS, NULL, fForeground, 0, NULL, _pv);
}

//+---------------------------------------------------------------------------
//
// OnPreservedKey
//
//----------------------------------------------------------------------------

STDAPI CKeyEventSink::OnPreservedKey(ITfContext *pic, REFGUID rguid, BOOL *pfEaten)
{
    if (!_pfnPreKeyCallback)
         return E_NOTIMPL;

    return _pfnPreKeyCallback(pic, rguid, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// Register
//
//----------------------------------------------------------------------------

HRESULT CKeyEventSink::_Register(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey)
{
    HRESULT hr;
    ITfKeystrokeMgr *pKeyMgr;

    Assert(_pfnPreKeyCallback);

    if (FAILED(ptim->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeyMgr)))
        return E_FAIL;

    hr = E_FAIL;

    while (pprekey->pguid)
    {
        if (FAILED(pKeyMgr->PreserveKey(tid, 
                                        *pprekey->pguid,
                                        &pprekey->tfpk,
                                        pprekey->psz,
                                        wcslen(pprekey->psz))))
            goto Exit;

        pprekey++;
    }

    ptim->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(pKeyMgr);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CKeyEventSink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CKeyEventSink::_Unregister(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey)
{
    HRESULT hr;
    ITfKeystrokeMgr *pKeyMgr = NULL;

    hr = E_FAIL;

    Assert(_pfnPreKeyCallback);

    if (FAILED(ptim->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeyMgr)))
        goto Exit;

    while (pprekey->pguid)
    {
        if (FAILED(pKeyMgr->UnpreserveKey(*pprekey->pguid, &pprekey->tfpk)))
            goto Exit;

        pprekey++;
    }

    hr = S_OK;
    SafeRelease(ptim);

Exit:
    SafeRelease(pKeyMgr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\init.cpp ===
//
// init.cpp
//

#include "private.h"
#include "immxutil.h"
#include "globals.h"
#include "dispattr.h"

HINSTANCE g_lib_hOle32 = 0;

//+---------------------------------------------------------------------------
//
// TFInitLib
//
//----------------------------------------------------------------------------

BOOL TFInitLib(void)
{
    return TFInitLib_PrivateForCiceroOnly(NULL);
}

// NB: this is going away once we cleanup/separate the private/public libs
BOOL TFInitLib_PrivateForCiceroOnly(PFNCOCREATE pfnCoCreate)
{
    if ((g_pfnCoCreate = pfnCoCreate) == NULL)
    {
        g_lib_hOle32 = LoadSystemLibrary(TEXT("ole32.dll"));

        if (g_lib_hOle32 == NULL)
        {
            Assert(0);
            return FALSE;
        }

        g_pfnCoCreate = (PFNCOCREATE)GetProcAddress(g_lib_hOle32, TEXT("CoCreateInstance"));

        if (g_pfnCoCreate == NULL)
        {
            Assert(0);
            FreeLibrary(g_lib_hOle32);
            g_lib_hOle32 = 0;
            return FALSE;
        }
    }

    g_uiACP = GetACP();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// TFUninitLib
//
//----------------------------------------------------------------------------

void TFUninitLib(void)
{
    if (g_pPropCache)
        delete g_pPropCache;

    g_pPropCache = NULL;

#if 0
    if (g_hMlang != 0) // Issue: get rid of this and g_cs if xml lib goes away
    {
        // Issue: we want to call this from PROCESSDETACH to 
        //         clean up library. So we don't call FreeLibrary here.
        // FreeLibrary(g_hMlang);
        g_hMlang = 0;
        g_pfnGetGlobalFontLinkObject = NULL;
    }
    Assert(g_pfnGetGlobalFontLinkObject == NULL);
#endif

    // don't free this lib!  people call us from process detach
    //FreeLibrary(g_lib_hOle32);
}

//+---------------------------------------------------------------------------
//
// TFUninitLib_Thread
//
//----------------------------------------------------------------------------

void TFUninitLib_Thread(LIBTHREAD *plt)
{
    if (plt == NULL )  
        return;

    if (plt->_pcat)
        plt->_pcat->Release();
    plt->_pcat = NULL;

    if (plt->_pDAM)
        plt->_pDAM->Release();
    plt->_pDAM = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\mes.cpp ===
//
// mes.cpp
//

#include "private.h"
#include "mes.h"

//////////////////////////////////////////////////////////////////////////////
//
// CMouseSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CMouseSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfMouseSink))
    {
        *ppvObj = SAFECAST(this, CMouseSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CMouseSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CMouseSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CMouseSink::CMouseSink(MOUSECALLBACK pfnCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CMouseSink"));

    _cRef = 1;
    _pfnCallback = pfnCallback;
    _pv = pv;
    Assert(_pic == NULL);
}

//+---------------------------------------------------------------------------
//
// OnMouseEvent
//
//----------------------------------------------------------------------------

STDAPI CMouseSink::OnMouseEvent(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten)
{
    return _pfnCallback(uEdge, uQuadrant, dwBtnStatus, pfEaten, _pv);
}

//+---------------------------------------------------------------------------
//
// CMouseSink::Advise
//
//----------------------------------------------------------------------------

HRESULT CMouseSink::_Advise(ITfRange *range, ITfContext *pic)
{
    HRESULT hr;
    ITfMouseTracker *tracker = NULL;

    Assert(_pic == NULL);
    hr = E_FAIL;

    if (FAILED(pic->QueryInterface(IID_ITfMouseTracker, (void **)&tracker)))
        goto Exit;

    if (FAILED(tracker->AdviseMouseSink(range, this, &_dwCookie)))
        goto Exit;

    _pic = pic;
    _pic->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(tracker);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CMouseSink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CMouseSink::_Unadvise()
{
    HRESULT hr;
    ITfMouseTracker *tracker = NULL;

    hr = E_FAIL;

    if (_pic == NULL)
        goto Exit;

    if (FAILED(_pic->QueryInterface(IID_ITfMouseTracker, (void **)&tracker)))
        goto Exit;

    if (FAILED(tracker->UnadviseMouseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(tracker);
    SafeReleaseClear(_pic);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\immxutil.cpp ===
#include "private.h"
#include "immxutil.h"
#include "helpers.h"
#include "regsvr.h"

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//+---------------------------------------------------------------------------
//
// GetTextExtInActiveView
//
//	Get a range text extent from the active view of a document mgr.
//----------------------------------------------------------------------------

HRESULT GetTextExtInActiveView(TfEditCookie ec, ITfRange *pRange, RECT *prc, BOOL *pfClipped)
{
    ITfContext *pic;
    ITfContextView *pView;
    HRESULT hr;

    // do the deref: range->ic->defView->GetTextExt()

    if (pRange->GetContext(&pic) != S_OK)
        return E_FAIL;

    hr = pic->GetActiveView(&pView);
    pic->Release();

    if (hr != S_OK)
        return E_FAIL;

    hr = pView->GetTextExt(ec, pRange, prc, pfClipped);
    pView->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// IsActiveView
//
// Returns TRUE iff pView is the active view in the specified context.
//----------------------------------------------------------------------------

BOOL IsActiveView(ITfContext *pic, ITfContextView *pView)
{
    ITfContextView *pActiveView;
    BOOL fRet;

    if (pic->GetActiveView(&pActiveView) != S_OK)
        return FALSE;

    fRet = IdentityCompare(pActiveView, pView);

    pActiveView->Release();

    return fRet;
}

//+---------------------------------------------------------------------------
//
// ShiftToOrClone
//
//----------------------------------------------------------------------------

BOOL ShiftToOrClone(IAnchor **ppaDst, IAnchor *paSrc)
{
    if (*ppaDst == paSrc)
        return TRUE;

    if (*ppaDst == NULL)
    {
        paSrc->Clone(ppaDst);
    }
    else
    {
        (*ppaDst)->ShiftTo(paSrc);
    }

    return (*ppaDst != NULL);
}

//+---------------------------------------------------------------------------
//
// AsciiToNum
//
//----------------------------------------------------------------------------

DWORD AsciiToNum( char *pszAscii)
{
   DWORD dwNum = 0;

   for (; *pszAscii; pszAscii++) {
       if (*pszAscii >= '0' && *pszAscii <= '9') {
           dwNum = (dwNum << 4) | (*pszAscii - '0');
       } else if (*pszAscii >= 'A' && *pszAscii <= 'F') {
           dwNum = (dwNum << 4) | (*pszAscii - 'A' + 0x000A);
       } else if (*pszAscii >= 'a' && *pszAscii <= 'f') {
           dwNum = (dwNum << 4) | (*pszAscii - 'a' + 0x000A);
       } else {
           return (0);
       }
   }

   return (dwNum);
}

//+---------------------------------------------------------------------------
//
// AsciiToNumDec
//
//----------------------------------------------------------------------------

BOOL AsciiToNumDec(char *pszAscii, DWORD *pdw)
{
    *pdw = 0;

   for (; *pszAscii; pszAscii++)
   {
       if (*pszAscii >= '0' && *pszAscii <= '9')
       {
           *pdw *= 10;
           *pdw += (*pszAscii - '0');
       }
       else
       {
           *pdw = 0;
           return FALSE;
       }
   }

   return TRUE;
}

//+---------------------------------------------------------------------------
//
// NumToA
//
//----------------------------------------------------------------------------

void NumToA(DWORD dw, char *psz)
{
    int n = 7;
    while (n >= 0)
    {
        BYTE b = (BYTE)(dw >> (n * 4)) & 0x0F;
        if (b < 0x0A)
           *psz = (char)('0' + b);
        else 
           *psz = (char)('A' + b - 0x0A);
        psz++;
        n--;
    }
    *psz = L'\0';

    return;
}

//+---------------------------------------------------------------------------
//
// WToNum
//
//----------------------------------------------------------------------------

DWORD WToNum( WCHAR *psz)
{
   DWORD dwNum = 0;

   for (; *psz; psz++) {
       if (*psz>= L'0' && *psz<= L'9') {
           dwNum = (dwNum << 4) | (*psz - L'0');
       } else if (*psz>= L'A' && *psz<= L'F') {
           dwNum = (dwNum << 4) | (*psz - L'A' + 0x000A);
       } else if (*psz>= L'a' && *psz<= L'f') {
           dwNum = (dwNum << 4) | (*psz - L'a' + 0x000A);
       } else {
           return (0);
       }
   }

   return (dwNum);
}

//+---------------------------------------------------------------------------
//
// NumToW
//
//----------------------------------------------------------------------------

void NumToW(DWORD dw, WCHAR *psz)
{
    int n = 7;
    while (n >= 0)
    {
        BYTE b = (BYTE)(dw >> (n * 4)) & 0x0F;
        if (b < 0x0A)
           *psz = (WCHAR)(L'0' + b);
        else 
           *psz = (WCHAR)(L'A' + b - 0x0A);
        psz++;
        n--;
    }
    *psz = L'\0';

    return;
}

//+---------------------------------------------------------------------------
//
// GetTopIC
//
//----------------------------------------------------------------------------

BOOL GetTopIC(ITfDocumentMgr *pdim, ITfContext **ppic)
{
    HRESULT hr;

    *ppic = NULL;

    if (pdim == NULL)
        return FALSE;

    hr = pdim->GetTop(ppic);

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// AdjustAnchor
//
//----------------------------------------------------------------------------

LONG AdjustAnchor(LONG ichAdjStart, LONG ichAdjEnd, LONG cchNew, LONG ichAnchor, BOOL fGravityRight)
{
    int cchAdjust;

    // if the adjustment is entirely to the right, nothing to do
    if (ichAdjStart > ichAnchor)
        return ichAnchor;

    // if the adjustment was a simple replacement -- no size change -- nothing to do
    if ((cchAdjust = cchNew - (ichAdjEnd - ichAdjStart)) == 0)
        return ichAnchor;

    if (ichAdjStart == ichAnchor && ichAdjEnd == ichAnchor)
    {
        // inserting at the anchor pos
        Assert(cchAdjust > 0);
        if (fGravityRight)
        {
            ichAnchor += cchAdjust;
        }
    }
    else if (ichAdjEnd <= ichAnchor)
    {
        // the adjustment is to the left of the anchor, just add the delta
        ichAnchor += cchAdjust;
    }
    else if (cchAdjust < 0)
    {
        // need to slide the anchor back if it's within the deleted range of text
        ichAnchor = min(ichAnchor, ichAdjEnd + cchAdjust);
    }
    else // cchAdjust > 0
    {
        // there's nothing to do
    }

    return ichAnchor;
}

//+---------------------------------------------------------------------------
//
// CompareRanges
//
//----------------------------------------------------------------------------

int CompareRanges(TfEditCookie ec, ITfRange *pRangeSrc, ITfRange *pRangeCmp)
{
    int nRet = CR_ERROR;
    BOOL fEqual;
    LONG l;

    pRangeCmp->CompareEnd(ec, pRangeSrc, TF_ANCHOR_START, &l);
    if (l <= 0)
        return CR_LEFT;

    pRangeSrc->CompareEnd(ec, pRangeCmp, TF_ANCHOR_START, &l);
    if (l < 0) // incl char to right
        return CR_RIGHT;

    if (pRangeSrc->IsEqualStart(ec, pRangeCmp, TF_ANCHOR_START, &fEqual) == S_OK && fEqual &&
        pRangeSrc->IsEqualEnd(ec, pRangeCmp, TF_ANCHOR_END, &fEqual) == S_OK && fEqual)
    {
        return CR_EQUAL;
    }

    pRangeSrc->CompareStart(ec, pRangeCmp, TF_ANCHOR_START, &l);
    if (l <= 0)
    {
        pRangeSrc->CompareEnd(ec, pRangeCmp, TF_ANCHOR_END, &l);
        if (l < 0)
            return CR_RIGHTMEET;
        else
            return CR_PARTIAL;
    }
    else
    {
        pRangeSrc->CompareEnd(ec, pRangeCmp, TF_ANCHOR_END, &l);
        if (l < 0)
            return CR_INCLUSION;
        else
            return CR_LEFTMEET;
    }

    return nRet;
}

//+---------------------------------------------------------------------------
//
// GetRangeForWholeDoc
//
//----------------------------------------------------------------------------

HRESULT GetRangeForWholeDoc(TfEditCookie ec, ITfContext *pic, ITfRange **pprange)
{
    HRESULT hr;
    ITfRange *pRangeEnd = NULL;
    ITfRange *pRange = NULL;

    *pprange = NULL;

    if (FAILED(hr = pic->GetStart(ec,&pRange)))
        return hr;

    if (FAILED(hr = pic->GetEnd(ec,&pRangeEnd)))
        return hr;

    hr = pRange->ShiftEndToRange(ec, pRangeEnd, TF_ANCHOR_END);
    pRangeEnd->Release();

    if (SUCCEEDED(hr))
        *pprange = pRange;
    else
        pRange->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// CompareGUIDs
//
//----------------------------------------------------------------------------
__inline int CompUnsigned(ULONG u1, ULONG u2)
{
    if (u1 == u2)
        return 0;

    return (u1 > u2) ? 1 : -1;
}

int CompareGUIDs(REFGUID guid1, REFGUID guid2)
{
    int i;
    int nRet;

    if (nRet = CompUnsigned(guid1.Data1, guid2.Data1))
        return nRet;

    if (nRet = CompUnsigned(guid1.Data2, guid2.Data2))
        return nRet;

    if (nRet = CompUnsigned(guid1.Data3, guid2.Data3))
        return nRet;

    for (i = 0; i < 8; i++)
    {
        if (nRet = CompUnsigned(guid1.Data4[i], guid2.Data4[i]))
            return nRet;
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
// IsDisabledTextServices
//
//----------------------------------------------------------------------------
BOOL IsDisabledTextServices(void)
{
    static const TCHAR c_szCTFKey[]     = TEXT("SOFTWARE\\Microsoft\\CTF");
    static const TCHAR c_szDiableTim[]  = TEXT("Disable Thread Input Manager");

    HKEY hKey;

    if (RegOpenKey(HKEY_CURRENT_USER, c_szCTFKey, &hKey) == ERROR_SUCCESS)
    {
        DWORD cb;
        DWORD dwDisableTim = 0;

        cb = sizeof(DWORD);

        RegQueryValueEx(hKey,
                        c_szDiableTim,
                        NULL,
                        NULL,
                        (LPBYTE)&dwDisableTim,
                        &cb);

        RegCloseKey(hKey);

        //
        // Ctfmon disabling flag is set, so return fail CreateInstance.
        //
        if (dwDisableTim)
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// IsTIPClsidEnabled
//
//----------------------------------------------------------------------------
const TCHAR c_szLanguageProfile[]   = TEXT("\\LanguageProfile");
const TCHAR c_szCTFTipPath[]        = TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");

BOOL IsTIPClsidEnabled(
    HKEY hkeyTop,
    LPTSTR szTipClsid,
    BOOL *bExistEnable)
{
    BOOL bRet = FALSE;
    HKEY hkeyTipLang;
    HKEY hkeyTipLangid;
    HKEY hkeyTipGuid;
    UINT uIndex;
    UINT uIndex2;
    DWORD cb;
    DWORD cchLangid;
    DWORD cchGuid;
    DWORD dwEnableTIP = 0;
    LPTSTR pszGuid;
    LPTSTR pszLangid;
    TCHAR szTIPLangid[15];
    TCHAR szTIPGuid[128];
    TCHAR szTIPClsidLang[MAX_PATH];
    FILETIME lwt;
    UINT uLangidLen;
    UINT uGuidLen;

    StringCchCopy(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), c_szCTFTipPath);
    StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), szTipClsid);
    StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), c_szLanguageProfile);

    pszLangid = szTIPClsidLang + lstrlen(szTIPClsidLang);
    uLangidLen = ARRAYSIZE(szTIPClsidLang) - lstrlen(szTIPClsidLang);

    if (RegOpenKeyEx(hkeyTop,
                     szTIPClsidLang, 0,
                     KEY_READ, &hkeyTipLang) != ERROR_SUCCESS)
    {
        goto Exit;
    }

    for (uIndex = 0; bRet == FALSE; uIndex++)
    {
        cchLangid = sizeof(szTIPLangid) / sizeof(TCHAR);

        if (RegEnumKeyEx(hkeyTipLang, uIndex,
                         szTIPLangid, &cchLangid,
                         NULL, NULL, NULL, &lwt) != ERROR_SUCCESS)
        {
            break;
        }

        if (cchLangid != 10)
        {
            // string langid subkeys should be like 0x00000409
            continue;
        }

        if (uLangidLen > (cchLangid + 1))
        {
            StringCchCopy(pszLangid, uLangidLen, TEXT("\\"));
            StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), szTIPLangid);
        }

        if (RegOpenKeyEx(hkeyTop,
                         szTIPClsidLang, 0,
                         KEY_READ, &hkeyTipLangid) != ERROR_SUCCESS)
        {
            continue;
        }

        pszGuid = szTIPClsidLang + lstrlen(szTIPClsidLang);
        uGuidLen = ARRAYSIZE(szTIPClsidLang) - lstrlen(szTIPClsidLang);

        for (uIndex2 = 0; bRet == FALSE; uIndex2++)
        {
            cchGuid = sizeof(szTIPGuid) / sizeof(TCHAR);

            if (RegEnumKeyEx(hkeyTipLangid, uIndex2,
                             szTIPGuid, &cchGuid,
                             NULL, NULL, NULL, &lwt) != ERROR_SUCCESS)
            {
                break;
            }

            if (cchGuid != 38)
            {
                continue;
            }

            if (uGuidLen > (cchGuid + 1))
            {
                StringCchCopy(pszGuid, uGuidLen, TEXT("\\"));
                StringCchCat(szTIPClsidLang, ARRAYSIZE(szTIPClsidLang), szTIPGuid);
            }

            if (RegOpenKeyEx(hkeyTop,
                             szTIPClsidLang, 0,
                             KEY_READ, &hkeyTipGuid) == ERROR_SUCCESS)
            {
                cb = sizeof(DWORD);

                if (RegQueryValueEx(hkeyTipGuid,
                                    TEXT("Enable"),
                                    NULL,
                                    NULL,
                                    (LPBYTE)&dwEnableTIP,
                                    &cb) == ERROR_SUCCESS)
                {

                    RegCloseKey(hkeyTipGuid);

                    if (dwEnableTIP)
                    {
                        *bExistEnable = TRUE;
                        bRet = TRUE;
                    }
                }
                else if (hkeyTop == HKEY_LOCAL_MACHINE)
                {
                    *bExistEnable = TRUE;
                    bRet = TRUE;
                }
            }

        }

        RegCloseKey(hkeyTipLangid);
    }

    RegCloseKey(hkeyTipLang);

Exit:

    return bRet;
}

//+---------------------------------------------------------------------------
//
// NoTipsInstalled
//
//----------------------------------------------------------------------------
// grab CLSID_SOFTKBDIMX here
#include <initguid.h>
#include "SoftKbd.h"

BOOL NoTipsInstalled(BOOL *pfOnlyTranslationRunning)
{
    const CLSID CLSID_SapiLayr = {0xdcbd6fa8, 0x032f, 0x11d3, {0xb5, 0xb1, 0x00, 0xc0, 0x4f, 0xc3, 0x24, 0xa1}};

    static const TCHAR c_szSpeechRecognizersKey[] = TEXT("Software\\Microsoft\\Speech\\Recognizers\\Tokens");
    static const TCHAR c_szCategory[] = TEXT("\\Category\\Category");

    BOOL bRet = TRUE;
    BOOL bExistEnable;
    HKEY hkeyTip;
    HKEY hkeyTipSub;
    UINT uIndex;
    DWORD dwSubKeys;
    DWORD cchClsid;
    CLSID clsidTip;
    TCHAR szTipClsid[128];
    TCHAR szTipClsidPath[MAX_PATH];
    FILETIME lwt;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\CTF\\TIP"),
                     0, KEY_READ, &hkeyTip) != ERROR_SUCCESS)
    {
        goto Exit;
    }

    // enum through all the TIP subkeys
    for (uIndex = 0; TRUE; uIndex++)
    {
        bExistEnable = FALSE;

        cchClsid = sizeof(szTipClsid) / sizeof(TCHAR);

        if (RegEnumKeyEx(hkeyTip, uIndex,
                         szTipClsid, &cchClsid,
                         NULL, NULL, NULL, &lwt) != ERROR_SUCCESS)
        {
            break;
        }

        if (cchClsid != 38)
        {
            // string clsid subkeys should be like {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
            continue;
        }

        StringCchCopy(szTipClsidPath, ARRAYSIZE(szTipClsidPath), szTipClsid);

        // we want subkey\Language Profiles key
        StringCchCat(szTipClsidPath, ARRAYSIZE(szTipClsidPath), c_szLanguageProfile);

        // is this subkey a tip?
        if (RegOpenKeyEx(hkeyTip,
                         szTipClsidPath, 0,
                         KEY_READ, &hkeyTipSub) == ERROR_SUCCESS)
        {
            RegCloseKey(hkeyTipSub);

            // it's a tip, get the clsid
            if (!StringAToCLSID(szTipClsid, &clsidTip))
                continue;

            // special case certain known tips
            if (IsEqualGUID(clsidTip, CLSID_SapiLayr))
            {
                // this is the sapi tip, which is always installed
                // but it will not activate if sapi is not installed
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 c_szSpeechRecognizersKey, 0,
                                 KEY_READ, &hkeyTipSub) != ERROR_SUCCESS)
                {
                    continue; // this tip doesn't count
                }

                // need 1 or more subkeys for sapi to be truely installed...whistler has a Tokens with nothing underneath
                if (RegQueryInfoKey(hkeyTipSub,
                                    NULL, NULL, NULL, &dwSubKeys, NULL,
                                    NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
                {
                    dwSubKeys = 0; // assume no sub keys on failure
                }

                RegCloseKey(hkeyTipSub);

                if (dwSubKeys != 0)
                {
                    bRet = FALSE;
                    break;
                }
            }
            else if (IsEqualGUID(clsidTip, CLSID_SoftkbdIMX))
            {
                // don't count the softkbd, it is disabled until another tip
                // enables it
                continue;
            }
            else if(IsTIPClsidEnabled(HKEY_CURRENT_USER, szTipClsid, &bExistEnable))
            {
                bRet = FALSE;
                break;
            }
            else if (!bExistEnable)
            {
                if(IsTIPClsidEnabled(HKEY_LOCAL_MACHINE, szTipClsid, &bExistEnable))
                {
                   bRet = FALSE;
                   break;
                }
            }
        }
    }

    RegCloseKey(hkeyTip);

Exit:
    if (bRet == TRUE && pfOnlyTranslationRunning != NULL) // skip the check for aimm, which passes in NULL pfOnlyTranslationRunning
    {
        // word10 compart: check for bookshelf's translation service
        // it uses cicero, but does not formally register itself as a tip.
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Microsoft Reference\\Bilinguals 1.0"),
                         0, KEY_READ, &hkeyTip) == ERROR_SUCCESS)
        {
            *pfOnlyTranslationRunning = TRUE;
            bRet = FALSE;
            RegCloseKey(hkeyTip);
        }
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// RunningOnWow64
//
//----------------------------------------------------------------------------

BOOL RunningOnWow64()
{
    BOOL bOnWow64 = FALSE;
    // check to make sure that we are running on wow64
    LONG lStatus;
    ULONG_PTR Wow64Info;

    typedef BOOL (WINAPI *PFN_NTQUERYINFORMATIONPROCESS)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);

    PFN_NTQUERYINFORMATIONPROCESS pfnNtQueryInformationProcess;
    HINSTANCE hLibNtDll = NULL;
    hLibNtDll = GetSystemModuleHandle( TEXT("ntdll.dll") );
    if (hLibNtDll)
    {
        pfnNtQueryInformationProcess = (PFN_NTQUERYINFORMATIONPROCESS)GetProcAddress(hLibNtDll, TEXT("NtQueryInformationProcess"));
        if (pfnNtQueryInformationProcess)
        {
            lStatus = pfnNtQueryInformationProcess(GetCurrentProcess(), ProcessWow64Information, &Wow64Info, sizeof(Wow64Info), NULL);
            if (NT_SUCCESS(lStatus) && Wow64Info)
            {
                bOnWow64 = TRUE;
            }
        }
    }

    return bOnWow64;
}

//+---------------------------------------------------------------------------
//
// GetSystemDefaultHKL
//
//----------------------------------------------------------------------------

HKL GetSystemDefaultHKL()
{
    HKL hkl;
    if (SystemParametersInfo( SPI_GETDEFAULTINPUTLANG, 0, &hkl, 0))
        return hkl;

    return GetKeyboardLayout(0);
}

//+---------------------------------------------------------------------------
//
// IsDisabledCUAS
//
//----------------------------------------------------------------------------
BOOL IsDisabledCUAS()
{
    static const TCHAR c_szCtfShared[]  = TEXT("SOFTWARE\\Microsoft\\CTF\\SystemShared");
    static const TCHAR c_szCUAS[]       = TEXT("CUAS");

    DWORD cb;
    HKEY hkeyCTF;
    BOOL bRet = TRUE;
    DWORD dwEnableCUAS = 0;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szCtfShared, &hkeyCTF) == ERROR_SUCCESS)
    {
        cb = sizeof(DWORD);

        RegQueryValueEx(hkeyCTF,
                        c_szCUAS,
                        NULL,
                        NULL,
                        (LPBYTE)&dwEnableCUAS,
                        &cb);

        if (dwEnableCUAS)
            bRet = FALSE;

        RegCloseKey(hkeyCTF);
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// IsInstalledEALangPack
//
//----------------------------------------------------------------------------
BOOL IsInstalledEALangPack()
{
    static const TCHAR c_szLangGroup[]  = TEXT("System\\CurrentControlSet\\Control\\Nls\\Language Groups");
    static const TCHAR c_szLangJPN[]    = TEXT("7");

    BOOL bRet = FALSE;
    HKEY hkeyLangGroup;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     c_szLangGroup,
                     0,
                     KEY_READ,
                     &hkeyLangGroup) == ERROR_SUCCESS)
    {
        DWORD cb;
        TCHAR szLangInstall[10];

        cb = sizeof(szLangInstall);

        //
        //  The checking of Japan Language is enough to know EA language pack
        //  installation.
        //
        if (RegQueryValueEx(hkeyLangGroup,
                            c_szLangJPN,
                            NULL,
                            NULL,
                            (LPBYTE)szLangInstall,
                            &cb) == ERROR_SUCCESS)
        {
            if (szLangInstall[0] != 0)
                return TRUE;
        }

        RegCloseKey(hkeyLangGroup);
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// SetDisableCUAS
//
//----------------------------------------------------------------------------
void SetDisableCUAS(
    BOOL bDisableCUAS)
{
    static const TCHAR c_szCtfShared[]  = TEXT("SOFTWARE\\Microsoft\\CTF\\SystemShared");
    static const TCHAR c_szIMM[]        = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IMM");
    static const TCHAR c_szLoadIMM[]    = TEXT("LoadIMM");
    static const TCHAR c_szLoadCTFIME[] = TEXT("LoadCTFIME");
    static const TCHAR c_szIMMFile[]    = TEXT("IME File");
    static const TCHAR c_szIMMFileName[]= TEXT("msctfime.ime");
    static const TCHAR c_szCUAS[]       = TEXT("CUAS");

    HKEY hkeyIMM;
    HKEY hkeyCTF;
    DWORD cb = sizeof(DWORD);
    DWORD dwCTFIME, dwCUAS;

    if (bDisableCUAS)
        dwCTFIME = dwCUAS = 0;
    else
        dwCTFIME = dwCUAS = 1;

    if (RegCreateKey(HKEY_LOCAL_MACHINE, c_szIMM, &hkeyIMM) != ERROR_SUCCESS)
    {
        hkeyIMM = NULL;
    }

    if (RegCreateKey(HKEY_LOCAL_MACHINE, c_szCtfShared, &hkeyCTF) != ERROR_SUCCESS)
    {
        hkeyCTF = NULL;
    }

    if (!bDisableCUAS)
    {
        //
        //  Turn on LoadIMM, LoadCTFIME and CUAS flags
        //

        if (hkeyIMM)
        {
            RegSetValueEx(hkeyIMM,
                          c_szIMMFile,
                          0,
                          REG_SZ,
                          (LPBYTE)c_szIMMFileName,
                          (lstrlen(c_szIMMFileName) + 1) * sizeof(TCHAR));
        }
    }
    else
    {
        //
        //  Turn off LoadIMM, LoadCTFIME and CUAS flags
        //

        BOOL bEALang = IsInstalledEALangPack();

        if (bEALang)
        {
            dwCTFIME = 1;
        }
    }

    if (hkeyIMM)
    {
        RegSetValueEx(hkeyIMM,
                      c_szLoadIMM,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwCTFIME,
                      cb);

        RegSetValueEx(hkeyIMM,
                      c_szLoadCTFIME,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwCTFIME,
                      cb);
    }

    if (hkeyCTF)
    {
        RegSetValueEx(hkeyCTF,
                      c_szCUAS,
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwCUAS,
                      cb);
    }

    if (hkeyIMM)
        RegCloseKey(hkeyIMM);

    if (hkeyCTF)
        RegCloseKey(hkeyCTF);
}

//+---------------------------------------------------------------------------
//
// RebootTheSystem
//
//----------------------------------------------------------------------------
void RebootTheSystem()
{
    HANDLE Token = NULL;
    ULONG ReturnLength, Index;
    PTOKEN_PRIVILEGES NewState = NULL;
    PTOKEN_PRIVILEGES OldState = NULL;
    BOOL Result;

    //  Only allow admin privilege user for system reboot.
    if (!IsAdminPrivilege())
        return;

    Result = OpenProcessToken( GetCurrentProcess(),
                               TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               &Token );
    if (Result)
    {
        ReturnLength = 4096;
        NewState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        OldState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        Result = (BOOL)((NewState != NULL) && (OldState != NULL));
        if (Result)
        {
            Result = GetTokenInformation( Token,            // TokenHandle
                                          TokenPrivileges,  // TokenInformationClass
                                          NewState,         // TokenInformation
                                          ReturnLength,     // TokenInformationLength
                                          &ReturnLength );  // ReturnLength
            if (Result)
            {
                //
                //  Set the state settings so that all privileges are
                //  enabled...
                //
                if (NewState->PrivilegeCount > 0)
                {
                    for (Index = 0; Index < NewState->PrivilegeCount; Index++)
                    {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }

                Result = AdjustTokenPrivileges( Token,           // TokenHandle
                                                FALSE,           // DisableAllPrivileges
                                                NewState,        // NewState
                                                ReturnLength,    // BufferLength
                                                OldState,        // PreviousState
                                                &ReturnLength ); // ReturnLength
                if (Result)
                {
                    ExitWindowsEx(EWX_REBOOT, 0);


                    AdjustTokenPrivileges( Token,
                                           FALSE,
                                           OldState,
                                           0,
                                           NULL,
                                           NULL );
                }
            }
        }
    }

    if (NewState != NULL)
    {
        LocalFree(NewState);
    }
    if (OldState != NULL)
    {
        LocalFree(OldState);
    }
    if (Token != NULL)
    {
        CloseHandle(Token);
    }
}

//+---------------------------------------------------------------------------
//
// IsAdminPrivilege
//
//----------------------------------------------------------------------------
BOOL IsAdminPrivilege()
{
    BOOL bAdmin = FALSE;
    BOOL bResult = FALSE;
    BOOL fSIDCreated = FALSE;
    HANDLE hToken = NULL;
    PSID AdminSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    fSIDCreated = AllocateAndInitializeSid(&NtAuthority,
                                           2,
                                           SECURITY_BUILTIN_DOMAIN_RID,
                                           DOMAIN_ALIAS_RID_ADMINS,
                                           0, 0, 0, 0, 0, 0,
                                           &AdminSid);

    if (!fSIDCreated)
        return FALSE;

    bResult = OpenProcessToken(GetCurrentProcess(),
                               TOKEN_QUERY,
                               &hToken );

    if (bResult)
    {
        DWORD dwSize = 0;
        TOKEN_GROUPS *pTokenGrpInfo;

        GetTokenInformation(hToken,
                            TokenGroups,
                            NULL,
                            dwSize,
                            &dwSize);

        if (dwSize)
            pTokenGrpInfo = (PTOKEN_GROUPS) LocalAlloc(LPTR, dwSize);
        else
            pTokenGrpInfo = NULL;

        if (pTokenGrpInfo && GetTokenInformation(hToken,
                                                 TokenGroups,
                                                 pTokenGrpInfo,
                                                 dwSize,
                                                 &dwSize))
        {
            UINT i;

            for (i = 0; i < pTokenGrpInfo->GroupCount; i++)
            {
                if (EqualSid(pTokenGrpInfo->Groups[i].Sid, AdminSid) &&
                    (pTokenGrpInfo->Groups[i].Attributes & SE_GROUP_ENABLED))
                {
                    bAdmin = TRUE;
                    break;
                }
            }
        }

        if (pTokenGrpInfo)
            LocalFree(pTokenGrpInfo);
    }

    if (hToken)
        CloseHandle(hToken);

    if (AdminSid)
        FreeSid(AdminSid);

    return bAdmin;
}

//+---------------------------------------------------------------------------
//
// IsInteractiveUserLogon
//
//----------------------------------------------------------------------------
BOOL IsInteractiveUserLogon()
{
    PSID InteractiveSid;
    BOOL bCheckSucceeded;
    BOOL bAmInteractive = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  1,
                                  SECURITY_INTERACTIVE_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &InteractiveSid))
    {
        return FALSE;
    }

    //
    // This checking is for logged on user or not. So we can blcok running
    // ctfmon.exe process from non-authorized user.
    //
    bCheckSucceeded = CheckTokenMembership(NULL,
                                           InteractiveSid,
                                           &bAmInteractive);

    if (InteractiveSid)
        FreeSid(InteractiveSid);

    return (bCheckSucceeded && bAmInteractive);
}



//+---------------------------------------------------------------------------
//
// GetSystemModuleHandle
//
//----------------------------------------------------------------------------

HMODULE GetSystemModuleHandle(LPCSTR lpModuleName)
{
    CicSystemModulePath path;

    if (!path.Init(lpModuleName))
         return NULL;

    return GetModuleHandle(path.GetPath());
}

//+---------------------------------------------------------------------------
//
// LoadSystemLibrary
//
//----------------------------------------------------------------------------

HMODULE LoadSystemLibrary(LPCSTR lpModuleName)
{
    CicSystemModulePath path;

    if (!path.Init(lpModuleName))
         return NULL;

    return LoadLibrary(path.GetPath());
}

//+---------------------------------------------------------------------------
//
// LoadSystemLibraryEx
//
//----------------------------------------------------------------------------

HMODULE LoadSystemLibraryEx(LPCSTR lpModuleName, HANDLE hFile, DWORD dwFlags)
{
    CicSystemModulePath path;

    if (!path.Init(lpModuleName))
         return NULL;

    return LoadLibraryEx(path.GetPath(), hFile, dwFlags);
}


//+---------------------------------------------------------------------------
//
// GetSystemModuleHandleW
//
//----------------------------------------------------------------------------

HMODULE GetSystemModuleHandleW(LPCWSTR lpModuleName)
{
    CicSystemModulePathW path;

    if (!path.Init(lpModuleName))
         return NULL;

    return GetModuleHandleW(path.GetPath());
}

//+---------------------------------------------------------------------------
//
// LoadSystemLibraryW
//
//----------------------------------------------------------------------------

HMODULE LoadSystemLibraryW(LPCWSTR lpModuleName)
{
    CicSystemModulePathW path;

    if (!path.Init(lpModuleName))
         return NULL;

    return LoadLibraryW(path.GetPath());
}

//+---------------------------------------------------------------------------
//
// LoadSystemLibraryEx
//
//----------------------------------------------------------------------------

HMODULE LoadSystemLibraryExW(LPCWSTR lpModuleName, HANDLE hFile, DWORD dwFlags)
{
    CicSystemModulePathW path;

    if (!path.Init(lpModuleName))
         return NULL;

    return LoadLibraryExW(path.GetPath(), hFile, dwFlags);
}

//+---------------------------------------------------------------------------
//
// FullPathExec
//
//----------------------------------------------------------------------------

BOOL FullPathExec(
    LPCSTR pszAppName,
    LPCSTR pszCmdLine,
    WORD wShowWindow,
    BOOL fWinDir)
{
    char szCmdLine[MAX_PATH + 1];
    CicSystemModulePath fullpath;
    fullpath.Init(pszAppName, fWinDir);
    if (!fullpath.GetLength())
        return FALSE;

    //
    // CreateProcess() wants an out buffer for CmdLine. So we just have it in
    // stack.
    //
    StringCchCopy(szCmdLine, ARRAYSIZE(szCmdLine), pszCmdLine);

    PROCESS_INFORMATION pi;
    STARTUPINFO si = {0};

    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = (WORD)wShowWindow;

    return CreateProcess(fullpath.GetPath(),
                         szCmdLine,
                         NULL,
                         NULL,
                         FALSE,
                         NORMAL_PRIORITY_CLASS,
                         NULL,
                         NULL,
                         &si,
                         &pi);
}

//+---------------------------------------------------------------------------
//
// RunCPLs
//
//----------------------------------------------------------------------------

BOOL RunCPLSetting(
    LPTSTR pCmdLine)
{
    const TCHAR c_szRundll32[]   = TEXT("Rundll32.exe");

    if (!pCmdLine)
        return FALSE;

    return FullPathExec(c_szRundll32, 
                        pCmdLine, 
                        SW_SHOWMINNOACTIVE,
                        FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\insert.cpp ===
//
// insert.cpp
//

#include "private.h"
#include "insert.h"
#include "mem.h"
#include "sdo.h"

DBG_ID_INSTANCE(CCompositionInsertHelper);

/* ee894895-2709-420d-927c-ab861ec88805 */
extern const GUID GUID_PROP_OVERTYPE = { 0xee894895, 0x2709, 0x420d, {0x92, 0x7c, 0xab, 0x86, 0x1e, 0xc8, 0x88, 0x05} };

IDataObject *GetFormattedChar(TfEditCookie ec, ITfRange *range)
{
    CDataObject *pdo;
    IDataObject *ido;
    WCHAR ch;
    ULONG cch;

    // first, try the real GetFormattedText

    if (range->GetFormattedText(ec, &ido) == S_OK)
        return ido;

    // settle for the raw text if that's the best we can do

    if (range->GetText(ec, 0, &ch, 1, &cch) != S_OK || cch != 1)
        return NULL;

    if ((pdo = new CDataObject) == NULL)
        return NULL;

    if (pdo->_SetData(&ch, 1) != S_OK)
    {
        pdo->Release();
        return NULL;
    }

    return pdo;
}

HRESULT InsertEmbedded(TfEditCookie ec, DWORD dwFlags, ITfRange *range, IDataObject *pdo)
{
    FORMATETC fe;
    STGMEDIUM sm;
    HRESULT hr;
    ULONG cch;
    WCHAR *pch;

    // first, try to insert directly
    if (range->InsertEmbedded(ec, 0, pdo) == S_OK)
        return S_OK;

    // if that didn't work, try to slam in raw text

    fe.cfFormat = CF_UNICODETEXT;
    fe.ptd = NULL;
    fe.dwAspect = DVASPECT_CONTENT;
    fe.lindex = -1;
    fe.tymed = TYMED_HGLOBAL;
    
    if (FAILED(pdo->GetData(&fe, &sm)))
        return E_FAIL;
    
    if (sm.hGlobal == NULL)
        return E_FAIL;
    
    pch = (WCHAR *)GlobalLock(sm.hGlobal);
    cch = wcslen(pch);

    hr = range->SetText(ec, 0, pch, cch);

    GlobalUnlock(sm.hGlobal);
    ReleaseStgMedium(&sm);

    return hr;
}


class COvertypeStore : public ITfPropertyStore
{
public:
    COvertypeStore(IDataObject *pdo, CCompositionInsertHelper *pHelper)
    {
        _pdo = pdo;
        pdo->AddRef();

        _pHelper = pHelper;
        pHelper->AddRef();

        _pHelper->_IncOvertypeStoreRef();

        _cRef = 1;
    }
    ~COvertypeStore()
    { 
        _pHelper->_DecOvertypeStoreRef();
        _pHelper->Release();
        _pdo->Release();
    }

    // IUnknown
    // 
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfPropertyStore
    //
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDataType(DWORD *pdwReserved);
    STDMETHODIMP GetData(VARIANT *pvarValue);
    STDMETHODIMP OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept);
    STDMETHODIMP Shrink(ITfRange *pRange, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Serialize(IStream *pStream, ULONG *pcb);

private:
    IDataObject *_pdo;    
    CCompositionInsertHelper *_pHelper;
    int _cRef;
};

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCompositionInsertHelper::CCompositionInsertHelper()
{
    Dbg_MemSetThisNameID(TEXT("CCompositionInsertHelper"));

    _cchMaxOvertype = DEF_MAX_OVERTYPE_CCH;
    _cRefOvertypeStore = 0;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

ULONG CCompositionInsertHelper::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

ULONG CCompositionInsertHelper::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// Configure
//
//----------------------------------------------------------------------------

HRESULT CCompositionInsertHelper::Configure(ULONG cchMaxOvertype)
{
    _cchMaxOvertype = cchMaxOvertype;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InsertAtSelection
//
//----------------------------------------------------------------------------

HRESULT CCompositionInsertHelper::InsertAtSelection(TfEditCookie ec, ITfContext *pic, const WCHAR *pchText, ULONG cchText, ITfRange **ppCompRange)
{
    ITfRange *rangeInsert;
    ITfInsertAtSelection *pias;
    LONG cchInsert;
    TF_HALTCOND hc;
    HRESULT hr;

    // starting a new composition, some init work needed....
    if (_cRefOvertypeStore > 0)
    {
        // clear previously allocated resources
        ReleaseBlobs(ec, pic, NULL);
    }

    if (ppCompRange == NULL)
        return E_INVALIDARG;

    *ppCompRange = NULL;

    if (pic->QueryInterface(IID_ITfInsertAtSelection, (void **)&pias) != S_OK)
        return E_FAIL;

    hr = E_FAIL;

    if (pias->InsertTextAtSelection(ec, TF_IAS_QUERYONLY, pchText, cchText, &rangeInsert) != S_OK || rangeInsert == NULL)
    {
        rangeInsert = NULL;
        goto Exit;
    }

    // backup the text that will be overwritten
    hc.pHaltRange = rangeInsert;
    hc.aHaltPos = TF_ANCHOR_START;
    hc.dwFlags = 0;

    if (rangeInsert->ShiftEnd(ec, LONG_MIN, &cchInsert, &hc) != S_OK)
        goto Exit;

    cchInsert = -cchInsert;

    if (cchInsert > 0)
    {
        if (_PreInsertGrow(ec, rangeInsert, 0, cchInsert, FALSE) != S_OK)
            goto Exit;
    }

    rangeInsert->Release();

    _fAcceptTextUpdated = TRUE; // protect any overtype property

    // do the overwrite
    if (pias->InsertTextAtSelection(ec, TF_IAS_NO_DEFAULT_COMPOSITION, pchText, cchText, &rangeInsert) != S_OK)
        goto Exit;

    hr = S_OK;
    *ppCompRange = rangeInsert;

Exit:
    _fAcceptTextUpdated = FALSE;
    pias->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryPreInsert
//
//----------------------------------------------------------------------------

HRESULT CCompositionInsertHelper::QueryPreInsert(TfEditCookie ec, ITfRange *rangeToAdjust,
                                                 ULONG cchCurrent, ULONG cchInsert, BOOL *pfInsertOk)
{
    return _PreInsert(ec, rangeToAdjust, cchCurrent, cchInsert, pfInsertOk, TRUE);
}

//+---------------------------------------------------------------------------
//
// PreInsert
//
//----------------------------------------------------------------------------

HRESULT CCompositionInsertHelper::PreInsert(TfEditCookie ec, ITfRange *rangeToAdjust,
                                            ULONG cchCurrent, ULONG cchInsert, BOOL *pfInsertOk)
{
    return _PreInsert(ec, rangeToAdjust, cchCurrent, cchInsert, pfInsertOk, FALSE);
}

//+---------------------------------------------------------------------------
//
// _PreInsert
//
//----------------------------------------------------------------------------

HRESULT CCompositionInsertHelper::_PreInsert(TfEditCookie ec, ITfRange *rangeToAdjust, ULONG cchCurrent,
                                             ULONG cchInsert, BOOL *pfInsertOk, BOOL fQuery)
{
    ITfContext *pic;
    LONG dLength;
    HRESULT hr;

    if (!fQuery)
    {
        Assert(_fAcceptTextUpdated == FALSE);
        // just for robustness, in case the app forgot to call PostInsert, now we'll release prop in _PreInsertShrink
        _fAcceptTextUpdated = FALSE;
    }

    //
    // check the [in] params
    //
    if (pfInsertOk == NULL)
        return E_INVALIDARG;

    *pfInsertOk = TRUE;

    if (rangeToAdjust == NULL)
        return E_INVALIDARG;

    dLength = (LONG)cchInsert - (LONG)cchCurrent;

    //
    // adjust the range
    //
    if (dLength > 0)
    {
        if (cchCurrent == 0)
        {
            // starting a new composition, some init work needed....
            if (!fQuery && _cRefOvertypeStore > 0)
            {
                // clear previously allocated resources
                if (rangeToAdjust->GetContext(&pic) == S_OK)
                {
                    ReleaseBlobs(ec, pic, NULL);
                    pic->Release();
                }
            }
            // let the app collapse, adjust the selection
            if (rangeToAdjust->AdjustForInsert(ec, 0, pfInsertOk) != S_OK) // 0 means just fix up the selection
                return E_FAIL;

            if (*pfInsertOk == FALSE)
                return S_OK; // nb: we don't set _fAcceptTextUpdated = TRUE
        }

        hr = _PreInsertGrow(ec, rangeToAdjust, cchCurrent, cchInsert, fQuery);
    }
    else if (dLength < 0)
    {
        hr = _PreInsertShrink(ec, rangeToAdjust, cchCurrent, cchInsert, fQuery);
    }
    else
    {
        hr = S_OK;
    }

    if (hr != S_OK)
        return E_FAIL;

    if (!fQuery)
    {
        //
        // protect the overtype property until PostInsert is called
        //
        _fAcceptTextUpdated = TRUE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// PreInsertGrow
//
//----------------------------------------------------------------------------

HRESULT CCompositionInsertHelper::_PreInsertGrow(TfEditCookie ec, ITfRange *rangeToAdjust, ULONG cchCurrent, ULONG cchInsert, BOOL fQuery)
{
    COvertypeStore *store;
    ITfRange *range;
    BOOL fEmpty;
    IDataObject *pdo;
    ULONG dch;
    ULONG cchCurrentMaxOvertype;
    BOOL fInsertOk;
    ITfContext *pic = NULL;
    ITfProperty *pOvertypeProp = NULL;
    HRESULT hr = E_FAIL;

    Assert((LONG)cchInsert - (LONG)cchCurrent > 0);

    if (rangeToAdjust->Clone(&range) != S_OK)
        return E_FAIL;

    if (range->Collapse(ec, TF_ANCHOR_END) != S_OK)
        goto Exit;

    if (!fQuery && rangeToAdjust->GetContext(&pic) == S_OK)
    {
        pic->GetProperty(GUID_PROP_OVERTYPE, &pOvertypeProp);
        pic->Release();
    }

    // this is a conservative test, it assumes that each new char
    // will overtype just one existing char.  The downside is that
    // we might not backup all chars if a new char replaces several
    // old ones, and there are more new chars than _cchMaxOvertype
    Assert(_cchMaxOvertype >= (ULONG)_cRefOvertypeStore);
    cchCurrentMaxOvertype = _cchMaxOvertype - (ULONG)_cRefOvertypeStore;
    dch = cchInsert - cchCurrent;

    if (dch > cchCurrentMaxOvertype)
    {
        if (range->AdjustForInsert(ec, dch - cchCurrentMaxOvertype, &fInsertOk) != S_OK)
            goto Exit;

        if (!fInsertOk || range->IsEmpty(ec, &fEmpty) != S_OK || fEmpty)
        {
            hr = S_OK;
            goto FinalShift;
        }

        // shift to the next test position
        range->Collapse(ec, TF_ANCHOR_END);
        // we only need to work extra hard for the remaining chars
        dch = cchCurrentMaxOvertype;
    }

    // figure out what the additional text will cover
    while (dch-- > 0)
    {
        if (range->AdjustForInsert(ec, 1, &fInsertOk) != S_OK)
            goto Exit;

        if (!fInsertOk || range->IsEmpty(ec, &fEmpty) != S_OK || fEmpty)
        {
            hr = S_OK;
            goto FinalShift;
        }

        // try to save the to-be-overtyped text
        if (pOvertypeProp != NULL &&
            (pdo = GetFormattedChar(ec, range)))
        {
            if (store = new COvertypeStore(pdo, this))
            {
                pOvertypeProp->SetValueStore(ec, range, store);
                store->Release();
            }
            pdo->Release();
        }

        // shift to the next test position
        range->Collapse(ec, TF_ANCHOR_END);
    }

FinalShift:
    // extend the input range to cover the overtyped text
    hr = rangeToAdjust->ShiftEndToRange(ec, range, TF_ANCHOR_END);

Exit:
    SafeRelease(pOvertypeProp);
    range->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// _PreInsertShrink
//
//----------------------------------------------------------------------------

HRESULT CCompositionInsertHelper::_PreInsertShrink(TfEditCookie ec, ITfRange *rangeToAdjust, ULONG cchCurrent, ULONG cchInsert, BOOL fQuery)
{
    ITfRange *range = NULL;
    ITfContext *pic = NULL;
    ITfProperty *pOvertypeProp = NULL;
    VARIANT var;
    LONG dShrink;
    LONG cchShift;
    HRESULT hr;
    LONG i;
    BOOL fRestoredText;
    IEnumTfRanges *pEnum;
    ITfRange *rangeEnum;
    ITfRange *range2Chars;
    BOOL fEmpty;

    Assert((LONG)cchInsert - (LONG)cchCurrent < 0);

    if (rangeToAdjust->Clone(&range) != S_OK)
        return E_FAIL;

    hr = E_FAIL;

    if (rangeToAdjust->GetContext(&pic) != S_OK)
        goto Exit;

    if (pic->GetProperty(GUID_PROP_OVERTYPE, &pOvertypeProp) != S_OK)
        goto Exit;

    // walk through the disappearing range and restore old text

    if (range->Collapse(ec, TF_ANCHOR_END) != S_OK)
        goto Exit;    

    dShrink = (LONG)cchCurrent - (LONG)cchInsert;
    dShrink = min(dShrink, (LONG)_cchMaxOvertype); // Issue: perf: could be more exact using ref count

    Assert(dShrink > 0); // we count on entering the loop at least once!
    for (i=0; i<dShrink; i++)
    {
        if (range->ShiftStart(ec, -1, &cchShift, NULL) != S_OK)
            goto Exit;
        Assert(cchShift == -1);

        fRestoredText = FALSE;

        if (range->Clone(&range2Chars) != S_OK)
            goto Exit;
        range2Chars->ShiftStart(ec, -1, &cchShift, NULL);

        if (pOvertypeProp->EnumRanges(ec, &pEnum, range2Chars) == S_OK)
        {
            if (pEnum->Next(1, &rangeEnum, NULL) == S_OK)
            {
                // make sure the range has a len of 1
                // it may have a len > 1 if a tip adds more chars to the end of composition
                if (rangeEnum->ShiftEnd(ec, -1, &cchShift, NULL) == S_OK && cchShift == -1 &&
                    rangeEnum->IsEmpty(ec, &fEmpty) == S_OK && fEmpty)
                {
                    if (pOvertypeProp->GetValue(ec, range, &var) == S_OK && var.vt != VT_EMPTY)
                    {
                        Assert(var.vt == VT_UNKNOWN);

                        if (fQuery || InsertEmbedded(ec, 0, range, (IDataObject *)var.punkVal) == S_OK)
                        {
                            fRestoredText = TRUE;
                        }

                        var.punkVal->Release();
                    }
                }
                rangeEnum->Release();
            }
            pEnum->Release();
        }

        range2Chars->Release();

        // don't do any extra work after we encounter an unbacked-up char
        if (!fRestoredText)
            break;

        if (range->Collapse(ec, TF_ANCHOR_START) != S_OK)
            goto Exit;
    }

    if (i > 0)
    {
        // pull back the range so it doesn't cover the restored text anymore
        if (rangeToAdjust->ShiftEndToRange(ec, range, TF_ANCHOR_END) != S_OK)
            goto Exit;
    }

    hr = S_OK;

Exit:
    SafeRelease(pic);
    SafeRelease(range);
    SafeRelease(pOvertypeProp);

    return hr;
}

//+---------------------------------------------------------------------------
//
// PostInsert
//
//----------------------------------------------------------------------------

HRESULT CCompositionInsertHelper::PostInsert()
{
    _fAcceptTextUpdated = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ReleaseBlobs
//
//----------------------------------------------------------------------------

HRESULT CCompositionInsertHelper::ReleaseBlobs(TfEditCookie ec, ITfContext *pic, ITfRange *range)
{
    ITfProperty *pOvertypeProp;
    HRESULT hr;

    if (pic == NULL)
        return E_INVALIDARG;

    if (pic->GetProperty(GUID_PROP_OVERTYPE, &pOvertypeProp) != S_OK)
        return E_FAIL;

    hr = pOvertypeProp->Clear(ec, range);

    pOvertypeProp->Release();

    Assert(_cRefOvertypeStore == 0); // the clear should have released all property stores

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// COvertypeStore
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP COvertypeStore::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;

    Assert(ppvObj);

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfPropertyStore))
    {
        *ppvObj = this;
        hr = S_OK;

        _cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(ULONG) COvertypeStore::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) COvertypeStore::Release(void)
{
    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;

    return 0;
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDMETHODIMP COvertypeStore::GetType(GUID *pguid)
{
    *pguid = GUID_PROP_OVERTYPE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDataType
//
//----------------------------------------------------------------------------

STDMETHODIMP COvertypeStore::GetDataType(DWORD *pdwReserved)
{
    *pdwReserved = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetData
//
//----------------------------------------------------------------------------

STDMETHODIMP COvertypeStore::GetData(VARIANT *pvarValue)
{
    QuickVariantInit(pvarValue);

    pvarValue->vt = VT_UNKNOWN;
    pvarValue->punkVal = _pdo;
    pvarValue->punkVal->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// TextUpdated
//
//----------------------------------------------------------------------------

STDMETHODIMP COvertypeStore::OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept)
{
    *pfAccept = _pHelper->_AcceptTextUpdated();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Shrink
//
//----------------------------------------------------------------------------

STDMETHODIMP COvertypeStore::Shrink(ITfRange *pRange, BOOL *pfFree)
{
    *pfFree = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Divide
//
//----------------------------------------------------------------------------

STDMETHODIMP COvertypeStore::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore)
{
    *ppPropStore = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDMETHODIMP COvertypeStore::Clone(ITfPropertyStore **ppPropStore)
{
    COvertypeStore *clone;
    
    *ppPropStore = NULL;

    if ((clone = new COvertypeStore(_pdo, _pHelper)) == NULL)
        return E_OUTOFMEMORY;

    *ppPropStore = clone;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetPropertyRangeCreator
//
//----------------------------------------------------------------------------

STDMETHODIMP COvertypeStore::GetPropertyRangeCreator(CLSID *pclsid)
{
    *pclsid = CLSID_NULL; // don't support persistence
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Serialize
//
//----------------------------------------------------------------------------

STDMETHODIMP COvertypeStore::Serialize(IStream *pStream, ULONG *pcb)
{
    Assert(0);
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\strary.cpp ===
//
// strary.cpp
//
// CStructArray
//

#include "private.h"
#include "strary.h"
#include "mem.h"

#define StrPB(x) (_pb + ((x) * _iElemSize))

//+---------------------------------------------------------------------------
//
// Insert(int iIndex, int cElems)
//
// Grows the array to accomodate cElems at offset iIndex.
//
// The new cells are NOT initialized!
//
//----------------------------------------------------------------------------

BOOL CVoidStructArray::Insert(int iIndex, int cElems)
{
    BYTE *pb;
    int iSizeNew;

    Assert(iIndex >= 0);
    Assert(iIndex <= _cElems);
    Assert(cElems > 0);

    // allocate space if necessary
    if (_iSize < _cElems + cElems)
    {
        // allocate 1.5x what we need to avoid future allocs
        iSizeNew = max(_cElems + cElems, _cElems + _cElems / 2);

        if ((pb = (_pb == NULL) ? 
                   (BYTE *)cicMemAlloc(iSizeNew*_iElemSize) :
                   (BYTE *)cicMemReAlloc(_pb, iSizeNew* _iElemSize))
            == NULL)
        {
            return FALSE;
        }

        _pb = pb;
        _iSize = iSizeNew;
    }

    if (iIndex < _cElems)
    {
        // make room for the new addition
        memmove(StrPB(iIndex + cElems), 
                StrPB(iIndex), 
                (_cElems - iIndex)*_iElemSize);
#ifdef DEBUG
        memset(StrPB(iIndex), 0xFE, cElems * _iElemSize);
#endif
    }

    _cElems += cElems;
    Assert(_iSize >= _cElems);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Remove(int Index, int cElems)
//
// Removes cElems at offset iIndex.
//
//----------------------------------------------------------------------------

void CVoidStructArray::Remove(int iIndex, int cElems)
{
    BYTE *pb;
    int iSizeNew;

    Assert(cElems > 0);
    Assert(iIndex >= 0);
    Assert(iIndex + cElems <= _cElems);

    if (iIndex + cElems < _cElems)
    {
        // shift following eles left
        memmove(StrPB(iIndex), 
                StrPB(iIndex + cElems), 
                (_cElems - iIndex - cElems) * _iElemSize);
#ifdef DEBUG
        memset(StrPB(_cElems - cElems), 0xFE, cElems * _iElemSize);
#endif
    }

    _cElems -= cElems;

    // free mem when array contents uses less than half alloc'd mem
    iSizeNew = _iSize / 2;
    if (iSizeNew > _cElems)
    {
        if ((pb = (BYTE *)cicMemReAlloc(_pb, iSizeNew * _iElemSize)) != NULL)
        {
            _pb = pb;
            _iSize = iSizeNew;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\timsink.cpp ===
//
// des.cpp
//
// CThreadMgrEventSink
//

#include "private.h"
#include "timsink.h"
#include "helpers.h"


//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfThreadMgrEventSink))
    {
        *ppvObj = this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CThreadMgrEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CThreadMgrEventSink::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CThreadMgrEventSink::CThreadMgrEventSink(DIMCALLBACK pfnDIMCallback, ICCALLBACK pfnICCallback, void *pv)
{
    Dbg_MemSetThisName(TEXT("CThreadMgrEventSink"));

    _pfnDIMCallback = pfnDIMCallback;
    _pfnICCallback = pfnICCallback;
    _pv = pv;

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CThreadMgrEventSink::~CThreadMgrEventSink()
{
}

//+---------------------------------------------------------------------------
//
// OnInitDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::OnInitDocumentMgr(ITfDocumentMgr *dim)
{
    if (!_pfnDIMCallback)
        return S_OK;

    return _pfnDIMCallback(TIM_CODE_INITDIM, dim, NULL, _pv);
}

//+---------------------------------------------------------------------------
//
// UninitializeDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::OnUninitDocumentMgr(ITfDocumentMgr *dim)
{
    if (!_pfnDIMCallback)
        return S_OK;

    return _pfnDIMCallback(TIM_CODE_UNINITDIM, dim, NULL, _pv);
}

//+---------------------------------------------------------------------------
//
// OnSetFocus
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::OnSetFocus(ITfDocumentMgr *dimFocus, ITfDocumentMgr *dimPrevFocus)
{
    if (!_pfnDIMCallback)
        return S_OK;

    return  _pfnDIMCallback(TIM_CODE_SETFOCUS, dimFocus, dimPrevFocus, _pv);
}

//+---------------------------------------------------------------------------
//
// OnPushContext
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::OnPushContext(ITfContext *pic)
{
    if (!_pfnICCallback)
        return S_OK;

    return _pfnICCallback(TIM_CODE_INITIC, pic, _pv);
}

//+---------------------------------------------------------------------------
//
// OnPopDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CThreadMgrEventSink::OnPopContext(ITfContext *pic)
{
    if (!_pfnICCallback)
        return S_OK;

    return _pfnICCallback(TIM_CODE_UNINITIC, pic, _pv);
}

//+---------------------------------------------------------------------------
//
// Advise
//
//----------------------------------------------------------------------------

HRESULT CThreadMgrEventSink::_Advise(ITfThreadMgr *tim)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _tim = NULL;
    hr = E_FAIL;

    if (tim->QueryInterface(IID_ITfSource, (void **)&source) != S_OK)
        goto Exit;

    if (source->AdviseSink(IID_ITfThreadMgrEventSink, this, &_dwCookie) != S_OK)
        goto Exit;

    _tim = tim;
    _tim->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Unadvise
//
//----------------------------------------------------------------------------

HRESULT CThreadMgrEventSink::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_tim == NULL)
        goto Exit;

    if (_tim->QueryInterface(IID_ITfSource, (void **)&source) != S_OK)
        goto Exit;

    if (source->UnadviseSink(_dwCookie) != S_OK)
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_tim);
    return hr;
}

//+---------------------------------------------------------------------------
//
// InitDIMs
//
//  This is a simple helper function to enumerate DIMs and ICs.
//  When the tips is activated, it can call this method to call callbacks
//  for exsiting DIMs and ICs.
//  
//----------------------------------------------------------------------------

HRESULT CThreadMgrEventSink::_InitDIMs(BOOL fInit)
{
    IEnumTfDocumentMgrs *pEnumDim = NULL;
    ITfDocumentMgr *pdim = NULL;
    ITfDocumentMgr *pdimFocus = NULL;

    if (FAILED(_tim->GetFocus(&pdimFocus)))
        goto Exit;

    if (_tim->EnumDocumentMgrs(&pEnumDim) != S_OK)
        goto Exit;

    if (fInit)
    {
        while (pEnumDim->Next(1, &pdim, NULL) == S_OK)
        {
            if (_pfnDIMCallback)
                _pfnDIMCallback(TIM_CODE_INITDIM,  pdim, NULL, _pv);

            if (_pfnICCallback)
            {
                IEnumTfContexts *pEnumIc = NULL;
                if (SUCCEEDED(pdim->EnumContexts(&pEnumIc)))
                {
                    ITfContext *pic = NULL;
                    while (pEnumIc->Next(1, &pic, NULL) == S_OK)
                    {
                        _pfnICCallback(TIM_CODE_INITIC, pic, _pv);
                        pic->Release();
                    }
                    pEnumIc->Release();
                }
            }

            if (_pfnDIMCallback && (pdim == pdimFocus))
            {
                _pfnDIMCallback(TIM_CODE_SETFOCUS, pdim, NULL, _pv);
            }

            pdim->Release();
        }
    }
    else
    {
        while (pEnumDim->Next(1, &pdim, NULL) == S_OK)
        {
            if (_pfnDIMCallback && (pdim == pdimFocus))
            {
                _pfnDIMCallback(TIM_CODE_SETFOCUS, NULL, pdim, _pv);
            }

            if (_pfnICCallback)
            {
                IEnumTfContexts *pEnumIc = NULL;
                if (SUCCEEDED(pdim->EnumContexts(&pEnumIc)))
                {
                    ITfContext *pic = NULL;
                    while (pEnumIc->Next(1, &pic, NULL) == S_OK)
                    {
                        _pfnICCallback(TIM_CODE_UNINITIC, pic, _pv);
                        pic->Release();
                    }
                    pEnumIc->Release();
                }
            }

            if (_pfnDIMCallback)
                _pfnDIMCallback(TIM_CODE_UNINITDIM, pdim, NULL, _pv);

            pdim->Release();
        }
    }

Exit:
    SafeRelease(pEnumDim);
    SafeRelease(pdimFocus);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\ptrary.cpp ===
//
// ptrary.cpp
//
// CPtrArray
//

#include "private.h"
#include "ptrary.h"
#include "mem.h"

//+---------------------------------------------------------------------------
//
// Insert(int iIndex, int cElems)
//
// Grows the array to accomodate cElems at offset iIndex.
//
// The new cells are NOT initialized!
//
//----------------------------------------------------------------------------

BOOL CVoidPtrArray::Insert(int iIndex, int cElems)
{
    void **ppv;
    int iSizeNew;

    Assert(iIndex >= 0);
    Assert(iIndex <= _cElems);
    Assert(cElems >= 0);

    if (cElems == 0)
        return TRUE;

    // allocate space if necessary
    if (_iSize < _cElems + cElems)
    {
        // allocate 1.5x what we need to avoid future allocs
        iSizeNew = max(_cElems + cElems, _cElems + _cElems / 2);

        if ((ppv = (_rgpv == NULL) ? (void **)cicMemAlloc(iSizeNew*sizeof(void *)) :
                                     (void **)cicMemReAlloc(_rgpv, iSizeNew*sizeof(void *)))
            == NULL)
        {
            return FALSE;
        }

        _rgpv = ppv;
        _iSize = iSizeNew;
    }

    if (iIndex < _cElems)
    {
        // make room for the new addition
        memmove(&_rgpv[iIndex + cElems], &_rgpv[iIndex], (_cElems - iIndex)*sizeof(void *));
    }

    _cElems += cElems;
    Assert(_iSize >= _cElems);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Remove(int Index, int cElems)
//
// Removes cElems at offset iIndex.
//
//----------------------------------------------------------------------------

void CVoidPtrArray::Remove(int iIndex, int cElems)
{
    int iSizeNew;

    Assert(cElems > 0);
    Assert(iIndex >= 0);
    Assert(iIndex + cElems <= _cElems);

    if (iIndex + cElems < _cElems)
    {
        // shift following eles left
        memmove(&_rgpv[iIndex], &_rgpv[iIndex + cElems], (_cElems - iIndex - cElems)*sizeof(void *));
    }

    _cElems -= cElems;

    // free mem when array contents uses less than half alloc'd mem
    iSizeNew = _iSize / 2;
    if (iSizeNew > _cElems)
    {
        CompactSize(iSizeNew);
    }
}

//+---------------------------------------------------------------------------
//
// Move
//
// Move an entry from one position to another, shifting other entries as
// appropriate to maintain the array size.
//
// The entry currently at iIndexNew will follow the moved entry on return.
//
// Returns the new index, which will be iIndexNew or iIndexNew - 1 if
// iIndexOld < iIndexNew.
//----------------------------------------------------------------------------

int CVoidPtrArray::Move(int iIndexNew, int iIndexOld)
{
    int iSrc;
    int iDst;
    int iActualNew;
    void *pv;
    int c;

    Assert(iIndexOld >= 0);
    Assert(iIndexOld < _cElems);
    Assert(iIndexNew >= 0);

    if (iIndexOld == iIndexNew)
        return iIndexOld;

    pv = _rgpv[iIndexOld];
    if (iIndexOld < iIndexNew)
    {
        c = iIndexNew - iIndexOld - 1;
        iSrc = iIndexOld + 1;
        iDst = iIndexOld;
        iActualNew = iIndexNew - 1;
    }
    else
    {
        c = iIndexOld - iIndexNew;
        iSrc = iIndexOld - c;
        iDst = iIndexOld - c + 1;
        iActualNew = iIndexNew;
    }
    Assert(iActualNew >= 0);
    Assert(iActualNew < _cElems);

    memmove(&_rgpv[iDst], &_rgpv[iSrc], c*sizeof(void *));

    _rgpv[iActualNew] = pv;

    return iActualNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <ole2.h>
#include <debug.h>
#include <mlang.h>
#include <limits.h>
#include "common.h"
#include "msctf.h"
#include "helpers.h"
#include "mem.h" // must be last

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\proputil.cpp ===
#include "private.h"
#include "proputil.h"
#include "immxutil.h"
#include "helpers.h"


//+---------------------------------------------------------------------------
//
// HrVariantToBlob
//
// cbvalue: on sizeof VARTYPE
//
//----------------------------------------------------------------------------

HRESULT HrVariantToBlob(VARIANT *pv, void *pvalue, ULONG *pcbvalue, VARTYPE vt)
{
    HRESULT hr = S_OK;
    SAFEARRAY *psa = NULL;
    void *pdata = NULL;
    int lb, ub;
    int iElemSize;
    ULONG cbvalue;

    while (V_VT(pv) == (VT_BYREF | VT_VARIANT))
        pv = V_VARIANTREF(pv);

    if (V_VT(pv) != (VT_ARRAY | vt)) 
        return E_FAIL;

    psa = V_ARRAY(pv);

    hr = SafeArrayLock(psa);
    if (FAILED(hr)) 
        goto Ret;

    hr = SafeArrayGetLBound(psa, 1, (LONG *)&lb);
    if (FAILED(hr)) 
        goto Ret;

    hr = SafeArrayGetUBound(psa, 1, (LONG *)&ub);
    if (FAILED(hr)) 
        goto Ret;

    iElemSize = SafeArrayGetElemsize(psa);
    cbvalue = ub - lb + 1;

    if (cbvalue * iElemSize > *pcbvalue)
    {
        hr = E_FAIL;
        goto Ret;
    }

    hr = SafeArrayAccessData(psa, (void **)&pdata);
    if (FAILED(hr)) 
        goto Ret;

    memcpy(pvalue, pdata, cbvalue * iElemSize);

    hr = SafeArrayUnaccessData(psa);
    if (FAILED(hr)) 
        goto Ret;

    *pcbvalue = cbvalue;

Ret:
    if (psa) SafeArrayUnlock(psa);
    return hr;
}

//+---------------------------------------------------------------------------
//
// HrBlobToVariant
//
// cbvalue: on sizeof VARTYPE
//
//----------------------------------------------------------------------------

HRESULT HrBlobToVariant(const void *value, ULONG cbvalue, VARIANT *pv, VARTYPE vt)
{
    HRESULT hr = S_OK;
    SAFEARRAY *psa = NULL;
    SAFEARRAYBOUND rsabound[1];
    void *pdata = NULL;
    int iElemSize;
    
    rsabound[0].lLbound = 0;
    rsabound[0].cElements = cbvalue;
    if (!(psa = SafeArrayCreate(vt, 1, rsabound)))
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }

    iElemSize = SafeArrayGetElemsize(psa);

    hr = SafeArrayAccessData(psa, (void **)&pdata);
    if (FAILED(hr)) 
        goto Ret;

    memcpy(pdata, value, cbvalue * iElemSize);

    hr = SafeArrayUnaccessData(psa);
    if (FAILED(hr)) 
        goto Ret;

    V_VT(pv) = VT_ARRAY | vt;
    V_ARRAY(pv) = psa;
    psa = NULL;

Ret:
    if (psa) SafeArrayDestroy(psa);
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetGUIDPropertyData
//
//----------------------------------------------------------------------------

HRESULT GetGUIDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, TfGuidAtom *pguid)
{
    VARIANT var;
    HRESULT hr = E_FAIL;

    *pguid = TF_INVALID_GUIDATOM;

    if (SUCCEEDED(pProp->GetValue(ec, pRange, &var)))
    {
        if (var.vt == VT_I4)
            *pguid = (TfGuidAtom)var.lVal;

        // no need to VariantClear because VT_I4
        hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetGUIDPropertyData
//
//----------------------------------------------------------------------------

HRESULT SetGUIDPropertyData(LIBTHREAD *plt, TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, REFGUID rguid)
{
    VARIANT var;
    GUID guid = rguid;

    var.vt = VT_I4;
    GetGUIDATOMFromGUID(plt, guid, (TfGuidAtom *)&var.lVal);

    return pProp->SetValue(ec, pRange, &var);
}

//+---------------------------------------------------------------------------
//
// VarToLangId
//
//----------------------------------------------------------------------------

WORD VarToWORD(VARIANT *pv)
{
    if (V_VT(pv) == VT_I2)
        return (WORD)V_I2(pv);

    return 0;
}

//+---------------------------------------------------------------------------
//
// SetLangToVar
//
//----------------------------------------------------------------------------

void SetWORDToVar(VARIANT *pv, WORD w)
{
    V_VT(pv) = VT_I2;
    V_I2(pv) = w;
}

//+---------------------------------------------------------------------------
//
// GetDWORDPropertyData
//
//----------------------------------------------------------------------------

HRESULT GetDWORDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, DWORD *pdw)
{
    VARIANT var;
    HRESULT hr = E_FAIL;

    if (pProp->GetValue(ec, pRange, &var) == S_OK)
    {
        Assert(var.vt == VT_I4); // expecting DWORD
        *pdw = var.lVal;
        // no need to VariantClear because VT_I4
        hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetDWORDPropertyData
//
//----------------------------------------------------------------------------

HRESULT SetDWORDPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, DWORD dw)
{
    VARIANT var;

    if (!dw)
    {
        return pProp->Clear(ec, pRange);
    }

    var.vt = VT_I4;
    var.lVal = dw;

    return pProp->SetValue(ec, pRange, &var);
}

//+---------------------------------------------------------------------------
//
// GetBSTRPropertyData
//
//----------------------------------------------------------------------------

HRESULT GetBSTRPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR *pbstr)
{
    VARIANT var = { 0 };
    HRESULT hr = E_FAIL;

    *pbstr = NULL;

    if (pProp->GetValue(ec, pRange, &var) != S_OK)
        return E_FAIL;

    if (var.vt != VT_BSTR)
        goto Exit;

    *pbstr = SysAllocString(var.bstrVal);

    if (*pbstr)
        hr = S_OK;
    else
        hr = E_OUTOFMEMORY;

Exit:
    VariantClear(&var);
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetBSTRPropertyData
//
//----------------------------------------------------------------------------

HRESULT SetBSTRPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR bstr)
{
    VARIANT var;
    HRESULT hr;

    if (!bstr)
        return pProp->Clear(ec, pRange);

    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(bstr);

    if (!var.bstrVal)
         return E_OUTOFMEMORY;

    hr = pProp->SetValue(ec, pRange, &var);

    VariantClear(&var);

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetUnknownPropertyData
//
//----------------------------------------------------------------------------

HRESULT GetUnknownPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, IUnknown **ppunk)
{
    VARIANT var = { 0 };

    *ppunk = NULL;

    if (pProp->GetValue(ec, pRange, &var) != S_OK)
        return E_FAIL;

    if (var.vt != VT_UNKNOWN)
        goto Exit;

    *ppunk = var.punkVal;
    (*ppunk)->AddRef();

Exit:
    VariantClear(&var);
    return (*ppunk == NULL) ? E_FAIL : S_OK;
}

//+---------------------------------------------------------------------------
//
// SetUnknownPropertyData
//
//----------------------------------------------------------------------------

HRESULT SetUnknownPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, IUnknown *punk)
{
    VARIANT var;

    if (!punk)
        return pProp->Clear(ec, pRange);

    var.vt = VT_UNKNOWN;
    var.punkVal = punk;

    return pProp->SetValue(ec, pRange, &var);
}

//+---------------------------------------------------------------------------
//
// GetReadingStrPropertyData
//
//----------------------------------------------------------------------------

HRESULT GetReadingStrPropertyData(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, BSTR *pbstr)
{
    return GetBSTRPropertyData(ec, pProp, pRange, pbstr);
}


//+---------------------------------------------------------------------------
//
// SetIntAttribute
//
//----------------------------------------------------------------------------

void SetIntAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, int nData)
{
    WCHAR wch[32];

    NumToW((DWORD)nData, wch);
    SetCharAttribute(pElem, pszTag, wch);
}

//+---------------------------------------------------------------------------
//
// SetCharAttribute
//
//----------------------------------------------------------------------------

void SetCharAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, WCHAR *pszData)
{
    VARIANT var;
    BSTR bstrTmp = SysAllocString(pszTag);
    BSTR bstrTmp2;

    if (!bstrTmp)
        return;

    bstrTmp2 = SysAllocString(pszData);

    if (bstrTmp2)
    {
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = bstrTmp2;

        pElem->setAttribute(bstrTmp, var);
    }

    VariantClear(&var);
    SysFreeString(bstrTmp);
}

//+---------------------------------------------------------------------------
//
// GetIntAttribute
//
//----------------------------------------------------------------------------

HRESULT GetIntAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, int *pnRet)
{
    WCHAR wch[32];
    if (FAILED(GetCharAttribute(pElem, pszTag, wch, ARRAYSIZE(wch))))
        return E_FAIL;

    *pnRet = (int)WToNum(wch);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetCharAttribute
//
//----------------------------------------------------------------------------

HRESULT GetCharAttribute(IXMLDOMElement *pElem, WCHAR *pszTag, WCHAR *pszData, int nSize)
{
    BSTR bstrTmp;
    VARIANT var;
    int nData = 0;
    HRESULT hr = E_FAIL;

    *pszData = L'\0';
    QuickVariantInit(&var);
    bstrTmp = SysAllocString(pszTag);

    if (!bstrTmp)
        return E_OUTOFMEMORY;

    if (SUCCEEDED(pElem->getAttribute(bstrTmp, &var)))
    {
        if (V_VT(&var) == VT_BSTR)
        {
            if (wcsncpy(pszData, V_BSTR(&var), nSize))
                hr = S_OK;
        }
    }
    SysFreeString(bstrTmp);
    VariantClear(&var);

    return hr;
}

//+---------------------------------------------------------------------------
//
// SetTextAndProperty
//
//----------------------------------------------------------------------------

HRESULT SetTextAndProperty(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, const WCHAR *pchText, LONG cchText, LANGID langid, const GUID *pattr)
{
    HRESULT hr;

    // Issue: sometimes we want to set TFST_CORRECTION
    hr = pRange->SetText(ec, 0, pchText, cchText);

    if (SUCCEEDED(hr) && cchText)
    {
        ITfProperty *pProp = NULL;

        // set langid 
        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LANGID, &pProp)))
        {
            SetLangIdPropertyData(ec, pProp, pRange, langid);
            pProp->Release();
        }
  
        if (pattr)
        {
            // set attr 
            if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp)))
            {
                hr = SetAttrPropertyData(plt, ec, pProp, pRange, *pattr);
                pProp->Release();
            }

        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// SetTextAndReading
//
//----------------------------------------------------------------------------

HRESULT SetTextAndReading(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, const WCHAR *pchText, LONG cchText, LANGID langid, const WCHAR *pszRead)
{
    ITfProperty *pProp;
    HRESULT hr;

    hr = SetTextAndProperty(plt, ec, pic, pRange, pchText, cchText, langid, NULL);

    if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_READING, &pProp)))
    {
        BSTR bstr = SysAllocString(pszRead);

        if (bstr)
        {
            SetBSTRPropertyData(ec, pProp, pRange, bstr);
            SysFreeString(bstr);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        pProp->Release();
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
// IsOwnerAndFocus
//
// This is service function for EnumTrackTextAndFocus.
//
//----------------------------------------------------------------------------

BOOL IsOwnerAndFocus(LIBTHREAD *plt, TfEditCookie ec, REFCLSID rclsid, ITfReadOnlyProperty *pProp, ITfRange *pRange)
{
    IEnumTfPropertyValue *pEnumPropVal;
    BOOL bRet = FALSE;
    VARIANT var;
    ULONG iTextOwner;
    ULONG iFocus;
    TF_PROPERTYVAL rgValue[2];

    if (SUCCEEDED(pProp->GetValue(ec, pRange, &var)))
    {
        Assert(var.vt == VT_UNKNOWN);

        if (SUCCEEDED(var.punkVal->QueryInterface(IID_IEnumTfPropertyValue, 
                                                (void **)&pEnumPropVal)))
        {
            if (pEnumPropVal->Next(2, rgValue, NULL) == S_OK)
            {
                Assert(rgValue[0].varValue.vt == VT_I4);
                Assert(rgValue[1].varValue.vt == VT_I4);

                // Issue: should we change the spec so the order is guaranteed maintained?
                if (IsEqualGUID(rgValue[0].guidId, GUID_PROP_TEXTOWNER))
                {
                    Assert(IsEqualGUID(rgValue[1].guidId, GUID_PROP_COMPOSING));
                    iTextOwner = 0;
                    iFocus = 1;
                }
                else
                {
                    iTextOwner = 1;
                    iFocus = 0;
                }

                // does the owner match rclisd?
                if (IsEqualTFGUIDATOM(plt, (TfGuidAtom)rgValue[iTextOwner].varValue.lVal, rclsid))
                {
                    // is the focus property set (not VT_EMPTY) and is it set TRUE?
                    bRet = (rgValue[iFocus].varValue.vt == VT_I4 && rgValue[iFocus].varValue.lVal != 0);
                }
            }
            pEnumPropVal->Release();
        }
        VariantClear(&var);
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// EnumTrackTextAndFocus
//
//----------------------------------------------------------------------------

HRESULT EnumTrackTextAndFocus(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfReadOnlyProperty **ppProp, IEnumTfRanges **ppEnumTrack)
{
    static const GUID *rgguidProp[2] = { &GUID_PROP_TEXTOWNER, &GUID_PROP_COMPOSING };

    ITfReadOnlyProperty *pPropTrack = NULL;
    HRESULT hr;

    *ppEnumTrack = NULL;
    *ppProp = NULL;

    if (SUCCEEDED(hr = pic->TrackProperties(rgguidProp, ARRAYSIZE(rgguidProp),
                                            0, NULL,
                                            &pPropTrack)))

    {
        hr = pPropTrack->EnumRanges(ec, ppEnumTrack, pRange);
        *ppProp = pPropTrack;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// IsGUIDProp
//
//----------------------------------------------------------------------------

BOOL IsGUIDProp(LIBTHREAD *plt, TfEditCookie ec, REFGUID rclsid, ITfProperty *pProp, ITfRange *pRange)
{
    TfGuidAtom guidatom;
    if (SUCCEEDED(GetGUIDPropertyData(ec, pProp, pRange, &guidatom)))
    {
        if (IsEqualTFGUIDATOM(plt, guidatom, rclsid))
        {
            return TRUE;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// AdjustRangeByProperty
//
//----------------------------------------------------------------------------

HRESULT AdjustRangeByTextOwner(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRange, REFCLSID rclsid)
{
    ITfProperty *pProp;
    ITfRange *pRangeStart = NULL;
    ITfRange *pRangeEnd = NULL;
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(pic->GetProperty(GUID_PROP_TEXTOWNER, &pProp)))
    {
        BOOL fEmpty = FALSE;

        pRange->IsEmpty(ec, &fEmpty);

        if (fEmpty)
        {
            pProp->FindRange(ec, pRange, &pRangeStart, TF_ANCHOR_START);
        }
        else
        {
            pProp->FindRange(ec, pRange, &pRangeStart, TF_ANCHOR_START);
            pProp->FindRange(ec, pRange, &pRangeEnd, TF_ANCHOR_END);
        }
        pProp->Release();
    }
    
    if (!pRangeStart)
        goto Exit;

    if (pRangeEnd)
    {
        pRangeStart->ShiftEndToRange(ec, pRangeEnd, TF_ANCHOR_END);
    }

    pRangeStart->Clone(ppRange);
    hr = S_OK;

Exit:
    SafeRelease(pRangeStart);
    SafeRelease(pRangeEnd);
    return hr;
}

//+---------------------------------------------------------------------------
//
// AdjustRangeByAttribute
//
//----------------------------------------------------------------------------

HRESULT AdjustRangeByAttribute(LIBTHREAD *plt, TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRange, const GUID *rgRGuid, int cGuid)
{
    ITfProperty *pProp;
    ITfRange *pRangeStart = NULL;
    ITfRange *pRangeEnd = NULL;
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp)))
    {
        IEnumTfRanges *pEnumProp;
        if (SUCCEEDED(pProp->EnumRanges(ec, &pEnumProp, pRange)))
        {
            ITfRange *pRangeProp;
            //
            // first range.
            //
            while (!pRangeStart && 
                   pEnumProp->Next(1, &pRangeProp, NULL) == S_OK)
            {
 
                for ( int i = 0; i < cGuid; i++ )
                {
                    if (IsGUIDProp(plt, ec, rgRGuid[i], pProp, pRangeProp))
                    {
                        pRangeProp->Clone(&pRangeStart);
                    }
                }
                pRangeProp->Release();
            }

            if (pRangeStart)
            {
                //
                // last range.
                //
                while (pEnumProp->Next(1, &pRangeProp, NULL) == S_OK)
                {
                    for ( int i = 0; i < cGuid; i++ )
                    {
                        if (IsGUIDProp(plt, ec, rgRGuid[i], pProp, pRangeProp))
                        {   
                            SafeRelease(pRangeEnd);
                            pRangeProp->Clone(&pRangeEnd);
                        }
                    }
                    pRangeProp->Release();
                }
            }
            pEnumProp->Release();
        }
        pProp->Release();
    }
    
    if (!pRangeStart)
        goto Exit;

    if (pRangeEnd)
    {
        pRangeStart->ShiftEndToRange(ec, pRangeEnd, TF_ANCHOR_END);
    }

    pRangeStart->Clone(ppRange);
    hr = S_OK;

Exit:
    SafeRelease(pRangeStart);
    SafeRelease(pRangeEnd);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\regimx.cpp ===
//
// regimx.cpp
//

#include "private.h"
#include "regimx.h"
#include "xstring.h"
#include "catutil.h"
#include "msctfp.h"

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//+---------------------------------------------------------------------------
//
// RegisterTIP
//
//----------------------------------------------------------------------------

BOOL RegisterTIP(HINSTANCE hInst, REFCLSID rclsid, WCHAR *pwszDesc, const REGTIPLANGPROFILE *plp)
{
    ITfInputProcessorProfiles *pReg = NULL;
    ITfInputProcessorProfilesEx *pRegEx = NULL;
    HRESULT hr;
    
    // register ourselves with the ActiveIMM
    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, 
                          CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pReg);
    if (FAILED(hr))
        goto Exit;

    hr = pReg->Register(rclsid);

    if (FAILED(hr))
        goto Exit;

    pReg->QueryInterface(IID_ITfInputProcessorProfilesEx, (void**)&pRegEx);

    while (plp->langid)
    {
        WCHAR wszFilePath[MAX_PATH];
        WCHAR *pv = &wszFilePath[0];

        wszFilePath[0] = L'\0';

        if (plp->szIconFile[0] != L'\0')
        {
            char szFilePath[MAX_PATH];
            WCHAR *pvCur;

            if (0 != 
                GetModuleFileName(hInst, szFilePath, ARRAYSIZE(szFilePath)))
            {
                StringCchCopyW(wszFilePath, ARRAYSIZE(wszFilePath), AtoW(szFilePath));
            }

            pv = pvCur = &wszFilePath[0];
            while (*pvCur)
            { 
                if (*pvCur == L'\\')
                    pv = pvCur + 1;
                pvCur++;
            }
            *pv = L'\0';
           
        }
        StringCchCopyW(pv, ARRAYSIZE(wszFilePath), plp->szIconFile);
        
        pReg->AddLanguageProfile(rclsid, 
                                 plp->langid, 
                                 *plp->pguidProfile, 
                                 plp->szProfile, 
                                 wcslen(plp->szProfile),
                                 wszFilePath,
                                 wcslen(wszFilePath),
                                 plp->uIconIndex);

        if (pRegEx && plp->uDisplayDescResIndex)
        {
            pRegEx->SetLanguageProfileDisplayName(rclsid, 
                                                  plp->langid, 
                                                  *plp->pguidProfile, 
                                                  wszFilePath,
                                                  wcslen(wszFilePath),
                                                  plp->uDisplayDescResIndex);
        }

        plp++;
    }

    RegisterGUIDDescription(rclsid, rclsid, pwszDesc);
Exit:
    SafeRelease(pReg);
    SafeRelease(pRegEx);
    return SUCCEEDED(hr);
}

//+---------------------------------------------------------------------------
//
// UnregisterTIP
//
//----------------------------------------------------------------------------

BOOL UnregisterTIP(REFCLSID rclsid)
{
    ITfInputProcessorProfiles *pReg;
    HRESULT hr;

    UnregisterGUIDDescription(rclsid, rclsid);

    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, 
                          CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pReg);
    if (FAILED(hr))
        goto Exit;

    hr = pReg->Unregister(rclsid);
    pReg->Release();

Exit:

    return FAILED(hr) ? FALSE : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\mem.cpp ===
//
// mem.cpp
//

#include "private.h"
#include "mem.h"
#ifdef USECRT
#include <malloc.h>
#endif

#ifndef DEBUG

///////////////////////////////////////////////////////////////////////////////
//
// RETAIL memory functions.
//
///////////////////////////////////////////////////////////////////////////////

extern "C" void *cicMemAlloc(UINT uCount)
{
#ifdef USECRT
    return malloc(uCount);
#else
    return LocalAlloc(LMEM_FIXED, uCount);
#endif
}

extern "C" void *cicMemAllocClear(UINT uCount)
{
#ifdef USECRT
    return calloc(uCount, 1);
#else
    return LocalAlloc(LPTR, uCount);
#endif
}

extern "C" void cicMemFree(void *pv)
{
#ifdef USECRT
    free(pv);
#else
    HLOCAL hLocal;

    hLocal = LocalFree(pv);

    Assert(hLocal == NULL);
#endif
}

extern "C" void *cicMemReAlloc(void *pv, UINT uCount)
{
#ifdef USECRT
    return realloc(pv, uCount);
#else
    return LocalReAlloc((HLOCAL)pv, uCount, LMEM_MOVEABLE | LMEM_ZEROINIT);
#endif
}

extern "C" UINT cicMemSize(void *pv)
{
#ifdef USECRT
    return _msize(pv);
#else
    return (UINT)LocalSize((HLOCAL)pv);
#endif
}

#else // DEBUG

///////////////////////////////////////////////////////////////////////////////
//
// DEBUG memory functions.
//
///////////////////////////////////////////////////////////////////////////////

#define MEM_SUSPICIOUSLY_LARGE_ALLOC    0x1000000 // 16MB

// All the debug state goes here.
// Be thread safe: make sure you hold s_Dbg_cs before touching/reading anything!

DBG_MEMSTATS s_Dbg_MemStats = { 0 };

DBG_MEM_COUNTER *s_rgCounters = NULL;

static CRITICAL_SECTION s_Dbg_cs;

static void *s_Dbg_pvBreak = (void *)-1; // set this to something to break on at runtime in MemAlloc/MemAllocClear/MemReAlloc

extern "C" TCHAR *Dbg_CopyString(const TCHAR *pszSrc)
{
    TCHAR *pszCpy;
    int c;

    c = lstrlen(pszSrc)+1;
    pszCpy = (TCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, c*sizeof(TCHAR));

    if (pszCpy != NULL)
    {
        memcpy(pszCpy, pszSrc, c*sizeof(TCHAR));
    }

    return pszCpy;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemInit
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemInit(const TCHAR *pszName, DBG_MEM_COUNTER *rgCounters)
{
    InitializeCriticalSection(&s_Dbg_cs);

    s_Dbg_MemStats.pszName = Dbg_CopyString(pszName);
    s_rgCounters = rgCounters;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemUninit
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemUninit()
{
    DBG_MEMALLOC *pdma;
    DBG_MEMALLOC *pdmaTmp;
    TCHAR achID[64];
    BOOL bMemLeak = FALSE;

    // dump stats
    Dbg_MemDumpStats();

    // everything free?
    pdma = s_Dbg_MemStats.pMemAllocList;

    if (pdma != NULL ||
        s_Dbg_MemStats.uTotalAlloc != s_Dbg_MemStats.uTotalFree) // second test necessary to catch size 0 objects
    {
        TraceMsg(TF_GENERAL, "%s: Memory leak detected! %x total bytes leaked!",
            s_Dbg_MemStats.pszName, s_Dbg_MemStats.uTotalAlloc - s_Dbg_MemStats.uTotalFree);
        bMemLeak = TRUE;
    }

    while (pdma != NULL)
    {
        if (pdma->dwID == DWORD(-1))
        {
            achID[0] = '\0';
        }
        else
        {
            wsprintf(achID, " (ID = 0x%x)", pdma->dwID);
        }

        TraceMsg(TF_GENERAL, "       Address: %8.8lx     Size: %8.8lx    TID: %8.8lx    %s%s%s line %i %s",
            pdma->pvAlloc, pdma->uCount, pdma->dwThreadID, pdma->pszName ? pdma->pszName : "", pdma->pszName ? " -- " : "", pdma->pszFile, pdma->iLine, achID);

        // free the DBG_MEMALLOC
        pdmaTmp = pdma->next;
        LocalFree(pdma->pszName);
        LocalFree(pdma);
        pdma = pdmaTmp;
    }

    // Assert after tracing.
    if (bMemLeak)
        AssertPrivate(0);

    s_Dbg_MemStats.pMemAllocList = NULL; // in case someone wants to call Dbg_MemInit again

    DeleteCriticalSection(&s_Dbg_cs);

    LocalFree(s_Dbg_MemStats.pszName);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemDumpStats
//
//----------------------------------------------------------------------------

extern "C" void Dbg_MemDumpStats()
{
    EnterCriticalSection(&s_Dbg_cs);

    TraceMsg(TF_GENERAL, "Memory: %s allocated %x bytes, freed %x bytes.",
        s_Dbg_MemStats.pszName, s_Dbg_MemStats.uTotalAlloc, s_Dbg_MemStats.uTotalFree);

    if (s_Dbg_MemStats.uTotalAlloc != s_Dbg_MemStats.uTotalFree)
    {
        TraceMsg(TF_GENERAL, "Memory: %s %x bytes currently allocated.",
            s_Dbg_MemStats.pszName, s_Dbg_MemStats.uTotalAlloc - s_Dbg_MemStats.uTotalFree);
    }

    TraceMsg(TF_GENERAL, "Memory:   %x MemAlloc", s_Dbg_MemStats.uTotalMemAllocCalls);
    TraceMsg(TF_GENERAL, "Memory:   %x MemAllocClear", s_Dbg_MemStats.uTotalMemAllocClearCalls);
    TraceMsg(TF_GENERAL, "Memory:   %x MemReAlloc", s_Dbg_MemStats.uTotalMemReAllocCalls);
    TraceMsg(TF_GENERAL, "Memory:   %x MemFree", s_Dbg_MemStats.uTotalMemFreeCalls);

    LeaveCriticalSection(&s_Dbg_cs);
}


//+---------------------------------------------------------------------------
//
// Dbg_MemAlloc
//
//----------------------------------------------------------------------------

extern "C" void *Dbg_MemAlloc(UINT uCount, const TCHAR *pszFile, int iLine)
{
    void *pv;
    DBG_MEMALLOC *pdma;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemAllocCalls);

    if (uCount == 0)
    {
        TraceMsg(TF_GENERAL, "Zero size memory allocation! %s line %i", pszFile, iLine);
        //Assert(0);
    }
    if (uCount >= MEM_SUSPICIOUSLY_LARGE_ALLOC)
    {
        TraceMsg(TF_GENERAL, "Suspiciously large memory allocation (0x%x bytes)! %s line %i", uCount, pszFile, iLine);
        Assert(0);
    }

    pv = LocalAlloc(LMEM_FIXED, uCount);

    if (pv == NULL)
        return NULL;

    //
    // record this allocation
    //

    if ((pdma = (DBG_MEMALLOC *)LocalAlloc(LPTR, sizeof(DBG_MEMALLOC))) == NULL)
    {
        // this is a transaction -- fail if we can't allocate the debug info
        LocalFree(pv);
        return NULL;
    }

    pdma->pvAlloc = pv;
    pdma->uCount = uCount;
    pdma->pszFile = pszFile;
    pdma->iLine = iLine;
    pdma->dwThreadID = GetCurrentThreadId();
    pdma->dwID = (DWORD)-1;

    EnterCriticalSection(&s_Dbg_cs);

    pdma->next = s_Dbg_MemStats.pMemAllocList;
    s_Dbg_MemStats.pMemAllocList = pdma;

    //
    // update global stats
    //

    s_Dbg_MemStats.uTotalAlloc += uCount;

    LeaveCriticalSection(&s_Dbg_cs);

    if (pv == s_Dbg_pvBreak)
        Assert(0);

    return pv;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemAllocClear
//
//----------------------------------------------------------------------------

extern "C" void *Dbg_MemAllocClear(UINT uCount, const TCHAR *pszFile, int iLine)
{
    void *pv;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemAllocClearCalls);
    InterlockedDecrement(&s_Dbg_MemStats.uTotalMemAllocCalls); // compensate for wrapping

    pv = Dbg_MemAlloc(uCount, pszFile, iLine);

    if (pv != NULL)
    {
        // clear out the mem
        memset(pv, 0, uCount);
    }
    
    return pv;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemFree
//
//----------------------------------------------------------------------------

extern "C" void Dbg_MemFree(void *pv)
{
    HLOCAL hLocal;
    DBG_MEMALLOC *pdma;
    DBG_MEMALLOC **ppdma;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemFreeCalls);

    if (pv != NULL) // MemFree(NULL) is legal
    {
        EnterCriticalSection(&s_Dbg_cs);

        // was this guy allocated?
        ppdma = &s_Dbg_MemStats.pMemAllocList;

        if (ppdma)
        {
            while ((pdma = *ppdma) && pdma->pvAlloc != pv)
            {
                ppdma = &pdma->next;
            }

            if (pdma != NULL)
            {
                // found it, update and delete
                s_Dbg_MemStats.uTotalFree += pdma->uCount;
                *ppdma = pdma->next;
                LocalFree(pdma->pszName);
                LocalFree(pdma);
            }
            else
            {
                TraceMsg(TF_GENERAL, "%s: MemFree'ing a bogus pointer %x!", s_Dbg_MemStats.pszName, pv);
                // Assert(0); // freeing bogus pointer
            }
        }
        else
        {
            Assert(0); // freeing bogus pointer
        }

        LeaveCriticalSection(&s_Dbg_cs);
    }

    hLocal = LocalFree(pv);
    Assert(hLocal == NULL);
}

//+---------------------------------------------------------------------------
//
// Dbg_MemReAlloc
//
//----------------------------------------------------------------------------

extern "C" void *Dbg_MemReAlloc(void *pv, UINT uCount, const TCHAR *pszFile, int iLine)
{
    DBG_MEMALLOC *pdma;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemReAllocCalls);

    EnterCriticalSection(&s_Dbg_cs);

    void * pvNew = NULL;
    // was this guy allocated?
    for (pdma = s_Dbg_MemStats.pMemAllocList; pdma != NULL && pdma->pvAlloc != pv; pdma = pdma->next)
        ;

    if (pdma == NULL)
    {
        // can't find this guy!
        TraceMsg(TF_GENERAL, "%s: MemReAlloc'ing a bogus pointer %x!", s_Dbg_MemStats.pszName, pv);
        Assert(0); // bogus pointer

        pv = NULL;
    }
    else
    {
        pvNew = LocalReAlloc((HLOCAL)pv, uCount, LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (pvNew != NULL)
        {
            // (LocalReAlloc succeeded)
            // pdma has reallocated block and total size of allocated memory should be updated here
            pdma->pvAlloc = pvNew;
            s_Dbg_MemStats.uTotalAlloc += (uCount - pdma->uCount);
            pdma->uCount = uCount;
            pdma->pszFile = pszFile;
            pdma->iLine = iLine;
        }
        // else 
        // (LocalReAlloc failed) we keep pdma as is
    }

    LeaveCriticalSection(&s_Dbg_cs);

    if (pv == s_Dbg_pvBreak)
        Assert(0);

    // return reallocated block if succeeded. 
    // return NULL if failed
    return pvNew;
}


//+---------------------------------------------------------------------------
//
// Dbg_MemSize
//
//----------------------------------------------------------------------------

extern "C" UINT Dbg_MemSize(void *pv)
{
    UINT uiSize;

    EnterCriticalSection(&s_Dbg_cs);

    uiSize = (UINT)LocalSize((HLOCAL)pv);

    LeaveCriticalSection(&s_Dbg_cs);

    return uiSize;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemSetName
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemSetName(void *pv, const TCHAR *pszName)
{
    return Dbg_MemSetNameIDCounter(pv, pszName, (DWORD)-1, (ULONG)-1);
}

//+---------------------------------------------------------------------------
//
// Dbg_MemSetNameID
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemSetNameID(void *pv, const TCHAR *pszName, DWORD dwID)
{
    return Dbg_MemSetNameIDCounter(pv, pszName, dwID, (ULONG)-1);
}

//+---------------------------------------------------------------------------
//
// Dbg_MemSetNameID
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemSetNameIDCounter(void *pv, const TCHAR *pszName, DWORD dwID, ULONG iCounter)
{
    DBG_MEMALLOC *pdma;
    BOOL f = FALSE;

    EnterCriticalSection(&s_Dbg_cs);

    for (pdma = s_Dbg_MemStats.pMemAllocList; pdma != NULL && pdma->pvAlloc != pv; pdma = pdma->next)
        ;

    if (pdma != NULL)
    {
        if (s_rgCounters != NULL && iCounter != (ULONG)-1)
        {
            s_rgCounters[iCounter].uCount++;
        }
        LocalFree(pdma->pszName);
        pdma->pszName = Dbg_CopyString(pszName);
        pdma->dwID = dwID;
        f = TRUE;
    }

    LeaveCriticalSection(&s_Dbg_cs);

    return f;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemGetName
//
// Pass in ccBuffer == 0 to get size of string only.
//
//----------------------------------------------------------------------------

extern "C" int Dbg_MemGetName(void *pv, TCHAR *pch, int ccBuffer)
{
    DBG_MEMALLOC *pdma;
    int cc;

    EnterCriticalSection(&s_Dbg_cs);

    for (pdma = s_Dbg_MemStats.pMemAllocList; pdma != NULL && pdma->pvAlloc != pv; pdma = pdma->next)
        ;

    if (pdma != NULL)
    {
        cc = lstrlen(pdma->pszName);
        if (ccBuffer > 0)
        {
            cc = min(cc, ccBuffer-1);
            memcpy(pch, pdma->pszName, cc);
            pch[cc] = '\0';
        }
    }
    else
    {
        if (ccBuffer > 0)
        {
            pch[0] = '\0';
        }
        cc = 0;
    }

    LeaveCriticalSection(&s_Dbg_cs);

    return cc;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\regsvr.cpp ===
//
// regsvr.cpp
//

#include "private.h"
#include "regsvr.h"
#include <advpub.h>


//+------------------------------------------------------------------------
//
//  Function:   CLSIDToString
//
//  Synopsis:   Converts a CLSID to an mbcs string.
//
//-------------------------------------------------------------------------

static const BYTE GuidMap[] = {3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
    8, 9, '-', 10, 11, 12, 13, 14, 15};

static const char szDigits[] = "0123456789ABCDEF";


BOOL CLSIDToStringA(REFGUID refGUID, char *pchA)
{
    int i;
    char *p = pchA;

    const BYTE * pBytes = (const BYTE *) &refGUID;

    *p++ = '{';
    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = '}';
    *p   = '\0';

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Function:   StringToCLSID
//
//  Synopsis:   Converts a CLSID to an mbcs string.
//
//-------------------------------------------------------------------------

BOOL HexStringToDword(LPCSTR &lpsz, DWORD &Value, int cDigits, WCHAR chDelim)
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

BOOL StringAToCLSID(char *pchA, GUID *pGUID)
{
    DWORD dw;
    char *lpsz = ++pchA;

    if (!HexStringToDword(lpsz, pGUID->Data1, sizeof(DWORD)*2, '-'))
        return FALSE;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
        return FALSE;

    pGUID->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
        return FALSE;

    pGUID->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))
        return FALSE;

    pGUID->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[6] = (BYTE)dw;
    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pGUID->Data4[7] = (BYTE)dw;

    return TRUE;
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG RecurseDeleteKey(HKEY hParentKey, LPCTSTR lpszKey)
{
    HKEY hKey;
    LONG lRes;
    FILETIME time;
    TCHAR szBuffer[256];
    DWORD dwSize = sizeof(szBuffer);

    if (RegOpenKey(hParentKey, lpszKey, &hKey) != ERROR_SUCCESS)
        return ERROR_SUCCESS; // let's assume we couldn't open it because it's not there

    lRes = ERROR_SUCCESS;
    while (RegEnumKeyEx(hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL, &time)==ERROR_SUCCESS)
    {
        lRes = RecurseDeleteKey(hKey, szBuffer);
        if (lRes != ERROR_SUCCESS)
            break;
        dwSize = sizeof(szBuffer);
    }
    RegCloseKey(hKey);

    return lRes == ERROR_SUCCESS ? RegDeleteKey(hParentKey, lpszKey) : lRes;
}


// set pszDesc == NULL to unregister, otherwise register
BOOL RegisterServer(REFCLSID clsid, LPCTSTR pszDesc, LPCTSTR pszPath, LPCTSTR pszModel, LPCTSTR pszSoftwareKey)
{
    static const TCHAR c_szInfoKeyPrefix[] = TEXT("CLSID\\");
    static const TCHAR c_szInProcSvr32[] = TEXT("InProcServer32");
    static const TCHAR c_szModelName[] = TEXT("ThreadingModel");

    TCHAR achIMEKey[ARRAYSIZE(c_szInfoKeyPrefix) + CLSID_STRLEN];
    DWORD dw;
    HKEY hKey;
    HKEY hSubKey;
    BOOL fRet;

    if (!CLSIDToStringA(clsid, achIMEKey + ARRAYSIZE(c_szInfoKeyPrefix) - 1))
        return FALSE;
    memcpy(achIMEKey, c_szInfoKeyPrefix, sizeof(c_szInfoKeyPrefix)-sizeof(TCHAR));

    if (pszDesc != NULL)
    {
        if (fRet = RegCreateKeyEx(HKEY_CLASSES_ROOT, achIMEKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dw)
                == ERROR_SUCCESS)
        {
            fRet &= RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)pszDesc, (lstrlen(pszDesc)+1)*sizeof(TCHAR))
                == ERROR_SUCCESS;
            if (!fRet)
            {
                RegCloseKey(hKey);
                return fRet;
            }
            if (fRet = RegCreateKeyEx(hKey, c_szInProcSvr32, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSubKey, &dw)
                == ERROR_SUCCESS)
            {
                fRet &= RegSetValueEx(hSubKey, NULL, 0, REG_SZ, (BYTE *)pszPath, (lstrlen(pszPath)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
                fRet &= RegSetValueEx(hSubKey, c_szModelName, 0, REG_SZ, (BYTE *)pszModel, (lstrlen(pszModel)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
                RegCloseKey(hSubKey);
            }
            RegCloseKey(hKey);
        }
    }
    else
    {
        fRet = (RecurseDeleteKey(HKEY_CLASSES_ROOT, achIMEKey) == ERROR_SUCCESS) &&
               (pszSoftwareKey == NULL || RecurseDeleteKey(HKEY_LOCAL_MACHINE, pszSoftwareKey) == ERROR_SUCCESS);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\cicerolib\src\sdo.cpp ===
//
// sdo.cpp
//

#include "private.h"
#include "sdo.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CDataObject
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CDataObject::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IDataObject))
    {
        *ppvObj = SAFECAST(this, IDataObject *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CDataObject::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CDataObject::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CDataObject::CDataObject()
{
    Dbg_MemSetThisName(TEXT("CDataObject"));

    memset(&_fe, 0, sizeof(_fe));
    memset(&_sm, 0, sizeof(_sm));
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CDataObject::~CDataObject()
{
    ReleaseStgMedium(&_sm);
}

//+---------------------------------------------------------------------------
//
// GetData
//
//----------------------------------------------------------------------------

STDAPI CDataObject::GetData(FORMATETC *pfe, STGMEDIUM *psm)
{
    WCHAR *pch;
    ULONG cch;

    if (pfe == NULL || psm == NULL)
        return E_INVALIDARG;

    // verify the formatetc -- Issue: use QueryGetData
    if (pfe->cfFormat != _fe.cfFormat)
        return DV_E_FORMATETC;
    // Issue: ignoring ptd
    if (pfe->dwAspect != _fe.dwAspect)
        return DV_E_DVASPECT;
    if (pfe->lindex != _fe.lindex)
        return DV_E_LINDEX;
    if (!(pfe->tymed & _fe.lindex))
        return DV_E_TYMED;

    Assert(_fe.tymed == _sm.tymed);

    // allocate the medium
    if ((pfe->tymed & _fe.lindex) == TYMED_HGLOBAL)
    {
        switch (pfe->cfFormat)
        {
            case CF_UNICODETEXT:
                pch = (WCHAR *)GlobalLock(_sm.hGlobal);
                cch = wcslen(pch) + 1; // include the '\0'

                if ((psm->hGlobal = GlobalAlloc(GMEM_FIXED, cch*sizeof(WCHAR))) == NULL)
                {
                    GlobalUnlock(_sm.hGlobal);
                    return STG_E_MEDIUMFULL;
                }

                memcpy(psm->hGlobal, pch, cch*sizeof(WCHAR));
                GlobalUnlock(_sm.hGlobal);

                psm->tymed = TYMED_HGLOBAL;

                psm->pUnkForRelease = NULL; // caller must GlobalFree
                break;

            default:
                Assert(0); // shouldn't have let anyone SetData with something we can't handle
                break;
        }
    }
    else
    {
        Assert(0); // shouldn't have let anyone SetData with something we can't handle
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDataHere
//
//----------------------------------------------------------------------------

STDAPI CDataObject::GetDataHere(FORMATETC *pfe, STGMEDIUM *psm)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// QueryGetData
//
//----------------------------------------------------------------------------

STDAPI CDataObject::QueryGetData(FORMATETC *pfe)
{
    if (pfe == NULL)
        return E_INVALIDARG;

    // verify the formatetc
    if (pfe->cfFormat != _fe.cfFormat)
        return DV_E_FORMATETC;
    // Issue: ignoring ptd
    if (pfe->dwAspect != _fe.dwAspect)
        return DV_E_DVASPECT;
    if (pfe->lindex != _fe.lindex)
        return DV_E_LINDEX;
    if (!(pfe->tymed & _fe.lindex))
        return DV_E_TYMED;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetCanonicalFormatEtc
//
//----------------------------------------------------------------------------

STDAPI CDataObject::GetCanonicalFormatEtc(FORMATETC *pfeIn, FORMATETC *pfeOut)
{
    return E_NOTIMPL; // Issue: may not be legal to leave this unimpl
}

//+---------------------------------------------------------------------------
//
// SetData
//
//----------------------------------------------------------------------------

STDAPI CDataObject::SetData(FORMATETC *pfe, STGMEDIUM *psm, BOOL fRelease)
{
    Assert(fRelease == TRUE); // bogus, but for now we don't support copying

    if (pfe == NULL || psm == NULL)
        return E_INVALIDARG;

    if (pfe->tymed != psm->tymed)
        return E_INVALIDARG;

    // free up any storage
    ReleaseStgMedium(&_sm);

    // copy the new stuff
    _fe = *pfe;
    _sm = *psm;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumFormatEtc
//
//----------------------------------------------------------------------------

STDAPI CDataObject::EnumFormatEtc(DWORD dwDir, IEnumFORMATETC **ppefe)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// DAdvise
//
//----------------------------------------------------------------------------

STDAPI CDataObject::DAdvise(FORMATETC *pfe, DWORD advf, IAdviseSink *pas, DWORD *pdwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// DUnadvise
//
//----------------------------------------------------------------------------

STDAPI CDataObject::DUnadvise(DWORD dwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// EnumDAdvise
//
//----------------------------------------------------------------------------

STDAPI CDataObject::EnumDAdvise(IEnumSTATDATA **ppesd)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// _SetData
//
//----------------------------------------------------------------------------

HRESULT CDataObject::_SetData(const WCHAR *pch, ULONG cch)
{
    FORMATETC fe;
    STGMEDIUM sm;

    fe.cfFormat = CF_UNICODETEXT;
    fe.ptd = NULL;
    fe.dwAspect = DVASPECT_CONTENT;
    fe.lindex = -1;
    fe.tymed = TYMED_HGLOBAL;

    sm.tymed = TYMED_HGLOBAL;
    sm.hGlobal = NULL;
    sm.pUnkForRelease = NULL;
    sm.hGlobal = GlobalAlloc(GMEM_FIXED, (cch+1)*sizeof(WCHAR));

    if (sm.hGlobal == NULL)
        return E_OUTOFMEMORY;

    memcpy(sm.hGlobal, pch, cch*sizeof(WCHAR));
    ((WCHAR *)sm.hGlobal)[cch] = '\0';

    return SetData(&fe, &sm, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\common\cutil.h ===
#ifndef __C_UTIL_H__
#define __C_UTIL_H__
class CUtil
{
public:
	static BOOL			IsWinNT(VOID);
	static BOOL			IsWinNT4(VOID);
	static BOOL			IsWinNT5(VOID);
	static BOOL			IsWin9x(VOID);
	static BOOL			IsWin95(VOID);
	static BOOL			IsWin98(VOID);
	static BOOL			IsHydra(VOID);
	static INT			GetWINDIR(LPTSTR lpstr, INT len);
};
#endif //__C_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\common\cfont.h ===
//////////////////////////////////////////////////////////////////
// File     :	cfont.h
// Purpose  :	class CFont define.
//				Util method for font handling.
// 
// 
// Date     :	Thu Jul 01 12:21:00 1999
// Author   :	toshiak
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_FONT_H__
#define __C_FONT_H__

#ifdef UNDER_CE // Windows CE does not support ENUMLOGFONTEX
#ifndef ENUMLOGFONTEX
#define ENUMLOGFONTEX ENUMLOGFONT
#endif // !ENUMLOGFONTEX
#endif // UNDER_CE

class CFont
{
public:	
	//Common method.
	static HFONT CreateDefGUIFont(VOID);
	//Ansi&Unicode
	static BOOL  GetDefGUILogFont(LOGFONT *lpLf);
	static HFONT CreateGUIFontByNameCharSet(LPTSTR	lpstrFontFace,
											INT		charSet,
											INT		pointSize);
	static BOOL	 IsFontExist(LPTSTR lpstrFontFace,
							 INT	charSet);
	static BOOL	 GetFontNameByCharSet(INT	 charSet,
									  LPTSTR lpstrFontFace,
									  INT    cchMax);
	static BOOL  GetFontInfoByName(LPTSTR lpstrFontFace,
								   INT	  *pCharSet,
								   INT	  *pCodePage);
	static BOOL  SearchLogFontByNameCharSet(LOGFONT *lpLf,
											LPTSTR	lpstrFontFace,
											INT		charSet,
											BOOL	fIncVert=FALSE);
	static INT   CALLBACK EnumFontFamiliesExProc(ENUMLOGFONTEX	*lpElf,
												 NEWTEXTMETRIC	*lpNtm,
												 INT			iFontType,
												 LPARAM			lParam);
#ifdef AWBOTH
	static BOOL  GetDefGUILogFontW(LOGFONTW *pLf);
	static HFONT CreateGUIFontByNameCharSetW(LPWSTR lptstrFontFace,
											 INT	charSet,
											 INT	pointSize);	
	static BOOL	 IsFontExist(LPWSTR lpstrFontFace,
							 INT	charSet);
	static BOOL	 GetFontNameByCharSetW(INT	  charSet,
									   LPWSTR lpstrFontFace,
									   INT    cchMax);
	static BOOL  GetFontInfoByNameW(LPWSTR lpstrFontFace,
									INT	  *pCharSet,
									INT	  *pCodePage);
	static BOOL  SearchLogFontByNameCharSetW(LOGFONTW	*lpLf,
											 LPWSTR		lpstrFontFace,
											 INT		charSet,
											 BOOL		fIncVert=FALSE);
	static INT   CALLBACK EnumFontFamiliesExProcW(ENUMLOGFONTEXW	*lpElf,
												  NEWTEXTMETRIC		*lpNtm,
												  INT				iFontType,
												  LPARAM			lParam);
#endif //AWBOTH
};
#endif //__C_FONT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\common\cutil.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "cutil.h"

#define	MemAlloc(a)	GlobalAlloc(GMEM_FIXED, (a))
#define MemFree(a)	GlobalFree((a))

static POSVERSIONINFO _getOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

BOOL
CUtil::IsWinNT(VOID)
{
	return (_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
}

BOOL
CUtil::IsWinNT4(VOID)
{
	if((_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
	   (_getOSVersion()->dwMajorVersion == 4) &&
	   (_getOSVersion()->dwMinorVersion >= 0) ) {
		return TRUE;
	}

	return FALSE;
}

BOOL
CUtil::IsWinNT5(VOID)
{
	if((_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
	   (_getOSVersion()->dwMajorVersion == 5) &&
	   (_getOSVersion()->dwMinorVersion >= 0)) {
		return TRUE;
	}
	return FALSE;
}

BOOL
CUtil::IsWin9x(VOID)
{
	if((_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
	   (_getOSVersion()->dwMajorVersion >= 4)) {
		return TRUE;
	}
	return FALSE;
}

BOOL
CUtil::IsWin95(VOID)
{
	if((_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
	   (_getOSVersion()->dwMajorVersion >= 4) &&
	   (_getOSVersion()->dwMinorVersion < 10)) {
		return TRUE;
	}
	return FALSE;
}
BOOL
CUtil::IsWin98(VOID)
{
	if((_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
	   (_getOSVersion()->dwMajorVersion >= 4) &&
	   (_getOSVersion()->dwMinorVersion  >= 10)) {
		return TRUE;
	}
	return FALSE;
}

BOOL
CUtil::IsHydra(VOID)
{
#ifdef UNDER_CE
	return FALSE;
#else //!UNDER_CE
	static DWORD fTested = FALSE, fHydra = FALSE;
	HKEY hKey;

	if(fTested) {
		return fHydra;
	}

	if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
									 TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
									 0,
									 KEY_READ,
									 &hKey)){
		DWORD cbData;
		if(ERROR_SUCCESS == RegQueryValueEx(hKey,
											TEXT("ProductSuite"),
											NULL,
											NULL,
											NULL,
											&cbData)){
			TCHAR *mszBuffer, *szCurPtr;
			if(NULL != (mszBuffer = (TCHAR *)MemAlloc(cbData))){
				RegQueryValueEx(hKey,
								TEXT("ProductSuite"),
								NULL,
								NULL,
								(unsigned char *)mszBuffer,
								&cbData);
				for(szCurPtr = mszBuffer; 0 != *szCurPtr; szCurPtr += lstrlen(szCurPtr)+1){
					if(0 == lstrcmpi(szCurPtr, TEXT("Terminal Server"))){
						fHydra = TRUE;
						break;
					}
				}
				MemFree(mszBuffer);
			}
		}
		RegCloseKey(hKey);
	}
	fTested = TRUE;
	return(fHydra);
#endif //UNDER_CE
}

INT
CUtil::GetWINDIR(LPTSTR lpstr, INT len)
{
#ifdef UNDER_CE
	static const TCHAR szWindowsDir[] = TEXT("\\Windows");
	_tcsncpy(lpstr, szWindowsDir, len);
	if(len < sizeof szWindowsDir/sizeof(TCHAR))
		lpstr[len-1] = TEXT('\0');
	return lstrlen(lpstr);
#else //!UNDER_CE
	INT dirSize=0;
	if(CUtil::IsHydra()) {
		dirSize = ::GetEnvironmentVariable(TEXT("WINDIR"), lpstr, len);
	}	
	else {
		dirSize = ::GetWindowsDirectory(lpstr, len);
	}
	return dirSize;
#endif //UNDER_CE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\common\cfont.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	cfont.cpp
// Purpose  :	Font handling class source code.
//				Shared by each Applet.
//				You can compile/test this file. see main() function below.
// 
// Date     :	Thu Jul 01 12:20:34 1999
// Author   :	toshiak
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <tchar.h>
#include "cfont.h"
#include "cutil.h"
#ifdef _TEST_CFONT
#include <stdio.h>
#endif //_TEST_CFONT

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//----------------------------------------------------------------
//structure define for internal 
//----------------------------------------------------------------
#define EFI_STOPIFFOUND		0x00000001
#define EFI_DONTENUMVERT	0x00010000

typedef struct tagENUMFONTINFOA {
	DWORD		dwFlag;
	BOOL		fFound;
	LOGFONTA	logFontIn;
	LOGFONTA	logFontOut;
}ENUMFONTINFOA, *LPENUMFONTINFOA;

typedef struct tagENUMFONTINFOW {
	DWORD		dwFlag;
	BOOL		fFound;
	LOGFONTW	logFontIn;
	LOGFONTW	logFontOut;
}ENUMFONTINFOW, *LPENUMFONTINFOW;

#ifdef UNICODE
#define ENUMFONTINFO	ENUMFONTINFOW
#define LPENUMFONTINFO	LPENUMFONTINFOW
#else
#define ENUMFONTINFO	ENUMFONTINFOA
#define LPENUMFONTINFO	LPENUMFONTINFOA
#endif

#ifdef UNDER_CE // Windows CE does not support EnumFontFamiliesEx
inline int EnumFontFamiliesEx(HDC hdc, LPLOGFONT lpLogfont, FONTENUMPROC lpEnumFontFamProc,
							  LPARAM lParam, DWORD)
{
	return ::EnumFontFamilies(hdc, lpLogfont->lfFaceName, lpEnumFontFamProc, lParam);
}

#ifndef ZeroMemory // Defined on sdk\inc\objbase.h under new source tree
#define ZeroMemory(dest, len) memset((dest),0,(len))
#endif
#define DEFAULT_GUI_FONT SYSTEM_FONT
#endif // UNDER_CE

//----------------------------------------------------------------
//
//	Public Method.
//
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function	:	CFont::CreateDefGUIFont
// Type		:	HFONT
// Purpose	:	Create(Copy) DEFAULT_GUI_FONT font Handle.
// Args		:	None
// Return	:	
// DATE		:	Wed Jun 30 18:33:15 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
HFONT
CFont::CreateDefGUIFont(VOID)
{
	HFONT hFont = (HFONT)::GetStockObject(DEFAULT_GUI_FONT);
	if(!hFont) {
		return NULL;
	}
#ifdef AWBOTH
	if(CUtil::IsWinNT()) {
		LOGFONTW lf;
		if(!::GetObjectW(hFont, sizeof(lf), &lf)) {
			return NULL;
		}
		return ::CreateFontIndirectW(&lf);
	}
#endif
	LOGFONT lf;
	if(!::GetObject(hFont, sizeof(lf), &lf)) {
		return NULL;
	}
	return ::CreateFontIndirect(&lf);
}

INT PointSize2LogPixel(INT pointSize)
{
	HWND hwnd = NULL;
	HDC hDC = ::GetDC(hwnd);
	INT dpi = ::GetDeviceCaps(hDC, LOGPIXELSY);
	::ReleaseDC(hwnd, hDC);
	return (pointSize * dpi)/72;
}

//////////////////////////////////////////////////////////////////
// Function	:	CFont::CreateGUIFontByCharSet
// Type		:	HFONT
// Purpose	:	Create GUI Font handle with specified characterset.
//				Font size is same with DEFAULT_GUI_FONT.
// Args		:	
//			:	LPTSTR	lpstrFontFace;	fontface string to search,
//										if this NULL, return first found
//										charset HFONT.
//			:	INT		charSet	
//			:	INT		poinstSize		Inclues VerticalFont or NOT (default is FALSE)
// Return	:	
// DATE		:	Wed Jun 30 18:37:54 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
HFONT
CFont::CreateGUIFontByNameCharSet(LPTSTR	lpstrFontFace,
								  INT		charSet,
								  INT		pointSize)
{
	LOGFONT lf, lfDef;
	//Get DEFAULT_GUI_FONT's LOGFONT data.
	if(!CFont::GetDefGUILogFont(&lfDef)) {
		return NULL;
	}
	//Search Specified charset font's LOGFONT data.
	if(!CFont::SearchLogFontByNameCharSet(&lf, lpstrFontFace, charSet, FALSE)) {
		return NULL;
	}
	lfDef.lfCharSet = lf.lfCharSet;
	if(pointSize > 0) {
		lfDef.lfHeight  = - PointSize2LogPixel(pointSize);
	}
	_tcscpy(lfDef.lfFaceName, lf.lfFaceName);
	return ::CreateFontIndirect(&lfDef);
}
#ifdef AWBOTH
HFONT
CFont::CreateGUIFontByNameCharSetW(LPWSTR	lpstrFontFace,
								   INT		charSet,
								   INT		pointSize)
{
	LOGFONTW lf, lfDef;
	//Get DEFAULT_GUI_FONT's LOGFONT data.
	if(!CFont::GetDefGUILogFontW(&lfDef)) {
		return NULL;
	}
	//Search Specified charset font's LOGFONT data.
	if(!CFont::SearchLogFontByNameCharSetW(&lf, lpstrFontFace, charSet, FALSE)) {
		return NULL;
	}

	lfDef.lfCharSet = lf.lfCharSet;
	if(pointSize > 0) {
		lfDef.lfHeight  = - PointSize2LogPixel(pointSize);
	}
	lfDef.lfWidth   = 0;
	wcscpy(lfDef.lfFaceName, lf.lfFaceName);
	return ::CreateFontIndirectW(&lfDef);
}
#endif //AWBOTH


//////////////////////////////////////////////////////////////////
// Function	:	CFont::IsFontExist
// Type		:	BOOL
// Purpose	:	Check specified FaceName & charSet font is Exit or NOT.
// Args		:	
//			:	LPTSTR	lpstrFontFace	
//			:	INT	charSet	
// Return	:	
// DATE		:	Thu Jul 22 23:00:54 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CFont::IsFontExist(LPTSTR lpstrFontFace, INT charSet)
{
	return CFont::SearchLogFontByNameCharSet(NULL,
											 lpstrFontFace,
											 charSet,
											 FALSE);
}

#ifdef AWBOTH
BOOL
CFont::IsFontExist(LPWSTR lpstrFontFace, INT charSet)
{
	return CFont::SearchLogFontByNameCharSetW(NULL,
											  lpstrFontFace,
											  charSet,
											  FALSE);
}
#endif //AWBOTH

//////////////////////////////////////////////////////////////////
// Function	:	CFont::GetFontNameByCharSet
// Type		:	BOOL
// Purpose	:	Serach & Get FontFace with Specified charSet
// Args		:	
//			:	INT	charSet	
//			:	LPTSTR	lpstrFontFace	
//			:	INT	cchMax	
// Return	:	
// DATE		:	Thu Jul 22 23:13:01 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CFont::GetFontNameByCharSet(INT		charSet,
							LPTSTR	lpstrFontFace,
							INT		cchMax)
{
	if(!lpstrFontFace) {
		return FALSE;
	}
	if(cchMax < LF_FACESIZE) {
		return FALSE;
	}

	LOGFONT lf;

	BOOL fRet = CFont::SearchLogFontByNameCharSet(&lf,
												  NULL,
												  charSet,
												  FALSE);
	if(fRet) {
		StringCchCopy(lpstrFontFace, cchMax, lf.lfFaceName);
	}
	return fRet;
}

#ifdef AWBOTH
BOOL
CFont::GetFontNameByCharSetW(INT	charSet,
							 LPWSTR	lpstrFontFace,
							 INT	cchMax)
{
	if(!lpstrFontFace) {
		return FALSE;
	}
	if(cchMax < LF_FACESIZE) {
		return FALSE;
	}

	LOGFONTW lf;

	BOOL fRet = CFont::SearchLogFontByNameCharSetW(&lf,
												  NULL,
												  charSet,
												  FALSE);
	if(fRet) {
		wcscpy(lpstrFontFace, lf.lfFaceName);
	}
	return fRet;
}
#endif


//////////////////////////////////////////////////////////////////
// Function	:	CFont::GetFontInfoByName
// Type		:	BOOL
// Purpose	:	
// Args		:	
//			:	LPTSTR	lpstrFontFace	
//			:	INT *	pCharSet	
//			:	INT *	pCodePage	
// Return	:	
// DATE		:	Fri Jul 23 02:48:29 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CFont::GetFontInfoByName(LPTSTR lpstrFontFace,
						 INT	*pCharSet,
						 INT	*pCodePage)
{
	LOGFONT lf;
	BOOL fRet = CFont::SearchLogFontByNameCharSet(&lf,
												  lpstrFontFace,
												  DEFAULT_CHARSET,
												  FALSE);
	if(!fRet) {
		return FALSE;
	}

	*pCharSet = (INT)lf.lfCharSet;
	CHARSETINFO info;
	if(::TranslateCharsetInfo((DWORD *)(DWORD_PTR)*pCharSet,
							  &info,
							  TCI_SRCCHARSET)) {
		*pCodePage = (INT)info.ciACP;
	}
	else { //failed
		*pCodePage = CP_ACP;
	}
	return 0;
}

#ifdef AWBOTH
BOOL
CFont::GetFontInfoByNameW(LPWSTR lpstrFontFace,
						  INT	  *pCharSet,
						  INT	  *pCodePage)
{
	LOGFONTW lf;
	BOOL fRet = CFont::SearchLogFontByNameCharSetW(&lf,
												   lpstrFontFace,
												   DEFAULT_CHARSET,
												   FALSE);
	if(!fRet) {
		return FALSE;
	}

	*pCharSet = (INT)lf.lfCharSet;
	CHARSETINFO info;
	if(::TranslateCharsetInfo((DWORD *)(DWORD_PTR)*pCharSet,
							  &info,
							  TCI_SRCCHARSET)) {
		*pCodePage = (INT)info.ciACP;
	}
	else { //failed
		*pCodePage = CP_ACP;
	}
	return 0;
}
#endif //AWBOTH

//----------------------------------------------------------------
//
// Private method.
//
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function	:	CFont::GetDefGUILogFont
// Type		:	BOOL
// Purpose	:	
// Args		:	LOGFONT *lpLF
// Return	:	
// DATE		:	Wed Jul 15 19:36:57 1998
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CFont::GetDefGUILogFont(LOGFONT *lpLF)
{
	if(!lpLF) {
		return FALSE;
	}
	if(!::GetObject((HFONT)::GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), lpLF)) {
		return FALSE;
	}
	return TRUE;
}
////////////////////
//Unicode version.
////////////////////
#ifdef AWBOTH
BOOL
CFont::GetDefGUILogFontW(LOGFONTW *lpLF)
{
	if(!lpLF) {
		return FALSE;
	}
	if(!::GetObjectW((HFONT)::GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONTW), lpLF)) {
		return FALSE;
	}
	return TRUE;
}
#endif //AWBOTH


//////////////////////////////////////////////////////////////////
// Function	:	CFont::SearchLogFontByNameCharSet
// Type		:	BOOL
// Purpose	:	Search LOGFONT data with specified FaceName & charset.
//				If FaceName is not specified, return first find charset logfont.
// Args		:	
//			:	LOGFONT *	lpLF	
//			:	LPTSTR		lpstrFontFace	
//			:	INT			charSet	
//			:	BOOL		fIncVert
//								Inclues VerticalFont or NOT (default is FALSE)
// Return	:	
// DATE		:	Thu Jul 01 17:12:40 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CFont::SearchLogFontByNameCharSet(LOGFONT	*lpLF,
								  LPTSTR	lpstrFontFace,
								  INT		charSet,
								  BOOL		fIncVert)
{
	HWND hwndDC = NULL;
	HDC hDC = ::GetDC(hwndDC);
	if(!hDC) {
		return FALSE;
	}
	ENUMFONTINFO	enumFontInfo;
	LPENUMFONTINFO	lpEnumFontInfo = &enumFontInfo;

	::ZeroMemory(&enumFontInfo, sizeof(enumFontInfo));
	lpEnumFontInfo->logFontIn.lfCharSet = (BYTE)charSet; 
	if(lpstrFontFace) { 
		if(lstrlen(lpstrFontFace) < LF_FACESIZE) {
			_tcscpy(lpEnumFontInfo->logFontIn.lfFaceName, lpstrFontFace);
		}
	}
	lpEnumFontInfo->dwFlag	= EFI_STOPIFFOUND;
	lpEnumFontInfo->dwFlag |= fIncVert ? 0 : EFI_DONTENUMVERT;
	lpEnumFontInfo->fFound	= FALSE;
	::EnumFontFamiliesEx(hDC,
						 &lpEnumFontInfo->logFontIn,
						 (FONTENUMPROC)CFont::EnumFontFamiliesExProc,
						 (LPARAM)lpEnumFontInfo,
						 0);
	::ReleaseDC(hwndDC, hDC);

	if(lpEnumFontInfo->fFound) {
		if(lpLF) {
			*lpLF = lpEnumFontInfo->logFontOut;
		}
	}
	return lpEnumFontInfo->fFound;
}

#ifdef AWBOTH
BOOL
CFont::SearchLogFontByNameCharSetW(LOGFONTW *lpLF,
								   LPWSTR	lpstrFontFace,
								   INT		charSet,
								   BOOL		fIncVert)
{
	HWND hwndDC = NULL;
	HDC hDC = ::GetDC(hwndDC);
	if(!hDC) {
		return FALSE;
	}
	ENUMFONTINFOW	enumFontInfo;
	LPENUMFONTINFOW	lpEnumFontInfo = &enumFontInfo;

	::ZeroMemory(&enumFontInfo, sizeof(enumFontInfo));
	lpEnumFontInfo->logFontIn.lfCharSet = (BYTE)charSet; 
	if(lpstrFontFace) { 
		if(wcslen(lpstrFontFace) < LF_FACESIZE) {
			wcscpy(lpEnumFontInfo->logFontIn.lfFaceName, lpstrFontFace);
		}
	}
	lpEnumFontInfo->dwFlag	= EFI_STOPIFFOUND;
	lpEnumFontInfo->dwFlag |= fIncVert ? 0 : EFI_DONTENUMVERT;
	lpEnumFontInfo->fFound	= FALSE;

	::EnumFontFamiliesExW(hDC,
						  &lpEnumFontInfo->logFontIn,
						  (FONTENUMPROCW)CFont::EnumFontFamiliesExProcW,
						  (LPARAM)lpEnumFontInfo,
						  0);
	::ReleaseDC(hwndDC, hDC);

	if(lpEnumFontInfo->fFound) {
		if(lpLF) {
			*lpLF = lpEnumFontInfo->logFontOut;
		}
	}
	return lpEnumFontInfo->fFound;
}
#endif

//////////////////////////////////////////////////////////////////
// Function	:	CFont::EnumFontFamiliesExProc
// Type		:	INT	CALLBACK
// Purpose	:	
// Args		:	
//			:	ENUMLOGFONTEX *	lpElf
//			:	NEWTEXTMETRIC *	lpNtm
//			:	INT	iFontType	
//			:	LPARAM	lParam	
// Return	:	
// DATE		:	Thu Jul 01 15:17:56 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
INT CALLBACK
CFont::EnumFontFamiliesExProc(ENUMLOGFONTEX	*lpElf,
							  NEWTEXTMETRIC	*lpNtm,
							  INT			iFontType,
							  LPARAM		lParam)
{
	LPENUMFONTINFO	lpEnumFontInfo = (LPENUMFONTINFO)lParam;
	if(!lpEnumFontInfo) {
		return 0; //Do not continue;
	}

	if(lpEnumFontInfo->dwFlag & EFI_STOPIFFOUND) {
		if(lpEnumFontInfo->logFontIn.lfFaceName[0] == (TCHAR)0x00) {
			if(lpEnumFontInfo->logFontIn.lfCharSet == lpElf->elfLogFont.lfCharSet) {
				//----------------------------------------------------------------
				//if EFI_DONTENUMVERT is set, 
				//Do skip vertical font enumulation.
				//----------------------------------------------------------------
				if( (lpEnumFontInfo->dwFlag & EFI_DONTENUMVERT) &&
					lpElf->elfLogFont.lfFaceName[0] == (TCHAR)'@') {
					return 1; //continue to enum.
				}
				//Found specified charSet's logfont
				lpEnumFontInfo->logFontOut = lpElf->elfLogFont;
				lpEnumFontInfo->fFound	   = TRUE;	
				return 0; //Do not coninue;
			}
		}
		else {
			if(lpEnumFontInfo->logFontIn.lfCharSet == lpElf->elfLogFont.lfCharSet &&
			   0 == _tcscmp(lpEnumFontInfo->logFontIn.lfFaceName, lpElf->elfLogFont.lfFaceName)) {
				//Found specified charSet's logfont
				lpEnumFontInfo->logFontOut = lpElf->elfLogFont;
				lpEnumFontInfo->fFound	   = TRUE;	
				return 0; //Do not coninue;
			}
		}
	}
	else {
#ifdef _TEST_CFONT
		extern LPTSTR GetCharset(int );
		_tprintf(TEXT("[%-24s] [%-20s][%s][%s][%s]\n"), 
				 lpElf->elfLogFont.lfFaceName,
				 GetCharset(lpElf->elfLogFont.lfCharSet),
				 lpElf->elfFullName,
				 lpElf->elfScript,
				 lpElf->elfStyle);
#endif
	}
	return 1;//continue to enum;
	UNREFERENCED_PARAMETER(lpNtm);
	UNREFERENCED_PARAMETER(iFontType);
}

#ifdef AWBOTH
INT CALLBACK
CFont::EnumFontFamiliesExProcW(ENUMLOGFONTEXW	*lpElf,
							   NEWTEXTMETRIC	*lpNtm,
							   INT				iFontType,
							   LPARAM			lParam)
{
	LPENUMFONTINFOW	lpEnumFontInfo = (LPENUMFONTINFOW)lParam;
	if(!lpEnumFontInfo) {
		return 0; //Do not continue;
	}

	if(lpEnumFontInfo->dwFlag & EFI_STOPIFFOUND) {
		if(lpEnumFontInfo->logFontIn.lfFaceName[0] == (WCHAR)0x00) {
			if(lpEnumFontInfo->logFontIn.lfCharSet == lpElf->elfLogFont.lfCharSet) {
				//----------------------------------------------------------------
				//if EFI_DONTENUMVERT is set, 
				//Do skip vertical font enumulation.
				//----------------------------------------------------------------
				if( (lpEnumFontInfo->dwFlag & EFI_DONTENUMVERT) &&
					lpElf->elfLogFont.lfFaceName[0] == (WCHAR)'@') {
					return 1; //continue to enum.
				}
				//Found specified charSet's logfont
				lpEnumFontInfo->logFontOut = lpElf->elfLogFont;
				lpEnumFontInfo->fFound	   = TRUE;
				return 0; //Do not coninue;
			}
		}
		else {
			if(lpEnumFontInfo->logFontIn.lfCharSet == lpElf->elfLogFont.lfCharSet &&
			   0 == wcscmp(lpEnumFontInfo->logFontIn.lfFaceName, lpElf->elfLogFont.lfFaceName)) {
				//Found specified charSet's logfont
				lpEnumFontInfo->logFontOut = lpElf->elfLogFont;
				lpEnumFontInfo->fFound	   = TRUE;
				return 0; //Do not coninue;
			}
		}
	}
	return 1;//continue to enum;
	UNREFERENCED_PARAMETER(lpNtm);
	UNREFERENCED_PARAMETER(iFontType);
}
#endif //AWBOTH




//----------------------------------------------------------------
//
// test program for cfontex.cpp 
//
// how to compile.	
// 1. for ANSI.	
//   cl cfontex.cpp -I../common -D_TEST_CFONT -link user32.lib advapi32.lib gdi32.lib
// 2. for Ansi&Wide both
//   cl cfontex.cpp -I../common -DAWBOTH -D_TEST_CFONT -link user32.lib advapi32.lib gdi32.lib
// 2. for Unicode.
//   cl cfontex.cpp -I../common -DUNICODE -D_UNICODE -D_TEST_CFONT -link user32.lib advapi32.lib gdi32.lib
//----------------------------------------------------------------
#ifdef _TEST_CFONT
#if defined(UNICODE) ||  defined(_UNICODE)
#define DEFSTR(a)	{a, L ## #a}
#else
#define DEFSTR(a)	{a, #a}
#endif
typedef struct tagIDSTR {
	INT id;
	TCHAR *p;
}IDSTR;

IDSTR idstr[]= {
	DEFSTR(ANSI_CHARSET),
	DEFSTR(DEFAULT_CHARSET),
	DEFSTR(SYMBOL_CHARSET),
	DEFSTR(SHIFTJIS_CHARSET),
	DEFSTR(HANGEUL_CHARSET),
	DEFSTR(HANGUL_CHARSET),
	DEFSTR(GB2312_CHARSET),
	DEFSTR(CHINESEBIG5_CHARSET),
	DEFSTR(OEM_CHARSET),
	DEFSTR(JOHAB_CHARSET),
	DEFSTR(HEBREW_CHARSET),
	DEFSTR(ARABIC_CHARSET),
	DEFSTR(GREEK_CHARSET),
	DEFSTR(TURKISH_CHARSET),
	DEFSTR(VIETNAMESE_CHARSET),
	DEFSTR(THAI_CHARSET),
	DEFSTR(EASTEUROPE_CHARSET),
	DEFSTR(RUSSIAN_CHARSET),
	DEFSTR(MAC_CHARSET),
	DEFSTR(BALTIC_CHARSET),
};

#define ArrayCount(a)	sizeof(a)/sizeof(a[0])
LPTSTR GetCharset(INT charset)
{
	static TCHAR szbuf[256];
	int i;
	for( i = 0; i < ArrayCount(idstr); i++) {
		if(charset == idstr[i].id) {
			return idstr[i].p;
		}
	}
	wsprintf(szbuf, TEXT("Unknown Charset[0x%08x]"), charset);
	return szbuf;
}

VOID PrintLogFont(LOGFONT *lplf)
{
	_tprintf(TEXT("lfHeight        [%d]\n"), lplf->lfHeight);
	_tprintf(TEXT("lfWidth         [%d]\n"), lplf->lfWidth );
	_tprintf(TEXT("lfEscapement    [%d]\n"), lplf->lfEscapement);
	_tprintf(TEXT("lfOrientation   [%d]\n"), lplf->lfOrientation);
	_tprintf(TEXT("lfWeight        [%d]\n"), lplf->lfWeight);
	_tprintf(TEXT("lfItalic        [%d]\n"), lplf->lfItalic);
	_tprintf(TEXT("lfUnderline     [%d]\n"), lplf->lfUnderline);
	_tprintf(TEXT("lfStrikeOut     [%d]\n"), lplf->lfStrikeOut);
	_tprintf(TEXT("lfCharSet       [%d]\n"), lplf->lfCharSet);
	_tprintf(TEXT("lfOutPrecision  [%d]\n"), lplf->lfOutPrecision);
	_tprintf(TEXT("lfClipPrecision [%d]\n"), lplf->lfClipPrecision);
	_tprintf(TEXT("lfQuality       [%d]\n"), lplf->lfQuality);
	_tprintf(TEXT("lfPitchAndFamily[%d]\n"), lplf->lfPitchAndFamily);
	_tprintf(TEXT("lfFaceName      [%s]\n"), lplf->lfFaceName);
}


#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <mbstring.h>
#include <mbctype.h>
#include <locale.h>
#include "cfont.h"
#include "cutil.h"
#include "cutil.cpp"
extern LPTSTR GetCharset(INT charset);
void main(void)
{
	_tsetlocale(LC_ALL, TEXT(".ACP"));
	HWND hwndDC = NULL;
	HDC hDC = ::GetDC(hwndDC);
	ENUMFONTINFO	enumFontInfo;
	LPENUMFONTINFO	lpEnumFontInfo = &enumFontInfo;

#if 0
	::ZeroMemory(&enumFontInfo, sizeof(enumFontInfo));
	lpEnumFontInfo->logFontIn.lfCharSet = (BYTE)DEFAULT_CHARSET;
	lpEnumFontInfo->dwFlag	= 0;
	_tprintf(TEXT("Enumlate All Font\n"));
	::EnumFontFamiliesEx(hDC,
						 &lpEnumFontInfo->logFontIn,
						 (FONTENUMPROC)CFont::EnumFontFamiliesExProc,
						 (LPARAM)lpEnumFontInfo,
						 0);

	::ZeroMemory(&enumFontInfo, sizeof(enumFontInfo));
	lpEnumFontInfo->logFontIn.lfCharSet = ANSI_CHARSET;
	lpEnumFontInfo->dwFlag	= 0;
	_tprintf(TEXT("Enumulate ANSI_CHARSET font\n"));
	::EnumFontFamiliesEx(hDC,
						 &lpEnumFontInfo->logFontIn,
						 (FONTENUMPROC)CFont::EnumFontFamiliesExProc,
						 (LPARAM)lpEnumFontInfo,
						 0);
	_tprintf(TEXT("Enumulate SHIFTJIS_CHARSET font\n"));
	::ZeroMemory(&enumFontInfo, sizeof(enumFontInfo));
	lpEnumFontInfo->logFontIn.lfCharSet = SHIFTJIS_CHARSET;
	lpEnumFontInfo->dwFlag	= 0;
	::EnumFontFamiliesEx(hDC,
						 &lpEnumFontInfo->logFontIn,
						 (FONTENUMPROC)CFont::EnumFontFamiliesExProc,
						 (LPARAM)lpEnumFontInfo,
						 0);

	::ReleaseDC(hwndDC, hDC);
#endif

	LOGFONT lf;
	BOOL fRet;
	static LPTSTR fontNameList[]= { TEXT("MS Mincho"),
									TEXT("MS Gothic"),
									TEXT("MS UI Gothic"),
									TEXT("lr "),
									TEXT("lr o"),
									TEXT("lr SVbN"),
									TEXT("lr oSVbN")};

	CFont::GetDefGUILogFont(&lf);
	_tprintf(TEXT("DEFAULT_GUI_FONT LOGFONT\n"));
	PrintLogFont(&lf);

	int i;
	for(i = 0; i < sizeof(fontNameList)/sizeof(fontNameList[0]); i++) {
		fRet = CFont::SearchLogFontByNameCharSet(&lf,
												 fontNameList[i],
												 SHIFTJIS_CHARSET);
		_tprintf(TEXT("Search Font [%-20s] %s\n"),
				 fontNameList[i],
				 fRet ? TEXT("FOUND") : TEXT("NOT FOUND"));
		if(fRet) {
			PrintLogFont(&lf);
			HFONT hFont = CFont::CreateGUIFontByNameCharSet(fontNameList[i],
															SHIFTJIS_CHARSET, FALSE);
			LOGFONT lfNew;
			::GetObject(hFont, sizeof(lfNew), &lfNew);
			PrintLogFont(&lfNew);
		}
	}
}

#endif //_TEST_CFONT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\common\exgdiw.h ===
#ifndef __EX_GDI_W_H__
#define __EX_GDI_W_H__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#ifndef __cplusplus
extern "C" {
#endif
BOOL ExExtTextOutW(HDC		hdc,		// handle to device context.
				   int		X,			// x-coordinate of reference point
				   int		Y,			// y-coordinate of reference point
				   UINT	 fuOptions,	// text-output options.
				   CONST RECT *lprc,	// optional clipping and/or opaquing rectangle.
				   LPWSTR	 lpString,	// points to string.
				   UINT	 cbCount,	// number of characters in string.
				   CONST INT *lpDx);	 // pointer to array of intercharacter spacing values );
BOOL ExGetTextExtentPoint32W(HDC    hdc,		// handle of device context.
							 LPWSTR wz,			// address of text string.
							 int    cch,		// number of characters in string.
							 LPSIZE lpSize);	// address of structure for string size.

#ifndef __cplusplus
}
#endif
#endif //__EX_GDI_W_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\common\exgdiw.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "exgdiw.h"

#define ExMemAlloc(a)		GlobalAllocPtr(GHND, (a))
#define ExMemFree(a)		GlobalFreePtr((a))

static POSVERSIONINFO ExGetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

static BOOL ExIsWin95(VOID) 
{ 
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
			(ExGetOSVersion()->dwMajorVersion >= 4) &&
			(ExGetOSVersion()->dwMinorVersion < 10);

	return fBool;
}

#if 0
static BOOL ExIsWin98(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
			(ExGetOSVersion()->dwMajorVersion >= 4) &&
			(ExGetOSVersion()->dwMinorVersion  >= 10);
	return fBool;
}


static BOOL ExIsWinNT4(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
			(ExGetOSVersion()->dwMajorVersion >= 4) &&
			(ExGetOSVersion()->dwMinorVersion >= 0);
	return fBool;
}

static BOOL ExIsWinNT5(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
			(ExGetOSVersion()->dwMajorVersion >= 4) &&
			(ExGetOSVersion()->dwMinorVersion >= 10);
	return fBool;
}

static BOOL ExIsWinNT(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
	return fBool;
}
#endif

//inline static UINT W2MForWin95(HDC hDC, LPWSTR lpwstr, UINT wchCount,
// LPSTR lpstr, UINT chByteSize)
static UINT W2MForGDI(INT	codePage,
					  LPWSTR	lpwstr,
					  UINT	wchCount,
					  LPSTR	lpstr,
					  UINT	chByteSize)
{
	LPSTR lptmp;
	UINT byte;
	UINT mbyte;
	char defChar = 0x7F;
	BOOL fUseDefChar = TRUE;

	switch(codePage) {
	case 932:
	case 936:
	case 950:
	case 949:
		byte = ::WideCharToMultiByte(codePage,	WC_COMPOSITECHECK,
									 lpwstr,	wchCount, 
									 lpstr,		chByteSize,
									 &defChar,	NULL);
		return byte;
	default:
		lptmp = lpstr;
		for(byte = 0; byte< wchCount; byte++) {
			defChar = 0x7F;
			mbyte = ::WideCharToMultiByte(codePage, WC_COMPOSITECHECK,
										  lpwstr,1,
										  lptmp,  chByteSize - byte,
										  &defChar,
										  &fUseDefChar);
			if(mbyte != 1){
				*lptmp = 0x7F; //defChar;
			}
			lptmp++;
			lpwstr++;
		}
		lpstr[byte]=0x00;
		return byte;
	}
}

static BOOL _ExExtTextOutWWithTrans(INT		codePage,
									HDC		hdc,
									int		X,			
									int		Y,			
									UINT	 fuOptions,	
									CONST RECT *lprc,	
									LPWSTR	 lpString,	
									UINT	 cbCount,	
									CONST INT *lpDx)	
{
#ifndef UNDER_CE // always Unicode
	UINT bufsize = (cbCount + 1) * sizeof(WCHAR);
	BOOL  fRet;

	LPSTR lpstr = (LPSTR)ExMemAlloc(bufsize);
	if(!lpstr) {
		return 0;
	}
#if 0
	UINT byte = ::WideCharToMultiByte(codePage,
									  WC_COMPOSITECHECK, 
									  lpString, cbCount,
									  lpstr,    bufsize, &defChar, 0);
#endif
	UINT byte = W2MForGDI(codePage, lpString, cbCount, lpstr, bufsize);
	fRet = ::ExtTextOutA(hdc,X,Y,fuOptions,lprc,lpstr, byte,lpDx);
	ExMemFree(lpstr);
	return fRet;
#else // UNDER_CE
	return ::ExtTextOutW(hdc,X,Y,fuOptions,lprc,lpString, cbCount,lpDx);
#endif // UNDER_CE
}
							 

//////////////////////////////////////////////////////////////////
// Function : ExExtTextOutWForWin95
// Type     : BOOL
// Purpose  : 
// Args     : 
//          : HDC hdc			// handle to device context.                           
//          : int X				// x-coordinate of reference point                     
//          : int Y				// y-coordinate of reference point                     
//          : UINT fuOptions	// text-output options.                                
//          : CONST RECT * lprc	// optional clipping and/or opaquing rectangle.        
//          : 			
//          : LPWSTR lpString	// points to string.                                   
//          : UINT cbCount		// number of characters in string.                     
//          : CONST INT  * lpDx // pointer to array of intercharacter spacing values 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static BOOL ExExtTextOutWForWin95(HDC		hdc,		
								  int		X,			
								  int		Y,			
								  UINT	 fuOptions,	
								  CONST RECT *lprc,	
								  LPWSTR	 lpString,	
								  UINT	 cbCount,	
								  CONST INT *lpDx)	
{
	//UINT bufsize = (cbCount + 1) * sizeof(WCHAR);

	TEXTMETRIC tm;
	::GetTextMetrics(hdc, &tm);
	//----------------------------------------------------------------
	//980730:By ToshiaK
	//Unicode GDI in Win95 has Bugs.
	//1. if try to use ExtTextOutW() with FE Unicode code point, with
	//   som ANSI or SYMBOL charset font, GPF occurs.
	//2. ExtTextOutW() cannot draw EUDC code. (Must use ExtTextOutA() to draw)
	//----------------------------------------------------------------
	LANGID langId = ::GetSystemDefaultLangID();
	switch(tm.tmCharSet) {
	case SHIFTJIS_CHARSET:
		if(PRIMARYLANGID(langId) == LANG_JAPANESE) {
			return _ExExtTextOutWWithTrans(932,
										   hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
		}
		return ::ExtTextOutW(hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx); 
		break;
	case GB2312_CHARSET:
		if(langId == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)) {
			return _ExExtTextOutWWithTrans(936,
										   hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
		}
		return ::ExtTextOutW(hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx); 
		break;
	case CHINESEBIG5_CHARSET:
		if(langId == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)) {
			return _ExExtTextOutWWithTrans(950,
										   hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
		}
		return ::ExtTextOutW(hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx); 
		break;
	case HANGEUL_CHARSET:
		if(PRIMARYLANGID(langId) == LANG_KOREAN) {
			return _ExExtTextOutWWithTrans(949,
										   hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
		}
		return ::ExtTextOutW(hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx); 
		break;
	case SYMBOL_CHARSET:
		return _ExExtTextOutWWithTrans(1252,
									   hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
		break;
	default:
		{
			CHARSETINFO info;
			if(::TranslateCharsetInfo((DWORD *)tm.tmCharSet,
									  &info,
									  TCI_SRCCHARSET)) {
				return _ExExtTextOutWWithTrans(info.ciACP,
											   hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
			}
			else {
				return _ExExtTextOutWWithTrans(CP_ACP,
											   hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
			}
		}
	}
}

static BOOL _ExGetTextExtentPoint32WWithTrans(INT codePage,
											  HDC hdc,
											  LPWSTR wz,		
											  int    cch,		
											  LPSIZE lpSize)	
{
#ifndef UNDER_CE // always Unicode
	UINT bufsize = (cch + 1) * sizeof(WCHAR);
	LPSTR lpstr = (LPSTR)ExMemAlloc(bufsize);
	BOOL  fRet;
	//CHAR defChar = 0x7F; 
	if(!lpstr) {
		return 0;
	}
	UINT byte = W2MForGDI(codePage, wz, cch, lpstr, bufsize);
#if 0
	UINT byte = ::WideCharToMultiByte(codePage,
									  WC_COMPOSITECHECK, 
									  wz, cch,
									  lpstr, bufsize,
									  &defChar, 0);
#endif
	fRet = ::GetTextExtentPoint32A(hdc, lpstr, byte, lpSize);
	ExMemFree(lpstr);
	return fRet;
#else // UNDER_CE
	return ::GetTextExtentPoint32W(hdc, wz, cch, lpSize);
#endif // UNDER_CE
}
//////////////////////////////////////////////////////////////////
// Function	:	ExGetTextExtentPoint32WForWin95
// Type		:	inline BOOL
// Purpose	:	
// Args		:	
//			:	HDC	hdc				//handle of device context.            
//			:	LPWSTR	wz			//address of text string.              
//			:	int	cch				//number of characters in string.      
//			:	LPSIZE	lpSize		//address of structure for string size.	
// Return	:	
// DATE		:	Thu Jul 30 20:31:05 1998
// Histroy	:	
//////////////////////////////////////////////////////////////////
static BOOL ExGetTextExtentPoint32WForWin95(HDC    hdc,		
											LPWSTR wz,		
											int    cch,		
											LPSIZE lpSize)	
{
	TEXTMETRIC tm;
	::GetTextMetrics(hdc, &tm);
	LANGID langId = ::GetSystemDefaultLangID();
	switch(tm.tmCharSet) {
	case SHIFTJIS_CHARSET:
		if(PRIMARYLANGID(langId) == LANG_JAPANESE) {
			return _ExGetTextExtentPoint32WWithTrans(932, hdc, wz, cch,lpSize);
		}
		return ::GetTextExtentPoint32W(hdc, wz, cch, lpSize);
		break;
	case GB2312_CHARSET:
		if(langId == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)) {
			return _ExGetTextExtentPoint32WWithTrans(936, hdc, wz, cch,lpSize);
		}
		return ::GetTextExtentPoint32W(hdc, wz, cch, lpSize);
		break;
	case CHINESEBIG5_CHARSET:
		if(langId == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)) {
			return _ExGetTextExtentPoint32WWithTrans(950, hdc, wz, cch,lpSize);
		}
		return ::GetTextExtentPoint32W(hdc, wz, cch, lpSize);
		break;
	case HANGEUL_CHARSET:
		if(PRIMARYLANGID(langId) == LANG_KOREAN) {
			return _ExGetTextExtentPoint32WWithTrans(949, hdc, wz, cch,lpSize);
		}
		return ::GetTextExtentPoint32W(hdc, wz, cch, lpSize);
		break;
	case SYMBOL_CHARSET:
		return _ExGetTextExtentPoint32WWithTrans(1252, hdc, wz, cch,lpSize);
		break;
	default:
		{
			CHARSETINFO info;
			if(::TranslateCharsetInfo((DWORD *)tm.tmCharSet, &info, TCI_SRCCHARSET)) {
				return _ExGetTextExtentPoint32WWithTrans(info.ciACP, hdc, wz, cch,lpSize);
			}
			else {
				return _ExGetTextExtentPoint32WWithTrans(CP_ACP, hdc, wz, cch,lpSize);
			}
		}
		break;
	}
	
}

//----------------------------------------------------------------
//public Function
//----------------------------------------------------------------
BOOL ExExtTextOutW(HDC		hdc,		// handle to device context.
				   int		X,			// x-coordinate of reference point
				   int		Y,			// y-coordinate of reference point
				   UINT	 fuOptions,	// text-output options.
				   CONST RECT *lprc,	// optional clipping and/or opaquing rectangle.
				   LPWSTR	 lpString,	// points to string.
				   UINT	 cbCount,	// number of characters in string.
				   CONST INT *lpDx)	 // pointer to array of intercharacter spacing values );
{
	if(ExIsWin95()) {
		return ExExtTextOutWForWin95(hdc, X, Y, fuOptions, lprc, lpString, cbCount, lpDx);
	}
	return ExtTextOutW(hdc, X, Y, fuOptions, lprc, lpString, cbCount, lpDx);
}

BOOL ExGetTextExtentPoint32W(HDC    hdc,		// handle of device context.
							 LPWSTR wz,		// address of text string.
							 int    cch,		// number of characters in string.
							 LPSIZE lpSize)	// address of structure for string size.
{
	BOOL fRet;
	//if char count is 0
	if(!wz) {
		lpSize->cx = lpSize->cy = 0;
		return 0;
	}
	if(cch == 0) {
#ifndef UNDER_CE
		fRet = GetTextExtentPointA(hdc, " ", 1, lpSize);
#else // UNDER_CE
		fRet = GetTextExtentPoint(hdc, TEXT(" "), 1, lpSize);
#endif // UNDER_CE
		lpSize->cx = 0;
		return (fRet);
	}
	if(ExIsWin95()) {
		return ExGetTextExtentPoint32WForWin95(hdc, wz, cch, lpSize);
	}
	return GetTextExtentPoint32W(hdc, wz, cch, lpSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\api.cpp ===
#include <windows.h>
#include "hwxapp.h"
#include "api.h"

extern const IID IID_Multibox = { /* 62e71630-f869-11d0-af9c-00805f0c8b6d */
    0x62e71630,
    0xf869,
    0x11d0,
    {0xaf, 0x9c, 0x00, 0x80, 0x5f, 0x0c, 0x8b, 0x6d}
};

HRESULT WINAPI GetIImePadAppletIdList(LPAPPLETIDLIST lpIdList)
{
#ifdef IME98_BETA2    //970826:ToshiaK for beta1 relesae, do not create multibox instance
    lpIdList->count = 0;
    lpIdList->pIIDList = NULL;
    return S_FALSE;
#else
    lpIdList->count = 1;
    lpIdList->pIIDList = (IID *)CoTaskMemAlloc(sizeof(IID)); 
    lpIdList->pIIDList[0] = IID_Multibox;
    return S_OK;
#endif
}

HRESULT WINAPI CreateIImePadAppletInstance(REFIID refiid, VOID **ppvObj)
{
    extern HINSTANCE g_hInst;

#ifdef IME98_BETA2
    *ppvObj = NULL;
    return S_FALSE;
#else
    CApplet *pCApplet = new CApplet(g_hInst);
    if(pCApplet == NULL) {
        return E_OUTOFMEMORY;
    }
    pCApplet->QueryInterface(refiid, ppvObj);
    return S_OK;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\api.h ===
#ifndef _API_H_
#define _API_H_
HRESULT WINAPI GetIImePadAppletIdList(LPAPPLETIDLIST lpIdList);
HRESULT WINAPI CreateIImePadAppletInstance(REFIID refiid, VOID **ppvObj);
#endif //_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\common\winapi.cpp ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "winapi.h"

#ifdef UNDER_CE // not support IsWindowUnicode
inline BOOL IsWindowUnicode(HWND){return TRUE;}
#endif // UNDER_CE

#define MemAlloc(a)	GlobalAlloc(GMEM_FIXED, (a))
#define MemFree(a)	GlobalFree((a))

#if !(defined(UNICODE) || defined(_UNICODE) || !defined(AWBOTH))
LRESULT WINAPI WinSendMessage(
							  HWND hWnd,
							  UINT Msg,
							  WPARAM wParam,
							  LPARAM lParam)
{
	if(::IsWindowUnicode(hWnd)) {
		return ::SendMessageW(hWnd, Msg, wParam, lParam);
	}
	else {
		return ::SendMessageA(hWnd, Msg, wParam, lParam);
	}
}

BOOL WINAPI WinPostMessage(
						   HWND hWnd,
						   UINT Msg,
						   WPARAM wParam,
						   LPARAM lParam)
{
	if(::IsWindowUnicode(hWnd)) {
		return ::PostMessageW(hWnd, Msg, wParam, lParam);
	}
	else {
		return ::PostMessageA(hWnd, Msg, wParam, lParam);
	}
}

BOOL WINAPI WinPeekMessage(
						   LPMSG lpMsg,
						   HWND hWnd ,
						   UINT wMsgFilterMin,
						   UINT wMsgFilterMax,
						   UINT wRemoveMsg)
{
	if(::IsWindowUnicode(hWnd)) {
		return ::PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
	}
	else {
		return ::PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
	}
}

LRESULT WINAPI WinDispatchMessage(
							   CONST MSG *lpMsg)
{
	if(::IsWindowUnicode(lpMsg->hwnd)) {
		return ::DispatchMessageW(lpMsg);
	}
	else {
		return ::DispatchMessageA(lpMsg);
	}
}

#define WinTranslateMessage		TranslateMessage

LONG WINAPI WinSetWindowLong(
							 HWND hWnd,
							 int nIndex,
							 LONG dwNewLong)
{
	if(::IsWindowUnicode(hWnd)) {
		return ::SetWindowLongW(hWnd, nIndex, dwNewLong);
	}
	else {
		return ::SetWindowLongA(hWnd, nIndex, dwNewLong);
	}
}

LONG WINAPI WinGetWindowLong(
							 HWND hWnd,
							 int nIndex)
{
	if(::IsWindowUnicode(hWnd)) {
		return ::GetWindowLongW(hWnd, nIndex);
	}
	else {
		return ::GetWindowLongA(hWnd, nIndex);
	}
}

#ifdef STRICT 
LRESULT WINAPI WinCallWindowProc(
								 WNDPROC lpPrevWndFunc,
								 HWND hWnd,
								 UINT Msg,
								 WPARAM wParam,
								 LPARAM lParam)
{
	if(::IsWindowUnicode(hWnd)) {
		return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
	}
	else {
		return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
	}
}
#else /* !STRICT */
LRESULT WINAPI WinCallWindowProc(
								 FARPROC lpPrevWndFunc,
								 HWND hWnd,
								 UINT Msg,
								 WPARAM wParam,
								 LPARAM lParam)
{
	if(::IsWindowUnicode(hWnd)) {
		return CallWindowProcW((FARPROC)lpPrevWndFunc, hWnd, Msg, wParam, lParam);
	}
	else {
		return CallWindowProcA((FARPROC)lpPrevWndFunc, hWnd, Msg, wParam, lParam);
	}
}
#endif /* STRICT */

LRESULT WINAPI WinDefWindowProc(
								HWND hWnd,
								UINT Msg,
								WPARAM wParam,
								LPARAM lParam)
{
	if(::IsWindowUnicode(hWnd)) {
		return ::DefWindowProcW(hWnd, Msg, wParam, lParam);
	}
	else {
		return ::DefWindowProcA(hWnd, Msg, wParam, lParam);
	}
}

BOOL WINAPI WinIsDialogMessage(
							   HWND hDlg,
							   LPMSG lpMsg)
{
	if(::IsWindowUnicode(hDlg)) {
		return ::IsDialogMessageW(hDlg, lpMsg);
	}
	else {
		return ::IsDialogMessageA(hDlg, lpMsg);
	}
}

//----------------------------------------------------------------
//	WinSetWindowTextA_CP
//	WinGetWindowTextA_CP
//	WinSetWindowTextW_CP
//	WinGetWindowTextW_CP
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function	:	WinSetWindowTextA_CP
// Type		:	BOOL WINAPI
// Purpose	:	
// Args		:	
//			:	UINT	codePage	
//			:	HWND	hWnd	
//			:	LPCSTR	lpString	
// Return	:	
// DATE		:	Fri Jul 16 04:21:05 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
#ifndef UNDER_CE
BOOL WINAPI
WinSetWindowTextA_CP(UINT codePage, HWND hWnd, LPCSTR  lpString)
{
	if(::IsWindowUnicode(hWnd)) {
		INT	len = ::lstrlenA(lpString);
		if(len == 0) {
			::SetWindowTextW(hWnd, L"");
		}
		else {
			LPWSTR	lpwstr = (LPWSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpwstr) {
				::MultiByteToWideChar(codePage, MB_PRECOMPOSED, lpString, -1,
									  lpwstr, len+1);
				::SetWindowTextW(hWnd, lpwstr);
				MemFree(lpwstr);
			}
		}
	}
	else {
		::SetWindowTextA(hWnd, lpString);
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function	:	WinGetWindowTextA_CP
// Type		:	int WINAPI
// Purpose	:	
// Args		:	
//			:	UINT	codePage	
//			:	HWND	hWnd	
//			:	LPSTR	lpString	
//			:	int	nMaxCount	
// Return	:	
// DATE		:	Fri Jul 16 04:25:37 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
int	WINAPI
WinGetWindowTextA_CP(UINT codePage, HWND hWnd, LPSTR  lpString, int nMaxCount)
{
	int result =0;

	if(::IsWindowUnicode(hWnd)) {
		INT len = ::GetWindowTextLengthW(hWnd);
		LPWSTR lpwstr;
		if(len > 0) {
			lpwstr = (LPWSTR)MemAlloc(sizeof(WCHAR)*(len+1));
			if(lpwstr) {
				result = ::GetWindowTextW(hWnd, lpwstr, len+1);
				::WideCharToMultiByte(codePage, WC_COMPOSITECHECK,
									  lpwstr, -1,
									  lpString,
									  nMaxCount,
									  NULL, NULL);
				MemFree(lpwstr);
			}
		}else{
			lstrcpy(lpString, "");
		}
	}
	else {
		result = ::GetWindowTextA(hWnd, lpString, nMaxCount);
	}
	return(result);
}
#endif //UNDER_CE


//////////////////////////////////////////////////////////////////
// Function	:	WinSetWindowTextW_CP
// Type		:	BOOL WINAPI
// Purpose	:	
// Args		:	
//			:	UINT	codePage	
//			:	HWND	hWnd	
//			:	LPCWSTR	lpString	
// Return	:	
// DATE		:	Fri Jul 16 04:22:42 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL WINAPI
WinSetWindowTextW_CP(UINT codePage, HWND hWnd, LPCWSTR lpString)
{
	if(!lpString) {
		return 0;
	}

	if(::IsWindowUnicode(hWnd)) {
		::SetWindowTextW(hWnd, lpString);
	}
	else {
		INT	len = ::lstrlenW(lpString);
		if(len > 0) {
			LPSTR	lpstr = (LPSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpstr) {
				::WideCharToMultiByte(codePage, WC_COMPOSITECHECK,
									  lpString, -1,
									  lpstr,
									  sizeof(WCHAR)*(len+1),
									  NULL, NULL);
				::SetWindowTextA(hWnd, lpstr);
				MemFree(lpstr);
			}
		}
		else {
			::SetWindowTextA(hWnd, "");
		}
	}
	return 0;
}

int	WINAPI
WinGetWindowTextW_CP(UINT codePage, HWND hWnd, LPWSTR lpString, int nMaxCount)
{
	int result = 0;

	if(!lpString) {
		return 0;
	}
	if(nMaxCount <= 0) {
		return 0;
	}
	if(::IsWindowUnicode(hWnd)) {
		result = ::GetWindowTextW(hWnd, lpString, nMaxCount);
	}
	else {
		INT size = ::GetWindowTextLengthA(hWnd);
		LPSTR lpstr;
		if(size > 0) {
			lpstr = (LPSTR)MemAlloc((size+1)* sizeof(CHAR));
			if(lpstr) {
				result = ::GetWindowTextA(hWnd, lpstr, size+1);
				result = ::MultiByteToWideChar(codePage, MB_PRECOMPOSED, lpstr, -1,
											   lpString, nMaxCount);
				MemFree(lpstr);
			}
		}
		else {
			*lpString = (WCHAR)0x0000;
		}
	}
	return(result);
}

#ifndef  UNDER_CE
int	WINAPI
WinGetWindowTextLengthA_CP(UINT codePage, HWND hWnd)
{
	if(::IsWindowUnicode(hWnd)) {
		INT len = ::GetWindowTextLengthW(hWnd);
		if(len > 0) {
			LPWSTR lpwstr = (LPWSTR)MemAlloc(sizeof(WCHAR)*(len+1));
			if(lpwstr) {
				::GetWindowTextW(hWnd, lpwstr, len+1);
				INT size = WideCharToMultiByte(codePage, WC_COMPOSITECHECK,
											   lpwstr, -1,
											   NULL, NULL, 0, 0);
				MemFree(lpwstr);
				return size;
			}
		}
	}
	else {
		return ::GetWindowTextLengthA(hWnd);
	}
	return 0;
}
#endif //UNDER_CE

//////////////////////////////////////////////////////////////////
// Function	:	WinGetWindowTextLengthW_CP
// Type		:	int WINAPI
// Purpose	:	
// Args		:	
//			:   UINT	codePage
//			:	HWND	hWnd	
// Return	:	
// DATE		:	Fri Jul 16 04:31:18 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
int	WINAPI
WinGetWindowTextLengthW_CP(UINT codePage, HWND hWnd)
{
	if(::IsWindowUnicode(hWnd)) {
		return ::GetWindowTextLengthA(hWnd);
	}
	else {
		INT size = ::GetWindowTextLengthA(hWnd);
		if(size > 0) {
			LPSTR lpstr = (LPSTR)MemAlloc(sizeof(CHAR)*(size+1));
			if(lpstr) {
				::GetWindowTextA(hWnd, lpstr, size+1);
				INT len = MultiByteToWideChar(codePage, MB_PRECOMPOSED,
											  lpstr, -1,
											  NULL, NULL);
				MemFree(lpstr);
				return len;
			}
		}
	}
	return 0;
}

//---------  for Win64 -------------------------------------------
#ifdef _WIN64
//////////////////////////////////////////////////////////////////
// Function :   WinSetUserData
// Type     :   LONG_PTR WINAPI
// Purpose  :   Wrapper for Win64 SetWindowLongPtr(.., GWLP_USERDATA,..) ;
// Args     :   
//          :   
//          :   HWND    hwnd    
//          :   LONG_PTR    lUserData   
// Return   :   
// DATE     :   Mon Jul 12 18:26:41 1999
// Histroy  :   
//////////////////////////////////////////////////////////////////
static LONG_PTR    WINAPI
WinSetUserDataTemplate(HWND hwnd, LONG_PTR lUserData, INT iOffset)
{
    if(::IsWindowUnicode(hwnd)) {
        return ::SetWindowLongPtrW(hwnd, iOffset, lUserData);
    }
    else {
        return ::SetWindowLongPtrA(hwnd, iOffset, lUserData);
    }
}

inline LONG_PTR WINAPI WinSetUserData(HWND hwnd, LONG_PTR lUserData){
    return(WinSetUserDataTemplate(hwnd, lUserData, GWLP_USERDATA));
}

inline LONG_PTR WINAPI WinSetUserDlgData(HWND hwnd, LONG_PTR lUserData){
    return(WinSetUserDataTemplate(hwnd, lUserData, DWLP_USER));
}

inline LONG_PTR WINAPI WinSetMsgResult(HWND hwnd, LONG_PTR lUserData){
    return(WinSetUserDataTemplate(hwnd, lUserData, DWLP_MSGRESULT));
}


//////////////////////////////////////////////////////////////////
// Function :   WinGetUserData
// Type     :   LONG_PTR WINAPI
// Purpose  :   Wrapper for Win64 GetWindowLongPtr(..,GWLP_USERDATA,.. );
// Args     :   
//          :   HWND    hwnd    
// Return   :   
// DATE     :   Mon Jul 12 18:28:07 1999
// Histroy  :   
//////////////////////////////////////////////////////////////////
static LONG_PTR WINAPI
WinGetUserDataTemplate(HWND hwnd, INT iOffset)
{
    if(::IsWindowUnicode(hwnd)) {
        return ::GetWindowLongPtrW(hwnd, iOffset);
    }
    else {
        return ::GetWindowLongPtrA(hwnd, iOffset);
    }
}

inline LONG_PTR WINAPI WinGetUserData(HWND hwnd){
    return(WinGetUserDataTemplate(hwnd, GWLP_USERDATA));
}

inline LONG_PTR WINAPI WinGetUserDlgData(HWND hwnd){
    return(WinGetUserDataTemplate(hwnd, DWLP_USER));
}

inline LONG_PTR WINAPI WinGetMsgResult(HWND hwnd){
    return(WinGetUserDataTemplate(hwnd, DWLP_MSGRESULT));
}

#else   //!_WIN64
//------- for Win32 ------------------------------------------
//////////////////////////////////////////////////////////////////
// Function :   WinSetUserData
// Type     :   LONG WINAPI
// Purpose  :   
// Args     :   
//          :   HWND    hwnd    
//          :   LONG    lUserData   
// Return   :   
// DATE     :   Mon Jul 12 18:29:21 1999
// Histroy  :   
//////////////////////////////////////////////////////////////////
static LONG    WINAPI
WinSetUserDataTemplate(HWND hwnd, LONG lUserData, INT iOffset)
{
#ifdef UNDER_CE
    return SetWindowLong(hwnd, iOffset, lUserData);
#else   //!UNDER_CE 
    if(::IsWindowUnicode(hwnd)) {
        return ::SetWindowLongW(hwnd, iOffset, lUserData);
    }
    else {
        return ::SetWindowLongA(hwnd, iOffset, lUserData);
    }
#endif
}

inline LONG WINAPI WinSetUserData(HWND hwnd, LONG lUserData){
    return(WinSetUserDataTemplate(hwnd, lUserData, GWL_USERDATA));
}

inline LONG WINAPI WinSetUserDlgData(HWND hwnd, LONG lUserData){
    return(WinSetUserDataTemplate(hwnd, lUserData, DWL_USER));
}

inline LONG WINAPI WinSetMsgResult(HWND hwnd, LONG lUserData){
    return(WinSetUserDataTemplate(hwnd, lUserData, DWL_MSGRESULT));
}

//////////////////////////////////////////////////////////////////
// Function :   WinGetUserData
// Type     :   LONG WINAPI
// Purpose  :   
// Args     :   
//          :   HWND    hwnd    
// Return   :   
// DATE     :   Mon Jul 12 18:29:43 1999
// Histroy  :   
//////////////////////////////////////////////////////////////////
static LONG WINAPI
WinGetUserDataTemplate(HWND hwnd, INT iOffset)
{
#ifdef UNDER_CE
    return GetWindowLong(hwnd, iOffset);
#else   //!UNDER_CE
    if(::IsWindowUnicode(hwnd)) {
        return ::GetWindowLongW(hwnd, iOffset);
    }
    else {
        return ::GetWindowLongA(hwnd, iOffset);
    }
#endif
}

inline LONG WINAPI WinGetUserData(HWND hwnd){
    return(WinGetUserDataTemplate(hwnd, GWL_USERDATA));
}

inline LONG WINAPI WinGetUserDlgData(HWND hwnd){
    return(WinGetUserDataTemplate(hwnd, DWL_USER));
}

inline LONG WINAPI WinGetMsgResult(HWND hwnd){
    return(WinGetUserDataTemplate(hwnd, DWL_MSGRESULT));
}

#endif  //_WIN64

//////////////////////////////////////////////////////////////////
// Function :   WinSetWndProc
// Type     :   WNDPROC WINAPI
// Purpose  :   
// Args     :   
//          :   HWND    hwnd    
//          :   WNDPROC lpfnWndProc 
// Return   :   
// DATE     :   Mon Jul 12 18:13:47 1999
// Histroy  :   
//////////////////////////////////////////////////////////////////
WNDPROC WINAPI
WinSetWndProc(HWND hwnd, WNDPROC lpfnWndProc)
{
#ifdef _WIN64
    if(::IsWindowUnicode(hwnd)) {
        return (WNDPROC)::SetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LONG_PTR)lpfnWndProc);
    }
    else {
        return (WNDPROC)::SetWindowLongPtrA(hwnd, GWLP_WNDPROC, (LONG_PTR)lpfnWndProc);
    }
#else  //!_WIN64

#ifdef UNDER_CE

    return (WNDPROC)SetWindowLong(hwnd, GWL_WNDPROC, (LONG)lpfnWndProc);

#else //!UNDER_CE

    if(::IsWindowUnicode(hwnd)) {
        return (WNDPROC)::SetWindowLongW(hwnd, GWL_WNDPROC, (LONG)lpfnWndProc);
    }
    else {
        return (WNDPROC)::SetWindowLongA(hwnd, GWL_WNDPROC, (LONG)lpfnWndProc);
    }

#endif  //end UNDER_CE

#endif  //_WIN64
}

LPVOID  WINAPI
WinSetUserPtr(HWND hwnd, LPVOID lpVoid)
{
#ifdef _WIN64
	return (LPVOID)WinSetUserData(hwnd, (LONG_PTR)lpVoid);
#else	
	return (LPVOID)WinSetUserData(hwnd, (LONG)lpVoid);
#endif
}

LPVOID  WINAPI  WinGetUserPtr(HWND hwnd)
{
	return (LPVOID)WinGetUserData(hwnd);
}

//////////////////////////////////////////////////////////////////
// Function :   WinGetWndProc
// Type     :   WNDPROC WINAPI
// Purpose  :   
// Args     :   
//          :   HWND    hwnd    
// Return   :   
// DATE     :   Mon Jul 12 18:30:22 1999
// Histroy  :   
//////////////////////////////////////////////////////////////////
WNDPROC WINAPI
WinGetWndProc(HWND hwnd)
{
#ifdef _WIN64
    if(::IsWindowUnicode(hwnd)) {
        return (WNDPROC)::GetWindowLongPtrW(hwnd, GWLP_WNDPROC);
    }
    else {
        return (WNDPROC)::GetWindowLongPtrA(hwnd, GWLP_WNDPROC);
    }
#else  //!_WIN64

#   ifdef UNDER_CE
    return (WNDPROC)GetWindowLong(hwnd, GWL_WNDPROC);
#   else
    if(::IsWindowUnicode(hwnd)) {
        return (WNDPROC)::GetWindowLongW(hwnd, GWL_WNDPROC);
    }
    else {
        return (WNDPROC)::GetWindowLongA(hwnd, GWL_WNDPROC);
    }
#   endif   //end UNDER_CE

#endif  //_WIN64
}

DWORD WINAPI
WinSetStyle(HWND hwnd, DWORD dwStyle)
{
#ifdef UNDER_CE
    return (DWORD)::SetWindowLong(hwnd, GWL_STYLE, (LONG)dwStyle);
#else   //!UNDER_CE
    if(::IsWindowUnicode(hwnd)) {
        return (DWORD)::SetWindowLongW(hwnd, GWL_STYLE, (LONG)dwStyle);
    }
    else {
        return (DWORD)::SetWindowLongA(hwnd, GWL_STYLE, (LONG)dwStyle);
    }
#endif  //End UNDER_CE
}

DWORD WINAPI
WinGetStyle(HWND hwnd)
{
#ifdef UNDER_CE
    return (DWORD)::GetWindowLong(hwnd, GWL_STYLE);
#else   //!UNDER_CE
    if(::IsWindowUnicode(hwnd)) {
        return (DWORD)::GetWindowLongW(hwnd, GWL_STYLE);
    }
    else {
        return (DWORD)::GetWindowLongA(hwnd, GWL_STYLE);
    }
#endif  //End UNDER_CE
}


DWORD WINAPI
WinSetExStyle(HWND hwnd, DWORD dwStyle)
{
#ifdef UNDER_CE
    return (DWORD)::SetWindowLong(hwnd, GWL_EXSTYLE, (LONG)dwStyle);
#else   //!UNDER_CE
    if(::IsWindowUnicode(hwnd)) {
        return (DWORD)::SetWindowLongW(hwnd, GWL_EXSTYLE, (LONG)dwStyle);
    }
    else {
        return (DWORD)::SetWindowLongA(hwnd, GWL_EXSTYLE, (LONG)dwStyle);
    }
#endif  //End UNDER_CE
}

DWORD WINAPI
WinGetExStyle(HWND hwnd)
{
#ifdef UNDER_CE
    return (DWORD)::GetWindowLong(hwnd, GWL_EXSTYLE);
#else   //!UNDER_CE
    if(::IsWindowUnicode(hwnd)) {
        return (DWORD)::GetWindowLongW(hwnd, GWL_EXSTYLE);
    }
    else {
        return (DWORD)::GetWindowLongA(hwnd, GWL_EXSTYLE);
    }
#endif  //End UNDER_CE
}

HINSTANCE WINAPI
WinGetInstanceHandle(HWND hwnd)
{
#ifdef _WIN64
    if(::IsWindowUnicode(hwnd)) {
        return (HINSTANCE)::GetWindowLongPtrW(hwnd, GWLP_HINSTANCE);
    }
    else {
        return (HINSTANCE)::GetWindowLongPtrA(hwnd, GWLP_HINSTANCE);
    }
#else  //!_WIN64

#ifdef UNDER_CE

    return (HINSTANCE)GetWindowLong(hwnd, GWL_HINSTANCE);

#else //!UNDER_CE

    if(::IsWindowUnicode(hwnd)) {
        return (HINSTANCE)::GetWindowLongW(hwnd, GWL_HINSTANCE);
    }
    else {
        return (HINSTANCE)::GetWindowLongA(hwnd, GWL_HINSTANCE);
    }
#endif  //end UNDER_CE

#endif  //_WIN64
}

#endif //#if !(defined(UNICODE) || defined(_UNICODE) || !defined(AWBOTH))


#ifndef UNDER_CE // always Unicode
INT LB_AddStringA(HWND hwndCtl, LPCSTR  lpsz)
{
	INT ret;
	if(::IsWindowUnicode(hwndCtl)) {
		INT	len = ::lstrlenA(lpsz);
		if(len > 0) {
			LPWSTR	lpwstr = (LPWSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpwstr) {
				::MultiByteToWideChar(932, MB_PRECOMPOSED, lpsz, -1,
									  lpwstr, len+1);
				ret = (INT)::SendMessageW(hwndCtl, LB_ADDSTRING, 0, (LPARAM)lpwstr);
				MemFree(lpwstr);
				return ret;
			}
		}else{
			return(INT)(::SendMessageW(hwndCtl, LB_ADDSTRING, 0, (LPARAM)L""));
		}
	}
	else {
		return (INT)::SendMessageA(hwndCtl, LB_ADDSTRING, 0, (LPARAM)lpsz);
	}
	return 0;
}
#endif // UNDER_CE

INT LB_AddStringW(HWND hwndCtl, LPCWSTR lpsz)
{
	if(!lpsz) {
		return -1;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		::SendMessageW(hwndCtl, LB_ADDSTRING, 0, (LPARAM)lpsz);
	}
	else {
#ifndef UNDER_CE // always Unicode
		INT	len = ::lstrlenW(lpsz);
		if(len > 0) {
			INT ret;
			LPSTR	lpstr = (LPSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpstr) {
				::WideCharToMultiByte(932, WC_COMPOSITECHECK,
									  lpsz, -1,
									  lpstr,
									  sizeof(WCHAR)*(len+1),
									  NULL, NULL);
				ret = (INT)::SendMessageA(hwndCtl, LB_ADDSTRING, 0, (LPARAM)lpstr);
				MemFree(lpstr);
				return ret;
			}
		}else{
			return(INT)(::SendMessageA(hwndCtl, LB_ADDSTRING, 0, (LPARAM)""));
		}
#endif // UNDER_CE
	}
	return 0;
}

#ifndef UNDER_CE // always Unicode
INT CB_AddStringA(HWND hwndCtl, LPCSTR  lpsz)
{
	if(!lpsz) {
		return 0;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		INT	len = ::lstrlenA(lpsz);
		if(len > 0) {
			LPWSTR	lpwstr = (LPWSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpwstr) {
				::MultiByteToWideChar(932, MB_PRECOMPOSED, lpsz, -1,
									  lpwstr, len+1);
				::SendMessageW(hwndCtl, CB_ADDSTRING, 0, (LPARAM)lpwstr);
				MemFree(lpwstr);
			}
		}else{
			::SendMessageW(hwndCtl, CB_ADDSTRING, 0, (LPARAM)L"");
		}
	}
	else {
		::SendMessageA(hwndCtl, CB_ADDSTRING, 0, (LPARAM)lpsz);
	}
	return 0;
}
#endif // UNDER_CE

INT CB_AddStringW(HWND hwndCtl, LPCWSTR lpsz)
{
	if(!lpsz) {
		return -1;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		::SendMessageW(hwndCtl, CB_ADDSTRING, 0, (LPARAM)lpsz);
	}
	else {
#ifndef UNDER_CE // always Unicode
		INT	len = ::lstrlenW(lpsz);
		if(len > 0) {
			LPSTR	lpstr = (LPSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpstr) {
				::WideCharToMultiByte(932, WC_COMPOSITECHECK,
									  lpsz, -1,
									  lpstr,
									  sizeof(WCHAR)*(len+1),
									  NULL, NULL);
				::SendMessageA(hwndCtl, CB_ADDSTRING, 0, (LPARAM)lpstr);
				MemFree(lpstr);
			}
		}else{
			::SendMessageA(hwndCtl, CB_ADDSTRING, 0, (LPARAM)"");
		}
#endif // UNDER_CE
	}
	return 0;
}

#ifndef UNDER_CE // always Unicode
INT CB_InsertStringA(HWND hwndCtl, INT index, LPCSTR  lpsz)
{
	if(!lpsz) {
		return 0;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		INT	len = ::lstrlenA(lpsz);
		if(len > 0) {
			LPWSTR	lpwstr = (LPWSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpwstr) {
				::MultiByteToWideChar(932, MB_PRECOMPOSED, lpsz, -1,
									  lpwstr, len+1);
				::SendMessageW(hwndCtl, CB_INSERTSTRING, index, (LPARAM)lpwstr);
				MemFree(lpwstr);
			}
		}else{
			::SendMessageW(hwndCtl, CB_INSERTSTRING, index, (LPARAM)L"");
		}
	}
	else {
		::SendMessageA(hwndCtl, CB_INSERTSTRING, index, (LPARAM)lpsz);
	}
	return 0;
}
#endif // UNDER_CE

INT CB_InsertStringW(HWND hwndCtl, INT index, LPCWSTR lpsz)
{
	if(!lpsz) {
		return -1;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		::SendMessageW(hwndCtl, CB_INSERTSTRING, index, (LPARAM)lpsz);
	}
	else {
#ifndef UNDER_CE // always Unicode
		INT	len = ::lstrlenW(lpsz);
		if(len > 0) {
			LPSTR	lpstr = (LPSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpstr) {
				::WideCharToMultiByte(932, WC_COMPOSITECHECK,
									  lpsz, -1,
									  lpstr,
									  sizeof(WCHAR)*(len+1),
									  NULL, NULL);
				::SendMessageA(hwndCtl, CB_INSERTSTRING, index, (LPARAM)lpstr);
				MemFree(lpstr);
			}
		}else{
			::SendMessageA(hwndCtl, CB_INSERTSTRING, index, (LPARAM)"");
		}
#endif // UNDER_CE
	}
	return 0;
}

#ifndef UNDER_CE // always Unicode
INT CB_GetLBTextA(HWND hwndCtl, INT index, LPSTR  lpszBuffer)
{
	if(!lpszBuffer) {
		return 0;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		INT	len = WinComboBox_GetLBTextLen(hwndCtl, index);
		if(len > 0) {
			LPWSTR	lpwstr = (LPWSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpwstr) {
				::SendMessageW(hwndCtl,  CB_GETLBTEXT, (WPARAM)index, (LPARAM)lpwstr);
				::WideCharToMultiByte(932, WC_COMPOSITECHECK,
									  lpwstr, -1,
									  lpszBuffer,
									  sizeof(WCHAR)*(len+1),
									  NULL, NULL);
				MemFree(lpwstr);
			}
		}
	}
	else {
		::SendMessageA(hwndCtl,  CB_GETLBTEXT, (WPARAM)index, (LPARAM)lpszBuffer);
	}
	return 0;
}
#endif // UNDER_CE

INT CB_GetLBTextW(HWND hwndCtl, INT index, LPWSTR lpszBuffer)
{
	if(!lpszBuffer) {
		return 0;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		::SendMessageW(hwndCtl, CB_GETLBTEXT, (WPARAM)index, (LPARAM)lpszBuffer);
	}
	else {
#ifndef UNDER_CE // always Unicode
		INT	len = WinComboBox_GetLBTextLen(hwndCtl, index);
		if(len > 0) {
			LPSTR	lpstr = (LPSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpstr) {
				::SendMessageA(hwndCtl, CB_GETLBTEXT, (WPARAM)index, (LPARAM)lpstr);
				::MultiByteToWideChar(932, MB_PRECOMPOSED, lpstr, -1,
									  lpszBuffer, len+1);
				MemFree(lpstr);
			}
		}
#endif // UNDER_CE
	}
	return 0;
}

#ifndef UNDER_CE // always Unicode
INT CB_FindStringA(HWND hwndCtl, INT indexStart, LPCSTR  lpszFind)
{
	INT result = 0;

	if(!lpszFind) {
		return 0;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		INT	len = ::lstrlenA(lpszFind);
		if(len > 0) {
			LPWSTR	lpwstr = (LPWSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpwstr) {
				::MultiByteToWideChar(932, MB_PRECOMPOSED, lpszFind, -1,
									  lpwstr, len+1);
				result = (INT)::SendMessageW(hwndCtl,  CB_FINDSTRING, (WPARAM)indexStart, (LPARAM)lpwstr);
				MemFree(lpwstr);
			}
		}
	}
	else {
		result = (INT)::SendMessageA(hwndCtl,  CB_FINDSTRING, (WPARAM)indexStart, (LPARAM)lpszFind);
	}
	return(result);
}
#endif // UNDER_CE

INT CB_FindStringW(HWND hwndCtl, INT indexStart, LPCWSTR lpszFind)
{
	INT result = 0;

	if(!lpszFind) {
		return 0;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		result = (INT)::SendMessageW(hwndCtl, CB_FINDSTRING, (WPARAM)indexStart, (LPARAM)lpszFind);
	}
	else {
#ifndef UNDER_CE // always Unicode
		INT	len = ::lstrlenW(lpszFind);
		if(len > 0) {
			LPSTR	lpstr = (LPSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpstr) {
				::WideCharToMultiByte(932, WC_COMPOSITECHECK,
									  lpszFind, -1,
									  lpstr,
									  sizeof(WCHAR)*(len+1),
									  NULL, NULL);
				result = (INT)::SendMessageA(hwndCtl, CB_FINDSTRING, (WPARAM)indexStart, (LPARAM)lpstr);
				MemFree(lpstr);
			}
		}
#endif // UNDER_CE
	}
	return(result);
}

#ifndef UNDER_CE // always Unicode
INT CB_FindStringExactA(HWND hwndCtl, INT indexStart, LPCSTR  lpszFind)
{
	INT result = 0;

	if(!lpszFind) {
		return 0;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		INT	len = ::lstrlenA(lpszFind);
		if(len > 0) {
			LPWSTR	lpwstr = (LPWSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpwstr) {
				::MultiByteToWideChar(932, MB_PRECOMPOSED, lpszFind, -1,
									  lpwstr, len+1);
				result = (INT)::SendMessageW(hwndCtl,  CB_FINDSTRINGEXACT, (WPARAM)indexStart, (LPARAM)lpwstr);
				MemFree(lpwstr);
			}
		}
	}
	else {
		result = (INT)::SendMessageA(hwndCtl,  CB_FINDSTRINGEXACT, (WPARAM)indexStart, (LPARAM)lpszFind);
	}
	return(result);
}
#endif // UNDER_CE

INT CB_FindStringExactW(HWND hwndCtl, INT indexStart, LPCWSTR lpszFind)
{
	INT result = 0;

	if(!lpszFind) {
		return 0;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		result = (INT)::SendMessageW(hwndCtl, CB_FINDSTRINGEXACT, (WPARAM)indexStart, (LPARAM)lpszFind);
	}
	else {
#ifndef UNDER_CE // always Unicode
		INT	len = ::lstrlenW(lpszFind);
		if(len > 0) {
			LPSTR	lpstr = (LPSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpstr) {
				::WideCharToMultiByte(932, WC_COMPOSITECHECK,
									  lpszFind, -1,
									  lpstr,
									  sizeof(WCHAR)*(len+1),
									  NULL, NULL);
				result = (INT)::SendMessageA(hwndCtl, CB_FINDSTRINGEXACT, (WPARAM)indexStart, (LPARAM)lpstr);
				MemFree(lpstr);
			}
		}
#endif // UNDER_CE
	}
	return(result);
}

#ifndef UNDER_CE // always Unicode
INT CB_SelectStringA(HWND hwndCtl, INT indexStart, LPCSTR  lpszSelect)
{
	INT ret = CB_ERR;
	if(!lpszSelect) {
		return CB_ERR;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		INT	len = ::lstrlenA(lpszSelect);
		if(len > 0) {
			LPWSTR	lpwstr = (LPWSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpwstr) {
				::MultiByteToWideChar(932, MB_PRECOMPOSED, lpszSelect, -1,
									  lpwstr, len+1);
				ret = (INT)::SendMessageW(hwndCtl,  CB_SELECTSTRING, (WPARAM)indexStart, (LPARAM)lpwstr);
				MemFree(lpwstr);
			}
		}
	}
	else {
		ret = (INT)::SendMessageA(hwndCtl,  CB_SELECTSTRING, (WPARAM)indexStart, (LPARAM)lpszSelect);
	}
	return ret;
}
#endif // UNDER_CE

INT CB_SelectStringW(HWND hwndCtl, INT indexStart, LPCWSTR lpszSelect)
{
	INT ret = CB_ERR;
	if(!lpszSelect) {
		return CB_ERR;
	}
	if(::IsWindowUnicode(hwndCtl)) {
		ret = (INT)::SendMessageW(hwndCtl, CB_SELECTSTRING, (WPARAM)indexStart, (LPARAM)lpszSelect);
	}
	else {
#ifndef UNDER_CE // always Unicode
		INT	len = ::lstrlenW(lpszSelect);
		if(len > 0) {
			LPSTR	lpstr = (LPSTR)MemAlloc(sizeof(WCHAR)*(len + 1));
			if(lpstr) {
				::WideCharToMultiByte(932, WC_COMPOSITECHECK,
									  lpszSelect, -1,
									  lpstr,
									  sizeof(WCHAR)*(len+1),
									  NULL, NULL);
				ret = (INT)::SendMessageA(hwndCtl, CB_SELECTSTRING, (WPARAM)indexStart, (LPARAM)lpstr);
				MemFree(lpstr);
			}
		}
#endif // UNDER_CE
	}
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\common\exres.cpp ===
//////////////////////////////////////////////////////////////////
//	File    : exres.cpp
//	Owner	: ToshiaK
//	Purpose :	Wrapper function for Gettting resource with Specified
//				language ID.	
//				In WinNT, GetThreadLocale() SetThreadLocale() works
//				and before getting resource, change LangId temporary,
//				call normal API for getting resource,
//				and reset LangID to previous one.
//				In Win95, SetThreadLocale() does NOT work.
//				in this case, Load resource directory and
//				find spcified language resource.
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include "exres.h"

//----------------------------------------------------------------
// Internal memory Allocate Free function.
//----------------------------------------------------------------
inline LPVOID ExMemAlloc(INT size)
{
	return (LPVOID)GlobalAllocPtr(GHND, (size));
}

inline BOOL ExMemFree(LPVOID lp)
{
#ifndef UNDER_CE
	return GlobalFreePtr((lp));
#else // UNDER_CE
	return (BOOL)GlobalFreePtr((lp));
#endif // UNDER_CE
}

inline Min(INT a, INT b) 
{
	 return ((a)<(b)?(a):(b)) ;
}

//----------------------------------------------------------------
// Function for Getting OS version 
//----------------------------------------------------------------
inline static POSVERSIONINFO ExGetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

inline static BOOL ExIsWin95(VOID) 
{ 
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
			(ExGetOSVersion()->dwMajorVersion >= 4) &&
			(ExGetOSVersion()->dwMinorVersion < 10);

	return fBool;
}

inline static BOOL ExIsWin98(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
			(ExGetOSVersion()->dwMajorVersion >= 4) &&
			(ExGetOSVersion()->dwMinorVersion  >= 10);
	return fBool;
}


inline static BOOL ExIsWinNT4(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
			(ExGetOSVersion()->dwMajorVersion >= 4) &&
			(ExGetOSVersion()->dwMinorVersion >= 0);
	return fBool;
}

inline static BOOL ExIsWinNT5(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
			(ExGetOSVersion()->dwMajorVersion >= 5) &&
			(ExGetOSVersion()->dwMinorVersion >= 0);
	return fBool;
}

inline static BOOL ExIsWinNT(VOID)
{
	return (ExIsWinNT4() || ExIsWinNT5());
}


//----------------------------------------------------------------
// Resource API open to public
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function : ExLoadStringW
// Type     : INT
// Purpose  : Wrapper of LoadStrinW() API.
//			  Load Unicode string with specified Language 
//			  in any platform.
// Args     : 
//          : LANGID	lgid 
//          : HINSTANCE hInst 
//          : UINT		uID 
//          : LPWSTR	lpBuffer 
//          : INT		nBufferMax 
// Return   : 
// DATE     : 971028
//////////////////////////////////////////////////////////////////
INT WINAPI ExLoadStringW(LANGID lgid, HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, INT nBufferMax)
{
	if(!hInst) {
		return 0;
	}
	if(!lpBuffer) {
		return 0;
	}

#if 0
	if(ExIsWinNT()) {
		LCID lcidOrig = GetThreadLocale();
		SetThreadLocale(MAKELCID(lgid, SORT_DEFAULT));
		INT ret = LoadStringW(hInst, uID, lpBuffer, nBufferMax); 	
		SetThreadLocale(lcidOrig);
		return ret;
	}
#endif

	INT len = 0;
	UINT block, num;
	block = (uID >>4)+1;
	num   = uID & 0xf;
	HRSRC hres;
	hres = FindResourceEx(hInst,
						  RT_STRING,
						  MAKEINTRESOURCE(block),
						  (WORD)lgid);
	//Dbg(("hres[0x%08x]\n", hres));
	if(!hres) {
		goto Error;
	}
	HGLOBAL hgbl;
	hgbl = LoadResource(hInst, hres);
	if(!hres) {
		goto Error;
	}
	//Dbg(("hgbl[0x%08x]\n", hgbl));
	LPWSTR lpwstr;
	lpwstr = (LPWSTR)LockResource(hgbl);
	if(!lpwstr) {
		goto Error;
	}
	UINT i;
	for(i = 0; i < num; i++) {
		lpwstr += *lpwstr + 1;
	}
	len = *lpwstr;
	CopyMemory(lpBuffer, lpwstr+1, Min(len, nBufferMax-1) * sizeof(WCHAR));
	lpBuffer[Min(len, nBufferMax-1)]= (WCHAR)0x0000;
 Error:
	return len;
}

//////////////////////////////////////////////////////////////////
// Function : ExLoadStringA
// Type     : INT
// Purpose  : Wrapper of LoadStringA().
// Args     : 
//          : LANGID	lgid
//          : HINSTANCE hInst 
//          : INT		uID 
//          : LPSTR		lpBuffer 
//          : INT		nBufferMax 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI ExLoadStringA(LANGID lgid, HINSTANCE hInst, INT uID, LPSTR lpBuffer, INT nBufferMax)
{
	if(!hInst) {
		return 0;
	}

	if(!lpBuffer) {
		return 0;
	}

#if 0
	if(ExIsWinNT()) {
		LCID lcidOrig = GetThreadLocale();
		SetThreadLocale(MAKELCID(lgid, SORT_DEFAULT));
		INT len = LoadStringA(hInst, uID, lpBuffer, nBufferMax);
		SetThreadLocale(lcidOrig);
		return len;
	}
#endif
	LPWSTR lpwstr = (LPWSTR)ExMemAlloc(nBufferMax*sizeof(WCHAR));
	if(!lpwstr) {
		return 0;
	}
	INT len = ExLoadStringW(lgid, hInst, uID, lpwstr, nBufferMax);
	len = WideCharToMultiByte(932, 
							  WC_COMPOSITECHECK, 
							  lpwstr, -1,
							  lpBuffer, nBufferMax, 
							  NULL, NULL); 

	if( len ) {
		len --;	// remove NULL char
	}

	ExMemFree(lpwstr);
	return len;
}

//////////////////////////////////////////////////////////////////
// Function : ExDialogBoxParamA
// Type     : int
// Purpose  :
// Args     :
//          : LANGID	lgid
//          : HINSTANCE hInstance		// handle to application instance
//          : LPCTSTR	lpTemplateName	// identifies dialog box template
//          : HWND		hWndParent		// handle to owner window
//          : DLGPROC	lpDialogFunc	// pointer to dialog box procedure
//          : LPARAM	dwInitParam		// initialization value
// Return   :
// DATE     :
//////////////////////////////////////////////////////////////////
int WINAPI	ExDialogBoxParamA(LANGID	lgid,
							  HINSTANCE	hInstance,
							  LPCTSTR	lpTemplateName,
							  HWND		hWndParent,
							  DLGPROC	lpDialogFunc,
							  LPARAM	dwInitParam)
{
	DLGTEMPLATE*pDlgTmpl;
	pDlgTmpl = ExLoadDialogTemplate(lgid, hInstance, lpTemplateName);
	if(ExIsWinNT5()) {
		return (INT)DialogBoxIndirectParamW(hInstance,
									   pDlgTmpl,
									   hWndParent,
									   lpDialogFunc,
									   dwInitParam);
	}
	else {
		return (INT)DialogBoxIndirectParamA(hInstance,
									   pDlgTmpl,
									   hWndParent,
									   lpDialogFunc,
									   dwInitParam);
	}
}

//////////////////////////////////////////////////////////////////
// Function : ExDialogBoxParamW
// Type     : int
// Purpose  :
// Args     :
//          : LANGID	lgid
//          : HINSTANCE hInstance		// handle to application instance
//          : LPCWSTR	lpTemplateName	// identifies dialog box template
//          : HWND		hWndParent		// handle to owner window
//          : DLGPROC	lpDialogFunc	// pointer to dialog box procedure
//          : LPARAM	dwInitParam		// initialization value
// Return   :
// DATE     :
//////////////////////////////////////////////////////////////////
int WINAPI	ExDialogBoxParamW(LANGID	lgid,
							  HINSTANCE	hInstance,
							  LPCWSTR	lpTemplateName,
							  HWND		hWndParent,
							  DLGPROC	lpDialogFunc,
							  LPARAM	dwInitParam)
{
	DLGTEMPLATE*pDlgTmpl;
#ifndef UNDER_CE
	pDlgTmpl = ExLoadDialogTemplate(lgid, hInstance, MAKEINTRESOURCEA(lpTemplateName));
#else // UNDER_CE
	pDlgTmpl = ExLoadDialogTemplate(lgid, hInstance, MAKEINTRESOURCE(lpTemplateName));
#endif // UNDER_CE
	return (INT)DialogBoxIndirectParamW(hInstance,
									   pDlgTmpl,
									   hWndParent,
									   lpDialogFunc,
									   dwInitParam);
}

//////////////////////////////////////////////////////////////////
// Function : ExCreateDialogParamA
// Type     : HWND 
// Purpose  : 
// Args     : 
//			: LANGID	lgid
//          : HINSTANCE	hInstance		// handle to application instance   
//          : LPCTSTR	lpTemplateName	// identifies dialog box template   
//          : HWND		hWndParent		// handle to owner window           
//          : DLGPROC	lpDialogFunc	// pointer to dialog box procedure  
//          : LPARAM	dwInitParam		// initialization value             
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HWND WINAPI ExCreateDialogParamA(LANGID		lgid,
								 HINSTANCE	hInstance,		
								 LPCTSTR	lpTemplateName,	
								 HWND		hWndParent,			
								 DLGPROC	lpDialogFunc,	
								 LPARAM		dwInitParam)		
{
	DLGTEMPLATE*pDlgTmpl;
	pDlgTmpl = ExLoadDialogTemplate(lgid, hInstance, lpTemplateName);
	if(ExIsWinNT5()) {
		return CreateDialogIndirectParamW( hInstance, pDlgTmpl, hWndParent, lpDialogFunc, dwInitParam);
	}
	else {
		return CreateDialogIndirectParamA( hInstance, pDlgTmpl, hWndParent, lpDialogFunc, dwInitParam);
	}
}

//////////////////////////////////////////////////////////////////
// Function : ExCreateDialogParamW
// Type     : HWND 
// Purpose  : 
// Args     : 
//			: LANGID	lgid
//          : HINSTANCE	hInstance		// handle to application instance   
//          : LPCTSTR	lpTemplateName	// identifies dialog box template   
//          : HWND		hWndParent		// handle to owner window           
//          : DLGPROC	lpDialogFunc	// pointer to dialog box procedure  
//          : LPARAM	dwInitParam		// initialization value             
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HWND WINAPI ExCreateDialogParamW(LANGID		lgid,
								 HINSTANCE	hInstance,		
								 LPCWSTR	lpTemplateName,	
								 HWND		hWndParent,			
								 DLGPROC	lpDialogFunc,	
								 LPARAM		dwInitParam)		
{
	DLGTEMPLATE*pDlgTmpl;
#ifndef UNDER_CE
	pDlgTmpl = ExLoadDialogTemplate(lgid, hInstance, MAKEINTRESOURCEA(lpTemplateName));
#else // UNDER_CE
	pDlgTmpl = ExLoadDialogTemplate(lgid, hInstance, MAKEINTRESOURCE(lpTemplateName));
#endif // UNDER_CE
	return CreateDialogIndirectParamW( hInstance, pDlgTmpl, hWndParent, lpDialogFunc, dwInitParam);
}

//////////////////////////////////////////////////////////////////
// Function : ExLoadDialogTemplate
// Type     : DLGTEMPLATE *
// Purpose  : 
// Args     : 
//          : LANGID lgid 
//          : HINSTANCE hInstance 
//          : LPCSTR pchTemplate 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
DLGTEMPLATE * WINAPI ExLoadDialogTemplate(LANGID	lgid,
										  HINSTANCE	hInstance,
#ifndef UNDER_CE
										  LPCSTR	pchTemplate)
#else // UNDER_CE
										  LPCTSTR	pchTemplate)
#endif // UNDER_CE
{
	HRSRC  hResDlg;
	HANDLE hDlgTmpl;
#ifndef UNDER_CE
	hResDlg = FindResourceExA( hInstance, RT_DIALOG, pchTemplate, lgid);
#else // UNDER_CE
	hResDlg = FindResourceEx(hInstance, RT_DIALOG, pchTemplate, lgid);
#endif // UNDER_CE
	if((hResDlg == NULL) && (lgid != MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL))) {
#ifndef UNDER_CE
		hResDlg = FindResourceExA(hInstance,
								  RT_DIALOG,
								  pchTemplate,
								  MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL));
#else // UNDER_CE
		hResDlg = FindResourceEx(hInstance,
								 RT_DIALOG,
								 pchTemplate,
								 MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL));
#endif // UNDER_CE
	}
	if (hResDlg == NULL) {
		return NULL; 
	}
	hDlgTmpl = LoadResource( hInstance, hResDlg );
	if(hDlgTmpl == NULL) {
		return NULL; /* failed */
	}
	return (DLGTEMPLATE *)LockResource( hDlgTmpl );
}

//////////////////////////////////////////////////////////////////
// Function : ExLoadMenuTemplate
// Type     : MENUTEMPLATE *
// Purpose  : 
// Args     : 
//          : LANGID lgid 
//          : HINSTANCE hInstance 
//          : LPCSTR pchTemplate 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static MENUTEMPLATE* ExLoadMenuTemplate(LANGID		lgid,
										 HINSTANCE	hInstance,
#ifndef UNDER_CE
										 LPCSTR	pchTemplate)
#else // UNDER_CE
										 LPCTSTR	pchTemplate)
#endif // UNDER_CE
{
	HRSRC  hResMenu;
	HANDLE hMenuTmpl;
	hResMenu = FindResourceEx( hInstance, RT_MENU, pchTemplate, lgid);
	if((hResMenu == NULL) && (lgid != MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL))) {
		hResMenu = FindResourceEx(hInstance,
								 RT_MENU,
								 pchTemplate,
								 MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL));
	}
	if (hResMenu == NULL) {
		return NULL; 
	}
	hMenuTmpl = LoadResource( hInstance, hResMenu );
	if(hMenuTmpl == NULL) {
		return NULL; /* failed */
	}
	return (MENUTEMPLATE *)LockResource( hMenuTmpl );
}

//////////////////////////////////////////////////////////////////
// Function : ExLoadMenu
// Type     : HMENU 
// Purpose  : 
// Args     : 
//			: LANGID	lgid
//          : HINSTANCE	hInstance		// handle to application instance   
//          : LPCTSTR	lpMenuName		// identifies menu template   
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HMENU WINAPI ExLoadMenu			(LANGID		lgid,
								 HINSTANCE	hInstance,		
								 LPCTSTR	lpMenuName )
{
#ifndef UNDER_CE // not support LoadMenuIndirect
	MENUTEMPLATE* pMenuTmpl;
	pMenuTmpl = ExLoadMenuTemplate(lgid, hInstance, lpMenuName);
	return LoadMenuIndirect( pMenuTmpl );
#else // UNDER_CE
	return ::LoadMenu(hInstance, lpMenuName);
#endif // UNDER_CE
}



//////////////////////////////////////////////////////////////////
// Function : SetDefaultGUIFont
// Type     : static INT
// Purpose  : Searh All children window and Call SendMessage()
//			  with WM_SETFONT.
//			  It is called recursively.
// Args     : 
//          : HWND hwndParent 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static INT SetDefaultGUIFont(HWND hwndParent)
{
	HWND hwndChild;
	if(!hwndParent) {
		return 0; 
	}
	SendMessage(hwndParent,
				WM_SETFONT,
				(WPARAM)(HFONT)GetStockObject(DEFAULT_GUI_FONT), 
				MAKELPARAM(TRUE, 0));
	for(hwndChild = GetWindow(hwndParent, GW_CHILD);
		hwndChild != NULL;
		hwndChild = GetWindow(hwndChild, GW_HWNDNEXT)) {
		SetDefaultGUIFont(hwndChild);
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : SetDefaultGUIFontEx
// Type     : static INT
// Purpose  : Searh All children window and Call SendMessage()
//			  with WM_SETFONT.
//			  It is called recursively.
// Args     : 
//          : HWND  hwndParent 
//          : HFONT hFont
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static INT SetDefaultGUIFontEx(HWND hwndParent, HFONT hFont)
{
	HWND hwndChild;
	if(!hwndParent) {
		return 0; 
	}
	SendMessage(hwndParent,
				WM_SETFONT,
				(WPARAM)hFont, 
				MAKELPARAM(TRUE, 0));
	for(hwndChild = GetWindow(hwndParent, GW_CHILD);
		hwndChild != NULL;
		hwndChild = GetWindow(hwndChild, GW_HWNDNEXT)) {
		SetDefaultGUIFontEx(hwndChild, hFont);
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : WINAPI ExSetDefaultGUIFont
// Type     : VOID
// Purpose  : Change GUI font as DEFAULT_GUI_FONT
//				In Win95, WinNT4,			DEFAULT_GUI_FONT is "lr o SVbN"
//				In Memphis, WinNT5.0		DEFAULT_GUI_FONT is "MS UI Gothic"
//				IME98's Dialog resource uses "MS UI Gothic" as their font.
//				if IME98 works in Win95 or WinNT40, This API Call SendMessage() with WM_SETFONT
//				to all children window.
//			  It should be called in WM_INITDIALOG. If you are creating new child window,
//			  You have to call it after new window was created.
// Args     : 
//          : HWND hwndDlg: Set the Dialog window handle to change font.
// Return   : none
// DATE     : 
//////////////////////////////////////////////////////////////////
VOID WINAPI ExSetDefaultGUIFont(HWND hwndDlg)
{
	//It is Valid only if platform is WinNT4.0 or Win95
	//if(ExIsWinNT5() || ExIsWin98()) {
		SetDefaultGUIFont(hwndDlg);
		UpdateWindow(hwndDlg);
	//}
	return;
}

//////////////////////////////////////////////////////////////////
// Function : WINAPI ExSetDefaultGUIFontEx
// Type     : VOID
// Purpose  : Change GUI font to given font.
//			    It should be called in WM_INITDIALOG. If you are creating new child window,
//			    you have to call it after new window was created.
//              If hFont is NULL, it will call ExSetDefaultGUIFont
// Args     : 
//          : HWND  hwndDlg: Set the Dialog window handle to change font.
//          : HFONT hFont  : Font handle which will be applied to.
// Return   : none
// DATE     : 
//////////////////////////////////////////////////////////////////
VOID WINAPI ExSetDefaultGUIFontEx(HWND hwndDlg, HFONT hFont)
{
	if(NULL == hFont){
		ExSetDefaultGUIFont(hwndDlg);
	}else{
		SetDefaultGUIFontEx(hwndDlg, hFont);
		UpdateWindow(hwndDlg);
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\common\exres.h ===
//////////////////////////////////////////////////////////////////
// File		: exres.h
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
// 
// This includes extended function for getting resource.
//
//////////////////////////////////////////////////////////////////

#ifndef __EXRES_H__
#define __EXRES_H__
#ifdef UNDER_CE // Windows CE
typedef VOID MENUTEMPLATE;
#endif // UNDER_CE

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus
//////////////////////////////////////////////////////////////////
// Function : ExLoadStringW
// Type     : INT
// Purpose  : Load Unicode string with specified Language 
//			  in any platform.
// Args     : 
//          : LANGID lgid 
//          : HINSTANCE hInst 
//          : UINT uID 
//          : LPWSTR lpBuffer 
//          : INT nBufferMax 
// Return   : 
// DATE     : 971028
//////////////////////////////////////////////////////////////////
INT WINAPI ExLoadStringW(LANGID		lgid,
						 HINSTANCE	hInst,
						 UINT		uID,
						 LPWSTR		lpBuffer,
						 INT		nBufferMax);

//////////////////////////////////////////////////////////////////
// Function : ExLoadStringW
// Type     : INT
// Purpose  : Load Ansi string with specified Language 
//			  in any platform.
// Args     : 
//          : LCID lcid 
//          : HINSTANCE hInst 
//          : UINT uID 
//          : LPSTR lpBuffer 
//          : INT nBufferMax 
// Return   : 
// DATE     : 971028
//////////////////////////////////////////////////////////////////
INT WINAPI ExLoadStringA(LANGID		lcid,
						 HINSTANCE	hInst,
						 INT		uID,
						 LPSTR		lpBuffer,
						 INT		nBufferMax);

//////////////////////////////////////////////////////////////////
// Function : ExDialogBoxParamA
// Type     : int
// Purpose  : Create modal dialog box with specified language dialalog template
// Args     :
//          : LANGID		lgid
//          : HINSTANCE		hInstance		// handle to application instance
//          : LPCTSTR		lpTemplateName	// identifies dialog box template
//          : HWND			hWndParent		// handle to owner window
//          : DLGPROC		lpDialogFunc	// pointer to dialog box procedure
//          : LPARAM		dwInitParam		// initialization value
// Return   :
// DATE     : 971028
//////////////////////////////////////////////////////////////////
int WINAPI ExDialogBoxParamA(LANGID		lgid, 
							 HINSTANCE	hInstance,
							 LPCTSTR	lpTemplateName,
							 HWND		hWndParent,
							 DLGPROC	lpDialogFunc,
							 LPARAM		dwInitParam);

//////////////////////////////////////////////////////////////////
// Function : ExDialogBoxParamW
// Type     : int
// Purpose  :
// Args     :
//          : LANGID	lgid
//          : HINSTANCE hInstance		// handle to application instance
//          : LPCWSTR	lpTemplateName	// identifies dialog box template
//          : HWND		hWndParent		// handle to owner window
//          : DLGPROC	lpDialogFunc	// pointer to dialog box procedure
//          : LPARAM	dwInitParam		// initialization value
// Return   :
// DATE     :
//////////////////////////////////////////////////////////////////
int WINAPI	ExDialogBoxParamW(LANGID	lgid,
							  HINSTANCE	hInstance,
							  LPCWSTR	lpTemplateName,
							  HWND		hWndParent,
							  DLGPROC	lpDialogFunc,
							  LPARAM	dwInitParam);

//////////////////////////////////////////////////////////////////
// Function : ExDialogBoxParamA
// Purpose  : Create modal dialog box with specified language dialalog template
// Args     :
//          : LANGID	lgid
//          : HINSTANCE hInstance		// handle to application instance
//          : LPCTSTR	lpTemplateName	// identifies dialog box template
//          : HWND		hWndParent		// handle to owner window
//          : DLGPROC	lpDialogFunc	// pointer to dialog box procedure
// Return   :
// DATE     : 971028
//////////////////////////////////////////////////////////////////
#define ExDialogBoxA(lgid, hInstance,lpTemplateName, hWndParent, lpDialogFunc) \
ExDialogBoxParamA(lgid, hInstance,lpTemplateName, hWndParent, lpDialogFunc, 0L)


//////////////////////////////////////////////////////////////////
// Function : ExCreateDialogParamA
// Type     : HWND
// Purpose  : 
// Args     : 
//			: LANGID	lgid
//          : HINSTANCE	hInstance		// handle to application instance   
//          : LPCTSTR	lpTemplateName	// identifies dialog box template   
//          : HWND		hWndParent		// handle to owner window           
//          : DLGPROC	lpDialogFunc	// pointer to dialog box procedure  
//          : LPARAM	dwInitParam		// initialization value             
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HWND WINAPI ExCreateDialogParamA(LANGID		lgid,
								 HINSTANCE	hInstance,		
								 LPCTSTR	lpTemplateName,	
								 HWND		hWndParent,			
								 DLGPROC	lpDialogFunc,	
								 LPARAM		dwInitParam);

//////////////////////////////////////////////////////////////////
// Function : ExCreateDialogParamW
// Type     : HWND
// Purpose  : 
// Args     : 
//			: LANGID	lgid
//          : HINSTANCE	hInstance		// handle to application instance   
//          : LPCWSTR	lpTemplateName	// identifies dialog box template   
//          : HWND		hWndParent		// handle to owner window           
//          : DLGPROC	lpDialogFunc	// pointer to dialog box procedure  
//          : LPARAM	dwInitParam		// initialization value             
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HWND WINAPI ExCreateDialogParamW(LANGID lgid,
								 HINSTANCE hInstance,
								 LPCWSTR lpTemplateName,
								 HWND hWndParent,
								 DLGPROC lpDialogFunc,
								 LPARAM dwInitParam);


//////////////////////////////////////////////////////////////////
// Function : ExCreateDialogA
// Type     : HWND
// Purpose  : 
// Args     : 
//			: LANGID	lgid
//          : HINSTANCE	hInstance		// handle to application instance   
//          : LPCTSTR	lpTemplateName	// identifies dialog box template   
//          : HWND		hWndParent		// handle to owner window           
//          : DLGPROC	lpDialogFunc	// pointer to dialog box procedure  
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
#define ExCreateDialogA(lgid, hInstance, lpTemplateName, hWndParent, lpDialogFunc) \
ExCreateDialogParamA(lgid, hInstance, lpTemplateName, hWndParent, lpDialogFunc, 0L)



//////////////////////////////////////////////////////////////////
// Function : ExCreateDialogW
// Type     : HWND
// Purpose  : 
// Args     : 
//			: LANGID	lgid
//          : HINSTANCE	hInstance		// handle to application instance   
//          : LPCWSTR	lpTemplateName	// identifies dialog box template   
//          : HWND		hWndParent		// handle to owner window           
//          : DLGPROC	lpDialogFunc	// pointer to dialog box procedure  
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
#define ExCreateDialogW(lgid, hInstance, lpTemplateName, hWndParent, lpDialogFunc) \
ExCreateDialogParamW(lgid, hInstance, lpTemplateName, hWndParent, lpDialogFunc, 0L)



//////////////////////////////////////////////////////////////////
// Function : ExLoadDialogTemplate
// Type     : DLGTEMPLATE *
// Purpose  : 
// Args     : 
//          : LANGID lgid 
//          : HINSTANCE hInstance 
//          : LPCSTR pchTemplate 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
DLGTEMPLATE * WINAPI ExLoadDialogTemplate(LANGID	lgid,
										  HINSTANCE	hInstance,
#ifndef UNDER_CE
										  LPCSTR	pchTemplate);
#else // UNDER_CE
										  LPCTSTR	pchTemplate);
#endif // UNDER_CE

//////////////////////////////////////////////////////////////////
// Function : ExLoadMenu
// Type     : HMENU 
// Purpose  : 
// Args     : 
//			: LANGID	lgid
//          : HINSTANCE	hInstance		// handle to application instance   
//          : LPCTSTR	lpMenuName		// identifies menu template   
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HMENU WINAPI ExLoadMenu			(LANGID		lgid,
								 HINSTANCE	hInstance,		
								 LPCTSTR	lpMenuName );

//////////////////////////////////////////////////////////////////
// Function : WINAPI ExSetDefaultGUIFontEx
// Type     : VOID
// Purpose  : Change GUI font to given font.
//			    It should be called in WM_INITDIALOG. If you are creating new child window,
//			    you have to call it after new window was created.
//              If hFont is NULL, it will call ExSetDefaultGUIFont
// Args     : 
//          : HWND  hwndDlg: Set the Dialog window handle to change font.
//          : HFONT hFont  : Font handle which will be applied to.
// Return   : none
// DATE     : 
//////////////////////////////////////////////////////////////////
VOID WINAPI ExSetDefaultGUIFontEx(HWND hwndDlg, HFONT hFont);

//////////////////////////////////////////////////////////////////
// Function : WINAPI ExSetDefaultGUIFont
// Type     : VOID
// Purpose  : Change GUI font as DEFAULT_GUI_FONT
//				In Win95, WinNT4,			DEFAULT_GUI_FONT is "lr o SVbN"
//				In Memphis, WinNT5.0		DEFAULT_GUI_FONT is "MS UI Gothic"
//				IME98's Dialog resource uses "MS UI Gothic" as it's dialog font.
//				if IME98 works in Win95 or WinNT40, This API Call SendMessage() with WM_SETFONT
//				to all children window. So, Dialog's font will be changed to "lr o SVbN"
//
//			    It should be called in WM_INITDIALOG. If you are creating new child window,
//			    you have to call it after new window was created.
// Args     : 
//          : HWND hwndDlg: Set the Dialog window handle to change font.
// Return   : none
// DATE     : 
//////////////////////////////////////////////////////////////////
VOID WINAPI ExSetDefaultGUIFont(HWND hwndDlg);



#ifdef __cplusplus
}
#endif

#endif //__EXRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\common\winapi.h ===
#ifndef _WIN_API_H_
#define _WIN_API_H_
#include <windows.h>
#include <commctrl.h>

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------
//Common
//----------------------------------------------------------------
#ifndef UNDER_CE
extern	BOOL	WINAPI	WinSetWindowTextA_CP(UINT codePage, HWND hWnd, LPCSTR  lpString);
extern	int		WINAPI	WinGetWindowTextA_CP(UINT codePage, HWND hWnd, LPSTR  lpString, int nMaxCount);
extern	int		WINAPI	WinGetWindowTextLengthA_CP(UINT codePage, HWND hWnd);
extern	BOOL	WINAPI	WinSetWindowTextW_CP(UINT codePage, HWND hWnd, LPCWSTR lpString);
extern	int		WINAPI	WinGetWindowTextW_CP(UINT codePage, HWND hWnd, LPWSTR lpString, int nMaxCount);
extern	int		WINAPI	WinGetWindowTextLengthW_CP(UINT codePage, HWND hWnd);
#endif


#if defined(UNICODE) || defined(_UNICODE) || !defined(AWBOTH)
#define WinSendMessage				SendMessage
#define WinPostMessage				PostMessage
#define WinPeekMessage				PeekMessage
#define WinDispatchMessage			DispatchMessage
#define WinTranslateMessage			TranslateMessage
#define WinSetWindowLong			SetWindowLong
#define WinGetWindowLong			GetWindowLong
#define WinCallWindowProc			CallWindowProc
#define WinDefWindowProc			DefWindowProc
#define WinIsDialogMessage			IsDialogMessage
#define WinDefWindowProc			DefWindowProc
#define WinTranslateAccelerator		TranslateAccelerator
#define WinMessageBoxA				MessageBoxA
#define WinMessageBoxW				MessageBoxW
#define WinSetWindowTextA			SetWindowTextA
#define WinSetWindowTextW			SetWindowTextW
#define WinGetWindowTextA			GetWindowTextA
#define WinGetWindowTextW			GetWindowTextW
#define WinGetWindowTextLengthA		GetWindowTextLengthA
#define WinGetWindowTextLengthW		GetWindowTextLengthW
#ifdef UNDER_CE
#define WinSetWindowTextW_CP(_cp, _h, _s)		WinSetWindowTextW((_h), (_s))
#define WinGetWindowTextW_CP(_cp, _h, _s, _n)	WinGetWindowTextW((_h), (_s), (_n))
#define WinGetWindowTextLengthW_CP(_cp, _h)		WinGetWindowTextLengthW(_h)
#endif

#ifdef _WIN64
#define WinSetUserData(_h, _l)		SetWindowLongPtr(_h, GWLP_USERDATA, (LONG_PTR)_l)
#define WinGetUserData(_h)			GetWindowLongPtr(_h, GWLP_USERDATA)
#define WinSetUserDlgData(_h, _ud)	SetWindowLongPtr(_h, DWLP_USER, (LONG_PTR)_ud)
#define WinGetUserDlgData(_h)		GetWindowLongPtr(_h, DWLP_USER)
#define WinSetMsgResult(_h, _ud)	SetWindowLongPtr(_h, DWLP_MSGRESULT, (LONG_PTR)_ud)
#define WinGetMsgResult(_h)			GetWindowLongPtr(_h, DWLP_MSGRESULT)
#define WinSetWndProc(_h, _proc)	(WNDPROC)SetWindowLongPtr(_h, GWLP_WNDPROC, (WNDPROC)_proc)
#define WinGetWndProc(_h)			(WNDPROC)GetWindowLongPtr(_h, GWLP_WNDPROC)
#define WinGetInstanceHandle(_h)	(HINSTANCE)GetWindowLongPtr(_h, GWLP_HINSTANCE)
#else //!_WIN64
#define WinSetUserData(_h, _l)		SetWindowLong(_h, GWL_USERDATA, (LONG)_l)
#define WinGetUserData(_h)			GetWindowLong(_h, GWL_USERDATA)
#define WinSetUserDlgData(_h, _ud)	SetWindowLong(_h, DWL_USER, (LONG)_ud)
#define WinGetUserDlgData(_h)		GetWindowLong(_h, DWL_USER)
#define WinSetMsgResult(_h, _ud)	SetWindowLong(_h, DWL_MSGRESULT, (LONG)_ud)
#define WinGetMsgResult(_h)			GetWindowLong(_h, DWL_MSGRESULT)
#define WinSetWndProc(_h, _proc)	SetWindowLong(_h, GWL_WNDPROC, (LONG)_proc)
#define WinGetWndProc(_h)			GetWindowLong(_h, GWL_WNDPROC)
#define WinGetInstanceHandle(_h)	(HINSTANCE)GetWindowLong(_h, GWL_HINSTANCE)

#define WinSetUserPtr(_h, _lp)		WinSetUserData(_h, _lp)
#define WinGetUserPtr(_h)			WinGetUserData(_h)

#define WinSetStyle(_h, _s)			(DWORD)SetWindowLong(_h, GWL_STYLE, _s)
#define WinGetStyle(_h)				(DWORD)GetWindowLong(_h, GWL_STYLE)
#define WinSetExStyle(_h, _s)		(DWORD)SetWindowLong(_h, GWL_EXSTYLE, (LONG)_s)
#define WinGetExStyle(_h)			(DWORD)GetWindowLong(_h, GWL_EXSTYLE)


#endif

#else  //if defined(UNICODE) || defined(_UNICODE) || !defined(AWBOTH)---

extern	LRESULT	WINAPI	WinSendMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
extern	BOOL	WINAPI	WinPostMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
extern	BOOL	WINAPI	WinPeekMessage(LPMSG lpMsg,
									   HWND hWnd,
									   UINT wMsgFilterMin,
									   UINT wMsgFilterMax,
									   UINT wRemoveMsg);
#define WinTranslateMessage	TranslateMessage
extern	LRESULT	WINAPI	WinDispatchMessage(CONST MSG *lpMsg);
extern	LONG	WINAPI	WinSetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong);
extern	LONG	WINAPI	WinGetWindowLong(HWND hWnd, int nIndex);
extern	LRESULT	WINAPI	WinCallWindowProc(WNDPROC lpPrevWndFunc,
										  HWND hWnd,
										  UINT Msg,
										  WPARAM wParam,
										  LPARAM lParam);
extern	LRESULT	WINAPI	WinDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
extern	BOOL	WINAPI	WinIsDialogMessage(HWND hDlg, LPMSG lpMsg);
extern	int		WINAPI	WinTranslateAccelerator(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
extern	int		WINAPI	WinMessageBoxA(HWND hWnd, LPCSTR  lpText, LPCSTR  lpCaption, UINT uType);
extern	int		WINAPI	WinMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);

#define WinSetWindowTextA(_h, _lp)		WinSetWindowTextA_CP(CP_ACP, _h, _lp)
#define WinGetWindowTextA(_h, _lp, _c)	WinGetWindowTextA_CP(CP_ACP, _h, _lp, _c)
#define WinSetWindowTextW(_h, _lp)		WinSetWindowTextW_CP(CP_ACP, _h, _lp)
#define WinGetWindowTextW(_h, _lp, _c)	WinGetWindowTextW_CP(CP_ACP, _h, _lp, _c)

#ifdef _WIN64
extern  LONG_PTR    WINAPI  WinSetUserData(HWND hwnd, LONG_PTR lUserData);
extern  LONG_PTR    WINAPI  WinGetUserData(HWND hwnd);
extern  LONG_PTR    WINAPI  WinSetUserDlgData(HWND hwnd, LONG_PTR lUserData);
extern  LONG_PTR    WINAPI  WinGetUserDlgData(HWND hwnd);
extern  LONG_PTR    WINAPI  WinSetMsgResult(HWND hwnd, LONG_PTR lUserData);
extern  LONG_PTR    WINAPI  WinGetMsgResult(HWND hwnd);
#else
extern  LONG    WINAPI  WinSetUserData(HWND hwnd, LONG lUserData);
extern  LONG    WINAPI  WinGetUserData(HWND hwnd);
extern  LONG    WINAPI  WinSetUserDlgData(HWND hwnd, LONG lUserData);
extern  LONG    WINAPI  WinGetUserDlgData(HWND hwnd);
extern  LONG    WINAPI  WinSetMsgResult(HWND hwnd, LONG lUserData);
extern  LONG    WINAPI  WinGetMsgResult(HWND hwnd);
#endif

extern  LPVOID  WINAPI  WinSetUserPtr(HWND hwnd, LPVOID lpVoid);
extern  LPVOID  WINAPI  WinGetUserPtr(HWND hwnd);
extern  WNDPROC WINAPI  WinSetWndProc(HWND hwnd, WNDPROC lpfnWndProc);
extern  WNDPROC WINAPI  WinGetWndProc(HWND hwnd);
extern  DWORD   WINAPI  WinSetStyle(HWND hwnd, DWORD dwStyle);
extern  DWORD   WINAPI  WinGetStyle(HWND hwnd);
extern  DWORD   WINAPI  WinSetExStyle(HWND hwnd, DWORD dwStyle);
extern  DWORD   WINAPI  WinGetExStyle(HWND hwnd);
extern  HINSTANCE   WINAPI WinGetInstanceHandle(HWND hwnd);
#endif //End of --if defined(UNICODE) || defined(_UNICODE) || !defined(AWBOTH)---


//----------------------------------------------------------------
// ComboBox common api
//----------------------------------------------------------------
#ifndef UNDER_CE
INT CB_AddStringA		(HWND hwndCtl, LPCSTR  lpsz);
INT CB_FindStringA		(HWND hwndCtl, INT indexStart, LPCSTR  lpszFind);
INT CB_InsertStringA	(HWND hwndCtl, INT index, LPCSTR  lpsz);
INT CB_GetLBTextLenA	(HWND hwndCtl, INT index);
INT CB_GetLBTextA		(HWND hwndCtl, INT index, LPSTR  lpszBuffer);
INT CB_FindStringExactA	(HWND hwndCtl, INT indexStart, LPCSTR  lpszFind);
INT CB_SelectStringA	(HWND hwndCtl, INT indexStart, LPCSTR  lpszSelect);
#endif
INT CB_AddStringW		(HWND hwndCtl, LPCWSTR lpsz);
INT CB_InsertStringW	(HWND hwndCtl, INT index, LPCWSTR lpsz);
INT CB_GetLBTextLenW	(HWND hwndCtl, INT index);
INT CB_GetLBTextW		(HWND hwndCtl, INT index, LPWSTR lpszBuffer);
INT CB_FindStringW		(HWND hwndCtl, INT indexStart, LPCWSTR lpszFind);
INT CB_FindStringExactW	(HWND hwndCtl, INT indexStart, LPCWSTR lpszFind);
INT CB_SelectStringW	(HWND hwndCtl, INT indexStart, LPCWSTR lpszSelect);

//----------------------------------------------------------------
// ComboBox macro
//----------------------------------------------------------------
#define WinComboBox_Enable(hwndCtl, fEnable)        EnableWindow((hwndCtl), (fEnable))
#define WinComboBox_GetText(hwndCtl, lpch, cchMax)  GetWindowText((hwndCtl), (lpch), (cchMax))
#define WinComboBox_GetTextA(hwndCtl, lpch, cchMax) WinGetWindowTextA((hwndCtl), (lpch), (cchMax))
#define WinComboBox_GetTextW(hwndCtl, lpch, cchMax) WinGetWindowTextW((hwndCtl), (lpch), (cchMax))
#define WinComboBox_GetTextLength(hwndCtl)          GetWindowTextLength(hwndCtl)
#define WinComboBox_GetTextLengthA(hwndCtl)         WinGetWindowTextLengthA(hwndCtl)
#define WinComboBox_GetTextLengthW(hwndCtl)         WinGetWindowTextLengthW(hwndCtl)
#define WinComboBox_SetText(hwndCtl, lpsz)          SetWindowText((hwndCtl), (lpsz))
#define WinComboBox_SetTextA(hwndCtl, lpsz)         WinSetWindowTextA((hwndCtl), (lpsz))
#define WinComboBox_SetTextW(hwndCtl, lpsz)         WinSetWindowTextW((hwndCtl), (lpsz))
#define WinComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)WinSendMessage((hwndCtl), \
																			   CB_LIMITTEXT, \
																			   (WPARAM)(int)(cchLimit), \
																			   0L))
#define WinComboBox_GetEditSel(hwndCtl)            ((DWORD)WinSendMessage((hwndCtl), \
																		  CB_GETEDITSEL, \
																		  0L, 0L))
#define WinComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)WinSendMessage((hwndCtl), \
																					  CB_SETEDITSEL, \
																					  0L, \
																					  MAKELPARAM((ichStart), \
																								 (ichEnd))))
#define WinComboBox_GetCount(hwndCtl)              ((int)(DWORD)WinSendMessage((hwndCtl), \
																			   CB_GETCOUNT, \
																			   0L, 0L))
#define WinComboBox_ResetContent(hwndCtl)          ((int)(DWORD)WinSendMessage((hwndCtl), \
																			   CB_RESETCONTENT, \
																			   0L, 0L))
#define WinComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)WinSendMessage((hwndCtl), \
																			   CB_ADDSTRING, \
																			   0L, \
																			   (LPARAM)(LPCTSTR)(lpsz)))
#define WinComboBox_AddStringA(hwndCtl, lpsz)       CB_AddStringA((hwndCtl), lpsz)
#define WinComboBox_AddStringW(hwndCtl, lpsz)       CB_AddStringW((hwndCtl), lpsz)
#define WinComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)WinSendMessage((hwndCtl), \
																				   CB_INSERTSTRING, \
																				   (WPARAM)(int)(index), \
																				   (LPARAM)(LPCTSTR)(lpsz)))
#define WinComboBox_InsertStringA(hwndCtl, index, lpsz) CB_InsertStringA((hwndCtl), index, lpsz)
#define WinComboBox_InsertStringW(hwndCtl, index, lpsz) CB_InsertStringW((hwndCtl), index, lpsz)
#define WinComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)WinSendMessage((hwndCtl), \
																			   CB_ADDSTRING, \
																			   0L, \
																			   (LPARAM)(data)))
#define WinComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)WinSendMessage((hwndCtl), \
																					 CB_INSERTSTRING, \
																					 (WPARAM)(int)(index), \
																					 (LPARAM)(data)))
#define WinComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)WinSendMessage((hwndCtl), \
																			   CB_DELETESTRING, \
																			   (WPARAM)(int)(index), \
																			   0L))
#define WinComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)WinSendMessage((hwndCtl), \
																					   CB_GETLBTEXTLEN, \
																					   (WPARAM)(int)(index), \
																					   0L))
//#define WinComboBox_GetLBTextLenA(hwndCtl, index)          CB_GetLBTextLenA((hwndCtl), (index))
//#define WinComboBox_GetLBTextLenW(hwndCtl, index)          CB_GetLBTextLenW((hwndCtl), (index))
#define WinComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)WinSendMessage((hwndCtl), \
																					   CB_GETLBTEXT, \
																					   (WPARAM)(int)(index), \
																					   (LPARAM)(LPCTSTR)(lpszBuffer)))
#define WinComboBox_GetLBTextA(hwndCtl, index, lpszBuffer)  CB_GetLBTextA((hwndCtl), (index), lpszBuffer)
#define WinComboBox_GetLBTextW(hwndCtl, index, lpszBuffer)  CB_GetLBTextW((hwndCtl), (index), lpszBuffer)
#define WinComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(DWORD)WinSendMessage((hwndCtl), \
																					   CB_GETITEMDATA, \
																					   (WPARAM)(int)(index), \
																					   0L))
#define WinComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)WinSendMessage((hwndCtl), \
																				   CB_SETITEMDATA, \
																				   (WPARAM)(int)(index), \
																				   (LPARAM)(data)))
#define WinComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)WinSendMessage((hwndCtl), \
																						   CB_FINDSTRING, \
																						   (WPARAM)(int)(indexStart), \
																						   (LPARAM)(LPCTSTR)(lpszFind)))
#define WinComboBox_FindStringA(hwndCtl,indexStart,lpszFind)  CB_FindStringA((hwndCtl), indexStart,lpszFind)
#define WinComboBox_FindStringW(hwndCtl,indexStart,lpszFind)  CB_FindStringW((hwndCtl), indexStart,lpszFind)
#define WinComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)WinSendMessage((hwndCtl), \
																						   CB_FINDSTRING, \
																						   (WPARAM)(int)(indexStart), \
																						   (LPARAM)(data)))
#define WinComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)WinSendMessage((hwndCtl), \
																				   CB_GETCURSEL, \
																				   0L, 0L))
#define WinComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)WinSendMessage((hwndCtl), \
																				   CB_SETCURSEL, \
																				   (WPARAM)(int)(index), \
																				   0L))
#define WinComboBox_SelectString(hwndCtl, indexStart, lpszSelect) ((int)WinSendMessage((hwndCtl), \
																					   CB_SELECTSTRING, \
																					   (WPARAM)(indexStart), \
																					   (LPARAM)(lpszSelect)))
#define WinComboBox_SelectStringA(hwndCtl, indexStart, lpszSelect) CB_SelectStringA((hwndCtl), \
																					(indexStart), \
																					(lpszSelect))
#define WinComboBox_SelectStringW(hwndCtl, indexStart, lpszSelect) CB_SelectStringW((hwndCtl), \
																					(indexStart), \
																					(lpszSelect))
#define WinComboBox_SelectItemData(hwndCtl, indexStart, data) ((int)WinSendMessage((hwndCtl), \
																				   CB_SELECTSTRING, \
																				   (WPARAM)(indexStart), \
																				   (LPARAM)(data)))
#define WinComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)WinSendMessage((hwndCtl), \
																				   CB_DIR, \
																				   (WPARAM)(UINT)(attrs), \
																				   (LPARAM)(LPCTSTR)(lpszFileSpec)))
#define WinComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)WinSendMessage((hwndCtl), \
																					CB_SHOWDROPDOWN, \
																					(WPARAM)(BOOL)(fShow), \
																					0L))
#define WinComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)WinSendMessage((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCTSTR)(lpszFind)))
#define WinComboBox_FindStringExactA(hwndCtl,indexStart,lpszFind)  CB_FindStringExactA((hwndCtl), indexStart,lpszFind)
#define WinComboBox_FindStringExactW(hwndCtl,indexStart,lpszFind)  CB_FindStringExactW((hwndCtl), indexStart,lpszFind)

#define WinComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)WinSendMessage((hwndCtl), \
																					CB_GETDROPPEDSTATE, \
																					0L, 0L))
#define WinComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)WinSendMessage((hwndCtl), \
																			   CB_GETDROPPEDCONTROLRECT, \
																			   0L, (LPARAM)(RECT *)(lprc)))
#define WinComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)WinSendMessage((hwndCtl), \
																				   CB_GETITEMHEIGHT, \
																				   0L, 0L))
#define WinComboBox_SetItemHeight(hwndCtl, index, cyItem) ((int)(DWORD)WinSendMessage((hwndCtl), \
																					  CB_SETITEMHEIGHT, \
																					  (WPARAM)(int)(index), \
																					  (LPARAM)(int)cyItem))
#define WinComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)WinSendMessage((hwndCtl), \
																					CB_GETEXTENDEDUI, \
																					0L, 0L))
#define WinComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)WinSendMessage((hwndCtl), \
																				   CB_SETEXTENDEDUI, \
																				   (WPARAM)(UINT)(flags), \
																				   0L))

#ifdef __cplusplus
};
#endif
#endif  //_WIN_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\ccom.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "ccom.h"
#include "memmgr.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

#ifdef _DEBUG
static INT allocCount;
static INT allocSize;
static INT freeCount;
static INT freeSize;
#endif

void *CCom::operator new(size_t size)
{
    BYTE *p = (BYTE *)MemAlloc(size);
    if(p) {
        ::ZeroMemory(p, size);
    }
#ifdef _DEBUG
    allocCount++;
    allocSize += (INT)::GlobalSize(GlobalHandle(p));
#endif
    return (void *)p;
}
void  CCom::operator delete(void *p)
{
#ifdef _DEBUG
    allocCount++;
    allocSize += (INT)::GlobalSize(GlobalHandle(p));
#endif
    if(p) {
        MemFree(p);
    }
}

#ifdef _DEBUG
VOID PrintMemory(LPSTR lpstrMsg)
{
    static CHAR szBuf[512];
    //LPSTR lpstr = (lpstrMsg == NULL) ? "none" : lpstrMsg;
    wsprintf(szBuf, "%s:Alloc %d size %d Free %d size %d\n",
             lpstrMsg,
             allocCount, allocSize, freeCount, freeSize);
    OutputDebugString(szBuf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\ccom.h ===
#ifndef _C_COM_H_
#define _C_COM_H_
class CCom
{
public:	
	void	*operator	new(size_t size);
	void	operator	delete(void *pv);
};
#ifdef _DEBUG
extern VOID PrintMemory(LPSTR lpstr);
#endif
#endif //_C_COM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\ce_cutil.cpp ===
// For Windows CE build
#include <windows.h>
#include <windowsx.h>
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#include "../common/cutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\ce_cfont.cpp ===
// For Windows CE build
#include "../common/cfont.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\ce_exgdiw.cpp ===
// For Windows CE build
#include <windows.h>
#include <windowsx.h>
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#include "../common/exgdiw.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\cexres.h ===
//////////////////////////////////////////////////////////////////
// File     : CEXRES.H
// Purpose  : Resource processing class
// 
// 
// Date     : Fri Jul 31 17:21:25 1998
// Author   : ToshiaK
//
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_EXTENDED_RESOURCE_H__
#define __C_EXTENDED_RESOURCE_H__
#ifdef UNDER_CE // Windows CE macro
#undef DialogBoxParamA
#undef DialogBoxParamW
#undef CreateDialogParamA
#undef CreateDialogParamW
typedef VOID MENUTEMPLATE;
#endif // UNDER_CE
class CExres
{
public:
	static INT LoadStringW(LANGID		lgid,
						   HINSTANCE	hInst,
						   UINT		uID,
						   LPWSTR		lpBuffer,
						   INT			nBufferMax);
	static INT LoadStringA(INT			codePage,
						   LANGID		lcid,
						   HINSTANCE	hInst,
						   INT			uID,
						   LPSTR		lpBuffer,
						   INT			nBufferMax);
	static int DialogBoxParamA(LANGID		lgid, 
							   HINSTANCE	hInstance,
							   LPCTSTR		lpTemplateName,
							   HWND		hWndParent,
							   DLGPROC		lpDialogFunc,
							   LPARAM		dwInitParam);
	static int DialogBoxParamW(LANGID		lgid,
							   HINSTANCE	hInstance,
							   LPCWSTR		lpTemplateName,
							   HWND		hWndParent,
							   DLGPROC		lpDialogFunc,
							   LPARAM		dwInitParam);
	static HWND CreateDialogParamA(LANGID		lgid,
								   HINSTANCE	hInstance,		
								   LPCTSTR		lpTemplateName,	
								   HWND		hWndParent,			
								   DLGPROC		lpDialogFunc,	
								   LPARAM		dwInitParam);
	static HWND CreateDialogParamW(LANGID		lgid,
								   HINSTANCE	hInstance,
								   LPCWSTR		lpTemplateName,
								   HWND		hWndParent,
								   DLGPROC		lpDialogFunc,
								   LPARAM		dwInitParam);
	static DLGTEMPLATE * LoadDialogTemplateA(LANGID	lgid,
											 HINSTANCE	hInstance,
											 LPCSTR	pchTemplate);
#ifdef UNDER_CE // Windows CE always UNICODE
	static DLGTEMPLATE * LoadDialogTemplate(LANGID	lgid,
											HINSTANCE	hInstance,
											LPCTSTR	pchTemplate);
#endif // UNDER_CE
	static MENUTEMPLATE* LoadMenuTemplateA(LANGID		lgid,
										   HINSTANCE	hInstance,
										   LPCSTR		pchTemplate);
	static HMENU LoadMenuA(LANGID		lgid,
						   HINSTANCE	hInstance,		
						   LPCTSTR		lpMenuName );
#ifdef UNDER_CE // Windows CE always UNICODE
	static HMENU LoadMenu(LANGID	lgid,
						  HINSTANCE	hInstance,
						  LPCTSTR	lpMenuName);
#endif // UNDER_CE
	static VOID SetDefaultGUIFont(HWND hwndDlg);
private:
	static INT SetDefaultGUIFontRecursive(HWND hwndParent);
};
#endif //__C_EXTENDED_RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\cfactory.h ===
#ifndef __C_FACTORY_H__
#define __C_FACTORY_H__
#include <objbase.h>
#include "ccom.h"

typedef struct tagFACTARRAY {
	const CLSID   *lpClsId;
#ifndef UNDER_CE
	LPSTR   lpstrRegistryName;
	LPSTR	lpstrProgID;
	LPSTR	lpstrVerIndProfID;
#else // UNDER_CE
	LPTSTR	lpstrRegistryName;
	LPTSTR	lpstrProgID;
	LPTSTR	lpstrVerIndProfID;
#endif // UNDER_CE
}FACTARRAY, *LPFACTARRAY;

class CFactory : public IClassFactory, CCom
{
public:
	//---- Inherit IUnknown ----
	HRESULT __stdcall QueryInterface(REFIID refIID, void** ppv);
	ULONG	__stdcall AddRef();
	ULONG	__stdcall Release();

	//---- Inherit IClassFactory ----
	STDMETHOD(CreateInstance)(THIS_ 
							  LPUNKNOWN pUnknownOuter,
							  REFIID refIID,
							  LPVOID *ppv) ;
	STDMETHOD(LockServer)(THIS_
						  BOOL bLock) ; 

	//----------------------------------------------------------------
	CFactory(VOID);		// Cponstructor
	~CFactory();		// Destructor

	static HRESULT GetClassObject(const CLSID& clsid,
	                              const IID& iid, 
	                              void** ppv) ;
	static BOOL IsLocked() {  			// Function to determine if component can be unloaded	
		return (m_cServerLocks > 0);
	}
	static HRESULT CanUnloadNow		(VOID);		// Functions to [un]register all components
	static HRESULT RegisterServer	(VOID);
	static HRESULT UnregisterServer	(VOID);
public:
	static LONG		m_cServerLocks;		// Count of locks		(static value)
	static LONG		m_cComponents;		// Count of componets	(static value)
	static HMODULE	m_hModule;			// Module handle		(static value)
	static FACTARRAY	m_fData;
	LONG m_cRef;						// Reference Count
} ;

#endif //__C_FACTORY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\cexres.cpp ===
//////////////////////////////////////////////////////////////////
//    File    : cexres.cpp
//    Owner    : ToshiaK
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include "cexres.h"
#ifdef UNDER_CE // Windows CE Stub for unsupported APIs
#include "stub_ce.h"
#endif // UNDER_CE

//----------------------------------------------------------------
// Internal memory Allocate Free function.
//----------------------------------------------------------------
inline LPVOID ExMemAlloc(INT size)
{
    return (LPVOID)GlobalAllocPtr(GHND, (size));
}

inline BOOL ExMemFree(LPVOID lp)
{
#ifndef UNDER_CE
    return GlobalFreePtr((lp));
#else // UNDER_CE
    return (BOOL)GlobalFreePtr((lp));
#endif // UNDER_CE
}

//----------------------------------------------------------------
// Function for Getting OS version 
//----------------------------------------------------------------
inline static POSVERSIONINFO ExGetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

inline static BOOL ExIsWin95(VOID) 
{ 
    BOOL fBool;
    fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
            (ExGetOSVersion()->dwMajorVersion >= 4) &&
            (ExGetOSVersion()->dwMinorVersion < 10);

    return fBool;
}

inline static BOOL ExIsWin98(VOID)
{
    BOOL fBool;
    fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
            (ExGetOSVersion()->dwMajorVersion >= 4) &&
            (ExGetOSVersion()->dwMinorVersion  >= 10);
    return fBool;
}


inline static BOOL ExIsWinNT4(VOID)
{
    BOOL fBool;
    fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (ExGetOSVersion()->dwMajorVersion >= 4); 
    return fBool;
}

inline static BOOL ExIsWinNT5(VOID)
{
    BOOL fBool;
    fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (ExGetOSVersion()->dwMajorVersion >= 5);
    return fBool;
}

inline static BOOL ExIsWinNT(VOID)
{
    return (ExIsWinNT4() || ExIsWinNT5());
}

inline INT Min(INT a, INT b)
{
    return (a) < (b) ? (a) : (b);
}
//----------------------------------------------------------------
// Resource API open to public
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function : LoadStringW
// Type     : INT
// Purpose  : Wrapper of LoadStrinW() API.
//              Load Unicode string with specified Language 
//              in any platform.
// Args     : 
//          : LANGID    lgid 
//          : HINSTANCE hInst 
//          : UINT        uID 
//          : LPWSTR    lpBuffer 
//          : INT        nBufferMax 
// Return   : 
// DATE     : 971028
//////////////////////////////////////////////////////////////////
INT CExres::LoadStringW(LANGID lgid, HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, INT nBufferMax)
{
    if(!hInst) {
        return 0;
    }
    if(!lpBuffer) {
        return 0;
    }

    INT len = 0;
    UINT block, num;
    block = (uID >>4)+1;
    num   = uID & 0xf;
    HRSRC hres;
    hres = ::FindResourceEx(hInst,
                            RT_STRING,
                            MAKEINTRESOURCE(block),
                            (WORD)lgid);
    if(!hres) {
        goto Error;
    }
    HGLOBAL hgbl;
    hgbl = ::LoadResource(hInst, hres);
    if(!hres) {
        goto Error;
    }
    LPWSTR lpwstr;
    lpwstr = (LPWSTR)::LockResource(hgbl);
    if(!lpwstr) {
        goto Error;
    }
    UINT i;
    for(i = 0; i < num; i++) {
        lpwstr += *lpwstr + 1;
    }
    len = *lpwstr;
    ::CopyMemory(lpBuffer, lpwstr+1, Min(len, nBufferMax-1) * sizeof(WCHAR));
    lpBuffer[Min(len, nBufferMax-1)]= (WCHAR)0x0000;
 Error:
    return len;
}

#ifndef UNDER_CE // Windows CE always UNICODE
//////////////////////////////////////////////////////////////////
// Function : LoadStringA
// Type     : INT
// Purpose  : Wrapper of LoadStringA().
// Args     : 
//          : LANGID    lgid
//          : HINSTANCE hInst 
//          : INT        uID 
//          : LPSTR        lpBuffer 
//          : INT        nBufferMax 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CExres::LoadStringA(INT codePage, LANGID lgid, HINSTANCE hInst, INT uID, LPSTR lpBuffer, INT nBufferMax)
{
    if (!hInst) {
        return 0;
    }

    if (!lpBuffer || nBufferMax == 0) {
        return 0;
    }

    LPWSTR lpwstr = (LPWSTR)ExMemAlloc(nBufferMax*sizeof(WCHAR));
    if (!lpwstr) {
        return 0;
    }
    INT len = CExres::LoadStringW(lgid, hInst, uID, lpwstr, nBufferMax);
    len = ::WideCharToMultiByte(codePage,
                                0, /*WC_COMPOSITECHECK, */
                                lpwstr, -1,
                                lpBuffer, nBufferMax, 
                                NULL, NULL); 

    if( len ) {
        len --;    // remove NULL char
    }
    ExMemFree(lpwstr);
    return len;
}
#endif // UNDER_CE

#ifndef UNDER_CE // Windows CE always UNICODE
//////////////////////////////////////////////////////////////////
// Function : DialogBoxParamA
// Type     : int
// Purpose  :
// Args     :
//          : LANGID    lgid
//          : HINSTANCE hInstance        // handle to application instance
//          : LPCTSTR    lpTemplateName    // identifies dialog box template
//          : HWND        hWndParent        // handle to owner window
//          : DLGPROC    lpDialogFunc    // pointer to dialog box procedure
//          : LPARAM    dwInitParam        // initialization value
// Return   :
// DATE     :
//////////////////////////////////////////////////////////////////
int CExres::DialogBoxParamA(LANGID        lgid,
                            HINSTANCE    hInstance,
                            LPCTSTR        lpTemplateName,
                            HWND        hWndParent,
                            DLGPROC        lpDialogFunc,
                            LPARAM        dwInitParam)
{
    DLGTEMPLATE*pDlgTmpl;
    pDlgTmpl = CExres::LoadDialogTemplateA(lgid, hInstance, lpTemplateName);
    if (pDlgTmpl != NULL)
        return (INT)::DialogBoxIndirectParamA(hInstance,
                                         pDlgTmpl,
                                         hWndParent,
                                         lpDialogFunc,
                                         dwInitParam);
    else
        return 0;
}
#endif // UNDER_CE

//////////////////////////////////////////////////////////////////
// Function : DialogBoxParamW
// Type     : int
// Purpose  :
// Args     :
//          : LANGID    lgid
//          : HINSTANCE hInstance        // handle to application instance
//          : LPCWSTR    lpTemplateName    // identifies dialog box template
//          : HWND        hWndParent        // handle to owner window
//          : DLGPROC    lpDialogFunc    // pointer to dialog box procedure
//          : LPARAM    dwInitParam        // initialization value
// Return   :
// DATE     :
//////////////////////////////////////////////////////////////////
int CExres::DialogBoxParamW(LANGID        lgid,
                            HINSTANCE    hInstance,
                            LPCWSTR        lpTemplateName,
                            HWND        hWndParent,
                            DLGPROC        lpDialogFunc,
                            LPARAM        dwInitParam)
{
    DLGTEMPLATE*pDlgTmpl;
#ifndef UNDER_CE // Windows CE always UNICODE
    pDlgTmpl = CExres::LoadDialogTemplateA(lgid, hInstance, MAKEINTRESOURCEA(lpTemplateName));
#else // UNDER_CE
    pDlgTmpl = CExres::LoadDialogTemplate(lgid, hInstance, MAKEINTRESOURCE(lpTemplateName));
#endif // UNDER_CE
    if (pDlgTmpl != NULL)
        return (INT)::DialogBoxIndirectParamW(hInstance,
                                         pDlgTmpl,
                                         hWndParent,
                                         lpDialogFunc,
                                         dwInitParam);
    else
        return 0;
}

#ifndef UNDER_CE // Windows CE always UNICODE
//////////////////////////////////////////////////////////////////
// Function : CreateDialogParamA
// Type     : HWND 
// Purpose  : 
// Args     : 
//            : LANGID    lgid
//          : HINSTANCE    hInstance        // handle to application instance   
//          : LPCTSTR    lpTemplateName    // identifies dialog box template   
//          : HWND        hWndParent        // handle to owner window           
//          : DLGPROC    lpDialogFunc    // pointer to dialog box procedure  
//          : LPARAM    dwInitParam        // initialization value             
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HWND CExres::CreateDialogParamA(LANGID        lgid,
                                HINSTANCE    hInstance,        
                                LPCTSTR        lpTemplateName,    
                                HWND        hWndParent,            
                                DLGPROC        lpDialogFunc,    
                                LPARAM        dwInitParam)        
{
    DLGTEMPLATE*pDlgTmpl;
    pDlgTmpl = CExres::LoadDialogTemplateA(lgid, hInstance, lpTemplateName);
    if (pDlgTmpl != NULL)
        return ::CreateDialogIndirectParamA( hInstance, pDlgTmpl, hWndParent, lpDialogFunc, dwInitParam);
    else
        return HWND(0);
}
#endif // UNDER_CE

//////////////////////////////////////////////////////////////////
// Function : CreateDialogParamW
// Type     : HWND 
// Purpose  : 
// Args     : 
//            : LANGID    lgid
//          : HINSTANCE    hInstance        // handle to application instance   
//          : LPCTSTR    lpTemplateName    // identifies dialog box template   
//          : HWND        hWndParent        // handle to owner window           
//          : DLGPROC    lpDialogFunc    // pointer to dialog box procedure  
//          : LPARAM    dwInitParam        // initialization value             
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HWND CExres::CreateDialogParamW(LANGID        lgid,
                                HINSTANCE    hInstance,        
                                LPCWSTR        lpTemplateName,    
                                HWND        hWndParent,            
                                DLGPROC        lpDialogFunc,    
                                LPARAM        dwInitParam)        
{
    DLGTEMPLATE*pDlgTmpl;
#ifndef UNDER_CE // Windows CE always UNICODE
    pDlgTmpl = CExres::LoadDialogTemplateA(lgid, hInstance, MAKEINTRESOURCEA(lpTemplateName));
#else // UNDER_CE
    pDlgTmpl = CExres::LoadDialogTemplate(lgid, hInstance, MAKEINTRESOURCE(lpTemplateName));
#endif // UNDER_CE
    if (pDlgTmpl != NULL)
        return ::CreateDialogIndirectParamW( hInstance, pDlgTmpl, hWndParent, lpDialogFunc, dwInitParam);
    else
        return HWND(0);
}

//////////////////////////////////////////////////////////////////
// Function : LoadDialogTemplate
// Type     : DLGTEMPLATE *
// Purpose  : 
// Args     : 
//          : LANGID lgid 
//          : HINSTANCE hInstance 
//          : LPCSTR pchTemplate 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
#ifndef UNDER_CE // Windows CE always UNICODE
DLGTEMPLATE * CExres::LoadDialogTemplateA(LANGID    lgid,
                                          HINSTANCE    hInstance,
                                          LPCSTR    pchTemplate)
{
    HRSRC  hResDlg;
    HANDLE hDlgTmpl;
    hResDlg = ::FindResourceExA( hInstance, RT_DIALOG, pchTemplate, lgid);
    if((hResDlg == NULL) && (lgid != MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL))) {
        hResDlg = ::FindResourceExA(hInstance,
                                    RT_DIALOG,
                                    pchTemplate,
                                    MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL));
    }
    if (hResDlg == NULL) {
        return NULL; 
    }
    hDlgTmpl = ::LoadResource(hInstance, hResDlg);
    if(hDlgTmpl == NULL) {
        return NULL; /* failed */
    }
    return (DLGTEMPLATE *)::LockResource(hDlgTmpl);
}
#else // UNDER_CE
DLGTEMPLATE * CExres::LoadDialogTemplate(LANGID    lgid,
                                         HINSTANCE    hInstance,
                                         LPCTSTR    pchTemplate)
{
    HRSRC  hResDlg;
    HANDLE hDlgTmpl;
    hResDlg = ::FindResourceEx(hInstance, RT_DIALOG, pchTemplate, lgid);
    if((hResDlg == NULL) && (lgid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))){
        hResDlg = ::FindResourceEx(hInstance,
                                    RT_DIALOG,
                                    pchTemplate,
                                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
    }
    if (hResDlg == NULL) {
        return NULL; 
    }
    hDlgTmpl = ::LoadResource(hInstance, hResDlg);
    if(hDlgTmpl == NULL) {
        return NULL; /* failed */
    }
    return (DLGTEMPLATE *)::LockResource(hDlgTmpl);
}
#endif // UNDER_CE

#ifndef UNDER_CE // Windows CE always UNICODE
//////////////////////////////////////////////////////////////////
// Function : LoadMenuTemplate
// Type     : MENUTEMPLATE *
// Purpose  : 
// Args     : 
//          : LANGID lgid 
//          : HINSTANCE hInstance 
//          : LPCSTR pchTemplate 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
MENUTEMPLATE* CExres::LoadMenuTemplateA(LANGID        lgid,
                                        HINSTANCE    hInstance,
                                        LPCSTR        pchTemplate)
{
    HRSRC  hResMenu;
    HANDLE hMenuTmpl;
    hResMenu = ::FindResourceEx( hInstance, RT_MENU, pchTemplate, lgid);
    if((hResMenu == NULL) && (lgid != MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL))) {
        hResMenu = ::FindResourceEx(hInstance,
                                    RT_MENU,
                                    pchTemplate,
                                    MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL));
    }
    if (hResMenu == NULL) {
        return NULL; 
    }
    hMenuTmpl = ::LoadResource( hInstance, hResMenu );
    if(hMenuTmpl == NULL) {
        return NULL; /* failed */
    }
    return (MENUTEMPLATE *)::LockResource( hMenuTmpl );
}
#endif // UNDER_CE

#ifndef UNDER_CE // Windows CE always UNICODE
//////////////////////////////////////////////////////////////////
// Function : LoadMenuA
// Type     : HMENU 
// Purpose  : 
// Args     : 
//            : LANGID    lgid
//          : HINSTANCE    hInstance        // handle to application instance   
//          : LPCTSTR    lpMenuName        // identifies menu template   
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HMENU CExres::LoadMenuA(LANGID        lgid,
                        HINSTANCE    hInstance,
                        LPCTSTR        lpMenuName )
{
    MENUTEMPLATE* pMenuTmpl;
    pMenuTmpl = CExres::LoadMenuTemplateA(lgid, hInstance, lpMenuName);
    if (pMenuTmpl != NULL)
        return ::LoadMenuIndirect( pMenuTmpl );
    else
        return HMENU(0);
}
#endif // UNDER_CE
#ifdef UNDER_CE // Windows CE always UNICODE
HMENU CExres::LoadMenu(LANGID        lgid,
                       HINSTANCE    hInstance,
                       LPCTSTR        lpMenuName )
{
    // Windows CE does not support LoadMenuIndirect
    return ::LoadMenu(hInstance, lpMenuName);
}
#endif // UNDER_CE

//////////////////////////////////////////////////////////////////
// Function : CExres::SetDefaultGUIFont
// Type     : VOID
// Purpose  : Change GUI font as DEFAULT_GUI_FONT
//                In Win95, WinNT4,            DEFAULT_GUI_FONT is "lr o SVbN"
//                In Memphis, WinNT5.0        DEFAULT_GUI_FONT is "MS UI Gothic"
//                IME98's Dialog resource uses "MS UI Gothic" as their font.
//                if IME98 works in Win95 or WinNT40, This API Call SendMessage() with WM_SETFONT
//                to all children window.
//              It should be called in WM_INITDIALOG. If you are creating new child window,
//              You have to call it after new window was created.
// Args     : 
//          : HWND hwndDlg: Set the Dialog window handle to change font.
// Return   : none
// DATE     : 
//////////////////////////////////////////////////////////////////
VOID CExres::SetDefaultGUIFont(HWND hwndDlg)
{
    CExres::SetDefaultGUIFontRecursive(hwndDlg);
    ::UpdateWindow(hwndDlg);
    return;
}

INT CExres::SetDefaultGUIFontRecursive(HWND hwndParent)
{
    HWND hwndChild;
    if(!hwndParent) {
        return 0; 
    }
#ifndef UNDER_CE // Windows CE always UNICODE
    if(::IsWindowUnicode(hwndParent)) {
#endif // UNDER_CE
        ::SendMessageW(hwndParent,
                       WM_SETFONT,
                       (WPARAM)(HFONT)::GetStockObject(DEFAULT_GUI_FONT), 
                       MAKELPARAM(TRUE, 0));
#ifndef UNDER_CE // Windows CE always UNICODE
    }
    else {
        ::SendMessageA(hwndParent,
                       WM_SETFONT,
                       (WPARAM)(HFONT)::GetStockObject(DEFAULT_GUI_FONT), 
                       MAKELPARAM(TRUE, 0));
    }
#endif // UNDER_CE
    for(hwndChild = ::GetWindow(hwndParent, GW_CHILD);
        hwndChild != NULL;
        hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT)) {
        SetDefaultGUIFontRecursive(hwndChild);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\cfactory.cpp ===
//////////////////////////////////////////////////////////////////
// File     : cfactory.cpp
// Purpose  : IClassFactory interface implement.
// 
// 
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved.
//
//////////////////////////////////////////////////////////////////
#define INITGUID 1
#include <objbase.h>
#include <comcat.h>
#include "cfactory.h"
#include "registry.h"
#include "guids.h"
#include "hwxapp.h"
#include "imepad.h"

#define MSAA
#ifdef MSAA // used by lib(plv etc.)
#include <oleacc.h>
#endif

//////////////////////////////////////////////////////////////////
//
// static member variable declaration.
//
LONG    CFactory::m_cServerLocks = 0;        // Locked count
LONG    CFactory::m_cComponents  = 0;        // Locked count
HMODULE CFactory::m_hModule      = NULL ;   // DLL module handle
FACTARRAY   CFactory::m_fData = {
    &CLSID_ImePadApplet_MultiBox,
#ifndef UNDER_CE
#ifdef FE_JAPANESE
    "MS-IME 2000 HandWriting Applet",
#elif  FE_KOREAN
    "MS Korean IME 6.1 HandWriting Applet",
#else
    "MSIME98 HandWriting Applet",
#endif
    "IMEPad.HWR",
    "IMEPad.HWR.6.1",
#else // UNDER_CE
#ifdef FE_JAPANESE
    TEXT("MS-IME 2000 HandWriting Applet"),
#elif  FE_KOREAN
    "MS Korean IME 6.1 HandWriting Applet",
#else
    TEXT("MSIME98 HandWriting Applet"),
#endif
    TEXT("IMEPad.HWR"),
    TEXT("IMEPad.HWR.8"),
#endif // UNDER_CE
};

//////////////////////////////////////////////////////////////////
// 
// static data definition


//////////////////////////////////////////////////////////////////
// Function : CFactory::CFactory
// Type     : None
// Purpose  : Constructor
// Args     : None
// Return   : 
// DATE     : Wed Mar 25 14:38:30 1998
//////////////////////////////////////////////////////////////////
CFactory::CFactory(VOID) : m_cRef(1)
{

}

//////////////////////////////////////////////////////////////////
// Function : CFactory::~CFactory
// Type     : None
// Purpose  : Destructor
// Args     : None
// Return   : 
// DATE     : Wed Mar 25 14:38:30 1998
//////////////////////////////////////////////////////////////////
CFactory::~CFactory(VOID)
{

}

//////////////////////////////////////////////////////////////////
//
// IUnknown implementation
//

//////////////////////////////////////////////////////////////////
// Function : CFactory::QueryInterface
// Type     : HRESULT __stdcall
// Purpose  : 
// Args     : 
//          : REFIID iid 
//            : LPVOID *ppv;
// Return   : 
// DATE     : Wed Mar 25 14:40:29 1998
//////////////////////////////////////////////////////////////////
HRESULT __stdcall CFactory::QueryInterface(REFIID iid, LPVOID * ppv)
{     
    IUnknown* pI ;
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory)) {
        pI= this ;
    }
    else {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    pI->AddRef() ;
    *ppv = pI ;
    return S_OK ;
}

//////////////////////////////////////////////////////////////////
// Function : CFactory::AddRef
// Type     : ULONG __stdcall
// Purpose  : 
// Args     : None
// Return   : reference count
// DATE     : Wed Mar 25 15:40:07 1998
//////////////////////////////////////////////////////////////////
ULONG __stdcall CFactory::AddRef()
{
    ::InterlockedIncrement(&m_cRef) ;
    return (ULONG)m_cRef;
}

//////////////////////////////////////////////////////////////////
// Function : CFactory::Release
// Type     : ULONG __stdcall
// Purpose  : 
// Args     : None
// Return   : reference count
// DATE     : Wed Mar 25 15:40:41 1998
//////////////////////////////////////////////////////////////////
ULONG __stdcall CFactory::Release()
{
    if(0 == ::InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }
    return m_cRef ;
}

//////////////////////////////////////////////////////////////////
//
// IClassFactory implementation
//
//////////////////////////////////////////////////////////////////
// Function : CFactory::CreateInstance
// Type     : HRESULT __stdcall
// Purpose  : 
// Args     : 
//          : IUnknown * pUnknownOuter 
//          : REFIID riid 
//          : LPVOID * ppv 
// Return   : 
// DATE     : Wed Mar 25 15:05:37 1998
//////////////////////////////////////////////////////////////////
HRESULT __stdcall CFactory::CreateInstance(IUnknown*    pUnknownOuter,
                                           REFIID        refiid,
                                           LPVOID        *ppv)
{
    // Create the component.
    HRESULT hr;
    if((pUnknownOuter != NULL) && (refiid != IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION ;
    }

    CApplet *lpCApplet = new CApplet(m_hModule);
    if(!lpCApplet) {
        return E_OUTOFMEMORY;
    }
    hr = lpCApplet->QueryInterface(refiid, ppv);
    if(FAILED(hr)) {
        return hr;
    }
    lpCApplet->Release();
    return hr;
}


//////////////////////////////////////////////////////////////////
// Function : CFactory::LockServer
// Type     : HRESULT __stdcall
// Purpose  : 
// Args     : 
//          : BOOL bLock 
// Return   : 
// DATE     : Wed Mar 25 15:13:41 1998
//////////////////////////////////////////////////////////////////
HRESULT __stdcall CFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        ::InterlockedIncrement(&m_cServerLocks) ;
    }
    else {
        ::InterlockedDecrement(&m_cServerLocks) ;
    }
    return S_OK ;
}

//////////////////////////////////////////////////////////////////
// Function : CFactory::GetClassObject
// Type     : HRESULT
// Purpose  : Called from exported API, DllGetClassObject()
// Args     : 
//          : REFCLSID rclsid 
//          : REFIID iid 
//          : LPVOID * ppv 
// Return   : 
// DATE     : Wed Mar 25 15:37:50 1998
//////////////////////////////////////////////////////////////////
HRESULT CFactory::GetClassObject(REFCLSID    rclsid,
                                 REFIID        iid,
                                 LPVOID        *ppv)
{
    if((iid != IID_IUnknown) && (iid != IID_IClassFactory)) {
        return E_NOINTERFACE ;
    }

    if(rclsid == CLSID_ImePadApplet_MultiBox) {
        *ppv = (IUnknown *) new CFactory();
        if(*ppv == NULL) {
            return E_OUTOFMEMORY ;
        }
        return NOERROR ;
    }
    return CLASS_E_CLASSNOTAVAILABLE ;
}

//////////////////////////////////////////////////////////////////
// Function : CFactory::RegisterServer
// Type     : HRESULT
// Purpose  : Called from exported API DllRegisterServer()
// Args     : None
// Return   : 
// DATE     : Wed Mar 25 17:03:13 1998
//////////////////////////////////////////////////////////////////
HRESULT CFactory::RegisterServer(VOID)
{
    // Get server location.
    Register(m_hModule,
             *m_fData.lpClsId,
             m_fData.lpstrRegistryName,
             m_fData.lpstrProgID,
             m_fData.lpstrVerIndProfID);
    RegisterCategory(TRUE,
                     CATID_MSIME_IImePadApplet,
                     CLSID_ImePadApplet_MultiBox);
    return S_OK ;
}

//////////////////////////////////////////////////////////////////
// Function : CFactory::UnregisterServer
// Type     : HRESULT
// Purpose  : Called from exported API, DllUnregisterServer()
// Args     : None
// Return   : 
// DATE     : Wed Mar 25 17:02:01 1998
//////////////////////////////////////////////////////////////////
HRESULT CFactory::UnregisterServer(VOID)
{
    RegisterCategory(FALSE,
                     CATID_MSIME_IImePadApplet,
                     CLSID_ImePadApplet_MultiBox);
    Unregister(*m_fData.lpClsId,
               m_fData.lpstrVerIndProfID,
               m_fData.lpstrProgID);
    return S_OK ;
}

//////////////////////////////////////////////////////////////////
// Function : CFactory::CanUnloadNow
// Type     : HRESULT
// Purpose  : Called from exported API, DllCanUnloadNow()
// Args     : None
// Return   : 
// DATE     : Wed Mar 25 17:02:18 1998
//////////////////////////////////////////////////////////////////
HRESULT CFactory::CanUnloadNow()
{
    if(IsLocked()) {
        return S_FALSE ;
    }
    else {
        return S_OK ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\cmnhdr.h ===
#ifndef _CMN_HDR_H_
#define _CMN_HDR_H_

//----------------------------------------------------------------
//helper Macro definition
//----------------------------------------------------------------
// show message at compile time with #pragma
// (e.g.)
// in source code, write these line
// #pragma chMSG(Show message at compile time)
// #pragma msgNOIMP
//----------------------------------------------------------------
#define chSTR1(a)			#a
#define chSTR2(a)			chSTR1(a)
#define chMSG(desc)			message(__FILE__ "(" chSTR2(__LINE__) ") : "#desc)
#define msgNOIMP			chMSG(<=====Not Impelemnted yet ======)

//----------------------------------------------------------------
// Get Array's count
//----------------------------------------------------------------
#define ArrayCount(a)	((sizeof(a))/(sizeof((a)[0])))

//----------------------------------------------------------------
//Declare string explicitly
//----------------------------------------------------------------
#define UTEXT(a)	L ## a	//L"XXXXXX"
#define ATEXT(a)	a		//"xxxxxx"

//----------------------------------------------------------------
//remove Ugly warning
//----------------------------------------------------------------
#define UNREF UNREFERENCED_PARAMETER
#define UNREF_FOR_MSG()	UNREF(hwnd);\
                        UNREF(uMsg);\
                        UNREF(wParam);\
                        UNREF(lParam)
#define UNREF_FOR_CMD()	UNREF(hwnd);\
                        UNREF(wCommand);\
                        UNREF(wNotify);\
                        UNREF(hwndCtrl)

#define Unref			UNREFERENCED_PARAMETER
#define Unref1(a)		Unref(a)
#define Unref2(a,b)		Unref(a);Unref(b)
#define Unref3(a,b,c)	Unref(a);Unref(b);Unref(c)
#define Unref4(a,b,c,d)	Unref(a);Unref(b);Unref(c);Unref(d)
#define UnrefMsg()		Unref(hwnd);Unref(wParam);Unref(lParam)
					
#pragma warning (disable:4127)
#pragma warning (disable:4244)
#pragma warning (disable:4706)

//----------------------------------------------------------------
//990810:ToshiaK for Win64
//Wrapper function for Set(Get)WindowLong/Set(Get)WindowLongPtr
// LPVOID  WinGetPtr(HWND hwnd, INT index);
// LPVOID  WinSetPtr(HWND hwnd, INT index, LPVOID lpVoid);
// LPVOID  WinSetUserPtr(HWND hwnd, LPVOID lpVoid);
// LPVOID  WinGetUserPtr(HWND hwnd);
// WNDPROC WinSetWndProc(HWND hwnd, WNDPROC lpfnWndProc);
// WNDPROC WinGetWndProc(HWND hwnd);
//----------------------------------------------------------------
inline LPVOID
WinGetPtr(HWND hwnd, INT index)
{
#ifdef _WIN64
	return (LPVOID)::GetWindowLongPtr(hwnd, index);
#else
	return (LPVOID)::GetWindowLong(hwnd, index);
#endif
}

inline LPVOID
WinSetPtr(HWND hwnd, INT index, LPVOID lpVoid)
{
#ifdef _WIN64
	return (LPVOID)::SetWindowLongPtr(hwnd, index, (LONG_PTR)lpVoid);
#else
	return (LPVOID)::SetWindowLong(hwnd, index, (LONG)lpVoid);
#endif
}

inline LPVOID
WinSetUserPtr(HWND hwnd, LPVOID lpVoid)
{
#ifdef _WIN64
	return (LPVOID)::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpVoid);
#else
	return (LPVOID)::SetWindowLong(hwnd, GWL_USERDATA, (LONG)lpVoid);
#endif
}

inline LPVOID
WinGetUserPtr(HWND hwnd)
{
#ifdef _WIN64
	return (LPVOID)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	return (LPVOID)::GetWindowLong(hwnd, GWL_USERDATA);
#endif
}

inline WNDPROC
WinSetWndProc(HWND hwnd, WNDPROC lpfnWndProc)
{
#ifdef _WIN64
	return (WNDPROC)::SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)lpfnWndProc);
#else
	return (WNDPROC)::SetWindowLong(hwnd, GWL_WNDPROC, (LONG)lpfnWndProc);
#endif
}

inline WNDPROC
WinGetWndProc(HWND hwnd)
{
#ifdef _WIN64
	return (WNDPROC)::GetWindowLongPtr(hwnd, GWLP_WNDPROC);
#else
	return (WNDPROC)::GetWindowLong(hwnd, GWL_WNDPROC);
#endif
}

#endif //_CMN_HDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\cfont.cpp ===
//////////////////////////////////////////////////////////////////
// File     :    cfont.cpp
// Purpose  :    Font handling class source code.
//                Shared by each Applet.
//                You can compile/test this file. see main() function below.
// 
// Date     :    Thu Jul 01 12:20:34 1999
// Author   :    toshiak
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <tchar.h>
#include "cfont.h"
#include "cutil.h"
#ifdef _TEST_CFONT
#include <stdio.h>
#endif //_TEST_CFONT

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//----------------------------------------------------------------
//structure define for internal 
//----------------------------------------------------------------
#define EFI_STOPIFFOUND        0x00000001
#define EFI_DONTENUMVERT    0x00010000

typedef struct tagENUMFONTINFOA {
    DWORD        dwFlag;
    BOOL        fFound;
    LOGFONTA    logFontIn;
    LOGFONTA    logFontOut;
}ENUMFONTINFOA, *LPENUMFONTINFOA;

typedef struct tagENUMFONTINFOW {
    DWORD        dwFlag;
    BOOL        fFound;
    LOGFONTW    logFontIn;
    LOGFONTW    logFontOut;
}ENUMFONTINFOW, *LPENUMFONTINFOW;

#ifdef UNICODE
#define ENUMFONTINFO    ENUMFONTINFOW
#define LPENUMFONTINFO    LPENUMFONTINFOW
#else
#define ENUMFONTINFO    ENUMFONTINFOA
#define LPENUMFONTINFO    LPENUMFONTINFOA
#endif

#ifdef UNDER_CE // Windows CE does not support EnumFontFamiliesEx
inline int EnumFontFamiliesEx(HDC hdc, LPLOGFONT lpLogfont, FONTENUMPROC lpEnumFontFamProc,
                              LPARAM lParam, DWORD)
{
    return ::EnumFontFamilies(hdc, lpLogfont->lfFaceName, lpEnumFontFamProc, lParam);
}

#ifndef ZeroMemory // Defined on sdk\inc\objbase.h under new source tree
#define ZeroMemory(dest, len) memset((dest),0,(len))
#endif
#define DEFAULT_GUI_FONT SYSTEM_FONT
#endif // UNDER_CE

//----------------------------------------------------------------
//
//    Public Method.
//
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function    :    CFont::CreateDefGUIFont
// Type        :    HFONT
// Purpose    :    Create(Copy) DEFAULT_GUI_FONT font Handle.
// Args        :    None
// Return    :    
// DATE        :    Wed Jun 30 18:33:15 1999
// Histroy    :    
//////////////////////////////////////////////////////////////////
HFONT
CFont::CreateDefGUIFont(VOID)
{
    HFONT hFont = (HFONT)::GetStockObject(DEFAULT_GUI_FONT);
    if(!hFont) {
        return NULL;
    }
#ifdef AWBOTH
    if(CUtil::IsWinNT()) {
        LOGFONTW lf;
        if(!::GetObjectW(hFont, sizeof(lf), &lf)) {
            return NULL;
        }
        return ::CreateFontIndirectW(&lf);
    }
#endif
    LOGFONT lf;
    if(!::GetObject(hFont, sizeof(lf), &lf)) {
        return NULL;
    }
    return ::CreateFontIndirect(&lf);
}

INT PointSize2LogPixel(INT pointSize)
{
    HWND hwnd = NULL;
    HDC hDC = ::GetDC(hwnd);
    INT dpi = ::GetDeviceCaps(hDC, LOGPIXELSY);
    ::ReleaseDC(hwnd, hDC);
    return (pointSize * dpi)/72;
}

//////////////////////////////////////////////////////////////////
// Function    :    CFont::CreateGUIFontByCharSet
// Type        :    HFONT
// Purpose    :    Create GUI Font handle with specified characterset.
//                Font size is same with DEFAULT_GUI_FONT.
// Args        :    
//            :    LPTSTR    lpstrFontFace;    fontface string to search,
//                                        if this NULL, return first found
//                                        charset HFONT.
//            :    INT        charSet    
//            :    INT        poinstSize        Inclues VerticalFont or NOT (default is FALSE)
// Return    :    
// DATE        :    Wed Jun 30 18:37:54 1999
// Histroy    :    
//////////////////////////////////////////////////////////////////
HFONT
CFont::CreateGUIFontByNameCharSet(LPTSTR    lpstrFontFace,
                                  INT        charSet,
                                  INT        pointSize)
{
    LOGFONT lf, lfDef;
    //Get DEFAULT_GUI_FONT's LOGFONT data.
    if(!CFont::GetDefGUILogFont(&lfDef)) {
        return NULL;
    }
    //Search Specified charset font's LOGFONT data.
    if(!CFont::SearchLogFontByNameCharSet(&lf, lpstrFontFace, charSet, FALSE)) {
        return NULL;
    }
    lfDef.lfCharSet = lf.lfCharSet;
    if(pointSize > 0) {
        lfDef.lfHeight  = - PointSize2LogPixel(pointSize);
    }
    _tcscpy(lfDef.lfFaceName, lf.lfFaceName);
    return ::CreateFontIndirect(&lfDef);
}
#ifdef AWBOTH
HFONT
CFont::CreateGUIFontByNameCharSetW(LPWSTR    lpstrFontFace,
                                   INT        charSet,
                                   INT        pointSize)
{
    LOGFONTW lf, lfDef;
    //Get DEFAULT_GUI_FONT's LOGFONT data.
    if(!CFont::GetDefGUILogFontW(&lfDef)) {
        return NULL;
    }
    //Search Specified charset font's LOGFONT data.
    if(!CFont::SearchLogFontByNameCharSetW(&lf, lpstrFontFace, charSet, FALSE)) {
        return NULL;
    }

    lfDef.lfCharSet = lf.lfCharSet;
    if(pointSize > 0) {
        lfDef.lfHeight  = - PointSize2LogPixel(pointSize);
    }
    lfDef.lfWidth   = 0;
    wcscpy(lfDef.lfFaceName, lf.lfFaceName);
    return ::CreateFontIndirectW(&lfDef);
}
#endif //AWBOTH


//////////////////////////////////////////////////////////////////
// Function    :    CFont::IsFontExist
// Type        :    BOOL
// Purpose    :    Check specified FaceName & charSet font is Exit or NOT.
// Args        :    
//            :    LPTSTR    lpstrFontFace    
//            :    INT    charSet    
// Return    :    
// DATE        :    Thu Jul 22 23:00:54 1999
// Histroy    :    
//////////////////////////////////////////////////////////////////
BOOL
CFont::IsFontExist(LPTSTR lpstrFontFace, INT charSet)
{
    return CFont::SearchLogFontByNameCharSet(NULL,
                                             lpstrFontFace,
                                             charSet,
                                             FALSE);
}

#ifdef AWBOTH
BOOL
CFont::IsFontExist(LPWSTR lpstrFontFace, INT charSet)
{
    return CFont::SearchLogFontByNameCharSetW(NULL,
                                              lpstrFontFace,
                                              charSet,
                                              FALSE);
}
#endif //AWBOTH

//////////////////////////////////////////////////////////////////
// Function    :    CFont::GetFontNameByCharSet
// Type        :    BOOL
// Purpose    :    Serach & Get FontFace with Specified charSet
// Args        :    
//            :    INT    charSet    
//            :    LPTSTR    lpstrFontFace    
//            :    INT    cchMax    
// Return    :    
// DATE        :    Thu Jul 22 23:13:01 1999
// Histroy    :    
//////////////////////////////////////////////////////////////////
BOOL
CFont::GetFontNameByCharSet(INT        charSet,
                            LPTSTR    lpstrFontFace,
                            INT        cchMax)
{
    if(!lpstrFontFace) {
        return FALSE;
    }
    if(cchMax < LF_FACESIZE) {
        return FALSE;
    }

    LOGFONT lf;

    BOOL fRet = CFont::SearchLogFontByNameCharSet(&lf,
                                                  NULL,
                                                  charSet,
                                                  FALSE);
    if(fRet) {
        StringCchCopy(lpstrFontFace, cchMax, lf.lfFaceName);
    }
    return fRet;
}

#ifdef AWBOTH
BOOL
CFont::GetFontNameByCharSetW(INT    charSet,
                             LPWSTR    lpstrFontFace,
                             INT    cchMax)
{
    if(!lpstrFontFace) {
        return FALSE;
    }
    if(cchMax < LF_FACESIZE) {
        return FALSE;
    }

    LOGFONTW lf;

    BOOL fRet = CFont::SearchLogFontByNameCharSetW(&lf,
                                                  NULL,
                                                  charSet,
                                                  FALSE);
    if(fRet) {
        wcscpy(lpstrFontFace, lf.lfFaceName);
    }
    return fRet;
}
#endif


//////////////////////////////////////////////////////////////////
// Function    :    CFont::GetFontInfoByName
// Type        :    BOOL
// Purpose    :    
// Args        :    
//            :    LPTSTR    lpstrFontFace    
//            :    INT *    pCharSet    
//            :    INT *    pCodePage    
// Return    :    
// DATE        :    Fri Jul 23 02:48:29 1999
// Histroy    :    
//////////////////////////////////////////////////////////////////
BOOL
CFont::GetFontInfoByName(LPTSTR lpstrFontFace,
                         INT    *pCharSet,
                         INT    *pCodePage)
{
    LOGFONT lf;
    BOOL fRet = CFont::SearchLogFontByNameCharSet(&lf,
                                                  lpstrFontFace,
                                                  DEFAULT_CHARSET,
                                                  FALSE);
    if(!fRet) {
        return FALSE;
    }

    *pCharSet = (INT)lf.lfCharSet;
    CHARSETINFO info;
    if(::TranslateCharsetInfo((DWORD *)(DWORD_PTR)*pCharSet,
                              &info,
                              TCI_SRCCHARSET)) {
        *pCodePage = (INT)info.ciACP;
    }
    else { //failed
        *pCodePage = CP_ACP;
    }
    return 0;
}

#ifdef AWBOTH
BOOL
CFont::GetFontInfoByNameW(LPWSTR lpstrFontFace,
                          INT      *pCharSet,
                          INT      *pCodePage)
{
    LOGFONTW lf;
    BOOL fRet = CFont::SearchLogFontByNameCharSetW(&lf,
                                                   lpstrFontFace,
                                                   DEFAULT_CHARSET,
                                                   FALSE);
    if(!fRet) {
        return FALSE;
    }

    *pCharSet = (INT)lf.lfCharSet;
    CHARSETINFO info;
    if(::TranslateCharsetInfo((DWORD *)(DWORD_PTR)*pCharSet,
                              &info,
                              TCI_SRCCHARSET)) {
        *pCodePage = (INT)info.ciACP;
    }
    else { //failed
        *pCodePage = CP_ACP;
    }
    return 0;
}
#endif //AWBOTH

//----------------------------------------------------------------
//
// Private method.
//
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function    :    CFont::GetDefGUILogFont
// Type        :    BOOL
// Purpose    :    
// Args        :    LOGFONT *lpLF
// Return    :    
// DATE        :    Wed Jul 15 19:36:57 1998
// Histroy    :    
//////////////////////////////////////////////////////////////////
BOOL
CFont::GetDefGUILogFont(LOGFONT *lpLF)
{
    if(!lpLF) {
        return FALSE;
    }
    if(!::GetObject((HFONT)::GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), lpLF)) {
        return FALSE;
    }
    return TRUE;
}
////////////////////
//Unicode version.
////////////////////
#ifdef AWBOTH
BOOL
CFont::GetDefGUILogFontW(LOGFONTW *lpLF)
{
    if(!lpLF) {
        return FALSE;
    }
    if(!::GetObjectW((HFONT)::GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONTW), lpLF)) {
        return FALSE;
    }
    return TRUE;
}
#endif //AWBOTH


//////////////////////////////////////////////////////////////////
// Function    :    CFont::SearchLogFontByNameCharSet
// Type        :    BOOL
// Purpose    :    Search LOGFONT data with specified FaceName & charset.
//                If FaceName is not specified, return first find charset logfont.
// Args        :    
//            :    LOGFONT *    lpLF    
//            :    LPTSTR        lpstrFontFace    
//            :    INT            charSet    
//            :    BOOL        fIncVert
//                                Inclues VerticalFont or NOT (default is FALSE)
// Return    :    
// DATE        :    Thu Jul 01 17:12:40 1999
// Histroy    :    
//////////////////////////////////////////////////////////////////
BOOL
CFont::SearchLogFontByNameCharSet(LOGFONT    *lpLF,
                                  LPTSTR    lpstrFontFace,
                                  INT        charSet,
                                  BOOL        fIncVert)
{
    HWND hwndDC = NULL;
    HDC hDC = ::GetDC(hwndDC);
    if(!hDC) {
        return FALSE;
    }
    ENUMFONTINFO    enumFontInfo;
    LPENUMFONTINFO    lpEnumFontInfo = &enumFontInfo;

    ::ZeroMemory(&enumFontInfo, sizeof(enumFontInfo));
    lpEnumFontInfo->logFontIn.lfCharSet = (BYTE)charSet; 
    if(lpstrFontFace) { 
        if(lstrlen(lpstrFontFace) < LF_FACESIZE) {
            _tcscpy(lpEnumFontInfo->logFontIn.lfFaceName, lpstrFontFace);
        }
    }
    lpEnumFontInfo->dwFlag    = EFI_STOPIFFOUND;
    lpEnumFontInfo->dwFlag |= fIncVert ? 0 : EFI_DONTENUMVERT;
    lpEnumFontInfo->fFound    = FALSE;
    ::EnumFontFamiliesEx(hDC,
                         &lpEnumFontInfo->logFontIn,
                         (FONTENUMPROC)CFont::EnumFontFamiliesExProc,
                         (LPARAM)lpEnumFontInfo,
                         0);
    ::ReleaseDC(hwndDC, hDC);

    if(lpEnumFontInfo->fFound) {
        if(lpLF) {
            *lpLF = lpEnumFontInfo->logFontOut;
        }
    }
    return lpEnumFontInfo->fFound;
}

#ifdef AWBOTH
BOOL
CFont::SearchLogFontByNameCharSetW(LOGFONTW *lpLF,
                                   LPWSTR    lpstrFontFace,
                                   INT        charSet,
                                   BOOL        fIncVert)
{
    HWND hwndDC = NULL;
    HDC hDC = ::GetDC(hwndDC);
    if(!hDC) {
        return FALSE;
    }
    ENUMFONTINFOW    enumFontInfo;
    LPENUMFONTINFOW    lpEnumFontInfo = &enumFontInfo;

    ::ZeroMemory(&enumFontInfo, sizeof(enumFontInfo));
    lpEnumFontInfo->logFontIn.lfCharSet = (BYTE)charSet; 
    if(lpstrFontFace) { 
        if(wcslen(lpstrFontFace) < LF_FACESIZE) {
            wcscpy(lpEnumFontInfo->logFontIn.lfFaceName, lpstrFontFace);
        }
    }
    lpEnumFontInfo->dwFlag    = EFI_STOPIFFOUND;
    lpEnumFontInfo->dwFlag |= fIncVert ? 0 : EFI_DONTENUMVERT;
    lpEnumFontInfo->fFound    = FALSE;

    ::EnumFontFamiliesExW(hDC,
                          &lpEnumFontInfo->logFontIn,
                          (FONTENUMPROCW)CFont::EnumFontFamiliesExProcW,
                          (LPARAM)lpEnumFontInfo,
                          0);
    ::ReleaseDC(hwndDC, hDC);

    if(lpEnumFontInfo->fFound) {
        if(lpLF) {
            *lpLF = lpEnumFontInfo->logFontOut;
        }
    }
    return lpEnumFontInfo->fFound;
}
#endif

//////////////////////////////////////////////////////////////////
// Function    :    CFont::EnumFontFamiliesExProc
// Type        :    INT    CALLBACK
// Purpose    :    
// Args        :    
//            :    ENUMLOGFONTEX *    lpElf
//            :    NEWTEXTMETRIC *    lpNtm
//            :    INT    iFontType    
//            :    LPARAM    lParam    
// Return    :    
// DATE        :    Thu Jul 01 15:17:56 1999
// Histroy    :    
//////////////////////////////////////////////////////////////////
INT CALLBACK
CFont::EnumFontFamiliesExProc(ENUMLOGFONTEX    *lpElf,
                              NEWTEXTMETRIC    *lpNtm,
                              INT            iFontType,
                              LPARAM        lParam)
{
    LPENUMFONTINFO    lpEnumFontInfo = (LPENUMFONTINFO)lParam;
    if(!lpEnumFontInfo) {
        return 0; //Do not continue;
    }

    if(lpEnumFontInfo->dwFlag & EFI_STOPIFFOUND) {
        if(lpEnumFontInfo->logFontIn.lfFaceName[0] == (TCHAR)0x00) {
            if(lpEnumFontInfo->logFontIn.lfCharSet == lpElf->elfLogFont.lfCharSet) {
                //----------------------------------------------------------------
                //if EFI_DONTENUMVERT is set, 
                //Do skip vertical font enumulation.
                //----------------------------------------------------------------
                if( (lpEnumFontInfo->dwFlag & EFI_DONTENUMVERT) &&
                    lpElf->elfLogFont.lfFaceName[0] == (TCHAR)'@') {
                    return 1; //continue to enum.
                }
                //Found specified charSet's logfont
                lpEnumFontInfo->logFontOut = lpElf->elfLogFont;
                lpEnumFontInfo->fFound       = TRUE;    
                return 0; //Do not coninue;
            }
        }
        else {
            if(lpEnumFontInfo->logFontIn.lfCharSet == lpElf->elfLogFont.lfCharSet &&
               0 == _tcscmp(lpEnumFontInfo->logFontIn.lfFaceName, lpElf->elfLogFont.lfFaceName)) {
                //Found specified charSet's logfont
                lpEnumFontInfo->logFontOut = lpElf->elfLogFont;
                lpEnumFontInfo->fFound       = TRUE;    
                return 0; //Do not coninue;
            }
        }
    }
    else {
#ifdef _TEST_CFONT
        extern LPTSTR GetCharset(int );
        _tprintf(TEXT("[%-24s] [%-20s][%s][%s][%s]\n"), 
                 lpElf->elfLogFont.lfFaceName,
                 GetCharset(lpElf->elfLogFont.lfCharSet),
                 lpElf->elfFullName,
                 lpElf->elfScript,
                 lpElf->elfStyle);
#endif
    }
    return 1;//continue to enum;
    UNREFERENCED_PARAMETER(lpNtm);
    UNREFERENCED_PARAMETER(iFontType);
}

#ifdef AWBOTH
INT CALLBACK
CFont::EnumFontFamiliesExProcW(ENUMLOGFONTEXW    *lpElf,
                               NEWTEXTMETRIC    *lpNtm,
                               INT                iFontType,
                               LPARAM            lParam)
{
    LPENUMFONTINFOW    lpEnumFontInfo = (LPENUMFONTINFOW)lParam;
    if(!lpEnumFontInfo) {
        return 0; //Do not continue;
    }

    if(lpEnumFontInfo->dwFlag & EFI_STOPIFFOUND) {
        if(lpEnumFontInfo->logFontIn.lfFaceName[0] == (WCHAR)0x00) {
            if(lpEnumFontInfo->logFontIn.lfCharSet == lpElf->elfLogFont.lfCharSet) {
                //----------------------------------------------------------------
                //if EFI_DONTENUMVERT is set, 
                //Do skip vertical font enumulation.
                //----------------------------------------------------------------
                if( (lpEnumFontInfo->dwFlag & EFI_DONTENUMVERT) &&
                    lpElf->elfLogFont.lfFaceName[0] == (WCHAR)'@') {
                    return 1; //continue to enum.
                }
                //Found specified charSet's logfont
                lpEnumFontInfo->logFontOut = lpElf->elfLogFont;
                lpEnumFontInfo->fFound       = TRUE;
                return 0; //Do not coninue;
            }
        }
        else {
            if(lpEnumFontInfo->logFontIn.lfCharSet == lpElf->elfLogFont.lfCharSet &&
               0 == wcscmp(lpEnumFontInfo->logFontIn.lfFaceName, lpElf->elfLogFont.lfFaceName)) {
                //Found specified charSet's logfont
                lpEnumFontInfo->logFontOut = lpElf->elfLogFont;
                lpEnumFontInfo->fFound       = TRUE;
                return 0; //Do not coninue;
            }
        }
    }
    return 1;//continue to enum;
    UNREFERENCED_PARAMETER(lpNtm);
    UNREFERENCED_PARAMETER(iFontType);
}
#endif //AWBOTH




//----------------------------------------------------------------
//
// test program for cfontex.cpp 
//
// how to compile.    
// 1. for ANSI.    
//   cl cfontex.cpp -I../common -D_TEST_CFONT -link user32.lib advapi32.lib gdi32.lib
// 2. for Ansi&Wide both
//   cl cfontex.cpp -I../common -DAWBOTH -D_TEST_CFONT -link user32.lib advapi32.lib gdi32.lib
// 2. for Unicode.
//   cl cfontex.cpp -I../common -DUNICODE -D_UNICODE -D_TEST_CFONT -link user32.lib advapi32.lib gdi32.lib
//----------------------------------------------------------------
#ifdef _TEST_CFONT
#if defined(UNICODE) ||  defined(_UNICODE)
#define DEFSTR(a)    {a, L ## #a}
#else
#define DEFSTR(a)    {a, #a}
#endif
typedef struct tagIDSTR {
    INT id;
    TCHAR *p;
}IDSTR;

IDSTR idstr[]= {
    DEFSTR(ANSI_CHARSET),
    DEFSTR(DEFAULT_CHARSET),
    DEFSTR(SYMBOL_CHARSET),
    DEFSTR(SHIFTJIS_CHARSET),
    DEFSTR(HANGEUL_CHARSET),
    DEFSTR(HANGUL_CHARSET),
    DEFSTR(GB2312_CHARSET),
    DEFSTR(CHINESEBIG5_CHARSET),
    DEFSTR(OEM_CHARSET),
    DEFSTR(JOHAB_CHARSET),
    DEFSTR(HEBREW_CHARSET),
    DEFSTR(ARABIC_CHARSET),
    DEFSTR(GREEK_CHARSET),
    DEFSTR(TURKISH_CHARSET),
    DEFSTR(VIETNAMESE_CHARSET),
    DEFSTR(THAI_CHARSET),
    DEFSTR(EASTEUROPE_CHARSET),
    DEFSTR(RUSSIAN_CHARSET),
    DEFSTR(MAC_CHARSET),
    DEFSTR(BALTIC_CHARSET),
};

#define ArrayCount(a)    sizeof(a)/sizeof(a[0])
LPTSTR GetCharset(INT charset)
{
    static TCHAR szbuf[256];
    int i;
    for( i = 0; i < ArrayCount(idstr); i++) {
        if(charset == idstr[i].id) {
            return idstr[i].p;
        }
    }
    wsprintf(szbuf, TEXT("Unknown Charset[0x%08x]"), charset);
    return szbuf;
}

VOID PrintLogFont(LOGFONT *lplf)
{
    _tprintf(TEXT("lfHeight        [%d]\n"), lplf->lfHeight);
    _tprintf(TEXT("lfWidth         [%d]\n"), lplf->lfWidth );
    _tprintf(TEXT("lfEscapement    [%d]\n"), lplf->lfEscapement);
    _tprintf(TEXT("lfOrientation   [%d]\n"), lplf->lfOrientation);
    _tprintf(TEXT("lfWeight        [%d]\n"), lplf->lfWeight);
    _tprintf(TEXT("lfItalic        [%d]\n"), lplf->lfItalic);
    _tprintf(TEXT("lfUnderline     [%d]\n"), lplf->lfUnderline);
    _tprintf(TEXT("lfStrikeOut     [%d]\n"), lplf->lfStrikeOut);
    _tprintf(TEXT("lfCharSet       [%d]\n"), lplf->lfCharSet);
    _tprintf(TEXT("lfOutPrecision  [%d]\n"), lplf->lfOutPrecision);
    _tprintf(TEXT("lfClipPrecision [%d]\n"), lplf->lfClipPrecision);
    _tprintf(TEXT("lfQuality       [%d]\n"), lplf->lfQuality);
    _tprintf(TEXT("lfPitchAndFamily[%d]\n"), lplf->lfPitchAndFamily);
    _tprintf(TEXT("lfFaceName      [%s]\n"), lplf->lfFaceName);
}


#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <mbstring.h>
#include <mbctype.h>
#include <locale.h>
#include "cfont.h"
#include "cutil.h"
#include "cutil.cpp"
extern LPTSTR GetCharset(INT charset);
void main(void)
{
    _tsetlocale(LC_ALL, TEXT(".ACP"));
    HWND hwndDC = NULL;
    HDC hDC = ::GetDC(hwndDC);
    ENUMFONTINFO    enumFontInfo;
    LPENUMFONTINFO    lpEnumFontInfo = &enumFontInfo;

#if 0
    ::ZeroMemory(&enumFontInfo, sizeof(enumFontInfo));
    lpEnumFontInfo->logFontIn.lfCharSet = (BYTE)DEFAULT_CHARSET;
    lpEnumFontInfo->dwFlag    = 0;
    _tprintf(TEXT("Enumlate All Font\n"));
    ::EnumFontFamiliesEx(hDC,
                         &lpEnumFontInfo->logFontIn,
                         (FONTENUMPROC)CFont::EnumFontFamiliesExProc,
                         (LPARAM)lpEnumFontInfo,
                         0);

    ::ZeroMemory(&enumFontInfo, sizeof(enumFontInfo));
    lpEnumFontInfo->logFontIn.lfCharSet = ANSI_CHARSET;
    lpEnumFontInfo->dwFlag    = 0;
    _tprintf(TEXT("Enumulate ANSI_CHARSET font\n"));
    ::EnumFontFamiliesEx(hDC,
                         &lpEnumFontInfo->logFontIn,
                         (FONTENUMPROC)CFont::EnumFontFamiliesExProc,
                         (LPARAM)lpEnumFontInfo,
                         0);
    _tprintf(TEXT("Enumulate SHIFTJIS_CHARSET font\n"));
    ::ZeroMemory(&enumFontInfo, sizeof(enumFontInfo));
    lpEnumFontInfo->logFontIn.lfCharSet = SHIFTJIS_CHARSET;
    lpEnumFontInfo->dwFlag    = 0;
    ::EnumFontFamiliesEx(hDC,
                         &lpEnumFontInfo->logFontIn,
                         (FONTENUMPROC)CFont::EnumFontFamiliesExProc,
                         (LPARAM)lpEnumFontInfo,
                         0);

    ::ReleaseDC(hwndDC, hDC);
#endif

    LOGFONT lf;
    BOOL fRet;
    static LPTSTR fontNameList[]= { TEXT("MS Mincho"),
                                    TEXT("MS Gothic"),
                                    TEXT("MS UI Gothic"),
                                    TEXT("lr "),
                                    TEXT("lr o"),
                                    TEXT("lr SVbN"),
                                    TEXT("lr oSVbN")};

    CFont::GetDefGUILogFont(&lf);
    _tprintf(TEXT("DEFAULT_GUI_FONT LOGFONT\n"));
    PrintLogFont(&lf);

    int i;
    for(i = 0; i < sizeof(fontNameList)/sizeof(fontNameList[0]); i++) {
        fRet = CFont::SearchLogFontByNameCharSet(&lf,
                                                 fontNameList[i],
                                                 SHIFTJIS_CHARSET);
        _tprintf(TEXT("Search Font [%-20s] %s\n"),
                 fontNameList[i],
                 fRet ? TEXT("FOUND") : TEXT("NOT FOUND"));
        if(fRet) {
            PrintLogFont(&lf);
            HFONT hFont = CFont::CreateGUIFontByNameCharSet(fontNameList[i],
                                                            SHIFTJIS_CHARSET, FALSE);
            LOGFONT lfNew;
            ::GetObject(hFont, sizeof(lfNew), &lfNew);
            PrintLogFont(&lfNew);
        }
    }
}

#endif //_TEST_CFONT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\const.h ===
#ifndef _CONST_H_
#define _CONST_H_

// Constants
#define MB_NUM_CANDIDATES 		9
#define INVALID_CHAR 			0xffff
#define TIMER_ID				100
//#define TIMER_AUTORECOG			101
#define BUTTON_HEIGHT 			18
#define BUTTON_WIDTH			62 //38  //36
#define TOTALLOGICALBOX			700

//#define PadWnd_Height   		120 	//The height of HwxPadApplet window in pixel
#define PadWnd_Height   		180 	//The height of HwxPadApplet window in pixel
#define INKBOXSIZE_MIN	   		148		// minimum inkbox size 50 by 50	in pixel
#define LISTVIEWWIDTH_MIN		65		// PadListView minimum width in pixel
#define Box_Border				4 		//Distance between two writing boxes
#define CACMBHEIGHT_MIN			90

#define	FONT_SIZE				12

#define	MACAW_REDRAW_BACKGROUND		0x0001
#define	MACAW_REDRAW_INK			0x0002

// CHwxThreadMB/CHwxThreadCAC user defined thread messages
#define THRDMSG_ADDINK      WM_USER + 500  // WPARAM= box size,	LPARAM= pStroke
#define THRDMSG_RECOGNIZE	WM_USER + 501  // WPARAM= logical box,LPARAM= 0
//#define THRDMSG_CHAR		WM_USER + 502  // WPARAM= wchar,LPARAM= 0
#define THRDMSG_SETMASK		WM_USER + 503  // WPARAM= mask,	LPARAM= 0
#define THRDMSG_SETCONTEXT	WM_USER + 504  // WPARAM= wchar,LPARAM= 0
#define THRDMSG_SETGUIDE	WM_USER + 505  // WPARAM= size,	LPARAM= 0
#define THRDMSG_EXIT        WM_USER + 506  // WPARAM= 0,LPARAM= 0

// CHwxMB/CHwxCAC user defined WINDOW messages
#define MB_WM_ERASE    		WM_USER + 1000 // WPARAM= 0,LPARAM= 0
#define MB_WM_DETERMINE   	WM_USER + 1001 // WPARAM= 0,LPARAM= 0
#define MB_WM_HWXCHAR     	WM_USER + 1002 // WPARAM= pHwxResultPri,LPARAM= 0
//#define MB_WM_COMCHAR     	WM_USER + 1003 // WPARAM= 0,LPARAM= 0
#define MB_WM_COPYINK     	WM_USER + 1004 // WPARAM= 0,LPARAM= 0
#define	CAC_WM_RESULT		WM_USER + 1005 // WPARAM= type, HIWORD(LPARAM)= rank, LOWORD(LPARAM)= code
#define CAC_WM_SENDRESULT	WM_USER + 1006
#define CAC_WM_DRAWSAMPLE   WM_USER + 1007
#define	CAC_WM_SHOWRESULT	WM_USER + 1008 

// CAC recognitio output 
#define FULLLIST			8 
#define PREFIXLIST			16
#define FREELIST			16
#define LISTTOTAL			(FULLLIST+PREFIXLIST+FREELIST)
#define LISTVIEW_COLUMN     8

#define IDC_CACINPUT		0x7FFA	//980706:ToshiaK for Help identifier 
#define IDC_MBINPUT			0x7FFB	//980706:ToshiaK for Help identifier 
#define IDC_CACLISTVIEW 	0x7FFF


#endif // _CONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\cutil.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "cutil.h"

#define MemAlloc(a)    GlobalAlloc(GMEM_FIXED, (a))
#define MemFree(a)    GlobalFree((a))

static POSVERSIONINFO _getOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

BOOL
CUtil::IsWinNT(VOID)
{
    return (_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
}

BOOL
CUtil::IsWinNT4(VOID)
{
    if((_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
       (_getOSVersion()->dwMajorVersion == 4)) {
        return TRUE;
    }

    return FALSE;
}

BOOL
CUtil::IsWinNT5(VOID)
{
    if((_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
       (_getOSVersion()->dwMajorVersion == 5)) {
        return TRUE;
    }
    return FALSE;
}

BOOL
CUtil::IsWin9x(VOID)
{
    if((_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
       (_getOSVersion()->dwMajorVersion >= 4)) {
        return TRUE;
    }
    return FALSE;
}

BOOL
CUtil::IsWin95(VOID)
{
    if((_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
       (_getOSVersion()->dwMajorVersion >= 4) &&
       (_getOSVersion()->dwMinorVersion < 10)) {
        return TRUE;
    }
    return FALSE;
}
BOOL
CUtil::IsWin98(VOID)
{
    if((_getOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
       (_getOSVersion()->dwMajorVersion >= 4) &&
       (_getOSVersion()->dwMinorVersion  >= 10)) {
        return TRUE;
    }
    return FALSE;
}

BOOL
CUtil::IsHydra(VOID)
{
#ifdef UNDER_CE
    return FALSE;
#else //!UNDER_CE
    static DWORD fTested = FALSE, fHydra = FALSE;
    HKEY hKey;

    if(fTested) {
        return fHydra;
    }

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                                     0,
                                     KEY_READ,
                                     &hKey)){
        DWORD cbData = 0;
        if(ERROR_SUCCESS == RegQueryValueEx(hKey,
                                            TEXT("ProductSuite"),
                                            NULL,
                                            NULL,
                                            NULL,
                                            &cbData)){
            TCHAR *mszBuffer, *szCurPtr;
            if(NULL != (mszBuffer = (TCHAR *)MemAlloc(cbData))){
                RegQueryValueEx(hKey,
                                TEXT("ProductSuite"),
                                NULL,
                                NULL,
                                (unsigned char *)mszBuffer,
                                &cbData);
                for(szCurPtr = mszBuffer; 0 != *szCurPtr; szCurPtr += lstrlen(szCurPtr)+1){
                    if(0 == lstrcmpi(szCurPtr, TEXT("Terminal Server"))){
                        fHydra = TRUE;
                        break;
                    }
                }
                MemFree(mszBuffer);
            }
        }
        RegCloseKey(hKey);
    }
    fTested = TRUE;
    return(fHydra);
#endif //UNDER_CE
}

INT
CUtil::GetWINDIR(LPTSTR lpstr, INT len)
{
#ifdef UNDER_CE
    static const TCHAR szWindowsDir[] = TEXT("\\Windows");
    _tcsncpy(lpstr, szWindowsDir, len);
    if(len < sizeof szWindowsDir/sizeof(TCHAR))
        lpstr[len-1] = TEXT('\0');
    return lstrlen(lpstr);
#else //!UNDER_CE
    INT dirSize=0;
    if(CUtil::IsHydra()) {
        dirSize = ::GetEnvironmentVariable(TEXT("WINDIR"), lpstr, len);
    }    
    else {
        dirSize = ::GetWindowsDirectory(lpstr, len);
    }
    return dirSize;
#endif //UNDER_CE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\dbgmgr.h ===
#ifndef _DBG_H_
#define _DBG_H_
////////////////////////////////////////////////////////
// Function: Dbg
// Type    : VOID
// Purpose : Printing debug message with same usage as printf()
// Args    : 
//         : LPSTR lpstrFuncName 
//		   : ...	
// CAUTION: Please use DOUBLE Blaket!!!
/////////////////////////////////////////////////////////
//VOID Dbg((LPSTR lpstrFuncName, ...));

#ifndef UNICODE_ONLY
extern VOID  _dbgA		 (LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
extern VOID  _dbgPrintA (LPSTR lpstrMsg, ...);
extern LPSTR _dbgVaStrA (LPSTR lpstrFmt, ...);
#endif

#ifndef ANSI_ONLY
extern VOID   _dbgW(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _dbgPrintW(LPWSTR lpstrMsg, ...);
extern LPWSTR _dbgVaStrW(LPWSTR lpstrFmt, ...);
#endif


#ifdef _DEBUG
#	ifdef UNICODE 
#		define Dbg(a)	_dbgW(TEXT(__FILE__), __LINE__, _dbgVaStrW a)
#		define DbgP(a)	_dbgPrintW(_dbgVaStrW a)
#	else //!UNICODE
#		define Dbg(a)	_dbgA(__FILE__, __LINE__, _dbgVaStrA a)
#		define DbgP(a)	_dbgPrintA(_dbgVaStrA a)
#	endif //UNICODE
#else //!_DEBUG
#	define Dbg(a)
#endif //_DEBUG

#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\dbg.h ===
//////////////////////////////////////////////////////////////////
// File     : dbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef _DBG_H_
#define _DBG_H_

#ifdef __cplusplus
#	define InlineFunc  inline
#else 
#	define InlineFunc  __inline
#endif

//----------------------------------------------------------------
// Callback function prototype
//----------------------------------------------------------------
typedef VOID (WINAPI *LPFNDBGCALLBACKA)(LPSTR  lpstr);
typedef VOID (WINAPI *LPFNDBGCALLBACKW)(LPWSTR lpwstr);

//-------------------------------------------------------
//MACRO function  prototype declare.
//It is valid only if compliled with _DEBUG definition.
//-------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function : DBGSetCallback
// Type     : VOID
// Purpose  : Set debug callback function.
//			  callback function has set, when DBG() has called,
//			  call this callback function with formatted message string.
// Args     : 
//          : LPFNDBGCALLBACKA lpfnDbgCallbackA 
//          : LPFNDBGCALLBACKW lpfnDbgCallbackW 
// Return   : VOID
// DATE     : Tue Jan 06 12:21:05 1998
//////////////////////////////////////////////////////////////////
//VOID DBGSetCallback(LPFNDBGCALLBACKA lpfnDbgCallbackA, LPFNDBGCALLBACKW lpfnDbgCallbackW);

//////////////////////////////////////////////////////////////////
// Function : DBGEnableOutput
// Type     : VOID
// Purpose  : On off OutputDebugString to COM.
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:33:21 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//VOID DBGEnableOutput(BOOL fEnable)

//////////////////////////////////////////////////////////////////
// Function : DBGIsOutputEnable
// Type     : BOOL
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 17:58:28 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//BOOL DBGIsOutputEnable(VOID)


////////////////////////////////////////////////////////
// Function	: DBG
// Type		: VOID
// Purpose	: Printing ANSI debug message with same usage as printf()
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// Example	: DBGW(("Error occured data[%d]", i));
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//		   : ...	
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example	: DBGW(("Error occured data[%d]", i));
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

//////////////////////////////////////////////////////////////////
// Function : DBGMsgBox
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example	: DBGMsgBox(("Error occured data[%d]", i));
//////////////////////////////////////////////////////////////////
//VOID DBGMsgBox((LPSTR lpstrFmt, ...))

//////////////////////////////////////////////////////////////////
// Function : DBGAssert
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fError
// Return   : 
// DATE     : Fri Jan 09 17:17:31 1998
//////////////////////////////////////////////////////////////////
//VOID DBGAssert(BOOL fError)


//////////////////////////////////////////////////////////////////
// Function : DBGSTR
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr
//////////////////////////////////////////////////////////////////
//VOID DBGSTR(LPSTR lpstr);


//////////////////////////////////////////////////////////////////
// Function : DBGGetErrorString
// Type     : VOID
// Purpose  : Get error message from WIN32 Error code.
// Args     : 
//          : INT errorCode 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetErrorString(INT errorCode)


//////////////////////////////////////////////////////////////////
// Function : DBGGetWinClass
// Type     : LPSTR
// Purpose  : Get class name string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinClass(HWND hwnd)

//////////////////////////////////////////////////////////////////
// Function : DBGGetWinText
// Type     : LPSTR
// Purpose  : Get title text string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinText(HWND hwnd)



#ifdef _DEBUG
//----------------------------------------------------------------
//Function prototype declare
//----------------------------------------------------------------
extern VOID   _debugEnableOutput	(BOOL fEnable);
extern BOOL   _debugIsOutputEnable	(VOID);
extern VOID	  _debugSetCallback		(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW);
extern VOID   _debugA				(LPSTR  lpstrFile, INT lineNo, LPSTR  lpstrMsg);
extern VOID   _debugW				(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _debugMsgBoxA			(LPSTR  lpstrFile,  INT lineNo, LPSTR lpstrMsg);
extern VOID   _debugAssert			(LPSTR  lpstrFile,  INT lineNo, BOOL fError, LPSTR lpstrMsg);
extern VOID   _debugPrintfA			(LPSTR  lpstrFmt, ...);
extern VOID   _debugPrintfW			(LPWSTR lpstrFmt, ...);
extern VOID   _debugOutStrA			(LPSTR  lpstr);
extern VOID	  _debugOutStrW			(LPWSTR lpwstr);
extern LPSTR  _debugVaStrA			(LPSTR  lpstrFmt, ...);
extern LPWSTR _debugVaStrW			(LPWSTR lpstrFmt, ...);
extern LPWSTR _debugMulti2Wide		(LPSTR  lpstr);
extern LPSTR  _debugGetWinClass		(HWND   hwnd);
extern LPSTR  _debugGetWinText		(HWND   hwnd);
extern LPSTR  _debugGetErrorString	(INT    errorCode);
//----------------------------------------------------------------
// Macro definition
//----------------------------------------------------------------
#	define DBGSetCallback(a,b)	_debugSetCallback(a, b)
#	define DBGEnableOutput(a)	_debugEnableOutput(a)
#	define DBGIsOutputEnable()	_debugIsOutputEnable()
#	define Dbg(a)				_debugA(__FILE__, __LINE__, _debugVaStrA a)
#	define DBGA(a)				_debugA(__FILE__, __LINE__, _debugVaStrA a)
#	define DBGW(a)				_debugW( _debugMulti2Wide(__FILE__), __LINE__, _debugVaStrW a)
#	define DBGMsgBox(a)			_debugMsgBoxA(__FILE__, __LINE__, _debugVaStrA a)
#	define DBGAssert(a)			_debugAssert(__FILE__, __LINE__, a, #a)
#	define DBGAssertSz(a,b)		_debugAssert(__FILE__, __LINE__, a, b)
#	define DBGOutStr(a)			_debugOutStrA(a)
#	define DBGOutStrA(a)		_debugOutStrA(a)
#	define DBGOutStrW(a)		_debugOutStrW(a)
#	define DBGP(a)				_debugOutStrA(_debugVaStrA a)
#	define DBGPA(a)				_debugOutStrA(_debugVaStrA a)
#	define DBGPW(a)				_debugOutStrW(_debugVaStrW a)
#	define DBGGetErrorString(a)	_debugGetErrorString(a)
#	define DBGGetWinClass(a)	_debugGetWinClass(a)
#	define DBGGetWinText(a)		_debugGetWinText(a)
#else //!_DEBUG	//in Release version, these will disapear...
#	define DBGSetCallback(a,b)
#	define DBGEnableOutput(a)
#	define DBGIsOutputEnable()
#	define Dbg(a)
#	define DBGW(a)
#	define DBGA(a)
#	define DBGP(a)
#	define DBGPA(a)
#	define DBGPW(a)
#	define DBGAssert(a)
#	define DBGAssertSz(a,b)
#	define DBGMsgBox(a)
#	define DBGOutStr(a)
#	define DBGOutStrA(a)
#	define DBGOutStrW(a)
#	define DBGGetErrorString(a)
#	define DBGGetWinClass(a)
#	define DBGGetWinText(a)
#endif //_DEBUG


//----------------------------------------------------------------
//These function use variable argument, so we cannot define 
//"Normal" MACRO for them.
//so, Use inline function that do nothing if _DEBUG is NOT set.
//----------------------------------------------------------------
InlineFunc VOID DBGDoNothingA(LPSTR  lpstrFmt, ...) {lpstrFmt;}
InlineFunc VOID DBGDoNothingW(LPWSTR lpstrFmt, ...) {lpstrFmt;}
#ifdef _DEBUG 
#define DBGPrintf		_debugPrintfA
#define DBGPrintfA		_debugPrintfA
#define DBGPrintfW		_debugPrintfW
#else 
#define DBGPrintf		DBGDoNothingA
#define DBGPrintfA		DBGDoNothingA
#define DBGPrintfW		DBGDoNothingW
#endif


//----------------------------------------------------------------
//This is helper inline function for outputs debug string in 
//Retail version. if FORCE_DEBUG is defined this function works.
//Some time, we met bugs than occurs only retail version, 
//and would like to out debug message. 
//----------------------------------------------------------------
#ifdef FORCE_DEBUG
#include <stdarg.h>
//////////////////////////////////////////////////////////////////
// Function : FDbg
// Type     : InlineFunc VOID
// Purpose  : 
// Args     : 
//          : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Tue Jan 06 19:06:19 1998
//////////////////////////////////////////////////////////////////
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...)
{
	CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	OutputDebugStringA(szBuf);	
	return;
}
#else //FORCE_DEBUG
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...) {lpstrFmt;}
#endif

#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\dbg.cpp ===
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdarg.h>
#include "dbg.h"
#include <stdio.h>

static IsWinNT()
{
    static OSVERSIONINFO os;
    if(os.dwOSVersionInfoSize == 0) { 
        os.dwOSVersionInfoSize = sizeof(os);
        ::GetVersionEx(&os);
    }
    return (os.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

//----------------------------------------------------------------
//internal function prototype declare
//----------------------------------------------------------------
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath);
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath);
VOID   _debugPrintfA            (LPSTR  lpstrFmt, ...);
VOID   _debugPrintfW            (LPWSTR lpstrFmt, ...);

//----------------------------------------------------------------
// Global Data
//----------------------------------------------------------------
static LPFNDBGCALLBACKA g_lpfnDbgCBA;
static LPFNDBGCALLBACKW g_lpfnDbgCBW;
static BOOL g_fEnable=TRUE;
inline VOID ODStrW(LPWSTR lpwstr)
{
    if(g_fEnable) OutputDebugStringW(lpwstr);
}
inline VOID ODStrA(LPSTR lpstr)
{
    if(g_fEnable) OutputDebugStringA(lpstr);
}

//////////////////////////////////////////////////////////////////
// Function : _debugSetCallback
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPFNDBGCALLBACK lpfnDbgCallback 
// Return   : 
// DATE     : Tue Jan 06 12:42:36 1998
//////////////////////////////////////////////////////////////////
VOID _debugSetCallback(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW)
{
    g_lpfnDbgCBA = lpfnCBA;
    g_lpfnDbgCBW = lpfnCBW;
    return;
}

//////////////////////////////////////////////////////////////////
// Function : _debugSwitchOutput
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:35:55 1998
// Author   : 
//////////////////////////////////////////////////////////////////
VOID _debugEnableOutput(BOOL fEnable)
{
    g_fEnable = fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _debugIsOutputEnable
// Type     : VOID
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 18:00:52 1998
// Author   : 
//////////////////////////////////////////////////////////////////
BOOL _debugIsOutputEnable(VOID)
{
    return g_fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _debugOutStrA
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Tue Jan 06 12:29:39 1998
//////////////////////////////////////////////////////////////////
VOID _debugOutStrA(LPSTR lpstr)
{
    static BOOL fIn;
    ODStrA(lpstr);
#ifdef _CONSOLE
    printf(lpstr);
#endif

    if(g_lpfnDbgCBA) {
        if(fIn) { return; }
        fIn = TRUE;
        (*g_lpfnDbgCBA)(lpstr);
        fIn = FALSE;
    }
    return;
}

//////////////////////////////////////////////////////////////////
// Function : _debugOutStrW
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpwstr 
// Return   : 
// DATE     : Tue Jan 06 12:30:07 1998
//////////////////////////////////////////////////////////////////
VOID _debugOutStrW(LPWSTR lpwstr)
{
    static BOOL fIn;

    if(IsWinNT()) {
        ODStrW(lpwstr);
    }
    else {
        static CHAR szBuf[1024];
        ::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
        ODStrA(szBuf);
    }

#ifdef _CONSOLE
    static CHAR szBuf[1024];
    ::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
    printf(szBuf);
#endif
    if(g_lpfnDbgCBW) { 
        if(fIn) { return; }         
        fIn = TRUE;
        (*g_lpfnDbgCBW)(lpwstr);
        fIn = FALSE;
    }
    return;
}

////////////////////////////////////////////////////////
// Function: _debugA
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _debugA(LPSTR        lpstrFile, 
             INT        lineNo, 
             LPSTR        lpstrMsg)
{
    _debugPrintfA("(%12s:%4d) %s", 
                 GetFileTitleStrA(lpstrFile),
                 lineNo,
                 lpstrMsg);
    return;
}

//////////////////////////////////////////////////////////////////
// Function : _debugW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFile 
//          : INT lineNo 
//          : LPWSTR lpstrMsg 
// Return   : 
// DATE     : Mon Jan 05 15:10:41 1998
//////////////////////////////////////////////////////////////////
VOID _debugW(LPWSTR        lpstrFile, 
           INT            lineNo, 
           LPWSTR        lpstrMsg)
{
    _debugPrintfW(L"(%12s:%4d) %s", 
               GetFileTitleStrW(lpstrFile),
               lineNo,
               lpstrMsg);
    return;
}

//////////////////////////////////////////////////////////////////
// Function : _debugVaStrA
// Type     : LPSTR
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:09:53 1998
//////////////////////////////////////////////////////////////////
LPSTR _debugVaStrA(LPSTR lpstrFmt, ...)
{
    static CHAR chBuf[512];
    va_list ap;
    va_start(ap, lpstrFmt);
    wvsprintfA(chBuf, lpstrFmt, ap);
    va_end(ap);
    return chBuf;
}


////////////////////////////////////////////////////////
// Function : _debugVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _debugVaStrW(LPWSTR lpstrFmt, ...)
{
    static WCHAR wchBuf[512];
    va_list ap;
    va_start(ap, lpstrFmt);
    vswprintf(wchBuf, lpstrFmt, ap);    //Use C-RunTime Library for Win95
    va_end(ap);
    return wchBuf;
}


////////////////////////////////////////////////////////
// Function: _debugPrintfA
// Type    : VOID
// Purpose : variable args version of OutputDebugStringA
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _debugPrintfA(LPSTR lpstrFmt, ...)
{
    static CHAR szBuf[512];
    va_list ap;
    va_start(ap, lpstrFmt);
    wvsprintfA(szBuf, lpstrFmt, ap);
    va_end(ap);
    _debugOutStrA(szBuf);
    return;
}

//////////////////////////////////////////////////////////////////
// Function : _debugPrintfW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:11:24 1998
//////////////////////////////////////////////////////////////////
VOID _debugPrintfW(LPWSTR lpstrFmt, ...)
{
    static WCHAR wchBuf[512];
    va_list ap;
    va_start(ap, lpstrFmt);
    vswprintf(wchBuf, lpstrFmt, ap); //Use C-RunTime Library for Win95
    va_end(ap);
    _debugOutStrW(wchBuf);
    return;
}


//////////////////////////////////////////////////////////////////
// Function : _debugMulti2Wide
// Type     : LPWSTR
// Purpose  : return Unicode string from MBCS string
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Mon Jan 05 15:10:48 1998
//////////////////////////////////////////////////////////////////
LPWSTR _debugMulti2Wide(LPSTR lpstr)
{
    static WCHAR wchBuf[512];
    MultiByteToWideChar(CP_ACP, 
                        MB_PRECOMPOSED,
                        lpstr, -1,
                        (WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
    return wchBuf;
}


//////////////////////////////////////////////////////////////////
// Function : _debugGetWinClass
// Type     : LPSTR
// Purpose  : Get Windows class name string
//              ANSI version only.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:08:43 1998
//////////////////////////////////////////////////////////////////
LPSTR _debugGetWinClass(HWND hwnd)
{
#ifdef _CONSOLE
    return NULL;
#endif
    static CHAR szBuf[256];
    szBuf[0]=(char)0x00;
    GetClassNameA(hwnd, szBuf, sizeof(szBuf));
    return szBuf;

}

//////////////////////////////////////////////////////////////////
// Function : _debugGetWinText
// Type     : LPSTR
// Purpose  : Get Windows text(title) string
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:09:08 1998
//////////////////////////////////////////////////////////////////
LPSTR _debugGetWinText(HWND hwnd)
{
#ifdef _CONSOLE
    return NULL;
#endif
    static CHAR szBuf[256];
    szBuf[0]=(char)0x00;
    GetWindowTextA(hwnd, szBuf, sizeof(szBuf));
    return szBuf;
}

//////////////////////////////////////////////////////////////////
// Function : _debugMsgBoxA
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Thu Jan 08 12:31:03 1998
//////////////////////////////////////////////////////////////////
VOID _debugMsgBoxA(LPSTR lpstrFile,  INT lineNo, LPSTR lpstrMsg)
{
#ifdef _CONSOLE
    return;
#endif
    char szTmp[512];
    wsprintf(szTmp, "Debug Message Box (File: %s, Line: %4d)", 
               GetFileTitleStrA(lpstrFile), 
               lineNo);
    MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
}

VOID _debugAssert(LPSTR  lpstrFile,  INT lineNo, BOOL fOk, LPSTR lpstrMsg)
{
    if(fOk) {
        return; 
    }
    char szTmp[512];
    wsprintf(szTmp, "ASSERT (File: %s, Line: %4d)", 
             GetFileTitleStrA(lpstrFile), 
             lineNo);
    MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
    DebugBreak();
}

//////////////////////////////////////////////////////////////////
// Function : _debugGetErrorString
// Type     : LPSTR
// Purpose  : Convert Error(Got from GetLastError()) value to ERROR Message String
// Args     : 
//          : INT errorCode 
// Return   : 
// DATE     : Mon Jan 05 16:43:34 1998
//////////////////////////////////////////////////////////////////
LPSTR _debugGetErrorString(INT errorCode)
{
    static CHAR szBuf[512];
    INT count;
    szBuf[0] = (CHAR)0x00;
    count = wsprintf(szBuf, "[0x%08x]:", errorCode);
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   errorCode, 
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                   szBuf+count,
                   sizeof(szBuf)-1-count,
                   NULL );
    if(*(szBuf + count) != (CHAR)0x00) {
        int nLen = lstrlenA(szBuf);
        if((nLen - count) > 1) {
            szBuf[nLen - 1] = (CHAR)0x00;
        }
    }
    return szBuf;
}


//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrA
// Type     : static LPSTR
// Purpose  : Return File name string(remove folder)
// Args     : 
//          : LPSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:34:22 1998
//////////////////////////////////////////////////////////////////
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath)
{
    static CHAR szBuf[2];
    CHAR *pLast, *pTemp;
    if(!lpstrFilePath) {
        szBuf[0] = (CHAR)0x00;
        return szBuf;
    }
    pLast = lpstrFilePath + (lstrlenA(lpstrFilePath) - 1);
    for(pTemp = CharPrevA(lpstrFilePath, pLast); 
        (pTemp  != lpstrFilePath) && 
        (*pTemp != '\\')     &&
        (*pTemp != (CHAR)0x00); 
        pTemp = CharPrevA(lpstrFilePath, pTemp)) {
        ;
    }
    if(*pTemp == '\\') {
        return pTemp+1;
    }
    return lpstrFilePath;
}

//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrW
// Type     : static LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:38:19 1998
//////////////////////////////////////////////////////////////////
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath)
{
    static WCHAR szBuf[2];
    WCHAR *pLast, *pTemp;
    if(!lpstrFilePath) {
        szBuf[0] = (CHAR)0x00;
        return szBuf;
    }
    pLast = lpstrFilePath + (lstrlenW(lpstrFilePath) - 1);
    for(pTemp = pLast-1;
        (pTemp != lpstrFilePath) &&
        (*pTemp != L'\\')         &&
        (*pTemp != (WCHAR)0x0000);
        pTemp--) {
        ;
    }

    if(*pTemp == L'\\') {
        return pTemp+1;
    }
    return lpstrFilePath;
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\exgdiw.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "exgdiw.h"

#define ExMemAlloc(a)        GlobalAllocPtr(GHND, (a))
#define ExMemFree(a)        GlobalFreePtr((a))

static POSVERSIONINFO ExGetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

static BOOL ExIsWin95(VOID) 
{ 
    BOOL fBool;
    fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
            (ExGetOSVersion()->dwMajorVersion >= 4) &&
            (ExGetOSVersion()->dwMinorVersion < 10);

    return fBool;
}

#if 0
static BOOL ExIsWin98(VOID)
{
    BOOL fBool;
    fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
            (ExGetOSVersion()->dwMajorVersion >= 4) &&
            (ExGetOSVersion()->dwMinorVersion  >= 10);
    return fBool;
}


static BOOL ExIsWinNT4(VOID)
{
    BOOL fBool;
    fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (ExGetOSVersion()->dwMajorVersion >= 4) &&
            (ExGetOSVersion()->dwMinorVersion >= 0);
    return fBool;
}

static BOOL ExIsWinNT5(VOID)
{
    BOOL fBool;
    fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (ExGetOSVersion()->dwMajorVersion >= 4) &&
            (ExGetOSVersion()->dwMinorVersion >= 10);
    return fBool;
}

static BOOL ExIsWinNT(VOID)
{
    BOOL fBool;
    fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
    return fBool;
}
#endif

//inline static UINT W2MForWin95(HDC hDC, LPWSTR lpwstr, UINT wchCount,
// LPSTR lpstr, UINT chByteSize)
static UINT W2MForGDI(INT    codePage,
                      LPWSTR    lpwstr,
                      UINT    wchCount,
                      LPSTR    lpstr,
                      UINT    chByteSize)
{
    LPSTR lptmp;
    UINT byte;
    UINT mbyte;
    char defChar = 0x7F;
    BOOL fUseDefChar = TRUE;

    switch(codePage) {
    case 932:
    case 936:
    case 950:
    case 949:
        byte = ::WideCharToMultiByte(codePage,    WC_COMPOSITECHECK,
                                     lpwstr,    wchCount, 
                                     lpstr,        chByteSize,
                                     &defChar,    NULL);
        return byte;
    default:
        lptmp = lpstr;
        for(byte = 0; byte< wchCount; byte++) {
            defChar = 0x7F;
            mbyte = ::WideCharToMultiByte(codePage, WC_COMPOSITECHECK,
                                          lpwstr,1,
                                          lptmp,  chByteSize - byte,
                                          &defChar,
                                          &fUseDefChar);
            if(mbyte != 1){
                *lptmp = 0x7F; //defChar;
            }
            lptmp++;
            lpwstr++;
        }
        lpstr[byte]=0x00;
        return byte;
    }
}

static BOOL _ExExtTextOutWWithTrans(INT        codePage,
                                    HDC        hdc,
                                    int        X,            
                                    int        Y,            
                                    UINT     fuOptions,    
                                    CONST RECT *lprc,    
                                    LPWSTR     lpString,    
                                    UINT     cbCount,    
                                    CONST INT *lpDx)    
{
#ifndef UNDER_CE // always Unicode
    UINT bufsize = (cbCount + 1) * sizeof(WCHAR);
    BOOL  fRet;

    LPSTR lpstr = (LPSTR)ExMemAlloc(bufsize);
    if(!lpstr) {
        return 0;
    }
#if 0
    UINT byte = ::WideCharToMultiByte(codePage,
                                      WC_COMPOSITECHECK, 
                                      lpString, cbCount,
                                      lpstr,    bufsize, &defChar, 0);
#endif
    UINT byte = W2MForGDI(codePage, lpString, cbCount, lpstr, bufsize);
    fRet = ::ExtTextOutA(hdc,X,Y,fuOptions,lprc,lpstr, byte,lpDx);
    ExMemFree(lpstr);
    return fRet;
#else // UNDER_CE
    return ::ExtTextOutW(hdc,X,Y,fuOptions,lprc,lpString, cbCount,lpDx);
#endif // UNDER_CE
}
                             

//////////////////////////////////////////////////////////////////
// Function : ExExtTextOutWForWin95
// Type     : BOOL
// Purpose  : 
// Args     : 
//          : HDC hdc            // handle to device context.                           
//          : int X                // x-coordinate of reference point                     
//          : int Y                // y-coordinate of reference point                     
//          : UINT fuOptions    // text-output options.                                
//          : CONST RECT * lprc    // optional clipping and/or opaquing rectangle.        
//          :             
//          : LPWSTR lpString    // points to string.                                   
//          : UINT cbCount        // number of characters in string.                     
//          : CONST INT  * lpDx // pointer to array of intercharacter spacing values 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static BOOL ExExtTextOutWForWin95(HDC        hdc,        
                                  int        X,            
                                  int        Y,            
                                  UINT     fuOptions,    
                                  CONST RECT *lprc,    
                                  LPWSTR     lpString,    
                                  UINT     cbCount,    
                                  CONST INT *lpDx)    
{
    //UINT bufsize = (cbCount + 1) * sizeof(WCHAR);

    TEXTMETRIC tm;
    ::GetTextMetrics(hdc, &tm);
    //----------------------------------------------------------------
    //980730:By ToshiaK
    //Unicode GDI in Win95 has Bugs.
    //1. if try to use ExtTextOutW() with FE Unicode code point, with
    //   som ANSI or SYMBOL charset font, GPF occurs.
    //2. ExtTextOutW() cannot draw EUDC code. (Must use ExtTextOutA() to draw)
    //----------------------------------------------------------------
    LANGID langId = ::GetSystemDefaultLangID();
    switch(tm.tmCharSet) {
    case SHIFTJIS_CHARSET:
        if(PRIMARYLANGID(langId) == LANG_JAPANESE) {
            return _ExExtTextOutWWithTrans(932,
                                           hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
        }
        return ::ExtTextOutW(hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx); 
        break;
    case GB2312_CHARSET:
        if(langId == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)) {
            return _ExExtTextOutWWithTrans(936,
                                           hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
        }
        return ::ExtTextOutW(hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx); 
        break;
    case CHINESEBIG5_CHARSET:
        if(langId == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)) {
            return _ExExtTextOutWWithTrans(950,
                                           hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
        }
        return ::ExtTextOutW(hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx); 
        break;
    case HANGEUL_CHARSET:
        if(PRIMARYLANGID(langId) == LANG_KOREAN) {
            return _ExExtTextOutWWithTrans(949,
                                           hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
        }
        return ::ExtTextOutW(hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx); 
        break;
    case SYMBOL_CHARSET:
        return _ExExtTextOutWWithTrans(1252,
                                       hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
        break;
    default:
        {
            CHARSETINFO info;
            if(::TranslateCharsetInfo((DWORD *)tm.tmCharSet,
                                      &info,
                                      TCI_SRCCHARSET)) {
                return _ExExtTextOutWWithTrans(info.ciACP,
                                               hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
            }
            else {
                return _ExExtTextOutWWithTrans(CP_ACP,
                                               hdc,X,Y,fuOptions,lprc,lpString,cbCount,lpDx);
            }
        }
    }
}

static BOOL _ExGetTextExtentPoint32WWithTrans(INT codePage,
                                              HDC hdc,
                                              LPWSTR wz,        
                                              int    cch,        
                                              LPSIZE lpSize)    
{
#ifndef UNDER_CE // always Unicode
    UINT bufsize = (cch + 1) * sizeof(WCHAR);
    LPSTR lpstr = (LPSTR)ExMemAlloc(bufsize);
    BOOL  fRet;
    //CHAR defChar = 0x7F; 
    if(!lpstr) {
        return 0;
    }
    UINT byte = W2MForGDI(codePage, wz, cch, lpstr, bufsize);
#if 0
    UINT byte = ::WideCharToMultiByte(codePage,
                                      WC_COMPOSITECHECK, 
                                      wz, cch,
                                      lpstr, bufsize,
                                      &defChar, 0);
#endif
    fRet = ::GetTextExtentPoint32A(hdc, lpstr, byte, lpSize);
    ExMemFree(lpstr);
    return fRet;
#else // UNDER_CE
    return ::GetTextExtentPoint32W(hdc, wz, cch, lpSize);
#endif // UNDER_CE
}
//////////////////////////////////////////////////////////////////
// Function    :    ExGetTextExtentPoint32WForWin95
// Type        :    inline BOOL
// Purpose    :    
// Args        :    
//            :    HDC    hdc                //handle of device context.            
//            :    LPWSTR    wz            //address of text string.              
//            :    int    cch                //number of characters in string.      
//            :    LPSIZE    lpSize        //address of structure for string size.    
// Return    :    
// DATE        :    Thu Jul 30 20:31:05 1998
// Histroy    :    
//////////////////////////////////////////////////////////////////
static BOOL ExGetTextExtentPoint32WForWin95(HDC    hdc,        
                                            LPWSTR wz,        
                                            int    cch,        
                                            LPSIZE lpSize)    
{
    TEXTMETRIC tm;
    ::GetTextMetrics(hdc, &tm);
    LANGID langId = ::GetSystemDefaultLangID();
    switch(tm.tmCharSet) {
    case SHIFTJIS_CHARSET:
        if(PRIMARYLANGID(langId) == LANG_JAPANESE) {
            return _ExGetTextExtentPoint32WWithTrans(932, hdc, wz, cch,lpSize);
        }
        return ::GetTextExtentPoint32W(hdc, wz, cch, lpSize);
        break;
    case GB2312_CHARSET:
        if(langId == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)) {
            return _ExGetTextExtentPoint32WWithTrans(936, hdc, wz, cch,lpSize);
        }
        return ::GetTextExtentPoint32W(hdc, wz, cch, lpSize);
        break;
    case CHINESEBIG5_CHARSET:
        if(langId == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)) {
            return _ExGetTextExtentPoint32WWithTrans(950, hdc, wz, cch,lpSize);
        }
        return ::GetTextExtentPoint32W(hdc, wz, cch, lpSize);
        break;
    case HANGEUL_CHARSET:
        if(PRIMARYLANGID(langId) == LANG_KOREAN) {
            return _ExGetTextExtentPoint32WWithTrans(949, hdc, wz, cch,lpSize);
        }
        return ::GetTextExtentPoint32W(hdc, wz, cch, lpSize);
        break;
    case SYMBOL_CHARSET:
        return _ExGetTextExtentPoint32WWithTrans(1252, hdc, wz, cch,lpSize);
        break;
    default:
        {
            CHARSETINFO info;
            if(::TranslateCharsetInfo((DWORD *)tm.tmCharSet, &info, TCI_SRCCHARSET)) {
                return _ExGetTextExtentPoint32WWithTrans(info.ciACP, hdc, wz, cch,lpSize);
            }
            else {
                return _ExGetTextExtentPoint32WWithTrans(CP_ACP, hdc, wz, cch,lpSize);
            }
        }
        break;
    }
    
}

//----------------------------------------------------------------
//public Function
//----------------------------------------------------------------
BOOL ExExtTextOutW(HDC        hdc,        // handle to device context.
                   int        X,            // x-coordinate of reference point
                   int        Y,            // y-coordinate of reference point
                   UINT     fuOptions,    // text-output options.
                   CONST RECT *lprc,    // optional clipping and/or opaquing rectangle.
                   LPWSTR     lpString,    // points to string.
                   UINT     cbCount,    // number of characters in string.
                   CONST INT *lpDx)     // pointer to array of intercharacter spacing values );
{
    if(ExIsWin95()) {
        return ExExtTextOutWForWin95(hdc, X, Y, fuOptions, lprc, lpString, cbCount, lpDx);
    }
    return ExtTextOutW(hdc, X, Y, fuOptions, lprc, lpString, cbCount, lpDx);
}

BOOL ExGetTextExtentPoint32W(HDC    hdc,        // handle of device context.
                             LPWSTR wz,        // address of text string.
                             int    cch,        // number of characters in string.
                             LPSIZE lpSize)    // address of structure for string size.
{
    BOOL fRet;
    //if char count is 0
    if(!wz) {
        lpSize->cx = lpSize->cy = 0;
        return 0;
    }
    if(cch == 0) {
#ifndef UNDER_CE
        fRet = GetTextExtentPointA(hdc, " ", 1, lpSize);
#else // UNDER_CE
        fRet = GetTextExtentPoint(hdc, TEXT(" "), 1, lpSize);
#endif // UNDER_CE
        lpSize->cx = 0;
        return (fRet);
    }
    if(ExIsWin95()) {
        return ExGetTextExtentPoint32WForWin95(hdc, wz, cch, lpSize);
    }
    return GetTextExtentPoint32W(hdc, wz, cch, lpSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hanja.h ===
/****************************************************************************
	HANJA.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Hanja conversion and dictionary lookup functions. Dictionary index is 
	stored as globally shared memory.
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_HANJA_H__INCLUDED_)
#define _HANJA_H__INCLUDED_

#include "LexHeader.h"

extern BOOL EnsureHanjaLexLoaded();
extern BOOL CloseLex();
BOOL GetMeaningAndProunc(WCHAR wch, LPWSTR lpwstrTip, INT cchMax);

#endif // !defined (_HANJA_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\guids.h ===
//////////////////////////////////////////////////////////////////
// File     : guids.h
// Purpose  : define multibox Class ID & Interface Id
// Date     : Tue Aug 04 16:01:13 1998
// Author   : ToshiaK
//
// History	: switch Class id & interface id with Fareast define.
//			  CLSID is CLSID_ImePadApplet_MultiBox.
//			  IID is IID_MultiBox.
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef _GUIDS_H_
#define _GUIDS_H_
#include <objbase.h>

//----------------------------------------------------------------
// Korean version CLSID & IID
//----------------------------------------------------------------
#ifdef FE_KOREAN
// IME 2000 GUID for Office 10
// {35CC8480-4FB1-11d3-A5DA-00C04F88249B}
// DEFINE_GUID(CLSID_ImePadApplet_MultiBox, 
// 0x35cc8480, 0x4fb1, 0x11d3, 0xa5, 0xda, 0x0, 0xc0, 0x4f, 0x88, 0x24, 0x9b);

// 12/11/2000 Changed GUID for Whistler
// {35CC8482-4FB1-11d3-A5DA-00C04F88249B}
DEFINE_GUID(CLSID_ImePadApplet_MultiBox, 
	0x35cc8482, 0x4fb1, 0x11d3, 0xa5, 0xda, 0x0, 0xc0, 0x4f, 0x88, 0x24, 0x9b);


// {35CC8483-4FB1-11d3-A5DA-00C04F88249B}
DEFINE_GUID(IID_MultiBox, 
0x35cc8483, 0x4fb1, 0x11d3, 0xa5, 0xda, 0x0, 0xc0, 0x4f, 0x88, 0x24, 0x9b);

//----------------------------------------------------------------
// Japanese version CLSID & IID
//----------------------------------------------------------------
#elif FE_JAPANESE
// {AC0875C1-CFAF-11d1-AFF2-00805F0C8B6D}
DEFINE_GUID(CLSID_ImePadApplet_MultiBox,
0xac0875c1, 0xcfaf, 0x11d1, 0xaf, 0xf2, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);

// {AC0875C2-CFAF-11d1-AFF2-00805F0C8B6D}
DEFINE_GUID(IID_MultiBox,
0xac0875c2, 0xcfaf, 0x11d1, 0xaf, 0xf2, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);
//----------------------------------------------------------------
// P.R.C version CLSID & IID
//----------------------------------------------------------------
#elif FE_CHINESE_SIMPLIFIED //==== P.R.C version.
// {454E7CD0-2B69-11d2-B004-00805F0C8B6D}
DEFINE_GUID(CLSID_ImePadApplet_MultiBox, 
0x454e7cd0, 0x2b69, 0x11d2, 0xb0, 0x4, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);
// {454E7CD1-2B69-11d2-B004-00805F0C8B6D}
DEFINE_GUID(IID_MultiBox, 
0x454e7cd1, 0x2b69, 0x11d2, 0xb0, 0x4, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);

#else  //==== english verson(?)
// {454E7CD2-2B69-11d2-B004-00805F0C8B6D}
DEFINE_GUID(CLSID_ImePadApplet_MultiBox,
0x454e7cd2, 0x2b69, 0x11d2, 0xb0, 0x4, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);
// {454E7CD3-2B69-11d2-B004-00805F0C8B6D}
DEFINE_GUID(IID_MultiBox,
0x454e7cd3, 0x2b69, 0x11d2, 0xb0, 0x4, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);
#endif

#endif //_GUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hlpidkor.h ===
// Context Help IDs for Korean HW Applet

#define IDH_TOC_HW					3299
//
#define IDH_PAD_HW_INPUT_BOX		3200
#define IDH_PAD_HW_INPUT_INPUT		3201
#define IDH_PAD_HW_INPUT_RECOG		3202
#define IDH_PAD_HW_INPUT_CLEAR		3203
#define IDH_PAD_HW_INPUT_PROP		3204
#define IDH_PAD_HW_SEARCH_BOX		3205
#define IDH_PAD_HW_SEARCH_LIST		3206
#define IDH_PAD_HW_SEARCH_SEARCH	3207
#define IDH_PAD_HW_SEARCH_RECOG		3208
#define IDH_PAD_HW_SEARCH_REVERT	3209	
#define IDH_PAD_HW_SEARCH_CLEAR		3210
//#define IDH_PAD_HW_SEARCH_DETAIL	3211


#define IDH_PAD_HW_PROP_TIME		3220
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\helpid.h ===
/////////////////////////////////////////////////////////////
//
//    File Name : HELPID.H
//
//    Purpose   : IME pbh  Avbg ContextHelpID`
//
//    Comments  : IME pbh 3000 nAAvbgA100XVB
//                 Avbg 3200 `B
//
//    History   : 970718 created for 98 / 970725 added TOC
//
/////////////////////////////////////////////////////////////
//=======================================================
//IME pbh -  Avbg
//=======================================================
//
#define IDH_TOC_HW			3299		//wv
//
#define IDH_PAD_HW_INPUT_BOX		3200		//-{bNX(picture)
#define IDH_PAD_HW_INPUT_INPUT		3201		//-{^(button)
#define IDH_PAD_HW_INPUT_RECOG		3202		//-F{^(button)
#define IDH_PAD_HW_INPUT_CLEAR		3203		//-{^(button)
#define IDH_PAD_HW_INPUT_PROP		3204		//-vpeB{^(button)
#define IDH_PAD_HW_SEARCH_BOX		3205		//-{bNX(picture)
#define IDH_PAD_HW_SEARCH_LIST		3206		//-Xg(list)
#define IDH_PAD_HW_SEARCH_SEARCH		3207		//-{^(button)
#define IDH_PAD_HW_SEARCH_RECOG		3208		//-F{^(button)
#define IDH_PAD_HW_SEARCH_REVERT		3209		//-{^(button)
#define IDH_PAD_HW_SEARCH_CLEAR		3210		//-{^(button)
#define IDH_PAD_HW_SEARCH_DETAIL		3211		//-/{^(button)

//[vpeB] _CAO@{bNX
#define IDH_PAD_HW_PROP_TIME		3220		//[FJn] {bNX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hlpidjpn.h ===
/////////////////////////////////////////////////////////////
//
//    File Name : HELPID.H
//
//    Purpose   : IME pbh  Avbg ContextHelpID`
//
//    Comments  : IME pbh 3000 nAAvbgA100XVB
//                 Avbg 3200 `B
//
//    History   : 970718 created for 98 / 970725 added TOC
//
/////////////////////////////////////////////////////////////
//=======================================================
//IME pbh -  Avbg
//=======================================================
//
#define IDH_TOC_HW			3299		//wv
//
#define IDH_PAD_HW_INPUT_BOX		3200		//-{bNX(picture)
#define IDH_PAD_HW_INPUT_INPUT		3201		//-{^(button)
#define IDH_PAD_HW_INPUT_RECOG		3202		//-F{^(button)
#define IDH_PAD_HW_INPUT_CLEAR		3203		//-{^(button)
#define IDH_PAD_HW_INPUT_PROP		3204		//-vpeB{^(button)
#define IDH_PAD_HW_SEARCH_BOX		3205		//-{bNX(picture)
#define IDH_PAD_HW_SEARCH_LIST		3206		//-Xg(list)
#define IDH_PAD_HW_SEARCH_SEARCH		3207		//-{^(button)
#define IDH_PAD_HW_SEARCH_RECOG		3208		//-F{^(button)
#define IDH_PAD_HW_SEARCH_REVERT		3209		//-{^(button)
#define IDH_PAD_HW_SEARCH_CLEAR		3210		//-{^(button)
#define IDH_PAD_HW_SEARCH_DETAIL		3211		//-/{^(button)

//[vpeB] _CAO@{bNX
#define IDH_PAD_HW_PROP_TIME		3220		//[FJn] {bNX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hanja.cpp ===
/****************************************************************************
    HANJA.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Hanja conversion and dictionary lookup functions. Dictionary index is 
    stored as globally shared memory.
    
    History:
    26-APR-1999 cslim       Modified for Multibox Applet Tooltip display
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include "hwxobj.h"
#include "lexheader.h"
#include "hanja.h"
#include "common.h"
#include "immsec.h"
#include "dbg.h"

// NT5 Globally shared memory. 
const TCHAR IMEKR_LEX_SHAREDDATA_MUTEX_NAME[]        = TEXT("ImeKrLex.Mutex");
const TCHAR IMEKR_LEX_SHAREDDATA_NAME[]              = TEXT("ImeKrLexHanjaToHangul.SharedMemory");


UINT   vuNumofK0=0, vuNumofK1=0;
WCHAR  vwcHangul=0;

// Private data
static BOOL   vfLexOpen = FALSE;
static HANDLE vhLex=0;
static HANDLE vhLexIndexTbl=0;
static UINT   vuNumOfHanjaEntry=0;
static DWORD  viBufferStart=0;    // seek point

// Private functions
static BOOL OpenLex();
//static VOID ClearHanjaSenseArray();
static INT SearchHanjaIndex(WCHAR wHChar, HanjaToHangulIndex *pLexIndexTbl);

BOOL EnsureHanjaLexLoaded()
{
    _DictHeader *pLexHeader;
    HKEY        hKey;
    DWORD         dwReadBytes;
    CHAR         szLexFileName[MAX_PATH], szLexPathExpanded[MAX_PATH];
    DWORD        dwCb, dwType;
    
    if (vfLexOpen)
        return TRUE;

    // Get Lex file path
    szLexFileName[0] = 0;
    szLexPathExpanded[0] = 0;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szIMERootKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        dwCb = sizeof(szLexFileName);
        dwType = REG_SZ;

        if (RegQueryValueEx(hKey, g_szDictionary, NULL, &dwType, (LPBYTE)szLexFileName, &dwCb) == ERROR_SUCCESS)
            ExpandEnvironmentStrings(szLexFileName, szLexPathExpanded, sizeof(szLexPathExpanded));
        RegCloseKey(hKey);
        }

    DBGAssert(szLexPathExpanded[0] != 0);
    if (szLexPathExpanded[0] == 0)
        return FALSE;

    vhLex = CreateFile(szLexPathExpanded, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
    if (vhLex==INVALID_HANDLE_VALUE) 
        {
        DBGAssert(0);
        return FALSE;
        }

    pLexHeader = new _DictHeader;
    if (!pLexHeader)
        return FALSE;

    if (ReadFile(vhLex, pLexHeader, sizeof(_DictHeader), &dwReadBytes, 0) == 0 || (dwReadBytes != sizeof(_DictHeader)))
        {
        DBGAssert(0);
        return FALSE;
        }

    // Set member vars
    vuNumOfHanjaEntry = pLexHeader->uiNumofHanja;
    viBufferStart      = pLexHeader->iBufferStart;

    if (pLexHeader->Version < LEX_VERSION || pLexHeader->Version > LEX_COMPATIBLE_VERSION_LIMIT ) 
        {
        delete pLexHeader;
        DBGAssert(0);
        return FALSE;
        }
        
    if (lstrcmpA(pLexHeader->COPYRIGHT_HEADER, COPYRIGHT_STR)) 
        {
        delete pLexHeader;
        DBGAssert(0);
        return FALSE;
        }

    // Read Index table
    SetFilePointer(vhLex, pLexHeader->iHanjaToHangulIndex, 0, FILE_BEGIN);    
    delete pLexHeader;

    return OpenLex();
}

__inline BOOL DoEnterCriticalSection(HANDLE hMutex)
{
    if(WAIT_FAILED==WaitForSingleObject(hMutex, 3000))    // Wait 3 seconds
        return(FALSE);
    return(TRUE);
}

BOOL OpenLex()
{
    BOOL                  fRet = FALSE;
    HanjaToHangulIndex* pHanjaToHangulIndex;
    HANDLE                 hMutex;
    DWORD                 dwReadBytes;
    
    ///////////////////////////////////////////////////////////////////////////
    // Mapping Lex file
    // The dictionary index is shared data between all IME instance
    hMutex=CreateMutex(GetIMESecurityAttributes(), FALSE, IMEKR_LEX_SHAREDDATA_MUTEX_NAME);

    if (hMutex != NULL)
        {
        if (DoEnterCriticalSection(hMutex) == FALSE)
            goto ExitOpenLexCritSection;

        vhLexIndexTbl = OpenFileMapping(FILE_MAP_READ, TRUE, IMEKR_LEX_SHAREDDATA_NAME);

        if(vhLexIndexTbl)
            {
            Dbg(("CHanja::OpenLex() - File mapping already exists"));
            fRet = TRUE;
            }
        else
            {
            // if no file mapping exist
            vhLexIndexTbl    = CreateFileMapping(INVALID_HANDLE_VALUE, 
                                            GetIMESecurityAttributes(), 
                                            PAGE_READWRITE, 
                                            0, 
                                            sizeof(HanjaToHangulIndex)*(vuNumOfHanjaEntry),
                                            IMEKR_LEX_SHAREDDATA_NAME);
        
            if (vhLexIndexTbl) 
                {
                Dbg(("CHanja::OpenLex() - File mapping Created"));
                pHanjaToHangulIndex = (HanjaToHangulIndex*)MapViewOfFile(vhLexIndexTbl, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
                if (!pHanjaToHangulIndex)
                    goto ExitOpenLexCritSection;

                if (ReadFile(vhLex, pHanjaToHangulIndex, sizeof(HanjaToHangulIndex)*(vuNumOfHanjaEntry), &dwReadBytes, 0) != 0 &&
                	dwReadBytes == sizeof(HanjaToHangulIndex)*(vuNumOfHanjaEntry))
                	{
                    fRet = TRUE;
                	}
                else
                	{
                    fRet = FALSE;
                	}
                	
                UnmapViewOfFile(pHanjaToHangulIndex);
                }
        #ifdef _DEBUG
            else
                DBGAssert(0);
        #endif
            }
            
    ExitOpenLexCritSection:
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
        }
    
    FreeIMESecurityAttributes();

    vfLexOpen = fRet;
    return fRet;
}

BOOL CloseLex()
{
    //ClearHanjaSenseArray();
    
    if (vhLexIndexTbl) 
        {
        CloseHandle(vhLexIndexTbl);
        vhLexIndexTbl = 0;
        }

    if (vhLex) 
        {
        CloseHandle(vhLex);
        vhLex = 0;
        }

    vfLexOpen =  FALSE;
    return TRUE;
}

BOOL GetMeaningAndProunc(WCHAR wch, LPWSTR lpwstrTip, INT cchMax)
{
    HanjaToHangulIndex* pHanjaToHangulIndex;
    INT                 iMapHanjaInfo;
    WCHAR               wcHanja;
    BYTE                cchMeaning = 0;
    WCHAR                wszMeaning[MAX_SENSE_LENGTH];
    DWORD                dwReadBytes;
    BOOL                   fRet = FALSE;

    Dbg(("GetMeaningAndProunc"));

    if (!EnsureHanjaLexLoaded()) 
        return FALSE;

    pHanjaToHangulIndex = (HanjaToHangulIndex*)MapViewOfFile(vhLexIndexTbl, FILE_MAP_READ, 0, 0, 0);
    if (!pHanjaToHangulIndex) 
        {
        DBGAssert(0);    
        return FALSE;
        }

    // Search index
    if ((iMapHanjaInfo = SearchHanjaIndex(wch, pHanjaToHangulIndex)) >= 0)
        {
        // Seek to mapping Hanja
        SetFilePointer(vhLex, viBufferStart + pHanjaToHangulIndex[iMapHanjaInfo].iOffset, 0, FILE_BEGIN);    

        // Read Hanja Info
        if (ReadFile(vhLex, &wcHanja, sizeof(WCHAR), &dwReadBytes, 0) == 0)
        	{
        	goto GetMeaningAndProuncExit;
        	}
        DBGAssert(wch == wcHanja);
        if (ReadFile(vhLex, &cchMeaning, sizeof(BYTE), &dwReadBytes, 0) == 0)
        	{
       		goto GetMeaningAndProuncExit;
        	}
        
        if (cchMeaning)
        	{
	        if (ReadFile(vhLex, wszMeaning, cchMeaning, &dwReadBytes, 0) == 0)
    	    	{
       			goto GetMeaningAndProuncExit;
        		}
        	}
        wszMeaning[cchMeaning>>1] = L'\0';

        swprintf(lpwstrTip,    L"%s %c\nU+%04X", wszMeaning, pHanjaToHangulIndex[iMapHanjaInfo].wchHangul, wch);
        
        fRet = TRUE;
        }

GetMeaningAndProuncExit:
    UnmapViewOfFile(pHanjaToHangulIndex);
    return fRet;
}

INT SearchHanjaIndex(WCHAR wHChar, HanjaToHangulIndex *pLexIndexTbl)
{
    int iHead = 0, iTail = vuNumOfHanjaEntry-1, iMid;

    while (iHead <= iTail)
        {
        iMid = (iHead + iTail) >> 1;

        Dbg(("SearchHanjaIndex iMid=%d, pLexIndexTbl[iMid].wchHanja = 0x%04X", iMid, pLexIndexTbl[iMid].wchHanja));

        if (pLexIndexTbl[iMid].wchHanja > wHChar)
            iTail = iMid - 1;
        else 
            if (pLexIndexTbl[iMid].wchHanja < wHChar)
                iHead = iMid + 1;
            else 
                return (iMid);
        }

    return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hlpideng.h ===
//////////////////////////////////////////////////////////////////
// File     : hlpideng.h
// Purpose  : Handwrinting help id define.
// 
// 
// Date     : Tue Aug 04 05:25:51 1998
// Author   : 
//
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
//----------------------------------------------------------------
//980803: ToshiaK. No HelpId exits in this version
//----------------------------------------------------------------
//End of FILE.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxapp.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include "memmgr.h"
#include "hwxapp.h"
#include "hwxobj.h"
#include "resource.h"
#include "guids.h"         //980408:ToshiaK
#include "hwxfe.h"        //980803 new: By ToshiaK
#include "dbg.h"
#include "ipoint1.h"    //990507:HiroakiK for IPINS_CURRENT
#ifdef UNDER_CE // Windows CE Stub for unsupported APIs
#include "stub_ce.h"
#endif // UNDER_CE

STDMETHODIMP CApplet::QueryInterface(REFIID refiid, VOID **ppv)
{
    if(refiid == IID_IUnknown) {
        *ppv = static_cast<IImePadApplet *>(this);
    }
    else if(refiid == IID_IImeSpecifyApplets) {
        *ppv = static_cast<IImeSpecifyApplets *>(this);
    }
    else if(refiid == IID_MultiBox) {
        *ppv = static_cast<IImePadApplet *>(this);
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CApplet::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CApplet::Release(void)
{
    if(InterlockedDecrement(&m_cRef) == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

//////////////////////////////////////////////////////////////////
// Function : CApplet::GetAppletIIDList
// Type     : STDMETHODIMP
// Purpose  : Enhancement for IME98A
// Args     : 
//          : REFIID refiid 
//          : LPAPPLETIDLIST lpIIDList 
// Return   : 
// DATE     : Thu Apr 09 22:46:04 1998
// Author   : ToshiaK
//////////////////////////////////////////////////////////////////
STDMETHODIMP CApplet::GetAppletIIDList(REFIID            refiid,
                                       LPAPPLETIDLIST    lpIIDList)
{
    if(refiid == IID_IImePadApplet) {
        lpIIDList->pIIDList = (IID *)::CoTaskMemAlloc(sizeof(IID)*1);
        if(!lpIIDList->pIIDList) {
            return E_OUTOFMEMORY;
        }
        lpIIDList->pIIDList[0] = IID_MultiBox;
        lpIIDList->count       = 1;
        return S_OK;
    }
    return E_NOINTERFACE;
}

CApplet::CApplet()
{
    m_cRef        = 1; //ToshiaK
    m_pPad        = NULL;
    m_bInit        = FALSE;
    m_hInstance = NULL;
    m_pCHwxInkWindow = NULL;
}

CApplet::CApplet(HINSTANCE hInst)
{
    m_cRef        = 1;
    m_pPad        = NULL;
    m_bInit        = FALSE;
    m_hInstance = hInst;
    m_pCHwxInkWindow = NULL;
}

CApplet::~CApplet()
{            
    // should call Terminate() before deleting CApplet object
}

// detect if this IME instance is attached to a 16-bit program
DWORD WINAPI Dummy(LPVOID pv)
{
     return 0;
    UNREFERENCED_PARAMETER(pv);
}

//----------------------------------------------------------------
//ToshiaK: temporary Code
//----------------------------------------------------------------
static INT GetPlatform(VOID)
{
    static INT platForm;
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO verInfo;
    if(fFirst) {
        verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &verInfo) ) {
            fFirst = FALSE;
        } 
        platForm = verInfo.dwPlatformId;
    }
    return platForm;
}

BOOL IsWindowsNT(VOID)
{
#ifndef UNDER_CE // Windows CE
    if(GetPlatform() == VER_PLATFORM_WIN32_NT) {
        return TRUE;
    }
    return FALSE;
#else // UNDER_CE
    return TRUE;
#endif // UNDER_CE
}

STDMETHODIMP CApplet::Initialize(IUnknown *pIImePad)
{
    HRESULT hr = S_OK;
    if ( !m_bInit )
    {
        //for IME98A Enhancement: By ToshiaK
        pIImePad->QueryInterface(IID_IImePad, (LPVOID *)&m_pPad);

        // support both WINDOWS95 and WINDOWS NT
        //----------------------------------------------------------------
        //ToshiaK: 970715
        //opengl32.dll is included in Memphis
        //below code recognize platform as WinNT in Memphis environment
        //----------------------------------------------------------------
        BOOL bNT = IsWindowsNT();
        HANDLE hLib;

        // see if this IME is attached to a 16 bit program
        BOOL b16 = FALSE;
        //DWORD dID = 0;
        hLib = NULL;
//        hLib = CreateThread(NULL,0,Dummy,NULL,CREATE_SUSPENDED,&dID);
#ifdef BUGBUG
        hLib = CreateThread(NULL,0,Dummy,NULL,0,&dID);
        if ( !hLib )
               b16 = TRUE;
        else
            CloseHandle(hLib);
#endif
        b16 = CHwxFE::Is16bitApplication();
        Dbg(("b16 %d\n", b16));

    //    GetModuleFileName(m_hInstance, tchPath, sizeof(tchPath)/sizeof(tchPath[0]));

        m_pCHwxInkWindow = (CHwxInkWindow *)new CHwxInkWindow(bNT,b16,this,m_hInstance);
        if ( !m_pCHwxInkWindow )
        {
            m_pPad->Release();
            m_pPad = NULL;
            hr = S_FALSE;
        }
        if ( hr == S_OK )
        {
            if ( !m_pCHwxInkWindow->Initialize(TEXT("CHwxInkWindow")) )
            {
                m_pPad->Release();
                m_pPad = NULL;
                delete m_pCHwxInkWindow;
                m_pCHwxInkWindow = NULL;
                hr = S_FALSE;
            }
            else
            {
                m_bInit = TRUE;
            }
        }
    }
    return hr;
}

STDMETHODIMP CApplet::Terminate(VOID)
{
    Dbg(("CApplet::Terminate START\n"));
    if ( m_pPad )
    {
        m_pPad->Release();
        m_pPad = NULL;
    }
    m_hInstance = NULL;
    m_bInit = FALSE;
    if ( m_pCHwxInkWindow )
    {
        m_pCHwxInkWindow->Terminate();
        delete m_pCHwxInkWindow;
        m_pCHwxInkWindow = NULL;
    }
    return S_OK;
}

STDMETHODIMP CApplet::GetAppletConfig(LPIMEAPPLETCFG lpAppletCfg)
{
    //----------------------------------------------------------------
    //980803: by ToshiaKfor FarEast merge.
    //----------------------------------------------------------------
    CHwxFE::GetTitleStringW(m_hInstance,
                            lpAppletCfg->wchTitle,
                            sizeof(lpAppletCfg->wchTitle)/sizeof(lpAppletCfg->wchTitle[0]));
    BOOL b16 = FALSE;
    //DWORD dID = 0;
    //HANDLE hLib = NULL;


#ifdef BUGBUG //981120
    hLib = CreateThread(NULL,0,Dummy,NULL,0,&dID);
    if ( !hLib )
          b16 = TRUE;
    else
        CloseHandle(hLib);
#endif
    //we have to use this one to check this.
    b16 = CHwxFE::Is16bitApplication();

#ifdef FE_JAPANESE
    lpAppletCfg->hIcon = (HICON)LoadImage(m_hInstance,
                                          MAKEINTRESOURCE(IDI_HWXPAD),
                                          IMAGE_ICON,16,16,LR_DEFAULTCOLOR);
#elif  FE_KOREAN
    lpAppletCfg->hIcon = (HICON)LoadImage(m_hInstance,
                                          MAKEINTRESOURCE(IDI_HWXPADKO),
                                          IMAGE_ICON,16,16,LR_DEFAULTCOLOR);
#elif FE_CHINESE_SIMPLIFIED
    lpAppletCfg->hIcon = (HICON)LoadImage(m_hInstance,
                                          MAKEINTRESOURCE(IDI_HWXPADSC),
                                          IMAGE_ICON,16,16,LR_DEFAULTCOLOR);
#endif
    lpAppletCfg->dwConfig = (!b16 ? IPACFG_PROPERTY : 0) | IPACFG_HELP;
    lpAppletCfg->iCategory        = IPACID_HANDWRITING;    //970812:ToshiaK

    //----------------------------------------------------------------
    //000804: Satori #2286. for Check Applet's main language to invoke help.
    //----------------------------------------------------------------
#ifdef FE_JAPANESE
    lpAppletCfg->langID = MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT);
#elif FE_KOREAN
    lpAppletCfg->langID = MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT);
#elif FE_CHINESE_SIMPLIFIED
    lpAppletCfg->langID = MAKELANGID(LANG_CHINESE,  SUBLANG_CHINESE_SIMPLIFIED);
#endif

    return S_OK;
}

STDMETHODIMP CApplet::CreateUI(HWND hwndParent,
                               LPIMEAPPLETUI lpImeAppletUI)
{
    HRESULT hr = S_OK;

    if( m_pCHwxInkWindow )  
    {
        if ( !m_pCHwxInkWindow->GetInkWindow() )
        {
            if ( !m_pCHwxInkWindow->CreateUI(hwndParent) )
            {
                hr = S_FALSE;
            }
        }
        lpImeAppletUI->dwStyle = IPAWS_SIZINGNOTIFY;
        lpImeAppletUI->hwnd   = m_pCHwxInkWindow->GetInkWindow();
        lpImeAppletUI->width  = m_pCHwxInkWindow->GetInkWindowWidth() + 3*Box_Border;
        lpImeAppletUI->height = m_pCHwxInkWindow->GetInkWindowHeight();
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

STDMETHODIMP CApplet::Notify(IUnknown   *pImePad,
                             INT        notify,
                             WPARAM    wParam,
                             LPARAM    lParam)
{
    switch (notify)
    {
    case IMEPN_ACTIVATE:
        if ( m_pCHwxInkWindow )
        {
            UpdateWindow(GetParent(m_pCHwxInkWindow->GetInkWindow()));
            InvalidateRect(m_pCHwxInkWindow->GetInkWindow(),NULL,TRUE);
            UpdateWindow(m_pCHwxInkWindow->GetInkWindow());
        }
        break;
    case IMEPN_INACTIVATE:
        break;
    case IMEPN_SHOW:
        if ( m_pCHwxInkWindow )
        {
            //----------------------------------------------------------------
            //for IME98A raid #2027.
            //980612: by ToshiaK. Check window is created or not.
            //when IMEPN_SHOW come before window has created, 
            // UpdateWindow(NULL); is called and Desktop flushes.
            //----------------------------------------------------------------
            if(m_pCHwxInkWindow->GetInkWindow() != NULL && ::IsWindow(m_pCHwxInkWindow->GetInkWindow())) {
               UpdateWindow(GetParent(m_pCHwxInkWindow->GetInkWindow()));
               InvalidateRect(m_pCHwxInkWindow->GetInkWindow(),NULL,TRUE);
               UpdateWindow(m_pCHwxInkWindow->GetInkWindow());
               if ( !m_pCHwxInkWindow->Is16BitApp() )
               {
                   m_pCHwxInkWindow->UpdateRegistry(FALSE);
               }
           }
        }
        break;
    case IMEPN_CONFIG:
        if ( m_pCHwxInkWindow && !m_pCHwxInkWindow->Is16BitApp() )
            m_pCHwxInkWindow->HandleConfigNotification();
        break;
    case IMEPN_HELP:            
        //----------------------------------------------------------------
        //980803: for FarEast merge
        //----------------------------------------------------------------
        if(m_pCHwxInkWindow) {
            CHwxFE::ShowHelp(m_pCHwxInkWindow->GetInkWindow());
        }
        break;
    case IMEPN_SIZECHANGING:
        if ( m_pCHwxInkWindow )
        {
            if(m_pCHwxInkWindow->HandleSizeNotify((INT *)wParam, (INT *)lParam)) {
                return S_OK;
            }
            else {
                return S_FALSE;
            }
        }
        break;
    default:
        break;
    }
    return S_OK;
    UNREFERENCED_PARAMETER(pImePad);
}

void CApplet::SendHwxChar(WCHAR wch)
{
    WCHAR wstr[2];
    wstr[0] = wch;
    wstr[1] = 0;
     m_pPad->Request(this,IMEPADREQ_INSERTSTRING,(WPARAM)wstr,0);
}

void CApplet::SendHwxStringCandidate(LPIMESTRINGCANDIDATE lpISC)
{
    if ( lpISC ) {
        if(m_pPad) {
            m_pPad->Request(this,IMEPADREQ_INSERTSTRINGCANDIDATE,(WPARAM)lpISC,0);
        }
    }
}

void CApplet::SendHwxStringCandidateInfo(LPIMESTRINGCANDIDATEINFO lpISC)
{
    if ( lpISC ) {
        if(m_pPad) {
            //----------------------------------------------------------------
            //For Satori #2123. Don't use Ipoint1.h's definition,
            //instead, use IPR_DEFAULT_INSERTPOS defined in imepad.h
            //----------------------------------------------------------------
            m_pPad->Request(this,
                            IMEPADREQ_INSERTSTRINGCANDIDATEINFO,
                            (WPARAM)lpISC,
                            IPR_DEFAULT_INSERTPOS); // IPINS_CURRENT);
        }
    }
}

void *CApplet::operator new(size_t size)
{
    return MemAlloc(size);
}

void  CApplet::operator delete(void *pv)
{
    if(pv) 
    {
        MemFree(pv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hlpidsc.h ===
//////////////////////////////////////////////////////////////////
// File     : hlpidsc.h
// Purpose  : WM_HELP, WM_CONTEXTMENU's help id define.
// 
// 
// Date     : Wed Aug 05 14:49:26 1998
// Author   : 
//
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef _HELP_ID_SIMPLIFIED_CHINESE_H_
#define _HELP_ID_SIMPLIFIED_CHINESE_H_

#define IDH_TOC_HW					3299		//
#define IDH_PAD_HW_INPUT_BOX		3200		//
#define IDH_PAD_HW_INPUT_INPUT		3201		//
#define IDH_PAD_HW_INPUT_RECOG		3202		//
#define IDH_PAD_HW_INPUT_CLEAR		3203		//
#define IDH_PAD_HW_INPUT_PROP		3204		//
#define IDH_PAD_HW_SEARCH_BOX		3205		//
#define IDH_PAD_HW_SEARCH_LIST		3206		//
#define IDH_PAD_HW_SEARCH_SEARCH	3207		//
#define IDH_PAD_HW_SEARCH_RECOG		3208		//
#define IDH_PAD_HW_SEARCH_REVERT	3209		//
#define IDH_PAD_HW_SEARCH_CLEAR		3210		//
#define IDH_PAD_HW_SEARCH_DETAIL	3211		//
#define IDH_PAD_HW_PROP_TIME		3220		//
#define IDH_PAD_HW_SEARCH_REVERT_GRAYED	3212	//

#endif //_HELP_ID_SIMPLIFIED_CHINESE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxfe.h ===
#ifndef __C_HWX_FAREAST_H__
#define __C_HWX_FAREAST_H__
class CHwxFE
{
public:
	static BOOL IsActiveIMEEnv(VOID);
	static LANGID GetAppLangID(VOID);
	static INT GetAppCodePage(VOID);
#ifndef UNDER_CE
	static INT GetRecognizerFileName(HINSTANCE hInst, LPSTR  lpstr,  INT cchMax);
#else // UNDER_CE
	static INT GetRecognizerFileName(HINSTANCE hInst, LPTSTR  lpstr,  INT cchMax);
#endif // UNDER_CE
	static INT LoadStrWithLangId	(LANGID langId,
									 HINSTANCE hInst,
									 INT id,
									 LPWSTR lpwstr,
									 INT cchMax);
	static INT GetTitleStringW		(HINSTANCE hInst, LPWSTR lpwstr, INT cchMax);
	static INT GetDispFontW			(HINSTANCE hInst, LPWSTR lpwstr, INT cchMax);
	static INT GetDispFontA			(HINSTANCE hInst, LPSTR  lpstr,  INT cchMax);
	static INT GetInkExpTextW		(HINSTANCE hInst, LPWSTR lpwstr, INT cchMax);
	static INT GetInkExpTextA		(HINSTANCE hInst, LPSTR  lpstr,  INT cchMax);
	static INT GetListExpTextW		(HINSTANCE hInst, LPWSTR lpwstr, INT cchMax);
	static INT GetListExpTextA		(HINSTANCE hInst, LPSTR  lpstr,  INT cchMax);
#ifdef UNDER_CE
	static INT GetHeaderStringW		(HINSTANCE hInst, INT index, LPWSTR lpstr, INT cchMax);
#endif // UNDER_CE
	static INT GetHeaderStringA		(HINSTANCE hInst, INT index, LPSTR lpstr, INT cchMax);
	static INT ShowHelp				(HWND hwnd);
	static INT HandleWmHelp			(HWND hwnd, BOOL fCAC);
	static INT HandleWmContextMenu	(HWND hwnd, BOOL fCAC);
	static INT GetTipText(WCHAR wch, LPWSTR lpwstrTip, INT cchMax, LPVOID lpSkdic);
#ifndef UNDER_CE
	static HMENU GetMenu(HINSTANCE hInst, LPSTR lpstrRes);
#else // UNDER_CE
	static HMENU GetMenu(HINSTANCE hInst, LPTSTR lpstrRes);
#endif // UNDER_CE
	static BOOL Is16bitApplication(VOID);
};
#endif //__C_HWX_FAREAST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxapp.h ===
#ifndef _HWXAPP_H_
#define _HWXAPP_H_
#include <windows.h>
#include "recog.h"
#include "imepad.h"

class CApplet;
typedef CApplet *LPCApplet;

class CHwxInkWindow;

//----------------------------------------------------------------
//IME98A enhance by ToshiaK: add IImeSpecifyApplets
//----------------------------------------------------------------
class CApplet: public IImePadApplet,public IImeSpecifyApplets
{
public:

	HRESULT __stdcall	QueryInterface(REFIID refiid, VOID **ppv);
	ULONG   __stdcall	AddRef(void);
	ULONG   __stdcall	Release(void);
	STDMETHODIMP	GetAppletIIDList(THIS_
									 REFIID			refiid,
									 LPAPPLETIDLIST	lpIIDList); 
	STDMETHODIMP	Initialize(IUnknown *pIImePad);
	STDMETHODIMP	Terminate(VOID);
	STDMETHODIMP	GetAppletConfig(LPIMEAPPLETCFG lpAppletCfg);
	STDMETHODIMP	CreateUI(HWND hwndParent,
							 LPIMEAPPLETUI lpImeAppletUI);
	STDMETHODIMP	Notify(IUnknown  *pImePad, 
						   INT		notify,
						   WPARAM	wParam,
						   LPARAM	lParam);
	CApplet();
	CApplet(HINSTANCE hInst);
	~CApplet();
	void *operator	new(size_t size);
	void  operator  delete(void *pv);
	void SendHwxChar(WCHAR wch);
	void SendHwxStringCandidate(LPIMESTRINGCANDIDATE lpISC);
	void SendHwxStringCandidateInfo(LPIMESTRINGCANDIDATEINFO lpISC);
	_inline IImePad * GetIImePad() { return m_pPad; }
	_inline HINSTANCE GetInstance() { return m_hInstance; }

protected:
	LONG m_cRef;

private:
	IImePad	*m_pPad;
	HINSTANCE m_hInstance;
	CHwxInkWindow * m_pCHwxInkWindow;
	BOOL	m_bInit;

};
#endif //_HWXAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxcac.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include "hwxobj.h"
#include "resource.h"
#include "../lib/plv/plv.h"
#include "../lib/ptt/ptt.h"
#ifdef FE_KOREAN
#include "hanja.h"
#else
#include "../imeskdic/imeskdic.h"
#endif
#include "hwxfe.h"
#include "cmnhdr.h"
#ifdef UNDER_CE // Windows CE Stub for unsupported APIs
#include "stub_ce.h"
#endif // UNDER_CE
// implementation of CHwxCAC

TCHAR szBuf[MAX_PATH];
TOOLINFOW ti;
static HPEN ghOldPen = NULL;
static HBITMAP ghOldBitmap = NULL;

static WCHAR wchChar[8][40];      // use to query the dictionary

#ifdef FE_JAPANESE
static KANJIINFO kanji;
const WORD wSamplePt[] = 
{0x350d,0x350e,0x3510,0x3513,0x3514,0x3515,0x3516,0x3517,0x3518,0,
0x191f,0x1822,0x1626,0x142a,0x132d,0x122f,0x1131,0x1033,0,
0x1a21,0x2420,0x301f,0x3a1f,0x441f,0x481f,0x4c1e,0x4f1e,
0x531d,0x5d1d,0x611d,0x621d,0x621e,0x621f,0x6221,0x6122,0x6023,0x5f25,
0x5d26,0x5a29,0x582c,0x562f,0,
0};
const wchar_t wSampleChar[24] =
{
0x5B80,0x30A6,0x30A5,0x6587,0x4E4B,0x3048,0x3047,0x5DFE,
0x5B57,0x5BF5,0x5BB9,0x5B9A,0x7A7A,0x5BF0,0x6848,0x5BC4,
0x5BA4,0x7AAE,0x5B9B,0x5BB3,0x7A81,0x5BDD,0x5BC7,0x5B8B
};
#endif // FE_JAPANESE


CHwxCAC::CHwxCAC(CHwxInkWindow * pInk,HINSTANCE hInst):CHwxObject(hInst)
{
    m_pInk = pInk;
    m_pCHwxThreadCAC = NULL;
    m_pCHwxStroke = NULL;
    m_hCACWnd = NULL;
//    m_hInstance = hInst;

    m_bLargeView = TRUE;
    m_gbDown = FALSE;
    m_bRightClick = FALSE;
    memset(m_gawch, '\0', sizeof(m_gawch));
    m_cnt = 0;
    if ( pInk )
        m_inkSize = pInk->GetCACInkHeight();
    else
        m_inkSize = PadWnd_Height;

    m_ghdc = NULL;
    m_ghbm = NULL;

    m_ghfntTT = NULL;

    m_hLVWnd = NULL;
#ifdef FE_JAPANESE
    m_pIImeSkdic = NULL;
    m_hSkdic = NULL;
#endif // FE_JAPANESE
    m_lpPlvInfo = NULL;
    m_hCursor = LoadCursor(NULL,IDC_ARROW);
    m_bResize = FALSE;
#ifdef FE_JAPANESE        
    memset(m_wchOther,'\0',sizeof(m_wchOther));
#endif
    m_bDrawSample = FALSE;
}

CHwxCAC::~CHwxCAC()
{
    m_pInk = NULL;
//    m_hInstance = NULL;
    if ( m_hCACWnd )
    {
         DestroyWindow(m_hCACWnd);
        m_hCACWnd = NULL;
    }
    if ( m_pCHwxThreadCAC )
    {
         delete m_pCHwxThreadCAC;
        m_pCHwxThreadCAC = NULL;
    }
    if ( m_pCHwxStroke )
    {
         delete m_pCHwxStroke;
        m_pCHwxStroke = NULL;
    }
    if ( m_ghdc )
    {
        if ( m_ghbm )
        {
            ghOldBitmap = SelectBitmap(m_ghdc,ghOldBitmap);
            DeleteBitmap(ghOldBitmap);
            ghOldBitmap = NULL;
            m_ghbm = NULL;
        }
        DeleteDC(m_ghdc);
        m_ghdc = NULL;
    }
    if ( m_ghfntTT )
    {
        DeleteObject(m_ghfntTT);
        m_ghfntTT = NULL;
    }
    if ( m_hLVWnd )
    {
        DestroyWindow(m_hLVWnd);
        m_hLVWnd = NULL;
    }

#ifdef FE_KOREAN
    CloseLex();
#else
    if ( m_pIImeSkdic )
    {
        m_pIImeSkdic->Release();
        m_pIImeSkdic = NULL;
    }
    if ( m_hSkdic )
    {
         FreeLibrary(m_hSkdic);
        m_hSkdic = NULL;
    }
#endif
    m_lpPlvInfo = NULL;
    
}
 
BOOL CHwxCAC::Initialize(TCHAR * pClsName)
{
    BOOL bRet = CHwxObject::Initialize(pClsName);
    if ( bRet )
    {
        WNDCLASS    wc; 
        wc.style         = CS_VREDRAW | CS_HREDRAW | CS_SAVEBITS; 
        wc.lpfnWndProc   = CACWndProc; 
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = sizeof(void *);
        wc.hInstance     = m_hInstance;
        wc.hIcon         = NULL; 
        wc.hCursor       = LoadCursor(NULL,MAKEINTRESOURCE(32631)); 
#ifndef UNDER_CE
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE +1);
#else // UNDER_CE
        wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
#endif // UNDER_CE
        wc.lpszMenuName  = NULL; 
        wc.lpszClassName = TEXT("MACAW"); 

        RegisterClass(&wc);
        
        bRet = Init();
        if ( !bRet )
            return FALSE;

        m_pCHwxThreadCAC = new CHwxThreadCAC(this);
        if ( !m_pCHwxThreadCAC )
            return FALSE;
        m_pCHwxStroke =  new CHwxStroke(FALSE,32);
        if ( !m_pCHwxStroke )
        {
            delete m_pCHwxThreadCAC;
            m_pCHwxThreadCAC = NULL;
            return FALSE;
        }
        bRet = m_pCHwxThreadCAC->Initialize(TEXT("CHwxThreadCAC"));
        if ( !bRet && Is16BitApp() && m_pCHwxThreadCAC->IsHwxjpnLoaded() )
        {
            bRet = TRUE;
        }
        if ( !bRet )
        {
             delete m_pCHwxThreadCAC;
            m_pCHwxThreadCAC = NULL;
            delete m_pCHwxStroke;
            m_pCHwxStroke = NULL;
            return FALSE;
        }
        bRet = m_pCHwxStroke->Initialize(TEXT("CHwxStrokeCAC"));
        if ( !bRet )
        {
             delete m_pCHwxThreadCAC;
            m_pCHwxThreadCAC = NULL;
            delete m_pCHwxStroke;
            m_pCHwxStroke = NULL;
            return FALSE;
        }
    }
    return bRet;
}

typedef HRESULT (WINAPI * PFN)(void **);
static TCHAR szDisp[2][60];
static WCHAR wchDisp[2][60];
BOOL CHwxCAC::Init() 
{ 
    // Create the font handles
    if ( IsNT() ) {
#ifndef UNDER_CE // Windows CE does not support CreateFont
        static WCHAR wchFont[LF_FACESIZE];
        CHwxFE::GetDispFontW(m_hInstance, wchFont, sizeof(wchFont)/sizeof(wchFont[0]));
        m_ghfntTT = CreateFontW(-FONT_SIZE*2,
                                0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET,
                                OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                DEFAULT_PITCH | FF_DONTCARE, 
                                wchFont);
#else // UNDER_CE
        static LOGFONT lf = {-FONT_SIZE*2, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                             DEFAULT_CHARSET,OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, {TEXT('\0')}};
        CHwxFE::GetDispFontW(m_hInstance, lf.lfFaceName,
                             sizeof(lf.lfFaceName)/sizeof(lf.lfFaceName[0]));
        m_ghfntTT = CreateFontIndirect(&lf);
#endif // UNDER_CE
    }
    else {
#ifndef UNDER_CE // Windows CE always Unicode
        static CHAR chFont[LF_FACESIZE];
        CHwxFE::GetDispFontA(m_hInstance, chFont, sizeof(chFont));
        m_ghfntTT = CreateFontA(-FONT_SIZE*2,
                                0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET,
                                OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                DEFAULT_PITCH | FF_DONTCARE, chFont);
#endif // UNDER_CE
    }

    if ( !m_ghfntTT )
    {
        return FALSE;
    }

    //980324:by ToshiaK
    if(IsNT()) {
        CHwxFE::GetInkExpTextW(m_hInstance,
                               wchDisp[0],
                               sizeof(wchDisp[0])/sizeof(wchDisp[0][0]));
        CHwxFE::GetListExpTextW(m_hInstance,
                                wchDisp[1],
                                sizeof(wchDisp[1])/sizeof(wchDisp[1][0]));
    }
    else {
#ifndef UNDER_CE // Windows CE always Unicode
        CHwxFE::GetInkExpTextA(m_hInstance,
                               szDisp[0],
                               sizeof(szDisp[0])/sizeof(szDisp[0][0]));
        CHwxFE::GetListExpTextA(m_hInstance,
                                szDisp[1],
                                sizeof(szDisp[1])/sizeof(szDisp[1][0]));
#endif // UNDER_CE
    }
//----------------------------------------------------------------
//Below code is Japanese only
//----------------------------------------------------------------
#ifdef FE_JAPANESE
    m_hSkdic = NULL;
    m_pIImeSkdic = NULL;

    GetModuleFileName(m_hInstance, szBuf, sizeof(szBuf)/sizeof(szBuf[0]));
#ifndef UNDER_CE
    TCHAR *p = strrchr(szBuf, (TCHAR)'\\');
#else // UNDER_CE
    TCHAR *p = _tcsrchr(szBuf, TEXT('\\'));
#endif // UNDER_CE
    p[1] = (TCHAR)0x00;
#ifdef _DEBUG
    lstrcat(szBuf, TEXT("dbgskdic.dll"));
#else
    lstrcat(szBuf, TEXT("imeskdic.dll"));
#endif // !_DEBUG

    m_hSkdic = LoadLibrary(szBuf);

    m_pIImeSkdic = NULL;
    if (m_hSkdic ) {
#ifndef UNDER_CE
        PFN lpfn =(PFN)GetProcAddress(m_hSkdic,"CreateIImeSkdicInstance");
#else // UNDER_CE
        PFN lpfn =(PFN)GetProcAddress(m_hSkdic,TEXT("CreateIImeSkdicInstance"));
#endif // UNDER_CE
        if(lpfn) {
            if(S_OK != (*lpfn)((void **)&m_pIImeSkdic) ) {
                FreeLibrary(m_hSkdic);
                m_hSkdic = NULL;
            }
        }
        else {
            FreeLibrary(m_hSkdic);
            m_hSkdic = NULL;
        }
    }
#endif    //FE_JAPANESE

    return    TRUE;
}

void CHwxCAC::InitBitmap(DWORD nMask, int nItem)
{
    RECT    rc;

    if (nMask & MACAW_REDRAW_BACKGROUND)
    {
        rc.left = rc.top = 0;
        rc.right = rc.bottom = m_inkSize;
#ifndef UNDER_CE
        FillRect(m_ghdc,&rc,(HBRUSH)(COLOR_3DFACE+1));
#else // UNDER_CE
        FillRect(m_ghdc,&rc,GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE
        
        InitBitmapBackground();
        if ( !nItem )
        {
            InitBitmapText();
        }
        ghOldPen = SelectPen(m_ghdc, GetStockObject(BLACK_PEN));
        return;
    }

    if (nMask & MACAW_REDRAW_INK)
    {
        InitBitmapBackground();
        if ( m_pCHwxStroke->GetNumStrokes() )
        {
            m_pCHwxStroke->DrawStroke(m_ghdc,0,TRUE);
        }
        else
        {
            InitBitmapText();
        }
        return;
    }
}

void CHwxCAC::InitBitmapText()
{
    HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    HFONT hOldFont = (HFONT)SelectObject( m_ghdc, hFont );
    RECT    rc;

    rc.left = rc.top = 20;
    rc.right = rc.bottom = m_inkSize - 20;
    COLORREF colOld = SetTextColor( m_ghdc, GetSysColor(COLOR_3DSHADOW) );
    COLORREF colBkOld = SetBkColor( m_ghdc, GetSysColor(COLOR_WINDOW) );
    //980324: by ToshiaK
    if(IsNT()) {
        DrawTextW(m_ghdc, wchDisp[0], lstrlenW(wchDisp[0]), &rc, DT_VCENTER|DT_WORDBREAK ); 
    }
    else {
        DrawText( m_ghdc, szDisp[0], lstrlen(szDisp[0]), &rc,DT_VCENTER|DT_WORDBREAK ); 
    }
    SetTextColor( m_ghdc, colOld );
    SetBkColor( m_ghdc, colBkOld );
    SelectObject( m_ghdc, hOldFont );
    //980803:by ToshiaK. no need to delete. hFont is DEFAULT_GUI_FONT.
    //DeleteFont(hFont);
}
 
void CHwxCAC::InitBitmapBackground()
{
    RECT    rc;
    HBRUSH    hOldBrush, hBrush;
    HPEN    hOldPen;
    //----------------------------------------------------------------
    //980803:ToshiaK. PRC's merge. Use COLOR_WINDOW instead of WHITE_BRUSH
    //----------------------------------------------------------------
#ifdef OLD980803
    hOldBrush =    SelectBrush(m_ghdc, GetStockObject(WHITE_BRUSH));
#endif
    hBrush      = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    hOldBrush =    SelectBrush(m_ghdc, hBrush);
    hOldPen   = SelectPen(m_ghdc, GetStockObject(BLACK_PEN));
    Rectangle(m_ghdc, 4, 4, m_inkSize-4, m_inkSize-4);
    rc.top = rc.left = 4;
    rc.bottom = rc.right = m_inkSize-4;
    DrawEdge(m_ghdc,&rc,EDGE_SUNKEN,BF_RECT);
    m_pInk->DrawHwxGuide(m_ghdc,&rc);
    hOldBrush =    SelectBrush(m_ghdc, hOldBrush);
    hOldPen   = SelectPen(m_ghdc, hOldPen);
    DeleteBrush(hOldBrush);
    DeletePen(hOldPen);
}

void CHwxCAC::HandleResizePaint(HWND hwnd)
{
    if ( m_ghdc )
    {
        if ( ghOldPen )
        {
             ghOldPen = SelectPen(m_ghdc,ghOldPen);
            DeletePen(ghOldPen);
            ghOldPen = NULL;
        }
        if ( ghOldBitmap )
        {
             ghOldBitmap = SelectBitmap(m_ghdc,ghOldBitmap);
            DeleteBitmap(ghOldBitmap);
            ghOldBitmap = NULL;
        }
        DeleteDC(m_ghdc);
    }
    HDC hdc  = GetDC(hwnd);
    m_ghbm = CreateCompatibleBitmap(hdc, m_inkSize,m_inkSize);
    m_ghdc = CreateCompatibleDC(hdc);
    ReleaseDC(hwnd, hdc);

    ghOldBitmap = SelectBitmap(m_ghdc, m_ghbm);

    InitBitmap(MACAW_REDRAW_BACKGROUND,m_gbDown ? 1 : 0);
    if ( GetStrokeCount() )
        InitBitmap(MACAW_REDRAW_INK,0);
}

BOOL CHwxCAC::CreateUI(HWND hwnd)
{
    //990602:kotae #434: to remove flicker, add WS_CLIPCHILDREN
    m_hCACWnd = CreateWindowEx(0,
                             TEXT("Macaw"), 
                             TEXT(""), 
                             WS_CHILD | WS_VISIBLE |WS_CLIPCHILDREN, 
                             0,
                             0,
                             0,
                             0,
                             hwnd,
                             (HMENU)IDC_CACINPUT, //980706:for #1624. for "?" help.
                            m_hInstance,
                            this);
    if( !m_hCACWnd )
    {
        return FALSE;
    }

    m_hLVWnd = PadListView_CreateWindow(m_hInstance,
                                        m_hCACWnd, IDC_CACLISTVIEW,
                                        CW_USEDEFAULT,
                                        CW_USEDEFAULT,
                                        500,
                                        CW_USEDEFAULT,
                                        CAC_WM_SENDRESULT);

    if ( !m_hLVWnd )
    {
         DestroyWindow(m_hCACWnd);
        m_hCACWnd = NULL;
        return FALSE;
    }
    // set style,callbacks,font,column
    PadListView_SetItemCount(m_hLVWnd, 0);

    PadListView_SetIconItemCallback(m_hLVWnd, (LPARAM)this, (LPFNPLVICONITEMCALLBACK)GetItemForIcon);
#ifdef FE_JAPANESE    
    PadListView_SetReportItemCallback(m_hLVWnd, (LPARAM)this,(LPFNPLVREPITEMCALLBACK)GetItemForReport);
#endif
    //----------------------------------------------------------------
    //980727: by ToshiaK for ActiveIME support
    //----------------------------------------------------------------
    //980803:ToshiaK. FE merge.
#ifndef UNDER_CE //#ifndef UNICODE
    static CHAR chFontName[LF_FACESIZE];
    CHwxFE::GetDispFontA(m_hInstance, chFontName, sizeof(chFontName));
#else // UNDER_CE
    static TCHAR chFontName[LF_FACESIZE];
    CHwxFE::GetDispFontW(m_hInstance, chFontName, sizeof chFontName/sizeof chFontName[0]);
#endif // UNDER_CE
    if(CHwxFE::IsActiveIMEEnv()) {
        PadListView_SetCodePage(m_hLVWnd, CHwxFE::GetAppCodePage());
        PadListView_SetHeaderFont(m_hLVWnd, chFontName);
    }
    
    //----------------------------------------------------------------
    //990810:ToshiaK KOTAE #1030.
    // Font's BUG. You should check Font's Charset.
    // Add new api for this. do not change PRC's code.
    //----------------------------------------------------------------
#ifdef FE_JAPANESE
    PadListView_SetIconFontEx(m_hLVWnd,   chFontName, SHIFTJIS_CHARSET, 16);
    PadListView_SetReportFontEx(m_hLVWnd, chFontName, SHIFTJIS_CHARSET, 12);
#elif FE_KOREAN
    PadListView_SetIconFontEx(m_hLVWnd,   chFontName, HANGUL_CHARSET, 12);
    PadListView_SetReportFontEx(m_hLVWnd, chFontName, HANGUL_CHARSET, 12);
#else
    PadListView_SetIconFont(m_hLVWnd,   chFontName, 16);
    PadListView_SetReportFont(m_hLVWnd, chFontName, 12);
#endif

    PadListView_SetStyle(m_hLVWnd,PLVSTYLE_ICON);

    if(IsNT()) { //980324:by ToshiaK #526 for WinNT50
        PadListView_SetExplanationTextW(m_hLVWnd,wchDisp[1]);
    }
    else {
#ifndef UNDER_CE // Windows CE always Unicode
        PadListView_SetExplanationText(m_hLVWnd,szDisp[1]);
#endif // UNDER_CE
    }

    //----------------------------------------------------------------
    //Detail View is only implemented in Japanese Handwriting
    //----------------------------------------------------------------
#ifdef FE_JAPANESE
    int i;
    for(i = 0; i < LISTVIEW_COLUMN; i++) 
    {
         PLV_COLUMN plvCol;
        //980803:ToshiaK: moved to CHwxfe::GetHeaderStringA()
#ifndef UNDER_CE //#ifndef UNICODE
        CHwxFE::GetHeaderStringA(m_hInstance, i, szBuf, sizeof(szBuf)/sizeof(szBuf[0]));
#else // UNDER_CE
        CHwxFE::GetHeaderStringW(m_hInstance, i, szBuf, sizeof(szBuf)/sizeof(szBuf[0]));
#endif // UNDER_CE
         plvCol.mask = PLVCF_FMT | PLVCF_WIDTH | PLVCF_TEXT;
         plvCol.fmt  = PLVCFMT_LEFT;
         plvCol.pszText = szBuf;
         plvCol.cx       = 60;    
         plvCol.cchTextMax = lstrlen(szBuf);
         PadListView_InsertColumn(m_hLVWnd, i, &plvCol);
    }
#endif //FE_JAPANESE

    SetToolTipInfo(TRUE);

    HandleResizePaint(m_hCACWnd);

    return TRUE;
}

void CHwxCAC::HandlePaint(HWND hwnd)
{
    PAINTSTRUCT    ps;
    RECT rcBkgnd;
    BeginPaint(hwnd, &ps);
    if ( ps.fErase )
    {
        rcBkgnd.left = m_inkSize;
         rcBkgnd.top = 0;
        rcBkgnd.right = m_pInk->GetCACWidth();
        rcBkgnd.bottom = m_pInk->GetCACHeight();
#ifndef UNDER_CE
        FillRect(ps.hdc,&rcBkgnd,(HBRUSH)(COLOR_3DFACE+1));
#else // UNDER_CE
        FillRect(ps.hdc,&rcBkgnd,GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE

        if ( m_pInk->GetCACHeight() > m_inkSize )
        {
            rcBkgnd.left = 0;
             rcBkgnd.top = m_inkSize;
            rcBkgnd.right = m_inkSize;
            rcBkgnd.bottom = m_pInk->GetCACHeight();
#ifndef UNDER_CE
            FillRect(ps.hdc,&rcBkgnd,(HBRUSH)(COLOR_3DFACE+1));
#else // UNDER_CE
            FillRect(ps.hdc,&rcBkgnd,GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE
        }
    }
    HandleResizePaint(hwnd);
    BitBlt(ps.hdc, 0, 0, m_inkSize, m_inkSize, m_ghdc, 0,0, SRCCOPY);

    if (m_gbDown)
        m_pCHwxStroke->DrawStroke(ps.hdc,-1,FALSE);
    EndPaint(hwnd, &ps);
    PadListView_Update(m_hLVWnd);
}

BOOL CHwxCAC::checkRange(int x, int y )
{
#if 1 //for KOTAE #818
    //Too ugly code...
    if(x < (4+2) ||(m_inkSize - (4+4-1)) < x) {
        return FALSE;
    }
    if(y < (4+2) || (m_inkSize - (4+4-1)) < y) {
        return FALSE;
    }
    return TRUE;
#endif

#if 0 //OLD CODE 990601;
    int inkSize = m_inkSize - 4;
    if ((x <= 2) || (x >= inkSize) || (y <= 2) || (y >= inkSize))
        return FALSE;
    return TRUE;
#endif
}

BOOL CHwxCAC::IsPointInResizeBox(int x,int y)
{
    int inkSize = m_inkSize - 4;

    if ((x <= inkSize) || (x >= (m_inkSize+4 )) || (y <= 4) || (y >= (m_pInk->GetCACHeight()-8)))
        return FALSE;
    return TRUE;
}

void CHwxCAC::recognize()
{
    memset(m_gawch, '\0', sizeof(m_gawch));
    PadListView_SetItemCount(m_hLVWnd,0);
    if(IsNT()) { //980324:by ToshiaK #526 for WinNT50
        PadListView_SetExplanationTextW(m_hLVWnd, NULL);
    }
    else {
        PadListView_SetExplanationText(m_hLVWnd,NULL);
    }

    m_cnt = 0;

    int inkSize = m_inkSize - 4;

    PostThreadMessage(m_pCHwxThreadCAC->GetID(), THRDMSG_SETGUIDE, inkSize, 0);
    PostThreadMessage(m_pCHwxThreadCAC->GetID(), THRDMSG_RECOGNIZE, 0, 0);
}

void CHwxCAC::NoThreadRecognize(int boxSize)
{
    memset(m_gawch, '\0', sizeof(m_gawch));
    PadListView_SetItemCount(m_hLVWnd,0);
    if(IsNT()) { //980324:toshiaK for #526
        PadListView_SetExplanationTextW(m_hLVWnd,NULL);
    }
    else {
        PadListView_SetExplanationText(m_hLVWnd,NULL);
    }
    PadListView_Update(m_hLVWnd);

    m_cnt = 0;

     m_pCHwxThreadCAC->RecognizeNoThread(boxSize);
}

void CHwxCAC::HandleMouseEvent(HWND hwnd,UINT msg,WPARAM wp,LPARAM lp)
{
    RECT    rc;
    POINT   pt;
    pt.x = (short) LOWORD(lp);
    pt.y = (short) HIWORD(lp);
    switch ( msg )
    {
        case WM_LBUTTONDBLCLK:
        case WM_LBUTTONDOWN:
            if (!m_gbDown && checkRange(pt.x,pt.y) )
            {
                if ( m_bRightClick )
                    return;

                 if  ( m_pCHwxStroke->AddPoint(pt) )
                {
                    m_gbDown = TRUE;
                    if ( !GetStrokeCount() )
                    {
                        InvalidateRect(hwnd, NULL, FALSE);
                        UpdateWindow(hwnd);
                    }

                    m_pCHwxStroke->GetUpdateRect(&rc);
                    InvalidateRect(hwnd, &rc, FALSE);
                
                    m_pCHwxStroke->IncStrokeCount();

                    SetCapture(hwnd);
                    if ( m_cnt && !m_pInk->IsSglClk() && !m_pInk->IsDblClk() )
                    {
                        memset(m_gawch, '\0', sizeof(m_gawch));
                        m_cnt = 0;
                        PadListView_SetItemCount(m_hLVWnd,0);
                        if(IsNT()) { //ToshiaK:983024
                            PadListView_SetExplanationTextW(m_hLVWnd,NULL);
                        }
                        else {
                            PadListView_SetExplanationText(m_hLVWnd,NULL);
                        }
                        PadListView_Update(m_hLVWnd);
                    }
                }
            }
            else if (IsPointInResizeBox(pt.x,pt.y) )
            {
                if ( !m_bResize )
                {
                    m_pInk->SetCACInkHeight( m_inkSize = pt.x > INKBOXSIZE_MIN ? pt.x : INKBOXSIZE_MIN );
                    m_pCHwxStroke->DeleteAllStroke();
                    m_pInk->ChangeIMEPADSize(FALSE);
                     m_pInk->ChangeLayout(FALSE);
                    SetCapture(hwnd);
                     m_bResize = TRUE;
                }
            }
            break;

        case WM_LBUTTONUP:
            if (m_gbDown)
            {
                //990602:Kotae #818
                if (pt.x < (4+2)) {
                    pt.x = 4+2;
                }
                else if (pt.x >= (m_inkSize-(4+4-1))) {
                    pt.x = m_inkSize-(4+4-1);
                }
                if (pt.y < (4+2)) {
                    pt.y = 4+2;
                }
                else if (pt.y >= (m_inkSize-(4+4-1))) {
                    pt.y = (m_inkSize-(4+4-1));
                }
#if 0
                if (pt.x <= 2)
                    pt.x = 4;
                else if (pt.x >= (m_inkSize-4))
                    pt.x = (m_inkSize-4) - 1;

                if (pt.y <= 2)
                    pt.y = 4;
                else if (pt.y >= (m_inkSize-4) )
                    pt.y = (m_inkSize-4) - 1;
#endif

                if ( m_pCHwxStroke->AddPoint(pt) )
                {
                    m_pCHwxStroke->GetUpdateRect(&rc);
                    InvalidateRect(hwnd, &rc, FALSE);

                    m_gbDown = FALSE;
                    ReleaseCapture();
                }
                m_pCHwxStroke->DecStrokeCount();
                if ( m_pCHwxStroke->AddBoxStroke(0,0,0) )
                {
                    m_pCHwxStroke->DrawStroke(m_ghdc, -2, FALSE);
                    if ( !Is16BitApp() && !m_bDrawSample && (m_pInk->IsSglClk() || m_pInk->IsDblClk()) )
                        recognize();
                }
            }
            else if ( IsPointInResizeBox(pt.x,pt.y) )
            {
                if ( m_bResize )
                {
                    m_pInk->SetCACInkHeight( m_inkSize = pt.x > INKBOXSIZE_MIN ? pt.x : INKBOXSIZE_MIN );
                    m_pInk->ChangeIMEPADSize(FALSE);
                     m_pInk->ChangeLayout(FALSE);
                    ReleaseCapture();
                     m_bResize = FALSE;
                }
            }
            else 
            {
                if ( m_bResize )
                {
                    if ( hwnd == GetCapture() )
                        ReleaseCapture();
                    m_hCursor = LoadCursor(NULL,IDC_ARROW);
                    SetCursor(m_hCursor);
                     m_bResize = FALSE;
                }
            }
            break;

        case WM_MOUSEMOVE:
            if (m_gbDown)
            {
                //fixed KOTAE #818
                if (pt.x < (4+2)) {
                    pt.x = 4+2;
                }
                else if (pt.x >= (m_inkSize-(4+4-1))) {
                    pt.x = m_inkSize-(4+4-1);
                }
                if (pt.y < (4+2)) {
                    pt.y = 4+2;
                }
                else if (pt.y >= (m_inkSize-(4+4-1))) {
                    pt.y = (m_inkSize-(4+4-1));
                }
//These are original code. 
//Original code uses too much Magic Number
//and miscalc rectangle size.
#if 0
                if (pt.x <= 2)
                    pt.x = 4;
                else if (pt.x >= (m_inkSize-4))
                    pt.x = (m_inkSize-4) - 1;

                if (pt.y <= 2)
                    pt.y = 4;
                else if (pt.y >= (m_inkSize-4))
                    pt.y = (m_inkSize-4) - 1;
#endif



                if ( m_gbDown = m_pCHwxStroke->AddPoint(pt) )
                {
                    m_pCHwxStroke->GetUpdateRect(&rc);
                    InvalidateRect(hwnd, &rc, FALSE);
                }
            }
            else if (hwnd == GetCapture() || IsPointInResizeBox(pt.x,pt.y) )
            {
                 HCURSOR hCur = LoadCursor(NULL,IDC_SIZEWE);
#ifndef UNDER_CE // CE specific
                m_hCursor = SetCursor(hCur);
#else // UNDER_CE
                SetCursor(hCur);
#endif // UNDER_CE
                if ( m_bResize )
                {
                    //990810:ToshiaK for KOTAE #1661.
                    //Limit's maximum size of ink box.
                    INT cxScreen = ::GetSystemMetrics(SM_CXFULLSCREEN)/2;
                    //INT cyScreen = ::GetSystemMetrics(SM_CYFULLSCREEN)/2;
                    //OLD CODE
                    //m_pInk->SetCACInkHeight( m_inkSize = pt.x > INKBOXSIZE_MIN ? pt.x : INKBOXSIZE_MIN );
                    if(pt.x < INKBOXSIZE_MIN) {
                        m_inkSize = INKBOXSIZE_MIN;
                    }
                    else if( cxScreen < pt.x) {
                        m_inkSize = cxScreen;
                    }
                    else {
                        m_inkSize = pt.x;
                    }
                    m_pInk->SetCACInkHeight(m_inkSize);                    
                    m_pInk->ChangeIMEPADSize(FALSE);
                     m_pInk->ChangeLayout(FALSE);
                }
            }
            else 
            {
                if ( !m_bResize )
                    SetCursor(m_hCursor);
            }
            break;
        case WM_RBUTTONDOWN:
            {
                if ( checkRange(pt.x,pt.y) )
                {
                     m_bRightClick = TRUE;
                }
            }
            break;
        case WM_RBUTTONUP:
            {
                //----------------------------------------------------------------
                //971219:by ToshiaK for IME98 #1163:
                //If already WM_LBUTTONDOWN has come
                //Do not invoke popup menu.
                //----------------------------------------------------------------
                if(m_gbDown) {
                    m_bRightClick = FALSE;
                    break;
                }
                if ( checkRange(pt.x,pt.y) )
                {
                     HMENU hMenu;
                    HMENU hMenuTrackPopup;
                    //----------------------------------------------------------------
                    //fixed MSKK #5035.Need to load specified language's menu resource
                    //BUGBUG::hMenu = LoadMenu (m_hInstance, MAKEINTRESOURCE(IDR_CACINK));
                    //----------------------------------------------------------------
                    hMenu = CHwxFE::GetMenu(m_hInstance, MAKEINTRESOURCE(IDR_CACINK));
                    if (hMenu)
                    {
                        hMenuTrackPopup = GetSubMenu (hMenu, 0);
                        if ( Is16BitApp() )
                        {
                            EnableMenuItem(hMenuTrackPopup,4,MF_BYPOSITION | MF_GRAYED);
                        }
                        else
                        {
                            if ( m_pInk->IsDblClk() )
                            {
                                 CheckMenuItem(hMenuTrackPopup,4,MF_BYPOSITION | MF_CHECKED);
                            }
                            else
                            {
                                 CheckMenuItem(hMenuTrackPopup,4,MF_BYPOSITION | MF_UNCHECKED);
                            }
                        }
                        ClientToScreen(m_hCACWnd,&pt);
#ifndef UNDER_CE // Windows CE does not support TPM_LEFTBUTTON on TrackPopupMenu
                        TrackPopupMenu (hMenuTrackPopup, TPM_LEFTALIGN | TPM_LEFTBUTTON, pt.x, pt.y, 0,m_hCACWnd, NULL);
#else // UNDER_CE
                        TrackPopupMenu(hMenuTrackPopup, TPM_LEFTALIGN, pt.x, pt.y, 0,m_hCACWnd, NULL);
#endif // UNDER_CE
                        DestroyMenu (hMenu);
                    }
                     m_bRightClick = FALSE;
                }
            }
             break;
    }
    Unref(wp);
}

BOOL CHwxCAC::IsDupResult(WORD wd)
{
     BOOL bRet = FALSE;
    for ( int i = 0; i < m_cnt; i++)
    {
        if ( m_gawch[i] == wd )
        {
             bRet = TRUE;
            break;
        }
    }
    return bRet;
}

void CHwxCAC::HandleRecogResult(HWND hwnd,WPARAM wp, LPARAM lp)
{
      DWORD        cstr;
    int            list;
    int            nItem = HIWORD(lp);
    list = (wp >> 8) & 0x00ff;
    cstr =  wp & 0x00ff;
    if ( cstr == (DWORD)GetStrokeCount() )
    {
        WCHAR wch = (WCHAR)lp;
        if ( list )
        {
            if ( !IsDupResult( wch ) )
            {
                m_gawch[m_cnt++] = wch;
            }
        }
        else
        {
            m_gawch[nItem] = wch;
            m_cnt = nItem + 1;
        }
    }
    Unref(hwnd);
}
void CHwxCAC::HandleShowRecogResult(HWND hwnd,WPARAM wp, LPARAM lp)
{
  if ( m_cnt )
  {
    PadListView_SetItemCount(m_hLVWnd,m_cnt);
    if(IsNT()) { //ToshiaK:980324
        PadListView_SetExplanationTextW(m_hLVWnd,NULL);
    }
    else {
        PadListView_SetExplanationText(m_hLVWnd,NULL);
    }
    PadListView_Update(m_hLVWnd);
  }
  Unref(hwnd);
  Unref(wp);
  Unref(lp);
}

void CHwxCAC::pickUpChar(LPPLVINFO lpPlvInfo)
{
    WCHAR wch;
    wch = GetWCHAR(m_lpPlvInfo->index);
    if ( wch )
    {
        pickUpCharHelper(wch);
     }
    Unref(lpPlvInfo);
}

void CHwxCAC::pickUpCharHelper(WCHAR wch)
{
     (m_pInk->GetAppletPtr())->SendHwxChar(wch);
    // 16 bit app, single/double click on recog button
    if ( Is16BitApp() )
    {
        HandleDeleteAllStroke();
    }
    else
    {
        if ( m_pInk->IsSglClk() )
        {
            m_pInk->SetSglClk(FALSE);
            HandleDeleteAllStroke();
        }
        if ( m_pInk->IsDblClk() )
            HandleDeleteAllStroke();
        if ( !m_pInk->IsSglClk() && !m_pInk->IsDblClk() )
            HandleDeleteAllStroke();
    }
}

HBITMAP CHwxCAC::makeCharBitmap(WCHAR wch)
{
     HDC hdcTmp;
    RECT rc ={0,0,32,32};
    HDC hdc;
    HBITMAP hBmp;
    HBITMAP hBmpOld;
    HFONT hFontOld;
    
    hBmp = LoadBitmap(m_hInstance, MAKEINTRESOURCE(IDB_CHARBMP));
    hdc = GetDC( (HWND)m_hCACWnd );
    hdcTmp     = CreateCompatibleDC( hdc );
    hBmpOld     = (HBITMAP)SelectObject( hdcTmp, hBmp );
    hFontOld = (HFONT)SelectObject( hdcTmp, m_ghfntTT );

    ExtTextOutW( hdcTmp, rc.left+2,rc.top+2,ETO_CLIPPED,&rc,&wch,1,NULL);

    SelectObject( hdcTmp, hFontOld );
    SelectObject( hdcTmp , hBmpOld );
    DeleteDC( hdcTmp );
    ReleaseDC( (HWND)m_hCACWnd, hdc );
    return hBmp;
}

void CHwxCAC::HandleSendResult(HWND hwnd,WPARAM wp,LPARAM lp)
{
    m_lpPlvInfo = (LPPLVINFO)lp;
    switch (m_lpPlvInfo->code)
    { 
        case PLVN_ITEMPOPED:
#ifdef UNDER_CE // ButtonDown/Up ToolTip
        case PLVN_ITEMDOWN:
#endif // UNDER_CE
             {
                if ( m_bLargeView )
                {
                    SetToolTipInfo(FALSE);
                    //970902: ToshiaK for #1215, #1231
                    TOOLTIPUSERINFO ttInfo;
#ifndef UNDER_CE // CE Specific(ptt use ClientToScreen(ttInfo.hwnd,&ttInfo.pt) )
                    ttInfo.hwnd = m_hCACWnd;
#else // UNDER_CE
                    ttInfo.hwnd = m_hLVWnd;
#endif // UNDER_CE
                    ttInfo.pt   = m_lpPlvInfo->pt;
                    ttInfo.rect = m_lpPlvInfo->itemRect;
                    ttInfo.lParam = (LPARAM)m_lpPlvInfo->index;
                    SendMessage(m_pInk->GetToolTipWindow(),
                                TTM_RELAYEVENT_WITHUSERINFO,
                                0,(LPARAM)(LPTOOLTIPUSERINFO)&ttInfo);

                }
            }
            break;
#ifdef UNDER_CE // ButtonDown/Up ToolTip
        case PLVN_ITEMUP:
             {
                if ( m_bLargeView )
                {
                    SetToolTipInfo(FALSE);
                    TOOLTIPUSERINFO ttInfo;
                    ZeroMemory(&ttInfo, sizeof(ttInfo));
                    SendMessage(m_pInk->GetToolTipWindow(),
                                TTM_RELAYEVENT_WITHUSERINFO,
                                0,(LPARAM)&ttInfo);
                }
            }
            break;
#endif // UNDER_CE
        case PLVN_ITEMCLICKED:
            if ( m_lpPlvInfo ) {
                //971219:fixed #3466
                if(m_lpPlvInfo->colIndex == 0) {
                    pickUpChar(m_lpPlvInfo);
                }
            }
            break;
        case PLVN_ITEMCOLUMNCLICKED:
            break;
        case PLVN_ITEMDBLCLICKED:
            break;
        case PLVN_ITEMCOLUMNDBLCLICKED:
            break;
//////////////////////////////////////////////////////////////////////////////
//  !!! CAC context menu Start !!!
#ifdef FE_JAPANESE    
        case PLVN_R_ITEMCLICKED:
            {
                HMENU hMenu;
                HMENU hMenuTrackPopup,hMenuSub;
                POINT pt = m_lpPlvInfo->pt;
                //----------------------------------------------------------------
                //fixed MSKK #5035.Need to load specified language's menu resource
                //BUGBUG::hMenu = LoadMenu (m_hInstance, MAKEINTRESOURCE(IDR_CACLV));
                //----------------------------------------------------------------
                hMenu = CHwxFE::GetMenu(m_hInstance, MAKEINTRESOURCE(IDR_CACLV));
                if (hMenu)
                {
                    hMenuTrackPopup = GetSubMenu (hMenu, 0);
                    ClientToScreen(m_hLVWnd,&pt);
                    hMenuSub = GetSubMenu(hMenuTrackPopup,2);
                    if ( m_bLargeView )
                    {
                         CheckMenuItem(hMenuSub,1,MF_BYPOSITION | MF_UNCHECKED);
                         CheckMenuItem(hMenuSub,0,MF_BYPOSITION | MF_CHECKED);
                    }
                    else
                    {
                         CheckMenuItem(hMenuSub,0,MF_BYPOSITION | MF_UNCHECKED);
                         CheckMenuItem(hMenuSub,1,MF_BYPOSITION | MF_CHECKED);
                    }
                    WCHAR     wch;
                    wch = GetWCHAR(m_lpPlvInfo->index);
                    
#ifdef OLD_970811 //ToshiaK. do not load radical bitmap for #1231
                    kanji.mask = KIF_ALL;
#else
                    kanji.mask = KIF_YOMI | KIF_ITAIJI;
#endif
                    kanji.cItaijiCount = 0;
                    memset(kanji.wchItaiji,'\0',sizeof(kanji.wchItaiji));
                    memset(m_wchOther,'\0',sizeof(m_wchOther));
                    if ( wch && m_pIImeSkdic )
                    {
                        m_pIImeSkdic->GetKanjiInfo(wch,&kanji);
                    }
                    HBITMAP hBmp[MAX_ITAIJI_COUNT+1]= {NULL};
                    if ( kanji.cItaijiCount )
                    {
                        DeleteMenu( hMenuTrackPopup, IDM_CACLVSENDOTHER_NONE, MF_BYCOMMAND );
                        for ( int ibmp = 0; ibmp < kanji.cItaijiCount; ibmp++)
                        {
#ifndef UNDER_CE // Windows CE does not support MF_BITMAP on AppendMenu
                             hBmp[ibmp] = makeCharBitmap(kanji.wchItaiji[ibmp]);
                            m_wchOther[ibmp] = kanji.wchItaiji[ibmp];
                            AppendMenu(GetSubMenu(hMenuTrackPopup,1) , MF_BITMAP, IDM_CACLVSENDOTHER_NONE+100+ibmp, (LPCTSTR)hBmp[ibmp] );
#else // UNDER_CE
                            TCHAR chItaiji[2] = {kanji.wchItaiji[ibmp], TEXT('\0')};
                            AppendMenu(GetSubMenu(hMenuTrackPopup,1), MF_STRING,
                                       IDM_CACLVSENDOTHER_NONE+100+ibmp, chItaiji);
#endif // UNDER_CE
                        }
                    }
                    else
                    {
                        EnableMenuItem(hMenuTrackPopup,1,MF_BYPOSITION | MF_GRAYED);
                    }

#if 1 // kwada : bold menu item
#ifndef UNDER_CE // Windows CE does not support SetMenuDefaultItem
                    SetMenuDefaultItem(hMenuTrackPopup,IDM_CACLVSENDCHAR,FALSE);
#endif // UNDER_CE
#endif
#ifndef UNDER_CE // Windows CE does not support TPM_LEFTBUTTON on TrackPopupMenu
                    TrackPopupMenu (hMenuTrackPopup, TPM_LEFTALIGN | TPM_LEFTBUTTON, pt.x, pt.y, 0,m_hCACWnd, NULL);
#else // UNDER_CE
                    TrackPopupMenu(hMenuTrackPopup, TPM_LEFTALIGN, pt.x, pt.y, 0,m_hCACWnd, NULL);
#endif // UNDER_CE
                    DestroyMenu (hMenu);
                    if( hBmp[0] ) 
                    {
                        for( int i=0; i<kanji.cItaijiCount; i++ ) 
                        {
                            if( hBmp[i] ) 
                            {
                                DeleteObject( hBmp[i] );
                            }
                        }
                    }

                }
            }
            break;
#endif // FE_JAPANESE
//  !!! CAC context menu END !!!
//////////////////////////////////////////////////////////////////////////////

        case PLVN_R_ITEMCOLUMNCLICKED:
            break;
        case PLVN_R_ITEMDBLCLICKED:
            break;
        case PLVN_R_ITEMCOLUMNDBLCLICKED:
            break;
        case PLVN_HDCOLUMNCLICKED:
    #ifdef FE_JAPANESE        
            if ( m_lpPlvInfo )
                sortKanjiInfo(m_lpPlvInfo->colIndex - 0);
            PadListView_Update(m_hLVWnd);
    #endif
            break;
        default:
             break;
    }
    Unref(hwnd);
    Unref(wp);
}

void CHwxCAC::GetInkFromMB(CHwxStroke & str,long deltaX,long deltaY)
{
     *m_pCHwxStroke = str;
    if ( !GetStrokeCount() )
    {
        return;
    }
    m_pCHwxStroke->ScaleInkXY(deltaX,deltaY);
    long X = (m_pInk->GetMBHeight() - m_inkSize)/2;
    long Y = (m_pInk->GetMBHeight() - m_inkSize)/2;

    if ( X || Y )
        m_pCHwxStroke->ScaleInkXY(X,Y);

    HandleResizePaint(m_hCACWnd);

    if ( m_pInk->IsSglClk() || m_pInk->IsDblClk() )
        recognize();
}

void CHwxCAC::HandleDeleteOneStroke()
{
    if ( GetStrokeCount() )
        m_pCHwxStroke->EraseCurrentStroke();

    if ( !GetStrokeCount() )
    {
        memset(m_gawch, '\0', sizeof(m_gawch));
        m_cnt = 0;
        PadListView_SetItemCount(m_hLVWnd,0);
        if(IsNT()) { //ToshiaK:980324
            PadListView_SetExplanationTextW(m_hLVWnd,wchDisp[1]);
        }
        else {
#ifndef UNDER_CE // Windows CE always Unicode
            PadListView_SetExplanationText(m_hLVWnd,szDisp[1]);
#endif // UNDER_CE
        }
        PadListView_Update(m_hLVWnd);
        InitBitmap(MACAW_REDRAW_BACKGROUND, 0);
        InitBitmap(MACAW_REDRAW_INK, 0);
        InvalidateRect(m_hCACWnd, NULL, FALSE);
        return;
    }
    if ( !Is16BitApp() && ( m_pInk->IsSglClk() || m_pInk->IsDblClk()) )
        recognize();
    PadListView_Update(m_hLVWnd);
    InitBitmap(MACAW_REDRAW_INK, 0);
    InvalidateRect(m_hCACWnd, NULL, FALSE);
}

void CHwxCAC::HandleDeleteAllStroke()
{
    if ( GetStrokeCount() )
    {
        m_pCHwxStroke->DeleteAllStroke();
        InitBitmap(MACAW_REDRAW_BACKGROUND, 0);
        InvalidateRect(m_hCACWnd, NULL, FALSE);
    }
}

LRESULT CHwxCAC::HandleCommand(HWND hwnd, UINT msg, WPARAM wp,LPARAM lp)
{
     UINT uCode =(UINT)LOWORD(wp);
    WCHAR wch;
    switch ( uCode )
    {
        case IDM_CACRECOG:
            if ( Is16BitApp() )
            {
              m_pCHwxThreadCAC->RecognizeNoThread(m_inkSize);
            }
            else
            {
                if ( !m_pInk->IsDblClk() && !m_pInk->IsSglClk() )
                {
                     m_pInk->SetSglClk(TRUE);
                    recognize();
                }
            }
            return 0;
        case IDM_CACDELETEONE:
            HandleDeleteOneStroke();
            return 0;
        case IDM_CACDELETEALL:
            HandleDeleteAllStroke();
            return 0;
        case IDM_CACAUTORECOG:
            // no 16 bit app events here
            if ( !Is16BitApp() )
            {
                m_pInk->SetDblClk(!m_pInk->IsDblClk());
                m_pInk->UpdateRegistry(TRUE/*fSet*/);    //SATORI #73 by HiroakiK                
                if ( m_pInk->IsDblClk() )
                    recognize();
            }
            return 0;
        case IDM_CACLVSENDCHAR:
            if ( m_lpPlvInfo )
                pickUpChar(m_lpPlvInfo);
            return 0;
        case IDM_CACLVSENDOTHER_NONE+100:
        case IDM_CACLVSENDOTHER_NONE+101:
        case IDM_CACLVSENDOTHER_NONE+102:
        case IDM_CACLVSENDOTHER_NONE+103:
        case IDM_CACLVSENDOTHER_NONE+104:
        case IDM_CACLVSENDOTHER_NONE+105:
        case IDM_CACLVSENDOTHER_NONE+106:
        case IDM_CACLVSENDOTHER_NONE+107:
        case IDM_CACLVSENDOTHER_NONE+108:
        case IDM_CACLVSENDOTHER_NONE+109:
        case IDM_CACLVSENDOTHER_NONE+110:
        case IDM_CACLVSENDOTHER_NONE+111:
        case IDM_CACLVSENDOTHER_NONE+112:
        case IDM_CACLVSENDOTHER_NONE+113:
        case IDM_CACLVSENDOTHER_NONE+114:
        case IDM_CACLVSENDOTHER_NONE+115:
        case IDM_CACLVSENDOTHER_NONE+116:
#ifdef FE_JAPANESE        
            if ( wch = m_wchOther[uCode-(IDM_CACLVSENDOTHER_NONE+100)] )
                pickUpCharHelper(wch);
            memset(m_wchOther,'\0',sizeof(m_wchOther));
#endif            
            return 0;
        case IDM_CACLVDISPLAY_LARGE:
            if ( !m_bLargeView )
            {
                PadListView_SetStyle(m_hLVWnd,PLVSTYLE_ICON);
            //    m_pInk->SetLargeBtn();
                m_bLargeView = TRUE;
                if(m_pInk) {
                    m_pInk->OnChangeView(TRUE);
                }
            }
            return 0;
        case IDM_CACLVDISPLAY_DETAIL:
            if ( m_bLargeView )
            {
                PadListView_SetStyle(m_hLVWnd,PLVSTYLE_REPORT);
                m_bLargeView = FALSE;
                if(m_pInk) {
                    m_pInk->OnChangeView(FALSE);
                }
            }
            return 0;
#ifdef FE_JAPANESE        
        case IDM_CACLVDISPLAYOTHER_KANJI:
        case IDM_CACLVDISPLAYOTHER_STROKE:
        case IDM_CACLVDISPLAYOTHER_RADICAL:
        case IDM_CACLVDISPLAYOTHER_R1:
        case IDM_CACLVDISPLAYOTHER_R2:
        case IDM_CACLVDISPLAYOTHER_K1:
        case IDM_CACLVDISPLAYOTHER_K2:
        case IDM_CACLVDISPLAYOTHER_OTHER:
            sortKanjiInfo(uCode-IDM_CACLVDISPLAYOTHER_KANJI);
            PadListView_Update(m_hLVWnd);
            return 0;
#endif // FE_JAPANESE        

        default:
            break;
    }
    return DefWindowProc(hwnd, msg, wp, lp);
}

//----------------------------------------------------------------
//990618:ToshiaK for KOTAE #1329
//----------------------------------------------------------------
void
CHwxCAC::OnSettingChange(UINT msg, WPARAM wp,LPARAM lp)
{
#ifndef UNDER_CE // Unsupported.
    if(wp == SPI_SETNONCLIENTMETRICS) {
        if(m_pCHwxStroke) {
            m_pCHwxStroke->ResetPen();
        }
    }
#else // UNDER_CE
    if(m_pCHwxStroke) {
        m_pCHwxStroke->ResetPen();
    }
#endif // UNDER_CE
    UNREFERENCED_PARAMETER(msg);
    UNREFERENCED_PARAMETER(lp);
}

int WINAPI GetItemForIcon(LPARAM lParam, int index, LPPLVITEM lpPlvItem)
{
    CHwxCAC * pCac = (CHwxCAC *)lParam;
    if ( pCac )
    {
        wchChar[0][0] = pCac->GetWCHAR(index);
        wchChar[0][1] = (WCHAR)0x0000;
        if ( wchChar[0][0] )
        {
            lpPlvItem->lpwstr = wchChar[0];
        }
        else
        {
            lpPlvItem->lpwstr = NULL;
        }
    }
    return 0;
}

#ifdef FE_JAPANESE
int WINAPI GetItemForReport(LPARAM lParam, int index, INT indexCol, LPPLVITEM lpPlvItem)
{
    CHwxCAC * pCac = (CHwxCAC *)lParam;
    WCHAR     wch;

    if ( pCac && (wch = pCac->GetWCHAR(index)) && indexCol <= 8 )
    {
        memset(&kanji,'\0',sizeof(kanji));
        kanji.mask = KIF_ALL;
        //981119: for KK RAID #6435
        //case for imeskdic.dll does not exist. 
        if(pCac->GetIIMESKDIC()){
            (pCac->GetIIMESKDIC())->GetKanjiInfo(wch,&kanji);
        }
        for ( int i = 0; i < indexCol; i++)
        {
            switch(i) 
            {
                case 0:
                    lpPlvItem[i].fmt = PLVFMT_TEXT;
                    wchChar[i][0] = wch;
                    wchChar[i][1] = (WCHAR)0x0000;
                    lpPlvItem[i].lpwstr = wchChar[i];
                    break;
                case 1:
                    lpPlvItem[i].fmt = PLVFMT_TEXT;
                    if ( kanji.usTotalStroke )
                    {
                        swprintf(wchChar[i], L"%d", kanji.usTotalStroke);
                    }
                    else
                    {
                        wchChar[i][0] = (WCHAR)0x0000;
                    }
                    lpPlvItem[i].lpwstr = wchChar[i];
                    break;
                case 2:
                    lpPlvItem[i].fmt = PLVFMT_BITMAP;
                    lpPlvItem[i].hBitmap = kanji.hBmpRadical;
                    break;
                case 3:
                    lpPlvItem[i].fmt = PLVFMT_TEXT;
                    lpPlvItem[i].lpwstr = kanji.wchOnYomi1;
                    break;
                case 4:
                    lpPlvItem[i].fmt = PLVFMT_TEXT;
                    lpPlvItem[i].lpwstr = kanji.wchOnYomi2;
                    break;
                case 5:
                    lpPlvItem[i].fmt = PLVFMT_TEXT;
                    lpPlvItem[i].lpwstr = kanji.wchKunYomi1;
                    break;
                case 6:
                    lpPlvItem[i].fmt = PLVFMT_TEXT;
                    lpPlvItem[i].lpwstr = kanji.wchKunYomi2;
                    break;
                case 7:
                    lpPlvItem[i].fmt = PLVFMT_TEXT;
                    lpPlvItem[i].lpwstr = kanji.wchItaiji;
                    break;
                default:
                    break;
            }
        }
    }
    return 0;
}
#endif //FE_JAPANESE

void CHwxCAC::SetToolTipInfo(BOOL bAdd)
{
    ti.cbSize = sizeof(TOOLINFOW);
    ti.uFlags = 0;
    ti.hwnd = m_hCACWnd;
    ti.hinst = m_hInstance;
    ti.lpszText = LPSTR_TEXTCALLBACKW; 
    ti.uId = IDC_CACLISTVIEW;
    UINT message = bAdd ? TTM_ADDTOOLW : TTM_NEWTOOLRECTW;
    HWND hwndTT = m_pInk->GetToolTipWindow();

    if ( bAdd )
    {
        ti.rect.left = ti.rect.top = ti.rect.right = ti.rect.bottom = 0;
        SendMessage(hwndTT,message,0,(LPARAM)(LPTOOLINFOW)&ti);
    }
    else
    {
        ti.rect = m_lpPlvInfo->itemRect;
        SendMessage(hwndTT,message,0,(LPARAM)(LPTOOLINFOW)&ti);
    }
}
 
void CHwxCAC::SetToolTipText(LPARAM lp)
{
    WCHAR wch;
    //BOOL bEmpty = FALSE;
    static WCHAR tip[60];
    LPTOOLTIPTEXTUSERINFO lpttt = (LPTOOLTIPTEXTUSERINFO)lp;
    int index = (int)((lpttt->userInfo).lParam);
    wch = GetWCHAR(index);

    //----------------------------------------------------------------
    //980805:ToshiaK. creating Tip string function has Moved to CHwxFE
    //----------------------------------------------------------------
    //980813:ToshiaK. merged with PRC fix
    memset(tip,'\0', sizeof(tip));
    if (-1 == CHwxFE::GetTipText(wch,
                                 tip,
                                 sizeof(tip)/sizeof(tip[0]), 
    #ifdef FE_KOREAN
                                  NULL)) 
    #else 
                                 m_pIImeSkdic)) 
    #endif

    {
         lpttt->lpszText = NULL; 
    } else {
         lpttt->lpszText = tip; 
    }
}

#ifdef FE_JAPANESE
// increasing order
int _cdecl CompareChar(const void * lp1, const void * lp2)
{
    LPKANJIINFO p1= (LPKANJIINFO)lp1;
    LPKANJIINFO p2= (LPKANJIINFO)lp2;
    if ( p1->wchKanji < p2->wchKanji )
        return -1;
    else if ( p1->wchKanji > p2->wchKanji )
        return 1;
    return 0;
}

// increasing order
int _cdecl CompareStroke(const void * lp1, const void * lp2)
{

    LPKANJIINFO p1= (LPKANJIINFO)lp1;
    LPKANJIINFO p2= (LPKANJIINFO)lp2;
    if ( p1->usTotalStroke < p2->usTotalStroke )
        return -1;
    else  if ( p1->usTotalStroke > p2->usTotalStroke )
        return 1;
    return 0;
}

// increasing order
int _cdecl CompareRadical(const void * lp1, const void * lp2)
{

    LPKANJIINFO p1= (LPKANJIINFO)lp1;
    LPKANJIINFO p2= (LPKANJIINFO)lp2;
    if ( p1->lRadicalIndex < p2->lRadicalIndex )
        return -1;
    else  if ( p1->lRadicalIndex > p2->lRadicalIndex )
        return 1;
    return 0;
}

// decreasing order
int _cdecl CompareR1(const void * lp1, const void * lp2)
{
    LPKANJIINFO p1= (LPKANJIINFO)lp1;
    LPKANJIINFO p2= (LPKANJIINFO)lp2;
    int i;
    for( i = 0; i < MAX_YOMI_COUNT+1; i++)
    {
        if ( p2->wchOnYomi1[i] < p1->wchOnYomi1[i] )
            return -1;
        else if ( p2->wchOnYomi1[i] > p1->wchOnYomi1[i] )
            return 1;
    }
    return 0;
}

// decreasing order
int _cdecl CompareR2(const void * lp1, const void * lp2)
{
       LPKANJIINFO p1= (LPKANJIINFO)lp1;
    LPKANJIINFO p2= (LPKANJIINFO)lp2;
    int i;
    for( i = 0; i < MAX_YOMI_COUNT+1; i++)
    {
        if ( p2->wchOnYomi2[i] < p1->wchOnYomi2[i] )
            return -1;
        else if ( p2->wchOnYomi2[i] > p1->wchOnYomi2[i] )
            return 1;
    }
    return 0;
}

// decreasing order
int _cdecl CompareK1(const void * lp1, const void * lp2)
{
    LPKANJIINFO p1= (LPKANJIINFO)lp1;
    LPKANJIINFO p2= (LPKANJIINFO)lp2;
    int i;
    for( i = 0; i < MAX_YOMI_COUNT+1; i++)
    {
        if ( p2->wchKunYomi1[i] < p1->wchKunYomi1[i] )
            return -1;
        else if ( p2->wchKunYomi1[i] > p1->wchKunYomi1[i] )
            return 1;
    }
    return 0;
}

// decreasing order
int _cdecl CompareK2(const void * lp1, const void * lp2)
{
    LPKANJIINFO p1= (LPKANJIINFO)lp1;
    LPKANJIINFO p2= (LPKANJIINFO)lp2;
    int i;
    for( i = 0; i < MAX_YOMI_COUNT+1; i++)
    {
        if ( p2->wchKunYomi2[i] < p1->wchKunYomi2[i] )
            return -1;
        else if ( p2->wchKunYomi2[i] > p1->wchKunYomi2[i] )
            return 1;
    }
    return 0;
}

// decreasing order
int _cdecl CompareOther(const void * lp1, const void * lp2)
{
    LPKANJIINFO p1= (LPKANJIINFO)lp1;
    LPKANJIINFO p2= (LPKANJIINFO)lp2;
    int i;
    for( i = 0; i < MAX_ITAIJI_COUNT; i++)
    {
        if ( p2->wchItaiji[i] < p1->wchItaiji[i] )
            return -1;
        else if ( p2->wchItaiji[i] > p1->wchItaiji[i] )
            return 1;
    }
    return 0;
}
#endif // FE_JAPANESE


#ifdef FE_JAPANESE
void CHwxCAC::sortKanjiInfo(int sortID)
{
    KANJIINFO kanjiData[LISTTOTAL];
    int i;
    if ( m_cnt <= LISTTOTAL && m_cnt > 0 && sortID >= 0 && sortID < LISTVIEW_COLUMN )
    {
         // get data
        memset(kanjiData,'\0',sizeof(KANJIINFO) * LISTTOTAL);
        for ( i = 0; i < m_cnt; i++ ) 
        {
            kanjiData[i].mask = KIF_STROKECOUNT | KIF_YOMI | KIF_ITAIJI | KIF_RADICALINDEX;
            kanjiData[i].wchKanji = m_gawch[i];
             m_pIImeSkdic->GetKanjiInfo(m_gawch[i],&kanjiData[i]);
        }
        // sort data
        switch ( sortID )
        {
             case 0:
                qsort(kanjiData,m_cnt,sizeof(KANJIINFO),CompareChar);
                break;
            case 1:
                qsort(kanjiData,m_cnt,sizeof(KANJIINFO),CompareStroke);
                break;
            case 2:
                qsort(kanjiData,m_cnt,sizeof(KANJIINFO),CompareRadical);
                break;
            case 3:
                qsort(kanjiData,m_cnt,sizeof(KANJIINFO),CompareR1);
                break;
            case 4:
                qsort(kanjiData,m_cnt,sizeof(KANJIINFO),CompareR2);
                break;
            case 5:
                qsort(kanjiData,m_cnt,sizeof(KANJIINFO),CompareK1);
                break;
            case 6:
                qsort(kanjiData,m_cnt,sizeof(KANJIINFO),CompareK2);
                break;
            case 7:
                qsort(kanjiData,m_cnt,sizeof(KANJIINFO),CompareOther);
                break;
        }
        // copy sorted UNICODE
        for ( i = 0; i < m_cnt; i ++)
        {
             m_gawch[i] = kanjiData[i].wchKanji;
        }
    }
}
#endif // FE_JAPANESE

void CHwxCAC::SetInkSize(int n)
{    
    m_inkSize = n;
}

void CHwxCAC::HandleDrawSample()
{
#ifdef FE_JAPANESE
    int i = 0;
    POINT pt;
    if ( !m_bDrawSample )
    {
        return;
    }
    while( wSamplePt[i] ) 
    {
        while( wSamplePt[i] ) 
        {
            pt.x = HIBYTE(wSamplePt[i]);
            pt.y = LOBYTE(wSamplePt[i]);

            // scaling
            pt.x = (m_inkSize*pt.x)/120;
            pt.y = (m_inkSize*pt.y)/120;
            
            m_pCHwxStroke->AddPoint(pt);
            i++;
        }
        m_pCHwxStroke->AddBoxStroke(0,0,0);
        i++;
    }
    InvalidateRect(m_hCACWnd,NULL,FALSE);
    UpdateWindow(m_hCACWnd);
//  too slow when calling this function
//    NoThreadRecognize(m_inkSize);

//  cache recognition results
    memcpy(m_gawch, wSampleChar, sizeof(wSampleChar));
    m_cnt = sizeof(wSampleChar)/sizeof(wchar_t);
    PadListView_SetItemCount(m_hLVWnd,m_cnt);
    if(IsNT()) 
    { 
        PadListView_SetExplanationTextW(m_hLVWnd,NULL);
    }
    else 
    {
        PadListView_SetExplanationText(m_hLVWnd,NULL);
    }
    PadListView_Update(m_hLVWnd);

#endif // FE_JAPANESE

    m_bDrawSample = FALSE;
}

#if 0
void CHwxCAC::HandleMeasureItem(HWND hwnd, LPARAM lp)
{
    LPMEASUREITEMSTRUCT lpmi = (LPMEASUREITEMSTRUCT)lp;

    if ( lpmi->CtlType == ODT_MENU )
    {
        HDC hDC = GetDC(hwnd);
        SIZE    size;
        LPTSTR lptstr = (LPTSTR)lpmi->itemData;
        GetTextExtentPoint32(hDC, lptstr, strlen(lptstr), &size);
        lpmi->itemWidth = size.cx + 22;
        lpmi->itemHeight = 20;
        ReleaseDC(hwnd, hDC);
    }
}

void CHwxCAC::HandleDrawItem(HWND hwnd, LPARAM lp)
{
    LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lp;

    if( lpdis->CtlType == ODT_MENU ) 
    {
        if ( lpdis->itemAction & ODA_DRAWENTIRE ||
             lpdis->itemAction & ODA_SELECT || 
             lpdis->itemAction & ODA_FOCUS ) 
        {
            HBRUSH    hBrush;
            RECT    rcItem;
            DWORD    dwOldTextColor, dwOldBkColor; 
            HICON     hIcon;

            if(lpdis->itemState & ODS_SELECTED) 
            {
                hBrush         = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
                dwOldBkColor   = SetBkColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
                dwOldTextColor = SetTextColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                hIcon = LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_SELECTED));
            }
            else 
            {
                hBrush         = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
                dwOldBkColor   = SetBkColor(lpdis->hDC, GetSysColor(COLOR_BTNFACE));
                dwOldTextColor = SetTextColor(lpdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
                hIcon = LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_UNSELECT));
            }

            FillRect(lpdis->hDC, (LPRECT)&lpdis->rcItem, hBrush);        
            CopyRect(&rcItem, &lpdis->rcItem);

               SIZE size;
            if(lpdis->itemID == IDM_CACAUTORECOG && lpdis->itemState != ODS_GRAYED ) 
            {
                DrawIconEx(lpdis->hDC, 
                       rcItem.left+2, 
                       rcItem.top+2,
                       hIcon, 
                       16,
                       16,
                       0,
                       NULL, 
                       DI_NORMAL); 
            }
            CopyRect(&rcItem, &lpdis->rcItem);
            GetTextExtentPoint32(lpdis->hDC, 
                                 (LPTSTR)lpdis->itemData,
                                 strlen((LPTSTR)lpdis->itemData),
                                  &size);
            ExtTextOut(lpdis->hDC, 
                       rcItem.left+22,
                       rcItem.top + (rcItem.bottom - rcItem.top - size.cy)/2,
                       ETO_CLIPPED,
                       &rcItem,
                       (LPTSTR)lpdis->itemData,
                       strlen((LPTSTR)lpdis->itemData),
                        NULL);
            DeleteObject(hBrush);
            SetBkColor(lpdis->hDC, dwOldBkColor);
            SetTextColor(lpdis->hDC, dwOldTextColor);
        }
    }
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxink.cpp ===
#include "hwxobj.h"
#include "resource.h"
#include "const.h"
#include "../lib/ptt/ptt.h"
#include "../lib/ddbtn/ddbtn.h"
#include "../lib/exbtn/exbtn.h"
#include "dbg.h"
#include "../common/cfont.h"
#include "hwxfe.h"
#include "cexres.h"
#include "cmnhdr.h"
#ifdef UNDER_CE // Windows CE Stub for unsupported APIs
#include "stub_ce.h"
#endif // UNDER_CE

// implementation of CHwxInkWindow
extern TCHAR szBuf[MAX_PATH];
extern TOOLINFOW ti;
WCHAR wszBuf[32];
        
CHwxInkWindow::CHwxInkWindow(BOOL bNT, BOOL b16, CApplet * pApp, HINSTANCE hInst):CHwxObject(hInst)
{
    m_pApplet = pApp;
//    m_hInstance = hInst;
    m_pMB = NULL;
    m_pCAC = NULL;
    m_hInkWnd = NULL;
    m_b16Bit = b16;
    m_bNT = bNT;
    m_bCAC = TRUE;
    m_bSglClk = FALSE;
    m_bDblClk = m_b16Bit ? FALSE : TRUE;
    m_hwndTT = NULL;
    m_bMouseDown = FALSE;

    m_hCACMBMenu = NULL;
    m_hCACMBRecog = NULL;
    m_hCACMBRevert = NULL;
    m_hCACMBClear = NULL;
    m_hCACSwitch = NULL;
    m_CACMBMenuDDBtnProc = NULL;
    m_CACMBRecogEXBtnProc = NULL;
    m_CACMBRevertEXBtnProc = NULL;
    m_CACMBClearEXBtnProc = NULL;
    m_CACSwitchDDBtnProc = NULL;
    
//    m_hwxPadWidth = 0;

    m_wPadHeight = PadWnd_Height;
    m_numBoxes = 2;       
    m_wPadWidth = m_numBoxes * m_wPadHeight;

    m_wInkWidth = m_wPadWidth + 4 + BUTTON_WIDTH;
    m_wInkHeight = m_wPadHeight;

    m_wCACInkHeight = PadWnd_Height;
     m_wCACPLVWidth = m_wCACInkHeight + 150;
     m_wCACPLVHeight = m_wCACInkHeight;
    m_wCACTMPWidth = m_wCACPLVWidth - m_wCACInkHeight;

    m_wCACWidth = m_wCACPLVWidth + 4 + BUTTON_WIDTH;
    m_wCACHeight = m_wCACPLVHeight;

//    m_wMaxHeight = (GetSystemMetrics(SM_CYSCREEN)*3)/4;

//    m_wCurrentCtrlID = 0;
//    m_dwLastTick = 0;
//    m_dwBtnUpCount = 0;
//    m_bRedundant = FALSE;
}

CHwxInkWindow::~CHwxInkWindow()
{
}

BOOL CHwxInkWindow::Initialize(TCHAR * pClsName)
{
     BOOL bRet = CHwxObject::Initialize(pClsName);

    if ( bRet )
    {
        WNDCLASS    wndClass;
        wndClass.style          = CS_HREDRAW | CS_VREDRAW;
        wndClass.lpfnWndProc    = HWXWndProc;
        wndClass.cbClsExtra     = 0;
        wndClass.cbWndExtra     = sizeof(void *);
        wndClass.hInstance      = m_hInstance;
        wndClass.hIcon          = 0;
        wndClass.hCursor        = 0;
#ifndef UNDER_CE
        wndClass.hbrBackground  = (HBRUSH)(COLOR_3DFACE+1);
#else // UNDER_CE
        wndClass.hbrBackground  = GetSysColorBrush(COLOR_3DFACE);
#endif // UNDER_CE
        wndClass.lpszMenuName   = NULL;
        wndClass.lpszClassName  = TEXT("HWXPad");


#if 0 
        if (!RegisterClass(&wndClass)) 
            return FALSE;
#endif
        //971217: ToshiaK no need to check return
        RegisterClass(&wndClass);


        if  ( !m_b16Bit )
        {
             m_pMB = new CHwxMB(this,m_hInstance);
            if ( !m_pMB )
                return FALSE;
            bRet = m_pMB->Initialize(TEXT("CHwxMB"));
            if ( !bRet )
            {
                 delete m_pMB;
                m_pMB = NULL;
                return FALSE;
            }
        }

        m_pCAC = new CHwxCAC(this,m_hInstance);
        if ( !m_pCAC )
        {
            if ( m_pMB )
            {
                 delete m_pMB;
                m_pMB = NULL;
            }
            return FALSE;
        }
        bRet = m_pCAC->Initialize(TEXT("CHwxCAC"));
        if ( !bRet )
        {
            if ( m_pMB )
            {
                 delete m_pMB;
                m_pMB = NULL;
            }
            delete m_pCAC;
            m_pCAC = NULL;
            return FALSE;
        }
    }
    InitCommonControls();
    return bRet;
}

BOOL CHwxInkWindow::CreateUI(HWND hwndParent)
{
    //990601:kotae #434 add WS_CLIPCHILDREN to remove flicker
    m_hInkWnd = CreateWindowEx(0,
                                TEXT("HWXPad"),
                               TEXT(""),
                               WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN,
                               0,0,0,0,
                               hwndParent,
                               NULL,m_hInstance,this);
    if ( !m_hInkWnd )
    {
         return FALSE;
    }
    if ( m_pMB )        // NULL means we have a 16-bit program
    {
         if ( !m_pMB->CreateUI(m_hInkWnd) )
        {
             DestroyWindow(m_hInkWnd);
            m_hInkWnd = NULL;
            return FALSE;
        }
    }
    if ( m_pCAC )
    {
         if ( !m_pCAC->CreateUI(m_hInkWnd) )
        {
             DestroyWindow(m_hInkWnd);
            m_hInkWnd = NULL;
            if ( m_pMB )
            {
                DestroyWindow(m_pMB->GetMBWindow());
                m_pMB->SetMBWindow(NULL);
            }
            return FALSE;
        }
    }
    ChangeLayout(FALSE);    
    SetTooltipInfo();
    return TRUE;
}

BOOL CHwxInkWindow::Terminate()
{
    Dbg(("CHwxInkWindow::Terminate\n"));
    if ( m_pCAC )
    {
        (m_pCAC->GetCACThread())->StopThread();
    }
    if ( m_pMB )
    {
        (m_pMB->GetMBThread())->StopThread();
    }
    if ( m_pCAC )
    {
         delete m_pCAC;
        m_pCAC = NULL;
    }
    if ( m_pMB )
    { 
         delete m_pMB;
        m_pMB = NULL;
    }
    if ( m_hInkWnd )
    {
         DestroyWindow(m_hInkWnd);
        m_hInkWnd = NULL;
    }
    if ( m_hwndTT )
    {
         DestroyWindow(m_hwndTT);
        m_hwndTT = NULL;
    }
    m_pApplet = NULL;

    if ( m_hCACMBMenu )
    {
         DestroyWindow(m_hCACMBMenu);
        m_hCACMBMenu = NULL;
    }
    if ( m_hCACMBRecog )
    {
         DestroyWindow(m_hCACMBRecog);
        m_hCACMBRecog = NULL;
    }
    if ( m_hCACMBRevert )
    {
         DestroyWindow(m_hCACMBRevert);
        m_hCACMBRevert = NULL;
    }
    if ( m_hCACMBClear )
    {
         DestroyWindow(m_hCACMBClear);
        m_hCACMBClear = NULL;
    }
    if ( m_hCACSwitch )
    {
         DestroyWindow(m_hCACSwitch);
        m_hCACSwitch = NULL;
    }

    m_CACMBMenuDDBtnProc = NULL;
    m_CACMBRecogEXBtnProc = NULL;
    m_CACMBRevertEXBtnProc = NULL;
    m_CACMBClearEXBtnProc = NULL;
    m_CACSwitchDDBtnProc = NULL;

#if 0
    m_btnMB.Destroy();
    m_btnMBRecog.Destroy();
    m_btnDelAll.Destroy();
    m_btnMBProp.Destroy();

    m_btnCAC.Destroy();
    m_btnRecog.Destroy();
    m_btnDel.Destroy();
    m_btnDelAllCAC.Destroy();
    m_btnDetail.Destroy();
    m_btnLarge.Destroy();
#endif //0
    return TRUE;
}

BOOL CHwxInkWindow::HandleCreate(HWND hwnd)
{
    HICON hIcon;
    HFONT hFont = NULL;
    static DDBITEM ddbItem;
    int i;
    m_hwndTT = ToolTip_CreateWindow(m_hInstance,TTS_ALWAYSTIP,hwnd);

#ifdef FE_CHINESE_SIMPLIFIED
    //980805:ToshiaK
    //In Win95 PRC's DEFAULT_GUI_FONT glyph is little bit ugly.
    //so use SYSTEM_FONT instead.
    //if(TRUE) { //TEST
    if(IsWin95() && m_hwndTT) {
        SendMessage(m_hwndTT,
                    WM_SETFONT,
                    (WPARAM)GetStockObject(SYSTEM_FONT),
                    MAKELPARAM(TRUE,0));
    }
#endif

    m_hCACMBMenu = DDButton_CreateWindow(m_hInstance,
                                          hwnd,
                                          DDBS_ICON | DDBS_NOSEPARATED | DDBS_THINEDGE,
                                         IDC_CACMBMENU,
                                         0,
                                         0,
                                         BUTTON_WIDTH,
                                         BUTTON_HEIGHT);
    //----------------------------------------------------------------
    //980803:ToshiaKIn PRC H/W switch view is needless
    //----------------------------------------------------------------
#ifdef FE_JAPANESE
    m_hCACSwitch = DDButton_CreateWindow(m_hInstance,
                                          hwnd,
                                          DDBS_ICON | DDBS_THINEDGE,
                                         IDC_CACSWITCHVIEW,
                                         0,
                                         0,
                                         BUTTON_WIDTH,
                                         BUTTON_HEIGHT+4);
#elif FE_KOREAN || FE_CHINESE_SIMPLIFIED
    m_hCACSwitch = NULL;
#endif


    m_hCACMBRecog = EXButton_CreateWindow(m_hInstance,
                                    hwnd, 
                                    (m_bCAC && !m_b16Bit) ?
                                    (EXBS_TEXT | EXBS_TOGGLE |EXBS_DBLCLKS | EXBS_THINEDGE) : // kwada:980402:raid #852
                                    (EXBS_TEXT | EXBS_THINEDGE),
                                    IDC_CACMBRECOG,
                                    0,
                                    0,
                                    BUTTON_WIDTH,
                                    BUTTON_HEIGHT);


    m_hCACMBRevert = EXButton_CreateWindow(m_hInstance,
                                    hwnd, 
                                    EXBS_TEXT | EXBS_THINEDGE,
                                    IDC_CACMBREVERT,
                                    0,
                                    0,
                                    BUTTON_WIDTH,
                                    BUTTON_HEIGHT);

    m_hCACMBClear = EXButton_CreateWindow(m_hInstance,
                                    hwnd, 
                                    EXBS_TEXT | EXBS_THINEDGE,
                                    IDC_CACMBCLEAR,
                                    0,
                                    0,
                                    BUTTON_WIDTH,
                                    BUTTON_HEIGHT);

#ifdef FE_JAPANESE
    if ( !m_hwndTT || !m_hCACMBMenu || !m_hCACMBRecog || !m_hCACMBRevert ||
         !m_hCACMBClear || !m_hCACSwitch )
    {
        goto error;
    }
#elif FE_KOREAN || FE_CHINESE_SIMPLIFIED
    if(!m_hwndTT      ||
       !m_hCACMBMenu  ||
       !m_hCACMBRecog ||
       !m_hCACMBRevert||
       !m_hCACMBClear)
    {
        goto error;
    }
#endif

#ifdef FE_JAPANESE
    hIcon = (HICON)LoadImage(m_hInstance,
                             MAKEINTRESOURCE(IDI_HWXPAD),
                             IMAGE_ICON,
                             16,16,
                             LR_DEFAULTCOLOR);
#elif FE_KOREAN
    hIcon = (HICON)LoadImage(m_hInstance,
                             MAKEINTRESOURCE(IDI_HWXPADKO),
                             IMAGE_ICON,
                             16,16,
                             LR_DEFAULTCOLOR);
#elif FE_CHINESE_SIMPLIFIED
    hIcon = (HICON)LoadImage(m_hInstance,
                             MAKEINTRESOURCE(IDI_HWXPADSC),
                             IMAGE_ICON,
                             16,16,
                             LR_DEFAULTCOLOR);
#endif
    DDButton_SetIcon(m_hCACMBMenu, hIcon);

#ifdef FE_JAPANESE
    hIcon = (HICON)LoadImage(m_hInstance,
                             MAKEINTRESOURCE(IDI_CACSWITCHVIEW),
                             IMAGE_ICON,
                             16,16,
                             LR_DEFAULTCOLOR);
    DDButton_SetIcon(m_hCACSwitch, hIcon);
#endif

    for(i = 0; i < 2; i++) 
    {
        ddbItem.cbSize = sizeof(ddbItem);
        ddbItem.lpwstr = LoadCACMBString(IDS_CAC+i);
        DDButton_AddItem(m_hCACMBMenu, &ddbItem);

#ifdef FE_JAPANESE
        ddbItem.lpwstr = LoadCACMBString(IDS_CACLARGE+i);
        DDButton_AddItem(m_hCACSwitch, &ddbItem);
#endif // FE_JAPANESE
    }

    //990716:ToshiaK for Win64.
    WinSetUserPtr(m_hCACMBMenu, (LPVOID)this);
    m_CACMBMenuDDBtnProc = (FARPROC)WinSetWndProc(m_hCACMBMenu,
                                                  (WNDPROC)CACMBBtnWndProc);

#ifdef FE_JAPANESE
    //990810:ToshiaK for Win64
    WinSetUserPtr(m_hCACSwitch, (LPVOID)this);
    m_CACSwitchDDBtnProc = (FARPROC)WinSetWndProc(m_hCACSwitch,
                                                  GWL_WNDPROC,
                                                  (WNDPROC)CACMBBtnWndProc);
#endif // FE_JAPANESE
    if ( m_b16Bit )
    {
       EnableWindow(m_hCACMBMenu,FALSE);
    }

#ifdef FE_JAPANESE
    DDButton_SetCurSel(m_hCACSwitch,m_pCAC->IsLargeView() ? 0 : 1);
#endif

    EXButton_SetText(m_hCACMBRecog,LoadCACMBString(IDS_CACMBRECOG));
    //990810:ToshiaK for Win64.
    WinSetUserPtr(m_hCACMBRecog, (LPVOID)this);
    m_CACMBRecogEXBtnProc = (FARPROC)WinSetWndProc(m_hCACMBRecog,
                                                   (WNDPROC)CACMBBtnWndProc);

    EXButton_SetText(m_hCACMBRevert,LoadCACMBString(IDS_CACMBREVERT));
    WinSetUserPtr(m_hCACMBRevert, (LPVOID)this);
    m_CACMBRevertEXBtnProc = (FARPROC)WinSetWndProc(m_hCACMBRevert,
                                                   (WNDPROC)CACMBBtnWndProc);
    
    EXButton_SetText(m_hCACMBClear,LoadCACMBString(IDS_CACMBCLEAR));
    WinSetUserPtr(m_hCACMBClear, (LPVOID)this);
    m_CACMBClearEXBtnProc = (FARPROC)WinSetWndProc(m_hCACMBClear,
                                                   (WNDPROC)CACMBBtnWndProc);

    if ( m_bCAC )
    {
        exbtnPushedorPoped(m_bDblClk);
//        EXButton_SetCheck(m_hCACMBRecog, m_bDblClk);
    }
    else
    {
       EnableWindow(m_hCACMBRevert,FALSE);
    }

#ifdef FE_JAPANESE
    //----------------------------------------------------------------
    //980728: by ToshiaK for ActiveIME support
    // 
    //----------------------------------------------------------------
    //--------- Active IME support S T A R T --------------
    if(MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT) != ::GetUserDefaultLangID() &&
       (IsWin95() || IsWin98() || IsWinNT4())) {
           //990810:ToshiaK for #1030
        INT point = 9;
        hFont = CFont::CreateGUIFontByNameCharSet(TEXT("MS Gothic"),
                                                  SHIFTJIS_CHARSET,
                                                  point);

        if(!hFont) {
            hFont = CFont::CreateGUIFontByNameCharSet(TEXT("MS UI Gothic"),
                                                      SHIFTJIS_CHARSET,
                                                      point);
            if(!hFont) {
                hFont = CFont::CreateGUIFontByNameCharSet(TEXT("MS P Gothic"),
                                                          SHIFTJIS_CHARSET,
                                                          point);
            }
        }
    }
    if(hFont) {
        SendMessage(m_hwndTT, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        SendMessage(m_hCACMBMenu, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        SendMessage(m_hCACMBRecog, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        SendMessage(m_hCACMBRevert, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        SendMessage(m_hCACMBClear, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        SendMessage(m_hCACSwitch, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        //----------------------------------------------------------------
        //These control copy hFont in WM_SETFONT, so hFont is needless here.
        //----------------------------------------------------------------
        ::DeleteObject(hFont);
    }
    //--------- Active IME support E N D --------------
#elif FE_KOREAN
    //----------------------------------------------------------------
    //980728: by ToshiaK for ActiveIME support
    //Korean version: CSLim
    //----------------------------------------------------------------
    //--------- Active IME support S T A R T --------------
    if(MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT) != ::GetUserDefaultLangID() &&
       (IsWin95() || IsWin98() || IsWinNT4())) {
           //990810:ToshiaK for #1030
        INT point = 9;
        hFont = CFont::CreateGUIFontByNameCharSet(TEXT("Gulim"),
                                                  HANGUL_CHARSET,
                                                  point);

        if(!hFont) {
            hFont = CFont::CreateGUIFontByNameCharSet(TEXT("GulimChe"),
                                                      HANGUL_CHARSET,
                                                      point);
            
            if(!hFont) {
                hFont = CFont::CreateGUIFontByNameCharSet(TEXT("Batang"),
                                                          SHIFTJIS_CHARSET,
                                                          point);
            }
        }
    }
    if(hFont) {
        SendMessage(m_hwndTT, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        SendMessage(m_hCACMBMenu, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        SendMessage(m_hCACMBRecog, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        SendMessage(m_hCACMBRevert, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        SendMessage(m_hCACMBClear, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        SendMessage(m_hCACSwitch, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
        //----------------------------------------------------------------
        //These control copy hFont in WM_SETFONT, so hFont is needless here.
        //----------------------------------------------------------------
        ::DeleteObject(hFont);
    }
    //--------- Active IME support E N D --------------
#elif FE_CHINESE_SIMPLIFIED
    //----------------------------------------------------------------
    //980813:Toshiak:
    //Merged PRC fix.
    //In Win95 PRC's DEFAULT_GUI_FONT glyph is little bit ugly.
    //so use SYSTEM_FONT instead.
    //----------------------------------------------------------------
    if(IsWin95()) {
        SendMessage(m_hwndTT,
                    WM_SETFONT,
                    (WPARAM)GetStockObject(SYSTEM_FONT),
                    MAKELPARAM(TRUE,0));
         SendMessage(m_hCACMBRecog,
                    WM_SETFONT,
                    (WPARAM)GetStockObject(SYSTEM_FONT),
                    MAKELPARAM(TRUE,0));
         SendMessage(m_hCACMBRevert,
                    WM_SETFONT,
                    (WPARAM)GetStockObject(SYSTEM_FONT),
                    MAKELPARAM(TRUE,0));
         SendMessage(m_hCACMBClear,
                    WM_SETFONT,
                    (WPARAM)GetStockObject(SYSTEM_FONT),
                    MAKELPARAM(TRUE,0));
    }
#endif

    return TRUE;

error:
    Terminate();
    return FALSE;
    UNREFERENCED_PARAMETER(hFont);
}

void CHwxInkWindow::HandlePaint(HWND hwnd)
{
      RECT rcUpdate;
    RECT rcBkgnd;
    if ( GetUpdateRect(hwnd,&rcUpdate,FALSE) )
    {
        PAINTSTRUCT ps;
         HDC hdc = BeginPaint(hwnd, &ps);
        if ( ps.fErase )
        {
             if ( m_bCAC )
            {
                rcBkgnd.left = m_wCACWidth - 4 - BUTTON_WIDTH;
                 rcBkgnd.top = 0;
                rcBkgnd.right = rcBkgnd.left + 4 + BUTTON_WIDTH + 3*Box_Border;
                rcBkgnd.bottom = m_wCACHeight;
#ifndef UNDER_CE
                FillRect(hdc,&rcBkgnd,(HBRUSH)(COLOR_3DFACE+1));
#else // UNDER_CE
                FillRect(hdc,&rcBkgnd,GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE
            }
            else
            {
                rcBkgnd.left = m_wInkWidth - 4 - BUTTON_WIDTH;
                 rcBkgnd.top = 0;
                rcBkgnd.right = rcBkgnd.left + 4 + BUTTON_WIDTH + 3*Box_Border;
                rcBkgnd.bottom = m_wInkHeight;
#ifndef UNDER_CE
                FillRect(hdc,&rcBkgnd,(HBRUSH)(COLOR_3DFACE+1));
#else // UNDER_CE
                FillRect(hdc,&rcBkgnd,GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE
                if ( m_wPadHeight < CACMBHEIGHT_MIN )
                {
                    rcBkgnd.left = 0;
                     rcBkgnd.top = m_wPadHeight;
                    rcBkgnd.right = m_wPadWidth;
                    rcBkgnd.bottom = m_wInkHeight;
#ifndef UNDER_CE
                    FillRect(hdc,&rcBkgnd,(HBRUSH)(COLOR_3DFACE+1));
#else // UNDER_CE
                    FillRect(hdc,&rcBkgnd,GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE
                }
            }
        }
        InvalidateRect(m_hCACMBMenu,&rcUpdate,FALSE);
        UpdateWindow(m_hCACMBMenu);

        InvalidateRect(m_hCACMBRecog,&rcUpdate,FALSE);
        UpdateWindow(m_hCACMBRecog);

        InvalidateRect(m_hCACMBRevert,&rcUpdate,FALSE);
        UpdateWindow(m_hCACMBRevert);

        InvalidateRect(m_hCACMBClear,&rcUpdate,FALSE);
        UpdateWindow(m_hCACMBClear);
#ifdef FE_JAPANESE
        if ( m_bCAC )
        {
            InvalidateRect(m_hCACSwitch,&rcUpdate,FALSE);
            UpdateWindow(m_hCACSwitch);
        }
#endif
#if 0
        if ( m_b16Bit )
        {
             m_btnLarge.Paint(hdc,&rcUpdate);
             m_btnDetail.Paint(hdc,&rcUpdate);
            m_btnRecog.Paint(hdc,&rcUpdate);
            m_btnDelAllCAC.Paint(hdc,&rcUpdate);
            m_btnDel.Paint(hdc,&rcUpdate);
            m_btnCAC.Paint(hdc,&rcUpdate);
        }
        else
        {
            if ( m_bCAC )
            {
                 m_btnLarge.Paint(hdc,&rcUpdate);
                 m_btnDetail.Paint(hdc,&rcUpdate);
                m_btnRecog.Paint(hdc,&rcUpdate);
                m_btnDelAllCAC.Paint(hdc,&rcUpdate);
                m_btnDel.Paint(hdc,&rcUpdate);
                m_btnCAC.Paint(hdc,&rcUpdate);
            }
            else
            {
                m_btnMBProp.Paint(hdc,&rcUpdate);
                m_btnMBRecog.Paint(hdc,&rcUpdate);
                m_btnDelAll.Paint(hdc,&rcUpdate);
                m_btnMB.Paint(hdc,&rcUpdate);
            }
        }
#endif // 0
        EndPaint(hwnd,&ps);
    }
}

#if 0
void CHwxInkWindow::HandleMouseEvent(HWND hwnd,UINT msg,WPARAM wp,LPARAM lp)
{
     POINT pt;
    pt.x = (short)LOWORD(lp);
    pt.y = (short)HIWORD(lp);

    if ( !m_b16Bit )
    {
        if ( m_bCAC )
        {
             LargeButton(msg,&pt,&m_btnLarge);
            DetailButton(msg,&pt,&m_btnDetail);
            RecogButton(msg,&pt,&m_btnRecog);
            DelAllCACButton(msg,&pt,&m_btnDelAllCAC);
            DelButton(msg,&pt,&m_btnDel);
            CACButton(msg,&pt,&m_btnCAC);
        }
        else
        {
//            PropButton(msg,&pt,&m_btnMBProp);
            DelAllMBButton(msg,&pt,&m_btnDelAll);
            MBButton(msg,&pt,&m_btnMB);
            MBRecogButton(msg,&pt,&m_btnMBRecog);
        }
    }
    else
    {
         LargeButton(msg,&pt,&m_btnLarge);
        DetailButton(msg,&pt,&m_btnDetail);
        DelAllCACButton(msg,&pt,&m_btnDelAllCAC);
        DelButton(msg,&pt,&m_btnDel);
        RecogButton(msg,&pt,&m_btnRecog);
    }

    static MSG rmsg;
    rmsg.lParam = lp;
    rmsg.wParam = wp;
    rmsg.message = msg;
    rmsg.hwnd = hwnd;
    SendMessage(m_hwndTT,TTM_RELAYEVENT,0,(LPARAM)(LPMSG)&rmsg);
}    
#endif // 0

LRESULT    CHwxInkWindow::HandleCommand(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
     switch ( LOWORD(wp) )
    {
        case IDC_CACMBMENU:
        {
             switch ( HIWORD(wp) )
            {
                 case DDBN_DROPDOWN:
                    ToolTip_Enable(m_hwndTT, FALSE);
                    DDButton_SetCurSel((HWND)lp,m_bCAC ? 0 : 1);
                    break;
                case DDBN_CLOSEUP:
                    ToolTip_Enable(m_hwndTT, TRUE);
                    break;
                case DDBN_SELCHANGE:
                    m_bCAC = ( 0 == DDButton_GetCurSel((HWND)lp) ) ? TRUE : FALSE;
                    if ( m_bCAC )
                    {
                        DWORD dwStyle;
                        (GetAppletPtr()->GetIImePad())->Request(GetAppletPtr(),
                                                                IMEPADREQ_GETAPPLETUISTYLE,
                                                                (WPARAM)&dwStyle,
                                                                (LPARAM)0);
                        dwStyle &= ~IPAWS_VERTICALFIXED;
                        (GetAppletPtr()->GetIImePad())->Request(GetAppletPtr(),
                                                                IMEPADREQ_SETAPPLETUISTYLE,
                                                                (WPARAM)dwStyle,
                                                                (LPARAM)0);

                        //----------------------------------------------------------------
                        //ToshiaK:980324: for #651 GPF in 16 bit
                        //Thest instruction will never come on 16bit application
                        //becaus DDBtn is Disabled. so it is safe code.
                        //----------------------------------------------------------------
                        if(!m_pMB) {
                            return 0;
                        }
                        //HWND hwndMB = m_pMB->GetMBWindow();
                        //HWND hwndCAC = m_pCAC->GetCACWindow();
                        m_pCAC->SetInkSize(m_wPadHeight);
                        SendMessage(m_pMB->GetMBWindow(), MB_WM_COPYINK, 0, 0);
                        SendMessage(m_pMB->GetMBWindow(), MB_WM_ERASE, 0, 0);
                        EnableWindow(m_pMB->GetMBWindow(),FALSE);
                        ShowWindow(m_pMB->GetMBWindow(),SW_HIDE);
                        EnableWindow(m_pCAC->GetCACWindow(),TRUE);
                        ShowWindow(m_pCAC->GetCACWindow(),SW_SHOW);
                        if ( !m_b16Bit )
                            EXButton_SetStyle(m_hCACMBRecog,
                                              EXBS_TEXT | EXBS_THINEDGE | EXBS_DBLCLKS | EXBS_TOGGLE);  // kwada:980402:raid #852
                        EnableWindow(m_hCACMBRevert,TRUE);
                        EnableWindow(m_hCACSwitch,TRUE);
                        ShowWindow(m_hCACSwitch,SW_SHOW);
                        m_wCACInkHeight = m_wPadHeight;
                        m_wCACPLVWidth = m_wCACInkHeight + m_wCACTMPWidth;
                        ChangeIMEPADSize(FALSE);
                        changeCACLayout(TRUE);
                    }
                    else
                    {
                        DWORD dwStyle;
                        (GetAppletPtr()->GetIImePad())->Request(GetAppletPtr(),
                                                                IMEPADREQ_GETAPPLETUISTYLE,
                                                                (WPARAM)&dwStyle,
                                                                (LPARAM)0);
                        dwStyle |= IPAWS_VERTICALFIXED;
                        (GetAppletPtr()->GetIImePad())->Request(GetAppletPtr(),
                                                                IMEPADREQ_SETAPPLETUISTYLE,
                                                                (WPARAM)dwStyle,
                                                                (LPARAM)0);

                        (m_pCAC->GetCACCHwxStroke())->DeleteAllStroke();
                        EnableWindow(m_pCAC->GetCACWindow(),FALSE);
                        ShowWindow(m_pCAC->GetCACWindow(),SW_HIDE);
                        EnableWindow(m_hCACSwitch,FALSE);
                        ShowWindow(m_hCACSwitch,SW_HIDE);
                        EnableWindow(m_hCACMBRevert,FALSE);
                        EXButton_SetStyle(m_hCACMBRecog,EXBS_TEXT | EXBS_THINEDGE);
                        EnableWindow(m_pMB->GetMBWindow(),TRUE);
                        ShowWindow(m_pMB->GetMBWindow(),SW_SHOW);
                        m_wPadHeight = m_wCACInkHeight;
                        m_wPadWidth = m_numBoxes * m_wPadHeight;
                        //----------------------------------------------------------------
                        //ToshiaK:980324: for #651 GPF in 16 bit
                        if(m_pMB) {
                            m_pMB->SetBoxSize((USHORT)m_wPadHeight);
                        }
                        ChangeIMEPADSize(FALSE);
                        changeMBLayout(TRUE);
                    }
                    if ( !m_b16Bit )
                        UpdateRegistry(FALSE); // recog button is recovered after style change. kwada:980402
                    break;
                case DDBN_CLICKED:
                default:
                    break;
            }
            break;
        }
        case IDC_CACMBRECOG:
        {
             switch ( HIWORD(wp) )
            {
                 case EXBN_DOUBLECLICKED:
                    if ( m_bCAC && !m_b16Bit )
                    {
                           m_bDblClk = !m_bDblClk;
                        m_bSglClk = FALSE;
//                        EXButton_SetCheck((HWND)lp,m_bDblClk);
                        if ( m_bDblClk )
                        {
                             exbtnPushedorPoped(TRUE);
                            m_pCAC->recognize();
                        }
                        else
                        {
                              exbtnPushedorPoped(FALSE);
                        }
                        UpdateRegistry(TRUE); // update recog button state. kwada:980402
                    }
                    break;
                case EXBN_CLICKED:
                    if ( m_bCAC )
                    {
                         if ( m_b16Bit )
                        {
                            m_pCAC->NoThreadRecognize(m_wCACInkHeight);
                        }
                        else
                        {
                             if ( !m_bDblClk )
                            {
                                m_bSglClk = !m_bSglClk;
                                if ( m_bSglClk )
                                {
                                     exbtnPushedorPoped(TRUE);
                                    m_pCAC->recognize();
                                }
                                else
                                {
                                      exbtnPushedorPoped(FALSE);
                                }
                            }
                            else
                            {
                                 exbtnPushedorPoped(TRUE);
                            //    EXButton_SetCheck((HWND)lp,TRUE);
                            }
                        }
                    }
                    else
                    {
                        //ToshiaK:980324: for #651 GPF in 16 bit
                        if(m_pMB) {
                            SendMessage(m_pMB->GetMBWindow(), MB_WM_DETERMINE, 0, 0);
                        }
                    }
                    break;
                case EXBN_ARMED:
                case EXBN_DISARMED:
                {
                    if ( m_bCAC && !m_b16Bit )
                    {
                        if ( m_bDblClk || m_bSglClk )
                        {
                             exbtnPushedorPoped(TRUE);
                        }
                        else
                        {
                              exbtnPushedorPoped(FALSE);
                        }
                    }
                }
                default:
                    break;
            }
            break;
        }
        case IDC_CACMBREVERT:
        {
             switch ( HIWORD(wp) )
            {
                case EXBN_CLICKED:
                    if ( m_bCAC )
                    {
                          m_pCAC->HandleDeleteOneStroke();
                        if ( m_pCAC->GetStrokeCount() == 0 && !m_bDblClk && m_bSglClk )
                        {
                            m_bSglClk = FALSE;
                             exbtnPushedorPoped(FALSE);
//                            EXButton_SetCheck(m_hCACMBRecog,m_bSglClk);
                        }
                    }
                    break;
                 case EXBN_DOUBLECLICKED:
                case EXBN_ARMED:
                case EXBN_DISARMED:
                default:
                    break;
            }
            break;
        }
        case IDC_CACMBCLEAR:
        {
             switch ( HIWORD(wp) )
            {
                case EXBN_CLICKED:
                    if ( m_bCAC )
                    {
                         m_pCAC->HandleDeleteAllStroke();
                        if ( m_pCAC->GetStrokeCount() == 0 && !m_bDblClk && m_bSglClk )
                        {
                            m_bSglClk = FALSE;
                             exbtnPushedorPoped(FALSE);
//                            EXButton_SetCheck(m_hCACMBRecog,m_bSglClk);
                        }
                    }
                    else
                    {
                        SendMessage(m_pMB->GetMBWindow(), MB_WM_ERASE, 0, 0);
                    }
                    break;
                 case EXBN_DOUBLECLICKED:
                case EXBN_ARMED:
                case EXBN_DISARMED:
                default:
                    break;
            }
            break;
        }
        case IDC_CACSWITCHVIEW:
        {
             switch ( HIWORD(wp) )
            {
                 case DDBN_DROPDOWN:
                    ToolTip_Enable(m_hwndTT, FALSE);
//                    DDButton_SetCurSel((HWND)lp,m_pCAC->IsLargeView() ? 0 : 1);
                    break;
                case DDBN_CLOSEUP:
                    ToolTip_Enable(m_hwndTT, TRUE);
                    break;
                case DDBN_CLICKED:
                case DDBN_SELCHANGE:
                    m_pCAC->SetLargeView((0 == DDButton_GetCurSel((HWND)lp)) ? TRUE : FALSE);
                    PadListView_SetStyle(m_pCAC->GetCACLVWindow(),
                            m_pCAC->IsLargeView() ? PLVSTYLE_ICON : PLVSTYLE_REPORT);
                    break;
                default:
                    break;
            }
            break;
        }
        default:
            return DefWindowProc(hwnd, msg, wp, lp);
    }
    return 0;
}
 
//----------------------------------------------------------------
//990618:ToshiaK for KOTAE #1329
//----------------------------------------------------------------
LRESULT
CHwxInkWindow::HandleSettingChange(HWND hwnd, UINT uMsg, WPARAM wp, LPARAM lp)
{
    if(m_pMB) {
        m_pMB->OnSettingChange(uMsg, wp, lp);
    }
    if(m_pCAC) {
        m_pCAC->OnSettingChange(uMsg, wp, lp);
    }
    return 0;
    UNREFERENCED_PARAMETER(hwnd);
}

void CHwxInkWindow::ChangeLayout(BOOL b)
{
    if ( !m_bCAC )
         changeMBLayout(b);
    else
         changeCACLayout(b);
}

void CHwxInkWindow::SetTooltipInfo()
{
    ti.cbSize = sizeof(TOOLINFOW);
    ti.uFlags = TTF_IDISHWND;
    ti.hwnd = m_hInkWnd;
    ti.hinst = m_hInstance;
    ti.lpszText = LPSTR_TEXTCALLBACKW; 

    ti.uId    = (UINT_PTR)m_hCACMBMenu;
    SendMessage(m_hwndTT,TTM_ADDTOOLW,0,(LPARAM)(LPTOOLINFOW)&ti);
    ti.uId    = (UINT_PTR)m_hCACMBRecog;
    SendMessage(m_hwndTT,TTM_ADDTOOLW,0,(LPARAM)(LPTOOLINFOW)&ti);
    ti.uId    = (UINT_PTR)m_hCACMBRevert;
    SendMessage(m_hwndTT,TTM_ADDTOOLW,0,(LPARAM)(LPTOOLINFOW)&ti);
    ti.uId    = (UINT_PTR)m_hCACMBClear;
    SendMessage(m_hwndTT,TTM_ADDTOOLW,0,(LPARAM)(LPTOOLINFOW)&ti);
    ti.uId    = (UINT_PTR)m_hCACSwitch;
    SendMessage(m_hwndTT,TTM_ADDTOOLW,0,(LPARAM)(LPTOOLINFOW)&ti);
}

void CHwxInkWindow::SetTooltipText(LPARAM lp)
{
    LPTOOLTIPTEXTW lpttt = (LPTOOLTIPTEXTW)lp;
    UINT stringID = 0;
    switch ( (((LPNMHDR)lp)->idFrom) )
    {
         case IDC_CACMBMENU:
          stringID = IDS_CACMBBTN2;
          break;
        case IDC_CACMBRECOG:
             stringID = m_bCAC ? IDS_CACMBBTN6 : IDS_CACMBBTN1;
          break;
        case IDC_CACMBREVERT:
           stringID = IDS_CACMBBTN3;
          break;
        case IDC_CACMBCLEAR:
          stringID = IDS_CACMBBTN4;
          break;
        case IDC_CACSWITCHVIEW:
          stringID = IDS_CACMBBTN5;
          break;
        default:
          break;
    }
    lpttt->lpszText = stringID == 0 ? NULL : LoadCACMBString(stringID);
}

void CHwxInkWindow::CopyInkFromMBToCAC(CHwxStroke & str,long deltaX,long deltaY)
{
   m_pCAC->GetInkFromMB(str,deltaX,deltaY);
}

CHwxStroke * CHwxInkWindow::GetCACCHwxStroke() 
{ 
    return m_pCAC->GetCACCHwxStroke(); 
}

void CHwxInkWindow::changeCACLayout(BOOL bRepaint /*bFirst*/)
{
    POINT   pt;
    RECT    rcUpdate;
//    BOOL     bRepaint = !bFirst;
    
    //    Recompute the layout and re-arrange the windows
    //  First we need to find out all the dimensions

//  m_wCACWidth = m_wCACPLVWidth + 4 + BUTTON_WIDTH;
//     m_wCACHeight = m_wCACInkHeight > m_wCACPLVHeight ? m_wCACInkHeight : m_wCACPLVHeight;

    GetWindowRect( m_hInkWnd, &rcUpdate );
    pt.x = rcUpdate.left;
    pt.y = rcUpdate.top;

    ScreenToClient( GetParent(m_hInkWnd), &pt );
#if 0
    m_btnCAC.SetRect(m_wCACPLVWidth+8, 4,m_wCACPLVWidth+8+BUTTON_WIDTH,
                     4+BUTTON_HEIGHT);

    m_btnRecog.SetRect(m_wCACPLVWidth+8, BUTTON_HEIGHT+4+8,
                       m_wCACPLVWidth+8+BUTTON_WIDTH, 
                       2*BUTTON_HEIGHT+4+8);

    m_btnDel.SetRect(m_wCACPLVWidth+8, 2*BUTTON_HEIGHT+10+4,
                      m_wCACPLVWidth+8+BUTTON_WIDTH, 
                     3*BUTTON_HEIGHT+10+4);

    m_btnDelAllCAC.SetRect(m_wCACPLVWidth+8, 3*BUTTON_HEIGHT+12+4,
                            m_wCACPLVWidth+8+BUTTON_WIDTH, 
                           4*BUTTON_HEIGHT+12+4);

     m_btnLarge.SetRect(m_wCACPLVWidth+8, 4*BUTTON_HEIGHT+18+4,
                        m_wCACPLVWidth+8+23, 
                          5*BUTTON_HEIGHT+21+4);

     m_btnDetail.SetRect(m_wCACPLVWidth+32, 4*BUTTON_HEIGHT+18+4,
                         m_wCACPLVWidth+32+12, 
                        5*BUTTON_HEIGHT+21+4);
#endif // 0
    MoveWindow( m_hInkWnd,pt.x, pt.y, m_wCACWidth+3*Box_Border, m_wCACHeight, bRepaint);
    MoveWindow( m_pCAC->GetCACWindow(), 0, 0, m_wCACPLVWidth, m_wCACHeight, bRepaint);
    MoveWindow( m_pCAC->GetCACLVWindow(),m_wCACInkHeight+5, 4, m_wCACTMPWidth-4, m_wCACPLVHeight-8, bRepaint);
    MoveWindow( m_hCACMBMenu,m_wCACPLVWidth+8, 4,
                             BUTTON_WIDTH,
                              BUTTON_HEIGHT,bRepaint);
    MoveWindow( m_hCACMBRecog,m_wCACPLVWidth+8, BUTTON_HEIGHT+4+8,
                                 BUTTON_WIDTH, 
                                BUTTON_HEIGHT,bRepaint);
    MoveWindow( m_hCACMBRevert,m_wCACPLVWidth+8, 2*BUTTON_HEIGHT+10+4,
                                 BUTTON_WIDTH, 
                               BUTTON_HEIGHT,bRepaint);
    MoveWindow( m_hCACMBClear,m_wCACPLVWidth+8, 3*BUTTON_HEIGHT+12+4,
                                   BUTTON_WIDTH, 
                               BUTTON_HEIGHT,bRepaint);
#ifdef FE_JAPANESE
    MoveWindow( m_hCACSwitch,m_wCACPLVWidth+8, 4*BUTTON_HEIGHT+18+4,
                                 BUTTON_WIDTH, 
                                BUTTON_HEIGHT+4,bRepaint);
#endif

    //----------------------------------------------------------------
    //990810:ToshiaK for KOTAE #1609
    //fixed control repaint problem.
    //To fix perfectly, We should use Begin(End)DeferWindowPos(), 
    //SetWindwPos() to re-layout.
    //But there are many part to change the code.
    //So, I only add following line to repaint again.
    //----------------------------------------------------------------
    if(m_hCACMBMenu) {
        ::InvalidateRect(m_hCACMBMenu,  NULL, NULL);
    }
    if(m_hCACMBRecog) {
        ::InvalidateRect(m_hCACMBRecog, NULL, NULL);
    }
    if(m_hCACMBRevert) {
        ::InvalidateRect(m_hCACMBRevert,NULL, NULL);
    }
    if(m_hCACMBClear) {
        ::InvalidateRect(m_hCACMBClear, NULL, NULL);
    }

#ifdef FE_JAPANESE
    if(m_hCACSwitch) {
        ::InvalidateRect(m_hCACSwitch, NULL, NULL);
    }
#endif
}

void CHwxInkWindow::changeMBLayout(BOOL bRepaint /*bFirst*/)
{

    POINT   pt;
    RECT    rcUpdate;
//    BOOL    bRepaint = !bFirst;
    
    //    Recompute the layout and re-arrange the windows
    //  First we need to find out all the dimensions

//     m_wInkWidth = m_wPadWidth + 4+ BUTTON_WIDTH;
//    m_wInkHeight = m_wPadHeight > PadWnd_Height ? m_wPadHeight : PadWnd_Height;

    GetWindowRect( m_hInkWnd, &rcUpdate );
    pt.x = rcUpdate.left;
    pt.y = rcUpdate.top;

    ScreenToClient( GetParent(m_hInkWnd), &pt );
#if 0
    m_btnMB.SetRect(m_wPadWidth+8, 4,m_wPadWidth+8+BUTTON_WIDTH, 
                     4+BUTTON_HEIGHT);

    m_btnMBRecog.SetRect(m_wPadWidth+8, BUTTON_HEIGHT+4+8,
                       m_wPadWidth+8+BUTTON_WIDTH, 
                       2*BUTTON_HEIGHT+4+8);

    m_btnDelAll.SetRect(m_wPadWidth+8, 3*BUTTON_HEIGHT+12+4,
                         m_wPadWidth+8+BUTTON_WIDTH, 
                        4*BUTTON_HEIGHT+12+4);

     m_btnMBProp.SetRect(m_wPadWidth+8, 2*BUTTON_HEIGHT+10+4,
                         m_wPadWidth+8+BUTTON_WIDTH, 
                        3*BUTTON_HEIGHT+10+4);
#endif // 0
    MoveWindow( m_hInkWnd, pt.x, pt.y, m_wInkWidth+3*Box_Border, m_wInkHeight, bRepaint);
    if(m_pMB) {
        MoveWindow( m_pMB->GetMBWindow(), 0, 0, m_wPadWidth, m_wPadHeight, bRepaint);
    }

    MoveWindow( m_hCACMBMenu,m_wPadWidth+8, 4,
                             BUTTON_WIDTH, 
                              BUTTON_HEIGHT,bRepaint);
    MoveWindow( m_hCACMBRecog,m_wPadWidth+8, BUTTON_HEIGHT+4+8,
                                 BUTTON_WIDTH, 
                                 BUTTON_HEIGHT,bRepaint);
    MoveWindow( m_hCACMBRevert,m_wPadWidth+8, 2*BUTTON_HEIGHT+10+4,
                             BUTTON_WIDTH, 
                            BUTTON_HEIGHT,bRepaint);
    MoveWindow( m_hCACMBClear,m_wPadWidth+8, 3*BUTTON_HEIGHT+12+4,
                                  BUTTON_WIDTH, 
                              BUTTON_HEIGHT,bRepaint);

    //----------------------------------------------------------------
    //990810:ToshiaK for KOTAE #1609
    //fixed control repaint problem.
    //To fix perfectly, We should use Begin(End)DeferWindowPos(), 
    //SetWindwPos() to re-layout.
    //But there are many part to change the code.
    //So, I only add following line to repaint again.
    //----------------------------------------------------------------
    //990810:ToshiaK.
    //In resizing, sometime "WPad" window is not redrawn..
    if(m_pMB) {
        ::InvalidateRect(m_pMB->GetMBWindow(), NULL, NULL);
    }

    if(m_hCACMBMenu) {
        ::InvalidateRect(m_hCACMBMenu,  NULL, NULL);
    }
    if(m_hCACMBRecog) {
        ::InvalidateRect(m_hCACMBRecog, NULL, NULL);
    }
    if(m_hCACMBRevert) {
        ::InvalidateRect(m_hCACMBRevert,NULL, NULL);
    }
    if(m_hCACMBClear) {
        ::InvalidateRect(m_hCACMBClear, NULL, NULL);
    }                              
}


#if 0
void CHwxInkWindow::clearCACLayout()
{
    m_btnCAC.SetRect(0,0,0,0);
    m_btnRecog.SetRect(0,0,0,0);
    m_btnDel.SetRect(0,0,0,0);
    m_btnDelAllCAC.SetRect(0,0,0,0);
    m_btnLarge.SetRect(0,0,0,0);
    m_btnDetail.SetRect(0,0,0,0);
}

void CHwxInkWindow::clearMBLayout()
{
    m_btnMB.SetRect(0,0,0,0);
    m_btnMBRecog.SetRect(0,0,0,0);
    m_btnDelAll.SetRect(0,0,0,0);
    m_btnMBProp.SetRect(0,0,0,0);
    m_btnMB.SetRect(0,0,0,0);
}
#endif // 0

void CHwxInkWindow::DrawHwxGuide(HDC hDC, LPRECT prc)
{
    HPEN hPen,hPenOld;
     RECT rcUpdate = *prc;

    hPen = CreatePen( PS_SOLID, 0, GetSysColor(COLOR_3DSHADOW) );
    hPenOld = (HPEN)SelectObject( hDC, hPen );

    #define DXW    10

    // center cross
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
//    MoveToEx( hDC, rcUpdate.right/2-DXW, rcUpdate.bottom/2, NULL );
//    LineTo( hDC, rcUpdate.right/2+DXW, rcUpdate.bottom/2 );
//    MoveToEx( hDC, rcUpdate.right/2, rcUpdate.bottom/2-DXW, NULL );
//    LineTo( hDC, rcUpdate.right/2, rcUpdate.bottom/2+DXW );
    MoveToEx( hDC, ( rcUpdate.left + (rcUpdate.right-rcUpdate.left)/2 )-DXW, rcUpdate.bottom/2, NULL );
    LineTo( hDC, ( rcUpdate.left + (rcUpdate.right-rcUpdate.left)/2 )+DXW, rcUpdate.bottom/2 );
    MoveToEx( hDC, ( rcUpdate.left + (rcUpdate.right-rcUpdate.left)/2 ), rcUpdate.bottom/2-DXW, NULL );
    LineTo( hDC, ( rcUpdate.left + (rcUpdate.right-rcUpdate.left)/2 ), rcUpdate.bottom/2+DXW );
#else // UNDER_CE
    {
        POINT pts[] ={{(rcUpdate.left + (rcUpdate.right-rcUpdate.left)/2)-DXW, rcUpdate.bottom/2},
                      {(rcUpdate.left + (rcUpdate.right-rcUpdate.left)/2)+DXW, rcUpdate.bottom/2}};
        Polyline(hDC, pts, ArrayCount(pts));
    }
    {
        POINT pts[] ={{(rcUpdate.left + (rcUpdate.right-rcUpdate.left)/2), rcUpdate.bottom/2-DXW},
                      {(rcUpdate.left + (rcUpdate.right-rcUpdate.left)/2), rcUpdate.bottom/2+DXW}};
        Polyline(hDC, pts, ArrayCount(pts));
    }
#endif // UNDER_CE

    // top left
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
    MoveToEx( hDC, rcUpdate.left+DXW, rcUpdate.top+DXW, NULL );
    LineTo( hDC, rcUpdate.left+DXW, rcUpdate.top+(DXW+DXW) );
    MoveToEx( hDC, rcUpdate.left+DXW, rcUpdate.top+DXW, NULL );
    LineTo( hDC, rcUpdate.left+(DXW+DXW), rcUpdate.top+DXW );
#else // UNDER_CE
    {
        POINT pts[] ={{rcUpdate.left+(DXW+DXW), rcUpdate.top+DXW},
                      {rcUpdate.left+DXW,       rcUpdate.top+DXW},
                      {rcUpdate.left+DXW,       rcUpdate.top+(DXW+DXW)}};
        Polyline(hDC, pts, ArrayCount(pts));
    }
#endif // UNDER_CE

    // bottom left
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
    MoveToEx( hDC, rcUpdate.left+DXW, rcUpdate.bottom-DXW, NULL );
    LineTo( hDC, rcUpdate.left+DXW, rcUpdate.bottom-(DXW+DXW) );
    MoveToEx( hDC, rcUpdate.left+DXW, rcUpdate.bottom-DXW, NULL );
    LineTo( hDC, rcUpdate.left+(DXW+DXW), rcUpdate.bottom-DXW );
#else // UNDER_CE
    {
        POINT pts[] ={{rcUpdate.left+DXW,       rcUpdate.bottom-(DXW+DXW)},
                      {rcUpdate.left+DXW,       rcUpdate.bottom-DXW},
                      {rcUpdate.left+(DXW+DXW), rcUpdate.bottom-DXW}};
        Polyline(hDC, pts, ArrayCount(pts));
    }
#endif // UNDER_CE

    // top right
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
    MoveToEx( hDC, rcUpdate.right-DXW, rcUpdate.top+DXW, NULL );
    LineTo( hDC, rcUpdate.right-DXW, rcUpdate.top+(DXW+DXW) );
    MoveToEx( hDC, rcUpdate.right-DXW, rcUpdate.top+DXW, NULL );
    LineTo( hDC, rcUpdate.right-(DXW+DXW), rcUpdate.top+DXW );
#else // UNDER_CE
    {
        POINT pts[] ={{rcUpdate.right-(DXW+DXW), rcUpdate.top+DXW},
                      {rcUpdate.right-DXW,       rcUpdate.top+DXW},
                      {rcUpdate.right-DXW,       rcUpdate.top+(DXW+DXW)}};
        Polyline(hDC, pts, ArrayCount(pts));
    }
#endif // UNDER_CE

    // bottom right
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
    MoveToEx( hDC, rcUpdate.right-DXW, rcUpdate.bottom-DXW, NULL );
    LineTo( hDC, rcUpdate.right-DXW, rcUpdate.bottom-(DXW+DXW) );
    MoveToEx( hDC, rcUpdate.right-DXW, rcUpdate.bottom-DXW, NULL );
    LineTo( hDC, rcUpdate.right-(DXW+DXW), rcUpdate.bottom-DXW );
#else // UNDER_CE
    {
        POINT pts[] ={{rcUpdate.right-(DXW+DXW), rcUpdate.bottom-DXW},
                      {rcUpdate.right-DXW,       rcUpdate.bottom-DXW},
                      {rcUpdate.right-DXW,       rcUpdate.bottom-(DXW+DXW)}};
        Polyline(hDC, pts, ArrayCount(pts));
    }
#endif // UNDER_CE


    SelectObject( hDC, hPenOld );
    DeleteObject( hPen );
}

// applet size changing
// inkbox size should remain unchanged
// both MB inkbox and CAC inkbox should be the same
void CHwxInkWindow::HandleSize(WPARAM wp, LPARAM lp)
{
    Dbg(("CHwxInkWindow::HandleSize\n"));
    int w = LOWORD(lp);
    int h = HIWORD(lp);
    int wdefaultSize;
    int hdefaultSize;
    int newWidth,newHeight;
    BOOL bChanged = FALSE;
    if ( m_bCAC )
    {
        if ( !w )
        {
            wdefaultSize =  PadWnd_Height + 150 + (3*Box_Border) + (4+BUTTON_WIDTH);
//            wdefaultSize =  PadWnd_Height + 120 + (3*Box_Border) + (4+BUTTON_WIDTH);
        }
        else
        {
            wdefaultSize =  m_wCACInkHeight + LISTVIEWWIDTH_MIN + (3*Box_Border) + (4+BUTTON_WIDTH); // minimum width
        }
//        hdefaultSize =  PadWnd_Height;    // minimum height
        hdefaultSize =  m_wCACInkHeight > CACMBHEIGHT_MIN ? m_wCACInkHeight : CACMBHEIGHT_MIN;
        newWidth = w > wdefaultSize ? w : wdefaultSize;
        newHeight = h > hdefaultSize ? h : hdefaultSize;

        if ( newWidth != m_wCACWidth || newHeight != m_wCACHeight )
        {
            m_wCACPLVWidth = newWidth - (3*Box_Border) - (4+BUTTON_WIDTH);
            m_wCACTMPWidth = m_wCACPLVWidth - m_wCACInkHeight;
            m_wCACPLVHeight = newHeight;
            m_pCAC->SetInkSize(m_wCACInkHeight);
            m_wCACWidth = m_wCACPLVWidth + 4 + BUTTON_WIDTH;
            m_wCACHeight = m_wCACInkHeight > m_wCACPLVHeight ? m_wCACInkHeight : m_wCACPLVHeight;
            ChangeIMEPADSize(FALSE);
             changeCACLayout(TRUE);
//             changeCACLayout(FALSE);
//            SetTooltipInfo(m_hInkWnd,FALSE);
        }
    }
    else
    {
        wdefaultSize = (m_numBoxes * INKBOXSIZE_MIN) + (3*Box_Border) + (4+BUTTON_WIDTH);
        hdefaultSize =  PadWnd_Height;
        // 0. decide if we need to resize
         // 1. need to decide ink-box size and numbers of boxes
        // m_wPadHeight, m_numBoxes, and m_wPadWidth
        // 2. notify m_boxSize in CHwxMB
        // 3. scale the ink if there is the ink before resizing

        
        newWidth = w > wdefaultSize ? w : wdefaultSize;
        newHeight = h > hdefaultSize ? h : hdefaultSize;
        int wInkWidth = m_wPadWidth + (3*Box_Border) + (4+BUTTON_WIDTH);
        int wInkHeight = m_wPadHeight;
        int num;
 
        if ( newWidth != wInkWidth && newHeight == wInkHeight )
        {
            m_numBoxes = ((num = (newWidth- (3*Box_Border) - (4+BUTTON_WIDTH)) / m_wInkHeight) && num > 1) ? num : 2;
            m_wPadWidth = m_numBoxes * m_wInkHeight;
            bChanged = TRUE;
        }
        if ( newWidth == wInkWidth && newHeight != wInkHeight )
        {
            //----------------------------------------------------------------
            //990723:ToshiaK for KOTAE #1615.
            //Raid Description:
            //    Try to decrease the number of boxes by dragging the left edge to the right.
            //    Result:  You can't decrease the number of boxes.  (You can add more boxes, though.)
            //This is VERY VERY UGLY CODE.
            //Too many auto variable, and not intuitive....
            //Anyway, if box size is minimize, it's in to this condition.
            //----------------------------------------------------------------
            //1. First calc m_numBoxes.
            m_numBoxes = ((num = (newWidth- (3*Box_Border) - (4+BUTTON_WIDTH)) / m_wInkHeight) && num > 1) ? num : 2;

            //2. calc new m_wPadWidth
            m_wPadWidth = m_numBoxes * m_wInkHeight;
            //3. LiZhang use too many magic number, I cannot understand...
            //   compare real width(WM_SIZE parameter width)
            //   and computed width.
            //   Real Applet's size seems to compute like this.
            //     "m_wPadWidth + 3*Box_Border + 4 + BUTTON_WIDTH" :-(
            //   
            if( (m_wPadWidth + 3*Box_Border+ 4+ BUTTON_WIDTH) > w && m_numBoxes > 2) {
                if(m_wPadWidth > 0) {
                    m_numBoxes = (w - (3*Box_Border+ 4+ BUTTON_WIDTH))/m_wInkHeight;
                    if(m_numBoxes < 2) {
                        m_numBoxes = 2;
                    }
                }
                m_wPadWidth = m_numBoxes * m_wInkHeight;
            }
            Dbg((" --> new m_numBoxes [%d]\n", m_numBoxes));
            Dbg((" --> new m_wPadWidth[%d]\n", m_wPadWidth));        
            bChanged = TRUE;
        }
        if ( newWidth != wInkWidth && newHeight != wInkHeight )
        {
            
            newWidth = newWidth - (3*Box_Border) - (4+BUTTON_WIDTH);
            m_numBoxes = ((num = newWidth / m_wPadHeight) && num > 1) ? num : 2;
            m_wPadWidth = m_numBoxes * m_wPadHeight;
            bChanged = TRUE;
        }

        if ( bChanged )
        {
            if(m_pMB) { //ToshiaK:980324
                m_pMB->SetBoxSize((USHORT)m_wPadHeight);
            }
            m_wInkWidth = m_wPadWidth + 4+ BUTTON_WIDTH;
            m_wInkHeight = m_wPadHeight > CACMBHEIGHT_MIN ? m_wPadHeight : CACMBHEIGHT_MIN;
            ChangeIMEPADSize(FALSE);
             changeMBLayout(TRUE);
        }
    }
    Unref(wp);
}

//////////////////////////////////////////////////////////////////
// Function : CHwxInkWindow::HandleSizeNotify
// Type     : BOOL
// Purpose  : check *pWidth, *pHeight, these are proper size or not.
// Args     : 
//          : INT * pWidth    [in/out] new width comes
//          : INT * pHeight [in/out] new height comes
// Return   : 
// DATE     : Fri Jun 05 20:42:02 1998
// Author   : ToshiaK
//////////////////////////////////////////////////////////////////
BOOL CHwxInkWindow::HandleSizeNotify(INT *pWidth, INT *pHeight)
{
    Dbg(("HandleSizeNotify *pWidth[%d] *pHeight[%d]\n", *pWidth, *pHeight));
    if(!pWidth || !pHeight) {
        return FALSE;
    }
    int w = *pWidth;
    int h = *pHeight;
    int wdefaultSize;
    int hdefaultSize;

    if ( m_bCAC )
    {
        if ( !w )
        {
            wdefaultSize =  PadWnd_Height + 150 + (3*Box_Border) + (4+BUTTON_WIDTH);
//            wdefaultSize =  PadWnd_Height + 120 + (3*Box_Border) + (4+BUTTON_WIDTH);
        }
        else
        {
            wdefaultSize =  m_wCACInkHeight + LISTVIEWWIDTH_MIN + (3*Box_Border) + (4+BUTTON_WIDTH); // minimum width
        }
        hdefaultSize =  m_wCACInkHeight > CACMBHEIGHT_MIN ? m_wCACInkHeight : CACMBHEIGHT_MIN;
        //----------------------------------------------------------------
        //980903:for #4892. if new size is less than default size, set default. 
        //----------------------------------------------------------------
        if(*pWidth  < wdefaultSize) {
            *pWidth = wdefaultSize;
        }
        if(*pHeight < hdefaultSize) {
            *pHeight = hdefaultSize;
        }
        return TRUE;
    }
    else
    {
        Dbg(("Multibox size changing\n"));
        wdefaultSize = (m_numBoxes * INKBOXSIZE_MIN) + (3*Box_Border) + (4+BUTTON_WIDTH);
        hdefaultSize =  PadWnd_Height;
        Dbg(("w[%d] h[%d] wdef[%d] hdef[%d]\n", w, h, wdefaultSize, hdefaultSize));
        Dbg(("m_wPadWidth[%d] m_wPadHeight[%d]\n", m_wPadWidth, m_wPadHeight));
        //----------------------------------------------------------------
        //980903:for #4892
        //check num box with new size.
        //Ink with & height is same.
        //----------------------------------------------------------------
        if(m_wInkHeight > 0) { //check to prevent Div0.
            //Calc new numbox from new Width. InkHeight is not changed.
            INT numBox = (*pWidth - (3*Box_Border)-(4+BUTTON_WIDTH))/ m_wInkHeight;

            //check Smooth Drag or only Frame drag flag.
            BOOL fDragFull=FALSE; 
#ifndef UNDER_CE // Windows CE does not support SPI_GETDRAGFULLWINDOWS
            ::SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &fDragFull, 0);
#endif // UNDER_CE
            if(fDragFull) {
                //Do not change multibox size if numBox is same as old value.
                if(numBox < 2 || numBox == m_numBoxes) {
                    return FALSE;
                }
            }
            else {
                if(numBox < 2) { //Box count should be greater than 1
                    *pWidth = 2 * m_wInkHeight + (3*Box_Border)+(4+BUTTON_WIDTH);
                }
                if(m_wPadHeight != h) {
                    *pHeight = m_wPadHeight;
                }
            }
        }
        return TRUE;
    }
    //return TRUE;

}

#if 0
void CHwxInkWindow::HandleTimer()
{
    if ( m_dwBtnUpCount == 1 )    // single click detected
    {
         if ( !m_bDblClk )
        {
            SetSglClk(!m_bSglClk);
            if ( m_bSglClk )
                m_pCAC->recognize();
        }
    }     
    m_wCurrentCtrlID = 0;  // no control selected
}
#endif // 0

void CHwxInkWindow::SetMBHeight(int h)
{
//     h = h > m_wMaxHeight? m_wMaxHeight : h;
     m_wPadHeight = h;
     m_wCACInkHeight = h;    
     m_wPadWidth = m_numBoxes * m_wPadHeight;
     m_pCAC->SetInkSize(h);
    if(m_pMB) { //ToshiaK:980324
        m_pMB->SetBoxSize((USHORT)h);
    }
       m_wInkWidth = m_wPadWidth + 4 + BUTTON_WIDTH;
     m_wInkHeight = m_wPadHeight > CACMBHEIGHT_MIN ? m_wPadHeight : CACMBHEIGHT_MIN;
}

void CHwxInkWindow::SetCACInkHeight(int w)
{
//    w = w > m_wMaxHeight? m_wMaxHeight : w;
    m_wCACInkHeight = w;
    m_wCACPLVWidth = m_wCACTMPWidth + m_wCACInkHeight;
    m_wPadHeight = m_wCACInkHeight;
    m_pCAC->SetInkSize(w);
    if(m_pMB) { //ToshiaK:980324
        m_pMB->SetBoxSize((USHORT)w);
    }
    m_wCACWidth = m_wCACPLVWidth + 4 + BUTTON_WIDTH;
    m_wCACHeight = m_wCACInkHeight > m_wCACPLVHeight ? m_wCACInkHeight : m_wCACPLVHeight;
}

void CHwxInkWindow::HandleConfigNotification()
{
    LANGID langId;
    //----------------------------------------------------------------
    //980803:ToshiaK
    //If environment is ActiveIME,
    //Invoke Dialog with English string.
    //----------------------------------------------------------------
    if(CHwxFE::IsActiveIMEEnv()) {
        langId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
    }
    else {
        langId = CHwxFE::GetAppLangID();
    }

    if ( !m_b16Bit ) {
        if(IsNT()) {
            CExres::DialogBoxParamW(langId, 
                                    m_hInstance,
                                    MAKEINTRESOURCEW(IDD_MBPROP),
                                    m_hInkWnd,
                                    CACMBPropDlgProc,
                                    (LPARAM)this);
        }
        else {
#ifndef UNDER_CE // Windows CE always Unicode
            CExres::DialogBoxParamA(langId,
                                    m_hInstance,
                                    MAKEINTRESOURCEA(IDD_MBPROP),
                                    m_hInkWnd,
                                    CACMBPropDlgProc,
                                    (LPARAM)this);
#endif // UNDER_CE
        }
    }
}

void CHwxInkWindow::UpdateRegistry(BOOL bSet)
{
    static PROPDATA pd;

    if ( !m_b16Bit ) // kwada:980402
        if ( bSet )
        {
            pd.uTimerValue = m_pMB->GetTimeOutValue();
            pd.bAlwaysRecog = m_bDblClk;
            (GetAppletPtr()->GetIImePad())->Request(GetAppletPtr(),IMEPADREQ_SETAPPLETDATA,(WPARAM)&pd,(LPARAM)sizeof(PROPDATA));
        }
        else
        {
            ZeroMemory(&pd, sizeof(pd)); //ToshiaK:971024
            if ( S_FALSE == (GetAppletPtr()->GetIImePad())->Request(GetAppletPtr(),IMEPADREQ_GETAPPLETDATA,(WPARAM)&pd,(LPARAM)sizeof(PROPDATA) ) )
            {
                //980921:for Raid#4981
                pd.uTimerValue = 2000; //Wait 2000msec

                pd.bAlwaysRecog = TRUE;
                (GetAppletPtr()->GetIImePad())->Request(GetAppletPtr(),IMEPADREQ_SETAPPLETDATA,(WPARAM)&pd,(LPARAM)sizeof(PROPDATA));
            }
            m_pMB->SetTimeOutValue(pd.uTimerValue);
            m_pMB->SetTimerStarted(pd.uTimerValue ? TRUE : FALSE );
            SetDblClk(pd.bAlwaysRecog);
        }
}

void CHwxInkWindow::HandleDlgMsg(HWND hdlg,BOOL bInit)
{
    LANGID langId;
    INT       codePage;
    //980803:ToshiaK for ActiveIME
    if(CHwxFE::IsActiveIMEEnv()) {
        langId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
        codePage = CP_ACP;
    }
    else {
        langId = CHwxFE::GetAppLangID();
        codePage = CHwxFE::GetAppCodePage();
    }

     int index;
    if ( bInit )
     {
#ifndef UNDER_CE // Windows CE always Unicode
        if(::IsWindowUnicode(hdlg)) {
#endif // UNDER_CE
            for ( int i = 0; i < 11; i++) {
                CExres::LoadStringW(langId,
                                    m_hInstance,
                                    IDS_TIMER0+i, 
                                    wszBuf,
                                    sizeof(wszBuf)/sizeof(wszBuf[0]));
                ::SendMessageW(::GetDlgItem(hdlg,IDC_MBCOMBO),CB_ADDSTRING,0,(LPARAM)wszBuf);
            }
            ::SendMessageW(::GetDlgItem(hdlg,IDC_CACCHECK),BM_SETCHECK, m_bDblClk,0);
            UpdateRegistry(TRUE); // update recog button state. kwada:980402
            if(m_pMB) { //ToshiaK:980324
                ::SendMessageW(GetDlgItem(hdlg,IDC_MBCOMBO),CB_SETCURSEL,
                               (WPARAM)(m_pMB->GetTimeOutValue()/1000),0);
            }
#ifndef UNDER_CE // Windows CE always Unicode
        }
        else {
            for ( int i = 0; i < 11; i++) {
                CExres::LoadStringA(codePage,
                                    langId,
                                    m_hInstance,
                                    IDS_TIMER0+i, 
                                    szBuf,
                                    sizeof(szBuf)/sizeof(TCHAR));
                SendMessage(GetDlgItem(hdlg,IDC_MBCOMBO),CB_ADDSTRING,0,(LPARAM)szBuf);
            }
            SendMessage(GetDlgItem(hdlg,IDC_CACCHECK),BM_SETCHECK,m_bDblClk,0);
            UpdateRegistry(TRUE); // update recog button state. kwada:980402
            if(m_pMB) { //ToshiaK:980324
                SendMessage(GetDlgItem(hdlg,IDC_MBCOMBO),CB_SETCURSEL,
                            (WPARAM)(m_pMB->GetTimeOutValue()/1000),0);
            }
        }
#endif // UNDER_CE
    }
    else
    {
#ifndef UNDER_CE // Windows CE always Unicode
        if(::IsWindowUnicode(hdlg)) {
#endif // UNDER_CE
            index = ::SendMessageW(::GetDlgItem(hdlg,IDC_MBCOMBO),CB_GETCURSEL,0,0);
            if ( index != CB_ERR ) {
                index *= 1000;
                if(m_pMB) { //ToshiaK:980324
                    m_pMB->SetTimeOutValue(index);
                    m_pMB->SetTimerStarted(index ? TRUE : FALSE);
                }
                m_bDblClk = (BOOL)::SendMessageW(GetDlgItem(hdlg,IDC_CACCHECK),BM_GETCHECK,0,0);
                SetDblClk(m_bDblClk);
                UpdateRegistry(TRUE);
            }
#ifndef UNDER_CE // Windows CE always Unicode
        }
        else {
            index = SendMessage(GetDlgItem(hdlg,IDC_MBCOMBO),CB_GETCURSEL,0,0);
            if ( index != CB_ERR ) {
                index *= 1000;
                if(m_pMB) { //ToshiaK:980324
                    m_pMB->SetTimeOutValue(index);
                    m_pMB->SetTimerStarted(index ? TRUE : FALSE);
                }
                m_bDblClk = (BOOL)SendMessage(GetDlgItem(hdlg,IDC_CACCHECK),BM_GETCHECK,0,0);
                SetDblClk(m_bDblClk);
                UpdateRegistry(TRUE);
            }
        }
#endif // UNDER_CE
    }
}

void CHwxInkWindow::ChangeIMEPADSize(BOOL bChangePos)
{
    Dbg(("CHwxInkWindow::ChangeIMEPADSize START bChangePos %d\n", bChangePos));
    int w;
    int h;
    if ( m_bCAC )
    {
        w =  m_wCACWidth+3*Box_Border;        
        h =  m_wCACHeight;
    }
    else
    {
        Dbg(("for multibox\n"));
        w = m_wInkWidth+3*Box_Border;
        h = m_wInkHeight;        
    }

    (GetAppletPtr()->GetIImePad())->Request(GetAppletPtr(),
                                            IMEPADREQ_SETAPPLETSIZE,
                                            MAKEWPARAM(w,h),
                                            (LPARAM)bChangePos);

}

void CHwxInkWindow::HandleHelp(HWND hwnd,UINT msg,WPARAM wp,LPARAM lp)
{
#ifndef UNDER_CE // Windows CE does not support WinHelp
      LPHELPINFO lpInfo = (LPHELPINFO)lp;
      Dbg(("CHwxInkWindow::HandleHelp() msg[%s]START\n",
           msg == WM_HELP ? "WM_HELP" : 
           msg == WM_CONTEXTMENU ? "WM_CONTEXTMENU" : "unknown"));
      if ( msg == WM_HELP )
      {
          Dbg(("hwnd         [0x%08x][%s]\n", hwnd, DBGGetWinClass(hwnd)));
          Dbg(("hItemHandle  [0x%08x][%s]\n", lpInfo->hItemHandle,
               DBGGetWinClass((HWND)lpInfo->hItemHandle)));
          Dbg(("m_hInkWnd    [0x%08x][%s]\n", m_hInkWnd, DBGGetWinClass(m_hInkWnd)));
#ifdef _DEBUG 
          if(m_pCAC) {
              Dbg(("GetCACWindow [0x%08x][%s]\n", 
                   m_pCAC->GetCACWindow(),
                   DBGGetWinClass(m_pCAC->GetCACWindow())));
          }
          if(m_pMB) {
              Dbg(("GetMBWindow  [0x%08x][%s]\n",
                   m_pMB->GetMBWindow(),
                   DBGGetWinClass(m_pMB->GetMBWindow())));
          }
#endif
           if ( m_bCAC && lpInfo->hItemHandle == m_pCAC->GetCACWindow() ) 
         {
             CHwxFE::HandleWmHelp((HWND)lpInfo->hItemHandle, TRUE);
         }
         else if ( !m_bCAC && m_pMB && lpInfo->hItemHandle == m_pMB->GetMBWindow() )
         {     
             CHwxFE::HandleWmHelp((HWND)lpInfo->hItemHandle, FALSE);
         }
         else if ( lpInfo->hItemHandle != m_hInkWnd )
         {     
                CHwxFE::HandleWmHelp((HWND)lpInfo->hItemHandle, (BOOL)m_bCAC);
         }     
      }
      else if ( msg == WM_CONTEXTMENU )
      {
           if (( m_bCAC && (HWND)wp == m_pCAC->GetCACWindow() ) 
          || ( !m_bCAC && m_pMB && (HWND)wp == m_pMB->GetMBWindow() )
          || ( (HWND)wp != m_hInkWnd ))
         {
                CHwxFE::HandleWmContextMenu((HWND)wp, (BOOL)m_bCAC);
         }
      }
#endif // UNDER_CE
      Unref(hwnd);
}

LRESULT CHwxInkWindow::HandleBtnSubWnd(HWND hwnd,UINT msg,WPARAM wp,LPARAM lp)
{
    static FARPROC fn;
    static MSG rmsg;
    
    //981006:In 16bit appliatioin,
    //hwnd's hiword is 0. so cannot specified the hwnd
    if(m_bNT && CHwxFE::Is16bitApplication()) {
        INT id = GetDlgCtrlID(hwnd);
        switch(id) {
        case IDC_CACMBMENU:
            fn = m_CACMBMenuDDBtnProc;
            break;
        case IDC_CACSWITCHVIEW:
            fn = m_CACSwitchDDBtnProc;
            break;
        case IDC_CACMBRECOG:
            fn = m_CACMBRecogEXBtnProc;
            break;
        case IDC_CACMBREVERT:
            fn = m_CACMBRevertEXBtnProc;
            break;
        case IDC_CACMBCLEAR:
            fn = m_CACMBClearEXBtnProc;
            break;
        default:
            fn = NULL;
            break;
        }
        if(NULL == fn) {
            return 0;
        }
    }
    else {
        if ( NULL == (fn = getCACMBBtnProc(hwnd)) )
            return 0;
    }
    switch(msg)
    {
        case WM_MOUSEMOVE:
//        case WM_LBUTTONDOWN:
//        case WM_LBUTTONUP:
            rmsg.lParam = lp;
            rmsg.wParam = wp;
            rmsg.message = msg;
            rmsg.hwnd = hwnd;
            SendMessage(m_hwndTT,TTM_RELAYEVENT,0,(LPARAM)(LPMSG)&rmsg);
            break;
        case WM_LBUTTONDOWN:
            m_bMouseDown = TRUE;
            break;
        case WM_LBUTTONUP:
        case WM_LBUTTONDBLCLK:
            m_bMouseDown = FALSE;
            break;
        case WM_DESTROY:
            if( m_hwndTT ) 
            {
                ti.cbSize = sizeof(TOOLINFOW);
                ti.uFlags = TTF_IDISHWND;
                ti.hwnd   = m_hInkWnd;
                ti.uId    = (UINT_PTR)hwnd;
                SendMessage(m_hwndTT,TTM_DELTOOLW,0,(LPARAM)(LPTOOLINFOW)&ti);
            }
            //990810:ToshiaK for Win64
            WinSetUserPtr(hwnd, (LPVOID)NULL);
            break;
        default:
            break;
    }
    return CallWindowProc((WNDPROC)fn, hwnd, msg, wp, lp);
}


LPWSTR CHwxInkWindow::LoadCACMBString(UINT idStr)
{
    static WCHAR wchStr[60];

    ZeroMemory(wchStr, sizeof(wchStr));
    CHwxFE::LoadStrWithLangId(CHwxFE::GetAppLangID(),
                              m_hInstance,
                              idStr,
                              wchStr,
                              sizeof(wchStr)/sizeof(WCHAR));
    return wchStr;
}

// this is a special function to handle m_hCACMBRecog
// button drawing(pushed or poped) in CAC mode only(not 16bit app)
void CHwxInkWindow::exbtnPushedorPoped(BOOL bPushed)
{
#ifndef UNDER_CE // Windows CE does not support GetCursorPos
    POINT pt;
    RECT  rcUpdate;
    GetCursorPos(&pt);
    GetWindowRect(m_hCACMBRecog,&rcUpdate);
    if ( PtInRect(&rcUpdate,pt) && m_bMouseDown )
#else // UNDER_CE
    if(m_bMouseDown)
#endif // UNDER_CE
    {
        EXButton_SetCheck(m_hCACMBRecog,!bPushed);
    }
    else 
    {
        EXButton_SetCheck(m_hCACMBRecog,bPushed);
    }
}

//////////////////////////////////////////////////////////////////
// Function    :    CHwxInkWindow_OnChangeView
// Type        :    INT
// Purpose    :    Notify view changes. 
// Args        :    
//            :    BOOL    fLarge    
// Return    :    
// DATE        :    Tue Jul 28 18:43:06 1998
// Histroy    :    
//////////////////////////////////////////////////////////////////
INT    CHwxInkWindow::OnChangeView(BOOL fLarge)
{
    if(m_hCACSwitch && ::IsWindow(m_hCACSwitch)) {
        DDButton_SetCurSel(m_hCACSwitch, fLarge ? 0 : 1);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxfe.cpp ===
//////////////////////////////////////////////////////////////////
// File     : hwxfe.cpp
// Purpose  : Class for Fareast functionality.
//              #define FE_JAPANESE                //Japanese specific
//              #define FE_CHINESE_SIMPLIFIED        //P.R.C specific
// 
// Date     : Tue Aug 04 05:27:58 1998
// Author   : ToshiaK
//
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#include "hwxobj.h"
#include <stdio.h>
#include <stdlib.h>
#include "resource.h"
#include "hwxfe.h"
#include "cexres.h"
#include "instr.h"
#include "memmgr.h"
#include "hwxobj.h"
#include "dbg.h"
#include "cmnhdr.h"
#include "../common/cutil.h"    //990722:ToshiaK for KOTAE #1090
#include "../common/cfont.h"    //990722:ToshiaK for KOTAE #1030
#ifdef FE_KOREAN
#include "hanja.h"
#endif

#ifdef UNDER_CE // Windows CE Stub for unsupported APIs
#include "stub_ce.h"
#endif // UNDER_CE

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//----------------------------------------------------------------
//Helpfile definition.
//----------------------------------------------------------------
#ifdef FE_JAPANESE
//990113 ToshiaK: created ../common/namesjp.h for KK's string define
#    include "../common/namesjp.h"
#    include "../common/htmlhelp.h"
#    include "hlpidjpn.h"
#    include "hlpidjpn.tbl"
#ifndef UNDER_CE //#ifndef UNICODE
#    define SZHELPFILE_MAIN                SZFILENAME_HELP            //defined KK's ../common/namesjp.h 
#    define SZHELPFILE_CONTEXTMENU        SZFILENAME_CONTEXTHELP    //defined KK's ../common/namesjp.h 
#    define SZHELPFILE_MAIN_ENG            SZFILENAME_ENG_HELP
#    define SZHELPFILE_CONTEXTMENU_ENG    SZFILENAME_ENG_CONTEXTHELP
#else // UNDER_CE
#    define SZHELPFILE_MAIN                WSZFILENAME_HELP        //defined KK's ../common/namesjp.h 
#    define SZHELPFILE_CONTEXTMENU        WSZFILENAME_CONTEXTHELP    //defined KK's ../common/namesjp.h 
#    define SZHELPFILE_MAIN_ENG            WSZFILENAME_ENG_HELP
#    define SZHELPFILE_CONTEXTMENU_ENG    WSZFILENAME_ENG_CONTEXTHELP
#endif // UNDER_CE
#elif FE_CHINESE_SIMPLIFIED
#    include "../common/htmlhelp.h"
#    include "hlpidsc.h"
#    include "hlpidsc.tbl"
#    define SZHELPFILE_MAIN            "PIntlpad.chm"
#    define SZHELPFILE_CONTEXTMENU    "PIntlpad.hlp"
#elif FE_KOREAN
#    include "hlpidkor.h"
#    include "hlpidkor.tbl"
#    define SZHELPFILE_MAIN                "impdko61.chm"            // Kor Pad CHM Help
#    define SZHELPFILE_CONTEXTMENU         "imkr61.hlp"              // Kor Context Help
#    define SZHELPFILE_MAIN_ENG            "korpaden.chm"            // Eng Pad CHM Help
#    define SZHELPFILE_CONTEXTMENU_ENG     "imkren61.hlp"            // Eng Context Help
#else 
#    include "hlpideng.h"
#    include "hlpideng.tbl"
#    define SZHELPFILE_MAIN            ""
#    define SZHELPFILE_CONTEXTMENU    ""
#endif

//----------------------------------------------------------------
//codepage define
//----------------------------------------------------------------
#define CP_KOREAN                    949
#define CP_JAPANESE                    932
#define CP_CHINESE_SIMPLIFIED        936
#define CP_CHINESE_TRADITIONAL        950

BOOL CHwxFE::IsActiveIMEEnv(VOID)
{
#ifdef FE_JAPANESE
    if(MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT) != ::GetSystemDefaultLangID() &&
       (IsWin95() || IsWin98() || IsWinNT4())) {
        return TRUE;
    }
    return FALSE;
#elif  FE_KOREAN || FE_CHINESE_SIMPLIFIED
    return FALSE;
#else
    return FALSE;
#endif
}

//////////////////////////////////////////////////////////////////
// Function    :    CHwxFE::GetAppLangID
// Type        :    LANGID
// Purpose    :    Get this Applet's Language Id.
// Args        :    None
// Return    :    
// DATE        :    Mon Aug 03 22:56:44 1998
// Histroy    :    
//////////////////////////////////////////////////////////////////
LANGID CHwxFE::GetAppLangID(VOID)
{
#ifdef FE_KOREAN
    if(MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT) == ::GetSystemDefaultLangID()) {
        return MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT);
    }
    else {
        return MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
    }
#elif  FE_JAPANESE
    if(MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT) == ::GetSystemDefaultLangID()) {
        return MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT);
    }
    else {
        return MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
    }
#elif FE_CHINESE_SIMPLIFIED
    return MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
#else 
    return MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
#endif
}

//////////////////////////////////////////////////////////////////
// Function    :    CHwxFE::GetAppCodePage
// Type        :    INT
// Purpose    :    Get this Applet's Code Page.
//                Japanese version return 932.
//                Simplified Chinese version, return 936. 
// Args        :    None
// Return    :    
// DATE        :    Mon Aug 03 23:24:30 1998
// Histroy    :    
//////////////////////////////////////////////////////////////////
INT CHwxFE::GetAppCodePage(VOID)
{
#ifdef  FE_JAPANESE
    return CP_JAPANESE;
#elif   FE_KOREAN
    return CP_KOREAN;
#elif FE_CHINESE_SIMPLIFIED
    return CP_CHINESE_SIMPLIFIED;
#else 
    return CP_ACP;
#endif
}

#define TSZ_KEY_PROGRAMFILESDIR        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define TSZ_NAME_PROGRAMFILESDIR    TEXT("ProgramFilesDir")
#define TSZ_INK_PATH                TEXT("Common Files\\Microsoft Shared\\Ink")
BOOL
chwxfe_GetProgramFilesDir(LPTSTR lpstr, INT maxLen)
{
    HKEY hKey;
    INT ret;
    ret = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TSZ_KEY_PROGRAMFILESDIR,
                         0, KEY_READ, &hKey);
    if(ret != ERROR_SUCCESS) {
        //DBG(("-->RegOpenKeyEx error [0x%08x]\n", ret));
        return FALSE;
    }
    
    ULONG ulSize = sizeof(TCHAR)*(maxLen-1);
    ret  = ::RegQueryValueEx(hKey,
                             TSZ_NAME_PROGRAMFILESDIR, 
                             NULL,
                             NULL,
                             (LPBYTE)lpstr, &ulSize);
    if(ret != ERROR_SUCCESS) {
        //DBG(("-->RegQueryValueEx error [0x%08x]\n", ret));
        ::RegCloseKey( hKey );
        return FALSE;
    }

    //DBG(("CRegUtil::GetProgramFilesDir() [%s]\n", lpstr));
    ::RegCloseKey( hKey );
    return TRUE;
}

INT
CHwxFE::GetRecognizerFileName(HINSTANCE hInst, LPTSTR  lpstr,  INT cchMax)
{
    TCHAR tszModPath[MAX_PATH];
    TCHAR tszFileName[64];
    TCHAR tszPF[MAX_PATH];
    CExres::LoadStringA(CHwxFE::GetAppCodePage(),
                        CHwxFE::GetAppLangID(),
                        hInst, 
                        IDS_RECOG_FILE,
                        tszFileName,
                        sizeof(tszFileName)/sizeof(tszFileName[0]));

    chwxfe_GetProgramFilesDir(tszPF, sizeof(tszPF)/sizeof(tszPF[0]));
    wsprintf(tszModPath,
             TEXT("%s\\%s\\%s"),
             tszPF,
             TSZ_INK_PATH,
             tszFileName);

    //OutputDebugString(tszModPath);
    HANDLE hFile;
    LPSECURITY_ATTRIBUTES pSec = (LPSECURITY_ATTRIBUTES)NULL;
    //=======================================================
    ::SetLastError(ERROR_SUCCESS);
    hFile = ::CreateFile(tszModPath,
                         GENERIC_READ,
                         FILE_SHARE_READ, 
                         pSec,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         0);
    if(hFile != INVALID_HANDLE_VALUE) {
        ::CloseHandle(hFile); 
        StringCchCopy(lpstr, cchMax, tszModPath);
        //OutputDebugString("tszModPath\n");
        return 0;
    }

    //Cannot find 

    GetModuleFileName(hInst,
                      tszModPath,
                      sizeof(tszModPath)/sizeof(tszModPath[0]));
    TCHAR *p = strrchr(tszModPath, (TCHAR)'\\');
    if(!p) {
        return -1;
    }
    p[1] = (TCHAR)0x00;

    StringCchCat(tszModPath, MAX_PATH, tszFileName);
    StringCchCopy(lpstr, cchMax, tszModPath);
    //OutputDebugString("tszModPath\n");
    return 0;
    cchMax;
}

INT CHwxFE::LoadStrWithLangId(LANGID    langId,
                              HINSTANCE hInst,
                              INT id,
                              LPWSTR lpwstr,
                              INT cchMax)
{
    CExres::LoadStringW(langId, hInst, id, lpwstr, cchMax);
    return 0;
}


//////////////////////////////////////////////////////////////////
// Function    :    CHwxFE::GetTitleStringW
// Type        :    INT
// Purpose    :    Get Handwriting applet's title string.
// Args        :    
//            :    HINSTANCE    hInst    
//            :    LPWSTR    lpwstr    
//            :    INT    cchMax    
// Return    :    
// DATE        :    Mon Aug 03 22:44:49 1998
// Histroy    :    
//////////////////////////////////////////////////////////////////
INT CHwxFE::GetTitleStringW(HINSTANCE hInst, LPWSTR lpwstr, INT cchMax)
{
#ifdef FE_CHINESE_SIMPLIFIED
    if(MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED) == ::GetSystemDefaultLangID()) {
        CExres::LoadStringW(CHwxFE::GetAppLangID(),
                            hInst,
                            IDS_TITLE,
                            lpwstr, 
                            cchMax);
    }
    else {
        CExres::LoadStringW(CHwxFE::GetAppLangID(),
                            hInst,
                            IDS_TITLE_US,
                            lpwstr, 
                            cchMax);
    }
#else
    CExres::LoadStringW(CHwxFE::GetAppLangID(),
                        hInst,
                        IDS_TITLE,
                        lpwstr, 
                        cchMax);
#endif    
    return 0;
}


INT CHwxFE::GetDispFontW(HINSTANCE hInst, LPWSTR lpwstr, INT cchMax)
{

    CExres::LoadStringW(CHwxFE::GetAppLangID(),
                        hInst,
                        IDS_FONT_DEFAULT,
                        lpwstr, 
                        cchMax);
    return 0;
}

#ifndef UNDER_CE // Windows CE always UNICODE
INT CHwxFE::GetDispFontA(HINSTANCE hInst, LPSTR  lpstr,  INT cchMax)
{
#ifdef FE_CHINESE_SIMPLIFIED
    if(MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED) == ::GetSystemDefaultLangID()) {
        CExres::LoadStringA(CHwxFE::GetAppCodePage(),
                            CHwxFE::GetAppLangID(), 
                            hInst,
                            IDS_FONT_DEFAULT,
                            lpstr,
                            cchMax);
    }
    else {
        CExres::LoadStringA(CHwxFE::GetAppCodePage(),
                            CHwxFE::GetAppLangID(), 
                            hInst,
                            IDS_FONT_DEFAULT_US,
                            lpstr,
                            cchMax);
    }
#elif FE_JAPANESE
    CExres::LoadStringA(CHwxFE::GetAppCodePage(),
                        CHwxFE::GetAppLangID(), 
                        hInst,
                        IDS_FONT_DEFAULT,
                        lpstr,
                        cchMax);

    //990810:ToshiaK for KOTAE #1030
    BOOL fRet = CFont::IsFontExist(lpstr, SHIFTJIS_CHARSET);
    if(fRet) {
        Dbg(("Found Fond[%s]\n", lpstr));
        return 0;
    }
    else {
        static TCHAR szFontUIGothic[]=TEXT("MS UI Gothic");
        fRet = CFont::IsFontExist(szFontUIGothic, SHIFTJIS_CHARSET);
        if(fRet) {
            Dbg(("Found MS UI Gothic\n"));
            StrcpySafeA(lpstr, szFontUIGothic, cchMax);
        }
        else {
            CFont::GetFontNameByCharSet(SHIFTJIS_CHARSET, lpstr, cchMax);
        }
    }
#elif FE_KOREAN
    CExres::LoadStringA(CHwxFE::GetAppCodePage(),
                        CHwxFE::GetAppLangID(), 
                        hInst,
                        IDS_FONT_DEFAULT,
                        lpstr,
                        cchMax);

    //990810:ToshiaK for KOTAE #1030
    //Korean version: CSLim
    BOOL fRet = CFont::IsFontExist(lpstr, HANGUL_CHARSET);
    if(fRet) {
        Dbg(("Found Fond[%s]\n", lpstr));
        return 0;
    }
    else {
        static TCHAR szFontGulim[]=TEXT("Gulim");
        fRet = CFont::IsFontExist(szFontGulim, HANGUL_CHARSET);
        if(fRet) {
            Dbg(("Found Gulim\n"));
            StrcpySafeA(lpstr, szFontGulim, cchMax);
        }
        else {
            CFont::GetFontNameByCharSet(HANGUL_CHARSET, lpstr, cchMax);
        }
    }

#endif

    return 0;
}
#endif // UNDER_CE

INT CHwxFE::GetInkExpTextW(HINSTANCE hInst, LPWSTR lpwstr, INT cchMax)
{
    CExres::LoadStringW(CHwxFE::GetAppLangID(),
                        hInst, 
                        IDS_CACINK,
                        lpwstr, 
                        cchMax);
    return 0;
}

#ifndef UNDER_CE // Windows CE always UNICODE
INT CHwxFE::GetInkExpTextA(HINSTANCE hInst, LPSTR lpstr, INT cchMax)
{
    CExres::LoadStringA(CHwxFE::GetAppCodePage(),
                        CHwxFE::GetAppLangID(),
                        hInst,
                        IDS_CACINK,
                        lpstr,
                        cchMax);
    return 0;
}
#endif // UNDER_CE

INT CHwxFE::GetListExpTextW    (HINSTANCE hInst, LPWSTR lpwstr, INT cchMax)
{
    CExres::LoadStringW(CHwxFE::GetAppLangID(),
                        hInst, 
                        IDS_CACPLV,
                        lpwstr, 
                        cchMax);
    return 0;
}

#ifndef UNDER_CE // Windows CE always UNICODE
INT CHwxFE::GetListExpTextA(HINSTANCE hInst, LPSTR lpstr, INT cchMax)
{
    CExres::LoadStringA(CHwxFE::GetAppCodePage(),
                        CHwxFE::GetAppLangID(),
                        hInst, 
                        IDS_CACPLV,
                        lpstr, 
                        cchMax);
    return 0;
}
#endif // UNDER_CE

#ifdef UNDER_CE
INT CHwxFE::GetHeaderStringW(HINSTANCE hInst, INT index, LPWSTR lpstr, INT cchMax)
{
    CExres::LoadStringW(CHwxFE::GetAppLangID(),
                        hInst,
                        IDS_LVC0+index,
                        lpstr, cchMax);
    return 0;
}
#endif // UNDER_CE

#ifndef UNDER_CE // Windows CE always UNICODE
INT CHwxFE::GetHeaderStringA(HINSTANCE hInst, INT index, LPSTR lpstr, INT cchMax)
{
    CExres::LoadStringA(CHwxFE::GetAppCodePage(),
                        CHwxFE::GetAppLangID(),
                        hInst,
                        IDS_LVC0+index,
                        lpstr, cchMax);
    return 0;
}
#endif // UNDER_CE

INT CHwxFE::ShowHelp(HWND hwnd)
{
#ifdef FE_KOREAN
    if (CHwxFE::Is16bitApplication())
        return 0;
    LPTSTR lpstrArg = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH*2+32);
    LPTSTR lpstrHelp = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
    LPTSTR lpstrWinDir = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
    LPTSTR lpstrName = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
    LPTSTR lpstrHelpName = NULL;
    INT size;

    if (!lpstrArg || !lpstrHelp || !lpstrWinDir || !lpstrName)
        goto LError;

    *lpstrHelp = (TCHAR)0x00;
    if (CHwxFE::GetAppLangID() == MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT))
        lpstrHelpName = SZHELPFILE_MAIN;
    else
        lpstrHelpName = SZHELPFILE_MAIN_ENG;

    StringCchCat(lpstrHelp, MAX_PATH, lpstrHelpName);
    GetSystemWindowsDirectory(lpstrWinDir, MAX_PATH);
	wsprintf(lpstrName,
			 TEXT("%s\\hh.exe"),
			 lpstrWinDir);
	wsprintf(lpstrArg,
			 TEXT("%s %s::/howIMETopic135_UsingTheHandwritingAppletTOC.htm"),
			 lpstrName,
			 lpstrHelp);
    Dbg(("lpstrHelp [%s]\n", lpstrHelp));

    {
		PROCESS_INFORMATION pi = {0};
		STARTUPINFO si = {0};
		si.cb = sizeof(si);
		si.wShowWindow = SW_SHOWNORMAL;
		::CreateProcess(lpstrName, lpstrArg, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
        if (pi.hProcess)
            CloseHandle(pi.hProcess);

        if (pi.hThread)
            CloseHandle(pi.hThread);
	}
 LError:
    if (lpstrArg)
        MemFree(lpstrArg);

    if (lpstrHelp)
        MemFree(lpstrHelp);

    if(lpstrWinDir)
        MemFree(lpstrWinDir);

    if(lpstrName)
        MemFree(lpstrName);

#elif  FE_JAPANESE
    if(CHwxFE::Is16bitApplication()) {
        return 0;
    }
    LPTSTR lpstrArg = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
    LPTSTR lpstrHelp= (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
    LPTSTR lpstrHelpName = NULL;
    INT size;
    if(!lpstrArg) {
        goto LError;
    }
    if(!lpstrHelp) {
        goto LError;
    }
    *lpstrHelp = (TCHAR)0x00;
    if(CHwxFE::GetAppLangID() == MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT)) {
        lpstrHelpName = SZHELPFILE_MAIN;
    }
    else {
        lpstrHelpName = SZHELPFILE_MAIN_ENG;
    }
    if(CUtil::IsHydra() && CUtil::IsWinNT4()) {
        size = CUtil::GetWINDIR(lpstrHelp, MAX_PATH);
        lpstrHelp[size] = (TCHAR)0x00;
        StringCchCat(lpstrHelp, MAX_PATH, TEXT("\\help\\"));
    }
    StringCchCat(lpstrHelp, MAX_PATH, lpstrHelpName);
    wsprintf(lpstrArg,
             TEXT("hh.exe %s::/IDH_TOC_HW_fake.htm"),
             lpstrHelp);
    Dbg(("lpstrHelp [%s]\n", lpstrHelp));
#ifndef UNDER_CE // Windows CE does not support WinExec
    ::WinExec(lpstrArg, SW_SHOWNORMAL);
#else // UNDER_CE
    //temp
    ::CreateProcess(lpstrArg, L"", NULL, NULL, FALSE, 0, NULL, NULL, NULL, NULL);
#endif // UNDER_CE
 LError:
    if(lpstrArg) {
        MemFree(lpstrArg);
    }
    if(lpstrHelp) {
        MemFree(lpstrHelp);
    }
#elif FE_CHINESE_SIMPLIFIED
    if(CHwxFE::Is16bitApplication()) {
           ::WinHelp(hwnd, SZHELPFILE_CONTEXTMENU, HELP_CONTEXT, IDH_TOC_HW);
    } else {
        LPSTR lpstrArg = (CHAR *)MemAlloc(sizeof(CHAR)*256);
        if(lpstrArg) {
            wsprintf(lpstrArg,
                     "hh.exe %s::/pad_sum.htm",
                     SZHELPFILE_MAIN);
            INT ret = ::WinExec(lpstrArg, SW_SHOWNORMAL);
            //WinExec return code is greater than 31 if succeeded
            if(ret <= 31) {
                ::WinHelp(hwnd, SZHELPFILE_CONTEXTMENU, HELP_CONTEXT, IDH_TOC_HW);
            }
            MemFree(lpstrArg);
        }
        else {
            ::WinHelp(hwnd, SZHELPFILE_CONTEXTMENU, HELP_CONTEXT, IDH_TOC_HW);
        }
    }
#    ifdef HTMLHELPBUG
    if(CHwxFE::Is16bitApplication()) {
           ::WinHelp(hwnd, SZHELPFILE_CONTEXTMENU, HELP_CONTEXT, IDH_TOC_HW);
    } else if (!::HtmlHelp(hwnd, SZHELPFILE_MAIN, HH_DISPLAY_TOPIC, 
        (LPARAM)"pad_sum.htm")) {
           ::WinHelp(hwnd, SZHELPFILE_CONTEXTMENU, HELP_CONTEXT, IDH_TOC_HW);
    }
#    endif //HTMLHELPBUG
#endif

    return 0;
    Unref(hwnd);
}

INT CHwxFE::HandleWmHelp(HWND hwnd, BOOL fCAC)
{
#ifndef UNDER_CE // Windows CE does not support WinHelp
#ifdef FE_KOREAN
    if(CHwxFE::GetAppLangID() == MAKELANGID(LANG_KOREAN,
                                            SUBLANG_DEFAULT)) {
        ::WinHelp(hwnd, 
                  SZHELPFILE_CONTEXTMENU,
                  HELP_WM_HELP,
                  fCAC ? (ULONG_PTR)CACHelpIdList : (ULONG_PTR)MBHelpIdList);
    }
    else {
        ::WinHelp(hwnd, 
                  SZHELPFILE_CONTEXTMENU_ENG,
                  HELP_WM_HELP,
                  fCAC ? (ULONG_PTR)CACHelpIdList : (ULONG_PTR)MBHelpIdList);
    }
    
#elif  FE_JAPANESE
    if(CHwxFE::GetAppLangID() == MAKELANGID(LANG_JAPANESE,
                                            SUBLANG_DEFAULT)) {
        ::WinHelp(hwnd, 
                  SZHELPFILE_CONTEXTMENU,
                  HELP_WM_HELP,
                  fCAC ? (ULONG_PTR)CACHelpIdList : (ULONG_PTR)MBHelpIdList);
    }
    else {
        ::WinHelp(hwnd, 
                  SZHELPFILE_CONTEXTMENU_ENG,
                  HELP_WM_HELP,
                  fCAC ? (ULONG_PTR)CACHelpIdList : (ULONG_PTR)MBHelpIdList);
    }
#elif FE_CHINESE_SIMPLIFIED
    ::WinHelp(hwnd, 
              SZHELPFILE_CONTEXTMENU,
              HELP_WM_HELP,
              fCAC ? (ULONG_PTR)CACHelpIdList : (ULONG_PTR)MBHelpIdList);
#endif

#endif // UNDER_CE
    return 0;
}

INT CHwxFE::HandleWmContextMenu    (HWND hwnd, BOOL fCAC)
{
#ifndef UNDER_CE // Windows CE does not support WinHelp
#ifdef FE_KOREAN
    if(CHwxFE::GetAppLangID() == MAKELANGID(LANG_KOREAN,
                                            SUBLANG_DEFAULT)) {
        ::WinHelp(hwnd,
                  SZHELPFILE_CONTEXTMENU,
                  HELP_CONTEXTMENU,
                  fCAC ? (ULONG_PTR)CACHelpIdList : (ULONG_PTR)MBHelpIdList);
    }
    else {
        ::WinHelp(hwnd,
                  SZHELPFILE_CONTEXTMENU_ENG,
                  HELP_CONTEXTMENU,
                  fCAC ? (ULONG_PTR)CACHelpIdList : (ULONG_PTR)MBHelpIdList);
    }
#elif  FE_JAPANESE
    if(CHwxFE::GetAppLangID() == MAKELANGID(LANG_JAPANESE,
                                            SUBLANG_DEFAULT)) {
        ::WinHelp(hwnd,
                  SZHELPFILE_CONTEXTMENU,
                  HELP_CONTEXTMENU,
                  fCAC ? (ULONG_PTR)CACHelpIdList : (ULONG_PTR)MBHelpIdList);
    }
    else {
        ::WinHelp(hwnd,
                  SZHELPFILE_CONTEXTMENU_ENG,
                  HELP_CONTEXTMENU,
                  fCAC ? (ULONG_PTR)CACHelpIdList : (ULONG_PTR)MBHelpIdList);
    }
#elif FE_CHINESE_SIMPLIFIED
    ::WinHelp(hwnd,
              SZHELPFILE_CONTEXTMENU,
              HELP_CONTEXTMENU,
              fCAC ? (ULONG_PTR)CACHelpIdList : (ULONG_PTR)MBHelpIdList);
#endif
#endif // UNDER_CE
    return 0;
}

//////////////////////////////////////////////////////////////////
// Function    :    CHwxFE::GetMenu
// Type        :    HMENU
// Purpose    :    
// Args        :    
//            :    HINSTANCE    hInst    
//            :    LPSTR    lpstrResId    
// Return    :    
// DATE        :    Wed Sep 09 18:47:21 1998
// Histroy    :    
//////////////////////////////////////////////////////////////////
#ifndef UNDER_CE
HMENU CHwxFE::GetMenu(HINSTANCE hInst, LPSTR lpstrResId)
#else // UNDER_CE
HMENU CHwxFE::GetMenu(HINSTANCE hInst, LPTSTR lpstrResId)
#endif // UNDER_CE
{
#ifndef UNDER_CE
    return CExres::LoadMenuA(CHwxFE::GetAppLangID(),
                             hInst,
                             lpstrResId);
#else // UNDER_CE
    return CExres::LoadMenu(CHwxFE::GetAppLangID(),
                            hInst,
                            lpstrResId);
#endif // UNDER_CE
}

//////////////////////////////////////////////////////////////////
// Function    :    CHwxFE::GetTipText
// Type        :    INT
// Purpose    :    Get HanCharacter's Reading text for Tooltip.
// Args        :    
//            :    WCHAR    wch    
//            :    LPWSTR    lpwstrTip    
//            :    INT    cchMax    
//            :    LPVOID    lpSkdic    
// Return    :    
// DATE        :    Wed Aug 05 18:45:36 1998
// Histroy    :    
//////////////////////////////////////////////////////////////////
//----------------------------------------------------------------
//Japanese version. 
//----------------------------------------------------------------
#ifdef FE_JAPANESE
INT CHwxFE::GetTipText(WCHAR wch, LPWSTR lpwstrTip, INT cchMax, LPVOID lpSkdic)
{
    static KANJIINFO kanji;
    IImeSkdic *lpIImeSkdic = (IImeSkdic *)lpSkdic; 
    if(!wch || !lpIImeSkdic|| !lpwstrTip ) {
        return -1;
    }
    kanji.mask = KIF_YOMI; 
    if(S_OK != lpIImeSkdic->GetKanjiInfo(wch,&kanji)) {
        return -1;
    }
    if( kanji.wchOnYomi1[0] ) {
        if( kanji.wchOnYomi2[0] ) {
            if( kanji.wchKunYomi1[0] ) {
                if( kanji.wchKunYomi2[0] ){
                    swprintf(lpwstrTip,
                             L"%s %s\n%s %s",
                             kanji.wchOnYomi1,
                             kanji.wchOnYomi2,
                             kanji.wchKunYomi1,
                             kanji.wchKunYomi2);
                }
                else {
                    swprintf(lpwstrTip,
                             L"%s %s\n%s",
                             kanji.wchOnYomi1,
                             kanji.wchOnYomi2,
                             kanji.wchKunYomi1);
                }
            }
            else {
                if( kanji.wchKunYomi2[0] ) {
                    swprintf(lpwstrTip,
                             L"%s %s\n%s",
                             kanji.wchOnYomi1,
                             kanji.wchOnYomi2,
                             kanji.wchKunYomi2);
                }
                else {
                    swprintf(lpwstrTip,
                             L"%s %s",
                             kanji.wchOnYomi1,
                             kanji.wchOnYomi2);
                }
            }
        }
        else {
            if(kanji.wchKunYomi1[0]) {
                if ( kanji.wchKunYomi2[0] ) {
                    swprintf(lpwstrTip,
                             L"%s\n%s %s",
                             kanji.wchOnYomi1,
                             kanji.wchKunYomi1,
                             kanji.wchKunYomi2);
                }
                else {
                    swprintf(lpwstrTip,
                             L"%s\n%s",
                             kanji.wchOnYomi1,
                             kanji.wchKunYomi1);
                }
            }
            else{
                if ( kanji.wchKunYomi2[0] ) {
                    swprintf(lpwstrTip,
                             L"%s\n%s",
                             kanji.wchOnYomi1,
                             kanji.wchKunYomi2);
                }
                else {
                    swprintf(lpwstrTip,
                             L"%s",
                             kanji.wchOnYomi1);
                }
            }
        }
    }
    else {
        if(kanji.wchOnYomi2[0] ){
            if ( kanji.wchKunYomi1[0] ) {
                if ( kanji.wchKunYomi2[0] ) {
                    swprintf(lpwstrTip,
                             L"%s\n%s %s",
                             kanji.wchOnYomi2,
                             kanji.wchKunYomi1,
                             kanji.wchKunYomi2);
                }
                else {
                    swprintf(lpwstrTip,
                             L"%s\n%s",
                             kanji.wchOnYomi2,
                             kanji.wchKunYomi1);
                }
            }
            else {
                if ( kanji.wchKunYomi2[0] ) {
                    swprintf(lpwstrTip,
                             L"%s\n%s",
                             kanji.wchOnYomi2,
                             kanji.wchKunYomi2);
                }
                else {
                    swprintf(lpwstrTip,
                             L"%s",
                             kanji.wchOnYomi2);
                }
            }
        }
        else{
            if( kanji.wchKunYomi1[0] ){
                if ( kanji.wchKunYomi2[0] ) {
                    swprintf(lpwstrTip,
                             L"%s %s",
                             kanji.wchKunYomi1,
                             kanji.wchKunYomi2);
                }
                else {
                    swprintf(lpwstrTip,
                             L"%s",
                             kanji.wchKunYomi1);
                }
            }
            else { 
                if( kanji.wchKunYomi2[0] ){
                    swprintf(lpwstrTip,
                             L"%s",
                             kanji.wchKunYomi2);
                }
                else {
                    return -1; //bEmpty = TRUE;
                }
            }
        }
    }
    return 0;
    Unref(cchMax);
}
//
// FE_JAPANESE CHwxFE::GetTipText() End
//
#elif FE_CHINESE_SIMPLIFIED
//----------------------------------------------------------------
//
//Simplified Chinese version.
//
//----------------------------------------------------------------
#include "imm.h"
//----------------------------------------------------------------
//helper function's prototype
//----------------------------------------------------------------
HKL GetIntelligentKL(VOID);
int CALLBACK QueryDicDataA(LPCSTR lpszReading,
                            DWORD  dwStyle,
                           LPCSTR lpszString,
                           LPVOID lpvData);
int CALLBACK QueryDicDataW(LPCWSTR lpszReading,
                           DWORD   dwStyle,
                           LPCWSTR lpszString,
                           LPVOID  lpvData);

INT GetTipTextA(WCHAR wch, LPWSTR lpwstrTip, INT cchMax, LPVOID lpSkdic)
{
    CHAR  ach[4];
    DWORD dwBuf[30];
    PCHAR pchReading = PCHAR(dwBuf + 1);

    static HKL hKL = NULL;
    if(!hKL) {
        hKL = GetIntelligentKL();
    }

    dwBuf[0] = 0;
    pchReading[0] = pchReading[1] = 0;

    ::WideCharToMultiByte(936, WC_COMPOSITECHECK, &wch, 1, ach,
                          sizeof(WCHAR)/sizeof(TCHAR), NULL, NULL);
    ach[2] = NULL;
    ::ImmEnumRegisterWordA(hKL,
                           QueryDicDataA,
                           NULL,
                           (IME_REGWORD_STYLE_USER_FIRST + 1),
                           ach, (LPVOID)dwBuf);

    if(*pchReading) {
        DWORD dwReadLen = ::MultiByteToWideChar(936,
                                                MB_COMPOSITE,
                                                pchReading,
                                                lstrlenA(pchReading),
                                                lpwstrTip,
                                                cchMax);
        lpwstrTip[dwReadLen] = NULL;
        return 0;
    }
    return -1;
    UNREFERENCED_PARAMETER(lpSkdic);
}

INT GetTipTextW(WCHAR wch, LPWSTR lpwstrTip, INT cchMax, LPVOID lpSkdic)
{
    DWORD  dwBuf[30];
    PWCHAR pwchReading = PWCHAR(dwBuf + 1);
    WCHAR  awch[2];

    static HKL hKL = NULL;
    if(!hKL) {
        hKL = GetIntelligentKL();
    }

    dwBuf[0] = 0;
    pwchReading[0] = 0;

    awch[0] = wch;
    awch[1] = NULL;
    ::ImmEnumRegisterWordW(hKL,
                           QueryDicDataW,
                           NULL,
                           (IME_REGWORD_STYLE_USER_FIRST + 1),
                           awch, (LPVOID)dwBuf);

    if(*pwchReading) {
        int nStrLen = lstrlenW(pwchReading);
        CopyMemory(lpwstrTip, pwchReading, nStrLen*sizeof(WCHAR));
        lpwstrTip[nStrLen] = NULL;
        return 0;
    }
    return -1;
    UNREFERENCED_PARAMETER(lpSkdic);
    UNREFERENCED_PARAMETER(cchMax);
}

INT CHwxFE::GetTipText(WCHAR wch, LPWSTR lpwstrTip, INT cchMax, LPVOID lpSkdic)
{
    if (IsWinNT()) {
        return GetTipTextW(wch, lpwstrTip, cchMax, lpSkdic);
    } else {
        return GetTipTextA(wch, lpwstrTip, cchMax, lpSkdic);
    }
}

//////////////////////////////////////////////////////////////////
// Function    :    GetIntelligentKL
// Type        :    HKL
// Purpose    :    
// Args        :    None
// Return    :    
// DATE        :    Wed Aug 05 18:56:22 1998
// Author    :    Hail(Hai Liu(PRC))
// Histroy    :    980805: merged with prc source.
//////////////////////////////////////////////////////////////////
HKL GetIntelligentKL(VOID)
{
  return (HKL)0xE00E0804;
}

//////////////////////////////////////////////////////////////////
// Function    :    QueryDicData
// Type        :    int CALLBACK
// Purpose    :    
// Args        :    
//            :    LPCSTR    lpszReading    
//            :    DWORD    dwStyle    
//            :    LPCSTR    lpszString    
//            :    LPVOID    lpvData    
// Return    :    
// DATE        :    Wed Aug 05 18:59:07 1998
// Author    :    Hail(Hai Liu (MSPRC))
// Histroy    :    980805: merged with prc source by ToshiaK(MSKK).
//////////////////////////////////////////////////////////////////
int CALLBACK QueryDicDataA(LPCSTR lpszReading,
                           DWORD   dwStyle,
                           LPCSTR lpszString,
                           LPVOID  lpvData)
{ 
    if (!*lpszReading) { return 1; }

    PDWORD pdwHomNum = (LPDWORD)lpvData;
    PCHAR  pchReadingList = (PCHAR)(pdwHomNum+1);

    pchReadingList += lstrlenA(pchReadingList);
    if (*pdwHomNum == 0) {
    } else if ((*pdwHomNum % 3) == 0) {
        *pchReadingList++ = '\n';
    } else {
        *pchReadingList++ = ' ';
    }
        
    while(*lpszReading != ' ' && *lpszReading != NULL) {
        *pchReadingList++ = *lpszReading++;
    }
    *pchReadingList = NULL;

    (*pdwHomNum)++;

    return 1;
    UNREFERENCED_PARAMETER(lpszString);
    UNREFERENCED_PARAMETER(dwStyle);
}

int CALLBACK QueryDicDataW(LPCWSTR lpwszReading,
                           DWORD   dwStyle,
                           LPCWSTR lpwszString,
                           LPVOID  lpvData)
{ 
    if (!*lpwszReading) { return 1; }

    PDWORD pdwHomNum = (LPDWORD)lpvData;
    PWCHAR  pwchReadingList = (PWCHAR)(pdwHomNum+1);

    pwchReadingList += lstrlenW(pwchReadingList);
    if (*pdwHomNum == 0) {
    } else if ((*pdwHomNum % 3) == 0) {
        *pwchReadingList++ = L'\n';
    } else {
        *pwchReadingList++ = L' ';
    }
        
    while(*lpwszReading != ' ' && *lpwszReading != NULL) {
        *pwchReadingList++ = *lpwszReading++;
    }
    *pwchReadingList = NULL;

    (*pdwHomNum)++;

    return 1;
    UNREFERENCED_PARAMETER(dwStyle);
    UNREFERENCED_PARAMETER(lpwszString);
}

//---FE_CHINESE_SIMPLIFIED CHwxFE::GetTipText() End
#elif FE_KOREAN
//---FE_KOREAN CHwxFE::GetTipText() Start
#define UNICODE_CJK_UNIFIED_IDEOGRAPHS_START                0x4E00
#define UNICODE_CJK_UNIFIED_IDEOGRAPHS_END                    0x9FFF
#define UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_START            0xF900
#define UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_END            0xFAFF

inline
BOOL fIsHanja(WCHAR wcCh)
    {
    return (wcCh >= UNICODE_CJK_UNIFIED_IDEOGRAPHS_START && 
            wcCh <= UNICODE_CJK_UNIFIED_IDEOGRAPHS_END) ||
           (wcCh >= UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_START &&
            wcCh <= UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_END);
    }

INT CHwxFE::GetTipText(WCHAR wch, LPWSTR lpwstrTip, INT cchMax, LPVOID lpSkdic)
{
    // If Hanja display the meaning and the pronounciation
    if ((fIsHanja(wch) && GetMeaningAndProunc(wch, lpwstrTip, cchMax)) == FALSE)
        {
        swprintf(lpwstrTip,    L"U+%04X", wch, wch);
        }
    return 0;
    UNREFERENCED_PARAMETER(wch);
    UNREFERENCED_PARAMETER(lpwstrTip);
    UNREFERENCED_PARAMETER(cchMax);
    UNREFERENCED_PARAMETER(lpSkdic);
}
//---FE_KOREAN CHwxFE::GetTipText() End
#else
INT CHwxFE::GetTipText(WCHAR wch, LPWSTR lpwstrTip, INT cchMax, LPVOID lpSkdic)
{
    return 0;
    UNREFERENCED_PARAMETER(wch);
    UNREFERENCED_PARAMETER(lpwstrTip);
    UNREFERENCED_PARAMETER(cchMax);
    UNREFERENCED_PARAMETER(lpSkdic);
}
#endif 

//////////////////////////////////////////////////////////////////
// Function    :    CHwxFE::Is16bitApplication
// Type        :    BOOL
// Purpose    :    Check application is 16bit or not for HtmlHelp
// Args        :    None
// Return    :    
// DATE        :    Mon Sep 21 13:30:56 1998
// Histroy    :    
//////////////////////////////////////////////////////////////////
BOOL CHwxFE::Is16bitApplication(VOID)
{
#ifndef UNDER_CE // Windows CE always Unicode
    Dbg(("CHwxFE::Is16bitApplication()\n"));
    if(IsWinNT()) {
        //Dbg(("NT \n"));
        DWORD dwType = 0;
        BOOL  fRet = FALSE;
        LPSTR lpstrPath = (LPSTR)MemAlloc(sizeof(CHAR)*(MAX_PATH+1));
        //Dbg(("lpstrPath 0x%08x\n", lpstrPath));
        if(lpstrPath) {
            *lpstrPath = (CHAR)0x00;
            INT len = ::GetModuleFileName(NULL, lpstrPath, sizeof(CHAR)*(MAX_PATH+1));
            if(len > 0) {
                *(lpstrPath+len) = (CHAR)0x00;
            }
            //Dbg(("lpstrPath %s\n", lpstrPath));
            ::GetBinaryType(lpstrPath, &dwType);
            //Dbg(("dwType 0x%08x\n", dwType));
            if(dwType == SCS_WOW_BINARY) {
                fRet = TRUE;
            }
            MemFree(lpstrPath);
            //Dbg(("fRet %d\n", fRet));
            return fRet;
        }
    }
    else {
        HANDLE hThread;
        DWORD dwId;
        hThread = ::CreateThread(NULL,
                                 0,
                                 NULL,
                                 0,
                                 0,
                                 &dwId);
        if(hThread) {
            //Dbg(("CreateThread hThread[%d]\n", hThread));
            ::CloseHandle(hThread);
            return FALSE;
        }
        else {
            INT ret = ::GetLastError();
            //Dbg(("CreateThread ret %d\n",ret));
            switch(ret) {
            case ERROR_NOT_SUPPORTED:
                return TRUE;
            case ERROR_INVALID_PARAMETER:
                return FALSE;
            default:
                return FALSE;
            }
        }
    }
#endif // UNDER_CE
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxobj.h ===
// This file defines a set of classes such as CHwxObject,CHwxInkWindow,
// CHwxMB,CHwxCAC,CHwxStroke,CHwxThread,CHwxThreadMB,CHwxThreadCAC,and
// so on.
#ifndef _HWXOBJ_H_
#define _HWXOBJ_H_

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "const.h"
#include "recog.h"
#include "hwxapp.h"
#include "../lib/ddbtn/ddbtn.h"
#include "../lib/exbtn/exbtn.h"
#include "../lib/plv/plv.h"
#ifdef FE_JAPANESE
#include "../imeskdic/imeskdic.h"
#endif

LRESULT	WINAPI HWXWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI MBWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI CACWndProc(HWND, UINT, WPARAM, LPARAM);

INT_PTR CALLBACK CACMBPropDlgProc(HWND, UINT, WPARAM, LPARAM);

LRESULT WINAPI CACMBBtnWndProc(HWND, UINT, WPARAM, LPARAM);

//----------------------------------------------------------------
//980727: by ToshiaK
//source is described in hwxobj.cpp
//----------------------------------------------------------------
BOOL IsWinNT4(VOID);
BOOL IsWinNT5(VOID);
BOOL IsWinNT5orUpper();
BOOL IsWinNT(VOID);
BOOL IsWin95(VOID);
BOOL IsWin98(VOID);

extern TCHAR szBuf[MAX_PATH];
extern TOOLINFOW ti;

class CHwxObject
{
	public:
		CHwxObject(HINSTANCE hInstance);
		~CHwxObject();

		virtual BOOL Initialize(TCHAR * pClsName);
		_inline TCHAR * GetHwxClsName() const { return (TCHAR *)m_pClassName; }
	    _inline int GetHwxClsNameLength() const { return m_nLen; }
#ifndef UNDER_CE
		_inline BOOL IsMyHwxCls(TCHAR * pClsName) { return !strcmp(m_pClassName,pClsName); }
#else // UNDER_CE
		_inline BOOL IsMyHwxCls(TCHAR * pClsName) { return !lstrcmp(m_pClassName,pClsName); }
#endif // UNDER_CE
		void * operator new(size_t size);
		void   operator delete(void * pv);

	protected:
		static HINSTANCE m_hInstance;		
	private:
		int m_nLen;					// length of a class name
		TCHAR  m_pClassName[16];		// class name 

};

typedef struct tagSTROKE
{
    struct   tagSTROKE *pNext;  // Pointer to the next stroke.
    int      xLeft;   			// Left edge of the box this stroke is drawn in
    int      iBox; 				// Logical box number the stroke was written in
	int      cpt;  				// number of points within the stroke
	POINT    apt[1];
} STROKE, *PSTROKE;

class CHwxThreadMB;
class CHwxThreadCAC;
class CHwxInkWindow;
class CApplet;

class CHwxStroke: public CHwxObject
{
  	public:
		CHwxStroke(BOOL bForward,long lSize);
		~CHwxStroke();
		virtual BOOL Initialize(TCHAR * pClsName);
		BOOL ResetPen(VOID);	//990618:ToshiaK for KOTAE #1329
		BOOL AddPoint(POINT pt);
		BOOL AddBoxStroke(int nLogBox,int nCurBox,int nBoxHeight);
		void EraseCurrentStroke();
		void DeleteAllStroke();
		CHwxStroke & operator=(CHwxStroke & stroke);	// copy stroke from one class to the other
		void ScaleInkXY(long x,long y);
		PSTROKE CopyCurrentStroke();
		void DrawStroke(HDC hdc,int nPts,BOOL bEntire);
		void GetUpdateRect(RECT * prc);

		_inline PSTROKE GetCurrentStrokePtr() { return m_pCurStroke; }
		_inline PSTROKE GetStrokePtr() { return m_pStroke; }
		_inline long * GetNumStrokesAddress() { return &m_nStroke; }
		_inline long   GetNumStrokes() { return m_nStroke; }
		_inline void   IncStrokeCount() { m_nStroke++; }
		_inline void   DecStrokeCount() { m_nStroke--; }
	protected:
		BOOL growPointBuffer();
		void resetPointBuffer();
		PSTROKE dupStroke();

	private:
		BOOL m_bForward;		// TRUE means inserting a current stroke at the
								// beginning of a stroke list
		PSTROKE  m_pStroke;		// a stroke list to form a character
		PSTROKE  m_pCurStroke; 	// point to the current stroke just inserted
		long	 m_nStroke;		// number of strokes in the list
	    POINT * m_ppt;          // points being drawn currently
    	long m_cpt;           	// count of points in the buffer
    	long m_max;           	// max room for points in m_ppt
		long m_nSize;			// a constant size for point buffer growing
		HPEN m_hPen;
};

typedef struct tagPROPDATA
{
	UINT uTimerValue;
	BOOL bAlwaysRecog;
}PROPDATA;

class CHwxMB: public CHwxObject
{
	public:
		CHwxMB(CHwxInkWindow * pInk,HINSTANCE hInst);
		~CHwxMB();
		virtual BOOL Initialize(TCHAR * pClsName);
		BOOL CreateUI(HWND);

		void HandlePaint(HWND);
		BOOL HandleMouseEvent(HWND,UINT,WPARAM,LPARAM);
		LRESULT HandleUserMessage(HWND,UINT,WPARAM,LPARAM);
		LRESULT	HandleCommand(HWND,UINT,WPARAM,LPARAM);
		void OnSettingChange(UINT,WPARAM,LPARAM);
		void SetBoxSize(WORD);

		_inline long GetStrokeCount() { return m_pCHwxStroke->GetNumStrokes(); }
		_inline long * GetStrokeCountAddress() { return m_pCHwxStroke->GetNumStrokesAddress(); }
		_inline PSTROKE GetStrokePoiner() { return m_pCHwxStroke->GetStrokePtr(); }
		_inline HWND GetMBWindow() { return m_hMBWnd; }
		_inline void SetMBWindow(HWND hwnd) { m_hMBWnd = hwnd; }
		_inline CHwxThreadMB * GetMBThread() { return m_pCHwxThreadMB; }
		_inline CHwxStroke * GetMBCHwxStroke() { return m_pCHwxStroke; }
		_inline UINT GetTimeOutValue() { return m_timeoutValue; }
		_inline void SetTimeOutValue(UINT u) { m_timeoutValue = u; }
		_inline void SetTimerStarted(BOOL bval) { m_bTimerStarted = bval; }

	protected:
	private:
		BOOL IsInInkBox(PPOINT);
		BOOL IsPointInResizeBox(PPOINT);
		void recognize();
		void SetLogicalBox(int);
		void SetContext();
		WCHAR findLastContext();
		void DrawMBInkBox(HDC, WORD);

		CHwxInkWindow * m_pInk;
		CHwxThreadMB * m_pCHwxThreadMB;
		CHwxStroke * m_pCHwxStroke;
		HWND m_hMBWnd;

	    RECT  m_clipRect;      // Current clipping rectangle.
    	POINT m_ptClient;      // Client windows origin.
    	DWORD m_CurrentMask;
		DWORD m_lastMaskSent;
    	WCHAR m_lastCharSent;
		WCHAR m_Context[101];
    	WORD m_bHiPri;
    	WORD m_boxSize;
    	WORD m_bDown;
		WORD m_bRightClick;
    	WORD m_bNoInk;
    	WORD m_cLogicalBox;
    	WORD m_curBox;
    	WORD m_iBoxPrev;
		HDC  m_hdcMouse;	 // cache HDC. It must be NULL when deleting an object
							 // of this class.
		HCURSOR   m_hCursor;
		BOOL	  m_bResize;
		int		  m_firstX;

	    BOOL  	  m_bTimerStarted;
		UINT      m_timeoutValue;

		WCHAR m_StringCandidate[MB_NUM_CANDIDATES][2];
		LPIMESTRINGCANDIDATE m_pImeStringCandidate;
		LPIMESTRINGCANDIDATEINFO m_pImeStringCandidateInfo;
		BOOL	 m_bErase;
};

class CHwxCAC;
class CHwxInkWindow: public CHwxObject
{
	public:
		CHwxInkWindow(BOOL,BOOL,CApplet *,HINSTANCE);
		~CHwxInkWindow();
		virtual BOOL Initialize(TCHAR * pClsName);
		BOOL CreateUI(HWND);
		BOOL Terminate();

		BOOL HandleCreate(HWND);
		void HandlePaint(HWND);
		void HandleHelp(HWND,UINT,WPARAM,LPARAM);
		LRESULT HandleCommand(HWND,UINT,WPARAM,LPARAM);
		LRESULT HandleSettingChange(HWND,UINT,WPARAM,LPARAM);
		LRESULT HandleBtnSubWnd(HWND,UINT,WPARAM,LPARAM);
		LPWSTR  LoadCACMBString(UINT);
		void HandleDlgMsg(HWND,BOOL);
		void CopyInkFromMBToCAC(CHwxStroke & str,long deltaX,long deltaY);
		void HandleSize(WPARAM,LPARAM);
		void ChangeLayout(BOOL);
	  	void SetTooltipInfo();
		void SetTooltipText(LPARAM);
		CHwxStroke * GetCACCHwxStroke();
		void DrawHwxGuide(HDC,LPRECT);
		void HandleConfigNotification();
		void UpdateRegistry(BOOL);
		void ChangeIMEPADSize(BOOL);
		BOOL HandleSizeNotify(INT *pWidth, INT *pHeight);	//980605; ToshiaK
		_inline HWND GetInkWindow() { return m_hInkWnd; }
		_inline HWND GetToolTipWindow() { return m_hwndTT; }

		_inline int GetInkWindowWidth()
		{
			return m_bCAC ? m_wCACWidth : m_wInkWidth;
		}
		_inline int GetInkWindowHeight()
		{
			return m_bCAC ? m_wCACHeight : m_wInkHeight;
		}

		_inline int GetMBWidth() { return m_wPadWidth; }
		_inline int GetMBHeight() { return m_wPadHeight; }
		void SetMBHeight(int h);

		_inline int GetMBBoxNumber() { return m_numBoxes; }

		_inline int GetCACWidth() { return m_wCACWidth; }
		_inline int GetCACHeight() { return m_wCACHeight; }
		_inline int GetCACInkHeight() { return m_wCACInkHeight; }
		void SetCACInkHeight(int w);

		_inline CApplet * GetAppletPtr() { return m_pApplet; }
		_inline CHwxStroke * GetMBCHwxStroke() { return m_pMB->GetMBCHwxStroke(); }
		_inline BOOL Is16BitApp() { return m_b16Bit; }
		_inline BOOL IsNT() { return m_bNT; }
		_inline BOOL IsSglClk() { return m_bSglClk; }
		_inline BOOL IsDblClk() { return m_bDblClk; }
		_inline void SetSglClk(BOOL b)
		{
			m_bSglClk = b;
			if ( m_bCAC )
			{
				exbtnPushedorPoped(m_bSglClk);
			}
		}
		_inline void SetDblClk(BOOL b)
		{
			m_bDblClk = b;
			if ( m_bCAC )
			{
				if ( m_bDblClk )
				{
					m_bSglClk = FALSE;
					exbtnPushedorPoped(TRUE);
				}
				else
				{
					exbtnPushedorPoped(m_bSglClk);
				}
			}
		}
		INT	 OnChangeView(BOOL fLarge);	//980728: by ToshiaK for raid #2846
	private:
		BOOL handleCACMBMenuCmd(RECT *,UINT,UINT,RECT *);
		void changeCACLayout(BOOL);
		void changeMBLayout(BOOL);
		void exbtnPushedorPoped(BOOL);
		FARPROC getCACMBBtnProc(HWND hwnd)
		{
			if ( hwnd == m_hCACMBMenu )
				return m_CACMBMenuDDBtnProc;
			else if ( hwnd == m_hCACMBRecog )
				return m_CACMBRecogEXBtnProc;
			else if ( hwnd == m_hCACMBRevert )
				return m_CACMBRevertEXBtnProc;
			else if ( hwnd == m_hCACMBClear )
				return m_CACMBClearEXBtnProc;
			else if ( hwnd == m_hCACSwitch )
				return m_CACSwitchDDBtnProc;
			else
				return NULL;
		}

		CApplet * m_pApplet;
		CHwxMB * m_pMB;
		CHwxCAC * m_pCAC;

		HWND m_hInkWnd;
		HWND m_hwndTT;
		BOOL m_b16Bit;
		BOOL m_bNT;
		BOOL m_bCAC;
		BOOL m_bSglClk;
		BOOL m_bDblClk;
		BOOL m_bMouseDown;
		HWND m_hCACMBMenu;
		HWND m_hCACMBRecog;
		HWND m_hCACMBRevert;
		HWND m_hCACMBClear;
		HWND m_hCACSwitch;
		FARPROC m_CACMBMenuDDBtnProc;
		FARPROC m_CACMBRecogEXBtnProc;
		FARPROC m_CACMBRevertEXBtnProc;
		FARPROC m_CACMBClearEXBtnProc;
		FARPROC m_CACSwitchDDBtnProc;


		int		m_wInkWidth;
		int		m_wInkHeight;
		int		m_wPadWidth;
		int		m_wPadHeight;
		int     m_numBoxes;

  		int 	m_wCACWidth;
		int 	m_wCACHeight;
		int		m_wCACPLVHeight;
		int		m_wCACPLVWidth;
		int 	m_wCACTMPWidth;
		int 	m_wCACInkHeight;
};

class CHwxCAC: public CHwxObject
{
	friend	int WINAPI GetItemForIcon(LPARAM lParam, int index, LPPLVITEM lpPlvItem);
	friend	int WINAPI GetItemForReport(LPARAM lParam, int index, int indexCol, LPPLVITEM lpPlvItem);
	public:
		CHwxCAC(CHwxInkWindow * pInk,HINSTANCE hInst);
		~CHwxCAC();
		virtual BOOL Initialize(TCHAR * pClsName);
		BOOL CreateUI(HWND);

		void HandlePaint(HWND);
		void HandleMouseEvent(HWND,UINT,WPARAM,LPARAM);
		void HandleRecogResult(HWND,WPARAM,LPARAM);
		void HandleShowRecogResult(HWND,WPARAM,LPARAM);
		void HandleSendResult(HWND,WPARAM,LPARAM);
		void GetInkFromMB(CHwxStroke & str,long deltaX,long deltaY);
		void HandleDeleteOneStroke();
		void HandleDeleteAllStroke();
		LRESULT	HandleCommand(HWND,UINT,WPARAM,LPARAM);
		void OnSettingChange(UINT,WPARAM,LPARAM);

	  	void SetToolTipInfo(BOOL);
		void SetToolTipText(LPARAM);
		void recognize();
		void NoThreadRecognize(int);
		void HandleResizePaint(HWND);
		void SetInkSize(int);
		void HandleDrawSample();
		_inline long GetStrokeCount() { return m_pCHwxStroke->GetNumStrokes(); }
		_inline long * GetStrokeCountAddress() { return m_pCHwxStroke->GetNumStrokesAddress(); }
		_inline PSTROKE GetStrokePointer() { return m_pCHwxStroke->GetStrokePtr(); }
		_inline HWND GetCACWindow() { return m_hCACWnd; }
		_inline HWND GetCACLVWindow() { return m_hLVWnd; }
		_inline CHwxThreadCAC * GetCACThread() { return m_pCHwxThreadCAC; }
		_inline CHwxStroke * GetCACCHwxStroke() { return m_pCHwxStroke; }
		_inline BOOL Is16BitApp() { return m_pInk->Is16BitApp(); }
		_inline BOOL IsNT() { return m_pInk->IsNT(); }
		_inline BOOL IsLargeView() { return m_bLargeView; }
		_inline void SetLargeView(BOOL b) { m_bLargeView = b; }
#ifdef FE_JAPANESE		
		_inline IImeSkdic * GetIIMESKDIC() { return m_pIImeSkdic; }
#endif
		_inline WCHAR GetWCHAR(int i)
		{
			if ( i >= 0 && i <= m_cnt )
				return m_gawch[i];
			return 0;
		}

	protected:
	private:
		BOOL Init();
		void InitBitmap(DWORD,int);
		void InitBitmapText();
		void InitBitmapBackground();
		BOOL checkRange(int, int);
		BOOL IsPointInResizeBox(int,int);
		BOOL IsDupResult(WORD);
		HBITMAP makeCharBitmap(WCHAR);
		void pickUpChar(LPPLVINFO);
		void pickUpCharHelper(WCHAR);
#ifdef FE_JAPANESE
		void sortKanjiInfo(int);
#endif
		CHwxInkWindow * m_pInk;
		CHwxThreadCAC * m_pCHwxThreadCAC;
		CHwxStroke * m_pCHwxStroke;
		HWND m_hCACWnd;

		BOOL 	 m_bLargeView;

		BOOL     m_gbDown;
		WORD 	m_bRightClick;
		WORD	 m_gawch[LISTTOTAL];
		int		 m_cnt;
		int 	 m_inkSize;

		HDC		 m_ghdc;
		HBITMAP	 m_ghbm;
		HFONT	 m_ghfntTT;

		HWND 	 m_hLVWnd;
#ifdef FE_JAPANESE		
		IImeSkdic * m_pIImeSkdic;
		HINSTANCE m_hSkdic;
#endif
		LPPLVINFO m_lpPlvInfo;
#ifdef FE_JAPANESE		
		WCHAR     m_wchOther[MAX_ITAIJI_COUNT+1];
#endif
		HCURSOR   m_hCursor;
		BOOL	  m_bResize;
		BOOL	  m_bDrawSample;
};

typedef BOOL (WINAPI * PHWXCONFIG)();
typedef HRC  (WINAPI * PHWXCREATE)(HRC);
typedef BOOL (WINAPI * PHWXDESTROY)(HRC);
typedef BOOL (WINAPI * PHWXSETGUIDE)(HRC,HWXGUIDE *);
typedef BOOL (WINAPI * PHWXALCVALID)(HRC,ALC);
typedef BOOL (WINAPI * PHWXALCPRIORITY)(HRC,ALC);
typedef BOOL (WINAPI * PHWXSETPARTIAL)(HRC,UINT);
typedef BOOL (WINAPI * PHWXSETABORT)(HRC,UINT *);
typedef BOOL (WINAPI * PHWXINPUT)(HRC,POINT *,UINT,DWORD);
typedef BOOL (WINAPI * PHWXENDINPUT)(HRC);
typedef BOOL (WINAPI * PHWXPROCESS)(HRC);
typedef INT  (WINAPI * PHWXGETRESULTS)(HRC,UINT,UINT,UINT,HWXRESULTS *);
typedef BOOL (WINAPI * PHWXSETCONTEXT)(HRC,WCHAR);    
typedef INT  (WINAPI * PHWXRESULTSAVAILABLE)(HRC);

typedef struct tagHWXRESULTPRI
{
	WORD cbCount;
	WORD iSelection;
	WORD iPosition;
	WCHAR chCandidate[MB_NUM_CANDIDATES];
	struct tagHWXRESULTPRI *pNext;
} HWXRESULTPRI, *LPHWXRESULTPRI;

class CHwxThread: public CHwxObject
{
	public:
		CHwxThread();
		~CHwxThread();
		virtual BOOL Initialize(TCHAR * pClsName);

		BOOL StartThread() ;
		void StopThread() ;
		_inline BOOL IsThreadStarted() { return m_hThread != NULL; }
		_inline HANDLE GetHandle() { return m_hThread; }
		_inline DWORD  GetID() { return m_thrdID; }
		_inline DWORD  GetHwxThreadArg() { return m_thrdArg; }

	protected:
		virtual DWORD RecognizeThread(DWORD) = 0;

		
		//static HINSTANCE m_hHwxjpn;
		//----------------------------------------------------------------
		//971217:ToshiaK changed to static to no static.
		//ImePad window is created per Thread.
		//----------------------------------------------------------------
		HINSTANCE m_hHwxjpn;
	    static PHWXCONFIG lpHwxConfig;
    	static PHWXCREATE lpHwxCreate;
    	static PHWXSETCONTEXT lpHwxSetContext;
    	static PHWXSETGUIDE lpHwxSetGuide;
		static PHWXALCVALID lpHwxAlcValid;
    	static PHWXSETPARTIAL lpHwxSetPartial;
		static PHWXSETABORT lpHwxSetAbort;
    	static PHWXINPUT lpHwxInput;
    	static PHWXENDINPUT lpHwxEndInput;
    	static PHWXPROCESS lpHwxProcess;
    	static PHWXRESULTSAVAILABLE lpHwxResultsAvailable;
    	static PHWXGETRESULTS lpHwxGetResults;
	    static PHWXDESTROY lpHwxDestroy;

		HANDLE m_hThread;
		DWORD  m_thrdID;
		DWORD  m_thrdArg;
		HANDLE m_hStopEvent;
		BOOL   m_Quit;		//971202: by Toshiak

	private:
		static DWORD WINAPI RealThreadProc(void* );
		DWORD  ClassThreadProc();
		void   RecogHelper(HRC,DWORD,DWORD);
};

class CHwxThreadMB: public CHwxThread
{
	public:
		CHwxThreadMB(CHwxMB * pMB, int nSize);
		~CHwxThreadMB();
		virtual BOOL Initialize(TCHAR * pClsName);
		virtual DWORD RecognizeThread(DWORD);
	protected:
	private:
		BOOL HandleThreadMsg(MSG *);
		HWXRESULTPRI *GetCandidates(HWXRESULTS *);
		void GetCharacters(int iSentAlready, int iReady);

		CHwxMB *  m_pMB;
		ALC		  m_recogMask;
		WCHAR	  m_prevChar;
		HRC 	  m_hrcActive;  	// HRC used for doing recognition.
		int 	  m_giSent;         // How many characters we have already sent.
		int 	  m_bDirty;		    // True if there is ink to process.
		HWXGUIDE  m_guide;
};

class CHwxThreadCAC: public CHwxThread
{
	public:
		CHwxThreadCAC(CHwxCAC * pCAC);
		~CHwxThreadCAC();
		virtual BOOL Initialize(TCHAR * pClsName);
		virtual DWORD RecognizeThread(DWORD);
		void 	RecognizeNoThread(int);
		_inline BOOL IsHwxjpnLoaded() { return m_hHwxjpn != NULL; }

	protected:
	private:
		void recoghelper(HRC,DWORD,DWORD);

		CHwxCAC * m_pCAC;
};
#endif // _HWXOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxmb.cpp ===
#include "hwxobj.h"
#include "memmgr.h"
#include "resource.h"
#include "hwxfe.h"
#include "dbg.h"
#include "cmnhdr.h"
#ifdef UNDER_CE // Windows CE Stub for unsupported APIs
#include "stub_ce.h"
#endif // UNDER_CE

#ifdef FE_JAPANESE
// for character comment
BOOL FGetFarEastInfo(HWXRESULTPRI *pResult, DWORD *pdwID, LPIMEFAREASTINFO *ppInfo);
#endif


// implementation of CHwxMB

CHwxMB::CHwxMB(CHwxInkWindow * pInk,HINSTANCE hInst):CHwxObject(hInst)
{
    m_pInk = pInk;
    m_pCHwxThreadMB = NULL;
    m_pCHwxStroke = NULL;
    m_hMBWnd = NULL;
//    m_hInstance = hInst;
    
    SetRect(&m_clipRect,0,0,0,0);
    m_ptClient.x = m_ptClient.y = 0;
#ifdef FE_CHINESE_SIMPLIFIED
    m_CurrentMask = m_lastMaskSent  = ALC_CHS_EXTENDED;
#else
    m_CurrentMask = m_lastMaskSent  = ALC_JPN_EXTENDED;
#endif
    m_lastCharSent =   INVALID_CHAR;
    memset(m_Context, '\0', sizeof(m_Context));
    m_bHiPri = FALSE;
    if ( pInk )
        m_boxSize = (USHORT)pInk->GetMBHeight();
    else
        m_boxSize = PadWnd_Height;

    m_bDown = FALSE;
    m_bRightClick = FALSE;
    m_bNoInk = TRUE;
    m_cLogicalBox = 0;
    m_curBox = TOTALLOGICALBOX;
    m_iBoxPrev = TOTALLOGICALBOX;
    m_hdcMouse = NULL;

    m_hCursor = LoadCursor(NULL,IDC_ARROW);
    m_bResize = FALSE;
    m_firstX = 0;

    m_bTimerStarted = FALSE;
    m_timeoutValue = 0;
    m_pImeStringCandidate = NULL;
    m_pImeStringCandidateInfo = NULL;
    m_bErase = FALSE;
}
 
CHwxMB::~CHwxMB()
{
    m_pInk = NULL;
//    m_hInstance = NULL;
    if ( m_hMBWnd )
    {
         DestroyWindow(m_hMBWnd);
        m_hMBWnd = NULL;
    }
    if ( m_pCHwxThreadMB )
    {
         delete m_pCHwxThreadMB;
        m_pCHwxThreadMB = NULL;
    }
    if ( m_pCHwxStroke )
    {
         delete m_pCHwxStroke;
        m_pCHwxStroke = NULL;
    }
    if ( m_pImeStringCandidate )
    {
         MemFree((void *)m_pImeStringCandidate);
        m_pImeStringCandidate = NULL;
    }
    if ( m_pImeStringCandidateInfo )
    {
         MemFree((void *)m_pImeStringCandidateInfo);
        m_pImeStringCandidateInfo = NULL;
    }
}

BOOL CHwxMB::Initialize(TCHAR * pClsName)
{
    BOOL bRet = CHwxObject::Initialize(pClsName);
    if ( bRet )
    {
        WNDCLASS        wndClass;
        wndClass.style          = CS_HREDRAW | CS_VREDRAW;
        wndClass.lpfnWndProc    = MBWndProc;
        wndClass.cbClsExtra     = 0;
        wndClass.cbWndExtra     = sizeof(void *);
        wndClass.hInstance      = m_hInstance;
        wndClass.hIcon          = 0;
        wndClass.hCursor        = LoadCursor(NULL,MAKEINTRESOURCE(32631));
#ifndef UNDER_CE
        wndClass.hbrBackground  = (HBRUSH)(COLOR_3DFACE+1);
#else // UNDER_CE
        wndClass.hbrBackground  = GetSysColorBrush(COLOR_3DFACE);
#endif // UNDER_CE
        wndClass.lpszMenuName   = NULL;
        wndClass.lpszClassName  = TEXT("WPad");

        RegisterClass(&wndClass);

        int tmpSize = sizeof(IMESTRINGCANDIDATE) + MB_NUM_CANDIDATES * sizeof(LPWSTR);
        m_pImeStringCandidate = (LPIMESTRINGCANDIDATE)MemAlloc(tmpSize);
        if ( !m_pImeStringCandidate )
        {
             return FALSE;
        }
        tmpSize = sizeof(IMESTRINGCANDIDATEINFO) + MB_NUM_CANDIDATES * sizeof(LPWSTR);
        m_pImeStringCandidateInfo = (LPIMESTRINGCANDIDATEINFO)MemAlloc(tmpSize);
        if ( !m_pImeStringCandidateInfo )
        {
             return FALSE;
        }
        m_pCHwxThreadMB = new CHwxThreadMB(this,m_boxSize);
        if ( !m_pCHwxThreadMB )
        {
            MemFree((void *)m_pImeStringCandidate);
            m_pImeStringCandidate = NULL;
            MemFree((void *)m_pImeStringCandidateInfo);
            m_pImeStringCandidateInfo = NULL;
            return FALSE;
        }
        m_pCHwxStroke = new CHwxStroke(TRUE,32);
        if ( !m_pCHwxStroke )
        {
            MemFree((void *)m_pImeStringCandidate);
            m_pImeStringCandidate = NULL;
            MemFree((void *)m_pImeStringCandidateInfo);
            m_pImeStringCandidateInfo = NULL;
            delete m_pCHwxThreadMB;
            m_pCHwxThreadMB = NULL;
            return FALSE;
        }

        bRet = m_pCHwxThreadMB->Initialize(TEXT("CHwxThreadMB"));
        if ( !bRet )
        {
            MemFree((void *)m_pImeStringCandidate);
            m_pImeStringCandidate = NULL;
            MemFree((void *)m_pImeStringCandidateInfo);
            m_pImeStringCandidateInfo = NULL;
             delete m_pCHwxThreadMB;
            m_pCHwxThreadMB = NULL;
            delete m_pCHwxStroke;
            m_pCHwxStroke = NULL;
            return FALSE;
        }
        bRet = m_pCHwxStroke->Initialize(TEXT("CHwxStrokeMB"));
        if ( !bRet )
        {
            MemFree((void *)m_pImeStringCandidate);
            m_pImeStringCandidate = NULL;
            MemFree((void *)m_pImeStringCandidateInfo);
            m_pImeStringCandidateInfo = NULL;
             delete m_pCHwxThreadMB;
            m_pCHwxThreadMB = NULL;
            delete m_pCHwxStroke;
            m_pCHwxStroke = NULL;
            return FALSE;
        }
    }
    return bRet;
}

BOOL CHwxMB::CreateUI(HWND hwnd)
{
     m_hMBWnd = CreateWindowEx( 0,
                                TEXT("WPad"),
                               TEXT(""),
                               WS_CHILD | WS_VISIBLE,
                               0, 0,
                               0, 0,
                               hwnd,
                               (HMENU)IDC_MBINPUT, //980706:for #1624. for "?" help
                               m_hInstance,
                               this);
    if( !m_hMBWnd )
    {
        return FALSE;
    }
    return TRUE;
}

void CHwxMB::HandlePaint(HWND hwnd)
{
    int        x, i;
    RECT rc;
    HBRUSH    hbr, hbrOld;
    int mbWidth = m_pInk->GetMBWidth();
    int mbHeight = m_pInk->GetMBHeight();
    int numBoxes = m_pInk->GetMBBoxNumber();

    //    Erase the whole thing first
    //
    PAINTSTRUCT ps;
    BeginPaint(hwnd, &ps);

    if ( ps.fErase )
    {
        rc.left = rc.top = 0;
        rc.right = mbWidth;
        rc.bottom = Box_Border;
#ifndef UNDER_CE
        FillRect(ps.hdc,&rc,(HBRUSH)(COLOR_3DFACE+1));
#else // UNDER_CE
        FillRect(ps.hdc,&rc,GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE

        rc.left = 0;
        rc.top = mbHeight - Box_Border;
        rc.right = mbWidth;
        rc.bottom = mbHeight;
#ifndef UNDER_CE
        FillRect(ps.hdc,&rc,(HBRUSH)(COLOR_3DFACE+1));
#else // UNDER_CE
        FillRect(ps.hdc,&rc,GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE

        x = 0;
        for ( i = 0; i < numBoxes; i++)
        {
             rc.left = x;
            rc.top = Box_Border;
            rc.right = rc.left + Box_Border;
            rc.bottom = mbHeight - Box_Border;
#ifndef UNDER_CE
            FillRect(ps.hdc,&rc,(HBRUSH)(COLOR_3DFACE+1));
#else // UNDER_CE
            FillRect(ps.hdc,&rc,GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE

             rc.left = x + m_boxSize - Box_Border;
            rc.top = Box_Border;
            rc.right = rc.left + Box_Border;
            rc.bottom = mbHeight - Box_Border;
#ifndef UNDER_CE
            FillRect(ps.hdc,&rc,(HBRUSH)(COLOR_3DFACE+1));
#else // UNDER_CE
            FillRect(ps.hdc,&rc,GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE
            x += m_boxSize;
        }
    }

    //    Draw all the boxes.
    //

    //----------------------------------------------------------------
    //980803:ToshiaK merge with PRC
    //use COLOR_WINDOW instead of WHITE_BRUSH
    //----------------------------------------------------------------
    hbr    = ::CreateSolidBrush(::GetSysColor(COLOR_WINDOW));
    hbrOld = (HBRUSH)::SelectObject(ps.hdc, hbr);
    x = 0;
    for (i=0; i < numBoxes; i++)
    {
        Rectangle(ps.hdc, x+Box_Border, Box_Border,
                  x+m_boxSize-Box_Border,
                  m_boxSize-Box_Border);
        rc.top = Box_Border;
        rc.left= x+Box_Border;
        rc.right=x+m_boxSize-Box_Border;
        rc.bottom=m_boxSize-Box_Border;
        DrawEdge(ps.hdc,&rc,EDGE_SUNKEN,BF_RECT);
        m_pInk->DrawHwxGuide(ps.hdc,&rc);
        x += m_boxSize;
    }
    m_iBoxPrev = TOTALLOGICALBOX;

    //
    // Redraw the current character.
    //
      m_pCHwxStroke->DrawStroke(ps.hdc,0,TRUE);
    ::SelectObject(ps.hdc, hbrOld);
    ::DeleteObject(hbr);  //980803:ToshiaK.PRC merge
    EndPaint(hwnd, &ps);
}

BOOL CHwxMB::IsInInkBox(PPOINT ppt)
{
    int iBox = ppt->x / m_boxSize;
    POINT pt = *ppt;
    RECT rc;
    rc.left = iBox*m_boxSize + Box_Border;
    rc.top = Box_Border;
    rc.right = rc.left + m_boxSize - 2*Box_Border;       
    rc.bottom = m_boxSize - Box_Border;
    return PtInRect(&rc,pt);
}

BOOL CHwxMB::IsPointInResizeBox(PPOINT ppt)
{

    int iBox = (ppt->x-1) / m_boxSize;
    int numBox = m_pInk->GetMBBoxNumber();
    if ( numBox == ( iBox + 1) )
        return FALSE;
    POINT pt = *ppt;
    RECT rc;
    rc.left = (iBox+1)*m_boxSize - Box_Border;
    rc.top = Box_Border + 2;
    rc.right = rc.left + 2*Box_Border;       
    rc.bottom = m_boxSize - Box_Border - 2;
    return PtInRect(&rc,pt);
}

void CHwxMB::recognize(void)
{
    PostThreadMessage(m_pCHwxThreadMB->GetID() , THRDMSG_RECOGNIZE, (WPARAM)m_cLogicalBox, (LONG) 0);
    m_cLogicalBox = 0;
}

void CHwxMB::SetLogicalBox(int iBox)
{
    if (iBox != m_curBox)   // Are we in a new box ?
    {
        //
        // We need to blow away the strokes we saved for redrawing the screen
        //
        m_pCHwxStroke->DeleteAllStroke();
        if (iBox == TOTALLOGICALBOX)    // If the new box is TOTALLOGICALBOX we need to recognize everything.
         {
            recognize();
        }
        else
        {
            m_cLogicalBox++;
        }
    }
}

void CHwxMB::SetContext()
{
    if (m_lastMaskSent != m_CurrentMask)
    {
        PostThreadMessage(m_pCHwxThreadMB->GetID(), THRDMSG_SETMASK,
                          (WPARAM) m_CurrentMask,
                         0);

        m_lastMaskSent = m_CurrentMask;
    }
    WCHAR wch = 0x0000;
    memset(m_Context, '\0', sizeof(m_Context));
    if ( S_OK == ((m_pInk->GetAppletPtr())->GetIImePad())->Request(m_pInk->GetAppletPtr(),IMEPADREQ_GETCOMPOSITIONSTRING,(WPARAM)m_Context,100) &&
         (wch = findLastContext()) )
    {
        if (m_lastCharSent != wch )
        {

            PostThreadMessage(m_pCHwxThreadMB->GetID(), THRDMSG_SETCONTEXT,
                             (WPARAM)wch,
                             0);

            m_lastCharSent = wch;
        }
    }
    else
    {
       if (m_lastCharSent != INVALID_CHAR)
       {
            PostThreadMessage(m_pCHwxThreadMB->GetID(), THRDMSG_SETCONTEXT,
                              (WPARAM) INVALID_CHAR,
                              0);

             m_lastCharSent = INVALID_CHAR;
       }
    }
}

void CHwxMB::DrawMBInkBox(HDC hdc, WORD iBox)
{
    RECT rc;
    HBRUSH hbr = ::CreateSolidBrush(::GetSysColor(COLOR_WINDOW));
    HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hbr);
    PatBlt(hdc,
          (m_boxSize * iBox) + Box_Border,
          Box_Border,
          m_boxSize-Box_Border*2,
          m_boxSize-Box_Border*2,
          PATCOPY);
    rc.left = (m_boxSize * iBox) + Box_Border;
    rc.top = Box_Border;
    rc.right = m_boxSize * (1 + iBox) - Box_Border;
    rc.bottom = m_boxSize - Box_Border;
    DrawEdge(hdc,&rc,EDGE_SUNKEN,BF_RECT);
    m_pInk->DrawHwxGuide(hdc,&rc);
    SelectObject(hdc, hbrOld);
    ::DeleteObject(hbr);
}

BOOL CHwxMB::HandleMouseEvent(HWND hwnd,UINT msg,WPARAM wp,LPARAM lp)
{
    POINT    pt;
    POINT ptTmp;
    int x,y;
    int iBox,len;
    
    //----------------------------------------------------------------
    //Satori #2763.
    //must cast (short) first.
    //pt.x = (unsigned short)LOWORD(lp);
    //pt.y = (unsigned short)HIWORD(lp);
    //----------------------------------------------------------------
    pt.x = (LONG)(short)LOWORD(lp);
    pt.y = (LONG)(short)HIWORD(lp);


#ifdef UNDER_CE // LBUTTON + ALT key handling
    //Standard way for RBUTTON handling is combination w/ LBUTTON + ALT key
    if(msg == WM_LBUTTONDOWN){
        if(GetAsyncKeyState(VK_MENU))
            msg = WM_RBUTTONDOWN;
    }
    else if(msg == WM_LBUTTONUP){
        if(GetAsyncKeyState(VK_MENU))
            msg = WM_RBUTTONUP;
    }
#endif // UNDER_CE
    switch (msg)
    {
        case WM_LBUTTONDBLCLK:
        case WM_LBUTTONDOWN:
        {
            // Pump up our thread priority by 1 level
            if ( !m_bDown && IsInInkBox(&pt) && !m_bResize )
            {
                if ( m_bRightClick )
                    return TRUE;
                if (!m_bHiPri)
                {
                    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);
                    m_bHiPri = TRUE;
                }

                if (m_bTimerStarted)
                {
                    KillTimer(hwnd, TIMER_ID);
                    m_bTimerStarted = FALSE;
                }

                SetCapture(hwnd);

                m_bDown = TRUE;

            // Now possibly sending the previous ink to the recognizer
            // and closing any open alt-lists.

               iBox = pt.x / m_boxSize;
               SetLogicalBox(iBox);
               m_bErase = FALSE;

            // Setup the clipRect and region for the DC if it's
            // not already set up.

                if (m_hdcMouse == NULL)
                {
                    m_hdcMouse = GetDC(hwnd);
                }

                if (iBox != m_curBox)
                {
                    m_clipRect.left = iBox*m_boxSize + Box_Border;
                    m_clipRect.top = Box_Border;
                    m_clipRect.right = m_clipRect.left +
                                           m_boxSize - 2*Box_Border;
                    m_clipRect.bottom = m_boxSize - Box_Border;

                    // adjust clip rectangle to have ink staying in the box
                    //990602:for KOTAE #818
                    m_clipRect.left += 2;
                    m_clipRect.top += 2;
                    m_clipRect.right -= 2;
                    m_clipRect.bottom -= 2;

#if 0 //OLD code
                    m_clipRect.left += 1;
                    m_clipRect.top += 1;
                    m_clipRect.right -= 1;
                    m_clipRect.bottom -= 1;
#endif
                }

                if (pt.x < m_clipRect.left)
                {
                    pt.x = m_clipRect.left;
                }
                else if (pt.x >= m_clipRect.right)
                {
                    pt.x = m_clipRect.right - 1;
                }

                if (pt.y < m_clipRect.top)
                {
                    pt.y = m_clipRect.top ;
                }
                else if (pt.y >= m_clipRect.bottom)
                {
                    pt.y = m_clipRect.bottom - 1;
                }

            // Get the offset to the window so we can convert the
            // screen points to window points without doing a call on each one.

                if ( m_pCHwxStroke->AddPoint(pt) )
                {
                    m_ptClient.x = m_ptClient.y = 0;
                    ScreenToClient(hwnd, &(m_ptClient));

                    // Save away the current and previous box info.

                    m_iBoxPrev = m_curBox;
                    m_curBox = (USHORT)iBox;

                    return TRUE;
                }
                else
                     return FALSE;
            }
            else if (IsPointInResizeBox(&pt))
            {
                if ( !m_bResize )
                {
                     SetCapture(hwnd);
                     m_bResize = TRUE;
                    m_firstX = pt.x;
                    ptTmp = pt;
                    ClientToScreen(hwnd,&ptTmp);
                    SetCursorPos(ptTmp.x,ptTmp.y);
                    if ( GetStrokeCount() )
                    {
                        HandleUserMessage(hwnd,MB_WM_ERASE,0,0);
                    }
                }
                return TRUE;
            }
            break;
        }

        case WM_LBUTTONUP:
        {
            if (m_bDown)
            {
                m_bDown = FALSE;
                x = (short)pt.x;
                y = (short)pt.y;

                if (x < m_clipRect.left)
                {
                    pt.x = m_clipRect.left;
                }
                else if (x >= m_clipRect.right)
                {
                    pt.x = m_clipRect.right - 1;
                }

                if (y < m_clipRect.top)
                {
                    pt.y = m_clipRect.top;
                }
                else if (y >= m_clipRect.bottom)
                {
                    pt.y = m_clipRect.bottom - 1;
                }
                m_pCHwxStroke->AddPoint(pt);

                ReleaseCapture();

                m_pCHwxStroke->AddBoxStroke(m_cLogicalBox-1,m_curBox,m_boxSize);

                if (m_bNoInk)
                {
                    m_bNoInk = FALSE;

                    //
                    // First Stroke in the box is done, set the context info now.
                    //

                    SetContext();
                }

                //
                // Send the Recognizer stroke off.
                //

                PSTROKE pstRecog = m_pCHwxStroke->CopyCurrentStroke();
                if ( pstRecog )
                    //----------------------------------------------------------------
                    //00/07/03: Hail pointed out.
                    //for Win64. (LPARAM) is better than LONG_PTR.
                    //LONG_PTR is not defined in VC6(only Platform SDK)
                    //----------------------------------------------------------------
                    PostThreadMessage(m_pCHwxThreadMB->GetID(),
                                      THRDMSG_ADDINK, 
                                      (WPARAM)m_boxSize,
                                      (LPARAM)pstRecog);
                //
                // Erase the old ink, we have a tiny slice of time before the next
                // stroke can begin.
                //

                if ((m_curBox != m_iBoxPrev) &&
                    (m_iBoxPrev != TOTALLOGICALBOX))
                {
                    DrawMBInkBox(m_hdcMouse, m_iBoxPrev);
                    m_iBoxPrev = TOTALLOGICALBOX;
                }

                //  Now start timer
                //
                //  If timeout value is 0, it means no timeout. Don't
                //  start timer
                if( m_timeoutValue )
                {
                    SetTimer(hwnd, TIMER_ID, m_timeoutValue, NULL);
                    m_bTimerStarted = TRUE;
                }

                return TRUE;
            }
            else if (IsPointInResizeBox(&pt))
            {
                if ( m_bResize )
                {
                    len = pt.x - m_firstX;
                    iBox = (m_firstX-4) / m_boxSize;
                    m_boxSize += (USHORT)len;
                    m_boxSize = (USHORT)(m_boxSize > INKBOXSIZE_MIN ? m_boxSize : INKBOXSIZE_MIN);
                    m_pInk->SetMBHeight(m_boxSize);
                    ptTmp.x = (iBox + 1) * m_boxSize;
                    ptTmp.y = pt.y;
                    ClientToScreen(hwnd,&ptTmp);
                    SetCursorPos(ptTmp.x,ptTmp.y);
                    m_firstX = (iBox+1) * m_boxSize;
                    m_pInk->ChangeIMEPADSize(FALSE);
                     m_pInk->ChangeLayout(FALSE);
                       ReleaseCapture();
                     m_bResize = FALSE;
                    UpdateWindow(GetParent(m_pInk->GetInkWindow()));
                    UpdateWindow(m_pInk->GetInkWindow());
                    return TRUE;
                }
            }
            else 
            {
                if ( m_bResize )
                {
                    if ( hwnd == GetCapture() )
                        ReleaseCapture();
                    m_hCursor = LoadCursor(NULL,IDC_ARROW);
                    SetCursor(m_hCursor);
                     m_bResize = FALSE;
                }
            }
            break;
        }

        case WM_MOUSEMOVE:
            {
                //char szbuf[256];
                //wsprintf(szbuf, "WM_MOUSEMOVE pt.x [%d] pt.y[%d]\n", pt.x, pt.y);
                //OutputDebugString(szbuf);
            }
            if (m_bDown && !m_bResize)
            {
                //UINT     cbPt = 1;
                x = (short)pt.x;
                y = (short)pt.y;                
                if ( x < m_clipRect.left)
                {
                    pt.x = m_clipRect.left;
                }
                else if ( x >= m_clipRect.right )
                {
                    pt.x = m_clipRect.right - 1;
                }

                if ( y < m_clipRect.top )
                {
                    pt.y = m_clipRect.top;
                }
                else if ( y >= m_clipRect.bottom )
                {
                    pt.y = m_clipRect.bottom - 1;
                }
                if ( m_pCHwxStroke->AddPoint(pt) )
                {
                     m_pCHwxStroke->DrawStroke(m_hdcMouse,2,FALSE);
                }
                return TRUE;
            }
            else if ( hwnd == GetCapture() || IsPointInResizeBox(&pt))
            {
                //990602:KOTAE #245. 
                //If mouse move is too fast, back ground is NOT repainted.
                //So, This is little bit hack but work well.
                //This sleep change context switch and remove too much WM_MOUSEMOVE message.
#if 1
                static DWORD g_dwTick;
                DWORD dwTick = ::GetTickCount();
                if(dwTick - g_dwTick < 20) {
                    return  TRUE;
                }
                g_dwTick = dwTick;
#endif

                 HCURSOR hCur = LoadCursor(NULL,IDC_SIZEWE);
#ifndef UNDER_CE // CE specific
                m_hCursor = SetCursor(hCur);
#else // UNDER_CE
                SetCursor(hCur);
#endif // UNDER_CE
                if ( m_bResize )
                {
                    Dbg(("Resizing Multibox \n"));
                    //990621:KOTAE #1229
                    pt.x = (short)pt.x;
                    if(pt.x < 0) {
                        return TRUE;
                    }

                    iBox = (m_firstX-4) / m_boxSize;
                    len = pt.x - m_firstX;
                    
                    m_boxSize += (USHORT)len;

                    Dbg(("=>new m_boxSize %d\n", m_boxSize));
                    //wsprintf(szbuf, "new m_boxSize [%d]\n", m_boxSize);
                    //OutputDebugString(szbuf);
                    //----------------------------------------------------------------
                    //980821:ToshiaKCheck max size of m_boxSize,
                    //To prevent resize boxsize inifinitly.
                    //----------------------------------------------------------------
                    INT cxScreen = ::GetSystemMetrics(SM_CXFULLSCREEN)/2;
                    INT cyScreen = ::GetSystemMetrics(SM_CYFULLSCREEN)/2;
                    if(m_boxSize >= INKBOXSIZE_MIN) {
                        if(m_boxSize >= cxScreen || m_boxSize >= cyScreen) {
                            m_boxSize = (USHORT)(cxScreen < cyScreen ? cxScreen : cyScreen);
                        }
                    }
                    else {
                        m_boxSize = INKBOXSIZE_MIN;
                    }
                    //----------------------------------------------------------------
                    //Old code
                    //----------------------------------------------------------------
                    //m_boxSize = m_boxSize > INKBOXSIZE_MIN ? m_boxSize : INKBOXSIZE_MIN ;
                    m_pInk->SetMBHeight( m_boxSize );
                    ptTmp.x = (iBox+1) * m_boxSize;
                    ptTmp.y = pt.y;
                    ClientToScreen(hwnd,&ptTmp);
                    SetCursorPos(ptTmp.x,ptTmp.y);
                    m_pInk->ChangeIMEPADSize(FALSE);
                     m_pInk->ChangeLayout(FALSE);
                    UpdateWindow(GetParent(m_pInk->GetInkWindow()));
                    UpdateWindow(m_pInk->GetInkWindow());
                    //990602:KOTAE #245.
                    ::InvalidateRect(m_pInk->GetInkWindow(), NULL, TRUE);
                    m_firstX = (iBox+1) * m_boxSize;
                }
                return TRUE;
            }
            else
            {
                if ( !m_bResize )
                {
                    m_hCursor = LoadCursor(NULL,IDC_ARROW);    // SATORI #164                
                    SetCursor(m_hCursor);
                }
                return TRUE;
            }
            break;
        case WM_RBUTTONDOWN:
            {
                 if ( IsInInkBox(&pt) )
                {
                     m_bRightClick = TRUE;
                    return TRUE;
                }
            }
            break;
        case WM_RBUTTONUP:
            {
                // 980408:kwada - IME98A #304 
                // No popup menu when left button is down.
                if(m_bDown) {
                    m_bRightClick = FALSE;
                    break;
                }

                 if ( IsInInkBox(&pt) )
                {
                    HMENU hMenu;
                    HMENU hMenuTrackPopup;
                    //----------------------------------------------------------------
                    //fixed MSKK #5035.Need to load specified language's menu resource
                    //BUGBUG::hMenu = LoadMenu (m_hInstance, MAKEINTRESOURCE(IDR_MB));
                    //----------------------------------------------------------------
                    hMenu = CHwxFE::GetMenu(m_hInstance, MAKEINTRESOURCE(IDR_MB));
                    if (!hMenu)
                    {
                         m_bRightClick = FALSE;
                        return FALSE;
                    }
                    hMenuTrackPopup = GetSubMenu (hMenu, 0);
                    ClientToScreen(m_hMBWnd,&pt);
#ifndef UNDER_CE // Windows CE does not support TPM_LEFTBUTTON on TrackPopupMenu
                    TrackPopupMenu (hMenuTrackPopup, TPM_LEFTALIGN | TPM_LEFTBUTTON, pt.x, pt.y, 0,m_hMBWnd, NULL);
#else // UNDER_CE
                    TrackPopupMenu (hMenuTrackPopup, TPM_LEFTALIGN, pt.x, pt.y, 0,m_hMBWnd, NULL);
#endif // UNDER_CE
                    DestroyMenu (hMenu);
                     m_bRightClick = FALSE;
                    return TRUE;
                }
            }
            break;
        default:
            break;
    }
    return FALSE;
    Unref(wp);
}


LRESULT CHwxMB::HandleUserMessage(HWND hwnd, UINT iMsg,WPARAM wp,LPARAM lp)
{
    LRESULT lRet = 0;

    switch (iMsg)
    {
        //
        // We sometimes don't get a WM_LBUTTONUP message due to the system
        // design.  We need to simulate one here if we think we are in a
        // down state or risk flaky behaviour.  The hwxpad assumes we will
        // get one and may leak resources if we don't.
        //
        case MB_WM_ERASE:
        case MB_WM_DETERMINE:
        {
            //
            // In either case, do the recognition, for erase then send a
            // backspace key through.
            //

            if (m_cLogicalBox)
            {
                // TOTALLOGICALBOX represents invalid box number, force it to recognize
                // the ink in the current box.

                if (m_hdcMouse == NULL)
                {
                    m_hdcMouse = GetDC(hwnd);
                }

                DrawMBInkBox(m_hdcMouse, m_curBox);
                SetLogicalBox(TOTALLOGICALBOX);
                lRet = 1;
                    
                m_bErase = FALSE;
                if (iMsg == MB_WM_ERASE)
                {
                    //
                    // Send a backspace key in to erase the last garbage character.
                    //
                      // PostThreadMessage(m_pCHwxThreadMB->GetID(), THRDMSG_CHAR, VK_BACK, 0);
                    m_bErase = TRUE;
                }
            }
            m_bNoInk = TRUE;  // We have no more ink for sure now.

                    //
                    // In either case erase/time-out/recog-button we no longer have
                    // a current box, or a need for a DC or a need to be HighPriority.
                    //

            if (m_hdcMouse)
            {
                ReleaseDC(hwnd, m_hdcMouse);
                m_hdcMouse = NULL;
            }

            m_curBox = TOTALLOGICALBOX;  // There's no more ink, init state again.

            if (m_bHiPri)
            {
                SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL);
                m_bHiPri = FALSE;
            }
            break;
        }
        case MB_WM_COPYINK:
            m_pInk->CopyInkFromMBToCAC(* m_pCHwxStroke,m_clipRect.left-Box_Border,0);
            break;
        case MB_WM_HWXCHAR:
        {
            HWXRESULTPRI   * pResult = (HWXRESULTPRI *)wp;
            HWXRESULTPRI   * pPrev = pResult;
            while ( pResult )
            {
                if ( m_bErase && NULL == pResult->pNext )
                {
                    // delete the last node
                    MemFree((void *)pResult);
                    break;
                }
                if ( pResult->cbCount )
                {
#ifndef FE_JAPANESE
                    for ( short i = 0; i < pResult->cbCount; i++)
                    {
                        m_StringCandidate[i][0] = pResult->chCandidate[i];
                        m_StringCandidate[i][1] = 0x0000;
                         m_pImeStringCandidate->lpwstr[i] = m_StringCandidate[i];
                    }
                    m_pImeStringCandidate->uCount = pResult->cbCount;
                    (m_pInk->GetAppletPtr())->SendHwxStringCandidate(m_pImeStringCandidate);
#else
                    DWORD dwFarEastid;
                    LPIMEFAREASTINFO lpFarEastInfo = NULL;

                    if (FGetFarEastInfo( pResult, &dwFarEastid, &lpFarEastInfo ))
                    {
                        for ( short i = 0; i < pResult->cbCount; i++)
                        {
                            m_StringCandidate[i][0] = pResult->chCandidate[i];
                            m_StringCandidate[i][1] = 0x0000;
                             m_pImeStringCandidateInfo->lpwstr[i] = m_StringCandidate[i];
                        }
                        m_pImeStringCandidateInfo->dwFarEastId        = dwFarEastid;
                        m_pImeStringCandidateInfo->lpFarEastInfo    = lpFarEastInfo;
                        m_pImeStringCandidateInfo->fInfoMask        = INFOMASK_NONE;
                        m_pImeStringCandidateInfo->iSelIndex        = 0;
                        m_pImeStringCandidateInfo->uCount            = pResult->cbCount;
                    
                        (m_pInk->GetAppletPtr())->SendHwxStringCandidateInfo(m_pImeStringCandidateInfo);

                        if (lpFarEastInfo)
                            MemFree(lpFarEastInfo);
                    }
                    else
                    {
                        for ( short i = 0; i < pResult->cbCount; i++)
                        {
                            m_StringCandidate[i][0] = pResult->chCandidate[i];
                            m_StringCandidate[i][1] = 0x0000;
                             m_pImeStringCandidate->lpwstr[i] = m_StringCandidate[i];
                        }
                        m_pImeStringCandidate->uCount = pResult->cbCount;
                        (m_pInk->GetAppletPtr())->SendHwxStringCandidate(m_pImeStringCandidate);
                    }
#endif
                }
                pResult = pResult->pNext;
                pPrev->pNext = NULL;
                MemFree((void *)pPrev);
                pPrev = pResult;
            }
            break;
        }
//        case MB_WM_COMCHAR:
//            ((m_pInk->GetAppletPtr())->GetIImePad())->Request(m_pInk->GetAppletPtr(),IMEPADREQ_SENDCONTROL,IMEPADCTRL_CARETBACKSPACE,0);
//            break;
        default:
             break;
    }
    return lRet;
    Unref(lp);
}

LRESULT    CHwxMB::HandleCommand(HWND hwnd,UINT msg,WPARAM wp,LPARAM lp)
{
     UINT uCode =(UINT)LOWORD(wp);
    switch ( uCode )
    {
        case IDM_MBRECOG:
            return HandleUserMessage(hwnd,MB_WM_DETERMINE,0,0);
        case IDM_MBDELETE:
            return HandleUserMessage(hwnd,MB_WM_ERASE,0,0);
        case IDM_MBPROP:
        // This is a hack fix. I think we should use Request().
        //((m_pInk->GetAppletPtr())->GetIImePad())->Request(m_pInk->GetAppletPtr(),
        //        IMEPADREQ_CONFIGSELF,0,0);
        //    IDM_CONFIGAPPLET == 0x7009
            if(m_pInk &&
               m_pInk->GetAppletPtr() &&
               m_pInk->GetAppletPtr()->GetIImePad()) {
                ((m_pInk->GetAppletPtr())->GetIImePad())->Request(m_pInk->GetAppletPtr(),
                                                                  IMEPADREQ_POSTMODALNOTIFY,
                                                                  IMEPN_CONFIG,
                                                                  0);
            }
            //PostMessage(GetParent(GetParent(hwnd)), WM_COMMAND,0x7009,NULL);
            return 0;
        default:
            break;
    }
    return DefWindowProc(hwnd, msg, wp, lp);
}

//----------------------------------------------------------------
//990618:ToshiaK for KOTAE #1329
//----------------------------------------------------------------
void
CHwxMB::OnSettingChange(UINT msg, WPARAM wp,LPARAM lp)
{
#ifndef UNDER_CE // Unsupported.
    if(wp == SPI_SETNONCLIENTMETRICS) {
        if(m_pCHwxStroke) {
            m_pCHwxStroke->ResetPen();
        }
    }
#else // UNDER_CE
    if(m_pCHwxStroke) {
        m_pCHwxStroke->ResetPen();
    }
#endif // UNDER_CE
    UNREFERENCED_PARAMETER(msg);
    UNREFERENCED_PARAMETER(lp);
}


void CHwxMB::SetBoxSize(WORD w)
{
    m_boxSize = w;
}

WCHAR CHwxMB::findLastContext()
{
    WCHAR prev,curr;
    prev = curr = 0x0000;
    for(int i = 0; i < sizeof(m_Context)/sizeof(WCHAR); i++)
    {
        if ( curr = m_Context[i] )
        {
             prev = curr;
        }
        else
        {
            return prev;
        }
    }
    return prev;
}



#ifdef FE_JAPANESE
// for character comment
#include "..\..\imeknl\iconvert\chcomnt.h"

BOOL FGetFarEastInfo(HWXRESULTPRI *pResult, DWORD *pdwID, LPIMEFAREASTINFO *ppInfo)
{
    // count char number
    INT i;
    INT len;
    WCHAR *wszComment;
    for ( i = len = 0; i < pResult->cbCount; i++)
    {
        wszComment = WSZGetCharComment(pResult->chCandidate[i], COMMENTCLIENT_HW);
        if (wszComment)
            len += lstrlenW(wszComment);
        
        len++;    // for NULL
    }

    
    if ((*ppInfo = (LPIMEFAREASTINFO)MemAlloc(sizeof(IMEFAREASTINFO)+len*sizeof(WCHAR)))==NULL)
        return FALSE;
    
    *pdwID = FEID_JAPANESE;
    
    (*ppInfo)->dwSize = sizeof(IMEFAREASTINFO)+len*sizeof(WCHAR);
    (*ppInfo)->dwType = IMEFAREASTINFO_TYPE_COMMENT;

    INT ip;
    WCHAR *wszBuf;

    ip = 0;
    wszBuf = (WCHAR*)((*ppInfo)->dwData);

    for ( i = 0; i < pResult->cbCount; i++)
    {
        wszComment = WSZGetCharComment(pResult->chCandidate[i], COMMENTCLIENT_HW);
        if (wszComment)
        {
            memcpy( wszBuf+ip, wszComment, (lstrlenW(wszComment)+1)*sizeof(WCHAR));
            ip += lstrlenW(wszComment)+1;
        }
        else
        {
            wszBuf[ip++] = 0;
        }
    }
    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxobj.cpp ===
#include "hwxobj.h"
#include "memmgr.h"
#ifdef UNDER_CE // Windows CE Stub for unsupported APIs
#include "stub_ce.h"
#endif // UNDER_CE

// implementation of CHwxObject

HINSTANCE CHwxObject::m_hInstance = NULL;
void * CHwxObject::operator new(size_t size)
{
    return MemAlloc(size);
}
 
void CHwxObject::operator delete(void * pv)
{
    if(pv) 
    {
        MemFree(pv);
    }
}

CHwxObject::CHwxObject(HINSTANCE hInstance)
{
    m_nLen = 0;
    m_pClassName[m_nLen] = (TCHAR)'\0';
    if ( !m_hInstance )
        m_hInstance = hInstance;
}

CHwxObject::~CHwxObject()
{
    if ( m_nLen && m_pClassName )
    {
        m_nLen = 0;
        m_pClassName[m_nLen] = (TCHAR)'\0';
    }
}

BOOL CHwxObject::Initialize(TCHAR * pClsName)
{
    BOOL bRet = TRUE;
    if ( pClsName )
    {
#ifndef UNDER_CE
        //990617:ToshiaK. This below code is wired...
        lstrcpyn(m_pClassName, pClsName, 16);
        m_nLen = lstrlen(m_pClassName);
#if 0
        m_nLen = strlen(pClsName);    // must be less than 16
        m_nLen = m_nLen > 16 ? 16 : m_nLen;
        pClsName[m_nLen] = (TCHAR)'\0'; 
        strcpy(m_pClassName,pClsName);
#endif
#else // UNDER_CE
        int cnsize = sizeof m_pClassName/sizeof m_pClassName[0];
        _tcsncpy(m_pClassName, pClsName, cnsize);
        m_pClassName[cnsize-1] = TEXT('\0');
        m_nLen = lstrlen(m_pClassName);
#endif // UNDER_CE

//        m_pClassName =(TCHAR *) new TCHAR[m_nLen + 1];
//        if ( m_pClassName )
//        {
//            strcpy(m_pClassName,pClsName);
//        }
//        else
//            bRet = FALSE;
    }
    else
    {
        m_nLen = 0;
        m_pClassName[m_nLen] = (TCHAR)'\0';
    }
    return bRet;
}

static POSVERSIONINFO GetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

BOOL IsWin95(VOID) 
{ 
    BOOL fBool;
    fBool = (GetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
            (GetOSVersion()->dwMajorVersion >= 4) &&
            (GetOSVersion()->dwMinorVersion < 10);

    return fBool;
}

BOOL IsWin98(VOID)
{
    BOOL fBool;
    fBool = (GetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
            (GetOSVersion()->dwMajorVersion >= 4) &&
            (GetOSVersion()->dwMinorVersion  >= 10);
    return fBool;
}


BOOL IsWinNT4(VOID)
{
    BOOL fBool;
    fBool = (GetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (GetOSVersion()->dwMajorVersion == 4);
    return fBool;
}

BOOL IsWinNT5(VOID)
{
    BOOL fBool;
    fBool = (GetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (GetOSVersion()->dwMajorVersion == 5);
    return fBool;
}

BOOL IsWinNT5orUpper()
{ 
    static BOOL fFirstCallNT5 = TRUE;
    static BOOL fNT5 = FALSE;

    if (fFirstCallNT5 == FALSE)
        return fNT5;

    fFirstCallNT5 = FALSE;
    fNT5 = (GetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (GetOSVersion()->dwMajorVersion >= 5);

    return fNT5;
}

BOOL IsWinNT(VOID)
{
    return (BOOL)(GetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxstr.cpp ===
#include "hwxobj.h"
#include "memmgr.h"
#include "cmnhdr.h"
#ifdef UNDER_CE // Windows CE Stub for unsupported APIs
#include "stub_ce.h"
#endif // UNDER_CE

// implementation of CHwxStroke class

CHwxStroke::CHwxStroke(BOOL bForward,long lSize = 32):CHwxObject(NULL)
{
    m_bForward = bForward;
    m_nSize = lSize;
    m_pStroke = NULL;
    m_pCurStroke = NULL;
    m_nStroke = 0;
    m_ppt = NULL;
    m_cpt = 0;
    m_max = 0;
    m_hPen = NULL;
}

CHwxStroke::~CHwxStroke()
{
     if ( m_ppt )
    {
//         delete [] m_ppt;
         MemFree((void *)m_ppt);
        m_ppt = NULL;
        m_cpt = 0;
        m_max = 0;
    }
    DeleteAllStroke();
    if ( m_hPen )
    {
         DeleteObject(m_hPen);
        m_hPen = NULL;
    }
}

BOOL CHwxStroke::Initialize(TCHAR * pClsName)
{
     BOOL bRet = CHwxObject::Initialize(pClsName);
    if ( bRet )
    {
         m_hPen = CreatePen(PS_SOLID,3,GetSysColor(COLOR_WINDOWTEXT));
        if ( !m_hPen )
            bRet = FALSE;
    }
    return bRet;
}

BOOL
CHwxStroke::ResetPen(VOID)
{
    if(m_hPen) {
        ::DeleteObject(m_hPen);
         m_hPen = ::CreatePen(PS_SOLID,3,GetSysColor(COLOR_WINDOWTEXT));
    }
    return TRUE;
}

BOOL CHwxStroke::AddPoint(POINT pt)
{
    if ( m_cpt >= m_max )
    {
         if ( !growPointBuffer() )
        {
             return FALSE;
        }
    }
    m_ppt[m_cpt++] = pt;    
    return TRUE;        
}

BOOL CHwxStroke::AddBoxStroke(int nLogBox,int nCurBox, int nBoxHeight)
{
//    PSTROKE pst = (PSTROKE) new BYTE[sizeof(STROKE) + m_cpt * sizeof(POINT)];
    PSTROKE pst = (PSTROKE)MemAlloc(sizeof(STROKE) + m_cpt * sizeof(POINT));

    if (!pst)
        return FALSE;

    pst->cpt   = m_cpt;
    pst->iBox  = nLogBox;   
    pst->xLeft = nCurBox * nBoxHeight;
    pst->pNext = NULL;

    memcpy(pst->apt, m_ppt, m_cpt*sizeof(POINT));
    m_cpt = 0;

    if ( m_bForward )
    {
        pst->pNext = m_pStroke;
        m_pStroke = pst;
    }
    else
    {
        PSTROKE pstrPrev = m_pStroke;
        if (pstrPrev == (PSTROKE) NULL)
            m_pStroke = pst;
        else
        {
            while (pstrPrev->pNext != (PSTROKE) NULL)
                pstrPrev = pstrPrev->pNext;

            pstrPrev->pNext = pst;
        }
    }
    m_pCurStroke = pst;
    m_nStroke++;
    return TRUE;
}

void CHwxStroke::EraseCurrentStroke()
{
    PSTROKE pstrPrev = (PSTROKE) NULL;
    PSTROKE pstr = m_pStroke;

    if ( !pstr )
        return;
    if ( m_bForward )
    {
        // delete at the beginning of the list
        m_pStroke = pstr->pNext;
        pstr->pNext = (PSTROKE)NULL;
        m_pCurStroke = m_pStroke;
    }
    else
    {
        // delete at the end of the list
        while (pstr->pNext)
        {
            pstrPrev = pstr;
            pstr = pstr->pNext;
        }
        if (pstrPrev == (PSTROKE) NULL)
            m_pStroke = (PSTROKE) NULL;
        else
            pstrPrev->pNext = (PSTROKE) NULL;
        m_pCurStroke = pstrPrev;
    }
//    delete [] pstr;
    MemFree((void *)pstr);
    m_nStroke--;
}
 
void CHwxStroke::DeleteAllStroke()
{
    PSTROKE pstr = m_pStroke;
    PSTROKE ptmp;

    m_pStroke = m_pCurStroke = (PSTROKE) NULL;
    m_nStroke = 0;
    while( pstr )
    {
        ptmp = pstr->pNext;
        pstr->pNext = (PSTROKE) NULL;
//        delete [] pstr;
        MemFree((void *)pstr);
        pstr = ptmp;
    }
}

void CHwxStroke::DrawStroke(HDC hdc,int nPts,BOOL bEntire)
{
#ifdef UNDER_CE // does not support SPI_SETNONCLIENTMETRICS on WM_SETTINGCHANGE
    if(bEntire){
        ResetPen();
    }
#endif // UNDER_CE
    PSTROKE pstr;
    HPEN hOldPen = (HPEN)SelectObject(hdc,m_hPen);
    if ( bEntire )
    {
        pstr = m_pStroke;
        while (pstr)
        {
            Polyline(hdc, pstr->apt, pstr->cpt);
            pstr = pstr->pNext;
        }
     }
     else
     {
        if ( nPts == -2 )         // draw the current stroke just added
        {
            if ( m_pCurStroke )
                Polyline(hdc, m_pCurStroke->apt, m_pCurStroke->cpt);
        }
        else if ( nPts == -1 )     // draw the entire point buffer
        {
            if ( m_ppt )
                Polyline(hdc, m_ppt, m_cpt);
        }
        else
        {                        // draw the partial of the point buffer
            if ( m_ppt &&  nPts < m_cpt )
                Polyline(hdc,&m_ppt[m_cpt-nPts],nPts);
        }
     }
    SelectObject(hdc,hOldPen);
}
 
void CHwxStroke::GetUpdateRect(RECT * prc)
{
     if ( prc && m_ppt )
    {
        RECT rc;
        int x,y;
        if (m_cpt < 2)
            x = 0, y = 0;
        else
            x = m_cpt - 2, y = m_cpt - 1;

        if (m_ppt[x].x < m_ppt[y].x)
            rc.left = m_ppt[x].x, rc.right = m_ppt[y].x;
        else
            rc.left = m_ppt[y].x, rc.right = m_ppt[x].x;

        if (m_ppt[x].y < m_ppt[y].y)
            rc.top = m_ppt[x].y, rc.bottom = m_ppt[y].y;
        else
            rc.top = m_ppt[y].y, rc.bottom = m_ppt[x].y;

        rc.left   -= 1;
        rc.top    -= 1;
        rc.right  += 1;
        rc.bottom += 1;
        *prc = rc;
    }
}

PSTROKE CHwxStroke::CopyCurrentStroke()
{
     if ( !m_pCurStroke )
        return NULL;
//    PSTROKE pst = (PSTROKE) new BYTE[sizeof(STROKE) + m_pCurStroke->cpt * sizeof(POINT)];
    PSTROKE pst = (PSTROKE)MemAlloc(sizeof(STROKE) + m_pCurStroke->cpt * sizeof(POINT));
    if ( !pst )
        return NULL;
    pst->cpt   = m_pCurStroke->cpt;
    pst->iBox  = m_pCurStroke->iBox;
    pst->xLeft = m_pCurStroke->xLeft;

    memcpy(pst->apt, m_pCurStroke->apt, m_pCurStroke->cpt*sizeof(POINT));
    pst->pNext = NULL;
    return pst;
}

// This function is used to copy ink from MB to CAC.
// Their stroke orders are different.

CHwxStroke & CHwxStroke::operator=(CHwxStroke & stroke)
{
//    if ( *this != stroke )
//    {
        this->DeleteAllStroke();         
        this->resetPointBuffer();
        if ( m_pStroke = stroke.dupStroke() )
        {
            if ( m_bForward )
            {
                 m_pCurStroke = m_pStroke;
            }
            else
            {
                  PSTROKE pst = m_pStroke;
                while ( pst->pNext )
                    pst = pst->pNext;
                m_pCurStroke = pst;
            }
            m_nStroke = stroke.GetNumStrokes();
        }
        else
        {
            m_pCurStroke = (PSTROKE)NULL;
            m_nStroke = 0;
        }
//    }
    return *this;    
}

BOOL CHwxStroke::growPointBuffer()
{

//    POINT  *ppnt = (POINT *) new BYTE[sizeof(POINT) * (m_nSize + m_max)];
    POINT  *ppnt = (POINT *)MemAlloc(sizeof(POINT) * (m_nSize + m_max));
    if (ppnt == (POINT *) NULL)
        return FALSE;

    if (m_ppt != (POINT *) NULL)
    {
        memcpy(ppnt, m_ppt, m_max * sizeof(POINT));
//        delete [] m_ppt;
        MemFree((void *)m_ppt);
    }
    m_ppt = ppnt;
    m_max += m_nSize;
    return TRUE;
}

void CHwxStroke::resetPointBuffer()
{
    if ( m_max && m_ppt )
        memset(m_ppt, '\0', m_max * sizeof(POINT));
     m_cpt = 0;
}


// This function copies the ink in reverse order
// and only supports the transition from MB to CAC.
PSTROKE CHwxStroke::dupStroke()
{
    PSTROKE pstr = (PSTROKE)NULL;
    PSTROKE pstrHead = (PSTROKE)NULL;
    PSTROKE pCurr;
    if ( m_pStroke )
    {
        pCurr = m_pStroke; 
        while (pCurr)
        {
//            if ((pstr = (PSTROKE) new BYTE[sizeof(STROKE) + pCurr->cpt * sizeof(POINT)]) == (PSTROKE) NULL)
            if ((pstr = (PSTROKE)MemAlloc(sizeof(STROKE) + pCurr->cpt * sizeof(POINT))) == (PSTROKE) NULL)
            {    
                break;
            }
            pstr->pNext = (STROKE *) NULL;
            pstr->cpt = pCurr->cpt;
            pstr->iBox = pCurr->iBox;
            pstr->xLeft = pCurr->xLeft;
            memcpy(pstr->apt, pCurr->apt, pCurr->cpt * sizeof(POINT));
            pstr->pNext = pstrHead;
            pstrHead = pstr;
            pCurr = pCurr->pNext;
        }
    }    
    return pstrHead;
}

// This function adjusts points relative to the box 
// when copying ink from MB to CAC.
void CHwxStroke::ScaleInkXY(long x,long y)
{
     if ( m_pStroke )
    {
        PSTROKE pCurr;
        int i;
        pCurr = m_pStroke;
        
         if ( x )
        {
            while (pCurr)
            {
                 for( i = 0; i < pCurr->cpt; i++ )
                {
                     pCurr->apt[i].x -= x;
                }
                pCurr = pCurr->pNext;
            }
        }
        if ( y )
        {
            pCurr = m_pStroke;
            while (pCurr)
            {
                 for( i = 0; i < pCurr->cpt; i++ )
                {
                     pCurr->apt[i].y -= y;
                }
                pCurr = pCurr->pNext;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\immsec.h ===
#if !defined (_IMMSEC_H__INCLUDED_)
#define _IMMSEC_H__INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif
PSECURITY_ATTRIBUTES CreateSecurityAttributes(VOID);
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa);
BOOL IsNT(VOID);
PSECURITY_ATTRIBUTES GetIMESecurityAttributes(VOID);
PSECURITY_ATTRIBUTES GetIMESecurityAttributesEx(VOID);
VOID FreeIMESecurityAttributes(VOID);
PSECURITY_ATTRIBUTES CreateSecurityAttributesEx(VOID);
PSID MyCreateSidEx(VOID);
#ifdef __cplusplus
}
#endif

#endif // !_IMMSEC_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\hwxthd.cpp ===
#include "hwxobj.h"
#include "memmgr.h"
#include "hwxfe.h"    //980803:ToshiaK
#include "dbg.h"
#include "cmnhdr.h"
#ifdef UNDER_CE // Windows CE Stub for unsupported APIs
#include "stub_ce.h"
#endif // UNDER_CE

// implementation of CHwxThread, CHwxThreadMB, and CHwxThreadCAC

//----------------------------------------------------------------
//971217:ToshiaK: comment outed. changed to m_hHwxjpn as non static 
//----------------------------------------------------------------
//HINSTANCE CHwxThread::m_hHwxjpn = NULL;

PHWXCONFIG CHwxThread::lpHwxConfig = NULL;
PHWXCREATE CHwxThread::lpHwxCreate = NULL;
PHWXSETCONTEXT CHwxThread::lpHwxSetContext = NULL;
PHWXSETGUIDE CHwxThread::lpHwxSetGuide = NULL;
PHWXALCVALID CHwxThread::lpHwxAlcValid = NULL;
PHWXSETPARTIAL CHwxThread::lpHwxSetPartial = NULL;
PHWXSETABORT CHwxThread::lpHwxSetAbort = NULL;
PHWXINPUT CHwxThread::lpHwxInput = NULL;
PHWXENDINPUT CHwxThread::lpHwxEndInput = NULL;
PHWXPROCESS CHwxThread::lpHwxProcess = NULL;
PHWXRESULTSAVAILABLE CHwxThread::lpHwxResultsAvailable = NULL;
PHWXGETRESULTS CHwxThread::lpHwxGetResults = NULL;
PHWXDESTROY CHwxThread::lpHwxDestroy = NULL;


CHwxThread::CHwxThread():CHwxObject(NULL)
{
    m_thrdID = 0 ;    
    m_hThread = NULL ;
    m_thrdArg = HWX_PARTIAL_ALL;
    m_hStopEvent = NULL;
    //----------------------------------------------------------------
    //971217:ToshiaK changed m_hHwxjpn to non static data.
    //so, Initialize it in Constructor.
    //----------------------------------------------------------------
    m_hHwxjpn    = NULL; 
}

CHwxThread::~CHwxThread()
{
    Dbg(("CHwxThread::~CHwxThread START\n"));
//    if ( IsThreadStarted() )
//    {
        //----------------------------------------------------------------
        //970729: ToshiaK temporary, comment out.
        //----------------------------------------------------------------
//         StopThread();
//    }
    if ( m_hHwxjpn )
    {
        // decreament library ref count until it is equal to zero
           FreeLibrary(m_hHwxjpn);
        m_hHwxjpn = NULL;
    }
    if (m_hStopEvent)
    {
        CloseHandle(m_hStopEvent);
        m_hStopEvent = NULL;
    }
}


BOOL CHwxThread::Initialize(TCHAR * pClsName)
{
     BOOL bRet = CHwxObject::Initialize(pClsName);
    if ( bRet )
    {
        TCHAR tchPath[MAX_PATH];
        //TCHAR tchMod[32];
        //----------------------------------------------------------------
        //980803:ToshiaK. Fareast merge.
        //----------------------------------------------------------------
        CHwxFE::GetRecognizerFileName(m_hInstance,
                                      tchPath,
                                      sizeof(tchPath)/sizeof(tchPath[0]));
        //OutputDebugString("hwxthd\n");
        //OutputDebugString(tchPath);
        //OutputDebugString("\n");
        //lstrcat(tchPath, tchMod);
        if ( !m_hHwxjpn )
        {    
            // first time load
            //OutputDebugString(tchPath);
            m_hHwxjpn = LoadLibrary(tchPath);
                //m_hHwxjpn = LoadLibrary(TEXT("hwxjpn.dll"));
            if ( m_hHwxjpn )
            {
                // get HwxXXXXX() API address from hwxjpn.dll
#ifndef UNDER_CE
                lpHwxConfig =(PHWXCONFIG)GetProcAddress(m_hHwxjpn,"HwxConfig");
                lpHwxCreate= (PHWXCREATE)GetProcAddress(m_hHwxjpn,"HwxCreate");
                lpHwxSetContext= (PHWXSETCONTEXT)GetProcAddress(m_hHwxjpn,"HwxSetContext");
                lpHwxSetGuide= (PHWXSETGUIDE)GetProcAddress(m_hHwxjpn,"HwxSetGuide");
                lpHwxAlcValid= (PHWXALCVALID)GetProcAddress(m_hHwxjpn,"HwxALCValid");
                 lpHwxSetPartial= (PHWXSETPARTIAL)GetProcAddress(m_hHwxjpn,"HwxSetPartial");
                lpHwxSetAbort= (PHWXSETABORT)GetProcAddress(m_hHwxjpn,"HwxSetAbort");
                lpHwxInput= (PHWXINPUT)GetProcAddress(m_hHwxjpn,"HwxInput");
                lpHwxEndInput= (PHWXENDINPUT)GetProcAddress(m_hHwxjpn,"HwxEndInput");
                lpHwxProcess= (PHWXPROCESS)GetProcAddress(m_hHwxjpn,"HwxProcess");
                lpHwxResultsAvailable= (PHWXRESULTSAVAILABLE)GetProcAddress(m_hHwxjpn,"HwxResultsAvailable");
                lpHwxGetResults= (PHWXGETRESULTS)GetProcAddress(m_hHwxjpn,"HwxGetResults");
                lpHwxDestroy= (PHWXDESTROY)GetProcAddress(m_hHwxjpn,"HwxDestroy");
#else // UNDER_CE
                lpHwxConfig =(PHWXCONFIG)GetProcAddress(m_hHwxjpn,TEXT("HwxConfig"));
                lpHwxCreate= (PHWXCREATE)GetProcAddress(m_hHwxjpn,TEXT("HwxCreate"));
                lpHwxSetContext= (PHWXSETCONTEXT)GetProcAddress(m_hHwxjpn,TEXT("HwxSetContext"));
                lpHwxSetGuide= (PHWXSETGUIDE)GetProcAddress(m_hHwxjpn,TEXT("HwxSetGuide"));
                lpHwxAlcValid= (PHWXALCVALID)GetProcAddress(m_hHwxjpn,TEXT("HwxALCValid"));
                 lpHwxSetPartial= (PHWXSETPARTIAL)GetProcAddress(m_hHwxjpn,TEXT("HwxSetPartial"));
                lpHwxSetAbort= (PHWXSETABORT)GetProcAddress(m_hHwxjpn,TEXT("HwxSetAbort"));
                lpHwxInput= (PHWXINPUT)GetProcAddress(m_hHwxjpn,TEXT("HwxInput"));
                lpHwxEndInput= (PHWXENDINPUT)GetProcAddress(m_hHwxjpn,TEXT("HwxEndInput"));
                lpHwxProcess= (PHWXPROCESS)GetProcAddress(m_hHwxjpn,TEXT("HwxProcess"));
                lpHwxResultsAvailable= (PHWXRESULTSAVAILABLE)GetProcAddress(m_hHwxjpn,TEXT("HwxResultsAvailable"));
                lpHwxGetResults= (PHWXGETRESULTS)GetProcAddress(m_hHwxjpn,TEXT("HwxGetResults"));
                lpHwxDestroy= (PHWXDESTROY)GetProcAddress(m_hHwxjpn,TEXT("HwxDestroy"));
#endif // UNDER_CE


                if ( !lpHwxConfig  || !lpHwxCreate || !lpHwxSetContext ||
                     !lpHwxSetGuide || !lpHwxAlcValid || !lpHwxSetPartial ||
                     !lpHwxSetAbort || !lpHwxInput || !lpHwxEndInput ||
                     !lpHwxProcess || !lpHwxResultsAvailable || !lpHwxGetResults ||
                     !lpHwxDestroy )
                {
                     FreeLibrary(m_hHwxjpn);
                    m_hHwxjpn = NULL;
                    bRet = FALSE;
                }
                else
                {
                    (*lpHwxConfig)();
                }
            }
            else
            {
                 bRet = FALSE;
            }
        }
    }
    if ( bRet && m_hHwxjpn && !IsThreadStarted() )
    {
         bRet = StartThread();
    }
    return bRet;
}

BOOL CHwxThread::StartThread()
{
    BOOL bRet = FALSE;
    if ( !(m_hStopEvent = CreateEvent(NULL,FALSE,FALSE,NULL)) )
        return bRet;
    m_Quit = FALSE;
#ifndef UNDER_CE // Windows CE does not support THREAD_QUERY_INFORMATION
    m_hThread = CreateThread(NULL, 0, RealThreadProc, (void *)this, THREAD_QUERY_INFORMATION, &m_thrdID);
#else // UNDER_CE
    m_hThread = CreateThread(NULL, 0, RealThreadProc, (void *)this, 0, &m_thrdID);
#endif // UNDER_CE
    if ( m_hThread )
    {
         if ( IsMyHwxCls(TEXT("CHwxThreadCAC")) )
        {
            SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
//            SetThreadPriority(m_hThread, THREAD_PRIORITY_BELOW_NORMAL);
            SetThreadPriority(m_hThread, THREAD_PRIORITY_LOWEST);
        }
        bRet = TRUE;
    }
    return bRet;
}
 
void CHwxThread::StopThread()
{
    Dbg(("StopThread START\n"));
    DWORD dwReturn = 0;
    if ( m_hThread && IsMyHwxCls(TEXT("CHwxThreadCAC")) )
    {
        //----------------------------------------------------------------
        //980817:ToshiaK.Removed SetPriorityClass() line.
        //This is very dangerous code, because we don't know what applicatin
        //does about Priority.
        //In KK's case, In WordPerfect, if we use SetPriorityClass(),
        //WordPerfect never quit. I don't know why Li-zhang wrote this line.
        //Anyway, it should be removed.
        //----------------------------------------------------------------
         //SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
        SetThreadPriority(m_hThread, THREAD_PRIORITY_HIGHEST);
    }
    if (m_hThread && 
        GetExitCodeThread(m_hThread,&dwReturn) &&
        STILL_ACTIVE == dwReturn )
    {
        INT ret, i;
        ret = PostThreadMessage(m_thrdID, THRDMSG_EXIT, 0, 0);
        for(i = 0; i < 100; i++) {
            Sleep(100);
            if(m_Quit) {
                //OutputDebugString("Thread END\n");
                Dbg(("Thread Quit\n"));
                break;
            }
        }
        m_hThread = NULL;
//----------------------------------------------------------------
//971202:By Toshiak. Do not use WaitForSigleObject() to syncronize
//----------------------------------------------------------------
#ifdef RAID_2926
        PostThreadMessage(m_thrdID, THRDMSG_EXIT, 0,0);
        WaitForSingleObject(m_hStopEvent,INFINITE);
        m_hThread = NULL ;
#endif
    }
    Dbg(("StopThread End\n"));
}
 
DWORD WINAPI CHwxThread::RealThreadProc(void * pv)
{
    CHwxThread * pCHwxThread = reinterpret_cast<CHwxThread*>(pv);
    return pCHwxThread->ClassThreadProc() ;
}
 
DWORD CHwxThread::ClassThreadProc()
{
    return RecognizeThread(m_thrdArg);
}

CHwxThreadMB::CHwxThreadMB(CHwxMB * pMB,int nSize)
{
    m_pMB = pMB;
#ifdef FE_CHINESE_SIMPLIFIED
    m_recogMask = ALC_CHS_EXTENDED;
#elif  FE_KOREAN
    m_recogMask = ALC_KOR_EXTENDED;
#else
    m_recogMask = ALC_JPN_EXTENDED;
#endif
    m_prevChar =  INVALID_CHAR;
    m_hrcActive = NULL;
    m_giSent = 0; 
    m_bDirty = FALSE;

    m_guide.xOrigin = 0;
    m_guide.yOrigin = 0;

    m_guide.cxBox = nSize << 3;
    m_guide.cyBox = nSize << 3;

//    m_guide.cxBase = 0;
    m_guide.cyBase = nSize << 3;

    m_guide.cHorzBox = 256;
    m_guide.cVertBox = 1;

    m_guide.cyMid = nSize << 3;

    m_guide.cxOffset = 0;
    m_guide.cyOffset = 0;

    m_guide.cxWriting =    nSize << 3;
    m_guide.cyWriting = nSize << 3;

    m_guide.nDir = HWX_HORIZONTAL;
}

CHwxThreadMB::~CHwxThreadMB()
{
    m_pMB = NULL;
}

BOOL CHwxThreadMB::Initialize(TCHAR * pClsName)
{
     return CHwxThread::Initialize(pClsName);
}

DWORD CHwxThreadMB::RecognizeThread(DWORD dummy)
{
    MSG      msg;
    int      count;


    // Now we are sitting in our message loop to wait for
    // the message sent by the main thread

    while (1)
    {
        if (!m_bDirty)
        {
            GetMessage(&msg, NULL, 0, 0);
        }
        else
        {
            if (!PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                m_bDirty = FALSE;

                (*lpHwxProcess)(m_hrcActive);

                count = (*lpHwxResultsAvailable)(m_hrcActive);

                if (count > m_giSent)
                {
                    GetCharacters(m_giSent, count);
                    m_giSent = count;
                }

                continue;
            }
        }

        if (!HandleThreadMsg(&msg))
        {
            //SetEvent(m_hStopEvent);
            m_Quit = TRUE;
            return 0;
        }
    }
    m_Quit = TRUE;
    Unref(dummy);
}

void CHwxThreadMB::GetCharacters(int iSentAlready, int iReady)
{
    HWXRESULTPRI   *pResult, *pHead;
    HWXRESULTS  *pBox;
    int         iIndex;
    int count = iReady - iSentAlready;

    pBox = (HWXRESULTS *)MemAlloc(count * (sizeof(HWXRESULTS) + (MB_NUM_CANDIDATES - 1)*sizeof(WCHAR)));

    if (pBox)
    {
        iIndex = (*lpHwxGetResults)(m_hrcActive, MB_NUM_CANDIDATES, iSentAlready, count, pBox);

        pHead = NULL;

        for (iIndex = count - 1; iIndex >= 0; iIndex--)
        {
            // Index to the correct box results structure.

            HWXRESULTS *pBoxCur = (HWXRESULTS *) (((char *) pBox) +
                                    (iIndex *
                                    (sizeof(HWXRESULTS) +
                                    (MB_NUM_CANDIDATES - 1) * sizeof(WCHAR))));

            pResult = GetCandidates(pBoxCur);

            if (pResult == NULL)
            {
                break;
            }

            pResult->pNext = pHead;
            pHead = pResult;
        }

        MemFree((void *)pBox);
        // Call back to the main thread to dispatch the BOXRESULTS

        if (pHead)
        {
            PostMessage(m_pMB->GetMBWindow(), MB_WM_HWXCHAR, (WPARAM)pHead, 0);
        }
    }
}

//////////////////////////////////////////////////////////////////
// Function    :    CHwxThreadMB::HandleThreadMsg
// Type        :    BOOL
// Purpose    :    
// Args        :    
//            :    MSG *    pMsg    
// Return    :    
// DATE        :    Fri Oct 06 20:45:37 2000
// Histroy    :    00/10/07: for Satori #2471.
//                It's very difficult bug.
//                Old code are following..
//
//                switch(pMsg->message){
//                    :
//                case THRDMSG_EXIT:
//                default:
//                    return FALSE;
//                }
//                if HandlThreadMsg() receive unknown message,
//                it always return False, then Thread quits!!!!.
//                In Cicero environment, somebody post unkonwn message,
//                to this Thread ID, when IMM IME is switched to Another IMM IME.
//                IMEPad uses AttachThreadInput() attached application process's thread ID,
//                Message is duplicated and HW thread receive this illegal
//                message ID.
//                So, I changed to return TRUE if HW thread receive unkonwn message 
//                
//                switch(pMsg->message){
//                    :
//                case THRDMSG_EXIT:
//                    return FALSE;
//                default:
//                    return TRUE;
//                }
//
//////////////////////////////////////////////////////////////////
BOOL CHwxThreadMB::HandleThreadMsg(MSG *pMsg)
{
    PSTROKE     pstr;
    int         iIndex;
    int         count;

    switch (pMsg->message)
    {
        case THRDMSG_ADDINK:

            pstr = (PSTROKE) pMsg->lParam;

            if (!pstr)
                return TRUE;

            if (m_hrcActive == NULL)
            {
                m_giSent = 0;

                m_hrcActive = (*lpHwxCreate)((HRC)NULL);

                if (m_hrcActive == NULL)
                    return TRUE;

                m_guide.cxBox = m_guide.cyBox = m_guide.cyBase = pMsg->wParam << 3;
                m_guide.cyMid = m_guide.cxWriting = m_guide.cyWriting = pMsg->wParam << 3;

                (*lpHwxSetGuide)(m_hrcActive, &m_guide);

                // Setup the ALC mask everytime we do recognization

                (*lpHwxAlcValid)(m_hrcActive, m_recogMask);

                // Setup the context information if we have a valid prevChar

                if (m_prevChar != INVALID_CHAR)
                {
                    WCHAR ctxtChar;

                    // Get the correct context
                    if( FoldStringW(MAP_FOLDCZONE, &m_prevChar, 1, &ctxtChar, 1) )
                    {
                        (*lpHwxSetContext)(m_hrcActive, ctxtChar);
                    }
                }
            }
            count = (pstr->iBox * pMsg->wParam) << 3;   // Compute the offset for the box logically.

            for (iIndex = 0; iIndex < pstr->cpt; iIndex++)
            {
                pstr->apt[iIndex].x = ((pstr->apt[iIndex].x - pstr->xLeft) << 3) + count;
                pstr->apt[iIndex].y = (pstr->apt[iIndex].y << 3);
            }

            (*lpHwxInput)(m_hrcActive, pstr->apt,pstr->cpt,0);

            MemFree((void *)pstr);

            m_bDirty = TRUE;

            return TRUE;

        case THRDMSG_RECOGNIZE:

            if (m_hrcActive == NULL)
            {
                return(TRUE);
            }

            (*lpHwxEndInput)(m_hrcActive);
            (*lpHwxProcess)(m_hrcActive);

            //
            // We only get back the top 6 candidates.
            //

            count = pMsg->wParam;               // # of boxes written in is sent here.

            if (count > m_giSent)
            {
                GetCharacters(m_giSent, count);
                m_giSent = count;
            }

            (*lpHwxDestroy)(m_hrcActive);
            m_bDirty = FALSE;
            m_hrcActive = NULL;
            return TRUE;

//        case THRDMSG_CHAR:
//            PostMessage(m_pMB->GetMBWindow(), MB_WM_COMCHAR, pMsg->wParam, 0);
//            return TRUE;

        case THRDMSG_SETMASK:
            m_recogMask = pMsg->wParam;
            return TRUE;

        case THRDMSG_SETCONTEXT:
            m_prevChar = (WCHAR) pMsg->wParam;
            return TRUE;
        case THRDMSG_EXIT:
        default:
            //----------------------------------------------------------------
            //Satori #2471:return TRUE not to quit thread accicentaly.
            //----------------------------------------------------------------
            return TRUE;
    }
}

HWXRESULTPRI * CHwxThreadMB::GetCandidates(HWXRESULTS *pbox)
{
    HWXRESULTPRI *pResult;
    int      i;

    pResult = (HWXRESULTPRI *)MemAlloc(sizeof(HWXRESULTPRI));

    if (!pResult)
        return NULL;

    pResult->pNext = NULL;

    for ( i=0; i<MB_NUM_CANDIDATES; i++ )
    {
        pResult->chCandidate[i] = pbox->rgChar[i];
        if ( !pbox->rgChar[i] )
            break;
    }

    pResult->cbCount = (USHORT)i;
    pResult->iSelection = 0;

    return pResult;
}

CHwxThreadCAC::CHwxThreadCAC(CHwxCAC * pCAC)
{
    m_pCAC = pCAC;
}

CHwxThreadCAC::~CHwxThreadCAC()
{
    m_pCAC = NULL;
}
 
BOOL CHwxThreadCAC::Initialize(TCHAR * pClsName)
{
     return CHwxThread::Initialize(pClsName);
}

DWORD CHwxThreadCAC::RecognizeThread(DWORD dwPart)
{
    MSG            msg;
    //UINT        nPartial = dwPart;
    HRC            hrc;
    HWXGUIDE      guide;
    BOOL        bRecog;
    DWORD        cstr;
    STROKE       *pstr;

    // Create the initial hrc for this thread, set the recognition paramters.

    hrc = (*lpHwxCreate)((HRC) NULL);
    if ( !hrc )
       return 0;
    guide.xOrigin  = 0;
    guide.yOrigin  = 0;
    guide.cxBox    = 1000;
    guide.cyBox    = 1000;
//    guide.cxBase   = 0;
    guide.cyBase   = 1000;
    guide.cHorzBox = 1;
    guide.cVertBox = 1;
    guide.cyMid    = 1000;
    guide.cxOffset = 0;
    guide.cyOffset = 0;
    guide.cxWriting = 1000;
    guide.cyWriting = 1000;
    guide.nDir = HWX_HORIZONTAL;

    (*lpHwxSetGuide)(hrc, &guide);                // Set the guide
//    (*lpHwxSetPartial)(hrc, nPartial);            // Set the recognition type
    (*lpHwxSetAbort)(hrc,(UINT *)m_pCAC->GetStrokeCountAddress());                     // Set the abort address

// Begin the message loop

    while (TRUE)
    {
        bRecog = FALSE;

        // Wait until we're told to recognize.
        if(GetMessage(&msg, NULL, 0, 0) == FALSE)
        {
            if ( hrc )
                (*lpHwxDestroy)(hrc);
            hrc = NULL;
            //971202: removed by Toshiak
            //SetEvent(m_hStopEvent);
            m_Quit = TRUE;
            Dbg(("Recognize Thread END\n"));
            return 0;
        }

        // We'll eat all the incoming messages
        do
        {
            switch (msg.message)
            {
            case THRDMSG_SETGUIDE:
                guide.cxBox  = msg.wParam;
                guide.cyBox  = msg.wParam;
                guide.cyBase = msg.wParam;
                guide.cyMid    = msg.wParam;
                guide.cxWriting = msg.wParam;
                guide.cyWriting = msg.wParam;
                (*lpHwxSetGuide)(hrc, &guide);            // Set the guide
                break;
            case THRDMSG_RECOGNIZE:
                bRecog = TRUE;
                break;
            case THRDMSG_EXIT:
                if ( hrc )
                    (*lpHwxDestroy)(hrc);
                hrc = NULL;
                //971202: removed by ToshiaK
                //SetEvent(m_hStopEvent);
                m_Quit = TRUE;
                Dbg(("Recognize Thread END\n"));
                return 0;
            default:
                break;
            }
        } while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE));

        // Was there a message to recognize?
        if (!bRecog)
            continue;

        bRecog = FALSE;

        // Count the number of valid strokes
        cstr = 0;
        pstr = m_pCAC->GetStrokePointer();
        while (pstr)
        {
            cstr++;
            pstr = pstr->pNext;
        }

        // If the available stroke count doesn't match the actual stroke count, exit

        if ((cstr != (DWORD)m_pCAC->GetStrokeCount()) || (!cstr))
        {
            continue;
        }

        recoghelper(hrc,HWX_PARTIAL_ALL,cstr);
        recoghelper(hrc,HWX_PARTIAL_ORDER,cstr);
        recoghelper(hrc,HWX_PARTIAL_FREE,cstr);
    }
    m_Quit = TRUE;
    Unref(dwPart);
}

void CHwxThreadCAC::recoghelper(HRC hrc,DWORD dwPart,DWORD cstr)
{
    UINT        nPartial = dwPart;
    HRC            hrcTmp;
    DWORD        dwTick;
    HWXRESULTS *pbox;
    int            ires;
    STROKE       *pstr;

    int nSize = dwPart != HWX_PARTIAL_ALL  ? PREFIXLIST : FULLLIST;
    pbox = (HWXRESULTS *)MemAlloc(sizeof(HWXRESULTS) + nSize * sizeof(WCHAR));
    if ( !pbox )
     {
        return;
     }

    hrcTmp = (*lpHwxCreate)(hrc);
    (*lpHwxSetPartial)(hrcTmp, nPartial);            // Set the recognition type
//    (*lpHwxSetAbort)(hrcTmp,(UINT *)m_pCAC->GetStrokeCountAddress());                // Set the abort address

    pstr      = m_pCAC->GetStrokePointer();
    dwTick = 0;
    while (pstr)
    {
        dwTick +=3641L;
        (*lpHwxInput)(hrcTmp, pstr->apt,pstr->cpt, dwTick);
        pstr = pstr->pNext;
    }

    memset(pbox, '\0', sizeof(HWXRESULTS) + nSize * sizeof(WCHAR));

    // Call the recognizer for results

     (*lpHwxEndInput)(hrcTmp);
     (*lpHwxProcess)(hrcTmp);
    (*lpHwxGetResults)(hrcTmp, nSize, 0, 1, pbox);
    (*lpHwxDestroy)(hrcTmp);

    // Return the results

    ires = 0;
    while (pbox->rgChar[ires])
    {
        if (cstr != (DWORD)m_pCAC->GetStrokeCount())
            break;
        SendMessage(m_pCAC->GetCACWindow(), CAC_WM_RESULT, (nPartial << 8) | cstr, MAKELPARAM((pbox->rgChar[ires]), ires));
        ires++;
    }
    MemFree((void *)pbox);
    if ( ires )
    {
      SendMessage(m_pCAC->GetCACWindow(), CAC_WM_SHOWRESULT,0,0);
    }
}

void CHwxThreadCAC::RecognizeNoThread(int nSize)
{
    HRC            hrc;
    HWXGUIDE      guide;
    STROKE       *pstr;
    long        numstrk = 0;

     if (( pstr = m_pCAC->GetStrokePointer()) == (STROKE *) NULL)
        return;

    // Create the initial hrc for this thread, set the recognition paramters.
    hrc = (*lpHwxCreate)((HRC) NULL);
    if ( !hrc )
        return;

    guide.xOrigin  = 0;
    guide.yOrigin  = 0;

    guide.cxBox    = nSize;
    guide.cyBox    = nSize;

//    guide.cxBase   = 0;
    guide.cyBase   = nSize;
    guide.cHorzBox = 1;
    guide.cVertBox = 1;
    guide.cyMid    = 0;
      guide.cxOffset = 0;
    guide.cyOffset = 0;
    guide.cxWriting = nSize;
    guide.cyWriting = nSize;
    guide.nDir = HWX_HORIZONTAL;

    (*lpHwxSetGuide)(hrc, &guide);                // Set the guide
//    (*lpHwxSetPartial)(hrc,HWX_PARTIAL_ALL);    // Set the recognition type
    (*lpHwxSetAbort)(hrc,(UINT *)m_pCAC->GetStrokeCountAddress()); 

    numstrk = m_pCAC->GetStrokeCount();
    recoghelper(hrc,HWX_PARTIAL_ALL,numstrk);
    recoghelper(hrc,HWX_PARTIAL_ORDER,numstrk);
//    recoghelper(hrc,HWX_PARTIAL_FREE,numstrk);

    (*lpHwxDestroy)(hrc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\instr.h ===
#ifndef _INLINE_STRING_H_
#define _INLINE_STRING_H_
/* strutil.cpp */
#define StrlenA		lstrlenA
#define StrcatA		lstrcatA
#define StrcpyA		lstrcpyA
#define StrcpynA	lstrcpynA
#define StrcmpA		lstrcmpA
#define StrlenW		lstrlenW
#define StrcpySafeW	StrcpynW
#define StrcpySafeA StrcpynA
inline LPWSTR StrcpyW(WCHAR *dest, const WCHAR *source)
{
	WCHAR *start = dest;
	while (*dest++ = *source++);
	return(start);
}

inline LPWSTR StrcatW(WCHAR *dest, const WCHAR *source)
{
	WCHAR *start = dest;
	WCHAR *pwch;
	for (pwch = dest; *pwch; pwch++);
	while (*pwch++ = *source++);
	return(start);
}

inline LPWSTR StrcpynW(LPWSTR dest, LPWSTR src, INT destLen)
{
	if(!dest) {
		return NULL;
	}
	if(!src) {
		return dest;
	}
	//WCHAR	*start = dest;
	INT		i;
	for(i = 0; i < destLen-1 && src[i]; i++) {
		dest[i] = src[i];
	}
	dest[i] = (WCHAR)0x0000;
	return dest;
}

inline int StrcmpW(const WCHAR * first, const WCHAR * last)
{
	for (; *first && *last && (*first == *last); first++, last++);
	return (*first - *last);
}

#endif //_INLINE_STRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\lexheader.h ===
#if !defined(_LEXHEADER_H__INCLUDED_)
#define _LEXHEADER_H__INCLUDED_

#define DICT_HEADER_SIZE 512
#define COPYRIGHT_STR "(C) 1997 Hangul Engineering Team. Microsoft Corp. All rights reserved.\n"
#define LEX_VERSION					0x1100
#define LEX_COMPATIBLE_VERSION_LIMIT	0x2000
#define LEX_FILE_NAME TEXT("IMEKR.LEX")

#define TOTAL_NUMBER_OF_HANGUL_MAPPING	(484 + 18) // K0+K1 + # of symbols( - )
#define TOTAL_NUMBER_OF_HANJA			7744
#define MAX_NUMBER_OF_HANJA_SAME_PRONUNC 103
#define MAX_SENSE_LENGTH	50

struct  _DictHeader {
	char	COPYRIGHT_HEADER[150];
	WORD	Version;
	UINT	NumOfHangulEntry;
	UINT	MaxNumOfHanja;
	DWORD	Headersize;
	DWORD	iBufferStart;	      // seek point of HnagulToHanja Index
	UINT	uiNumofHanja;
	DWORD   iHanjaToHangulIndex;  // seek point of HanjaToHangul Index
	DWORD	reserved[10];
	_DictHeader() { 
		Version = 0;
		iBufferStart = Headersize= 0;

		memset(reserved, '\0', sizeof(reserved));
		memset(COPYRIGHT_HEADER, '\0', sizeof(COPYRIGHT_HEADER));
		strcpy(COPYRIGHT_HEADER, COPYRIGHT_STR);
		COPYRIGHT_HEADER[strlen(COPYRIGHT_HEADER)+1] = '\032';
	}
};

struct _LexIndex {
	WCHAR	wcHangul;
	WORD	wNumOfK0, wNumOfK1;
	UINT	iOffset;

	_LexIndex() {
		wcHangul = 0;
		wNumOfK0 = wNumOfK1 = 0;
		iOffset = 0;
	}
};

struct HanjaToHangulIndex 
{
	WCHAR	wchHanja;
	WCHAR	wchHangul;
	UINT	iOffset;

	HanjaToHangulIndex() 
	{
		wchHanja = wchHangul = 0;
		iOffset = 0;
	}
};


#endif // !defined(_LEXHEADER_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\immsec.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    immsec.c

Abstract:

    security code called by IMEs 

Author:

     Chae Seong Lim [cslim] 23-Dec-1997
    Takao Kitano [takaok] 01-May-1996

Revision History:
    Chae Seong Lim [cslim] 971223 Korean IME version
    Hiroaki Kanokogi [hiroakik] 960624  Modified for MSIME96
    Hiroaki Kanokogi [hiroakik] 960911  NT #11911

--*/

#include <windows.h>
#include "hwxobj.h"
#define _USEINIME_
//#ifndef _USEINIME_    // .IME does not need
//#include <dbgmgr.h>
//#include <misc/memalloc.h>
//#endif // _USEINIME_
#include "immsec.h"


#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

//
// internal functions
//
PSID MyCreateSid( DWORD dwSubAuthority );
#ifndef _USEINIME_
POSVERSIONINFO GetVersionInfo(VOID);
#endif // _USEINIME_

//
// debug functions
//
#ifdef DEBUG
#define ERROROUT(x)      ErrorOut( x )
#define WARNOUT(x)       WarnOut( x )
#else
#define ERROROUT(x) 
#define WARNOUT(x)       
#endif

#ifdef DEBUG
VOID WarnOut( PTSTR pStr )
{
    OutputDebugString( pStr );
}

VOID ErrorOut( PTSTR pStr )
{
    DWORD dwError;
    DWORD dwResult;
    static TCHAR buf1[512];
    static TCHAR buf2[512];

    dwError = GetLastError();
    dwResult = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwError,
                              MAKELANGID( LANG_ENGLISH, LANG_NEUTRAL ),
                              buf1,
                              512,
                              NULL );                                   
    
    if ( dwResult > 0 ) {
        wsprintfA(buf2, "%s:%s(0x%x)", pStr, buf1, dwError);
    } else {
        wsprintfA(buf2, "%s:(0x%x)", pStr, dwError);
    }
    OutputDebugString( buf2 );
}
#endif


//
// GetIMESecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeIMESecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//

static PSECURITY_ATTRIBUTES pSAIME = NULL;
static PSECURITY_ATTRIBUTES pSAIME_UserDic = NULL;
static INT nNT95 = 0;    //0...Not examined, 1...NT, 2...Not NT

PSECURITY_ATTRIBUTES GetIMESecurityAttributes(VOID)
{
    if (nNT95 == 0)
        nNT95 = IsWinNT() ? 1 : 2;
    
    if (nNT95==1)
        return (pSAIME==NULL) ? (pSAIME=CreateSecurityAttributes()) : pSAIME;
    else
        return NULL;
    // To avoid CreateSecurityAttributes from being called every time when OS is not NT.
}

#if NOT_USED
PSECURITY_ATTRIBUTES GetIMESecurityAttributesEx(VOID)
{
    if (nNT95 == 0)
        nNT95 = IsWinNT() ? 1 : 2; //IsNT is not for multi-threaded programs, right?
    
    if (nNT95==1)
        return (pSAIME_UserDic==NULL) ? (pSAIME_UserDic=CreateSecurityAttributesEx()) : pSAIME_UserDic;
    else
        return NULL;
    // To avoid CreateSecurityAttributes from being called every time when OS is not NT.
}
#endif
//
// FreeIMESecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      GetIMESecurityAttributes() call.
//

VOID FreeIMESecurityAttributes()
{
    if (pSAIME!=NULL)
        FreeSecurityAttributes(pSAIME);
    if (pSAIME_UserDic!=NULL)
        FreeSecurityAttributes(pSAIME_UserDic);

    pSAIME = NULL;
    pSAIME_UserDic = NULL;
}

//
// CreateSecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributes()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    DWORD                cbacl;

    PSID                 psid1, psid2;
    BOOL                 fResult;

    psid1 = MyCreateSid( SECURITY_INTERACTIVE_RID );
    if ( psid1 == NULL ) {
        return NULL;
    } 

    psid2 = MyCreateSid( SECURITY_LOCAL_SYSTEM_RID );
    if ( psid2 == NULL ) {
        FreeSid ( psid1 );
        return NULL;
    } 

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SIDs we've just created.
    //
    cbacl =  sizeof(ACL) + 
             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) * 2 + 
             GetLengthSid(psid1) + GetLengthSid(psid2);

    pacl = (PACL)MEMALLOC( cbacl );
    if ( pacl == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed") );
        FreeSid ( psid1 );
        FreeSid ( psid2 );
        return NULL;
    }

    fResult = InitializeAcl( pacl, cbacl, ACL_REVISION );
    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeAcl failed") );
        FreeSid ( psid1 );
        FreeSid ( psid2 );
        MEMFREE( pacl );
        return NULL;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid1 );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        MEMFREE( pacl );
        FreeSid ( psid1 );
        FreeSid ( psid2 );
        return NULL;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid2 );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        MEMFREE( pacl );
        FreeSid ( psid1 );
        FreeSid ( psid2 );
        return NULL;
    }

    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid ( psid1 );
    FreeSid ( psid2 );

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidAcl returns fFalse!"));
        MEMFREE( pacl );
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC( sizeof( SECURITY_ATTRIBUTES ) );
    if ( psa == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psa failed") );
        MEMFREE( pacl );
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC( SECURITY_DESCRIPTOR_MIN_LENGTH );
    if ( psd == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psd failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        return NULL;
    }

    if ( ! InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION ) ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl( psd,
                                         TRUE,
                                         pacl,
                                         FALSE );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    } 

    if (!IsValidSecurityDescriptor(psd)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = FALSE;

    return psa;
}

PSID MyCreateSid( DWORD dwSubAuthority )
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid( &SidAuthority,
                                        1,
                                        dwSubAuthority,
                                        0,0,0,0,0,0,0,
                                        &psid );
    if ( ! fResult ) {
        ERROROUT( TEXT("MyCreateSid:AllocateAndInitializeSid failed") );
        return NULL;
    }

    if ( ! IsValidSid( psid ) ) {
        WARNOUT( TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid( psid );
        return NULL;
    }

    return psid;
}

//
// FreeSecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      CreateSecurityAttributes() call.
//
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa )
{
    BOOL fResult;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    PACL pacl;

    fResult = GetSecurityDescriptorDacl( psa->lpSecurityDescriptor,
                                         &fDaclPresent,
                                         &pacl,
                                         &fDaclDefaulted );                  
    if ( fResult ) {
        if ( pacl != NULL )
            MEMFREE( pacl );
    } else {
        ERROROUT( TEXT("FreeSecurityAttributes:GetSecurityDescriptorDacl failed") );
    }

    MEMFREE( psa->lpSecurityDescriptor );
    MEMFREE( psa );
}


#if NOT_USED
//
// Function Below is added to give GENERIC_ALL to everyone for UserDictionary
// which is accessed from network (not interactive).
// 960911 HiroakiK NT #11911
//

//
// CreateSecurityAttributesEx()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access for everyone
//                 ^^^^^^^^
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributesEx()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    DWORD                cbacl;

    PSID                 psid;
    BOOL                 fResult;

    //
    // create a sid for everyone access
    //
    psid = MyCreateSidEx();
    if ( psid == NULL ) {
        return NULL;
    } 

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SID we've just created.
    //
    cbacl =  sizeof(ACL) + 
             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) + 
             GetLengthSid(psid);

    pacl = (PACL)MEMALLOC( cbacl );
    if ( pacl == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed") );
        FreeSid ( psid );
        return NULL;
    }

    fResult = InitializeAcl( pacl, cbacl, ACL_REVISION );
    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeAcl failed") );
        FreeSid ( psid );
        MEMFREE( pacl );
        return NULL;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        MEMFREE( pacl );
        FreeSid ( psid );
        return NULL;
    }


    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid ( psid );

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidAcl returns fFalse!"));
        MEMFREE( pacl );
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC( sizeof( SECURITY_ATTRIBUTES ) );
    if ( psa == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psa failed") );
        MEMFREE( pacl );
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC( SECURITY_DESCRIPTOR_MIN_LENGTH );
    if ( psd == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psd failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        return NULL;
    }

    if ( ! InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION ) ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl( psd,
                                         TRUE,
                                         pacl,
                                         FALSE );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    } 


    if (!IsValidSecurityDescriptor(psd)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = FALSE;

    return psa;
}

PSID MyCreateSidEx(VOID)
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid( &SidAuthority,
                                        1,
                                        SECURITY_WORLD_RID,
                                        0,0,0,0,0,0,0,
                                        &psid );
    if ( ! fResult ) {
        ERROROUT( TEXT("MyCreateSid:AllocateAndInitializeSid failed") );
        return NULL;
    }

    if ( ! IsValidSid( psid ) ) {
        WARNOUT( TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid( psid );
        return NULL;
    }

    return psid;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\makefile.inc ===
cfont.cpp : ..\common\cfont.cpp
    COPY $** $@
cutil.cpp : ..\common\cutil.cpp
    COPY $** $@
exgdiw.cpp : ..\common\exgdiw.cpp
    COPY $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\main.cpp ===
#include <windows.h>
#include "cfactory.h"

#ifndef UNDER_CE // Cannot override DllMain's prototype
BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwF, LPVOID lpNotUsed);
#else // UNDER_CE
BOOL WINAPI DllMain(HANDLE hInst, DWORD dwF, LPVOID lpNotUsed);
#endif // UNDER_CE

extern HINSTANCE g_hInst = NULL;

#ifndef UNDER_CE // Cannot override DllMain's prototype
BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwF, LPVOID lpNotUsed)
#else // UNDER_CE
BOOL WINAPI DllMain(HANDLE hInst, DWORD dwF, LPVOID lpNotUsed)
#endif // UNDER_CE
{
    UNREFERENCED_PARAMETER(lpNotUsed);
    switch (dwF) {
    case DLL_PROCESS_ATTACH:
#ifndef UNDER_CE // Windows CE does not support DisableThreadLibraryCalls
        DisableThreadLibraryCalls(hInst);
#endif // UNDER_CE
#ifndef UNDER_CE // Cannot override DllMain's prototype
        g_hInst = hInst;
        CFactory::m_hModule = hInst;
#else // UNDER_CE
        g_hInst = (HINSTANCE)hInst;
        CFactory::m_hModule = (HMODULE)hInst;
#endif // UNDER_CE
        break;
    case DLL_PROCESS_DETACH:
#ifdef _DEBUG
        OutputDebugString("===== MULTIBOX.DLL DLL_PROCESS_DETACH =====\n");
#endif
        g_hInst = NULL;
        break;
    }
    return TRUE;
}

//----------------------------------------------------------------
//IME98A Enhancement:
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function : DllCanUnloadNow
// Type     : STDAPI
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Wed Mar 25 14:15:36 1998
//////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow()
{
    return CFactory::CanUnloadNow() ;
}

//////////////////////////////////////////////////////////////////
// Function : DllGetClassObject
// Type     : STDAPI
// Purpose  : 
// Args     : 
//          : REFCLSID rclsid 
//          : REFIID riid 
//          : LPVOID * ppv 
// Return   : 
// DATE     : Wed Mar 25 14:17:10 1998
//////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID    rclsid,
                         REFIID        riid,
                         LPVOID        *ppv)
{
    return CFactory::GetClassObject(rclsid, riid, ppv);
}

//----------------------------------------------------------------
//
// Server [un]registration exported API
//
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function : DllRegisterServer
// Type     : STDAPI
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Wed Mar 25 14:25:39 1998
//////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer()
{
    return CFactory::RegisterServer();
}

//////////////////////////////////////////////////////////////////
// Function : DllUnregisterServer
// Type     : STDAPI
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Wed Mar 25 14:26:03 1998
//////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer()
{
    return CFactory::UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\memmgr.h ===
#ifndef _MEM_MGR_H_
#define _MEM_MGR_H_

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif //WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <windowsx.h>

#define MemAlloc(a)	GlobalAllocPtr(GHND, (a))
#define MemFree(a)	GlobalFreePtr((a))

#endif //_MEM_MGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by APPLET.RC
//
#define IDI_HWXPAD                      105
#define IDI_CACSWITCHVIEW               106
#define IDR_MB                          127
#define IDD_MBPROP                      140
#define IDR_CACINK                      142
#define IDR_CACLV                       144
#define IDB_CHARBMP                     146
#define IDC_MBCOMBO                     147
#define IDC_MBSTATIC                    148
#define IDC_CACCHECK                    149
#define IDC_CACMBMENU                   150
#define IDC_CACMBRECOG                  151
#define IDC_CACMBREVERT                 152
#define IDC_CACMBCLEAR                  153
#define IDC_CACSWITCHVIEW               154
#define IDI_HWXPADSC                    157
#define IDI_HWXPADKO                    158
#define IDS_TIMER0                      1008
#define IDS_TIMER1                      1009
#define IDS_TIMER2                      1010
#define IDS_TIMER3                      1011
#define IDS_TIMER4                      1012
#define IDS_TIMER5                      1013
#define IDS_TIMER6                      1014
#define IDS_TIMER7                      1015
#define IDS_TIMER8                      1016
#define IDS_TIMER9                      1017
#define IDS_TIMER10                     1018
#define IDS_LVC0                        1019
#define IDS_LVC1                        1020
#define IDS_LVC2                        1021
#define IDS_LVC3                        1022
#define IDS_LVC4                        1023
#define IDS_LVC5                        1024
#define IDS_LVC6                        1025
#define IDS_LVC7                        1026
#define IDS_CAC                         1027
#define IDS_MB                          1028
#define IDS_CACLARGE                    1029
#define IDS_CACDETAIL                   1030
#define IDS_CACMBRECOG                  1031
#define IDS_CACMBREVERT                 1032
#define IDS_CACMBCLEAR                  1033
#define IDS_CACINK                      1034
#define IDS_CACPLV                      1035
#define IDS_CACMBBTN1                   1036
#define IDS_CACMBBTN2                   1037
#define IDS_CACMBBTN3                   1038
#define IDS_CACMBBTN4                   1039
#define IDS_CACMBBTN5                   1040
#define IDS_CACMBBTN6                   1041
#define IDS_TITLE                       1042
#define IDS_TITLE_US                    1043
#define IDS_FONT_DEFAULT                1044
#define IDS_FONT_DEFAULT_US             1045
#define IDS_RECOG_FILE                  1046
#define IDM_MBRECOG                     40001
#define IDM_MBDELETE                    40002
#define IDM_MBPROP                      40004
#define IDM_CACRECOG                    40007
#define IDM_CACDELETEONE                40008
#define IDM_CACDELETEALL                40009
#define IDM_CACAUTORECOG                40010
#define IDM_CACLVSENDCHAR               40011
#define IDM_CACLVSENDOTHER_NONE         40014
#define IDM_CACLVDISPLAY_LARGE          40015
#define IDM_CACLVDISPLAY_DETAIL         40016
#define IDM_CACLVDISPLAYOTHER_KANJI     40018
#define IDM_CACLVDISPLAYOTHER_STROKE    40019
#define IDM_CACLVDISPLAYOTHER_RADICAL   40020
#define IDM_CACLVDISPLAYOTHER_R1        40021
#define IDM_CACLVDISPLAYOTHER_R2        40022
#define IDM_CACLVDISPLAYOTHER_K1        40023
#define IDM_CACLVDISPLAYOTHER_K2        40024
#define IDM_CACLVDISPLAYOTHER_OTHER     40025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        158
#define _APS_NEXT_COMMAND_VALUE         40026
#define _APS_NEXT_CONTROL_VALUE         1042
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\wndproc.cpp ===
#include "hwxobj.h"
#include "const.h"
#include "../lib/ptt/ptt.h"
#include "cexres.h"
#include "dbg.h"
#include "cmnhdr.h"

// HWX Window procedures

LRESULT    WINAPI HWXWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    //990716:ToshiaK for Win64
    //CHwxInkWindow * app = (CHwxInkWindow *)GetWindowLong(hwnd,0);
     CHwxInkWindow * app = (CHwxInkWindow *)WinGetPtr(hwnd,0);
    switch(msg)
    {
        case WM_CREATE:
             app = (CHwxInkWindow *)((LPCREATESTRUCT)lp)->lpCreateParams;
             //990810:ToshiaK for Win64
              //SetWindowLong(hwnd,0,(LONG)app);
              WinSetPtr(hwnd, 0, (LPVOID)app);
             if ( !app->HandleCreate(hwnd) )
             {
                  return -1;
             }
            return 0;
        case WM_NOTIFY:
            if ( ((LPNMHDR)lp)->code == TTN_NEEDTEXTW )
            {
                app->SetTooltipText(lp);
            }
            return 0;
        case WM_PAINT:
            app->HandlePaint(hwnd);
            return 0;                
        case WM_COMMAND:
            return app->HandleCommand(hwnd, msg, wp, lp);            
        case WM_SIZE:
            if ( SIZE_RESTORED == wp )
                app->HandleSize(wp,lp);
            return 0;
        case WM_SETTINGCHANGE:    
            if(app) {
                return app->HandleSettingChange(hwnd,msg,wp,lp);
            }
            return 0;
#ifdef UNDER_CE // Windows CE specific
        case WM_WINDOWPOSCHANGED:
            return 0;
#endif // UNDER_CE
        case WM_ERASEBKGND:
            return 0;
#ifndef UNDER_CE // Windows CE does not support WinHelp
        case WM_CONTEXTMENU:
        case WM_HELP:
            app->HandleHelp(hwnd,msg,wp,lp);
            return 0;
#endif // UNDER_CE
#ifndef UNDER_CE // Windows CE does not support WM_ENTERIDLE
         case WM_ENTERIDLE:
             Dbg(("WM_ENTERIDLE for HWXWndPrc\n"));
             if((::GetKeyState(VK_CONTROL) & 0x8000) &&
                ((::GetKeyState(VK_SHIFT)  & 0x8000) || (::GetKeyState(VK_SPACE) & 0x8000))) {
                 Dbg(("VK_CONTROL & SHIFT or VK_CONTROL & SPACE COME\n"));
                 ::SendMessage(hwnd, WM_CANCELMODE, 0, 0L);
                 return 0;
             }
            return DefWindowProc(hwnd, msg, wp, lp);             
#endif // UNDER_CE
        default:
            return DefWindowProc(hwnd, msg, wp, lp);
    }
}

LRESULT WINAPI MBWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
     //990810:ToshiaK for Win64
     //CHwxMB * app = (CHwxMB *)GetWindowLong(hwnd,0);
     CHwxMB * app = (CHwxMB *)WinGetPtr(hwnd,0);

    switch (msg)
    {
        case WM_CREATE:
        {
            app = (CHwxMB *)((LPCREATESTRUCT)lp)->lpCreateParams;
            //990810:ToshiaK for Win64
             //SetWindowLong(hwnd,0,(LONG)app);
             WinSetPtr(hwnd, 0, (LPVOID)app);
            return 0;
        }

//        case WM_DESTROY:
        //970729: by ToshiaK temporarily, comment out
//            PostThreadMessage((app->GetMBThread())->GetID(), THRDMSG_EXIT, 0, 0);
//            PostQuitMessage(0);
//            return 0;

        case WM_PAINT:
            app->HandlePaint(hwnd);
            return 0;

        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
        case WM_LBUTTONUP:
        case WM_MOUSEMOVE:
        case WM_RBUTTONUP:
        case WM_RBUTTONDOWN:
            if(!app) { //toshiaK:980324
                break;
            }
            if( app->HandleMouseEvent(hwnd, msg, wp,lp) )
                return 0;
            else
                break;

        case WM_TIMER:
            KillTimer(hwnd, TIMER_ID);
            if(!app) { //toshiaK:980324
                break;
            }
            app->SetTimerStarted(FALSE);
            app->HandleUserMessage(hwnd, MB_WM_DETERMINE,wp,lp);
            return 0;

        case WM_COMMAND:
            if(!app) { //toshiaK:980324
                break;
            }
            return app->HandleCommand(hwnd,msg,wp,lp);

        //    User defined window messages

        case MB_WM_ERASE:
        case MB_WM_DETERMINE:
        case MB_WM_HWXCHAR:
//        case MB_WM_COMCHAR:
        case MB_WM_COPYINK:
            if(!app) { //toshiaK:980324
                break;
            }
            return app->HandleUserMessage(hwnd, msg,wp,lp);
        case WM_ERASEBKGND:
            return 0;
#ifndef UNDER_CE // Windows CE does not support WM_ENTERIDLE
        case WM_ENTERIDLE:
            if((::GetKeyState(VK_CONTROL) & 0x8000) &&
               ((::GetKeyState(VK_SHIFT)  & 0x8000) || (::GetKeyState(VK_SPACE) & 0x8000))) {
                 Dbg(("VK_CONTROL & SHIFT or VK_CONTROL & SPACE COME\n"));
                 Dbg(("WM_ENTERIDLE for MBWndProc\n"));
                 ::SendMessage(hwnd, WM_CANCELMODE, 0, 0L);
                 return 0;
             }
            return 0;
#endif // UNDER_CE
        default:
            return DefWindowProc(hwnd, msg, wp, lp);
    }
    return 1;
}

LRESULT WINAPI CACWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    //990810:toshiaK for Win64
    //CHwxCAC * app = (CHwxCAC *)GetWindowLong(hwnd,0);
    CHwxCAC * app = (CHwxCAC *)WinGetPtr(hwnd,0);

    switch (msg)
    {
    case WM_CREATE:
        app = (CHwxCAC *)((LPCREATESTRUCT)lp)->lpCreateParams;
        //990716:ToshiaK for Win64
        //SetWindowLong(hwnd,0,(LONG)app);
         WinSetPtr(hwnd, 0, (LPVOID)app);
        PostMessage(hwnd,CAC_WM_DRAWSAMPLE,0,0);
        return 0;

//    case WM_DESTROY:
        //970729: by ToshiaK, temporarily comment out
//        PostQuitMessage(0);
//        break;

    case WM_PAINT:
          app->HandlePaint(hwnd);
        break;

    case WM_RBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
        app->HandleMouseEvent(hwnd,msg,wp,lp);
        break;
    case WM_NOTIFY:
        if ( ((LPNMHDR)lp)->code == TTN_NEEDTEXT_WITHUSERINFO )
        {
            app->SetToolTipText(lp);
        }
        break;
    case WM_COMMAND:
        return app->HandleCommand(hwnd,msg,wp,lp);
    case CAC_WM_RESULT:
        app->HandleRecogResult(hwnd,wp,lp);
        break;
    case CAC_WM_SHOWRESULT:
        app->HandleShowRecogResult(hwnd,wp,lp);
        break;
    case CAC_WM_SENDRESULT:
        app->HandleSendResult(hwnd,wp,lp);
        break;
    case CAC_WM_DRAWSAMPLE:
        app->HandleDrawSample();
        break;
    //990618:ToshiaK for Kotae#    1329
    case WM_ERASEBKGND:
        break;
#ifndef UNDER_CE // Windows CE does not support WM_ENTERIDLE
    case WM_ENTERIDLE:
        Dbg(("WM_ENTERIDLE for CACWndProc\n"));

        if((::GetKeyState(VK_CONTROL) & 0x8000) &&
           ((::GetKeyState(VK_SHIFT)  & 0x8000) || (::GetKeyState(VK_SPACE) & 0x8000))) {
             Dbg(("VK_CONTROL & SHIFT or VK_CONTROL & SPACE COME\n"));
             Dbg(("WM_ENTERIDLE for MBWndProc\n"));
             ::SendMessage(hwnd, WM_CANCELMODE, 0, 0L);
             return 0;
         }
        break;
#endif // UNDER_CE
    default:
        return DefWindowProc(hwnd, msg, wp, lp); 
    }
    return 0;
}
//----------------------------------------------------------------
//980805:ToshiaK. PRC merge
//----------------------------------------------------------------
LRESULT CALLBACK IMELockWndProc(
                                HWND   hWnd,
                                UINT   uMsg,
                                WPARAM wParam,
                                LPARAM lParam)
{
    WNDPROC wcOrgComboProc;

    //990810:ToshiaK for Win64 
    //wcOrgComboProc = (WNDPROC)GetWindowLong(hWnd, GWL_USERDATA);
    wcOrgComboProc = (WNDPROC)WinGetUserPtr(hWnd);

    switch (uMsg) {
#ifndef UNDER_CE // Windows CE does not support WM_INPUTLANGCHANGEREQUEST
    case WM_INPUTLANGCHANGEREQUEST:
        MessageBeep((UINT)-1);
        return 0;
#endif // UNDER_CE
    case WM_DESTROY:
        //990716:ToshiaK for Win64
        //SetWindowLong(hWnd, GWL_WNDPROC, (LONG)wcOrgComboProc);
        //SetWindowLong(hWnd, GWL_USERDATA, 0);
         WinSetWndProc(hWnd, (WNDPROC)wcOrgComboProc);
         WinSetUserPtr(hWnd, (LPVOID)0);
        break;
    default:
        break;
    }

    return CallWindowProc((WNDPROC)wcOrgComboProc, hWnd, uMsg, wParam, lParam);
}

BOOL CALLBACK SubclassChildProc(
                                HWND   hWnd,    // handle to child window
                                LPARAM lParam)  // application-defined value
{
    WNDPROC wpOldComboProc;

    //  Subclass child window to IME-UnSwitchable
    //990716:ToshiaK for Win64
    //wpOldComboProc = (WNDPROC)GetWindowLong(hWnd, GWL_WNDPROC);
    //SetWindowLong(hWnd, GWL_WNDPROC, (LONG)IMELockWndProc);
    //SetWindowLong(hWnd, GWL_USERDATA, (LONG)wpOldComboProc);
    wpOldComboProc = (WNDPROC)WinGetWndProc(hWnd);
    WinSetWndProc(hWnd, (WNDPROC)IMELockWndProc);
    WinSetUserPtr(hWnd, (LPVOID)wpOldComboProc);

    return TRUE;
    Unref(lParam);
}
 
void SubclassChildWindowAll(HWND hWndParent)
                            
{
#ifndef UNDER_CE // Windows CE does not support WM_INPUTLANGCHANGEREQUEST
    EnumChildWindows(hWndParent, (WNDENUMPROC)SubclassChildProc, 0);
#endif // UNDER_CE
    return;
}


INT_PTR CALLBACK CACMBPropDlgProc(HWND hdlg, UINT msg, WPARAM wp, LPARAM lp)
{
    CHwxInkWindow * pInk;
    switch (msg)
    {
         case WM_INITDIALOG:
            {
                pInk = (CHwxInkWindow *)lp;
#ifndef UNDER_CE // Windows CE does not support SetProp
                //SetPropW(hdlg,TEXT("CMPROP"),(HANDLE)lp);
                if(::IsWindowUnicode(hdlg)) {
                    ::SetPropW(hdlg,L"CMPROP",(HANDLE)lp);
                }
                else {
                    ::SetPropA(hdlg,"CMPROP",(HANDLE)lp);
                }
                //::SetPropW(hdlg,TEXT("CMPROP"),(HANDLE)lp);
#else // UNDER_CE

                ::SetWindowLong(hdlg, GWL_USERDATA, (LONG)lp);
#endif // UNDER_CE
                if ( pInk )
                    pInk->HandleDlgMsg(hdlg,TRUE);

                CExres::SetDefaultGUIFont(hdlg); //971117: ToshiaK
                //----------------------------------------------------------------
                //980805:ToshiaK. PRC merge.
                //----------------------------------------------------------------
                SubclassChildWindowAll(hdlg);
            }
            return TRUE;
        case WM_COMMAND:
            if ( LOWORD(wp)  == IDOK )
            {
#ifndef UNDER_CE // Windows CE does not support GetProp
                //pInk = (CHwxInkWindow *)GetProp(hdlg,TEXT("CMPROP"));
                if(::IsWindowUnicode(hdlg)) {
                    pInk = (CHwxInkWindow *)GetPropW(hdlg, L"CMPROP");
                }
                else {
                    pInk = (CHwxInkWindow *)GetPropA(hdlg,"CMPROP");
                }
#else // UNDER_CE
                pInk = (CHwxInkWindow *)GetWindowLong(hdlg, GWL_USERDATA);
#endif // UNDER_CE
                if ( pInk )
                    pInk->HandleDlgMsg(hdlg,FALSE);

#ifndef UNDER_CE // Windows CE does not support RemoveProp
                //RemoveProp(hdlg,TEXT("CMPROP"));
                if(::IsWindowUnicode(hdlg)) {
                    ::RemovePropW(hdlg, L"CMPROP");
                }
                else {
                    ::RemovePropA(hdlg, "CMPROP");
                }
#endif // UNDER_CE
                EndDialog(hdlg,TRUE);
                return TRUE;
            }
            else if ( LOWORD(wp) == IDCANCEL )
            {
#ifndef UNDER_CE // Windows CE does not support RemoveProp
                //RemoveProp(hdlg,TEXT("CMPROP"));
                if(::IsWindowUnicode(hdlg)) {
                    ::RemovePropW(hdlg, L"CMPROP");
                }
                else {
                    ::RemovePropA(hdlg, "CMPROP");
                }
#endif // UNDER_CE

                EndDialog(hdlg,FALSE);
                return TRUE;
            }
        default:
             return FALSE;
    }
}

LRESULT WINAPI CACMBBtnWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    //990810:ToshiaK for Win64
    //CHwxInkWindow * app = (CHwxInkWindow *)GetWindowLong(hwnd,GWL_USERDATA);
    CHwxInkWindow * app = (CHwxInkWindow *)WinGetUserPtr(hwnd);
    if ( !app )
         return 0;
    return app->HandleBtnSubWnd(hwnd,msg,wp,lp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\registry.cpp ===
#include <objbase.h>
#include <comcat.h>
#include "common.h"
#include "registry.h"

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"


////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

#ifndef UNDER_CE
// Set the given key and its value.
BOOL SetKeyAndValue(const char* pszPath,
                    const char* szSubkey,
                    const char* szValue,
                    const char* szName=NULL) ;

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 char* szCLSID,
                 int length) ;

// Delete szKeyChild and all of its descendents.
LONG RecursiveDeleteKey(HKEY hKeyParent, const char* szKeyChild) ;
#else // UNDER_CE
// Set the given key and its value.
BOOL SetKeyAndValue(LPCTSTR pszPath,
                    LPCTSTR szSubkey,
                    LPCTSTR szValue,
                    LPCTSTR szName=NULL) ;

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 LPTSTR szCLSID,
                 int length) ;

// Delete szKeyChild and all of its descendents.
LONG RecursiveDeleteKey(HKEY hKeyParent, LPCTSTR szKeyChild) ;
#endif // UNDER_CE

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
#ifndef UNDER_CE
HRESULT Register(HMODULE hModule,             // DLL module handle
                 const CLSID& clsid,         // Class ID
                 const char* szFriendlyName, // Friendly Name
                 const char* szVerIndProgID, // Programmatic
                 const char* szProgID)         //      IDs
#else // UNDER_CE
HRESULT Register(HMODULE hModule,         // DLL module handle
                 const CLSID& clsid,     // Class ID
                 LPCTSTR szFriendlyName, // Friendly Name
                 LPCTSTR szVerIndProgID, // Programmatic
                 LPCTSTR szProgID)         //      IDs
#endif // UNDER_CE
{
    // Get server location.
#ifndef UNDER_CE
    char szModule[512] ;
    //DWORD dwResult =
        ::GetModuleFileName(hModule, 
                            szModule,
                            sizeof(szModule)/sizeof(char)) ;
#else // UNDER_CE
    TCHAR szModule[512];
    //DWORD dwResult =
        ::GetModuleFileName(hModule, 
                            szModule,
                            sizeof(szModule)/sizeof(TCHAR)) ;
#endif // UNDER_CE

    // Convert the CLSID into a char.
#ifndef UNDER_CE
    char szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;
#else // UNDER_CE
    TCHAR szCLSID[CLSID_STRING_SIZE];
    CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)/sizeof(TCHAR));
#endif // UNDER_CE

    // Build the key CLSID\\{...}
#ifndef UNDER_CE
    char szKey[64] ;
    StringCchCopy(szKey, ARRAYSIZE(szKey), "CLSID\\") ;
    StringCchCat(szKey, ARRAYSIZE(szKey), szCLSID) ;
#else // UNDER_CE
    TCHAR szKey[64] ;
    lstrcpy(szKey, TEXT("CLSID\\")) ;
    lstrcat(szKey, szCLSID) ;
#endif // UNDER_CE
  
    // Add the CLSID to the registry.
    SetKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
#ifndef UNDER_CE
    SetKeyAndValue(szKey, "InprocServer32", szModule) ;
    SetKeyAndValue(szKey,
                   "InprocServer32",
                   "Apartment",
                   "ThreadingModel") ;
#else // UNDER_CE
    SetKeyAndValue(szKey, TEXT("InprocServer32"), szModule) ;
    SetKeyAndValue(szKey,
                   TEXT("InprocServer32"),
                   TEXT("Apartment"),
                   TEXT("ThreadingModel")) ;
#endif // UNDER_CE


    // Add the ProgID subkey under the CLSID key.
#ifndef UNDER_CE
    SetKeyAndValue(szKey, "ProgID", szProgID) ;
#else // UNDER_CE
    SetKeyAndValue(szKey, TEXT("ProgID"), szProgID) ;
#endif // UNDER_CE

    // Add the version-independent ProgID subkey under CLSID key.
#ifndef UNDER_CE
    SetKeyAndValue(szKey, "VersionIndependentProgID",
                   szVerIndProgID) ;
#else // UNDER_CE
    SetKeyAndValue(szKey, TEXT("VersionIndependentProgID"),
                   szVerIndProgID) ;
#endif // UNDER_CE

    // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
#ifndef UNDER_CE
    SetKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
    SetKeyAndValue(szVerIndProgID, "CLSID", szCLSID) ;
    SetKeyAndValue(szVerIndProgID, "CurVer", szProgID) ;
#else // UNDER_CE
    SetKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
    SetKeyAndValue(szVerIndProgID, TEXT("CLSID"), szCLSID) ;
    SetKeyAndValue(szVerIndProgID, TEXT("CurVer"), szProgID) ;
#endif // UNDER_CE

    // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
#ifndef UNDER_CE
    SetKeyAndValue(szProgID, NULL, szFriendlyName) ; 
    SetKeyAndValue(szProgID, "CLSID", szCLSID) ;
#else // UNDER_CE
    SetKeyAndValue(szProgID, NULL, szFriendlyName) ; 
    SetKeyAndValue(szProgID, TEXT("CLSID"), szCLSID) ;
#endif // UNDER_CE

    return S_OK ;
}

//
// Remove the component from the registry.
//

#ifndef UNDER_CE
LONG Unregister(const CLSID& clsid,            // Class ID
                const char* szVerIndProgID, // Programmatic
                const char* szProgID)        //     IDs
#else // UNDER_CE
LONG Unregister(const CLSID& clsid,        // Class ID
                LPCTSTR szVerIndProgID, // Programmatic
                LPCTSTR szProgID)        //     IDs
#endif // UNDER_CE
{
    // Convert the CLSID into a char.
#ifndef UNDER_CE
    char szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;
#else // UNDER_CE
    TCHAR szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)/sizeof(TCHAR));
#endif // UNDER_CE

    // Build the key CLSID\\{...}
#ifndef UNDER_CE
    char szKey[64] ;
    StringCchCopy(szKey, ARRAYSIZE(szKey), "CLSID\\") ;
    StringCchCat(szKey, ARRAYSIZE(szKey), szCLSID) ;
#else // UNDER_CE
    TCHAR szKey[64] ;
    lstrcpy(szKey, TEXT("CLSID\\")) ;
    lstrcat(szKey, szCLSID) ;
#endif // UNDER_CE

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = RecursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;

    // Delete the version-independent ProgID Key.
    lResult = RecursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
    // Delete the ProgID key.
    lResult = RecursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
    return S_OK ;
}

void SelfRegisterCategory(BOOL bRegister,
                          const CATID     &catId, 
                          REFCLSID    clsId)
{
#ifndef UNDER_CE
    CHAR szCLSID[256];
    CHAR szKey[1024];
    CHAR szSub[1024];
    CLSIDtochar(clsId, szCLSID, sizeof(szCLSID));
    StringCchPrintf(szKey, ARRAYSIZE(szKey), "CLSID\\%s\\Implemented Categories", szCLSID); 
    CLSIDtochar(catId, szSub, sizeof(szSub));
#else // UNDER_CE
    TCHAR szCLSID[256];
    TCHAR szKey[1024];
    TCHAR szSub[1024];
    CLSIDtochar(clsId, szCLSID, sizeof(szCLSID)/sizeof(TCHAR));
    wsprintf(szKey, TEXT("CLSID\\%s\\Implemented Categories"), szCLSID); 
    CLSIDtochar(catId, szSub, sizeof(szSub)/sizeof(TCHAR));
#endif // UNDER_CE
    SetKeyAndValue(szKey, 
                   szSub,
                   NULL,
                   NULL);
    return;
    UNREFERENCED_PARAMETER(bRegister);
}
void RegisterCategory(BOOL bRegister,
                      const CATID     &catId, 
                      REFCLSID    clsId)
{
    // Create the standard COM Category Manager
    ICatRegister* pICatRegister = NULL ;
    HRESULT hr = ::CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                                    NULL, CLSCTX_ALL, IID_ICatRegister,
                                    (void**)&pICatRegister) ;
    if (FAILED(hr)){
        //ErrorMessage("Could not create the ComCat component.", hr);
        SelfRegisterCategory(bRegister, catId, clsId);
        return ;
    }

    // Array of Categories
    int cIDs = 1 ;
    CATID IDs[1] ;
    IDs[0] = catId;

    // Register or Unregister
    if(bRegister) {
        hr = pICatRegister->RegisterClassImplCategories(clsId,
                                                        cIDs, IDs);
        //ASSERT_HRESULT(hr) ; 
    }
    else {
        // Unregister the component from its categories.
        hr = pICatRegister->UnRegisterClassImplCategories(clsId,
                                                          cIDs, IDs);
    }
    if(pICatRegister) {
        pICatRegister->Release() ;
    }
}


///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
#ifndef UNDER_CE
void CLSIDtochar(const CLSID& clsid,
                 char* szCLSID,
                 int length)
#else // UNDER_CE
void CLSIDtochar(const CLSID& clsid,
                 LPTSTR szCLSID,
                 int length)
#endif // UNDER_CE
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    //HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    StringFromCLSID(clsid, &wszCLSID);

    if (wszCLSID != NULL)
        {
        // Covert from wide characters to non-wide.
#ifndef UNDER_CE // #ifndef UNICODE
        wcstombs(szCLSID, wszCLSID, length);
#else // UNDER_CE
        wcsncpy(szCLSID, wszCLSID, length);
        szCLSID[length-1] = TEXT('\0');
#endif // UNDER_CE

        // Free memory.
        CoTaskMemFree(wszCLSID) ;
        }
}

//
// Delete a key and all of its descendents.
//
#ifndef UNDER_CE
LONG RecursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const char* lpszKeyChild)  // Key to delete
#else // UNDER_CE
LONG RecursiveDeleteKey(HKEY hKeyParent,       // Parent of key to delete
                        LPCTSTR lpszKeyChild)  // Key to delete
#endif // UNDER_CE
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
                             KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
#ifndef UNDER_CE
    char szBuffer[256] ;
#else // UNDER_CE
    TCHAR szBuffer[256];
#endif // UNDER_CE
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
                        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = RecursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//     - This helper function was borrowed and modifed from
//       Kraig Brockschmidt's book Inside OLE.
//
#ifndef UNDER_CE
BOOL SetKeyAndValue(const char* szKey,
                    const char* szSubkey,
                    const char* szValue, 
                    const char* szName)
#else // UNDER_CE
BOOL SetKeyAndValue(LPCTSTR szKey,
                    LPCTSTR szSubkey,
                    LPCTSTR szValue,
                    LPCTSTR szName)
#endif // UNDER_CE
{
    HKEY hKey;
#ifndef UNDER_CE
    char szKeyBuf[1024] ;
#else // UNDER_CE
    TCHAR szKeyBuf[1024];
#endif // UNDER_CE

    // Copy keyname into buffer.
#ifndef UNDER_CE
    StringCchCopyA(szKeyBuf, ARRAYSIZE(szKeyBuf), szKey);
#else // UNDER_CE
    lstrcpy(szKeyBuf, szKey);
#endif // UNDER_CE

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
#ifndef UNDER_CE
        StringCchCat(szKeyBuf, ARRAYSIZE(szKeyBuf), "\\") ;
        StringCchCat(szKeyBuf, ARRAYSIZE(szKeyBuf), szSubkey ) ;
#else // UNDER_CE
        lstrcat(szKeyBuf, TEXT("\\")) ;
        lstrcat(szKeyBuf, szSubkey ) ;
#endif // UNDER_CE
    }

    // Create and open key and subkey.
#ifndef UNDER_CE
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
                                  szKeyBuf, 
                                  0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS, NULL, 
                                  &hKey, NULL) ;
#else // UNDER_CE
    DWORD dwDisposition; // Under WinCE, Must set lpdwDisposition.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                  szKeyBuf,
                                  0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS, NULL, 
                                  &hKey, &dwDisposition);
#endif // UNDER_CE
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
#ifndef UNDER_CE
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
                      (BYTE *)szValue, 
                      lstrlen(szValue)+1) ;
#else // UNDER_CE
        RegSetValueEx(hKey, szName, 0, REG_SZ,
                      (BYTE *)szValue,
                      (lstrlen(szValue)+1) * sizeof(TCHAR));
#endif // UNDER_CE
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\recog.h ===
/***************************************************************************\
*
* RECOG.H - Handwriting functions, types, and definitions
*
*	Version 1.1
*
*	Copyright (c) 1992-1998 Microsoft Corp. All rights reserved.
*
\***************************************************************************/

#ifndef _INC_RECOG
#define _INC_RECOG

// @CESYSGEN IF CE_MODULES_HWXUSA || CE_MODULES_HWXJPN

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* Suggested sequence for using these APIs:
 *
 *	HwxConfig (once only)
 *		HwxCreate (once per recognition panel)
 *		HwxSetGuide
 *		HwxSetAlphabet
 *		HwxSetContext	(if there is a previous character)
 *			HwxInput	(as the user writes)
 *			HwxProcess  (to process the ink input)
 *			HwxResultsAvailable (find out if new results are available)
 *				HwxGetResults   (every time there are any results available)
 *		HwxEndInput (when user is done inputting ink)
 *		HwxProcess  (to process the ink input)
 *		HwxGetResults (to get the last characters)
 *		HwxDestroy
 */

// The constants below are used with HWXSetAlphabet().  These specify which
// character groupings to recognize.
#define ALC_WHITE			0x00000001	// White space.
#define ALC_LCALPHA			0x00000002	// a..z
#define ALC_UCALPHA			0x00000004	// A..Z
#define ALC_NUMERIC			0x00000008	// 0..9
#define ALC_PUNC			0x00000010	// Standard punc., language dependent.
#define	ALC_NUMERIC_PUNC	0x00000020	// Non digit characters in numbers.
#define ALC_MATH			0x00000040	// %^*()-+={}<>,/.  (??? language dependent ???)
#define ALC_MONETARY		0x00000080	// Punct. in local monetary expressions.
#define	ALC_COMMON_SYMBOLS	0x00000100	// Commonly used symbols from all categories.
#define ALC_OTHER			0x00000200	// Other punctuation not typically used.
#define ALC_ASCII			0x00000400	// 7-bit chars 20..7F
#define ALC_HIRAGANA		0x00000800	// Hiragana (JPN)
#define ALC_KATAKANA		0x00001000	// Katakana (JPN)
#define ALC_KANJI_COMMON	0x00002000	// Common Kanji (JPN)
#define ALC_KANJI_RARE		0x00004000	// Common Kanji (JPN)
#define	ALC_HANGUL_COMMON	0x00008000	// Common Hangul used in Korea.
#define	ALC_HANGUL_RARE		0x00010000	// The rest of the Hangul used in Korea.
#define ALC_UNUSED			0x00FE0000	// Reserved for future use.
#define ALC_OEM				0xFF000000	// OEM recognizer-specific.

// Useful groupings

#define ALC_ALPHA			(ALC_LCALPHA | ALC_UCALPHA)
#define ALC_ALPHANUMERIC	(ALC_ALPHA | ALC_NUMERIC)
#define	ALC_KANA			(ALC_HIRAGANA | ALC_KATAKANA)
#define	ALC_KANJI_ALL		(ALC_KANJI_COMMON | ALC_KANJI_RARE)
#define	ALC_HANGUL_ALL		(ALC_HANGUL_COMMON | ALC_HANGUL_RARE)
#define	ALC_EXTENDED_SYM	(ALC_MATH | ALC_MONETARY | ALC_OTHER)
#define ALC_SYS_MINIMUM		(ALC_ALPHANUMERIC | ALC_PUNC | ALC_WHITE)
#define ALC_SYS_DEFAULT		(ALC_SYS_MINIMUM | ALC_COMMON_SYMBOLS)

// Standard configurations for various languages.

#define	ALC_USA_COMMON		(ALC_SYS_DEFAULT)
#define	ALC_USA_EXTENDED	(ALC_USA_COMMON | ALC_EXTENDED_SYM)

#define	ALC_JPN_COMMON		(ALC_SYS_DEFAULT | ALC_KANA | ALC_KANJI_COMMON)
#define	ALC_JPN_EXTENDED	(ALC_JPN_COMMON | ALC_EXTENDED_SYM | ALC_KANJI_RARE)

#define	ALC_CHS_COMMON		(ALC_SYS_DEFAULT | ALC_KANJI_COMMON)
#define	ALC_CHS_EXTENDED	(ALC_CHS_COMMON | ALC_EXTENDED_SYM | ALC_KANJI_RARE)

#define	ALC_CHT_COMMON		(ALC_SYS_DEFAULT | ALC_KANJI_COMMON)
#define	ALC_CHT_EXTENDED	(ALC_CHT_COMMON | ALC_EXTENDED_SYM | ALC_KANJI_RARE)

#define	ALC_KOR_COMMON		(ALC_SYS_DEFAULT | ALC_HANGUL_COMMON | ALC_KANJI_COMMON)
#define	ALC_KOR_EXTENDED	(ALC_KOR_COMMON | ALC_EXTENDED_SYM | ALC_HANGUL_RARE | ALC_KANJI_RARE)

// Define ALC mask type.
typedef LONG				ALC;		// Enabled Alphabet
typedef ALC					*PALC;		// ptr to ALC

// Handwriting Recognizer:
DECLARE_HANDLE(HRC);			// Handwriting Recognition Context

typedef HRC			*PHRC;

// Filled in by HwxGetResults().
// The rgChar array is actually a variable sized array of alternate results.  The number of
// alternates is passed into HwxGetResults().
typedef struct tagHWXRESULTS {
    USHORT	indxBox;		// zero-based index into guide structure where char was written
	WCHAR	rgChar[1];		// variable-sized array of characters returned
} HWXRESULTS, *PHWXRESULTS;

// Passed in to HwxSetGuide().  Specifies where the boxes are on the screen.
// All positions are in scaled screen coordinates.  You should do the scaling so
// that cyWriting is around 1000.  To avoid speed and rounding problems you should
// use an integral multiple of your actual size.
// JRB: FIXME: Check description above is correct!!!
// NOTE: the current code requires that the writing area be centered.  E.g. You
// need to set cxBox, cxOffset and cxWriting such that:
//		cxBox == 2 * cxOffset + cxWriting
typedef struct tagHWXGUIDE {
	// Number of input boxes in each direction.
	UINT	cHorzBox;
	UINT	cVertBox;

	// Upper left corner of input area.
	INT		xOrigin;
	INT		yOrigin;

	// Width and height of a single box.
	UINT	cxBox;
	UINT	cyBox;

	// Offset within a box to the upper left of the writing area.
	UINT	cxOffset;
	UINT	cyOffset;

	// Width and height of writing area.
	UINT	cxWriting;
	UINT	cyWriting;

	// Baseline and midline information for western alphabets.  They are measured from
	// the top of the writing area.  These fields are not used and must be set to zero
	// for the Far East languages (Japanese, Chinese, and Korean).  They must be set to
	// the correct values for English or any other language based on Latin letters.
	UINT	cyMid;
	UINT	cyBase;

	// Writing direction
	UINT	nDir;
} HWXGUIDE, *PHWXGUIDE;

// The following are the currently planned handwriting directions.  Note that a given recognizer
// may not support the requested direction, if this is the case, HwxSetGuide will return an error.

#define	HWX_HORIZONTAL		0
#define	HWX_BIDIRECTIONAL	1
#define	HWX_VERTICAL		2

// For FE recognizers we would like to be able to enter partial characters and have the recognizer
// attempt to 'fill in the gaps'.  This is most useful for difficult or rare characters with many
// strokes.  The following values can be passed to HwxSetPartial

#define	HWX_PARTIAL_ALL			0			// The whole character must be written (default)
#define	HWX_PARTIAL_ORDER		1			// The stroke order does matter 
#define	HWX_PARTIAL_FREE		2			// The stroke order doesn't matter

// Called once to initialize DLL.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxConfig();

// Called to create an HRC before any ink is collected. You can pass in NULL
// for the parameter, but if you pass in an old HRC, it copies the old settings (such
// as alphabet, guide structure, previous context, etc.)
// JRB: FIXME: Make above description of what's copied clearer.
// On failure, use GetLastError() to identify the cause of the error.
HRC		WINAPI HwxCreate(HRC);

// Called to destroy an HRC after recognition is complete.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxDestroy(HRC);

// Tells the HRC where the boxes on the screen are.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxSetGuide(HRC, HWXGUIDE *);

// Limits the set of characters the recognizer can return.  (See ALC values above.)
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxALCValid(HRC, ALC);

// Reorders the characters the recognizer returns so that selected characters
// appear at the top of the list.  (See ALC values above.)
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxALCPriority(HRC, ALC);

// Sets parameter for partial recognition.
// On failure, use GetLastError() to identify the cause of the error.
// JRB: FIXME: Need to define the legal values for second argument.
BOOL	WINAPI HwxSetPartial(HRC, UINT);

// Sets abort address.  If the number of strokes currently doesn't match the value
// written at the address, the current recognition is halted.  This only works for
// HwxSetPartial modes HWX_PARTIAL_FRONT and HWX_PARTIAL_ANY
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxSetAbort(HRC, UINT *);

// Adds ink to the HRC.
// Takes the HRC, the array of points, the count of points, and 
// the time stamp of the first mouse event in the stroke.  The
// time stamp should be taken directly from the MSG structure
// for the mouse down event.  The points should be scaled to
// match the guide structure.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxInput(HRC, POINT *, UINT, DWORD);

// Called after last ink is added.  You cannot add anymore ink
// to the HRC after this has been called.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxEndInput(HRC);

// Recognizes as much ink as it can.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxProcess(HRC);

// Retrieves the results from an HRC. This may be called repeatedly. This allows you
// to get results for several characters at a time. The return value is the number of
// characters actually returned.  The results for those characters are put in the
// rgBoxResults buffer that was passed in.
// Returns -1 on error.
// On failure, use GetLastError() to identify the cause of the error.
INT		WINAPI HwxGetResults(
	HRC			hrc,			// HRC containing results
	UINT		cAlt,			// number of alternates
	UINT		iFirst,			// index of first character to return
	UINT		cBoxRes,		// number of characters to return
	HWXRESULTS	*rgBoxResults	// array of cBoxRes ranked lists
);

// Tells the HRC what the previous character was for context purposes.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxSetContext(HRC, WCHAR);

// Tells you how many results can be retrieved from HwxGetResults.
// Returns -1 on error.
// On failure, use GetLastError() to identify the cause of the error.
INT		WINAPI HwxResultsAvailable(HRC);

#ifdef __cplusplus
}
#endif // __cplusplus

// @CESYSGEN ENDIF
 
#endif // #define _INC_RECOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imembx\registry.h ===
#ifndef __REGISTRY_H__
#define __REGISTRY_H__
#ifndef UNDER_CE
HRESULT Register(HMODULE hModule, 
				 const CLSID& clsid, 
				 const char* szFriendlyName,
				 const char* szVerIndProgID,
				 const char* szProgID) ;

HRESULT Unregister(const CLSID& clsid,
				   const char* szVerIndProgID,
				   const char* szProgID) ;
#else // UNDER_CE
HRESULT Register(HMODULE hModule, 
				 const CLSID& clsid, 
				 LPCTSTR szFriendlyName,
				 LPCTSTR szVerIndProgID,
				 LPCTSTR szProgID) ;

HRESULT Unregister(const CLSID& clsid,
				   LPCTSTR szVerIndProgID,
				   LPCTSTR szProgID) ;
#endif // UNDER_CE

VOID RegisterCategory(BOOL bRegister,
					  const CATID     &catId, 
					  REFCLSID	clsId);

#endif //__REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\imeskdic\imeskdic.h ===
#ifndef _IME_SK_DIC_H_
#define _IME_SK_DIC_H_
#include <windows.h>
#include <objbase.h>

#define MAX_YOMI_COUNT		16
#define MAX_ITAIJI_COUNT	16
#define MAX_RADYOMI_COUNT	32	//970930


#define KIF_STROKECOUNT		0x0001
#define KIF_RADICALBMP		0x0002
#define KIF_YOMI			0x0004
#define KIF_ITAIJI			0x0008
#define KIF_RADICALINDEX	0x0010	//980615: ToshiaK new for Raid #1966
#define KIF_ALL				0x000F


#pragma pack(1)
typedef struct tagKANJIINFO {
	INT			mask;
	WCHAR		wchKanji;
	USHORT		usTotalStroke;
	HBITMAP		hBmpRadical;
	LONG		lRadicalIndex;
	WCHAR		wchOnYomi1[MAX_YOMI_COUNT+1];
	WCHAR		wchOnYomi2[MAX_YOMI_COUNT+1];
	WCHAR		wchKunYomi1[MAX_YOMI_COUNT+1];
	WCHAR		wchKunYomi2[MAX_YOMI_COUNT+1];
	INT			cItaijiCount;
	WCHAR		wchItaiji[MAX_ITAIJI_COUNT];
	ULONG		ulRes1;
	ULONG		ulRes2;
}KANJIINFO, *LPKANJIINFO ;

#define RIF_STROKECOUNT		0x0001
#define RIF_BITMAP			0x0002
#define RIF_KANJICOUNT		0x0004
#define RIF_READING			0x0008
#ifdef MSAA
#define RIF_RADICALINDEX	0x0010	//980817: kwada to get id of radical bitmap.
#endif

typedef struct tagRadicalInfo {
	INT		mask;
	INT		stroke;
	HBITMAP	hBitmap;
#ifdef MSAA
	LONG	lRadicalIndex; 	//980817: kwada to get id of radical bitmap.
#endif
	INT		cKanjiCount;
	WCHAR	wchReading[MAX_RADYOMI_COUNT+1];
}RADICALINFO, *LPRADICALINFO;


#ifdef __cplusplus
extern "C" {
#endif

DECLARE_INTERFACE_(IImeSkdic, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
	STDMETHOD(GetKanjiInfo)(THIS_ WCHAR wchKanjiCode, LPKANJIINFO lpKInfo) PURE;

	STDMETHOD_(INT, GetMaxRadicalStrokeCount)	(THIS) PURE;
	STDMETHOD_(INT, GetRadicalCountByStroke)	(THIS_ INT stroke) PURE;
	STDMETHOD(GetRadicalByStrokeIndex)			(THIS_ INT stroke, 
												 INT index, 
												 LPRADICALINFO lpRadInfo) PURE;
	STDMETHOD(GetKanjiCountByRadicalStrokeIndex)(THIS_ INT radStroke, INT index) PURE;
	STDMETHOD(GetKanjiInfoByRadicalStrokeIndex)	(THIS_ INT radStroke,
												 INT index,
												 INT kanjiIndex,
												 LPKANJIINFO lpKInfo) PURE;
	STDMETHOD_(INT, GetMaxStrokeCount)			(THIS) PURE;
	STDMETHOD_(INT, GetKanjiCountByStroke)		(THIS_ INT stroke) PURE;
	STDMETHOD(GetKanjiInfoByStrokeIndex)		(THIS_ INT stroke,
												 INT index,
												 LPKANJIINFO lpKInfo) PURE;
};

#pragma pack()

#ifdef __cplusplus
};
#endif
#endif //_IME_SK_DIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\include\cpadsvrc.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvr.cpp
// Purpose  :	
// 
// 
// Date     :	Fri Apr 16 15:39:33 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifdef UNDER_CE // stub for CE
#include "stub_ce.h"
#endif // UNDER_CE
#include "imepadsv.h"
#include "cpadsvrc.h"
#include "cpadcb.h"
#include "cpaddbg.h"

//----------------------------------------------------------------
//misc definition
//----------------------------------------------------------------
#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)
inline LPVOID
WinSetUserPtr(HWND hwnd, LPVOID lpVoid)
{
#ifdef _WIN64	
	return (LPVOID)SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpVoid);
#else
	return (LPVOID)SetWindowLong(hwnd, GWL_USERDATA, (LONG)lpVoid);
#endif
}

inline LPVOID
WinGetUserPtr(HWND hwnd)
{
#ifdef _WIN64	
	return (LPVOID)GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	return (LPVOID)GetWindowLong(hwnd, GWL_USERDATA);
#endif
}

//----------------------------------------------------------------
//
//public method decalre
//
//----------------------------------------------------------------
CImePadSvrCOM::CImePadSvrCOM(VOID)
{
	Dbg(("CImePadSvrCOM::CImePadSvrCOM() constructor START\n"));
	m_fShowReqStatus	= FALSE;
	m_fLastActiveCtx	= FALSE;
	m_hwndIF			= NULL;
	m_lpIUnkIImeIPoint	= NULL;
	m_lpIUnkIImeCallback= NULL;
	m_lpIImePadServer	= NULL;
	m_lpCImePadCallback	= NULL;
	m_dwRegAdvise		= 0;
	m_fCoInitSuccess	= FALSE;
	Dbg(("CImePadSvrCOM::CImePadSvrCOM() constructor END\n"));
}

CImePadSvrCOM::~CImePadSvrCOM(VOID)
{
	Dbg(("CImePadSvrCOM::CImePadSvrCOM() Destructor START\n"));
	this->TermOleAPI();
	this->DestroyIFHWND(TRUE);
	m_fShowReqStatus	= FALSE;
	m_fLastActiveCtx	= FALSE;
	m_hwndIF			= NULL;
	m_lpIUnkIImeIPoint	= NULL;
	m_lpIUnkIImeCallback= NULL;
	m_lpIImePadServer	= NULL;
	m_lpCImePadCallback	= NULL;
	m_dwRegAdvise		= 0;
	m_fCoInitSuccess	= FALSE;
	Dbg(("CImePadSvrCOM::CImePadSvrCOM() Destructor END\n"));
}

INT
CImePadSvrCOM::ForceDisConnect(VOID)
{
	Dbg(("CImePadSvrCOM::ForceDisConnect START\n"));
	if(m_lpIImePadServer) {
		m_lpIImePadServer = NULL;
		if(m_lpCImePadCallback) {
			m_lpCImePadCallback->Release();
			m_lpCImePadCallback = NULL;
		}
	}
	this->DestroyIFHWND(TRUE);
	Dbg(("CImePadSvrCOM::ForceDisConnect END\n"));
	return 0;
}

BOOL
CImePadSvrCOM::IsCoInitialized(VOID)
{
	return m_fCoInitSuccess;
}

BOOL
CImePadSvrCOM::IsAvailable(VOID)
{
	return TRUE;
}

BOOL
CImePadSvrCOM::OnIMEPadClose(VOID)
{
	m_fShowReqStatus = FALSE;
	return 0;
}

INT
CImePadSvrCOM::Initialize(LANGID imeLangID,
					   DWORD	dwImeInputID,
					   LPVOID lpVoid)
{
	HRESULT hr;
	if(!this->InitOleAPI()) {
		return -1;
	}
	if(!m_fCoInitSuccess) {
		hr = (*m_fnCoInitialize)(NULL);
		if(hr == S_OK) {
			m_fCoInitSuccess = TRUE;
		}
	}
	if(m_lpIImePadServer) {
		Dbg(("CImePadSvrCOM::Initialize() already Initialized\n"));
		return 0;
	}

	if(!m_fnCoCreateInstance) {
		return -1;
	}
	hr = (*m_fnCoCreateInstance)(CLSID_IImePadServerComponent,
								 NULL,
								 CLSCTX_LOCAL_SERVER,
								 IID_IImePadServer, 
								 (LPVOID *)&m_lpIImePadServer);
	if(!SUCCEEDED(hr)) {
		Dbg(("CImePadSvrCOM::Initialize() Error[0x%08x]\n", hr));
		return -1;
	}
	if(!m_lpIImePadServer) {
		Dbg(("CImePadSvrCOM::m_lpIImePadServer is NULL\n"));
		return -1;
	}
	m_lpCImePadCallback = new CImePadCallback(m_hwndIF, this);
	if(!m_lpCImePadCallback) {
		Dbg(("m_lpCImePadCallback is NULL\n"));
		return -1;
	}
	m_lpCImePadCallback->AddRef();
#if 0
	hr = m_lpIImePadServer->Initialize(::GetCurrentProcessId(),
									   ::GetCurrentThreadId(),
									   imeLangID,
									   dwImeInputID,
									   m_lpCImePadCallback,
									   &m_dwRegAdvise,
									   0,
									   0);
#endif
	Dbg(("CImePadSvrCOM::Initialize() Initialize ret[0x%08x]\n", hr));
	
	this->CreateIFHWND();	//Create internal Interface Window.
	return 0;
	Unref(imeLangID);
	Unref(lpVoid);
}

INT
CImePadSvrCOM::Terminate(LPVOID)
{
	Dbg(("CImePadSvrCOM::::Terminate() START \n"));
	HRESULT hr = S_OK;
	if(m_lpIImePadServer) {
		hr = m_lpIImePadServer->Terminate(m_dwRegAdvise, 0);
		if(SUCCEEDED(hr)) {
			m_dwRegAdvise = 0;
			if(m_lpCImePadCallback) {
				delete m_lpCImePadCallback;
				m_lpCImePadCallback = NULL;
			}
			hr = m_lpIImePadServer->Release();
			m_lpIImePadServer = NULL;
		}
		else {
			DBGShowError(hr, "IImePad::Terminate");
			//Dbg(("Call CoDisconnectObject()\n"));
			//::CoDisconnectObject((IUnknown *)m_lpIImePadServer, 0);
			m_lpIImePadServer = NULL;
		}
	}

	//----------------------------------------------------------------
	//if server has downed, some times CoUninitialize() cause GPF.
	//First we should check what is the real problem, 
	//And remove GPF Bug with code. 
	//After that, for warrent, we should use _try/exception code.
	//----------------------------------------------------------------

	Dbg(("Call Uninitialize\n"));

	if(m_fnCoUninitialize && m_fCoInitSuccess) {
		Dbg(("Call CoUninitialize()\n"));
		(*m_fnCoUninitialize)();
		m_fCoInitSuccess = FALSE;
	}
	Dbg(("-->CoUninitialize End\n"));
	this->TermOleAPI();


#ifdef _RELEASEMODULE
	__try {
		if(m_fnCoUninitialize && m_fCoInitSuccess) {
			Dbg(("Call CoUninitialize()\n"));
			(*m_fnCoUninitialize)();
			m_fCoInitSuccess = FALSE;
		}
		this->TermOleAPI();
	}
	__except(EXCEPTION_EXECUTE_HANDLER) {
		
		Dbg(("########################################################\n"));
		Dbg(("#### CoUninitialize() CAUSE EXCEPTION!!!!!!!            \n"));
		Dbg(("########################################################\n"));
	}
#endif
	this->DestroyIFHWND(TRUE);

	Dbg(("CImePadSvrCOM::Terminate() End\n"));
	return 0;
}


INT
CImePadSvrCOM::ShowUI(BOOL fShow)
{
	if(m_lpIImePadServer) {
		m_lpIImePadServer->ShowUI(fShow);
	}
	m_fShowReqStatus = fShow;
	return 0;
}

INT
CImePadSvrCOM::IsVisible(BOOL *pfVisible)
{
	return 0;
	Unref(pfVisible);
}

INT
CImePadSvrCOM::ActivateApplet(UINT activateID,
						  DWORD dwActivateParam,
						  LPWSTR lpwstr1,
						  LPWSTR lpwstr2)
{
	return 0;
	Unref(activateID);
	Unref(dwActivateParam);
	Unref(lpwstr1);
	Unref(lpwstr2);
}

INT
CImePadSvrCOM::Notify(INT id, WPARAM wParam, LPARAM lParam)
{
	switch(id) {
	case IMEPADNOTIFY_ACTIVATECONTEXT:
		Dbg(("CImePadSvrCOM::Notify: ActivateContext\n"));
		m_fLastActiveCtx = (BOOL)wParam;
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_ACTIVATECONTEXT);
		if(m_fLastActiveCtx) {
			::SetTimer(m_hwndIF,
					   TIMERID_NOTIFY_ACTIVATECONTEXT,
					   TIMERELAPS_ACTIVATE,
					   NULL);
		}
		else {
			::SetTimer(m_hwndIF,
					   TIMERID_NOTIFY_ACTIVATECONTEXT,
					   TIMERELAPS_INACTIVATE,
					   NULL);
		}
		break;
	case IMEPADNOTIFY_MODECHANGED:
		break;
	case IMEPADNOTIFY_STARTCOMPOSITION:
		break;
	case IMEPADNOTIFY_COMPOSITION:
		break;
	case IMEPADNOTIFY_ENDCOMPOSITION:
		break;
	case IMEPADNOTIFY_OPENCANDIDATE:
		break;
	case IMEPADNOTIFY_CLOSECANDIDATE:
		break;
	case IMEPADNOTIFY_APPLYCANDIDATE:
		break;
	case IMEPADNOTIFY_QUERYCANDIDATE:
		break;
	case IMEPADNOTIFY_APPLYCANDIDATE_EX:
		break;
	default:
		if(m_lpIImePadServer) {
			m_lpIImePadServer->Notify(id, wParam, lParam);
		}
		break;
	}
	return 0;
	Unref(wParam);
	Unref(lParam);
}

INT
CImePadSvrCOM::GetAppletInfoList(INT *pCountApplet, LPVOID *pList)
{
	return 0;
	Unref(pCountApplet);
	Unref(pList);
}


IUnknown *
CImePadSvrCOM::SetIUnkIImeIPoint(IUnknown *pIUnkIImeIPoint)
{
	return m_lpIUnkIImeIPoint = pIUnkIImeIPoint;
}

IUnknown *
CImePadSvrCOM::SetIUnkIImeCallback(IUnknown *pIUnkIImeCallback)
{
	return m_lpIUnkIImeCallback = pIUnkIImeCallback;
}

IUnknown*
CImePadSvrCOM::GetIUnkIImeIPoint(VOID)
{
	return m_lpIUnkIImeIPoint;
}

IUnknown*
CImePadSvrCOM::GetIUnkIImeCallback(VOID)
{
	return m_lpIUnkIImeCallback;
}

//----------------------------------------------------------------
//
//private static method
//
//----------------------------------------------------------------
LRESULT CALLBACK
CImePadSvrCOM::InterfaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPCImePadSvrCOM lpCImePadSvr = NULL;
	switch(uMsg) {
	case WM_NCCREATE:
		lpCImePadSvr = (LPCImePadSvrCOM)((LPCREATESTRUCT)lParam)->lpCreateParams;
		WinSetUserPtr(hwnd, (LPVOID)lpCImePadSvr);
		break;
	case WM_NCDESTROY:
		WinSetUserPtr(hwnd, (LPVOID)NULL);
		break;
	default:
		lpCImePadSvr = (LPCImePadSvrCOM)WinGetUserPtr(hwnd);
		if(lpCImePadSvr) {
			return lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT
CImePadSvrCOM::RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg) {
	case WM_COPYDATA:
		return MsgCopyData(hwnd, wParam, lParam);
	case WM_TIMER:
		return MsgTimer(hwnd, wParam, lParam);
	case WM_USER+500:
		return MsgUser(hwnd, wParam, lParam);
	default:
		break;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT
CImePadSvrCOM::MsgCopyData(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	return 0;
	Unref(hwnd);
	Unref(wParam);
	Unref(lParam);
}

LRESULT
CImePadSvrCOM::MsgTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	switch(wParam) {
	case TIMERID_NOTIFY_ACTIVATECONTEXT:
		::KillTimer(hwnd, wParam);
		if(m_lpIImePadServer) {
			//try try try..
#if 0
			if(!m_fLastActiveCtx) { //Inactivate case
				HWND hwndFG;
				DWORD dwTID, dwPID, dwPIDFG, dwTIDFG;
				hwndFG  = ::GetForegroundWindow();
				dwTIDFG = ::GetWindowThreadProcessId(hwndFG, &dwPIDFG);
				dwTID   = ::GetCurrentThreadId();
				dwPID   = ::GetCurrentProcessId();
				TCHAR szClass[256];
				::GetClassName(hwndFG, szClass, sizeof(szClass));
				Dbg(("FG class [%s]\n", szClass));
				if(dwTIDFG == dwTID) {
					return 0;
				}
				else {
					m_lpIImePadServer->Notify(IMEPADNOTIFY_ACTIVATECONTEXT,
											 (WPARAM)FALSE,
											 0);
				}
			}
#endif
			m_lpIImePadServer->Notify(IMEPADNOTIFY_ACTIVATECONTEXT,
									 (WPARAM)m_fLastActiveCtx,
									 0);
		}
		break;
	default:
		::KillTimer(hwnd, wParam);
		break;
	}
	return 0;
	Unref(hwnd);
	Unref(wParam);
	Unref(lParam);
}

LRESULT
CImePadSvrCOM::MsgUser(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	return 0;
	Unref(hwnd);
	Unref(wParam);
	Unref(lParam);
}

HWND
CImePadSvrCOM::CreateIFHWND(VOID)
{
	return NULL;
#if 0
	Dbg(("CImePadSvrCOM::CreateIFHWND START\n"));
	if(m_hwndIF && ::IsWindow(m_hwndIF)) {
		return m_hwndIF;
	}
	ATOM atom;
	HWND hwnd;

#ifndef UNDER_CE // No Ex
	WNDCLASSEX wc;
#else // UNDER_CE
	WNDCLASS wc;
#endif // UNDER_CE

#ifndef UNDER_CE // No Ex
	wc.cbSize = sizeof(wc);
#endif // UNDER_CE
	wc.style			= 0;
	wc.lpfnWndProc		= (WNDPROC)CImePadSvrCOM::InterfaceWndProc;
	wc.cbClsExtra		= 0;
	wc.cbWndExtra		= 0; 
	wc.hInstance		= m_ghModClient;
	wc.hIcon			= (HICON)NULL;
	wc.hCursor			= (HCURSOR)NULL; 
	wc.hbrBackground	= (HBRUSH)NULL;
	wc.lpszMenuName		= NULL;
	wc.lpszClassName	= SZ_IMEPADCLIENTCLASS;
#ifndef UNDER_CE // No Ex
	wc.hIconSm			= NULL;

	atom = ::RegisterClassEx(&wc);
#else // UNDER_CE
	atom = ::RegisterClass(&wc);
#endif // UNDER_CE
	hwnd = ::CreateWindowEx(0,
							SZ_IMEPADCLIENTCLASS,
							NULL,
							WS_POPUP | WS_DISABLED,
							0,0,0,0,
							NULL,
							NULL,
							m_ghModClient,
							(LPVOID)this);
	if(!hwnd) {
		Dbg(("CreateWindowEx Error %d\n", GetLastError()));
	}
	m_hwndIF = hwnd;
	Dbg(("CImePadSvrCOM::CreateIFHWND END\n"));
	return hwnd;
#endif
}

BOOL
CImePadSvrCOM::DestroyIFHWND(BOOL fReserved)
{
	Dbg(("CImePadSvrCOM::DestroyIFHWND() START\n"));
#if 0
	if(m_hwndIF && ::IsWindow(m_hwndIF)) {
		::DestroyWindow(m_hwndIF);
		m_hwndIF = NULL;
	}
	//Must Unregister class. 
	BOOL fRet = ::UnregisterClass(SZ_IMEPADCLIENTCLASS, m_ghModClient);
	if(!fRet) {
		Dbg(("UnregisterClass Failed [%d]\n", GetLastError()));
	}

	Dbg(("CImePadSvrCOM::DestroyIFHWND() END\n"));
#endif
	return TRUE;
	Unref(fReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\include\iimecb.h ===
#ifndef __I_IME_CALLBACK_H__
#define __I_IME_CALLBACK_H__
#include <windows.h>
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------
// Interface Declaration
//
// {67419A52-0ECD-11d3-83FC-00C04F7A06E5}
DEFINE_GUID(IID_IImeCallback,
0x67419a52, 0xecd, 0x11d3, 0x83, 0xfc, 0x0, 0xc0, 0x4f, 0x7a, 0x6, 0xe5);

DECLARE_INTERFACE(IImeCallback);
DECLARE_INTERFACE_(IImeCallback,IUnknown)
{
	//--- IUnknown ---
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
	//---- IImeCallback ----
	STDMETHOD(GetApplicationHWND)(THIS_ HWND *pHWND) PURE;
	STDMETHOD(Notify)(THIS_ UINT notify, WPARAM wParam, LPARAM lParam) PURE;
};

//----------------------------------------------------------------
// IImeCallback::Notify()'s notify
// IMECBNOTIFY_IMEPADOPENED
// WPARAM wParam: not used. always 0
// LPARAM lParam: not used. always 0
//----------------------------------------------------------------
#define IMECBNOTIFY_IMEPADOPENED	0

//----------------------------------------------------------------
// IImeCallback::Notify()'s notify
// IMECBNOTIFY_IMEPADCLOSED
// WPARAM wParam: not used. always 0
// LPARAM lParam: not used. always 0
//----------------------------------------------------------------
#define IMECBNOTIFY_IMEPADCLOSED	1



#ifdef __cplusplus
};
#endif
#endif //__I_IME_CALLBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\include\cpadsvrc.h ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvrc.h
// Purpose  :	CImePadServer for COM(Component Object Model) interface.
//				(ImePad executable COM server)
//				
// 
// Date     :	Fri Apr 16 14:34:49 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_IMEPAD_SERVER_COM_H__
#define __C_IMEPAD_SERVER_COM_H__
#include "cpadsvr.h"

interface IImePadServer;
//----------------------------------------------------------------
//			CLASS: CImePadSvrCom
//
//	 This is simple wrapper class for IImePadLocal COM interface. 
//	dot IME can use this class to access/control ImePad without
//	using COM API directly.
//	And this class also wraps 16bit/32bit difference.
//	As you know, we cannot use COM API in 16bit Application. 
//  So, Client does not need to care if it work in 16bit/32bit.
//----------------------------------------------------------------
class CImePadSvrCOM;
typedef CImePadSvrCOM*	LPCImePadSvrCOM; 
class CImePadSvrCOM:public CImePadSvr
{
public:
	CImePadSvrCOM(VOID);
	~CImePadSvrCOM(VOID);
	virtual BOOL		IsAvailable			(VOID);
	virtual BOOL		OnIMEPadClose		(VOID);
	virtual INT			Initialize			(LANGID	imeLangID, DWORD dwImeInputID, LPVOID lpVoid);
	virtual	INT			Terminate			(LPVOID lpVoid);
	virtual INT			ForceDisConnect		(VOID);
	virtual	INT			ShowUI				(BOOL fShow);
	virtual	INT			IsVisible			(BOOL *pfVisible);
	virtual	INT			ActivateApplet		(UINT activateID, DWORD	dwActParam,LPWSTR lpwstr1,LPWSTR lpwstr2);
	virtual	INT			Notify				(INT id, WPARAM wParam, LPARAM lParam);
	virtual INT			GetAppletInfoList	(INT *pCountApplet, LPVOID *pList);
	virtual IUnknown*	SetIUnkIImeIPoint	(IUnknown *pIUnk);
	virtual IUnknown*	SetIUnkIImeCallback	(IUnknown *pIUnk);
	virtual IUnknown*	GetIUnkIImeIPoint	(VOID);
	virtual IUnknown*	GetIUnkIImeCallback	(VOID);
private:
	BOOL IsCoInitialized(VOID);
	//----------------------------------------------------------------
	//private methods.
	//----------------------------------------------------------------
	static LRESULT CALLBACK InterfaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT MsgCopyData(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT MsgTimer   (HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT MsgUser	   (HWND hwnd, WPARAM wParam, LPARAM lParam);
	HWND	CreateIFHWND	(VOID);
	BOOL	DestroyIFHWND	(BOOL fReserved);
	//----------------------------------------------------------------
	//private member
	//----------------------------------------------------------------
	BOOL				m_fShowReqStatus;		//Save ShowUI()'s bool value.
	BOOL				m_fLastActiveCtx;		//Save IMEPADNOTIFY_ACTIVATECONTEXT
	HWND				m_hwndIF;				//Internal I/F Window handle.
	IUnknown*			m_lpIUnkIImeIPoint;		//IImeIPoint I/F pointer as IUnknown.
	IUnknown*			m_lpIUnkIImeCallback;	//IImeCallback I/F pointer as IUnknown.
	IImePadServer*		m_lpIImePadServer;		//IImePadServer I/F pointer.
	LPCImePadCallback	m_lpCImePadCallback;	//CImePadCallback instance pointer.	
	DWORD				m_dwRegAdvise;			//Callbacck interface connect cookie.
	BOOL				m_fCoInitSuccess;		//Flag for CoInitialize() successed or not. 
};
#endif //__C_IMEPAD_SERVER_COM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\include\imepad_.h ===
//////////////////////////////////////////////////////////////////
// File     : imepad_.h
// Purpose  : IImePadInternal interface definition
//			  for FarEast MSIME.
// 
// Author	: ToshiaK(MSKK)  	
// 
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////

#ifndef _IME_PAD__H_
#define _IME_PAD__H_
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <objbase.h>


#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////
//
// IMEPADAPPLETINFO structure
//
#pragma pack(1)
typedef struct tagIMEPADAPPLETINFO {
	DWORD	dwSize;
	WCHAR	wchTitle[64];
	CLSID	clsId;
	IID		iid;
	DWORD	dwCategory;
	DWORD	dwReserved1;
	DWORD	dwReserved2;
}IMEPADAPPLETINFO, *LPIMEPADAPPLETINFO;

typedef struct tagIMEPADAPPLYCANDEX
{
	DWORD   dwSize;
	LPWSTR  lpwstrDisplay;
	LPWSTR  lpwstrReading;
	DWORD   dwReserved;
}IMEPADAPPLYCANDEX, *LPIMEPADAPPLYCANDEX;

#pragma pack()


//////////////////////////////////////////////////////////////////
//
// IImePadInternal's interface definition.
//
// 
//----------------------------------------------------------------
// CLSID, IID 
//
// {963732E0-CAB2-11d1-AFF1-00805F0C8B6D}
DEFINE_GUID(CLSID_IImePad,
0x963732e0, 0xcab2, 0x11d1, 0xaf, 0xf1, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);

// {963732E1-CAB2-11d1-AFF1-00805F0C8B6D}
DEFINE_GUID(IID_IImePadInternal,
0x963732e1, 0xcab2, 0x11d1, 0xaf, 0xf1, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);


//----------------------------------------------------------------
// Interface Declaration
//
DECLARE_INTERFACE(IImePadInternal);
DECLARE_INTERFACE_(IImePadInternal,IUnknown)
{
	//--- IUnknown ---
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
	//---- IImePadInternal ----
	STDMETHOD(Initialize)(THIS_
						  IUnknown	*lpIImeNotify,		//IImeNotify Interface.
						  LANGID	imelangId,			//LangageId of caller's ime.
						  DWORD		dwRes1,				//Reserved area.	
						  DWORD		dwRes2				//Reserved area.
						  ) PURE;
	STDMETHOD(Terminate)(THIS) PURE;
	STDMETHOD(ShowUI)	(THIS_ HWND hwndOwner, BOOL fShow) PURE;
	STDMETHOD(IsVisible)(THIS_ BOOL *pfVisible) PURE;
	STDMETHOD(Notify)	(THIS_ UINT notify, WPARAM wParam, LPARAM lParam) PURE;
	STDMETHOD(SetIImeIPoint)(THIS_ 
							 IUnknown *lpIImeIPoint	//IImeIPoint interface pointer
							 ) PURE;
	STDMETHOD(GetAppletInfoList)(THIS_  
								 DWORD				dwFlag,
								 IMEPADAPPLETINFO   **lppInfo,
								 INT				*pInfoCount) PURE;
	STDMETHOD(ActivateApplet)(THIS_ 
							  UINT		activateId,
							  DWORD		dwActivateParam,
							  LPWSTR	lpwstrAppletParam1,
							  LPWSTR	lpwstrAppletParam2) PURE;
};

//----------------------------------------------------------------
//IImePadApplet category ID
//----------------------------------------------------------------
#define IPACID_NONE                 0x0000
#define IPACID_SOFTKEY              0x0001
#define IPACID_HANDWRITING          0x0002
#define IPACID_STROKESEARCH         0x0003
#define IPACID_RADICALSEARCH        0x0004
#define IPACID_SYMBOLSEARCH         0x0005
#define IPACID_VOICE                0x0006
#define IPACID_EPWING               0x0007
#define IPACID_OCR                  0x0008
#define IPACID_USER                 0x0100

//////////////////////////////////////////////////////////////////
//
//Notify message for IImePadInternal::Notify()
//
//----------------------------------------------------------------
// Notify composition string's window rect
// WPARAM wParam: no use
// LPARAM lParam: LPRECT lpRect = (LPRECT)lParam;
//----------------------------------------------------------------
#define IMEPADNOTIFY_RECTCHANGED				0x0001

//----------------------------------------------------------------
// Notify context's activation
// WPARAM wParam: BOOL fActivate = (BOOL)wParam;
// LPARAM lParam: no use
//----------------------------------------------------------------
#define IMEPADNOTIFY_ACTIVATECONTEXT			0x0002

//----------------------------------------------------------------
// Notify for mode changed
// WPARAM wParam: (INT) convMode    = (INT)wParam;
// LPARAM lParam: (INT) sentenceMode= (INT)lParam;
// conversion mode and sentence mode are IME_CMODE_XX or IME_SMODE_XX 
//----------------------------------------------------------------
#define	IMEPADNOTIFY_MODECHANGED				0x0006

//----------------------------------------------------------------
// Notify for start composition 
// WPARAM wParam: not defined
// LPARAM lParam: not defined
//----------------------------------------------------------------
#define IMEPADNOTIFY_STARTCOMPOSITION			0x0007

//----------------------------------------------------------------
// Notify for composition
// WPARAM wParam: not defined
// LPARAM lParam: not defined
//----------------------------------------------------------------
#define IMEPADNOTIFY_COMPOSITION				0x0008

//----------------------------------------------------------------
// Notify for end composition 
// WPARAM wParam: not defined
// LPARAM lParam: not defined
//----------------------------------------------------------------
#define IMEPADNOTIFY_ENDCOMPOSITION				0x0009

//----------------------------------------------------------------
// Notify for open candidate
// WPARAM wParam: not defined
// LPARAM lParam: not defined
//----------------------------------------------------------------
#define IMEPADNOTIFY_OPENCANDIDATE				0x000A

//----------------------------------------------------------------
// Notify for close candidate
// WPARAM wParam: not defined
// LPARAM lParam: not defined
//----------------------------------------------------------------
#define IMEPADNOTIFY_CLOSECANDIDATE				0x000B

//----------------------------------------------------------------
// Notify for Candidate Applied
// WPARAM wParam: dwCharId = (DWORD)wParam;
// LPARAM lParam: iSelIndex = (INT)lParam;
//----------------------------------------------------------------
#define IMEPADNOTIFY_APPLYCANDIDATE				0x000C

//----------------------------------------------------------------
// Notify for Querying Candidate
// WPARAM wParam: dwCharId = (DWORD)wParam;
// LPARAM lParam: 0. not used.
//----------------------------------------------------------------
#define IMEPADNOTIFY_QUERYCANDIDATE				0x000D


//----------------------------------------------------------------
// Notify for Candidate Applied
// WPARAM wParam: dwCharId = (DWORD)wParam;
// LPARAM lParam: lpApplyCandEx = (LPIMEPADAPPLYCANDEX)lParam;
//----------------------------------------------------------------
#define IMEPADNOTIFY_APPLYCANDIDATE_EX			0x000E



//----------------------------------------------------------------
//Notify for Destroying ImePad's current thread window
//WPARAM wParam: no use 
//LPARAM lParam: no use
//----------------------------------------------------------------
#define IMEPADNOTIFY_ONIMEWINDOWDESTROY			0x0100




//////////////////////////////////////////////////////////////////
//
// ActivateId for IImePadInternal::ActivateApplet()
//
//----------------------------------------------------------------
// IMEPADACTID_ACTIVATEBYCATID requests ImePad to 
// Activate Applet by CategoryId.
//
// UINT		activateId:			IMEPADACTID_ACTIVATEBYCATID;
// LPARAM	lParamActivate:		IPACID_XXXX;
// LPWSTR	lpwstrAppletParam1:	string passed to applet.
// LPWSTR	lpwstrAppletParam2:	string passed to applet.

#define IMEPADACTID_ACTIVATEBYCATID			1000

//----------------------------------------------------------------
// IMEPADACTID_ACTIVATEBYIID requests ImePad to 
// activate applet by Interface ID
//
// UINT		activateId:			IMEPADACTID_ACTIVATEBYIID;
// DWORD	dwActivateParam:	(DWORD)(IID *)pIID;
// LPWSTR	lpwstrAppletParam1:	string passed to applet.
// LPWSTR	lpwstrAppletParam2:	string passed to applet.

#define IMEPADACTID_ACTIVATEBYIID			1001

//----------------------------------------------------------------
// IMEPADACTID_ACTIVATEBYNAME requests ImePad to 
// activaet applet by applet's title name.
//
// UINT		activateId:			IMEPADACTID_ACTIVATEBYNAME
// DWORD	dwActivateParam:	(DWORD)(LPWSTR)lpwstrTitle;
// LPWSTR	lpwstrAppletParam1:	string passed to applet.
// LPWSTR	lpwstrAppletParam2:	string passed to applet.

#define IMEPADACTID_ACTIVATEBYNAME			1003



#ifdef __cplusplus
};
#endif
#endif //_IME_PAD__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\include\imepad.h ===
/******************************************************************************
*																			  *
* imepad.h - - Interface for the Windows IMEPAD, IMEPADAPPLET				  *
*																			  *
* Version 8.1 															  *
*																			  *
* Copyright (c) 1995-2000, Microsoft Corp.		All rights reserved.		  *
*																			  *
******************************************************************************/
#ifndef _IME_PAD_H_
#define _IME_PAD_H_
#include <windows.h>
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------
// ImePadApplet's Category ID
//----------------------------------------------------------------
// {4A0F8E31-C3EE-11d1-AFEF-00805F0C8B6D}
DEFINE_GUID(CATID_MSIME_IImePadApplet_VER7,
0x4a0f8e31, 0xc3ee, 0x11d1, 0xaf, 0xef, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);

//----------------------------------------------------------------
// ImePadApplet's Category ID version 8.0.0
//----------------------------------------------------------------
// {56F7A792-FEF1-11d3-8463-00C04F7A06E5}
DEFINE_GUID(CATID_MSIME_IImePadApplet_VER80,
0x56f7a792, 0xfef1, 0x11d3, 0x84, 0x63, 0x0, 0xc0, 0x4f, 0x7a, 0x6, 0xe5);

//----------------------------------------------------------------
// ImePadApplet's Category ID version 8.1.0
//----------------------------------------------------------------
// {656520B0-BB88-11d4-84C0-00C04F7A06E5}
DEFINE_GUID(CATID_MSIME_IImePadApplet, 
0x656520b0, 0xbb88, 0x11d4, 0x84, 0xc0, 0x0, 0xc0, 0x4f, 0x7a, 0x6, 0xe5);


//----------------------------------------------------------------
// Interface ID
//----------------------------------------------------------------
// {5D8E643A-C3A9-11d1-AFEF-00805F0C8B6D}
DEFINE_GUID(IID_IImePad, 
0x5d8e643a, 0xc3a9, 0x11d1, 0xaf, 0xef, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);

// {5D8E643B-C3A9-11d1-AFEF-00805F0C8B6D}
DEFINE_GUID(IID_IImePadApplet,
0x5d8e643b, 0xc3a9, 0x11d1, 0xaf, 0xef, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);

// {5D8E643C-C3A9-11d1-AFEF-00805F0C8B6D}
DEFINE_GUID(IID_IImeSpecifyApplets,
0x5d8e643c, 0xc3a9, 0x11d1, 0xaf, 0xef, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);


#ifdef _WIN64
#pragma pack(8)
#else //!_WIN64
#pragma pack(1)
#endif

typedef struct tagAPPLETIDLIST {
	INT	 count;
	IID *pIIDList;
}APPLETIDLIST, *LPAPPLETIDLIST;

//structure for IMEPADREQ_INSERTSTRINGCANDIDATE
typedef struct tagIMESTRINGCANDIDATE {
	UINT	uCount;
	LPWSTR	lpwstr[1];
}IMESTRINGCANDIDATE, *LPIMESTRINGCANDIDATE;

//structure for IMEPADREQ_INSERTITEMCANDIDATE
typedef struct tagIMEITEM {
	INT		cbSize;
	INT		iType;
	LPVOID	lpItemData;
}IMEITEM, *LPIMEITEM;

typedef struct tagIMEITEMCANDIDATE {
	UINT	uCount;
	IMEITEM imeItem[1];
}IMEITEMCANDIDATE, *LPIMEITEMCANDIDATE;

//----------------------------------------------------------------
// Character Id in FarEast
//----------------------------------------------------------------
#define FEID_NONE					0x00
#define FEID_CHINESE_TRADITIONAL	0x01
#define FEID_CHINESE_SIMPLIFIED		0x02
#define FEID_CHINESE_HONGKONG		0x03
#define FEID_CHINESE_SINGAPORE		0x04
#define FEID_JAPANESE				0x05
#define FEID_KOREAN					0x06
#define FEID_KOREAN_JOHAB			0x07

//----------------------------------------------------------------
// String with FarEast id
//----------------------------------------------------------------
typedef struct tabIMESTRINGINFO {
	DWORD	dwFarEastId;
	LPWSTR	lpwstr;
}IMESTRINGINFO, *LPIMESTRINGINFO;

#define INFOMASK_NONE           0x00000000
#define INFOMASK_QUERY_CAND     0x00000001
#define INFOMASK_APPLY_CAND     0x00000002
#define INFOMASK_APPLY_CAND_EX  0x00000004
#define INFOMASK_STRING_FIX     0x00010000
#define INFOMASK_HIDE_CAND      0x00020000
#define INFOMASK_BLOCK_CAND     0x00040000

//----------------------------------------------------------------
//FarEast data type
//----------------------------------------------------------------
#define IMEFAREASTINFO_TYPE_DEFAULT		0
#define IMEFAREASTINFO_TYPE_READING		1
#define IMEFAREASTINFO_TYPE_COMMENT		2
#define IMEFAREASTINFO_TYPE_COSTTIME		3


//----------------------------------------------------------------
//FarEast specified data.
//----------------------------------------------------------------
typedef struct tabIMEFAREASTINFO {
	DWORD dwSize;		//total structure size.
	DWORD dwType;		//Data type.
	DWORD dwData[1];	//fareast spec data.
}IMEFAREASTINFO, *LPIMEFAREASTINFO;

//----------------------------------------------------------------
// String candidate info
//----------------------------------------------------------------
typedef struct tagIMESTRINGCANDIDATEINFO {
	DWORD				dwFarEastId;
	LPIMEFAREASTINFO	lpFarEastInfo;
	DWORD				fInfoMask;
	INT					iSelIndex;
	UINT				uCount;
	LPWSTR				lpwstr[1];
}IMESTRINGCANDIDATEINFO, *LPIMESTRINGCANDIDATEINFO;

//----------------------------------------------------------------
//Composition string's information
//----------------------------------------------------------------
typedef struct tagIMECOMPOSITIONSTRINGINFO {
	INT iCompStrLen;
	INT iCaretPos;
	INT iEditStart;
	INT iEditLen;
	INT iTargetStart;
	INT iTargetLen;
}IMECOMPOSITIONSTRINGINFO, *LPIMECOMPOSITIONSTRINGINFO;

//----------------------------------------------------------------
//Composition string's each character
//----------------------------------------------------------------
typedef struct tagIMECHARINFO {
	WCHAR	wch;
	DWORD	dwCharInfo;
}IMECHARINFO, *LPIMECHARINFO;

//----------------------------------------------------------------
//IMECHARINFO's dwCharInfo bit mask
//----------------------------------------------------------------
#define CHARINFO_APPLETID_MASK	0xFF000000
#define CHARINFO_FEID_MASK		0x00F00000
#define CHARINFO_CHARID_MASK	0x0000FFFF

#define APPLETIDFROMCHARINFO(charInfo)	(((DWORD)(charInfo) & CHARINFO_APPLETID_MASK) >> 24)
#define FEIDFROMCHARINFO(charInfo)		(((DWORD)(charInfo) & CHARINFO_FEID_MASK) >> 20)
#define CHARIDFROMCHARINFO(charInfo)	((DWORD)(charInfo) & CHARINFO_CHARID_MASK)

//===== IImePadApplet Configuration ===============================
#define MAX_APPLETTITLE		64
#define MAX_FONTFACE		32	
typedef struct tagAPPLETCFG {
	DWORD		dwConfig;						//set combination of IPACFG_XXXX
	WCHAR		wchTitle[MAX_APPLETTITLE];		//set applet's title name;
	WCHAR		wchTitleFontFace[MAX_FONTFACE];	//set title's font face. 
	DWORD		dwCharSet;						//set character set.
	INT			iCategory;						//set IPACID_XXXX
	HICON		hIcon;							//set Icon Handle for ImePad Appelt's menu.
	LANGID		langID;							//set Applet langID.
	WORD		dummy;
	LPARAM		lReserved1;
}IMEAPPLETCFG, *LPIMEAPPLETCFG;

//----------------------------------------------------------------
// APPLETCFG dwConfig mask
//
#define IPACFG_NONE					0x00000000L
#define IPACFG_PROPERTY				0x00000001L		//Applet has property.
#define IPACFG_HELP					0x00000002L		//Applet has help.
#define IPACFG_TITLE				0x00010000L		//Title is set.
#define IPACFG_TITLEFONTFACE		0x00020000L		//wchFontFace, dwCharSet is valid.
#define IPACFG_CATEGORY				0x00040000L		//category has set.
#define IPACFG_LANG					0x00000010L		//LangID has set.
//----------------------------------------------------------------
// APPLETCFG iCategory
//
#define IPACID_NONE					0x0000
#define IPACID_SOFTKEY				0x0001
#define IPACID_HANDWRITING			0x0002
#define IPACID_STROKESEARCH			0x0003
#define IPACID_RADICALSEARCH		0x0004
#define IPACID_SYMBOLSEARCH			0x0005
#define IPACID_VOICE				0x0006
#define IPACID_EPWING				0x0007
#define IPACID_OCR					0x0008
#define IPACID_USER					0x0100


typedef struct tagIMEAPPLETUI {
	HWND	hwnd;					//Window handle of Applet.
	DWORD	dwStyle;				//set combination of IPAWS_XXX.
	INT		width;					//set Applet's initial width. 
	INT		height;					//set Applet's initial height.
	INT		minWidth;				//set min width.  Valid only IPAWS_MINSIZEFIXED style has set.
	INT		minHeight;				//set min height. Valid only IPAWS_MINSIZEFIXED style has set.
	INT		maxWidth;				//set max width.  Valid only IPAWS_MAXSIZEFIXED style has set.
	INT		maxHeight;				//set max height. Valid only IPAWS_MAXSIZEFIXED style has set.
	LPARAM	lReserved1;				//reserved area. 
	LPARAM	lReserved2;				//reserved area. 
}IMEAPPLETUI, *LPIMEAPPLETUI;

#pragma pack()


//Default insert position
#define IPR_DEFAULT_INSERTPOS		((WORD)0xFFFF)


//==== IImePad Request ID ==========================================
#define IMEPADREQ_FIRST							0x1000
//----------------------------------------------------------------
// IMEPADREQ_INSERTSTRING
// wParam = (WPARMA)(LPWSTR)lpwstr;		//address of Unicode text string.
// lParam = 0;							//not used.
//----------------------------------------------------------------
#define IMEPADREQ_INSERTSTRING					(IMEPADREQ_FIRST + 1)

//----------------------------------------------------------------
// IMEPADREQ_INSERTSTRINGCANDIDATE
// wParam = (WPARAM)(LPIMESTRINGCANDIDATE)lpStrCand;	//address of IMESTRINGCANDIDATE
// lParam = 0;											//not used.
//----------------------------------------------------------------
#define IMEPADREQ_INSERTSTRINGCANDIDATE			(IMEPADREQ_FIRST + 2)

//----------------------------------------------------------------
// IMEPADREQ_INSERTITEMCANDIDATE
// Not implemented in version 7.1.0
// wParam = 0;
// lParam = 0;
//----------------------------------------------------------------
#define IMEPADREQ_INSERTITEMCANDIDATE			(IMEPADREQ_FIRST + 3)

//----------------------------------------------------------------
// IMEPADREQ_SENDCONTROL
// wParam = (WPARAM)imePadCtrl; //control code (IMEPADCTRL_XXXX)
// lParam = 0;					//not used.
//----------------------------------------------------------------
#define IMEPADREQ_SENDCONTROL					(IMEPADREQ_FIRST + 4)

//----------------------------------------------------------------
// IMEPADREQ_SENDKEYCONTROL
// wParam = MAKEWPARAM(ctlMask, updown);
//			ctlMask is IMEKEYCTRLMASK_XXX combination
//			upDown	is IMEKEYCTRL_UP or DOWN
// lParam = (LPARAM)wvKey;		//Virtual keycode.
//----------------------------------------------------------------
#define IMEPADREQ_SENDKEYCONTROL				(IMEPADREQ_FIRST + 5)

//----------------------------------------------------------------
// IMEPADREQ_GETCOMPOSITIONSTRING
// wParam = (WPARAM)(LPWSTR)lpwstr;		//address of Unicode string buffer.		
// lParam = (LPARAM)(UINT)cchMax;		//buffer max count.
//----------------------------------------------------------------
#define IMEPADREQ_GETCOMPOSITIONSTRING			(IMEPADREQ_FIRST + 6)

//----------------------------------------------------------------
// IMEPADREQ_GETSELECTEDSTRING
// Not implemented in version 6.0.0
// wParam = 0;
// lParam = 0;
//----------------------------------------------------------------
#define IMEPADREQ_GETSELECTEDSTRING				(IMEPADREQ_FIRST + 7)

//----------------------------------------------------------------
// IMEPADREQ_SETAPPLETSIZE
// wParam = MAKEWPARAM(width, height);	// Applet's width & height
// lParam = 0;							// not used.
//----------------------------------------------------------------
#define IMEPADREQ_SETAPPLETSIZE					(IMEPADREQ_FIRST + 8)

//----------------------------------------------------------------
// IMEPADREQ_SETAPPLETDATA
// wParam = (WPARAM)(PBYTE)pByte;		//address of applet's data.
// lParam = (LPARAM)(INT)size;			//byte size of pByte. 
//----------------------------------------------------------------
#define IMEPADREQ_SETAPPLETDATA					(IMEPADREQ_FIRST + 9)

//----------------------------------------------------------------
// IMEPADREQ_GETAPPLETDATA
// wParam = (WPARAM)(PBYTE)pByte;		//address of applet's data.
// lParam = (LPARAM)(INT)size;			//byte size of pByte. 
//----------------------------------------------------------------
#define IMEPADREQ_GETAPPLETDATA					(IMEPADREQ_FIRST + 10)

//----------------------------------------------------------------
// IMEPADREQ_SETTITLEFONT
// wParam = (WPARAM)(LPWSTR)lpwstrFontFace; //FontFace name
// lParam = (LPARAM)(INT)charSet;			//character set
//----------------------------------------------------------------
#define IMEPADREQ_SETTITLEFONT					(IMEPADREQ_FIRST + 11)

//----------------------------------------------------------------
// IMEPADREQ_GETCOMPOSITIONSTRINGINFO
// wParam = (WPARAM)(LPIMECOMPOSITIONSTRINGINFO)lpImeCompInfo. 
//				//IMECOMPOSITIONSTRINGINFO struct address.
// lParam = 0;	//no use.
//----------------------------------------------------------------
#define IMEPADREQ_GETCOMPOSITIONSTRINGINFO		(IMEPADREQ_FIRST + 12)

//----------------------------------------------------------------
// IMEPADREQ_GETCOMPOSITIONSTRINGID
// wParam = (WPARAM)(LPIMECHARINFO)lpCharInfo;
// lParam = (LPARAM)(INT)dwMaxLen;
//----------------------------------------------------------------
#define IMEPADREQ_GETCOMPOSITIONSTRINGID		(IMEPADREQ_FIRST + 13)

//----------------------------------------------------------------
// IMEPADREQ_INSERTSTRINGCANDIDATEINFO
// wParam = (WPARAM)(LPIMESTRINGCANDIDATEINFO)lpCandInfo;
// lParam = (LPARAM)(WORD)wStartPos;
//----------------------------------------------------------------
#define IMEPADREQ_INSERTSTRINGCANDIDATEINFO		(IMEPADREQ_FIRST + 14)

//----------------------------------------------------------------
// IMEPADREQ_CHANGESTRINGCANDIDATEINFO
// wParam = (WPARAM)(LPIMESTRINGCANDIDATEINFO)lpCandInfo;
// lParam = MAKELPARAM(startPos, length);
//----------------------------------------------------------------
#define IMEPADREQ_CHANGESTRINGCANDIDATEINFO		(IMEPADREQ_FIRST + 15)

//----------------------------------------------------------------
// IMEPADREQ_DELETESTRING
// wParam = MAKEWPARAM(wStartPos, wLength); 
// lParam = 0;								//not used.
//----------------------------------------------------------------
#define IMEPADREQ_DELETESTRING					(IMEPADREQ_FIRST + 16)

//----------------------------------------------------------------
// IMEPADREQ_CHANGESTRING
// wParam = (WPARAM)(LPWSTR)lpwstr; 
// lParam = MAKELPARAM(wStartPos, wLength);
//----------------------------------------------------------------
#define IMEPADREQ_CHANGESTRING					(IMEPADREQ_FIRST + 17)

//----------------------------------------------------------------
// IMEPADREQ_INSERTSTRINGINFO
// wParam = (WPARAM)(LPIMESTRINGINFO)lpStrInfo;
// lParam = dwStartPos
//----------------------------------------------------------------
#define IMEPADREQ_INSERTSTRINGINFO				(IMEPADREQ_FIRST + 18)

//----------------------------------------------------------------
// IMEPADREQ_CHANGESTRINGINFO
// wParam = (WPARAM)(LPIMESTRINGINFO)lpStrInfo;
// lParam = MAKELPARAM(wStartPos, wLength);
//----------------------------------------------------------------
#define IMEPADREQ_CHANGESTRINGINFO				(IMEPADREQ_FIRST + 19)

//----------------------------------------------------------------
// IMEPADREQ_GETAPPLHWND
// wParam = (WPARAM)(HWND *)lpHwnd;
// lParam = 0; not used.
//----------------------------------------------------------------
#define IMEPADREQ_GETAPPLHWND					(IMEPADREQ_FIRST + 20)

//----------------------------------------------------------------
// IMEPADREQ_FORCEIMEPADWINDOWSHOW
// wParam = (WPARAM)(BOOL)fShowForce
// lParam = 0; not used.
//----------------------------------------------------------------
#define IMEPADREQ_FORCEIMEPADWINDOWSHOW			(IMEPADREQ_FIRST + 21)

//----------------------------------------------------------------
// IMEPADREQ_POSTMODALNOTIFY
// wParam = (WPARAM)notifycode 
// lParam = (LPARAM)dwData.
//----------------------------------------------------------------
#define IMEPADREQ_POSTMODALNOTIFY				(IMEPADREQ_FIRST + 22)

//----------------------------------------------------------------
// IMEPADREQ_GETDEFAULTUILANGID
// wParam = (WPARAM)(LANGID *)pLangID;
// lParam = 0; not used
//----------------------------------------------------------------
#define IMEPADREQ_GETDEFAULTUILANGID			(IMEPADREQ_FIRST + 23)

//----------------------------------------------------------------
// IMEPADREQ_GETCURRENTUILANGID
// wParam = (WPARAM)(LANGID *)pLangID;
// lParam = 0; not used
//----------------------------------------------------------------
#define IMEPADREQ_GETCURRENTUILANGID			(IMEPADREQ_FIRST + 24)

//----------------------------------------------------------------
// IMEPADREQ_GETAPPLETUISTYLE
// wParam = (WPARAM)(DWORD *)pdwStyle;
// lParam = 0; not used.
//----------------------------------------------------------------
#define IMEPADREQ_GETAPPLETUISTYLE				(IMEPADREQ_FIRST + 25)

//----------------------------------------------------------------
// IMEPADREQ_SETAPPLETUISTYLE
// wParam = (WPARAM)(DWORD)dwStyle;
// lParam = 0; not used.
//----------------------------------------------------------------
#define IMEPADREQ_SETAPPLETUISTYLE				(IMEPADREQ_FIRST + 26)

//----------------------------------------------------------------
// IMEPADREQ_ISAPPLETACTIVE
// wParam = (WPARAM)(BOOL *)pfActive;
// lParam = 0; not used.
//----------------------------------------------------------------
#define IMEPADREQ_ISAPPLETACTIVE				(IMEPADREQ_FIRST + 27)

//----------------------------------------------------------------
// IMEPADREQ_ISIMEPADWINDOWVISIBLE
// wParam = (WPARAM)(BOOL *)pfVisible;
// lParam = 0; not used.
//----------------------------------------------------------------
#define IMEPADREQ_ISIMEPADWINDOWVISIBLE			(IMEPADREQ_FIRST + 28)

//----------------------------------------------------------------
// IMEPADREQ_SETAPPLETMINMAXSIZE
// wParam = MAKEWPARAM(width, height);	// Applet's width & height
// lParam = MAKELPARAM(fMax, fNoMove);	// Set Max size or Min size,
//										// And move or not move. 
//----------------------------------------------------------------
#define IMEPADREQ_SETAPPLETMINMAXSIZE			(IMEPADREQ_FIRST + 29)

//----------------------------------------------------------------
// IMEPADREQ_GETCONVERSIONSTATUS
// wParam = (WPARAM)(DWORD *)pdwConversionMode; //conversion mode.
// lParam = (LPARAM)(DWORD *)pdwSentenceMode;   //sentence mode.
//----------------------------------------------------------------
#define IMEPADREQ_GETCONVERSIONSTATUS			(IMEPADREQ_FIRST + 30)

//----------------------------------------------------------------
// IMEPADREQ_GETVERSION
// wParam = (WPARAM)(DWORD *)pdwVerMS;
// lParam = (LPARAM)(DWORD *)pdwVerLS;
//----------------------------------------------------------------
#define IMEPADREQ_GETVERSION					(IMEPADREQ_FIRST + 31)

//----------------------------------------------------------------
// IMEPADREQ_GETCURRENTIMEINFO
// wParam = (WPARAM)(DWORD *)pdwImeLangID;
// lParam = (LPARAM)(DWORD *)pdwImeInputID;
//----------------------------------------------------------------
#define IMEPADREQ_GETCURRENTIMEINFO				(IMEPADREQ_FIRST + 32)


//===== IMEPADREQ_SENDCONTROL reques parameter ======================
#define IMEPADCTRL_CONVERTALL			1
#define IMEPADCTRL_DETERMINALL			2
#define IMEPADCTRL_DETERMINCHAR			3
#define IMEPADCTRL_CLEARALL				4
#define IMEPADCTRL_CARETSET				5
#define IMEPADCTRL_CARETLEFT			6	
#define IMEPADCTRL_CARETRIGHT			7
#define IMEPADCTRL_CARETTOP				8 
#define IMEPADCTRL_CARETBOTTOM			9 
#define IMEPADCTRL_CARETBACKSPACE		10 
#define IMEPADCTRL_CARETDELETE			11 
#define IMEPADCTRL_PHRASEDELETE			12
#define IMEPADCTRL_INSERTSPACE			13
#define IMEPADCTRL_INSERTFULLSPACE		14
#define IMEPADCTRL_INSERTHALFSPACE		15
#define IMEPADCTRL_ONIME				16
#define IMEPADCTRL_OFFIME				17
#define IMEPADCTRL_ONPRECONVERSION		18
#define IMEPADCTRL_OFFPRECONVERSION		19
#define IMEPADCTRL_PHONETICCANDIDATE	20


//hot key definition
#define IMEKEYCTRLMASK_ALT			0x0001
#define IMEKEYCTRLMASK_CTRL			0x0002
#define IMEKEYCTRLMASK_SHIFT		0x0004

#define IMEKEYCTRL_UP				1
#define IMEKEYCTRL_DOWN				0

//===== IImePadApplet Notify ID =====================================
#define IMEPN_FIRST					0x0100
#define IMEPN_ACTIVATE				(IMEPN_FIRST + 1)
#define IMEPN_INACTIVATE			(IMEPN_FIRST + 2)
#define IMEPN_SHOW					(IMEPN_FIRST + 4)
#define IMEPN_HIDE					(IMEPN_FIRST + 5)
#define IMEPN_SIZECHANGING			(IMEPN_FIRST + 6)
#define IMEPN_SIZECHANGED			(IMEPN_FIRST + 7)
#define IMEPN_CONFIG				(IMEPN_FIRST + 8)
#define IMEPN_HELP					(IMEPN_FIRST + 9)
#define IMEPN_QUERYCAND				(IMEPN_FIRST +10)
#define IMEPN_APPLYCAND				(IMEPN_FIRST +11)
#define IMEPN_APPLYCANDEX			(IMEPN_FIRST +12)
#define IMEPN_SETTINGCHANGED		(IMEPN_FIRST +13)	

#define IMEPN_USER					(IMEPN_FIRST + 100)


typedef struct tagAPPLYCANDEXPARAM
{

	DWORD	dwSize;
	LPWSTR	lpwstrDisplay;
	LPWSTR	lpwstrReading;
	DWORD	dwReserved;

} APPLYCANDEXPARAM, *LPAPPLYCANDEXPARAM;


//===== IImePadApplet window style ================================
#define IPAWS_ENABLED               0x00000001L     //Show Applet as Enabled window.
#define IPAWS_SIZINGNOTIFY			0x00000004L		//send IMEPN_SIZECHANGING(ED) notify to applet.
#define IPAWS_VERTICALFIXED			0x00000100L		//Vertically fixed.
#define IPAWS_HORIZONTALFIXED		0x00000200L		//Horizontally fixed.
#define IPAWS_SIZEFIXED				0x00000300L		//size is fixed.
#define IPAWS_MAXWIDTHFIXED			0x00001000L		//max width	 is fixed.
#define IPAWS_MAXHEIGHTFIXED		0x00002000L		//max height is fixed.
#define IPAWS_MAXSIZEFIXED			0x00003000L		//max size is fixed.
#define IPAWS_MINWIDTHFIXED			0x00010000L		//min width	 is fixed. 
#define IPAWS_MINHEIGHTFIXED		0x00020000L		//min height is fixed.
#define IPAWS_MINSIZEFIXED			0x00030000L		//min size is fixed.



//======IImePad IImePadApplet Interface definition===============

DECLARE_INTERFACE(IImePad);
DECLARE_INTERFACE(IImePadApplet);
DECLARE_INTERFACE(IImeSpecifyApplets);


DECLARE_INTERFACE_(IImePad, IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef) (THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	/*** IImePad methods ***/
	STDMETHOD(Request)(THIS_
					   IImePadApplet *pIImePadApplet,
					   INT reqId,
					   WPARAM wParam,
					   LPARAM lParam) PURE;
};

DECLARE_INTERFACE_(IImeSpecifyApplets, IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef) (THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	/*** IImeSpecifyApplet methods ***/
	STDMETHOD(GetAppletIIDList)(THIS_
								REFIID			refiid,
								LPAPPLETIDLIST	lpIIDList) PURE;
};


DECLARE_INTERFACE_(IImePadApplet, IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef) (THIS) PURE;
	STDMETHOD_(ULONG, Release) (THIS) PURE;
	/*** IImePadApplet methods ***/
	STDMETHOD(Initialize)(THIS_ IUnknown *lpIImePad)  PURE;
	STDMETHOD(Terminate) (THIS)						PURE;
	STDMETHOD(GetAppletConfig)(THIS_ LPIMEAPPLETCFG lpAppletCfg) PURE;
	STDMETHOD(CreateUI)(THIS_ 
						HWND				hwndParent,
						LPIMEAPPLETUI		lpImeAppletUI) PURE;
	STDMETHOD(Notify)(THIS_ 
					  IUnknown	*lpImePad,
					  INT		notify,
					  WPARAM	wParam,
					  LPARAM	lParam) PURE;
};


#ifdef __cplusplus
};
#endif

#endif //_IME_PAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\include\imeconpt.h ===
#ifndef _IME_CON_POINT_H_
#define _IME_CON_POINT_H_
#include <windows.h>
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------
// Interface Declaration
//
// {963732E2-CAB2-11d1-AFF1-00805F0C8B6D}
DEFINE_GUID(IID_IImeConnectionPoint,
0x963732e2, 0xcab2, 0x11d1, 0xaf, 0xf1, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);

DECLARE_INTERFACE(IImeConnectionPoint);
DECLARE_INTERFACE_(IImeConnectionPoint,IUnknown)
{
	//--- IUnknown ---
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
	//---- IImeConnectionPoint ----
	STDMETHOD(GetApplicationHWND)(THIS_ HWND *pHWND) PURE;
	STDMETHOD(Notify)(THIS_ UINT notify, WPARAM wParam, LPARAM lParam) PURE;
};

//----------------------------------------------------------------
// IImeConnectionPoint::Notify()'s notify
// IMECPNOTIFY_IMEPADOPENED
// WPARAM wParam: not used. always 0
// LPARAM lParam: not used. always 0
//----------------------------------------------------------------
#define IMECPNOTIFY_IMEPADOPENED	0

//----------------------------------------------------------------
// IImeConnectionPoint::Notify()'s notify
// IMECPNOTIFY_IMEPADCLOSED
// WPARAM wParam: not used. always 0
// LPARAM lParam: not used. always 0
//----------------------------------------------------------------
#define IMECPNOTIFY_IMEPADCLOSED	1



#ifdef __cplusplus
};
#endif
#endif //_IME_CONN_POINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\include\ipoint1.h ===
//
//	%%Title: IImeIPoint
//	%%Unit: COM
//	%%Contact: TakeshiF
//	%%Date: 97/02/26
//	%%File: ipoint.h
//
//	Defines IImeIPoint interface methods
//

#ifdef __cplusplus
extern "C" {			/* Assume C declarations for C++ */
#endif /* __cplusplus */


#ifndef RC_INVOKED
#pragma pack(1)			/* Assume byte packing throughout */
#endif /* !RC_INVOKED */

//----------------------------------------------------------------
// Fareast Language id
//----------------------------------------------------------------
#define IPFEID_MASK					0x00F00000

#define IPFEID_NONE					0x00000000
#define IPFEID_CHINESE_TRADITIONAL	0x00100000
#define IPFEID_CHINESE_SIMPLIFIED	0x00200000
#define IPFEID_CHINESE_HONGKONG		0x00300000
#define IPFEID_CHINESE_SINGAPORE	0x00400000
#define IPFEID_JAPANESE				0x00500000
#define IPFEID_KOREAN				0x00600000
#define IPFEID_KOREAN_JOHAB			0x00700000

//
// dwCharId
//
//		0xFF000000	= AppletId	  AppletId		   (set by IMEPAD)
//								  ID = 0:Char From IMM.
//									 !=0:IMEPAD use for identify the char owner.
//		0x00F00000	= FEID_XX	  Fareast Language id  (set by IMEPAD)
//		0x000F0000	   (reserve)
//		0x0000FFFF	= CharacterNo serial no of insert char	(set by IPOINT)
//
//
#define IPCHARID_CHARNO_MASK		0x0000FFFF

//----------------------------------------------------------------
//Control Id (dwIMEFuncID)
//----------------------------------------------------------------
											// lparam (N/A use IPCTRLPARAM_DEFAULT)
#define IPCTRL_CONVERTALL			1		// N/A
#define IPCTRL_DETERMINALL			2		// N/A
#define IPCTRL_DETERMINCHAR			3		// n:number of DETCHARS (IPCTRLPARAM_DEFAULT is same as 1)
#define IPCTRL_CLEARALL				4		// N/A
#define IPCTRL_CARETSET				5		// IPCTRLPARAM_MAKE_CARET_POS(uipos, chpos)
#define IPCTRL_CARETLEFT			6		// n:number of LEFT (IPCTRLPARAM_DEFAULT is same as 1)
#define IPCTRL_CARETRIGHT			7		// n:number of RIGHT(IPCTRLPARAM_DEFAULT is same as 1)
#define IPCTRL_CARETTOP				8		// N/A
#define IPCTRL_CARETBOTTOM			9		// N/A
#define IPCTRL_CARETBACKSPACE		10		// n:number of BS chars. (IPCTRLPARAM_DEFAULT is same as 1)
#define IPCTRL_CARETDELETE			11		// n:number of DEL chars. (IPCTRLPARAM_DEFAULT is same as 1)
#define IPCTRL_PHRASEDELETE			12		// N/A 
#define IPCTRL_INSERTSPACE			13		// N/A
#define IPCTRL_INSERTFULLSPACE		14		// N/A
#define IPCTRL_INSERTHALFSPACE		15		// N/A
#define IPCTRL_ONIME				16		// N/A
#define IPCTRL_OFFIME				17		// N/A
#define IPCTRL_PRECONVERSION		18		// IPCTRLPARAM_ON/IPCTRLPARAM_OFF
#define IPCTRL_PHONETICCANDIDATE	19		// N/A
#define IPCTRL_GETCONVERSIONMODE	20		// lparam should be LPARAM address.
#define IPCTRL_GETSENTENCENMODE		21		// lparam should be LPARAM address.
//----------------------------------------------------------------
//Control Id lparam
//----------------------------------------------------------------
#define IPCTRLPARAM_DEFAULT ((LPARAM)(0xfeeeeeee))
#define IPCTRLPARAM_ON		((LPARAM)(0x00000001))
#define IPCTRLPARAM_OFF		((LPARAM)(0x00000000))

// for IPCTRL_CARETSET
#define CARET_ICHPOS   (0x0000FFFF)		// IP Position on the composition string. 0-n
#define CARET_UIPOS	   (0x0FFF0000)		// UIPOS (position on the character)
										// 0-3: X--XO--O ( 2chars )
										//		23012301
#define IPCTRLPARAM_MAKE_CARET_POS(uipos, chpos) ((LPARAM)(((uipos << 16) & CARET_UIPOS) | (chpos & CARET_ICHPOS)))


//
// for IPCANDIDATE/dwFlags
//
#define IPFLAG_QUERY_CAND	  0x00000001
#define IPFLAG_APPLY_CAND	  0x00000002
#define IPFLAG_APPLY_CAND_EX  0x00000004
#define IPFLAG_DISPLAY_FIX	  0x00010000
#define IPFLAG_HIDE_CAND	  0x00020000  // hide candidate box. added at 99.04.14
#define IPFLAG_BLOCK_CAND	  0x00040000  // treat this as a block. added at 99.06.24

//
// for InsertImeItem (iPos)
//
#define IPINS_CURRENT		  (0xfeeeeeee)

typedef struct tagIPCANDIDATE {
	DWORD	dwSize;					// size of this structure
	DWORD	dwFlags;				// IPFLAG_XXXX
	INT		iSelIndex;				// select index.
	INT		nCandidate;				// number of candidate
	DWORD	dwPrivateDataOffset;	// Private data offset	
	DWORD	dwPrivateDataSize;		// Private data size
	DWORD	dwOffset[1];			//Offset of String from IPCANDIDATE struct's TOP address.
} IPCANDIDATE, * PIPCANDIDATE;


// {84E913C1-BA57-11d1-AFEE-00805F0C8B6D}
DEFINE_GUID(IID_IImeIPoint1, 
0x84e913c1, 0xba57, 0x11d1, 0xaf, 0xee, 0x0, 0x80, 0x5f, 0xc, 0x8b, 0x6d);

#ifndef RC_INVOKED
#pragma pack()
#endif	/* !RC_INVOKED */

#undef	INTERFACE
#define INTERFACE	IImeIPoint1

DECLARE_INTERFACE_(IImeIPoint1, IUnknown)
{
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
	STDMETHOD_(ULONG, Release) (THIS) PURE;

	STDMETHOD(InsertImeItem)(THIS_
							 IPCANDIDATE* pImeItem,
							 INT		  iPos,		// = IPINS_CURRENT:use current IP position and 
													//				   set IP to the end of insert chars.
													// = 0-n: The offset of all composition string to set 
													//		  IP position, before insert chars. 
													//		  and IP back to original position.
							 DWORD		  *lpdwCharId) PURE;

	STDMETHOD(ReplaceImeItem)(THIS_
							 INT		  iPos,		// = IPINS_CURRENT:use current IP position and 
													//				   set IP to the end of insert chars.
													// = 0-n: The offset of all composition string to set 
													//		  IP position, before insert chars. 
													//		  and IP back to original position.
							 INT		  iTargetLen, 
							 IPCANDIDATE* pImeItem,
							 DWORD		  *lpdwCharId) PURE;

	STDMETHOD(InsertStringEx)(THIS_ 
							 WCHAR* pwSzInsert,
							 INT	cchSzInsert,
							 DWORD	*lpdwCharId) PURE;

	STDMETHOD(DeleteCompString)(THIS_ 
							 INT		  iPos,		// = IPINS_CURRENT:use current IP position .
													// = 0-n: The offset of all composition string to set 
													//		  IP position, before deleting chars. 
													//		  and IP back to original position.
							 INT		  cchSzDel) PURE;

	STDMETHOD(ReplaceCompString)(THIS_ 
							 INT		  iPos,		// = IPINS_CURRENT:use current IP position and 
													//				   set IP to the end of insert chars.
													// = 0-n: The offset of all composition string to set 
													//		  IP position, before insert chars. 
													//		  and IP back to original position.
							 INT		  iTargetLen, 
							 WCHAR		 *pwSzInsert, 
							 INT		  cchSzInsert,
							 DWORD		 *lpdwCharId) PURE;

	STDMETHOD(ControlIME)(THIS_ DWORD dwIMEFuncID, LPARAM lpara) PURE;

	STDMETHOD(GetAllCompositionInfo)(THIS_		// You can set NULL to any parameter if you don't need.
		WCHAR	**ppwSzCompStr,			// All composition string with determined area. (
										//	   This area allocated by IPOINT using CoTaskMemAlloc, so
										//	   If function is succeed caller must free this area using CoTaskMemFree.
		DWORD	**ppdwCharID,			// Array of charID coresponding to composition string.
										//	   This area allocated by IPOINT using CoTaskMemAlloc, so
										//	   If function is succeed caller must free this area using CoTaskMemFree.
										//
										// if the character of compositionstring is changed from typingstring then
										// charID is null.
										//
		INT		*pcchCompStr,			// All composition string length.
		INT		*piIPPos,				// Current IP position.
		INT		*piStartUndetStrPos,	// Undetermined string start position.
		INT		*pcchUndetStr,			// Undetermined string length.
		INT		*piEditStart,			// Editable area start position.
		INT		*piEditLen				// Editable area length.
	) PURE;


	STDMETHOD(GetIpCandidate)(THIS_ DWORD dwCharId, IPCANDIDATE **ppImeItem, INT *piColumn, INT *piCount) PURE;
										// ppImeItem is allocated by IPOINT using CoTaskMemAlloc
	STDMETHOD(SelectIpCandidate)(THIS_ DWORD dwCharId, INT iselno) PURE;

	STDMETHOD(UpdateContext)(THIS_ BOOL fGenerateMessage) PURE;

};

#ifdef __cplusplus
}			 /* Assume C declarations for C++ */
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\include\makefile.inc ===
MIDL= midl.exe
Create_files: 
	$(MIDL) imepadsv.idl /h imepadsv.h /I$(INCLUDES) /iid padguids.c /proxy padproxy.c /out $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\cddbitem.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "dbg.h"
#include "cddbitem.h"


CDDBItem::CDDBItem()
{
	m_lpwstrText = NULL;
	m_hIcon		 = NULL;
}

CDDBItem::~CDDBItem()
{
	if(m_lpwstrText) {
		MemFree(m_lpwstrText);
		m_lpwstrText = NULL;
	}
}

LPWSTR	CDDBItem::SetTextW(LPWSTR lpwstr)
{
	if(m_lpwstrText) {
		MemFree(m_lpwstrText);
	}
	m_lpwstrText = StrdupW(lpwstr);
	return m_lpwstrText;
}

LPWSTR	CDDBItem::GetTextW(VOID)
{
	return m_lpwstrText;
}

LPSTR CDDBItem::GetTextA(VOID)
{
	if(!m_lpwstrText) {
		return NULL;
	}
	WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK,
						m_lpwstrText, -1, 
						m_szTmpStr, sizeof(m_szTmpStr),
						NULL, NULL);
	return m_szTmpStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\cddbitem.h ===
#ifndef _CDDB_ITEM_H_
#define _CDDB_ITEM_H_
#include "ccom.h"
class CDDBItem : public CCommon
{
public:
	CDDBItem();
	~CDDBItem();
	LPWSTR			SetTextW(LPWSTR lpwstr);
	LPWSTR			GetTextW(VOID);
	LPSTR			GetTextA(VOID);
	LPCDDBItem	next; //for linked list;
private:
	LPWSTR			m_lpwstrText;
	CHAR			m_szTmpStr[256];
	HICON			m_hIcon;
};

#endif //_CDDB_ITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\cddbtn.h ===
#ifndef _DDBTN__H_
#define _DDBTN__H_
#include <windowsx.h>
#include "dbg.h"
#include "ddbtn.h"
#include "ccom.h" 
#include "cddbitem.h"

#ifdef UNDER_CE // macro
#undef DrawIcon
#endif // UNDER_CE

//----------------------------------------------------------------
//Button ID
//----------------------------------------------------------------
#define BID_BUTTON		0x0001
#define BID_DROPDOWN	0x0002
#define BID_ALL			(BID_BUTTON | BID_DROPDOWN)
#define BID_UNDEF		0x1000

//----------------------------------------------------------------
//Local Command ID.
//----------------------------------------------------------------
#define CMD_DROPDOWN	0x0100
//----------------------------------------------------------------
//Pushed poped, flat image style definition.
//----------------------------------------------------------------
typedef enum tagIMAGESTYLE {
	IS_FLAT = 0,
	IS_POPED,
	IS_PUSHED,
}IMAGESTYLE;

class CDDButton : public CCommon
{
public:	
	CDDButton(HINSTANCE hInst, HWND hwndParent, DWORD dwStyle, DWORD wID); 
	~CDDButton();
#ifndef UNDER_CE
	BOOL	RegisterWinClass(LPSTR lpstrClassName);
#else // UNDER_CE
	BOOL	RegisterWinClass(LPTSTR lpstrClassName);
#endif // UNDER_CE
	INT		MsgCreate			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgPaint			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDestroy			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgTimer			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgMouseMove		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgButtonDown		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT		MsgButtonUp			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT		MsgEnable			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgCaptureChanged	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgUserCommand		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgCommand			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgSetFont			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgExitMenuLoop		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgMeasureItem		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDrawItem			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDDB_AddItem		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDDB_InsertItem	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDDB_SetCurSel	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDDB_GetCurSel	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDDB_SetIcon		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDDB_SetText		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDDB_SetStyle		(HWND hwnd, WPARAM wParam, LPARAM lParam);
private:
	//----------------------------------------------------------------	
	// Private method
	//----------------------------------------------------------------	
	INT			NotifyToParent	(INT notify);
	INT			GetButtonFromPos(INT xPos, INT yPos);
	INT			SplitRect		(LPRECT lpRc,	LPRECT lpButton, LPRECT lpDrop);
	INT			DrawButton		(HDC hDC, LPRECT lpRc);
	INT			DrawThickEdge	(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT			DrawThinEdge	(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT			DrawTriangle	(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT			DrawIcon		(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT			DrawBitmap		(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT		    DrawText		(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT			GetDDBItemCount	(VOID);
	LPCDDBItem	GetDDBItemByIndex(INT index);
	LPCDDBItem	InsertDDBItem(LPCDDBItem lpCDDBItem, INT index);
	INT			DropDownItemList(VOID);
	INT			IncrementIndex	(VOID);
	INT			MenuMeasureItem	(HWND hwndOwner, LPMEASUREITEMSTRUCT lpmis);
	INT			MenuDrawItem	(HWND hwndOwner, LPDRAWITEMSTRUCT    lpdis);
	//----------------------------------------------------------------	
	//member variable
	//----------------------------------------------------------------	
	HINSTANCE			m_hInst;
	HWND				m_hwndParent;
	HWND				m_hwndFrame;
	DWORD				m_dwStyle;			//combination of DDBS_XXXX
	DWORD				m_wID;				//Window ID;
	BOOL				m_fEnable;			//Enabled or Disabled.		
	HFONT				m_hFont;			//Font handle;
	HICON				m_hIcon;			//Icon handle;
	INT					m_cxIcon;			//Icon width;
	INT					m_cyIcon;			//Icon height;
	LPWSTR				m_lpwstrText;		//Button face text;
	BOOL				m_fExitMenuLoop;	
	INT					m_bidDown;
	BOOL				m_fButton;
	BOOL				m_fDrop;
	INT					m_curDDBItemIndex;	//current selected item index.
	LPCDDBItem			m_lpCDDBItem;		//CDDBItem Linked list head.
	INT					m_cxDropDown;		//
#ifndef UNDER_CE // not support WNDCLASSEX
	WNDCLASSEX			m_tmpWC;			//to reduce stack;
#else // UNDER_CE
	WNDCLASS			m_tmpWC;			//to reduce stack;
#endif // UNDER_CE
	RECT				m_tmpBtnRc;			//to reduce stack;
	RECT				m_tmpDropRc;		//to reduce stack;
	RECT				m_tmpRect;			//to reduce stack;
	RECT				m_tmpRect2;			//to reduce stack;
	POINT				m_tmpPoint;			//to reduce stack;
	PAINTSTRUCT			m_tmpPs;			//to reduce stack;
	ICONINFO			m_tmpIconInfo;		//to reduce stack;
	BITMAP				m_tmpBitmap;		//to reduce stack;
	TPMPARAMS			m_tmpTpmParams;		//to reduce stack;
	SIZE				m_tmpSize;
	MENUITEMINFO		m_miInfo;
	BOOL				m_f16bitOnNT;
#ifndef UNDER_CE // not support NONCLIENTMETRICS
	NONCLIENTMETRICS	m_ncm;
#endif // UNDER_CE
#ifdef UNDER_CE // Windows CE does not support GetCursorPos
	POINT				m_ptEventPoint;		//ButtonDown/Up Event Point
#endif // UNDER_CE
};

#endif //_DDBTN__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\cddbtn.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "ddbtn.h"
#include "cddbtn.h"
#include "exgdiw.h"
#include "dbg.h"

static POSVERSIONINFO GetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

static BOOL ExIsWinNT(VOID)
{
	return (GetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
} 


//----------------------------------------------------------------
// <-Spec width>
//          <-->  12 point
// +--------+--+
// |		|  |
// |		|  |
// +--------+--+
//----------------------------------------------------------------
#define CXDROPDOWN 12
#define TIMERID_MONITORPOS	0x0010
#define WM_USER_COMMAND		(WM_USER+400)
//----------------------------------------------------------------
//Get, Set LPCDDButton this pointer. 
//this is set to cbWndExtra.
//See WinRegister()
//----------------------------------------------------------------
inline LPCDDButton GetThis(HWND hwnd)
{
#ifdef _WIN64
	return (LPCDDButton)GetWindowLongPtr(hwnd, 0);
#else
	return (LPCDDButton)GetWindowLong(hwnd, 0);
#endif
}
//----------------------------------------------------------------
inline LPCDDButton SetThis(HWND hwnd, LPCDDButton lpDDB)
{
#ifdef _WIN64
	return (LPCDDButton)SetWindowLongPtr(hwnd, 0, (LONG_PTR)lpDDB);
#else
	return (LPCDDButton)SetWindowLong(hwnd, 0, (LONG)lpDDB);
#endif
}

//////////////////////////////////////////////////////////////////
// Function : WndProc
// Type     : static LRESULT CALLBACK
// Purpose  : Window Procedure for Drop Down Button.
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 970905
//////////////////////////////////////////////////////////////////
static LRESULT CALLBACK WndProc(HWND	hwnd,
								UINT	uMsg,
								WPARAM	wParam,
								LPARAM	lParam)
{
	LPCDDButton lpDDB;
	if(uMsg == WM_CREATE) {
		lpDDB = (LPCDDButton)((LPCREATESTRUCT)lParam)->lpCreateParams;
		if(!lpDDB) {
			return 0;	// do not create button
		}
		SetThis(hwnd, lpDDB);
		lpDDB->MsgCreate(hwnd, wParam, lParam);
		return 1;
	}

	if(uMsg == WM_DESTROY) {
		lpDDB = GetThis(hwnd);
		if(lpDDB) {
			delete lpDDB;
			PrintMemInfo();
		}
		SetThis(hwnd, (LPCDDButton)NULL);
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	}

	lpDDB = GetThis(hwnd);
	if(!lpDDB) {
		return DefWindowProc(hwnd, uMsg, wParam, lParam);		
	}

	switch(uMsg) {
	case WM_PAINT:
		lpDDB->MsgPaint(hwnd, wParam, lParam);
		break;
	case WM_MOUSEMOVE:
		lpDDB->MsgMouseMove(hwnd, wParam, lParam);
		break;
	case WM_TIMER:
		lpDDB->MsgTimer(hwnd, wParam, lParam);
		break;
	case WM_SETFONT:
		return lpDDB->MsgSetFont(hwnd, wParam, lParam);
	case WM_LBUTTONDBLCLK:
	case WM_MBUTTONDBLCLK:
	case WM_RBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
		lpDDB->MsgButtonDown(hwnd, uMsg, wParam, lParam);
		break;
	case WM_LBUTTONUP:
	case WM_MBUTTONUP:
	case WM_RBUTTONUP:
		lpDDB->MsgButtonUp(hwnd, uMsg, wParam, lParam);
		break;
	case WM_ENABLE:
		lpDDB->MsgEnable(hwnd, wParam, lParam);
		break;
	case WM_COMMAND:
		return lpDDB->MsgCommand(hwnd, wParam, lParam); 
	case WM_USER_COMMAND:
		return lpDDB->MsgUserCommand(hwnd, wParam, lParam); 
	case WM_EXITMENULOOP:
		lpDDB->MsgExitMenuLoop(hwnd, wParam, lParam); 
		break;
	case WM_MEASUREITEM:
		return lpDDB->MsgMeasureItem(hwnd, wParam, lParam); 		
	case WM_DRAWITEM:
		return lpDDB->MsgDrawItem(hwnd, wParam, lParam);
	case DDBM_ADDITEM:		return lpDDB->MsgDDB_AddItem	(hwnd, wParam, lParam); 
	case DDBM_INSERTITEM:	return lpDDB->MsgDDB_InsertItem	(hwnd, wParam, lParam); 
	case DDBM_SETCURSEL:	return lpDDB->MsgDDB_SetCurSel	(hwnd, wParam, lParam); 
	case DDBM_GETCURSEL:	return lpDDB->MsgDDB_GetCurSel	(hwnd, wParam, lParam); 
	case DDBM_SETICON:		return lpDDB->MsgDDB_SetIcon	(hwnd, wParam, lParam); 
	case DDBM_SETTEXT:		return lpDDB->MsgDDB_SetText	(hwnd, wParam, lParam); 
	case DDBM_SETSTYLE:		return lpDDB->MsgDDB_SetStyle	(hwnd, wParam, lParam); 
#ifndef UNDER_CE // not support WM_ENTERIDLE
	case WM_ENTERIDLE:
		//----------------------------------------------------------------
		//980818:Bug found in PRC.
		//If Ctrl+Shift is assigned to switch IME,
		//Menu remains in spite of imepad has destroyed.
		//To prevent it, if Ctrl+Shift come while menu is poping up.
		//close it. 
		//----------------------------------------------------------------
		{
			if((::GetKeyState(VK_CONTROL) & 0x8000) &&
			   (::GetKeyState(VK_SHIFT)   & 0x80000)) {
				Dbg(("VK_SHIFT_CONTROL COME\n"));
				::SendMessage(hwnd, WM_CANCELMODE, 0, 0L);
				return 0;
			}
		}
		break;
#endif // UNDER_CE
	default:
		//Dbg(("Msg [0x%08x]\n", uMsg));
		break;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton
// Type     : 
// Purpose  : Constructor
// Args     : 
//          : HINSTANCE hInst 
//          : HWND hwndParent 
//          : DWORD dwStyle 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
CDDButton::CDDButton(HINSTANCE hInst, HWND hwndParent, DWORD dwStyle, DWORD wID) 
{
	m_hInst				= hInst;
	m_hwndParent		= hwndParent;
	m_dwStyle			= dwStyle;
	m_wID				= wID;
	m_cxDropDown		= CXDROPDOWN;
	m_bidDown			= BID_UNDEF;
	m_curDDBItemIndex	= -1; 
	m_fEnable		 	= TRUE;

	m_f16bitOnNT = FALSE;
#ifndef UNDER_CE // Windows CE always 32bit application
	if(ExIsWinNT()) {
		char szBuf[256];
		DWORD dwType = 0;
		::GetModuleFileName(NULL, szBuf, sizeof(szBuf));
		::GetBinaryType(szBuf, &dwType);
		if(dwType == SCS_WOW_BINARY) {
			m_f16bitOnNT = TRUE;
		}
	}
#endif // UNDER_CE
#ifdef UNDER_CE // Windows CE does not support GetCursorPos
	m_ptEventPoint.x = -1;
	m_ptEventPoint.y = -1;
#endif // UNDER_CE
}

//////////////////////////////////////////////////////////////////
// Function : ~CDDButton
// Type     : 
// Purpose  : Destructor
// Args     : 
//          : 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
CDDButton::~CDDButton()
{
	Dbg(("~CDDButton \n"));
	if(m_hIcon) {
		Dbg(("DestroyIcon\n"));
		DestroyIcon(m_hIcon); 
		m_hIcon = NULL;
	}
	if(m_hFont) {
		Dbg(("Delete FONT\n"));
		DeleteObject(m_hFont);
		m_hFont = NULL;
	}
	if(m_lpwstrText) {
		MemFree(m_lpwstrText);
		m_lpwstrText = NULL;
	}
	if(m_lpCDDBItem) {
		Dbg(("Delete CDDBItem List\n"));
		LPCDDBItem p, pTmp;
		for(p = m_lpCDDBItem; p; p = pTmp) {
			pTmp = p->next;
			delete p;
		}
		m_lpCDDBItem = NULL;
	}
}

//////////////////////////////////////////////////////////////////
// Function : RegisterWinClass
// Type     : BOOL
// Purpose  : 
// Args     : 
//          : LPSTR lpstrClassName 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
#ifndef UNDER_CE
BOOL CDDButton::RegisterWinClass(LPSTR lpstrClass)
#else // UNDER_CE
BOOL CDDButton::RegisterWinClass(LPTSTR lpstrClass)
#endif // UNDER_CE
{
	ATOM ret;
	//----------------------------------------------------------------
	//check specified class is already exist or not
	//----------------------------------------------------------------
#ifndef UNDER_CE // not support GetClassInfoEx
	if(::GetClassInfoEx(m_hInst, lpstrClass, &m_tmpWC)){
		//lpstrClass is already registerd.
		return TRUE;
	}
#else // UNDER_CE
	if(::GetClassInfo(m_hInst, lpstrClass, &m_tmpWC)){
		//lpstrClass is already registerd.
		return TRUE;
	}
#endif // UNDER_CE
	::ZeroMemory(&m_tmpWC, sizeof(m_tmpWC));
#ifndef UNDER_CE // not support RegisterClassEx
	m_tmpWC.cbSize			= sizeof(m_tmpWC);
#endif // UNDER_CE
	m_tmpWC.style			= CS_HREDRAW | CS_VREDRAW;	 /* Class style(s). */
	m_tmpWC.lpfnWndProc		= (WNDPROC)WndProc;
	m_tmpWC.cbClsExtra		= 0;						/* No per-class extra data.*/
	m_tmpWC.cbWndExtra		= sizeof(LPCDDButton);	// Set Object's pointer.	
	m_tmpWC.hInstance		= m_hInst;					/* Application that owns the class.	  */
	m_tmpWC.hIcon			= NULL; 
	m_tmpWC.hCursor			= LoadCursor(NULL, IDC_ARROW);
	m_tmpWC.hbrBackground	= (HBRUSH)NULL;
	//m_tmpWC.hbrBackground	= (HBRUSH)(COLOR_3DFACE+1);
	m_tmpWC.lpszMenuName	= NULL;						/* Name of menu resource in .RC file. */
	m_tmpWC.lpszClassName	= lpstrClass;				/* Name used in call to CreateWindow. */
#ifndef UNDER_CE // not support RegisterClassEx
	m_tmpWC.hIconSm			= NULL;
	ret = ::RegisterClassEx(&m_tmpWC);
#else // UNDER_CE
	ret = ::RegisterClass(&m_tmpWC);
#endif // UNDER_CE
	return ret ? TRUE: FALSE;
}

INT CDDButton::MsgCreate(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	m_hwndFrame = hwnd;
	return 1;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgPaint
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgPaint(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	PAINTSTRUCT ps;
	RECT		rc;
	HDC			hDCMem;
	HDC			hDC;
	HBITMAP		hBitmap, hBitmapPrev;


	::GetClientRect(hwnd, &rc);
	hDC				= ::BeginPaint(hwnd, &ps);
	hDCMem			= ::CreateCompatibleDC(hDC);
	hBitmap			= ::CreateCompatibleBitmap(hDC, rc.right - rc.left, rc.bottom - rc.top);
	hBitmapPrev		= (HBITMAP)::SelectObject(hDCMem, hBitmap);

	DrawButton(hDCMem, &rc);

	::BitBlt(hDC, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
			 hDCMem, 0, 0, SRCCOPY);

	::SelectObject(hDCMem, hBitmapPrev );

	::DeleteObject(hBitmap);
	::DeleteDC(hDCMem);
	::EndPaint(hwnd, &ps);
	return 0;
	UnrefForMsg();
}

INT CDDButton::MsgDestroy(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	return 0;
	UnrefForMsg();
}

INT CDDButton::MsgTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
#ifndef UNDER_CE // no monitor position. (not support GetCursorPos)
	static RECT  rc;
	static POINT pt;
	if(wParam == TIMERID_MONITORPOS) {
		::GetWindowRect(hwnd, &rc);
		::GetCursorPos(&pt);
		if(!PtInRect(&rc, pt)) {
			::KillTimer(hwnd, wParam);
			::InvalidateRect(hwnd, NULL, NULL);
		}
	}
#endif // UNDER_CE
	return 0;
	UnrefForMsg();
}
//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgMouseMove
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgMouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
#ifdef UNDER_CE // Windows CE does not support GetCursorPos
	m_ptEventPoint.x = (SHORT)LOWORD(lParam); 
	m_ptEventPoint.y = (SHORT)HIWORD(lParam); 
#endif // UNDER_CE
#ifndef UNDER_CE // no monitor position. (not support GetCursorPos)
	KillTimer(hwnd, TIMERID_MONITORPOS);
	SetTimer(hwnd,  TIMERID_MONITORPOS, 100, NULL);
#endif // UNDER_CE
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgButtonDown
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static RECT rc;
	Dbg(("MsgButtonDown uMsg [0x%08x] x[%d] y[%d]\n",
		 uMsg,
		 LOWORD(lParam),
		 HIWORD(lParam)));
	if(uMsg != WM_LBUTTONDOWN && uMsg != WM_LBUTTONDBLCLK ) {
		return 0;
	}

	if(!m_fEnable) 
	{
		return 0;
	}

#ifdef UNDER_CE // Windows CE does not support GetCursorPos
	m_ptEventPoint.x = (SHORT)LOWORD(lParam); 
	m_ptEventPoint.y = (SHORT)HIWORD(lParam); 
#endif // UNDER_CE
	INT bID = GetButtonFromPos(LOWORD(lParam), HIWORD(lParam)); 
	Dbg(("bID[%d] m_fExitMenuLoop [%d]\n", bID, m_fExitMenuLoop));
	switch(bID) {
	case BID_BUTTON:
		if(m_fExitMenuLoop) {
			m_fExitMenuLoop = FALSE;
		}
		m_bidDown = bID;
		if(m_f16bitOnNT) {
		}
		else {
			::SetCapture(hwnd);
		}
		break;
	case BID_ALL:
	case BID_DROPDOWN:
		if(m_fExitMenuLoop) {
			m_fExitMenuLoop = FALSE;
			m_bidDown = BID_UNDEF;
			return 0;
		}
		m_bidDown = bID;
		//----------------------------------------------------------------
		// do not call popup menu here.
		// first, end WM_XBUTTON down message and return to 
		// window message loop.
		//----------------------------------------------------------------
		//::PostMessage(hwnd, WM_COMMAND, (WPARAM)CMD_DROPDOWN, 0L);
		::PostMessage(hwnd, WM_USER_COMMAND, (WPARAM)CMD_DROPDOWN, 0L);
		break;
	case BID_UNDEF:
	default:
		break;
	}
	::InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgButtonUp
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if(!m_fEnable) 
	{
		return 0;
	}

#ifdef UNDER_CE // Windows CE does not support GetCursorPos
	m_ptEventPoint.x = (SHORT)LOWORD(lParam); 
	m_ptEventPoint.y = (SHORT)HIWORD(lParam); 
#endif // UNDER_CE
	switch(m_bidDown) {
	case BID_BUTTON:
		{
			ReleaseCapture();
			INT bid = GetButtonFromPos(LOWORD(lParam), HIWORD(lParam));
			INT newIndex;
			if(bid == BID_BUTTON) {
				newIndex = IncrementIndex();
				NotifyToParent(DDBN_CLICKED);
				if(newIndex != -1) {
					NotifyToParent(DDBN_SELCHANGE);
				}
			}
		}
		break;
	case BID_ALL:
	case BID_DROPDOWN:
		if(m_f16bitOnNT) {
			m_bidDown = BID_UNDEF;
		}
		InvalidateRect(hwnd, NULL, FALSE);
		return 0;
		break;
	}
	m_bidDown = BID_UNDEF;
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	Unref(uMsg);
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgCaptureChanged
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgCaptureChanged(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	m_bidDown = BID_UNDEF;
	::InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgExitMenuLoop
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgExitMenuLoop(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	Dbg(("WM_EXITMENULOOP\n"));
#ifndef UNDER_CE // Windows CE does not support GetCursorPos()
	::GetCursorPos(&m_tmpPoint);
	::GetClientRect(m_hwndFrame, &m_tmpRect);
	::ScreenToClient(m_hwndFrame, &m_tmpPoint);
	
	if(PtInRect(&m_tmpRect, m_tmpPoint)) {
		m_fExitMenuLoop = TRUE;
	}
	else {
		m_fExitMenuLoop = FALSE;
	}
#else  // UNDER_CE
	m_fExitMenuLoop = FALSE;
#endif // UNDER_CE
	return 0;
	UnrefForMsg();
}
//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgCommand
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	INT index;
	switch(wParam) {
	case CMD_DROPDOWN:
		NotifyToParent(DDBN_DROPDOWN);
		index = DropDownItemList();
		m_bidDown = BID_UNDEF;
		InvalidateRect(hwnd, NULL, FALSE);
		NotifyToParent(DDBN_CLOSEUP);
		//Dbg(("new Index %d\n", index));
		if(index != -1 && index != m_curDDBItemIndex) {
			m_curDDBItemIndex = index;
			NotifyToParent(DDBN_SELCHANGE);
		}

		break;
	default:
		break;
	}
	return 0;
	UnrefForMsg();
}

INT CDDButton::MsgUserCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	return MsgCommand(hwnd, wParam, lParam);
}

INT	CDDButton::MsgSetFont(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	HFONT hFont = (HFONT)wParam;
	BOOL fRedraw = LOWORD(lParam);

	HFONT hFontNew;
	if(!hFont) {
		return 0;
	}
#ifndef UNDER_CE
	LOGFONTA logFont;
#else  // UNDER_CE
	LOGFONT logFont;
#endif // UNDER_CE
	::GetObject(hFont, sizeof(logFont), &logFont);

	hFontNew = ::CreateFontIndirect(&logFont);
	if(!hFontNew) {
		return 0;
	}
	if(m_hFont) {
		::DeleteObject(m_hFont);
	}
	m_hFont = hFontNew;
	if(fRedraw) {
		::InvalidateRect(hwnd, NULL, TRUE);
	}
	return 0;
}

INT	CDDButton::MsgMeasureItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgMeasureItem START\n"));
	LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT)lParam;
	switch(lpmis->CtlType) {
	case ODT_MENU:
		Dbg(("MsgMeasureItem END\n"));
		return MenuMeasureItem(hwnd, lpmis);
		break;
	}
	return 0;
	UnrefForMsg();
}

INT	CDDButton::MsgDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;
	switch(lpdis->CtlType) {
	case ODT_MENU:
		return MenuDrawItem(hwnd, lpdis);
		break;
	default:
		break;
	}
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgDDB_AddItem
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgDDB_AddItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	LPDDBITEM	lpItem = (LPDDBITEM)lParam;
	LPCDDBItem	lpCItem = new CDDBItem;
	if(!lpCItem) {
		return -1;
	}
	lpCItem->SetTextW(lpItem->lpwstr);
	InsertDDBItem(lpCItem, -1);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgDDB_InsertItem
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgDDB_InsertItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	LPDDBITEM	lpItem = (LPDDBITEM)lParam;
	LPCDDBItem	lpCItem = new CDDBItem;
	if(!lpCItem) {
		return -1;
	}
	lpCItem->SetTextW(lpItem->lpwstr);
	InsertDDBItem(lpCItem, (INT)wParam);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgDDB_SetCurSel
// Type     : INT
// Purpose  : Set current selection.
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam			INT index
//          : LPARAM lParam			no use:
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgDDB_SetCurSel(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	INT count = GetDDBItemCount();
	if(count <=0) {
		return -1;
	}
	if(0 <= (INT)wParam && count <= (INT)wParam) {
		return -1;
	}
	m_curDDBItemIndex = (INT)wParam;
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgDDB_GetCurSel
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam		no use.
//          : LPARAM lParam		no use.
// Return   : return current item's index. (ZERO based)
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgDDB_GetCurSel(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	return m_curDDBItemIndex;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgDDB_SetIcon
// Type     : INT
// Purpose  : Set new icon.
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam		HICON hIcon.	
//          : LPARAM lParam		no use.	
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgDDB_SetIcon(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgDDB_SetIcon: wParam[0x%08x] lParam[0x%08x]\n", wParam, lParam));
	if((HICON)wParam == NULL) {
		Dbg(("MsgDDB_SetIcon: ERROR END\n"));
		return -1;
	}
	//if icon style is not set, destroy specified icon
	if(!(m_dwStyle & DDBS_ICON)) {
		DestroyIcon((HICON)wParam);
		return -1;
	} 
	if(m_hIcon) {
		DestroyIcon(m_hIcon);
	} 
	m_hIcon = (HICON)wParam;

	//----------------------------------------------------------------
	//Get Icon width and height.
	//----------------------------------------------------------------
#ifndef UNDER_CE // Windows CE does not support GetIconInfo()
	ZeroMemory(&m_tmpIconInfo, sizeof(m_tmpIconInfo));
	::GetIconInfo(m_hIcon, &m_tmpIconInfo);
	Dbg(("fIcon    [%d]\n",		m_tmpIconInfo.fIcon ));
	Dbg(("xHotspot [%d]\n",		m_tmpIconInfo.xHotspot ));
	Dbg(("yHotspot [%d]\n",		m_tmpIconInfo.yHotspot ));
	Dbg(("hbmMask  [0x%08x]\n", m_tmpIconInfo.hbmMask ));
	Dbg(("hbmColor [0x%08x]\n", m_tmpIconInfo.hbmColor ));

	if(m_tmpIconInfo.hbmMask) {
		GetObject(m_tmpIconInfo.hbmMask, sizeof(m_tmpBitmap), &m_tmpBitmap);
		Dbg(("bmWidth[%d] bmHeight[%d]\n", 
			 m_tmpBitmap.bmWidth,
			 m_tmpBitmap.bmHeight));
		DeleteObject(m_tmpIconInfo.hbmMask);
		m_cxIcon = m_tmpBitmap.bmWidth;
		m_cyIcon = m_tmpBitmap.bmHeight;
	}
	if(m_tmpIconInfo.hbmColor) {
		DeleteObject(m_tmpIconInfo.hbmColor);
	}
#else // UNDER_CE
	m_cxIcon = GetSystemMetrics(SM_CXSMICON);
	m_cyIcon = GetSystemMetrics(SM_CYSMICON);
#endif // UNDER_CE
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgDDB_SetText
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND	 hwnd 
//          : WPARAM wParam		LPWSTR lpwstr: null terminated Unicode string.
//          : LPARAM lParam		no use.
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgDDB_SetText(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	if(!(LPWSTR)wParam) {
		return -1;
	}

	if( ((LPWSTR)wParam)[0] == (WCHAR)0x0000) {
		return -1;
	} 

	if(m_lpwstrText) {
		MemFree(m_lpwstrText);
	}

	m_lpwstrText = StrdupW((LPWSTR)wParam);
#ifdef MSAA
	if(::IsWindowUnicode(hwnd)) {
		::SetWindowTextW(hwnd, m_lpwstrText);
	}
	else {
		if(m_lpwstrText) {
			INT len = ::lstrlenW(m_lpwstrText);
			LPSTR lpstr = (LPSTR)MemAlloc((len + 1)*sizeof(WCHAR));
			if(lpstr) {
				
#if 0 //for remove warning
				INT ret = ::WideCharToMultiByte(CP_ACP,
												WC_COMPOSITECHECK,
												m_lpwstrText, -1,
												lpstr, (len+1)*sizeof(WCHAR),
												0, 0);
#endif
				::WideCharToMultiByte(CP_ACP,
									  WC_COMPOSITECHECK,
									  m_lpwstrText, -1,
									  lpstr, (len+1)*sizeof(WCHAR),
									  0, 0);
				::SetWindowTextA(hwnd, lpstr);
				MemFree(lpstr);
			}
		}
	}
#endif
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	Unref(lParam);
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgDDB_SetStyle
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam		DWORD dwStyle:
//          : LPARAM lParam		no use.
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgDDB_SetStyle(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	DWORD dwStyle = (DWORD)wParam;
#if 0 //DDBS_TEXT is 0...
	if((dwStyle & DDBS_TEXT) &&
	   (dwStyle & DDBS_ICON)) {
		return -1;
	}
#endif
	m_dwStyle = dwStyle;
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	Unref(hwnd);
	Unref(lParam);
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::MsgEnable
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::MsgEnable(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	//Dbg(("MsgEnabled START wParam[%d]\n", wParam));
	m_fEnable = (BOOL)wParam;
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	UnrefForMsg();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\ccom.h ===
#ifndef _DDBTN_COM_H_
#define _DDBTN_COM_H_

#ifdef UNDER_CE // not support GlobalAlloc
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

#ifdef _DEBUG
#include "dbg.h"
static INT countAlloced;
static INT countFreed;
static INT curSize;
inline VOID _printMemInfo(VOID)
{
	Dbg(("countAlloced %d\n", countAlloced));
	Dbg(("countFreed   %d\n", countFreed));
	Dbg(("curSize      %d\n", curSize));
}
#define PrintMemInfo()	_printMemInfo()
#else
#define PrintMemInfo()
#endif

inline VOID *MemAlloc(size_t size)
{
	LPVOID p = GlobalAlloc(GMEM_FIXED, size);
#ifdef _DEBUG
	if(p) {
		countAlloced++;
		curSize += (INT)GlobalSize(p);
		Dbg(("Alloc: %4d byte\n", GlobalSize(p)));
	}
#endif
	return p;
}

inline BOOL MemFree(LPVOID p)
{
#ifdef _DEBUG
	if(p) {
		countFreed++;
		curSize -= (INT)GlobalSize(p);
		Dbg(("Free : %4d byte\n", GlobalSize(p)));
	}
#endif
	BOOL ret = FALSE;
	if(p) {
		LPVOID lpRet = (LPVOID)GlobalFree(p);
		if(NULL == lpRet) {
			ret = TRUE;
		}
	}
	return ret;
}

//----------------------------------------------------------------
inline LPWSTR StrdupW(LPWSTR lpwstr)
{
	LPWSTR p;
	INT len;
	if(!lpwstr) {
		return NULL;
	}
	len = lstrlenW(lpwstr);
	p = (LPWSTR)MemAlloc((len + 1)* sizeof(WCHAR) );
	if(p) {
		CopyMemory(p, lpwstr, len * sizeof(WCHAR));
		p[len] = (WCHAR)0x0000;
	}
	return p;
}

class CCommon {
public:
	void *operator new(size_t size) {
		BYTE *p = (BYTE *)MemAlloc(size);
		if(p) {
			ZeroMemory(p, size);
		}
		return (void *)p;
	}
	void operator delete(void *pv) {
		if(pv) {
			MemFree(pv);
		}
	}
};

// to reference each other
class CDDButton;
typedef CDDButton *LPCDDButton;

class CDDBItem;
typedef CDDBItem *LPCDDBItem;



//----------------------------------------------------------------
#define UnrefForMsg()	UNREFERENCED_PARAMETER(hwnd);\
						UNREFERENCED_PARAMETER(wParam);\
						UNREFERENCED_PARAMETER(lParam)

#define UnrefForCmd()	UNREFERENCED_PARAMETER(hwnd);\
						UNREFERENCED_PARAMETER(wCommand);\
						UNREFERENCED_PARAMETER(wNotify);\
						UNREFERENCED_PARAMETER(hwndCtrl)

#define Unref(a)		UNREFERENCED_PARAMETER(a)
#define Unref1(a)		UNREFERENCED_PARAMETER(a)
#define Unref2(a, b)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b)
#define Unref3(a,b,c)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b);\
						UNREFERENCED_PARAMETER(c)

#define Unref4(a,b,c,d)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b);\
						UNREFERENCED_PARAMETER(c);\
						UNREFERENCED_PARAMETER(d)

#endif //_DDBTN_COM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\cddbtnp.cpp ===
//#define WIN32_LEAN_AND_MEAN
#define OEMRESOURCE
#include <windows.h>
#include <windowsx.h>
#include "ddbtn.h"
#include "cddbtn.h"
#include "dbg.h"
#include "exgdiw.h"

//----------------------------------------------------------------
//Menu Index mask 
//----------------------------------------------------------------
#define INDEX_MASK 0x7000


//----------------------------------------------------------------
//Private method definition
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function : CDDButton::NotifyToParent
// Type     : INT
// Purpose  : Send WM_COMMAND to Parent window procedure.
// Args     : 
//          : INT notify 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::NotifyToParent(INT notify)
{
	SendMessage(m_hwndParent, 
				WM_COMMAND, 
				MAKEWPARAM(m_wID, notify),
				(LPARAM)m_hwndFrame);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::GetButtonFromPos
// Type     : INT
// Purpose  : 
// Args     : 
//          : INT xPos 
//          : INT yPos 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::GetButtonFromPos(INT xPos, INT yPos)
{
	static RECT rc, rcBtn, rcDrop;
	POINT  pt;
	GetClientRect(m_hwndFrame, &rc);
	pt.x = xPos;
	pt.y = yPos;

	if(m_dwStyle & DDBS_NOSEPARATED) {
		if(PtInRect(&rc, pt)) {
			return BID_ALL;
		}
	}
	else {
		SplitRect(&rc, &rcBtn, &rcDrop);
		if(PtInRect(&rcBtn, pt)) {
			return BID_BUTTON;
		}
		if(PtInRect(&rcDrop, pt)) {
			return BID_DROPDOWN;
		}
	} 
	return BID_UNDEF;
}

INT CDDButton::SplitRect(LPRECT lpRc,	LPRECT lpButton, LPRECT lpDrop)
{
	*lpButton = *lpDrop = *lpRc;
	
	if((lpRc->right - lpRc->left) <= m_cxDropDown) {
		lpButton->right = lpRc->left;
	}
	else {
		lpButton->right = lpRc->right - m_cxDropDown;
		lpDrop->left = lpRc->right - m_cxDropDown;
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::DrawButton
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::DrawButton(HDC hDC, LPRECT lpRc)
{
	POINT pt;
#if 0
	Dbg(("DrawButton START l[%d] t[%d] r[%d] b[%d]\n", 
		 lpRc->left,
		 lpRc->top,
		 lpRc->right,
		 lpRc->bottom));
#endif

#ifndef UNDER_CE // Windows CE does not support GetCursorPos
	GetCursorPos(&pt);
	ScreenToClient(m_hwndFrame, &pt);
#else // UNDER_CE
	pt = m_ptEventPoint;
#endif // UNDER_CE
	INT curBID = GetButtonFromPos(pt.x, pt.y);
	//Dbg(("--->curBID    0x%04x\n", curBID));
	//Dbg(("--->m_bidDown 0x%04x\n", m_bidDown));
	SplitRect(lpRc, &m_tmpBtnRc, &m_tmpDropRc);

	IMAGESTYLE styleBtn, styleDrop;
	DWORD		dwOldTextColor, dwOldBkColor;

	dwOldBkColor	= ::SetBkColor(hDC, GetSysColor(COLOR_3DFACE));
	dwOldTextColor	= ::SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
#ifndef UNDER_CE
	::FillRect(hDC, lpRc, (HBRUSH)(COLOR_3DFACE +1));
#else // UNDER_CE
	::FillRect(hDC, lpRc, GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE

	switch(m_bidDown) {
	case BID_UNDEF: // no Button was clicked.
		if(m_dwStyle & DDBS_NOSEPARATED) {
			if(curBID == BID_ALL) {
				styleBtn  = styleDrop = IS_POPED;
			}
			else {
				if(m_dwStyle & DDBS_FLAT) {
					styleBtn  = styleDrop = IS_FLAT;
				}
				else  {
					styleBtn  = styleDrop = IS_POPED;
				}
			}
		}
		else {
			if(m_dwStyle & DDBS_FLAT) {
				if( (curBID == BID_BUTTON) || (curBID == BID_DROPDOWN) ) {
					styleBtn  = styleDrop = IS_POPED;
				}
				else {
					styleBtn  = styleDrop = IS_FLAT;
				}
			}
			else {
				styleBtn = styleDrop = IS_POPED;
			}
		}
		break;
	case BID_BUTTON:
		styleBtn  = (curBID == BID_BUTTON) ? IS_PUSHED : IS_POPED;
		styleDrop = IS_POPED;
		break;
	case BID_DROPDOWN:
		styleBtn  = IS_POPED;
		styleDrop = IS_PUSHED;
		break;
	case BID_ALL: //DDBS_NOSEPARATED style.
		styleBtn = styleDrop = IS_PUSHED;
		break;
	default:
		return 0;
		break;
	}

	//Dbg(("styleBtn [%d]\n", styleBtn));
	if(m_dwStyle & DDBS_NOSEPARATED) {
		if(m_dwStyle & DDBS_THINEDGE) { 
			DrawThinEdge(hDC, lpRc,  styleBtn);
		}
		else {
			DrawThickEdge(hDC, lpRc, styleBtn);
		}
	}
	else {
		if(m_dwStyle & DDBS_THINEDGE) {
			DrawThinEdge(hDC, &m_tmpBtnRc,  styleBtn);
			DrawThinEdge(hDC, &m_tmpDropRc, styleDrop);
		}
		else {
			DrawThickEdge(hDC, &m_tmpBtnRc,  styleBtn);
			DrawThickEdge(hDC, &m_tmpDropRc, styleDrop);
		}
	}
	if(m_dwStyle & DDBS_ICON) {
		DrawIcon(hDC, &m_tmpBtnRc, styleBtn);
	}
	else {
		DrawText(hDC, &m_tmpBtnRc, styleBtn);
	}
	DrawTriangle(hDC, &m_tmpDropRc, styleDrop);

	::SetBkColor(hDC, dwOldBkColor);
	::SetTextColor(hDC, dwOldTextColor);

	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::DrawThickEdge
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::DrawThickEdge(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	DWORD dwStyle;
	switch(style) {
	case IS_PUSHED:
		dwStyle = DFCS_PUSHED;
		break;
	case IS_POPED:
		dwStyle = 0;
		break;
	case IS_FLAT:	// do not draw 
	default:
		return 0;
		break;
	}
	::DrawFrameControl(hDC, lpRc, DFC_BUTTON, DFCS_BUTTONPUSH | dwStyle);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::DrawThinEdge
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::DrawThinEdge(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	HPEN hPenPrev, hPenNew=0 ;
	HPEN hPenTopLeft = 0;
	HPEN hPenBottomRight = 0;

	switch(style) {
	case IS_PUSHED:
		hPenNew = hPenTopLeft	  = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
				  hPenBottomRight = (HPEN)GetStockObject(WHITE_PEN);
		break;
	case IS_POPED:
		hPenTopLeft = (HPEN)GetStockObject(WHITE_PEN);
		hPenNew = hPenBottomRight = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
		break;
	case IS_FLAT:	// do not draw 
		return 0;
		break;
	}

	hPenPrev = (HPEN)SelectObject(hDC, hPenTopLeft);
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
	MoveToEx(hDC, lpRc->left, lpRc->top, NULL);
	LineTo(hDC,   lpRc->right, lpRc->top);
	MoveToEx(hDC, lpRc->left, lpRc->top, NULL);
	LineTo(hDC,   lpRc->left, lpRc->bottom);
#else // UNDER_CE
	{
		POINT pts[] = {{lpRc->left,  lpRc->bottom},
					   {lpRc->left,  lpRc->top},
					   {lpRc->right, lpRc->top}};
		Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
	}
#endif // UNDER_CE

	SelectObject(hDC, hPenBottomRight);
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
	MoveToEx(hDC, lpRc->right -1, lpRc->top - 1, NULL);
	LineTo(hDC,   lpRc->right -1, lpRc->bottom);
	MoveToEx(hDC, lpRc->left + 1, lpRc->bottom -1, NULL);
	LineTo(hDC,   lpRc->right -1, lpRc->bottom -1);
#else // UNDER_CE
	{
		POINT pts[] = {{lpRc->right - 1, lpRc->top    - 1},
					   {lpRc->right - 1, lpRc->bottom - 1},
					   {lpRc->left  + 1, lpRc->bottom - 1}};
		Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
	}
#endif // UNDER_CE

	SelectObject(hDC, hPenPrev);
	DeleteObject(hPenNew);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::DrawTriangle
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::DrawTriangle	(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	POINT pt;
	HPEN hPenPrev, hPen;
	INT sunken; 
	if ( m_fEnable )
	{
		hPen = (HPEN)GetStockObject(BLACK_PEN);
	}
	else
	{
	 	hPen = CreatePen(PS_SOLID,1,GetSysColor(COLOR_GRAYTEXT));   // dark gray color
	}
	hPenPrev = (HPEN)SelectObject(hDC, hPen);

	switch(style) {
	case IS_PUSHED:
		sunken = 1;
		break;
	case IS_FLAT:
	case IS_POPED:
	default:
		sunken = 0;
		break;
	}
	pt.x = lpRc->left + (lpRc->right  - lpRc->left)/2 - 3 + sunken; 
	pt.y = lpRc->top  + (lpRc->bottom - lpRc->top )/2 - 2 + sunken; 
	
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
	MoveToEx(hDC, pt.x,     pt.y, NULL);    
	LineTo(hDC,   pt.x + 5, pt.y);
	pt.y++;
	MoveToEx(hDC, pt.x + 1, pt.y, NULL);
	LineTo(hDC,   pt.x + 4, pt.y);
	pt.y++;
	MoveToEx(hDC, pt.x + 2, pt.y, NULL);
	LineTo(hDC,   pt.x + 3, pt.y);
#else // UNDER_CE
	{
		POINT pts[] = {{pt.x, pt.y}, {pt.x + 5, pt.y}};
		Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
	}
	pt.y++;
	{
		POINT pts[] = {{pt.x + 1, pt.y}, {pt.x + 4, pt.y}};
		Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
	}
	pt.y++;
	{
		POINT pts[] = {{pt.x + 2, pt.y}, {pt.x + 3, pt.y}};
		Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
	}
#endif // UNDER_CE
	hPen = (HPEN)SelectObject(hDC, hPenPrev);
	if ( !m_fEnable )
	{
	 	DeletePen(hPen);
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::DrawIcon
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::DrawIcon(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	if(!m_hIcon) {
		return -1;
	}

	INT sunken, xPos, yPos;
	switch(style) {
	case IS_PUSHED:
		sunken = 1;
		break;
	case IS_POPED:
	case IS_FLAT:
	default:
		sunken = 0;
		break;
	}
	//----------------------------------------------------------------
	//centering Icon
	xPos = lpRc->left + ((lpRc->right  - lpRc->left) - m_cxIcon)/2;
	yPos = lpRc->top  + ((lpRc->bottom - lpRc->top)  - m_cyIcon)/2;
	if ( m_fEnable )
	{
		DrawIconEx(hDC,				//HDC hdc,// handle to device context
			   xPos + sunken,	//int xLeft,// x-coordinate of upper left corner
			   yPos + sunken,	//int yTop,// y-coordinate of upper left corner
			   m_hIcon,			//HICON hIcon,// handle to icon to draw
#ifndef UNDER_CE // CE specific
			   m_cxIcon,		//int cxWidth,// width of the icon
			   m_cyIcon,		//int cyWidth,// height of the icon
#else // UNDER_CE
			   0,0,
#endif // UNDER_CE
			   0,				//UINT istepIfAniCur,// index of frame in animated cursor
			   NULL,			//HBRUSH hbrFlickerFreeDraw,// handle to background brush
			   DI_NORMAL);		//UINT diFlags// icon-drawing flags
	}
	else
	{
#ifndef UNDER_CE // Windows CE does not support DrawState
	 	DrawState(hDC,NULL,NULL,(LPARAM)m_hIcon,0,
			xPos + sunken,
			yPos + sunken,
			m_cxIcon,
			m_cyIcon,
			DST_ICON | DSS_DISABLED);
#else // UNDER_CE
		// needs to create or replace DrawState() !!!
		DBGCHK(TEXT("CDDButton::DrawIcon"), FALSE);
#endif // UNDER_CE
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::DrawBitmap
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::DrawBitmap(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	return 0;
	UNREFERENCED_PARAMETER(hDC);
	UNREFERENCED_PARAMETER(lpRc);
	UNREFERENCED_PARAMETER(style);
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::DrawText
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
inline BOOL MIN(INT a, INT b)
{
	if(a > b) {
		return b;
	}
	else {
		return a;
	}
}
INT CDDButton::DrawText(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	static POINT pt;
	static RECT	 rc;
	INT sunken, len;
	if(!m_lpwstrText) {
		return -1;
	}
	len = lstrlenW(m_lpwstrText);
	HFONT hFontPrev;
	if(m_hFont) {
		hFontPrev = (HFONT)SelectObject(hDC, m_hFont); 
	}
	else {
		hFontPrev = (HFONT)SelectObject(hDC, (HFONT)GetStockObject(DEFAULT_GUI_FONT));
	}

	ExGetTextExtentPoint32W(hDC, 
							m_lpwstrText, 
							len, 
							&m_tmpSize);
	if((lpRc->right - lpRc->left) > m_tmpSize.cx) {
		pt.x = lpRc->left + ((lpRc->right - lpRc->left) - m_tmpSize.cx)/2;
	}
	else {
		pt.x = lpRc->left+2; //2 is edge space
	}
	
	if((lpRc->bottom - lpRc->top) > m_tmpSize.cy) {
		pt.y = lpRc->top + ((lpRc->bottom - lpRc->top) - m_tmpSize.cy)/2;
	}
	else {
		pt.y = lpRc->top+2; //2 is edge space 
	}
	switch(style) {
	case IS_PUSHED:
		sunken = 1;
		break;
	case IS_POPED:
	case IS_FLAT:
	default:
		sunken = 0;
	}
	rc.left  = pt.x;
	rc.right = MIN(pt.x + m_tmpSize.cx, lpRc->right-2);
	rc.top   = pt.y;
	rc.bottom = MIN(pt.y + m_tmpSize.cy, lpRc->bottom-2 );
	ExExtTextOutW(hDC,
					pt.x + sunken, 
					pt.y + sunken,
					ETO_CLIPPED | ETO_OPAQUE,
					&rc, 
					m_lpwstrText,
					len,
					NULL);
	SelectObject(hDC, hFontPrev);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::GetDDBItemCount
// Type     : INT
// Purpose  : 
// Args     : 
//          : VOID
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT	CDDButton::GetDDBItemCount(VOID)
{
	INT i;
	LPCDDBItem *pp;
	for(i = 0, pp = &m_lpCDDBItem; *pp; pp = &(*pp)->next, i++) {
	}
	return i;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::GetDDBItemByIndex
// Type     : LPCDDBItem
// Purpose  : 
// Args     : 
//          : INT index 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
LPCDDBItem CDDButton::GetDDBItemByIndex(INT index)
{
	INT i;
	LPCDDBItem *pp;
	for(i = 0, pp = &m_lpCDDBItem; *pp; pp = &(*pp)->next, i++) {
		if(i == index) {
			break;
		}
	}
	return *pp;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::InsertDDBItem
// Type     : LPCDDBItem
// Purpose  : 
// Args     : 
//          : LPCDDBItem lpCDDBItem 
//          : INT index 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
LPCDDBItem CDDButton::InsertDDBItem(LPCDDBItem lpCDDBItem, INT index)
{
	INT i;
	LPCDDBItem *pp;
	for(i = 0, pp = &m_lpCDDBItem; *pp; pp = &(*pp)->next, i++) {
		if(i == index) {
			lpCDDBItem->next = (*pp)->next;
			*pp = lpCDDBItem;
			return lpCDDBItem;
		}
	}
	*pp = lpCDDBItem;
	return lpCDDBItem;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::DropDownItemList
// Type     : INT
// Purpose  : 
// Args     : 
//          : VOID
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////

INT CDDButton::DropDownItemList(VOID)
{
	POINT	pt;
	INT count;
	if((count = GetDDBItemCount()) <= 0) {
		return 0;
	}
	HMENU hMenu = ::CreatePopupMenu();
	INT i;

	for(i = 0; i < count; i++) {
#ifndef UNDER_CE // Windows CE does not support InsertMenuItem
		::ZeroMemory(&m_miInfo, sizeof(m_miInfo));
#endif // UNDER_CE
		LPCDDBItem lpItem = GetDDBItemByIndex(i);
		if(!lpItem) {
			continue;
		}
#ifndef UNDER_CE // Windows CE does not support InsertMenuItem
		m_miInfo.cbSize		= sizeof(m_miInfo);
		m_miInfo.fMask		= MIIM_TYPE | MIIM_ID | MIIM_DATA;
		m_miInfo.fType		= MFT_OWNERDRAW;
		m_miInfo.fState		= MFS_ENABLED;
		m_miInfo.wID		= INDEX_MASK + i;
		m_miInfo.dwItemData	= (ULONG_PTR)lpItem;
		::InsertMenuItem(hMenu, i, TRUE, &m_miInfo);
#else // UNDER_CE
		// Windows CE does not support OBM_CHECK
		::InsertMenu(hMenu, i, MF_BYPOSITION | MF_STRING | MF_ENABLED |
					 (m_curDDBItemIndex == i ? MF_CHECKED : MF_UNCHECKED),
					 INDEX_MASK + i, lpItem->GetTextW());
//		::InsertMenu(hMenu, i, MF_BYPOSITION | MF_OWNERDRAW | MF_ENABLED,
//					 INDEX_MASK + i, (LPCTSTR)lpItem);
#endif // UNDER_CE
	}

	//----------------------------------------------------------------
	// calc menu position
	//----------------------------------------------------------------
	::GetWindowRect(m_hwndFrame, &m_tmpRect);
	pt.x = m_tmpRect.left;
	pt.y = m_tmpRect.bottom;
	m_tmpTpmParams.cbSize	 = sizeof(m_tmpTpmParams);
	m_tmpTpmParams.rcExclude = m_tmpRect;
	Dbg(("Before Call TrackPopupMenuEx\n"));
	INT newIndex = ::TrackPopupMenuEx(hMenu,
									  TPM_VERTICAL | TPM_RETURNCMD, 
									  pt.x,
									  pt.y,
									  m_hwndFrame,  
									  &m_tmpTpmParams);
	Dbg(("After Call TrackPopupMenuEx\n"));
	if(newIndex == 0) { //Do NOT selected, but menu has closed.
#ifdef UNDER_CE // Windows CE does not support GetCursorPos()
		MSG msg;
		if(PeekMessage(&msg, m_hwndFrame,
			WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_NOREMOVE)){
			if(m_hwndFrame == msg.hwnd){
				POINT pt = {(SHORT)LOWORD(msg.lParam),
							(SHORT)HIWORD(msg.lParam)};
				RECT rc;
				GetClientRect(m_hwndFrame, &rc);
				if(PtInRect(&rc, pt)) {
					m_fExitMenuLoop = TRUE;
				}
				else {
					m_fExitMenuLoop = FALSE;
				}
			}
		}
#endif // UNDER_CE
		return -1;
	}
	if(0 <=  (newIndex - INDEX_MASK) && (newIndex - INDEX_MASK) < count) {
		return newIndex - INDEX_MASK;
	}
	return -1;
}

//////////////////////////////////////////////////////////////////
// Function : CDDButton::IncrementIndex
// Type     : INT
// Purpose  : increment and circurate m_curDDBItemIndex
// Args     : 
//          : VOID
// Return   : new Index;
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CDDButton::IncrementIndex(VOID)
{
	if(m_curDDBItemIndex == -1) {
		return -1;
	}
	INT count = GetDDBItemCount();
	if(count == 0) {
		return -1;
	}
	m_curDDBItemIndex = (m_curDDBItemIndex+1) % count; 
	return m_curDDBItemIndex;
}

INT	CDDButton::MenuMeasureItem(HWND hwndOwner, LPMEASUREITEMSTRUCT lpmis)
{
#ifndef UNDER_CE // Windows CE does not support OBM_CHECK (OWNERDRAW)
	//Dbg(("MenuMeasureItem START\n"));
	SIZE	size;
	HDC		hDC;
	//INT checkW = ::GetSystemMetrics(SM_CXMENUCHECK);
	//INT checkH = ::GetSystemMetrics(SM_CYMENUCHECK);


	LPCDDBItem lpCItem = (LPCDDBItem)lpmis->itemData;
	if(!lpCItem) {
		return 0;
	}

	hDC = ::GetDC(hwndOwner);
	HFONT hFontPrev = NULL;
	HFONT hFontMenu = NULL;
	if(m_hFont) {
		hFontPrev = (HFONT)::SelectObject(hDC, m_hFont);
	}
	else {
		m_ncm.cbSize = sizeof(m_ncm);
		::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &m_ncm, 0);
		hFontMenu = ::CreateFontIndirect(&m_ncm.lfMenuFont);
		if(hFontMenu) {
			hFontPrev = (HFONT)::SelectObject(hDC, hFontMenu);
		}
	}
	::ExGetTextExtentPoint32W(hDC, 
							  lpCItem->GetTextW(), 
							  ::lstrlenW(lpCItem->GetTextW()),
							  &size);
	TEXTMETRIC tm;
	::GetTextMetrics(hDC, &tm);

	if(hFontPrev) {
		::SelectObject(hDC, hFontPrev);
	}
	if(hFontMenu) {
		::DeleteObject(hFontMenu);
	}
	::ReleaseDC(hwndOwner, hDC);
	//----------------------------------------------------------------
	//Use magic number.
	//----------------------------------------------------------------
	lpmis->itemHeight = ::GetSystemMetrics(SM_CYMENUSIZE) - 2;
	lpmis->itemWidth  = lpmis->itemHeight + size.cx;
	//Dbg(("MenuMeasureItem END\n"));
#endif // UNDER_CE
	return TRUE;
}

INT	CDDButton::MenuDrawItem(HWND hwndOwner, LPDRAWITEMSTRUCT lpdis)
{
#ifndef UNDER_CE // Windows CE does not support OBM_CHECK (OWNERDRAW)
	//Dbg(("MenuDrawItem START\n"));
	LPCDDBItem lpCItem;
	SIZE size;
	DWORD	dwOldTextColor, dwOldBkColor; 

	if(!lpdis) { DBGAssert(FALSE); return 0;}	

    Dbg(("itemID [%d]\n", lpdis->itemID));
	

	lpCItem = (LPCDDBItem)lpdis->itemData;
	if(lpdis->itemState & ODS_SELECTED) {
#ifndef UNDER_CE
		::FillRect(lpdis->hDC, &lpdis->rcItem, (HBRUSH)(COLOR_HIGHLIGHT + 1));
#else // UNDER_CE
		::FillRect(lpdis->hDC, &lpdis->rcItem, GetSysColorBrush(COLOR_HIGHLIGHT));
#endif // UNDER_CE
		dwOldBkColor   = ::SetBkColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
		dwOldTextColor = ::SetTextColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
	}
	else {
#ifndef UNDER_CE
		::FillRect(lpdis->hDC, &lpdis->rcItem, (HBRUSH)(COLOR_MENU + 1));
#else // UNDER_CE
		::FillRect(lpdis->hDC, &lpdis->rcItem, GetSysColorBrush(COLOR_MENU));
#endif // UNDER_CE
		dwOldBkColor   = ::SetBkColor(lpdis->hDC, GetSysColor(COLOR_MENU));
		dwOldTextColor = ::SetTextColor(lpdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
	}

	HBITMAP	hBmp = NULL;
	INT offsetX, offsetY;
	TEXTMETRIC tm;

	HFONT hFontPrev = NULL;
	if(m_hFont) {
		hFontPrev = (HFONT)::SelectObject(lpdis->hDC, m_hFont);
	}
	::GetTextMetrics(lpdis->hDC, &tm);
	INT height = tm.tmHeight + tm.tmExternalLeading;

	::ExGetTextExtentPoint32W(lpdis->hDC, 
							  lpCItem->GetTextW(), 
							  ::lstrlenW(lpCItem->GetTextW()),
							  &size);
	//----------------------------------------------------------------
	//In DropDownItemList(), item Id is command id with INDEX_MASK
	//To get real index, remove INDEX_MASK
	//----------------------------------------------------------------
	if(m_curDDBItemIndex == ((INT)lpdis->itemID & ~INDEX_MASK)) {
		//----------------------------------------------------------------
		//Draw checked mark
		//----------------------------------------------------------------
		hBmp = ::LoadBitmap(NULL, MAKEINTRESOURCE(OBM_CHECK));
		if(hBmp) {
			BITMAP bmp;
			::GetObject(hBmp, sizeof(bmp), &bmp);
			offsetX = (height - bmp.bmWidth )/2;
			offsetY = (lpdis->rcItem.bottom - lpdis->rcItem.top - bmp.bmHeight)/2;
			::DrawState(lpdis->hDC,
						NULL,
						NULL,
						(LPARAM)hBmp,
						(WPARAM)0,
						lpdis->rcItem.left + offsetX,
						lpdis->rcItem.top  + offsetY,
						bmp.bmWidth, bmp.bmHeight, 
						DST_BITMAP | DSS_NORMAL);
			::DeleteObject(hBmp);
		}
	}
	offsetX = size.cy;
	offsetY = ((lpdis->rcItem.bottom - lpdis->rcItem.top)-size.cy)/2;
	::ExExtTextOutW(lpdis->hDC,
					lpdis->rcItem.left + height, //offsetX,
					lpdis->rcItem.top +offsetY,
					ETO_CLIPPED,
					&lpdis->rcItem,
					lpCItem->GetTextW(),
					::lstrlenW(lpCItem->GetTextW()),
					NULL);

	//----------------------------------------------------------------
	//Restore DC
	//----------------------------------------------------------------
	if(hFontPrev) {
		::SelectObject(lpdis->hDC, hFontPrev);
	}
	::SetBkColor(lpdis->hDC,   dwOldBkColor);
	::SetTextColor(lpdis->hDC, dwOldTextColor); 

	//Dbg(("MenuDrawItem END\n"));
#endif // UNDER_CE
	return TRUE;
	UNREFERENCED_PARAMETER(hwndOwner);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\dbg.cpp ===
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdarg.h>
#include "dbg.h"
#include <stdio.h>

static IsWinNT()
{
	static OSVERSIONINFO os;
	if(os.dwOSVersionInfoSize == 0) { 
		os.dwOSVersionInfoSize = sizeof(os);
		::GetVersionEx(&os);
	}
	return (os.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

//----------------------------------------------------------------
//internal function prototype declare
//----------------------------------------------------------------
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath);
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath);
VOID   _ddbtnDbgPrintfA			(LPSTR  lpstrFmt, ...);
VOID   _ddbtnDbgPrintfW			(LPWSTR lpstrFmt, ...);

//----------------------------------------------------------------
// Global Data
//----------------------------------------------------------------
static LPFNDBGCALLBACKA g_lpfnDbgCBA;
static LPFNDBGCALLBACKW g_lpfnDbgCBW;
static BOOL g_fEnable=FALSE;
inline VOID ODStrW(LPWSTR lpwstr)
{
	if(g_fEnable) OutputDebugStringW(lpwstr);
}
inline VOID ODStrA(LPSTR lpstr)
{
	if(g_fEnable) OutputDebugStringA(lpstr);
}

//////////////////////////////////////////////////////////////////
// Function : _debugSetCallback
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPFNDBGCALLBACK lpfnDbgCallback 
// Return   : 
// DATE     : Tue Jan 06 12:42:36 1998
//////////////////////////////////////////////////////////////////
VOID _ddbtnDbgSetCallback(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW)
{
	g_lpfnDbgCBA = lpfnCBA;
	g_lpfnDbgCBW = lpfnCBW;
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgSwitchOutput
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:35:55 1998
// Author   : 
//////////////////////////////////////////////////////////////////
VOID _ddbtnDbgEnableOutput(BOOL fEnable)
{
	g_fEnable = fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgIsOutputEnable
// Type     : VOID
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 18:00:52 1998
// Author   : 
//////////////////////////////////////////////////////////////////
BOOL _ddbtnDbgIsOutputEnable(VOID)
{
	return g_fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgOutStrA
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Tue Jan 06 12:29:39 1998
//////////////////////////////////////////////////////////////////
VOID _ddbtnDbgOutStrA(LPSTR lpstr)
{
	static BOOL fIn;
	ODStrA(lpstr);
#ifdef _CONSOLE
	printf(lpstr);
#endif

	if(g_lpfnDbgCBA) {
		if(fIn) { return; }
		fIn = TRUE;
		(*g_lpfnDbgCBA)(lpstr);
		fIn = FALSE;
	}
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgOutStrW
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpwstr 
// Return   : 
// DATE     : Tue Jan 06 12:30:07 1998
//////////////////////////////////////////////////////////////////
VOID _ddbtnDbgOutStrW(LPWSTR lpwstr)
{
	static BOOL fIn;

	if(IsWinNT()) {
		ODStrW(lpwstr);
	}
	else {
		static CHAR szBuf[1024];
		::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
		ODStrA(szBuf);
	}

#ifdef _CONSOLE
	static CHAR szBuf[1024];
	::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
	printf(szBuf);
#endif
	if(g_lpfnDbgCBW) { 
		if(fIn) { return; } 		
		fIn = TRUE;
		(*g_lpfnDbgCBW)(lpwstr);
		fIn = FALSE;
	}
	return;
}

////////////////////////////////////////////////////////
// Function: _ddbtnDbgA
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _ddbtnDbgA(LPSTR		lpstrFile, 
			 INT		lineNo, 
			 LPSTR		lpstrMsg)
{
	_ddbtnDbgPrintfA("(%12s:%4d) %s", 
				 GetFileTitleStrA(lpstrFile),
				 lineNo,
				 lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFile 
//          : INT lineNo 
//          : LPWSTR lpstrMsg 
// Return   : 
// DATE     : Mon Jan 05 15:10:41 1998
//////////////////////////////////////////////////////////////////
VOID _ddbtnDbgW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg)
{
	_ddbtnDbgPrintfW(L"(%12s:%4d) %s", 
			   GetFileTitleStrW(lpstrFile),
			   lineNo,
			   lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgVaStrA
// Type     : LPSTR
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:09:53 1998
//////////////////////////////////////////////////////////////////
LPSTR _ddbtnDbgVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(chBuf, lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function : _ddbtnDbgVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _ddbtnDbgVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap);	//Use C-RunTime Library for Win95
	va_end(ap);
	return wchBuf;
}


////////////////////////////////////////////////////////
// Function: _ddbtnDbgPrintfA
// Type    : VOID
// Purpose : variable args version of OutputDebugStringA
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _ddbtnDbgPrintfA(LPSTR lpstrFmt, ...)
{
	static CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	_ddbtnDbgOutStrA(szBuf);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgPrintfW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:11:24 1998
//////////////////////////////////////////////////////////////////
VOID _ddbtnDbgPrintfW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap); //Use C-RunTime Library for Win95
	va_end(ap);
	_ddbtnDbgOutStrW(wchBuf);
	return;
}


//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgMulti2Wide
// Type     : LPWSTR
// Purpose  : return Unicode string from MBCS string
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Mon Jan 05 15:10:48 1998
//////////////////////////////////////////////////////////////////
LPWSTR _ddbtnDbgMulti2Wide(LPSTR lpstr)
{
	static WCHAR wchBuf[512];
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}


//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgGetWinClass
// Type     : LPSTR
// Purpose  : Get Windows class name string
//			  ANSI version only.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:08:43 1998
//////////////////////////////////////////////////////////////////
LPSTR _ddbtnDbgGetWinClass(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetClassNameA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;

}

//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgGetWinText
// Type     : LPSTR
// Purpose  : Get Windows text(title) string
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:09:08 1998
//////////////////////////////////////////////////////////////////
LPSTR _ddbtnDbgGetWinText(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetWindowTextA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;
}

//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgMsgBoxA
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Thu Jan 08 12:31:03 1998
//////////////////////////////////////////////////////////////////
VOID _ddbtnDbgMsgBoxA(LPSTR lpstrFile,  INT lineNo, LPSTR lpstrMsg)
{
#ifdef _CONSOLE
	return;
#endif
	char szTmp[512];
	wsprintf(szTmp, "Debug Message Box (File: %s, Line: %4d)", 
			   GetFileTitleStrA(lpstrFile), 
			   lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
}

VOID _ddbtnDbgAssert(LPSTR  lpstrFile,  INT lineNo, BOOL fOk, LPSTR lpstrMsg)
{
	if(fOk) {
		return; 
	}
	char szTmp[512];
	wsprintf(szTmp, "ASSERT (File: %s, Line: %4d)", 
			 GetFileTitleStrA(lpstrFile), 
			 lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
	DebugBreak();
}

//////////////////////////////////////////////////////////////////
// Function : _ddbtnDbgGetErrorString
// Type     : LPSTR
// Purpose  : Convert Error(Got from GetLastError()) value to ERROR Message String
// Args     : 
//          : INT errorCode 
// Return   : 
// DATE     : Mon Jan 05 16:43:34 1998
//////////////////////////////////////////////////////////////////
LPSTR _ddbtnDbgGetErrorString(INT errorCode)
{
	static CHAR szBuf[512];
	INT count;
	szBuf[0] = (CHAR)0x00;
	count = wsprintf(szBuf, "[0x%08x]:", errorCode);
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   errorCode, 
				   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				   szBuf+count,
				   sizeof(szBuf)-1-count,
				   NULL );
	if(*(szBuf + count) != (CHAR)0x00) {
		int nLen = lstrlenA(szBuf);
		if((nLen - count) > 1) {
			szBuf[nLen - 1] = (CHAR)0x00;
		}
	}
	return szBuf;
}


//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrA
// Type     : static LPSTR
// Purpose  : Return File name string(remove folder)
// Args     : 
//          : LPSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:34:22 1998
//////////////////////////////////////////////////////////////////
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath)
{
	static CHAR szBuf[2];
	CHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenA(lpstrFilePath) - 1);
	for(pTemp = CharPrevA(lpstrFilePath, pLast); 
		(pTemp  != lpstrFilePath) && 
		(*pTemp != '\\')	 &&
		(*pTemp != (CHAR)0x00); 
		pTemp = CharPrevA(lpstrFilePath, pTemp)) {
		;
	}
	if(*pTemp == '\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}

//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrW
// Type     : static LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:38:19 1998
//////////////////////////////////////////////////////////////////
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath)
{
	static WCHAR szBuf[2];
	WCHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenW(lpstrFilePath) - 1);
	for(pTemp = pLast-1;
		(pTemp != lpstrFilePath) &&
		(*pTemp != L'\\')		 &&
		(*pTemp != (WCHAR)0x0000);
		pTemp--) {
		;
	}

	if(*pTemp == L'\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\ddbtn.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "dbg.h"
#include "cddbtn.h"

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//////////////////////////////////////////////////////////////////
// Function : DDButton_CreateWindow
// Type     : HWND
// Purpose  : Opened API.
//			: Create Drop Down Button.
// Args     : 
//          : HINSTANCE		hInst 
//          : HWND			hwndParent 
//          : DWORD			dwStyle		DDBS_XXXXX combination.
//          : INT			wID			Window ID
//          : INT			xPos 
//          : INT			yPos 
//          : INT			width 
//          : INT			height 
// Return   : 
// DATE     : 970905
//////////////////////////////////////////////////////////////////
#ifndef UNDER_CE
#define SZCLASSNAME "MSIME_DDB"
#else // UNDER_CE
#define SZCLASSNAME TEXT("MSIME_DDB")
#endif // UNDER_CE
#ifdef UNDER_CE // In Windows CE, all window classes are process global.
static LPCTSTR MakeClassName(HINSTANCE hInst, LPTSTR lpszBuf)
{
	// make module unique name
	TCHAR szFileName[MAX_PATH];
	GetModuleFileName(hInst, szFileName, MAX_PATH);
	LPTSTR lpszFName = _tcsrchr(szFileName, TEXT('\\'));
	if(lpszFName) *lpszFName = TEXT('_');
	StringCchCopy(lpszBuf, MAX_PATH, SZCLASSNAME);
	StringCchCat(lpszBuf, MAX_PATH, lpszFName);

	return lpszBuf;
}

BOOL DDButton_UnregisterClass(HINSTANCE hInst)
{
	TCHAR szClassName[MAX_PATH];
	return UnregisterClass(MakeClassName(hInst, szClassName), hInst);
}

#endif // UNDER_CE
HWND DDButton_CreateWindow(HINSTANCE	hInst, 
						   HWND			hwndParent, 
						   DWORD		dwStyle,
						   INT			wID, 
						   INT			xPos,
						   INT			yPos,
						   INT			width,
						   INT			height)
{
	LPCDDButton lpDDB = new CDDButton(hInst, hwndParent, dwStyle, wID);
	HWND hwnd;
	if(!lpDDB) {
		return NULL;
	}
#ifndef UNDER_CE // In Windows CE, all window classes are process global.
	lpDDB->RegisterWinClass(SZCLASSNAME);
	hwnd = CreateWindowEx(0,
						  SZCLASSNAME, 
#else // UNDER_CE
	TCHAR szClassName[MAX_PATH];
	MakeClassName(hInst, szClassName);

	lpDDB->RegisterWinClass(szClassName);
	hwnd = CreateWindowEx(0,
						  szClassName, 
#endif // UNDER_CE
#ifndef UNDER_CE
						  "", 
#else // UNDER_CE
						  TEXT(""),
#endif // UNDER_CE
						  WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, 
						  xPos, yPos,
						  width,
						  height,
						  hwndParent,
#ifdef _WIN64
						  (HMENU)(INT_PTR)wID,
#else
						  (HMENU)wID,
#endif
						  hInst,
						  (LPVOID)lpDDB);
	return hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\ccom.h ===
#ifndef _DDBTN_COM_H_
#define _DDBTN_COM_H_

#ifdef UNDER_CE // not support GlobalAlloc
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

#ifdef _DEBUG
#include "dbg.h"
static INT countAlloced;
static INT countFreed;
static INT curSize;
inline VOID _printMemInfo(VOID)
{
	Dbg(("countAlloced %d\n", countAlloced));
	Dbg(("countFreed   %d\n", countFreed));
	Dbg(("curSize      %d\n", curSize));
}
#define PrintMemInfo()	_printMemInfo()
#else
#define PrintMemInfo()
#endif

inline VOID *MemAlloc(size_t size)
{
	LPVOID p = GlobalAlloc(GMEM_FIXED, size);
#ifdef _DEBUG
	if(p) {
		countAlloced++;
		curSize += (INT)GlobalSize(p);
	}
#endif
	return p;
}

inline BOOL MemFree(LPVOID p)
{
#ifdef _DEBUG
	if(p) {
		countFreed++;
		curSize -= (INT)GlobalSize(p);
	}
#endif
	BOOL ret = FALSE;
	if(p) {
#ifdef _WIN64
		ret = (BOOL)(INT_PTR)GlobalFree(p);
#else
		ret = (BOOL)GlobalFree(p);
#endif
	}
	return ret;
}

//----------------------------------------------------------------
inline LPWSTR StrdupW(LPWSTR lpwstr)
{
	LPWSTR p;
	INT len;
	if(!lpwstr) {
		return NULL;
	}
	len = lstrlenW(lpwstr);
	p = (LPWSTR)MemAlloc((len + 1)* sizeof(WCHAR) );
	if(p) {
		CopyMemory(p, lpwstr, len * sizeof(WCHAR));
		p[len] = (WCHAR)0x0000;
	}
	return p;
}

class CCommon {
public:
	void *operator new(size_t size) {
		BYTE *p = (BYTE *)MemAlloc(size);
		if(p) {
			ZeroMemory(p, size);
		}
		return (void *)p;
	}
	void operator delete(void *pv) {
		if(pv) {
			MemFree(pv);
		}
	}
};

//----------------------------------------------------------------
#define UnrefForMsg()	UNREFERENCED_PARAMETER(hwnd);\
						UNREFERENCED_PARAMETER(wParam);\
						UNREFERENCED_PARAMETER(lParam)

#define UnrefForCmd()	UNREFERENCED_PARAMETER(hwnd);\
						UNREFERENCED_PARAMETER(wCommand);\
						UNREFERENCED_PARAMETER(wNotify);\
						UNREFERENCED_PARAMETER(hwndCtrl)

#define Unref(a)		UNREFERENCED_PARAMETER(a)
#define Unref1(a)		UNREFERENCED_PARAMETER(a)
#define Unref2(a, b)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b)
#define Unref3(a,b,c)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b);\
						UNREFERENCED_PARAMETER(c)

#define Unref4(a,b,c,d)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b);\
						UNREFERENCED_PARAMETER(c);\
						UNREFERENCED_PARAMETER(d)

#endif //_DDBTN_COM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\dbg.h ===
//////////////////////////////////////////////////////////////////
// File     : dbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef _DBG_H_
#define _DBG_H_

#ifdef __cplusplus
#	define InlineFunc  inline
#else 
#	define InlineFunc  __inline
#endif

//----------------------------------------------------------------
// Callback function prototype
//----------------------------------------------------------------
typedef VOID (WINAPI *LPFNDBGCALLBACKA)(LPSTR  lpstr);
typedef VOID (WINAPI *LPFNDBGCALLBACKW)(LPWSTR lpwstr);

//-------------------------------------------------------
//MACRO function  prototype declare.
//It is valid only if compliled with _DEBUG definition.
//-------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function : DBGSetCallback
// Type     : VOID
// Purpose  : Set debug callback function.
//			  callback function has set, when DBG() has called,
//			  call this callback function with formatted message string.
// Args     : 
//          : LPFNDBGCALLBACKA lpfnDbgCallbackA 
//          : LPFNDBGCALLBACKW lpfnDbgCallbackW 
// Return   : VOID
// DATE     : Tue Jan 06 12:21:05 1998
//////////////////////////////////////////////////////////////////
//VOID DBGSetCallback(LPFNDBGCALLBACKA lpfnDbgCallbackA, LPFNDBGCALLBACKW lpfnDbgCallbackW);

//////////////////////////////////////////////////////////////////
// Function : DBGEnableOutput
// Type     : VOID
// Purpose  : On off OutputDebugString to COM.
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:33:21 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//VOID DBGEnableOutput(BOOL fEnable)

//////////////////////////////////////////////////////////////////
// Function : DBGIsOutputEnable
// Type     : BOOL
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 17:58:28 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//BOOL DBGIsOutputEnable(VOID)


////////////////////////////////////////////////////////
// Function	: DBG
// Type		: VOID
// Purpose	: Printing ANSI debug message with same usage as printf()
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// Example	: DBGW(("Error occured data[%d]", i));
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//		   : ...	
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example	: DBGW(("Error occured data[%d]", i));
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

//////////////////////////////////////////////////////////////////
// Function : DBGMsgBox
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example	: DBGMsgBox(("Error occured data[%d]", i));
//////////////////////////////////////////////////////////////////
//VOID DBGMsgBox((LPSTR lpstrFmt, ...))

//////////////////////////////////////////////////////////////////
// Function : DBGAssert
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fError
// Return   : 
// DATE     : Fri Jan 09 17:17:31 1998
//////////////////////////////////////////////////////////////////
//VOID DBGAssert(BOOL fError)


//////////////////////////////////////////////////////////////////
// Function : DBGSTR
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr
//////////////////////////////////////////////////////////////////
//VOID DBGSTR(LPSTR lpstr);


//////////////////////////////////////////////////////////////////
// Function : DBGGetErrorString
// Type     : VOID
// Purpose  : Get error message from WIN32 Error code.
// Args     : 
//          : INT errorCode 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetErrorString(INT errorCode)


//////////////////////////////////////////////////////////////////
// Function : DBGGetWinClass
// Type     : LPSTR
// Purpose  : Get class name string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinClass(HWND hwnd)

//////////////////////////////////////////////////////////////////
// Function : DBGGetWinText
// Type     : LPSTR
// Purpose  : Get title text string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinText(HWND hwnd)



#ifdef _DEBUG
//----------------------------------------------------------------
//Function prototype declare
//----------------------------------------------------------------
extern VOID   _ddbtnDbgEnableOutput	(BOOL fEnable);
extern BOOL   _ddbtnDbgIsOutputEnable	(VOID);
extern VOID	  _ddbtnDbgSetCallback		(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW);
extern VOID   _ddbtnDbgA				(LPSTR  lpstrFile, INT lineNo, LPSTR  lpstrMsg);
extern VOID   _ddbtnDbgW				(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _ddbtnDbgMsgBoxA			(LPSTR  lpstrFile,  INT lineNo, LPSTR lpstrMsg);
extern VOID   _ddbtnDbgAssert			(LPSTR  lpstrFile,  INT lineNo, BOOL fError, LPSTR lpstrMsg);
extern VOID   _ddbtnDbgPrintfA			(LPSTR  lpstrFmt, ...);
extern VOID   _ddbtnDbgPrintfW			(LPWSTR lpstrFmt, ...);
extern VOID   _ddbtnDbgOutStrA			(LPSTR  lpstr);
extern VOID	  _ddbtnDbgOutStrW			(LPWSTR lpwstr);
extern LPSTR  _ddbtnDbgVaStrA			(LPSTR  lpstrFmt, ...);
extern LPWSTR _ddbtnDbgVaStrW			(LPWSTR lpstrFmt, ...);
extern LPWSTR _ddbtnDbgMulti2Wide		(LPSTR  lpstr);
extern LPSTR  _ddbtnDbgGetWinClass		(HWND   hwnd);
extern LPSTR  _ddbtnDbgGetWinText		(HWND   hwnd);
extern LPSTR  _ddbtnDbgGetErrorString	(INT    errorCode);
extern LPSTR  _ddbtnDbgGetVkStr		(INT	virtKey);
//----------------------------------------------------------------
// Macro definition
//----------------------------------------------------------------
#	define DBGSetCallback(a,b)	_ddbtnDbgSetCallback(a, b)
#	define DBGEnableOutput(a)	_ddbtnDbgEnableOutput(a)
#	define DBGIsOutputEnable()	_ddbtnDbgIsOutputEnable()
#	define Dbg(a)				_ddbtnDbgA(__FILE__, __LINE__, _ddbtnDbgVaStrA a)
#	define DBGA(a)				_ddbtnDbgA(__FILE__, __LINE__, _ddbtnDbgVaStrA a)
#	define DBGW(a)				_ddbtnDbgW( _ddbtnDbgMulti2Wide(__FILE__), __LINE__, _ddbtnDbgVaStrW a)
#	define DBGMsgBox(a)			_ddbtnDbgMsgBoxA(__FILE__, __LINE__, _ddbtnDbgVaStrA a)
#	define DBGAssert(a)			_ddbtnDbgAssert(__FILE__, __LINE__, a, #a)
#	define DBGAssertSz(a,b)		_ddbtnDbgAssert(__FILE__, __LINE__, a, b)
#	define DBGOutStr(a)			_ddbtnDbgOutStrA(a)
#	define DBGOutStrA(a)		_ddbtnDbgOutStrA(a)
#	define DBGOutStrW(a)		_ddbtnDbgOutStrW(a)
#	define DBGP(a)				_ddbtnDbgOutStrA(_ddbtnDbgVaStrA a)
#	define DBGPA(a)				_ddbtnDbgOutStrA(_ddbtnDbgVaStrA a)
#	define DBGPW(a)				_ddbtnDbgOutStrW(_ddbtnDbgVaStrW a)
#	define DBGGetErrorString(a)	_ddbtnDbgGetErrorString(a)
#	define DBGGetWinClass(a)	_ddbtnDbgGetWinClass(a)
#	define DBGGetWinText(a)		_ddbtnDbgGetWinText(a)
#	define DBGGetVirtKeyStr(a)	_ddbtnDbgGetVkStr(a)
#else //!_DEBUG	//in Release version, these will disapear...
#	define DBGSetCallback(a,b)
#	define DBGEnableOutput(a)
#	define DBGIsOutputEnable()
#	define Dbg(a)
#	define DBGW(a)
#	define DBGA(a)
#	define DBGP(a)
#	define DBGPA(a)
#	define DBGPW(a)
#	define DBGAssert(a)
#	define DBGAssertSz(a,b)
#	define DBGMsgBox(a)
#	define DBGOutStr(a)
#	define DBGOutStrA(a)
#	define DBGOutStrW(a)
#	define DBGGetErrorString(a)
#	define DBGGetWinClass(a)
#	define DBGGetWinText(a)
#	define DBGGetVirtKeyStr(a)
#endif //_DEBUG


//----------------------------------------------------------------
//These function use variable argument, so we cannot define 
//"Normal" MACRO for them.
//so, Use inline function that do nothing if _DEBUG is NOT set.
//----------------------------------------------------------------
InlineFunc VOID DBGDoNothingA(LPSTR  lpstrFmt, ...) {lpstrFmt;}
InlineFunc VOID DBGDoNothingW(LPWSTR lpstrFmt, ...) {lpstrFmt;}
#ifdef _DEBUG 
#define DBGPrintf		_ddbtnDbgPrintfA
#define DBGPrintfA		_ddbtnDbgPrintfA
#define DBGPrintfW		_ddbtnDbgPrintfW
#else 
#define DBGPrintf		DBGDoNothingA
#define DBGPrintfA		DBGDoNothingA
#define DBGPrintfW		DBGDoNothingW
#endif


//----------------------------------------------------------------
//This is helper inline function for outputs debug string in 
//Retail version. if FORCE_DEBUG is defined this function works.
//Some time, we met bugs than occurs only retail version, 
//and would like to out debug message. 
//----------------------------------------------------------------
#ifdef FORCE_DEBUG
#include <stdarg.h>
//////////////////////////////////////////////////////////////////
// Function : FDbg
// Type     : InlineFunc VOID
// Purpose  : 
// Args     : 
//          : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Tue Jan 06 19:06:19 1998
//////////////////////////////////////////////////////////////////
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...)
{
	CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	OutputDebugStringA(szBuf);	
	return;
}
#else //FORCE_DEBUG
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...) {lpstrFmt;}
#endif

#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testmain.rc
//
#define IDI_ICON1                       111
#define IDI_ICON2                       112
#define IDD_LISTREPORT                  500
#define IDD_PADLIST                     501
#define IDC_ADDITEM                     1024
#define IDC_INSERTITEM                  1025
#define IDC_GETCURSEL                   1026
#define IDC_SETTEXT                     1027
#define IDC_SETCURSEL                   1033
#define IDC_SETICON                     1034
#define IDC_DDBS_TEXT                   1037
#define IDC_SETSTYLE                    1038
#define IDC_DDBS_ICON                   1039
#define IDC_DDBS_DROPDOWN               1040
#define IDC_DDBS_NOSEPARATEDBUTTON      1040
#define IDC_DDBS_THINEDGE               1041
#define IDC_DDBS_FLAT                   1043
#define IDC_EDIT_ADDITEM                1044
#define IDC_EDIT_INSERTITEM_INDEX       1045
#define IDC_EDIT_INSERTITEM             1046
#define IDC_EDIT_SETCURSEL              1047
#define IDC_STATIC_GETCURSEL            1048
#define IDC_RADIO_ICON1                 1052
#define IDC_RADIO_ICON2                 1053
#define IDC_EDIT_SETTEXT                1054
#define IDC_RADIO_ICON3                 1055
#define IDC_RADIO_ICON4                 1056
#define IDB_KEYLIST                     3000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1057
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\ddbtn.h ===
//////////////////////////////////////////////////////////////////
// File     :	ddbtn.h ( DropDownButton)
// Purpose  :	new control for drop down button
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//	
// History	:970905 Started
//////////////////////////////////////////////////////////////////
//----------------------------------------------------------------
//
//Detail description
//
//----------------------------------------------------------------
#if 0
	This Drop down Button(DDButton) control has 2 mode,
	1. Separated Button.
	2. No Separated Button.
	Normal case is Separated button. like Word or Excel's common interface,
	Icon button and Triangle button.
	If DDBS_NOSEPARATED is NOT set, you can see below face.
	this is 1.case. 
	Figure 1. normal face.
			left	  right
		+-----------+-------+
		|			|		|
		|			| ##### |
		|			|  ###	|
		|			|	#	|
		|			|		|
		+-----------+-------+
	you can set Text or Icon to left button, with DDButton_SetText() or DDButton_SetIcon().
	you can set Item list to DDButton with DDButton_InsertItem() or DDButton_AddItem().
	If some item are inserted, and you can see drop down menu if you clicked 
	the "right" button.

	Figure 2. drop down menu has shown.

		left button	  right button
		+-----------+-------+
		|			|		|
		|			| ##### |
		|			|  ###	|
		|			|	#	|
		|			|		|
		+-----------+-------+---+
		| 	I t e m       0		|
		| 	I t e m       1		|
		|V 	I t e m       2		|
		| 	I t e m       3		|
		| 	I t e m       4		|
		| 	I t e m       5		|
		| 	I t e m       6		|
		+-----------------------+
	"V" means current selected Item.
	If you Call DDButton_GetCurSel(), you can get current selected item.
	in this case, you can get 2 as integer value.
	If you selected specified item in the menu, not current selected item,
	you can get WM_COMMAND in Parent window procedure with, "DDBN_SELCHANGE".

	you can also set current selected item by DDButton_SetCurSel().
	
	If you click "left button", current selected item index is incremented.
	in this case, if you click "left button", 
	you can receive DDBN_CLICKED notify, and AFTER that, you receive
	DDBN_SELCHANGE.
	current selected index has changed to "3"
	and Before menu will be shown, you can receive WM_COMMAND with
	DDBN_DROPDOWN, and after menu has hidden, you can receive,
	DDBN_CLOSEUP notify.


	If DDBS_NOSEPARATED is NOT set, you can see below face.
	Figure 3. with DDBS_NOSEPARATED style.
		+-------------------+
		|					|
		|			  ##### |
		|			   ###	|
		|				#	|
		|					|
		+-------------------+

	This DDButton has this style, you can NOT receive DDBN_CLICKED.
	only 
	DDBN_DROPDOWN, DDBN_CLOSEUP and DDBN_SELCHANGE will be sent.

#endif //if 0



#ifndef _DROP_DOWN_BUTTON_
#define _DROP_DOWN_BUTTON_

//----------------------------------------------------------------
//Drop Down Button Style
//----------------------------------------------------------------
#define DDBS_TEXT				0x0000		// Show Text as Button Face.
#define DDBS_ICON				0x0001		// Show Icon as Button Face.
#define DDBS_THINEDGE			0x0002		// Draw Thin Edge.
#define DDBS_FLAT				0x0004		// Flat style drop down button.
#define DDBS_NOSEPARATED		0x0010		// No separated button.
											// when button was pushed, always drop down is shown.

//----------------------------------------------------------------
//Drop down Item's type mask.
//----------------------------------------------------------------
#define DDBF_TEXT			0x0000	//Only Unicode string. 
#define DDBF_ICON			0x0001	//not used.
#define DDBF_SEPARATOR		0x0002	//not used.

//----------------------------------------------------------------
//Drop down Item structure
//----------------------------------------------------------------
#pragma pack(1)
typedef struct tagDDBITEM {
	INT		cbSize;		// DDBITEM structure size is needed.
	UINT	mask;		// reserved. not used.
	LPWSTR	lpwstr;		// drop down item string. 
	HICON	hIcon;		//reserved. not used.
	LPARAM	lParam;		//reserved. not used.
}DDBITEM, *LPDDBITEM;
#pragma pack()

//----------------------------------------------------------------
//Drop Down Button Message
//----------------------------------------------------------------
#define DDBM_ADDITEM			(WM_USER + 100)
#define DDBM_INSERTITEM			(WM_USER + 101)
#define DDBM_SETCURSEL			(WM_USER + 102)
#define DDBM_GETCURSEL			(WM_USER + 103)
#define DDBM_SETICON			(WM_USER + 104)
#define DDBM_SETTEXT			(WM_USER + 105)
#define DDBM_SETSTYLE			(WM_USER + 106)

//----------------------------------------------------------------
//Drop Down Button Notify code.
//It is set to Parent window of Drop Down button as
//WM_COMMAND.
//----------------------------------------------------------------
//----------------------------------------------------------------
// Notify:			DDBN_CLICKED
// When it comes?:	If DDBS_NOSEPARATED was SET,this notify only come,
//					when current selected item was change.
//					If DDBS_NOSEPARATED was NOT set, when button was clicked, or menu item 
//					was changed, this notify come.
//----------------------------------------------------------------
//----------------------------------------------------------------
// Notify:			DDBN_SELCHANGED
// When it comes?:	If menu item was selected, this notify come.
//					if DDBS_NOSEPARATED style is NOT set,
//					when right button(Separated right button, not a mouse)
//					was clicked, this notify comes, after DDBN_CLICKED notify.
//----------------------------------------------------------------
//----------------------------------------------------------------
// Notify:			DDBN_DROPDOWN
// When it comes?:	If dropdown menu was shown, this notify come.
//----------------------------------------------------------------
//----------------------------------------------------------------
// Notify:			DDBN_CLOSEUP
// When it comes?:	If dropdown menu was hidden, this notify come.
//----------------------------------------------------------------
#define DDBN_CLICKED		0		
#define DDBN_SELCHANGE		1		
#define DDBN_DROPDOWN		2		
#define DDBN_CLOSEUP		3		

//----------------------------------------------------------------
//Drop Down Button Message Macro.
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function : DDButton_AddItem
// Type     : INT
// Purpose  : add dropdown item. 
// Args     : HWND		hwndCtrl:		DDButton window handle
//          : LPDDBITEM lpDDBItem:		
// Remarks	: when it was called, 
//			: lpDDBItem->lpwstr data is copyed to DDButton's 
//			: internal data area.
// Return   : 
//////////////////////////////////////////////////////////////////
#define DDButton_AddItem(hwndCtrl, pddbItem) \
		((int)(DWORD)SendMessage((hwndCtrl), DDBM_ADDITEM, 0, (LPARAM)pddbItem))

//////////////////////////////////////////////////////////////////
// Function : DDButton_InsertItem
// Type     : INT
// Purpose  : insert dropdown item.
// Args     : HWND		hwndCtrl:		DDButton window handle
//			: INT		index:			
//          : LPDDBITEM lpDDBItem:		
// Remarks	: when it was called, 
//			: lpDDBItem->lpwstr data is copyed to DDButton's 
//			: internal data area.
// Return   : 
//////////////////////////////////////////////////////////////////
#define DDButton_InsertItem(hwndCtrl, index, pddbItem) \
		((int)(DWORD)SendMessage((hwndCtrl), DDBM_INSERTITEM, (WPARAM)(index), (LPARAM)(pddbItem)))

//////////////////////////////////////////////////////////////////
// Function : DDButton_SetCurSel
// Type     : INT
// Purpose  : Set current item by specified index.
// Args     : HWND		hwndCtrl:		DDButton window handle
//			: INT		index:			Select index.
// Return   : 
//////////////////////////////////////////////////////////////////
#define DDButton_SetCurSel(hwndCtrl, index) \
		((int)(DWORD)SendMessage((hwndCtrl), DDBM_SETCURSEL, (WPARAM)(index), (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : DDButton_GetCurSel
// Type     : INT
// Purpose  : 
// Args     : HWND		hwndCtrl:		DDButton window handle
// Return   : current selected item index.
//////////////////////////////////////////////////////////////////
#define DDButton_GetCurSel(hwndCtrl) \
		((int)(DWORD)SendMessage((hwndCtrl), DDBM_GETCURSEL, (WPARAM)0, (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : DDButton_SetIcon
// Type     : INT
// Purpose  : Set button image as icon.
// Args     : HWND		hwndCtrl:		DDButton window handle.
//			: HICON		hIcon:			Icon handle.
// Remarks	: DDBS_ICON style must be set.
// Return   : 
//////////////////////////////////////////////////////////////////
#define DDButton_SetIcon(hwndCtrl, hIcon) \
		((int)(DWORD)SendMessage((hwndCtrl), DDBM_SETICON, (WPARAM)hIcon, (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : DDButton_SetText
// Type     : INT
// Purpose  : Set button image as icon.
// Args     : HWND		hwndCtrl:		DDButton window handle.
//			: LPWSTR	lpsz:			Unicode String pointer.
// Remarks	: 
// Return   : 
//////////////////////////////////////////////////////////////////
#define DDButton_SetText(hwndCtrl, lpsz) \
		((int)(DWORD)SendMessage((hwndCtrl), DDBM_SETTEXT, (WPARAM)lpsz, (LPARAM)0))

//////////////////////////////////////////////////////////////////
// Function : DDButton_SetStyle
// Type     : INT
// Purpose  : Set Drop down button's style.
// Args     : HWND		hwndCtrl:		DDButton window handle.
//			: DWORD		dwStyle:		DDBS_XXXXX combination.
// Remarks	: 
// Return   : 
//////////////////////////////////////////////////////////////////
#define DDButton_SetStyle(hwndCtrl, dwStyle) \
		((int)(DWORD)SendMessage((hwndCtrl), DDBM_SETSTYLE, (WPARAM)dwStyle, (LPARAM)0))

//////////////////////////////////////////////////////////////////
// Function : DDButton_CreateWindow
// Type     : HWND
// Purpose  : Opened API.
//			: Create Drop Down Button.
// Args     : 
//          : HINSTANCE		hInst 
//          : HWND			hwndParent 
//          : DWORD			dwStyle		DDBS_XXXXX combination.
//          : INT			wID			Window ID
//          : INT			xPos 
//          : INT			yPos 
//          : INT			width 
//          : INT			height 
// Return   : 
// DATE     : 970905
//////////////////////////////////////////////////////////////////
extern HWND DDButton_CreateWindow(HINSTANCE	hInst, 
								  HWND		hwndParent, 
								  DWORD		dwStyle,
								  INT		wID, 
								  INT		xPos,
								  INT		yPos,
								  INT		width,
								  INT		height);

#ifdef UNDER_CE // In Windows CE, all window classes are process global.
extern BOOL DDButton_UnregisterClass(HINSTANCE hInst);
#endif // UNDER_CE

#endif //_DROP_DOWN_BUTTON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\cexbtn.h ===
#ifndef _CLASS_EXTENDED_BUTTON_H_
#define _CLASS_EXTENDED_BUTTON_H_
#include <windowsx.h>
#include "dbg.h"
#include "ccom.h" 

#ifdef UNDER_CE // macro
// Under WindowsCE, DrawIcon() is defined as DrawIconEx(), not a real function
#undef DrawIcon
#endif // UNDER_CE

//----------------------------------------------------------------
//Pushed poped, flat image style definition.
//----------------------------------------------------------------
typedef enum tagIMAGESTYLE {
	IS_FLAT = 0,
	IS_POPED,
	IS_PUSHED,
}IMAGESTYLE;

class CEXButton;
typedef CEXButton *LPCEXButton;

class CEXButton : public CCommon
{
public:	
	CEXButton(HINSTANCE hInst, HWND hwndParent, DWORD dwStyle, DWORD wID); 
	~CEXButton();
#ifndef UNDER_CE
	BOOL	RegisterWinClass(LPSTR lpstrClassName);
#else // UNDER_CE
	BOOL	RegisterWinClass(LPTSTR lpstrClassName);
#endif // UNDER_CE
	INT		MsgCreate			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgPaint			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDestroy			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgTimer			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgMouseMove		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgButtonDown		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT		MsgButtonUp			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT		MsgNcMouseMove		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgNcButtonDown		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT		MsgNcButtonUp		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT		MsgEnable			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgSetFont			(HWND hwnd, WPARAM wParam, LPARAM lParam);	
	INT		MsgCaptureChanged	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgEXB_GetCheck		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgEXB_SetCheck		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgEXB_SetIcon		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgEXB_SetText		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgEXB_SetStyle		(HWND hwnd, WPARAM wParam, LPARAM lParam);
private:
	//----------------------------------------------------------------	
	// Private method
	//----------------------------------------------------------------	
	INT		NotifyToParent	(INT notify);
	INT		NotifyClickToParent(INT notify);
	INT		PressedState();
	INT		CancelPressedState();

	INT		DrawButton		(HDC hDC, LPRECT lpRc);
	INT		DrawThickEdge	(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT     DrawThinEdge	(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT     DrawIcon		(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT     DrawBitmap		(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT     DrawText		(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT     DrawLine		(HDC hDC, INT x, INT y, INT destX, INT destY);
	//----------------------------------------------------------------	
	//member variable
	//----------------------------------------------------------------	
	HINSTANCE			m_hInst;
	HWND				m_hwndParent;
	HWND				m_hwndFrame;
	DWORD				m_dwStyle;			//combination of DDBS_XXXX
	DWORD				m_wID;				//Window ID;
	BOOL				m_fEnable;			//Enabled or Disabled.		
	HFONT				m_hFont;			//Font handle
	HICON				m_hIcon;			//Icon handle
	INT					m_cxIcon;			//Icon width
	INT					m_cyIcon;			//Icon height
	LPWSTR				m_lpwstrText;		//Button face text.
	BOOL				m_fPushed;			//Toggle button : Pushed or poped state. 
	BOOL				m_fArmed;			//Pushed or poped apparence.
	BOOL				m_fDowned;			//Mouse has clicked.
	BOOL				m_fDblClked;		//Send Double click or not.
	BOOL				m_fWaiting;			// Waiting for double click.
#ifdef NOTUSED // kwada
	INT					m_wNotifyMsg;		// either EXBN_CLICKED or EXBN_DOUBLECLICKED
#endif
	BOOL				m_f16bitOnNT;		//it's on 16bit Application On WinNT. 
	SIZE				m_tmpSize;			//to reduce stack
#ifndef UNDER_CE // not support WNDCLASSEX
	WNDCLASSEX			m_tmpWC;			//to reduce stack
#else // UNDER_CE
	WNDCLASS			m_tmpWC;			//to reduce stack
#endif // UNDER_CE
	RECT				m_tmpBtnRc;			//to reduce stack
	RECT				m_tmpRect;			//to reduce stack
	RECT				m_tmpRect2;			//to reduce stack
	POINT				m_tmpPoint;			//to reduce stack
	PAINTSTRUCT			m_tmpPs;			//to reduce stack
	ICONINFO			m_tmpIconInfo;		//to reduce stack
	BITMAP				m_tmpBitmap;		//to reduce stack
};

#endif //_CLASS_EXTENDED_BUTTON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\testmain.cpp ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include "resource.h"

#include "dbg.h"
#include "ddbtn.h"
#include "../ptt/ptt.h"

char g_szClass[]="TestMain";
HINSTANCE g_hInst;
BOOL InitApplication(HINSTANCE hInst, LPSTR lpstrClass, WNDPROC lpfnWndProc)
{
	return 0;
}

LPWSTR GetWText(HWND hwnd, INT wID)
{
	CHAR   szBuf[256];
	static WCHAR wchBuf[512];
	Edit_GetText(GetDlgItem(hwnd, wID), szBuf, sizeof(szBuf));
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						szBuf, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}

INT GetINT(HWND hwnd, INT wID)
{
	CHAR szBuf[32];
	Edit_GetText(GetDlgItem(hwnd, wID), szBuf, sizeof(szBuf));
	return atoi(szBuf);
}

typedef struct tagVALLIST {
	INT wID;
	INT lParam;
}VALLIST;

VALLIST slist[] = {
	{ IDC_DDBS_TEXT,				DDBS_TEXT		},
	{ IDC_DDBS_ICON,				DDBS_ICON		},
	{ IDC_DDBS_THINEDGE,			DDBS_THINEDGE	},
	{ IDC_DDBS_FLAT,				DDBS_FLAT		},
	{ IDC_DDBS_NOSEPARATEDBUTTON,	DDBS_NOSEPARATED},
};

typedef struct tagICONLIST {
	INT wID;
	INT lParam;
	INT width;
	INT height;
}ICONLIST;

ICONLIST iconList[]={
	{ IDC_RADIO_ICON1,	IDI_ICON1, 16, 16, },
	{ IDC_RADIO_ICON2,  IDI_ICON1, 32, 32, },
	{ IDC_RADIO_ICON3,	IDI_ICON2, 16, 16, },
	{ IDC_RADIO_ICON4,  IDI_ICON2, 32, 32, },
};

HWND MainCreateWindow(HINSTANCE hInst, HWND hwndOwner, LPSTR lpstrClass, LPVOID lpVoid)
{
	HWND hwnd;
	hwnd = CreateDialogParam(hInst, 
							 g_szClass, 
							 hwndOwner, 
							 NULL, 
							 (LPARAM)lpVoid);
	if(!hwnd) {
		return (HWND)NULL;
	}
	UpdateWindow(hwnd);
	return hwnd;
}

#define ArrayCount(a)	(sizeof(a)/sizeof(a[0]))
#define MAX(a, b)		( a > b ? a : b)
#define IDC_DDBID		4096
#define IDC_SWITCHVIEW	8888

HWND CreateSwitchViewButton(HINSTANCE hInst, HWND hwndParent, INT wID)
{
	HWND hwnd = DDButton_CreateWindow(hInst, 
									  hwndParent, 
									  DDBS_ICON,
									  wID,
									  80,
									  30, 
									  36,
									  24);
	HICON hIcon = LoadImage(hInst,
							MAKEINTRESOURCE(IDI_ICON2),
							IMAGE_ICON, 
							16, 16,
							LR_DEFAULTCOLOR);
	DDButton_SetIcon(hwnd, hIcon);
	DDBITEM ddbItem;
	ZeroMemory(&ddbItem, sizeof(ddbItem));
	ddbItem.cbSize = sizeof(ddbItem);

	ddbItem.lpwstr = L"\";
	DDButton_AddItem(hwnd, &ddbItem);
	ddbItem.lpwstr = L"g\";
	DDButton_AddItem(hwnd, &ddbItem);
	DDButton_SetCurSel(hwnd, 0);
	return hwnd;
}


LRESULT CALLBACK MainWndProc(HWND	hwnd,
							 UINT	uMsg,
							 WPARAM	wParam,
							 LPARAM	lParam)
{
	PAINTSTRUCT ps;
	HDC hDC;
	RECT rc;
	static INT iIndex;
	switch(uMsg) {
	case WM_CREATE:
		{
			DDButton_CreateWindow(g_hInst, hwnd, DDBS_ICON,
								  IDC_DDBID,
								  20,
								  30, 
								  36,
								  24);
			CreateSwitchViewButton(g_hInst, hwnd, IDC_SWITCHVIEW);
		}
		SetTimer(hwnd, 0x9999, 50, NULL);
		return 1;
	case WM_TIMER:
		{
			KillTimer(hwnd, wParam);
			INT i;
			for(i = 0; i < sizeof(iconList)/sizeof(iconList[0]); i++) {
				HICON hIcon = LoadImage(g_hInst,
										MAKEINTRESOURCE(iconList[i].lParam),
										IMAGE_ICON, 
										iconList[i].width,
										iconList[i].height,
										LR_DEFAULTCOLOR);
				SendMessage(GetDlgItem(hwnd, iconList[i].wID),
							BM_SETIMAGE,
							(WPARAM)IMAGE_ICON,
							(LPARAM)hIcon);
			}
			HWND hwndDDB	 = GetDlgItem(hwnd, IDC_DDBID);
			for(i = 0; i < 23; i++) {
				DDBITEM ddbItem;
				WCHAR wchBuf[256];
				ZeroMemory(&ddbItem, sizeof(ddbItem));
				ddbItem.cbSize = sizeof(ddbItem);
				ddbItem.lpwstr = wchBuf;
				swprintf(wchBuf, L"Item %2d", i);
				DDButton_AddItem(hwndDDB, &ddbItem);
			}
		}
		break;
	case WM_SYSCOMMAND:
		if(wParam == SC_CLOSE) {
			PostQuitMessage(0);
		}
		break;
	case WM_COMMAND:
		{
			WORD wNotifyCode = HIWORD(wParam); // notification code 
			WORD wID		 = LOWORD(wParam);         // item, control, or accelerator identifier 
			HWND hwndCtl	 = (HWND) lParam;      // handle of control 
			HWND hwndDDB	 = GetDlgItem(hwnd, IDC_DDBID);
			switch(wID) {
			case IDC_DDBID:
				{
					switch(wNotifyCode) {
					case DDBN_CLICKED:
						DBG(("DDBN_CLICKED come\n"));
						break;
					case DDBN_SELCHANGE:
						DBG(("DDBN_SELCHANGE come\n"));
						break;
					case DDBN_DROPDOWN:
						DBG(("DDBN_DROPDOWN come\n"));
						break;
					case DDBN_CLOSEUP:
						DBG(("DDBN_CLOSEUP come\n"));
						break;
					default:
						DBG(("ERROR Unknown Notify\n"));
						break;
					}
				}
				break;
			case IDC_ADDITEM:
				{
					DDBITEM ddbItem;
					ZeroMemory(&ddbItem, sizeof(ddbItem));
					ddbItem.cbSize = sizeof(ddbItem);
					ddbItem.lpwstr = GetWText(hwnd, IDC_EDIT_ADDITEM);
					DDButton_AddItem(hwndDDB, &ddbItem);
					iIndex++;
				}
				break;
			case IDC_INSERTITEM:
				{
					DDBITEM ddbItem;
					INT index;
					WCHAR wchItem[256];
					ZeroMemory(&ddbItem, sizeof(ddbItem));
					ddbItem.cbSize = sizeof(ddbItem);
					ddbItem.lpwstr = GetWText(hwnd, IDC_EDIT_INSERTITEM);
					index = GetINT(hwnd, IDC_EDIT_INSERTITEM_INDEX);
					DDButton_InsertItem(hwndDDB, iIndex, &ddbItem);
				}
				break;
			case IDC_GETCURSEL:
				{
					INT i;
					char szBuf[256];
					i = DDButton_GetCurSel(hwndDDB);
					wsprintf(szBuf, "Cur Sel Index %d", i);
					Static_SetText(GetDlgItem(hwnd, IDC_STATIC_GETCURSEL), szBuf);
				}
				break;
			case IDC_SETTEXT:
				{
					DDButton_SetText(hwndDDB, GetWText(hwnd, IDC_EDIT_SETTEXT));
				}
				break;
			case IDC_SETCURSEL:
				{
					DDButton_SetCurSel(hwndDDB, GetINT(hwnd, IDC_EDIT_SETCURSEL));
				}
				break;
			case IDC_SETICON:
				{
					INT i;
					for(i = 0; i < sizeof(iconList)/sizeof(iconList[0]); i++) {
						if(Button_GetCheck(GetDlgItem(hwnd, iconList[i].wID))) {
							HICON hIcon = LoadImage(g_hInst,
													MAKEINTRESOURCE(iconList[i].lParam),
													IMAGE_ICON, 
													iconList[i].width,
													iconList[i].height,
													LR_DEFAULTCOLOR);
							DDButton_SetIcon(hwndDDB, hIcon);
						}
					}
				}
				break;
			case IDC_SETSTYLE:
				{
					INT i;
					DWORD dwStyle = 0;
					for(i = 0; i < sizeof(slist)/sizeof(slist[0]); i++) {
						INT ret = Button_GetCheck(GetDlgItem(hwnd, slist[i].wID));
						if(ret) {
							dwStyle |= slist[i].lParam;
						}
					}
					DDButton_SetStyle(hwndDDB, dwStyle);
				}
				break;
			}
		}
		break;
	case WM_PAINT:
		hDC = BeginPaint(hwnd, &ps);
		GetClientRect(hwnd, &rc);
		FillRect(hDC, &rc, (HBRUSH)(COLOR_3DFACE + 1));
		EndPaint(hwnd, &ps);
		break;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int WINAPI WinMain(HINSTANCE hInstance,
				   HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine,
				   int nCmdShow)
{

	MSG msg;
	HWND hwnd;
	INT ret;
	
	g_hInst = hInstance;
	WNDCLASSEX  wc;
	ZeroMemory(&wc, sizeof(wc));

	wc.cbSize			= sizeof(wc);
	wc.style			= CS_HREDRAW | CS_VREDRAW;	 /* Class style(s). */
	wc.lpfnWndProc		= (WNDPROC)MainWndProc;
	wc.cbClsExtra		= 0;					/* No per-class extra data.*/
	wc.cbWndExtra		= DLGWINDOWEXTRA;		/* No per-window extra data.		  */
	wc.hInstance		= hInstance;			/* Application that owns the class.	  */
	wc.hIcon			= NULL; //LoadIcon(hInstance, MAKEINTRESOURCE(SCROLL32_ICON));
	wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1); //UGetStockObject(LTGRAY_BRUSH); //WHITE_BRUSH); 
	wc.lpszMenuName		= NULL; //g_szClass;    /* Name of menu resource in .RC file. */
	wc.lpszClassName	= g_szClass;	  /* Name used in call to CreateWindow. */
	wc.hIconSm = NULL;
	RegisterClassEx(&wc);

	hwnd = CreateDialog(hInstance, 
						g_szClass, 
						0, 
						NULL);

	UpdateWindow(hwnd); 
	ShowWindow(hwnd, SW_SHOW);
	while (GetMessage(&msg, NULL, 0, 0)){
		TranslateMessage(&msg);
		DispatchMessage(&msg); 
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\cexbtn.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "exbtn.h"
#include "cexbtn.h"
#include "exgdiw.h"
#include "dbg.h"

static POSVERSIONINFO GetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

static BOOL ExIsWinNT(VOID)
{
	return (GetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
} 

#define TIMERID_MONITORPOS	0x98
//LIZHANG 10/27/97
#define TIMERID_DOUBLEORSINGLECLICKED	0x99

//----------------------------------------------------------------
//Get, Set LPCEXButton this pointer. 
//this is set to cbWndExtra.
//See WinRegister()
//----------------------------------------------------------------
inline LPCEXButton GetThis(HWND hwnd)
{
#ifdef _WIN64
	return (LPCEXButton)GetWindowLongPtr(hwnd, 0);
#else
	return (LPCEXButton)GetWindowLong(hwnd, 0);
#endif

}
//----------------------------------------------------------------
inline LPCEXButton SetThis(HWND hwnd, LPCEXButton lpEXB)
{
#ifdef _WIN64
	return (LPCEXButton)SetWindowLongPtr(hwnd, 0, (LONG_PTR)lpEXB);
#else
	return (LPCEXButton)SetWindowLong(hwnd, 0, (LONG)lpEXB);
#endif
}

//////////////////////////////////////////////////////////////////
// Function : WndProc
// Type     : static LRESULT CALLBACK
// Purpose  : Window Procedure for Extended button.
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 970905
//////////////////////////////////////////////////////////////////
static LRESULT CALLBACK WndProc(HWND	hwnd,
								UINT	uMsg,
								WPARAM	wParam,
								LPARAM	lParam)
{
	LPCEXButton lpEXB;
	//Dbg(("WndProc hwnd[0x%08x] uMsg[0x%08x]\n", hwnd, uMsg));
#ifndef UNDER_CE // #ifdef _DEBUG ?
	HWND hwndCap = ::GetCapture();
	char szBuf[256];
	if(hwndCap) {
		::GetClassNameA(hwndCap, szBuf, sizeof(szBuf));
		Dbg(("-->Capture [0x%08x][%s]\n", hwndCap, szBuf));
	}						
#endif // UNDER_CE
	if(uMsg == WM_CREATE) {
		lpEXB = (LPCEXButton)((LPCREATESTRUCT)lParam)->lpCreateParams;
		if(!lpEXB) {
			return 0;	// do not create button
		}
		SetThis(hwnd, lpEXB);
		lpEXB->MsgCreate(hwnd, wParam, lParam);
		return 1;
	}

	if(uMsg == WM_DESTROY) {
		lpEXB = GetThis(hwnd);
		if(lpEXB) {
			delete lpEXB;
		}
		SetThis(hwnd, (LPCEXButton)NULL);
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	}

	lpEXB = GetThis(hwnd);
	if(!lpEXB) {
		return DefWindowProc(hwnd, uMsg, wParam, lParam);		
	}

	switch(uMsg) {
	case WM_PAINT:
		return lpEXB->MsgPaint(hwnd, wParam, lParam);
		break;
	case WM_MOUSEMOVE:
		lpEXB->MsgMouseMove(hwnd, wParam, lParam);
		break;
	case WM_TIMER:
		return lpEXB->MsgTimer(hwnd, wParam, lParam);
	case WM_CAPTURECHANGED:
		return lpEXB->MsgCaptureChanged(hwnd, wParam, lParam);
	case WM_NCLBUTTONDBLCLK:
	case WM_NCRBUTTONDBLCLK:
	case WM_NCMBUTTONDBLCLK:
	case WM_NCLBUTTONDOWN:
	case WM_NCMBUTTONDOWN:
	case WM_NCRBUTTONDOWN:
		lpEXB->MsgNcButtonDown(hwnd, uMsg, wParam, lParam);
		break;
	case WM_NCLBUTTONUP:
	case WM_NCMBUTTONUP:
	case WM_NCRBUTTONUP:
		lpEXB->MsgNcButtonUp(hwnd, uMsg, wParam, lParam);
		break;
	case WM_NCMOUSEMOVE:
		lpEXB->MsgNcMouseMove(hwnd, wParam, lParam);
		break;
	case WM_LBUTTONDBLCLK:
	case WM_MBUTTONDBLCLK:
	case WM_RBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
		lpEXB->MsgButtonDown(hwnd, uMsg, wParam, lParam);
		break;
	case WM_LBUTTONUP:
	case WM_MBUTTONUP:
	case WM_RBUTTONUP:
		lpEXB->MsgButtonUp(hwnd, uMsg, wParam, lParam);
		break;
	case WM_ENABLE:
		lpEXB->MsgEnable(hwnd, wParam, lParam);
		break;
	case WM_SETFONT:
		lpEXB->MsgSetFont(hwnd, wParam, lParam);
		break;
	case EXBM_GETCHECK:		return lpEXB->MsgEXB_GetCheck	(hwnd, wParam, lParam); 
	case EXBM_SETCHECK:		return lpEXB->MsgEXB_SetCheck	(hwnd, wParam, lParam); 
	case EXBM_SETICON:		return lpEXB->MsgEXB_SetIcon	(hwnd, wParam, lParam); 
	case EXBM_SETTEXT:		return lpEXB->MsgEXB_SetText	(hwnd, wParam, lParam); 
	case EXBM_SETSTYLE:		return lpEXB->MsgEXB_SetStyle	(hwnd, wParam, lParam); 
	default:
		break;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton
// Type     : 
// Purpose  : Constructor
// Args     : 
//          : HINSTANCE hInst 
//          : HWND hwndParent 
//          : DWORD dwStyle 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
CEXButton::CEXButton(HINSTANCE hInst, HWND hwndParent, DWORD dwStyle, DWORD wID) 
{
	m_hInst				= hInst;
	m_hwndParent		= hwndParent;
	m_dwStyle			= dwStyle;
	m_hFont				= NULL;
	m_wID				= wID;
	m_lpwstrText		= NULL;
	m_fPushed			= FALSE;
	m_fEnable			= TRUE;
	m_fDblClked			= FALSE; // kwada raid:#852
	m_fWaiting			= FALSE; // kwada raid:#852
	m_fArmed			= FALSE; // kwada raid:#852
#ifdef NOTUSED // kwada raid:#852
	m_wNotifyMsg		= EXBN_CLICKED;
#endif

	//----------------------------------------------------------------
	// for 16bit Application(for Word6.0)
	//----------------------------------------------------------------
	m_f16bitOnNT = FALSE;
#ifndef UNDER_CE // Windows CE always 32bit application
	if(ExIsWinNT()) {
		char szBuf[256];
		DWORD dwType = 0;
		::GetModuleFileName(NULL, szBuf, sizeof(szBuf));
		::GetBinaryType(szBuf, &dwType);
		if(dwType == SCS_WOW_BINARY) {
			m_f16bitOnNT = TRUE;
		}
	}
#endif // UNDER_CE
}

//////////////////////////////////////////////////////////////////
// Function : ~CEXButton
// Type     : 
// Purpose  : Destructor
// Args     : 
//          : 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
CEXButton::~CEXButton()
{
	Dbg(("~CEXButton \n"));
	if(m_hIcon) {
		Dbg(("DestroyIcon\n"));
		DestroyIcon(m_hIcon); 
		m_hIcon = NULL;
	}
	if(m_hFont) {
		Dbg(("Delete FONT\n"));
		DeleteObject(m_hFont);
		m_hFont = NULL;
	}
	if(m_lpwstrText) {
		MemFree(m_lpwstrText);
		m_lpwstrText = NULL;
	}
}

//////////////////////////////////////////////////////////////////
// Function : RegisterWinClass
// Type     : BOOL
// Purpose  : 
// Args     : 
//          : LPSTR lpstrClassName 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
#ifndef UNDER_CE
BOOL CEXButton::RegisterWinClass(LPSTR lpstrClass)
#else // UNDER_CE
BOOL CEXButton::RegisterWinClass(LPTSTR lpstrClass)
#endif // UNDER_CE
{
	ATOM ret;
	//----------------------------------------------------------------
	//check specified class is already exist or not
	//----------------------------------------------------------------
#ifndef UNDER_CE // Windows CE does not support EX
	if(::GetClassInfoEx(m_hInst, lpstrClass, &m_tmpWC)){
#else // UNDER_CE
	if(::GetClassInfo(m_hInst, lpstrClass, &m_tmpWC)){
#endif // UNDER_CE
		//lpstrClass is already registerd.
		return TRUE;
	}
	::ZeroMemory(&m_tmpWC, sizeof(m_tmpWC));
#ifndef UNDER_CE // Windows CE does not support EX
	m_tmpWC.cbSize			= sizeof(m_tmpWC);
#endif // UNDER_CE
	m_tmpWC.style			= CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;	 /* Class style(s). */
	m_tmpWC.lpfnWndProc		= (WNDPROC)WndProc;
	m_tmpWC.cbClsExtra		= 0;						/* No per-class extra data.*/
	m_tmpWC.cbWndExtra		= sizeof(LPCEXButton);	// Set Object's pointer.	
	m_tmpWC.hInstance		= m_hInst;					/* Application that owns the class.	  */
	m_tmpWC.hIcon			= NULL; 
	m_tmpWC.hCursor			= LoadCursor(NULL, IDC_ARROW);
	m_tmpWC.hbrBackground	= (HBRUSH)NULL;
	//m_tmpWC.hbrBackground	= (HBRUSH)(COLOR_3DFACE+1);
	m_tmpWC.lpszMenuName	= NULL;						/* Name of menu resource in .RC file. */
	m_tmpWC.lpszClassName	= lpstrClass;				/* Name used in call to CreateWindow. */
#ifndef UNDER_CE // Windows CE does not support EX
	m_tmpWC.hIconSm			= NULL;
	ret = ::RegisterClassEx(&m_tmpWC);
#else // UNDER_CE
	ret = ::RegisterClass(&m_tmpWC);
#endif // UNDER_CE
	return ret ? TRUE: FALSE;
}

INT CEXButton::MsgCreate(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	m_hwndFrame = hwnd;
	return 1;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgPaint
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgPaint(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	PAINTSTRUCT ps;
	RECT		rc;
	HDC			hDCMem;
	HDC			hDC;
	HBITMAP		hBitmap, hBitmapPrev;


	::GetClientRect(hwnd, &rc);
	hDC				= ::BeginPaint(hwnd, &ps);
	hDCMem			= ::CreateCompatibleDC(hDC);
	hBitmap			= ::CreateCompatibleBitmap(hDC, rc.right - rc.left, rc.bottom - rc.top);
	hBitmapPrev		= (HBITMAP)::SelectObject(hDCMem, hBitmap);
	
	DrawButton(hDCMem, &rc);

	::BitBlt(hDC, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
			 hDCMem, 0, 0, SRCCOPY);

	::SelectObject(hDCMem, hBitmapPrev );

	::DeleteObject(hBitmap);
	::DeleteDC(hDCMem);
	::EndPaint(hwnd, &ps);
	return 0;
	UnrefForMsg();
}

INT CEXButton::MsgDestroy(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgTimer
// Type     : INT
// Purpose  : wait for the second click
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     :
//			: change for raid #852. kwada:980402
//////////////////////////////////////////////////////////////////

INT CEXButton::MsgTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	static RECT  rc;
	static POINT pt;

	switch(wParam) {
#ifndef UNDER_CE // no monitor position. (not support GetCursorPos)
	case TIMERID_MONITORPOS:
		Dbg(("MsgTimer TIMERID_MONITORPOS\n"));
		::GetWindowRect(hwnd, &rc);
		::GetCursorPos(&pt);
		if(!::PtInRect(&rc, pt)) {
			::KillTimer(hwnd, wParam);
			::InvalidateRect(hwnd, NULL, NULL);
		}
		break;
#endif // UNDER_CE
	case TIMERID_DOUBLEORSINGLECLICKED:
		{
			Dbg(("MsgTimer TIMERID_DOUBLEORSINGLECLICKED\n"));
			KillTimer(hwnd, wParam);
			m_fWaiting = FALSE;
			if(!m_fDowned) // The second click didn't come. kwada raid:#852
				NotifyClickToParent(EXBN_CLICKED);
		}
		break;
	}
	return 0;
	UnrefForMsg();
}
//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgMouseMove
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     :
//			: change for raid #852. kwada:980402
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgMouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgMouseMove START \n"));
	if(m_fDowned) { // Mouse was already DOWNED,Captured.
		if(m_f16bitOnNT) {
#ifndef UNDER_CE // Windows CE always 32bit application
			RECT rc;
			POINT pt;
			::GetWindowRect(hwnd, &rc);
			::GetCursorPos(&pt);
			if(!::PtInRect(&rc, pt)) {
				::InvalidateRect(hwnd, NULL, NULL);
				return 0;
			}
#endif // UNDER_CE
		}
		else { //normal case
			m_tmpPoint.x = LOWORD(lParam);
			m_tmpPoint.y = HIWORD(lParam);
			GetClientRect(hwnd, &m_tmpRect);
			if(PtInRect(&m_tmpRect, m_tmpPoint)) // moved to inside
				PressedState();
			else // moved to outside
				CancelPressedState();
		}
	}
	InvalidateRect(hwnd, NULL, FALSE);
	Dbg(("MsgMouseMove END\n"));
	return 0;
	UnrefForMsg();
}

INT CEXButton::MsgNcMouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgNcMouseMove START \n"));
	return 0;
	UnrefForMsg();
}


//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgButtonDown
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     :
//			: change for raid #852. kwada:980402
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgButtonDown START wParam[0x%08x] lParam[0x%08x]\n", wParam, lParam));
	static RECT rc;
	POINT  pt;
	pt.x = LOWORD(lParam);
	pt.y = HIWORD(lParam);
	if(uMsg != WM_LBUTTONDOWN && uMsg != WM_LBUTTONDBLCLK) {
		Dbg(("MsgButtonDown END\n"));
		return 0;
	}
	if(!m_fEnable) {
		Dbg(("MsgButtonDown END\n"));
		return 0;
	}

	GetClientRect(hwnd, &rc);
	if(m_dwStyle & EXBS_DBLCLKS) { // accept double clicks
		Dbg(("MsgButtonDown \n"));
		KillTimer(hwnd, TIMERID_DOUBLEORSINGLECLICKED);
		if ( uMsg == WM_LBUTTONDOWN ) {
			// mouse down
			//----------------------------------------------------------------
			//for 16bit application on WinNT, do not call SetCapture()
			//----------------------------------------------------------------
			if(m_f16bitOnNT) {
#ifndef UNDER_CE // Windows CE always 32bit application
#ifdef _DEBUG
				UINT_PTR ret = ::SetTimer(hwnd, TIMERID_MONITORPOS, 100, NULL);
				Dbg(("SetTimer [%p][%d]\n", ret, GetLastError()));
#else
				::SetTimer(hwnd, TIMERID_MONITORPOS, 100, NULL);
#endif
#endif // UNDER_CE
			}
			else {
				SetCapture(hwnd);
			}
			m_fDowned = TRUE;
			m_fDblClked = FALSE;
			PressedState();
			// timer on - wait for the second click.
			m_fWaiting = TRUE;
			SetTimer(hwnd,  TIMERID_DOUBLEORSINGLECLICKED, GetDoubleClickTime(), NULL);
		}
		else { // uMsg == WM_LBUTTONDBLCLK
			Dbg(("MsgButtonDown \n"));
			// mouse down
			if(m_f16bitOnNT) {
#ifdef _DEBUG
				UINT_PTR ret = ::SetTimer(hwnd, TIMERID_MONITORPOS, 100, NULL);
				Dbg(("SetTimer [%p][%d]\n", ret, GetLastError()));
#else
				::SetTimer(hwnd, TIMERID_MONITORPOS, 100, NULL);
#endif
			}
			else {
				SetCapture(hwnd);
			}
			m_fDowned = TRUE;
			m_fDblClked = m_fWaiting ? TRUE : FALSE; // consider if DBLCLK comes after timeout
			m_fWaiting = FALSE;
			PressedState();
		}
	}else { // single click only
		// LBUTTONDOWN  & LBUTTONDBLCLK
		// mouse down
		if(m_f16bitOnNT) {
#ifndef UNDER_CE // Windows CE always 32bit application
#ifdef _DEBUG
			UINT_PTR ret = ::SetTimer(hwnd, TIMERID_MONITORPOS, 100, NULL);
			Dbg(("SetTimer [%p][%d]\n", ret, GetLastError()));
#else
			::SetTimer(hwnd, TIMERID_MONITORPOS, 100, NULL);
#endif
#endif // UNDER_CE
		}
		else {
			SetCapture(hwnd);
		}
		m_fDowned = TRUE;
		m_fDblClked = FALSE;
		PressedState();
	}

	InvalidateRect(hwnd, NULL, FALSE);
	Dbg(("MsgButtonDown END\n"));
	return 0;
	UnrefForMsg();
}

INT CEXButton::MsgNcButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgNcButtonDown START\n"));
	return 0;
	Unref(uMsg);
	UnrefForMsg();
}

INT CEXButton::MsgNcButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgNcButtonUp START\n"));
	return 0;
	Unref(uMsg);
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgButtonUp
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     :
//			: change for raid #852. kwada:980402
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgButtonUp START\n"));
	static RECT rc;
	POINT  pt;
	if(uMsg != WM_LBUTTONUP) {
		Dbg(("MsgButtonUp END\n"));
		return 0;
	}
	if(!m_fEnable) {
		Dbg(("MsgButtonUp END\n"));
		return 0;
	}
	pt.x = LOWORD(lParam);
	pt.y = HIWORD(lParam);
	GetClientRect(hwnd, &rc);

	if(m_dwStyle & EXBS_DBLCLKS) {
		if(m_fDowned) // captured
		{
			if(PtInRect(&rc, pt)) // inside
			{
				if(m_fDblClked)	{ // end of double click
					m_fDblClked = FALSE;
					NotifyClickToParent(EXBN_DOUBLECLICKED);
				}
				else { // end of single click
					if(!m_fWaiting) // after timeout - second click won't come.
						NotifyClickToParent(EXBN_CLICKED);
				}
			}
		}
	}
	else { // single click only
		if(m_fDowned) // captured
		{
			if(PtInRect(&rc, pt))
				NotifyClickToParent(EXBN_CLICKED);
			else
				CancelPressedState();
		}
	}

#ifndef UNDER_CE // Windows CE always 32bit application
	if(m_f16bitOnNT) {
		::KillTimer(hwnd, TIMERID_MONITORPOS);
	}
#endif // UNDER_CE
	//if(hwnd == GetCapture()) {
	ReleaseCapture();
	//}
	m_fDowned = FALSE;	
	InvalidateRect(hwnd, NULL, FALSE);
	Dbg(("MsgButtonUp END\n"));
	return 0;
	Unref(uMsg);
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgEnable
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     :
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgEnable(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	//Dbg(("MsgEnabled START wParam[%d]\n", wParam));
	m_fEnable = (BOOL)wParam;
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	UnrefForMsg();
}

INT CEXButton::MsgSetFont(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	HFONT hFont = (HFONT)wParam;
	BOOL fRedraw = LOWORD(lParam);

	HFONT hFontNew;
	if(!hFont) {
		return 0;
	}
#ifndef UNDER_CE
	LOGFONTA logFont;
#else  // UNDER_CE
	LOGFONT logFont;
#endif // UNDER_CE
	::GetObject(hFont, sizeof(logFont), &logFont);

	hFontNew = ::CreateFontIndirect(&logFont);
	if(!hFontNew) {
		return 0;
	}
	if(m_hFont) {
		::DeleteObject(m_hFont);
	}
	m_hFont = hFontNew;
	if(fRedraw) {
		::InvalidateRect(hwnd, NULL, TRUE);
	}
	return 0;
}


//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgCaptureChanged
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgCaptureChanged(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgCaptureChanged START \n"));
#ifdef _DEBUG
	HWND hwndCap = ::GetCapture();
	CHAR szBuf[256];
	szBuf[0] = (CHAR)0x00;
	::GetClassName(hwndCap, szBuf, sizeof(szBuf));
	Dbg(("-->hwndCap [0x%08x][%s]\n", hwndCap, szBuf));
#endif
	//m_fDowned = FALSE;
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgEXB_GetCheck
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgEXB_GetCheck(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	return m_fPushed;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgEXB_SetCheck
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgEXB_SetCheck(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	BOOL fPrev = m_fPushed;
	//
	//m_fPushed is Always 1 or 0. do not set != 0 data as TRUE
	m_fPushed = (BOOL)wParam ? 1 : 0;
	if(m_dwStyle & EXBS_TOGGLE){
		if(fPrev != m_fPushed) {
			NotifyToParent(m_fPushed ? EXBN_ARMED : EXBN_DISARMED);
		}
	}
	m_fArmed = m_fPushed;
	InvalidateRect(hwnd, NULL, FALSE);
	return m_fPushed;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgEXB_SetIcon
// Type     : INT
// Purpose  : Set new icon.
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam		HICON hIcon.	
//          : LPARAM lParam		no use.	
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgEXB_SetIcon(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	//Dbg(("MsgEXB_SetIcon: wParam[0x%08x] lParam[0x%08x]\n", wParam, lParam));
	if((HICON)wParam == NULL) {
		Dbg(("MsgEXB_SetIcon: ERROR END\n"));
		return -1;
	}
	//if icon style is not set, destroy specified icon
	if(!(m_dwStyle & EXBS_ICON)) {
		DestroyIcon((HICON)wParam);
		return -1;
	} 
	if(m_hIcon) {
		DestroyIcon(m_hIcon);
	} 
	m_hIcon = (HICON)wParam;

	//----------------------------------------------------------------
	//Get Icon width and height.
	//----------------------------------------------------------------
#ifndef UNDER_CE // Windows CE does not support GetIconInfo()
	ZeroMemory(&m_tmpIconInfo, sizeof(m_tmpIconInfo));
	::GetIconInfo(m_hIcon, &m_tmpIconInfo);
	//Dbg(("fIcon    [%d]\n",		m_tmpIconInfo.fIcon ));
	//Dbg(("xHotspot [%d]\n",		m_tmpIconInfo.xHotspot ));
	//Dbg(("yHotspot [%d]\n",		m_tmpIconInfo.yHotspot ));
	//Dbg(("hbmMask  [0x%08x]\n", m_tmpIconInfo.hbmMask ));
	//Dbg(("hbmColor [0x%08x]\n", m_tmpIconInfo.hbmColor ));

	if(m_tmpIconInfo.hbmMask) {
		GetObject(m_tmpIconInfo.hbmMask, sizeof(m_tmpBitmap), &m_tmpBitmap);
#if 0
		Dbg(("bmWidth[%d] bmHeight[%d]\n", 
			 m_tmpBitmap.bmWidth,
			 m_tmpBitmap.bmHeight));
#endif
		DeleteObject(m_tmpIconInfo.hbmMask);
		m_cxIcon = m_tmpBitmap.bmWidth;
		m_cyIcon = m_tmpBitmap.bmHeight;
	}
	if(m_tmpIconInfo.hbmColor) {
		DeleteObject(m_tmpIconInfo.hbmColor);
	}
#else // UNDER_CE
	m_cxIcon = GetSystemMetrics(SM_CXSMICON);
	m_cyIcon = GetSystemMetrics(SM_CYSMICON);
#endif // UNDER_CE
	InvalidateRect(hwnd, NULL, FALSE);
	UpdateWindow(hwnd);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgEXB_SetText
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND	 hwnd 
//          : WPARAM wParam		LPWSTR lpwstr: null terminated Unicode string.
//          : LPARAM lParam		no use.
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgEXB_SetText(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	//Dbg(("MsgEXB_SetText START wParam[0x%08x]\n", wParam));
	if(!(LPWSTR)wParam) {
		Dbg(("--->Error \n"));
		return -1;
	}

	if( ((LPWSTR)wParam)[0] == (WCHAR)0x0000) {
		Dbg(("--->Error \n"));
		return -1;
	} 

	if(m_lpwstrText) {
		MemFree(m_lpwstrText);
	}
	m_lpwstrText = StrdupW((LPWSTR)wParam);
	//DBGW((L"--->NEW m_lpwstrText [%s]\n", m_lpwstrText));
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	Unref(lParam);
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::MsgEXB_SetStyle
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam		DWORD dwStyle:
//          : LPARAM lParam		no use.
// Return   : 
// DATE     :
//			: modified by kwada:980402 
//////////////////////////////////////////////////////////////////
INT CEXButton::MsgEXB_SetStyle(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	DWORD dwStyle = (DWORD)wParam;
	m_dwStyle = dwStyle;
	if(m_dwStyle & EXBS_TOGGLE)
		m_fArmed = m_fPushed;
	else
		m_fArmed = m_fDowned;
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	Unref(hwnd);
	Unref(lParam);
}
//----------------------------------------------------------------
//Private method definition
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function : CEXButton::NotifyToParent
// Type     : INT
// Purpose  : Send WM_COMMAND to Parent window procedure.
// Args     : 
//          : INT notify 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::NotifyToParent(INT notify)
{
	SendMessage(m_hwndParent, 
				WM_COMMAND, 
				MAKEWPARAM(m_wID, notify),
				(LPARAM)m_hwndFrame);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::NotifyClickToParent
// Type     : INT
// Purpose  : Change state and send click to the parent window.
// Args     : 
//          : INT notify (EXBN_CLICKED or EXBN_DOUBLECLICKED)
// Return   : 
// DATE     : kwada:980402 for raid #852
//////////////////////////////////////////////////////////////////
INT CEXButton::NotifyClickToParent(INT notify)
{
	if(m_dwStyle & EXBS_TOGGLE) { // toggle state for toggle button
		m_fPushed ^=1;
		if(m_fArmed && !m_fPushed) {
			NotifyToParent(EXBN_DISARMED);
		}
		else if(!m_fArmed && m_fPushed) {
			NotifyToParent(EXBN_ARMED);
		}
		m_fArmed = m_fPushed;
	}
	else { // push button
		if(m_fArmed) {
			m_fArmed = FALSE;
			NotifyToParent(EXBN_DISARMED);
		}
	}
	NotifyToParent(notify);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::PressedState
// Type     : INT
// Purpose  : Change apparence:turn to pressed state
// Args     : 
//          : 
// Return   :
// DATE     : kwada:980402 for raid #852
//////////////////////////////////////////////////////////////////
INT CEXButton::PressedState()
{
	if(!m_fArmed){
		NotifyToParent(EXBN_ARMED);
		m_fArmed = TRUE;
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::CancelPressedState
// Type     : INT
// Purpose  : Change apparence:back to original state
// Args     : 
//          : 
// Return   :
// DATE     : kwada:980402 for raid #852
//////////////////////////////////////////////////////////////////
INT CEXButton::CancelPressedState()
{
	if(m_dwStyle & EXBS_TOGGLE) {
		if(m_fArmed && !m_fPushed) {
			NotifyToParent(EXBN_DISARMED);
		}
		else if(!m_fArmed && m_fPushed) {
			NotifyToParent(EXBN_ARMED);
		}
		m_fArmed = m_fPushed;
	}
	else {
		if(m_fArmed) {
			NotifyToParent(EXBN_DISARMED);
			m_fArmed = FALSE;
		}
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawButton
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawButton(HDC hDC, LPRECT lpRc)
{
#if 0
	Dbg(("DrawButton Start l[%d] t[%d] r[%d] b[%d]\n", 
		 lpRc->left,
		 lpRc->top,
		 lpRc->right,
		 lpRc->bottom));
#endif

#ifndef UNDER_CE // Windows CE does not support GetCursorPos()
	POINT pt;
	GetCursorPos(&pt);
	ScreenToClient(m_hwndFrame, &pt);
#endif // UNDER_CE
	IMAGESTYLE styleBtn;
	DWORD		dwOldTextColor, dwOldBkColor;


	BOOL fFlat			  = m_dwStyle & EXBS_FLAT;
	BOOL fToggle		  = (m_dwStyle & EXBS_TOGGLE) && m_fPushed;
	//Dbg(("m_dwStyle [0x%08x]\n", m_dwStyle));
#if 0
	BOOL fMouseOnButton	  = PtInRect(lpRc, pt);
	Dbg(("fOnMouse [%d] fFlat[%d] fToggle[%d]\n", 
		 fMouseOnButton,
		 fFlat,
		 fToggle));
#endif

#ifndef UNDER_CE // Windows CE does not support GetCursorPos()
	if(fFlat && !PtInRect(lpRc, pt) && !m_fDowned) {
#else // UNDER_CE
	if(fFlat && !m_fDowned) {
#endif // UNDER_CE
		styleBtn = fToggle ? IS_PUSHED : IS_FLAT;
	}
#ifdef OLD
	else if(PtInRect(lpRc, pt) && m_fDowned) {
		styleBtn = fToggle ? IS_POPED : IS_PUSHED;
	}
	else {
		styleBtn = fToggle ? IS_PUSHED : IS_POPED;
	}
#else
	else {
		styleBtn = m_fArmed ? IS_PUSHED : IS_POPED; // kwada:980402 raid #852
	}
#endif
	if(styleBtn == IS_PUSHED && (m_dwStyle & EXBS_TOGGLE) ) {
		// dither - kwada :raid #592
		HBITMAP hBitmap;
		HBRUSH	hPatBrush,hOldBrush;
		WORD pat[8]={0x5555,0xAAAA,0x5555,0xAAAA,0x5555,0xAAAA,0x5555,0xAAAA};

		hPatBrush = NULL;
		hBitmap	= ::CreateBitmap(8,8,1,1,pat);
		if(hBitmap)
			hPatBrush	= ::CreatePatternBrush(hBitmap);

		if(hPatBrush) {
			hOldBrush	= (HBRUSH)::SelectObject(hDC,hPatBrush);
			dwOldBkColor = ::SetBkColor(hDC,::GetSysColor(COLOR_3DHILIGHT));
			dwOldTextColor = ::SetTextColor(hDC,::GetSysColor(COLOR_3DFACE));

			::FillRect(hDC, lpRc, hPatBrush);

			::SetTextColor(hDC,dwOldTextColor);
			::SetBkColor(hDC,dwOldBkColor);
			::SelectObject(hDC,hOldBrush);
			::DeleteObject(hPatBrush);
		}else
#ifndef UNDER_CE
			::FillRect(hDC, lpRc, (HBRUSH)(COLOR_3DHILIGHT +1));
#else // UNDER_CE
			::FillRect(hDC, lpRc, GetSysColorBrush(COLOR_3DHILIGHT));
#endif // UNDER_CE

		if(hBitmap)
			::DeleteObject(hBitmap);

		dwOldBkColor	= ::SetBkColor(hDC, ::GetSysColor(COLOR_3DHILIGHT));
	}
	else {
#ifndef UNDER_CE
		::FillRect(hDC, lpRc, (HBRUSH)(COLOR_3DFACE +1));
#else // UNDER_CE
		::FillRect(hDC, lpRc, GetSysColorBrush(COLOR_3DFACE));
#endif // UNDER_CE
		dwOldBkColor	= ::SetBkColor(hDC, GetSysColor(COLOR_3DFACE));
	}
	dwOldTextColor	= ::SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));

	if(m_dwStyle & EXBS_THINEDGE) {
		DrawThinEdge(hDC, lpRc,  styleBtn);
	}
	else {
		DrawThickEdge(hDC, lpRc,  styleBtn);
	}
	if(m_dwStyle & EXBS_ICON) {
		DrawIcon(hDC, lpRc, styleBtn);
	}
	else {
		DrawText(hDC, lpRc, styleBtn);
	}
	::SetBkColor(hDC, dwOldBkColor);
	::SetTextColor(hDC, dwOldTextColor);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawThickEdge
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawThickEdge(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	if(style == IS_FLAT) {
		return 0;
	}

	HPEN hPenOrig   = NULL;
	HPEN hPenWhite  = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
	HPEN hPenGlay   = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
	HPEN hPenBlack  = (HPEN)GetStockObject(BLACK_PEN);


	switch(style) {
	case IS_POPED:
		hPenOrig  = (HPEN)::SelectObject(hDC, hPenWhite);
		DrawLine(hDC, lpRc->left, lpRc->top, lpRc->right-1, lpRc->top); 
		DrawLine(hDC, lpRc->left, lpRc->top, lpRc->left, lpRc->bottom - 1);

		SelectObject(hDC, hPenGlay);
		DrawLine(hDC, lpRc->right-2, lpRc->top+1,    lpRc->right-2, lpRc->bottom - 1);
		DrawLine(hDC, lpRc->left+1,  lpRc->bottom-2, lpRc->right-1, lpRc->bottom - 2); 

		SelectObject(hDC, hPenBlack);
		DrawLine(hDC, lpRc->right-1, lpRc->top,  lpRc->right-1, lpRc->bottom); 		
		DrawLine(hDC, lpRc->left,    lpRc->bottom-1, lpRc->right,  lpRc->bottom-1);
		break;
	case IS_PUSHED:
		hPenOrig  = (HPEN)::SelectObject(hDC, hPenBlack);
		DrawLine(hDC, lpRc->left, lpRc->top, lpRc->right-1, lpRc->top); 
		DrawLine(hDC, lpRc->left, lpRc->top, lpRc->left, lpRc->bottom - 1);

		SelectObject(hDC, hPenGlay);
		DrawLine(hDC, lpRc->left+1, lpRc->top+1, lpRc->right-2, lpRc->top+1); 		
		DrawLine(hDC, lpRc->left+1, lpRc->top+1, lpRc->left+1,  lpRc->bottom - 2);

		SelectObject(hDC, hPenWhite);
		DrawLine(hDC, lpRc->right-1, lpRc->top,  lpRc->right-1, lpRc->bottom); 		
		DrawLine(hDC, lpRc->left,    lpRc->bottom-1, lpRc->right-1,  lpRc->bottom - 1);
		break;
	default:
		break;
	}
	if(hPenOrig) {
		SelectObject(hDC, hPenOrig);
	}
	DeleteObject(hPenWhite);
	DeleteObject(hPenGlay);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawThinEdge
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawThinEdge(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	HPEN hPenPrev;
	HPEN hPenTopLeft=0;
	HPEN hPenBottomRight=0;

	switch(style) {
	case IS_PUSHED:
		hPenTopLeft	    = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
		hPenBottomRight = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
		break;
	case IS_POPED:
		hPenTopLeft		= CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
		hPenBottomRight = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
		break;
	case IS_FLAT:	// do not draw 
		return 0;
		break;
	}

	hPenPrev = (HPEN)::SelectObject(hDC, hPenTopLeft);
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
	MoveToEx(hDC, lpRc->left, lpRc->top, NULL);
	LineTo(hDC,   lpRc->right, lpRc->top);
	MoveToEx(hDC, lpRc->left, lpRc->top, NULL);
	LineTo(hDC,   lpRc->left, lpRc->bottom);
#else // UNDER_CE
	{
		POINT pts[] = {{lpRc->left,  lpRc->bottom},
					   {lpRc->left,  lpRc->top},
					   {lpRc->right, lpRc->top}};
		Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
	}
#endif // UNDER_CE

	SelectObject(hDC, hPenBottomRight);
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
	MoveToEx(hDC, lpRc->right -1, lpRc->top - 1, NULL);
	LineTo(hDC,   lpRc->right -1, lpRc->bottom);
	MoveToEx(hDC, lpRc->left + 1, lpRc->bottom -1, NULL);
	LineTo(hDC,   lpRc->right -1, lpRc->bottom -1);
#else // UNDER_CE
	{
		POINT pts[] = {{lpRc->right - 1, lpRc->top    - 1},
					   {lpRc->right - 1, lpRc->bottom - 1},
					   {lpRc->left  + 1, lpRc->bottom - 1}};
		Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
	}
#endif // UNDER_CE

	SelectObject(hDC, hPenPrev);
	DeleteObject(hPenTopLeft);
	DeleteObject(hPenBottomRight);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawLine
// Type     : INT
// Purpose  : Draw Line with current Pen. 
// Args     : 
//          : HDC hDC 
//          : INT x 
//          : INT y 
//          : INT destX 
//          : INT destY 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawLine(HDC hDC, INT x, INT y, INT destX, INT destY)
{
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
	MoveToEx(hDC, x, y, NULL);
	LineTo  (hDC, destX, destY);
#else // UNDER_CE
	POINT pts[] = {{x, y}, {destX, destY}};
	Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
#endif // UNDER_CE
	return 0;
}
//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawIcon
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawIcon(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	if(!m_hIcon) {
		return -1;
	}

	INT sunken, xPos, yPos;
	switch(style) {
	case IS_PUSHED:
		sunken = 1;
		break;
	case IS_POPED:
	case IS_FLAT:
	default:
		sunken = 0;
		break;
	}
	//----------------------------------------------------------------
	//centering Icon
	xPos = lpRc->left + ((lpRc->right  - lpRc->left) - m_cxIcon)/2;
	yPos = lpRc->top  + ((lpRc->bottom - lpRc->top)  - m_cyIcon)/2;
	DrawIconEx(hDC,				//HDC hdc,// handle to device context
			   xPos + sunken,	//int xLeft,// x-coordinate of upper left corner
			   yPos + sunken,	//int yTop,// y-coordinate of upper left corner
			   m_hIcon,			//HICON hIcon,// handle to icon to draw
			   m_cxIcon,		//int cxWidth,// width of the icon
			   m_cyIcon,		//int cyWidth,// height of the icon
			   0,				//UINT istepIfAniCur,// index of frame in animated cursor
			   NULL,			//HBRUSH hbrFlickerFreeDraw,// handle to background brush
			   DI_NORMAL);		//UINT diFlags// icon-drawing flags
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawBitmap
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawBitmap(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	return 0;
	Unref(hDC);
	Unref(lpRc);
	Unref(style);
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawText
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
inline BOOL MIN(INT a, INT b)
{
	if(a > b) {
		return b;
	}
	else {
		return a;
	}
}
//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawText
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawText(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
#if 0
	Dbg(("DrawText START style[%d]\n", style));
	Dbg(("--->Clinet w[%d] h[%d]\n",
		 lpRc->right - lpRc->left,
		 lpRc->bottom - lpRc->top));
#endif
	static POINT pt;
	static RECT	 rc;
	INT sunken, len;
	if(!m_lpwstrText) {
		Dbg(("--->Error m_lpwstrText is NULL\n"));
		return -1;
	}
	len = lstrlenW(m_lpwstrText);
	//DBGW((L"--->len [%d] str[%s]\n", len, m_lpwstrText));
	HFONT hFontPrev;

	if(m_hFont) {
		hFontPrev = (HFONT)::SelectObject(hDC, m_hFont); 
	}
	else {
		hFontPrev = (HFONT)::SelectObject(hDC, GetStockObject(DEFAULT_GUI_FONT));
	}

	ExGetTextExtentPoint32W(hDC, 
							m_lpwstrText, 
							len, 
							&m_tmpSize);
	//Dbg(("--->size.cx [%d] cy[%d]\n", m_tmpSize.cx, m_tmpSize.cy));
	if((lpRc->right - lpRc->left) > m_tmpSize.cx) {
		pt.x = lpRc->left + ((lpRc->right - lpRc->left) - m_tmpSize.cx)/2;
	}
	else {
		pt.x = lpRc->left+2; //2 is edge space
	}
	
	if((lpRc->bottom - lpRc->top) > m_tmpSize.cy) {
		pt.y = lpRc->top + ((lpRc->bottom - lpRc->top) - m_tmpSize.cy)/2;
	}
	else {
		pt.y = lpRc->top+2; //2 is edge space 
	}
	switch(style) {
	case IS_PUSHED:
		sunken = 1;
		break;
	case IS_POPED:
	case IS_FLAT:
	default:
		sunken = 0;
	}

	rc.left   = pt.x;
	rc.right  = lpRc->right - 2;
	rc.top    = pt.y;
	rc.bottom = lpRc->bottom-2;
#if 0
	Dbg(("--->rc l[%d] t[%d] r[%d] b[%d]\n", 
		 rc.left,
		 rc.top,
		 rc.right,
		 rc.bottom));
#endif
	if(m_fEnable) {
		DWORD dwOldBk = ::SetBkMode(hDC, TRANSPARENT);
		ExExtTextOutW(hDC,
					  pt.x + sunken, 
					  pt.y + sunken,
					  ETO_CLIPPED,
					  &rc, 
					  m_lpwstrText,
					  len,
					  NULL);
		::SetBkMode(hDC, dwOldBk);
	}
	else {
		DWORD dwOldTC;
		static RECT rcBk;
		rcBk = rc;
		rcBk.left   +=1 ;
		rcBk.top    +=1 ;
		rcBk.right  +=1;
		rcBk.bottom +=1;
		//Draw white text.
		dwOldTC = ::SetTextColor(hDC, GetSysColor(COLOR_3DHILIGHT));
		ExExtTextOutW(hDC,
					  pt.x + sunken+1,
					  pt.y + sunken+1,
					  ETO_CLIPPED,
					  &rcBk, 
					  m_lpwstrText,
					  len,
					  NULL);
		::SetTextColor(hDC, GetSysColor(COLOR_GRAYTEXT));
		DWORD dwOldBk = ::SetBkMode(hDC, TRANSPARENT);
		ExExtTextOutW(hDC,
					  pt.x + sunken, 
					  pt.y + sunken,
					  ETO_CLIPPED,
					  &rc, 
					  m_lpwstrText,
					  len,
					  NULL);
		::SetBkMode(hDC, dwOldBk);
		::SetTextColor(hDC, dwOldTC);
	}

	SelectObject(hDC, hFontPrev);

	//Dbg(("--->DrawText END\n"));
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\exbtn.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "dbg.h"
#include "cexbtn.h"

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//////////////////////////////////////////////////////////////////
// Function : EXButton_CreateWindow
// Type     : HWND
// Purpose  : Opened API.
//			: Create Extended Button.
// Args     : 
//          : HINSTANCE		hInst 
//          : HWND			hwndParent 
//          : DWORD			dwStyle		EXBS_XXXXX combination.
//          : INT			wID			Window ID
//          : INT			xPos 
//          : INT			yPos 
//          : INT			width 
//          : INT			height 
// Return   : 
// DATE     : 970905
//////////////////////////////////////////////////////////////////
#ifndef UNDER_CE
#define SZCLASSNAME "MSIME_EXB"
#else // UNDER_CE
#define SZCLASSNAME TEXT("MSIME_EXB")
#endif // UNDER_CE
#ifdef UNDER_CE // In Windows CE, all window classes are process global.
static LPCTSTR MakeClassName(HINSTANCE hInst, LPTSTR lpszBuf)
{
	// make module unique name
	TCHAR szFileName[MAX_PATH];
	GetModuleFileName(hInst, szFileName, MAX_PATH);
	LPTSTR lpszFName = _tcsrchr(szFileName, TEXT('\\'));
	if(lpszFName) *lpszFName = TEXT('_');
	StringCchCopy(lpszBuf, MAX_PATH, SZCLASSNAME);
	StringCchCat(lpszBuf, MAX_PATH, lpszFName);
	return lpszBuf;
}

BOOL EXButton_UnregisterClass(HINSTANCE hInst)
{
	TCHAR szClassName[MAX_PATH];
	return UnregisterClass(MakeClassName(hInst, szClassName), hInst);
}

#endif // UNDER_CE
HWND EXButton_CreateWindow(HINSTANCE	hInst, 
						   HWND			hwndParent, 
						   DWORD		dwStyle,
						   INT			wID, 
						   INT			xPos,
						   INT			yPos,
						   INT			width,
						   INT			height)
{
	DBG_INIT();
	LPCEXButton lpEXB = new CEXButton(hInst, hwndParent, dwStyle, wID);
	HWND hwnd;
	if(!lpEXB) {
		return NULL;
	}
#ifndef UNDER_CE // In Windows CE, all window classes are process global.
	lpEXB->RegisterWinClass(SZCLASSNAME);
	hwnd = CreateWindowEx(0,
						  SZCLASSNAME, 
#else // UNDER_CE
	TCHAR szClassName[MAX_PATH];
	MakeClassName(hInst, szClassName);

	lpEXB->RegisterWinClass(szClassName);
	hwnd = CreateWindowEx(0,
						  szClassName, 
#endif // UNDER_CE
#ifndef UNDER_CE
						  "", 
#else // UNDER_CE
						  TEXT(""),
#endif // UNDER_CE
						  WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, 
						  xPos, yPos,
						  width,
						  height,
						  hwndParent,
#ifdef _WIN64
						  (HMENU)(INT_PTR)wID,
#else
						  (HMENU)wID,
#endif
						  hInst,
						  (LPVOID)lpEXB);
	return hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testmain.rc
//
#define IDI_ICON1                       111
#define IDI_ICON2                       112
#define IDD_LISTREPORT                  500
#define IDD_PADLIST                     501
#define IDC_ADDITEM                     1024
#define IDC_INSERTITEM                  1025
#define IDC_GETCURSEL                   1026
#define IDC_SETTEXT                     1027
#define IDC_SETCURSEL                   1033
#define IDC_SETICON                     1034
#define IDC_DDBS_TEXT                   1037
#define IDC_EXBS_TEXT                   1037
#define IDC_SETSTYLE                    1038
#define IDC_DDBS_ICON                   1039
#define IDC_EXBS_ICON                   1039
#define IDC_DDBS_DROPDOWN               1040
#define IDC_EXBS_TOGGLE                 1040
#define IDC_DDBS_THINEDGE               1041
#define IDC_EXBS_THINEDGE               1041
#define IDC_DDBS_FLAT                   1043
#define IDC_EXBS_FLAT                   1043
#define IDC_EDIT_ADDITEM                1044
#define IDC_EDIT_INSERTITEM_INDEX       1045
#define IDC_EDIT_INSERTITEM             1046
#define IDC_EDIT_SETCURSEL              1047
#define IDC_STATIC_GETCURSEL            1048
#define IDC_RADIO_ICON1                 1052
#define IDC_RADIO_ICON2                 1053
#define IDC_EDIT_SETTEXT                1054
#define IDC_RADIO_ICON3                 1055
#define IDC_RADIO_ICON4                 1056
#define IDC_SETCHECK_FALSE              1057
#define IDC_SETCHECK_TRUE               1058
#define IDC_ENABLE_TRUE                 1059
#define IDC_ENABLE_FALSE                1060
#define IDC_BUTTON3                     1061
#define IDB_KEYLIST                     3000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1062
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\dbg.h ===
//////////////////////////////////////////////////////////////////
// File     : dbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef _DBG_H_
#define _DBG_H_
//-------------------------------------------------------
//dbgmgr.h is ../common/dbgmgr.h IME98's common debuging api header.
//In IMEPAD,  only for MemAlloc(), MemFree() function.
//because, we had to send allocate data to ImeIPoint and Freed in 
//it. 
//-------------------------------------------------------

//-------------------------------------------------------
//MACRO function(?) prototype declare
//-------------------------------------------------------
////////////////////////////////////////////////////////
// Function	: DBG
// Type		: VOID
// Purpose	: Printing ANSI debug message with same usage as printf()
//			: 
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//		   : ...	
// CAUTION: Please use DOUBLE Blaket!!!
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

////////////////////////////////////////////////////////
// Function	: DBGMB
// Type		: VOID
// Purpose	: Show Messagebox for ANSI debug message 
//			: Same usage as printf()
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBGMB((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function	: DBGShowWindow
// Type		: VOID
// Purpose	: Invoke debug message window.
//			: DBG(), DBGW()'s message is shown here.
// Args		: HINSTANCE	hInst
//		    : HWND		hwndOwner
/////////////////////////////////////////////////////////
//VOID DBGShowWindow(HINSTANCE hInst, HWND hwndOwner);



#ifdef _DEBUG
extern VOID		_exbtnInit(VOID);
#ifndef UNICODE_ONLY
extern VOID  _exbtnA		 (LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
extern VOID  _exbtnPrintA (LPSTR lpstrMsg, ...);
extern LPSTR _exbtnVaStrA (LPSTR lpstrFmt, ...);
extern LPWSTR _exbtnMulti2Wide(LPSTR lpstr);
extern VOID _exbtnMBA(LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
extern VOID _exbtnMBW(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
#endif

#ifndef ANSI_ONLY
extern VOID   _exbtnW(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _exbtnPrintW(LPWSTR lpstrMsg, ...);
extern LPWSTR _exbtnVaStrW(LPWSTR lpstrFmt, ...);
#endif
#endif


#if defined(_DEBUG) || (defined(_NDEBUG) && defined(_RELDEBUG))
#	define DBG_INIT()			_exbtnInit()
#	define DBGW(a)				_exbtnW( _exbtnMulti2Wide(__FILE__), __LINE__, _exbtnVaStrW a)
#	define DBGA(a)				_exbtnA(__FILE__, __LINE__, _exbtnVaStrA a)
#	define Dbg(a)				_exbtnA(__FILE__, __LINE__, _exbtnVaStrA a)
#	define DBGMB(a)				_exbtnMBA(__FILE__, __LINE__, _exbtnVaStrA a)
#	define DBGMBA(a)			_exbtnMBA(__FILE__, __LINE__, _exbtnVaStrA a)
#	define DBGMBW(a)			_exbtnMBW(_exbtnMulti2Wide(__FILE__), __LINE__, _exbtnVaStrW a)
#else //!_DEBUG	//in Release version, these are disapear...
#	define DBG_INIT()
#	define DBGW(a)	
#	define DBGA(a)		
#	define Dbg(a)
#	define DBGMB(a)
#	define DBGMBA(a)
#	define DBGMBW(a)
#endif //_DEBUG


#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\dbg.cpp ===
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include <stdio.h>
#include <commdlg.h>
#include "dbg.h"

#define PRINT_STRW	//OutputDebugStringW
#define PRINT_STRA	//OutputDebugStringA
static FILE *g_fp;
//-------------------------------------------------------
//Global String buffer
//-------------------------------------------------------
static WCHAR g_wchBuf[1024];
static CHAR  g_chBuf[1024];

static LPSTR GetFileTitleStrA(LPSTR lpstrFile)
{
	static CHAR tchJunk64[64];
	GetFileTitleA(lpstrFile, tchJunk64, sizeof(tchJunk64));	
	return tchJunk64;
}

static LPWSTR GetFileTitleStrW(LPWSTR lpstrFile)
{
	static WCHAR tchJunk64[64];
	GetFileTitleW(lpstrFile, tchJunk64, sizeof(tchJunk64));	
	return tchJunk64;
}


////////////////////////////////////////////////////////
// Function : _exbtnMBA
// Type     : VOID
// Purpose  : Popup Debug MessageBox
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstrMsg 
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
VOID _exbtnMBA(LPSTR	lpstrFile, 
			   INT		lineNo, 
			   LPSTR	lpstrMsg)
{
	wsprintfA(g_chBuf, 
			  "%s(%d)%s", 
			  GetFileTitleStrA(lpstrFile),
			  lineNo,
			  lpstrMsg);
	MessageBoxA(NULL, 
				g_chBuf, 
				"#### IMEPAD ERROR MESSAGE #####",
				MB_ICONERROR | MB_OK | MB_APPLMODAL);
	return;
}

VOID _exbtnMBW(LPWSTR	lpstrFile, 
			   INT		lineNo, 
			   LPWSTR	lpstrMsg)
{
	wsprintfW(g_wchBuf, 
			 L"%s(%d)%s", 
			 GetFileTitleStrW(lpstrFile),			 
			 lineNo,
			 lpstrMsg);
	MessageBoxW(NULL, 
				lpstrFile, 
				L"#### ERROR #####",
				MB_OK | MB_APPLMODAL);
	return;
}


////////////////////////////////////////////////////////
// Function : _exbtnVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _exbtnVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfW(wchBuf, lpstrFmt, ap);
	va_end(ap);
	return wchBuf;
}

LPSTR _exbtnVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(chBuf, lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function: _exbtnPrint
// Type    : VOID
// Purpose : variable args version of OutputDebugString
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _exbtnPrintA(LPSTR lpstrFmt, ...)
{
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(g_chBuf, lpstrFmt, ap);
	va_end(ap);
	if(g_fp) {
		fprintf(g_fp, "%s", g_chBuf);
	}
	PRINT_STRA(g_chBuf);
	return;
}

VOID _exbtnPrintW(LPWSTR lpstrFmt, ...)
{
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfW(g_wchBuf, lpstrFmt, ap);
	va_end(ap);
	if(g_fp) {
		fwprintf(g_fp, L"%s", g_wchBuf);
	}
	PRINT_STRW(g_wchBuf);
	return;
}

////////////////////////////////////////////////////////
// Function: _exbtn
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _exbtnA(LPSTR		lpstrFile, 
		   INT		lineNo, 
		   LPSTR		lpstrMsg
)
{
	_exbtnPrintA("(%s:%d) %s", 
			   GetFileTitleStrA(lpstrFile),
			   lineNo,
			   lpstrMsg);
	return;
}

VOID _exbtnW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg
)
{
	_exbtnPrintW(L"(%s:%d) %s", 
			   GetFileTitleStrW(lpstrFile),
			   lineNo,
			   lpstrMsg);

	return;
}

LPWSTR _exbtnMulti2Wide(LPSTR lpstr)
{
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)g_wchBuf, sizeof(g_wchBuf)/sizeof(WCHAR) );
	return g_wchBuf;
}

VOID _exbtnInit(VOID)
{
#if 0
	if(!g_fp) {
		g_fp = fopen("c:\\temp\\exbtn.log", "w+");
		if(!g_fp) {
			return;
		}
	}
#endif
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\exbtn.h ===
//////////////////////////////////////////////////////////////////
// File     :	exbtn.h ( Extended Button)
// Purpose  :	new control for button
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//	
// History	:970905 Started
//////////////////////////////////////////////////////////////////
#ifndef _EXTENDED_BUTTON_
#define _EXTENDED_BUTTON_

//----------------------------------------------------------------
//Extended Button Style
//----------------------------------------------------------------
#define EXBS_TEXT			0x0000		// Show Text as Button Face.(Default value)
#define EXBS_ICON			0x0001		// Show Icon as Button Face.
#define EXBS_THINEDGE		0x0002		// Draw Thin Edge.
#define EXBS_FLAT			0x0004		// Flat style drop down button.
#define EXBS_TOGGLE			0x0010		// Keep push state.
#define EXBS_DBLCLKS		0x0020		// Send double clicks. kwada 980402

#define EXBM_GETCHECK			(WM_USER + 100)
#define EXBM_SETCHECK			(WM_USER + 101)
#define EXBM_SETICON			(WM_USER + 102)
#define EXBM_SETTEXT			(WM_USER + 103)
#define EXBM_SETSTYLE			(WM_USER + 104)

//----------------------------------------------------------------
//Drop Down Button Notify code.
//It is set to Parent window of Drop Down button as
//WM_COMMAND.
//----------------------------------------------------------------
#define EXBN_CLICKED		0
#define EXBN_ARMED			1		//Button
#define EXBN_DISARMED		2
#define EXBN_DOUBLECLICKED	3

//////////////////////////////////////////////////////////////////
// Function : EXButton_GetCheck
// Type     : INT
// Purpose  : Set button image as icon.
// Args     : HWND		hwndCtrl:		EXButton window handle.
// Remarks	: EXBS_ICON style must be set.
// Return   : 
//////////////////////////////////////////////////////////////////
#define EXButton_GetCheck(hwndCtrl) \
		((int)(DWORD)SendMessage((hwndCtrl), EXBM_GETCHECK, (WPARAM)0, (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : EXButton_SetCheck
// Type     : INT
// Purpose  : Set button image as icon.
// Args     : HWND		hwndCtrl:		EXButton window handle.
//			: BOOL		fCheck:			Check state or Uncheck state.
// Remarks	: EXBS_TOGGLE style must be set.
// Return   : 
//////////////////////////////////////////////////////////////////
#define EXButton_SetCheck(hwndCtrl, fCheck) \
		((int)(DWORD)SendMessage((hwndCtrl), EXBM_SETCHECK, (WPARAM)(BOOL)fCheck, (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : EXButton_SetIcon
// Type     : INT
// Purpose  : Set button image as icon.
// Args     : HWND		hwndCtrl:		EXButton window handle.
//			: HICON		hIcon:			Icon handle.
// Remarks	: EXBS_ICON style must be set.
// Return   : 
//////////////////////////////////////////////////////////////////
#define EXButton_SetIcon(hwndCtrl, hIcon) \
		((int)(DWORD)SendMessage((hwndCtrl), EXBM_SETICON, (WPARAM)hIcon, (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : EXButton_SetText
// Type     : INT
// Purpose  : Set button image as icon.
// Args     : HWND		hwndCtrl:		EXButton window handle.
//			: LPWSTR	lpsz:			Unicode String pointer.
// Remarks	: 
// Return   : 
//////////////////////////////////////////////////////////////////
#define EXButton_SetText(hwndCtrl, lpsz) \
		((int)(DWORD)SendMessage((hwndCtrl), EXBM_SETTEXT, (WPARAM)lpsz, (LPARAM)0))

//////////////////////////////////////////////////////////////////
// Function : EXButton_SetStyle
// Type     : INT
// Purpose  : Set Drop down button's style.
// Args     : HWND		hwndCtrl:		EXButton window handle.
//			: DWORD		dwStyle:		EXBS_XXXXX combination.
// Remarks	: 
// Return   : 
//////////////////////////////////////////////////////////////////
#define EXButton_SetStyle(hwndCtrl, dwStyle) \
		((int)(DWORD)SendMessage((hwndCtrl), EXBM_SETSTYLE, (WPARAM)dwStyle, (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : EXButton_CreateWindow
// Type     : HWND
// Purpose  : Opened API.
//			: Create Drop Down Button.
// Args     : 
//          : HINSTANCE		hInst 
//          : HWND			hwndParent 
//          : DWORD			dwStyle		EXBS_XXXXX combination.
//          : INT			wID			Window ID
//          : INT			xPos 
//          : INT			yPos 
//          : INT			width 
//          : INT			height 
// Return   : 
// DATE     : 970905
//////////////////////////////////////////////////////////////////
extern HWND EXButton_CreateWindow(HINSTANCE	hInst, 
								  HWND		hwndParent, 
								  DWORD		dwStyle,
								  INT		wID, 
								  INT		xPos,
								  INT		yPos,
								  INT		width,
								  INT		height);

#ifdef UNDER_CE // In Windows CE, all window classes are process global.
extern BOOL EXButton_UnregisterClass(HINSTANCE hInst);
#endif // UNDER_CE

#endif //_EXTENED_BUTTON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\testmain.cpp ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include "resource.h"

#include "dbg.h"
#include "exbtn.h"

char g_szClass[]="TestMain";
HINSTANCE g_hInst;
BOOL InitApplication(HINSTANCE hInst, LPSTR lpstrClass, WNDPROC lpfnWndProc)
{
	return 0;
}

LPWSTR GetWText(HWND hwnd, INT wID)
{
	CHAR   szBuf[256];
	static WCHAR wchBuf[512];
	Edit_GetText(GetDlgItem(hwnd, wID), szBuf, sizeof(szBuf));
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						szBuf, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}

typedef struct tagVALLIST {
	INT wID;
	INT lParam;
}VALLIST;

VALLIST slist[] = {
	{ IDC_EXBS_TEXT,		EXBS_TEXT		},
	{ IDC_EXBS_ICON,		EXBS_ICON		},
	{ IDC_EXBS_THINEDGE,	EXBS_THINEDGE	},
	{ IDC_EXBS_FLAT,		EXBS_FLAT		},
	{ IDC_EXBS_TOGGLE,		EXBS_TOGGLE		},
};

typedef struct tagICONLIST {
	INT wID;
	INT lParam;
	INT width;
	INT height;
}ICONLIST;

ICONLIST iconList[]={
	{ IDC_RADIO_ICON1,	IDI_ICON1, 16, 16, },
	{ IDC_RADIO_ICON2,  IDI_ICON1, 32, 32, },
	{ IDC_RADIO_ICON3,	IDI_ICON2, 16, 16, },
	{ IDC_RADIO_ICON4,  IDI_ICON2, 32, 32, },
};
HWND MainCreateWindow(HINSTANCE hInst, HWND hwndOwner, LPSTR lpstrClass, LPVOID lpVoid)
{
	HWND hwnd;
	hwnd = CreateDialogParam(hInst, 
							 g_szClass, 
							 hwndOwner, 
							 NULL, 
							 (LPARAM)lpVoid);
	if(!hwnd) {
		return (HWND)NULL;
	}
	UpdateWindow(hwnd);
	return hwnd;
}

#define ArrayCount(a)	(sizeof(a)/sizeof(a[0]))
#define MAX(a, b)		( a > b ? a : b)
#define IDC_EXBID	4096
LRESULT CALLBACK MainWndProc(HWND	hwnd,
							 UINT	uMsg,
							 WPARAM	wParam,
							 LPARAM	lParam)
{
	PAINTSTRUCT ps;
	HDC hDC;
	RECT rc;
	static INT iIndex;
	switch(uMsg) {
	case WM_CREATE:
		{
			HWND hwndEXB = EXButton_CreateWindow(g_hInst, hwnd, EXBS_TEXT,
												 IDC_EXBID,
												 20,
												 30, 
												 35,
												 18);
			EXButton_SetText(hwndEXB, L"J^");
		}
		SetTimer(hwnd, 0x9999, 50, NULL);
		return 1;
	case WM_TIMER:
		{
			KillTimer(hwnd, wParam);
			INT i;
			for(i = 0; i < sizeof(iconList)/sizeof(iconList[0]); i++) {
				HICON hIcon = LoadImage(g_hInst,
										MAKEINTRESOURCE(iconList[i].lParam),
										IMAGE_ICON, 
										iconList[i].width,
										iconList[i].height,
										LR_DEFAULTCOLOR);
				SendMessage(GetDlgItem(hwnd, iconList[i].wID),
							BM_SETIMAGE,
							(WPARAM)IMAGE_ICON,
							(LPARAM)hIcon);
			}
		}
		break;
	case WM_SYSCOMMAND:
		if(wParam == SC_CLOSE) {
			PostQuitMessage(0);
		}
		break;
	case WM_COMMAND:
		{
			WORD wNotifyCode = HIWORD(wParam); // notification code 
			WORD wID		 = LOWORD(wParam);         // item, control, or accelerator identifier 
			HWND hwndCtl	 = (HWND) lParam;      // handle of control 
			HWND hwndEXB	 = (HWND) GetDlgItem(hwnd, IDC_EXBID);
			switch(wID) {
			case IDC_EXBID:
				{
					switch(wNotifyCode) {
					case EXBN_CLICKED:
						DBG(("EXBN_CLICKED come\n"));
						break;
					case EXBN_DOUBLECLICKED:
						DBG(("EXBN_DOUBLECLICKED come\n"));
						break;
					case EXBN_ARMED:
						DBG(("EXBN_ARMED come\n"));
						EXButton_SetText(hwndEXB, L"");
						break;
					case EXBN_DISARMED: 
						DBG(("EXBN_DISARMED come\n"));
						EXButton_SetText(hwndEXB, L"J^");
						break;
					default:
						DBG(("ERROR Unknown Notify\n"));
						break;
					}
				}
				break;
				break;
			case IDC_SETTEXT:
				{
					EXButton_SetText(hwndEXB, GetWText(hwnd, IDC_EDIT_SETTEXT));
				}
				break;
			case IDC_SETICON:
				{
					INT i;
					for(i = 0; i < sizeof(iconList)/sizeof(iconList[0]); i++) {
						if(Button_GetCheck(GetDlgItem(hwnd, iconList[i].wID))) {
							HICON hIcon = LoadImage(g_hInst,
													MAKEINTRESOURCE(iconList[i].lParam),
													IMAGE_ICON, 
													iconList[i].width,
													iconList[i].height,
													LR_DEFAULTCOLOR);
							EXButton_SetIcon(hwndEXB, hIcon);
						}
					}
				}
				break;
			case IDC_SETCHECK_TRUE:
				EXButton_SetCheck(hwndEXB, TRUE);
				break;
			case IDC_SETCHECK_FALSE:
				EXButton_SetCheck(hwndEXB, FALSE);
				break;
			case IDC_SETSTYLE:
				{
					INT i;
					DWORD dwStyle = 0;
					for(i = 0; i < sizeof(slist)/sizeof(slist[0]); i++) {
						INT ret = Button_GetCheck(GetDlgItem(hwnd, slist[i].wID));
						if(ret) {
							dwStyle |= slist[i].lParam;
						}
					}
					EXButton_SetStyle(hwndEXB, dwStyle);
				}
				break;
			case IDC_ENABLE_TRUE:
				EnableWindow(hwndEXB, TRUE);
				break;
			case IDC_ENABLE_FALSE:
				EnableWindow(hwndEXB, FALSE);
				break;
			}

		}
		break;
	case WM_PAINT:
		hDC = BeginPaint(hwnd, &ps);
		GetClientRect(hwnd, &rc);
		FillRect(hDC, &rc, (HBRUSH)(COLOR_3DFACE + 1));
		EndPaint(hwnd, &ps);
		break;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int WINAPI WinMain(HINSTANCE hInstance,
				   HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine,
				   int nCmdShow)
{

	MSG msg;
	HWND hwnd;
//	INT ret;
	
	g_hInst = hInstance;
	WNDCLASSEX  wc;
	ZeroMemory(&wc, sizeof(wc));

	wc.cbSize			= sizeof(wc);
	wc.style			= CS_HREDRAW | CS_VREDRAW;	 /* Class style(s). */
	wc.lpfnWndProc		= (WNDPROC)MainWndProc;
	wc.cbClsExtra		= 0;					/* No per-class extra data.*/
	wc.cbWndExtra		= DLGWINDOWEXTRA;		/* No per-window extra data.		  */
	wc.hInstance		= hInstance;			/* Application that owns the class.	  */
	wc.hIcon			= NULL; //LoadIcon(hInstance, MAKEINTRESOURCE(SCROLL32_ICON));
	wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1); //UGetStockObject(LTGRAY_BRUSH); //WHITE_BRUSH); 
	wc.lpszMenuName		= NULL; //g_szClass;    /* Name of menu resource in .RC file. */
	wc.lpszClassName	= g_szClass;	  /* Name used in call to CreateWindow. */
	wc.hIconSm = NULL;
	RegisterClassEx(&wc);

	hwnd = CreateDialog(hInstance, 
						g_szClass, 
						0, 
						NULL);

	UpdateWindow(hwnd); 
	ShowWindow(hwnd, SW_SHOW);
	while (GetMessage(&msg, NULL, 0, 0)){
		TranslateMessage(&msg);
		DispatchMessage(&msg); 
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\accplv.h ===
#ifndef __ACCPLV_H
#define __ACCPLV_H

#include <windows.h>

#include <ole2.h>
//980112 ToshiaK: VC6 has these include files.
//#include "../msaa/inc32/oleacc.h"
//#include "../msaa/inc32/winable.h"
#include <oleacc.h>
#include <winable.h>
//#include "enumvar.h"

#include "plv_.h"

class CAccPLV : public IAccessible
{
public:
	//--------------------------------
	//	IUnknown interface methods
	//--------------------------------

	STDMETHODIMP			QueryInterface( REFIID riid, void** ppv );
	STDMETHODIMP_(ULONG)	AddRef( void );
	STDMETHODIMP_(ULONG)	Release( void );


	//--------------------------------
	//	IDispatch interface methods
	//--------------------------------

	STDMETHODIMP		GetTypeInfoCount( UINT* pctinfo );
	STDMETHODIMP		GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo** pptinfo );
	STDMETHODIMP		GetIDsOfNames( REFIID riid,
						               OLECHAR** rgszNames,
						               UINT cNames,
						               LCID lcid,
						               DISPID* rgdispid );
	STDMETHODIMP		Invoke( DISPID dispidMember,
						        REFIID riid,
						        LCID lcid,
						        WORD wFlags,
						        DISPPARAMS* pdispparams,
						        VARIANT* pvarResult,
						        EXCEPINFO* pexcepinfo,
						        UINT* puArgErr );


	//--------------------------------
	//	IAccessible interface methods
	//--------------------------------

	STDMETHODIMP		get_accParent( IDispatch ** ppdispParent );
	STDMETHODIMP		get_accChildCount( long* pChildCount );
	STDMETHODIMP		get_accChild( VARIANT varChild,
						              IDispatch ** ppdispChild );
	STDMETHODIMP		get_accName( VARIANT varChild, BSTR* pszName );
	STDMETHODIMP		get_accValue( VARIANT varChild, BSTR* pszValue );
	STDMETHODIMP		get_accDescription( VARIANT varChild,
						                    BSTR* pszDescription );
	STDMETHODIMP		get_accRole( VARIANT varChild, VARIANT *pvarRole );
	STDMETHODIMP		get_accState( VARIANT varChild, VARIANT *pvarState );
	STDMETHODIMP		get_accHelp( VARIANT varChild, BSTR* pszHelp );
	STDMETHODIMP		get_accHelpTopic( BSTR* pszHelpFile,
						                  VARIANT varChild,
						                  long* pidTopic );
	STDMETHODIMP		get_accKeyboardShortcut( VARIANT varChild,
						                         BSTR* pszKeyboardShortcut );
	STDMETHODIMP		get_accFocus( VARIANT * pvarFocusChild );
	STDMETHODIMP		get_accSelection( VARIANT * pvarSelectedChildren );
	STDMETHODIMP		get_accDefaultAction( VARIANT varChild,
						                      BSTR* pszDefaultAction );
	STDMETHODIMP		accSelect( long flagsSel, VARIANT varChild );
	STDMETHODIMP		accLocation( long* pxLt,
						             long* pyTp,
									 long* pcxWd,
									 long* pcyHt,
									 VARIANT varChild );
	STDMETHODIMP		accNavigate( long navDir,
						             VARIANT varStart,
									 VARIANT * pVarEndUpAt );
	STDMETHODIMP		accHitTest( long xLeft,
						            long yTop,
									VARIANT * pvarChildAtPoint );
	STDMETHODIMP		accDoDefaultAction( VARIANT varChild );
	STDMETHODIMP		put_accName( VARIANT varChild, BSTR szName );
	STDMETHODIMP		put_accValue( VARIANT varChild, BSTR pszValue );


	//--------------------------------
	//	Constructors and Destructors
	//--------------------------------

	CAccPLV( void );
	~CAccPLV( void );
	
	void *operator new(size_t);
	void operator delete(void*);

	HRESULT				Initialize(HWND hwnd);
	LRESULT				LresultFromObject(WPARAM wParam);
protected:
	IAccessible *	m_pDefAccessible;
	ITypeInfo *		m_pTypeInfo;
	HWND			m_hWnd;
	LPPLVDATA		m_lpPlv;
};

#endif  /* __ACCKYLV_H */



//----  End of ACCKYLV.H  ----
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\accplv.cpp ===
//=======================================================================
//		File:	ACCPLV.CPP
//=======================================================================
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "winapi.h"

#include <ole2.h>
//#include <initguid.h>
// 98/07/28 kwada
// Some ids are defined in oleacc.h
// Instances of them are in oleacc.dll. 
// Initguid is needed because oleacc.lib is not linked.
// To avoid conflict of instanciation of those guid,
// initguid appears only once in the application.
//#include "../msaa/inc32/oleacc.h"
//#include "../msaa/inc32/winable.h"
//980112 ToshiaK: VC6 has these include files.
#include <oleacc.h>
#include <winable.h>

#include "accplv.h"
#include "plv.h"
#include "plv_.h"
#include "plvproc.h"
#include "dbg.h"
#include "strutil.h"
//#include "repview.h"
//#include "iconview.h"
#include "rvmisc.h"
#include "ivmisc.h"

CAccPLV::CAccPLV()
{
    m_hWnd = NULL;
    m_pTypeInfo = NULL;
    m_pDefAccessible = NULL;
}

CAccPLV::~CAccPLV( void )
{
    if ( m_pTypeInfo )
    {
        m_pTypeInfo->Release();
        m_pTypeInfo = NULL;
    }

    if ( m_pDefAccessible )
    {
        m_pDefAccessible->Release();
        m_pDefAccessible = NULL;
    }
	
}

void *
CAccPLV::operator new(size_t size){
	return MemAlloc(size);
}

void
CAccPLV::operator delete(void *ptr){
	if(ptr)
		MemFree(ptr);
}

HRESULT CAccPLV::Initialize(HWND hWnd)
{
	HRESULT		hr;
	ITypeLib *	piTypeLib;

	m_hWnd = hWnd;
	m_lpPlv = GetPlvDataFromHWND(hWnd);

	if(!PLV_IsMSAAAvailable(m_lpPlv))
		return E_FAIL;

	hr = PLV_CreateStdAccessibleObject(m_lpPlv,
									   hWnd,
									   OBJID_CLIENT,
									   IID_IAccessible,
									   (void **) &m_pDefAccessible);

	if (FAILED( hr ))
		return hr;

	//-----------------------------------------------------
    //	Obtain an ITypeInfo pointer to our type library.
	//	  The ITypeInfo pointer is used to implement the
	//	  IDispatch interface.
	//-----------------------------------------------------

	//-----------------------------------------------------
	//	First, attempt to load the Accessibility type
	//	  library version 1.0 using the registry.
	//-----------------------------------------------------

    hr = LoadRegTypeLib( LIBID_Accessibility, 1, 0, 0, &piTypeLib );

	//-----------------------------------------------------
	//	If we fail to load the type library from the
	//	  registry information, explicitly try to load
	//	  it from the MSAA system DLL.
	//-----------------------------------------------------

    if ( FAILED( hr ) )
    {
        static OLECHAR szOleAcc[] = L"OLEACC.DLL";
        hr = LoadTypeLib( szOleAcc, &piTypeLib );
    }

	//-----------------------------------------------------
	//	If we successfully load the type library, attempt
	//	  to get the IAccessible type description
	//	  (ITypeInfo pointer) from the type library.
	//-----------------------------------------------------

    if ( SUCCEEDED( hr ) )
    {
        hr = piTypeLib->GetTypeInfoOfGuid( IID_IAccessible, &m_pTypeInfo );
        piTypeLib->Release();
    }

	return hr;
}

//-----------------------------------------------------------------------
//	CAccPLV::QueryInterface()
// ----------------------------------------------------------------------

STDMETHODIMP CAccPLV::QueryInterface( REFIID riid, void** ppv )
{
    *ppv = NULL;
	
	//-----------------------------------------------------
	//	If the IUnknown, IDispatch, or IAccessible
	//	  interface is desired, simply cast the this
	//	  pointer appropriately.
	//-----------------------------------------------------

	if ( riid == IID_IUnknown )
        *ppv = (LPUNKNOWN) this;

	else if ( riid == IID_IDispatch )
        *ppv = (IDispatch *) this;

	else if ( riid == IID_IAccessible )
        *ppv = (IAccessible *)this;

	//-----------------------------------------------------
	//	If the IEnumVARIANT interface is desired, create
	//	  a new VARIANT enumerator which contains all
	//	  the Accessible object's children.
	//-----------------------------------------------------
#ifdef NOTIMPLEMENTED
	else if (riid == IID_IEnumVARIANT)
	{
		return m_pDefAccessible->QueryInterface(riid, ppv);
		//?? AddRef();
	}
#endif
	//-----------------------------------------------------
	//	If the desired interface isn't one we know about,
	//	  return E_NOINTERFACE.
	//-----------------------------------------------------

    else
        return E_NOINTERFACE;


	//-----------------------------------------------------
	//	Increase the reference count of any interface
	//	  returned.
	//-----------------------------------------------------

    ((LPUNKNOWN) *ppv)->AddRef();


    return S_OK;
}


//-----------------------------------------------------------------------
//	CAccPLV::AddRef()
//  CAccPLV::Release()
//	NOTES:
//
//		The lifetime of the Accessible object is governed by the
//		lifetime of the HWND object for which it provides
//		Accessibility.  The object is created in response to the
//		first WM_GETOBJECT message that the server application
//		is ready to process and is destroyed when the server's
//		main window is destroyed.  Since the object's lifetime
//		is not dependent on a reference count, the object has no
//		internal mechanism for tracking reference counting and
//		AddRef() and Release() always return one.
//
//-----------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAccPLV::AddRef( void )
{
	return 1L;
}

STDMETHODIMP_(ULONG) CAccPLV::Release( void )
{
	return 1L;
}

//-----------------------------------------------------------------------
//	CAccPLV::GetTypeInfoCount()
//
//	DESCRIPTION:
//
//		Implements the IDispatch interface method GetTypeInfoCount().
//
//		Retrieves the number of type information interfaces that an
//		object provides (either 0 or 1).
//
//	PARAMETERS:
//
//		pctInfo		[out] Points to location that receives the
//							number of type information interfaces
//							that the object provides. If the object
//							provides type information, this number
//							is set to 1; otherwise it's set to 0.
//
//	RETURNS:
//
//		HRESULT			  S_OK if the function succeeds or 
//							E_INVALIDARG if pctInfo is invalid.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::GetTypeInfoCount( UINT *pctInfo )
{
    if ( !pctInfo )
        return E_INVALIDARG;

    *pctInfo = ( m_pTypeInfo == NULL ? 1 : 0 );

    return S_OK;
}

//-----------------------------------------------------------------------
//	CAccPLV:GetTypeInfo()
//
//	DESCRIPTION:
//
//		Implements the IDispatch interface method GetTypeInfo().
//
//		Retrieves a type information object, which can be used to
//		get the type information for an interface.
//
//	PARAMETERS:
//
//		itinfo		[in]  The type information to return. If this value
//							is 0, the type information for the IDispatch
//							implementation is to be retrieved.
//
//		lcid		[in]  The locale ID for the type information.
//
//		ppITypeInfo	[out] Receives a pointer to the type information
//							object requested.
//
//	RETURNS:
//
//		HRESULT			  S_OK if the function succeeded (the TypeInfo
//							element exists), TYPE_E_ELEMENTNOTFOUND if
//							itinfo is not equal to zero, or 
//							E_INVALIDARG if ppITypeInfo is invalid.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo )
{
    if ( !ppITypeInfo )
        return E_INVALIDARG;

    *ppITypeInfo = NULL;

    if ( itinfo != 0 )
        return TYPE_E_ELEMENTNOTFOUND;
    else if ( m_pTypeInfo == NULL )
        return E_NOTIMPL;

    *ppITypeInfo = m_pTypeInfo;
    m_pTypeInfo->AddRef();

    return S_OK;
	UNREFERENCED_PARAMETER(lcid);
}

//-----------------------------------------------------------------------
//	CAccPLV::GetIDsOfNames()
//
//	DESCRIPTION:
//
//		Implements the IDispatch interface method GetIDsOfNames().
//
//		Maps a single member and an optional set of argument names
//		to a corresponding set of integer DISPIDs, which may be used
//		on subsequent calls to IDispatch::Invoke.
//
//	NOTES:
//
//		This method simply delegates the call to
//		ITypeInfo::GetIDsOfNames().
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::GetIDsOfNames( REFIID riid, OLECHAR ** rgszNames, UINT cNames,
                                        LCID lcid, DISPID * rgdispid )
{
    if ( m_pTypeInfo == NULL )
        return E_NOTIMPL;

    return( m_pTypeInfo->GetIDsOfNames( rgszNames, cNames, rgdispid ) );
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(lcid);
}

//-----------------------------------------------------------------------
//	CAccPLV::Invoke()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::Invoke( DISPID dispid,
                                 REFIID riid,
                                 LCID lcid,
                                 WORD wFlags,
                                 DISPPARAMS * pdispparams,
                                 VARIANT *pvarResult,
                                 EXCEPINFO *pexcepinfo,
                                 UINT *puArgErr )
{
    if ( m_pTypeInfo == NULL )
        return E_NOTIMPL;

    return m_pTypeInfo->Invoke( (IAccessible *)this,
                                dispid,
                                wFlags,
                                pdispparams,
                                pvarResult,
                                pexcepinfo,
                                puArgErr );
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(lcid);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accParent()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accParent( IDispatch ** ppdispParent )
{
	return m_pDefAccessible->get_accParent( ppdispParent );
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accChildCount()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accChildCount( long* pChildCount )
{
	if(!PLV_IsMSAAAvailable(m_lpPlv))
		return E_FAIL;
    if ( !pChildCount )
        return E_INVALIDARG;

	if(m_lpPlv->dwStyle == PLVSTYLE_ICON) // iconview
		*pChildCount = m_lpPlv->iItemCount;
	else
		*pChildCount = (m_lpPlv->iItemCount + 1) * RV_GetColumn(m_lpPlv); // include header

	return S_OK;
}


//-----------------------------------------------------------------------
//	CAccPLV::get_accChild()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    if ( !ppdispChild )
        return E_INVALIDARG;


	*ppdispChild = NULL;
    return S_FALSE;
	UNREFERENCED_PARAMETER(varChild);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accName()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accName().
//
//		Retrieve the name property for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszName			[out] Pointer to the BSTR that will contain
//								the child's name property string.
//-----------------------------------------------------------------------
#define BUFLEN 128
STDMETHODIMP CAccPLV::get_accName( VARIANT varChild, BSTR* pszName )
{
    if (!pszName)
        return E_INVALIDARG;

	*pszName = NULL;

	if ( varChild.lVal == CHILDID_SELF )
		//return m_pDefAccessible->get_accName(varChild,pszName);
		return S_OK;
	
	
	if(m_lpPlv->dwStyle == PLVSTYLE_ICON) {
		PLVITEM plvItem;
		m_lpPlv->lpfnPlvIconItemCallback(m_lpPlv->iconItemCallbacklParam, 
										 varChild.lVal - 1,
										 &plvItem);
		*pszName = SysAllocString(plvItem.lpwstr);
	}
	else {
		static TCHAR	szString[BUFLEN];
		static OLECHAR	wszString[BUFLEN];
   
		static INT nCol,index,colIndex;
		nCol = RV_GetColumn(m_lpPlv);
		if (nCol < 1)
			return E_FAIL;
		index = (varChild.lVal - 1) / nCol;
		colIndex = (varChild.lVal - 1) % nCol;

		if(!index) { // Header
			if(IsWindowUnicode(m_lpPlv->hwndHeader)){
				static HD_ITEMW hdItem;
				hdItem.mask = HDI_TEXT;
				hdItem.fmt  = HDF_STRING;
				hdItem.pszText = wszString;
				hdItem.cchTextMax = BUFLEN;
				SendMessageW(m_lpPlv->hwndHeader, HDM_GETITEMW, (WPARAM)colIndex, (LPARAM)&hdItem);
				*pszName = SysAllocString(hdItem.pszText);
			}
			else{
				static HD_ITEMA hdItem;
				hdItem.mask = HDI_TEXT;
				hdItem.fmt  = HDF_STRING;
				hdItem.pszText = szString;
				hdItem.cchTextMax = BUFLEN;

				SendMessageA(m_lpPlv->hwndHeader, HDM_GETITEMA, (WPARAM)colIndex, (LPARAM)&hdItem);

				MultiByteToWideChar(m_lpPlv->codePage,MB_PRECOMPOSED,hdItem.pszText,-1,
									wszString,hdItem.cchTextMax);
				*pszName = SysAllocString(wszString);
			}
		}
		else { // item
			LPPLVITEM lpPlvItemList = (LPPLVITEM)MemAlloc(sizeof(PLVITEM)*nCol);
			if(!lpPlvItemList)
				return E_FAIL;

			ZeroMemory(lpPlvItemList, sizeof(PLVITEM)*nCol);
			m_lpPlv->lpfnPlvRepItemCallback(m_lpPlv->repItemCallbacklParam, 
											index-1, // line index
											nCol,  //column Count.
											lpPlvItemList);

			*pszName = SysAllocString(lpPlvItemList[colIndex].lpwstr);
			MemFree(lpPlvItemList);
		}
	}

	return S_OK;
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accValue()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accValue().
//
//		Retrieves the value property for the specified child.
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accValue( VARIANT varChild, BSTR* pszValue )
{
    if (!pszValue)
        return E_INVALIDARG;
	
	return m_pDefAccessible->get_accValue(varChild,pszValue);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accDescription()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accDescription().
//
//		Retrieves the description property for the specified child.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accDescription( VARIANT varChild, BSTR* pszDesc )
{
    if (!pszDesc)
		return E_INVALIDARG;

	return m_pDefAccessible->get_accDescription(varChild,pszDesc);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accRole()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accRole().
//
//		Retrieves the role property for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pVarRole		[out] Pointer to the VARIANT structure that
//								will contain the specified child's
//								role property.  This property may
//								either be in the form of a standard
//								role constant or a custom description
//								string.
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accRole( VARIANT varChild, VARIANT * pVarRole )
{
    if (!pVarRole)
		return E_INVALIDARG;

	if ( varChild.lVal == CHILDID_SELF )
		return m_pDefAccessible->get_accRole( varChild, pVarRole );

	pVarRole->vt = VT_I4;

	pVarRole->lVal = ROLE_SYSTEM_CLIENT;
	return S_OK;

}

//-----------------------------------------------------------------------
//	CAccPLV::get_accState()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accState().
//		Retrieves the current state for the specified object or child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pVarState		[out] Pointer to the VARIANT structure that
//								will contain information describing
//								the specified child's current state.
//								This information may either be in the
//								form of one or more object state
//								constants or a custom description
//								string.
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accState( VARIANT varChild, VARIANT * pVarState )
{
	if(!PLV_IsMSAAAvailable(m_lpPlv))
		return E_FAIL;

	if (!pVarState)
		return E_INVALIDARG;

	if ( varChild.lVal == CHILDID_SELF )
		return m_pDefAccessible->get_accState(varChild,pVarState);

	pVarState->vt = VT_I4;

	if(m_lpPlv->dwStyle == PLVSTYLE_ICON) // iconview
		pVarState->lVal = STATE_SYSTEM_SELECTABLE;
	else { // report view
		static INT nCol,index,colIndex;
		nCol = RV_GetColumn(m_lpPlv);
		if (nCol < 1)
			return E_FAIL;
		
		index = (varChild.lVal - 1) / nCol;
		colIndex = (varChild.lVal - 1) % nCol;
		if(index){
			if(colIndex)
				pVarState->lVal = STATE_SYSTEM_READONLY;
			else // item
				pVarState->lVal = STATE_SYSTEM_SELECTABLE;
		}
		else{ // header
			pVarState->lVal = STATE_SYSTEM_READONLY;
		}
	}
		
	return S_OK;
	UNREFERENCED_PARAMETER(varChild);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accHelp()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accHelp().
//
//		Retrieves the help property string for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszHelp			[out] Pointer to the BSTR that will contain
//								the child's help property string.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accHelp( VARIANT varChild, BSTR* pszHelp )
{
    if (!pszHelp)
		return E_INVALIDARG;
	return m_pDefAccessible->get_accHelp( varChild, pszHelp );
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accHelpTopic()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accHelpTopic().
//
//		Retrieves the fully qualified path name of the help file
//		associated with the specified object, as well as a pointer
//		to the appropriate topic with in that file.
//
//	PARAMETERS:
//
//		pszHelpFile		[out] Pointer to the BSTR that will contain
//								the fully qualified path name of the
//								help file associated with the child.
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pidTopic		[out] Pointer to the value identifying the
//								help file topic associated with the
//								object.
//
//	RETURNS:
//
//		HRESULT			DISP_E_MEMBERNOTFOUND because the help topic
//						  property is not supported for the Accessible
//						  object or any of its children.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accHelpTopic( BSTR* pszHelpFile, VARIANT varChild, long* pidTopic )
{
	//-----------------------------------------------------
	//	The help topic property is not supported for
	//	  either the Accessible object or any of its
	//	  children.
	//-----------------------------------------------------
	//return m_pDefAccessible->get_accHelpTopic(pszHelpFile,varChild,pidTopic);
	return DISP_E_MEMBERNOTFOUND;
	UNREFERENCED_PARAMETER(pszHelpFile);
	UNREFERENCED_PARAMETER(varChild);
	UNREFERENCED_PARAMETER(pidTopic);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accKeyboardShortcut()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method
//		get_accKeyboardShortcut().
//
//		Retrieves the specified object's keyboard shortcut property.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszShortcut		[out] Pointer to the BSTR that will contain
//								the keyboard shortcut string, or NULL
//								if no keyboard shortcut is associated
//								with this item.
//
//
//	RETURNS:
//
//		HRESULT			DISP_E_MEMBERNOTFOUND because the keyboard
//						  shortcut property is not supported for the
//						  Accessible object or any of its children.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accKeyboardShortcut( VARIANT varChild, BSTR* pszShortcut )
{
	//-----------------------------------------------------
	//	The keyboard shortcut property is not supported
	//	  for either the Accessible object or any of its
	//	  children.  So, set pszShortcut to NULL and
	//	  return DISP_E_MEMBERNOTFOUND.
	//-----------------------------------------------------
	if(!pszShortcut)
		return E_INVALIDARG;
	return m_pDefAccessible->get_accKeyboardShortcut(varChild,pszShortcut);
#ifdef REF				
	pszShortcut = NULL;
    return DISP_E_MEMBERNOTFOUND;
#endif
}




//-----------------------------------------------------------------------
//	CAccPLV::get_accFocus()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accFocus().
//
//		Retrieves the child object that currently has the input focus.
//		Only one object or item within a container can have the current
//		focus at any one time.
//
//	PARAMETERS:
//
//		pVarFocus		[out] Pointer to the VARIANT structure that
//								will contain information describing
//								the specified child's current state.
//								This information may either be in the
//								form of one or more object state
//								constants or a custom description
//								string.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the pVarFocus parameter is
//						  invalid or S_OK.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accFocus( VARIANT * pVarFocus )
{
    if ( !pVarFocus )
        return E_INVALIDARG;

	return m_pDefAccessible->get_accFocus(pVarFocus);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accSelection()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accSelection().
//
//		Retrieves the selected children of this object.
//
//	PARAMETERS:
//
//		pVarSel  		[out] Pointer to the VARIANT structure that
//								will be filled with information about
//								the selected child object or objects.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the pVarSel parameter is
//						  invalid or S_OK.
//
//	NOTES:
//
//		Refer to the MSAA SDK documentation for a full description
//		of this method and the possible settings of pVarSel.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accSelection( VARIANT * pVarSel )
{
    if ( !pVarSel )
        return E_INVALIDARG;
	return m_pDefAccessible->get_accSelection(pVarSel);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accDefaultAction()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accDefaultAction().
//
//		Retrieves a string containing a localized, human-readable sentence
//		that describes the object's default action.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose default action string is
//								to be retrieved.  Since CAccPLV
//								only supports child IDs, the vt member
//								of this structure must equal VT_I4.
//
//		pszDefAct		[out] Pointer to the BSTR that will contain
//								the child's default action string,
//								or NULL if there is no default action
//								for this object.
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accDefaultAction( VARIANT varChild, BSTR* pszDefAct )
{
	if (!pszDefAct)
        return E_INVALIDARG;
	return m_pDefAccessible->get_accDefaultAction(varChild, pszDefAct);
}

//-----------------------------------------------------------------------
//	CAccPLV::accDoDefaultAction()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accDoDefaultAction().
//
//		Performs the object's default action.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose default action will be
//								invoked.  Since CAccPLV only
//								supports child IDs, the vt member of
//								this structure must equal VT_I4.
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::accDoDefaultAction( VARIANT varChild )
{
	//if ( varChild.lVal == CHILDID_SELF )
	return m_pDefAccessible->accDoDefaultAction( varChild );
}

//-----------------------------------------------------------------------
//	CAccPLV::accSelect()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::accSelect( long flagsSel, VARIANT varChild )
{
	return m_pDefAccessible->accSelect(flagsSel, varChild);
}

//-----------------------------------------------------------------------
//	CAccPLV::accLocation()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accLocation().
//
//		Retrieves the specified child's current screen location in
//		screen coordinates.
//
//	PARAMETERS:
//
//		pxLeft			[out] Address of the child's left most
//								boundary.
//
//		pyTop			[out] Address of the child's upper most
//								boundary.
//
//		pcxWid			[out] Address of the child's width.
//
//		pcyHt			[out] Address of the child's height.
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose screen location is to be
//								retrieved.  Since CAccPLV only
//								supports child IDs, the vt member
//								of this structure must equal VT_I4.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if any of the parameters
//						  are invalid, E_UNEXPECTED if we are for
//						  some reason unable to determine the
//						  window rect of the button or status bar,
//						  S_OK if the screen coordinates of the
//						  child are successfully determined, or
//						  the return value from the standard client
//						  window implementation of accLocation().
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::accLocation( long* pxLeft,
                                      long* pyTop,
                                      long* pcxWid,
                                      long* pcyHt,
                                      VARIANT varChild )
{
    if (!pxLeft || !pyTop || !pcxWid || !pcyHt)
        return E_INVALIDARG;

	if ( varChild.lVal == CHILDID_SELF )
		return m_pDefAccessible->accLocation( pxLeft, pyTop, pcxWid, pcyHt, varChild );
	
	*pxLeft = *pyTop = *pcxWid = *pcyHt = 0;

	static INT index,colIndex,nCol;
	static POINT pt;

	if(m_lpPlv->dwStyle == PLVSTYLE_ICON) {
		*pcxWid  = IV_GetItemWidth(m_hWnd);
		*pcyHt = IV_GetItemHeight(m_hWnd);

		index = varChild.lVal - 1;
		nCol = IV_GetCol(m_hWnd);
		pt.x = IV_GetXMargin(m_hWnd) + *pcxWid  * (index % nCol);
		pt.y = IV_GetYMargin(m_hWnd) + *pcyHt * (index / nCol);
		ClientToScreen(m_hWnd,&pt);
		*pxLeft = pt.x;
		*pyTop = pt.y;
		return S_OK;
	}
	else {
		nCol = RV_GetColumn(m_lpPlv);
		if (nCol < 1)
			return E_FAIL;
			
		index = (varChild.lVal - 1) / nCol;
		colIndex = (varChild.lVal - 1) % nCol;

		if(!index){ //header
			*pcyHt = RV_GetHeaderHeight(m_lpPlv);
			pt.y = RV_GetYMargin(m_hWnd);
		}
		else{
			*pcyHt = RV_GetItemHeight(m_hWnd);
			pt.y = RV_GetYMargin(m_hWnd) + RV_GetHeaderHeight(m_lpPlv)
				   + ((index - 1) - m_lpPlv->iCurTopIndex) * (*pcyHt);
		}
		
		static HD_ITEM hdItem;
		hdItem.mask = HDI_WIDTH;
		hdItem.fmt = 0;
		Header_GetItem(m_lpPlv->hwndHeader,colIndex,&hdItem);
		*pcxWid = hdItem.cxy;

		pt.x = 0;
		for(int i = 0;i<colIndex;i++){
			Header_GetItem(m_lpPlv->hwndHeader,i,&hdItem);
			pt.x += hdItem.cxy;
		}

		ClientToScreen(m_hWnd,&pt);
		*pxLeft = pt.x;
		*pyTop = pt.y;
		return S_OK;
	}
}


//-----------------------------------------------------------------------
//	CAccPLV::accNavigate()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::accNavigate( long navDir, VARIANT varStart, VARIANT* pVarEndUpAt )
{
	return m_pDefAccessible->accNavigate( navDir, varStart, pVarEndUpAt );
}

//-----------------------------------------------------------------------
//	CAccPLV::accHitTest()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accHitTest().
//
//		Retrieves the ID of the a child at a given point on the screen.
//
//	PARAMETERS:
//
//		xLeft and yTop	[in]  The screen coordinates of the point
//								to be hit tested.
//
//		pVarHit			[out] Pointer to the VARIANT structure that
//								will contain information describing
//								the hit child.  If the vt member is
//								VT_I4, then the lVal member is a child
//								ID.  If the vt member is VT_EMPTY,
//								then the navigation failed.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the pVarHit parameter is
//						  invalid, or S_OK.
//
//	NOTES:
//
//		Since the CAccPLV object has no child objects (only child
//		elements), pVarHit will never be a pointer to a IDispatch
//		interface of a child object.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::accHitTest( long xLeft, long yTop, VARIANT* pVarHit )
{
	if(!PLV_IsMSAAAvailable(m_lpPlv))
		return E_FAIL;

	if ( !pVarHit )
		return E_INVALIDARG;


	static POINT	pt;
	static RECT		rc;
	static INT		index,nCol;
	static PLVINFO	plvInfo;
	static HD_ITEM	hdItem;
	
	pt.x = xLeft;
	pt.y = yTop;
	ScreenToClient(m_hWnd,&pt);
	GetClientRect(m_hWnd, &rc );

	if (PtInRect( &rc, pt )) {
		pVarHit->vt = VT_I4;
		pVarHit->lVal = CHILDID_SELF;
#ifdef OLD
		if(m_lpPlv->dwStyle == PLVSTYLE_ICON) // iconview
			index = IV_GetInfoFromPoint(m_lpPlv, pt, &plvInfo);
		else { // report view
			nCol = RV_GetColumn(m_lpPlv);
			index = RV_GetInfoFromPoint(m_lpPlv, pt, &plvInfo);
			if(index < 0) {
				if(pt.y > RV_GetHeaderHeight(m_lpPlv)) // out of header
					return m_pDefAccessible->accHitTest(xLeft, yTop, pVarHit);

				 // header
				INT wid = 0;
				hdItem.mask = HDI_WIDTH;
				hdItem.fmt = 0;
				for(index = 0;index<nCol;index++){
					Header_GetItem(m_lpPlv->hwndHeader,index,&hdItem);
					wid += hdItem.cxy;
					if(pt.x <= wid)
						break;
				}
			}
			else
				index = (index + 1) * nCol + plvInfo.colIndex;
		}
		pVarHit->lVal = index + 1; // 1 origin
#else // new
		pVarHit->lVal = PLV_ChildIDFromPoint(m_lpPlv,pt);

		if(pVarHit->lVal < 0)
			return m_pDefAccessible->accHitTest(xLeft, yTop, pVarHit);
#endif 
		return S_OK;
	}

	return m_pDefAccessible->accHitTest(xLeft, yTop, pVarHit);
}



//-----------------------------------------------------------------------
//	CAccPLV::put_accName()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::put_accName( VARIANT varChild, BSTR szName )
{
	//-----------------------------------------------------
	//	We don't allow clients to change the name
	//	  property of any child so we simply return
	//	  S_FALSE.
	//-----------------------------------------------------
    return S_FALSE;
	UNREFERENCED_PARAMETER(varChild);
	UNREFERENCED_PARAMETER(szName);
}

//-----------------------------------------------------------------------
//	CAccPLV::put_accValue()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::put_accValue( VARIANT varChild, BSTR szValue )
{
	//-----------------------------------------------------
	//	We don't allow clients to change the value
	//	  property of the status bar (the only child that
	//	  has a value property) so we simply return S_FALSE.
	//-----------------------------------------------------
	return S_FALSE;
	UNREFERENCED_PARAMETER(varChild);
	UNREFERENCED_PARAMETER(szValue);
}

//-----------------------------------------------------------------------
//	CAccPLV::LresultFromObject()
//
//	DESCRIPTION:
//
//		call ::LresultFromObject()
//
//	PARAMETERS:
//
//		wParam			[in]  wParam of WM_GETOBJECT message
//
//-----------------------------------------------------------------------
LRESULT CAccPLV::LresultFromObject(WPARAM wParam)
{
	if(!PLV_IsMSAAAvailable(m_lpPlv))
		return E_FAIL;
	return PLV_LresultFromObject(m_lpPlv,IID_IAccessible,wParam,(IAccessible *)this);
}

//----  End of ACCPLV.CPP  ----
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\dbg.h ===
//////////////////////////////////////////////////////////////////
// File     : dbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef _DBG_H_
#define _DBG_H_

#define	MemAlloc(a)		GlobalAlloc(GMEM_FIXED, (a))
#define MemFree(a)		GlobalFree((a))

//-------------------------------------------------------
//MACRO function(?) prototype declare
//-------------------------------------------------------
////////////////////////////////////////////////////////
// Function	: DBG
// Type		: VOID
// Purpose	: Printing ANSI debug message with same usage as printf()
//			: 
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//		   : ...	
// CAUTION: Please use DOUBLE Blaket!!!
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

////////////////////////////////////////////////////////
// Function	: DBGMB
// Type		: VOID
// Purpose	: Show Messagebox for ANSI debug message 
//			: Same usage as printf()
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBGMB((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function	: DBGShowWindow
// Type		: VOID
// Purpose	: Invoke debug message window.
//			: DBG(), DBGW()'s message is shown here.
// Args		: HINSTANCE	hInst
//		    : HWND		hwndOwner
/////////////////////////////////////////////////////////
//VOID DBGShowWindow(HINSTANCE hInst, HWND hwndOwner);




#ifdef _DEBUG
extern VOID _plvDbgShowWindow(HINSTANCE hInst, HWND hwndOwner);
#ifndef UNICODE_ONLY
extern VOID  _plvDbgA		 (LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
extern VOID  _plvDbgPrintA (LPSTR lpstrMsg, ...);
extern LPSTR _plvDbgVaStrA (LPSTR lpstrFmt, ...);
extern LPWSTR _plvDbgMulti2Wide(LPSTR lpstr);
extern VOID _plvDbgMBA(LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
extern VOID _plvDbgMBW(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID _dbg_Assert(LPCTSTR		fileName,
						INT			line,
						BOOL			flag,
						LPCTSTR		pszExp);

#endif

#ifndef ANSI_ONLY
extern VOID   _plvDbgW(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _plvDbgPrintW(LPWSTR lpstrMsg, ...);
extern LPWSTR _plvDbgVaStrW(LPWSTR lpstrFmt, ...);
#endif
#endif

#if defined(_DEBUG) || (defined(_NDEBUG) && defined(_RELDEBUG))
#	define DBGShowWindow(a,b)	_plvDbgShowWindow(a,b);
#	define DBGW(a)				_plvDbgW( _plvDbgMulti2Wide(__FILE__), __LINE__, _plvDbgVaStrW a)
#	define DBGA(a)				_plvDbgA(__FILE__, __LINE__, _plvDbgVaStrA a)
#	define Dbg(a)				_plvDbgA(__FILE__, __LINE__, _plvDbgVaStrA a)
#	define DBGMB(a)				_plvDbgMBA(__FILE__, __LINE__, _plvDbgVaStrA a)
#	define DBGMBA(a)			_plvDbgMBA(__FILE__, __LINE__, _plvDbgVaStrA a)
#	define DBGMBW(a)			_plvDbgMBW(_plvDbgMulti2Wide(__FILE__), __LINE__, _plvDbgVaStrW a)
#	define DBGASSERT(a)			_plvDbgAssert(__FILE__, __LINE__, a, #a);
#	define DBGASSERTDO(a)		_plvDbgAssert(__FILE__, __LINE__, a, #a);
#else //!_DEBUG	//in Release version, these are disapear...
#	define DBGShowWindow(a,b)
#	define DBGW(a)	
#	define DBGA(a)		
#	define Dbg(a)
#	define DBGMB(a)
#	define DBGMBA(a)
#	define DBGMBW(a)
#	define DBGASSERT(a)
#	define DBGASSERTDO(a)		(a)
#endif //_DEBUG

//extern VOID  _plvDbgA		 (LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
//extern VOID  _plvDbgPrintA (LPSTR lpstrMsg, ...);
//extern LPSTR _plvDbgVaStrA (LPSTR lpstrFmt, ...);
#define DP(a) //_plvDbgA(__FILE__, __LINE__, _plvDbgVaStrA a)
#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\dbg.cpp ===
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <stdarg.h>
#include "dbg.h"

static VOID DbgSetWinTextA(LPSTR lpstr);
static VOID DbgSetWinTextW(LPWSTR lpwstr);

#define PRINT_STRW	//OutputDebugStringW
#define PRINT_STRA	//OutputDebugStringA

//-------------------------------------------------------
//Global String buffer
//-------------------------------------------------------
static WCHAR g_wchBuf[1024];
static CHAR  g_chBuf[1024];

static LPSTR GetFileTitleStrA(LPSTR lpstrFile)
{
	static CHAR tchJunk64[64];
	GetFileTitleA(lpstrFile, tchJunk64, sizeof(tchJunk64));	
	return tchJunk64;
}

static LPWSTR GetFileTitleStrW(LPWSTR lpstrFile)
{
	static WCHAR tchJunk64[64];
	GetFileTitleW(lpstrFile, tchJunk64, sizeof(tchJunk64));	
	return tchJunk64;
}


////////////////////////////////////////////////////////
// Function : _plvDbgMBA
// Type     : VOID
// Purpose  : Popup Debug MessageBox
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstrMsg 
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
VOID _plvDbgMBA(LPSTR	lpstrFile, 
			   INT		lineNo, 
			   LPSTR	lpstrMsg)
{
	wsprintfA(g_chBuf, 
			  "%s(%d)%s", 
			  GetFileTitleStrA(lpstrFile),
			  lineNo,
			  lpstrMsg);
	MessageBoxA(NULL, 
				g_chBuf, 
				"#### IMEPAD ERROR MESSAGE #####",
				MB_ICONERROR | MB_OK | MB_APPLMODAL);
	return;
}

VOID _plvDbgMBW(LPWSTR	lpstrFile, 
			   INT		lineNo, 
			   LPWSTR	lpstrMsg)
{
	wsprintfW(g_wchBuf, 
			 L"%s(%d)%s", 
			 GetFileTitleStrW(lpstrFile),			 
			 lineNo,
			 lpstrMsg);
	MessageBoxW(NULL, 
				lpstrFile, 
				L"#### ERROR #####",
				MB_OK | MB_APPLMODAL);
	return;
}


////////////////////////////////////////////////////////
// Function : _plvDbgVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _plvDbgVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfW(wchBuf, lpstrFmt, ap);
	va_end(ap);
	return wchBuf;
}

LPSTR _plvDbgVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(chBuf, lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function: _plvDbgPrint
// Type    : VOID
// Purpose : variable args version of OutputDebugString
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _plvDbgPrintA(LPSTR lpstrFmt, ...)
{
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(g_chBuf, lpstrFmt, ap);
	va_end(ap);
	PRINT_STRA(g_chBuf);
	DbgSetWinTextA(g_chBuf);
	return;
}

VOID _plvDbgPrintW(LPWSTR lpstrFmt, ...)
{
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfW(g_wchBuf, lpstrFmt, ap);
	va_end(ap);
	PRINT_STRW(g_wchBuf);
	DbgSetWinTextW(g_wchBuf);
	return;
}

////////////////////////////////////////////////////////
// Function: _plvDbg
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _plvDbgA(LPSTR		lpstrFile, 
		   INT		lineNo, 
		   LPSTR		lpstrMsg
)
{
	_plvDbgPrintA("(%s:%d) %s", 
			   GetFileTitleStrA(lpstrFile),
			   lineNo,
			   lpstrMsg);
	return;
}

VOID _plvDbgW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg
)
{
	_plvDbgPrintW(L"(%s:%d) %s", 
			   GetFileTitleStrW(lpstrFile),
			   lineNo,
			   lpstrMsg);

	return;
}

LPWSTR _plvDbgMulti2Wide(LPSTR lpstr)
{
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)g_wchBuf, sizeof(g_wchBuf)/sizeof(WCHAR) );
	return g_wchBuf;
}

#define ID_EDITWIN		0x40
#define ID_BTN_CLEAR	0x41
static HWND g_hwndDbg;
static VOID DbgSetWinTextA(LPSTR lpstr)
{
	HWND hwndEdit;
	INT len; 
	if(!g_hwndDbg)  {
		return; 
	}
	if(!lpstr) {
		return;
	}
	hwndEdit = GetDlgItem(g_hwndDbg, ID_EDITWIN);
	if(!hwndEdit) {
		return;
	}
	len = lstrlen(lpstr);
	if(lpstr[len-1] == '\n') {
		lpstr[len-1] = '\r';
		lpstr[len]='\n'; //lpstr is static enough size buffer's pointer.
		lpstr[len+1]=0x00;
	}
	Edit_SetSel(hwndEdit, (WPARAM)-2, (LPARAM)-2);
	Edit_ReplaceSel(hwndEdit, lpstr);
	return; 
}

static VOID DbgSetWinTextW(LPWSTR lpwstr)
{
	static CHAR szStr[512];
	WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK,
						lpwstr, -1, 
						szStr,
						sizeof(szStr),
						NULL, NULL);
	DbgSetWinTextA(szStr);
}

VOID _plvDbgAssert(LPCTSTR		fileName,
					INT			line,
					BOOL		flag,
					LPCTSTR		pszExp)
{
	if(!flag) {
		wsprintf(g_chBuf, "  Assertion Faled %s(%d) %s\n",
				 GetFileTitleStrA((CHAR *)fileName),
				 line,
				 pszExp != (LPCTSTR)NULL ? pszExp : "");
		PRINT_STRA(g_chBuf);
		DebugBreak();
	}
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\iconview.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "plv_.h"
#include "plv.h"
#include "dbg.h"
#include "iconview.h"
#include "ivmisc.h"
#include "exgdiw.h"
#include "exres.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

static POSVERSIONINFO ExGetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

static BOOL ExIsWinNT(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
	return fBool;
}

#define IV_EDGET_NONE		0
#define IV_EDGET_RAISED		1
#define IV_EDGET_SUNKEN		2


//////////////////////////////////////////////////////////////////
// Function : RepView_RestoreScrollPos
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IconView_RestoreScrollPos(LPPLVDATA lpPlvData)
{
	return IV_SetCurScrollPos(lpPlvData->hwndSelf, lpPlvData->nCurIconScrollPos);
}

//////////////////////////////////////////////////////////////////
// Function : IconView_ResetScrollRange
// Type     : INT
// Purpose  : Reset scroll bar's range,
//			: if PadListView size was changed.
// Args     : 
//          : LPPLVDATA lpPlvData 
// Return   : 
// DATE     : 970829
//////////////////////////////////////////////////////////////////
INT IconView_ResetScrollRange(LPPLVDATA lpPlvData)
{
	static SCROLLINFO scrInfo;

	HWND hwnd = lpPlvData->hwndSelf;

	INT nRow = IV_GetRow(hwnd);
	INT nCol = IV_GetCol(hwnd);
	INT nMax = IV_GetMaxLine(hwnd);
	INT nPos = lpPlvData->nCurIconScrollPos;

	//----------------------------------------------------------------
	//important:
	//calc new cur top index
	//----------------------------------------------------------------
	lpPlvData->iCurIconTopIndex = nCol * nPos; //changed 970707

	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= 0;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nRow;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	//In normal case,  
	//if (scrInfo.nMax - scrInfo.nMin + 1) <= scrInfo.nPage, 
	// scroll bar is hidden. to prevent it,
	// in this case, set proper page, and DISABLE scrollbar.
	// Now we can show scroll bar always
	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : IconView_SetItemCount
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
//          : INT itemCount 
//          : BOOL fDraw		update scroll bar or not
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IconView_SetItemCount(LPPLVDATA lpPlvData, INT itemCount, BOOL fDraw)
{
	//Dbg(("IconView_SetItemCount [%d]\n", itemCount));
	lpPlvData->iItemCount	     = itemCount;
	lpPlvData->nCurIconScrollPos = 0;	//970707 ToshiaK, same as iCurTopIndex
	lpPlvData->iCurIconTopIndex  = 0;	//970707 ToshiaK, same as iCurTopIndex

	if(fDraw) {
		INT nMaxLine = IV_GetMaxLine(lpPlvData->hwndSelf);
		INT nPage	 = IV_GetRow(lpPlvData->hwndSelf);
		IV_SetScrollInfo(lpPlvData->hwndSelf, 0, nMaxLine, nPage, 0);
	}
	return 0;
}

INT IconView_SetTopIndex(LPPLVDATA lpPlvData, INT indexTop)
{
	INT nCol = IV_GetCol(lpPlvData->hwndSelf); 
	if(nCol <=0) {
		Dbg(("Internal ERROR Colmn 0\n"));
		return 0;
	}
	if(indexTop < lpPlvData->iItemCount) {
		lpPlvData->iCurIconTopIndex = (indexTop/nCol) * nCol;
		
		IV_SetCurScrollPos(lpPlvData->hwndSelf,
						   lpPlvData->iCurIconTopIndex/nCol);
		InvalidateRect(lpPlvData->hwndSelf, NULL, TRUE);
		UpdateWindow(lpPlvData->hwndSelf);
		return indexTop;
	}
	else {
		Dbg(("Internal ERROR\n"));
		return -1;
	}
}

INT IconView_Paint(HWND hwnd, WPARAM wParam, LPARAM lParam)
{

	static PAINTSTRUCT ps;
	static RECT		rc;
	static HBRUSH		hBrush;
	static HDC			hDCMem;
	static HDC			hDC;
	static HBITMAP		hBitmap, hBitmapPrev;
	static DWORD		dwOldTextColor, dwOldBkColor;
	static INT			i, j;

	//Dbg(("IconView_Paint START\n"));
	hDC = BeginPaint(hwnd, &ps);

	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	GetClientRect(hwnd, &rc);

	hDCMem		= CreateCompatibleDC(hDC);
	hBitmap		= CreateCompatibleBitmap(hDC, rc.right - rc.left, rc.bottom-rc.top);
	hBitmapPrev = (HBITMAP)SelectObject(hDCMem, hBitmap);

	//----------------------------------------------------------------
	//971111: #2586
	//----------------------------------------------------------------
	//hBrush         = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
	//dwOldBkColor   = SetBkColor(hDCMem, GetSysColor(COLOR_3DFACE));
	hBrush         = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
	dwOldBkColor   = SetBkColor(hDCMem, GetSysColor(COLOR_WINDOW));
	dwOldTextColor = SetTextColor(hDCMem, GetSysColor(COLOR_WINDOWTEXT));

	FillRect(hDCMem, &rc, hBrush);

	INT nRow = IV_GetRow(hwnd);
	INT nCol = IV_GetCol(hwnd);
	INT nMetricsCount;
	nMetricsCount = (nRow+1) * nCol;
	INT x, y;
	RECT rcChar;

	HFONT hFontOld = NULL;
	if(lpPlvData->hFontIcon) {
		hFontOld = (HFONT)SelectObject(hDCMem, lpPlvData->hFontIcon);
	}


	INT nItemWidth  = IV_GetItemWidth(hwnd);
	INT nItemHeight = IV_GetItemHeight(hwnd);
	INT iCurIconTopIndex;
	//----------------------------------------------------------------
	//error no call back exists
	if(!lpPlvData->lpfnPlvIconItemCallback) {
		Dbg(("Call back does not exists\n"));
		goto LError;
	}
	if(nCol <=0 ){
		Dbg(("Column count is less than zero\n"));
		goto LError;
	}
	//Dbg(("Call back exist\n"));
	static PLVITEM plvItemTmp, plvItem;
	POINT pt;
#ifndef UNDER_CE // Windows CE does not support GetCursorPos.
	GetCursorPos(&pt);
	ScreenToClient(hwnd, &pt);
#else // UNDER_CE
	if(lpPlvData->iCapture != CAPTURE_NONE){
		pt.x = lpPlvData->ptCapture.x;
		pt.y = lpPlvData->ptCapture.y;
	}
	else{
		// set outer client point
		pt.x = -1;
		pt.y = -1;
	}
#endif // UNDER_CE
	//Dbg(("iCurIconTopIndex [%d]\n", lpPlvData->iCurIconTopIndex));
	//Dbg(("iItemCount   [%d]\n", lpPlvData->iItemCount));

	//----------------------------------------------------------------
	//970707 toshiak changed.
	//iCurIconTopIndex shold be a muliple of nCol; 
	//----------------------------------------------------------------
	iCurIconTopIndex = (lpPlvData->iCurIconTopIndex / nCol) * nCol;

	for(i = 0, j = iCurIconTopIndex;
		i < nMetricsCount && j < lpPlvData->iItemCount;
		i++, j++) {
		x = IV_GetXMargin(hwnd) + nItemWidth  * (i % nCol);
		y = IV_GetYMargin(hwnd) + nItemHeight * (i / nCol);
		rcChar.left  = rc.left + x;
		rcChar.top   = rc.top  + y;
		rcChar.right = rcChar.left + nItemWidth;
		rcChar.bottom= rcChar.top  + nItemHeight;
		if(rcChar.top > rc.bottom) {
			break;
		}
		plvItem = plvItemTmp;
		lpPlvData->lpfnPlvIconItemCallback(lpPlvData->iconItemCallbacklParam, 
										   j, 
										   &plvItem);
		if(plvItem.lpwstr) {
			INT edgeFlag;
			if(lpPlvData->iCapture == CAPTURE_LBUTTON) {
				if(PtInRect(&rcChar, lpPlvData->ptCapture) &&
				   PtInRect(&rcChar, pt)) {
					edgeFlag = IV_EDGET_SUNKEN;
				}
				else {
					edgeFlag = IV_EDGET_NONE;
				}
			}
			else {
				if(PtInRect(&rcChar, pt)) {
					edgeFlag = IV_EDGET_RAISED;
				}
				else {
					edgeFlag = IV_EDGET_NONE;
				}
			}
			INT sunken = 0;
			switch(edgeFlag) {
			case IV_EDGET_SUNKEN:
				sunken = 1;
				DrawEdge(hDCMem, &rcChar, EDGE_SUNKEN, BF_SOFT | BF_RECT);
				break;
			case IV_EDGET_RAISED:
				sunken = 0;
				DrawEdge(hDCMem, &rcChar, EDGE_RAISED, BF_SOFT | BF_RECT);
				break;
			case IV_EDGET_NONE:
			default:
				break;
			}
			SIZE size;

			if(ExGetTextExtentPoint32W(hDCMem, plvItem.lpwstr, 1, &size)) {
				ExExtTextOutW(hDCMem, 
							  rcChar.left + (nItemWidth  - size.cx)/2 + sunken,
							  rcChar.top  + (nItemHeight - size.cy)/2 + sunken,
							  ETO_CLIPPED,
							  &rcChar,
							  plvItem.lpwstr,
							  1,
							  NULL);
			}
		}
	}

 LError:
	if(hFontOld){
		SelectObject(hDCMem, hFontOld);
	}
	// LIZHANG: if there is no items, draw the explanation text
	if ( !lpPlvData->iItemCount && (lpPlvData->lpText || lpPlvData->lpwText ))
	{
		HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
		HFONT hOldFont = (HFONT)SelectObject( hDCMem, hFont );
		RECT rcTmp = rc;
		rcTmp.left = 20;
		rcTmp.top = 20;
		rcTmp.right -= 10;
		rcTmp.bottom -= 10;

		//COLORREF colOld = SetTextColor( hDCMem, GetSysColor(COLOR_WINDOW) );
		//COLORREF colBkOld = SetBkColor( hDCMem, GetSysColor(COLOR_3DFACE) );
		COLORREF colOld = SetTextColor( hDCMem, GetSysColor(COLOR_WINDOWTEXT));
		COLORREF colBkOld = SetBkColor( hDCMem, GetSysColor(COLOR_WINDOW) );
#ifndef UNDER_CE // always Unicode
		if(ExIsWinNT()) {
			if(lpPlvData->lpwText) {
				DrawTextW(hDCMem,
						 lpPlvData->lpwText,
						 lstrlenW(lpPlvData->lpwText),
						 &rcTmp,
						 DT_VCENTER|DT_WORDBREAK ); 
			}
		}
		else {
			DrawText( hDCMem,
					 lpPlvData->lpText,
					 lstrlen(lpPlvData->lpText),
					 &rcTmp,
					 DT_VCENTER|DT_WORDBREAK ); 
		}
#else // UNDER_CE
		if(lpPlvData->lpwText) {
			DrawTextW(hDCMem,
					 lpPlvData->lpwText,
					 lstrlenW(lpPlvData->lpwText),
					 &rcTmp,
					 DT_VCENTER|DT_WORDBREAK ); 
		}
#endif // UNDER_CE
		SetTextColor( hDCMem, colOld );
		SetBkColor( hDCMem, colBkOld );
		SelectObject( hDCMem, hOldFont );
	}

	BitBlt(hDC, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
		   hDCMem, 0, 0, SRCCOPY);

	DeleteObject(hBrush);
	SetBkColor(hDCMem, dwOldBkColor);
	SetTextColor(hDCMem, dwOldTextColor);
	SelectObject(hDCMem, hBitmapPrev );

	DeleteObject(hBitmap);
	DeleteDC( hDCMem );

	EndPaint(hwnd, &ps);
	return 0;
	Unref3(hwnd, wParam, lParam);
}

INT IconView_ButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData)  {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	switch(uMsg) {
	case WM_LBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	case WM_MBUTTONDBLCLK:
	case WM_RBUTTONDBLCLK:
		SetCapture(hwnd);
#ifdef UNDER_CE // LBUTTON + ALT key handling
		//Standard way for RBUTTON handling is combination w/ LBUTTON + ALT key
		if(uMsg == WM_LBUTTONDOWN && GetAsyncKeyState(VK_MENU)){
			uMsg = WM_RBUTTONDOWN;
		}
#endif // UNDER_CE
		switch(uMsg) {
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_LBUTTON;
			break;
		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_MBUTTON;
			break;
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_RBUTTON;
			break;
		}
#ifndef UNDER_CE // Windows CE does not support GetCursorPos.
		GetCursorPos(&lpPlvData->ptCapture);
		//remember left button down place
		ScreenToClient(hwnd, &lpPlvData->ptCapture);
#else // UNDER_CE
		lpPlvData->ptCapture.x = (SHORT)LOWORD(lParam);
		lpPlvData->ptCapture.y = (SHORT)HIWORD(lParam);
#endif // UNDER_CE
		switch(uMsg) {
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			InvalidateRect(hwnd, NULL, FALSE);
			break;
		}
#ifdef UNDER_CE // Windows CE used ButtonDown Event for ToolTip
		if(lpPlvData->uMsg != 0) {
			if(uMsg == WM_LBUTTONDOWN) {
				PLVINFO plvInfo;
				INT index = IV_GetInfoFromPoint(lpPlvData,
												lpPlvData->ptCapture,
												&plvInfo);
				plvInfo.code = PLVN_ITEMDOWN;
				SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
			}
		}
#endif // UNDER_CE
		break;
	}
	return 0;
	Unref2(wParam, lParam);
}

INT IconView_ButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	static POINT pt;
	static PLVINFO plvInfo;
	static INT	index, downIndex;
	if(!lpPlvData)  {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	switch(uMsg) {
	case WM_MBUTTONUP:
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
		Dbg(("WM_LBUTTONUP COMES\n"));
#ifdef UNDER_CE // LBUTTON + ALT key handling
		//Standard way for RBUTTON handling is combination w/ LBUTTON + ALT key
		if(uMsg == WM_LBUTTONUP && GetAsyncKeyState(VK_MENU)){
			uMsg = WM_RBUTTONUP;
		}
#endif // UNDER_CE

		InvalidateRect(hwnd, NULL, FALSE);
		pt.x = LOWORD(lParam);
		pt.y = HIWORD(lParam);
#if 0
		Dbg(("x %d, y %d\n", pt.x, pt.y));
		Dbg(("capture x[%d] y[%d] \n",
			 lpPlvData->ptCapture.x,
			 lpPlvData->ptCapture.y));
#endif
		downIndex = IV_GetInfoFromPoint(lpPlvData, lpPlvData->ptCapture, NULL);
		index = IV_GetInfoFromPoint(lpPlvData, pt, &plvInfo);
		ReleaseCapture();
#if 0
		Dbg(("mouse down index [%d]\n", downIndex));
		Dbg(("mouse up   index [%d]\n", index));
#endif
		if(index != -1) {
			Dbg(("code  [%d]\n", plvInfo.code));
			Dbg(("index [%d]\n", plvInfo.index));
			Dbg(("left[%d] top[%d] right[%d] bottom[%d] \n",
				 plvInfo.itemRect.left,
				 plvInfo.itemRect.top,
				 plvInfo.itemRect.right,
				 plvInfo.itemRect.bottom));
			if(index == downIndex) {
				if(lpPlvData->uMsg != 0) {
					if(uMsg == WM_LBUTTONUP) {
						plvInfo.code = PLVN_ITEMCLICKED;
						SendMessage(GetParent(hwnd), lpPlvData->uMsg, index, (LPARAM)&plvInfo);
					}
					else if(uMsg == WM_RBUTTONUP) {
						plvInfo.code = PLVN_R_ITEMCLICKED;
						SendMessage(GetParent(hwnd), lpPlvData->uMsg, index, (LPARAM)&plvInfo);
					}
				}
			}
		}
#ifdef UNDER_CE // Windows CE used ButtonUp Event for ToolTip
		if(lpPlvData->uMsg != 0) {
			if(uMsg == WM_LBUTTONUP) {
				PLVINFO plvInfo;
				INT index = IV_GetInfoFromPoint(lpPlvData,
												lpPlvData->ptCapture,
												&plvInfo);
				plvInfo.code = PLVN_ITEMUP;
				SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
			}
		}
#endif // UNDER_CE
		lpPlvData->iCapture = CAPTURE_NONE;
		lpPlvData->ptCapture.x = 0;
		lpPlvData->ptCapture.y = 0;
		break;
	}
	return 0;
	Unref(wParam);
}

INT IconView_MouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData)  {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	static POINT pt;
	static PLVINFO plvInfo;
	pt.x = LOWORD(lParam);
	pt.y = HIWORD(lParam);
	//Dbg(("x %d, y %d\n", pt.x, pt.y));
	INT index = IV_GetInfoFromPoint(lpPlvData, pt, &plvInfo);
	//Dbg(("mouse up   index [%d]\n", index));
	InvalidateRect(hwnd, NULL, NULL);
	//----------------------------------------------------------------
	//970929:
	//if(index != -1 && !lpPlvData->fCapture) {
	//----------------------------------------------------------------
	if(index != -1 && (lpPlvData->iCapture == CAPTURE_NONE)) {
#if 0
		Dbg(("style [%d]\n", plvInfo.style));
		Dbg(("code  [%d]\n", plvInfo.code));
		Dbg(("index [%d]\n", plvInfo.index));
		Dbg(("left[%d] top[%d] right[%d] bottom[%d] \n",
			 plvInfo.itemRect.left,
			 plvInfo.itemRect.top,
			 plvInfo.itemRect.right,
			 plvInfo.itemRect.bottom));
#endif
		if(lpPlvData->uMsg != 0) {
			plvInfo.code = PLVN_ITEMPOPED;
			SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
#ifdef MSAA
			static oldindex = 0;
			index++; // convert to 1 origin child id

			if((index > 0)&&(index != oldindex)) {
				PLV_NotifyWinEvent(lpPlvData,
								   EVENT_OBJECT_FOCUS,
								   hwnd,
								   OBJID_CLIENT,
								   index); // child id
				oldindex = index;
			}
#endif
		}
	}
	return 0;
	Unref(wParam);
}

//////////////////////////////////////////////////////////////////
// Function : IconView_VScroll
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IconView_VScroll(HWND hwnd, WPARAM wParam,  LPARAM lParam)
{
	//----------------------------------------------------------------
	// get current top index.
	// calc scroll position. 
	// get new top index and set it. 
	// redraw window rectangle.
	//----------------------------------------------------------------
	INT nScrollCode	  = (int) LOWORD(wParam); // scroll bar value 
#ifdef _DEBUG
	INT nArgPos 	  = (short int) HIWORD(wParam);  // scroll box position 
#endif
	//HWND hwndScrollBar = (HWND) lParam;      // handle of scroll bar 
	INT nPos;
	INT nRow, nCol, nMax;

	switch(nScrollCode) {
	case SB_LINEDOWN:	
		Dbg(("SB_LINEDOWN COME nArgPos[%d]\n", nArgPos));
		nRow = IV_GetRow(hwnd);
		nMax = IV_GetMaxLine(hwnd);
		nPos = IV_GetCurScrollPos(hwnd);		
		if(nPos + nRow > nMax - 1) {
			return 0;
		}
		nPos++;
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_LINEUP:
		Dbg(("SB_LINEUP COME nArgPos[%d]\n", nArgPos));
		IV_GetRowColumn(hwnd, &nRow, &nCol);
		nPos = IV_GetCurScrollPos(hwnd);
		if(nPos <= 0) {
			return 0;
		}
		nPos--; 
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_PAGEDOWN:	
		Dbg(("SB_PAGEDOWN COME nArgPos[%d]\n", nArgPos));
		IV_GetRowColumn(hwnd, &nRow, &nCol);
		nMax = IV_GetMaxLine(hwnd);
		nPos = IV_GetCurScrollPos(hwnd);
		Dbg(("nMax [%d] nPos %d nRow[%d] nCol[%d]\n", nMax, nPos, nRow, nCol));
		nPos = min(nPos+nRow, nMax - nRow);
		Dbg(("-->nPos [%d] \n", nPos));
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_PAGEUP:		//TrackNbN
		Dbg(("SB_PAGEUP COME nArgPos[%d]\n", nArgPos));
		IV_GetRowColumn(hwnd, &nRow, &nCol);
		nPos = IV_GetCurScrollPos(hwnd);
		nPos = max(0, nPos - nRow);
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_TOP:
		Dbg(("SB_TOP COME nArgPos[%d]\n", nArgPos));
		break;
	case SB_BOTTOM:
		Dbg(("SB_BOTTOM COME nArgPos[%d]\n", nArgPos));
		break;
	case SB_THUMBTRACK:		//TrackDrag
		Dbg(("SB_THUMBTRACK COME nArgPos[%d]\n", nArgPos));
		nPos = IV_GetScrollTrackPos(hwnd);
		//Dbg(("Current Pos %d\n", nPos));
		IV_GetRowColumn(hwnd, &nRow, &nCol);
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_THUMBPOSITION:	//Scroll BarDragI
		Dbg(("SB_THUMBPOSITION COME nArgPos[%d]\n", nArgPos));
		nPos = IV_GetScrollTrackPos(hwnd);
		Dbg(("Current Pos %d\n", nPos));
		IV_GetRowColumn(hwnd, &nRow, &nCol);
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_ENDSCROLL:
		Dbg(("SB_ENDSCROLL COME nArgPos[%d]\n", nArgPos));
		break;
	}
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	Unref3(hwnd, wParam, lParam);
}

INT IconView_SetCurSel(LPPLVDATA lpPlvData, INT index)
{
	INT		i, j;
	HWND	hwnd;	

	//Dbg(("IconView_SetCurSel Index [%d][0x%08x]START\n", index, index));

	hwnd = lpPlvData->hwndSelf;
	RECT rc;
	GetClientRect(hwnd, &rc);
	INT nRow = IV_GetRow(hwnd);
	INT nCol = IV_GetCol(hwnd);

	if(nCol <= 0) {
		return 0;
	}

	INT nMetricsCount;
	nMetricsCount = (nRow+1) * nCol;
	INT x, y;
	RECT rcChar;

	INT nItemWidth  = IV_GetItemWidth(hwnd);
	INT nItemHeight = IV_GetItemHeight(hwnd);
	INT iCurIconTopIndex;

	static PLVITEM plvItemTmp, plvItem;
	POINT pt;
	iCurIconTopIndex = (lpPlvData->iCurIconTopIndex / nCol) * nCol;
	for(i = 0, j = iCurIconTopIndex;
		i < nMetricsCount && j < lpPlvData->iItemCount;
		i++, j++) {
		if(index == j) {
			x = IV_GetXMargin(hwnd) + nItemWidth  * (i % nCol);
			y = IV_GetYMargin(hwnd) + nItemHeight * (i / nCol);
			rcChar.left  = rc.left + x;
			rcChar.top   = rc.top  + y;
			pt.x = rcChar.left + (nItemWidth  * 3)/4;
			pt.y = rcChar.top  + (nItemHeight * 3)/4;
			ClientToScreen(hwnd, &pt);
			SetCursorPos(pt.x, pt.y);
			break;
		}
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : IconView_GetWidthByColumn
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlv 
//          : INT col 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IconView_GetWidthByColumn(LPPLVDATA lpPlv, INT col)
{
	if(col < 0) {
		col = 0;
	}
	INT nItemWidth = IV_GetItemWidth(lpPlv->hwndSelf);
	INT nVScroll = GetSystemMetrics(SM_CXVSCROLL);
	INT nEdge    = GetSystemMetrics(SM_CXEDGE);
	Dbg(("nItemWidth [%d] nVScroll[%d] nEdge[%d]\n", nItemWidth, nVScroll, nEdge));
	Dbg(("Total Width [%d]\n", col*nItemWidth + nVScroll + nEdge*2));
	return col*nItemWidth + nVScroll + nEdge*2;
}


//////////////////////////////////////////////////////////////////
// Function : IconView_GetHeightByRow
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlv 
//          : INT row 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IconView_GetHeightByRow(LPPLVDATA lpPlv, INT row)
{
	if(row < 0) {
		row = 0;
	}
	INT nItemHeight = IV_GetItemHeight(lpPlv->hwndSelf);
	INT nEdge       = GetSystemMetrics(SM_CXEDGE);
	Dbg(("nItemHeight [%d] [%d] nEdge[%d]\n", nItemHeight, nEdge));
	Dbg(("Total Height[%d]\n", row*nItemHeight + nEdge*2));
	return row*nItemHeight + nEdge*2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\dispatch.h ===
/* dispatch.c */
#ifndef _DISPATCH_H_
#define _DISPATCH_H_

typedef LRESULT (*PFNMSG)(HWND, UINT, WPARAM, LPARAM);
typedef LRESULT (*PFNCMD)(HWND, WORD, WORD, HWND);

typedef enum{
   edwpNone,            // Do not call any default procedure.
   edwpWindow,          // Call DefWindowProc.
   edwpDialog,          // Call DefDlgProc (This should be used only for
                        // custom dialogs - standard dialog use edwpNone).
   edwpMDIChild,        // Call DefMDIChildProc.
   edwpMDIFrame         // Call DefFrameProc.
} EDWP;                // Enumeration for Default Window Procedures

typedef struct _MSD{
    UINT   uMessage;
    PFNMSG pfnmsg;
} MSD;                 // MeSsage Dispatch structure

typedef struct _MSDI{
    int  cmsd;          // Number of message dispatch structs in rgmsd
    MSD *rgmsd;         // Table of message dispatch structures
    EDWP edwp;          // Type of default window handler needed.
} MSDI, FAR *LPMSDI;   // MeSsage Dipatch Information

typedef struct _CMD{
    WORD   wCommand;
    PFNCMD pfncmd;
} CMD;                 // CoMmand Dispatch structure

typedef struct _CMDI{
    int  ccmd;          // Number of command dispatch structs in rgcmd
    CMD *rgcmd;         // Table of command dispatch structures
    EDWP edwp;          // Type of default window handler needed.
} CMDI, FAR *LPCMDI;   // CoMmand Dispatch Information

LRESULT DispMessage(LPMSDI lpmsdi, HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam);
LRESULT DispCommand(LPCMDI lpcmdi, HWND hwnd, WPARAM wparam, LPARAM lparam);
LRESULT DispDefault(EDWP edwp, HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam);

#endif // _DISPATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\dispatch.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "dispatch.h"


LRESULT DispMessage(LPMSDI lpmsdi, 
                    HWND   hwnd, 
                    UINT   uMessage, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    int  imsd = 0;

    MSD *rgmsd = lpmsdi->rgmsd;
    int  cmsd  = lpmsdi->cmsd;

    for (imsd = 0; imsd < cmsd; imsd++)
    {
        if (rgmsd[imsd].uMessage == uMessage)
            return rgmsd[imsd].pfnmsg(hwnd, uMessage, wparam, lparam);
    }

    return DispDefault(lpmsdi->edwp, hwnd, uMessage, wparam, lparam);
}

////////////////////////////////////////////////////////////////
// Function : DispCommand
// Type     :  LRESULT
// Purpose  : 
//          : 
// Argument : 
//          : LPCMDI lpcmdi 
//          : HWND hwnd 
//          : WPARAM wparam 
//          : LPARAM lparam 
// Return   :
// AUTHOR   : g(ToshiaK)
// START DATE: 
// HISTORY  : 
// 
/////////////////////////////////////////////////////////////////
LRESULT DispCommand(LPCMDI lpcmdi, 
                    HWND   hwnd, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    //LRESULT lRet = 0;
    WORD    wCommand = GET_WM_COMMAND_ID(wparam, lparam);
    int     icmd;

    CMD    *rgcmd = lpcmdi->rgcmd;
    int     ccmd  = lpcmdi->ccmd;

    // Message packing of wparam and lparam have changed for Win32,
    // so use the GET_WM_COMMAND macro to unpack the commnad

    for (icmd = 0; icmd < ccmd; icmd++)
    {
        if (rgcmd[icmd].wCommand == wCommand)
        {
            return rgcmd[icmd].pfncmd(hwnd,
                                      wCommand,
                                      GET_WM_COMMAND_CMD(wparam, lparam),
                                      GET_WM_COMMAND_HWND(wparam, lparam));
        }
    }

    return DispDefault(lpcmdi->edwp, hwnd, WM_COMMAND, wparam, lparam);
}


////////////////////////////////////////////////////////////////
// Function : DispDefault
// Type     :  LRESULT
// Purpose  : 
//          : 
// Argument : 
//          : EDWP edwp 
//          : HWND hwnd 
//          : UINT uMessage 
//          : WPARAM wparam 
//          : LPARAM lparam 
// Return   :
// AUTHOR   : g(ToshiaK)
// START DATE: 
// HISTORY  : 
// 
/////////////////////////////////////////////////////////////////
#define hwndMDIClient NULL
LRESULT DispDefault(EDWP   edwp, 
                    HWND   hwnd, 
                    UINT   uMessage, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    switch (edwp)
    {
        case edwpNone:
            return 0;
        case edwpWindow:
            return DefWindowProc(hwnd, uMessage, wparam, lparam);
        case edwpDialog:
            return DefDlgProc(hwnd, uMessage, wparam, lparam);
#ifndef UNDER_CE // Windows CE does not support MDI func
        case edwpMDIFrame:
            return DefFrameProc(hwnd, hwndMDIClient, uMessage, wparam, lparam);
        case edwpMDIChild:
            return DefMDIChildProc(hwnd, uMessage, wparam, lparam);
#endif // UNDER_CE
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\ivmisc.h ===
#ifndef _IV_MISC_H_
#define _IV_MISC_H_
/* ivmisc.cpp */
extern INT RECT_GetWidth(LPRECT lpRc);
extern INT RECT_GetHeight(LPRECT lpRc);
extern INT IV_GetItemWidth(HWND hwnd);
extern INT IV_GetItemHeight(HWND hwnd);
extern INT IV_GetXMargin(HWND hwnd);
extern INT IV_GetYMargin(HWND hwnd);
extern INT IV_GetDispWidth(HWND hwnd);
extern INT IV_GetDispHeight(HWND hwnd);
extern INT IV_GetWidth(HWND hwnd);
extern INT IV_GetHeight(HWND hwnd);
extern INT IV_GetRow(HWND hwnd);
extern INT IV_GetCol(HWND hwnd);
extern INT IV_GetRowColumn(HWND hwnd, INT *pRow, INT *pCol);
extern INT IV_GetMaxLine(HWND hwnd);
extern INT IV_GetInfoFromPoint(LPPLVDATA lpPlvData, POINT pt, LPPLVINFO lpPlvInfo);
extern INT IV_GetCurScrollPos(HWND hwnd);
extern INT IV_SetCurScrollPos(HWND hwnd, INT nPos);
extern INT IV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos);
extern INT IV_GetScrollTrackPos(HWND hwnd);
#endif //_IV_MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\iconview.h ===
#ifndef _ICON_VIEW_H_
#define _ICON_VIEW_H_
/* iconview.cpp */
extern INT IconView_RestoreScrollPos(LPPLVDATA lpPlvData);
extern INT IconView_ResetScrollRange(LPPLVDATA lpPlvData);
extern INT IconView_SetItemCount(LPPLVDATA lpPlvData, INT itemCount, BOOL fDraw);
extern INT IconView_SetTopIndex(LPPLVDATA lpPlvData, INT indexTop);
extern INT IconView_SetCurSel(LPPLVDATA lpPlvData, INT index);
extern INT IconView_Paint(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT IconView_ButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT IconView_ButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT IconView_MouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT IconView_VScroll(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT IconView_GetWidthByColumn(LPPLVDATA lpPlv, INT col);
extern INT IconView_GetHeightByRow(LPPLVDATA lpPlv, INT row);
#endif //_ICON_VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plv.h ===
#ifndef _PAD_LIST_VIEW_H_
#define _PAD_LIST_VIEW_H_
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <commctrl.h>

#define WC_PADLISTVIEW		TEXT("PadListView")

//----------------------------------------------------------------
//PadListView's style. it is not compatible to WS_XXXX
//----------------------------------------------------------------
#define PLVSTYLE_ICON		0x0001
#define PLVSTYLE_REPORT		0x0002

//----------------------------------------------------------------
// PadListView display data's format
//----------------------------------------------------------------
#define PLVFMT_TEXT		0x0001			// Unicode string(NULL terminate)
#define PLVFMT_BITMAP	0x0002			// Bitmap

typedef struct tagPLVITEM {
	INT		fmt;			// PLVFMT_TEXT or PLVFMT_BITMAP. cannot set combination.
	union  {
		LPWSTR	lpwstr;
		HBITMAP	hBitmap;
	};
}PLVITEM, *LPPLVITEM;

//----------------------------------------------------------------
// commctrl.h's LV_COLUMNA
//----------------------------------------------------------------
#if 0
typedef struct _LV_COLUMNA
{
    UINT mask; 	 //LVCF_FMT, LVCF_WIDTH, LVCF_TEXT, LVCF_SUBITEM;
    int fmt;
    int cx;
    LPSTR pszText;
    int cchTextMax;
    int iSubItem;
} LV_COLUMNA;
#endif

//----------------------------------------------------------------
// PLV_COLUMN is same as LV_COLMUNA
// to insert header control to PadListView.
// PadListView uses Header contorol as child window.
// Interface (PadListView_Insert(Delete)Column uses common control
// (commctrl.h)'s LV_COLUMNA structure.
//----------------------------------------------------------------
#ifndef UNDER_CE // always Unicode
#define PLV_COLUMN				LV_COLUMNA
#else // UNDER_CE
#define PLV_COLUMN				LV_COLUMNW
#endif // UNDER_CE

#define PLVCF_FMT               LVCF_FMT
#define PLVCF_WIDTH             LVCF_WIDTH
#define PLVCF_TEXT              LVCF_TEXT
#define PLVCF_SUBITEM           LVCF_SUBITEM
#define PLVCF_SEPARATER			0x1000			// new define.

#define PLVCFMT_LEFT            LVCFMT_LEFT
#define PLVCFMT_RIGHT           LVCFMT_RIGHT
#define PLVCFMT_CENTER          LVCFMT_CENTER
#define PLVCFMT_JUSTIFYMASK     LVCFMT_JUSTIFYMASK

//----------------------------------------------------------------
//callback function's prototype declaration.

//----------------------------------------------------------------
// this is for PadListView's ICON VIEW callback to retrieve
// display item data by INDEX
//----------------------------------------------------------------
typedef INT (WINAPI *LPFNPLVICONITEMCALLBACK)(LPARAM lParam, INT index, LPPLVITEM lpPlvItem);

//----------------------------------------------------------------
//970705 spec changed, to performance up.
//----------------------------------------------------------------
// This is for PadListView's REPORT VIEW callback to retrieve  
// display item data by INDEX.
// you can specify data with index and column in lpPlvItemList.
// so, lpPlvItemList is PLVITEM's array pointer.
// array count is colCount, that is inserted by user.
#if 0
		+-----------+-----------+-----------+-----------+-----------+-----------+
header	| Column0	| Column1   | Column2   | Column3   | Colmun4   |           |
		+-----------+-----------+-----------+-----------+-----------+-----------+
index-9 |AAAA		  BBBB		  CCCC		 DDDD		 EEEE					|
		|-----------------------------------------------------------------------|
		|																		|
		|-----------------------------------------------------------------------|
		|
in this case to draw top line of report view, PadListView  call report view's call back function 
like this.

LPARAM	lParam	 = user defined data.
INT		index	 = 9;
INT		colCount = 5;
// create 
LPPLVITEM lpPlvItem = (LPPLVITEM)MemAlloc(sizeof(PLVITEM)* colCount); 
ZeroMemory(lpPlvItem, sizeof(PLVITEM)*colCount);

(*lpfnCallback)(lParam,			//user defined data.
				index,			//line index,
				colCount,		//column count,
				lpPlvItem);		//display item data array.

in your call back function, you can specify data like this.

INT WINAPI UserReportViewCallback(LPARAM lParam, INT index, INT colCount, LPPLVITEM lpPlvItemList)
{
	// get line data with index.
	UserGetLineDataWithIndex(index, &someStructure);
	for(i = 0; i < colCount, i++) {
		switch(i) { 
		case 0: // first column data.
			lpPlvItem[i].fmt = PLVFMT_TEXT; // or PLVFMT_BITMAP.
			lpPlvItem[i].lpwst = someStructure.lpwstr[i];
			break;
		case 1: // second column data.
			lpPlvItem[i].fmt = PLVFMT_TEXT;	// or PLVFMT_BITMAP.
			lpPlvItem[i].lpwst = someStructure.lpwstr[i];
			break;
			:
			:
		}
	}
	return 0;
 }
#endif
//----------------------------------------------------------------
typedef INT (WINAPI *LPFNPLVREPITEMCALLBACK)(LPARAM lParam, 
											 INT	index, 
											 INT	colCount, 
											 LPPLVITEM lpPlvItemList);


//----------------------------------------------------------------
// PadListView Notify code, data
// Notify message will be send to PadListView's parent window.
// user can specify their own Message Id when it created.
// see PadListView_CreateWindow(). 
// Notify message data is as follow's
// User Defined message.
// wID			= (INT)Window Id of PadListView.
// lpPlvInfo	= (LPPLVINFO)lParam. notify Info structure data pointer
//----------------------------------------------------------------
#define PLVN_ITEMPOPED				(WORD)1		//item data is poped image.
												//in icon view, all item notify come,
												//in report view, only first column.
#define PLVN_ITEMPUSHED				(WORD)2		//
#define PLVN_ITEMCLICKED			(WORD)3		//item data is clicked.
#define PLVN_ITEMDBLCLICKED			(WORD)4		//item data is double clicked
#define PLVN_ITEMCOLUMNCLICKED		(WORD)5		//not item but column is clicked(only in report view)
#define PLVN_ITEMCOLUMNDBLCLICKED	(WORD)6		//not item is column is clicked(only in report view)

#define PLVN_R_ITEMCLICKED			(WORD)7		//item data is clicked.
#define PLVN_R_ITEMDBLCLICKED		(WORD)8		//item data is double clicked
#define PLVN_R_ITEMCOLUMNCLICKED	(WORD)9		//not item but column is clicked(only in report view)
#define PLVN_R_ITEMCOLUMNDBLCLICKED	(WORD)10	//not item is column is clicked(only in report view)
#define PLVN_HDCOLUMNCLICKED		(WORD)20	//in Report view, header clicked.
												//in this case PLVINFO's colIndex is valid.
#define PLVN_VSCROLLED				(WORD)30	//970810: new.
#ifdef UNDER_CE // Windows CE used ButtonDown/Up Event for ToolTip
#define PLVN_ITEMDOWN				(WORD)41	//item data is downed.
#define PLVN_ITEMUP					(WORD)42	//item data is upped.
#endif // UNDER_CE

typedef struct tagPLVINFO {
	INT		code;		//PLVN_XXXX	
	INT		index;		//selected, or on item's index. it is same as wParam data.
	POINT	pt;			//mouse point in Pad listview client area
	RECT	itemRect;	//item's rectangle, 
	INT		colIndex;	//if style is report view,  column index is specifed.
	RECT	colItemRect;//if style is report view column rectangle is specified.
}PLVINFO, *LPPLVINFO;

//////////////////////////////////////////////////////////////////
// Function : PadListView_CreateWindow
// Type     : HWND
// Purpose  : Create PadListView control window.
// Args     : 
//          : HINSTANCE hInst		//instance handle
//          : HWND hwndParent		//Parent window handle 
//			: INT wID				//ChildWindow's Identifier.
//          : INT x					//horizontal position of window 
//          : INT y					//vertical position of window
//          : INT width				//window width
//          : INT height			//window height
//          : UINT uNotifyMsg		//notify message. it should be Greater than WM_USER
// Return	: PadListView's window handle
//////////////////////////////////////////////////////////////////
extern HWND WINAPI PadListView_CreateWindow(HINSTANCE hInst, 
									 HWND hwndParent, 
									 INT wID, 
									 INT x, 
									 INT y, 
									 INT width, 
									 INT height, 
									 UINT uNotifyMsg);

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetItemCount
// Type     : INT
// Purpose  : Get item count that was specified by user.
// Args     : 
//          : HWND hwnd 
// Return   : item count.(0<=)
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_GetItemCount(HWND hwnd);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetItemCount
// Type     : INT
// Purpose  : Set total Item's count to PadListView.
//			: it effect's scroll bar.
// Args     : 
//          : HWND hwnd 
//          : INT itemCount 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetItemCount(HWND hwnd, INT itemCount);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetTopIndex
// Type     : INT
// Purpose  : Set top index. Top index is left-top corner data(ICON VIEW)
//			: or top line(REPORT VIEW). index is ZERO-BASED. If top index is set as 10, 
//			: PadListView display index 10's item at left-top or top in client area.
//			: It means scroll bar is automatically scrolled.
//			: In ICON VIEW, PadListView re-calc top index. because, 
//			: top index should be Column data count * N.
//			: ICONV VIEW calc Column count from client width and item width.
//			: 100 item is set to PadListView, column count is 10,
//			: if user set top index as 5, it is re-calc to 0.
//			: if user set top index as 47, it is re-calc to 40.
// Args     : 
//          : HWND hwnd 
//          : INT indexTop 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetTopIndex(HWND hwnd, INT indexTop);

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetTopIndex
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : Top item index.
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_GetTopIndex(HWND hwnd);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetIconItemCallback
// Type     : INT
// Purpose  : Set user defined Function that gets each Item's data
//			: in ICON VIEW
//			: PadListView call this function, when redraw client area.
//			: User must manage display data with index.
// Args     : 
//          : HWND hwnd 
//          : LPARAM lParam 
//          : LPFNPLVITEMCALLBACK lpfnPlvItemCallback 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetIconItemCallback(HWND hwnd, LPARAM lParam, LPFNPLVICONITEMCALLBACK lpfnIconItemCallback);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetReportItemCallback
// Type     : INT
// Purpose  : Set user defined Function that gets each column's data
//			: in Report view.
//			: User must manage display data with index and column index.
// Args     : 
//          : HWND hwnd 
//          : LPFNPLVCOLITEMCALLBACK lpfnColItemCallback 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetReportItemCallback(HWND hwnd, LPARAM lParam, LPFNPLVREPITEMCALLBACK lpfnRepItemCallback);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetIconFont
// Type     : INT
// Purpose  : Set specifed Font for ICON View.
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName:	NULL terminated font name.
//          : INT point:			font point count. 				 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetIconFont(HWND hwnd, LPTSTR lpstrFontName, INT point);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetReportFont
// Type     : INT
// Purpose  : Set specifed Font for REPORT VIEW.
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName 
//          : INT point 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetReportFont(HWND hwnd, LPTSTR lpstrFontName, INT point);

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetStyle
// Type     : INT
// Purpose  : return current PadListView's style
// Args     : 
//          : HWND hwnd 
// Return   : PLVSTYLE_ICON or PLVSTYLE_REPORT
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_GetStyle(HWND hwnd);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetStyle
// Type     : INT
// Purpose  : set the PadListView's style.
//			  style is PLVSTYLE_LIST or PLVSTYLE_REPORT
// Args     : 
//          : HWND hwnd 
//          : INT style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetStyle(HWND hwnd, INT style);


//////////////////////////////////////////////////////////////////
// Function : PadListView_Update
// Type     : INT
// Purpose  : Repaint PadListView.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_Update(HWND hwnd);

//////////////////////////////////////////////////////////////////
// Function : PadListView_InsertColumn
// Type     : INT
// Purpose  : Set header control's column data.
//			: most of feature is same as LVM_INSERTCOLUMN message.
// Args     : 
//          : HWND hwnd 
//          : INT index 
//          : PLV_COLUMN * lpPlvCol 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_InsertColumn(HWND hwnd, INT index, PLV_COLUMN *lpPlvCol);
//extern INT  WINAPI PadListView_DeleteColumn(HWND hwnd, INT index);


//////////////////////////////////////////////////////////////////
// Function : PadListView_SetExplanationText
// Type     : INT
// Purpose  : set the PadListView's text .
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpText 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetExplanationText(HWND hwnd, LPSTR lpText);

extern INT  WINAPI PadListView_SetExplanationTextW(HWND hwnd, LPWSTR lpText);
//////////////////////////////////////////////////////////////////
// Function : PadListView_SetCurSel
// Type     : INT
// Purpose  : set cur selection. Move cursor to specified index.
//			:
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpText 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT WINAPI PadListView_SetCurSel(HWND hwnd, INT index);

extern INT WINAPI PadListView_SetExtendStyle(HWND hwnd, INT style);

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetWidthByColumn
// Type     : INT WINAPI
// Purpose  : Calc PLV's window width by specified Column count
//			: This is PLVS_ICONVIEW style only.
// Args     : 
//          : HWND hwnd		PadListView window handle
//          : INT col		column count
// Return   : width by pixel.
// DATE     : 971120
//////////////////////////////////////////////////////////////////
extern INT WINAPI PadListView_GetWidthByColumn(HWND hwnd, INT col);

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetHeightByRow
// Type     : INT WINAPI
// Purpose  : Calc PLV's window height
//			  by specified Row count.
//			  This is PLVS_ICONVIEW style only.
// Args     : 
//          : HWND hwnd		PLV's window handle
//          : INT row		row count
// Return   : height in pixel
// DATE     : 971120
//////////////////////////////////////////////////////////////////
extern INT WINAPI PadListView_GetHeightByRow(HWND hwnd, INT row);

//////////////////////////////////////////////////////////////////
// Function	:	PadListView_SetHeaderFont
// Type		:	INT WINAPI 
// Purpose	:	
// Args		:	
//			:	HWND	hwnd	
//			:	LPSTR	lpstrFontName	
// Return	:	
// DATE		:	Tue Jul 28 08:58:06 1998
// Histroy	:	
//////////////////////////////////////////////////////////////////
extern INT WINAPI PadListView_SetHeaderFont(HWND hwnd, LPTSTR lpstrFontName);

//////////////////////////////////////////////////////////////////
// Function	:	PadListView_SetCodePage
// Type		:	INT WINAPI
// Purpose	:	
// Args		:	
//			:	HWND	hwnd	
//			:	INT	codePage	
// Return	:	
// DATE		:	Tue Jul 28 08:59:35 1998
// Histroy	:	
//////////////////////////////////////////////////////////////////
extern INT WINAPI PadListView_SetCodePage(HWND hwnd, INT codePage);


extern INT WINAPI PadListView_SetIconFontEx(HWND  hwnd,
											LPTSTR lpstrFontName,
											INT   charSet,
											INT    point);

extern INT WINAPI PadListView_SetReportFontEx(HWND	 hwnd,
											  LPTSTR lpstrFontName,
											  INT   charSet,
											  INT	 point);

#ifdef UNDER_CE // In Windows CE, all window classes are process global.
extern BOOL PadListView_UnregisterClass(HINSTANCE hInst);
#endif // UNDER_CE

#endif //_PAD_LIST_VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\ivmisc.cpp ===
//////////////////////////////////////////////////////////////////
// File     : ivmisc.cpp
// Purpose  : PadListView control's ICON View function.
//			: Name is ICON View but it does not use ICON
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "plv_.h"
#include "plv.h"
#include "dbg.h"
#include "ivmisc.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

inline INT RECT_GetWidth(LPRECT lpRc)
{
	return lpRc->right - lpRc->left;
}

inline INT RECT_GetHeight(LPRECT lpRc)
{
	return lpRc->bottom - lpRc->top;
}

INT IV_GetItemWidth(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nItemWidth;
}

INT IV_GetItemHeight(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nItemHeight;
}


INT IV_GetXMargin(HWND hwnd)
{
	//return XMARGIN;
	return 0;
	Unref(hwnd);
}

INT IV_GetYMargin(HWND hwnd)
{
	//return YMARGIN;
	return 0;
	Unref(hwnd);
}

INT IV_GetDispWidth(HWND hwnd)
{
	return IV_GetWidth(hwnd) - IV_GetXMargin(hwnd)*2;
}

INT IV_GetDispHeight(HWND hwnd)
{
	return IV_GetHeight(hwnd) - IV_GetYMargin(hwnd)*2;
}

INT IV_GetWidth(HWND hwnd)
{
	RECT rc;
	GetClientRect(hwnd, &rc);
	return RECT_GetWidth(&rc);
}

INT IV_GetHeight(HWND hwnd)
{
	RECT rc;
	GetClientRect(hwnd, &rc);
	return RECT_GetHeight(&rc);
}

INT IV_GetRow(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);

	return IV_GetDispHeight(hwnd)/lpPlv->nItemHeight;
}

INT IV_GetCol(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return IV_GetDispWidth(hwnd) / lpPlv->nItemWidth;
}

INT IV_GetRowColumn(HWND hwnd, INT *pRow, INT *pCol)
{
	*pRow = IV_GetRow(hwnd);
	*pCol = IV_GetCol(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : IV_GetMaxLine
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IV_GetMaxLine(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	INT nCol = IV_GetCol(hwnd);
	if(nCol <= 0) {
		return 0;
	} 
	if(lpPlv->iItemCount > 0) {
		return (lpPlv->iItemCount - 1)/nCol + 1;
	}
	else {
		return 0;
	}
}

//////////////////////////////////////////////////////////////////
// Function : IV_IndexFromPoint
// Type     : INT
// Purpose  : Get item index from PadListView point
// Args     : 
//          : LPPLVDATA lpPlvData 
//          : POINT pt // position of pad listview client.
// Return   : return pt's item index. if -1 error.
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IV_GetInfoFromPoint(LPPLVDATA lpPlvData, POINT pt, LPPLVINFO lpPlvInfo)
{
	INT nRow = IV_GetRow(lpPlvData->hwndSelf);
	INT nCol = IV_GetCol(lpPlvData->hwndSelf);
	if(nCol <= 0) {
		return -1;
	}
	INT nMetricsCount;
	nMetricsCount = (nRow+1) * nCol;
	INT i, j;
	INT x, y;
	RECT rcChar, rc;

	INT nItemWidth  = IV_GetItemWidth(lpPlvData->hwndSelf);
	INT nItemHeight = IV_GetItemHeight(lpPlvData->hwndSelf);

	GetClientRect(lpPlvData->hwndSelf, &rc);
	for(i = 0, j = lpPlvData->iCurIconTopIndex; 
		i < nMetricsCount && j < lpPlvData->iItemCount;
		i++, j++) {
		x = IV_GetXMargin(lpPlvData->hwndSelf) + nItemWidth  * (i % nCol);
		y = IV_GetYMargin(lpPlvData->hwndSelf) + nItemHeight * (i / nCol);
		rcChar.left  = rc.left + x;
		rcChar.top   = rc.top  + y;
		rcChar.right = rcChar.left + nItemWidth;
		rcChar.bottom= rcChar.top  + nItemHeight;
		if(PtInRect(&rcChar, pt)) {
			if(lpPlvInfo) {
				ZeroMemory(lpPlvInfo, sizeof(PLVINFO));
				lpPlvInfo->code  = 0; // don't know at this time.
				lpPlvInfo->index = j;
				lpPlvInfo->pt	 = pt;
				lpPlvInfo->itemRect = rcChar;
			}
			return j;
		}
	}
	return -1;
}

//////////////////////////////////////////////////////////////////
// Function : IV_GetCurScrollPos
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 970707 to use icon original pos (nCurIconScrollPos)
//////////////////////////////////////////////////////////////////
INT IV_GetCurScrollPos(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nCurIconScrollPos;
}

INT IV_SetCurScrollPos(HWND hwnd, INT nPos)
{
	static SCROLLINFO scrInfo;
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);

	INT nRow = IV_GetRow(hwnd);
	INT nCol = IV_GetCol(hwnd);
	INT nMax = IV_GetMaxLine(hwnd);

	Dbg(("nPos[%d] nRow[%d] nCol[%d] nMax[%d]\n", nPos, nRow, nCol, nMax));
	lpPlv->nCurIconScrollPos = nPos;

	//----------------------------------------------------------------
	//important:
	//calc new cur top index
	//----------------------------------------------------------------
	lpPlv->iCurIconTopIndex = nCol * nPos; //changed 970707
	
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= 0;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nRow;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;


	//In normal case,  
	//if (scrInfo.nMax - scrInfo.nMin + 1) <= scrInfo.nPage, 
	// scroll bar is hidden. to prevent it,
	// in this case, set proper page, and DISABLE scrollbar.
	// Now we can show scroll bar always
	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	//970810 toshiak. send scrolled notify.
	static PLVINFO plvInfo;
	ZeroMemory(&plvInfo, sizeof(plvInfo));
	plvInfo.code = PLVN_VSCROLLED;
	SendMessage(GetParent(lpPlv->hwndSelf), 
				lpPlv->uMsg,
				(WPARAM)0,
				(LPARAM)&plvInfo);
	return nPos;
}

INT IV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= nMin;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nPage;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	return 0;
} 

INT IV_GetScrollTrackPos(HWND hwnd)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_ALL;
	GetScrollInfo(hwnd, SB_VERT, &scrInfo);
	return scrInfo.nTrackPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvproc.h ===
#ifndef _PLV_PROC_H_
#define _PLV_PROC_H_
/* plvproc.cpp */
extern LRESULT CALLBACK PlvWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif //_PLV_PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plv.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>

#include "plv.h"
#include "plv_.h"
#include "plvproc.h"
#include "dbg.h"
#include "strutil.h"
#include "repview.h"
#include "iconview.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE
#ifdef MSAA
#pragma message("->plv.cpp:MSAA supported.")
#include "accplv.h"
#include "ivmisc.h"
#include "rvmisc.h"
#endif // MSAA
#ifdef UNDER_CE
	#ifdef FE_JAPANESE
		#define MS_MINCHO_J TEXT("\xff2d\xff33 \x660e\x671d") // lr  
		#define MS_GOTHIC_J TEXT("\xff2d\xff33 \x30b4\x30b7\x30c3\x30af") // lr SVbN 
	#elif FE_KOREAN
		#define GULIM_KO  TEXT("\xad74\xb9bc") // Gulim
		#define BATANG_KO TEXT("\xbc14\xd0d5") // Batang
	#endif	
#else // UNDER_CE
	#ifdef FE_KOREAN
		#define GULIM_KO  "\xb1\xbc\xb8\xb2" // Gulim
		#define BATANG_KO "\xb9\xd9\xc5\xc1" // Batang
	#endif	
#endif

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

extern LPPLVDATA PLV_Initialize(VOID);
extern VOID PLV_Destroy(LPPLVDATA lpPlv);
extern INT PLV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos);
extern INT PLV_GetScrollTrackPos(HWND hwnd);

#ifdef UNDER_CE // In Windows CE, all window classes are process global.
static LPCTSTR MakeClassName(HINSTANCE hInst, LPTSTR lpszBuf)
{
	// make module unique name
	TCHAR szFileName[MAX_PATH];
	GetModuleFileName(hInst, szFileName, MAX_PATH);
	LPTSTR lpszFName = _tcsrchr(szFileName, TEXT('\\'));
	if(lpszFName) *lpszFName = TEXT('_');
	StringCchCopy(lpszBuf, MAX_PATH, WC_PADLISTVIEW);
	StringCchCat(lpszBuf, MAX_PATH, lpszFName);

	return lpszBuf;
}

BOOL PadListView_UnregisterClass(HINSTANCE hInst)
{
	TCHAR szClassName[MAX_PATH];
	return UnregisterClass(MakeClassName(hInst, szClassName), hInst);
}
#endif // UNDER_CE

//----------------------------------------------------------------
// Public API Declare
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function : PadListView_RegisterClass
// Type     : static ATOM
// Purpose  : 
// Args     : 
//          : HINSTANCE hInst 
//          : LPSTR lpstrClass 
//          : WNDPROC lpfnWndProc 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
#ifndef UNDER_CE
static BOOL PadListView_RegisterClass(HINSTANCE hInst, LPSTR lpstrClass, WNDPROC lpfnWndProc)
#else // UNDER_CE
static BOOL PadListView_RegisterClass(HINSTANCE hInst, LPTSTR lpstrClass, WNDPROC lpfnWndProc)
#endif // UNDER_CE
{
	ATOM ret;
#ifndef UNDER_CE // Windows CE does not support EX
	static WNDCLASSEX  wc;
#else // UNDER_CE
	WNDCLASS  wc;
#endif // UNDER_CE

	//----------------------------------------------------------------
	//check specified class is already exist or not
	//----------------------------------------------------------------
#ifndef UNDER_CE // Windows CE does not support EX
	if(GetClassInfoEx(hInst, lpstrClass, &wc)){
#else // UNDER_CE
	if(GetClassInfo(hInst, lpstrClass, &wc)){
#endif // UNDER_CE
		//lpstrClass is already registerd.
		return TRUE;
	}
	ZeroMemory(&wc, sizeof(wc));
#ifndef UNDER_CE // Windows CE does not support EX
	wc.cbSize			= sizeof(wc);
#endif // UNDER_CE
	wc.style			= CS_HREDRAW | CS_VREDRAW;	 /* Class style(s). */
	wc.lpfnWndProc		= (WNDPROC)lpfnWndProc;
	wc.cbClsExtra		= 0;						/* No per-class extra data.*/
	wc.cbWndExtra		= sizeof(LPVOID);			/* No per-window extra data.		  */
	wc.hInstance		= hInst;					/* Application that owns the class.	  */
	wc.hIcon			= NULL; //LoadIcon(hInstance, MAKEINTRESOURCE(SCROLL32_ICON));
	wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
	//wc.hbrBackground	= (HBRUSH)(COLOR_3DFACE+1);
	//wc.hbrBackground	= (HBRUSH)(COLOR_3DFACE+1);
	//wc.hbrBackground	= GetStockObject(WHITE_BRUSH); 
	wc.lpszMenuName		= NULL; //g_szClass;		/* Name of menu resource in .RC file. */
	wc.lpszClassName	= lpstrClass;				/* Name used in call to CreateWindow. */
#ifndef UNDER_CE // Windows CE does not support EX
	wc.hIconSm = NULL;
	ret = RegisterClassEx(&wc);
#else // UNDER_CE
	ret = RegisterClass(&wc);
#endif // UNDER_CE
	return ret ? TRUE: FALSE;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_CreateWindow
// Type     : HWND
// Purpose  : 
// Args     : 
//          : HINSTANCE hInst 
//          : HWND hwndParent 
//          : INT x 
//          : INT y 
//          : INT width 
//          : INT height 
//          : UINT uNotifyMsg 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HWND WINAPI PadListView_CreateWindow(HINSTANCE	hInst,
							  HWND		hwndParent,
							  INT		wID,
							  INT		x,
							  INT		y,
							  INT		width,
							  INT		height,
							  UINT		uNotifyMsg)
{
	HWND hwnd;	
#ifndef UNDER_CE // In Windows CE, all window classes are process global.
	BOOL ret = PadListView_RegisterClass(hInst, WC_PADLISTVIEW, PlvWndProc);
#else // UNDER_CE
	TCHAR szClassName[MAX_PATH];
	MakeClassName(hInst, szClassName);
	BOOL ret = PadListView_RegisterClass(hInst, szClassName, PlvWndProc);
#endif // UNDER_CE
	if(!ret) {
		Dbg(("Failed to Regiset class[%s]\n", WC_PADLISTVIEW));
		return NULL;
	}

	LPPLVDATA lpPlvData = PLV_Initialize();
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return NULL;
	}
	lpPlvData->hInst = hInst;
	lpPlvData->uMsg  = uNotifyMsg;
	hwnd = CreateWindowEx(WS_EX_CLIENTEDGE,
#ifndef UNDER_CE // All CE window class is process global.
						  WC_PADLISTVIEW,
						  WC_PADLISTVIEW,
#else // UNDER_CE
						  szClassName,
						  szClassName,
#endif // UNDER_CE
						  WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
						  x, y,
						  width,
						  height,
						  hwndParent,
						  (HMENU)(UINT_PTR)wID,
						  hInst,
						  (LPVOID)lpPlvData);
	if(!hwnd) {
		Dbg(("Create Window Failed \n"));
		return NULL;
	}
	return hwnd;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetItemCount
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_GetItemCount(HWND hwnd)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	return lpPlvData->iItemCount;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetItemCount
// Type     : INT
// Purpose  : Set total Item's count to PadListView.
//			: it effect's scroll bar.
// Args     : 
//          : HWND hwnd 
//          : INT itemCount 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetItemCount(HWND hwnd, INT itemCount)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_SetItemCount(lpPlvData, itemCount, TRUE);
		RepView_SetItemCount(lpPlvData, itemCount, FALSE);
	}
	else if(lpPlvData->dwStyle == PLVSTYLE_REPORT) {
		IconView_SetItemCount(lpPlvData, itemCount, FALSE);
		RepView_SetItemCount(lpPlvData, itemCount, TRUE);
	}
	PadListView_Update(hwnd);
	return 0;
	Unref(itemCount);
}


//////////////////////////////////////////////////////////////////
// Function : PadListView_SetExplanationText
// Type     : INT
// Purpose  : set the PadListView's text .
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpText 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetExplanationText(HWND hwnd, LPSTR lpText)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	lpPlvData->lpText = lpText;			// lpText must point to a static data
	PadListView_Update(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetExplanationTextW
// Type     : INT
// Purpose  : set the PadListView's text .
// Args     : 
//          : HWND hwnd 
//          : LPWSTR lpText 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetExplanationTextW(HWND hwnd, LPWSTR lpwText)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	lpPlvData->lpwText = lpwText;			// lpText must point to a static data
	PadListView_Update(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetTopIndex
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : INT indexTop 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetTopIndex(HWND hwnd, INT indexTop)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		return IconView_SetTopIndex(lpPlvData, indexTop);
	}
	else if(lpPlvData->dwStyle == PLVSTYLE_REPORT) {
		return RepView_SetTopIndex(lpPlvData, indexTop);
	}
	else {
		Dbg(("Internal ERROR\n"));
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetTopIndex
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_GetTopIndex(HWND hwnd)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		return lpPlvData->iCurIconTopIndex;
	}
	else {
		return lpPlvData->iCurTopIndex;
	}
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetIconItemCallback
// Type     : INT
// Purpose  : Set user defined Function that gets each Item's string
// Args     : 
//          : HWND hwnd 
//          : LPARAM lParam 
//          : LPFNPLVITEMCALLBACK lpfnPlvItemCallback 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetIconItemCallback(HWND hwnd, LPARAM lParam, LPFNPLVICONITEMCALLBACK lpfnPlvIconItemCallback)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	lpPlvData->iconItemCallbacklParam   = lParam;
	lpPlvData->lpfnPlvIconItemCallback  = lpfnPlvIconItemCallback;
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetReportItemCallback
// Type     : INT
// Purpose  : Set user defined Function that gets each column's string 
//			: in Report view.
// Args     : 
//          : HWND hwnd 
//          : LPFNPLVCOLITEMCALLBACK lpfnColItemCallback 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetReportItemCallback(HWND hwnd, LPARAM lParam, LPFNPLVREPITEMCALLBACK lpfnPlvRepItemCallback)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	lpPlvData->repItemCallbacklParam  = lParam;
	lpPlvData->lpfnPlvRepItemCallback = lpfnPlvRepItemCallback;
	return 0;
}


typedef struct tagFONTINFO {
	LPTSTR		lpstrFontName;
	BOOL		fFound;
	LPLOGFONT	lpLogFont;
}FONTINFO, *LPFONTINFO;

static INT CALLBACK EnumFontFamProc(ENUMLOGFONT		*lpElf,
									NEWTEXTMETRIC	*lpNtm,
									INT				iFontType,
									LPARAM			lParam)
{
	//Dbg(("EnumFontFamProc font[%s]\n", lpElf->elfLogFont.lfFaceName));
#ifndef UNDER_CE // always Unicode
	if(0 == StrcmpA(lpElf->elfLogFont.lfFaceName, ((FONTINFO *)lParam)->lpstrFontName)) {
#else // UNDER_CE
	if(0 == lstrcmp(lpElf->elfLogFont.lfFaceName, ((FONTINFO *)lParam)->lpstrFontName)) {
#endif // UNDER_CE
		*((LPFONTINFO)lParam)->lpLogFont = lpElf->elfLogFont;
		((LPFONTINFO)lParam)->fFound  = TRUE;
		return 0;
	}
	return 1;	
	Unref(lpNtm);
	Unref(iFontType);
}

static INT GetLogFont(HDC hDC, LPTSTR lpstrFaceName, LOGFONT *plf)
{
	static FONTINFO fontInfo;
	if(!lpstrFaceName) {
		Dbg(("GetLogFont Error lpstrFaceName is NULL\n"));
		return -1;
	}
	if(lstrlen(lpstrFaceName) >= LF_FACESIZE) {
		Dbg(("GetLogFont Error length invalid\n"));
		return -1;
	}
	if(!plf) {
		Dbg(("GetLogFont Error plf is NULL\n"));
		return -1;
	}
	ZeroMemory(&fontInfo, sizeof(fontInfo));
	fontInfo.lpstrFontName = lpstrFaceName;
	fontInfo.lpLogFont	   = plf;
	EnumFontFamilies(hDC, NULL, (FONTENUMPROC)EnumFontFamProc, (LPARAM)&fontInfo);
	if(fontInfo.fFound) {
		return 0;
	}
	else {
		return -1;
	}
}

typedef struct tagFONTINFOEX {
	LPTSTR		lpstrFontName;
	INT			charSet;
	BOOL		fFound;
	LPLOGFONT	lpLogFont;
}FONTINFOEX, *LPFONTINFOEX;

static INT CALLBACK EnumFontFamProcEx(ENUMLOGFONT	*lpElf,
									  NEWTEXTMETRIC	*lpNtm,
									  INT				iFontType,
									  LPARAM			lParam)
{
	//Dbg(("EnumFontFamProc font[%s]\n", lpElf->elfLogFont.lfFaceName));
	if(0 == StrcmpA(lpElf->elfLogFont.lfFaceName, ((FONTINFOEX *)lParam)->lpstrFontName)) {
		if((BYTE)((FONTINFOEX *)lParam)->charSet == lpElf->elfLogFont.lfCharSet) {
			*((LPFONTINFOEX)lParam)->lpLogFont = lpElf->elfLogFont;
			((LPFONTINFOEX)lParam)->fFound  = TRUE;
			return 0;
		}
	}
	return 1;	
	Unref(lpNtm);
	Unref(iFontType);
}

static INT GetLogFontEx(HDC		hDC,
						LPTSTR	lpstrFaceName,
						INT		charSet,
						LOGFONT *plf)
{
	Dbg(("!!!!!! GetLogFont charSet[%d]\n", charSet));
	static FONTINFOEX fontInfo;
	if(!lpstrFaceName) {
		Dbg(("GetLogFont Error lpstrFaceName is NULL\n"));
		return -1;
	}
	if(lstrlen(lpstrFaceName) >= LF_FACESIZE) {
		Dbg(("GetLogFont Error length invalid\n"));
		return -1;
	}
	if(!plf) {
		Dbg(("GetLogFont Error plf is NULL\n"));
		return -1;
	}
	ZeroMemory(&fontInfo, sizeof(fontInfo));
	fontInfo.lpstrFontName = lpstrFaceName;
	fontInfo.charSet	   = charSet;
	fontInfo.lpLogFont	   = plf;
	static LOGFONT logFont;
	ZeroMemory(&logFont, sizeof(logFont));
	logFont.lfCharSet = (BYTE)charSet,
#ifndef UNDER_CE
	StrcpyA(logFont.lfFaceName, lpstrFaceName);
#else // UNDER_CE
	lstrcpy(logFont.lfFaceName, lpstrFaceName);
#endif // UNDER_CE
#ifndef UNDER_CE // Windows CE does not support EnumFontFamiliesEx
	EnumFontFamiliesEx(hDC, 
					   &logFont,
					   (FONTENUMPROC)EnumFontFamProcEx,
					   (LPARAM)&fontInfo,
					   0);
#else // UNDER_CE
	EnumFontFamilies(hDC,
					 logFont.lfFaceName,
					 (FONTENUMPROC)EnumFontFamProcEx,
					 (LPARAM)&fontInfo);
#endif // UNDER_CE
	if(fontInfo.fFound) {
		return 0;
	}
	else {
		return -1;
	}
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetIconFont
// Type     : INT
// Purpose  : Set specifed Font for ICON View.
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName 
//          : INT point 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
#define ABS(a)   (a > 0 ? a: -a)
//for do not use stack.
static TEXTMETRIC	g_tm;
static LOGFONT		g_logFont;

INT WINAPI PadListView_SetIconFont(HWND hwnd, LPTSTR lpstrFontName, INT point)
{
	Dbg(("PadListView_SetIconFont  START font[%s] point[%d]\n", lpstrFontName, point));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	if(!lpPlvData) {
		Dbg(("PadListView_SetIconFont ERROR\n"));
		return 0;
	}

	HFONT hFont;
	HDC hDC = GetDC(hwnd);
	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);

	if(-1 == GetLogFont(hDC, lpstrFontName, &g_logFont)) {
		Dbg(("GetLogFont Error [%s]\n", lpstrFontName));
#ifndef UNDER_CE
	#ifdef FE_JAPANESE
		if(0 == lstrcmp(lpstrFontName, "lr ")) {
			GetLogFont(hDC, "MS Mincho", &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, "lr SVbN")) {
			GetLogFont(hDC, "MS Gothic", &g_logFont);
		}
	#elif FE_KOREAN
		if(0 == lstrcmp(lpstrFontName, GULIM_KO)) {
			GetLogFont(hDC, "Gulim", &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, BATANG_KO)) {
			GetLogFont(hDC, "Batang", &g_logFont);
		}
	#else
		return (-1);
	#endif
#else // UNDER_CE
	#ifdef FE_JAPANESE
		if(0 == lstrcmp(lpstrFontName, MS_MINCHO_J)) {
			GetLogFont(hDC, TEXT("MS Mincho"), &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, MS_GOTHIC_J)) {
			GetLogFont(hDC, TEXT("MS Gothic"), &g_logFont);
		}
	#elif FE_KOREAN
		if(0 == lstrcmp(lpstrFontName, GULIM_KO)) {
			GetLogFont(hDC, TEXT("Gulim"), &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, BATANG_KO)) {
			GetLogFont(hDC, TEXT("Batang"), &g_logFont);
		}
	#else
		return (-1);
	#endif
#endif // UNDER_CE
	}
	ReleaseDC(hwnd, hDC);

	//----------------------------------------------------------------
	//Set new size
	//----------------------------------------------------------------
	g_logFont.lfHeight			= - (point * dpi)/72;
	g_logFont.lfWidth			= 0; // Calcurated automatically by lfHeight.

	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontIcon) {
		DeleteObject(lpPlvData->hFontIcon);
	}
	lpPlvData->iFontPointIcon = point;
	lpPlvData->hFontIcon = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nItemWidth  = ABS(g_logFont.lfHeight) + XRECT_MARGIN*2;
	lpPlvData->nItemHeight = ABS(g_logFont.lfHeight) + YRECT_MARGIN*2;
	PadListView_Update(hwnd);
	Dbg(("PadListView_SetFont END\n"));

#if 0
	HFONT hFont;
	//use global data logfont, TextMetrics
	ZeroMemory(&g_logFont,	sizeof(g_logFont));
	ZeroMemory(&g_tm,		sizeof(g_tm));

	HDC hDC = GetDC(hwnd);
	if(!hDC) {
		Dbg(("PadListView_SetIconFont ERROR\n"));
		return -1;
	}
	GetTextMetrics(hDC, &g_tm);

	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);
	ReleaseDC(hwnd, hDC);

	g_logFont.lfHeight		   = - (point * dpi)/72;
	g_logFont.lfCharSet        = DEFAULT_CHARSET; //g_tm.tmCharSet;
	g_logFont.lfPitchAndFamily = g_tm.tmPitchAndFamily;
	Dbg(("g_logFont.lfHeight         = %d\n", g_logFont.lfHeight));
	Dbg(("g_logFont.lfCharSet        = %d\n", g_logFont.lfCharSet));
	Dbg(("g_logFont.lfPitchAndFamily = %d\n", g_logFont.lfPitchAndFamily));

	StrcpyA(g_logFont.lfFaceName, lpstrFontName);
	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontIcon) {
		DeleteObject(lpPlvData->hFontIcon);
	}
	lpPlvData->iFontPointIcon = point;
	lpPlvData->hFontIcon = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nItemWidth  = ABS(g_logFont.lfHeight) + XRECT_MARGIN*2;
	lpPlvData->nItemHeight = ABS(g_logFont.lfHeight) + YRECT_MARGIN*2;
	PadListView_Update(hwnd);
	Dbg(("PadListView_SetFont END\n"));
#endif
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetReportFont
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName 
//          : INT point 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetReportFont(HWND hwnd, LPTSTR lpstrFontName, INT point)
{
	Dbg(("PadListView_SetReportFont  START\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("PadListView_SetReportFont ERROR\n"));
		return 0;
	}

	HFONT hFont;
	ZeroMemory(&g_logFont, sizeof(g_logFont));

	HDC hDC = GetDC(hwnd);
	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);
	if(-1 == GetLogFont(hDC, lpstrFontName, &g_logFont)) {
		Dbg(("GetLogFont Error [%s]\n", lpstrFontName));
#ifndef UNDER_CE
	#ifdef FE_JAPANESE
		if(0 == lstrcmp(lpstrFontName, "lr ")) {
			GetLogFont(hDC, "MS Mincho", &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, "lr SVbN")) {
			GetLogFont(hDC, "MS Gothic", &g_logFont);
		}
	#elif FE_KOREAN
		if(0 == lstrcmp(lpstrFontName, GULIM_KO)) {
			GetLogFont(hDC, "Gulim", &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, BATANG_KO)) {
			GetLogFont(hDC, "Batang", &g_logFont);
		}
	#else
		return (-1);
	#endif
#else // UNDER_CE
	#ifdef FE_JAPANESE
		if(0 == lstrcmp(lpstrFontName, MS_MINCHO_J)) {
			GetLogFont(hDC, TEXT("MS Mincho"), &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, MS_GOTHIC_J)) {
			GetLogFont(hDC, TEXT("MS Gothic"), &g_logFont);
		}
	#elif FE_KOREAN
		if(0 == lstrcmp(lpstrFontName, GULIM_KO)) {
			GetLogFont(hDC, TEXT("Gulim"), &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, BATNANG_KO)) {
			GetLogFont(hDC, TEXT("Batang"), &g_logFont);
		}
	#else
		return (-1);
	#endif
#endif // UNDER_CE
	}
	ReleaseDC(hwnd, hDC);
	g_logFont.lfHeight		   = - (point * dpi)/72;
	g_logFont.lfWidth		   = 0;

	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontRep) {
		DeleteObject(lpPlvData->hFontRep);
	}
	lpPlvData->iFontPointRep = point;
	lpPlvData->hFontRep		 = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nRepItemWidth  = ABS(g_logFont.lfHeight) + PLV_REPRECT_XMARGIN*2;
	lpPlvData->nRepItemHeight = ABS(g_logFont.lfHeight) + PLV_REPRECT_YMARGIN*2;
	PadListView_Update(hwnd);
	return 0;
#if 0
	HFONT hFont;

	HDC hDC = GetDC(hwnd);
	if(!hDC) {
		Dbg(("PadListView_SetReportFont ERROR\n"));
		return -1;
	}
	ZeroMemory(&g_tm,      sizeof(g_tm));
	GetTextMetrics(hDC, &g_tm);
	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);

	ReleaseDC(hwnd, hDC);

	ZeroMemory(&g_logFont, sizeof(g_logFont));
	g_logFont.lfHeight			= - (point * dpi)/72;
	g_logFont.lfCharSet			= DEFAULT_CHARSET; //g_tm.tmCharSet;
	g_logFont.lfPitchAndFamily	= g_tm.tmPitchAndFamily;
	Dbg(("g_logFont.lfHeight         = %d\n", g_logFont.lfHeight));
	Dbg(("g_logFont.lfCharSet        = %d\n", g_logFont.lfCharSet));
	Dbg(("g_logFont.lfPitchAndFamily = %d\n", g_logFont.lfPitchAndFamily));

	StrcpyA(g_logFont.lfFaceName, lpstrFontName);
	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontRep) {
		DeleteObject(lpPlvData->hFontRep);
	}
	lpPlvData->iFontPointRep = point;
	lpPlvData->hFontRep		 = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nRepItemWidth  = ABS(g_logFont.lfHeight) + PLV_REPRECT_XMARGIN*2;
	lpPlvData->nRepItemHeight = ABS(g_logFont.lfHeight) + PLV_REPRECT_YMARGIN*2;
	PadListView_Update(hwnd);
	Dbg(("PadListView_SetFont END\n"));
	return 0;
#endif
}

//
///
//990126:toshiaK
//////////////////////////////////////////////////////////////////
// Function : PadListView_SetIconFontEx
// Type     : INT
// Purpose  : Set specifed Font for ICON View.
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName 
//			: INT charSet
//          : INT point 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetIconFontEx(HWND hwnd,
									 LPTSTR lpstrFontName,
									 INT charSet,
									 INT point)
{
	Dbg(("PadListView_SetIconFontEx  START font[%s] point[%d]\n", lpstrFontName, point));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	if(!lpPlvData) {
		Dbg(("PadListView_SetIconFont ERROR\n"));
		return 0;
	}

	HFONT hFont;
	HDC hDC = GetDC(hwnd);
	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);
	if(-1 == GetLogFontEx(hDC, lpstrFontName, charSet, &g_logFont)) {
		ReleaseDC(hwnd, hDC);
		return -1;
	}
	ReleaseDC(hwnd, hDC);

	//----------------------------------------------------------------
	//Set new size
	//----------------------------------------------------------------
	g_logFont.lfHeight			= - (point * dpi)/72;
	g_logFont.lfWidth			= 0; // Calcurated automatically by lfHeight.

	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontIcon) {
		DeleteObject(lpPlvData->hFontIcon);
	}
	lpPlvData->iFontPointIcon = point;
	lpPlvData->hFontIcon = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nItemWidth  = ABS(g_logFont.lfHeight) + XRECT_MARGIN*2;
	lpPlvData->nItemHeight = ABS(g_logFont.lfHeight) + YRECT_MARGIN*2;
	PadListView_Update(hwnd);
	Dbg(("PadListView_SetFont END\n"));
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetReportFontEx
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName 
//			: INT charSet
//          : INT point 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetReportFontEx(HWND hwnd,
									   LPTSTR lpstrFontName,
									   INT charSet,
									   INT point)
{
	Dbg(("PadListView_SetReportFontEx  START\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("PadListView_SetReportFont ERROR\n"));
		return 0;
	}

	HFONT hFont;
	ZeroMemory(&g_logFont, sizeof(g_logFont));

	HDC hDC = GetDC(hwnd);
	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);

	if(-1 == GetLogFontEx(hDC, lpstrFontName, charSet, &g_logFont)) {
		ReleaseDC(hwnd, hDC);
		return -1;
	}
	ReleaseDC(hwnd, hDC);
	g_logFont.lfHeight		   = - (point * dpi)/72;
	g_logFont.lfWidth		   = 0;

	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontRep) {
		DeleteObject(lpPlvData->hFontRep);
	}
	lpPlvData->iFontPointRep = point;
	lpPlvData->hFontRep		 = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nRepItemWidth  = ABS(g_logFont.lfHeight) + PLV_REPRECT_XMARGIN*2;
	lpPlvData->nRepItemHeight = ABS(g_logFont.lfHeight) + PLV_REPRECT_YMARGIN*2;
	PadListView_Update(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetStyle
// Type     : INT
// Purpose  : set the PadListView's style.
//			  style is PLVSTYLE_LIST or PLVSTYLE_REPORT
// Args     : 
//          : HWND hwnd 
//          : INT style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetStyle(HWND hwnd, INT style)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("PadListView_SetStyle ERROR\n"));
		return -1;
	}
	if(style != PLVSTYLE_ICON && 
	   style != PLVSTYLE_REPORT) {
		Dbg(("Internal ERROR\n"));
		return -1;
	}
	lpPlvData->dwStyle = style;
	if(style == PLVSTYLE_ICON) {
		if(lpPlvData->hwndHeader) {
			//Hide header control
			SetWindowPos(lpPlvData->hwndHeader, NULL, 0, 0, 0, 0,
						 SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
		}
		IconView_RestoreScrollPos(lpPlvData);
	}
	else if(style == PLVSTYLE_REPORT) {
		if(lpPlvData->hwndHeader) {
			RECT rc;
			GetClientRect(lpPlvData->hwndSelf, &rc); // get PadListView's client rect
			HD_LAYOUT hdl;
			WINDOWPOS wp;
			hdl.prc = &rc;
			hdl.pwpos = &wp;
			//Calc header control window size
			if(Header_Layout(lpPlvData->hwndHeader, &hdl) == FALSE) {
				//OutputDebugString("Create Header Layout error\n");
				return NULL;
			}
			SetWindowPos(lpPlvData->hwndHeader, wp.hwndInsertAfter, wp.x, wp.y,
						 wp.cx, wp.cy, wp.flags | SWP_SHOWWINDOW);
		}
		RepView_RestoreScrollPos(lpPlvData);
	}
	PadListView_Update(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetStyle
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_GetStyle(HWND hwnd)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("PadListView_SetFont ERROR\n"));
		return -1;
	}
	return (INT)lpPlvData->dwStyle;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_Update
// Type     : INT
// Purpose  : Repaint PadListView.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_Update(HWND hwnd)
{
	InvalidateRect(hwnd, NULL, TRUE);
	UpdateWindow(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetCurSel
// Type     : INT
// Purpose  : set cur selection. Move cursor to specified index.
//			:
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpText 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetCurSel(HWND hwnd, INT index)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return -1;
	}
	switch(lpPlvData->dwStyle) {
	case PLVSTYLE_ICON:
		IconView_SetCurSel(lpPlvData, index);
		break;
	case PLVSTYLE_REPORT:
		RepView_SetCurSel(lpPlvData, index);
		break;
	default:
		break;
	}
	return 0;
}


#if 0

typedef struct _LV_COLUMNA
{
    UINT mask; 	 //LVCF_FMT, LVCF_WIDTH, LVCF_TEXT, LVCF_SUBITEM;
    int fmt;
    int cx;
    LPSTR pszText;
    int cchTextMax;
    int iSubItem;
} LV_COLUMNA;

#define HDI_WIDTH               0x0001
#define HDI_HEIGHT              HDI_WIDTH
#define HDI_TEXT                0x0002
#define HDI_FORMAT              0x0004
#define HDI_LPARAM              0x0008
#define HDI_BITMAP              0x0010

#define HDF_LEFT                0
#define HDF_RIGHT               1
#define HDF_CENTER              2
#define HDF_JUSTIFYMASK         0x0003
#define HDF_RTLREADING          4

#define LVCF_FMT                0x0001
#define LVCF_WIDTH              0x0002
#define LVCF_TEXT               0x0004
#define LVCF_SUBITEM            0x0008

#define LVCFMT_LEFT             0x0000
#define LVCFMT_RIGHT            0x0001
#define LVCFMT_CENTER           0x0002
#define LVCFMT_JUSTIFYMASK      0x0003

#endif

//////////////////////////////////////////////////////////////////
// Function : PadListView_InsertColumn
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : INT index 
//          : PLV_COLUMN * lpPlvCol 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_InsertColumn(HWND hwnd, INT index, PLV_COLUMN *lpPlvCol)
{

	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return -1;
	}

	if(!lpPlvCol) {
		Dbg(("Internal ERROR\n"));
		return -1;
	}
#ifndef UNDER_CE // always Unicode
	if(::IsWindowUnicode(lpPlvData->hwndHeader)) {
#endif // UNDER_CE
		static HD_ITEMW hdi;
#ifndef UNDER_CE // #ifndef UNICODE
		static WCHAR wchBuf[256];
#endif // UNDER_CE
		ZeroMemory(&hdi, sizeof(hdi));
		if(lpPlvCol->mask & LVCF_FMT)	{ hdi.mask |= HDI_FORMAT;	} 
		if(lpPlvCol->mask & LVCF_WIDTH) { hdi.mask |= HDI_WIDTH;	}
		if(lpPlvCol->mask & LVCF_TEXT)	{ hdi.mask |= HDI_TEXT;		}
		if(lpPlvCol->fmt & LVCFMT_LEFT)			{ hdi.fmt |= HDF_LEFT;	}
		if(lpPlvCol->fmt & LVCFMT_RIGHT)		{ hdi.fmt |= HDF_RIGHT; }
		if(lpPlvCol->fmt & LVCFMT_CENTER)		{ hdi.fmt |= HDF_CENTER;}
		if(lpPlvCol->fmt & LVCFMT_JUSTIFYMASK)	{ hdi.fmt |= HDF_JUSTIFYMASK;}
#ifndef UNDER_CE // #ifndef UNICODE
		//----------------------------------------------------------------
		//980728: for ActiveIME support. use lpPlvData->codePage to convert
		//----------------------------------------------------------------
		::MultiByteToWideChar(lpPlvData->codePage,
							  MB_PRECOMPOSED,
							  lpPlvCol->pszText, -1, 
							  (WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
		hdi.pszText    = wchBuf; //lpPlvCol->pszText;
#else // UNDER_CE
		hdi.pszText    = lpPlvCol->pszText;
#endif // UNDER_CE
		hdi.cxy        = lpPlvCol->cx;
		hdi.cchTextMax = lpPlvCol->cchTextMax;
		hdi.fmt |= HDF_OWNERDRAW; //989727: always set ownerdraw
		SendMessageW(lpPlvData->hwndHeader, HDM_INSERTITEMW, (WPARAM)index, (LPARAM)&hdi);
#ifndef UNDER_CE // always Unicode
	}
	else {
		static HD_ITEMA hdi;
		ZeroMemory(&hdi, sizeof(hdi));
		if(lpPlvCol->mask & LVCF_FMT)	{ hdi.mask |= HDI_FORMAT;	} 
		if(lpPlvCol->mask & LVCF_WIDTH) { hdi.mask |= HDI_WIDTH;	}
		if(lpPlvCol->mask & LVCF_TEXT)	{ hdi.mask |= HDI_TEXT;		}

		if(lpPlvCol->fmt & LVCFMT_LEFT)			{ hdi.fmt |= HDF_LEFT;	}
		if(lpPlvCol->fmt & LVCFMT_RIGHT)		{ hdi.fmt |= HDF_RIGHT; }
		if(lpPlvCol->fmt & LVCFMT_CENTER)		{ hdi.fmt |= HDF_CENTER;}
		if(lpPlvCol->fmt & LVCFMT_JUSTIFYMASK)	{ hdi.fmt |= HDF_JUSTIFYMASK;}

		hdi.pszText    = lpPlvCol->pszText;
		hdi.cxy        = lpPlvCol->cx;
		hdi.cchTextMax = lpPlvCol->cchTextMax;
		hdi.fmt |= HDF_OWNERDRAW; //989727: always set ownerdraw
		Header_InsertItem(lpPlvData->hwndHeader, index, &hdi);
	}
#endif // UNDER_CE
	return 0;
}


//----------------------------------------------------------------
// Private API Declaration
//----------------------------------------------------------------
LPPLVDATA PLV_Initialize(VOID)
{
	LPPLVDATA lpPlvData = (LPPLVDATA)MemAlloc(sizeof(PLVDATA));
	if(!lpPlvData) {
		Dbg(("Memory ERROR\n"));
		return (LPPLVDATA)NULL;
	}
	ZeroMemory((LPVOID)lpPlvData, sizeof(PLVDATA));
	//----------------------------------------------------------------
	//IconView, Report view Common data.
	//----------------------------------------------------------------
	lpPlvData->dwSize			= sizeof(PLVDATA);	//this data size;
	lpPlvData->dwStyle			= PLVSTYLE_ICON;	//Pad listview window style (PLVIF_XXXX)
	lpPlvData->hwndSelf			= NULL;				//Pad listview window handle.
	lpPlvData->iItemCount		= 0;				//Virtual total item Count. it effects scroll bar.
	lpPlvData->iCurTopIndex		= 0;				//In report view top line..
	lpPlvData->nCurScrollPos	= 0;				//In report view Current Scroll posision.
	lpPlvData->iCurIconTopIndex	= 0;				//In icon view top line..
	lpPlvData->nCurIconScrollPos= 0;				//In icon view Scroll posision.
	lpPlvData->uMsg				= 0;				// user notify message.
	lpPlvData->iCapture			= CAPTURE_NONE;		//is mouse captured or not.
	lpPlvData->ptCapture.x		= 0;				//LButton Down mouse point.  
	lpPlvData->ptCapture.y		= 0;				//LButton Down mouse point.  

	//----------------------------------------------------------------
	//for Icon view
	//----------------------------------------------------------------
	lpPlvData->nItemWidth		= PLVICON_DEFAULT_WIDTH;			// List(Icon like )view's whole width.
	lpPlvData->nItemHeight		= PLVICON_DEFAULT_HEIGHT;			// List(Icon like )view's whole height.
	lpPlvData->iFontPointIcon	= PLVICON_DEFAULT_FONTPOINT;		// Icon View's font point.
	lpPlvData->hFontIcon		= NULL;								// Icon View's font
	lpPlvData->iconItemCallbacklParam = (LPARAM)0;	// Callback data for LPFNPLVITEMCALLBACK
    lpPlvData->lpfnPlvIconItemCallback = NULL;		//Callback function for getting item by index.

	//----------------------------------------------------------------
	//for report view
	//----------------------------------------------------------------
	lpPlvData->hwndHeader		= NULL;							//Header control's window handle.
    lpPlvData->nRepItemWidth	= PLVREP_DEFAULT_WIDTH;			//Report view's width
    lpPlvData->nRepItemHeight	= PLVREP_DEFAULT_HEIGHT;		//Report view's height
    lpPlvData->iFontPointRep	= PLVREP_DEFAULT_FONTPOINT;		// Report View's font point.
    lpPlvData->hFontRep			= NULL;							// Report View's font
	lpPlvData->repItemCallbacklParam = (LPARAM)0;
	lpPlvData->lpfnPlvRepItemCallback = NULL;				//Callback function for getting colitem by index.
	lpPlvData->lpText = NULL;
	lpPlvData->codePage = CP_ACP;	//980727
#ifdef MSAA
	PLV_InitMSAA(lpPlvData);
#endif
	return lpPlvData;
}

VOID PLV_Destroy(LPPLVDATA lpPlv)
{
	if(lpPlv) {
#ifdef MSAA
		PLV_UninitMSAA(lpPlv);
#endif
		MemFree(lpPlv);
	}
	return;
}

INT PLV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= nMin;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nPage;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	return 0;
} 

INT PLV_GetScrollTrackPos(HWND hwnd)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_ALL;
	GetScrollInfo(hwnd, SB_VERT, &scrInfo);
	return scrInfo.nTrackPos;
}

INT WINAPI PadListView_SetExtendStyle(HWND hwnd, INT style)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	if(lpPlvData->hwndHeader) {
		INT s = (INT)GetWindowLong(lpPlvData->hwndHeader, GWL_STYLE);
		SetWindowLong(lpPlvData->hwndHeader, GWL_STYLE, (LONG)(s & ~HDS_BUTTONS));
	}
	return 0;
	Unref(style);
}


//////////////////////////////////////////////////////////////////
// Function : PadListView_GetWidthByColumn
// Type     : INT WINAPI
// Purpose  : Calc PLV's window width by specified Column count
//			: This is PLVS_ICONVIEW style only.
// Args     : 
//          : HWND hwnd		PadListView window handle
//          : INT col		column count
// Return   : width by pixel.
// DATE     : 971120
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_GetWidthByColumn(HWND hwnd, INT col)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return IconView_GetWidthByColumn(lpPlv, col);	
}


//////////////////////////////////////////////////////////////////
// Function : PadListView_GetHeightByRow
// Type     : INT WINAPI
// Purpose  : Calc PLV's window height
//			  by specified Row count.
//			  This is PLVS_ICONVIEW style only.
// Args     : 
//          : HWND hwnd		PLV's window handle
//          : INT row		row count
// Return   : height in pixel
// DATE     : 971120
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_GetHeightByRow(HWND hwnd, INT row)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return IconView_GetHeightByRow(lpPlv, row);	
}

//////////////////////////////////////////////////////////////////
// Function	:	PadListView_SetHeaderFont
// Type		:	INT WINAPI 
// Purpose	:	
// Args		:	
//			:	HWND	hwnd	
//			:	LPSTR	lpstrFontName	
// Return	:	
// DATE		:	Tue Jul 28 08:58:06 1998
// Histroy	:	
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetHeaderFont(HWND hwnd, LPTSTR lpstrFontName)
{
	Dbg(("PadListView_SetHeaderFont  START\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	INT point = 9;
	if(!lpPlvData) {
		Dbg(("PadListView_SetHeaderFont ERROR\n"));
		return 0;
	}

	HFONT hFont;
	::ZeroMemory(&g_logFont, sizeof(g_logFont));

	HDC hDC = ::GetDC(hwnd);
	INT dpi = ::GetDeviceCaps(hDC, LOGPIXELSY);
	if(-1 == GetLogFont(hDC, lpstrFontName, &g_logFont)) {
		::ReleaseDC(hwnd, hDC);
		return -1;
	}
	::ReleaseDC(hwnd, hDC);
	g_logFont.lfHeight		   = - (point * dpi)/72;
	g_logFont.lfWidth		   = 0;

	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontHeader) {
		::DeleteObject(lpPlvData->hFontHeader);
	}
	lpPlvData->hFontHeader = hFont;
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function	:	PadListView_SetCodePage
// Type		:	INT WINAPI
// Purpose	:	
// Args		:	
//			:	HWND	hwnd	
//			:	INT	codePage	
// Return	:	
// DATE		:	Tue Jul 28 08:59:35 1998
// Histroy	:	
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetCodePage(HWND hwnd, INT codePage)
{
	Dbg(("PadListView_SetCodePage  START\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(lpPlvData) {
		lpPlvData->codePage = codePage;
	}
	return 0; 
}

#ifdef MSAA
//////////////////////////////////////////////////////////////////
// Functions : MSAA Support Functions
// DATE     : 980724
//////////////////////////////////////////////////////////////////

BOOL PLV_InitMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return FALSE;
	lpPlv->bMSAAAvailable = FALSE;

	lpPlv->bCoInitialized = FALSE;
	lpPlv->hOleAcc = NULL;
	lpPlv->pfnLresultFromObject = NULL;
#ifdef NOTUSED
	lpPlv->pfnObjectFromLresult = NULL;
	lpPlv->pfnAccessibleObjectFromWindow = NULL;
	lpPlv->pfnAccessibleObjectFromPoint = NULL;
#endif
	lpPlv->pfnCreateStdAccessibleObject = NULL;
#ifdef NOTUSED
	lpPlv->pfnAccessibleChildren = NULL;
#endif
	lpPlv->hUser32 = NULL;
	lpPlv->pfnNotifyWinEvent=NULL;
	
	lpPlv->bReadyForWMGetObject=FALSE;
	lpPlv->pAccPLV = NULL;

	if(!PLV_LoadOleAccForMSAA(lpPlv))
		return FALSE;

	if(!PLV_LoadUser32ForMSAA(lpPlv)){
		PLV_UnloadOleAccForMSAA(lpPlv);
		return FALSE;
	}

	if(!PLV_CoInitialize(lpPlv)){
		PLV_UnloadUser32ForMSAA(lpPlv);
		PLV_UnloadOleAccForMSAA(lpPlv);
		return FALSE;
	}
	
	lpPlv->bMSAAAvailable = TRUE;

	return TRUE;
}

void PLV_UninitMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return;

	if(lpPlv->bMSAAAvailable){
		PLV_CoUninitialize(lpPlv);
		PLV_UnloadUser32ForMSAA(lpPlv);
		PLV_UnloadOleAccForMSAA(lpPlv);
		lpPlv->bMSAAAvailable = FALSE;
	}
}

BOOL PLV_CoInitialize(LPPLVDATA lpPlv)
{
	if(lpPlv && !lpPlv->bCoInitialized &&
	   SUCCEEDED(CoInitialize(NULL)))
		lpPlv->bCoInitialized = TRUE;

	return lpPlv->bCoInitialized;
}

void PLV_CoUninitialize(LPPLVDATA lpPlv)
{
	if(lpPlv && lpPlv->bCoInitialized){
		CoUninitialize();
		lpPlv->bCoInitialized = FALSE;
	}
}

BOOL PLV_LoadOleAccForMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return FALSE;

	lpPlv->hOleAcc=::LoadLibrary("oleacc.dll");
	if(!lpPlv->hOleAcc)
		return FALSE;

	if((lpPlv->pfnLresultFromObject
		=(LPFNLRESULTFROMOBJECT)::GetProcAddress(lpPlv->hOleAcc,"LresultFromObject"))
#ifdef NOTUSED
	   && (lpPlv->pfnObjectFromLresult
		   =(LPFNOBJECTFROMLRESULT)::GetProcAddress(lpPlv->hOleAcc,"ObjectFromLresult"))
	   && (lpPlv->pfnAccessibleObjectFromWindow
		   =(LPFNACCESSIBLEOBJECTFROMWINDOW)::GetProcAddress(lpPlv->hOleAcc,"AccessibleObjectFromWindow"))
	   && (lpPlv->pfnAccessibleObjectFromPoint
		   =(LPFNACCESSIBLEOBJECTFROMPOINT)::GetProcAddress(lpPlv->hOleAcc,"AccessibleObjectFromPoint"))
#endif
	   && (lpPlv->pfnCreateStdAccessibleObject
		   =(LPFNCREATESTDACCESSIBLEOBJECT)::GetProcAddress(lpPlv->hOleAcc,"CreateStdAccessibleObject"))
#ifdef NOTUSED
	   && (lpPlv->pfnAccessibleChildren
		   =(LPFNACCESSIBLECHILDREN)::GetProcAddress(lpPlv->hOleAcc,"CreateAccessibleChildren"))
#endif
	  )
			return TRUE;

	PLV_UnloadOleAccForMSAA(lpPlv);
	return FALSE;
}

void PLV_UnloadOleAccForMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return;

	if(lpPlv->hOleAcc){
		::FreeLibrary(lpPlv->hOleAcc);
		lpPlv->hOleAcc = NULL;
	}
	lpPlv->pfnLresultFromObject=NULL;
#ifdef NOTUSED
	lpPlv->pfnObjectFromLresult=NULL;
	lpPlv->pfnAccessibleObjectFromWindow=NULL;
	lpPlv->pfnAccessibleObjectFromPoint=NULL;
#endif
	lpPlv->pfnCreateStdAccessibleObject=NULL;
#ifdef NOTUSED
	lpPlv->pfnAccessibleChildren=NULL;
#endif
}

BOOL PLV_LoadUser32ForMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return FALSE;

	lpPlv->hUser32=::LoadLibrary("user32.dll");
	if(!lpPlv->hUser32)
		return FALSE;

	if((lpPlv->pfnNotifyWinEvent
		=(LPFNNOTIFYWINEVENT)::GetProcAddress(lpPlv->hUser32,"NotifyWinEvent")))
		return TRUE;

	PLV_UnloadUser32ForMSAA(lpPlv);
	return FALSE;
}

void PLV_UnloadUser32ForMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return;

	if(lpPlv->hUser32){
		::FreeLibrary(lpPlv->hUser32);
		lpPlv->hUser32 = NULL;
	}
	lpPlv->pfnNotifyWinEvent = NULL;
}

BOOL PLV_IsMSAAAvailable(LPPLVDATA lpPlv)
{
	return (lpPlv && lpPlv->bMSAAAvailable);
}

LRESULT PLV_LresultFromObject(LPPLVDATA lpPlv,REFIID riid, WPARAM wParam, LPUNKNOWN punk)
{
	if(lpPlv && lpPlv->pfnLresultFromObject)
		return lpPlv->pfnLresultFromObject(riid, wParam, punk);

	return (LRESULT)E_FAIL;
}

#ifdef NOTUSED
HRESULT PLV_ObjectFromLresult(LPPLVDATA lpPlv,LRESULT lResult, REFIID riid, WPARAM wParam, void** ppvObject)
{
	if(lpPlv && lpPlv->pfnObjectFromLresult)
		return lpPlv->pfnObjectFromLresult(lResult, riid, wParam, ppvObject);
	return E_FAIL;
}

HRESULT PLV_AccessibleObjectFromWindow(LPPLVDATA lpPlv,HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject)
{
	if(lpPlv && lpPlv->pfnAccessibleObjectFromWindow)
		return lpPlv->pfnAccessibleObjectFromWindow(hwnd, dwId, riid, ppvObject);
	return E_FAIL;
}

HRESULT PLV_AccessibleObjectFromPoint(LPPLVDATA lpPlv,POINT ptScreen, IAccessible ** ppacc, VARIANT* pvarChild)
{
	if(lpPlv && lpPlv->pfnAccessibleObjectFromPoint)
		return lpPlv->pfnAccessibleObjectFromPoint(ptScreen, ppacc, pvarChild);
	return E_FAIL;
}
#endif // NOTUSED

HRESULT PLV_CreateStdAccessibleObject(LPPLVDATA lpPlv,HWND hwnd, LONG idObject, REFIID riid, void** ppvObject)
{
	if(lpPlv && lpPlv->pfnCreateStdAccessibleObject)
		return lpPlv->pfnCreateStdAccessibleObject(hwnd, idObject, riid, ppvObject);
	return E_FAIL;
}

#ifdef NOTUSED
HRESULT PLV_AccessibleChildren (LPPLVDATA lpPlv,IAccessible* paccContainer, LONG iChildStart,				
								LONG cChildren, VARIANT* rgvarChildren,LONG* pcObtained)
{
	if(lpPlv && lpPlv->pfnAccessibleChildren)
		return lpPlv->pfnAccessibleChildren (paccContainer, iChildStart,cChildren,
											 rgvarChildren, pcObtained);
	return E_FAIL;
}
#endif

void PLV_NotifyWinEvent(LPPLVDATA lpPlv,DWORD event,HWND hwnd ,LONG idObject,LONG idChild)
{
	if(lpPlv && lpPlv->pfnNotifyWinEvent)
		lpPlv->pfnNotifyWinEvent(event,hwnd,idObject,idChild);
}

INT PLV_ChildIDFromPoint(LPPLVDATA lpPlv,POINT pt)
{
	if(!lpPlv)
		return -1;

	static INT		index,nCol,nWid;
	static PLVINFO	plvInfo;
	static HD_ITEM	hdItem;
	
	if(lpPlv->dwStyle == PLVSTYLE_ICON) // iconview
		index = IV_GetInfoFromPoint(lpPlv, pt, &plvInfo);
	else { // report view
		nCol = RV_GetColumn(lpPlv);
		index = RV_GetInfoFromPoint(lpPlv, pt, &plvInfo);
		if(index < 0) {
			if(pt.y > RV_GetHeaderHeight(lpPlv)) // out of header
				return -1;

			// header
			nWid = 0;
			hdItem.mask = HDI_WIDTH;
			hdItem.fmt = 0;
			for(index = 0;index<nCol;index++){
				Header_GetItem(lpPlv->hwndHeader,index,&hdItem);
				nWid += hdItem.cxy;
				if(pt.x <= nWid)
					break;
			}
		}
		else
			index = (index + 1) * nCol + plvInfo.colIndex;
	}
	
	return index + 1; // 1 origin
}

#endif // MSAA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvproc_.h ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "dispatch.h"

#ifdef MSAA
#include "plv_.h"
static LRESULT MsgGetObject			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgShowWindow		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif

static LRESULT MsgCreate			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgDestroy			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgPaint				(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgSize				(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgTimer				(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgNcMouseMove		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgMouseMove			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgLMRButtonDblClk	(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgLMRButtonDown		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgLMRButtonUp		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgCaptureChanged	(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgVScroll			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgNotify			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgCommand			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgMeasureItem		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgDrawItem			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT CmdDefault			(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl);

static MSD rgmsd[] =
{
	{ WM_CREATE,		MsgCreate		},
    { WM_DESTROY,		MsgDestroy		},
	{ WM_PAINT,			MsgPaint		},
	{ WM_NOTIFY,		MsgNotify		},
	{ WM_SIZE,			MsgSize			},
	{ WM_TIMER,			MsgTimer		},
	{ WM_NCMOUSEMOVE,	MsgNcMouseMove	},
	{ WM_MOUSEMOVE,		MsgMouseMove	},

	{ WM_LBUTTONDBLCLK,	MsgLMRButtonDblClk},
	{ WM_MBUTTONDBLCLK,	MsgLMRButtonDblClk},
	{ WM_RBUTTONDBLCLK,	MsgLMRButtonDblClk},

	{ WM_LBUTTONDOWN,	MsgLMRButtonDown},
	{ WM_MBUTTONDOWN,	MsgLMRButtonDown},
	{ WM_RBUTTONDOWN,	MsgLMRButtonDown},

	{ WM_LBUTTONUP,		MsgLMRButtonUp	},
	{ WM_MBUTTONUP,		MsgLMRButtonUp	},
	{ WM_RBUTTONUP,		MsgLMRButtonUp	},

	{ WM_CAPTURECHANGED,MsgCaptureChanged},
	{ WM_VSCROLL,		MsgVScroll		},
    { WM_NOTIFY,		MsgNotify		},
	{ WM_COMMAND,		MsgCommand		},
	{ WM_MEASUREITEM,	MsgMeasureItem	},	//for AcitveIME support
	{ WM_DRAWITEM,		MsgDrawItem		},	//for ActiveIME support	
#ifdef MSAA
	{ WM_GETOBJECT,		MsgGetObject		},
	{ WM_SHOWWINDOW,	MsgShowWindow		},
#endif
};

static MSDI msdiMain =
{
    sizeof(rgmsd) / sizeof(MSD),
    rgmsd,
	edwpWindow,
    //edwpNone, 
};

static CMD rgcmd[] =
{
	{ 0,		CmdDefault	},
};

static CMDI cmdiMain =
{
    sizeof(rgcmd) / sizeof(CMD),
    rgcmd,
    edwpWindow
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plv_.h ===
#ifndef _PLV__H_
#define _PLV__H_
#include "plv.h"

#ifdef MSAA
#include <ole2.h>
//980112 ToshiaK: VC6 has these include files.
//#include "../msaa/inc32/oleacc.h"
//#include "../msaa/inc32/winable.h"
#include <oleacc.h>
#include <winable.h>

#if(WINVER >= 0x0400)
#define WMOBJ_ID                        0x0000
#define WM_GETOBJECT                    0x003D
#endif /* WINVER >= 0x0400 */


typedef HRESULT (STDAPICALLTYPE * LPFNCOINITIALIZE)(LPVOID pvReserved);
typedef void (STDAPICALLTYPE * LPFNCOUNINITIALIZE)(void);
typedef WINABLEAPI void (WINAPI *LPFNNOTIFYWINEVENT)(DWORD,HWND,LONG,LONG);
class CAccPLV;
#endif // MSAA

#define ArrayCount(a)		(sizeof(a)/sizeof(a[0]))
#define UnrefForMsg()	UNREFERENCED_PARAMETER(hwnd);\
						UNREFERENCED_PARAMETER(uMsg);\
						UNREFERENCED_PARAMETER(wParam);\
						UNREFERENCED_PARAMETER(lParam)

#define UnrefForCmd()	UNREFERENCED_PARAMETER(hwnd);\
						UNREFERENCED_PARAMETER(wCommand);\
						UNREFERENCED_PARAMETER(wNotify);\
						UNREFERENCED_PARAMETER(hwndCtrl)

#define Unref(a)		UNREFERENCED_PARAMETER(a)

#define Unref1(a)		UNREFERENCED_PARAMETER(a)

#define Unref2(a, b)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b)

#define Unref3(a,b,c)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b);\
						UNREFERENCED_PARAMETER(c)

#define Unref4(a,b,c,d)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b);\
						UNREFERENCED_PARAMETER(c);\
						UNREFERENCED_PARAMETER(d)

//----------------------------------------------------------------
// Default Icon view's width & height
//----------------------------------------------------------------
#define WHOLE_WIDTH		40		//default
#define WHOLE_HEIGHT	40		//default
#define XMARGIN			5	
#define YMARGIN			5
#define XRECT_MARGIN	4
#define YRECT_MARGIN	4
#define PLV_REPRECT_XMARGIN			2
#define PLV_REPRECT_YMARGIN			2

#define PLV_EDGE_NONE				0
#define PLV_EDGE_SUNKEN				1
#define PLV_EDGE_RAISED				2


#define PLVICON_DEFAULT_WIDTH		40
#define PLVICON_DEFAULT_HEIGHT		40
#define PLVICON_DEFAULT_FONTPOINT	16

#define PLVREP_DEFAULT_WIDTH		100
#define PLVREP_DEFAULT_HEIGHT		20
#define PLVREP_DEFAULT_FONTPOINT	9

//----------------------------------------------------------------
//970929: for #1964. do not pop for RButtonDown. 
//LPPLVDATA->iCapture data.
//----------------------------------------------------------------
#define CAPTURE_NONE		0	
#define CAPTURE_LBUTTON		1
#define CAPTURE_MBUTTON		2
#define CAPTURE_RBUTTON		3

#if 0
This sample is Capital Letter "L, N"
                   <-nItemWidth->
                   < >  XRECT_MARGIN
      YMARGIN +  +---------------------------------------------------------------------
              +  | +------------++------------+     +
                 | | +--------+ || +--------+ |     |     
                 | | | *      | || | *    * | |     |     
                 | | | *      | || | * *  * | |nItemHeight
                 | | | *      | || | *  * * | |     |     
                 | | | ****** | || | *    * | |     |     
                 | | +--------+ || +--------+ |     |     
                 | +------------++------------+     +
                >| <--- XMARGIN
                 |
#endif


//----------------------------------------------------------------
//Pad List view internal Data structure.
//----------------------------------------------------------------
typedef struct tagPLVDATA {
	DWORD		dwSize;				//this data size;
	DWORD		dwStyle;			//Pad listview window style (PLVIF_XXXX)
	HINSTANCE	hInst;				//Instance handle.
	HWND		hwndSelf;			//Pad listview window handle.
	INT			iItemCount;			//Virtual total item Count. it effects scroll bar.
	INT			iCurTopIndex;		//In report view top line item index.
	INT			nCurScrollPos;		//In report view Current Scroll posision.
	INT			iCurIconTopIndex;	//In Icon view, top-left corner virtual index.
	INT			nCurIconScrollPos;	//In Icon view, top-left corner virtual index.
	UINT		uMsg;				//Notify message for parent window.
	INT			iCapture;			//Captured with which button(Left, Middle Right).
	POINT		ptCapture;			//LButton Down mouse point.  
	UINT		uMsgDown;			//L,M,R button down message.
	//----------------------------------------------------------------
	//for Icon view
	//----------------------------------------------------------------
	INT			nItemWidth;			// List(Icon like )view's whole width.
	INT			nItemHeight;		// List(Icon like )view's whole height.
	INT			iFontPointIcon;		// Icon View's font point.
	HFONT		hFontIcon;			// Icon View's font
	LPARAM		iconItemCallbacklParam;	// Callback data for LPFNPLVITEMCALLBACK
	LPFNPLVICONITEMCALLBACK		lpfnPlvIconItemCallback;		//Callback function for getting item by index.
	//----------------------------------------------------------------
	//for report view
	//----------------------------------------------------------------
	HWND		hwndHeader;			//Header control's window handle .
	INT			nRepItemWidth;			//Report view's width.
	INT			nRepItemHeight;			//Report view's height.
	INT			iFontPointRep;		// Report View's font point.
	HFONT		hFontRep;			// Report View's font.
	LPARAM		repItemCallbacklParam; //Callback data for LPFNPLVREPITEMCALLBACK.
	LPFNPLVREPITEMCALLBACK		lpfnPlvRepItemCallback;		//Callback function for getting colitem by index.
	//----------------------------------------------------------------
	//for Explanation Text
	//----------------------------------------------------------------
	LPSTR 	lpText;	 // pointer to an explanation text in either ICONVIEW or REPORTVIEW
	LPWSTR 	lpwText; // pointer to an explanation text in either ICONVIEW or REPORTVIEW
	UINT	codePage;			//M2W, W2M's codepage.	//980724
	HFONT	hFontHeader;		//Header control font.	//980724
#ifdef MSAA
	BOOL bMSAAAvailable;
	BOOL bCoInitialized;
	
	HINSTANCE	hOleAcc;
	LPFNLRESULTFROMOBJECT			pfnLresultFromObject;
#ifdef NOTUSED	
	LPFNOBJECTFROMLRESULT			pfnObjectFromLresult;
	LPFNACCESSIBLEOBJECTFROMWINDOW	pfnAccessibleObjectFromWindow;
	LPFNACCESSIBLEOBJECTFROMPOINT	pfnAccessibleObjectFromPoint;
#endif // NOTUSED
	LPFNCREATESTDACCESSIBLEOBJECT	pfnCreateStdAccessibleObject;
#ifdef NOTUSED
	LPFNACCESSIBLECHILDREN			pfnAccessibleChildren;
#endif // NOTUSED

	HINSTANCE	hUser32;
	LPFNNOTIFYWINEVENT	pfnNotifyWinEvent;

	BOOL	bReadyForWMGetObject;
	CAccPLV	*pAccPLV;
#endif
}PLVDATA, *LPPLVDATA;

//----------------------------------------------------------------
//TIMERID for monitoring mouse pos
//----------------------------------------------------------------
#define TIMERID_MONITOR 0x20
//////////////////////////////////////////////////////////////////
// Function : GetPlvDataFromHWND
// Type     : inline LPPLVDATA
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
inline LPPLVDATA GetPlvDataFromHWND(HWND hwnd)
{
#ifdef _WIN64
	return (LPPLVDATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	return (LPPLVDATA)GetWindowLong(hwnd, GWL_USERDATA);
#endif
}

//////////////////////////////////////////////////////////////////
// Function : SetPlvDataToHWND
// Type     : inline LONG
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : LPPLVDATA lpPlvData 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
inline LPVOID SetPlvDataToHWND(HWND hwnd, LPPLVDATA lpPlvData)
{
#ifdef _WIN64
	return (LPVOID)SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpPlvData);
#else
	return (LPVOID)SetWindowLong(hwnd, GWL_USERDATA, (LONG)lpPlvData);
#endif
}

#ifdef MSAA
BOOL PLV_InitMSAA(LPPLVDATA);
void PLV_UninitMSAA(LPPLVDATA);

BOOL PLV_CoInitialize(LPPLVDATA);
void PLV_CoUninitialize(LPPLVDATA);

BOOL PLV_LoadOleAccForMSAA(LPPLVDATA);
void PLV_UnloadOleAccForMSAA(LPPLVDATA);
BOOL PLV_LoadUser32ForMSAA(LPPLVDATA);
void PLV_UnloadUser32ForMSAA(LPPLVDATA);
BOOL PLV_IsMSAAAvailable(LPPLVDATA);
LRESULT PLV_LresultFromObject(LPPLVDATA,REFIID riid, WPARAM wParam, LPUNKNOWN punk);
#ifdef NOTUSED
HRESULT PLV_ObjectFromLresult(LPPLVDATA,LRESULT lResult, REFIID riid, WPARAM wParam, void **ppvObject);
HRESULT PLV_AccessibleObjectFromWindow(LPPLVDATA,HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject);
HRESULT PLV_AccessibleObjectFromPoint(LPPLVDATA,POINT ptScreen, IAccessible ** ppacc, VARIANT* pvarChild);
#endif

HRESULT PLV_CreateStdAccessibleObject(LPPLVDATA,HWND hwnd, LONG idObject, REFIID riid, void** ppvObject);

#ifdef NOTUSED
HRESULT PLV_AccessibleChildren (LPPLVDATA,IAccessible* paccContainer, LONG iChildStart,				
								LONG cChildren, VARIANT* rgvarChildren,LONG* pcObtained);
#endif

void PLV_NotifyWinEvent(LPPLVDATA,DWORD,HWND,LONG,LONG);

INT PLV_ChildIDFromPoint(LPPLVDATA,POINT);
#endif // MSAA

#endif //_PLV__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvproc.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "dispatch.h"
#include "plv.h"
#include "plv_.h"
#include "plvproc.h"
#include "plvproc_.h"
#include "dbg.h"
#include "iconview.h"
#include "repview.h"
#include "exgdiw.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

#ifdef MSAA
#include "accplv.h"
#endif

extern LPPLVDATA PLV_Initialize(VOID);
extern VOID PLV_Destroy(LPPLVDATA lpPlv);
extern INT PLV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos);
extern INT PLV_GetScrollTrackPos(HWND hwnd);


LRESULT CALLBACK PlvWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LRESULT hres;
	hres = DispMessage(&msdiMain, hwnd, uMsg, wParam, lParam);
	return hres;
}

////////////////////////////////////////////////////////
// Function : MsgCreate
// Type     : static LRESULT
// Purpose  : Process WM_CREATE message.
//			  Intialize PLVDATA and associate to window handle.
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
static LRESULT MsgCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = (LPPLVDATA)((LPCREATESTRUCT)lParam)->lpCreateParams;
	if(!lpPlvData) {
		return -1;		// create error
	}
	lpPlvData->hwndSelf = hwnd;
	SetPlvDataToHWND(hwnd, lpPlvData);
	//show scroll bar always
	//----------------------------------------------------------------
	// if header window is not created yet, create it.
	//----------------------------------------------------------------
	if(!lpPlvData->hwndHeader)  {
		lpPlvData->hwndHeader = RepView_CreateHeader(lpPlvData);
	}
	PLV_SetScrollInfo(hwnd, 0,0,0,0);
	return TRUE;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgPaint
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgPaint(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	//OutputDebugString("MsgPaint 1 START\n");
	DP(("MsgPaint COME\n"));
	if(!lpPlvData) {
		//OutputDebugString("MsgPaint 1 END\n");
		return 0;
	}
	DP(("MsgPaint lpPlvData->dwStyle [%d]n", lpPlvData->dwStyle));
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		//OutputDebugString("MsgPaint 1 Icon\n");
		IconView_Paint(hwnd, wParam, lParam);
	}
	else {
		//OutputDebugString("MsgPaint 1 Rep\n");
		RepView_Paint(hwnd, wParam, lParam);
	}
	DP(("MsgPaint END\n"));
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgVScroll
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgVScroll(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_VScroll(hwnd, wParam, lParam);
	}
	else {
		RepView_VScroll(hwnd, wParam, lParam);
	}
	return 0;
	UnrefForMsg();
}

////////////////////////////////////////////////////////
// Function : MsgDestroy
// Type     : static LRESULT
// Purpose  : Process WM_DESTORY message
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
static LRESULT MsgDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->hwndHeader) {
		::DestroyWindow(lpPlvData->hwndHeader);
		lpPlvData->hwndHeader = NULL;
	}
	if(lpPlvData->hFontIcon) {
		::DeleteObject(lpPlvData->hFontIcon);
		lpPlvData->hFontIcon = NULL;
	}
	if(lpPlvData->hFontRep) {
		::DeleteObject(lpPlvData->hFontRep);
		lpPlvData->hFontRep = NULL;
	}
	if(lpPlvData->hFontHeader) {
		::DeleteObject(lpPlvData->hFontHeader);
		lpPlvData->hFontHeader = NULL; 
	}
	
#ifdef MSAA
	lpPlvData->bReadyForWMGetObject = FALSE;
	if(lpPlvData->pAccPLV) {
		CoDisconnectObject((LPUNKNOWN) lpPlvData->pAccPLV, 0L);
		delete lpPlvData->pAccPLV;
		lpPlvData->pAccPLV = NULL;
		PLV_NotifyWinEvent(lpPlvData,
						   EVENT_OBJECT_DESTROY,
						   hwnd,
						   OBJID_CLIENT,
						   CHILDID_SELF);
	}
#endif

#if 1 // kwada
	PLV_Destroy(lpPlvData);
#else
	MemFree(lpPlvData);
#endif
	SetPlvDataToHWND(hwnd, (LPPLVDATA)NULL);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgSize
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgSize(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	//INT nWidth	= LOWORD(lParam);
	//INT nHeight = HIWORD(lParam);
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	RECT rc;

	Dbg(("MsgSize COME\n"));
	if(lpPlvData->hwndHeader && lpPlvData->dwStyle == PLVSTYLE_REPORT) {
		GetClientRect(lpPlvData->hwndSelf, &rc); // get PadListView's client rect
		HD_LAYOUT hdl;
		WINDOWPOS wp;
		hdl.prc = &rc;
		hdl.pwpos = &wp;
		//Calc header control window size
		if(Header_Layout(lpPlvData->hwndHeader, &hdl) == FALSE) {
			//OutputDebugString("Create Header Layout error\n");
			return NULL;
		}
		SetWindowPos(lpPlvData->hwndHeader, wp.hwndInsertAfter, wp.x, wp.y,
					 wp.cx, wp.cy, wp.flags | SWP_SHOWWINDOW);
	}
	else {
		Dbg(("Header is NULL\n"));
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_ResetScrollRange(lpPlvData);
	}
	else {
		RepView_ResetScrollRange(lpPlvData);
	}
	UpdateWindow(hwnd);
	return 0;
	UnrefForMsg();
}

static LRESULT MsgTimer(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static RECT  rc; 
	static POINT pt;
	if(wParam == TIMERID_MONITOR) {
		GetCursorPos(&pt);
		GetWindowRect(hwnd, &rc);
		if(!PtInRect(&rc, pt)) {
			KillTimer(hwnd, wParam);
			InvalidateRect(hwnd, NULL, FALSE);
		}
	}
	return 0;
	Unref(uMsg);
	Unref(lParam);
}
//////////////////////////////////////////////////////////////////
// Function : MsgLMRButtonDown
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgLMRButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_ButtonDown(hwnd, uMsg, wParam, lParam);
	}
	else {
		RepView_ButtonDown(hwnd, uMsg, wParam, lParam);
	}
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgLMRButtonDblClk
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgLMRButtonDblClk(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_ButtonDown(hwnd, uMsg, wParam, lParam);
	}
	else {
		RepView_ButtonDown(hwnd, uMsg, wParam, lParam);
	}
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgLMRButtonUp
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgLMRButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_ButtonUp(hwnd, uMsg, wParam, lParam);
	}
	else {
		RepView_ButtonUp(hwnd, uMsg, wParam, lParam);
	}
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgMouseMove
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgMouseMove(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_MouseMove(hwnd, wParam, lParam);
	}
	else {
		RepView_MouseMove(hwnd, wParam, lParam);
	}
	KillTimer(hwnd, TIMERID_MONITOR);
	SetTimer(hwnd, TIMERID_MONITOR, 100, NULL);
	return 0;
	UnrefForMsg();
}

static LRESULT MsgNcMouseMove(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgCaptureChanged
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgCaptureChanged(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
 	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if((HWND)wParam != hwnd) { // some other window captured mouse.
		lpPlvData->iCapture = CAPTURE_NONE;
	}
	return 0;
	UnrefForMsg();
}

////////////////////////////////////////////////////////
// Function : MsgNotify
// Type     : static LRESULT
// Purpose  : Process WM_NOTIFY message.
//			: currently for Tab Control window.
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
/////////////////////////////
//typedef struct tagNMHDR
//{
//    HWND  hwndFrom;
//    UINT  idFrom;
//    UINT  code;         // NM_ code
//}   NMHDR;
//typedef NMHDR FAR * LPNMHDR;
/////////////////////////////
static LRESULT MsgNotify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	INT     idCtrl = (INT)wParam;

	switch(idCtrl) {
	case HEADER_ID:
		RepView_Notify(hwnd, uMsg, wParam, lParam);
		break;
	}
	return 0; 
	UnrefForMsg();
}

static LRESULT MsgCommand(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DispCommand(&cmdiMain, hwnd, wParam, lParam);
	UnrefForMsg();
}

static LRESULT MsgMeasureItem(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return 0;
	UnrefForMsg();
}

static LRESULT MsgDrawItem(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgDrawItem START\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;
	switch(lpdis->CtlType) {
	case ODT_HEADER:
		{
			static WCHAR wchBuf[256];
#ifndef UNDER_CE // always Unicode
			if(::IsWindowUnicode(lpdis->hwndItem)) {
#endif // UNDER_CE
				HDITEMW hdItem;
				::ZeroMemory(&hdItem, sizeof(hdItem));
				hdItem.mask = HDI_TEXT | HDI_HEIGHT;
				wchBuf[0] = (WCHAR)0x00;
				hdItem.pszText     = wchBuf;
				hdItem.cchTextMax  = sizeof(wchBuf);
				::SendMessageW(lpdis->hwndItem,
							   HDM_GETITEMW,
							   (WPARAM)lpdis->itemID,
							   (LPARAM)&hdItem);
				DBGW((L"%d: %s\n", lpdis->itemID, wchBuf));
#ifndef UNDER_CE // always Unicode
			}
			else {
				HDITEMA hdItem;
				static char szBuf[256];
				::ZeroMemory(&hdItem, sizeof(hdItem));
				hdItem.mask = HDI_TEXT | HDI_HEIGHT;
				szBuf[0] = (CHAR)0x00;
				hdItem.pszText     = szBuf;
				hdItem.cchTextMax  = sizeof(szBuf);
				::SendMessageA(lpdis->hwndItem,
							   HDM_GETITEMA,
							   (WPARAM)lpdis->itemID,
							   (LPARAM)&hdItem);
				//Dbg(("%d: %s\n", lpdis->itemID, szBuf));
				MultiByteToWideChar(lpPlvData->codePage, 
									MB_PRECOMPOSED,
									szBuf, -1,
									(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
			}
#endif // UNDER_CE
			SIZE size;
			INT offsetX, offsetY;
			HFONT hFontPrev = NULL;
			if(lpPlvData->hFontHeader) {
				hFontPrev = (HFONT)::SelectObject(lpdis->hDC, lpPlvData->hFontHeader);
			}
			::ExGetTextExtentPoint32W(lpdis->hDC,
									  wchBuf,
									  lstrlenW(wchBuf),
									  &size);
			offsetX = GetSystemMetrics(SM_CXDLGFRAME);
			offsetY = (lpdis->rcItem.bottom - lpdis->rcItem.top - size.cy)/2;
			::ExExtTextOutW(lpdis->hDC,
						  lpdis->rcItem.left+offsetX,
						  lpdis->rcItem.top+offsetY,
						  ETO_CLIPPED,
						  &lpdis->rcItem,
						  wchBuf,
						  lstrlenW(wchBuf),
						  NULL);
			if(lpPlvData->hFontHeader) {
				::SelectObject(lpdis->hDC, hFontPrev);
			}
		}
		break;
	default:
		break;
	}
	return TRUE; 
	UnrefForMsg();
}

static LRESULT CmdDefault(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl)
{
	return 0;
	UnrefForCmd();
}

#ifdef MSAA
static LRESULT MsgGetObject(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	if(!PLV_IsMSAAAvailable(lpPlvData))
		return E_FAIL;

	if(!lpPlvData->bReadyForWMGetObject)
		return E_FAIL;
	
	if(OBJID_CLIENT == lParam) {
		if(!lpPlvData->pAccPLV){
			lpPlvData->pAccPLV = new CAccPLV;
			if(!lpPlvData->pAccPLV)
				return (LRESULT)E_OUTOFMEMORY;

			HRESULT hr;
			hr = lpPlvData->pAccPLV->Initialize(hwnd);
			if(FAILED(hr)){
				delete lpPlvData->pAccPLV;
				lpPlvData->pAccPLV = NULL;
				return (LRESULT)hr;
			}
			PLV_NotifyWinEvent(lpPlvData,
							   EVENT_OBJECT_CREATE,
							   hwnd,
							   OBJID_CLIENT,
							   CHILDID_SELF);
		}
		return lpPlvData->pAccPLV->LresultFromObject(wParam);
	}

	return (HRESULT)0L;
	UnrefForMsg();
}

static LRESULT MsgShowWindow(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	if(PLV_IsMSAAAvailable(lpPlvData))
	{
		if(!lpPlvData->bReadyForWMGetObject)
			lpPlvData->bReadyForWMGetObject = TRUE;
		PLV_NotifyWinEvent(lpPlvData ,
						   wParam ? EVENT_OBJECT_SHOW : EVENT_OBJECT_HIDE,
						   hwnd,
						   OBJID_CLIENT,
						   CHILDID_SELF );
	}
	return DispDefault(msdiMain.edwp, hwnd, uMsg, wParam, lParam);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\dispatch.h ===
/* dispatch.c */
#ifndef _DISPATCH_H_
#define _DISPATCH_H_

typedef LRESULT (*PFNMSG)(HWND, UINT, WPARAM, LPARAM);
typedef LRESULT (*PFNCMD)(HWND, WORD, WORD, HWND);

typedef enum{
   edwpNone,            // Do not call any default procedure.
   edwpWindow,          // Call DefWindowProc.
   edwpDialog,          // Call DefDlgProc (This should be used only for
                        // custom dialogs - standard dialog use edwpNone).
   edwpMDIChild,        // Call DefMDIChildProc.
   edwpMDIFrame         // Call DefFrameProc.
} EDWP;                // Enumeration for Default Window Procedures

typedef struct _MSD{
    UINT   uMessage;
    PFNMSG pfnmsg;
} MSD;                 // MeSsage Dispatch structure

typedef struct _MSDI{
    int  cmsd;          // Number of message dispatch structs in rgmsd
    MSD *rgmsd;         // Table of message dispatch structures
    EDWP edwp;          // Type of default window handler needed.
} MSDI, FAR *LPMSDI;   // MeSsage Dipatch Information

typedef struct _CMD{
    WORD   wCommand;
    PFNCMD pfncmd;
} CMD;                 // CoMmand Dispatch structure

typedef struct _CMDI{
    int  ccmd;          // Number of command dispatch structs in rgcmd
    CMD *rgcmd;         // Table of command dispatch structures
    EDWP edwp;          // Type of default window handler needed.
} CMDI, FAR *LPCMDI;   // CoMmand Dispatch Information

LRESULT DispMessage(LPMSDI lpmsdi, HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam);
LRESULT DispCommand(LPCMDI lpcmdi, HWND hwnd, WPARAM wparam, LPARAM lparam);
LRESULT DispDefault(EDWP edwp, HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam);

#endif // _DISPATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\rvmisc.h ===
#ifndef _RV_MISC_H_
#define _RV_MISC_H_
/* rvmisc.cpp */
extern INT RV_GetItemWidth(HWND hwnd);
extern INT RV_GetItemHeight(HWND hwnd);
extern INT RV_GetXMargin(HWND hwnd);
extern INT RV_GetYMargin(HWND hwnd);
extern INT RV_GetHeaderHeight(LPPLVDATA lpPlvData);
extern INT RV_GetDispWidth(HWND hwnd);
extern INT RV_GetDispHeight(HWND hwnd);
extern INT RV_GetWidth(HWND hwnd);
extern INT RV_GetHeight(HWND hwnd);
extern INT RV_GetRow(HWND hwnd);
extern INT RV_GetColumn(LPPLVDATA lpPlvData);
extern INT RV_GetCol(HWND hwnd);
extern INT RV_GetRowColumn(HWND hwnd, INT *pRow, INT *pCol);
extern INT RV_GetMaxLine(HWND hwnd);
extern INT RV_GetInfoFromPoint(LPPLVDATA lpPlvData, POINT pt, LPPLVINFO lpPlvInfo);
extern INT RV_DrawItem(LPPLVDATA lpPlvData, HDC hDC, HDC hDCForBmp, POINT pt, INT colIndex, LPRECT lpRect, LPPLVITEM lpPlvItem);
extern INT RV_GetCurScrollPos(HWND hwnd);
extern INT RV_SetCurScrollPos(HWND hwnd, INT nPos);
extern INT RV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos);
extern INT RV_GetScrollTrackPos(HWND hwnd);
#endif //_RV_MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\repview.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "plv_.h"
#include "plv.h"
#include "dbg.h"
#include "repview.h"
#include "rvmisc.h"
#include "exgdiw.h"
// temporary
#if 0
#include "resource.h"
#endif
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

static POSVERSIONINFO ExGetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

static BOOL ExIsWinNT(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
	return fBool;
}

//----------------------------------------------------------------
// Header control window ID 
//----------------------------------------------------------------

HWND RepView_CreateHeader(LPPLVDATA lpPlvData)
{
	if(!lpPlvData) {
		return NULL;
	}
	static RECT rc;
//	HD_ITEM hdItem;
	InitCommonControls();
	HWND hwnd;
#ifndef UNDER_CE // always Unicode
	if(ExIsWinNT()) {
#endif // UNDER_CE
		hwnd = CreateWindowExW(0,
									WC_HEADERW,
									L"",
									WS_CHILD | WS_VISIBLE | HDS_BUTTONS |HDS_HORZ, 
									0, 0, 0, 0, //rc.left, rc.top, rc.right - rc.left, 30,
									lpPlvData->hwndSelf,
									(HMENU)HEADER_ID,
									lpPlvData->hInst,
									NULL);
#ifndef UNDER_CE // always Unicode
	}
	else {
		hwnd = CreateWindowExA(0,
									WC_HEADER,
									"",
									WS_CHILD | WS_VISIBLE | HDS_BUTTONS |HDS_HORZ, 
									0, 0, 0, 0, //rc.left, rc.top, rc.right - rc.left, 30,
									lpPlvData->hwndSelf,
									(HMENU)HEADER_ID,
									lpPlvData->hInst,
									NULL);
	}
#endif // UNDER_CE
	if(hwnd == NULL) {
		//wsprintf(szBuf, "Create Header tError %d\n", GetLastError());
		//OutputDebugString(szBuf);
		//OutputDebugString("Create Header error\n");
		return NULL;
	}
	SendMessage(hwnd, 
				WM_SETFONT,
				(WPARAM)(HFONT)GetStockObject(DEFAULT_GUI_FONT),
				MAKELPARAM(FALSE, 0));

	GetClientRect(lpPlvData->hwndSelf, &rc); // get PadListView's client rect
	static HD_LAYOUT hdl;
	static WINDOWPOS wp;
	hdl.prc = &rc;
	hdl.pwpos = &wp;
	//Calc header control window size
	if(Header_Layout(hwnd, &hdl) == FALSE) {
		//OutputDebugString("Create Header Layout error\n");
		return NULL;
	}
#if 0  // test test
		HD_ITEM hdi;  // Header item.
		hdi.mask = HDI_FORMAT | HDI_WIDTH | HDI_TEXT;
		hdi.fmt  = HDF_LEFT | HDF_STRING;
		hdi.pszText = "poipoi"; //:zItemHead[i];     // The text for the item.
		hdi.cxy = 75;			         // The initial width.
		hdi.cchTextMax = lstrlen(hdi.pszText);  // The length of the string.
		Header_InsertItem(hwnd, 0, &hdi);
#endif

	SetWindowPos(hwnd, wp.hwndInsertAfter, wp.x, wp.y,
				 wp.cx, wp.cy, wp.flags | SWP_SHOWWINDOW);
				 //wp.cx, wp.cy, wp.flags | SWP_HIDEWINDOW);
	return hwnd;
}

//////////////////////////////////////////////////////////////////
// Function : RepView_RestoreScrollPos
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_RestoreScrollPos(LPPLVDATA lpPlvData)
{
	return RV_SetCurScrollPos(lpPlvData->hwndSelf, lpPlvData->nCurScrollPos);
}

//////////////////////////////////////////////////////////////////
// Function : RepView_ResetScrollPos
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_ResetScrollRange(LPPLVDATA lpPlvData)
{
	static SCROLLINFO scrInfo;
	if(!lpPlvData) {
		return 0;
	}
	HWND hwnd = lpPlvData->hwndSelf;
	INT nRow = RV_GetRow(hwnd);
	//INT nCol = RV_GetCol(hwnd);
	INT nMax = RV_GetMaxLine(hwnd);


	INT nPos = lpPlvData->nCurScrollPos;
	//lpPlv->iCurTopIndex = nPos;

	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= 0;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nRow;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	//In normal case,  
	//if (scrInfo.nMax - scrInfo.nMin + 1) <= scrInfo.nPage, 
	// scroll bar is hidden. to prevent it,
	// in this case, set proper page, and DISABLE scrollbar.
	// Now we can show scroll bar always
	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : RepView_SetItemCount
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
//          : INT itemCount 
//          : BOOL fDraw		update scroll bar or not
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_SetItemCount(LPPLVDATA lpPlvData, INT itemCount, BOOL fDraw)
{
	lpPlvData->iItemCount = itemCount;
	lpPlvData->iCurTopIndex  = 0;	//970707 ToshiaK, change curTopindex to 0
	lpPlvData->nCurScrollPos = 0;	//970707 ToshiaK, same as iCurTopIndex
	
	if(fDraw) {
		INT nMaxLine = lpPlvData->iItemCount; //RV_GetMaxLine(lpPlvData->hwndSelf);
		INT nPage	 = RV_GetRow(lpPlvData->hwndSelf);
		RV_SetScrollInfo(lpPlvData->hwndSelf, 0, nMaxLine, nPage, 0);
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : RepView_SetTopIndex
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
//          : INT indexTop 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_SetTopIndex(LPPLVDATA lpPlvData, INT indexTop)
{
	INT nCol = RV_GetCol(lpPlvData->hwndSelf); 
	if(nCol <=0) {
		return 0;
	}
	if(indexTop < lpPlvData->iItemCount) {
		lpPlvData->iCurTopIndex = indexTop;
		RV_SetCurScrollPos(lpPlvData->hwndSelf, lpPlvData->iCurTopIndex);
		RECT rc;
		GetClientRect(lpPlvData->hwndSelf, &rc);
		rc.top += RV_GetHeaderHeight(lpPlvData);
		InvalidateRect(lpPlvData->hwndSelf, &rc, TRUE);
		UpdateWindow(lpPlvData->hwndSelf);
		return indexTop;
	}
	else {
		return -1;
	}
}

//////////////////////////////////////////////////////////////////
// Function : RepView_Paint
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_Paint(HWND hwnd, WPARAM wParam, LPARAM lParam)
{

	//OutputDebugString("RepViewPaint start\n");
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	DP(("RepView_Paint START lpPlvData[0x%08x]\n", lpPlvData));
	DP(("RepView_Paint START lpPlvData->lpfnPlvRepItemCallback[0x%08x]\n", lpPlvData->lpfnPlvRepItemCallback));
	if(!lpPlvData->lpfnPlvRepItemCallback) {
		Dbg((" Error Callback\n"));
		//OutputDebugString("RepViewPaint end 1\n");
		return 0;
	}

	INT nCol		= RV_GetColumn(lpPlvData);
	INT *pColWidth;  
	if(nCol < 1) {
		return 0;
	}

	LPPLVITEM lpPlvItemList = (LPPLVITEM)MemAlloc(sizeof(PLVITEM)*nCol);
	if(!lpPlvItemList) {
		return 0;
	}

	pColWidth = (INT *)MemAlloc(sizeof(INT)*nCol);

	if(!pColWidth) {
		DP(("RepView_Paint END\n"));
		//OutputDebugString("RepViewPaint end 2\n");
		MemFree(lpPlvItemList);
		return 0;
	}
	ZeroMemory(lpPlvItemList, sizeof(PLVITEM)*nCol);

	static PAINTSTRUCT ps;
	HDC hDC = BeginPaint(hwnd, &ps);

	static RECT rc;
	GetClientRect(hwnd, &rc);

	HDC hDCMem = CreateCompatibleDC(hDC);
	HBITMAP hBitmap = CreateCompatibleBitmap(hDC,
											 rc.right - rc.left,
											 rc.bottom - rc.top);
	HBITMAP hBitmapPrev    = (HBITMAP)SelectObject(hDCMem, hBitmap);

	//----------------------------------------------------------------
	//971111: #2586: Back color is COLOR_WINDOW
	//----------------------------------------------------------------
	//HBRUSH  hBrush         = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
	//DWORD   dwOldBkColor   = SetBkColor(hDCMem, GetSysColor(COLOR_3DFACE));

	HBRUSH  hBrush         = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
	DWORD   dwOldBkColor   = SetBkColor(hDCMem, GetSysColor(COLOR_WINDOW));
	DWORD   dwOldTextColor = SetTextColor(hDCMem, GetSysColor(COLOR_WINDOWTEXT));

	HDC hDCForBmp  = CreateCompatibleDC(hDCMem); // for item columne bitmap;

	FillRect(hDCMem, &rc, hBrush);

	INT nRow = RV_GetRow(hwnd);
	INT y;
	static RECT rcItem;

	static PLVITEM plvItemTmp, plvItem;
	HFONT hFontOld = NULL;

	if(lpPlvData->hFontRep) {
		hFontOld = (HFONT)SelectObject(hDCMem, lpPlvData->hFontRep);
	}

	static POINT pt;
#ifndef UNDER_CE // Windows CE does not support GetCursorPos.
	GetCursorPos(&pt);
	ScreenToClient(hwnd, &pt);
#else // UNDER_CE
	if(lpPlvData->iCapture != CAPTURE_NONE){
		pt.x = lpPlvData->ptCapture.x;
		pt.y = lpPlvData->ptCapture.y;
	}
	else{
		// set outer client point
		pt.x = -1;
		pt.y = -1;
	}
#endif // UNDER_CE

	static RECT rcHead;
	GetClientRect(lpPlvData->hwndHeader, &rcHead);

	INT nItemHeight = RV_GetItemHeight(hwnd);
	INT yOffsetHead = rcHead.bottom - rcHead.top;
	INT	i, j, k;		


	for(k = 0; k < nCol; k++) {
		HD_ITEM hdItem;
		hdItem.mask = HDI_WIDTH;
		hdItem.fmt  = 0;
		Header_GetItem(lpPlvData->hwndHeader, k, &hdItem);
		pColWidth[k] = hdItem.cxy;
	}

	//	DP(("lpPlvData->iCurTopIndex [%d]\n", lpPlvData->iCurTopIndex));
	//	DP(("nRow %d\n", nRow));
	//	DP(("lpPlvData->iItemCount [%d]\n", lpPlvData->iItemCount));

	//----------------------------------------------------------------
	// for each index item( each line that will be displayed )
	//----------------------------------------------------------------
	//Dbg(("iCurTopIndex = %d\n", lpPlvData->iCurTopIndex));
	//Dbg(("iItemCount   = %d\n", lpPlvData->iItemCount));
	for(i = 0, j = lpPlvData->iCurTopIndex;
		i < nRow && j < lpPlvData->iItemCount;
		i++, j++) {

		//----------------------------------------------------------------
		// get line's vertical offset.
		//----------------------------------------------------------------
		y = RV_GetYMargin(hwnd) + nItemHeight * i;

		ZeroMemory(lpPlvItemList, sizeof(PLVITEM)*nCol);
		//----------------------------------------------------------------
		//changed data query call back spec in 970705: by toshiak
		// get line's all column data with one function call.
		//----------------------------------------------------------------
		lpPlvData->lpfnPlvRepItemCallback(lpPlvData->repItemCallbacklParam, 
										  j,		//line index. 
										  nCol,		//column Count.
										  lpPlvItemList);
		INT xOffset = 0;
		//Dbg(("j = %d\n", j));
		for(k = 0; k < nCol; k++) {
			//Dbg(("k = %d\n", k));
			rcItem.left  = xOffset;
			rcItem.right = rcItem.left + pColWidth[k];
			rcItem.top   = rc.top      + yOffsetHead + y;
			rcItem.bottom= rcItem.top  + nItemHeight;
			if(rcItem.top > rc.bottom) {
				break;
			}
			if(rcItem.left > rc.right) {
				break;
			}
			RV_DrawItem(lpPlvData, hDCMem, hDCForBmp, pt, k, &rcItem, &lpPlvItemList[k]);
			xOffset += pColWidth[k];
		}
		//----------------------------------------------------------------
		//000531:Satori #1641
		//Call DeleteObject() here.
		//----------------------------------------------------------------
		for(k = 0; k < nCol; k++) {
			if(lpPlvItemList[k].fmt == PLVFMT_BITMAP && lpPlvItemList[k].hBitmap != NULL) {
				DeleteObject(lpPlvItemList[k].hBitmap);
			}
		}
	}
	if(hFontOld){
		SelectObject(hDCMem, hFontOld);
	}

	if(pColWidth) {
		MemFree(pColWidth);
	}

	if(lpPlvItemList) {
		MemFree(lpPlvItemList);
	}
	// LIZHANG: if there is no items, draw the explanation text
	if ( !lpPlvData->iItemCount && (lpPlvData->lpText || lpPlvData->lpwText))
	{
		HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
		HFONT hOldFont = (HFONT)SelectObject( hDCMem, hFont );
		RECT rcTmp = rc;
		rcTmp.left = 20;
		rcTmp.top = 20;
		rcTmp.right -= 10;
		rcTmp.bottom -= 10;

		//----------------------------------------------------------------
		//971111: #2586
		//COLORREF colOld = SetTextColor( hDCMem, GetSysColor(COLOR_WINDOW) );
		//COLORREF colBkOld = SetBkColor( hDCMem, GetSysColor(COLOR_3DFACE) );
		//----------------------------------------------------------------
		COLORREF colOld = SetTextColor( hDCMem, GetSysColor(COLOR_WINDOWTEXT));
		COLORREF colBkOld = SetBkColor( hDCMem, GetSysColor(COLOR_WINDOW) );
#ifndef UNDER_CE // always Unicode
		if(ExIsWinNT()) {
#endif // UNDER_CE
			if(lpPlvData->lpwText) {
				DrawTextW( hDCMem,
						  lpPlvData->lpwText,
						  lstrlenW(lpPlvData->lpwText),
						  &rcTmp,
						  DT_VCENTER|DT_WORDBREAK ); 
			}
#ifndef UNDER_CE // always Unicode
		}
		else {
			if(lpPlvData->lpText) {
				DrawText( hDCMem,
						 lpPlvData->lpText,
						 lstrlen(lpPlvData->lpText),
						 &rcTmp,DT_VCENTER|DT_WORDBREAK ); 
			}
		}
#endif // UNDER_CE
		SetTextColor( hDCMem, colOld );
		SetBkColor( hDCMem, colBkOld );
		SelectObject( hDCMem, hOldFont );
	}

	BitBlt(hDC,
		   rc.left,
		   rc.top, 
		   rc.right - rc.left,
		   rc.bottom - rc.top,
		   hDCMem, 0, 0, SRCCOPY);

	// LIZHANG 7/6/97 added this line to repaint header control
	InvalidateRect(lpPlvData->hwndHeader,NULL,FALSE);

	DeleteObject(hBrush);
	SetBkColor(hDCMem, dwOldBkColor);
	SetTextColor(hDCMem, dwOldTextColor);
	SelectObject(hDCMem, hBitmapPrev );
	DeleteObject(hBitmap);
	DeleteDC(hDCForBmp);
	DeleteDC( hDCMem );


	EndPaint(hwnd, &ps);
	//OutputDebugString("RepViewPaint end 3\n");
	return 0;
	Unref3(hwnd, wParam, lParam);
}

INT RepView_Notify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	//Dbg(("Header Notify come\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	HD_NOTIFY *lpNtfy = (HD_NOTIFY *)lParam;
	switch(lpNtfy->hdr.code) {
	case HDN_ITEMCLICKW:
	case HDN_ITEMCLICKA:
		{
			//Dbg(("lpNtfy->iItem   [%d]\n", lpNtfy->iItem));
			//Dbg(("lpNtfy->iButton [%d]\n", lpNtfy->iButton));
			static PLVINFO plvInfo;
			ZeroMemory(&plvInfo, sizeof(plvInfo));
			plvInfo.code = PLVN_HDCOLUMNCLICKED;
			plvInfo.colIndex = lpNtfy->iItem;
			SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
		}
		break;
	case HDN_ITEMDBLCLICK:
	case HDN_DIVIDERDBLCLICK:
	case HDN_BEGINTRACK:
		break;
	case HDN_ENDTRACKA:
	case HDN_ENDTRACKW:
		{
			RECT	rc, rcHead;
			GetClientRect(hwnd, &rc);
			GetClientRect(lpNtfy->hdr.hwndFrom, &rcHead);
			rc.top += rcHead.bottom - rcHead.top;
			InvalidateRect(hwnd, &rc, FALSE);
		}
		break;
	case HDN_TRACK:
		break;
	}
	return 0;
	Unref(uMsg);
	Unref(wParam);
}

INT RepView_ButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData)  {
		return 0;
	}
	switch(uMsg) {
	case WM_LBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	case WM_MBUTTONDBLCLK:
	case WM_RBUTTONDBLCLK:
		//Dbg(("WM_LBUTTONDOWN COME\n"));
		SetCapture(hwnd);
#ifdef UNDER_CE // LBUTTON + ALT key handling
		//Standard way for RBUTTON handling is combination w/ LBUTTON + ALT key
		if(uMsg == WM_LBUTTONDOWN && GetAsyncKeyState(VK_MENU)){
			uMsg = WM_RBUTTONDOWN;
		}
#endif // UNDER_CE
		switch(uMsg) {
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_LBUTTON;
			break;
		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_MBUTTON;
			break;
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_RBUTTON;
			break;
		}
#ifndef UNDER_CE // Windows CE does not support GetCursorPos.
		GetCursorPos(&lpPlvData->ptCapture);
		//remember left button down place
		ScreenToClient(hwnd, &lpPlvData->ptCapture);
#else // UNDER_CE
		lpPlvData->ptCapture.x = (SHORT)LOWORD(lParam);
		lpPlvData->ptCapture.y = (SHORT)HIWORD(lParam);
#endif // UNDER_CE
		RECT rc;
		GetClientRect(hwnd, &rc);
		rc.top += RV_GetHeaderHeight(lpPlvData);
		InvalidateRect(hwnd, &rc, FALSE);
		//UpdateWindow(lpPlvData->hwndSelf);
		break;
	}
	return 0;
	Unref2(wParam, lParam);
}

INT RepView_ButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	static POINT pt;
	static PLVINFO plvInfo;
	static INT	index, downIndex;
	if(!lpPlvData)  {
		return 0;
	}
	switch(uMsg) {
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
		//Dbg(("WM_LBUTTONUP COMES\n"));
#ifdef UNDER_CE // LBUTTON + ALT key handling
		//Standard way for RBUTTON handling is combination w/ LBUTTON + ALT key
		if(uMsg == WM_LBUTTONUP && GetAsyncKeyState(VK_MENU)){
			uMsg = WM_RBUTTONUP;
		}
#endif // UNDER_CE
		RECT rc;
		lpPlvData->iCapture = CAPTURE_NONE;
		ReleaseCapture();
		GetClientRect(lpPlvData->hwndSelf, &rc);
		rc.top += RV_GetHeaderHeight(lpPlvData);
		InvalidateRect(lpPlvData->hwndSelf, &rc, TRUE);
		pt.x = LOWORD(lParam);
		pt.y = HIWORD(lParam);
		//Dbg(("x %d, y %d\n", pt.x, pt.y));
		//Dbg(("capture x[%d] y[%d] \n",lpPlvData->ptCapture.x,lpPlvData->ptCapture.y));
		downIndex = RV_GetInfoFromPoint(lpPlvData, lpPlvData->ptCapture, NULL);
		index = RV_GetInfoFromPoint(lpPlvData, pt, &plvInfo);
		//Dbg(("mouse down index [%d]\n", downIndex));
		//Dbg(("mouse up   index [%d]\n", index));
		if(index != -1) {
			Dbg(("code  [%d]\n", plvInfo.code));
			Dbg(("index [%d]\n", plvInfo.index));
			Dbg(("left[%d] top[%d] right[%d] bottom[%d] \n",
				 plvInfo.itemRect.left,
				 plvInfo.itemRect.top,
				 plvInfo.itemRect.right,
				 plvInfo.itemRect.bottom));
			if(index == downIndex) {
				if(lpPlvData->uMsg != 0) {
					if(uMsg == WM_LBUTTONUP) {
						plvInfo.code = PLVN_ITEMCLICKED;
						SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
					}
					else if(uMsg == WM_RBUTTONUP) {
						plvInfo.code = PLVN_R_ITEMCLICKED;
						SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
					}
				}
			}
		}
		lpPlvData->ptCapture.x = 0;
		lpPlvData->ptCapture.y = 0;
		break;
	}
	return 0;
	Unref(wParam);
}

//////////////////////////////////////////////////////////////////
// Function : RepView_MouseMove
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_MouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData)  {
		return 0;
	}
	static RECT rc;
	static POINT pt;
	static PLVINFO plvInfo;
	pt.x = LOWORD(lParam);
	pt.y = HIWORD(lParam);
	//Dbg(("x %d, y %d\n", pt.x, pt.y));
	INT index = RV_GetInfoFromPoint(lpPlvData, pt, &plvInfo);
	//Dbg(("mouse up   index [%d]\n", index));
	GetClientRect(lpPlvData->hwndSelf, &rc);
	rc.top += RV_GetHeaderHeight(lpPlvData);
	InvalidateRect(hwnd, &rc, FALSE);
	if(index != -1 && (lpPlvData->iCapture == CAPTURE_NONE)) {
		if(lpPlvData->uMsg != 0) {
			if(plvInfo.colIndex == 0) { //poped image is only when column index == 0.
				plvInfo.code = PLVN_ITEMPOPED;
				SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
			}
#ifdef MSAA
			static oldindex = 0;

			index = PLV_ChildIDFromPoint(lpPlvData,pt);
			if((index > 0)&&(index != oldindex)){
				PLV_NotifyWinEvent(lpPlvData,
								   EVENT_OBJECT_FOCUS,
								   hwnd,
								   OBJID_CLIENT,
								   index); // child id
				oldindex = index;
			}
#endif
		}
	}
	return 0;
	Unref(wParam);
}

//////////////////////////////////////////////////////////////////
// Function : RepView_VScroll
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_VScroll(HWND hwnd, WPARAM wParam,  LPARAM lParam)
{
	//----------------------------------------------------------------
	// get current top index.
	// calc scroll position. 
	// get new top index and set it. 
	// redraw window rectangle.
	//----------------------------------------------------------------
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData)  {
		return 0;
	}

	INT nScrollCode	  = (int) LOWORD(wParam); // scroll bar value 
#ifdef _DEBUG
	INT nArgPos 	  = (short int) HIWORD(wParam);  // scroll box position 
#endif
	//HWND hwndScrollBar = (HWND) lParam;      // handle of scroll bar 
	INT nPos;
	INT nRow, nCol, nMax;

	switch(nScrollCode) {
	case SB_LINEDOWN:	
		Dbg(("SB_LINEDOWN COME nArgPos[%d]\n", nArgPos));
		nRow = RV_GetRow(hwnd);
		nMax = RV_GetMaxLine(hwnd);
		nPos = RV_GetCurScrollPos(hwnd);		
		if(nPos + nRow > nMax - 1) {
			return 0;
		}
		nPos++;
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_LINEUP:
		Dbg(("SB_LINEUP COME nArgPos[%d]\n", nArgPos));
		RV_GetRowColumn(hwnd, &nRow, &nCol);
		nPos = RV_GetCurScrollPos(hwnd);
		if(nPos <= 0) {
			return 0;
		}
		nPos--; 
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_PAGEDOWN:	
		Dbg(("SB_PAGEDOWN COME nArgPos[%d]\n", nArgPos));
		RV_GetRowColumn(hwnd, &nRow, &nCol);
		nMax = RV_GetMaxLine(hwnd);
		nPos = RV_GetCurScrollPos(hwnd);
		nPos = min(nPos+nRow, nMax - nRow);
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_PAGEUP:		//TrackNbN
		Dbg(("SB_PAGEUP COME nArgPos[%d]\n", nArgPos));
		RV_GetRowColumn(hwnd, &nRow, &nCol);
		nPos = RV_GetCurScrollPos(hwnd);
		nPos = max(0, nPos - nRow);
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_TOP:
		Dbg(("SB_TOP COME nArgPos[%d]\n", nArgPos));
		break;
	case SB_BOTTOM:
		Dbg(("SB_BOTTOM COME nArgPos[%d]\n", nArgPos));
		break;
	case SB_THUMBTRACK:		//TrackDrag
		Dbg(("SB_THUMBTRACK COME nArgPos[%d]\n", nArgPos));
		nPos = RV_GetScrollTrackPos(hwnd);
		Dbg(("Current Pos %d\n", nPos));
		RV_GetRowColumn(hwnd, &nRow, &nCol);
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_THUMBPOSITION:	//Scroll BarDragI
		Dbg(("SB_THUMBPOSITION COME nArgPos[%d]\n", nArgPos));
		nPos = RV_GetScrollTrackPos(hwnd);
		Dbg(("Current Pos %d\n", nPos));
		RV_GetRowColumn(hwnd, &nRow, &nCol);
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_ENDSCROLL:
		Dbg(("SB_ENDSCROLL COME nArgPos[%d]\n", nArgPos));
		break;
	}
	RECT rc;
	GetClientRect(lpPlvData->hwndSelf, &rc);
	rc.top += RV_GetHeaderHeight(lpPlvData);
	InvalidateRect(lpPlvData->hwndSelf, &rc, TRUE);
	return 0;
	Unref3(hwnd, wParam, lParam);
}

INT RepView_SetCurSel(LPPLVDATA lpPlvData, INT index)
{
	DP(("RepView_Paint START lpPlvData[0x%08x]\n", lpPlvData));
	INT nCol		= RV_GetColumn(lpPlvData);
	if(!lpPlvData) {
		return 0;
	}
	if(nCol < 1) {
		return 0;
	}
	HWND hwnd = lpPlvData->hwndSelf; 
	static RECT rc;
	GetClientRect(hwnd, &rc);
	INT nRow = RV_GetRow(hwnd);
	INT y;
	static RECT rcItem;
	static POINT pt;
	static RECT rcHead;
	GetClientRect(lpPlvData->hwndHeader, &rcHead);

	INT nItemHeight = RV_GetItemHeight(hwnd);
	INT yOffsetHead = rcHead.bottom - rcHead.top;
	INT	i, j;
	Dbg(("yOffsetHead [%d] nItemHeight[%d]\n", yOffsetHead, nItemHeight));
	//----------------------------------------------------------------
	// for each index item( each line that will be displayed )
	//----------------------------------------------------------------
	for(i = 0, j = lpPlvData->iCurTopIndex; 
		i < nRow && j < lpPlvData->iItemCount;
		i++, j++) {

		//----------------------------------------------------------------
		// get line's vertical offset.
		//----------------------------------------------------------------
		if(j == index) {
			y = RV_GetYMargin(hwnd) + nItemHeight * i;
			Dbg(("y %d\n", y));
			INT xOffset = 0;
			rcItem.left  = xOffset;
			rcItem.top   = rc.top      + yOffsetHead + y;
			pt.x = rcItem.left + (nItemHeight * 3)/4;
			pt.y = rcItem.top  + (nItemHeight * 3)/4;
			Dbg(("pt.x[%d] pt.y[%d]\n", pt.x, pt.y));
			ClientToScreen(hwnd, &pt);
			SetCursorPos(pt.x, pt.y);
			break;			
		}
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\repview.h ===
#ifndef _REP_VIEW_H_
#define _REP_VIEW_H_

#define HEADER_ID		0x20
/* repview.cpp */
extern HWND RepView_CreateHeader(LPPLVDATA lpPlvData);
extern INT RepView_RestoreScrollPos(LPPLVDATA lpPlvData);
extern INT RepView_ResetScrollRange(LPPLVDATA lpPlvData);
extern INT RepView_SetItemCount(LPPLVDATA lpPlvData, INT itemCount, INT fDraw);
extern INT RepView_SetTopIndex(LPPLVDATA lpPlvData, INT indexTop);
extern INT RepView_SetCurSel(LPPLVDATA lpPlvData, INT index);
extern INT RepView_ErrorPaint(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT RepView_Paint(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT RepView_Notify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT RepView_ButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT RepView_ButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT RepView_MouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT RepView_VScroll(HWND hwnd, WPARAM wParam, LPARAM lParam);

#endif //_REP_VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\strutil.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#pragma warning(disable :4706) //4706    "rl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\rvmisc.cpp ===
//////////////////////////////////////////////////////////////////
// File     : ivmisc.cpp
// Purpose  : PadListView control's ICON View function.
//			: Name is ICON View but it does not use ICON
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "plv_.h"
#include "plv.h"
#include "dbg.h"
#include "rvmisc.h"
#include "strutil.h"
#include "exgdiw.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

inline INT RECT_GetWidth(LPRECT lpRc)
{
	return lpRc->right - lpRc->left;
}

inline INT RECT_GetHeight(LPRECT lpRc)
{
	return lpRc->bottom - lpRc->top;
}

INT RV_GetItemWidth(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nRepItemWidth;
}

INT RV_GetItemHeight(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nRepItemHeight;
}


INT RV_GetXMargin(HWND hwnd)
{
	return XMARGIN;
	Unref(hwnd);
}

INT RV_GetYMargin(HWND hwnd)
{
	//return YMARGIN;
	return 0;
	Unref(hwnd);
}
INT RV_GetHeaderHeight(LPPLVDATA lpPlvData)
{
	static RECT rc;
	if(!lpPlvData->hwndHeader) {
		return 0;
	}
	GetClientRect(lpPlvData->hwndHeader, &rc);
	return rc.bottom - rc.top;
}

INT RV_GetDispWidth(HWND hwnd)
{
	return RV_GetWidth(hwnd) - RV_GetXMargin(hwnd)*2;
}

INT RV_GetDispHeight(HWND hwnd)
{
	return RV_GetHeight(hwnd) - RV_GetYMargin(hwnd)*2;
}

INT RV_GetWidth(HWND hwnd)
{
	static RECT rc;
	GetClientRect(hwnd, &rc);
	return RECT_GetWidth(&rc);
}

INT RV_GetHeight(HWND hwnd)
{
	static RECT rc;
	GetClientRect(hwnd, &rc);
	return RECT_GetHeight(&rc);
}

INT RV_GetRow(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return (RV_GetDispHeight(hwnd) - RV_GetHeaderHeight(lpPlv))/lpPlv->nRepItemHeight;
}

INT RV_GetColumn(LPPLVDATA lpPlvData)
{
	if(!lpPlvData) {
		//OutputDebugString("RV_GetColumn: lpPlvData NULL\n");
		return 0;
	}
	if(!lpPlvData->hwndHeader) {
		//OutputDebugString("RV_GetColumn: hwndHeader NULL\n");
		return 0;
	}
	return Header_GetItemCount(lpPlvData->hwndHeader);
}

INT RV_GetCol(HWND hwnd)
{
	//LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return 1;
	UNREFERENCED_PARAMETER(hwnd);
}

INT RV_GetRowColumn(HWND hwnd, INT *pRow, INT *pCol)
{
	*pRow = RV_GetRow(hwnd);
	*pCol = RV_GetCol(hwnd);
	return 0;
}

INT RV_GetMaxLine(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->iItemCount;
}

//////////////////////////////////////////////////////////////////
// Function : RV_IndexFromPoint
// Type     : INT
// Purpose  : Get item index from PadListView point
// Args     : 
//          : LPPLVDATA lpPlvData 
//          : POINT pt // position of pad listview client.
// Return   : return pt's item index. if -1 error.
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RV_GetInfoFromPoint(LPPLVDATA lpPlvData, POINT pt, LPPLVINFO lpPlvInfo)
{
	INT nRow = RV_GetRow(lpPlvData->hwndSelf);
	// get header control item count;
	INT nCol = RV_GetColumn(lpPlvData);

	if(nCol <=0 ) {
		return 0;
	}

	INT i, j, k;
	INT x, y;
	static RECT rc, rcHead;
	//INT nItemWidth  = RV_GetItemWidth(lpPlvData->hwndSelf);
	INT nItemHeight = RV_GetItemHeight(lpPlvData->hwndSelf);

	GetClientRect(lpPlvData->hwndHeader, &rcHead);
	GetClientRect(lpPlvData->hwndSelf,   &rc);

	INT yOffsetHead = rcHead.bottom - rcHead.top;
	static RECT rcItem;

	for(i = 0, j = lpPlvData->iCurTopIndex; 
		i < nRow  && j < lpPlvData->iItemCount;
		i++, j++) {
		x = RV_GetXMargin(lpPlvData->hwndSelf);
		y = RV_GetYMargin(lpPlvData->hwndSelf) + nItemHeight*i;
		INT xOffset = 0;
		HD_ITEM hdItem;
		for(k = 0; k < nCol; k++) {
			hdItem.mask = HDI_WIDTH;
			hdItem.fmt  = 0;
			Header_GetItem(lpPlvData->hwndHeader, k, &hdItem);
			rcItem.left  = xOffset;
			rcItem.right = rcItem.left + hdItem.cxy;
			rcItem.top   = rc.top  + yOffsetHead + y;
			rcItem.bottom= rcItem.top  + nItemHeight;
			if(PtInRect(&rcItem, pt)) {
				if(lpPlvInfo) {
					ZeroMemory(lpPlvInfo, sizeof(PLVINFO));
					lpPlvInfo->code        = 0; // don't know at this time.
					lpPlvInfo->index       = j;
					lpPlvInfo->pt	       = pt;
					lpPlvInfo->itemRect    = rcItem;
					lpPlvInfo->colIndex    = k;
					lpPlvInfo->colItemRect = rcItem;
				}
				return j;
			}
			xOffset += hdItem.cxy;
		}
	}
	return -1;
}

INT RV_DrawItem(LPPLVDATA	lpPlvData, 
				HDC			hDC, 
				HDC			hDCForBmp, 
				POINT		pt,
				INT			colIndex, 
				LPRECT		lpRect, 
				LPPLVITEM	lpPlvItem)
{

	if(!lpPlvItem->lpwstr) {
		return 0;
	}
	//INT edgeFlag = PLV_EDGE_NONE;
	INT sunken = 0;


	if(lpPlvItem->fmt == PLVFMT_TEXT) {
		SIZE size;
		//Dbg(("Call GetTextExtentPoint32W()\n"));
		//Dbg(("Length %d\n", StrlenW(lpPlvItem->lpwstr)));
		if(!ExGetTextExtentPoint32W(hDC, 
									lpPlvItem->lpwstr, 
									StrlenW(lpPlvItem->lpwstr), 
									&size)) {
			return 0;
		}
		if(colIndex == 0) {
			RECT rcItem = *lpRect;
			rcItem.left += 2;
			rcItem.right = rcItem.left + size.cx+4;
			if(lpPlvData->iCapture == CAPTURE_LBUTTON) {
#if 0
				Dbg(("RV_Draw Captureing\n"));
				Dbg(("pt [%d][%d] cap pt[%d][%d]drawrect l[%d] t[%d] r[%d] b[%d]\n",
					 pt.x,
					 pt.y,
					 lpPlvData->ptCapture.x,
					 lpPlvData->ptCapture.y,
					 rcItem.left, 
					 rcItem.top, 
					 rcItem.right, 
					 rcItem.bottom));
#endif
				if(PtInRect(&rcItem, lpPlvData->ptCapture) && PtInRect(&rcItem, pt)) {
					sunken = 1;
					DrawEdge(hDC, &rcItem, EDGE_SUNKEN, BF_SOFT | BF_RECT);
				}
			}
			else {
				if(PtInRect(&rcItem, pt)) {
					sunken = 0; //-1;
					DrawEdge(hDC, &rcItem, EDGE_RAISED, BF_SOFT | BF_RECT);
				}
			}
		}
		//Dbg(("Call ExtTextOut()\n"));
		ExExtTextOutW(hDC, 
					  lpRect->left + sunken + (colIndex == 0 ? 4 : 0),
					  lpRect->top  + (lpRect->bottom - lpRect->top - size.cy)/2 + sunken,
					  ETO_CLIPPED,
					  lpRect,
					  lpPlvItem->lpwstr,
					  StrlenW(lpPlvItem->lpwstr), 
					  NULL);
	}
	else if(lpPlvItem->fmt == PLVFMT_BITMAP) {
		//Dbg(("Draw Bitmap\n"));
		if(lpPlvItem->hBitmap) {
			BITMAP bitMap;
			HBITMAP hBitmapOld;
			GetObject(lpPlvItem->hBitmap, sizeof(bitMap), &bitMap);
			hBitmapOld = (HBITMAP)SelectObject(hDCForBmp, lpPlvItem->hBitmap);
			INT yOffset = 0;
			if(bitMap.bmHeight < (lpRect->bottom - lpRect->top)) {
				yOffset = ((lpRect->bottom - lpRect->top) - bitMap.bmHeight)/ 2;
			}
			BitBlt(hDC, 
				   lpRect->left, 
				   lpRect->top+yOffset, 
				   lpRect->right - lpRect->left, lpRect->bottom - lpRect->top,
#ifndef UNDER_CE // CE Specific ??
				   hDCForBmp, 0, 0, SRCAND);
#else // UNDER_CE
				   hDCForBmp, 0, 0, SRCINVERT);
#endif // UNDER_CE
			SelectObject(hDCForBmp, hBitmapOld);
			//----------------------------------------------------------------
			//000531:Satori #1461
			//Don't call DeleteObject() here, call it from RV_DrawItem()'s caller.
			//repview.cpp:RepView_Paint();
			//----------------------------------------------------------------
			//DeleteObject(lpPlvItem->hBitmap);
		}
	}
	return 0;
}


INT RV_GetCurScrollPos(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nCurScrollPos;
}

INT RV_SetCurScrollPos(HWND hwnd, INT nPos)
{
	static SCROLLINFO scrInfo;
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);

	INT nRow = RV_GetRow(hwnd);
	//INT nCol = RV_GetCol(hwnd);
	INT nMax = RV_GetMaxLine(hwnd);

	lpPlv->nCurScrollPos = nPos;
	lpPlv->iCurTopIndex = nPos;

	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= 0;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nRow;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	//In normal case,  
	//if (scrInfo.nMax - scrInfo.nMin + 1) <= scrInfo.nPage, 
	// scroll bar is hidden. to prevent it,
	// in this case, set proper page, and DISABLE scrollbar.
	// Now we can show scroll bar always
	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}

	//970810 toshiak. send scrolled notify.
	static PLVINFO plvInfo;
	ZeroMemory(&plvInfo, sizeof(plvInfo));
	plvInfo.code = PLVN_VSCROLLED;
	SendMessage(GetParent(lpPlv->hwndSelf), 
				lpPlv->uMsg,
				(WPARAM)0,
				(LPARAM)&plvInfo);
	return nPos;
}

//////////////////////////////////////////////////////////////////
// Function : RV_SetScrollInfo
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : INT nMin 
//          : INT nMax 
//          : INT nPage 
//          : INT nPos 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= nMin;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nPage;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	return 0;
} 

INT RV_GetScrollTrackPos(HWND hwnd)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_ALL;
	GetScrollInfo(hwnd, SB_VERT, &scrInfo);
	return scrInfo.nTrackPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\testlist.h ===
#ifndef _TEST_LIST_H_ 
#define _TEST_LIST_H_ 
HWND TestList_Create(HINSTANCE hInst, HWND hwndParent);
#endif //_TEST_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\dispatch.cpp ===
#include "imewarn.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "dispatch.h"


LRESULT DispMessage(LPMSDI lpmsdi, 
                    HWND   hwnd, 
                    UINT   uMessage, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    int  imsd = 0;

    MSD *rgmsd = lpmsdi->rgmsd;
    int  cmsd  = lpmsdi->cmsd;

    for (imsd = 0; imsd < cmsd; imsd++)
    {
        if (rgmsd[imsd].uMessage == uMessage)
            return rgmsd[imsd].pfnmsg(hwnd, uMessage, wparam, lparam);
    }

    return DispDefault(lpmsdi->edwp, hwnd, uMessage, wparam, lparam);
}

////////////////////////////////////////////////////////////////
// Function : DispCommand
// Type     :  LRESULT
// Purpose  : 
//          : 
// Argument : 
//          : LPCMDI lpcmdi 
//          : HWND hwnd 
//          : WPARAM wparam 
//          : LPARAM lparam 
// Return   :
// AUTHOR   : g(ToshiaK)
// START DATE: 
// HISTORY  : 
// 
/////////////////////////////////////////////////////////////////
LRESULT DispCommand(LPCMDI lpcmdi, 
                    HWND   hwnd, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    LRESULT lRet = 0;
    WORD    wCommand = GET_WM_COMMAND_ID(wparam, lparam);
    int     icmd;

    CMD    *rgcmd = lpcmdi->rgcmd;
    int     ccmd  = lpcmdi->ccmd;

    // Message packing of wparam and lparam have changed for Win32,
    // so use the GET_WM_COMMAND macro to unpack the commnad

    for (icmd = 0; icmd < ccmd; icmd++)
    {
        if (rgcmd[icmd].wCommand == wCommand)
        {
            return rgcmd[icmd].pfncmd(hwnd,
                                      wCommand,
                                      GET_WM_COMMAND_CMD(wparam, lparam),
                                      GET_WM_COMMAND_HWND(wparam, lparam));
        }
    }

    return DispDefault(lpcmdi->edwp, hwnd, WM_COMMAND, wparam, lparam);
}


////////////////////////////////////////////////////////////////
// Function : DispDefault
// Type     :  LRESULT
// Purpose  : 
//          : 
// Argument : 
//          : EDWP edwp 
//          : HWND hwnd 
//          : UINT uMessage 
//          : WPARAM wparam 
//          : LPARAM lparam 
// Return   :
// AUTHOR   : g(ToshiaK)
// START DATE: 
// HISTORY  : 
// 
/////////////////////////////////////////////////////////////////
#define hwndMDIClient NULL
LRESULT DispDefault(EDWP   edwp, 
                    HWND   hwnd, 
                    UINT   uMessage, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    switch (edwp)
    {
        case edwpNone:
            return 0;
        case edwpWindow:
            return DefWindowProc(hwnd, uMessage, wparam, lparam);
        case edwpDialog:
            return DefDlgProc(hwnd, uMessage, wparam, lparam);
        case edwpMDIFrame:
            return DefFrameProc(hwnd, hwndMDIClient, uMessage, wparam, lparam);
        case edwpMDIChild:
            return DefMDIChildProc(hwnd, uMessage, wparam, lparam);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\strutil.h ===
#ifndef _STR_UTIL_H_
#define _STR_UTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(disable :4706) //4706    "rl"
//----------------------------------------------------------------
//ANSI version string utility
//----------------------------------------------------------------
#define	StrlenW		lstrlenW
#define StrlenA		lstrlenA
#define StrcpyA		lstrcpyA
#define StrcatA		lstrcatA
#define StrcmpA		lstrcmp

inline int __cdecl StrncmpA(const char * first,
							const char * last,
							unsigned int count)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last) {
		first++;
		last++;
	}
	return *(unsigned char *)first - *(unsigned char *)last;
}

inline char * __cdecl StrncpyA(char * dest,	const char * source, unsigned int count)
{
	char *start = dest;

	while (count && (*dest++ = *source++))	/* copy string */
		count--;

	if (count)								/* pad out with zeroes */
		while (--count)
			*dest++ = '\0';

	return(start);
}

inline char * __cdecl StrchrA(const char * string, int ch)
{
	while (*string && *string != (char)ch)
		string++;

	if (*string == (char)ch)
		return((char *)string);
	return NULL;
}

//----------------------------------------------------------------
//Unicode version string utility
//----------------------------------------------------------------
inline WCHAR * __cdecl StrchrW(const WCHAR * string, int ch)
{
	while (*string && *string != (WCHAR)ch)
		string++;

	if (*string == (WCHAR)ch)
		return((WCHAR *)string);
	return NULL;
}

inline int __cdecl StrncmpW(const WCHAR * first,
							const WCHAR * last,
							unsigned int count)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last) {
		first++;
		last++;
	}
	return *first - *last;
}

inline int __cdecl StrcmpW(const WCHAR * first, const WCHAR * last)
{
	for (; *first && *last && (*first == *last); first++, last++);
	return (*first - *last);
}

inline WCHAR * __cdecl StrcpyW(WCHAR * dest, const WCHAR * source)
{
	WCHAR *start = dest;

	while (*dest++ = *source++);

	return(start);
}

inline WCHAR * __cdecl StrncpyW(WCHAR * dest,
								const WCHAR * source,
								unsigned int count)

{
	WCHAR *start = dest;

	while (count && (*dest++ = *source++))	/* copy string */
		count--;

	if (count)								/* pad out with zeroes */
		while (--count)
			*dest++ = 0;

	return(start);
}

inline WCHAR * __cdecl StrcatW(WCHAR * dest, const WCHAR * source)
{
	WCHAR *start = dest;
	WCHAR *pwch;

	for (pwch = dest; *pwch; pwch++);
	while (*pwch++ = *source++);

	return(start);
}


#ifdef __cplusplus
}
#endif
#endif //_STR_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by plvtest.rc
//
#define IDS_JSS_HANKAKU_ALPHA           1
#define IDS_JSS_SYMBOL_ALNUM            2
#define IDS_JSS_HIRA_KATA               3
#define IDS_JSS_GREEK                   4
#define IDS_JSS_RUSSIAN                 5
#define IDS_JSS_SPECIAL                 6
#define IDS_JSS_KANJI_1                 7
#define IDS_JSS_KANJI_2                 8
#define IDS_JSS_KANJI_3                 9
#define IDS_JSS_GAIJI                   10
#define IDS_USS_BASIC_LATIN             11
#define IDS_USS_LATIN_1_SUPPLEMENT      12
#define IDS_USS_LATIN_EXTENDED_A        13
#define IDS_USS_LATIN_EXTENDED_B        14
#define IDS_USS_IPA_EXTENSIONS          15
#define IDS_USS_SPACING_MODIFIER_LETTERS 16
#define IDS_USS_COMBINING_DIACRITICAL_MARKS 17
#define IDS_USS_GREEK                   18
#define IDS_USS_CYRILLIC                19
#define IDS_USS_ARMENIAN                20
#define IDS_USS_HEBREW                  21
#define IDS_USS_ARABIC                  22
#define IDS_USS_DEVANAGARI              23
#define IDS_USS_BENGALI                 24
#define IDS_USS_GURMUKHI                25
#define IDS_USS_GUJARATI                26
#define IDS_USS_ORIYA                   27
#define IDS_USS_TAMIL                   28
#define IDS_USS_TELUGU                  29
#define IDS_USS_KANNADA                 30
#define IDS_USS_MALAYALAM               31
#define IDS_USS_THAI                    32
#define IDS_USS_LAO                     33
#define IDS_USS_TIBETAN                 34
#define IDS_USS_GEORGIAN                35
#define IDS_USS_HANGUL_JAMO             36
#define IDS_USS_LATIN_EXTENDED_ADDITIONAL 37
#define IDS_USS_GREEK_EXTENDED          38
#define IDS_USS_GENERAL_PUNCTUATION     39
#define IDS_USS_SUPERSCRIPTS_AND_SUBSCRIPTS 40
#define IDS_USS_CURRENCY_SYMBOLS        41
#define IDS_USS_COMBINING_MARKS_FOR_SYMBOLS 42
#define IDS_USS_LETTERLIKE_SYMBOLS      43
#define IDS_USS_NUMBER_FORMS            44
#define IDS_USS_ARROWS                  45
#define IDS_USS_MATHEMATICAL_OPERATORS  46
#define IDS_USS_MISCELLANEOUS_TECHNICAL 47
#define IDS_USS_CONTROL_PICTURES        48
#define IDS_USS_OPTICAL_CHARACTER_RECOGNITION 49
#define IDS_USS_ENCLOSED_ALPHANUMERICS  50
#define IDS_USS_BOX_DRAWING             51
#define IDS_USS_BLOCK_ELEMENTS          52
#define IDS_USS_GEOMETRIC_SHAPES        53
#define IDS_USS_MISCELLANEOUS_SYMBOLS   54
#define IDS_USS_DINGBATS                55
#define IDS_USS_CJK_SYMBOLS_AND_PUNCTUATION 56
#define IDS_USS_HIRAGANA                57
#define IDS_USS_KATAKANA                58
#define IDS_USS_BOPOMOFO                59
#define IDS_USS_HANGUL_COMPATIBILITY_JAMO 60
#define IDS_USS_KANBUN                  61
#define IDS_USS_ENCLOSED_CJK_LETTERS_AND_MONTHS 62
#define IDS_USS_CJK_COMPATIBILITY       63
#define IDS_USS_CJK_UNIFIED_IDEOGRAPHS  64
#define IDS_USS_HANGUL_SYLLABLES        65
#define IDS_USS_HIGH_SURROGATES         66
#define IDS_USS_HIGH_PRIVATE_USE_SURROGATES 67
#define IDS_USS_LOW_SURROGATES          68
#define IDS_USS_PRIVATE_USE             69
#define IDS_USS_CJK_COMPATIBILITY_IDEOGRAPHS 70
#define IDS_USS_ALPHABETIC_PRESENTATION_FORMS 71
#define IDS_USS_ARABIC_PRESENTATION_FORMS_A 72
#define IDS_USS_COMBINING_HALF_MARKS    73
#define IDS_USS_CJK_COMPATIBILITY_FORMS 74
#define IDS_USS_SMALL_FORM_VARIANTS     75
#define IDS_USS_ARABIC_PRESENTATION_FORMS_B 76
#define IDS_USS_HALFWIDTH_AND_FULLWIDTH_FORMS 77
#define IDS_USS_SPECIALS                78
#define IDS_SUBSET                      79
#define IDS_FONT                        80
#define IDS_CODE_UNICODE                81
#define IDS_CODE_SJIS                   82
#define IDI_ICON1                       100
#define IDD_PADLIST                     106
#define IDD_PLVLIST                     106
#define IDD_LISTREPORT                  109
#define IDD_PLVREPORT                   109
#define IDD_PARENT                      110
#define IDB_BITMAP1                     111
#define IDC_BUTTON1                     1024
#define IDC_LIST1                       1027
#define IDC_CHECK1                      1028
#define IDC_BUTTON2                     1032
#define IDC_BUTTON3                     1033
#define IDC_BTN_2                       1034
#define IDC_CHARTYPE                    1035
#define IDC_FONT                        1036
#define IDC_CODE                        1037
#define IDC_COMBO1                      1038
#define IDC_BTN_SWITCH                  1039

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1040
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\testlist.cpp ===
#include "imewarn.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include "resource.h"
#include "testlist.h"
#include <stdio.h>
#include "plv.h"
#include "dbg.h"

extern HINSTANCE g_hInst;
INT_PTR CALLBACK ListWndProc(HWND  hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HWND TestList_Create(HINSTANCE hInst, HWND hwndParent)
{
	return CreateDialog(hInst, MAKEINTRESOURCE(IDD_PLVLIST), hwndParent, ListWndProc);
}


INT WINAPI GetItemForIcon(LPARAM lParam, INT index, LPPLVITEM lpPlvItem)
{
	static WCHAR wchCode[2];
	wchCode[0] = (WCHAR)(index + (WCHAR)lParam);
	lpPlvItem->lpwstr = wchCode;
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : GetItemForReport
// Type     : INT WINAPI
// Purpose  : Get report view's line data.
// Args     : 
//          : LPARAM lParam 
//          : INT index 
//          : INT colCount 
//          : LPPLVITEM lpPlvItem 
// Return   : 
// DATE     : 970705, spec changed. see plv.h
//////////////////////////////////////////////////////////////////
INT WINAPI GetItemForReport(LPARAM lParam, INT index, INT colCount, LPPLVITEM lpPlvItemList)
{
	static WCHAR wchChar[5][64];
	int i;
	for(i = 0; i < colCount; i++) {
		switch(i) { 
		case 0:
			lpPlvItemList[i].fmt = PLVFMT_TEXT;
			wchChar[i][0] = (WCHAR)(index + (WCHAR)lParam);
			wchChar[i][1] = (WCHAR)0x0000;
			lpPlvItemList[i].lpwstr = wchChar[0];
			break;
		case 1:
			lpPlvItemList[i].fmt = PLVFMT_BITMAP;
			lpPlvItemList[i].hBitmap = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP1));
			break;
		case 2:
		case 3:
		case 4:
			lpPlvItemList[i].fmt = PLVFMT_TEXT;
			swprintf(wchChar[i], L" Line %d - Colmun %d", index, i);
			lpPlvItemList[i].lpwstr = wchChar[i];
			break;
		default:
			break;
		}
	}
	return 0;
}

#define IDC_LISTVIEW   10
INT_PTR CALLBACK ListWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg) {
	case WM_INITDIALOG:
		{
			HWND hwndLv = PadListView_CreateWindow(g_hInst,			//Instance handle
												   hwnd,			//parent window handle
												   IDC_LISTVIEW,	// Window ID.	
												   10,				// x position
												   10,				// y position
												   400,				// width
												   200,				// height	
												   WM_USER+1);		// notify msg.
			PadListView_SetItemCount(hwndLv, 6000);
			PadListView_SetIconItemCallback(hwndLv, (LPARAM)0x4e00, GetItemForIcon);
			PadListView_SetReportItemCallback(hwndLv, (LPARAM)0x4e00, GetItemForReport);
			PadListView_SetIconFont(hwndLv, "MS UI Gothic", 18);
			PadListView_SetReportFont(hwndLv, "MS UI Gothic", 12);
			PadListView_SetStyle(hwndLv, PLVSTYLE_ICON);
			INT i;
			for(i = 0; i < 5; i++) {
				PLV_COLUMN plvCol;
				char szBuf[30];
				wsprintf(szBuf, "column %d", i+1);
				plvCol.mask = PLVCF_FMT | PLVCF_WIDTH | PLVCF_TEXT;
				plvCol.fmt  = PLVCFMT_LEFT;
				plvCol.pszText = szBuf;
				plvCol.cx	   = 70;	
				plvCol.cchTextMax = lstrlen(szBuf);
				PadListView_InsertColumn(hwndLv, i, &plvCol);
			}
		}
		return 1;
	case WM_USER+1:
		{
			LPPLVINFO lpPlvInfo = (LPPLVINFO)lParam;
			OutputDebugStringA("----------------start---------------------------\n");
			DBG(("idCtrl    [%d]\n", (INT)wParam));
			DBG(("code      [%d][%s]\n", lpPlvInfo->code,
				 lpPlvInfo->code == PLVN_ITEMPOPED				? "PLVN_ITEMPOPED"				:
				 lpPlvInfo->code == PLVN_ITEMCLICKED			? "PLVN_ITEMCLICKED"			:
				 lpPlvInfo->code == PLVN_ITEMCOLUMNCLICKED		? "PLVN_ITEMCOLUMNCLICKED"		:
				 lpPlvInfo->code == PLVN_ITEMDBLCLICKED			? "PLVN_ITEMDBLCLICKED"			:
				 lpPlvInfo->code == PLVN_ITEMCOLUMNDBLCLICKED	? "PLVN_ITEMCOLUMNDBLCLICKED"	:
				 lpPlvInfo->code == PLVN_R_ITEMCLICKED			? "PLVN_R_ITEMCLICKED"			:
				 lpPlvInfo->code == PLVN_R_ITEMCOLUMNCLICKED	? "PLVN_R_ITEMCOLUMNCLICKED"	:
				 lpPlvInfo->code == PLVN_R_ITEMDBLCLICKED		? "PLVN_R_ITEMDBLCLICKED"		:
				 lpPlvInfo->code == PLVN_R_ITEMCOLUMNDBLCLICKED ? "PLVN_R_ITEMCOLUMNDBLCLICKED" :
				 lpPlvInfo->code == PLVN_HDCOLUMNCLICKED		? "PLVN_HDCOLUMNCLICKED"		: "UNKNOWN"));
			DBG(("index     [%d]\n", lpPlvInfo->index));
			DBG(("pt        x[%d] y[%d]\n",
				 lpPlvInfo->pt.x,
				 lpPlvInfo->pt.y));
			DBG(("colIndex  [%d]\n", lpPlvInfo->colIndex));
			DBG(("itemRect    L[%3d] T[%3d] R[%3d] B[%3d]\n", 
				 lpPlvInfo->itemRect.left,
				 lpPlvInfo->itemRect.top,
				 lpPlvInfo->itemRect.right,
				 lpPlvInfo->itemRect.bottom));
			DBG(("colItenRect L[%3d] T[%3d] R[%3d] B[%3d]\n",
				 lpPlvInfo->colItemRect.left,    
				 lpPlvInfo->colItemRect.top,     
				 lpPlvInfo->colItemRect.right,   
				 lpPlvInfo->colItemRect.bottom));
			OutputDebugStringA("----------------end---------------------------\n");
		}
		break;
	case WM_COMMAND:
		switch(LOWORD(wParam)) {
		case IDOK:
		case IDCANCEL:
			DestroyWindow(hwnd);
			break;
		case IDC_BTN_SWITCH:
			DBG(("IDC_BTN_SWITCH COME\n"));
			if(PLVSTYLE_ICON == PadListView_GetStyle(GetDlgItem(hwnd, IDC_LISTVIEW))) {
				PadListView_SetStyle(GetDlgItem(hwnd, IDC_LISTVIEW), PLVSTYLE_REPORT);
			}
			else {
				PadListView_SetStyle(GetDlgItem(hwnd, IDC_LISTVIEW), PLVSTYLE_ICON);
			}
			break;
		}
		break;
	default:
		break;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\cdwtt.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "ptt.h"
#include "cdwtt.h"
#include "dbg.h"
#include "exgdiw.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

//----------------------------------------------------------------
//Animate window const value
//----------------------------------------------------------------
#define AW_HOR_POSITIVE             0x00000001
#define AW_HOR_NEGATIVE             0x00000002
#define AW_VER_POSITIVE             0x00000004
#define AW_VER_NEGATIVE             0x00000008
#define AW_CENTER                   0x00000010
#define AW_HIDE                     0x00010000
#define AW_ACTIVATE                 0x00020000
#define AW_SLIDE                    0x00040000
#define AW_BLEND                    0x00080000

//----------------------------------------------------------------
//local Timer id
//----------------------------------------------------------------
#define TID_SHOW		3
#define TID_MONITOR		4
#define TID_DURATION	5

#ifdef MemAlloc
#undef MemAlloc
#endif
#ifdef MemFree
#undef MemFree
#endif

#define MemAlloc(a)		GlobalAllocPtr(GHND, a)
#define MemFree(a)		GlobalFreePtr(a);
#define MAX(a, b)	((a) > (b) ? (a) : (b))
#define UnrefMsg()		UNREFERENCED_PARAMETER(hwnd); \
						UNREFERENCED_PARAMETER(wParam); \
						UNREFERENCED_PARAMETER(lParam)

#if 0
typedef struct {  // ti  
    UINT      cbSize; 
    UINT      uFlags; 
    HWND      hwnd; 
    UINT      uId; 
    RECT      rect; 
    HINSTANCE hinst; 
    LPTSTR     lpszText; 
} TOOLINFO, NEAR *PTOOLINFO, FAR *LPTOOLINFO; 

typedef struct tagTOOLINFOW {
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT uId;
    RECT rect;
    HINSTANCE hinst;
    LPWSTR lpszText;
} TOOLINFOW, NEAR *PTOOLINFOW, FAR *LPTOOLINFOW;
#endif

LPXINFO XInfo_New(VOID)
{
	LPXINFO lpXif = (LPXINFO)MemAlloc(sizeof(XINFO));
	if(lpXif) {
		ZeroMemory(lpXif, sizeof(XINFO));
	}
	return lpXif;
}

LRESULT CALLBACK CDWToolTip::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPCDWToolTip lpCDWTT;
	switch(uMsg) {
#ifndef UNDER_CE // Windows CE does not support WM_NCCREATE/WM_NCDESTROY
	case WM_NCCREATE:
		lpCDWTT = new CDWToolTip(hwnd);
		SetHWNDPtr(hwnd, lpCDWTT);
		break;
	case WM_NCDESTROY:
		lpCDWTT = (LPCDWToolTip)::GetHWNDPtr(hwnd);
		SetHWNDPtr(hwnd, NULL);
		if(lpCDWTT) {
			delete lpCDWTT;
		}
		break;
#else // UNDER_CE
	case WM_CREATE:
		lpCDWTT = new CDWToolTip(hwnd);
		SetHWNDPtr(hwnd, lpCDWTT);
		if(lpCDWTT) {
			return lpCDWTT->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	case WM_DESTROY:
		lpCDWTT = (LPCDWToolTip)GetHWNDPtr(hwnd);
		if(lpCDWTT) {
			lpCDWTT->RealWndProc(hwnd, uMsg, wParam, lParam);
			SetHWNDPtr(hwnd, NULL);
			delete lpCDWTT;
		}
		break;
#endif // UNDER_CE
	default:
		lpCDWTT = (LPCDWToolTip)GetHWNDPtr(hwnd);
		if(lpCDWTT) {
			return lpCDWTT->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void *CDWToolTip::operator new(size_t size)
{
	BYTE *p = (BYTE *)MemAlloc(size);
	if(p) {
		ZeroMemory(p, size);
	}
	return (void *)p;
}

void  CDWToolTip::operator delete(void *pv)
{
	if(pv) {
		MemFree(pv);
	}
}

CDWToolTip::CDWToolTip(HWND hwnd)
{
	m_hwndSelf = hwnd;
	m_hFont	   = NULL;	
}

CDWToolTip::~CDWToolTip()
{
	//do nothing
}

LRESULT CDWToolTip::RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg) {
	case WM_CREATE:
		return MsgCreate(hwnd, wParam, lParam);
	case WM_PAINT:
		return MsgPaint	(hwnd, wParam, lParam);
#ifndef UNDER_CE // Not support
	case WM_PRINTCLIENT:
		return MsgPrintClient(hwnd, wParam, lParam);
#endif // UNDER_CE
	case WM_TIMER:
		return MsgTimer(hwnd, wParam, lParam);
	case WM_DESTROY:
		return MsgDestroy(hwnd, wParam, lParam);
	case WM_SETFONT:
		return MsgSetFont(hwnd, wParam, lParam);
	case TTM_SETDELAYTIME:
		return TTM_SetDelayTime(hwnd, wParam, lParam);
	case TTM_ADDTOOLW:
		return TTM_AddToolW(hwnd, wParam, lParam);
	case TTM_DELTOOLW:
		return TTM_DelToolW(hwnd, wParam, lParam);
	case TTM_NEWTOOLRECTW:
		return TTM_NewToolRectW(hwnd, wParam, lParam);
	case TTM_RELAYEVENT_WITHUSERINFO:
		return TTM_RelayEventWithUserInfo(hwnd, wParam, lParam);
	case TTM_RELAYEVENT:
		return TTM_RelayEvent(hwnd, wParam, lParam);
	case TTM_GETTOOLINFOW:
	case TTM_SETTOOLINFOW:
		return TTM_GetSetToolInfoW(hwnd, uMsg, wParam, lParam);
	case TTM_GETTOOLCOUNT:
		return TTM_GetToolCount(hwnd, wParam, lParam);
	default:
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}


LRESULT CDWToolTip::MsgCreate(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	m_hwndSelf = hwnd;
	m_fEnable  = TRUE; //970812: new to show or hide tooltip explicitly 
	return 1;
	UnrefMsg();
}

LRESULT CDWToolTip::MsgPrintClient(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
#ifndef UNDER_CE // Not support
	Dbg(("WM_PRINTCLIENT COME lParam[0x%08x]\n", lParam));
	RECT rc;
	POINT		pt;
	GetCursorPos(&pt);
	GetClientRect(hwnd, &rc);
	HDC hDC = (HDC)wParam;
	HFONT hFontOld = NULL;
	if(m_hFont) {
		hFontOld = (HFONT)::SelectObject(hDC, m_hFont);
	}
	else {
		hFontOld = (HFONT)::SelectObject(hDC, GetStockObject(DEFAULT_GUI_FONT));
	}
	LPWSTR lpwstr = GetTipTextW();
	if(lpwstr) {
		DrawTipText(hDC, &rc, lpwstr);
	}
	::SelectObject(hDC, hFontOld);
#endif // UNDER_CE
	return 0;
	UNREFERENCED_PARAMETER(lParam);
}

LRESULT CDWToolTip::MsgSetFont(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	HFONT hFont = (HFONT)wParam;
	BOOL  fRedraw = LOWORD(lParam);

	if(!hFont) {
		return 0;
	}

#ifndef UNDER_CE
	LOGFONTA logFont;
#else // UNDER_CE
	LOGFONT logFont;
#endif // UNDER_CE
	HFONT hFontNew;
	::GetObject(hFont, sizeof(logFont), &logFont);
	hFontNew = ::CreateFontIndirect(&logFont);

	if(!hFontNew) {
		return 0;
	}
	if(m_hFont) {
		::DeleteObject(m_hFont);
	}
	m_hFont = hFontNew;
	if(fRedraw) {
		::InvalidateRect(hwnd, NULL, TRUE);
	}
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::MsgPaint(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	PAINTSTRUCT ps;
	RECT		rc;
#ifndef UNDER_CE // Windows CE does not support GetCursorPos
	POINT		pt;
	::GetCursorPos(&pt);
#endif // UNDER_CE
	::GetClientRect(hwnd, &rc);

	HDC hDC = ::BeginPaint(hwnd, &ps);
	HFONT hFontOld = NULL;
	if(m_hFont) {
		hFontOld = (HFONT)::SelectObject(hDC, m_hFont);
	}
	else {
		hFontOld = (HFONT)::SelectObject(hDC, GetStockObject(DEFAULT_GUI_FONT));
	}
	LPWSTR lpwstr = GetTipTextW();
	if(lpwstr) {
		DrawTipText(hDC, &rc, lpwstr);
	}
	::SelectObject(hDC, hFontOld);
	::EndPaint(hwnd, &ps);
	//Dbg(("--->WM_PAINT END\n"));
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::MsgTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	static POINT	pt;
	static SIZE		size;
	static RECT		rect;
	static BOOL fAnimate;

#ifndef UNDER_CE // Windows CE does not support GetCursorPos
	::GetCursorPos(&pt);
#else // UNDER_CE
	if(m_lpXInfoCur){
		pt = m_lpXInfoCur->userInfo.pt;
		ClientToScreen(m_lpXInfoCur->userInfo.hwnd, &pt);
	}
#endif // UNDER_CE
	switch(wParam) {
	case TID_SHOW:
		//Dbg(("TID_SHOW COME\n"));
		KillTimer(hwnd, TID_SHOW);
		SetTimer(hwnd, TID_MONITOR, 20, NULL);
		SetTimer(hwnd, TID_DURATION, 6000, NULL);
		//get cur mouse pos
		//show tool tip window
		//call invalidate rect
		//set monitoring timer
		if(0 == GetTipSize(&size)) {
			if(m_fEnable) {
				//Dbg(("-->GetTipSize ret 0\n"));
				if(IsMousePointerIn()) {
					//Dbg(("-->Call SetWindowPos\n"));
					//990530: KOTAE #433
					INT cxScr = ::GetSystemMetrics(SM_CXSCREEN);
					INT cyScr = ::GetSystemMetrics(SM_CYSCREEN);
					
					if(cxScr < (pt.x + size.cx)) {
						pt.x = cxScr - size.cx;
					}

					if(cyScr < pt.y + 20 + size.cy) {
						pt.y = cyScr - (20*2 + size.cy);
					}

					SetWindowPos(hwnd, 
								 HWND_TOP, 
								 pt.x, pt.y+20,
								 size.cx, size.cy, 
								 SWP_NOACTIVATE | SWP_HIDEWINDOW |SWP_NOOWNERZORDER);

					fAnimate = SetWindowAnimate(hwnd);
					if(!fAnimate)
						SetWindowPos(hwnd, 
									 HWND_TOP, 
									 pt.x, pt.y+20, 
									 size.cx, size.cy, 
									 SWP_NOACTIVATE | SWP_SHOWWINDOW | SWP_NOOWNERZORDER);

					//Dbg(("-->SetWindowPos End\n"));

					m_fShow = TRUE;

					if(!fAnimate)
						InvalidateRect(hwnd, NULL, NULL);

					//Dbg(("-->Invalidate Rect End\n"));
				}
			}
		}
		//Dbg(("TID_SHOW END\n"));
		break;
	case TID_MONITOR:
		{
			//Dbg(("TID_MONITOR COME\n"));
			HWND hwndOwner = (HWND)GetWindow(hwnd, GW_OWNER);
			if(!IsMousePointerIn() || NULL == GetTipTextW() || !IsWindowVisible(hwndOwner) ) {
				//Dbg(("---> Hide Window\n"));
				::SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
							   SWP_HIDEWINDOW |
							   SWP_NOACTIVATE |
							   SWP_NOZORDER   | 
							   SWP_NOSIZE		| 
							   SWP_NOMOVE);
				//Dbg(("Set curInfo NULL\n"));
				m_lpXInfoCur = NULL;
				m_fShow = FALSE;
				::KillTimer(hwnd, TID_MONITOR);
				::KillTimer(hwnd, TID_DURATION);
			}
		}
		break;
	case TID_DURATION:
		//Dbg(("TID_DURATION START\n"));
		SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
					 SWP_NOZORDER   |
					 SWP_NOSIZE     |
					 SWP_HIDEWINDOW |
					 SWP_NOACTIVATE);
		//Dbg(("Set curInfo NULL\n"));
		//lptt->lpXInfoCur = NULL;
		m_fShow = FALSE;
		::KillTimer(hwnd, TID_MONITOR);
		::KillTimer(hwnd, TID_DURATION);
		break;
	default:
		break;
	}
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::MsgDestroy(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	Dbg(("WM_DESTORY START\n"));
	::KillTimer(hwnd, TID_SHOW);
	::KillTimer(hwnd, TID_MONITOR);
	::KillTimer(hwnd, TID_DURATION);
	LPXINFO lpXInfo, lpXInfoNext;
	m_lpXInfoCur = NULL;
	INT i;
	for(lpXInfo = m_lpXInfoHead, i = 0;
		lpXInfo;
		lpXInfo = lpXInfoNext, i++){
		lpXInfoNext = lpXInfo->next;
		//Dbg(("-->%d: Free XInfo\n", i));
		MemFree(lpXInfo);
	}
	if(m_hFont) {
		::DeleteObject(m_hFont); 
		m_hFont = NULL;
	}
	Dbg(("--->WM_DESTORY END\n"));
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_SetDelayTime(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	switch(wParam) {
	case TTDT_AUTOMATIC:
		break;
	case TTDT_RESHOW:
		break;
	case TTDT_AUTOPOP:
		break;
	case TTDT_INITIAL:
		break;
	}
	m_dwDelayFlag = (DWORD)wParam;
	m_dwDelayTime = (DWORD)lParam;
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_AddToolW(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	TOOLINFOW *lpTi = (LPTOOLINFOW)lParam;
	if(!lpTi) {
		Dbg(("################### lParam is NULLL\n"));
		return 0;
	}
	if(lpTi->cbSize !=  sizeof(TOOLINFOW)) {
		Dbg(("##### TTM_ADDTOOLW size ERROR\n"));
		return 0;
	}
	LPXINFO *ppXInfo, lpXInfoNew;
	lpXInfoNew = XInfo_New();
	if(!lpXInfoNew) {
		return 0;
	}
	lpXInfoNew->toolInfoW = *lpTi;
	for(ppXInfo = &m_lpXInfoHead; 
		*ppXInfo; 
		ppXInfo = &(*ppXInfo)->next){
	}
	*ppXInfo = lpXInfoNew;
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_DelToolW(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	TOOLINFOW *lpTi = (LPTOOLINFOW)lParam;
	if(!lpTi) {
		Dbg(("################### lParam is NULLL\n"));
		return 0;
	}
	if(lpTi->cbSize !=  sizeof(TOOLINFOW)) {
		return 0;
	}
	LPXINFO *ppXInfo, lpXInfoTmp;
	for(ppXInfo = &m_lpXInfoHead; *ppXInfo; ppXInfo = &(*ppXInfo)->next){
		if((*ppXInfo)->toolInfoW.hwnd == lpTi->hwnd &&
		   (*ppXInfo)->toolInfoW.uId  == lpTi->uId) {
			lpXInfoTmp = *ppXInfo;
			*ppXInfo = (*ppXInfo)->next;
			if(lpXInfoTmp == m_lpXInfoCur) {
				//Dbg(("Set curInfo NULL\n"));
				m_lpXInfoCur = NULL;
			}
			MemFree(lpXInfoTmp);
			Dbg(("TTM_DELTOOLW SUCCEEDED\n"));
			return 0;
			break;
		}
	}
	Dbg(("TTM_DELTOOLW Error END\n"));
	return -1;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_NewToolRectW(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	TOOLINFOW *lpTi = (LPTOOLINFOW)lParam;
	if(lpTi->cbSize !=  sizeof(TOOLINFOW)) {
		return 0;
	}
	LPXINFO *ppXInfo;
	for(ppXInfo = &m_lpXInfoHead; *ppXInfo; ppXInfo = &(*ppXInfo)->next) {
		if((*ppXInfo)->toolInfoW.hwnd == lpTi->hwnd &&
		   (*ppXInfo)->toolInfoW.uId  == lpTi->uId) {
			if(m_lpXInfoCur == *ppXInfo) {
				m_xInfoPrev = *(m_lpXInfoCur);
			}
			(*ppXInfo)->toolInfoW = *lpTi;
			break;
		}
	}
	return 0;
	UnrefMsg();
}

// SendMessage(hwnd, TTM_RELAYEVENT_WITHUESRINFO, 0, LPTOOLTIPUSERINFO lpInfo);
LRESULT CDWToolTip::TTM_RelayEventWithUserInfo(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	INT i;
	LPXINFO *ppXInfo;
	LPTOOLTIPUSERINFO lpUserInfo = (LPTOOLTIPUSERINFO)lParam;
	//Dbg(("TTM_RELAYEVENT_WITHUSERINFO START\n"));
	if(!lpUserInfo) {
		//Dbg(("--->TTM_RELAYEVENT_WITHUSERINFO ERROR END\n"));
		return 0;
	}
	for(i = 0, ppXInfo = &m_lpXInfoHead; 
		*ppXInfo;
		i++, ppXInfo = &(*ppXInfo)->next) {
		UINT uFlags = (*ppXInfo)->toolInfoW.uFlags;
		if(uFlags & TTF_IDISHWND) {
			if((HWND)(*ppXInfo)->toolInfoW.uId == lpUserInfo->hwnd) {
				//Dbg(("[%d]Find info with hwnd index\n", i));
				break;
			}
		}
		else {
#ifdef _DEBUG //970915:
			if(!IsWindow(lpUserInfo->hwnd)) {
				Dbg(("############## hwnd corrupted [0x%08x]\n", 
					 lpUserInfo->hwnd));
				DebugBreak();
			}
			if(!IsWindow((*ppXInfo)->toolInfoW.hwnd)) {
				Dbg(("############## hwnd corrupted [0x%08x]\n", 
					 (*ppXInfo)->toolInfoW.hwnd));
				DebugBreak();
			}
#endif
			if(lpUserInfo->hwnd == GetDlgItem((*ppXInfo)->toolInfoW.hwnd, 
											  (INT)(*ppXInfo)->toolInfoW.uId)) {
				break;
			}
			else if(lpUserInfo->hwnd == (*ppXInfo)->toolInfoW.hwnd) {
				if(PtInRect(&(*ppXInfo)->toolInfoW.rect, lpUserInfo->pt)) {
					break;
				}
			}
#if 0
			if(PtInRect(&(*ppXInfo)->toolInfoW.rect, lpUserInfo->pt)) {
				Dbg(("[%d]Find INFO with id [%d]\n", i, (*ppXInfo)->toolInfoW.uId));
				break;
			}
#endif
		}
	} 
	if(*ppXInfo) {
		//m_curRelayMsg = *lpmsg;
		if(m_lpXInfoCur == *ppXInfo) {  // Same info is used.
			//check specified rect is same or not
			// it is very dirty code.....
			// if rectangle is same. 
			if((lpUserInfo->rect.left   == (*ppXInfo)->userInfo.rect.left ) &&
			   (lpUserInfo->rect.top    == (*ppXInfo)->userInfo.rect.top  ) &&
			   (lpUserInfo->rect.right  == (*ppXInfo)->userInfo.rect.right) &&
			   (lpUserInfo->rect.bottom == (*ppXInfo)->userInfo.rect.bottom)) { 
				//Dbg(("Set Timer 500\n"));
				//SetTimer(hwnd, TID_SHOW, 500, NULL);
			}
			else {
				//if rectangl is NOT same, it should be displayed now
				//Dbg(("Set Timer 10\n"));
				SetTimer(hwnd, TID_SHOW, 100, NULL);
			}
		}
		else {  
			SetTimer(hwnd, TID_SHOW, 500, NULL);
		}
		(*ppXInfo)->whichEvent = TTM_RELAYEVENT_WITHUSERINFO;
		(*ppXInfo)->userInfo   = *lpUserInfo;
		m_lpXInfoCur = *ppXInfo;
		//Dbg(("--->TTM_REUSER END\n"));
	}
	else {
		//Dbg(("Set curInfo NULL\n"));
		m_lpXInfoCur = NULL;
		//Dbg(("--->TTM_REUSER CUR NULL END\n"));
	}
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_RelayEvent(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	LPMSG lpmsg = (LPMSG)lParam;
	INT	i;
	LPXINFO *ppXInfo; //lpXInfo; //, lpXInfoCur;
	if(!lpmsg) {
		return 0;
	}
	switch(lpmsg->message) {
	case WM_LBUTTONDOWN:
	case WM_MOUSEMOVE:
	case WM_LBUTTONUP:
	case WM_RBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
		for(i = 0, ppXInfo = &m_lpXInfoHead; 
			*ppXInfo;
			i++, ppXInfo = &(*ppXInfo)->next) {
			UINT uFlags = (*ppXInfo)->toolInfoW.uFlags;
			if(uFlags & TTF_IDISHWND) {
				if((HWND)(*ppXInfo)->toolInfoW.uId == lpmsg->hwnd) {
					//Dbg(("[%d]Find info with hwnd index\n", i));
					break;
				}
			}
			else {
				POINT pt;
				pt.x = LOWORD(lpmsg->lParam);
				pt.y = HIWORD(lpmsg->lParam);
				if(PtInRect(&(*ppXInfo)->toolInfoW.rect, pt)) {
					//Dbg(("[%d]Find INFO with id [%d]\n", i, (*ppXInfo)->toolInfoW.uId));
					break;
				}
			}
		} 
		if(*ppXInfo) {
			m_curRelayMsg = *lpmsg;
			(*ppXInfo)->whichEvent = TTM_RELAYEVENT;
			if(m_lpXInfoCur) { 
				if(m_lpXInfoCur != *ppXInfo) {
					//Dbg(("-->SetTimer TID_SHOW with 100msec\n"));
					SetTimer(hwnd, TID_SHOW, 100, NULL);
					m_xInfoPrev = *m_lpXInfoCur;
				}
				else {  
					//----------------------------------------------------------------
					//m_lpXInfoCur is not changed.
					//check rectangle, other information is same or not
					//----------------------------------------------------------------
					if(!IsSameInfo(&m_xInfoPrev, *ppXInfo)) { 
						SetTimer(hwnd, TID_SHOW, 100, NULL);
						m_xInfoPrev = **ppXInfo;
					}
				}
				//else {
				//	SetTimer(hwnd, TID_SHOW, 500, NULL);
				//}
				
			}
			else {  
				//Dbg(("-->SetTimer TID_SHOW with 500msec\n"));
				SetTimer(hwnd, TID_SHOW, 500, NULL);
			}
			m_lpXInfoCur = *ppXInfo;
		}
		else {
			//Dbg(("Set curInfo NULL\n"));
			m_lpXInfoCur = NULL;
		}
		break;
	default:
		break;
	}
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_GetSetToolInfoW(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPTOOLINFOW lpTi = (LPTOOLINFOW)lParam;
	if(lpTi->cbSize != sizeof(TOOLINFOW)) {
		return 0;
	}
	LPXINFO *ppXInfo;
	for(ppXInfo = &m_lpXInfoHead; *ppXInfo; ppXInfo = &(*ppXInfo)->next) {
		if((*ppXInfo)->toolInfoW.hwnd == lpTi->hwnd && 
		   (*ppXInfo)->toolInfoW.uId  == lpTi->uId) {
			if(uMsg == TTM_GETTOOLINFOW) {
				(*lpTi) = (*ppXInfo)->toolInfoW;
			}
			else {
				(*ppXInfo)->toolInfoW = *lpTi;
			}
			break;
		}
	}
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_GetToolCount(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	INT i;
	LPXINFO *ppXInfo;
	for(i = 0, ppXInfo = &m_lpXInfoHead;
		*ppXInfo;
		ppXInfo = &(*ppXInfo)->next, i++) {
	}
	return i;
	UnrefMsg();
}

BOOL CDWToolTip::Enable(HWND hwndToolTip, BOOL fEnable)
{
	if(m_hwndSelf != hwndToolTip) {
		//Dbg(("ToolTip Enable Invalid Window Handle\n"));
		return 0;
	}
	m_fEnable = fEnable;
	m_fShow   = fEnable;
	if(!fEnable) { //if fEnable FALSE
		::SetWindowPos(hwndToolTip, NULL, 0, 0, 0, 0, 
					   SWP_HIDEWINDOW |
					   SWP_NOACTIVATE |
					   SWP_NOZORDER   | 
					   SWP_NOSIZE	  | 
					   SWP_NOMOVE);
		::KillTimer(hwndToolTip, TID_SHOW);
		::KillTimer(hwndToolTip, TID_MONITOR);
		::KillTimer(hwndToolTip, TID_DURATION);
	}
	return 0;
}

LPWSTR CDWToolTip::GetTipTextW(VOID)
{
	static TOOLTIPTEXTW			toolTipTextW;
	static TOOLTIPTEXTUSERINFO	ttTextUserInfo;
	INT idCtrl;
	if(!m_lpXInfoCur) {
		//Dbg(("GetTipTextW m_lpXInfoCur is NULL\n"));
		return NULL;
	}
	if(m_lpXInfoCur->toolInfoW.uFlags & TTF_IDISHWND) {
		idCtrl = GetDlgCtrlID((HWND)m_lpXInfoCur->toolInfoW.uId);
	}
	else {
		idCtrl = (INT)m_lpXInfoCur->toolInfoW.uId;
	}
	switch(m_lpXInfoCur->whichEvent) {
	case TTM_RELAYEVENT_WITHUSERINFO:
		ZeroMemory((LPVOID)&ttTextUserInfo, sizeof(ttTextUserInfo));
		ttTextUserInfo.hdr.hwndFrom = m_hwndSelf;
		ttTextUserInfo.hdr.idFrom   = idCtrl;
		ttTextUserInfo.hdr.code     = TTN_NEEDTEXT_WITHUSERINFO;
		ttTextUserInfo.userInfo   = m_lpXInfoCur->userInfo;
		::SendMessage(m_lpXInfoCur->toolInfoW.hwnd, 
					  WM_NOTIFY, 
					  (WPARAM)0, 
					  (LPARAM)&ttTextUserInfo);
#if _DEBUG
		if(!toolTipTextW.lpszText) {
			//Dbg(("###### Text is NULL\n"));
		}
#endif
		return (LPWSTR)ttTextUserInfo.lpszText;
		break;
	case TTM_RELAYEVENT:
	default:
		ZeroMemory((LPVOID)&toolTipTextW, sizeof(toolTipTextW));
		toolTipTextW.hdr.hwndFrom = m_hwndSelf;
		toolTipTextW.hdr.idFrom   = idCtrl;
		toolTipTextW.hdr.code     = TTN_NEEDTEXTW;
		toolTipTextW.hinst			= m_lpXInfoCur->toolInfoW.hinst;
		toolTipTextW.uFlags			= m_lpXInfoCur->toolInfoW.uFlags;
		if(m_lpXInfoCur->toolInfoW.lpszText == LPSTR_TEXTCALLBACKW) {
			if(!m_lpXInfoCur->toolInfoW.hwnd) {
				//Dbg(("###### hwnd is NULL\n"));
				return NULL;
			}
			if(!IsWindow(m_lpXInfoCur->toolInfoW.hwnd)) {
				//Dbg(("###### hwnd is Corrupted?\n"));
				return NULL;
			}
			SendMessage(m_lpXInfoCur->toolInfoW.hwnd, 
						WM_NOTIFY, 
						(WPARAM)0, 
						(LPARAM)&toolTipTextW);
#ifdef _DEBUG 
			if(!toolTipTextW.lpszText) {
				//Dbg(("###### Text is NULL\n"));
			}
#endif
			return (LPWSTR)toolTipTextW.lpszText;
		}
		break;
	}
	return NULL;
}

INT CDWToolTip::GetTipSize(LPSIZE lpSize)
{
	LPWSTR lpwstr = GetTipTextW();
	HDC hDC;
	SIZE size;
	INT	 i;
	LPWSTR lp, lpTop;
	//Dbg(("GetTipSize START \n"));

	if(!lpSize) {
		//Dbg(("-->GetTipSize ERROR END\n"));
		return -1;
	}
	if(!lpwstr) {
		//Dbg(("--->GetTipSize lpwstr is NULL\n"));
		return -1;
	}
	//DBGW((L"lpwst [%s]\n", lpwstr));
#ifdef _DEBUG 
	if(!IsWindow(m_hwndSelf)) {
		//Dbg(("######### hwnd is Corrupted [0x%08x]\n", m_hwndSelf));
		DebugBreak();
	}
#endif
	hDC = ::GetDC(m_hwndSelf);
	HFONT hFontOld = NULL;
	if(m_hFont) {
		hFontOld = (HFONT)::SelectObject(hDC, m_hFont);
	}
	else { 
		hFontOld = (HFONT)::SelectObject(hDC, GetStockObject(DEFAULT_GUI_FONT));
	}
	lpSize->cx = lpSize->cy = 0;
	for(i=0, lpTop = lp = lpwstr;;lp++) {
		if(*lp == (WCHAR)L'\n') {
			//Dbg(("Find return i[%d]\n", i));
			ExGetTextExtentPoint32W(hDC, lpTop, i, &size);
			//Dbg(("cx[%d] cy[%d]\n", size.cx, size.cy));
			lpSize->cx = MAX(lpSize->cx, size.cx);
			lpSize->cy += size.cy;
			lpTop = lp+1;
			i = 0;
		}
		else if (*lp == (WCHAR)0x0000) {
			ExGetTextExtentPoint32W(hDC, lpTop, i, &size);
			lpSize->cx = MAX(lpSize->cx, size.cx);
			lpSize->cy += size.cy;
			break;
		}
		else {
			i++;
		}
	}
	lpSize->cx += 4;
	lpSize->cy += 4;
	::SelectObject(hDC, hFontOld);
	::ReleaseDC(m_hwndSelf, hDC);
	//Dbg(("TIP SIZE cx[%d] cy[%d]\n", lpSize->cx, lpSize->cy));
	//Dbg(("-->GetTipSize NORMAL END\n"));
	return 0;
}

INT CDWToolTip::DrawTipText(HDC hDC, LPRECT lpRc, LPWSTR lpwstr)
{
	SIZE size;
	INT	 i, j;
	LPWSTR lp, lpTop;
	if(!lpwstr) {
		return 0;
	}
	if(!lpRc) {
		return 0;
	}
	INT yOffset = 0;
#ifndef UNDER_CE
	::FillRect(hDC, lpRc, (HBRUSH)(COLOR_INFOBK + 1));
#else // UNDER_CE
	::FillRect(hDC, lpRc, GetSysColorBrush(COLOR_INFOBK));
#endif // UNDER_CE
	COLORREF dwOldTC = ::SetTextColor(hDC, GetSysColor(COLOR_INFOTEXT));
	DWORD oldMode = ::SetBkMode(hDC, TRANSPARENT);
	// Init size
	size.cx = size.cy = 0;
	
	for(i=j=0, lpTop = lp = lpwstr;;lp++) {
		if(*lp == L'\n' || *lp == (WCHAR)0x0000) {
			ExGetTextExtentPoint32W(hDC, lpTop, i, &size);
			//Dbg(("Length %d\n", i));
			ExExtTextOutW(hDC,
						  lpRc->left + 1,
						  lpRc->top  + 1 + yOffset,
						  ETO_CLIPPED, lpRc,
						  lpTop, 
						  i,
						  NULL);
			if(*lp == (WCHAR)0x0000) {
				break;
			}
			lpTop = lp+1;
			i = 0;
			j++;
			yOffset += size.cy;
		}
		else {
			i++;
		}
	}
	::SetTextColor(hDC, dwOldTC);
	::SetBkMode(hDC, oldMode);
	return 0;
}

BOOL CDWToolTip::IsMousePointerIn(VOID)
{
	POINT	pt;
	RECT	rect;
	HWND hwndTarget;

	//Dbg(("IsMousePointerIn START\n"));
#ifndef UNDER_CE // Windows CE does not support GetCursorPos
	::GetCursorPos(&pt);
#else // UNDER_CE
	if(m_lpXInfoCur){
		pt = m_lpXInfoCur->userInfo.pt;
		ClientToScreen(m_lpXInfoCur->userInfo.hwnd, &pt);
	}
#endif // UNDER_CE
	if(!m_lpXInfoCur) {
		//Dbg(("--->IsMousePointer in ERROR END\n"));
		return FALSE;
	}
	if(m_lpXInfoCur->toolInfoW.uFlags & TTF_IDISHWND) {
		hwndTarget = (HWND)m_lpXInfoCur->toolInfoW.uId;
		//Dbg(("---> TYPE TTF_IDISHWND hwnd[0x%08x]\n", hwndTarget ));
		if(IsWindow(hwndTarget)) {
			//Dbg(("--->IsWindow OK\n"));
			GetWindowRect(hwndTarget, &rect);
			//Dbg(("--->GetWindowRect OK\n"));
			if(PtInRect(&rect, pt)) {
				return TRUE;
			}
			return FALSE;
		}
		else {
			//Dbg(("################ hwndTarget[0x%08x] IS CORRUPTED\n", hwndTarget));
		}
	}
	else {
		switch(m_lpXInfoCur->whichEvent) {
		case TTM_RELAYEVENT:
			//OLD_970808
			::ScreenToClient(m_lpXInfoCur->toolInfoW.hwnd, &pt);
			if(::PtInRect(&m_lpXInfoCur->toolInfoW.rect, pt)) {
				return TRUE;
			}
			break;
		case TTM_RELAYEVENT_WITHUSERINFO:
			if(IsWindow(m_lpXInfoCur->toolInfoW.hwnd)) {
				HWND hwndCmd = GetDlgItem(m_lpXInfoCur->toolInfoW.hwnd, 
										  (INT)m_lpXInfoCur->toolInfoW.uId);
				RECT rc;
				::GetClientRect(hwndCmd, &rc);
				//LPRECT lpRc = &rc;
#if 0
				Dbg(("--->t[%d]l[%d]r[%d]b[%d]\n",
					 lpRc->top,
					 lpRc->left,
					 lpRc->right,
					 lpRc->bottom));			
#endif
				::ScreenToClient(hwndCmd, &pt);
				Dbg(("--->pt.x[%d] pt.y[%d]\n", pt.x, pt.y));
				if(PtInRect(&rc, pt)) {
					if(PtInRect(&m_lpXInfoCur->userInfo.rect, pt)) {
						return TRUE;
					}
				}
				else {
					//Dbg(("--->Is Mouse PtInRect Error END\n"));
				}
			}
			else {
				Dbg(("################ hwndTarget[0x%08x] IS CORRUPTED\n", 
					 m_lpXInfoCur->toolInfoW.hwnd));
			}
			break;
		}
	}
	//Dbg(("--->Is Mouse PtInRect Error END\n"));
	return FALSE;
}

BOOL CDWToolTip::IsSameInfo(LPXINFO lpXInfo1, LPXINFO lpXInfo2)
{
	if(!lpXInfo1 || !lpXInfo2) {
		return FALSE;
	}
	switch(lpXInfo1->whichEvent) {
	case TTM_RELAYEVENT:
		if(lpXInfo2->whichEvent != TTM_RELAYEVENT) {
			return FALSE;
		}
		if((lpXInfo1->toolInfoW.uFlags != lpXInfo2->toolInfoW.uFlags) || 
		   (lpXInfo1->toolInfoW.hwnd   != lpXInfo2->toolInfoW.hwnd)   ||
		   (lpXInfo1->toolInfoW.uId    != lpXInfo2->toolInfoW.uId)    ||
		   (lpXInfo1->toolInfoW.rect.top   != lpXInfo2->toolInfoW.rect.top)   ||
		   (lpXInfo1->toolInfoW.rect.left  != lpXInfo2->toolInfoW.rect.left)  ||
		   (lpXInfo1->toolInfoW.rect.right != lpXInfo2->toolInfoW.rect.right) ||
		   (lpXInfo1->toolInfoW.rect.bottom!= lpXInfo2->toolInfoW.rect.bottom)) {
			return FALSE;
		}
		break;
	case TTM_RELAYEVENT_WITHUSERINFO:
		if(lpXInfo2->whichEvent != TTM_RELAYEVENT_WITHUSERINFO) {
			return FALSE;
		}
		if((lpXInfo1->userInfo.hwnd != lpXInfo2->userInfo.hwnd) ||
		   (lpXInfo1->userInfo.pt.x != lpXInfo2->userInfo.pt.x) ||
		   (lpXInfo1->userInfo.pt.y != lpXInfo2->userInfo.pt.y) ||
		   (lpXInfo1->userInfo.rect.top    != lpXInfo2->userInfo.rect.top)    ||
		   (lpXInfo1->userInfo.rect.left   != lpXInfo2->userInfo.rect.left)   ||
		   (lpXInfo1->userInfo.rect.right  != lpXInfo2->userInfo.rect.right)  ||
		   (lpXInfo1->userInfo.rect.bottom != lpXInfo2->userInfo.rect.bottom)) {
			return FALSE;
		}
		break;
	} 
	return TRUE;
}

//----------------------------------------------------------------
POSVERSIONINFO CDWToolTip::GetVersionInfo()
{
    static BOOL fFirstCall = TRUE;
    static OSVERSIONINFO os;

    if ( fFirstCall ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &os ) ) {
            fFirstCall = FALSE;
        }
    }
    return &os;
}

BOOL CDWToolTip::IsWinNT4() 
{ 
	BOOL fNT4;
	fNT4 = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
		(GetVersionInfo()->dwMajorVersion >= 4);

	return fNT4;
}

BOOL CDWToolTip::IsWinNT5() 
{ 
	BOOL fNT5;
	fNT5 = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
		(GetVersionInfo()->dwMajorVersion == 5);

	return fNT5;
}

BOOL CDWToolTip::IsWinNT()
{
	return (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT);
}

BOOL CDWToolTip::IsWin95(VOID)
{
	if(GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
		return TRUE;
	}
	return FALSE;
}

BOOL CDWToolTip::IsWin98() 
{ 
	BOOL fMemphis;
	fMemphis = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
		(GetVersionInfo()->dwMajorVersion >= 4) &&
		(GetVersionInfo()->dwMinorVersion  >= 10);

	return fMemphis;
}

//----------------------------------------------------------------
//----------------------------------------------------------------
//VC6 does NOT defined 
//#define SPI_GETMENUANIMATION                0x1002
//#define SPI_GETTOOLTIPANIMATION             0x1016
//----------------------------------------------------------------
#define MY_SPI_GETMENUANIMATION                0x1002
#define MY_SPI_GETTOOLTIPANIMATION             0x1016
typedef BOOL (WINAPI *LPFNANIMATEWINDOW)(HWND hwnd, DWORD dwTime, DWORD dwFlag);
BOOL CDWToolTip::SetWindowAnimate(HWND hwnd)
{
	//----------------------------------------------------------------
	//08/16/00
	//Satori #2239. Animate window show HourGlass cursor,
	//when owner window is Disabled and very weird.
	//We should stop animate tool tip in Office10
	//----------------------------------------------------------------
	return FALSE;
	UNREFERENCED_PARAMETER(hwnd);
#if 0

#ifndef UNDER_CE // No support
	HMODULE hLib;
	LPFNANIMATEWINDOW lpfnProc;
	BOOL fRet, fAnimate;
	//----------------------------------------------------------------
	//00/08/01 for Satori #2239
	//for Win98: can use SPI_GETMENUANIMATION for Tooltip.
	//for Win2K: can use SPI_GETTOOLTIPANIMATION for Tooltip.
	//----------------------------------------------------------------
	if(IsWin98() || IsWinNT5()) {
		if(IsWin98()) {
			fRet = SystemParametersInfo(MY_SPI_GETMENUANIMATION,
										0,
										&fAnimate,
										FALSE);
			if(!fRet || !fAnimate) {
				return 0;
			}
		}
		else { //Win2K()
			fRet = SystemParametersInfo(MY_SPI_GETTOOLTIPANIMATION,
										0,
										&fAnimate,
										FALSE);
			if(!fRet || !fAnimate) {
				return 0;
			}
		}

		hLib = GetModuleHandle("user32");
		if(!hLib) {
			return 0;
		}
		lpfnProc = (LPFNANIMATEWINDOW)GetProcAddress(hLib, "AnimateWindow");
		if(lpfnProc) {
			INT ret = (*lpfnProc)(hwnd, 200, AW_VER_POSITIVE|AW_SLIDE);
			Dbg(("ret [%d] lasterror[%d]\n", ret, GetLastError()));
			return ret;
		}
	}
#endif // UNDER_CE
	return 0;
#endif //if 0
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\testmain.cpp ===
#include "imewarn.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "resource.h"
#include "testlist.h"

/* testmain.cpp */
extern BOOL InitApplication(HINSTANCE hInst, LPSTR lpstrClass, WNDPROC lpfnWndProc);
extern HWND MainCreateWindow(HINSTANCE hInst, HWND hwndOwner, LPSTR lpstrClass, LPVOID lpVoid);
extern LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);

char g_szClass[]="TestMain";
HINSTANCE g_hInst;
BOOL InitApplication(HINSTANCE hInst, LPSTR lpstrClass, WNDPROC lpfnWndProc)
{
	return 0;
}

HWND MainCreateWindow(HINSTANCE hInst, HWND hwndOwner, LPSTR lpstrClass, LPVOID lpVoid)
{
	HWND hwnd;
	hwnd = CreateDialogParam(hInst, 
							 g_szClass, 
							 hwndOwner, 
							 NULL, 
							 (LPARAM)lpVoid);
	if(!hwnd) {
		return (HWND)NULL;
	}
	UpdateWindow(hwnd);
	return hwnd;
}

LRESULT CALLBACK MainWndProc(HWND	hwnd,
							 UINT	uMsg,
							 WPARAM	wParam,
							 LPARAM	lParam)
{
	LRESULT hres;
	HWND hwndDlg;
	LPDRAWITEMSTRUCT lpdi;
		LPMEASUREITEMSTRUCT lpmi = (LPMEASUREITEMSTRUCT)lParam;
	BOOL bDraw;
	switch(uMsg) {
	case WM_CREATE:
		break;
	//case WM_HITTESET:
	//	break;
	case WM_NCHITTEST:
		break;
	case WM_MOUSEACTIVATE:
		//return MA_NOACTIVATEANDEAT;
		break;
	case WM_SYSCOMMAND:
		{
			UINT uCmdType = wParam;        // type of system command requested
			switch(uCmdType) {
			case SC_CLOSE:
				PostQuitMessage(0);
				break;
			}
		}
		break;
	case WM_COMMAND:
		switch(LOWORD(wParam)) {
		case IDC_BUTTON1:
			hwndDlg = TestList_Create(g_hInst, hwnd);
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);


	//hres = DispMessage(&msdiMain, hwnd, uMsg, wParam, lParam);
	//return hres;
}

int WINAPI WinMain(HINSTANCE hInstance,
				   HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine,
				   int nCmdShow)
{

	MSG msg;
	HWND hwnd;
	INT ret;
	
	g_hInst = hInstance;
	WNDCLASSEX  wc;
	ZeroMemory(&wc, sizeof(wc));

	wc.cbSize			= sizeof(wc);
	wc.style			= CS_HREDRAW | CS_VREDRAW;	 /* Class style(s). */
	wc.lpfnWndProc		= (WNDPROC)MainWndProc;
	wc.cbClsExtra		= 0;					/* No per-class extra data.*/
	wc.cbWndExtra		= DLGWINDOWEXTRA;		/* No per-window extra data.		  */
	wc.hInstance		= hInstance;			/* Application that owns the class.	  */
	wc.hIcon			= NULL; //LoadIcon(hInstance, MAKEINTRESOURCE(SCROLL32_ICON));
	wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground	= GetStockObject(LTGRAY_BRUSH); //WHITE_BRUSH); 
	wc.lpszMenuName		= NULL; //g_szClass;    /* Name of menu resource in .RC file. */
	wc.lpszClassName	= g_szClass;	  /* Name used in call to CreateWindow. */
	wc.hIconSm = NULL;
	RegisterClassEx(&wc);

	hwnd = CreateDialog(hInstance, 
						g_szClass, 
						0, 
						NULL);

	UpdateWindow(hwnd); 
	ShowWindow(hwnd, SW_SHOW);
	while (GetMessage(&msg, NULL, 0, 0)){
		TranslateMessage(&msg);
		DispatchMessage(&msg); 
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\cdwtt.h ===
#ifndef __C_DWTT_H__
#define __C_DWTT_H__
#include "ptt.h"

inline LPVOID GetHWNDPtr(HWND hwnd)
{
#ifdef _WIN64
	return (LPVOID)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	return (LPVOID)::GetWindowLong(hwnd, GWL_USERDATA);
#endif
}

inline LPVOID SetHWNDPtr(HWND hwnd, LPVOID lpVoid)
{
#ifdef _WIN64
	return (LPVOID)::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpVoid);
#else
	return (LPVOID)::SetWindowLong(hwnd, GWL_USERDATA, (LONG)lpVoid);
#endif
}

//----------------------------------------------------------------
//Disabled Window ToolTip class
//----------------------------------------------------------------
// For Disabled Window Tool Tip data
//----------------------------------------------------------------
typedef struct tagXINFO {
	struct tagXINFO		*next;
	INT					whichEvent;			//TTM_RELAYEVNET or TTM_RELAYEVENT_WITHUSERINFO
	TOOLTIPUSERINFO		userInfo;
	TOOLINFOW			toolInfoW;
}XINFO, *LPXINFO;

class CDWToolTip;
typedef CDWToolTip *LPCDWToolTip;

class CDWToolTip
{
public:
	CDWToolTip(HWND hwnd);
	~CDWToolTip();
	BOOL Enable(HWND hwndToolTip, BOOL fEnable);	
	void *operator new(size_t size);
	void operator  delete(void *p);
	static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
private:
	LRESULT RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT MsgCreate		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT MsgPrintClient	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT MsgPaint		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT	MsgTimer		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT	MsgDestroy		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT	MsgSetFont		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_SetDelayTime(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_AddToolW	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT	TTM_DelToolW	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_NewToolRectW(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_RelayEventWithUserInfo(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_RelayEvent(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_GetSetToolInfoW(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_GetToolCount(HWND hwnd, WPARAM wParam, LPARAM lParam);
	BOOL	SetWindowAnimate(HWND hwnd);
	LPWSTR	GetTipTextW(VOID);
	INT		GetTipSize	(LPSIZE lpSize);	
	INT		DrawTipText	(HDC hDC, LPRECT lpRc, LPWSTR lpwstr);
	BOOL	IsMousePointerIn(VOID);
	BOOL	IsSameInfo(LPXINFO lpXInfo1, LPXINFO lpXInfo2);
	static POSVERSIONINFO GetVersionInfo();
	static BOOL	IsWinNT4(VOID);
	static BOOL	IsWinNT5(VOID);
	static BOOL	IsWinNT(VOID);
	static BOOL	IsWin98(VOID);
	static BOOL	IsWin95(VOID);
private:
	HWND	m_hwndSelf;
	HFONT	m_hFont;
	BOOL	m_fShow;			//Already show or not;
	DWORD	m_dwDelayFlag;
	DWORD   m_dwDelayTime;
	DWORD	m_dwDurationTime;
	LPXINFO	m_lpXInfoHead;
	LPXINFO	m_lpXInfoCur;
	XINFO	m_xInfoPrev;		//New 971104
	MSG		m_curRelayMsg;
	BOOL	m_fEnable;		//if FALSE never show tooltip;
};
#endif // __C_DWTT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\dbg.cpp ===
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#pragma warning(disable:4057)
#pragma warning(disable:4115)
#pragma warning(disable:4200)
#pragma warning(disable:4201)
#pragma warning(disable:4209)
#pragma warning(disable:4214)
#pragma warning(disable:4218)
#pragma warning(disable:4310)
#pragma warning(disable:4514)
#pragma warning(disable:4699)
#pragma warning(disable:4710)

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdarg.h>
#include "dbg.h"
#include <stdio.h>

static IsWinNT()
{
	static OSVERSIONINFO os;
	if(os.dwOSVersionInfoSize == 0) { 
		os.dwOSVersionInfoSize = sizeof(os);
		::GetVersionEx(&os);
	}
	return (os.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

//----------------------------------------------------------------
//internal function prototype declare
//----------------------------------------------------------------
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath);
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath);
VOID   _pttDbgPrintfA			(LPSTR  lpstrFmt, ...);
VOID   _pttDbgPrintfW			(LPWSTR lpstrFmt, ...);

//----------------------------------------------------------------
// Global Data
//----------------------------------------------------------------
static LPFNDBGCALLBACKA g_lpfnDbgCBA;
static LPFNDBGCALLBACKW g_lpfnDbgCBW;
static BOOL g_fEnable=FALSE;
inline VOID ODStrW(LPWSTR lpwstr)
{
	if(g_fEnable) OutputDebugStringW(lpwstr);
}
inline VOID ODStrA(LPSTR lpstr)
{
	if(g_fEnable) OutputDebugStringA(lpstr);
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgSetCallback
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPFNDBGCALLBACK lpfnDbgCallback 
// Return   : 
// DATE     : Tue Jan 06 12:42:36 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgSetCallback(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW)
{
	g_lpfnDbgCBA = lpfnCBA;
	g_lpfnDbgCBW = lpfnCBW;
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgSwitchOutput
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:35:55 1998
// Author   : 
//////////////////////////////////////////////////////////////////
VOID _pttDbgEnableOutput(BOOL fEnable)
{
	g_fEnable = fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgIsOutputEnable
// Type     : VOID
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 18:00:52 1998
// Author   : 
//////////////////////////////////////////////////////////////////
BOOL _pttDbgIsOutputEnable(VOID)
{
	return g_fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgOutStrA
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Tue Jan 06 12:29:39 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgOutStrA(LPSTR lpstr)
{
	static BOOL fIn;
	ODStrA(lpstr);
#ifdef _CONSOLE
	printf(lpstr);
#endif

	if(g_lpfnDbgCBA) {
		if(fIn) { return; }
		fIn = TRUE;
		(*g_lpfnDbgCBA)(lpstr);
		fIn = FALSE;
	}
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgOutStrW
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpwstr 
// Return   : 
// DATE     : Tue Jan 06 12:30:07 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgOutStrW(LPWSTR lpwstr)
{
	static BOOL fIn;

	if(IsWinNT()) {
		ODStrW(lpwstr);
	}
	else {
		static CHAR szBuf[1024];
		::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
		ODStrA(szBuf);
	}

#ifdef _CONSOLE
	static CHAR szBuf[1024];
	::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
	printf(szBuf);
#endif
	if(g_lpfnDbgCBW) { 
		if(fIn) { return; } 		
		fIn = TRUE;
		(*g_lpfnDbgCBW)(lpwstr);
		fIn = FALSE;
	}
	return;
}

////////////////////////////////////////////////////////
// Function: _pttDbgA
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _pttDbgA(LPSTR		lpstrFile, 
			 INT		lineNo, 
			 LPSTR		lpstrMsg)
{
	_pttDbgPrintfA("(%12s:%4d) %s", 
				 GetFileTitleStrA(lpstrFile),
				 lineNo,
				 lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFile 
//          : INT lineNo 
//          : LPWSTR lpstrMsg 
// Return   : 
// DATE     : Mon Jan 05 15:10:41 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg)
{
	_pttDbgPrintfW(L"(%12s:%4d) %s", 
			   GetFileTitleStrW(lpstrFile),
			   lineNo,
			   lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgVaStrA
// Type     : LPSTR
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:09:53 1998
//////////////////////////////////////////////////////////////////
LPSTR _pttDbgVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(chBuf, lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function : _pttDbgVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _pttDbgVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap);	//Use C-RunTime Library for Win95
	va_end(ap);
	return wchBuf;
}


////////////////////////////////////////////////////////
// Function: _pttDbgPrintfA
// Type    : VOID
// Purpose : variable args version of OutputDebugStringA
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _pttDbgPrintfA(LPSTR lpstrFmt, ...)
{
	static CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	_pttDbgOutStrA(szBuf);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgPrintfW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:11:24 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgPrintfW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap); //Use C-RunTime Library for Win95
	va_end(ap);
	_pttDbgOutStrW(wchBuf);
	return;
}


//////////////////////////////////////////////////////////////////
// Function : _pttDbgMulti2Wide
// Type     : LPWSTR
// Purpose  : return Unicode string from MBCS string
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Mon Jan 05 15:10:48 1998
//////////////////////////////////////////////////////////////////
LPWSTR _pttDbgMulti2Wide(LPSTR lpstr)
{
	static WCHAR wchBuf[512];
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}


//////////////////////////////////////////////////////////////////
// Function : _pttDbgGetWinClass
// Type     : LPSTR
// Purpose  : Get Windows class name string
//			  ANSI version only.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:08:43 1998
//////////////////////////////////////////////////////////////////
LPSTR _pttDbgGetWinClass(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetClassNameA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;

}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgGetWinText
// Type     : LPSTR
// Purpose  : Get Windows text(title) string
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:09:08 1998
//////////////////////////////////////////////////////////////////
LPSTR _pttDbgGetWinText(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetWindowTextA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgMsgBoxA
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Thu Jan 08 12:31:03 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgMsgBoxA(LPSTR lpstrFile,  INT lineNo, LPSTR lpstrMsg)
{
#ifdef _CONSOLE
	return;
#endif
	char szTmp[512];
	wsprintf(szTmp, "Debug Message Box (File: %s, Line: %4d)", 
			   GetFileTitleStrA(lpstrFile), 
			   lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
}

VOID _pttDbgAssert(LPSTR  lpstrFile,  INT lineNo, BOOL fOk, LPSTR lpstrMsg)
{
	if(fOk) {
		return; 
	}
	char szTmp[512];
	wsprintf(szTmp, "ASSERT (File: %s, Line: %4d)", 
			 GetFileTitleStrA(lpstrFile), 
			 lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
	DebugBreak();
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgGetErrorString
// Type     : LPSTR
// Purpose  : Convert Error(Got from GetLastError()) value to ERROR Message String
// Args     : 
//          : INT errorCode 
// Return   : 
// DATE     : Mon Jan 05 16:43:34 1998
//////////////////////////////////////////////////////////////////
LPSTR _pttDbgGetErrorString(INT errorCode)
{
	static CHAR szBuf[512];
	INT count;
	szBuf[0] = (CHAR)0x00;
	count = wsprintf(szBuf, "[0x%08x]:", errorCode);
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   errorCode, 
				   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				   szBuf+count,
				   sizeof(szBuf)-1-count,
				   NULL );
	if(*(szBuf + count) != (CHAR)0x00) {
		int nLen = lstrlenA(szBuf);
		if((nLen - count) > 1) {
			szBuf[nLen - 1] = (CHAR)0x00;
		}
	}
	return szBuf;
}


//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrA
// Type     : static LPSTR
// Purpose  : Return File name string(remove folder)
// Args     : 
//          : LPSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:34:22 1998
//////////////////////////////////////////////////////////////////
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath)
{
	static CHAR szBuf[2];
	CHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenA(lpstrFilePath) - 1);
	for(pTemp = CharPrevA(lpstrFilePath, pLast); 
		(pTemp  != lpstrFilePath) && 
		(*pTemp != '\\')	 &&
		(*pTemp != (CHAR)0x00); 
		pTemp = CharPrevA(lpstrFilePath, pTemp)) {
		;
	}
	if(*pTemp == '\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}

//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrW
// Type     : static LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:38:19 1998
//////////////////////////////////////////////////////////////////
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath)
{
	static WCHAR szBuf[2];
	WCHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenW(lpstrFilePath) - 1);
	for(pTemp = pLast-1;
		(pTemp != lpstrFilePath) &&
		(*pTemp != L'\\')		 &&
		(*pTemp != (WCHAR)0x0000);
		pTemp--) {
		;
	}

	if(*pTemp == L'\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\ptt.h ===
//////////////////////////////////////////////////////////////////
// File     : ptt.h
// Purpose  : Own Tooltop for disabled window
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef _PAD_TOOL_TIP_H_
#define _PAD_TOOL_TIP_H_
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <commctrl.h>
extern HWND WINAPI ToolTip_CreateWindow(HINSTANCE hInst, DWORD dwStyle, HWND hwndOwner);
extern INT  WINAPI ToolTip_Enable(HWND hwndToolTip, BOOL fEnable);
#ifdef UNDER_CE // In Windows CE, all window classes are process global.
extern BOOL ToolTip_UnregisterClass(HINSTANCE hInst);
#endif // UNDER_CE
#define TTM_RELAYEVENT_WITHUSERINFO		(WM_USER+101)
#define TTN_NEEDTEXT_WITHUSERINFO		(TTN_FIRST - 20)

typedef struct tagTOOLTIPUSERINFO {
	HWND	hwnd;
	POINT	pt;
	RECT	rect;
	LPARAM	lParam; 
}TOOLTIPUSERINFO, *LPTOOLTIPUSERINFO;

typedef struct tagTOOLTIPTEXTUSERINFO
{
	NMHDR			hdr;
	TOOLTIPUSERINFO	userInfo;
	LPWSTR			lpszText;
}TOOLTIPTEXTUSERINFO, *LPTOOLTIPTEXTUSERINFO;
#endif // _DW_TOOL_TIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\ptt.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "cdwtt.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#ifndef UNDER_CE
static char g_szClass[]="fdwtooltip";
#else // UNDER_CE
static TCHAR g_szClass[]=TEXT("fdwtooltip");
#endif // UNDER_CE

#ifdef UNDER_CE // In Windows CE, all window classes are process global.
static LPCTSTR MakeClassName(HINSTANCE hInst, LPTSTR lpszBuf)
{
	// make module unique name
	TCHAR szFileName[MAX_PATH];
	GetModuleFileName(hInst, szFileName, MAX_PATH);
	LPTSTR lpszFName = _tcsrchr(szFileName, TEXT('\\'));
	if(lpszFName) *lpszFName = TEXT('_');
	StringCchCopy(lpszBuf, MAX_PATH, g_szClass);
	StringCchCat(lpszBuf, MAX_PATH, lpszFName);

	return lpszBuf;
}

BOOL ToolTip_UnregisterClass(HINSTANCE hInst)
{
	TCHAR szClassName[MAX_PATH];
	return UnregisterClass(MakeClassName(hInst, szClassName), hInst);
}
#endif // UNDER_CE

HWND WINAPI ToolTip_CreateWindow(HINSTANCE hInst, DWORD dwStyle, HWND hwndOwner)
{
#ifndef UNDER_CE // Windows CE does not support EX
	WNDCLASSEX  wc;
	if(!::GetClassInfoEx(hInst, g_szClass, &wc)) {
#else // UNDER_CE
	TCHAR szClassName[MAX_PATH];
	WNDCLASS  wc;
	if(!::GetClassInfo(hInst, MakeClassName(hInst, szClassName), &wc)) {
#endif // UNDER_CE
		::ZeroMemory(&wc, sizeof(wc));
#ifndef UNDER_CE // Windows CE does not support EX
		wc.cbSize			= sizeof(wc);
#endif // UNDER_CE
		wc.style			= CS_HREDRAW | CS_VREDRAW;
		wc.lpfnWndProc		= (WNDPROC)CDWToolTip::WndProc;
		wc.cbClsExtra		= 0;
		wc.cbWndExtra		= 0;
		wc.hInstance		= hInst;
		wc.hIcon			= NULL; 
		wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
		wc.hbrBackground	= (HBRUSH)NULL;
		wc.lpszMenuName		= NULL; 
#ifndef UNDER_CE // In Windows CE, all window classes are process global.
		wc.lpszClassName	= g_szClass;
#else // UNDER_CE
		wc.lpszClassName	= szClassName;
#endif // UNDER_CE
#ifndef UNDER_CE // Windows CE does not support EX
		wc.hIconSm = NULL;
		::RegisterClassEx(&wc);
#else // UNDER_CE
		::RegisterClass(&wc);
#endif // UNDER_CE
	}
	HWND hwnd;
	//----------------------------------------------------------------
	//for Satori #2239.
	//If create window with WS_DISABLED, AnimateWindow change cursor as hourglass.
	//So, removed WS_DISABLED.
	//----------------------------------------------------------------
	//00/08/08: This fix is NOT enough...
	//Tooltip gets focus...
	//----------------------------------------------------------------
	hwnd =  ::CreateWindowEx(0,
#ifndef UNDER_CE // In Windows CE, all window classes are process global.
							 g_szClass,
#else // UNDER_CE
							 szClassName,
#endif // UNDER_CE
							 NULL,
							 //dwStyle | WS_POPUP | WS_BORDER | WS_VISIBLE, //WS_DISABLED,
							 dwStyle | WS_POPUP | WS_BORDER | WS_DISABLED,
							 0, 0, 0, 0, 
							 hwndOwner,
							 NULL,
							 hInst,
							 NULL);
	return hwnd;
}

INT WINAPI ToolTip_Enable(HWND hwndToolTip, BOOL fEnable)
{
	LPCDWToolTip lpCDWTT = (LPCDWToolTip)GetHWNDPtr(hwndToolTip);
	if(lpCDWTT) {
		lpCDWTT->Enable(hwndToolTip, fEnable);
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\dbg.h ===
//////////////////////////////////////////////////////////////////
// File     : dbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef _DBG_H_
#define _DBG_H_

#ifdef __cplusplus
#	define InlineFunc  inline
#else 
#	define InlineFunc  __inline
#endif

//----------------------------------------------------------------
// Callback function prototype
//----------------------------------------------------------------
typedef VOID (WINAPI *LPFNDBGCALLBACKA)(LPSTR  lpstr);
typedef VOID (WINAPI *LPFNDBGCALLBACKW)(LPWSTR lpwstr);

//-------------------------------------------------------
//MACRO function  prototype declare.
//It is valid only if compliled with _DEBUG definition.
//-------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function : DBGSetCallback
// Type     : VOID
// Purpose  : Set debug callback function.
//			  callback function has set, when DBG() has called,
//			  call this callback function with formatted message string.
// Args     : 
//          : LPFNDBGCALLBACKA lpfnDbgCallbackA 
//          : LPFNDBGCALLBACKW lpfnDbgCallbackW 
// Return   : VOID
// DATE     : Tue Jan 06 12:21:05 1998
//////////////////////////////////////////////////////////////////
//VOID DBGSetCallback(LPFNDBGCALLBACKA lpfnDbgCallbackA, LPFNDBGCALLBACKW lpfnDbgCallbackW);

//////////////////////////////////////////////////////////////////
// Function : DBGEnableOutput
// Type     : VOID
// Purpose  : On off OutputDebugString to COM.
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:33:21 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//VOID DBGEnableOutput(BOOL fEnable)

//////////////////////////////////////////////////////////////////
// Function : DBGIsOutputEnable
// Type     : BOOL
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 17:58:28 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//BOOL DBGIsOutputEnable(VOID)


////////////////////////////////////////////////////////
// Function	: DBG
// Type		: VOID
// Purpose	: Printing ANSI debug message with same usage as printf()
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// Example	: DBGW(("Error occured data[%d]", i));
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//		   : ...	
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example	: DBGW(("Error occured data[%d]", i));
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

//////////////////////////////////////////////////////////////////
// Function : DBGMsgBox
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example	: DBGMsgBox(("Error occured data[%d]", i));
//////////////////////////////////////////////////////////////////
//VOID DBGMsgBox((LPSTR lpstrFmt, ...))

//////////////////////////////////////////////////////////////////
// Function : DBGAssert
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fError
// Return   : 
// DATE     : Fri Jan 09 17:17:31 1998
//////////////////////////////////////////////////////////////////
//VOID DBGAssert(BOOL fError)


//////////////////////////////////////////////////////////////////
// Function : DBGSTR
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr
//////////////////////////////////////////////////////////////////
//VOID DBGSTR(LPSTR lpstr);


//////////////////////////////////////////////////////////////////
// Function : DBGGetErrorString
// Type     : VOID
// Purpose  : Get error message from WIN32 Error code.
// Args     : 
//          : INT errorCode 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetErrorString(INT errorCode)


//////////////////////////////////////////////////////////////////
// Function : DBGGetWinClass
// Type     : LPSTR
// Purpose  : Get class name string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinClass(HWND hwnd)

//////////////////////////////////////////////////////////////////
// Function : DBGGetWinText
// Type     : LPSTR
// Purpose  : Get title text string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinText(HWND hwnd)



#ifdef _DEBUG
//----------------------------------------------------------------
//Function prototype declare
//----------------------------------------------------------------
extern VOID   _pttDbgEnableOutput	(BOOL fEnable);
extern BOOL   _pttDbgIsOutputEnable	(VOID);
extern VOID	  _pttDbgSetCallback		(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW);
extern VOID   _pttDbgA				(LPSTR  lpstrFile, INT lineNo, LPSTR  lpstrMsg);
extern VOID   _pttDbgW				(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _pttDbgMsgBoxA			(LPSTR  lpstrFile,  INT lineNo, LPSTR lpstrMsg);
extern VOID   _pttDbgAssert			(LPSTR  lpstrFile,  INT lineNo, BOOL fError, LPSTR lpstrMsg);
extern VOID   _pttDbgPrintfA			(LPSTR  lpstrFmt, ...);
extern VOID   _pttDbgPrintfW			(LPWSTR lpstrFmt, ...);
extern VOID   _pttDbgOutStrA			(LPSTR  lpstr);
extern VOID	  _pttDbgOutStrW			(LPWSTR lpwstr);
extern LPSTR  _pttDbgVaStrA			(LPSTR  lpstrFmt, ...);
extern LPWSTR _pttDbgVaStrW			(LPWSTR lpstrFmt, ...);
extern LPWSTR _pttDbgMulti2Wide		(LPSTR  lpstr);
extern LPSTR  _pttDbgGetWinClass		(HWND   hwnd);
extern LPSTR  _pttDbgGetWinText		(HWND   hwnd);
extern LPSTR  _pttDbgGetErrorString	(INT    errorCode);
extern LPSTR  _pttDbgGetVkStr		(INT	virtKey);
//----------------------------------------------------------------
// Macro definition
//----------------------------------------------------------------
#	define DBGSetCallback(a,b)	_pttDbgSetCallback(a, b)
#	define DBGEnableOutput(a)	_pttDbgEnableOutput(a)
#	define DBGIsOutputEnable()	_pttDbgIsOutputEnable()
#	define Dbg(a)				_pttDbgA(__FILE__, __LINE__, _pttDbgVaStrA a)
#	define DBGA(a)				_pttDbgA(__FILE__, __LINE__, _pttDbgVaStrA a)
#	define DBGW(a)				_pttDbgW( _pttDbgMulti2Wide(__FILE__), __LINE__, _pttDbgVaStrW a)
#	define DBGMsgBox(a)			_pttDbgMsgBoxA(__FILE__, __LINE__, _pttDbgVaStrA a)
#	define DBGAssert(a)			_pttDbgAssert(__FILE__, __LINE__, a, #a)
#	define DBGAssertSz(a,b)		_pttDbgAssert(__FILE__, __LINE__, a, b)
#	define DBGOutStr(a)			_pttDbgOutStrA(a)
#	define DBGOutStrA(a)		_pttDbgOutStrA(a)
#	define DBGOutStrW(a)		_pttDbgOutStrW(a)
#	define DBGP(a)				_pttDbgOutStrA(_pttDbgVaStrA a)
#	define DBGPA(a)				_pttDbgOutStrA(_pttDbgVaStrA a)
#	define DBGPW(a)				_pttDbgOutStrW(_pttDbgVaStrW a)
#	define DBGGetErrorString(a)	_pttDbgGetErrorString(a)
#	define DBGGetWinClass(a)	_pttDbgGetWinClass(a)
#	define DBGGetWinText(a)		_pttDbgGetWinText(a)
#else //!_DEBUG	//in Release version, these will disapear...
#	define DBGSetCallback(a,b)
#	define DBGEnableOutput(a)
#	define DBGIsOutputEnable()
#	define Dbg(a)
#	define DBGW(a)
#	define DBGA(a)
#	define DBGP(a)
#	define DBGPA(a)
#	define DBGPW(a)
#	define DBGAssert(a)
#	define DBGAssertSz(a,b)
#	define DBGMsgBox(a)
#	define DBGOutStr(a)
#	define DBGOutStrA(a)
#	define DBGOutStrW(a)
#	define DBGGetErrorString(a)
#	define DBGGetWinClass(a)
#	define DBGGetWinText(a)
#endif //_DEBUG


//----------------------------------------------------------------
//These function use variable argument, so we cannot define 
//"Normal" MACRO for them.
//so, Use inline function that do nothing if _DEBUG is NOT set.
//----------------------------------------------------------------
InlineFunc VOID DBGDoNothingA(LPSTR  lpstrFmt, ...) { lpstrFmt;}
InlineFunc VOID DBGDoNothingW(LPWSTR lpstrFmt, ...) { lpstrFmt;}
#ifdef _DEBUG 
#define DBGPrintf		_debugPrintfA
#define DBGPrintfA		_debugPrintfA
#define DBGPrintfW		_debugPrintfW
#else 
#define DBGPrintf		DBGDoNothingA
#define DBGPrintfA		DBGDoNothingA
#define DBGPrintfW		DBGDoNothingW
#endif


//----------------------------------------------------------------
//This is helper inline function for outputs debug string in 
//Retail version. if FORCE_DEBUG is defined this function works.
//Some time, we met bugs than occurs only retail version, 
//and would like to out debug message. 
//----------------------------------------------------------------
#ifdef FORCE_DEBUG
#include <stdarg.h>
//////////////////////////////////////////////////////////////////
// Function : FDbg
// Type     : InlineFunc VOID
// Purpose  : 
// Args     : 
//          : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Tue Jan 06 19:06:19 1998
//////////////////////////////////////////////////////////////////
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...)
{
	CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	OutputDebugStringA(szBuf);	
	return;
}
#else //FORCE_DEBUG
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...) { lpstrFmt;}
#endif

#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\padrs\cmddef.h ===
#ifndef __CMD_DEF_H__
#define __CMD_DEF_H__
//----------------------------------------------------------------
//Please check these are different with res/main/resource.h's IDC_XXX
//----------------------------------------------------------------
#define IDC_KBTN_FIRST					6000
#define IDC_KBTN_BACKSPACE              (IDC_KBTN_FIRST+1)
#define IDC_KBTN_DELETE                 (IDC_KBTN_FIRST+2) 
#define IDC_KBTN_ENTER                  (IDC_KBTN_FIRST+3) 
#define IDC_KBTN_ESCAPE                 (IDC_KBTN_FIRST+4) 
#define IDC_KBTN_SPACE                  (IDC_KBTN_FIRST+5) 
#define IDC_KBTN_FAREAST                (IDC_KBTN_FIRST+6) 
#define IDC_KBTN_ARROWS				    (IDC_KBTN_FIRST+7) 
#define IDC_KBTN_ARROW_LEFT			    (IDC_KBTN_FIRST+8)
#define IDC_KBTN_ARROW_RIGHT		    (IDC_KBTN_FIRST+9)
#define IDC_KBTN_ARROW_UP			    (IDC_KBTN_FIRST+10)
#define IDC_KBTN_ARROW_DOWN			    (IDC_KBTN_FIRST+11)
#define IDC_KBTN_HOME                   (IDC_KBTN_FIRST+12)
#define IDC_KBTN_PAGEUP                	(IDC_KBTN_FIRST+13)
#define IDC_KBTN_TAB                    (IDC_KBTN_FIRST+14)
#define IDC_KBTN_LWIN              		(IDC_KBTN_FIRST+15)
#define IDC_KBTN_END                    (IDC_KBTN_FIRST+16)
#define IDC_KBTN_PAGEDOWN				(IDC_KBTN_FIRST+17)
#define IDC_KBTN_INSERT					(IDC_KBTN_FIRST+18)
#define IDC_KBTN_APPKEY                 (IDC_KBTN_FIRST+19)

#endif // __CMD_DEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\padrs\resmain.h ===
//////////////////////////////////////////////////////////////////
// File     :	resmain.h
// Purpose  :	
// 
// 
// Date     :	Thu May 20 21:28:50 1999
// Author   :	toshiak
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __RES_MAIN_H__
#define __RES_MAIN_H__
//=======================================================
//IMEPad Popup menu help id.(For Korean WinHelp)
//=======================================================
//
#define IDH_TOC_IMEPAD			3099		//Main Help

//-------------------------------------------------------
//Not used.
//-------------------------------------------------------
#define IDH_PAD_BASE_MENU			3000			//Menu.
#define IDH_PAD_BASE_APPLET			3001			//applet menu.
#define	IDH_PAD_BASE_BACK			3002			//back.

//-------------------------------------------------------
//Basic Buttons.
//-------------------------------------------------------
#define IDH_PAD_BASE_BASIC_BS		3010			//[BS]
#define IDH_PAD_BASE_BASIC_DEL		3011			//[Del]
#define IDH_PAD_BASE_BASIC_CONV		3012			//[Conv]
#define IDH_PAD_BASE_BASIC_ENTER	3013			//[Enter]
#define IDH_PAD_BASE_BASIC_SPACE	3014			//[space]
#define IDH_PAD_BASE_BASIC_ESC		3015			//[ESC]
#define IDH_PAD_BASE_BASIC_LEFT		3016			//[<-]
#define IDH_PAD_BASE_BASIC_RIGHT	3017			//[->]
#define IDH_PAD_BASE_BASIC_UP		3018			//[Up arrow]
#define IDH_PAD_BASE_BASIC_DOWN		3019			//[Down arrow]

//-------------------------------------------------------
//Extended Buttons.
//-------------------------------------------------------
#define IDH_PAD_BASE_EX_HOME		3020			//[HOME]
#define IDH_PAD_BASE_EX_END			3021			//[End]
#define IDH_PAD_BASE_EX_PGUP		3022			//[PgUp]
#define IDH_PAD_BASE_EX_PGDN		3023			//[PgDw]
#define IDH_PAD_BASE_EX_TAB			3024			//[Tab]
#define IDH_PAD_BASE_EX_INS			3025			//[Ins]
#define IDH_PAD_BASE_EX_WINDOWS		3026			//[Windows]
#define IDH_PAD_BASE_EX_APP			3027			//[App]
#define IDH_PAD_BASE_DELETE			3030			

//-------------------------------------------------------
//IMEPad's property dialog.
//-------------------------------------------------------
#define IDH_PAD_PROPERTY_OK			3600		//OK
#define IDH_PAD_PROPERTY_CANCEL		3601		//Cancel
#define IDH_PAD_PROPERTY_HELP		3602		//Help
#define IDH_PAD_PROPERTY_BASIC      3607    	//Basic button.
#define IDH_PAD_PROPERTY_EX			3608    	//Extended button.
#define IDH_PAD_PROPERTY_POS        3609    	//Position.
#define IDH_PAD_PROPERTY_LANG       3611    	//Language.

//----------------------------------------------------------------
//IMEPad's user configuration(IMEPad change menu order)
//
#define IDH_PAD_USER_ADD	        3702        
#define IDH_PAD_USER_REMOVE		    3703        
#define IDH_PAD_USER_CLOSE		    3704        
#define IDH_PAD_USER_RESET		    3705        
#define IDH_PAD_USER_UP		        3706        
#define IDH_PAD_USER_DOWN			3707        

#endif //__RES_MAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\padrs\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by F:\satori\fecommon\imepadsv\res\cht\res.rc
//
#define IDC_STATIC                      -1

#define IDS_TITLE_IMEPAD                1
#define IDS_TITLE_PADMENU               2
#define IDS_TITLE_APPLETMENU            3
#define IDS_TITLE_TURNBACK              4
#define IDS_TITLE_VERSION               5
#define IDS_TITLE_HELP                  6
#define IDS_TITLE_IMEPAD_HELP           7
#define IDS_TITLE_CLOSE                 8
#define IDS_TITLE_PROPERTY              9
#define IDS_TITLE_ADD_APPLETS           10
#define IDS_TITLE_LEFT                  11
#define IDS_TITLE_RIGHT                 12
#define IDS_TITLE_APPLET                13
#define IDS_TITLE_FILENAME              14
#define IDS_TITLE_CHANGE_APPLET_ORDER   15
#define IDS_TITLE_RES2                  16
#define IDS_TITLE_RES3                  17
#define IDS_TITLE_RES4                  18
#define IDS_SUFFIX_PROPERTY             19
#define IDS_SUFFIX_HELP                 20
#define IDS_BUTTON_BACK                 21
#define IDS_BUTTON_NEXT                 22
#define IDS_BUTTON_FINISH               23
#define IDS_BUTTON_RES1                 24
#define IDS_BUTTON_RES2                 25
#define IDS_BUTTON_RES3                 26
#define IDS_LANG_AUTO                   27
#define IDS_LANG_ENGLISH                28
#define IDS_LANG_CHINESE_SIMPLIFIED     29
#define IDS_LANG_CHINESE_TRADITIONAL    30
#define IDS_LANG_JAPANESE               31
#define IDS_LANG_KOREAN                 32
#define IDS_KBTN_BACKSPACE              33
#define IDS_KBTN_ENTER                  34
#define IDS_KBTN_SPACE                  35
#define IDS_KBTN_DELETE                 36
#define IDS_KBTN_ESCAPE                 37
#define IDS_KBTN_HOME                   38
#define IDS_KBTN_PAGEUP                 39
#define IDS_KBTN_TAB                    40
#define IDS_KBTN_LWIN                   41
#define IDS_KBTN_END                    42
#define IDS_KBTN_PAGEDOWN               43
#define IDS_KBTN_INSERT                 44
#define IDS_KBTN_APPKEY                 45
#define IDS_KBTN_FE_ENG                 46
#define IDS_KBTN_FE_CHS                 47
#define IDS_KBTN_FE_CHT                 48
#define IDS_KBTN_FE_JPN                 49
#define IDS_KBTN_FE_KOR                 50
#define IDS_FE_KEY_ENG                  51
#define IDS_FE_KEY_CHS                  52
#define IDS_FE_KEY_CHT                  53
#define IDS_FE_KEY_JPN                  54
#define IDS_FE_KEY_KOR                  55
#define IDS_ACC_BACKSPACE               56
#define IDS_ACC_ENTER                   57
#define IDS_ACC_SPACE                   58
#define IDS_ACC_DELETE                  59
#define IDS_ACC_ESCAPE                  60
#define IDS_ACC_HOME                    61
#define IDS_ACC_PAGEUP                  62
#define IDS_ACC_TAB                     63
#define IDS_ACC_LWIN                    64
#define IDS_ACC_END                     65
#define IDS_ACC_PAGEDOWN                66
#define IDS_ACC_INSERT                  67
#define IDS_ACC_APPKEY                  68
#define IDS_ACC_ARROW_LEFT              69
#define IDS_ACC_ARROW_RIGHT             70
#define IDS_ACC_ARROW_UP                71
#define IDS_ACC_ARROW_DOWN              72
#define IDS_ACC_FE_ENG                  73
#define IDS_ACC_FE_CHS                  74
#define IDS_ACC_FE_CHT                  75
#define IDS_ACC_FE_JPN                  76
#define IDS_ACC_RES1                    77
#define IDS_ACC_RES2                    78
#define IDS_ACC_RES3                    79
#define IDS_ACC_RES4                    80
#define IDS_ACC_RES5                    81
#define IDS_MSG_INVALID_FOLDER          82
#define IDS_MSG_NOFOLDER_CREATE         83
#define IDS_MSG_FAILEDTOCREATEFOLDER    84
#define IDS_MSG_NOAPPLETINFOLDER        85
#define IDS_MSG_NOENOUGHMEMORY          86
#define IDS_MSG_NOSPECIFIEDAPPLET       87
#define IDS_MSG_DOADMIN                 88
#define IDS_MSG_RES1                    89
#define IDS_MSG_RES2                    90
#define IDS_MSG_RES3                    91
#define IDS_MSG_RES4                    92
#define IDS_MSG_RES5                    93
#define IDS_MSG_RES6                    94
#define IDS_FONTNAME_NATIVE_0           95
#define IDS_FONTNAME_NATIVE_1           96
#define IDS_FONTNAME_NATIVE_2           97
#define IDS_FONTNAME_NATIVE_3           98
#define IDS_FONTNAME_ENG_0              99
#define IDS_FONTNAME_ENG_1              100
#define IDS_FONTNAME_ENG_2              101
#define IDS_FONTNAME_ENG_3              102
#define IDI_WINDOW                      200
#define IDI_APPKEY                      201
#define IDI_INSTALL                     202
#define IDI_IMEPAD                      206
#define IDD_PROPERTY                    208
#define IDD_CHGAPPLETORDER              212
#define IDD_BTNPANE                     213
#define IDD_INST_SETAPPLETFOLDER        214
#define IDR_MENUCONTEXTHELP             215
#define IDD_INST_SETINSTALLFOLDER       216
#define IDD_INST_BROWSEAPPLET           217
#define IDD_VERSION                     218
#define IDD_INST_DOING                  219
#define IDD_INST_ADD_DELETE             220
#define IDD_INST_DELETE                 221
#define IDC_BROWSE                      1027
#define IDC_APPLETLIST                  1027
#define IDC_STATIC_MSG                  1028
#define IDC_CHECK1                      1028
#define IDC_STATIC_COPYFROM             1030
#define IDC_STATIC_ERRORMSG             1031
#define IDC_STATIC_ERROR_TITLE          1032
#define IDC_PROGRESS                    1033
#define IDC_STATIC_FOLDERNAME           1036
#define IDC_OTHERLIST                   1036
#define IDC_FOLDER_PATH                 1037
#define IDC_STATIC_FILENAME             1038
#define IDC_SRCFOLDER                   1039
#define IDC_FOLDERNAME                  1040
#define IDC_DESTFOLDER                  1041
#define IDC_TITLE_DESTFOLDER            1042
#define IDC_ADDAPPLET                   1042
#define IDC_DELETEAPPLET                1043
#define IDC_LISTAPPLET                  1046
#define IDC_NOTIFY                      1047
#define IDC_TEXT_VERSION                1048
#define IDC_CFG_GEN_APPLETBAR           1068
#define IDC_CFG_GEN_APPLETBAR_POSITION  1069
#define IDC_CFG_GEN_BASIC_BUTTONS       1070
#define IDC_CFG_GEN_EXTEND_BUTTONS      1071
#define IDC_CFG_GEN_BUTTON_LANGUAGE     1072
#define IDC_CFG_GEN_BUTTON_POSITION     1073
#define IDC_CFG_GEN_MENU_LANGUAGE       1074
#define IDC_CFG_GEN_BUTTON_OK           1075
#define IDC_CFG_GEN_BUTTON_CANCEL       1076
#define IDC_CFG_GEN_BUTTON_HELP         1077
#define IDC_CFG_CHGMENU_APPLETS         1078
#define IDC_CFG_GEN_BUTTON_POSITION2    1078
#define IDC_CFG_CHGMENU_CURAPPLETS      1079
#define IDC_CFG_CHGMENU_CLOSE           1080
#define IDC_CFG_CHGMENU_RESET           1081
#define IDC_CFG_CHGMENU_ADD             1082
#define IDC_CFG_CHGMENU_DELETE          1083
#define IDC_CFG_CHGMENU_UP              1084
#define IDC_CFG_CHGMENU_DOWN            1095
#define IDC_INST_APPLETLIST             1096
#define IDC_INST_INSTALL_FROM_FILE      1097

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         40012
#define _APS_NEXT_CONTROL_VALUE         1093
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadcb.h ===
#ifndef __C_IME_PAD_CALLBACK_H__
#define __C_IME_PAD_CALLBACK_H__
#include "cpadsvr.h"

//----------------------------------------------------------------
//990630:ToshiaK for #1327
//----------------------------------------------------------------
#define WM_USER_UPDATECONTEXT	(WM_USER+400)

class CImePadCallback;
typedef CImePadCallback *LPCImePadCallback;

class CImePadCallback :public IImePadCallback
{
public:
	HRESULT __stdcall QueryInterface(REFIID riid, void**ppv);
	ULONG   __stdcall AddRef	(void);
	ULONG   __stdcall Release	(void);
	virtual HRESULT STDMETHODCALLTYPE OnStart( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE OnClose( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE OnPing( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE PassData( 
		/* [in] */ long nSize,
		/* [size_is][in] */ byte __RPC_FAR *pByte,
		/* [out][in] */ DWORD __RPC_FAR *pdwCharID);
	virtual HRESULT STDMETHODCALLTYPE ReceiveData( 
		/* [in] */ DWORD dwCmdID,
		/* [in] */ DWORD dwDataID,
		/* [out] */ long __RPC_FAR *pSize,
		/* [size_is][size_is][out] */ byte __RPC_FAR *__RPC_FAR *ppByte);
public:
	CImePadCallback(HWND hwndIF, LPCImePadSvr lpCImePadSvr);
	~CImePadCallback();
	VOID* operator new( size_t size );
	VOID  operator delete( VOID *lp );
private:
	LPCImePadSvr	m_lpCImePadSvr;
	DWORD			m_dwReg;
	HWND			m_hwndIF;
	LONG			m_cRef;			
};

#ifndef		__DEFINE_IMEPAD_IUNKNOWN_DUMMY__
#define		__DEFINE_IMEPAD_IUNKNOWN_DUMMY__
#pragma pack(8)
typedef struct IUnkDummyVtbl
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
		IUnknown __RPC_FAR * This,
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
		IUnknown __RPC_FAR * This);
	
	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
		IUnknown __RPC_FAR * This);
}IUnkDummyVtbl;

interface IUnkDummy
{
       CONST_VTBL struct IUnkDummyVtbl __RPC_FAR *lpVtbl;
};
#pragma pack()
#endif //__DEFINE_IMEPAD_IUNKNOWN_DUMMY__

extern BOOL IsBadVtbl(IUnkDummy *lpIUnk);


#endif //__C_IME_PAD_CALLBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\padrs\padhelp.h ===
//////////////////////////////////////////////////////////////////
// File     :	padhelp.h
// Purpose  :	Each FarEast's help module header. 
// 
// 
// Date     :	Thu May 20 20:43:25 1999
// Author   :	toshiak
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __PAD_HELP_H__
#define __PAD_HELP_H__

#define PADHELPINDEX_MAIN				1	
#define PADHELPINDEX_PROPERTY			2
#define PADHELPINDEX_APPLETMENUCHANGE	3
#define PADHELPINDEX_RESERVED1			4
#define PADHELPINDEX_RESERVED2			5

#define SZPADHELP_HANDLEHELP			TEXT("PadHelp_HandleHelp")
#define SZPADHELP_HANDLECONTEXTPOPUP	TEXT("PadHelp_HandleContextPopup")

//----------------------------------------------------------------
//Add imepadUiLangID
//----------------------------------------------------------------
typedef INT (WINAPI *LPFN_PADHELP_HANDLEHELP)(HWND hwnd, INT padHelpIndex, LANGID imepadUiLangID);
typedef INT (WINAPI *LPFN_PADHELP_HANDLECONTEXTPOPUP)(HWND hwndCtrl, INT idCtrl, LANGID imepadUiLangID);
INT WINAPI PadHelp_HandleHelp(HWND hwnd, INT padHelpIndex, LANGID imepadUiLangID);
INT WINAPI PadHelp_HandleContextPopup(HWND hwndCtrl, INT idCtrl, LANGID imepadUiLangID);

#endif //__PAD_HELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\padrs\resmain.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	resmain.cpp
// Purpose  :	IMEPad's neutral resource &
//            	Help API.
// 
// 
// Date     :	Thu May 20 20:58:06 1999
// Author   :	toshiak
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include "resource.h"
#include "cmddef.h"
#include "padhelp.h"
//#include "../common/cutil.h"
#include "resmain.h"
#include "common.h"
// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//----------------------------------------------------------------
//Helpfile name
//----------------------------------------------------------------
#define TSZ_HTMLHELP_FILE_KOR	TEXT("impdko61.chm")    //Helpfile for Htmlhelp
#define TSZ_HTMLHELP_FILE_ENG	TEXT("korpaden.chm")    //Helpfile for Htmlhelp
#define TSZ_WMHELP_FILE	    	TEXT("imkr61.hlp")      // IME Pad Context Help. Kor only.

//----------------------------------------------------------------
//HelpId table
//----------------------------------------------------------------
static INT g_helpIdList[]={
    IDC_KBTN_BACKSPACE,  IDH_PAD_BASE_BASIC_BS,
    IDC_KBTN_DELETE,     IDH_PAD_BASE_BASIC_DEL,
    IDC_KBTN_FAREAST,    IDH_PAD_BASE_BASIC_CONV,
    IDC_KBTN_ENTER,      IDH_PAD_BASE_BASIC_ENTER,
    IDC_KBTN_SPACE,      IDH_PAD_BASE_BASIC_SPACE,
    IDC_KBTN_ESCAPE,     IDH_PAD_BASE_BASIC_ESC,
    IDC_KBTN_ARROWS,     IDH_PAD_BASE_BASIC_LEFT,
    IDC_KBTN_ARROW_LEFT, IDH_PAD_BASE_BASIC_LEFT,
    IDC_KBTN_ARROW_RIGHT,IDH_PAD_BASE_BASIC_RIGHT,
    IDC_KBTN_ARROW_UP,   IDH_PAD_BASE_BASIC_UP,
    IDC_KBTN_ARROW_DOWN, IDH_PAD_BASE_BASIC_DOWN,
    IDC_KBTN_HOME,       IDH_PAD_BASE_EX_HOME,
    IDC_KBTN_END,        IDH_PAD_BASE_EX_END,
    IDC_KBTN_PAGEUP,     IDH_PAD_BASE_EX_PGUP,
    IDC_KBTN_PAGEDOWN,   IDH_PAD_BASE_EX_PGDN,
    IDC_KBTN_TAB,        IDH_PAD_BASE_EX_TAB,
    IDC_KBTN_INSERT,     IDH_PAD_BASE_EX_INS,
    IDC_KBTN_LWIN,       IDH_PAD_BASE_EX_WINDOWS,
    IDC_KBTN_APPKEY,     IDH_PAD_BASE_EX_APP,

    //IMEPad's property dialog's Popup-help.
	IDC_CFG_GEN_BASIC_BUTTONS,    	IDH_PAD_PROPERTY_BASIC,
	IDC_CFG_GEN_EXTEND_BUTTONS,    	IDH_PAD_PROPERTY_EX,
	IDC_CFG_GEN_BUTTON_POSITION,	IDH_PAD_PROPERTY_POS,
	IDC_CFG_GEN_MENU_LANGUAGE,    	IDH_PAD_PROPERTY_LANG,
	IDC_CFG_GEN_BUTTON_OK,        	IDH_PAD_PROPERTY_OK,
	IDC_CFG_GEN_BUTTON_CANCEL,    	IDH_PAD_PROPERTY_CANCEL,
	IDC_CFG_GEN_BUTTON_HELP,    	IDH_PAD_PROPERTY_HELP,

    //IMEPad's user configu dialog's Popup-help.
	IDC_CFG_CHGMENU_APPLETS,    	0,
	IDC_CFG_CHGMENU_CURAPPLETS,    	0,
	IDC_CFG_CHGMENU_CLOSE,        	IDH_PAD_USER_CLOSE,
	IDC_CFG_CHGMENU_RESET,        	IDH_PAD_USER_RESET,
	IDC_CFG_CHGMENU_ADD,        	IDH_PAD_USER_ADD,
	IDC_CFG_CHGMENU_DELETE,        	IDH_PAD_USER_REMOVE,
	IDC_CFG_CHGMENU_UP,            	IDH_PAD_USER_UP,
	IDC_CFG_CHGMENU_DOWN,        	IDH_PAD_USER_DOWN,
	0,            	0,
}; 

//////////////////////////////////////////////////////////////////
// Function	:	PadHelp_HandleHelp
// Type	    :	INT WINAPI
// Purpose	:    
// Args	    :    
//            :	HWND	hwnd	
//            :	INT		padHelpIndex	
//            :	LANGID	imepadUiLangID
// Return	:    
// DATE	    :	Fri Aug 04 08:59:21 2000
// Histroy	:	Fri Aug 04 09:03:17 2000
//                # Add imepadUiLangID. 
//////////////////////////////////////////////////////////////////
INT WINAPI
PadHelp_HandleHelp(HWND hwnd, INT padHelpIndex, LANGID imepadUiLangID)
{
	TCHAR tszPath[MAX_PATH];
	TCHAR tszFile[MAX_PATH];
	BOOL  fKoreanEnv = (imepadUiLangID == MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT)) ? TRUE : FALSE;

	tszPath[0] = (TCHAR)0x00;
	tszFile[0] = (TCHAR)0x00;
    // There is No Korean TS NT4.0
#if 0
    //----------------------------------------------------------------
    //In WinNT4.0 TerminalServer, htmlhlp has bug.
    //have to set absolute HTML helpfile path to it
    //----------------------------------------------------------------
	if(CUtil::IsHydra() && CUtil::IsWinNT4()) {
    	INT size = CUtil::GetWINDIR(tszFile, sizeof(tszFile)/sizeof(tszFile[0]));
    	tszFile[size] = (TCHAR)0x00;
    	lstrcat(tszFile, TEXT("\\help\\"));
    	lstrcat(tszFile, fKoreanEnv ? TSZ_HTMLHELP_FILE_KOR : TSZ_HTMLHELP_FILE_ENG);
    }
	else {
    	lstrcpy(tszFile, fKoreanEnv ? TSZ_HTMLHELP_FILE_KOR : TSZ_HTMLHELP_FILE_ENG);
    }
#endif
	StringCchCopy(tszFile, ARRAYSIZE(tszFile), fKoreanEnv ? TSZ_HTMLHELP_FILE_KOR : TSZ_HTMLHELP_FILE_ENG);

	switch(padHelpIndex) {
	case PADHELPINDEX_MAIN:
	case PADHELPINDEX_APPLETMENUCHANGE:
    	wsprintf(tszPath, TEXT("hh.exe %s"), tszFile);
    	break;
	case PADHELPINDEX_PROPERTY:
    	wsprintf(tszPath, TEXT("hh.exe %s::/howIMETopic166_ChangetheIMEPadOperatingEnvironment.htm"), tszFile);
    	break;

#if 0
	case PADHELPINDEX_RESERVED1:
    	wsprintf(tszPath, TEXT("hh.exe %s::/IDH_TOC_IMEPAD_fake.htm"), tszFile);
    	break;
	case PADHELPINDEX_RESERVED2:
    	wsprintf(tszPath, TEXT("hh.exe %s::/IDH_TOC_IMEPAD_fake.htm"), tszFile);
    	break;
#endif
	default:
    	return -1;
    }
#ifndef UNDER_CE
    ::WinExec(tszPath, SW_SHOWNORMAL);
#else
#pragma message("Not Implemented yet!!")
#endif
	return 0;
	UNREFERENCED_PARAMETER(hwnd);
	UNREFERENCED_PARAMETER(imepadUiLangID);
}

//////////////////////////////////////////////////////////////////
// Function	:	PadHelp_HandleContextPopup
// Type	    :	INT WINAPI
// Purpose	:	Invoke Popup Help.
//                ::WinHelp(HWND   hwndCtrl,                //set passed parameter.
//                          LPTSTR TSZ_WMHELP_FILE,        //set your WinHelp file name.
//                          DWORD	 HELP_CONTEXTPOPUP,        //uCommand.
//                          DWORD	 realHelpIndex);        //Context Identifier for a topic.
//            	This code only popups context help.
// Args	    :    
//            :	HWND	hwndCtrl:	Control window handle for popup.
//            :	INT		idCtrl:    	Logical Control ID	        
// Return	:    
// DATE	    :	Tue Jun 22 15:49:37 1999
//            :	LANGID	imepadUiLangID:	IMEPad's Ui langID.
// Return	:    
// DATE	    :	Tue Jun 22 15:49:37 1999
// Histroy	:	Fri Aug 04 09:02:12 2000
//                # Add imepadUiLangID. but you don't need to check it now.
//////////////////////////////////////////////////////////////////
INT WINAPI
PadHelp_HandleContextPopup(HWND hwndCtrl, INT idCtrl, LANGID imepadUiLangID)
{
#ifdef _DEBUG
	TCHAR tszBuf[256];
	TCHAR tszClass[256];
	GetClassName(hwndCtrl, tszClass, sizeof(tszClass)/sizeof(tszClass[0]));
	wsprintf(tszBuf,
             "PadHelp_HandleContextPopup: hwndCtrl[0x%08x][%s] idCtrl[%d][0x%08x]\n",
             hwndCtrl,
             tszClass,
             idCtrl,
             idCtrl);
	OutputDebugString(tszBuf);
#endif
	int i;
	for(i = 0; i < sizeof(g_helpIdList)/sizeof(g_helpIdList[0]); i+=2) {
    	if(idCtrl == g_helpIdList[i]) {
#ifdef _DEBUG
        	wsprintf(tszBuf,
                     "Find idCtrl[%d][0x%08x] helpId[%d][0x%08x]\n",
                     idCtrl, idCtrl,
                     g_helpIdList[i+1], g_helpIdList[i+1]);
        	OutputDebugString(tszBuf);
#endif
        	return ::WinHelp(hwndCtrl,
                             TSZ_WMHELP_FILE,
                             HELP_CONTEXTPOPUP,
                             g_helpIdList[i+1]);
        }
    }
	return 0;
	UNREFERENCED_PARAMETER(hwndCtrl);
	UNREFERENCED_PARAMETER(imepadUiLangID);
}

//----------------------------------------------------------------
//DllMain
//----------------------------------------------------------------
BOOL WINAPI DllMain(HANDLE hInst, DWORD dwF, LPVOID lpNotUsed)
{
	return TRUE;
	UNREFERENCED_PARAMETER(hInst);
	UNREFERENCED_PARAMETER(dwF);
	UNREFERENCED_PARAMETER(lpNotUsed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadcb.cpp ===
#include <windows.h>
#include <windowsx.h>
#ifdef UNDER_CE // stub for CE
#include "stub_ce.h"
#endif // UNDER_CE
#include "imepadsv.h"
#include "cpadcb.h"
#include "cpaddbg.h"
#include "ipoint1.h"
#include "iimecb.h"
#include "imepad.h"

#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)


BOOL IsBadVtbl(IUnkDummy *lpIUnk)
{
#ifdef _DEBUG
	BOOL fBad = ::IsBadReadPtr(lpIUnk, sizeof(VOID*)) ||
		::IsBadReadPtr(lpIUnk->lpVtbl, sizeof(VOID*)) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->QueryInterface) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->AddRef) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->Release);
	if(fBad) {
		DBG(("--> IsBadVtbl HIT HIT HIT\n"));
	}
	return fBad;
#else
	return ::IsBadReadPtr(lpIUnk, sizeof(VOID*)) ||
		   ::IsBadReadPtr(lpIUnk->lpVtbl, sizeof(VOID*)) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->QueryInterface) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->AddRef) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->Release);
#endif
}

HRESULT __stdcall CImePadCallback::QueryInterface(REFIID riid, void**ppv)
{
	if(riid == IID_IUnknown) {
		*ppv = static_cast<IImePadCallback *>(this);
	}
	else if (riid == IID_IImePadCallback) {
		*ppv = static_cast<IImePadCallback *>(this);
	}
	else {
		return (*ppv = 0), E_NOINTERFACE;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

ULONG __stdcall
CImePadCallback::AddRef(void)
{
	//DBG(("CImePadCallback::AddRef Always return 2\n"));
	DBG(("CImePadCallback::AddRef m_cRef[%d] -> [%d]\n", m_cRef, m_cRef+1));
	return ::InterlockedIncrement(&m_cRef);
}

ULONG __stdcall
CImePadCallback::Release(void)
{
	//Never call delete in it.
	DBG(("CImePadCallback::Release (Never Delete) m_cRef[%d] -> [%d]\n", m_cRef, m_cRef-1));
	::InterlockedDecrement(&m_cRef);
	return m_cRef;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadCallback::OnStart
// Type		:	HRESULT __stdcall
// Purpose	:	
// Args		:	
//			:	DWORD	dwParam	
// Return	:	
// DATE		:	Tue Aug 31 16:49:37 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
HRESULT __stdcall
CImePadCallback::OnStart(DWORD dwParam)
{
	DBG(("OnClose come dwParam[%d]\n", dwParam));
	IUnknown *lpUnk;
	IImeCallback *lp = NULL;
	if(!m_lpCImePadSvr) {
		DBG(("-->m_lpCImePadSvr is NULL ?\n"));
		return -1;
	}

	lpUnk = m_lpCImePadSvr->GetIUnkIImeCallback();
	if(!lpUnk) {
		DBG(("-->IImeCallback does not set\n"));
		return -1;
	}

#if 0
	if(IsBadVtbl((IUnkDummy*)lpUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}
#endif

	__try {
		lpUnk->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
		if(!lp) {
			DBG(("-->QuertyInterface Failed\n"));
		}
		lp->Notify(IMECBNOTIFY_IMEPADOPENED, 0, 0);
		lp->Release();
	}
	__except(EXCEPTION_EXECUTE_HANDLER) {
		return E_FAIL;
	}

	return S_OK;
	Unref(dwParam);
}

HRESULT __stdcall CImePadCallback::OnClose(DWORD dwParam)
{
	DBG(("OnClose come dwParam[%d]\n", dwParam));
	IUnknown *lpUnk;
	IImeCallback *lp = NULL;
	if(!m_lpCImePadSvr) {
		DBG(("-->m_lpCImePadSvr is NULL ?\n"));
		return -1;
	}
	m_lpCImePadSvr->OnIMEPadClose();

	lpUnk = m_lpCImePadSvr->GetIUnkIImeCallback();
	if(!lpUnk) {
		DBG(("-->IImeCallback does not set\n"));
		return -1;
	}

#if 0
	if(IsBadVtbl((IUnkDummy*)lpUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}
#endif

	__try {
		lpUnk->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
		if(!lp) {
			DBG(("-->QuertyInterface Failed\n"));
		}
		lp->Notify(IMECBNOTIFY_IMEPADCLOSED, 0, 0);
		lp->Release();
	}
	__except(EXCEPTION_EXECUTE_HANDLER) {
		return E_FAIL;
	}

	return S_OK;
	Unref(dwParam);
}

HRESULT __stdcall
CImePadCallback::OnPing(DWORD dwParam)
{
	return S_OK;
	Unref(dwParam);
}

typedef struct tagPADCTRL2IPCTRL {
	DWORD dwImePadCtrl;
	DWORD dwIPointCtrl;
}PADCTL2IPCTRL;

static PADCTL2IPCTRL padCtrl2Ip[]= {
	{ IMEPADCTRL_CONVERTALL,           IPCTRL_CONVERTALL,		      },
	{ IMEPADCTRL_DETERMINALL,          IPCTRL_DETERMINALL,		      },
	{ IMEPADCTRL_DETERMINCHAR,         IPCTRL_DETERMINCHAR,		      },
	{ IMEPADCTRL_CLEARALL,             IPCTRL_CLEARALL,			      },
	{ IMEPADCTRL_CARETSET,             IPCTRL_CARETSET,			      },
	{ IMEPADCTRL_CARETLEFT,            IPCTRL_CARETLEFT,			  },
	{ IMEPADCTRL_CARETRIGHT,           IPCTRL_CARETRIGHT,		      },
	{ IMEPADCTRL_CARETTOP,             IPCTRL_CARETTOP,			      },
	{ IMEPADCTRL_CARETBOTTOM,          IPCTRL_CARETBOTTOM,		      },
	{ IMEPADCTRL_CARETBACKSPACE,       IPCTRL_CARETBACKSPACE,	      },
	{ IMEPADCTRL_CARETDELETE,          IPCTRL_CARETDELETE,		      },
	{ IMEPADCTRL_PHRASEDELETE,         IPCTRL_PHRASEDELETE,		      },
	{ IMEPADCTRL_INSERTSPACE,          IPCTRL_INSERTSPACE,		      },
	{ IMEPADCTRL_INSERTFULLSPACE,      IPCTRL_INSERTFULLSPACE,	      },
	{ IMEPADCTRL_INSERTHALFSPACE,      IPCTRL_INSERTHALFSPACE,	      },
	{ IMEPADCTRL_ONIME,                IPCTRL_ONIME,				  },
	{ IMEPADCTRL_OFFIME,               IPCTRL_OFFIME,			      },
	{ IMEPADCTRL_ONPRECONVERSION,      IPCTRL_PRECONVERSION,		  },
	{ IMEPADCTRL_PHONETICCANDIDATE,    IPCTRL_PHONETICCANDIDATE,	  },
};

HRESULT __stdcall
CImePadCallback::PassData(long nSize, byte *pByte, DWORD *pdwCharID)
{
	DBG(("CImePadCallback::PassData START\n"));
	LPIMEDATAHEADER lpImeDataHeader = (LPIMEDATAHEADER)pByte;

	HRESULT hr = S_OK;
	IUnknown *lpIUnk = NULL;
	IImeIPoint1 *lpIImeIPoint = NULL;
	DWORD dwCharID = 0;

	// Security Fix: Attack surface reduction
	if(!pByte) {
		return E_FAIL;
	}

	if(!m_lpCImePadSvr) {
		DBG(("m_lpCImePadSvr is NULL Error\n"));
		return E_FAIL;
	}
	lpIUnk = m_lpCImePadSvr->GetIUnkIImeIPoint();
	if(!lpIUnk) {
		DBG(("lpIUnk is NULL\n"));
		return E_FAIL;
	}

#if 0
	if(IsBadVtbl((IUnkDummy*)lpIUnk)) {
		return E_FAIL;
	}
#endif

	__try {
		hr = lpIUnk->QueryInterface(IID_IImeIPoint1, (VOID **)&lpIImeIPoint);
		if(hr != S_OK) {
			DBG(("QuertyInterface Failed\n"));
			return E_FAIL;
		}
		if(!lpIImeIPoint) {
			DBG(("QuertyInterface failed\n"));
			return E_FAIL;
		}
		DBG(("m_hwndIF [0x%08x]\n", m_hwndIF));


		switch(lpImeDataHeader->dwDataID) {
		case IMEDATAID_CONTROL:
			{
				LPIMEDATACONTROL lpImeDataCtrl = (LPIMEDATACONTROL)lpImeDataHeader;
				for(int i = 0; i < sizeof(padCtrl2Ip)/sizeof(padCtrl2Ip[0]); i++) {
					if(lpImeDataCtrl->dwControl == padCtrl2Ip[i].dwImePadCtrl) {
						hr = lpIImeIPoint->ControlIME((WORD)padCtrl2Ip[i].dwIPointCtrl,
													   IPCTRLPARAM_DEFAULT);
						//hr = lpIImeIPoint->UpdateContext(TRUE);
						break;
					}
				}
			}
			break;
		case IMEDATAID_STRING:
			{
				DBG(("--> IMEDATAID_STRING\n"));
				LPIMEDATASTRING lpImeDataStr = (LPIMEDATASTRING)lpImeDataHeader;
				switch(lpImeDataHeader->dwCmdID) {
				case IMECMDID_INSERTSTRING:
					{
						DBG(("--> IMECMDID_INSERTSTRING START\n"));
						LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
						INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
						DBGW((L"lpwstr [%s] len[%d]\n", lpwstr, len));
						BOOL fPreConv = lpImeDataStr->fPreConv;
						//990818:ToshiaK for KOTAE #1775.
						dwCharID = lpImeDataStr->dwCharID;
						hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
						hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
													  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
						hr = lpIImeIPoint->InsertStringEx(lpwstr,
														  len,
														  &dwCharID);
						hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
						if(pdwCharID) {
							*pdwCharID = dwCharID;
						}
						fPreConv = 0;
						DBG(("--> IMECMDID_INSERTSTRING END\n"));
					}
					break;
				case IMECMDID_CHANGESTRING:
					{
						DBG(("--> IMECMDID_CHANGESTRING\n"));
						LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
						INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
						dwCharID	  = ((LPIMEDATASTRING)lpImeDataHeader)->dwCharID;
						BOOL fPreConv = lpImeDataStr->fPreConv;
						hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
						hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
													  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
						hr = lpIImeIPoint->ReplaceCompString(lpImeDataStr->dwStartPos,
															 lpImeDataStr->dwDeleteLength,
															 lpwstr,
															 len,
															 &dwCharID);
						hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
						//hr = lpIImeIPoint->UpdateContext(TRUE);
						if(pdwCharID) {
							*pdwCharID = dwCharID;
						}
						hr = (HRESULT)dwCharID;
					}
					break;
				case IMECMDID_DELETESTRING:
					{
						DBG(("--> IMECMDID_DELETESTRING\n"));
						hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME, IPCTRLPARAM_DEFAULT);
						hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
						hr = lpIImeIPoint->DeleteCompString((DWORD)lpImeDataStr->dwStartPos,
															(DWORD)lpImeDataStr->dwDeleteLength);
						hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
						//hr = lpIImeIPoint->UpdateContext(TRUE);
					}
					break;
				case IMECMDID_INSERTSTRINGINFO:
				case IMECMDID_CHANGESTRINGINFO:
					{
						DBG(("--> IMECMDID_INSERT(Change)STRINGINFO\n"));
						LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
						INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
						dwCharID	  = ((LPIMEDATASTRING)lpImeDataHeader)->dwCharID;
						BOOL fPreConv = lpImeDataStr->fPreConv;
						hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
						hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
													  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
						hr = lpIImeIPoint->ReplaceCompString(lpImeDataStr->dwStartPos,
															 lpImeDataStr->dwDeleteLength,
															 lpwstr,
															 len,
															 &dwCharID);
						hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
						if(pdwCharID) {
							*pdwCharID = dwCharID;
						}
						hr = (HRESULT)dwCharID;
					}
					break;
				default:
					break;
					}
			}
			break;
		case IMEDATAID_STRINGCAND:
			{
				DBG(("Data ID is IMEDATAID_STRINGCAND\n"));
				HRESULT hr;
				LPIMEDATASTRINGCAND lpStrCand = (LPIMEDATASTRINGCAND)lpImeDataHeader;
				PIPCANDIDATE lpIpCand;
				INT	textCount, byteCount, i, nSize;
				PBYTE p;
				textCount =  byteCount = 0;
				DBG(("--> dwStringCount %d\n", lpStrCand->dwStringCount));
				for(i = 0; i < (INT)lpStrCand->dwStringCount; i++) {
					DBG(("--> %d offset [%d]\n", i, lpStrCand->dwOffsetString[i]));
					textCount++; 
					LPWSTR lpwstr = (LPWSTR)(((LPBYTE)lpStrCand) +  lpStrCand->dwOffsetString[i]);
					DBGW((L"--> %d %s\n", i, lpwstr));
					byteCount += (lstrlenW(lpwstr)+1) * sizeof(WCHAR);
				}
				if(textCount == 0) {
					return S_OK;
				}
				dwCharID = lpStrCand->dwCharID;
				DWORD dwExInfo = lpStrCand->dwExtraInfoSize;
				nSize = sizeof(IPCANDIDATE) + (textCount-1) * sizeof(DWORD) + byteCount + dwExInfo;
				lpIpCand = (IPCANDIDATE *)MemAlloc(nSize);
				if (lpIpCand == NULL)
				    return E_OUTOFMEMORY;
				
				lpIpCand->dwSize		= nSize;
				lpIpCand->dwFlags		= lpStrCand->dwInfoMask;
				lpIpCand->iSelIndex		= lpStrCand->dwSelIndex;
				lpIpCand->nCandidate	= textCount;
				lpIpCand->dwPrivateDataOffset = 0;
				lpIpCand->dwPrivateDataSize	  = 0;
				DBG(("lpIpCand[0x%08x] \n", lpIpCand));
				DBG(("sizeof(IPCANDIDATE) [%d]\n", sizeof(IPCANDIDATE)));
				DBG(("size add [%d]\n", sizeof(DWORD) * (textCount -1)));
				DWORD dwOffset = sizeof(IPCANDIDATE)+sizeof(DWORD)*(textCount-1);
				p = ((PBYTE)lpIpCand) + dwOffset;

				for(i = 0; i < (INT)lpStrCand->dwStringCount; i++) {
					LPWSTR lpwstr = (LPWSTR)(((LPBYTE)lpStrCand) +  lpStrCand->dwOffsetString[i]);
					DWORD dwStrSize = (lstrlenW(lpwstr) + 1) * sizeof(WCHAR);
					CopyMemory((LPWSTR)p, 
							   (WCHAR *)lpwstr,
							   dwStrSize);
					lpIpCand->dwOffset[i] = dwOffset;
					dwOffset += dwStrSize;
					p += dwStrSize;
				}
				if(dwExInfo > 0) {
					lpIpCand->dwPrivateDataSize   = dwExInfo;
	#ifdef _WIN64
					lpIpCand->dwPrivateDataOffset = (DWORD)((DWORD_PTR)p - (DWORD_PTR)lpIpCand);
	#else
					lpIpCand->dwPrivateDataOffset = (DWORD)p - (DWORD)lpIpCand;
	#endif
					CopyMemory(p,
							   (LPBYTE)((LPBYTE)lpStrCand + lpStrCand->dwExtraInfoOffset),
							   lpStrCand->dwExtraInfoSize);
				}
				BOOL fPreConv = lpStrCand->fPreConv;
				hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME, IPCTRLPARAM_DEFAULT);
				hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION,
											  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
				//----------------------------------------------------------------

				//990713: need to set Start position for IPoint.
				//----------------------------------------------------------------
				DWORD dwInsertPos; // = IPINS_CURRENT;	//Default.
				DWORD dwLen;		 
				//990823:Toshiak for KOTAE #1779.
				//000825:Satori #2123
				if(lpStrCand->dwStartPos == IMECMDVALUE_DEFAULT_INSERT_POS) {
					dwInsertPos = IPINS_CURRENT; //Set IPoint's value
				}
				else {
					dwInsertPos = lpStrCand->dwStartPos;
				}
					
				dwLen		= lpStrCand->dwDeleteLength;
				switch(lpStrCand->header.dwCmdID) {
				case IMECMDID_INSERTSTRINGCANDINFO:
					hr = lpIImeIPoint->InsertImeItem(lpIpCand,
													 dwInsertPos,
													 &dwCharID);
					break;
				case IMECMDID_CHANGESTRINGCANDINFO:
					hr = lpIImeIPoint->ReplaceImeItem(dwInsertPos,
													  dwLen,
													  lpIpCand,
													  &dwCharID);
					break;
				default:
					break;
				}
				hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
				//hr = lpIImeIPoint->UpdateContext(TRUE);
				MemFree(lpIpCand);
				if(pdwCharID) {
					*pdwCharID = dwCharID;
				}
			}
			break;
		default:
			break;
		}
		//990630:ToshiaK for #1327.
		//In WinWord, if call UpdateContext(TRUE) here,
		//Word does NOT repaint composition string.
		//once return the SendMessageTimeout() procedure,
		//and update context asynchronously.
		//in WM_USER_UPDATECONTEXT's lParam, set IImeIPoint interface pointer.
		//and message procedure, check it with current iimeipoint.
		::PostMessage(m_hwndIF, WM_USER_UPDATECONTEXT, (WPARAM)0, (LPARAM)lpIImeIPoint);
		lpIImeIPoint->Release();
	}
	__except(EXCEPTION_EXECUTE_HANDLER) {
		hr = E_FAIL;
	}

	return hr;
	Unref(nSize);
}


HRESULT STDMETHODCALLTYPE 
CImePadCallback::ReceiveData( 
	/* [in] */ DWORD dwCmdID,
	/* [in] */ DWORD dwDataID,
	/* [out] */ long __RPC_FAR *pSize,
	/* [size_is][size_is][out] */ byte __RPC_FAR *__RPC_FAR *ppByte)
{
	DBG(("CImePadCallback::ReceiveData START\n"));
	DBG(("-->dwCmdID  [0x%08x]\n", dwCmdID));
	DBG(("-->dwDataID [0x%08x]\n", dwDataID));
	DBG(("-->pSize    [0x%08x]\n", pSize));
	DBG(("-->ppByte   [0x%08x]\n", ppByte));

	HRESULT hr = S_OK;
	IUnknown *lpIUnk = NULL;
	IImeIPoint1 *lpIImeIPoint = NULL;

	// Security Fix: Attack surface reduction
	if((!ppByte) || (!pSize)) {
		return E_FAIL;
	}

	DBG(("-->Check m_lpCImePadSvr\n"));
	if(!m_lpCImePadSvr) {
		DBG(("m_lpCImePadSvr is NULL Error\n"));
		return E_FAIL;
	}
	DBG(("-->Check m_fnCoTaskMemAlloc\n"));
	if(!m_lpCImePadSvr->m_fnCoTaskMemAlloc ||
	   !m_lpCImePadSvr->m_fnCoTaskMemFree) {
		DBG(("--> OLE32.DLL does NOT EXIST ? Error\n"));
		return E_FAIL;
	}
	

	lpIUnk = m_lpCImePadSvr->GetIUnkIImeIPoint();
	DBG(("-->Check lpIUnk [0x%08x]\n", lpIUnk));
	if(!lpIUnk) {
		DBG(("lpIUnk is NULL\n"));
		return E_FAIL;
	}

#if 0
	DBG(("-->Check lpIUnk IsBadVtbl[0x%08x]\n", lpIUnk));
	if(IsBadVtbl((IUnkDummy*)lpIUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}
#endif

	__try {
		DBG(("-->Call QuertyInterface\n"));
		hr = lpIUnk->QueryInterface(IID_IImeIPoint1, (VOID **)&lpIImeIPoint);
		if(hr != S_OK) {
			DBG(("QuertyInterface Failed\n"));
			return E_FAIL;
		}
		DBG(("--> QueryInterface Success \n"));
		if(!lpIImeIPoint) {
			DBG(("QuertyInterface failed\n"));
			return E_FAIL;
		}

		LPIMEDATACOMPOSITION lpCompoInfo;
		LPIMEDATACOMPOSITION lpCompoTmp;
		LPWSTR lpwstrCompo, lpwstr;
		DWORD  *pdwCharID, *pdw;	
		DWORD  dwSize;
		DWORD dwDtnSize;
		LPBYTE lpbOutOfBuffer;
		switch(dwDataID) {
		case IMEDATAID_COMPOSITION:
			switch(dwCmdID) {
			case IMECMDID_GETCOMPOSITIONINFO:
				DBG(("--> IMECMDID_GETCOMPOSITIONINFO\n"));
				dwSize = sizeof(IMEDATACOMPOSITION);
				lpCompoInfo = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvr->m_fnCoTaskMemAlloc)(dwSize);
				if(!lpCompoInfo) {
					lpIImeIPoint->Release();
					return E_OUTOFMEMORY;
				}
				hr = lpIImeIPoint->GetAllCompositionInfo(NULL,
														 NULL,
														 (INT *)&lpCompoInfo->dwStringCount,
														 (INT *)&lpCompoInfo->dwCaretPos,
														 (INT *)&lpCompoInfo->dwUndeterminedStartPos,
														 (INT *)&lpCompoInfo->dwUndeterminedLength,
														 (INT *)&lpCompoInfo->dwEditStartPos,
														 (INT *)&lpCompoInfo->dwEditLength);
				lpCompoInfo->header.dwSize  = dwSize;
				lpCompoInfo->header.dwCmdID = dwCmdID;
				lpCompoInfo->header.dwDataID= dwDataID;
				lpCompoInfo->dwOffsetString = 0;
				lpCompoInfo->dwOffsetCharID = 0;
				*pSize = lpCompoInfo->header.dwSize;
				*ppByte = (PBYTE)lpCompoInfo;
				DBG(("--> IMECMDID_GETCOMPOSITIONINFO END\n"));
				break;
			case IMECMDID_GETCOMPOSITIONSTRING:
				DBG(("--> IMECMDID_GETCOMPOSITIONSTRING START\n"));
				lpCompoInfo = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvr->m_fnCoTaskMemAlloc)(sizeof(IMEDATACOMPOSITION));
				if(!lpCompoInfo) {
					DBG(("-->OutofMemory\n"));
					lpIImeIPoint->Release();
					return E_OUTOFMEMORY;
				}
				lpwstrCompo = NULL;
				pdwCharID   = NULL;
				ZeroMemory(lpCompoInfo, sizeof(IMEDATACOMPOSITION));

				hr = lpIImeIPoint->GetAllCompositionInfo(&lpwstrCompo,
														 &pdwCharID,
														 (INT *)&lpCompoInfo->dwStringCount,
														 (INT *)&lpCompoInfo->dwCaretPos,
														 (INT *)&lpCompoInfo->dwUndeterminedStartPos,
														 (INT *)&lpCompoInfo->dwUndeterminedLength,
														 (INT *)&lpCompoInfo->dwEditStartPos,
														 (INT *)&lpCompoInfo->dwEditLength);
				DBG(("-->hr [0x%08x]\n", hr));
				DBGW((L"-->lpwstrCompo[%s]\n", lpwstrCompo));
				dwSize = sizeof(IMEDATACOMPOSITION) +
						 (lpCompoInfo->dwStringCount+1)*sizeof(WCHAR) +
						 (lpCompoInfo->dwStringCount) * sizeof(DWORD);
				DBG(("-->dwSize [%d]\n", dwSize));
				lpCompoTmp = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvr->m_fnCoTaskMemAlloc)(dwSize);
				if(!lpCompoTmp) {
					DBG(("-->OutofMemory\n"));
					lpIImeIPoint->Release();
					return E_OUTOFMEMORY;
				}
				lpCompoTmp->header.dwSize  = dwSize;
				lpCompoTmp->header.dwCmdID = dwCmdID;
				lpCompoTmp->header.dwDataID= dwDataID;
				lpCompoTmp->dwStringCount           = lpCompoInfo->dwStringCount;
				lpCompoTmp->dwCaretPos              = lpCompoInfo->dwCaretPos;
				lpCompoTmp->dwUndeterminedStartPos  = lpCompoInfo->dwUndeterminedStartPos;
				lpCompoTmp->dwUndeterminedLength    = lpCompoInfo->dwUndeterminedLength;
				lpCompoTmp->dwEditStartPos          = lpCompoInfo->dwEditStartPos;
				lpCompoTmp->dwEditLength            = lpCompoInfo->dwEditLength;
				lpCompoTmp->dwOffsetString = (DWORD)sizeof(IMEDATACOMPOSITION);

				lpwstr = (LPWSTR)((PBYTE)lpCompoTmp + lpCompoTmp->dwOffsetString);

				// Security Fix: Dangerous API (CopyMemory)
				lpbOutOfBuffer = ((LPBYTE)lpCompoTmp) + dwSize;
				dwDtnSize = (DWORD)(lpbOutOfBuffer - ((LPBYTE)lpwstr));
				if (dwDtnSize < ((lpCompoTmp->dwStringCount+1) * sizeof(WCHAR)) ) {
					lpCompoTmp->dwStringCount = dwDtnSize / sizeof(WCHAR) - 1;
				}

				//990928:toshiaK for KOTAE #2273
				//Need to check lpwstrCompo is NULL or not.
				if(lpwstrCompo && lpCompoTmp->dwStringCount > 0) {
					CopyMemory(lpwstr, 
							   (WCHAR *)lpwstrCompo,
							   lpCompoTmp->dwStringCount * sizeof(WCHAR));
				}
				lpwstr[lpCompoTmp->dwStringCount] = (WCHAR)0x0000;

				lpCompoTmp->dwOffsetCharID = (DWORD)(sizeof(IMEDATACOMPOSITION) +
													 (lpCompoTmp->dwStringCount+1)*sizeof(WCHAR));
				//990928:toshiaK for KOTAE #2273
				//Need to check pdwCharID is NULL or not.
				if(pdwCharID && lpCompoTmp->dwStringCount > 0) {
					pdw = (DWORD *)((PBYTE)lpCompoTmp + lpCompoTmp->dwOffsetCharID);

					// Security Fix: Dangerous API (CopyMemory)
					dwDtnSize = (DWORD)(lpbOutOfBuffer - ((LPBYTE)pdw));
					if (dwDtnSize < (lpCompoTmp->dwStringCount * sizeof(DWORD)) ) {
						lpCompoTmp->dwStringCount = dwDtnSize / sizeof(DWORD);
					}

					CopyMemory(pdw, pdwCharID, sizeof(DWORD)*lpCompoTmp->dwStringCount);
				}

				*pSize = lpCompoTmp->header.dwSize;
				*ppByte = (PBYTE)lpCompoTmp;
				(*m_lpCImePadSvr->m_fnCoTaskMemFree)(lpCompoInfo);

				//990928:toshiaK for KOTAE #2273
				if(lpwstrCompo) {
					(*m_lpCImePadSvr->m_fnCoTaskMemFree)(lpwstrCompo);
				}
				//990928:toshiaK for KOTAE #2273
				if(pdwCharID) {
					(*m_lpCImePadSvr->m_fnCoTaskMemFree)(pdwCharID);
				}
				DBG(("--> IMECMDID_GETCOMPOSITIONSTRING END\n"));
				break;
			default:
				// Security Fix: Attack surface reduction
				hr = S_FALSE;

				break;
			}
			break;
		case IMEDATAID_CONVSTATUS:
			{
				if(dwCmdID != IMECMDID_GETCONVERSIONSTATUS) {
					DBG((" --> INVALID CMDID\n"));

					// Security Fix: Attack surface reduction
					hr = S_FALSE;
					break;
				}
				DBG(("--> IMECMDID_GETCONVERSIONSTATUS\n"));
				dwSize = sizeof(IMEDATACONVSTATUS);
				LPIMEDATACONVSTATUS lpConvStat;
				lpConvStat = (LPIMEDATACONVSTATUS)(*m_lpCImePadSvr->m_fnCoTaskMemAlloc)(dwSize);
				if(!lpConvStat) {
					DBG(("E_OUTOFMEMORY dwSize [%d]\n", dwSize));
					lpIImeIPoint->Release();
					return E_OUTOFMEMORY;
				}
				LPARAM lConv = 0;
				LPARAM lSent = 0;
				hr = lpIImeIPoint->ControlIME((WORD)IPCTRL_GETCONVERSIONMODE,
											  (LPARAM)&lConv);
				
				hr = lpIImeIPoint->ControlIME((WORD)IPCTRL_GETSENTENCENMODE,
											  (LPARAM)&lSent);
				lpConvStat->header.dwSize  = dwSize;
				lpConvStat->header.dwCmdID = IMECMDID_GETCONVERSIONSTATUS;
				lpConvStat->header.dwDataID= IMEDATAID_CONVSTATUS;
				lpConvStat->dwConversionMode = (DWORD)lConv;
				lpConvStat->dwSentenceMode   = (DWORD)lSent;
				DBG((" --> dwConversionMode[0x%8x]\n", lpConvStat->dwConversionMode));
				DBG((" --> dwSentenceMode  [0x%8x]\n", lpConvStat->dwSentenceMode));
				*pSize  = dwSize;
				*ppByte = (PBYTE)lpConvStat;
			}
			break;
		case IMEDATAID_APPINFO:
			//990816:ToshiaK KOTAE Raid #1757
			if(dwCmdID != IMECMDID_GETAPPLHWND) {
				DBG((" --> INVALID CMDID\n"));
				hr = S_FALSE;
			}
			else {
				IImeCallback *lp = NULL;
				IUnknown *lpUnkCB;
				lpUnkCB = m_lpCImePadSvr->GetIUnkIImeCallback();
				if(!lpUnkCB) {
					DBG(("-->IImeCallback does not set\n"));
					lpIImeIPoint->Release();
					return E_FAIL;
				}
#if 0
				if(IsBadVtbl((IUnkDummy*)lpUnkCB)) {
					DBG(("lpIUnk is BAD Pointer \n"));
					lpIImeIPoint->Release();
					return E_FAIL;
				}
#endif
				lpUnkCB->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
				if(!lp) {
					DBG(("-->QuertyInterface Failed\n"));
					lpIImeIPoint->Release();
					return E_FAIL;
				}

				dwSize = sizeof(IMEDATAAPPLINFO);
				LPIMEDATAAPPLINFO lpApplInfo;
				lpApplInfo = (LPIMEDATAAPPLINFO)(*m_lpCImePadSvr->m_fnCoTaskMemAlloc)(dwSize);
				if(!lpApplInfo) {
					DBG(("E_OUTOFMEMORY dwSize [%d]\n", dwSize));
					lpIImeIPoint->Release();
					return E_OUTOFMEMORY;
				}
				lpApplInfo->header.dwSize  = dwSize;
				lpApplInfo->header.dwCmdID = IMECMDID_GETAPPLHWND;
				lpApplInfo->header.dwDataID= IMEDATAID_APPINFO;
				lpApplInfo->hwndApp = NULL;
				lp->GetApplicationHWND(&lpApplInfo->hwndApp);

				if(pSize && ppByte) {
					*pSize  = dwSize;
					*ppByte = (PBYTE)lpApplInfo;
				}
				else {
					(*m_lpCImePadSvr->m_fnCoTaskMemFree)(lpApplInfo);
					hr = E_FAIL;
				}
				lp->Release();
			}
			break;
		default:
			DBG(("UNKOWN DATAID [0x%08x]\n",  dwDataID));
			hr = S_FALSE;
			break;
		}

		lpIImeIPoint->Release();
	}
	__except(EXCEPTION_EXECUTE_HANDLER) {
		hr = E_FAIL;
	}

	DBG(("CImePadCallback::ReceiveData END hr[0x%08x]\n", hr));
	return hr;
}


//----------------------------------------------------------------

CImePadCallback::CImePadCallback(HWND hwndIF, LPCImePadSvr lpCImePadSvr)
{
	DBG(("######## CImePadCallback::CImePadCallback constructor START ##########\n"));
	m_hwndIF	   = hwndIF;
	m_lpCImePadSvr = lpCImePadSvr;
	m_cRef		   = 0;
	DBG(("######## CImePadCallback::CImePadCallback constructor END   ##########\n"));
}

CImePadCallback::~CImePadCallback()
{
	DBG(("######## CImePadCallback::~CImePadCallback destructor START ##########\n"));
	m_hwndIF	   = NULL;
	m_lpCImePadSvr = NULL;
	DBG(("######## CImePadCallback::~CImePadCallback destructor END   ##########\n"));
	m_cRef		   = 0;
}

VOID*
CImePadCallback::operator new( size_t size )
{
	LPVOID lp = (LPVOID)MemAlloc(size);
	return lp;
}

VOID
CImePadCallback::operator delete( VOID *lp )
{
	if(lp) {
		MemFree(lp);
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpaddbg.cpp ===
//////////////////////////////////////////////////////////////////
// File     : cpaddbg.cpp
// Purpose  :
// 
// 
// Date     : Fri Feb 19 22:03:56 1999
// Author   : 
//
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdarg.h>
#include "cpaddbg.h"
#include <stdio.h>

static IsWinNT()
{
	static OSVERSIONINFO os;
	if(os.dwOSVersionInfoSize == 0) { 
		os.dwOSVersionInfoSize = sizeof(os);
		::GetVersionEx(&os);
	}
	return (os.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

//----------------------------------------------------------------
//internal function prototype declare
//----------------------------------------------------------------
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath);
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath);
VOID   _padDbgPrintfA			(LPSTR  lpstrFmt, ...);
VOID   _padDbgPrintfW			(LPWSTR lpstrFmt, ...);

#define SZPREFIX	"IME:cpad:"
#define WSZPREFIX	L"IME:cpad:"
//----------------------------------------------------------------
// Global Data
//----------------------------------------------------------------
static LPFNDBGCALLBACKA g_lpfnDbgCBA=NULL;
static LPFNDBGCALLBACKW g_lpfnDbgCBW=NULL;
//static BOOL g_fEnable=FALSE;
static BOOL g_fEnable=TRUE;
inline VOID ODStrW(LPWSTR lpwstr)
{
	if(g_fEnable) OutputDebugStringW(lpwstr);
}
inline VOID ODStrA(LPSTR lpstr)
{
	if(g_fEnable) OutputDebugStringA(lpstr);
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgSetCallback
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPFNDBGCALLBACK lpfnDbgCallback 
// Return   : 
// DATE     : Tue Jan 06 12:42:36 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgSetCallback(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW)
{
	g_lpfnDbgCBA = lpfnCBA;
	g_lpfnDbgCBW = lpfnCBW;
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgSwitchOutput
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:35:55 1998
// Author   : 
//////////////////////////////////////////////////////////////////
VOID _padDbgEnableOutput(BOOL fEnable)
{
	g_fEnable = fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgIsOutputEnable
// Type     : VOID
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 18:00:52 1998
// Author   : 
//////////////////////////////////////////////////////////////////
BOOL _padDbgIsOutputEnable(VOID)
{
	return g_fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgOutStrA
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Tue Jan 06 12:29:39 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgOutStrA(LPSTR lpstr)
{
	static BOOL fIn;
	ODStrA(lpstr);
#ifdef _CONSOLE
	printf(lpstr);
#endif

	if(g_lpfnDbgCBA) {
		if(fIn) { return; }
		fIn = TRUE;
		(*g_lpfnDbgCBA)(lpstr);
		fIn = FALSE;
	}
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgOutStrW
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpwstr 
// Return   : 
// DATE     : Tue Jan 06 12:30:07 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgOutStrW(LPWSTR lpwstr)
{
	static BOOL fIn;
	if(IsWinNT()) {
		ODStrW(lpwstr);
	}
	else {
		static CHAR szBuf[1024];
		::WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0);
		ODStrA(szBuf);
	}

#ifdef _CONSOLE
	static CHAR szBuf[1024];
	::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
	printf(szBuf);
#endif
	if(g_lpfnDbgCBW) { 
		if(fIn) { return; } 		
		fIn = TRUE;
		(*g_lpfnDbgCBW)(lpwstr);
		fIn = FALSE;
	}
	return;
}

////////////////////////////////////////////////////////
// Function: _padDbgA
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _padDbgA(LPSTR		lpstrFile, 
			 INT		lineNo, 
			 LPSTR		lpstrMsg)
{
	_padDbgPrintfA("%s(%12s:%4d) %s", 
				  SZPREFIX,
				  GetFileTitleStrA(lpstrFile),
				  lineNo,
				  lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFile 
//          : INT lineNo 
//          : LPWSTR lpstrMsg 
// Return   : 
// DATE     : Mon Jan 05 15:10:41 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg)
{
	_padDbgPrintfW(L"%s(%10s:%4d) %s", 
				  WSZPREFIX,
				  GetFileTitleStrW(lpstrFile),
				  lineNo,
				  lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgVaStrA
// Type     : LPSTR
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:09:53 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	StringCbVPrintfA(chBuf, sizeof(chBuf), lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function : _padDbgVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _padDbgVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	StringCbVPrintfW(wchBuf, sizeof(wchBuf), lpstrFmt, ap);	//Use C-RunTime Library for Win95
	va_end(ap);
	return wchBuf;
}


////////////////////////////////////////////////////////
// Function: _padDbgPrintfA
// Type    : VOID
// Purpose : variable args version of OutputDebugStringA
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _padDbgPrintfA(LPSTR lpstrFmt, ...)
{
	static CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	StringCbVPrintfA(szBuf, sizeof(szBuf), lpstrFmt, ap);
	va_end(ap);
	_padDbgOutStrA(szBuf);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgPrintfW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:11:24 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgPrintfW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	StringCbVPrintfW(wchBuf, sizeof(wchBuf), lpstrFmt, ap); //Use C-RunTime Library for Win95
	va_end(ap);
	_padDbgOutStrW(wchBuf);
	return;
}


//////////////////////////////////////////////////////////////////
// Function : _padDbgMulti2Wide
// Type     : LPWSTR
// Purpose  : return Unicode string from MBCS string
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Mon Jan 05 15:10:48 1998
//////////////////////////////////////////////////////////////////
LPWSTR _padDbgMulti2Wide(LPSTR lpstr)
{
	static WCHAR wchBuf[512];
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}


//////////////////////////////////////////////////////////////////
// Function : _padDbgGetWinClass
// Type     : LPSTR
// Purpose  : Get Windows class name string
//			  ANSI version only.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:08:43 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetWinClass(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetClassNameA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;

}

//////////////////////////////////////////////////////////////////
// Function : _padDbgGetWinText
// Type     : LPSTR
// Purpose  : Get Windows text(title) string
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:09:08 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetWinText(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetWindowTextA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgMsgBoxA
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Thu Jan 08 12:31:03 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgMsgBoxA(LPSTR lpstrFile,  INT lineNo, LPSTR lpstrMsg)
{
#ifdef _CONSOLE
	return;
#endif
	char szTmp[512];
	StringCbPrintfA(szTmp, sizeof(szTmp), "Debug Message Box (File: %s, Line: %4d)", 
			  GetFileTitleStrA(lpstrFile), 
			  lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
}

VOID _padDbgAssert(LPSTR  lpstrFile,  INT lineNo, BOOL fOk, LPSTR lpstrMsg)
{
	if(fOk) {
		return; 
	}
	char szTmp[512];
	StringCbPrintfA(szTmp, sizeof(szTmp), "ASSERT (File: %s, Line: %4d)", 
			  GetFileTitleStrA(lpstrFile), 
			  lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
	DebugBreak();
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgGetErrorString
// Type     : LPSTR
// Purpose  : Convert Error(Got from GetLastError()) value to ERROR Message String
// Args     : 
//          : INT errorCode 
// Return   : 
// DATE     : Mon Jan 05 16:43:34 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetErrorString(INT errorCode)
{
	static CHAR szBuf[512];
	INT count;
	szBuf[0] = (CHAR)0x00;
	StringCbPrintfA(szBuf, sizeof(szBuf), "[0x%08x]:", errorCode);
	count = lstrlenA(szBuf);
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   errorCode, 
				   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				   szBuf+count,
				   sizeof(szBuf)-1-count,
				   NULL );
	if(*(szBuf + count) != (CHAR)0x00) {
		int nLen = lstrlenA(szBuf);
		if((nLen - count) > 1) {
			szBuf[nLen - 1] = (CHAR)0x00;
		}
	}
	return szBuf;
}


//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrA
// Type     : static LPSTR
// Purpose  : Return File name string(remove folder)
// Args     : 
//          : LPSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:34:22 1998
//////////////////////////////////////////////////////////////////
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath)
{
	static CHAR szBuf[2];
	CHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenA(lpstrFilePath) - 1);
	for(pTemp = CharPrevA(lpstrFilePath, pLast); 
		(pTemp  != lpstrFilePath) && 
		(*pTemp != '\\')	 &&
		(*pTemp != (CHAR)0x00); 
		pTemp = CharPrevA(lpstrFilePath, pTemp)) {
		;
	}
	if(*pTemp == '\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}

//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrW
// Type     : static LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:38:19 1998
//////////////////////////////////////////////////////////////////
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath)
{
	static WCHAR szBuf[2];
	WCHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenW(lpstrFilePath) - 1);
	for(pTemp = pLast-1;
		(pTemp != lpstrFilePath) &&
		(*pTemp != L'\\')		 &&
		(*pTemp != (WCHAR)0x0000);
		pTemp--) {
		;
	}

	if(*pTemp == L'\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}


#define DEFID(a)	{a, #a}
typedef struct idStr {
	INT code;
	LPSTR lpstr;
}IDSTR; 

IDSTR rpcError[]={
	DEFID(RPC_S_INVALID_STRING_BINDING),
	DEFID(RPC_S_WRONG_KIND_OF_BINDING),
	DEFID(RPC_S_INVALID_BINDING),
	DEFID(RPC_S_PROTSEQ_NOT_SUPPORTED),
	DEFID(RPC_S_INVALID_RPC_PROTSEQ),
	DEFID(RPC_S_INVALID_STRING_UUID),
	DEFID(RPC_S_INVALID_ENDPOINT_FORMAT),
	DEFID(RPC_S_INVALID_NET_ADDR),
	DEFID(RPC_S_NO_ENDPOINT_FOUND),
	DEFID(RPC_S_INVALID_TIMEOUT),
	DEFID(RPC_S_OBJECT_NOT_FOUND),
	DEFID(RPC_S_ALREADY_REGISTERED),
	DEFID(RPC_S_TYPE_ALREADY_REGISTERED),
	DEFID(RPC_S_ALREADY_LISTENING),
	DEFID(RPC_S_NO_PROTSEQS_REGISTERED),
	DEFID(RPC_S_NOT_LISTENING),
	DEFID(RPC_S_UNKNOWN_MGR_TYPE),
	DEFID(RPC_S_UNKNOWN_IF),
	DEFID(RPC_S_NO_BINDINGS),
	DEFID(RPC_S_NO_PROTSEQS),
	DEFID(RPC_S_CANT_CREATE_ENDPOINT),
	DEFID(RPC_S_OUT_OF_RESOURCES),
	DEFID(RPC_S_SERVER_UNAVAILABLE),
	DEFID(RPC_S_SERVER_TOO_BUSY),
	DEFID(RPC_S_INVALID_NETWORK_OPTIONS),
	DEFID(RPC_S_NO_CALL_ACTIVE),
	DEFID(RPC_S_CALL_FAILED),
	DEFID(RPC_S_CALL_FAILED_DNE),
	DEFID(RPC_S_PROTOCOL_ERROR),
	DEFID(RPC_S_UNSUPPORTED_TRANS_SYN),
	DEFID(RPC_S_UNSUPPORTED_TYPE),
	DEFID(RPC_S_INVALID_TAG),
	DEFID(RPC_S_INVALID_BOUND),
	DEFID(RPC_S_NO_ENTRY_NAME),
	DEFID(RPC_S_INVALID_NAME_SYNTAX),
	DEFID(RPC_S_UNSUPPORTED_NAME_SYNTAX),
	DEFID(RPC_S_UUID_NO_ADDRESS),
	DEFID(RPC_S_DUPLICATE_ENDPOINT),
	DEFID(RPC_S_UNKNOWN_AUTHN_TYPE),
	DEFID(RPC_S_MAX_CALLS_TOO_SMALL),
	DEFID(RPC_S_STRING_TOO_LONG),
	DEFID(RPC_S_PROTSEQ_NOT_FOUND),
	DEFID(RPC_S_PROCNUM_OUT_OF_RANGE),
	DEFID(RPC_S_BINDING_HAS_NO_AUTH),
	DEFID(RPC_S_UNKNOWN_AUTHN_SERVICE),
	DEFID(RPC_S_UNKNOWN_AUTHN_LEVEL),
	DEFID(RPC_S_INVALID_AUTH_IDENTITY),
	DEFID(RPC_S_UNKNOWN_AUTHZ_SERVICE),
	DEFID(EPT_S_INVALID_ENTRY),
	DEFID(EPT_S_CANT_PERFORM_OP),
	DEFID(EPT_S_NOT_REGISTERED),
	DEFID(RPC_S_NOTHING_TO_EXPORT),
	DEFID(RPC_S_INCOMPLETE_NAME),
	DEFID(RPC_S_INVALID_VERS_OPTION),
	DEFID(RPC_S_NO_MORE_MEMBERS),
	DEFID(RPC_S_NOT_ALL_OBJS_UNEXPORTED),
	DEFID(RPC_S_INTERFACE_NOT_FOUND),
	DEFID(RPC_S_ENTRY_ALREADY_EXISTS),
	DEFID(RPC_S_ENTRY_NOT_FOUND),
	DEFID(RPC_S_NAME_SERVICE_UNAVAILABLE),
	DEFID(RPC_S_INVALID_NAF_ID),
	DEFID(RPC_S_CANNOT_SUPPORT),
	DEFID(RPC_S_NO_CONTEXT_AVAILABLE),
	DEFID(RPC_S_INTERNAL_ERROR),
	DEFID(RPC_S_ZERO_DIVIDE),
	DEFID(RPC_S_ADDRESS_ERROR),
	DEFID(RPC_S_FP_DIV_ZERO),
	DEFID(RPC_S_FP_UNDERFLOW),
	DEFID(RPC_S_FP_OVERFLOW),
	DEFID(RPC_X_NO_MORE_ENTRIES),
	DEFID(RPC_X_SS_CHAR_TRANS_OPEN_FAIL),
	DEFID(RPC_X_SS_CHAR_TRANS_SHORT_FILE),
	DEFID(RPC_X_SS_IN_NULL_CONTEXT),
	DEFID(RPC_X_SS_CONTEXT_DAMAGED),
	DEFID(RPC_X_SS_HANDLES_MISMATCH),
	DEFID(RPC_X_SS_CANNOT_GET_CALL_HANDLE),
	DEFID(RPC_X_NULL_REF_POINTER),
	DEFID(RPC_X_ENUM_VALUE_OUT_OF_RANGE),
	DEFID(RPC_X_BYTE_COUNT_TOO_SMALL),
	DEFID(RPC_X_BAD_STUB_DATA),
	DEFID(ERROR_INVALID_USER_BUFFER),
	DEFID(ERROR_UNRECOGNIZED_MEDIA),
	DEFID(ERROR_NO_TRUST_LSA_SECRET),
	DEFID(ERROR_NO_TRUST_SAM_ACCOUNT),
	DEFID(ERROR_TRUSTED_DOMAIN_FAILURE),
	DEFID(ERROR_TRUSTED_RELATIONSHIP_FAILURE),
	DEFID(ERROR_TRUST_FAILURE),
	DEFID(RPC_S_CALL_IN_PROGRESS),
};

LPSTR _padDbgGetRPCError(INT code)
{
	INT i;
	for(i = 0; i < sizeof(rpcError)/sizeof(rpcError[0]); i++) {
		if(rpcError[i].code == code) {
			return rpcError[i].lpstr;
		}
	}
	static char szBuf[]="";
	return szBuf;
}

INT _padDbgShowError(HRESULT hr, LPSTR lpstrFunc)
{
	char szBuf[256];
	char szMsg[1024];
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   hr,
				   0,
				   szBuf,
				   256,
				   NULL);
	szBuf[lstrlenA(szBuf)-1] = (char)0x00;
	StringCbPrintfA(szMsg, sizeof(szMsg), "!!%s: hr[0x%08x] code[%d][%x][%s][%s]",
			  lpstrFunc ? lpstrFunc : "UnknownFunc",
			  hr,
			  HRESULT_CODE(hr),
			  HRESULT_CODE(hr),
			  _padDbgGetErrorString(HRESULT_CODE(hr)), 
			  szBuf);
	DBG(("%s\n", szMsg));
	return 0;
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpaddbg.h ===
//////////////////////////////////////////////////////////////////
// File     : cpaddbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef __C_PAD_DBG_H_
#define __C_PAD_DBG_H_

#include "strsafe.h"

#ifdef __cplusplus
#   define InlineFunc  inline
#else 
#   define InlineFunc  __inline
#endif

//----------------------------------------------------------------
// Callback function prototype
//----------------------------------------------------------------
typedef VOID (WINAPI *LPFNDBGCALLBACKA)(LPSTR  lpstr);
typedef VOID (WINAPI *LPFNDBGCALLBACKW)(LPWSTR lpwstr);

//-------------------------------------------------------
//MACRO function  prototype declare.
//It is valid only if compliled with _DEBUG definition.
//-------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function : DBGSetCallback
// Type     : VOID
// Purpose  : Set debug callback function.
//            callback function has set, when DBG() has called,
//            call this callback function with formatted message string.
// Args     : 
//          : LPFNDBGCALLBACKA lpfnDbgCallbackA 
//          : LPFNDBGCALLBACKW lpfnDbgCallbackW 
// Return   : VOID
// DATE     : Tue Jan 06 12:21:05 1998
//////////////////////////////////////////////////////////////////
//VOID DBGSetCallback(LPFNDBGCALLBACKA lpfnDbgCallbackA, LPFNDBGCALLBACKW lpfnDbgCallbackW);

//////////////////////////////////////////////////////////////////
// Function : DBGEnableOutput
// Type     : VOID
// Purpose  : On off OutputDebugString to COM.
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:33:21 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//VOID DBGEnableOutput(BOOL fEnable)

//////////////////////////////////////////////////////////////////
// Function : DBGIsOutputEnable
// Type     : BOOL
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 17:58:28 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//BOOL DBGIsOutputEnable(VOID)


////////////////////////////////////////////////////////
// Function : DBG
// Type     : VOID
// Purpose  : Printing ANSI debug message with same usage as printf()
// Args     : 
//          : LPSTR lpstrFuncName 
//          : ...   
// Example  : DBGW(("Error occured data[%d]", i));
// CAUTION  : Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//         : ...    
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example  : DBGW(("Error occured data[%d]", i));
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

//////////////////////////////////////////////////////////////////
// Function : DBGMsgBox
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example  : DBGMsgBox(("Error occured data[%d]", i));
//////////////////////////////////////////////////////////////////
//VOID DBGMsgBox((LPSTR lpstrFmt, ...))

//////////////////////////////////////////////////////////////////
// Function : DBGAssert
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fError
// Return   : 
// DATE     : Fri Jan 09 17:17:31 1998
//////////////////////////////////////////////////////////////////
//VOID DBGAssert(BOOL fError)


//////////////////////////////////////////////////////////////////
// Function : DBGSTR
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr
//////////////////////////////////////////////////////////////////
//VOID DBGSTR(LPSTR lpstr);


//////////////////////////////////////////////////////////////////
// Function : DBGGetErrorString
// Type     : VOID
// Purpose  : Get error message from WIN32 Error code.
// Args     : 
//          : INT errorCode 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetErrorString(INT errorCode)


//////////////////////////////////////////////////////////////////
// Function : DBGGetWinClass
// Type     : LPSTR
// Purpose  : Get class name string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinClass(HWND hwnd)

//////////////////////////////////////////////////////////////////
// Function : DBGGetWinText
// Type     : LPSTR
// Purpose  : Get title text string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinText(HWND hwnd)



#ifdef _DEBUG
//----------------------------------------------------------------
//Function prototype declare
//----------------------------------------------------------------
extern VOID   _padDbgEnableOutput   (BOOL fEnable);
extern BOOL   _padDbgIsOutputEnable (VOID);
extern VOID   _padDbgSetCallback        (LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW);
extern VOID   _padDbgA              (LPSTR  lpstrFile, INT lineNo, LPSTR  lpstrMsg);
extern VOID   _padDbgW              (LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _padDbgMsgBoxA            (LPSTR  lpstrFile,  INT lineNo, LPSTR lpstrMsg);
extern VOID   _padDbgAssert         (LPSTR  lpstrFile,  INT lineNo, BOOL fError, LPSTR lpstrMsg);
extern VOID   _padDbgPrintfA            (LPSTR  lpstrFmt, ...);
extern VOID   _padDbgPrintfW            (LPWSTR lpstrFmt, ...);
extern VOID   _padDbgOutStrA            (LPSTR  lpstr);
extern VOID   _padDbgOutStrW            (LPWSTR lpwstr);
extern LPSTR  _padDbgVaStrA         (LPSTR  lpstrFmt, ...);
extern LPWSTR _padDbgVaStrW         (LPWSTR lpstrFmt, ...);
extern LPWSTR _padDbgMulti2Wide     (LPSTR  lpstr);
extern LPSTR  _padDbgGetWinClass        (HWND   hwnd);
extern LPSTR  _padDbgGetWinText     (HWND   hwnd);
extern LPSTR  _padDbgGetErrorString (INT    errorCode);
extern LPSTR  _padDbgGetVkStr       (INT    virtKey);
extern INT    _padDbgShowError      (HRESULT hr, LPSTR lpstrFunc);
//----------------------------------------------------------------
// Macro definition
//----------------------------------------------------------------
#   define DBGSetCallback(a,b)  _padDbgSetCallback(a, b)
#   define DBGEnableOutput(a)   _padDbgEnableOutput(a)
#   define DBGIsOutputEnable()  _padDbgIsOutputEnable()
#   undef DBG
#   define DBG(a)               _padDbgA(__FILE__, __LINE__, _padDbgVaStrA a)
#   define DBGA(a)              _padDbgA(__FILE__, __LINE__, _padDbgVaStrA a)
#   define DBGW(a)              _padDbgW( _padDbgMulti2Wide(__FILE__), __LINE__, _padDbgVaStrW a)
#   define DBGMsgBox(a)         _padDbgMsgBoxA(__FILE__, __LINE__, _padDbgVaStrA a)
#   define DBGAssert(a)         _padDbgAssert(__FILE__, __LINE__, a, #a)
#   define DBGAssertSz(a,b)     _padDbgAssert(__FILE__, __LINE__, a, b)
#   define DBGOutStr(a)         _padDbgOutStrA(a)
#   define DBGOutStrA(a)        _padDbgOutStrA(a)
#   define DBGOutStrW(a)        _padDbgOutStrW(a)
#   define DBGP(a)              _padDbgOutStrA(_padDbgVaStrA a)
#   define DBGPA(a)             _padDbgOutStrA(_padDbgVaStrA a)
#   define DBGPW(a)             _padDbgOutStrW(_padDbgVaStrW a)
#   define DBGGetErrorString(a) _padDbgGetErrorString(a)
#   define DBGGetWinClass(a)    _padDbgGetWinClass(a)
#   define DBGGetWinText(a)     _padDbgGetWinText(a)
#   define DBGShowError(a,b)    _padDbgShowError(a,b)
#else //!_DEBUG //in Release version, these will disapear...
#   define DBGSetCallback(a,b)
#   define DBGEnableOutput(a)
#   define DBGIsOutputEnable()
#   undef DBG
#   define DBG(a)
#   define DBGW(a)
#   define DBGA(a)
#   define DBGP(a)
#   define DBGPA(a)
#   define DBGPW(a)
#   define DBGAssert(a)
#   define DBGAssertSz(a,b)
#   define DBGMsgBox(a)
#   define DBGOutStr(a)
#   define DBGOutStrA(a)
#   define DBGOutStrW(a)
#   define DBGGetErrorString(a)
#   define DBGGetWinClass(a)
#   define DBGGetWinText(a)
#   define DBGShowError(a,b)
#endif //_DEBUG


//----------------------------------------------------------------
//These function use variable argument, so we cannot define 
//"Normal" MACRO for them.
//so, Use inline function that do nothing if _DEBUG is NOT set.
//----------------------------------------------------------------
InlineFunc VOID DBGDoNothingA(LPSTR  lpstrFmt, ...) {lpstrFmt;}
InlineFunc VOID DBGDoNothingW(LPWSTR lpstrFmt, ...) {lpstrFmt;}
#ifdef _DEBUG 
#define DBGPrintf       _padDbgPrintfA
#define DBGPrintfA      _padDbgPrintfA
#define DBGPrintfW      _padDbgPrintfW
#else 
#define DBGPrintf       DBGDoNothingA
#define DBGPrintfA      DBGDoNothingA
#define DBGPrintfW      DBGDoNothingW
#endif


//----------------------------------------------------------------
//This is helper inline function for outputs debug string in 
//Retail version. if FORCE_DEBUG is defined this function works.
//Some time, we met bugs than occurs only retail version, 
//and would like to out debug message. 
//----------------------------------------------------------------
#ifdef FORCE_DEBUG
#include <stdarg.h>
//////////////////////////////////////////////////////////////////
// Function : FDbg
// Type     : InlineFunc VOID
// Purpose  : 
// Args     : 
//          : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Tue Jan 06 19:06:19 1998
//////////////////////////////////////////////////////////////////
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...)
{
    CHAR szBuf[512];
    va_list ap;
    va_start(ap, lpstrFmt);
    StringCbVPrintfA(szBuf, sizeof(szBuf), lpstrFmt, ap);
    va_end(ap);
    OutputDebugStringA(szBuf);  
    return;
}
#else //FORCE_DEBUG
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...) {lpstrFmt;}
#endif

#endif //_C_PAD_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadsvrs.h ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvrs.h
// Purpose  :	
// 
// Date     :	Fri Apr 16 14:34:49 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_IMEPAD_SERVER_SHARE_MEM_H__
#define __C_IMEPAD_SERVER_SHARE_MEM_H__
#include "cpadsvr.h"

class CImePadSvrSharemem;
typedef CImePadSvrSharemem *LPCImePadSvrSharemem;

//----------------------------------------------------------------
//Async notify data.
//----------------------------------------------------------------
typedef struct tagIMEPADNOTIFYDATA {
	DWORD	dwCharID;
	DWORD	dwSelIndex;
	LPWSTR	lpwstrCreated1;
	LPWSTR	lpwstrCreated2;
}IMEPADNOTIFYDATA, LPIMEPADNOTIFYDATA;

interface IImePadServer;
class CImePadSvrSharemem:public CImePadSvr
{
public:
	CImePadSvrSharemem(VOID);
	~CImePadSvrSharemem(VOID);
	virtual BOOL		IsAvailable			(VOID);
	virtual BOOL		OnIMEPadClose		(VOID);
	virtual INT			Initialize			(LANGID	imeLangID, DWORD dwImeInputID, LPVOID lpVoid);
	virtual	INT			Terminate			(LPVOID lpVoid);
	virtual INT			ForceDisConnect		(VOID);
	virtual	INT			ShowUI				(BOOL fShow);
	virtual	INT			IsVisible			(BOOL *pfVisible);
	virtual	INT			ActivateApplet		(UINT		activateID,
											 DWORD_PTR	dwActParam,
											 LPWSTR lpwstr1,
											 LPWSTR lpwstr2);
	virtual	INT			Notify				(INT id, WPARAM wParam, LPARAM lParam);
	virtual INT			GetAppletConfigList	(DWORD	dwMask,
											 INT*	pCountApplet,
											 IMEPADAPPLETCONFIG **ppList);
	virtual IUnknown*	SetIUnkIImeIPoint	(IUnknown *pIUnk);
	virtual IUnknown*	SetIUnkIImeCallback	(IUnknown *pIUnk);
	virtual IUnknown*	GetIUnkIImeIPoint	(VOID);
	virtual IUnknown*	GetIUnkIImeCallback	(VOID);
private:
	//----------------------------------------------------------------
	//private methods.
	//----------------------------------------------------------------
	IImePadServer *			CreateObject(VOID);
	static LRESULT CALLBACK ClientWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT MsgTimer   (HWND hwnd, WPARAM wParam, LPARAM lParam);
	HWND	CreateIFHWND	(VOID);
	BOOL	DestroyIFHWND	(BOOL fReserved);
	INT		CLSID2Str		(REFCLSID refclsid, TCHAR *szBuf, size_t cbBuf);
	INT		CLSID2ModuleName(REFCLSID refclsid,
							 BOOL fLocalSvr,
							 TCHAR *szPath,
							 INT cbSize);

	//----------------------------------------------------------------
	//private member
	//----------------------------------------------------------------
	LANGID					m_imeLangID;			//Save Initialized data.
	DWORD					m_dwImeInputID;			//Save Initialized data.
	BOOL					m_fShowReqStatus;		//Save ShowUI()'s bool value.
	BOOL					m_fLastActiveCtx;		//Save IMEPADNOTIFY_ACTIVATECONTEXT
	HWND					m_hwndIF;				//Internal I/F Window handle.
	IUnknown*				m_lpIUnkIImeIPoint;		//IImeIPoint I/F pointer as IUnknown.
	IUnknown*				m_lpIUnkIImeCallback;	//IImeCallback I/F pointer as IUnknown.
	IImePadServer*			m_lpIImePadServer;		//IImePadServer I/F pointer.
	LPCImePadCallback		m_lpCImePadCallback;	//CImePadCallback instance pointer.
	DWORD					m_dwRegAdvise;			//Callbacck interface connect cookie.
	HMODULE					m_hModuleProxyStub;		//ProxyStub dll instance handle.
	DWORD					m_dwTLSIndexForProxyStub;
	IMEPADNOTIFYDATA		m_ntfyDataApplyCand;	//for IMEPADNOTIFY_APPLYCAND	
	IMEPADNOTIFYDATA		m_ntfyDataQueryCand;	//for IMEPADNOTIFY_QUERYCAND
	IMEPADNOTIFYDATA		m_ntfyDataApplyCandEx;	//for IMEPADNOTIFY_APPLYCANDEX
};
#endif //__C_IMEPAD_SERVER_SHARE_MEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadsvr.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvr.cpp
// Purpose  :	Client source code for IMEPad executable.
// 
// 
// Date     :	Fri Apr 16 15:39:33 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
//----------------------------------------------------------------
//	Public static methods
//
//	static BOOL OnProcessAttach(HINSTANCE hInst);
//	static BOOL OnProcessDetach(VOID);
//	static BOOL OnThreadAttach(VOID);
//	static BOOL OnThreadDetach(VOID);
//	static LPCImePadSvr GetCImePadSvr(VOID);
//	static LPCImePadSvr LoadCImePadSvr(VOID);
//	static LPCImePadSvr FecthCImePadSvr(VOID);
//	static VOID         DestroyCImePadSvr(VOID);
//
//----------------------------------------------------------------
#include <windows.h>
#ifdef UNDER_CE // stub for CE
#include "stub_ce.h"
#endif // UNDER_CE
#include "cpadsvr.h"
#include "cpaddbg.h"
#include "cpadsvrs.h"	//Use Shared Memory for IPC. 

//----------------------------------------------------------------
//misc definition
//----------------------------------------------------------------
#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)

//----------------------------------------------------------------
//Static member initialize
//----------------------------------------------------------------
#define UNDEF_TLSINDEX	0xFFFFFFFF					
INT		CImePadSvr::m_gdwTLSIndex = UNDEF_TLSINDEX;	//Thread Local Strage initial value.
HMODULE	CImePadSvr::m_ghModClient = NULL;			//Client Module handle.

//----------------------------------------------------------------
//OLE function is dynamically loaded/called
//----------------------------------------------------------------
#define SZMOD_OLE32DLL			TEXT("OLE32.DLL")
#define SZFN_COINITIALIZE		"CoInitialize"
#define SZFN_COCREATEINSTANCE	"CoCreateInstance"
#define SZFN_COUNINITIALIZE		"CoUninitialize"
#define SZFN_CODISCONNECTOBJECT	"CoDisconnectObject"
#define SZFN_COTASKMEMALLOC		"CoTaskMemAlloc"
#define SZFN_COTASKMEMREALLOC	"CoTaskMemRealloc"
#define SZFN_COTASKMEMFREE		"CoTaskMemFree"

#ifdef UNICODE
#pragma message("UNICODE Unicode")
#endif
//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::OnProcessAttach
// Type		:	BOOL
// Purpose	:	Get thread local strage index.
//				Initialize static value.	
// Args		:	
//			:	HINSTANCE	hInst	Caller's moudle handle.
// Return	:	
// DATE		:	Fri Apr 16 15:41:32 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvr::OnProcessAttach(HINSTANCE hInst)
{
	DBG(("CImePadSvr::OnProcessAttach START\n"));
#ifdef _DEBUG
	DWORD dwPID = ::GetCurrentProcessId();
	DWORD dwTID = ::GetCurrentThreadId();
	DBG(("-->PID [0x%08x][%d] TID [0x%08x][%d]\n", dwPID, dwPID, dwTID, dwTID));
#endif

#ifdef _DEBUG
	if(m_ghModClient) {
		::DebugBreak();
	}
	if(m_gdwTLSIndex != UNDEF_TLSINDEX) {
		::DebugBreak();
	}
#endif
	m_ghModClient  = (HMODULE)hInst;
	m_gdwTLSIndex  = ::TlsAlloc();	//Get new TLS index.
	if(m_gdwTLSIndex == UNDEF_TLSINDEX) {
		DBG(("-->OnPorcessAttach ::TlsAlloc Error ret [%d]\n", GetLastError()));
	}

	DBG(("-->OnProcessAttach() m_gdwTLSIndex[0x%08x][%d]\n",  m_gdwTLSIndex, m_gdwTLSIndex));
	DBG(("CImePadSvr::OnProcessAttach END\n"));
	return TRUE;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::OnProcessDetach
// Type		:	BOOL
// Purpose	:	Delete all client instance.
//				We cannot call COM API in DLL_PROCESS_DETACH.
//				See DCOM mailing list article, 
//				http://discuss.microsoft.com/SCRIPTS/WA-MSD.EXE?A2=ind9712a&L=dcom&F=&S=&P=20706
// Args		:	None
// Return	:	
// DATE		:	Tue Apr 13 17:49:55 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvr::OnProcessDetach(VOID)
{
	DBG(("CImePadSvr::OnProcessDetach\n"));
	CImePadSvr::OnThreadDetach();

	if(!::TlsFree(m_gdwTLSIndex)) {
		DBG(("-->::TlsFree Error [%d]\n", GetLastError()));
	}
	m_gdwTLSIndex = UNDEF_TLSINDEX;
	DBG(("CImePadSvr::OnProcessDetach END\n"));
	return TRUE;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::OnThreadAttach
// Type		:	BOOL
// Purpose	:	Do Nothing.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 21:37:16 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvr::OnThreadAttach(VOID)
{
	return TRUE;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::OnThreadDetach
// Type		:	BOOL
// Purpose	:	
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 21:38:06 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvr::OnThreadDetach(VOID)
{
	DBG(("CImePadSvr::OnThreadDetach\n"));
#ifdef _DEBUG
	DWORD dwPID = ::GetCurrentProcessId();
	DWORD dwTID = ::GetCurrentThreadId();
	DBG(("-->PID [0x%08x][%d] TID [0x%08x][%d]\n", dwPID, dwPID, dwTID, dwTID));
#endif
	LPCImePadSvr lpCImePadSvr = (LPCImePadSvr)::TlsGetValue(m_gdwTLSIndex);
	if(lpCImePadSvr) {
		DBG(("-->First Set TlsSetValue as NULL\n"));
		if(!::TlsSetValue(m_gdwTLSIndex, NULL)) {
			DBG(("TlsSetValue Failed\n"));
		}
		DBG(("-->Call ForceDisConnect() START\n"));
		lpCImePadSvr->ForceDisConnect();
		DBG(("-->Call ForceDisConnect() END\n"));
		delete lpCImePadSvr;
	}
	DBG(("CImePadSvr::OnThreadDetach END\n"));
	return TRUE;
}


//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::GetCImePadSvr
// Type		:	LPCImePadSvr
// Purpose	:	Get LPCImePadSvr pointer in current Thread.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 21:41:46 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
LPCImePadSvr
CImePadSvr::GetCImePadSvr(VOID)
{
	LPCImePadSvr lpCImePadSvr;
	if(m_gdwTLSIndex == UNDEF_TLSINDEX) {
		DBG(("-->CImePadSvr::GetCImePadSvr() Error, need TLS index\n"));  
#ifdef _DEBUG
		//DebugBreak();
#endif
		return NULL;
	}
	lpCImePadSvr = (LPCImePadSvr)::TlsGetValue(m_gdwTLSIndex); 
	return lpCImePadSvr;
}


//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::LoadCImePadSvr
// Type		:	LPCImePadSvr
// Purpose	:	Load LPCImePadSvr pointer in current thread.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 21:42:17 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
LPCImePadSvr
CImePadSvr::LoadCImePadSvr(INT protocol)
{
	LPCImePadSvr lpCImePadSvr;

	lpCImePadSvr = CImePadSvr::GetCImePadSvr();
	
	if(lpCImePadSvr) {	//Already created in current thread. 
		return lpCImePadSvr;
	}

	lpCImePadSvr = NULL;
	switch(protocol) {
	case CIMEPADSVR_COM:
		//lpCImePadSvr = new CImePadSvrCOM(); 
		break;
	case CIMEPADSVR_SHAREDMEM:
		lpCImePadSvr = new CImePadSvrSharemem();
		if(lpCImePadSvr) {
			if(!lpCImePadSvr->IsAvailable()) {
				delete lpCImePadSvr;
				lpCImePadSvr = NULL;
			}
		}
		break;
	default:
		break;
	}
	if(!lpCImePadSvr) {
		DBG(("-->LoadCImePadSvr() Error Out of Memory?\n"));
		return NULL;
	}
	//Set new value to TLS.
	if(!::TlsSetValue(m_gdwTLSIndex, lpCImePadSvr)) {
		DBG(("-->LoadCImePadSvr() TlsSetValue Failed [%d]\n", GetLastError()));
		delete lpCImePadSvr;
		::TlsSetValue(m_gdwTLSIndex, NULL);
		return NULL;
	}
	return lpCImePadSvr;
}

LPCImePadSvr
CImePadSvr::FecthCImePadSvr(VOID)
{
	return NULL;
}

VOID
CImePadSvr::DestroyCImePadSvr(VOID)
{
	DBG(("CImePadSvr::DestroyCImePadSvr START\n"));
	LPCImePadSvr lpCImePadSvr = GetCImePadSvr();
	if(!lpCImePadSvr) {
		DBG(("-->CImePadSvr::DestroyCImePadSvr() Already Destroyed or not instance\n"));
		DBG(("CImePadSvr::DestroyCImePadSvr END\n"));
		return;
	}
	lpCImePadSvr->Terminate(NULL);
	delete lpCImePadSvr;
	if(!::TlsSetValue(m_gdwTLSIndex, NULL)) {
		DBG(("-->TlsSetValue() error [%d]\n", GetLastError()));
	}
	DBG(("CImePadSvr::DestroyCImePadSvr END\n"));
	return;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::CImePadSvr
// Type		:	
// Purpose	:	Constructor of CImePadSvr
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:37:18 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvr::CImePadSvr()
{
	DBG(("CImePadSvr::CImePadSvr START\n"));
	m_fCoInitSuccess		= FALSE;	//Flag for CoInitialize() successed or not. 
	m_fOLELoaded			= FALSE;	//OLE32.DLL is loaded by Application or explicitly loaded.
	m_hModOLE				= FALSE;	//OLE32.DLL module handle.
	m_fnCoInitialize		= NULL;		//CoInitialize()		function pointer.
	m_fnCoCreateInstance	= NULL;		//CoCreateInstance()	function pointer.
	m_fnCoUninitialize		= NULL;		//CoUninitialize()		function pointer.
	m_fnCoDisconnectObject	= NULL;		//CoDisconnectObject()	function pointer.
	m_fnCoTaskMemAlloc		= NULL;		//CoTaskMemAlloc()		function pointer.
	m_fnCoTaskMemRealloc	= NULL;		//CoTaskMemRealloc()	function pointer.
	m_fnCoTaskMemFree		= NULL;		//CoTaskMemFree()		function pointer.
	DBG(("CImePadSvr::CImePadSvr END\n"));
}

CImePadSvr::~CImePadSvr()
{
	DBG(("CImePadSvr::~CImePadSvr START\n"));
	m_fCoInitSuccess		= FALSE;	//Flag for CoInitialize() successed or not. 
	m_fOLELoaded			= FALSE;	//OLE32.DLL is loaded by Application or explicitly loaded.
	m_hModOLE				= FALSE;	//OLE32.DLL module handle.
	m_fnCoInitialize		= NULL;		//CoInitialize()		function pointer.
	m_fnCoCreateInstance	= NULL;		//CoCreateInstance()	function pointer.
	m_fnCoUninitialize		= NULL;		//CoUninitialize()		function pointer.
	m_fnCoDisconnectObject	= NULL;		//CoDisconnectObject()	function pointer.
	m_fnCoTaskMemAlloc		= NULL;		//CoTaskMemAlloc()		function pointer.
	m_fnCoTaskMemRealloc	= NULL;		//CoTaskMemRealloc()	function pointer.
	m_fnCoTaskMemFree		= NULL;		//CoTaskMemFree()		function pointer.
	DBG(("CImePadSvr::~CImePadSvr END\n"));
}

BOOL
CImePadSvr::InitOleAPI(VOID)
{
	DBG(("CImePadSvr::InitOleAPI START\n"));

	// Security Push: Dangerous API
	// Mofule name must be with full path.

	if(!m_hModOLE) {
		INT	cbBufSize = (MAX_PATH+lstrlen(SZMOD_OLE32DLL)) * sizeof(TCHAR);
		LPTSTR	lptstrOLE32FileName = (LPTSTR)MemAlloc(cbBufSize);
		if (lptstrOLE32FileName) {
			if (GetSystemDirectory(lptstrOLE32FileName, cbBufSize / sizeof(TCHAR))) {
				if (SUCCEEDED(StringCbCat(lptstrOLE32FileName, cbBufSize, TEXT("\\")))) {
					if (SUCCEEDED(StringCbCat(lptstrOLE32FileName, cbBufSize, SZMOD_OLE32DLL))) {
						m_hModOLE = ::GetModuleHandle(lptstrOLE32FileName);
						if(m_hModOLE) {
							DBG(("-->%s is Loaded by Application\n", SZMOD_OLE32DLL));
							m_fOLELoaded = FALSE;
						}
						else {
							m_hModOLE = ::LoadLibrary(lptstrOLE32FileName);
						}
					}
				}
			}
			MemFree(lptstrOLE32FileName);
		}
	}

	if(m_hModOLE) {
		DBG(("--> %s has Loaded Explicitly", SZMOD_OLE32DLL)); 
		m_fOLELoaded = TRUE;
	}
	else {
		return FALSE;
	}


	m_fnCoInitialize	  = (FN_COINITIALIZE)		GetProcAddress(m_hModOLE, SZFN_COINITIALIZE);
	m_fnCoCreateInstance  = (FN_COCREATEINSTANCE)	::GetProcAddress(m_hModOLE, SZFN_COCREATEINSTANCE);
	m_fnCoUninitialize	  = (FN_COUNINITIALIZE)		::GetProcAddress(m_hModOLE, SZFN_COUNINITIALIZE);
	m_fnCoDisconnectObject= (FN_CODISCONNECTOBJECT)	::GetProcAddress(m_hModOLE, SZFN_CODISCONNECTOBJECT);
	m_fnCoTaskMemAlloc	  = (FN_COTASKMEMALLOC)		::GetProcAddress(m_hModOLE, SZFN_COTASKMEMALLOC);
	m_fnCoTaskMemRealloc  = (FN_COTASKMEMREALLOC)	::GetProcAddress(m_hModOLE, SZFN_COTASKMEMREALLOC);
	m_fnCoTaskMemFree	  = (FN_COTASKMEMFREE)		::GetProcAddress(m_hModOLE, SZFN_COTASKMEMFREE);

	if(!m_fnCoInitialize		||
	   !m_fnCoCreateInstance	||
	   !m_fnCoUninitialize		||
	   !m_fnCoDisconnectObject	||
	   !m_fnCoTaskMemAlloc		||
	   !m_fnCoTaskMemRealloc	||	
	   !m_fnCoTaskMemFree) {
	   
		DBG(("InitOleAPI Failed: GetProcAddress Error\n"));
		return FALSE;
	}
	DBG(("CImePadSvr::InitOleAPI END\n"));
	return TRUE;
}

BOOL
CImePadSvr::TermOleAPI(VOID)
{
	DBG(("CImePadSvr::TermOleAPI START\n"));
	m_fnCoInitialize		= NULL;
	m_fnCoCreateInstance	= NULL;
	m_fnCoUninitialize		= NULL;
	m_fnCoDisconnectObject	= NULL;
	m_fnCoTaskMemAlloc		= NULL;
	m_fnCoTaskMemRealloc	= NULL; 
	m_fnCoTaskMemFree		= NULL;

	if(!m_hModOLE) {
		DBG(("-->TermOleAPI already Terminated?\n"));
		return TRUE;
	}

	if(m_hModOLE && m_fOLELoaded) {
		DBG(("--> FreeLibrary\n"));
		::FreeLibrary(m_hModOLE);
	}
	m_hModOLE    = NULL;
	m_fOLELoaded = FALSE;
	DBG(("CImePadSvr::TermOleAPI END\n"));
	return TRUE;
}

VOID*
CImePadSvr::operator new( size_t size )
{
	LPVOID lp = (LPVOID)MemAlloc(size);
	return lp;
}

VOID
CImePadSvr::operator delete( VOID *lp )
{
	if(lp) {
		MemFree(lp);
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadsvr.h ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvr.h
// Purpose  :	Class for Client that uses IMEPad.
//				This is Super(Abstract) class.
//				
// 
// Date     :	Fri Apr 16 14:34:49 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_IMEPAD_SERVER_H__
#define __C_IMEPAD_SERVER_H__
#include "imepadsv.h"

//----------------------------------------------------------------
//Select protocol in LoadCImePadSvr();
//----------------------------------------------------------------
#define CIMEPADSVR_COM				0x0010
#define CIMEPADSVR_SHAREDMEM		0x0020
#define SZ_IMEPADIFCLASS			TEXT("msimepad9IFClass")
//----------------------------------------------------------------
//TIMER id definition
//----------------------------------------------------------------
#define TIMERID_NOTIFY_ACTIVATECONTEXT	0x0010
#define TIMERID_NOTIFY_APPLYCANDIDATE	0x0011
#define TIMERID_NOTIFY_QUERYCANDIDATE	0x0012
#define TIMERID_NOTIFY_APPLYCANDIDATEEX	0x0013
#define TIMERELAPS_ACTIVATE				200		//milisec
#define TIMERELAPS_INACTIVATE			100
#define TIMERELAPS_NOTIFY				200

//----------------------------------------------------------------
//Forward declare
//----------------------------------------------------------------
class CImePadCallback;
typedef CImePadCallback *LPCImePadCallback;
class CImePadSvr;
typedef CImePadSvr*	LPCImePadSvr;

//----------------------------------------------------------------
//OLE API func's pointer declare
//----------------------------------------------------------------
typedef HRESULT (WINAPI* FN_COINITIALIZE)(LPVOID pvReserved);
typedef HRESULT (WINAPI* FN_COCREATEINSTANCE)(REFCLSID rclsid,
											  LPUNKNOWN pUnkOuter,
											  DWORD dwClsContext,
											  REFIID riid,
											  LPVOID FAR* ppv);
typedef void    (WINAPI* FN_COUNINITIALIZE)(void);
typedef HRESULT (WINAPI* FN_CODISCONNECTOBJECT)(LPUNKNOWN pUnk, DWORD dwReserved);
typedef LPVOID  (WINAPI* FN_COTASKMEMALLOC)(ULONG cb);
typedef LPVOID  (WINAPI* FN_COTASKMEMREALLOC)(LPVOID pv, ULONG cb);
typedef VOID    (WINAPI* FN_COTASKMEMFREE)(LPVOID pv);


class CImePadSvr
{
public:
	//----------------------------------------------------------------
	//Static method declare
	//----------------------------------------------------------------
	static BOOL OnProcessAttach(HINSTANCE hInst);
	static BOOL OnProcessDetach(VOID);
	static BOOL OnThreadAttach(VOID);
	static BOOL OnThreadDetach(VOID);
	static LPCImePadSvr GetCImePadSvr(VOID);
	static LPCImePadSvr LoadCImePadSvr(INT flag);
	static LPCImePadSvr FecthCImePadSvr(VOID);
	static VOID         DestroyCImePadSvr(VOID);
	friend class CImePadCallback;
	VOID* operator new( size_t size );
	VOID  operator delete( VOID *lp );
private:
	static INT		m_gdwTLSIndex;
protected:
	static HMODULE	m_ghModClient;
	INT InitOleAPI(VOID);
	INT TermOleAPI(VOID);
	BOOL					m_fCoInitSuccess;		//Flag for CoInitialize() successed or not. 
	BOOL					m_fOLELoaded;			//OLE32.DLL is loaded by Application or explicitly loaded.
	HMODULE					m_hModOLE;				//OLE32.DLL module handle.
	FN_COINITIALIZE			m_fnCoInitialize;		//CoInitialize()		function pointer.
	FN_COCREATEINSTANCE		m_fnCoCreateInstance;	//CoCreateInstance()	function pointer.
	FN_COUNINITIALIZE		m_fnCoUninitialize;		//CoUninitialize()		function pointer.
	FN_CODISCONNECTOBJECT	m_fnCoDisconnectObject;	//CoDisconnectObject()	function pointer.
	FN_COTASKMEMALLOC		m_fnCoTaskMemAlloc;		//CoTaskMemAlloc()		function pointer.
	FN_COTASKMEMREALLOC		m_fnCoTaskMemRealloc;	//CoTaskMemRealloc()	function pointer.
	FN_COTASKMEMFREE		m_fnCoTaskMemFree;		//CoTaskMemFree()		function pointer.
public:
	CImePadSvr();
	virtual ~CImePadSvr();
	virtual BOOL		IsAvailable			(VOID)=0;
	virtual BOOL		OnIMEPadClose		(VOID)=0;
	//----------------------------------------------------------------
	//IImePadSvr interface
	//----------------------------------------------------------------
	virtual INT			Initialize			(LANGID	imeLangID, DWORD dwImeInputID, LPVOID lpVoid)=0;
	virtual	INT			Terminate			(LPVOID lpVoid)=0;
	virtual INT			ForceDisConnect		(VOID)=0;
	virtual	INT			ShowUI				(BOOL fShow)=0;
	virtual	INT			IsVisible			(BOOL *pfVisible)=0;
	virtual	INT			ActivateApplet		(UINT   activateID,
											 DWORD_PTR	dwActParam,
											 LPWSTR lpwstr1,
											 LPWSTR lpwstr2)=0; 
	virtual	INT			Notify				(INT	id,
											 WPARAM wParam,
											 LPARAM lParam)=0;
	virtual INT			GetAppletConfigList(DWORD	dwMask,
											 INT*	pCountApplet,
											 IMEPADAPPLETCONFIG **ppCfgList)=0;
	//----------------------------------------------------------------
	//Set/Get IImeIPoint, IImeCallback interface
	//----------------------------------------------------------------
	virtual IUnknown*	SetIUnkIImeIPoint	(IUnknown *pIUnk)=0;
	virtual IUnknown*	SetIUnkIImeCallback	(IUnknown *pIUnk)=0;
	virtual IUnknown*	GetIUnkIImeIPoint	(VOID)=0;
	virtual IUnknown*	GetIUnkIImeCallback	(VOID)=0;
};
#endif //__C_IMEPAD_SERVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadsvrs.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvrs.cpp
// Purpose  :	CImePadServer for Shared Memory version.
// 
// 
// Date     :	Fri Apr 16 15:39:33 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifdef UNDER_CE // stub for CE
#include "stub_ce.h"
#endif // UNDER_CE
#include "imepadsv.h"
#include "cpadsvrs.h"
#include "cpadcb.h"
#include "cpaddbg.h"
#include "iimecb.h"
#include "ipoint1.h"

// Safe String
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//----------------------------------------------------------------
//misc definition
//----------------------------------------------------------------
#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)

inline LPVOID
WinSetUserPtr(HWND hwnd, LPVOID lpVoid)
{
#ifdef _WIN64	
	return (LPVOID)SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpVoid);
#else
	return (LPVOID)SetWindowLong(hwnd, GWL_USERDATA, (LONG)lpVoid);
#endif
}

inline LPVOID
WinGetUserPtr(HWND hwnd)
{
#ifdef _WIN64	
	return (LPVOID)GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	return (LPVOID)GetWindowLong(hwnd, GWL_USERDATA);
#endif
}

static LPWSTR
StrdupW(LPWSTR lpwstr)
{
	LPWSTR lpwstrRet;
	if(!lpwstr) {
		return NULL;
	}
	INT len = lstrlenW(lpwstr);
	if(len == 0) {
		return NULL;
	}
	lpwstrRet = (LPWSTR)MemAlloc((len+1) * sizeof(WCHAR));
	if(!lpwstrRet) {
		return NULL;
	}
	CopyMemory(lpwstrRet, lpwstr, sizeof(WCHAR)*len);
	lpwstrRet[len] = (WCHAR)0x0000;
	return lpwstrRet;
} 

//----------------------------------------------------------------
//
//public method decalre
//
//----------------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrSharemem::CImePadSvrSharemem
// Type		:	None
// Purpose	:	Constructor of CImePadSvrSharemem class
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:04:01 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvrSharemem::CImePadSvrSharemem(VOID)
{
	DBG(("CImePadSvrSharemem::CImePadSvrSharemem() constructor START\n"));
	m_imeLangID				= 0;		//Save Initialized data.
	m_dwImeInputID			= 0;		//Save Initialized data.
	m_fShowReqStatus		= FALSE;	//Save ShowUI()'s bool value.
	m_fLastActiveCtx		= FALSE;	//Save IMEPADNOTIFY_ACTIVATECONTEXT
	m_hwndIF				= NULL;		//Internal I/F Window handle.
	m_lpIUnkIImeIPoint		= NULL;		//IImeIPoint I/F pointer as IUnknown.
	m_lpIUnkIImeCallback	= NULL;		//IImeCallback I/F pointer as IUnknown.
	m_lpCImePadCallback		= NULL;		//CImePadCallback instance pointer.
	m_lpIImePadServer		= NULL;		//IImePadServer I/F pointer.
	m_dwRegAdvise			= 0;
	m_hModuleProxyStub		= NULL;

	//Initialize Candidate data
	ZeroMemory(&m_ntfyDataApplyCand,	sizeof(m_ntfyDataApplyCand));
	ZeroMemory(&m_ntfyDataQueryCand,	sizeof(m_ntfyDataQueryCand));
	ZeroMemory(&m_ntfyDataApplyCandEx,	sizeof(m_ntfyDataApplyCandEx));

	DBG(("CImePadSvrSharemem::CImePadSvrSharemem() constructor END\n"));
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrSharemem::~CImePadSvrSharemem
// Type		:	INT
// Purpose	:	Destructor of CImePadSvrSharemem Class.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:04:29 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvrSharemem::~CImePadSvrSharemem(VOID)
{
	DBG(("CImePadSvrSharemem::CImePadSvrSharemem() Destructor START\n"));
	this->DestroyIFHWND(TRUE);
	m_imeLangID				= 0;		//Save Initialized data.
	m_dwImeInputID			= 0;		//Save Initialized data.
	m_fShowReqStatus		= FALSE;	//Save ShowUI()'s bool value.
	m_fLastActiveCtx		= FALSE;	//Save IMEPADNOTIFY_ACTIVATECONTEXT
	m_hwndIF				= NULL;		//Internal I/F Window handle.
	m_lpIUnkIImeIPoint		= NULL;		//IImeIPoint I/F pointer as IUnknown.
	m_lpIUnkIImeCallback	= NULL;		//IImeCallback I/F pointer as IUnknown.
	m_lpIImePadServer		= NULL;		//IImePadServer I/F pointer.

	//990813:ToshiaK. Memory leak.
	if(m_lpCImePadCallback) {
		delete m_lpCImePadCallback;
		m_lpCImePadCallback = NULL;
	}

	if(m_hModuleProxyStub) {
		::FreeLibrary(m_hModuleProxyStub);
		m_hModuleProxyStub = 0;
	}
	DBG(("CImePadSvrSharemem::CImePadSvrSharemem() Destructor END\n"));
}

BOOL
CImePadSvrSharemem::IsAvailable(VOID)
{
	LPTSTR lpPath = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
	if(!lpPath) {
		DBG(("-->Outof Memory ??\n"));
		return FALSE;
	}

	if(0 ==  this->CLSID2ModuleName(IID_IImePadServerSHM,
									FALSE,
									lpPath,
									sizeof(TCHAR)*MAX_PATH)) {
		MemFree(lpPath);
		return TRUE;
	}
	MemFree(lpPath);
	return FALSE;

}

BOOL
CImePadSvrSharemem::OnIMEPadClose(VOID)
{
	m_fShowReqStatus = FALSE;
	return 0;
}

INT
CImePadSvrSharemem::Initialize(LANGID	imeLangID,
							   DWORD	dwImeInputID,
							   LPVOID	lpVoid)
{
	DBG(("CImePadSvrSharemem::Initialize() START\n"));
	DBG(("--> imeLangID   [0x%08x]\n", imeLangID));
	DBG(("--> dwImeInputID[0x%08x]\n", dwImeInputID));
	if(m_lpIImePadServer) {
		DBG(("-->Already Initialized\n"));
		return 0;
	}

	HRESULT hr;
	
	this->CreateIFHWND();	//Create internal Interface Window.
	m_imeLangID		= imeLangID;
	m_dwImeInputID	= dwImeInputID;
	if(!m_lpCImePadCallback) {
		m_lpCImePadCallback = new CImePadCallback(m_hwndIF, this);
	}
	this->InitOleAPI();
	m_lpIImePadServer = (IImePadServer *)this->CreateObject();
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->Initialize(::GetCurrentProcessId(),
								  ::GetCurrentThreadId(),
								  (DWORD)imeLangID,
								  (DWORD)dwImeInputID,
								  FALSE,					//fUIM;
								  m_lpCImePadCallback,
								  NULL,
								  0,
								  0);
	DBG(("CImePadSvrSharemem::Initialize() END\n"));
	return 0;
	Unref(lpVoid);
	Unref(hr);
}

INT
CImePadSvrSharemem::Terminate(LPVOID lpVoid)
{
	DBG(("CImePadSvrSharemem::::Terminate() START \n"));
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->Terminate(0, 0);
	m_lpIImePadServer = NULL;
	//990813:ToshiaK memory leak;
	if(m_lpCImePadCallback) {
		delete m_lpCImePadCallback;
		m_lpCImePadCallback = NULL;
	}
	DBG(("CImePadSvrSharemem::Terminate() End\n"));
	return 0;
	Unref(lpVoid);
}

INT
CImePadSvrSharemem::ForceDisConnect(VOID)
{
	DBG(("CImePadSvrSharemem::ForceDisConnect START\n"));
	if(m_lpIImePadServer) {
		m_lpIImePadServer = NULL;
	}
	DBG(("CImePadSvrSharemem::ForceDisConnect END\n"));
	return 0;
}


INT
CImePadSvrSharemem::ShowUI(BOOL fShow)
{
	DBG(("CImePadSvrSharemem::ShowUI() START fShow [%d]\n"));
	m_fShowReqStatus = fShow;
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->ShowUI(fShow);
	DBG(("CImePadSvrSharemem::ShowUI() END\n"));
	return 0;
}

INT
CImePadSvrSharemem::IsVisible(BOOL *pfVisible)
{
	if(pfVisible) {
		*pfVisible = m_fShowReqStatus;
	}
	return 0;
}

INT
CImePadSvrSharemem::ActivateApplet(UINT activateID,
								   DWORD_PTR dwActivateParam,
								   LPWSTR lpwstr1,
								   LPWSTR lpwstr2)
{
	DBG(("CImePadSvrSharemem::ActivateApplet START\n"));
	DBG(("-->activateID      [0x%08x][%s]\n",
		 activateID,
		 activateID == IMEPADACTID_ACTIVATEBYCATID ? "IMEPADACTID_ACTIVATEBYCATID" :
		 activateID == IMEPADACTID_ACTIVATEBYIID   ? "IMEPADACTID_ACTIVATEBYIID" :
		 activateID == IMEPADACTID_ACTIVATEBYNAME  ? "IMEPADACTID_ACTIVATEBYNAME" : 
		 "Unknown"));
	DBG(("-->dwActivateParam [0x%08x]\n", dwActivateParam));
	DBG(("-->lpwstr1         [0x%08x]\n", lpwstr1));
	DBG(("-->lpwstr2         [0x%08x]\n", lpwstr2));

	if(!m_lpIImePadServer) {
		DBG(("-->m_lpIImePadServer is NULL\n"));
		DBG(("CImePadSvrSharemem::ActivateApplet END\n"));
		return -1;
	}
	m_lpIImePadServer->ActivateApplet(activateID,
									  dwActivateParam,
									  lpwstr1,
									  lpwstr2);
	DBG(("CImePadSvrSharemem::ActivateApplet END\n"));
	return 0;
	Unref(activateID);
	Unref(dwActivateParam);
	Unref(lpwstr1);
	Unref(lpwstr2);
}

INT
CImePadSvrSharemem::Notify(INT id, WPARAM wParam, LPARAM lParam)
{
	HRESULT hr;
	switch(id) {
	case IMEPADNOTIFY_ACTIVATECONTEXT:
		DBG(("CImePadSvrSharemem::Notify: ActivateContext\n"));
		//990608:KOTAE #1121. if ImePad is not shown in this application,
		//Do not send IMEPADNOTIFY_ACTIVATECONTEXT
		if(!m_fShowReqStatus) {
			return 0;
		}
		m_fLastActiveCtx = (BOOL)wParam;
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_ACTIVATECONTEXT);
		if(m_fLastActiveCtx) {
			::SetTimer(m_hwndIF,
					   TIMERID_NOTIFY_ACTIVATECONTEXT,
					   TIMERELAPS_ACTIVATE,
					   NULL);
		}
		else {
			::SetTimer(m_hwndIF,
					   TIMERID_NOTIFY_ACTIVATECONTEXT,
					   TIMERELAPS_INACTIVATE,
					   NULL);
		}
		break;
	case IMEPADNOTIFY_APPLYCANDIDATE:
		//----------------------------------------------------------------
		// Notify for Candidate Applied
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: iSelIndex = (INT)lParam;
		//----------------------------------------------------------------
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATE);
		m_ntfyDataApplyCand.dwCharID   = (DWORD)wParam;
		m_ntfyDataApplyCand.dwSelIndex = (DWORD)lParam;
		::SetTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATE, TIMERELAPS_NOTIFY, NULL);

		break;
	case IMEPADNOTIFY_QUERYCANDIDATE:
		//----------------------------------------------------------------
		// Notify for Querying Candidate
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: 0. not used.
		//----------------------------------------------------------------
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_QUERYCANDIDATE);
		m_ntfyDataQueryCand.dwCharID = (DWORD)wParam;
		::SetTimer(m_hwndIF, TIMERID_NOTIFY_QUERYCANDIDATE, TIMERELAPS_NOTIFY, NULL);
		break;
	case IMEPADNOTIFY_APPLYCANDIDATE_EX:
		//----------------------------------------------------------------
		// Notify for Candidate Applied
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: lpApplyCandEx = (LPIMEPADAPPLYCANDEX)lParam;
		//----------------------------------------------------------------
		{
			::KillTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATEEX);
			m_ntfyDataApplyCandEx.dwCharID = (DWORD)wParam;
			LPIMEPADAPPLYCANDINFO lpApplyCandInfo = (LPIMEPADAPPLYCANDINFO)lParam;

			if(m_ntfyDataApplyCandEx.lpwstrCreated1) {
				MemFree(m_ntfyDataApplyCandEx.lpwstrCreated1);
			}
			if(m_ntfyDataApplyCandEx.lpwstrCreated2) {
				MemFree(m_ntfyDataApplyCandEx.lpwstrCreated2);
			}
			m_ntfyDataApplyCandEx.lpwstrCreated1 = NULL;
			m_ntfyDataApplyCandEx.lpwstrCreated2 = NULL;
			
			if(lpApplyCandInfo) {
				if(lpApplyCandInfo->lpwstrDisplay) {
					m_ntfyDataApplyCandEx.lpwstrCreated1 = StrdupW(lpApplyCandInfo->lpwstrDisplay);
				}
				if(lpApplyCandInfo->lpwstrReading) {
					m_ntfyDataApplyCandEx.lpwstrCreated2 = StrdupW(lpApplyCandInfo->lpwstrReading);
				}
			}
			::SetTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATEEX, TIMERELAPS_NOTIFY, NULL);
		}
		break;
	case IMEPADNOTIFY_MODECHANGED:
		break;
	case IMEPADNOTIFY_STARTCOMPOSITION:
		break;
	case IMEPADNOTIFY_COMPOSITION:
		break;
	case IMEPADNOTIFY_ENDCOMPOSITION:
		break;
	case IMEPADNOTIFY_OPENCANDIDATE:
		break;
	case IMEPADNOTIFY_CLOSECANDIDATE:
		break;
	default:
		break;
	}
	return 0;
	Unref(hr);
	Unref(wParam);
	Unref(lParam);
}

INT
CImePadSvrSharemem::GetAppletConfigList(DWORD dwMask,
										INT *pCountApplet,
										IMEPADAPPLETCONFIG **ppList)
{
	DBG(("CImePadSvrSharemem::GetAppletConfigList START\n"));
	if(!m_lpIImePadServer) {
		DBG(("-->m_lpIImePadServer is NULL\n"));
		return -1;
	}
	HRESULT hr;
	hr = m_lpIImePadServer->GetAppletConfigList(dwMask,
												(UINT *)pCountApplet,
												ppList);
	DBG(("CImePadSvrSharemem::GetAppletConfigList END\n"));
	return hr;
}

IUnknown *
CImePadSvrSharemem::SetIUnkIImeIPoint(IUnknown *pIUnkIImeIPoint)
{
	return m_lpIUnkIImeIPoint = pIUnkIImeIPoint;
}

IUnknown *
CImePadSvrSharemem::SetIUnkIImeCallback(IUnknown *pIUnkIImeCallback)
{
	return m_lpIUnkIImeCallback = pIUnkIImeCallback;
}

IUnknown*
CImePadSvrSharemem::GetIUnkIImeIPoint(VOID)
{
	return m_lpIUnkIImeIPoint;
}

IUnknown*
CImePadSvrSharemem::GetIUnkIImeCallback(VOID)
{
	return m_lpIUnkIImeCallback;
}


//----------------------------------------------------------------
//
//private static method
//
//----------------------------------------------------------------

IImePadServer*
CImePadSvrSharemem::CreateObject(VOID)
{
	DBG(("CImePadSvrSharemem::CreateObject START\n"));
	typedef LPVOID (WINAPI * LPFN_CREATEOBJECT)(DWORD dwIntanceID);
	if(m_hModuleProxyStub) {
		DBG(("-->Already Created\n"));
		return m_lpIImePadServer;
	}

	LPTSTR lpPath = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
	if(!lpPath) {
		DBG(("-->Outof Memory ??\n"));
		return NULL;
	}

	if(0 !=  this->CLSID2ModuleName(IID_IImePadServerSHM,
									FALSE,
									lpPath,
									sizeof(TCHAR)*MAX_PATH)) {
		DBG(("-->Cannot found proxy\n"));
		goto LError;
	}
	m_hModuleProxyStub= ::LoadLibrary(lpPath);
	DBG(("-->lpPath [%s]\n", lpPath));
#if 0
#ifdef _DEBUG		
	m_hModuleProxyStub = ::LoadLibrary(TEXT("dbgpadsm.dll"));
#else
	m_hModuleProxyStub = ::LoadLibrary(TEXT("imepadsm.dll"));
#endif
#endif
	if(!m_hModuleProxyStub) {
		goto LError;
	}

	LPFN_CREATEOBJECT lpfn;
	lpfn = (LPFN_CREATEOBJECT)::GetProcAddress(m_hModuleProxyStub, "CreateObject");
	if(!lpfn) {
		DBG(("-->GetProcAddress Error \n"));
		goto LError;
	}
	m_lpIImePadServer = (IImePadServer *)(*lpfn)(0);
	return m_lpIImePadServer;

 LError:
	if(lpPath) {
		MemFree(lpPath);
	}
	return NULL;
} 

LRESULT CALLBACK
CImePadSvrSharemem::ClientWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPCImePadSvrSharemem lpCImePadSvr = NULL;
	switch(uMsg) {
#ifdef UNDER_CE
	case WM_CREATE:
		lpCImePadSvr = (LPCImePadSvrSharemem)((LPCREATESTRUCT)lParam)->lpCreateParams;
		WinSetUserPtr(hwnd, (LPVOID)lpCImePadSvr);
		if(lpCImePadSvr) {
			return lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	case WM_DESTROY:
		lpCImePadSvr = (LPCImePadSvrSharemem)WinGetUserPtr(hwnd);
		if(lpCImePadSvr) {
			lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		WinSetUserPtr(hwnd, (LPVOID)NULL);
		break;
#else //!UNDER_CE
	case WM_NCCREATE:
		lpCImePadSvr = (LPCImePadSvrSharemem)((LPCREATESTRUCT)lParam)->lpCreateParams;
		WinSetUserPtr(hwnd, (LPVOID)lpCImePadSvr);
		break;
	case WM_NCDESTROY:
		WinSetUserPtr(hwnd, (LPVOID)NULL);
		break;
#endif //UNDER_CE
	default:
		lpCImePadSvr = (LPCImePadSvrSharemem)WinGetUserPtr(hwnd);
		if(lpCImePadSvr) {
			return lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT
CImePadSvrSharemem::RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg) {
	case WM_CREATE:
		DBG(("CImePadSvrSharemem::WM_CREATE\n"));
		return 1;
	case WM_TIMER:
		return MsgTimer(hwnd, wParam, lParam);
	case WM_USER_UPDATECONTEXT:
		{
			IImeIPoint1 *lpIImeIPoint = NULL;
			if(!m_lpIUnkIImeIPoint) {
				DBG(("--> m_lpIUnkIImeIPoint is NULL\n"));
				return E_FAIL;
			}
			if(IsBadVtbl((IUnkDummy *)m_lpIUnkIImeIPoint)) {
				return E_FAIL;
			}

			HRESULT hr = m_lpIUnkIImeIPoint->QueryInterface(IID_IImeIPoint1,
															(VOID **)&lpIImeIPoint);
			if(hr != S_OK) {
				DBG(("QuertyInterface Failed\n"));
				return E_FAIL;
			}
			if(!lpIImeIPoint) {
				DBG(("lpIImeIPoint is NULL\n"));
				return 0;
			}
			//Check current IImeIPoint is same with lParam's IImeIPoint.
			//990715:Fixed KOTAE #1563. 
			//In 16bit application wParam's HIWORD is always 0x0000 !!!!!
			//So, Use LParam.
			if((IImeIPoint1 *)lParam == lpIImeIPoint) {
				DBG(("Call UpdateContext\n"));
				lpIImeIPoint->UpdateContext(TRUE);
			}
			else {
				DBG(("lpIImeIPoint is different lParam[0x%08x]\n", lParam));
			}
			lpIImeIPoint->Release();
		}
		break;
	default:
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT
CImePadSvrSharemem::MsgTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	HRESULT hr;
	switch(wParam) {
	case TIMERID_NOTIFY_ACTIVATECONTEXT:
		::KillTimer(hwnd, wParam);
		if(!m_lpIImePadServer) {
			return -1;
		}
		m_lpIImePadServer->Notify(IMEPADNOTIFY_ACTIVATECONTEXT,
								  (WPARAM)m_fLastActiveCtx,
								  (LPARAM)0);
		break;
	case TIMERID_NOTIFY_APPLYCANDIDATE:
		::KillTimer(hwnd, wParam);
		if(!m_lpIImePadServer) {
			return -1;
		}
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_APPLYCANDIDATE,
										  m_ntfyDataApplyCand.dwCharID,
										  0,
										  0,
										  0);
		m_ntfyDataApplyCand.dwCharID = 0;
		break;
	case TIMERID_NOTIFY_QUERYCANDIDATE:
		::KillTimer(hwnd, wParam);
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_QUERYCANDIDATE,
										  m_ntfyDataQueryCand.dwCharID,
										  m_ntfyDataQueryCand.dwSelIndex,
										  0,
										  0);
		m_ntfyDataQueryCand.dwCharID   = 0;
		m_ntfyDataQueryCand.dwSelIndex = 0;
		break;
	case TIMERID_NOTIFY_APPLYCANDIDATEEX:
		::KillTimer(hwnd, wParam);
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_APPLYCANDIDATE_EX,
										  m_ntfyDataApplyCandEx.dwCharID,
										  0,
										  m_ntfyDataApplyCandEx.lpwstrCreated1,
										  m_ntfyDataApplyCandEx.lpwstrCreated2);
		if(m_ntfyDataApplyCandEx.lpwstrCreated1) {
			MemFree(m_ntfyDataApplyCandEx.lpwstrCreated1);
		}
		if(m_ntfyDataApplyCandEx.lpwstrCreated2) {
			MemFree(m_ntfyDataApplyCandEx.lpwstrCreated2);
		}
		m_ntfyDataApplyCandEx.lpwstrCreated1 = NULL;
		m_ntfyDataApplyCandEx.lpwstrCreated2 = NULL;

		break;
	default:
		::KillTimer(hwnd, wParam);
		break;
	}
	return 0;
	Unref(hr);
	Unref(hwnd);
	Unref(wParam);
	Unref(lParam);
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrSharemem::CreateIFHWND
// Type		:	HWND
// Purpose	:	Create interface size 0 window.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:01:19 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
HWND
CImePadSvrSharemem::CreateIFHWND(VOID)
{
	DBG(("CImePadSvrSharemem::CreateIFHWND START\n"));
	if(m_hwndIF && ::IsWindow(m_hwndIF)) {
		return m_hwndIF;
	}
	ATOM atom;
	HWND hwnd;

#ifndef UNDER_CE // No Ex
	WNDCLASSEX wc;
#else // UNDER_CE
	WNDCLASS wc;
#endif // UNDER_CE

#ifndef UNDER_CE // No Ex
	wc.cbSize = sizeof(wc);
#endif // UNDER_CE
	wc.style			= 0;
	wc.lpfnWndProc		= (WNDPROC)CImePadSvrSharemem::ClientWndProc;
	wc.cbClsExtra		= 0;
	wc.cbWndExtra		= 0; 
	wc.hInstance		= m_ghModClient;
	wc.hIcon			= (HICON)NULL;
	wc.hCursor			= (HCURSOR)NULL; 
	wc.hbrBackground	= (HBRUSH)NULL;
	wc.lpszMenuName		= NULL;
	wc.lpszClassName	= SZ_IMEPADIFCLASS;
#ifndef UNDER_CE // No Ex
	wc.hIconSm			= NULL;

	atom = ::RegisterClassEx(&wc);
#else // UNDER_CE
	atom = ::RegisterClass(&wc);
#endif // UNDER_CE
	hwnd = ::CreateWindowEx(0,
							SZ_IMEPADIFCLASS,
							NULL,
							WS_POPUP | WS_DISABLED,
							0,0,0,0,
							NULL,
							NULL,
							m_ghModClient,
							(LPVOID)this);
	if(!hwnd) {
		DBG(("CreateWindowEx Error %d\n", GetLastError()));
	}
	m_hwndIF = hwnd;
	DBG(("CImePadSvrSharemem::CreateIFHWND END\n"));
	return hwnd;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrSharemem::DestroyIFHWND
// Type		:	BOOL
// Purpose	:	Destroy interface window.
// Args		:	
//			:	BOOL	fReserved	
// Return	:	
// DATE		:	Mon May 17 23:02:43 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvrSharemem::DestroyIFHWND(BOOL fReserved)
{
	DBG(("CImePadSvrSharemem::DestroyIFHWND() START\n"));
	if(m_hwndIF && ::IsWindow(m_hwndIF)) {
		::DestroyWindow(m_hwndIF);
		m_hwndIF = NULL;
	}
	//Must Unregister class. 
	BOOL fRet = ::UnregisterClass(SZ_IMEPADIFCLASS, m_ghModClient);
	if(!fRet) {
		if(::GetLastError() != ERROR_CLASS_DOES_NOT_EXIST) {
			DBG(("UnregisterClass Unknown error [%d]\n", GetLastError()));
		}
	}
	DBG(("CImePadSvrSharemem::DestroyIFHWND() END\n"));
	return TRUE;
	Unref(fReserved);
}

// Security Fix: strsafe.h
// Add 3rd parameter.
INT
CImePadSvrSharemem::CLSID2Str(REFCLSID refclsid, TCHAR *szBuf, size_t cbBuf)
{
	// Security Fix: strsafe.h
	// Change wsprintf to StringCbPrintf.
	StringCbPrintf(szBuf, cbBuf, TEXT("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), 
			 refclsid.Data1,
			 refclsid.Data2,
			 refclsid.Data3,
			 refclsid.Data4[0],
			 refclsid.Data4[1],
			 refclsid.Data4[2],
			 refclsid.Data4[3],
			 refclsid.Data4[4],
			 refclsid.Data4[5],
			 refclsid.Data4[6],
			 refclsid.Data4[7]);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CLSID2ModuleName
// Type     : INT
// Purpose  : Get module path from CLSID. only gets InprocServer32
//			: Path.
// Args     : 
//          : REFCLSID refclsid 
//			: BOOL fLocalSvr;
//          : TCHAR szPath 
//          : INT cbSize 
// Return   : 
// DATE     : Thu Apr 16 02:48:05 1998
// Author   : 
//////////////////////////////////////////////////////////////////
#define MAX_CLSIDNAME 64
INT
CImePadSvrSharemem::CLSID2ModuleName(REFCLSID refclsid, BOOL fLocalSvr, TCHAR *szPath, INT cbSize)
{
	//DBG(("CImePadSvrSharemem::CLSID2ModuleName START\n"));
	static TCHAR szCLSID[MAX_CLSIDNAME];
	static TCHAR szServerKey[256];

	// Security Fix: strsafe.h
	// Add 3rd parameter.
	CLSID2Str(refclsid, szCLSID, sizeof(szCLSID));
	DBG(("-->szCLSID [%s]\n", szCLSID));

	// Security Fix: strsafe.h
	// Change wsprintf to StringCbPrintf.
	if(fLocalSvr) {
		StringCbPrintf(szServerKey, sizeof(szServerKey), TEXT("CLSID\\%s\\LocalServer32"), szCLSID);
	}
	else {
		StringCbPrintf(szServerKey, sizeof(szServerKey), TEXT("CLSID\\%s\\InprocServer32"), szCLSID);
	}

	DBG(("-->szServerKey[%s]\n", szServerKey));
	INT ret;
	HKEY hKey;
	ret = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
						 szServerKey,
						 0, 
						 KEY_READ, //ALL_ACCESS,
						 &hKey);
	if(ret != ERROR_SUCCESS) {
		DBG(("-->RegOpenKeyEx Failed ret=[0x%08x], GLE [0x%08x]\n", ret, GetLastError()));
		return ret;
	}
	ULONG size = cbSize;
	ret = ::RegQueryValueEx(hKey,
							NULL,
							NULL,
							NULL,
							(LPBYTE)szPath, &size);
	if(ret != ERROR_SUCCESS) {
		DBG(("-->RegQueryValueEx Failed\n", ret));
		::RegCloseKey(hKey);
		return ret;
	}
	::RegCloseKey(hKey);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadcbu.cpp ===
#include <windows.h>
#include <windowsx.h>
#ifdef UNDER_CE // stub for CE
#include "stub_ce.h"
#endif // UNDER_CE
#include "imepadsv.h"
#include "cpadcbu.h"
#include "cpaddbg.h"
#include "ipoint1.h"
#include "iimecb.h"
#include "imepad.h"

#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)

BOOL IsBadVtblUIM(IUnkDummy *lpIUnk)
{
#ifdef _DEBUG
	BOOL fBad = ::IsBadReadPtr(lpIUnk, sizeof(VOID*)) ||
		::IsBadReadPtr(lpIUnk->lpVtbl, sizeof(VOID*)) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->QueryInterface) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->AddRef) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->Release);
	if(fBad) {
		DBG(("--> IsBadVtbl HIT HIT HIT\n"));
	}
	return fBad;
#else
	return ::IsBadReadPtr(lpIUnk, sizeof(VOID*)) ||
		   ::IsBadReadPtr(lpIUnk->lpVtbl, sizeof(VOID*)) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->QueryInterface) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->AddRef) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->Release);
#endif
}

HRESULT __stdcall
CImePadCallbackUIM::QueryInterface(REFIID riid, void**ppv)
{
	if(riid == IID_IUnknown) {
		*ppv = static_cast<IImePadCallback *>(this);
	}
	else if (riid == IID_IImePadCallback) {
		*ppv = static_cast<IImePadCallback *>(this);
	}
	else {
		return (*ppv = 0), E_NOINTERFACE;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

ULONG __stdcall
CImePadCallbackUIM::AddRef(void)
{
	//DBG(("CImePadCallbackUIM::AddRef Always return 2\n"));
	DBG(("CImePadCallbackUIM::AddRef m_cRef[%d] -> [%d]\n", m_cRef, m_cRef+1));
	return ::InterlockedIncrement(&m_cRef);
}

ULONG __stdcall
CImePadCallbackUIM::Release(void)
{
	//Never call delete in it.
	DBG(("CImePadCallbackUIM::Release (Never Delete) m_cRef[%d] -> [%d]\n", m_cRef, m_cRef-1));
	::InterlockedDecrement(&m_cRef);
	return m_cRef;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadCallbackUIM::OnStart
// Type		:	HRESULT __stdcall
// Purpose	:	
// Args		:	
//			:	DWORD	dwParam	
// Return	:	
// DATE		:	Tue Aug 31 16:49:37 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
HRESULT __stdcall
CImePadCallbackUIM::OnStart(DWORD dwParam)
{
	DBG(("OnClose come dwParam[%d]\n", dwParam));
	IUnknown *lpUnk;
	IImeCallback *lp = NULL;
	if(!m_lpCImePadSvrUIM) {
		DBG(("-->m_lpCImePadSvrUIM is NULL ?\n"));
		return -1;
	}

	lpUnk = m_lpCImePadSvrUIM->GetIUnkIImeCallback();
	if(!lpUnk) {
		DBG(("-->IImeCallback does not set\n"));
		return -1;
	}

	if(IsBadVtblUIM((IUnkDummy*)lpUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}

	lpUnk->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
	if(!lp) {
		DBG(("-->QuertyInterface Failed\n"));
	}
	lp->Notify(IMECBNOTIFY_IMEPADOPENED, 0, 0);
	lp->Release();
	return S_OK;
	Unref(dwParam);
}

HRESULT __stdcall CImePadCallbackUIM::OnClose(DWORD dwParam)
{
	DBG(("OnClose come dwParam[%d]\n", dwParam));
	IUnknown *lpUnk;
	IImeCallback *lp = NULL;
	if(!m_lpCImePadSvrUIM) {
		DBG(("-->m_lpCImePadSvrUIM is NULL ?\n"));
		return -1;
	}
	m_lpCImePadSvrUIM->OnIMEPadClose();

	lpUnk = m_lpCImePadSvrUIM->GetIUnkIImeCallback();
	if(!lpUnk) {
		DBG(("-->IImeCallback does not set\n"));
		return -1;
	}

	if(IsBadVtblUIM((IUnkDummy*)lpUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}

	lpUnk->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
	if(!lp) {
		DBG(("-->QuertyInterface Failed\n"));
	}
	lp->Notify(IMECBNOTIFY_IMEPADCLOSED, 0, 0);
	lp->Release();
	return S_OK;
	Unref(dwParam);
}

HRESULT __stdcall
CImePadCallbackUIM::OnPing(DWORD dwParam)
{
	return S_OK;
	Unref(dwParam);
}

typedef struct tagPADCTRL2IPCTRL {
	DWORD dwImePadCtrl;
	DWORD dwIPointCtrl;
}PADCTL2IPCTRL;

static PADCTL2IPCTRL padCtrl2Ip[]= {
	{ IMEPADCTRL_CONVERTALL,           IPCTRL_CONVERTALL,		      },
	{ IMEPADCTRL_DETERMINALL,          IPCTRL_DETERMINALL,		      },
	{ IMEPADCTRL_DETERMINCHAR,         IPCTRL_DETERMINCHAR,		      },
	{ IMEPADCTRL_CLEARALL,             IPCTRL_CLEARALL,			      },
	{ IMEPADCTRL_CARETSET,             IPCTRL_CARETSET,			      },
	{ IMEPADCTRL_CARETLEFT,            IPCTRL_CARETLEFT,			  },
	{ IMEPADCTRL_CARETRIGHT,           IPCTRL_CARETRIGHT,		      },
	{ IMEPADCTRL_CARETTOP,             IPCTRL_CARETTOP,			      },
	{ IMEPADCTRL_CARETBOTTOM,          IPCTRL_CARETBOTTOM,		      },
	{ IMEPADCTRL_CARETBACKSPACE,       IPCTRL_CARETBACKSPACE,	      },
	{ IMEPADCTRL_CARETDELETE,          IPCTRL_CARETDELETE,		      },
	{ IMEPADCTRL_PHRASEDELETE,         IPCTRL_PHRASEDELETE,		      },
	{ IMEPADCTRL_INSERTSPACE,          IPCTRL_INSERTSPACE,		      },
	{ IMEPADCTRL_INSERTFULLSPACE,      IPCTRL_INSERTFULLSPACE,	      },
	{ IMEPADCTRL_INSERTHALFSPACE,      IPCTRL_INSERTHALFSPACE,	      },
	{ IMEPADCTRL_ONIME,                IPCTRL_ONIME,				  },
	{ IMEPADCTRL_OFFIME,               IPCTRL_OFFIME,			      },
	{ IMEPADCTRL_ONPRECONVERSION,      IPCTRL_PRECONVERSION,		  },
	{ IMEPADCTRL_PHONETICCANDIDATE,    IPCTRL_PHONETICCANDIDATE,	  },
};

HRESULT __stdcall
CImePadCallbackUIM::PassData(long nSize, byte *pByte, DWORD *pdwCharID)
{
	DBG(("CImePadCallbackUIM::PassData START\n"));
	LPIMEDATAHEADER lpImeDataHeader = (LPIMEDATAHEADER)pByte;

	HRESULT hr = S_OK;
	IUnknown *lpIUnk = NULL;
	IImeIPoint1 *lpIImeIPoint = NULL;
	DWORD dwCharID = 0;

	if(!m_lpCImePadSvrUIM) {
		DBG(("m_lpCImePadSvrUIM is NULL Error\n"));
		return E_FAIL;
	}
	lpIUnk = m_lpCImePadSvrUIM->GetIUnkIImeIPoint();
	if(!lpIUnk) {
		DBG(("lpIUnk is NULL\n"));
		return E_FAIL;
	}

	if(IsBadVtblUIM((IUnkDummy*)lpIUnk)) {
		return E_FAIL;
	}

	hr = lpIUnk->QueryInterface(IID_IImeIPoint1, (VOID **)&lpIImeIPoint);
	if(hr != S_OK) {
		DBG(("QuertyInterface Failed\n"));
		return E_FAIL;
	}
	if(!lpIImeIPoint) {
		DBG(("QuertyInterface failed\n"));
		return E_FAIL;
	}
	DBG(("m_hwndIF [0x%08x]\n", m_hwndIF));


	switch(lpImeDataHeader->dwDataID) {
	case IMEDATAID_CONTROL:
		{
			LPIMEDATACONTROL lpImeDataCtrl = (LPIMEDATACONTROL)lpImeDataHeader;
			for(int i = 0; i < sizeof(padCtrl2Ip)/sizeof(padCtrl2Ip[0]); i++) {
				if(lpImeDataCtrl->dwControl == padCtrl2Ip[i].dwImePadCtrl) {
					hr = lpIImeIPoint->ControlIME((WORD)padCtrl2Ip[i].dwIPointCtrl,
												   IPCTRLPARAM_DEFAULT);
					//hr = lpIImeIPoint->UpdateContext(TRUE);
					break;
				}
			}
		}
		break;
	case IMEDATAID_STRING:
		{
			DBG(("--> IMEDATAID_STRING\n"));
			LPIMEDATASTRING lpImeDataStr = (LPIMEDATASTRING)lpImeDataHeader;
			switch(lpImeDataHeader->dwCmdID) {
			case IMECMDID_INSERTSTRING:
				{
					DBG(("--> IMECMDID_INSERTSTRING START\n"));
					LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
					INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
					DBGW((L"lpwstr [%s] len[%d]\n", lpwstr, len));
					BOOL fPreConv = lpImeDataStr->fPreConv;
					//990818:ToshiaK for KOTAE #1775.
					dwCharID = lpImeDataStr->dwCharID;
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
												  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
					hr = lpIImeIPoint->InsertStringEx(lpwstr,
													  len,
													  &dwCharID);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					if(pdwCharID) {
						*pdwCharID = dwCharID;
					}
					fPreConv = 0;
					DBG(("--> IMECMDID_INSERTSTRING END\n"));
				}
				break;
			case IMECMDID_CHANGESTRING:
				{
					DBG(("--> IMECMDID_CHANGESTRING\n"));
					LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
					INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
					dwCharID	  = ((LPIMEDATASTRING)lpImeDataHeader)->dwCharID;
					BOOL fPreConv = lpImeDataStr->fPreConv;
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
												  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
					hr = lpIImeIPoint->ReplaceCompString(lpImeDataStr->dwStartPos,
														 lpImeDataStr->dwDeleteLength,
														 lpwstr,
														 len,
														 &dwCharID);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					//hr = lpIImeIPoint->UpdateContext(TRUE);
					if(pdwCharID) {
						*pdwCharID = dwCharID;
					}
					hr = (HRESULT)dwCharID;
				}
				break;
			case IMECMDID_DELETESTRING:
				{
					DBG(("--> IMECMDID_DELETESTRING\n"));
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME, IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					hr = lpIImeIPoint->DeleteCompString((DWORD)lpImeDataStr->dwStartPos,
														(DWORD)lpImeDataStr->dwDeleteLength);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					//hr = lpIImeIPoint->UpdateContext(TRUE);
				}
				break;
			case IMECMDID_INSERTSTRINGINFO:
			case IMECMDID_CHANGESTRINGINFO:
				{
					DBG(("--> IMECMDID_INSERT(Change)STRINGINFO\n"));
					LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
					INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
					dwCharID	  = ((LPIMEDATASTRING)lpImeDataHeader)->dwCharID;
					BOOL fPreConv = lpImeDataStr->fPreConv;
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
												  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
					hr = lpIImeIPoint->ReplaceCompString(lpImeDataStr->dwStartPos,
														 lpImeDataStr->dwDeleteLength,
														 lpwstr,
														 len,
														 &dwCharID);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					if(pdwCharID) {
						*pdwCharID = dwCharID;
					}
					hr = (HRESULT)dwCharID;
				}
				break;
			default:
				break;
				}
		}
		break;
	case IMEDATAID_STRINGCAND:
		{
			DBG(("Data ID is IMEDATAID_STRINGCAND\n"));
			HRESULT hr;
			LPIMEDATASTRINGCAND lpStrCand = (LPIMEDATASTRINGCAND)lpImeDataHeader;
			PIPCANDIDATE lpIpCand;
			INT	textCount, byteCount, i, nSize;
			PBYTE p;
			textCount =  byteCount = 0;
			DBG(("--> dwStringCount %d\n", lpStrCand->dwStringCount));
			for(i = 0; i < (INT)lpStrCand->dwStringCount; i++) {
				DBG(("--> %d offset [%d]\n", i, lpStrCand->dwOffsetString[i]));
				textCount++; 
				LPWSTR lpwstr = (LPWSTR)(((LPBYTE)lpStrCand) +  lpStrCand->dwOffsetString[i]);
				DBGW((L"--> %d %s\n", i, lpwstr));
				byteCount += (lstrlenW(lpwstr)+1) * sizeof(WCHAR);
			}
			if(textCount == 0) {
				return S_OK;
			}
			dwCharID = lpStrCand->dwCharID;
			DWORD dwExInfo = lpStrCand->dwExtraInfoSize;
			nSize = sizeof(IPCANDIDATE) + (textCount-1) * sizeof(DWORD) + byteCount + dwExInfo;
			lpIpCand = (IPCANDIDATE *)MemAlloc(nSize);
			lpIpCand->dwSize		= nSize;
			lpIpCand->dwFlags		= lpStrCand->dwInfoMask;
			lpIpCand->iSelIndex		= lpStrCand->dwSelIndex;
			lpIpCand->nCandidate	= textCount;
			lpIpCand->dwPrivateDataOffset = 0;
			lpIpCand->dwPrivateDataSize	  = 0;
			DBG(("lpIpCand[0x%08x] \n", lpIpCand));
			DBG(("sizeof(IPCANDIDATE) [%d]\n", sizeof(IPCANDIDATE)));
			DBG(("size add [%d]\n", sizeof(DWORD) * (textCount -1)));
			DWORD dwOffset = sizeof(IPCANDIDATE)+sizeof(DWORD)*(textCount-1);
			p = ((PBYTE)lpIpCand) + dwOffset;
			for(i = 0; i < (INT)lpStrCand->dwStringCount; i++) {
				LPWSTR lpwstr = (LPWSTR)(((LPBYTE)lpStrCand) +  lpStrCand->dwOffsetString[i]);
				DWORD dwStrSize = (lstrlenW(lpwstr) + 1) * sizeof(WCHAR);
				CopyMemory((LPWSTR)p, 
						   (WCHAR *)lpwstr,
						   dwStrSize);
				lpIpCand->dwOffset[i] = dwOffset;
				dwOffset += dwStrSize;
				p += dwStrSize;
			}
			if(dwExInfo > 0) {
				lpIpCand->dwPrivateDataSize   = dwExInfo;
#ifdef _WIN64
				lpIpCand->dwPrivateDataOffset = (DWORD)((DWORD_PTR)p - (DWORD_PTR)lpIpCand);
#else
				lpIpCand->dwPrivateDataOffset = (DWORD)p - (DWORD)lpIpCand;
#endif
				CopyMemory(p,
						   (LPBYTE)((LPBYTE)lpStrCand + lpStrCand->dwExtraInfoOffset),
						   lpStrCand->dwExtraInfoSize);
			}
			BOOL fPreConv = lpStrCand->fPreConv;
			hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME, IPCTRLPARAM_DEFAULT);
			hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION,
										  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
			//----------------------------------------------------------------

			//990713: need to set Start position for IPoint.
			//----------------------------------------------------------------
			DWORD dwInsertPos; // = IPINS_CURRENT;	//Default.
			DWORD dwLen;		 
			//990823:Toshiak for KOTAE #1779.
			//000825:Satori #2123
			if(lpStrCand->dwStartPos == IMECMDVALUE_DEFAULT_INSERT_POS) {
				dwInsertPos = IPINS_CURRENT; //Set IPoint's value
			}
			else {
				dwInsertPos = lpStrCand->dwStartPos;
			}

			dwLen	= (DWORD)lpStrCand->dwDeleteLength;
			switch(lpStrCand->header.dwCmdID) {
			case IMECMDID_INSERTSTRINGCANDINFO:
				hr = lpIImeIPoint->InsertImeItem(lpIpCand,
												 dwInsertPos,
												 &dwCharID);
				break;
			case IMECMDID_CHANGESTRINGCANDINFO:
				hr = lpIImeIPoint->ReplaceImeItem(dwInsertPos,
												  dwLen,
												  lpIpCand,
												  &dwCharID);
				break;
			default:
				break;
			}
			hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
			//hr = lpIImeIPoint->UpdateContext(TRUE);
			MemFree(lpIpCand);
			if(pdwCharID) {
				*pdwCharID = dwCharID;
			}
		}
		break;
	default:
		break;
	}
	//990630:ToshiaK for #1327.
	//In WinWord, if call UpdateContext(TRUE) here,
	//Word does NOT repaint composition string.
	//once return the SendMessageTimeout() procedure,
	//and update context asynchronously.
	//in WM_USER_UPDATECONTEXT's lParam, set IImeIPoint interface pointer.
	//and message procedure, check it with current iimeipoint.
	::PostMessage(m_hwndIF, WM_USER_UPDATECONTEXT, (WPARAM)0, (LPARAM)lpIImeIPoint);
	lpIImeIPoint->Release();
	return hr;
	Unref(nSize);
}


HRESULT STDMETHODCALLTYPE 
CImePadCallbackUIM::ReceiveData( 
	/* [in] */ DWORD dwCmdID,
	/* [in] */ DWORD dwDataID,
	/* [out] */ long __RPC_FAR *pSize,
	/* [size_is][size_is][out] */ byte __RPC_FAR *__RPC_FAR *ppByte)
{
	DBG(("CImePadCallbackUIM::ReceiveData START\n"));
	DBG(("-->dwCmdID  [0x%08x]\n", dwCmdID));
	DBG(("-->dwDataID [0x%08x]\n", dwDataID));
	DBG(("-->pSize    [0x%08x]\n", pSize));
	DBG(("-->ppByte   [0x%08x]\n", ppByte));

	HRESULT hr = S_OK;
	IUnknown *lpIUnk = NULL;
	IImeIPoint1 *lpIImeIPoint = NULL;

	DBG(("-->Check m_lpCImePadSvrUIM\n"));
	if(!m_lpCImePadSvrUIM) {
		DBG(("m_lpCImePadSvrUIM is NULL Error\n"));
		return E_FAIL;
	}
	DBG(("-->Check m_fnCoTaskMemAlloc\n"));
	if(!m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc ||
	   !m_lpCImePadSvrUIM->m_fnCoTaskMemFree) {
		DBG(("--> OLE32.DLL does NOT EXIST ? Error\n"));
		return E_FAIL;
	}
	

	lpIUnk = m_lpCImePadSvrUIM->GetIUnkIImeIPoint();
	DBG(("-->Check lpIUnk [0x%08x]\n", lpIUnk));
	if(!lpIUnk) {
		DBG(("lpIUnk is NULL\n"));
		return E_FAIL;
	}

	DBG(("-->Check lpIUnk IsBadVtblUIM[0x%08x]\n", lpIUnk));
	if(IsBadVtblUIM((IUnkDummy*)lpIUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}

	DBG(("-->Call QuertyInterface\n"));
	hr = lpIUnk->QueryInterface(IID_IImeIPoint1, (VOID **)&lpIImeIPoint);
	if(hr != S_OK) {
		DBG(("QuertyInterface Failed\n"));
		return E_FAIL;
	}
	DBG(("--> QueryInterface Success \n"));
	if(!lpIImeIPoint) {
		DBG(("QuertyInterface failed\n"));
		return E_FAIL;
	}

	LPIMEDATACOMPOSITION lpCompoInfo;
	LPIMEDATACOMPOSITION lpCompoTmp;
	LPWSTR lpwstrCompo, lpwstr;
	DWORD  *pdwCharID, *pdw;	
	DWORD  dwSize;
	switch(dwDataID) {
	case IMEDATAID_COMPOSITION:
		switch(dwCmdID) {
		case IMECMDID_GETCOMPOSITIONINFO:
			DBG(("--> IMECMDID_GETCOMPOSITIONINFO\n"));
			dwSize = sizeof(IMEDATACOMPOSITION);
			lpCompoInfo = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpCompoInfo) {
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			hr = lpIImeIPoint->GetAllCompositionInfo(NULL,
													 NULL,
													 (INT *)&lpCompoInfo->dwStringCount,
													 (INT *)&lpCompoInfo->dwCaretPos,
													 (INT *)&lpCompoInfo->dwUndeterminedStartPos,
													 (INT *)&lpCompoInfo->dwUndeterminedLength,
													 (INT *)&lpCompoInfo->dwEditStartPos,
													 (INT *)&lpCompoInfo->dwEditLength);
			lpCompoInfo->header.dwSize  = dwSize;
			lpCompoInfo->header.dwCmdID = dwCmdID;
			lpCompoInfo->header.dwDataID= dwDataID;
			lpCompoInfo->dwOffsetString = 0;
			lpCompoInfo->dwOffsetCharID = 0;
			*pSize = lpCompoInfo->header.dwSize;
			*ppByte = (PBYTE)lpCompoInfo;
			DBG(("--> IMECMDID_GETCOMPOSITIONINFO END\n"));
			break;
		case IMECMDID_GETCOMPOSITIONSTRING:
			DBG(("--> IMECMDID_GETCOMPOSITIONSTRING START\n"));
			lpCompoInfo = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc)(sizeof(IMEDATACOMPOSITION));
			if(!lpCompoInfo) {
				DBG(("-->OutofMemory\n"));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			lpwstrCompo = NULL;
			pdwCharID   = NULL;
			ZeroMemory(lpCompoInfo, sizeof(IMEDATACOMPOSITION));

			hr = lpIImeIPoint->GetAllCompositionInfo(&lpwstrCompo,
													 &pdwCharID,
													 (INT *)&lpCompoInfo->dwStringCount,
													 (INT *)&lpCompoInfo->dwCaretPos,
													 (INT *)&lpCompoInfo->dwUndeterminedStartPos,
													 (INT *)&lpCompoInfo->dwUndeterminedLength,
													 (INT *)&lpCompoInfo->dwEditStartPos,
													 (INT *)&lpCompoInfo->dwEditLength);
			DBG(("-->hr [0x%08x]\n", hr));
			DBGW((L"-->lpwstrCompo[%s]\n", lpwstrCompo));
			dwSize = sizeof(IMEDATACOMPOSITION) +
					 (lpCompoInfo->dwStringCount+1)*sizeof(WCHAR) +
					 (lpCompoInfo->dwStringCount) * sizeof(DWORD);
			DBG(("-->dwSize [%d]\n", dwSize));
			lpCompoTmp = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpCompoTmp) {
				DBG(("-->OutofMemory\n"));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			lpCompoTmp->header.dwSize  = dwSize;
			lpCompoTmp->header.dwCmdID = dwCmdID;
			lpCompoTmp->header.dwDataID= dwDataID;
			lpCompoTmp->dwStringCount           = lpCompoInfo->dwStringCount;
			lpCompoTmp->dwCaretPos              = lpCompoInfo->dwCaretPos;
			lpCompoTmp->dwUndeterminedStartPos  = lpCompoInfo->dwUndeterminedStartPos;
			lpCompoTmp->dwUndeterminedLength    = lpCompoInfo->dwUndeterminedLength;
			lpCompoTmp->dwEditStartPos          = lpCompoInfo->dwEditStartPos;
			lpCompoTmp->dwEditLength            = lpCompoInfo->dwEditLength;
			lpCompoTmp->dwOffsetString = (DWORD)sizeof(IMEDATACOMPOSITION);

			lpwstr = (LPWSTR)((PBYTE)lpCompoTmp + lpCompoTmp->dwOffsetString);
			//990928:toshiaK for KOTAE #2273
			//Need to check lpwstrCompo is NULL or not.
			if(lpwstrCompo && lpCompoTmp->dwStringCount > 0) {
				CopyMemory(lpwstr, 
						   (WCHAR *)lpwstrCompo,
						   lpCompoTmp->dwStringCount * sizeof(WCHAR));
			}
			lpwstr[lpCompoTmp->dwStringCount] = (WCHAR)0x0000;

			lpCompoTmp->dwOffsetCharID = (DWORD)(sizeof(IMEDATACOMPOSITION) +
												 (lpCompoTmp->dwStringCount+1)*sizeof(WCHAR));
			//990928:toshiaK for KOTAE #2273
			//Need to check pdwCharID is NULL or not.
			if(pdwCharID && lpCompoTmp->dwStringCount > 0) {
				pdw = (DWORD *)((PBYTE)lpCompoTmp + lpCompoTmp->dwOffsetCharID);
				CopyMemory(pdw, pdwCharID, sizeof(DWORD)*lpCompoTmp->dwStringCount);
			}

			*pSize = lpCompoTmp->header.dwSize;
			*ppByte = (PBYTE)lpCompoTmp;
			(*m_lpCImePadSvrUIM->m_fnCoTaskMemFree)(lpCompoInfo);

			//990928:toshiaK for KOTAE #2273
			if(lpwstrCompo) {
				(*m_lpCImePadSvrUIM->m_fnCoTaskMemFree)(lpwstrCompo);
			}
			//990928:toshiaK for KOTAE #2273
			if(pdwCharID) {
				(*m_lpCImePadSvrUIM->m_fnCoTaskMemFree)(pdwCharID);
			}
			DBG(("--> IMECMDID_GETCOMPOSITIONSTRING END\n"));
			break;
		default:
			break;
		}
		break;
	case IMEDATAID_CONVSTATUS:
		{
			if(dwCmdID != IMECMDID_GETCONVERSIONSTATUS) {
				DBG((" --> INVALID CMDID\n"));
			}
			DBG(("--> IMECMDID_GETCONVERSIONSTATUS\n"));
			dwSize = sizeof(IMEDATACONVSTATUS);
			LPIMEDATACONVSTATUS lpConvStat;
			lpConvStat = (LPIMEDATACONVSTATUS)(*m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpConvStat) {
				DBG(("E_OUTOFMEMORY dwSize [%d]\n", dwSize));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			LPARAM lConv = 0;
			LPARAM lSent = 0;
			hr = lpIImeIPoint->ControlIME((WORD)IPCTRL_GETCONVERSIONMODE,
										  (LPARAM)&lConv);
			
			hr = lpIImeIPoint->ControlIME((WORD)IPCTRL_GETSENTENCENMODE,
										  (LPARAM)&lSent);
			lpConvStat->header.dwSize  = dwSize;
			lpConvStat->header.dwCmdID = IMECMDID_GETCONVERSIONSTATUS;
			lpConvStat->header.dwDataID= IMEDATAID_CONVSTATUS;
			lpConvStat->dwConversionMode = (DWORD)lConv;
			lpConvStat->dwSentenceMode   = (DWORD)lSent;
			DBG((" --> dwConversionMode[0x%8x]\n", lpConvStat->dwConversionMode));
			DBG((" --> dwSentenceMode  [0x%8x]\n", lpConvStat->dwSentenceMode));
			*pSize  = dwSize;
			*ppByte = (PBYTE)lpConvStat;
		}
		break;
	case IMEDATAID_APPINFO:
		//990816:ToshiaK KOTAE Raid #1757
		if(dwCmdID != IMECMDID_GETAPPLHWND) {
			DBG((" --> INVALID CMDID\n"));
			hr = S_FALSE;
		}
		else {
			IImeCallback *lp = NULL;
			IUnknown *lpUnkCB;
			lpUnkCB = m_lpCImePadSvrUIM->GetIUnkIImeCallback();
			if(!lpUnkCB) {
				DBG(("-->IImeCallback does not set\n"));
				lpIImeIPoint->Release();
				return E_FAIL;
			}
			if(IsBadVtblUIM((IUnkDummy*)lpUnkCB)) {
				DBG(("lpIUnk is BAD Pointer \n"));
				lpIImeIPoint->Release();
				return E_FAIL;
			}
			lpUnkCB->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
			if(!lp) {
				DBG(("-->QuertyInterface Failed\n"));
				lpIImeIPoint->Release();
				return E_FAIL;
			}

			dwSize = sizeof(IMEDATAAPPLINFO);
			LPIMEDATAAPPLINFO lpApplInfo;
			lpApplInfo = (LPIMEDATAAPPLINFO)(*m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpApplInfo) {
				DBG(("E_OUTOFMEMORY dwSize [%d]\n", dwSize));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			lpApplInfo->header.dwSize  = dwSize;
			lpApplInfo->header.dwCmdID = IMECMDID_GETAPPLHWND;
			lpApplInfo->header.dwDataID= IMEDATAID_APPINFO;
			lpApplInfo->hwndApp = NULL;
			lp->GetApplicationHWND(&lpApplInfo->hwndApp);

			if(pSize && ppByte) {
				*pSize  = dwSize;
				*ppByte = (PBYTE)lpApplInfo;
			}
			else {
				(*m_lpCImePadSvrUIM->m_fnCoTaskMemFree)(lpApplInfo);
				hr = E_FAIL;
			}
			lp->Release();
		}
		break;
	default:
		DBG(("UNKOWN DATAID [0x%08x]\n",  dwDataID));
		hr = S_FALSE;
		break;
	}

	lpIImeIPoint->Release();
	DBG(("CImePadCallbackUIM::ReceiveData END hr[0x%08x]\n", hr));
	return hr;
}


//----------------------------------------------------------------

CImePadCallbackUIM::CImePadCallbackUIM(HWND hwndIF, LPCImePadSvrUIM lpCImePadSvrUIM)
{
	DBG(("######## CImePadCallbackUIM::CImePadCallbackUIM constructor START ##########\n"));
	m_hwndIF			= hwndIF;
	m_lpCImePadSvrUIM	= lpCImePadSvrUIM;
	m_cRef				= 0;
	DBG(("######## CImePadCallbackUIM::CImePadCallbackUIM constructor END   ##########\n"));
}

CImePadCallbackUIM::~CImePadCallbackUIM()
{
	DBG(("######## CImePadCallbackUIM::~CImePadCallbackUIM destructor START ##########\n"));
	m_hwndIF			= NULL;
	m_lpCImePadSvrUIM	= NULL;
	DBG(("######## CImePadCallbackUIM::~CImePadCallbackUIM destructor END   ##########\n"));
	m_cRef				= 0;
}

VOID*
CImePadCallbackUIM::operator new( size_t size )
{
	LPVOID lp = (LPVOID)MemAlloc(size);
	return lp;
}

VOID
CImePadCallbackUIM::operator delete( VOID *lp )
{
	if(lp) {
		MemFree(lp);
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadsvu.h ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvr.h
// Purpose  :	Class for Client that uses IMEPad.
//				This is Super(Abstract) class.
//				
// 
// Date     :	Fri Apr 16 14:34:49 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_IMEPAD_SERVER_FOR_UIM_H__
#define __C_IMEPAD_SERVER_FOR_UIM_H__
#include "imepadsv.h"


//----------------------------------------------------------------
//Forward declare
//----------------------------------------------------------------
class CImePadCallbackUIM;
typedef CImePadCallbackUIM *LPCImePadCallbackUIM;
class CImePadSvrUIM;
typedef CImePadSvrUIM*	LPCImePadSvrUIM;

//----------------------------------------------------------------
//OLE API func's pointer declare
//----------------------------------------------------------------
typedef HRESULT (WINAPI* FN_COINITIALIZE)(LPVOID pvReserved);
typedef HRESULT (WINAPI* FN_COCREATEINSTANCE)(REFCLSID rclsid,
											  LPUNKNOWN pUnkOuter,
											  DWORD dwClsContext,
											  REFIID riid,
											  LPVOID FAR* ppv);
typedef void    (WINAPI* FN_COUNINITIALIZE)(void);
typedef HRESULT (WINAPI* FN_CODISCONNECTOBJECT)(LPUNKNOWN pUnk, DWORD dwReserved);
typedef LPVOID  (WINAPI* FN_COTASKMEMALLOC)(ULONG cb);
typedef LPVOID  (WINAPI* FN_COTASKMEMREALLOC)(LPVOID pv, ULONG cb);
typedef VOID    (WINAPI* FN_COTASKMEMFREE)(LPVOID pv);

class CImePadSvrUIM
{
public:
	//----------------------------------------------------------------
	//Static method declare
	//----------------------------------------------------------------
	static HRESULT		CreateInstance(HINSTANCE		hInst,
									   LPCImePadSvrUIM	*pp,
									   LPARAM			lReserved1,
									   LPARAM			lReserved2);
	static HRESULT		DeleteInstance(LPCImePadSvrUIM	lpCImePadSvrUIM,
									   LPARAM			lReserved);
public:
	friend class CImePadCallbackUIM;
	//VOID* operator new( size_t size );
	//VOID  operator delete( VOID *lp );
public:
	CImePadSvrUIM(HINSTANCE hInst);
	virtual ~CImePadSvrUIM();
	virtual BOOL		IsAvailable			(VOID)=0;
	virtual BOOL		OnIMEPadClose		(VOID)=0;
	//----------------------------------------------------------------
	//IImePadSvr interface
	//----------------------------------------------------------------
	virtual INT			Initialize			(LANGID		imeLangID,
											 DWORD		dwImeInputID,
											 LPVOID		lpVoid)=0;
	virtual	INT			Terminate			(LPVOID lpVoid)=0;
	virtual INT			ForceDisConnect		(VOID)=0;
	virtual	INT			ShowUI				(BOOL fShow)=0;
	virtual	INT			IsVisible			(BOOL *pfVisible)=0;
	virtual	INT			ActivateApplet		(UINT   activateID,
											 LPARAM	dwActParam,
											 LPWSTR lpwstr1,
											 LPWSTR lpwstr2)=0; 
	virtual	INT			Notify				(INT	id,
											 WPARAM wParam,
											 LPARAM lParam)=0;
	virtual INT			GetAppletConfigList(DWORD	dwMask,
											INT*	pCountApplet,
											IMEPADAPPLETCONFIG **ppCfgList)=0;
	//----------------------------------------------------------------
	//Set/Get IImeIPoint, IImeCallback interface
	//----------------------------------------------------------------
	virtual IUnknown*	SetIUnkIImeIPoint	(IUnknown *pIUnk)=0;
	virtual IUnknown*	SetIUnkIImeCallback	(IUnknown *pIUnk)=0;
	virtual IUnknown*	GetIUnkIImeIPoint	(VOID)=0;
	virtual IUnknown*	GetIUnkIImeCallback	(VOID)=0;
protected:
	HMODULE	m_hModClient;
	INT		InitOleAPI(VOID);
	INT		TermOleAPI(VOID);
	BOOL					m_fCoInitSuccess;		//Flag for CoInitialize() successed or not. 
	BOOL					m_fOLELoaded;			//OLE32.DLL is loaded by Application or explicitly loaded.
	HMODULE					m_hModOLE;				//OLE32.DLL module handle.
	FN_COINITIALIZE			m_fnCoInitialize;		//CoInitialize()		function pointer.
	FN_COCREATEINSTANCE		m_fnCoCreateInstance;	//CoCreateInstance()	function pointer.
	FN_COUNINITIALIZE		m_fnCoUninitialize;		//CoUninitialize()		function pointer.
	FN_CODISCONNECTOBJECT	m_fnCoDisconnectObject;	//CoDisconnectObject()	function pointer.
	FN_COTASKMEMALLOC		m_fnCoTaskMemAlloc;		//CoTaskMemAlloc()		function pointer.
	FN_COTASKMEMREALLOC		m_fnCoTaskMemRealloc;	//CoTaskMemRealloc()	function pointer.
	FN_COTASKMEMFREE		m_fnCoTaskMemFree;		//CoTaskMemFree()		function pointer.
};
#endif //__C_IMEPAD_SERVER_FOR_UIM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadcbu.h ===
#ifndef __C_IME_PAD_CALLBACK_FOR_UIM_H__
#define __C_IME_PAD_CALLBACK_FOR_UIM_H__
#include "cpadsvu.h"

//----------------------------------------------------------------
//990630:ToshiaK for #1327
//----------------------------------------------------------------
#define WM_USER_UPDATECONTEXT	(WM_USER+400)

class CImePadCallbackUIM;
typedef CImePadCallbackUIM *LPCImePadCallbackUIM;

class CImePadCallbackUIM :public IImePadCallback
{
public:
	HRESULT __stdcall QueryInterface(REFIID riid, void**ppv);
	ULONG   __stdcall AddRef	(void);
	ULONG   __stdcall Release	(void);
	virtual HRESULT STDMETHODCALLTYPE OnStart( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE OnClose( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE OnPing( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE PassData( 
		/* [in] */ long nSize,
		/* [size_is][in] */ byte __RPC_FAR *pByte,
		/* [out][in] */ DWORD __RPC_FAR *pdwCharID);
	virtual HRESULT STDMETHODCALLTYPE ReceiveData( 
		/* [in] */ DWORD dwCmdID,
		/* [in] */ DWORD dwDataID,
		/* [out] */ long __RPC_FAR *pSize,
		/* [size_is][size_is][out] */ byte __RPC_FAR *__RPC_FAR *ppByte);
public:
	CImePadCallbackUIM(HWND hwndIF, LPCImePadSvrUIM lpCImePadSvrUIM);
	~CImePadCallbackUIM();
	VOID* operator new( size_t size );
	VOID  operator delete( VOID *lp );
private:
	LPCImePadSvrUIM	m_lpCImePadSvrUIM;
	DWORD			m_dwReg;
	HWND			m_hwndIF;
	LONG			m_cRef;			
};

#ifndef		__DEFINE_IMEPAD_IUNKNOWN_DUMMY__
#define		__DEFINE_IMEPAD_IUNKNOWN_DUMMY__
#pragma pack(8)
typedef struct IUnkDummyVtbl
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
		IUnknown __RPC_FAR * This,
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
		IUnknown __RPC_FAR * This);
	
	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
		IUnknown __RPC_FAR * This);
}IUnkDummyVtbl;

interface IUnkDummy
{
       CONST_VTBL struct IUnkDummyVtbl __RPC_FAR *lpVtbl;
};
#pragma pack()
#endif //__DEFINE_IMEPAD_IUNKNOWN_DUMMY__

extern BOOL IsBadVtblUIM(IUnkDummy *lpIUnk);




#endif //__C_IME_PAD_CALLBACK_FOR_UIM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpaddbg.h ===
//////////////////////////////////////////////////////////////////
// File     : cpaddbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef __C_PAD_DBG_H_
#define __C_PAD_DBG_H_

#ifdef __cplusplus
#   define InlineFunc  inline
#else 
#   define InlineFunc  __inline
#endif

//----------------------------------------------------------------
// Callback function prototype
//----------------------------------------------------------------
typedef VOID (WINAPI *LPFNDBGCALLBACKA)(LPSTR  lpstr);
typedef VOID (WINAPI *LPFNDBGCALLBACKW)(LPWSTR lpwstr);

//-------------------------------------------------------
//MACRO function  prototype declare.
//It is valid only if compliled with _DEBUG definition.
//-------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function : DBGSetCallback
// Type     : VOID
// Purpose  : Set debug callback function.
//            callback function has set, when DBG() has called,
//            call this callback function with formatted message string.
// Args     : 
//          : LPFNDBGCALLBACKA lpfnDbgCallbackA 
//          : LPFNDBGCALLBACKW lpfnDbgCallbackW 
// Return   : VOID
// DATE     : Tue Jan 06 12:21:05 1998
//////////////////////////////////////////////////////////////////
//VOID DBGSetCallback(LPFNDBGCALLBACKA lpfnDbgCallbackA, LPFNDBGCALLBACKW lpfnDbgCallbackW);

//////////////////////////////////////////////////////////////////
// Function : DBGEnableOutput
// Type     : VOID
// Purpose  : On off OutputDebugString to COM.
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:33:21 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//VOID DBGEnableOutput(BOOL fEnable)

//////////////////////////////////////////////////////////////////
// Function : DBGIsOutputEnable
// Type     : BOOL
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 17:58:28 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//BOOL DBGIsOutputEnable(VOID)


////////////////////////////////////////////////////////
// Function : DBG
// Type     : VOID
// Purpose  : Printing ANSI debug message with same usage as printf()
// Args     : 
//          : LPSTR lpstrFuncName 
//          : ...   
// Example  : DBGW(("Error occured data[%d]", i));
// CAUTION  : Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//         : ...    
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example  : DBGW(("Error occured data[%d]", i));
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

//////////////////////////////////////////////////////////////////
// Function : DBGMsgBox
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example  : DBGMsgBox(("Error occured data[%d]", i));
//////////////////////////////////////////////////////////////////
//VOID DBGMsgBox((LPSTR lpstrFmt, ...))

//////////////////////////////////////////////////////////////////
// Function : DBGAssert
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fError
// Return   : 
// DATE     : Fri Jan 09 17:17:31 1998
//////////////////////////////////////////////////////////////////
//VOID DBGAssert(BOOL fError)


//////////////////////////////////////////////////////////////////
// Function : DBGSTR
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr
//////////////////////////////////////////////////////////////////
//VOID DBGSTR(LPSTR lpstr);


//////////////////////////////////////////////////////////////////
// Function : DBGGetErrorString
// Type     : VOID
// Purpose  : Get error message from WIN32 Error code.
// Args     : 
//          : INT errorCode 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetErrorString(INT errorCode)


//////////////////////////////////////////////////////////////////
// Function : DBGGetWinClass
// Type     : LPSTR
// Purpose  : Get class name string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinClass(HWND hwnd)

//////////////////////////////////////////////////////////////////
// Function : DBGGetWinText
// Type     : LPSTR
// Purpose  : Get title text string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinText(HWND hwnd)



#ifdef _DEBUG
//----------------------------------------------------------------
//Function prototype declare
//----------------------------------------------------------------
extern VOID   _padDbgEnableOutput   (BOOL fEnable);
extern BOOL   _padDbgIsOutputEnable (VOID);
extern VOID   _padDbgSetCallback        (LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW);
extern VOID   _padDbgA              (LPSTR  lpstrFile, INT lineNo, LPSTR  lpstrMsg);
extern VOID   _padDbgW              (LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _padDbgMsgBoxA            (LPSTR  lpstrFile,  INT lineNo, LPSTR lpstrMsg);
extern VOID   _padDbgAssert         (LPSTR  lpstrFile,  INT lineNo, BOOL fError, LPSTR lpstrMsg);
extern VOID   _padDbgPrintfA            (LPSTR  lpstrFmt, ...);
extern VOID   _padDbgPrintfW            (LPWSTR lpstrFmt, ...);
extern VOID   _padDbgOutStrA            (LPSTR  lpstr);
extern VOID   _padDbgOutStrW            (LPWSTR lpwstr);
extern LPSTR  _padDbgVaStrA         (LPSTR  lpstrFmt, ...);
extern LPWSTR _padDbgVaStrW         (LPWSTR lpstrFmt, ...);
extern LPWSTR _padDbgMulti2Wide     (LPSTR  lpstr);
extern LPSTR  _padDbgGetWinClass        (HWND   hwnd);
extern LPSTR  _padDbgGetWinText     (HWND   hwnd);
extern LPSTR  _padDbgGetErrorString (INT    errorCode);
extern LPSTR  _padDbgGetVkStr       (INT    virtKey);
extern INT    _padDbgShowError      (HRESULT hr, LPSTR lpstrFunc);
//----------------------------------------------------------------
// Macro definition
//----------------------------------------------------------------
#   define DBGSetCallback(a,b)  _padDbgSetCallback(a, b)
#   define DBGEnableOutput(a)   _padDbgEnableOutput(a)
#   define DBGIsOutputEnable()  _padDbgIsOutputEnable()
#   undef DBG
#   define DBG(a)               _padDbgA(__FILE__, __LINE__, _padDbgVaStrA a)
#   define DBGA(a)              _padDbgA(__FILE__, __LINE__, _padDbgVaStrA a)
#   define DBGW(a)              _padDbgW( _padDbgMulti2Wide(__FILE__), __LINE__, _padDbgVaStrW a)
#   define DBGMsgBox(a)         _padDbgMsgBoxA(__FILE__, __LINE__, _padDbgVaStrA a)
#   define DBGAssert(a)         _padDbgAssert(__FILE__, __LINE__, a, #a)
#   define DBGAssertSz(a,b)     _padDbgAssert(__FILE__, __LINE__, a, b)
#   define DBGOutStr(a)         _padDbgOutStrA(a)
#   define DBGOutStrA(a)        _padDbgOutStrA(a)
#   define DBGOutStrW(a)        _padDbgOutStrW(a)
#   define DBGP(a)              _padDbgOutStrA(_padDbgVaStrA a)
#   define DBGPA(a)             _padDbgOutStrA(_padDbgVaStrA a)
#   define DBGPW(a)             _padDbgOutStrW(_padDbgVaStrW a)
#   define DBGGetErrorString(a) _padDbgGetErrorString(a)
#   define DBGGetWinClass(a)    _padDbgGetWinClass(a)
#   define DBGGetWinText(a)     _padDbgGetWinText(a)
#   define DBGShowError(a,b)    _padDbgShowError(a,b)
#else //!_DEBUG //in Release version, these will disapear...
#   define DBGSetCallback(a,b)
#   define DBGEnableOutput(a)
#   define DBGIsOutputEnable()
#   undef DBG
#   define DBG(a)
#   define DBGW(a)
#   define DBGA(a)
#   define DBGP(a)
#   define DBGPA(a)
#   define DBGPW(a)
#   define DBGAssert(a)
#   define DBGAssertSz(a,b)
#   define DBGMsgBox(a)
#   define DBGOutStr(a)
#   define DBGOutStrA(a)
#   define DBGOutStrW(a)
#   define DBGGetErrorString(a)
#   define DBGGetWinClass(a)
#   define DBGGetWinText(a)
#   define DBGShowError(a,b)
#endif //_DEBUG


//----------------------------------------------------------------
//These function use variable argument, so we cannot define 
//"Normal" MACRO for them.
//so, Use inline function that do nothing if _DEBUG is NOT set.
//----------------------------------------------------------------
InlineFunc VOID DBGDoNothingA(LPSTR  lpstrFmt, ...) {lpstrFmt;}
InlineFunc VOID DBGDoNothingW(LPWSTR lpstrFmt, ...) {lpstrFmt;}
#ifdef _DEBUG 
#define DBGPrintf       _padDbgPrintfA
#define DBGPrintfA      _padDbgPrintfA
#define DBGPrintfW      _padDbgPrintfW
#else 
#define DBGPrintf       DBGDoNothingA
#define DBGPrintfA      DBGDoNothingA
#define DBGPrintfW      DBGDoNothingW
#endif


//----------------------------------------------------------------
//This is helper inline function for outputs debug string in 
//Retail version. if FORCE_DEBUG is defined this function works.
//Some time, we met bugs than occurs only retail version, 
//and would like to out debug message. 
//----------------------------------------------------------------
#ifdef FORCE_DEBUG
#include <stdarg.h>
//////////////////////////////////////////////////////////////////
// Function : FDbg
// Type     : InlineFunc VOID
// Purpose  : 
// Args     : 
//          : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Tue Jan 06 19:06:19 1998
//////////////////////////////////////////////////////////////////
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...)
{
    CHAR szBuf[512];
    va_list ap;
    va_start(ap, lpstrFmt);
    wvsprintfA(szBuf, lpstrFmt, ap);
    va_end(ap);
    OutputDebugStringA(szBuf);  
    return;
}
#else //FORCE_DEBUG
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...) {lpstrFmt;}
#endif

#endif //_C_PAD_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpaddbg.cpp ===
//////////////////////////////////////////////////////////////////
// File     : cpaddbg.cpp
// Purpose  :
// 
// 
// Date     : Fri Feb 19 22:03:56 1999
// Author   : 
//
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdarg.h>
#include "cpaddbg.h"
#include <stdio.h>

static IsWinNT()
{
	static OSVERSIONINFO os;
	if(os.dwOSVersionInfoSize == 0) { 
		os.dwOSVersionInfoSize = sizeof(os);
		::GetVersionEx(&os);
	}
	return (os.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

//----------------------------------------------------------------
//internal function prototype declare
//----------------------------------------------------------------
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath);
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath);
VOID   _padDbgPrintfA			(LPSTR  lpstrFmt, ...);
VOID   _padDbgPrintfW			(LPWSTR lpstrFmt, ...);

#define SZPREFIX	"IME:cpad:"
#define WSZPREFIX	L"IME:cpad:"
//----------------------------------------------------------------
// Global Data
//----------------------------------------------------------------
static LPFNDBGCALLBACKA g_lpfnDbgCBA=NULL;
static LPFNDBGCALLBACKW g_lpfnDbgCBW=NULL;
//static BOOL g_fEnable=FALSE;
static BOOL g_fEnable=TRUE;
inline VOID ODStrW(LPWSTR lpwstr)
{
	if(g_fEnable) OutputDebugStringW(lpwstr);
}
inline VOID ODStrA(LPSTR lpstr)
{
	if(g_fEnable) OutputDebugStringA(lpstr);
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgSetCallback
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPFNDBGCALLBACK lpfnDbgCallback 
// Return   : 
// DATE     : Tue Jan 06 12:42:36 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgSetCallback(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW)
{
	g_lpfnDbgCBA = lpfnCBA;
	g_lpfnDbgCBW = lpfnCBW;
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgSwitchOutput
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:35:55 1998
// Author   : 
//////////////////////////////////////////////////////////////////
VOID _padDbgEnableOutput(BOOL fEnable)
{
	g_fEnable = fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgIsOutputEnable
// Type     : VOID
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 18:00:52 1998
// Author   : 
//////////////////////////////////////////////////////////////////
BOOL _padDbgIsOutputEnable(VOID)
{
	return g_fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgOutStrA
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Tue Jan 06 12:29:39 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgOutStrA(LPSTR lpstr)
{
	static BOOL fIn;
	ODStrA(lpstr);
#ifdef _CONSOLE
	printf(lpstr);
#endif

	if(g_lpfnDbgCBA) {
		if(fIn) { return; }
		fIn = TRUE;
		(*g_lpfnDbgCBA)(lpstr);
		fIn = FALSE;
	}
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgOutStrW
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpwstr 
// Return   : 
// DATE     : Tue Jan 06 12:30:07 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgOutStrW(LPWSTR lpwstr)
{
	static BOOL fIn;
	if(IsWinNT()) {
		ODStrW(lpwstr);
	}
	else {
		static CHAR szBuf[1024];
		::WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0);
		ODStrA(szBuf);
	}

#ifdef _CONSOLE
	static CHAR szBuf[1024];
	::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
	printf(szBuf);
#endif
	if(g_lpfnDbgCBW) { 
		if(fIn) { return; } 		
		fIn = TRUE;
		(*g_lpfnDbgCBW)(lpwstr);
		fIn = FALSE;
	}
	return;
}

////////////////////////////////////////////////////////
// Function: _padDbgA
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _padDbgA(LPSTR		lpstrFile, 
			 INT		lineNo, 
			 LPSTR		lpstrMsg)
{
	_padDbgPrintfA("%s(%12s:%4d) %s", 
				  SZPREFIX,
				  GetFileTitleStrA(lpstrFile),
				  lineNo,
				  lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFile 
//          : INT lineNo 
//          : LPWSTR lpstrMsg 
// Return   : 
// DATE     : Mon Jan 05 15:10:41 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg)
{
	_padDbgPrintfW(L"%s(%10s:%4d) %s", 
				  WSZPREFIX,
				  GetFileTitleStrW(lpstrFile),
				  lineNo,
				  lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgVaStrA
// Type     : LPSTR
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:09:53 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(chBuf, lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function : _padDbgVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _padDbgVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap);	//Use C-RunTime Library for Win95
	va_end(ap);
	return wchBuf;
}


////////////////////////////////////////////////////////
// Function: _padDbgPrintfA
// Type    : VOID
// Purpose : variable args version of OutputDebugStringA
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _padDbgPrintfA(LPSTR lpstrFmt, ...)
{
	static CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	_padDbgOutStrA(szBuf);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgPrintfW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:11:24 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgPrintfW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap); //Use C-RunTime Library for Win95
	va_end(ap);
	_padDbgOutStrW(wchBuf);
	return;
}


//////////////////////////////////////////////////////////////////
// Function : _padDbgMulti2Wide
// Type     : LPWSTR
// Purpose  : return Unicode string from MBCS string
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Mon Jan 05 15:10:48 1998
//////////////////////////////////////////////////////////////////
LPWSTR _padDbgMulti2Wide(LPSTR lpstr)
{
	static WCHAR wchBuf[512];
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}


//////////////////////////////////////////////////////////////////
// Function : _padDbgGetWinClass
// Type     : LPSTR
// Purpose  : Get Windows class name string
//			  ANSI version only.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:08:43 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetWinClass(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetClassNameA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;

}

//////////////////////////////////////////////////////////////////
// Function : _padDbgGetWinText
// Type     : LPSTR
// Purpose  : Get Windows text(title) string
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:09:08 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetWinText(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetWindowTextA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgMsgBoxA
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Thu Jan 08 12:31:03 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgMsgBoxA(LPSTR lpstrFile,  INT lineNo, LPSTR lpstrMsg)
{
#ifdef _CONSOLE
	return;
#endif
	char szTmp[512];
	wsprintfA(szTmp, "Debug Message Box (File: %s, Line: %4d)", 
			  GetFileTitleStrA(lpstrFile), 
			  lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
}

VOID _padDbgAssert(LPSTR  lpstrFile,  INT lineNo, BOOL fOk, LPSTR lpstrMsg)
{
	if(fOk) {
		return; 
	}
	char szTmp[512];
	wsprintfA(szTmp, "ASSERT (File: %s, Line: %4d)", 
			  GetFileTitleStrA(lpstrFile), 
			  lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
	DebugBreak();
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgGetErrorString
// Type     : LPSTR
// Purpose  : Convert Error(Got from GetLastError()) value to ERROR Message String
// Args     : 
//          : INT errorCode 
// Return   : 
// DATE     : Mon Jan 05 16:43:34 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetErrorString(INT errorCode)
{
	static CHAR szBuf[512];
	INT count;
	szBuf[0] = (CHAR)0x00;
	count = wsprintfA(szBuf, "[0x%08x]:", errorCode);
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   errorCode, 
				   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				   szBuf+count,
				   sizeof(szBuf)-1-count,
				   NULL );
	if(*(szBuf + count) != (CHAR)0x00) {
		int nLen = lstrlenA(szBuf);
		if((nLen - count) > 1) {
			szBuf[nLen - 1] = (CHAR)0x00;
		}
	}
	return szBuf;
}


//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrA
// Type     : static LPSTR
// Purpose  : Return File name string(remove folder)
// Args     : 
//          : LPSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:34:22 1998
//////////////////////////////////////////////////////////////////
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath)
{
	static CHAR szBuf[2];
	CHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenA(lpstrFilePath) - 1);
	for(pTemp = CharPrevA(lpstrFilePath, pLast); 
		(pTemp  != lpstrFilePath) && 
		(*pTemp != '\\')	 &&
		(*pTemp != (CHAR)0x00); 
		pTemp = CharPrevA(lpstrFilePath, pTemp)) {
		;
	}
	if(*pTemp == '\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}

//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrW
// Type     : static LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:38:19 1998
//////////////////////////////////////////////////////////////////
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath)
{
	static WCHAR szBuf[2];
	WCHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenW(lpstrFilePath) - 1);
	for(pTemp = pLast-1;
		(pTemp != lpstrFilePath) &&
		(*pTemp != L'\\')		 &&
		(*pTemp != (WCHAR)0x0000);
		pTemp--) {
		;
	}

	if(*pTemp == L'\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}


#define DEFID(a)	{a, #a}
typedef struct idStr {
	INT code;
	LPSTR lpstr;
}IDSTR; 

IDSTR rpcError[]={
	DEFID(RPC_S_INVALID_STRING_BINDING),
	DEFID(RPC_S_WRONG_KIND_OF_BINDING),
	DEFID(RPC_S_INVALID_BINDING),
	DEFID(RPC_S_PROTSEQ_NOT_SUPPORTED),
	DEFID(RPC_S_INVALID_RPC_PROTSEQ),
	DEFID(RPC_S_INVALID_STRING_UUID),
	DEFID(RPC_S_INVALID_ENDPOINT_FORMAT),
	DEFID(RPC_S_INVALID_NET_ADDR),
	DEFID(RPC_S_NO_ENDPOINT_FOUND),
	DEFID(RPC_S_INVALID_TIMEOUT),
	DEFID(RPC_S_OBJECT_NOT_FOUND),
	DEFID(RPC_S_ALREADY_REGISTERED),
	DEFID(RPC_S_TYPE_ALREADY_REGISTERED),
	DEFID(RPC_S_ALREADY_LISTENING),
	DEFID(RPC_S_NO_PROTSEQS_REGISTERED),
	DEFID(RPC_S_NOT_LISTENING),
	DEFID(RPC_S_UNKNOWN_MGR_TYPE),
	DEFID(RPC_S_UNKNOWN_IF),
	DEFID(RPC_S_NO_BINDINGS),
	DEFID(RPC_S_NO_PROTSEQS),
	DEFID(RPC_S_CANT_CREATE_ENDPOINT),
	DEFID(RPC_S_OUT_OF_RESOURCES),
	DEFID(RPC_S_SERVER_UNAVAILABLE),
	DEFID(RPC_S_SERVER_TOO_BUSY),
	DEFID(RPC_S_INVALID_NETWORK_OPTIONS),
	DEFID(RPC_S_NO_CALL_ACTIVE),
	DEFID(RPC_S_CALL_FAILED),
	DEFID(RPC_S_CALL_FAILED_DNE),
	DEFID(RPC_S_PROTOCOL_ERROR),
	DEFID(RPC_S_UNSUPPORTED_TRANS_SYN),
	DEFID(RPC_S_UNSUPPORTED_TYPE),
	DEFID(RPC_S_INVALID_TAG),
	DEFID(RPC_S_INVALID_BOUND),
	DEFID(RPC_S_NO_ENTRY_NAME),
	DEFID(RPC_S_INVALID_NAME_SYNTAX),
	DEFID(RPC_S_UNSUPPORTED_NAME_SYNTAX),
	DEFID(RPC_S_UUID_NO_ADDRESS),
	DEFID(RPC_S_DUPLICATE_ENDPOINT),
	DEFID(RPC_S_UNKNOWN_AUTHN_TYPE),
	DEFID(RPC_S_MAX_CALLS_TOO_SMALL),
	DEFID(RPC_S_STRING_TOO_LONG),
	DEFID(RPC_S_PROTSEQ_NOT_FOUND),
	DEFID(RPC_S_PROCNUM_OUT_OF_RANGE),
	DEFID(RPC_S_BINDING_HAS_NO_AUTH),
	DEFID(RPC_S_UNKNOWN_AUTHN_SERVICE),
	DEFID(RPC_S_UNKNOWN_AUTHN_LEVEL),
	DEFID(RPC_S_INVALID_AUTH_IDENTITY),
	DEFID(RPC_S_UNKNOWN_AUTHZ_SERVICE),
	DEFID(EPT_S_INVALID_ENTRY),
	DEFID(EPT_S_CANT_PERFORM_OP),
	DEFID(EPT_S_NOT_REGISTERED),
	DEFID(RPC_S_NOTHING_TO_EXPORT),
	DEFID(RPC_S_INCOMPLETE_NAME),
	DEFID(RPC_S_INVALID_VERS_OPTION),
	DEFID(RPC_S_NO_MORE_MEMBERS),
	DEFID(RPC_S_NOT_ALL_OBJS_UNEXPORTED),
	DEFID(RPC_S_INTERFACE_NOT_FOUND),
	DEFID(RPC_S_ENTRY_ALREADY_EXISTS),
	DEFID(RPC_S_ENTRY_NOT_FOUND),
	DEFID(RPC_S_NAME_SERVICE_UNAVAILABLE),
	DEFID(RPC_S_INVALID_NAF_ID),
	DEFID(RPC_S_CANNOT_SUPPORT),
	DEFID(RPC_S_NO_CONTEXT_AVAILABLE),
	DEFID(RPC_S_INTERNAL_ERROR),
	DEFID(RPC_S_ZERO_DIVIDE),
	DEFID(RPC_S_ADDRESS_ERROR),
	DEFID(RPC_S_FP_DIV_ZERO),
	DEFID(RPC_S_FP_UNDERFLOW),
	DEFID(RPC_S_FP_OVERFLOW),
	DEFID(RPC_X_NO_MORE_ENTRIES),
	DEFID(RPC_X_SS_CHAR_TRANS_OPEN_FAIL),
	DEFID(RPC_X_SS_CHAR_TRANS_SHORT_FILE),
	DEFID(RPC_X_SS_IN_NULL_CONTEXT),
	DEFID(RPC_X_SS_CONTEXT_DAMAGED),
	DEFID(RPC_X_SS_HANDLES_MISMATCH),
	DEFID(RPC_X_SS_CANNOT_GET_CALL_HANDLE),
	DEFID(RPC_X_NULL_REF_POINTER),
	DEFID(RPC_X_ENUM_VALUE_OUT_OF_RANGE),
	DEFID(RPC_X_BYTE_COUNT_TOO_SMALL),
	DEFID(RPC_X_BAD_STUB_DATA),
	DEFID(ERROR_INVALID_USER_BUFFER),
	DEFID(ERROR_UNRECOGNIZED_MEDIA),
	DEFID(ERROR_NO_TRUST_LSA_SECRET),
	DEFID(ERROR_NO_TRUST_SAM_ACCOUNT),
	DEFID(ERROR_TRUSTED_DOMAIN_FAILURE),
	DEFID(ERROR_TRUSTED_RELATIONSHIP_FAILURE),
	DEFID(ERROR_TRUST_FAILURE),
	DEFID(RPC_S_CALL_IN_PROGRESS),
};

LPSTR _padDbgGetRPCError(INT code)
{
	INT i;
	for(i = 0; i < sizeof(rpcError)/sizeof(rpcError[0]); i++) {
		if(rpcError[i].code == code) {
			return rpcError[i].lpstr;
		}
	}
	static char szBuf[]="";
	return szBuf;
}

INT _padDbgShowError(HRESULT hr, LPSTR lpstrFunc)
{
	char szBuf[256];
	char szMsg[1024];
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   hr,
				   0,
				   szBuf,
				   256,
				   NULL);
	szBuf[lstrlenA(szBuf)-1] = (char)0x00;
	wsprintfA(szMsg, "!!%s: hr[0x%08x] code[%d][%x][%s][%s]",
			  lpstrFunc ? lpstrFunc : "UnknownFunc",
			  hr,
			  HRESULT_CODE(hr),
			  HRESULT_CODE(hr),
			  _padDbgGetErrorString(HRESULT_CODE(hr)), 
			  szBuf);
	DBG(("%s\n", szMsg));
	return 0;
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadsvu.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvr.cpp
// Purpose  :	Client source code for IMEPad executable.
// 
// 
// Date     :	Fri Apr 16 15:39:33 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#include <windows.h>
#include "cpadsvu.h"
#include "cpaddbg.h"
#include "cpadsvus.h"	//Use Shared Memory for IPC. 

//----------------------------------------------------------------
//misc definition
//----------------------------------------------------------------
#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)

//----------------------------------------------------------------
//OLE function is dynamically loaded/called
//----------------------------------------------------------------
#define SZMOD_OLE32DLL			TEXT("OLE32.DLL")
#ifdef UNDER_CE // For GetModuleHandleW
#define WSZMOD_OLE32DLL			L"OLE32.DLL"
#endif // UNDER_CE
#define SZFN_COINITIALIZE		"CoInitialize"
#define SZFN_COCREATEINSTANCE	"CoCreateInstance"
#define SZFN_COUNINITIALIZE		"CoUninitialize"
#define SZFN_CODISCONNECTOBJECT	"CoDisconnectObject"
#define SZFN_COTASKMEMALLOC		"CoTaskMemAlloc"
#define SZFN_COTASKMEMREALLOC	"CoTaskMemRealloc"
#define SZFN_COTASKMEMFREE		"CoTaskMemFree"


//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrUIM::CreateInstance
// Type		:	HRESULT
// Purpose	:	Create New CImePadSvrUIM instance.
// Args		:	
//			:	LPCImePadSvrUIM *	pp	
//			:	LPARAM	lReserved1	//not used. must be ZERO.
//			:	LPARAM	lReserved2	//not used. must be ZERO.
// Return	:	
// DATE		:	Tue Mar 28 00:31:26 2000
// Histroy	:	
//////////////////////////////////////////////////////////////////
HRESULT
CImePadSvrUIM::CreateInstance(HINSTANCE			hInst,
							  LPCImePadSvrUIM	*pp,
							  LPARAM			lReserved1,
							  LPARAM			lReserved2)
{
	if(!pp) {
		return S_FALSE;
	}
	LPCImePadSvrUIM lpCImePadSvrUIM;
	lpCImePadSvrUIM = NULL;
	lpCImePadSvrUIM = new CImePadSvrUIM_Sharemem(hInst);
	if(lpCImePadSvrUIM) {
		if(!lpCImePadSvrUIM->IsAvailable()) {
			delete lpCImePadSvrUIM;
			lpCImePadSvrUIM = NULL;
			*pp = NULL;
			return S_FALSE;
		}
		*pp = lpCImePadSvrUIM;
		return S_OK;
	}
	return S_FALSE;

	UNREFERENCED_PARAMETER(lReserved1);
	UNREFERENCED_PARAMETER(lReserved2);
}

HRESULT
CImePadSvrUIM::DeleteInstance(LPCImePadSvrUIM	lpCImePadSvrUIM,
							  LPARAM			lReserved)
{
	lReserved; // no ref
	DBG(("CImePadSvrUIM::DestroyCImePadSvrUIM START\n"));
	if(!lpCImePadSvrUIM) {
		return S_FALSE;
	}

	lpCImePadSvrUIM->Terminate(NULL);
	delete lpCImePadSvrUIM;

	DBG(("CImePadSvrUIM::DestroyCImePadSvrUIM END\n"));
	return S_OK;
}


//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrUIM::CImePadSvrUIM
// Type		:	
// Purpose	:	Constructor of CImePadSvrUIM
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:37:18 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvrUIM::CImePadSvrUIM(HINSTANCE hInst)
{
	DBG(("CImePadSvrUIM::CImePadSvrUIM START\n"));
	m_fCoInitSuccess		= FALSE;	//Flag for CoInitialize() successed or not. 
	m_fOLELoaded			= FALSE;	//OLE32.DLL is loaded by Application or explicitly loaded.
	m_hModOLE				= FALSE;	//OLE32.DLL module handle.
	m_fnCoInitialize		= NULL;		//CoInitialize()		function pointer.
	m_fnCoCreateInstance	= NULL;		//CoCreateInstance()	function pointer.
	m_fnCoUninitialize		= NULL;		//CoUninitialize()		function pointer.
	m_fnCoDisconnectObject	= NULL;		//CoDisconnectObject()	function pointer.
	m_fnCoTaskMemAlloc		= NULL;		//CoTaskMemAlloc()		function pointer.
	m_fnCoTaskMemRealloc	= NULL;		//CoTaskMemRealloc()	function pointer.
	m_fnCoTaskMemFree		= NULL;		//CoTaskMemFree()		function pointer.
	m_hModClient			= (HMODULE)hInst;	
	DBG(("CImePadSvrUIM::CImePadSvrUIM END\n"));
}

CImePadSvrUIM::~CImePadSvrUIM()
{
	DBG(("CImePadSvrUIM::~CImePadSvrUIM START\n"));
	m_fCoInitSuccess		= FALSE;	//Flag for CoInitialize() successed or not. 
	m_fOLELoaded			= FALSE;	//OLE32.DLL is loaded by Application or explicitly loaded.
	m_hModOLE				= FALSE;	//OLE32.DLL module handle.
	m_fnCoInitialize		= NULL;		//CoInitialize()		function pointer.
	m_fnCoCreateInstance	= NULL;		//CoCreateInstance()	function pointer.
	m_fnCoUninitialize		= NULL;		//CoUninitialize()		function pointer.
	m_fnCoDisconnectObject	= NULL;		//CoDisconnectObject()	function pointer.
	m_fnCoTaskMemAlloc		= NULL;		//CoTaskMemAlloc()		function pointer.
	m_fnCoTaskMemRealloc	= NULL;		//CoTaskMemRealloc()	function pointer.
	m_fnCoTaskMemFree		= NULL;		//CoTaskMemFree()		function pointer.
	m_hModClient			= NULL;
	DBG(("CImePadSvrUIM::~CImePadSvrUIM END\n"));
}

BOOL
CImePadSvrUIM::InitOleAPI(VOID)
{
	DBG(("CImePadSvrUIM::InitOleAPI START\n"));
	if(!m_hModOLE) {
#ifndef UNDER_CE // For GetModuleHandleW
		m_hModOLE = ::GetModuleHandle(SZMOD_OLE32DLL);
#else // UNDER_CE
		m_hModOLE = ::GetModuleHandleW(WSZMOD_OLE32DLL);
#endif // UNDER_CE
		if(m_hModOLE) {
			DBG(("-->%s is Loaded by Application\n", SZMOD_OLE32DLL));
			m_fOLELoaded = FALSE;
		}
		else {
			m_hModOLE = ::LoadLibrary(SZMOD_OLE32DLL);
			if(m_hModOLE) {
				DBG(("--> %s has Loaded Explicitly", SZMOD_OLE32DLL)); 
				m_fOLELoaded = TRUE;
			}
			else {
				return FALSE;
			}
		}
	}

	m_fnCoInitialize	  = (FN_COINITIALIZE)		GetProcAddress(m_hModOLE, SZFN_COINITIALIZE);
	m_fnCoCreateInstance  = (FN_COCREATEINSTANCE)	::GetProcAddress(m_hModOLE, SZFN_COCREATEINSTANCE);
	m_fnCoUninitialize	  = (FN_COUNINITIALIZE)		::GetProcAddress(m_hModOLE, SZFN_COUNINITIALIZE);
	m_fnCoDisconnectObject= (FN_CODISCONNECTOBJECT)	::GetProcAddress(m_hModOLE, SZFN_CODISCONNECTOBJECT);
	m_fnCoTaskMemAlloc	  = (FN_COTASKMEMALLOC)		::GetProcAddress(m_hModOLE, SZFN_COTASKMEMALLOC);
	m_fnCoTaskMemRealloc  = (FN_COTASKMEMREALLOC)	::GetProcAddress(m_hModOLE, SZFN_COTASKMEMREALLOC);
	m_fnCoTaskMemFree	  = (FN_COTASKMEMFREE)		::GetProcAddress(m_hModOLE, SZFN_COTASKMEMFREE);

	if(!m_fnCoInitialize		||
	   !m_fnCoCreateInstance	||
	   !m_fnCoUninitialize		||
	   !m_fnCoDisconnectObject	||
	   !m_fnCoTaskMemAlloc		||
	   !m_fnCoTaskMemRealloc	||	
	   !m_fnCoTaskMemFree) {
	   
		DBG(("InitOleAPI Failed: GetProcAddress Error\n"));
		return FALSE;
	}
	DBG(("CImePadSvrUIM::InitOleAPI END\n"));
	return TRUE;
}

BOOL
CImePadSvrUIM::TermOleAPI(VOID)
{
	DBG(("CImePadSvrUIM::TermOleAPI START\n"));
	m_fnCoInitialize		= NULL;
	m_fnCoCreateInstance	= NULL;
	m_fnCoUninitialize		= NULL;
	m_fnCoDisconnectObject	= NULL;
	m_fnCoTaskMemAlloc		= NULL;
	m_fnCoTaskMemRealloc	= NULL; 
	m_fnCoTaskMemFree		= NULL;

	if(!m_hModOLE) {
		DBG(("-->TermOleAPI already Terminated?\n"));
		return TRUE;
	}

	if(m_hModOLE && m_fOLELoaded) {
		DBG(("--> FreeLibrary\n"));
		::FreeLibrary(m_hModOLE);
	}
	m_hModOLE    = NULL;
	m_fOLELoaded = FALSE;
	DBG(("CImePadSvrUIM::TermOleAPI END\n"));
	return TRUE;
}

#if 0
VOID*
CImePadSvrUIM::operator new( size_t size )
{
	LPVOID lp = (LPVOID)MemAlloc(size);
	return lp;
}

VOID
CImePadSvrUIM::operator delete( VOID *lp )
{
	if(lp) {
		MemFree(lp);
	}
	return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadsvus.h ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvus.h
// Purpose  :	
// 
// Date     :	Fri Apr 16 14:34:49 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_IMEPAD_SERVER_SHARE_MEM_FOR_UIM_H__
#define __C_IMEPAD_SERVER_SHARE_MEM_FOR_UIM_H__
#include "cpadsvu.h"

class CImePadSvrUIM_Sharemem;
typedef CImePadSvrUIM_Sharemem *LPCImePadSvrUIM_Sharemem;

//----------------------------------------------------------------
//Async notify data.
//----------------------------------------------------------------
typedef struct tagIMEPADNOTIFYDATA {
	DWORD	dwCharID;
	DWORD	dwSelIndex;
	LPWSTR	lpwstrCreated1;
	LPWSTR	lpwstrCreated2;
}IMEPADNOTIFYDATA, LPIMEPADNOTIFYDATA;

interface IImePadServer;
class CImePadSvrUIM_Sharemem:public CImePadSvrUIM
{
public:
	CImePadSvrUIM_Sharemem(HINSTANCE hInst);
	~CImePadSvrUIM_Sharemem(VOID);
	virtual BOOL		IsAvailable			(VOID);
	virtual BOOL		OnIMEPadClose		(VOID);
	virtual INT			Initialize			(LANGID	imeLangID, DWORD dwImeInputID, LPVOID lpVoid);
	virtual	INT			Terminate			(LPVOID lpVoid);
	virtual INT			ForceDisConnect		(VOID);
	virtual	INT			ShowUI				(BOOL fShow);
	virtual	INT			IsVisible			(BOOL *pfVisible);
	virtual	INT			ActivateApplet		(UINT	activateID,
											 LPARAM	dwActParam,
											 LPWSTR lpwstr1,
											 LPWSTR lpwstr2);
	virtual	INT			Notify				(INT id, WPARAM wParam, LPARAM lParam);
	virtual INT			GetAppletConfigList	(DWORD	dwMask,
											 INT*	pCountApplet,
											 IMEPADAPPLETCONFIG **ppList);
	virtual IUnknown*	SetIUnkIImeIPoint	(IUnknown *pIUnk);
	virtual IUnknown*	SetIUnkIImeCallback	(IUnknown *pIUnk);
	virtual IUnknown*	GetIUnkIImeIPoint	(VOID);
	virtual IUnknown*	GetIUnkIImeCallback	(VOID);
private:
	//----------------------------------------------------------------
	//private methods.
	//----------------------------------------------------------------
	IImePadServer *			CreateObject(VOID);
	static LRESULT CALLBACK ClientWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT MsgTimer   (HWND hwnd, WPARAM wParam, LPARAM lParam);
	HWND	CreateIFHWND	(VOID);
	BOOL	DestroyIFHWND	(BOOL fReserved);
	INT		CLSID2Str		(REFCLSID refclsid, TCHAR *szBuf);
	INT		CLSID2ModuleName(REFCLSID refclsid,
							 BOOL fLocalSvr,
							 TCHAR *szPath,
							 INT cbSize);

	//----------------------------------------------------------------
	//private member
	//----------------------------------------------------------------
	LANGID					m_imeLangID;			//Save Initialized data.
	DWORD					m_dwImeInputID;			//Save Initialized data.
	BOOL					m_fShowReqStatus;		//Save ShowUI()'s bool value.
	BOOL					m_fLastActiveCtx;		//Save IMEPADNOTIFY_ACTIVATECONTEXT
	HWND					m_hwndIF;				//Internal I/F Window handle.
	IUnknown*				m_lpIUnkIImeIPoint;		//IImeIPoint I/F pointer as IUnknown.
	IUnknown*				m_lpIUnkIImeCallback;	//IImeCallback I/F pointer as IUnknown.
	IImePadServer*			m_lpIImePadServer;		//IImePadServer I/F pointer.
	LPCImePadCallbackUIM	m_lpCImePadCallbackUIM;	//CImePadCallback instance pointer.
	LPARAM					m_dwRegAdvise;			//Callbacck interface connect cookie.
	HMODULE					m_hModuleProxyStub;		//ProxyStub dll instance handle.
	DWORD					m_dwTLSIndexForProxyStub;
	IMEPADNOTIFYDATA		m_ntfyDataApplyCand;	//for IMEPADNOTIFY_APPLYCAND	
	IMEPADNOTIFYDATA		m_ntfyDataQueryCand;	//for IMEPADNOTIFY_QUERYCAND
	IMEPADNOTIFYDATA		m_ntfyDataApplyCandEx;	//for IMEPADNOTIFY_APPLYCANDEX
};
#endif //__C_IMEPAD_SERVER_SHARE_MEM_FOR_UIM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\enum.cpp ===
/****************************************************************************
   Enum.cpp : implementation of Busu/Stroke Enumeration functions

   Copyright 2000 Microsoft Corp.

   History:
	  07-FEB-2000 bhshin  created
****************************************************************************/
#include "private.h"
#include "Enum.h"
#include "Lookup.h"
#include "Hanja.h"
#include "..\common\trie.h"

// GetMaxBusu
// 
// get the maximum busu sequence number
//
// Parameters:
//  pLexMap -> (MAPFILE*) ptr to lexicon map struct
//
// Result:
//  (number of busu, -1 if error occurs)
//
// 08FEB2000  bhshin  began
short GetMaxBusu(MAPFILE *pLexMap)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	short cBusu;
		
	// parameter validation
	if (pLexMap == NULL)
		return -1;

	if (pLexMap->pvData == NULL)
		return -1;

	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	// lookup BusuInfo table
	cBusu = *(pLex + pLexHeader->rgnBusuInfo);

	return cBusu;
}

// GetMaxStroke
// 
// get the maximum stroke number
//
// Parameters:
//  pLexMap -> (MAPFILE*) ptr to lexicon map struct
//
// Result:
//  (max stroke number, -1 if error occurs)
//
// 08FEB2000  bhshin  began
short GetMaxStroke(MAPFILE *pLexMap)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	short cStroke, nMaxStroke;
	
	// parameter validation
	if (pLexMap == NULL)
		return -1;

	if (pLexMap->pvData == NULL)
		return -1;

	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	// lookup StrokeHead table
	cStroke = *(pLex + pLexHeader->rgnStrokeHead);

	_STROKE_HEAD *pStrokeHead = (_STROKE_HEAD*)(pLex + pLexHeader->rgnStrokeHead + 1);

	// get the max stroke
	nMaxStroke = pStrokeHead[cStroke-1].bStroke;

	return nMaxStroke;
}

// GetFirstBusuHanja
// 
// get the first hanja of input busu
//
// Parameters:
//  pLexMap -> (MAPFILE*) ptr to lexicon map struct
//  nBusuID -> (short) busu id
//  pwchFirst -> (WCHAR*) output first hanja with input busu ID
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 07FEB2000  bhshin  began
BOOL GetFirstBusuHanja(MAPFILE *pLexMap, short nBusuID, WCHAR *pwchFirst)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	short cBusuID;

	*pwchFirst = NULL;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;

	if (nBusuID <= 0)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	// lookup BusuHead table to get the Busu Code ID
	cBusuID = *(pLex + pLexHeader->rgnBusuHead);
	if (nBusuID >= cBusuID)
		return FALSE;

	_BUSU_HEAD *pBusuHead = (_BUSU_HEAD*)(pLex + pLexHeader->rgnBusuHead + 1);

	*pwchFirst = pBusuHead[nBusuID-1].wchHead;

	return TRUE;
}

// GetNextBusuHanja
// 
// get the next same busu hanja
//
// Parameters:
//  pLexMap  -> (MAPFILE*) ptr to lexicon map struct
//  wchHanja -> (int) current hanja 
//  pwchNext -> (WCHAR*) output next hanja with same busu
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 07FEB2000  bhshin  began
BOOL GetNextBusuHanja(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *pwchNext)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	DWORD dwOffset;
	DWORD dwIndex;

	*pwchNext = NULL;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	dwOffset = pLexHeader->rgnHanja;

	if (fIsExtAHanja(wchHanja))
	{
		dwIndex = (wchHanja - HANJA_EXTA_START);
	}
	else if (fIsCJKHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += (wchHanja - HANJA_CJK_START);
	}
	else if (fIsCompHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += HANJA_CJK_END - HANJA_CJK_START + 1;
		dwIndex += (wchHanja - HANJA_COMP_START);
	}
	else
	{
		// unknown input
		return FALSE;
	}

	_HANJA_INFO *pHanjaInfo = (_HANJA_INFO*)(pLex + dwOffset);

	*pwchNext = pHanjaInfo[dwIndex].wchNextBusu;

	return TRUE;
}

// GetFirstStrokeHanja
// 
// get the first hanja of input stroke
//
// Parameters:
//  pLexMap   -> (MAPFILE*) ptr to lexicon map struct
//  nStroke   -> (int) stroke number
//  pwchFirst -> (WCHAR*) output first hanja with input stroke
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 07FEB2000  bhshin  began
BOOL GetFirstStrokeHanja(MAPFILE *pLexMap, short nStroke, WCHAR *pwchFirst)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	short cStroke, nMaxStroke;
	
	*pwchFirst = NULL;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;

	if (nStroke < 0)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	// lookup StrokeHead table
	cStroke = *(pLex + pLexHeader->rgnStrokeHead);

	_STROKE_HEAD *pStrokeHead = (_STROKE_HEAD*)(pLex + pLexHeader->rgnStrokeHead + 1);

	// check max stroke
	nMaxStroke = pStrokeHead[cStroke-1].bStroke;
	if (nStroke > nMaxStroke)
		return FALSE;

	for (int i = 0; i < cStroke; i++)
	{
		if (pStrokeHead[i].bStroke == nStroke)
			break;
	}

	if (i == cStroke)
	{
		// not found
		*pwchFirst = NULL; 
		return FALSE;
	}

	*pwchFirst = pStrokeHead[i].wchHead;

	return TRUE;
}

// GetNextStrokeHanja
// 
// get the next same stroke hanja
//
// Parameters:
//  pLexMap -> (MAPFILE*) ptr to lexicon map struct
//  wchHanja -> (int) current hanja 
//  pwchNext -> (WCHAR*) output next hanja with same stroke
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 07FEB2000  bhshin  began
BOOL GetNextStrokeHanja(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *pwchNext)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	DWORD dwOffset;
	DWORD dwIndex;

	*pwchNext = NULL;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	dwOffset = pLexHeader->rgnHanja;

	if (fIsExtAHanja(wchHanja))
	{
		dwIndex = (wchHanja - HANJA_EXTA_START);
	}
	else if (fIsCJKHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += (wchHanja - HANJA_CJK_START);
	}
	else if (fIsCompHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += HANJA_CJK_END - HANJA_CJK_START + 1;
		dwIndex += (wchHanja - HANJA_COMP_START);
	}
	else
	{
		// unknown input
		return FALSE;
	}

	_HANJA_INFO *pHanjaInfo = (_HANJA_INFO*)(pLex + dwOffset);

	*pwchNext = pHanjaInfo[dwIndex].wchNextStroke;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadsvus.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvrs.cpp
// Purpose  :	CImePadServerUIM for Shared Memory version.
// 
// 
// Date     :	Fri Apr 16 15:39:33 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#include <windows.h>
#include "imepadsv.h"
#include "cpadsvus.h"
#include "cpadcbu.h"
#include "cpaddbg.h"
#include "iimecb.h"
#include "ipoint1.h"

//----------------------------------------------------------------
//misc definition
//----------------------------------------------------------------
#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)


#define SZ_IMEPADIFCLASS			TEXT("msimepad8UIMIFClass")
//----------------------------------------------------------------
//TIMER id definition
//----------------------------------------------------------------
#define TIMERID_NOTIFY_ACTIVATECONTEXT	0x0010
#define TIMERID_NOTIFY_APPLYCANDIDATE	0x0011
#define TIMERID_NOTIFY_QUERYCANDIDATE	0x0012
#define TIMERID_NOTIFY_APPLYCANDIDATEEX	0x0013
#define TIMERELAPS_ACTIVATE				200		//milisec
#define TIMERELAPS_INACTIVATE			100
#define TIMERELAPS_NOTIFY				200

inline LPVOID
WinSetUserPtr(HWND hwnd, LPVOID lpVoid)
{
#ifdef _WIN64	
	return (LPVOID)SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpVoid);
#else
	return (LPVOID)SetWindowLong(hwnd, GWL_USERDATA, (LONG)lpVoid);
#endif
}

inline LPVOID
WinGetUserPtr(HWND hwnd)
{
#ifdef _WIN64	
	return (LPVOID)GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	return (LPVOID)GetWindowLong(hwnd, GWL_USERDATA);
#endif
}

static LPWSTR
StrdupW(LPWSTR lpwstr)
{
	LPWSTR lpwstrRet;
	if(!lpwstr) {
		return NULL;
	}
	INT len = lstrlenW(lpwstr);
	if(len == 0) {
		return NULL;
	}
	lpwstrRet = (LPWSTR)MemAlloc((len+1) * sizeof(WCHAR));
	if(!lpwstrRet) {
		return NULL;
	}
	CopyMemory(lpwstrRet, lpwstr, sizeof(WCHAR)*len);
	lpwstrRet[len] = (WCHAR)0x0000;
	return lpwstrRet;
} 

//----------------------------------------------------------------
//
//public method decalre
//
//----------------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrSharemem::CImePadSvrSharemem
// Type		:	None
// Purpose	:	Constructor of CImePadSvrSharemem class
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:04:01 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvrUIM_Sharemem::CImePadSvrUIM_Sharemem(HINSTANCE hInst):CImePadSvrUIM(hInst)
{
	DBG(("CImePadSvrUIM_Sharemem::CImePadSvrUIM_Sharemem() constructor START\n"));
	m_imeLangID				= 0;		//Save Initialized data.
	m_dwImeInputID			= 0;		//Save Initialized data.
	m_fShowReqStatus		= FALSE;	//Save ShowUI()'s bool value.
	m_fLastActiveCtx		= FALSE;	//Save IMEPADNOTIFY_ACTIVATECONTEXT
	m_hwndIF				= NULL;		//Internal I/F Window handle.
	m_lpIUnkIImeIPoint		= NULL;		//IImeIPoint I/F pointer as IUnknown.
	m_lpIUnkIImeCallback	= NULL;		//IImeCallback I/F pointer as IUnknown.
	m_lpCImePadCallbackUIM	= NULL;		//CImePadCallbackUIM instance pointer.
	m_lpIImePadServer		= NULL;		//IImePadServer I/F pointer.
	m_dwRegAdvise			= 0;
	m_hModuleProxyStub		= NULL;

	//Initialize Candidate data
	ZeroMemory(&m_ntfyDataApplyCand,	sizeof(m_ntfyDataApplyCand));
	ZeroMemory(&m_ntfyDataQueryCand,	sizeof(m_ntfyDataQueryCand));
	ZeroMemory(&m_ntfyDataApplyCandEx,	sizeof(m_ntfyDataApplyCandEx));

	DBG(("CImePadSvrUIM_Sharemem::CImePadSvrUIM_Sharemem() constructor END\n"));
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrUIM_Sharemem::~CImePadSvrUIM_Sharemem
// Type		:	INT
// Purpose	:	Destructor of CImePadSvrUIM_Sharemem Class.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:04:29 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvrUIM_Sharemem::~CImePadSvrUIM_Sharemem(VOID)
{
	DBG(("CImePadSvrUIM_Sharemem::CImePadSvrUIM_Sharemem() Destructor START\n"));
	this->DestroyIFHWND(TRUE);
	m_imeLangID				= 0;		//Save Initialized data.
	m_dwImeInputID			= 0;		//Save Initialized data.
	m_fShowReqStatus		= FALSE;	//Save ShowUI()'s bool value.
	m_fLastActiveCtx		= FALSE;	//Save IMEPADNOTIFY_ACTIVATECONTEXT
	m_hwndIF				= NULL;		//Internal I/F Window handle.
	m_lpIUnkIImeIPoint		= NULL;		//IImeIPoint I/F pointer as IUnknown.
	m_lpIUnkIImeCallback	= NULL;		//IImeCallback I/F pointer as IUnknown.
	m_lpIImePadServer		= NULL;		//IImePadServer I/F pointer.

	//990813:ToshiaK. Memory leak.
	if(m_lpCImePadCallbackUIM) {
		delete m_lpCImePadCallbackUIM;
		m_lpCImePadCallbackUIM = NULL;
	}

	if(m_hModuleProxyStub) {
		::FreeLibrary(m_hModuleProxyStub);
		m_hModuleProxyStub = 0;
	}
	DBG(("CImePadSvrUIM_Sharemem::CImePadSvrUIM_Sharemem() Destructor END\n"));
}

BOOL
CImePadSvrUIM_Sharemem::IsAvailable(VOID)
{
	LPTSTR lpPath = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
	if(!lpPath) {
		DBG(("-->Outof Memory ??\n"));
		return FALSE;
	}

	if(0 ==  this->CLSID2ModuleName(IID_IImePadServerSHM,
									FALSE,
									lpPath,
									sizeof(TCHAR)*MAX_PATH)) {
		MemFree(lpPath);
		return TRUE;
	}
	MemFree(lpPath);
	return FALSE;

}

BOOL
CImePadSvrUIM_Sharemem::OnIMEPadClose(VOID)
{
	m_fShowReqStatus = FALSE;
	return 0;
}

INT
CImePadSvrUIM_Sharemem::Initialize(LANGID	imeLangID,
							   DWORD	dwImeInputID,
							   LPVOID	lpVoid)
{
	DBG(("CImePadSvrUIM_Sharemem::Initialize() START\n"));
	DBG(("--> imeLangID   [0x%08x]\n", imeLangID));
	DBG(("--> dwImeInputID[0x%08x]\n", dwImeInputID));
	if(m_lpIImePadServer) {
		DBG(("-->Already Initialized\n"));
		return 0;
	}

	HRESULT hr;
	
	this->CreateIFHWND();	//Create internal Interface Window.
	m_imeLangID		= imeLangID;
	m_dwImeInputID	= dwImeInputID;
	if(!m_lpCImePadCallbackUIM) {
		m_lpCImePadCallbackUIM = new CImePadCallbackUIM(m_hwndIF, this);
	}
	this->InitOleAPI();

	m_lpIImePadServer = (IImePadServer *)this->CreateObject();
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->Initialize(::GetCurrentProcessId(),
								  ::GetCurrentThreadId(),
								  (DWORD)imeLangID,
								  (DWORD)dwImeInputID,
								  TRUE,					//fUIM,
								  m_lpCImePadCallbackUIM,
								  NULL,
								  0,
								  0);
	DBG(("CImePadSvrUIM_Sharemem::Initialize() END\n"));
	return 0;
	Unref(lpVoid);
	Unref(hr);
}

INT
CImePadSvrUIM_Sharemem::Terminate(LPVOID lpVoid)
{
	DBG(("CImePadSvrUIM_Sharemem::::Terminate() START \n"));
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->Terminate(0, 0);
	m_lpIImePadServer = NULL;
	//990813:ToshiaK memory leak;
	if(m_lpCImePadCallbackUIM) {
		delete m_lpCImePadCallbackUIM;
		m_lpCImePadCallbackUIM = NULL;
	}
	DBG(("CImePadSvrUIM_Sharemem::Terminate() End\n"));
	return 0;
	Unref(lpVoid);
}

INT
CImePadSvrUIM_Sharemem::ForceDisConnect(VOID)
{
	DBG(("CImePadSvrUIM_Sharemem::ForceDisConnect START\n"));
	if(m_lpIImePadServer) {
		m_lpIImePadServer = NULL;
	}
	DBG(("CImePadSvrUIM_Sharemem::ForceDisConnect END\n"));
	return 0;
}


INT
CImePadSvrUIM_Sharemem::ShowUI(BOOL fShow)
{
	DBG(("CImePadSvrUIM_Sharemem::ShowUI() START fShow [%d]\n"));
	m_fShowReqStatus = fShow;
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->ShowUI(fShow);
	DBG(("CImePadSvrUIM_Sharemem::ShowUI() END\n"));
	return 0;
}

INT
CImePadSvrUIM_Sharemem::IsVisible(BOOL *pfVisible)
{
	if(pfVisible) {
		*pfVisible = m_fShowReqStatus;
	}
	return 0;
}

INT
CImePadSvrUIM_Sharemem::ActivateApplet(UINT activateID,
									   LPARAM dwActivateParam,
									   LPWSTR lpwstr1,
									   LPWSTR lpwstr2)
{
	DBG(("CImePadSvrUIM_Sharemem::ActivateApplet START\n"));
	DBG(("-->activateID      [0x%08x][%s]\n",
		 activateID,
		 activateID == IMEPADACTID_ACTIVATEBYCATID ? "IMEPADACTID_ACTIVATEBYCATID" :
		 activateID == IMEPADACTID_ACTIVATEBYIID   ? "IMEPADACTID_ACTIVATEBYIID" :
		 activateID == IMEPADACTID_ACTIVATEBYNAME  ? "IMEPADACTID_ACTIVATEBYNAME" : 
		 "Unknown"));
	DBG(("-->dwActivateParam [0x%08x]\n", dwActivateParam));
	DBG(("-->lpwstr1         [0x%08x]\n", lpwstr1));
	DBG(("-->lpwstr2         [0x%08x]\n", lpwstr2));

	if(!m_lpIImePadServer) {
		DBG(("-->m_lpIImePadServer is NULL\n"));
		DBG(("CImePadSvrUIM_Sharemem::ActivateApplet END\n"));
		return -1;
	}
	m_lpIImePadServer->ActivateApplet(activateID,
									  dwActivateParam,
									  lpwstr1,
									  lpwstr2);
	DBG(("CImePadSvrUIM_Sharemem::ActivateApplet END\n"));
	return 0;
	Unref(activateID);
	Unref(dwActivateParam);
	Unref(lpwstr1);
	Unref(lpwstr2);
}

INT
CImePadSvrUIM_Sharemem::Notify(INT id, WPARAM wParam, LPARAM lParam)
{
	HRESULT hr;
	switch(id) {
	case IMEPADNOTIFY_ACTIVATECONTEXT:
		DBG(("CImePadSvrUIM_Sharemem::Notify: ActivateContext\n"));
		//990608:KOTAE #1121. if ImePad is not shown in this application,
		//Do not send IMEPADNOTIFY_ACTIVATECONTEXT
		if(!m_fShowReqStatus) {
			return 0;
		}
		m_fLastActiveCtx = (BOOL)wParam;
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_ACTIVATECONTEXT);
		if(m_fLastActiveCtx) {
			::SetTimer(m_hwndIF,
					   TIMERID_NOTIFY_ACTIVATECONTEXT,
					   TIMERELAPS_ACTIVATE,
					   NULL);
		}
		else {
			::SetTimer(m_hwndIF,
					   TIMERID_NOTIFY_ACTIVATECONTEXT,
					   TIMERELAPS_INACTIVATE,
					   NULL);
		}
		break;
	case IMEPADNOTIFY_APPLYCANDIDATE:
		//----------------------------------------------------------------
		// Notify for Candidate Applied
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: iSelIndex = (INT)lParam;
		//----------------------------------------------------------------
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATE);
		m_ntfyDataApplyCand.dwCharID   = (DWORD)wParam;
		m_ntfyDataApplyCand.dwSelIndex = (DWORD)lParam;
		::SetTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATE, TIMERELAPS_NOTIFY, NULL);

		break;
	case IMEPADNOTIFY_QUERYCANDIDATE:
		//----------------------------------------------------------------
		// Notify for Querying Candidate
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: 0. not used.
		//----------------------------------------------------------------
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_QUERYCANDIDATE);
		m_ntfyDataQueryCand.dwCharID = (DWORD)wParam;
		::SetTimer(m_hwndIF, TIMERID_NOTIFY_QUERYCANDIDATE, TIMERELAPS_NOTIFY, NULL);
		break;
	case IMEPADNOTIFY_APPLYCANDIDATE_EX:
		//----------------------------------------------------------------
		// Notify for Candidate Applied
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: lpApplyCandEx = (LPIMEPADAPPLYCANDEX)lParam;
		//----------------------------------------------------------------
		{
			::KillTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATEEX);
			m_ntfyDataApplyCandEx.dwCharID = (DWORD)wParam;
			LPIMEPADAPPLYCANDINFO lpApplyCandInfo = (LPIMEPADAPPLYCANDINFO)lParam;

			if(m_ntfyDataApplyCandEx.lpwstrCreated1) {
				MemFree(m_ntfyDataApplyCandEx.lpwstrCreated1);
			}
			if(m_ntfyDataApplyCandEx.lpwstrCreated2) {
				MemFree(m_ntfyDataApplyCandEx.lpwstrCreated2);
			}
			m_ntfyDataApplyCandEx.lpwstrCreated1 = NULL;
			m_ntfyDataApplyCandEx.lpwstrCreated2 = NULL;
			
			if(lpApplyCandInfo) {
				if(lpApplyCandInfo->lpwstrDisplay) {
					m_ntfyDataApplyCandEx.lpwstrCreated1 = StrdupW(lpApplyCandInfo->lpwstrDisplay);
				}
				if(lpApplyCandInfo->lpwstrReading) {
					m_ntfyDataApplyCandEx.lpwstrCreated2 = StrdupW(lpApplyCandInfo->lpwstrReading);
				}
			}
			::SetTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATEEX, TIMERELAPS_NOTIFY, NULL);
		}
		break;
	case IMEPADNOTIFY_MODECHANGED:
		break;
	case IMEPADNOTIFY_STARTCOMPOSITION:
		break;
	case IMEPADNOTIFY_COMPOSITION:
		break;
	case IMEPADNOTIFY_ENDCOMPOSITION:
		break;
	case IMEPADNOTIFY_OPENCANDIDATE:
		break;
	case IMEPADNOTIFY_CLOSECANDIDATE:
		break;
	default:
		break;
	}
	return 0;
	Unref(hr);
	Unref(wParam);
	Unref(lParam);
}

INT
CImePadSvrUIM_Sharemem::GetAppletConfigList(DWORD dwMask,
										INT *pCountApplet,
										IMEPADAPPLETCONFIG **ppList)
{
	DBG(("CImePadSvrUIM_Sharemem::GetAppletConfigList START\n"));
	if(!m_lpIImePadServer) {
		DBG(("-->m_lpIImePadServer is NULL\n"));
		return -1;
	}
	HRESULT hr;
	hr = m_lpIImePadServer->GetAppletConfigList(dwMask,
												(UINT *)pCountApplet,
												ppList);
	DBG(("CImePadSvrUIM_Sharemem::GetAppletConfigList END\n"));
	return hr;
}

IUnknown *
CImePadSvrUIM_Sharemem::SetIUnkIImeIPoint(IUnknown *pIUnkIImeIPoint)
{
	return m_lpIUnkIImeIPoint = pIUnkIImeIPoint;
}

IUnknown *
CImePadSvrUIM_Sharemem::SetIUnkIImeCallback(IUnknown *pIUnkIImeCallback)
{
	return m_lpIUnkIImeCallback = pIUnkIImeCallback;
}

IUnknown*
CImePadSvrUIM_Sharemem::GetIUnkIImeIPoint(VOID)
{
	return m_lpIUnkIImeIPoint;
}

IUnknown*
CImePadSvrUIM_Sharemem::GetIUnkIImeCallback(VOID)
{
	return m_lpIUnkIImeCallback;
}


//----------------------------------------------------------------
//
//private static method
//
//----------------------------------------------------------------

IImePadServer*
CImePadSvrUIM_Sharemem::CreateObject(VOID)
{
	DBG(("CImePadSvrUIM_Sharemem::CreateObject START\n"));
	typedef LPVOID (WINAPI * LPFN_CREATEOBJECT2)(DWORD dwIntanceID, DWORD *pdwTLS);

	LPTSTR lpPath = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
	if(!lpPath) {
		DBG(("-->Outof Memory ??\n"));
		return NULL;
	}

	if(0 !=  this->CLSID2ModuleName(IID_IImePadServerSHM,
									FALSE,
									lpPath,
									sizeof(TCHAR)*MAX_PATH)) {
		DBG(("-->Cannot found proxy\n"));
		goto LError;
	}
	if(!m_hModuleProxyStub) {
		m_hModuleProxyStub= ::LoadLibrary(lpPath);
	}
	DBG(("-->lpPath [%s]\n", lpPath));

	if(!m_hModuleProxyStub) {
		DBG(("CImePadSvrUIM_Sharemem::CreateObject START\n"));
		goto LError;
	}

	LPFN_CREATEOBJECT2 lpfn;
	lpfn = (LPFN_CREATEOBJECT2)::GetProcAddress(m_hModuleProxyStub, "CreateObject2");
	if(!lpfn) {
		DBG(("-->GetProcAddress Error \n"));
		goto LError;
	}
	m_lpIImePadServer = (IImePadServer *)(*lpfn)(0, NULL);
	DBG(("CImePadSvrUIM_Sharemem::CreateObject m_lpIImePadServer[0x%08x]\n", m_lpIImePadServer));
	return m_lpIImePadServer;

 LError:
	if(lpPath) {
		MemFree(lpPath);
	}
	DBG(("CImePadSvrUIM_Sharemem::CreateObject Error END\n"));
	return NULL;
} 

LRESULT CALLBACK
CImePadSvrUIM_Sharemem::ClientWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPCImePadSvrUIM_Sharemem lpCImePadSvr = NULL;
	switch(uMsg) {
#ifdef UNDER_CE
	case WM_CREATE:
		lpCImePadSvr = (LPCImePadSvrUIM_Sharemem)((LPCREATESTRUCT)lParam)->lpCreateParams;
		WinSetUserPtr(hwnd, (LPVOID)lpCImePadSvr);
		if(lpCImePadSvr) {
			return lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	case WM_DESTROY:
		lpCImePadSvr = (LPCImePadSvrUIM_Sharemem)WinGetUserPtr(hwnd);
		if(lpCImePadSvr) {
			lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		WinSetUserPtr(hwnd, (LPVOID)NULL);
		break;
#else //!UNDER_CE
	case WM_NCCREATE:
		lpCImePadSvr = (LPCImePadSvrUIM_Sharemem)((LPCREATESTRUCT)lParam)->lpCreateParams;
		WinSetUserPtr(hwnd, (LPVOID)lpCImePadSvr);
		break;
	case WM_NCDESTROY:
		WinSetUserPtr(hwnd, (LPVOID)NULL);
		break;
#endif //UNDER_CE
	default:
		lpCImePadSvr = (LPCImePadSvrUIM_Sharemem)WinGetUserPtr(hwnd);
		if(lpCImePadSvr) {
			return lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT
CImePadSvrUIM_Sharemem::RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg) {
	case WM_CREATE:
		DBG(("CImePadSvrUIM_Sharemem::WM_CREATE\n"));
		return 1;
	case WM_TIMER:
		return MsgTimer(hwnd, wParam, lParam);
	case WM_USER_UPDATECONTEXT:
		{
			IImeIPoint1 *lpIImeIPoint = NULL;
			if(!m_lpIUnkIImeIPoint) {
				DBG(("--> m_lpIUnkIImeIPoint is NULL\n"));
				return E_FAIL;
			}
			if(IsBadVtblUIM((IUnkDummy *)m_lpIUnkIImeIPoint)) {
				return E_FAIL;
			}

			HRESULT hr = m_lpIUnkIImeIPoint->QueryInterface(IID_IImeIPoint1,
															(VOID **)&lpIImeIPoint);
			if(hr != S_OK) {
				DBG(("QuertyInterface Failed\n"));
				return E_FAIL;
			}
			if(!lpIImeIPoint) {
				DBG(("lpIImeIPoint is NULL\n"));
				return 0;
			}
			//Check current IImeIPoint is same with lParam's IImeIPoint.
			//990715:Fixed KOTAE #1563. 
			//In 16bit application wParam's HIWORD is always 0x0000 !!!!!
			//So, Use LParam.
			if((IImeIPoint1 *)lParam == lpIImeIPoint) {
				DBG(("Call UpdateContext\n"));
				lpIImeIPoint->UpdateContext(TRUE);
			}
			else {
				DBG(("lpIImeIPoint is different lParam[0x%08x]\n", lParam));
			}
			lpIImeIPoint->Release();
		}
		break;
	default:
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT
CImePadSvrUIM_Sharemem::MsgTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	HRESULT hr;
	switch(wParam) {
	case TIMERID_NOTIFY_ACTIVATECONTEXT:
		::KillTimer(hwnd, wParam);
		if(!m_lpIImePadServer) {
			return -1;
		}
		m_lpIImePadServer->Notify(IMEPADNOTIFY_ACTIVATECONTEXT,
								  (WPARAM)m_fLastActiveCtx,
								  (LPARAM)0);
		break;
	case TIMERID_NOTIFY_APPLYCANDIDATE:
		::KillTimer(hwnd, wParam);
		if(!m_lpIImePadServer) {
			return -1;
		}
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_APPLYCANDIDATE,
										  m_ntfyDataApplyCand.dwCharID,
										  0,
										  0,
										  0);
		m_ntfyDataApplyCand.dwCharID = 0;
		break;
	case TIMERID_NOTIFY_QUERYCANDIDATE:
		::KillTimer(hwnd, wParam);
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_QUERYCANDIDATE,
										  m_ntfyDataQueryCand.dwCharID,
										  m_ntfyDataQueryCand.dwSelIndex,
										  0,
										  0);
		m_ntfyDataQueryCand.dwCharID   = 0;
		m_ntfyDataQueryCand.dwSelIndex = 0;
		break;
	case TIMERID_NOTIFY_APPLYCANDIDATEEX:
		::KillTimer(hwnd, wParam);
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_APPLYCANDIDATE_EX,
										  m_ntfyDataApplyCandEx.dwCharID,
										  0,
										  m_ntfyDataApplyCandEx.lpwstrCreated1,
										  m_ntfyDataApplyCandEx.lpwstrCreated2);
		if(m_ntfyDataApplyCandEx.lpwstrCreated1) {
			MemFree(m_ntfyDataApplyCandEx.lpwstrCreated1);
		}
		if(m_ntfyDataApplyCandEx.lpwstrCreated2) {
			MemFree(m_ntfyDataApplyCandEx.lpwstrCreated2);
		}
		m_ntfyDataApplyCandEx.lpwstrCreated1 = NULL;
		m_ntfyDataApplyCandEx.lpwstrCreated2 = NULL;

		break;
	default:
		::KillTimer(hwnd, wParam);
		break;
	}
	return 0;
	Unref(hr);
	Unref(hwnd);
	Unref(wParam);
	Unref(lParam);
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrUIM_Sharemem::CreateIFHWND
// Type		:	HWND
// Purpose	:	Create interface size 0 window.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:01:19 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
HWND
CImePadSvrUIM_Sharemem::CreateIFHWND(VOID)
{
	DBG(("CImePadSvrUIM_Sharemem::CreateIFHWND START\n"));
	if(m_hwndIF && ::IsWindow(m_hwndIF)) {
		return m_hwndIF;
	}
	ATOM atom;
	HWND hwnd;

#ifndef UNDER_CE // No Ex
	WNDCLASSEX wc;
#else // UNDER_CE
	WNDCLASS wc;
#endif // UNDER_CE

#ifndef UNDER_CE // No Ex
	wc.cbSize = sizeof(wc);
#endif // UNDER_CE
	wc.style			= 0;
	wc.lpfnWndProc		= (WNDPROC)CImePadSvrUIM_Sharemem::ClientWndProc;
	wc.cbClsExtra		= 0;
	wc.cbWndExtra		= 0; 
	wc.hInstance		= m_hModClient;
	wc.hIcon			= (HICON)NULL;
	wc.hCursor			= (HCURSOR)NULL; 
	wc.hbrBackground	= (HBRUSH)NULL;
	wc.lpszMenuName		= NULL;
	wc.lpszClassName	= SZ_IMEPADIFCLASS;
#ifndef UNDER_CE // No Ex
	wc.hIconSm			= NULL;

	atom = ::RegisterClassEx(&wc);
#else // UNDER_CE
	atom = ::RegisterClass(&wc);
#endif // UNDER_CE
	hwnd = ::CreateWindowEx(0,
							SZ_IMEPADIFCLASS,
							NULL,
							WS_POPUP | WS_DISABLED,
							0,0,0,0,
							NULL,
							NULL,
							m_hModClient,
							(LPVOID)this);
	if(!hwnd) {
		DBG(("CreateWindowEx Error %d\n", GetLastError()));
	}
	m_hwndIF = hwnd;
	DBG(("CImePadSvrUIM_Sharemem::CreateIFHWND END\n"));
	return hwnd;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrUIM_Sharemem::DestroyIFHWND
// Type		:	BOOL
// Purpose	:	Destroy interface window.
// Args		:	
//			:	BOOL	fReserved	
// Return	:	
// DATE		:	Mon May 17 23:02:43 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvrUIM_Sharemem::DestroyIFHWND(BOOL fReserved)
{
	//DBG(("CImePadSvrUIM_Sharemem::DestroyIFHWND() START\n"));
	if(m_hwndIF && ::IsWindow(m_hwndIF)) {
		::DestroyWindow(m_hwndIF);
		m_hwndIF = NULL;
	}
	//Must Unregister class. 
	BOOL fRet = ::UnregisterClass(SZ_IMEPADIFCLASS, m_hModClient);
	if(!fRet) {
		if(::GetLastError() != ERROR_CLASS_DOES_NOT_EXIST) {
			DBG(("UnregisterClass Unknown error [%d]\n", GetLastError()));
		}
	}
	//DBG(("CImePadSvrUIM_Sharemem::DestroyIFHWND() END\n"));
	return TRUE;
	Unref(fReserved);
}

INT
CImePadSvrUIM_Sharemem::CLSID2Str(REFCLSID refclsid, TCHAR *szBuf)
{
	wsprintf(szBuf, TEXT("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), 
			 refclsid.Data1,
			 refclsid.Data2,
			 refclsid.Data3,
			 refclsid.Data4[0],
			 refclsid.Data4[1],
			 refclsid.Data4[2],
			 refclsid.Data4[3],
			 refclsid.Data4[4],
			 refclsid.Data4[5],
			 refclsid.Data4[6],
			 refclsid.Data4[7]);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CLSID2ModuleName
// Type     : INT
// Purpose  : Get module path from CLSID. only gets InprocServer32
//			: Path.
// Args     : 
//          : REFCLSID refclsid 
//			: BOOL fLocalSvr;
//          : TCHAR szPath 
//          : INT cbSize 
// Return   : 
// DATE     : Thu Apr 16 02:48:05 1998
// Author   : 
//////////////////////////////////////////////////////////////////
#define MAX_CLSIDNAME 64
INT
CImePadSvrUIM_Sharemem::CLSID2ModuleName(REFCLSID refclsid, BOOL fLocalSvr, TCHAR *szPath, INT cbSize)
{
	//DBG(("CImePadSvrUIM_Sharemem::CLSID2ModuleName START\n"));
	static TCHAR szCLSID[MAX_CLSIDNAME];
	static TCHAR szServerKey[256];

	CLSID2Str(refclsid, szCLSID);
	DBG(("-->szCLSID [%s]\n", szCLSID));

	if(fLocalSvr) {
		wsprintf(szServerKey, TEXT("CLSID\\%s\\LocalServer32"), szCLSID);
	}
	else {
		wsprintf(szServerKey, TEXT("CLSID\\%s\\InprocServer32"), szCLSID);
	}

	INT ret;
	HKEY hKey;
	ret = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
						 szServerKey,
						 0, 
						 KEY_READ, //ALL_ACCESS,
						 &hKey);
	if(ret != ERROR_SUCCESS) {
		DBG(("-->RegOpenKeyEx Failed\n", ret));
		return ret;
	}
	ULONG size = cbSize;
	ret = ::RegQueryValueEx(hKey,
							NULL,
							NULL,
							NULL,
							(LPBYTE)szPath, &size);
	if(ret != ERROR_SUCCESS) {
		DBG(("-->RegQueryValueEx Failed\n", ret));
		::RegCloseKey(hKey);
		return ret;
	}
	::RegCloseKey(hKey);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\ihanjainfo.cpp ===
// IHanjaInfo.cpp : Implementation of CHanjaInfo
#include "stdafx.h"
#include "HjDict.h"
#include "IHanjaInfo.h"

/////////////////////////////////////////////////////////////////////////////
// CHanjaInfo


STDMETHODIMP CHanjaInfo::get_BusuID(short *pVal)
{
	*pVal = m_nBusuID;

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_Stroke(short *pVal)
{
	*pVal = m_nStroke;

	return S_OK;
}


STDMETHODIMP CHanjaInfo::get_StrokeExcludeBusu(short *pVal)
{
	*pVal = m_nStrokeExcludeBusu;

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_Type(HANJA_TYPE *pVal)
{
	*pVal = m_nType;

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_Meaning(BSTR *pVal)
{
	*pVal = m_bstrMeaning.Copy();

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_Explain(BSTR *pVal)
{
	*pVal = m_bstrExplain.Copy();

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_NextBusu(long *pVal)
{
	*pVal = m_wchNextBusu;

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_NextStroke(long *pVal)
{
	*pVal = m_wchNextStroke;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\enum.h ===
/****************************************************************************
   Enum.h : declaration of Busu/Stroke Enumeration functions

   Copyright 2000 Microsoft Corp.

   History:
	  07-FEB-2000 bhshin  created
****************************************************************************/

#ifndef _ENUM_HEADER
#define _ENUM_HEADER

#include "Lex.h"

short GetMaxBusu(MAPFILE *pLexMap);
short GetMaxStroke(MAPFILE *pLexMap);

BOOL GetFirstBusuHanja(MAPFILE *pLexMap, short nBusuID, WCHAR *pwchFirst);
BOOL GetNextBusuHanja(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *pwchNext);

BOOL GetFirstStrokeHanja(MAPFILE *pLexMap, short nStroke, WCHAR *pwchFirst);
BOOL GetNextStrokeHanja(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *pwchNext);

#endif // #ifndef _ENUM_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\ibusuinfo.h ===
// IBusuInfo.h : Declaration of the CBusuInfo

#ifndef __BUSUINFO_H_
#define __BUSUINFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CBusuInfo
class ATL_NO_VTABLE CBusuInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CBusuInfo, &CLSID_BusuInfo>,
	public IDispatchImpl<IBusuInfo, &IID_IBusuInfo, &LIBID_HJDICTLib>
{
public:
	CBusuInfo()
	{
		m_wchBusu = NULL;
		m_nStroke = 0;
		m_bstrDesc.Empty();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_BUSUINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CBusuInfo)
	COM_INTERFACE_ENTRY(IBusuInfo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Operator
public:
	void Initialize(WCHAR wchBusu, short nStroke, LPCWSTR lpcwszDesc)
	{
		m_wchBusu = wchBusu;
		m_nStroke = nStroke;
		m_bstrDesc = lpcwszDesc;
	}

// IBusuInfo
public:
	STDMETHOD(get_Stroke)(/*[out, retval]*/ short *pVal);
	STDMETHOD(get_BusuDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Busu)(/*[out, retval]*/ long *pVal);

// Data members
protected:
	WCHAR m_wchBusu;
	short m_nStroke;
	CComBSTR m_bstrDesc; 
};

#endif //__BUSUINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\ihanjainfo.h ===
// IHanjaInfo.h : Declaration of the CHanjaInfo

#ifndef __HANJAINFO_H_
#define __HANJAINFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CHanjaInfo
class ATL_NO_VTABLE CHanjaInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CHanjaInfo, &CLSID_HanjaInfo>,
	public IDispatchImpl<IHanjaInfo, &IID_IHanjaInfo, &LIBID_HJDICTLib>
{
public:
	CHanjaInfo()
	{
		m_nBusuID = -1;
		m_nStroke = -1;
		m_nStrokeExcludeBusu = -1;
		m_nType = HANJA_UNKNOWN;
		m_bstrMeaning.Empty();
		m_bstrExplain.Empty();
		m_wchNextBusu = NULL;
		m_wchNextStroke = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_HANJAINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHanjaInfo)
	COM_INTERFACE_ENTRY(IHanjaInfo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Operator
public:
	void Initialize(short BusuID, short Stroke, short StrokeExcludeBusu, short Type,
		            LPCWSTR lpcwszMean, LPCWSTR lpcwszExplain, 
					WCHAR wchNextBusu, WCHAR wchNextStroke)
	{
		m_nBusuID = BusuID;
		m_nStroke = Stroke;
		m_nStrokeExcludeBusu = StrokeExcludeBusu;
		m_nType = (HANJA_TYPE)Type;
		m_bstrMeaning = lpcwszMean;
		m_bstrExplain = lpcwszExplain;
		m_wchNextBusu = wchNextBusu;
		m_wchNextStroke = wchNextStroke;
	}

// IHanjaInfo
public:
	STDMETHOD(get_NextStroke)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_NextBusu)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_Explain)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Meaning)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Type)(/*[out, retval]*/ HANJA_TYPE *pVal);
	STDMETHOD(get_StrokeExcludeBusu)(/*[out, retval]*/ short *pVal);
	STDMETHOD(get_Stroke)(/*[out, retval]*/ short *pVal);
	STDMETHOD(get_BusuID)(/*[out, retval]*/ short *pVal);

// Data members
protected:
	short m_nBusuID;
	short m_nStroke;
	short m_nStrokeExcludeBusu;
	HANJA_TYPE m_nType;
	CComBSTR m_bstrMeaning;
	CComBSTR m_bstrExplain;
	WCHAR m_wchNextBusu;
	WCHAR m_wchNextStroke;
};

#endif //__HANJAINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\ibusuinfo.cpp ===
// IBusuInfo.cpp : Implementation of CBusuInfo
#include "stdafx.h"
#include "HjDict.h"
#include "IBusuInfo.h"

/////////////////////////////////////////////////////////////////////////////
// CBusuInfo

STDMETHODIMP CBusuInfo::get_Busu(long *pVal)
{
	*pVal = (long)m_wchBusu;

	return S_OK;
}

STDMETHODIMP CBusuInfo::get_BusuDesc(BSTR *pVal)
{
	*pVal = m_bstrDesc.Copy();

	return S_OK;
}

STDMETHODIMP CBusuInfo::get_Stroke(short *pVal)
{
	*pVal = m_nStroke;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\hanja.h ===
/****************************************************************************
   Hanja.cpp : declaration of Hanja definition and utility functions

   Copyright 2000 Microsoft Corp.

   History:
	  02-FEB-2000 bhshin  created
****************************************************************************/

#ifndef _HANJA_HEADER
#define _HANJA_HEADER

// CJK Unified Ideograph
#define  HANJA_CJK_START	0x4E00
#define  HANJA_CJK_END		0x9FA5

// CJK Compatibility Ideograph
#define  HANJA_COMP_START	0xF900
#define  HANJA_COMP_END		0xFA2D

// CJK Unified Ideograph Extension A
#define  HANJA_EXTA_START   0x3400
#define  HANJA_EXTA_END		0x4DB5

// Pre-composed HANGUL
#define  HANGUL_PRECOMP_BASE 0xAC00
#define  HANGUL_PRECOMP_MAX  0xD7A3

__inline
BOOL fIsHangulSyllable(WCHAR wch)
{
    return (wch >= HANGUL_PRECOMP_BASE && wch <= HANGUL_PRECOMP_MAX) ? TRUE : FALSE;
}

__inline
BOOL fIsCJKHanja(WCHAR wch)
{
	return (wch >= HANJA_CJK_START && wch <= HANJA_CJK_END) ? TRUE : FALSE;
}

__inline
BOOL fIsCompHanja(WCHAR wch)
{
	return (wch >= HANJA_COMP_START && wch <= HANJA_COMP_END) ? TRUE : FALSE;
}

__inline
BOOL fIsExtAHanja(WCHAR wch)
{
	return (wch >= HANJA_EXTA_START && wch <= HANJA_EXTA_END) ? TRUE : FALSE;
}

__inline
BOOL fIsHanja(WCHAR wch)
{
	return (fIsCJKHanja(wch) || fIsCompHanja(wch) || fIsExtAHanja(wch)) ? TRUE : FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\hjdict.cpp ===
// HjDict.cpp : Implementation of DLL Exports.
//
// History:
//		17-MAY-2000	  bhshin    removed unused method/interface for CICERO
//		02-FEB-2000   bhshin	created


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f HjDictps.mk in the project directory.

#include "private.h"
#include "resource.h"
#include <initguid.h>
#include "HjDict.h"

#include "HjDict_i.c"
#include "IHJDict.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_HJDict, CHJDict)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_HJDICTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\lookup.h ===
/****************************************************************************
   Lookup.h : declarations of various lookup functions

   Copyright 2000 Microsoft Corp.

   History:
   		02-AUG-2000 bhshin  remove unused method for Hand Writing team
   		17-MAY-2000 bhshin  remove unused method for CICERO
		02-FEB-2000 bhshin  created
****************************************************************************/

#ifndef _LOOKUP_H
#define _LOOKUP_H

#include "Lex.h" // MAPFILE

//----------------------------------------------------------------------------
// structures for lookup lexicon
//----------------------------------------------------------------------------

int LookupHanjaIndex(MAPFILE *pLexMap, WCHAR wchHanja);

BOOL LookupHangulOfHanja(MAPFILE *pLexMap, LPCWSTR lpcwszHanja, int cchHanja,
						 LPWSTR wzHangul, int cchHangul);

BOOL LookupMeaning(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *wzMean, int cchMean);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\feime\kor\ime2k\hanjadic\lookup.cpp ===
/****************************************************************************
   Lookup.cpp : implementation of various lookup functions

   Copyright 2000 Microsoft Corp.

   History:
   		02-AUG-2000 bhshin  remove unused method for Hand Writing team
		17-MAY-2000 bhshin  remove unused method for CICERO
		02-FEB-2000 bhshin  created
****************************************************************************/
#include "private.h"
#include "Lookup.h"
#include "Hanja.h"
#include "trie.h"


// LookupHanjaIndex
// 
// get the hanja index with code value
// it's needed for just K0/K1 lex
//
// Parameters:
//  pLexMap      -> (MAPFILE*) ptr to lexicon map struct
//  wchHanja     -> (WCHAR) hanja unicode
//
// Result:
//  (-1 if not found, otherwise return index value)
//
// 02FEB2000  bhshin  began
int LookupHanjaIndex(MAPFILE *pLexMap, WCHAR wchHanja)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	DWORD dwOffset;
	DWORD dwIndex;
	unsigned short *pIndex;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	dwOffset = pLexHeader->rgnHanjaIdx;

	if (fIsExtAHanja(wchHanja))
	{
		dwIndex = (wchHanja - HANJA_EXTA_START);
	}
	else if (fIsCJKHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += (wchHanja - HANJA_CJK_START);
	}
	else if (fIsCompHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += HANJA_CJK_END - HANJA_CJK_START + 1;
		dwIndex += (wchHanja - HANJA_COMP_START);
	}
	else
	{
		// unknown input
		return -1;
	}

	pIndex = (WCHAR*)(pLex + dwOff